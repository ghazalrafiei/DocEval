['text':'*
 *    Copyright (C) 2021-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' Encodes the double with the lowest possible scale index. In worst case we will interpret the','line_number':69,'multiline':False]
['text':' memory as integer which is guaranteed to succeed.','line_number':70,'multiline':False]
['text':' Subtract the last scale that was added in the loop before returning','line_number':77,'multiline':False]
['text':' Checks if it is possible to do delta of ObjectIds','line_number':81,'multiline':False]
['text':' Traverses object and calls 'ElementFunc' on every scalar subfield encountered.','line_number':87,'multiline':False]
['text':' Internal recursion function for traverseLockStep() when we just need to traverse reference','line_number':99,'multiline':False]
['text':' object. Like '_traverse' above but exits when an empty sub object is encountered. Returns 'true'','line_number':100,'multiline':False]
['text':' if empty subobject found.','line_number':101,'multiline':False]
['text':' Helper function for mergeObj() to detect if Object contain subfields of empty Objects','line_number':117,'multiline':False]
['text':' Internal recursion function for traverseLockStep(). See documentation for traverseLockStep.','line_number':122,'multiline':False]
['text':' If 'reference' element is Object then 'obj' must also be Object.','line_number':134,'multiline':False]
['text':' Differences in empty objects are not allowed.','line_number':139,'multiline':False]
['text':' Everything match, recurse deeper.','line_number':144,'multiline':False]
['text':' Assume field name at 'it' is coming later in 'reference'. Traverse as if it is','line_number':150,'multiline':False]
['text':' missing from 'obj'. We don't increment the iterator in this case. If it is a','line_number':151,'multiline':False]
['text':' mismatch we will detect that at end when 'it' is not at 'end'. Nothing can fail','line_number':152,'multiline':False]
['text':' below this so traverse without all the checks. Any empty object detected is an','line_number':153,'multiline':False]
['text':' error.','line_number':154,'multiline':False]
['text':' Going from scalar to object is not allowed, this would compress inefficiently','line_number':162,'multiline':False]
['text':' Non-object, call provided function with the two elements','line_number':167,'multiline':False]
['text':' Extra elements in 'obj' are not allowed. These needs to be merged in to 'reference' to be','line_number':171,'multiline':False]
['text':' able to compress.','line_number':172,'multiline':False]
['text':' Traverses and validates BSONObj's in reference and obj in lock-step. Returns true if the object','line_number':176,'multiline':False]
['text':' hierarchies are compatible for sub-object compression. To be compatible fields in 'obj' must be','line_number':177,'multiline':False]
['text':' in the same order as in 'reference' and sub-objects in 'reference' must be sub-objects in 'obj'.','line_number':178,'multiline':False]
['text':' The only difference between the two objects that is allowed is missing fields in 'obj' compared','line_number':179,'multiline':False]
['text':' to 'reference'. 'ElementFunc' is called for every matching pair of BSONElement. Function','line_number':180,'multiline':False]
['text':' signature should be void(const BSONElement&, const BSONElement&).','line_number':181,'multiline':False]
['text':' Extra elements in 'obj' are not allowed. These needs to be merged in to 'reference' to be','line_number':185,'multiline':False]
['text':' able to compress.','line_number':186,'multiline':False]
['text':' Internal recursion function for mergeObj(). See documentation for mergeObj. Returns true if merge','line_number':190,'multiline':False]
['text':' was successful.','line_number':191,'multiline':False]
['text':' Iterate until we reach end of any of the two objects.','line_number':198,'multiline':False]
['text':' We can merge this sub-obj/array if both sides are Object or both are Array','line_number':205,'multiline':False]
['text':' There may not be a mismatch in empty objects','line_number':209,'multiline':False]
['text':' Recurse deeper','line_number':213,'multiline':False]
['text':' Both or neither elements must be Object to be mergable','line_number':221,'multiline':False]
['text':' If name match and neither is Object we can append from reference and increment','line_number':224,'multiline':False]
['text':' both objects.','line_number':225,'multiline':False]
['text':' Name mismatch, first search in 'obj' if reference element exists later.','line_number':234,'multiline':False]
['text':' Reference element does not exist in 'obj' so add it and continue merging with just','line_number':239,'multiline':False]
['text':' this iterator incremented. Unless it is an empty object or contains an empty object','line_number':240,'multiline':False]
['text':' which is incompatible.','line_number':241,'multiline':False]
['text':' Reference element does exist later in 'obj'. Add element in 'it' if it is the first','line_number':252,'multiline':False]
['text':' time we see it, fail otherwise (incompatible ordering). Unless 'it' is or contains an','line_number':253,'multiline':False]
['text':' empty object which is incompatible.','line_number':254,'multiline':False]
['text':' Add remaining reference elements when we reached end in 'obj'.','line_number':265,'multiline':False]
['text':' We cannot allow empty object/array mismatch','line_number':267,'multiline':False]
['text':' Add remaining 'obj' elements when we reached end in 'reference'.','line_number':277,'multiline':False]
['text':' We cannot allow empty object/array mismatch','line_number':279,'multiline':False]
['text':' Tries to merge in elements from 'obj' into 'reference'. For successful merge the elements that','line_number':293,'multiline':False]
['text':' already exist in 'reference' must be in 'obj' in the same order. The merged object is returned in','line_number':294,'multiline':False]
['text':' case of a successful merge, empty BSONObj is returned for failure. This is quite an expensive','line_number':295,'multiline':False]
['text':' operation as we are merging unsorted objects. Time complexity is O(N^2).','line_number':296,'multiline':False]
['text':' namespace','line_number':307,'multiline':False]
['text':' Flush previous sub-object compression when non-object is appended','line_number':327,'multiline':False]
['text':' First validate that we don't store MinKey or MaxKey anywhere in the Object. If this is the','line_number':348,'multiline':False]
['text':' case, throw exception before we modify any state.','line_number':349,'multiline':False]
['text':' Different types on root is not allowed','line_number':369,'multiline':False]
['text':' We are in DeterminingReference mode, check if this current object is compatible and merge','line_number':377,'multiline':False]
['text':' in any new fields that are discovered.','line_number':378,'multiline':False]
['text':' If merge failed, flush current sub-object compression and start over.','line_number':389,'multiline':False]
['text':' If we only contain empty subobj (no value elements) then append in regular mode','line_number':392,'multiline':False]
['text':' instead of re-starting subobj compression.','line_number':393,'multiline':False]
['text':' If we've buffered twice as many objects as we have sub-elements we will achieve good','line_number':407,'multiline':False]
['text':' compression so use the currently built reference.','line_number':408,'multiline':False]
['text':' Reference already determined for sub-object compression, try to add this new object.','line_number':417,'multiline':False]
['text':' If we were not compatible restart subobj compression unless our object contain no value','line_number':419,'multiline':False]
['text':' fields (just empty subobjects)','line_number':420,'multiline':False]
['text':' If the reference object contain any empty subobjects we need to end interleaved mode as','line_number':437,'multiline':False]
['text':' skipping in all substreams would not be encoded as skipped root object.','line_number':438,'multiline':False]
['text':' Save internal state before finalizing','line_number':456,'multiline':False]
['text':' Finalize binary','line_number':460,'multiline':False]
['text':' Restore previous state.','line_number':464,'multiline':False]
['text':' Does not modify the buffer, just sets the point where future writes should occur.','line_number':466,'multiline':False]
['text':' Write EOO at the end','line_number':484,'multiline':False]
['text':' Store EOO type with empty field name as previous.','line_number':509,'multiline':False]
['text':' If we detect a type change (or this is first value). Flush all pending values in Simple-8b','line_number':525,'multiline':False]
['text':' and write uncompressed literal. Reset all default values.','line_number':526,'multiline':False]
['text':' Store delta in Simple-8b if types match','line_number':535,'multiline':False]
['text':' If previous wasn't encodable we cannot store 0 in Simple8b as that would create','line_number':548,'multiline':False]
['text':' an ambiguity between 0 and repeat of previous','line_number':549,'multiline':False]
['text':' We only do delta encoding of binary if the binary type and size are','line_number':567,'multiline':False]
['text':' exactly the same. To support size difference we'd need to add a count to','line_number':568,'multiline':False]
['text':' be able to reconstruct binaries starting with zero bytes. We don't want','line_number':569,'multiline':False]
['text':' to waste bits for this.','line_number':570,'multiline':False]
['text':' Variable to indicate that it was possible to encode this BSONElement as an integer','line_number':588,'multiline':False]
['text':' for storage inside Simple8b. If encoding is not possible the element is stored as','line_number':589,'multiline':False]
['text':' uncompressed.','line_number':590,'multiline':False]
['text':' Value to store in Simple8b if encoding is possible.','line_number':592,'multiline':False]
['text':' Store uncompressed literal if value is outside of range of encodable values.','line_number':651,'multiline':False]
['text':' Rescale previous known value if this skip caused Simple-8b blocks to be written','line_number':666,'multiline':False]
['text':' Encode last value in the previous block with old and new scale index. We know that scaling','line_number':684,'multiline':False]
['text':' with the old index is possible.','line_number':685,'multiline':False]
['text':' Fail if we could not rescale','line_number':690,'multiline':False]
['text':' Create a new Simple8bBuilder for the rescaled values. If any Simple8b block is finalized when','line_number':695,'multiline':False]
['text':' adding the new values then rescaling is less optimal than flushing with the current scale. So','line_number':696,'multiline':False]
['text':' we just record if this happens in our write callback.','line_number':697,'multiline':False]
['text':' Iterate over our pending values, decode them back into double, rescale and append to our new','line_number':700,'multiline':False]
['text':' Simple8b builder','line_number':701,'multiline':False]
['text':' Apply delta to previous, decode to double and rescale','line_number':708,'multiline':False]
['text':' Fail if we could not rescale','line_number':713,'multiline':False]
['text':' Append the scaled delta','line_number':717,'multiline':False]
['text':' Fail if are out of range for Simple8b or a block was written','line_number':721,'multiline':False]
['text':' Remember previous for next value','line_number':725,'multiline':False]
['text':' Last add our new value','line_number':729,'multiline':False]
['text':' We managed to add all re-scaled values, this will thus compress better. Set write callback to','line_number':735,'multiline':False]
['text':' our buffer writer and return','line_number':736,'multiline':False]
['text':' Scale with lowest possible scale index','line_number':742,'multiline':False]
['text':' New value need higher scale index. We have two choices:','line_number':746,'multiline':False]
['text':' (1) Re-scale pending values to use this larger scale factor','line_number':747,'multiline':False]
['text':' (2) Flush pending and start a new block with this higher scale factor','line_number':748,'multiline':False]
['text':' We try both options and select the one that compresses best','line_number':749,'multiline':False]
['text':' Re-scale possible, use this Simple8b builder','line_number':752,'multiline':False]
['text':' Re-scale not possible, flush and start new block with the higher scale factor','line_number':759,'multiline':False]
['text':' Make sure value and previous are using the same scale factor.','line_number':767,'multiline':False]
['text':' Record our new scale factor','line_number':775,'multiline':False]
['text':' Append delta and check if we wrote a Simple8b block. If we did we may be able to reduce the','line_number':779,'multiline':False]
['text':' scale factor when starting a new block','line_number':780,'multiline':False]
['text':' Reset the scale factor to 0 and append all pending values to a new Simple8bBuilder. In','line_number':791,'multiline':False]
['text':' the worse case we will end up with an identical scale factor.','line_number':792,'multiline':False]
['text':' Create a new Simple8bBuilder.','line_number':796,'multiline':False]
['text':' Iterate over previous pending values and re-add them recursively. That will increase the','line_number':800,'multiline':False]
['text':' scale factor as needed. No need to set '_prevEncoded64' in this code path as that will be','line_number':801,'multiline':False]
['text':' done in the recursive call to '_appendDouble' below.','line_number':802,'multiline':False]
['text':' The first two bytes are type and field name null terminator','line_number':819,'multiline':False]
['text':' Add space for type byte and field name null terminator','line_number':826,'multiline':False]
['text':' Re-allocate buffer if not large enough','line_number':829,'multiline':False]
['text':' Store null terminator, this byte will never change','line_number':834,'multiline':False]
['text':' Copy element into buffer for previous. Omit field name.','line_number':838,'multiline':False]
['text':' Write literal without field name and reset control byte to force new one to be written when','line_number':845,'multiline':False]
['text':' appending next value.','line_number':846,'multiline':False]
['text':' Reset state','line_number':857,'multiline':False]
['text':' Initialize previous encoded when needed','line_number':866,'multiline':False]
['text':' Allocate new control byte if we don't already have one. Record its offset so we can find','line_number':901,'multiline':False]
['text':' it even if the underlying buffer reallocates.','line_number':902,'multiline':False]
['text':' Read current count from previous control byte','line_number':907,'multiline':False]
['text':' If previous byte was written with a different control byte then we can't re-use and need','line_number':910,'multiline':False]
['text':' to start a new one','line_number':911,'multiline':False]
['text':' Write back new count and clear offset if we have reached max count','line_number':924,'multiline':False]
['text':' Write/update block count','line_number':937,'multiline':False]
['text':' Write Simple-8b block in little endian byte order','line_number':940,'multiline':False]
['text':' Write control block if this Simple-8b block made it full.','line_number':943,'multiline':False]
['text':' If we are double we need to remember the last value written in the block. There could','line_number':951,'multiline':False]
['text':' be multiple values pending still so we need to loop backwards and re-construct the','line_number':952,'multiline':False]
['text':' value before the first value in pending.','line_number':953,'multiline':False]
['text':' As we're going backwards we need to 'expandDelta' backwards which is the same','line_number':958,'multiline':False]
['text':' as 'calcDelta'.','line_number':959,'multiline':False]
['text':' We need to buffer all control blocks written by the EncodingStates','line_number':1043,'multiline':False]
['text':' so they can be added to the main buffer in the right order.','line_number':1044,'multiline':False]
['text':' Check if added object is compatible with selected reference object. Collect a flat vector of','line_number':1051,'multiline':False]
['text':' all elements while we are doing this.','line_number':1052,'multiline':False]
['text':' We should have received one callback for every sub-element in reference object. This should','line_number':1063,'multiline':False]
['text':' match number of encoding states setup previously.','line_number':1064,'multiline':False]
['text':' Append elements to corresponding encoding state.','line_number':1070,'multiline':False]
['text':' Start sub-object compression. Enter DeterminingReference mode, we use this first Object','line_number':1083,'multiline':False]
['text':' as the first reference','line_number':1084,'multiline':False]
['text':' Done determining reference sub-object. Write this control byte and object to stream.','line_number':1095,'multiline':False]
['text':' Initialize all encoding states. We do this by traversing in lock-step between the reference','line_number':1105,'multiline':False]
['text':' object and first buffered element. We can use the fact if sub-element exists in reference to','line_number':1106,'multiline':False]
['text':' determine if we should start with a zero delta or skip.','line_number':1107,'multiline':False]
['text':' Set a valid 'previous' into the encoding state to avoid a full','line_number':1109,'multiline':False]
['text':' literal to be written when we append the first element. We want this','line_number':1110,'multiline':False]
['text':' to be a zero delta as the reference object already contain this','line_number':1111,'multiline':False]
['text':' literal.','line_number':1112,'multiline':False]
['text':' Append remaining buffered objects.','line_number':1127,'multiline':False]
['text':' The objects we append here should always be compatible with our reference object. If they','line_number':1131,'multiline':False]
['text':' are not then there is a bug somewhere.','line_number':1132,'multiline':False]
['text':' Flush all EncodingStates, this will cause them to write out all their elements that is','line_number':1143,'multiline':False]
['text':' captured by the controlBlockWriter.','line_number':1144,'multiline':False]
['text':' We now need to write all control blocks to the binary stream in the right order. This is done','line_number':1149,'multiline':False]
['text':' in the decoder's perspective where a DecodingState that exhausts its elements will read the','line_number':1150,'multiline':False]
['text':' next control byte. We can use a min-heap to see which encoding states have written the fewest','line_number':1151,'multiline':False]
['text':' elements so far. In case of tie we use the smallest encoder/decoder index.','line_number':1152,'multiline':False]
['text':' num elements written ','line_number':1153,'multiline':True]
['text':' encoder index ','line_number':1153,'multiline':True]
['text':' Initialize as min-heap','line_number':1158,'multiline':False]
['text':' Append all control blocks','line_number':1162,'multiline':False]
['text':' Take out encoding state with fewest elements written from heap','line_number':1164,'multiline':False]
['text':' And we take out control blocks in FIFO order from this encoding state','line_number':1166,'multiline':False]
['text':' Write it to the buffer','line_number':1171,'multiline':False]
['text':' No more control blocks for this encoding state so remove it from the heap','line_number':1175,'multiline':False]
['text':' Calculate how many elements were in this control block','line_number':1180,'multiline':False]
['text':' Append num elements and put this encoding state back into the heap.','line_number':1200,'multiline':False]
['text':' All control blocks written, write EOO to end the interleaving and cleanup.','line_number':1204,'multiline':False]
['text':' namespace mongo','line_number':1211,'multiline':False]
