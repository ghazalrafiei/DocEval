['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':30,'multiline':False]
['text':'* Mutable BSON Implementation Overview
 *
 *  If you haven't read it already, please read the 'Mutable BSON Overview' comment in
 *  document.h before reading further.
 *
 *  In the following discussion, the capitalized terms 'Element' and 'Document' refer to
 *  the classes of the same name. At times, it is also necessary to refer to abstract
 *  'elements' or 'documents', in the sense of bsonspec.org. These latter uses are
 *  non-capitalized. In the BSON specification, there are two 'classes' of
 *  elements. 'Primitive' or 'leaf' elements are those elements which do not contain other
 *  elements. In practice, all BSON types except 'Array' and 'Object' are primitives. The
 *  CodeWScope type is an exception, but one that we sidestep by considering its BSONObj
 *  payload to be opaque.
 *
 *  A mutable BSON Document and its component Elements are implemented in terms of four
 *  data structures. These structures are owned by a Document::Impl object. Each Document
 *  owns a unique Document::Impl, which owns the relevant data structures and provides
 *  accessors, mutators, and helper methods related to those data structures. Understanding
 *  these data structures is critical for understanding how the system as a whole operates.
 *
 *  - The 'Elements Vector': This is a std::vector<ElementRep>, where 'ElementRep' is a
 *    structure type defined below that contains the detailed information about an entity
 *    in the Document (e.g. an Object, or an Array, or a NumberLong, etc.). The 'Element'
 *    and 'ConstElement' objects contain a pointer to a Document (which allows us to reach
 *    the Document::Impl for the Document), and an index into the Elements Vector in the
 *    Document::Impl. These two pieces of information make it possible for us to obtain the
 *    ElementRep associated with a given Element. Note that the Elements Vector is append
 *    only: ElementReps are never removed from it, even if the cooresponding Element is
 *    removed from the Document. By never removing ElementReps, and by using indexes into
 *    the Elements Vector, we can ensure that Elements are never invalidated. Note that
 *    every Document comes with an automatically provided 'root' element of mongo::Object
 *    type. The ElementRep for the root is always in the first slot (index zero) of the
 *    Elements Vector.
 *
 *  - The 'Leaf Builder': This is a standard BSONObjBuilder. When a request is made to the
 *    Document to add new data to the Document via one of the Document::makeElement[TYPE]
 *    calls, the element is constructed by invoking the appropriate method on the Leaf
 *    Builder, forwarding the arguments provided to the call on Document. This results in a
 *    contiguous region of memory which encodes this element, capturing its field name, its
 *    type, and the bytes that encode its value, in the same way it normally does when
 *    using BSONObjBuilder. We then build an ElementRep that indexes into the BufBuilder
 *    behind the BSONObjBuilder (more on how this happens below, in the section on the
 *    'Objects Vector'), then insert that new ElementRep into the ElementsVector, and
 *    finally return an Element that dereferences to the new ElementRep. Subsequently,
 *    requests for the type, fieldname or value bytes via the Element are satisfied by
 *    obtaining the contiguous memory region for the element, which may be used to
 *    construct a BSONElement over that memory region.
 *
 *  - The 'Objects Vector': This is a std::vector<BSONObj>. Any BSONObj object that
 *    provides values for parts of the Document is stored in the Objects Vector. For
 *    instance, in 'Example 2' from document.h, the Document we construct wraps an existing
 *    BSONObj, which is passed in to the Document constructor. That BSONObj would be stored
 *    in the Objects Vector. The data content of the BSONObj is not copied, but the BSONObj
 *    is copied, so the if the BSONObj is counted, we will up its refcount. In any event
 *    the lifetime of the BSONObj must exceed our lifetime by some mechanism. ElementReps
 *    that represent the component elements of the BSONObj store the index of their
 *    supporting BSONObj into the 'objIdx' field of ElementRep. Later, when Elements
 *    referring to those ElementReps are asked for properties like the field name or type
 *    of the Element, the underlying memory region in the appropriate BSONObj may be
 *    examined to provide the relevant data.
 *
 *  - The 'Field Name Heap': For some elements, particularly those in the Leaf Builder or
 *    those embedded in a BSONObj in the Objects Vector, we can easily obtain the field
 *    name by reading it from the encoded BSON. However, some elements are not so
 *    fortunate. Newly created elements of mongo::Array or mongo::Object type, for
 *    instance, don't have a memory region that provides values. In such cases, the field
 *    name is stored in the field name heap, which is simply std::vector<char>, where the
 *    field names are null-byte-delimited. ElementsReps for such elements store an offset
 *    into the Field Name Heap, and when asked for their field name simply return a pointer
 *    to the string data the offset identifies. This exploits the fact that in BSON, valid
 *    field names are null terinated and do not contain embedded null bytes.
 *
 *  - The 'root' Element. Each Document contains a well known Element, which always refers
 *    to a pre-constructed ElementRep at offset zero in the Elements Vector. This is an
 *    Object element, and it is considered as the root of the document tree. It is possible
 *    for ElementReps to exist in the Document data structures, but not be in a child
 *    relationship to the root Element. Newly created Elements, for instance, are in this
 *    sort of 'detached' state until they are attched to another element. Only Element's
 *    that are children of the root element are traversed when calling top level
 *    serialization or comparision operations on Document.
 *
 *  When you construct a Document that obtains its values from an underlying BSONObj, the
 *  entire BSONObj is not 'unpacked' into ElementReps at Document construction
 *  time. Instead, as you ask for Elements with the Element navigation API, the Elements
 *  for children and siblings are created on demand. Subobjects which are never visited
 *  will never have ElementReps constructed for them. Similarly, when writing a Document
 *  back out to a builder, regions of memory that provide values for the Document and which
 *  have not been modified will be block copied, instead of being recursively explored and
 *  written.
 *
 *  To see how these data structures interoperate, we will walk through an example. You may
 *  want to read the comments for ElementRep before tackling the example, since we will
 *  refer to the internal state of ElementRep here. The example code used here exists as a
 *  unit test in mutable_bson_test.cpp as (Documentation, Example3).
 *
 *
 *  Legend:
 *   oi   : objIdx
 *   +/-  : bitfield state (s: serialized, a: array)
 *   x    : invalid/empty rep idx
 *   ?    : opaque rep idx
 *   ls/rs: left/right sibling
 *   lc/rc: left/right child
 *   p    : parent

    static const char inJson[] =
        "{"
        "  'xs': { 'x' : 'x', 'X' : 'X' },"
        "  'ys': { 'y' : 'y' }"
        "}";
    mongo::BSONObj inObj = mongo::fromjson(inJson);
    mmb::Document doc(inObj);

 *    _elements
 *      oi      flags                offset                  ls  rs  lc  rc  p
 *    +-----------------------------------------------------------------------------+
 *  0 | 1 | s:- | ...       | off 0       into _fieldNames | x | x | ? | ? | x      |
 *    +-----------------------------------------------------------------------------+
 *
 *    _objects
 *    +-----------------------------------------------------------------------------+
 *    | BSONObj for _leafBuilder | BSONObj for inObj |                              |
 *    +-----------------------------------------------------------------------------+
 *
 *    _fieldNames
 *    +-----------------------------------------------------------------------------+
 *    | \0                                                                          |
 *    +-----------------------------------------------------------------------------+
 *
 *    _leafBuf
 *    +-----------------------------------------------------------------------------+
 *    | {}                                                                          |
 *    +-----------------------------------------------------------------------------+


    mmb::Element root = doc.root();
    mmb::Element xs = root.leftChild();

 *    _elements
 *      oi      flags                offset                  ls  rs  lc  rc  p
 *    +-----------------------------------------------------------------------------+
 *  0 | 1 | s:- | ...       | off 0       into _fieldNames | x | x | 1 | ? | x      | *
 *  1 | 1 | s:+ | ...       | off of 'xs' into _objects[1] | x | ? | ? | ? | 0      | *
 *    +-----------------------------------------------------------------------------+
 *
 *    _objects
 *    +-----------------------------------------------------------------------------+
 *    | BSONObj for _leafBuilder | BSONObj for inObj |                              |
 *    +-----------------------------------------------------------------------------+
 *
 *    _fieldNames
 *    +-----------------------------------------------------------------------------+
 *    | \0                                                                          |
 *    +-----------------------------------------------------------------------------+
 *
 *    _leafBuf
 *    +-----------------------------------------------------------------------------+
 *    | {}                                                                          |
 *    +-----------------------------------------------------------------------------+


    mmb::Element ys = xs.rightSibling();

 *    _elements
 *      oi      flags                offset                  ls  rs  lc  rc  p
 *    +-----------------------------------------------------------------------------+
 *  0 | 1 | s:- | ...       | off 0       into _fieldNames | x | x | 1 | ? | x      |
 *  1 | 1 | s:+ | ...       | off of 'xs' into _objects[1] | x | 2 | ? | ? | 0      | *
 *  2 | 1 | s:+ | ...       | off of 'ys' into _objects[1] | 1 | ? | ? | ? | 0      | *
 *    +-----------------------------------------------------------------------------+
 *
 *    _objects
 *    +-----------------------------------------------------------------------------+
 *    | BSONObj for _leafBuilder | BSONObj for inObj |                              |
 *    +-----------------------------------------------------------------------------+
 *
 *    _fieldNames
 *    +-----------------------------------------------------------------------------+
 *    | \0                                                                          |
 *    +-----------------------------------------------------------------------------+
 *
 *    _leafBuf
 *    +-----------------------------------------------------------------------------+
 *    | {}                                                                          |
 *    +-----------------------------------------------------------------------------+


    mmb::Element dne = ys.rightSibling();

 *    _elements
 *      oi      flags                offset                  ls  rs  lc  rc  p
 *    +-----------------------------------------------------------------------------+
 *  0 | 1 | s:- | ...       | off 0       into _fieldNames | x | x | 1 | 2 | x      | *
 *  1 | 1 | s:+ | ...       | off of 'xs' into _objects[1] | x | 2 | ? | ? | 0      |
 *  2 | 1 | s:+ | ...       | off of 'ys' into _objects[1] | 1 | x | ? | ? | 0      | *
 *    +-----------------------------------------------------------------------------+
 *
 *    _objects
 *    +-----------------------------------------------------------------------------+
 *    | BSONObj for _leafBuilder | BSONObj for inObj |                              |
 *    +-----------------------------------------------------------------------------+
 *
 *    _fieldNames
 *    +-----------------------------------------------------------------------------+
 *    | \0                                                                          |
 *    +-----------------------------------------------------------------------------+
 *
 *    _leafBuf
 *    +-----------------------------------------------------------------------------+
 *    | {}                                                                          |
 *    +-----------------------------------------------------------------------------+


    mmb::Element ycaps = doc.makeElementString("Y", "Y");

 *    _elements
 *      oi      flags                offset                  ls  rs  lc  rc  p
 *    +-----------------------------------------------------------------------------+
 *  0 | 1 | s:- | ...       | off 0       into _fieldNames | x | x | 1 | 2 | x      |
 *  1 | 1 | s:+ | ...       | off of 'xs' into _objects[1] | x | 2 | ? | ? | 0      |
 *  2 | 1 | s:+ | ...       | off of 'ys' into _objects[1] | 1 | x | ? | ? | 0      |
 *  3 | 0 | s:+ | ...       | off of 'Y'  into _objects[0] | x | x | x | x | x      | *
 *    +-----------------------------------------------------------------------------+
 *
 *    _objects
 *    +-----------------------------------------------------------------------------+
 *    | BSONObj for _leafBuilder | BSONObj for inObj |                              |
 *    +-----------------------------------------------------------------------------+
 *
 *    _fieldNames
 *    +-----------------------------------------------------------------------------+
 *    | \0                                                                          |
 *    +-----------------------------------------------------------------------------+
 *
 *    _leafBuf
 *    +-----------------------------------------------------------------------------+
 *    | { "Y" : "Y" }                                                               | *
 *    +-----------------------------------------------------------------------------+


    ys.pushBack(ycaps);

 *    _elements
 *      oi      flags                offset                    ls  rs  lc  rc  p
 *    +-----------------------------------------------------------------------------+
 *  0 | 1 | s:- | ...       | off 0         into _fieldNames | x | x | 1 | 2 | x    |
 *  1 | 1 | s:+ | ...       | off of 'xs'   into _objects[1] | x | 2 | ? | ? | 0    |
 *  2 | 1 | s:- | ...       | off of 'ys'   into _objects[1] | 1 | x | 4 | 3 | 0    | *
 *  3 | 0 | s:+ | ...       | off of 'Y'    into _objects[0] | 4 | x | x | x | 2    | *
 *  4 | 1 | s:+ | ...       | off of 'ys.y' into _objects[1] | x | 3 | x | x | 2    | *
 *    +-----------------------------------------------------------------------------+
 *
 *    _objects
 *    +-----------------------------------------------------------------------------+
 *    | BSONObj for _leafBuilder | BSONObj for inObj |                              |
 *    +-----------------------------------------------------------------------------+
 *
 *    _fieldNames
 *    +-----------------------------------------------------------------------------+
 *    | \0                                                                          |
 *    +-----------------------------------------------------------------------------+
 *
 *    _leafBuf
 *    +-----------------------------------------------------------------------------+
 *    | { "Y" : "Y" }                                                               |
 *    +-----------------------------------------------------------------------------+


    mmb::Element pun = doc.makeElementArray("why");

 *    _elements
 *      oi      flags                offset                     ls  rs  lc  rc  p
 *    +-----------------------------------------------------------------------------+
 *  0 | 1  | s:- | ...       | off 0         into _fieldNames | x | x | 1 | 2 | x   |
 *  1 | 1  | s:+ | ...       | off of 'xs'   into _objects[1] | x | 2 | ? | ? | 0   |
 *  2 | 1  | s:- | ...       | off of 'ys'   into _objects[1] | 1 | x | 4 | 3 | 0   |
 *  3 | 0  | s:+ | ...       | off of 'Y'    into _objects[0] | 4 | x | x | x | 2   |
 *  4 | 1  | s:+ | ...       | off of 'ys.y' into _objects[1] | x | 3 | x | x | 2   |
 *  5 | -1 | s:- | a:+ | ... | off of 'why'  into _fieldNames | x | x | x | x | x   | *
 *    +-----------------------------------------------------------------------------+
 *
 *    _objects
 *    +-----------------------------------------------------------------------------+
 *    | BSONObj for _leafBuilder | BSONObj for inObj |                              |
 *    +-----------------------------------------------------------------------------+
 *
 *    _fieldNames
 *    +-----------------------------------------------------------------------------+
 *    | \0why\0                                                                     | *
 *    +-----------------------------------------------------------------------------+
 *
 *    _leafBuf
 *    +-----------------------------------------------------------------------------+
 *    | { "Y" : "Y" }                                                               |
 *    +-----------------------------------------------------------------------------+


    ys.pushBack(pun);

 *    _elements
 *      oi      flags                offset                     ls  rs  lc  rc  p
 *    +-----------------------------------------------------------------------------+
 *  0 | 1  | s:- | ...       | off 0         into _fieldNames | x | x | 1 | 2 | x   |
 *  1 | 1  | s:+ | ...       | off of 'xs'   into _objects[1] | x | 2 | ? | ? | 0   |
 *  2 | 1  | s:- | ...       | off of 'ys'   into _objects[1] | 1 | x | 4 | 5 | 0   | *
 *  3 | 0  | s:+ | ...       | off of 'Y'    into _objects[0] | 4 | 5 | x | x | 2   | *
 *  4 | 1  | s:+ | ...       | off of 'ys.y' into _objects[1] | x | 3 | x | x | 2   |
 *  5 | -1 | s:- | a:+ | ... | off of 'why'  into _fieldNames | 3 | x | x | x | 2   | *
 *    +-----------------------------------------------------------------------------+
 *
 *    _objects
 *    +-----------------------------------------------------------------------------+
 *    | BSONObj for _leafBuilder | BSONObj for inObj |                              |
 *    +-----------------------------------------------------------------------------+
 *
 *    _fieldNames
 *    +-----------------------------------------------------------------------------+
 *    | \0why\0                                                                     |
 *    +-----------------------------------------------------------------------------+
 *
 *    _leafBuf
 *    +-----------------------------------------------------------------------------+
 *    | { "Y" : "Y" }                                                               |
 *    +-----------------------------------------------------------------------------+


    pun.appendString("na", "not");

 *    _elements
 *      oi      flags                offset                     ls  rs  lc  rc  p
 *    +-----------------------------------------------------------------------------+
 *  0 | 1  | s:- | ...       | off 0         into _fieldNames | x | x | 1 | 2 | x   |
 *  1 | 1  | s:+ | ...       | off of 'xs'   into _objects[1] | x | 2 | ? | ? | 0   |
 *  2 | 1  | s:- | ...       | off of 'ys'   into _objects[1] | 1 | x | 4 | 5 | 0   |
 *  3 | 0  | s:+ | ...       | off of 'Y'    into _objects[0] | 4 | 5 | x | x | 2   |
 *  4 | 1  | s:+ | ...       | off of 'ys.y' into _objects[1] | x | 3 | x | x | 2   |
 *  5 | -1 | s:- | a:+ | ... | off of 'why'  into _fieldNames | 3 | x | 6 | 6 | 2   | *
 *  6 | 0  | s:+ | ...       | off of 'na'   into _objects[0] | x | x | x | x | 5   | *
 *    +-----------------------------------------------------------------------------+
 *
 *    _objects
 *    +-----------------------------------------------------------------------------+
 *    | BSONObj for _leafBuilder | BSONObj for inObj |                              |
 *    +-----------------------------------------------------------------------------+
 *
 *    _fieldNames
 *    +-----------------------------------------------------------------------------+
 *    | \0why\0                                                                     |
 *    +-----------------------------------------------------------------------------+
 *
 *    _leafBuf
 *    +-----------------------------------------------------------------------------+
 *    | { "Y" : "Y", "na" : "not" }                                                 | *
 *    +-----------------------------------------------------------------------------+
 *
 ','line_number':49,'multiline':True]
['text':' Work around http://gcc.gnu.org/bugzilla/show_bug.cgi?id=29365. Note that the selection of','line_number':406,'multiline':False]
['text':' minor version 4 is somewhat arbitrary. It does appear that the fix for this was backported','line_number':407,'multiline':False]
['text':' to earlier versions. This is a conservative choice that we can revisit later. We need the','line_number':408,'multiline':False]
['text':' __clang__ here because Clang claims to be gcc of some version.','line_number':409,'multiline':False]
['text':' The designated field name for the root element.','line_number':415,'multiline':False]
['text':' How many reps do we cache before we spill to heap. Use a power of two. For debug','line_number':418,'multiline':False]
['text':' builds we make this very small so it is less likely to mask vector invalidation','line_number':419,'multiline':False]
['text':' logic errors. We don't make it zero so that we do execute the fastRep code paths.','line_number':420,'multiline':False]
['text':' An ElementRep contains the information necessary to locate the data for an Element,','line_number':423,'multiline':False]
['text':' and the topology information for how the Element is related to other Elements in the','line_number':424,'multiline':False]
['text':' document.','line_number':425,'multiline':False]
['text':' Builds an ElementRep in its correct default state. This is used instead of a default','line_number':428,'multiline':False]
['text':' constructor or NSDMIs to ensure that this type stays trivial so that vectors of it are cheap','line_number':429,'multiline':False]
['text':' to grow.','line_number':430,'multiline':False]
['text':' The index of the BSONObj that provides the value for this Element. For nodes','line_number':433,'multiline':False]
['text':' where serialized is 'false', this value may be kInvalidObjIdx to indicate that','line_number':434,'multiline':False]
['text':' the Element does not have a supporting BSONObj.','line_number':435,'multiline':False]
['text':' This bit is true if this ElementRep identifies a completely serialized','line_number':439,'multiline':False]
['text':' BSONElement (i.e. a region of memory with a bson type byte, a fieldname, and an','line_number':440,'multiline':False]
['text':' encoded value). Changes to children of a serialized element will cause it to be','line_number':441,'multiline':False]
['text':' marked as unserialized.','line_number':442,'multiline':False]
['text':' For object like Elements where we cannot determine the type of the object by','line_number':445,'multiline':False]
['text':' looking a region of memory, the 'array' bit allows us to determine whether we','line_number':446,'multiline':False]
['text':' are an object or an array.','line_number':447,'multiline':False]
['text':' Reserved for future use.','line_number':450,'multiline':False]
['text':' This word either gives the offset into the BSONObj associated with this','line_number':453,'multiline':False]
['text':' ElementRep where this serialized BSON element may be located, or the offset into','line_number':454,'multiline':False]
['text':' the _fieldNames member of the Document where the field name for this BSON','line_number':455,'multiline':False]
['text':' element may be located.','line_number':456,'multiline':False]
['text':' The indexes of our left and right siblings in the Document.','line_number':459,'multiline':False]
['text':' The indexes of our left and right chidren in the Document.','line_number':465,'multiline':False]
['text':' The index of our parent in the Document.','line_number':471,'multiline':False]
['text':' The size of the field name and the total element size are cached to allow quickly','line_number':474,'multiline':False]
['text':' constructing a BSONElement object. These fields are private (even though the rest of this','line_number':475,'multiline':False]
['text':' struct is public) because of the somewhat complex requirements to update and use them','line_number':476,'multiline':False]
['text':' correctly.','line_number':477,'multiline':False]
['text':'','line_number':484,'multiline':False]
['text':' The cached sizes for this element, or -1 if unknown or too big to fit.','line_number':490,'multiline':False]
['text':' TODO consider putting _fieldNameSize in the reserved bit field above to allow larger total','line_number':491,'multiline':False]
['text':' sizes to be cached. Alternatively, could use an 8/24 split uint32_t. Since BSONObj is limited','line_number':492,'multiline':False]
['text':' to just over 16MB, that will cover all practical element sizes. For now, this is fine since','line_number':493,'multiline':False]
['text':' computing the size is a trivial cost when working with elements larger 32KB.','line_number':494,'multiline':False]
['text':' We want ElementRep to be a POD so Document::Impl can grow the std::vector with','line_number':502,'multiline':False]
['text':' memmove.','line_number':503,'multiline':False]
['text':'','line_number':504,'multiline':False]
['text':' The ElementRep for the root element is always zero.','line_number':507,'multiline':False]
['text':' This is the object index for elements in the leaf heap.','line_number':510,'multiline':False]
['text':' This is the sentinel value to indicate that we have no supporting BSONObj.','line_number':513,'multiline':False]
['text':' This is the highest valid object index that does not overlap sentinel values.','line_number':516,'multiline':False]
['text':' Returns the offset of 'elt' within 'object' as a uint32_t. The element must be part','line_number':534,'multiline':False]
['text':' of the object or the behavior is undefined.','line_number':535,'multiline':False]
['text':' BSON documents express their size as an int32_t so we should always be able to','line_number':544,'multiline':False]
['text':' express the offset as a uint32_t.','line_number':545,'multiline':False]
['text':' Returns true if this ElementRep is 'detached' from all other elements and can be','line_number':551,'multiline':False]
['text':' added as a child, which helps ensure that we maintain a tree rather than a graph','line_number':552,'multiline':False]
['text':' when adding new elements to the tree. The root element is never considered to be','line_number':553,'multiline':False]
['text':' attachable.','line_number':554,'multiline':False]
['text':' Returns a Status describing why 'canAttach' returned false. This function should not','line_number':560,'multiline':False]
['text':' be inlined since it just makes the callers larger for no real gain.','line_number':561,'multiline':False]
['text':' Enable paranoid mode to force a reallocation on mutation of the princple data','line_number':574,'multiline':False]
['text':' structures in Document::Impl. This is really slow, but can be very helpful if you','line_number':575,'multiline':False]
['text':' suspect an invalidation logic error and want to find it with valgrind. Paranoid mode','line_number':576,'multiline':False]
['text':' only works in debug mode; it is ignored in release builds.','line_number':577,'multiline':False]
['text':' namespace','line_number':582,'multiline':False]
['text':'* Document::Impl holds the Document state. Please see the file comment above for details
 *  on the fields of Impl and how they are used to realize the implementation of mutable
 *  BSON. Impl provides various utility methods to insert, lookup, and interrogate the
 *  Elements, BSONObj objects, field names, and builders associated with the Document.
 *
 *  TODO: At some point, we could remove the firewall and inline the members of Impl into
 *  Document.
 ','line_number':585,'multiline':True]
['text':' We always have a BSONObj for the leaves, and we often have','line_number':608,'multiline':False]
['text':' one for our base document, so reserve 2.','line_number':609,'multiline':False]
['text':' We always have at least one byte for the root field name, and we would like','line_number':612,'multiline':False]
['text':' to be able to hold a few short field names without reallocation.','line_number':613,'multiline':False]
['text':' We need an object at _objects[0] so that we can access leaf elements we','line_number':616,'multiline':False]
['text':' construct with the leaf builder in the same way we access elements serialized in','line_number':617,'multiline':False]
['text':' other BSONObjs. So we call asTempObj on the builder and store the result in slot','line_number':618,'multiline':False]
['text':' 0.','line_number':619,'multiline':False]
['text':' Clear out the state in the vectors.','line_number':630,'multiline':False]
['text':' There is no way to reset the state of a BSONObjBuilder, so we need to call its','line_number':637,'multiline':False]
['text':' dtor, reset the underlying buf, and re-invoke the constructor in-place.','line_number':638,'multiline':False]
['text':' Ensure that we start in the same state as the ctor would leave us in.','line_number':648,'multiline':False]
['text':' Obtain the ElementRep for the given rep id.','line_number':652,'multiline':False]
['text':' Obtain the ElementRep for the given rep id.','line_number':657,'multiline':False]
['text':' Construct and return a new default initialized ElementRep. The RepIdx identifying','line_number':666,'multiline':False]
['text':' the new rep is returned in the out parameter.','line_number':667,'multiline':False]
['text':' Force all reps to new addresses to help catch invalid rep usage.','line_number':677,'multiline':False]
['text':' Insert a new ElementRep for a leaf element at the given offset and return its ID.','line_number':686,'multiline':False]
['text':' BufBuilder hands back sizes in 'int's.','line_number':688,'multiline':False]
['text':' TODO: Is this a legitimate possibility?','line_number':696,'multiline':False]
['text':' Obtain the object builder for the leaves.','line_number':703,'multiline':False]
['text':' Obtain the BSONObj for the given object id.','line_number':708,'multiline':False]
['text':' Obtain the BSONObj for the given object id.','line_number':714,'multiline':False]
['text':' Insert the given BSONObj and return an ID for it.','line_number':720,'multiline':False]
['text':' Force reallocation to catch use after invalidation.','line_number':726,'multiline':False]
['text':' Given a RepIdx, return the BSONElement that it represents.','line_number':733,'multiline':False]
['text':' A helper method that either inserts the field name into the field name heap and','line_number':738,'multiline':False]
['text':' updates element.','line_number':739,'multiline':False]
['text':' Retrieve the fieldName, given a rep.','line_number':745,'multiline':False]
['text':' The root element has no field name.','line_number':747,'multiline':False]
['text':' Retrieve the type, given a rep.','line_number':766,'multiline':False]
['text':' The root element is always an Object.','line_number':768,'multiline':False]
['text':' Returns true if rep is not an object or array.','line_number':782,'multiline':False]
['text':' Returns true if rep's value can be provided as a BSONElement.','line_number':791,'multiline':False]
['text':' The root element may be marked serialized, but it doesn't have a BSONElement','line_number':793,'multiline':False]
['text':' representation.','line_number':794,'multiline':False]
['text':' Return the index of the left child of the Element with index 'index', resolving the','line_number':801,'multiline':False]
['text':' left child to a realized Element if it is currently opaque. This may also cause the','line_number':802,'multiline':False]
['text':' parent elements child.right entry to be updated.','line_number':803,'multiline':False]
['text':' If the left child is anything other than opaque, then we are done here.','line_number':808,'multiline':False]
['text':' It should be impossible to have an opaque left child and be non-serialized,','line_number':813,'multiline':False]
['text':' Do this now before other writes so compiler can exploit knowing','line_number':820,'multiline':False]
['text':' that we are not eoo.','line_number':821,'multiline':False]
['text':' Calling makeNewRep invalidates rep since it may cause a reallocation of','line_number':827,'multiline':False]
['text':' the element vector. After calling insertElement, we reacquire rep.','line_number':828,'multiline':False]
['text':' If this new object has possible substructure, mark its children as opaque.','line_number':836,'multiline':False]
['text':' Return the index of the right child of the Element with index 'index', resolving any','line_number':852,'multiline':False]
['text':' opaque nodes. Note that this may require resolving all of the right siblings of the','line_number':853,'multiline':False]
['text':' left child.','line_number':854,'multiline':False]
['text':' The resolveRightSibling calls should have eventually updated this nodes right','line_number':869,'multiline':False]
['text':' child pointer to point to the node we are about to return.','line_number':870,'multiline':False]
['text':' Return the index of the right sibling of the Element with index 'index', resolving','line_number':877,'multiline':False]
['text':' the right sibling to a realized Element if it is currently opaque.','line_number':878,'multiline':False]
['text':' If the right sibling is anything other than opaque, then we are done here.','line_number':883,'multiline':False]
['text':' Do this now before other writes so compiler can exploit knowing','line_number':892,'multiline':False]
['text':' that we are not eoo.','line_number':893,'multiline':False]
['text':' Calling makeNewRep invalidates rep since it may cause a reallocation of','line_number':899,'multiline':False]
['text':' the element vector. After calling insertElement, we reacquire rep.','line_number':900,'multiline':False]
['text':' If this new object has possible substructure, mark its children as opaque.','line_number':909,'multiline':False]
['text':' If we have found the end of this object, then our (necessarily existing)','line_number':918,'multiline':False]
['text':' parent's necessarily opaque right child is now determined to be us.','line_number':919,'multiline':False]
['text':' Find the ElementRep at index 'index', and mark it and all of its currently','line_number':930,'multiline':False]
['text':' serialized parents as non-serialized.','line_number':931,'multiline':False]
['text':' It does not make sense for leaf Elements to become deserialized, and','line_number':935,'multiline':False]
['text':' requests to do so indicate a bug in the implementation of the library.','line_number':936,'multiline':False]
['text':' StringData may come from either the field name heap or the leaf builder.','line_number':946,'multiline':False]
['text':' A BSONElement could alias the leaf builder.','line_number':959,'multiline':False]
['text':' A BSONObj could alias the leaf buildr.','line_number':964,'multiline':False]
['text':' Returns true if 'data' points within the leaf BufBuilder.','line_number':968,'multiline':False]
['text':' TODO: Write up something documenting that the following is technically UB due','line_number':970,'multiline':False]
['text':' to illegality of comparing pointers to different aggregates for ordering. Also,','line_number':971,'multiline':False]
['text':' do we need to do anything to prevent the optimizer from compiling this out on','line_number':972,'multiline':False]
['text':' that basis? I've seen clang do that. We may need to declare these volatile. On','line_number':973,'multiline':False]
['text':' the other hand, these should only be being called under a dassert, so the','line_number':974,'multiline':False]
['text':' optimizer is maybe not in play, and the UB is unlikely to be a problem in','line_number':975,'multiline':False]
['text':' practice.','line_number':976,'multiline':False]
['text':' Returns true if 'data' points within the field name heap.','line_number':982,'multiline':False]
['text':' If some operations were not in-place, set source to NULL and return false to','line_number':996,'multiline':False]
['text':' inform upstream that we are not returning in-place result data.','line_number':997,'multiline':False]
['text':' Set up the source and source size out parameters.','line_number':1006,'multiline':False]
['text':' Swap our damage event queue with upstream, and reset ours to an empty vector. In','line_number':1011,'multiline':False]
['text':' princple, we can do another round of in-place updates.','line_number':1012,'multiline':False]
['text':' Force damage events to new addresses to catch invalidation errors.','line_number':1040,'multiline':False]
['text':' Check all preconditions on doing an in-place update, except for size match.','line_number':1046,'multiline':False]
['text':' NOTE: CodeWScope might arguably be excluded since it has substructure, but','line_number':1048,'multiline':False]
['text':' mutable doesn't permit navigation into its document, so we can handle it.','line_number':1049,'multiline':False]
['text':' We can only do an in-place update to an element that is serialized and is not in','line_number':1051,'multiline':False]
['text':' the leaf heap.','line_number':1052,'multiline':False]
['text':'','line_number':1053,'multiline':False]
['text':' TODO: In the future, we can replace values in the leaf heap if they are of the','line_number':1054,'multiline':False]
['text':' same size as the origin was. For now, we don't support that.','line_number':1055,'multiline':False]
['text':' sourceRep should be newly created, so it must have a value representation.','line_number':1059,'multiline':False]
['text':' For a target that has substructure, we only permit in-place updates if there','line_number':1062,'multiline':False]
['text':' cannot be ElementReps that reference data within the target. We don't need to','line_number':1063,'multiline':False]
['text':' worry about ElementReps for source, since it is newly created. The only way','line_number':1064,'multiline':False]
['text':' there can be ElementReps referring into substructure is if the Element has','line_number':1065,'multiline':False]
['text':' non-empty non-opaque child references.','line_number':1066,'multiline':False]
['text':' Insert the given field name into the field name heap, and return an ID for this','line_number':1087,'multiline':False]
['text':' field name.','line_number':1088,'multiline':False]
['text':' Force names to new addresses to catch invalidation errors.','line_number':1096,'multiline':False]
['text':' Retrieve the field name with the given id.','line_number':1103,'multiline':False]
['text':' We own a BufBuilder to avoid BSONObjBuilder's ref-count mechanism which would throw','line_number':1116,'multiline':False]
['text':' off our offset calculations.','line_number':1117,'multiline':False]
['text':' Sometimes, we need a temporary storage area for a fieldName, because the source of','line_number':1121,'multiline':False]
['text':' the fieldName is in the same buffer that we want to write to, potentially','line_number':1122,'multiline':False]
['text':' reallocating it. In such cases, we temporarily store the value here, rather than','line_number':1123,'multiline':False]
['text':' creating and destroying a string and its buffer each time.','line_number':1124,'multiline':False]
['text':' Queue of damage events and status bit for whether in-place updates are possible.','line_number':1127,'multiline':False]
['text':' check that new element roots a clean subtree.','line_number':1140,'multiline':False]
['text':' The new element shares our parent.','line_number':1156,'multiline':False]
['text':' We are the new element's right sibling.','line_number':1159,'multiline':False]
['text':' The new element's left sibling is our left sibling.','line_number':1162,'multiline':False]
['text':' If the new element has a left sibling after the adjustments above, then that left','line_number':1165,'multiline':False]
['text':' sibling must be updated to have the new element as its right sibling.','line_number':1166,'multiline':False]
['text':' The new element becomes our left sibling.','line_number':1170,'multiline':False]
['text':' If we were our parent's left child, then we no longer are. Make the new right','line_number':1173,'multiline':False]
['text':' sibling the right child.','line_number':1174,'multiline':False]
['text':' check that new element roots a clean subtree.','line_number':1191,'multiline':False]
['text':' If our current right sibling is opaque it needs to be resolved. This will invalidate','line_number':1207,'multiline':False]
['text':' our reps so we need to reacquire them.','line_number':1208,'multiline':False]
['text':' The new element shares our parent.','line_number':1218,'multiline':False]
['text':' We are the new element's left sibling.','line_number':1221,'multiline':False]
['text':' The new element right sibling is our right sibling.','line_number':1224,'multiline':False]
['text':' The new element becomes our right sibling.','line_number':1227,'multiline':False]
['text':' If the new element has a right sibling after the adjustments above, then that right','line_number':1230,'multiline':False]
['text':' sibling must be updated to have the new element as its left sibling.','line_number':1231,'multiline':False]
['text':' If we were our parent's right child, then we no longer are. Make the new right','line_number':1235,'multiline':False]
['text':' sibling the right child.','line_number':1236,'multiline':False]
['text':' We need to realize any opaque right sibling, because we are going to need to set its','line_number':1249,'multiline':False]
['text':' left sibling. Do this before acquiring thisRep since otherwise we would potentially','line_number':1250,'multiline':False]
['text':' invalidate it.','line_number':1251,'multiline':False]
['text':' If our right sibling is not the end of the object, then set its left sibling to be','line_number':1260,'multiline':False]
['text':' our left sibling.','line_number':1261,'multiline':False]
['text':' Similarly, if our left sibling is not the beginning of the obejct, then set its','line_number':1265,'multiline':False]
['text':' right sibling to be our right sibling.','line_number':1266,'multiline':False]
['text':' If this element was our parent's right child, then our left sibling is the new right','line_number':1272,'multiline':False]
['text':' child.','line_number':1273,'multiline':False]
['text':' Similarly, if this element was our parent's left child, then our right sibling is','line_number':1278,'multiline':False]
['text':' the new left child.','line_number':1279,'multiline':False]
['text':' The Element becomes detached.','line_number':1285,'multiline':False]
['text':' TODO: Some rename operations may be possible to do in-place.','line_number':1303,'multiline':False]
['text':' Operations below may invalidate thisRep, so we may need to reacquire it.','line_number':1306,'multiline':False]
['text':' For non-leaf serialized elements, we can realize any opaque relatives and then','line_number':1309,'multiline':False]
['text':' convert ourselves to deserialized.','line_number':1310,'multiline':False]
['text':' Realize any opaque right sibling or left child now, since otherwise we will lose','line_number':1314,'multiline':False]
['text':' the ability to do so.','line_number':1315,'multiline':False]
['text':' The resolve calls above may have invalidated thisRep, we need to reacquire it.','line_number':1319,'multiline':False]
['text':' Set this up as a non-supported deserialized element. We will set the fieldName','line_number':1322,'multiline':False]
['text':' in the else clause in the block below.','line_number':1323,'multiline':False]
['text':' TODO: If we ever want to be able to add to the left or right of an opaque object','line_number':1328,'multiline':False]
['text':' without expanding, this may need to change.','line_number':1329,'multiline':False]
['text':' For leaf elements we just create a new Element with the current value and','line_number':1334,'multiline':False]
['text':' replace. Note that the 'setValue' call below will invalidate thisRep.','line_number':1335,'multiline':False]
['text':' The easy case: just update what our field name offset refers to.','line_number':1339,'multiline':False]
['text':' Capturing Document::Impl by non-const ref exploits the constness loophole','line_number':1349,'multiline':False]
['text':' created by our Impl so that we can let leftChild be lazily evaluated, even for a','line_number':1350,'multiline':False]
['text':' const Element.','line_number':1351,'multiline':False]
['text':' Capturing Document::Impl by non-const ref exploits the constness loophole','line_number':1361,'multiline':False]
['text':' created by our Impl so that we can let leftChild be lazily evaluated, even for a','line_number':1362,'multiline':False]
['text':' const Element.','line_number':1363,'multiline':False]
['text':' Capturing Document::Impl by non-const ref exploits the constness loophole','line_number':1372,'multiline':False]
['text':' created by our Impl so that we can let leftChild be lazily evaluated, even for a','line_number':1373,'multiline':False]
['text':' const Element.','line_number':1374,'multiline':False]
['text':' We are (currently) never left opaque, so don't need to resolve.','line_number':1384,'multiline':False]
['text':' Capturing Document::Impl by non-const ref exploits the constness loophole','line_number':1393,'multiline':False]
['text':' created by our Impl so that we can let rightSibling be lazily evaluated, even for a','line_number':1394,'multiline':False]
['text':' const Element.','line_number':1395,'multiline':False]
['text':' TODO: Could DRY this loop with the identical logic in findElementNamed.','line_number':1427,'multiline':False]
['text':' We are (currently) never left opaque, so don't need to resolve.','line_number':1448,'multiline':False]
['text':' Short circuit a tautological compare.','line_number':1538,'multiline':False]
['text':' If either Element can represent its current value as a BSONElement, then we can','line_number':1542,'multiline':False]
['text':' obtain its value and use compareWithBSONElement. If both Elements have a','line_number':1543,'multiline':False]
['text':' representation as a BSONElement, compareWithBSONElement will notice that the first','line_number':1544,'multiline':False]
['text':' argument has a value and delegate to BSONElement::woCompare.','line_number':1545,'multiline':False]
['text':' Subtle: we must negate the comparison result here because we are reversing the','line_number':1550,'multiline':False]
['text':' argument order in this call.','line_number':1551,'multiline':False]
['text':'','line_number':1552,'multiline':False]
['text':' TODO: Andy has suggested that this may not be legal since woCompare is not reflexive','line_number':1553,'multiline':False]
['text':' in all cases.','line_number':1554,'multiline':False]
['text':' Leaf elements should always have a value, so we should only be dealing with Objects','line_number':1566,'multiline':False]
['text':' or Arrays here.','line_number':1567,'multiline':False]
['text':' Obtain the canonical types for this Element and the BSONElement, if they are','line_number':1571,'multiline':False]
['text':' different use the difference as the result. Please see BSONElement::woCompare for','line_number':1572,'multiline':False]
['text':' details. We know that thisRep is not a number, so we don't need to check that','line_number':1573,'multiline':False]
['text':' particular case.','line_number':1574,'multiline':False]
['text':' If we are considering field names, and the field names do not compare as equal,','line_number':1581,'multiline':False]
['text':' return the field name ordering as the element ordering.','line_number':1582,'multiline':False]
['text':' We are dealing with either two objects, or two arrays. We need to consider the child','line_number':1592,'multiline':False]
['text':' elements individually. We walk two iterators forward over the children and compare','line_number':1593,'multiline':False]
['text':' them. Length mismatches are handled by checking early for reaching the end of the','line_number':1594,'multiline':False]
['text':' children.','line_number':1595,'multiline':False]
['text':' If we have a representation as a BSONElement, we can just use BSONElement::woCompare','line_number':1623,'multiline':False]
['text':' to do the entire comparison.','line_number':1624,'multiline':False]
['text':' Leaf elements should always have a value, so we should only be dealing with Objects','line_number':1628,'multiline':False]
['text':' or Arrays here.','line_number':1629,'multiline':False]
['text':' Obtain the canonical types for this Element and the BSONElement, if they are','line_number':1632,'multiline':False]
['text':' different use the difference as the result. Please see BSONElement::woCompare for','line_number':1633,'multiline':False]
['text':' details. We know that thisRep is not a number, so we don't need to check that','line_number':1634,'multiline':False]
['text':' particular case.','line_number':1635,'multiline':False]
['text':' If we are considering field names, and the field names do not compare as equal,','line_number':1642,'multiline':False]
['text':' return the field name ordering as the element ordering.','line_number':1643,'multiline':False]
['text':' We are dealing with either two objects, or two arrays. We need to consider the child','line_number':1665,'multiline':False]
['text':' elements individually. We walk two iterators forward over the children and compare','line_number':1666,'multiline':False]
['text':' them. Length mismatches are handled by checking early for reaching the end of the','line_number':1667,'multiline':False]
['text':' children.','line_number':1668,'multiline':False]
['text':' If this is the root element, then we need to handle it differently, since it','line_number':1694,'multiline':False]
['text':' doesn't have a field name and should embed directly, rather than as an object.','line_number':1695,'multiline':False]
['text':' TODO: Alias check for binary data?','line_number':1769,'multiline':False]
['text':' Can't set to your own root element, since this would create a circular document.','line_number':1974,'multiline':False]
['text':' Setting to self is a no-op.','line_number':1980,'multiline':False]
['text':'','line_number':1981,'multiline':False]
['text':' Setting the root is always an error so we want to fall through to the error handling in this','line_number':1982,'multiline':False]
['text':' case.','line_number':1983,'multiline':False]
['text':' No need to invariant(ok()) since we are only called from methods that have done so.','line_number':2010,'multiline':False]
['text':' check that new element roots a clean subtree.','line_number':2019,'multiline':False]
['text':' Check that this element is eligible for children.','line_number':2023,'multiline':False]
['text':' TODO: In both of the following cases, we call two public API methods each. We can','line_number':2031,'multiline':False]
['text':' probably do better by writing this explicitly here and drying it with the public','line_number':2032,'multiline':False]
['text':' addSiblingLeft and addSiblingRight implementations.','line_number':2033,'multiline':False]
['text':' TODO: It is cheap to get the left child. However, it still means creating a rep','line_number':2035,'multiline':False]
['text':' for it. Can we do better?','line_number':2036,'multiline':False]
['text':' TODO: It is expensive to get the right child, since we have to build reps for','line_number':2041,'multiline':False]
['text':' all of the opaque children. But in principle, we don't really need them. Could','line_number':2042,'multiline':False]
['text':' we potentially add this element as a right child, leaving its left sibling','line_number':2043,'multiline':False]
['text':' opaque? We would at minimum need to update leftSibling, which currently assumes','line_number':2044,'multiline':False]
['text':' that your left sibling is never opaque. But adding new Elements to the end is a','line_number':2045,'multiline':False]
['text':' quite common operation, so it would be nice if we could do this efficiently.','line_number':2046,'multiline':False]
['text':' It must be the case that we have no children, so the new element becomes both the','line_number':2052,'multiline':False]
['text':' right and left child of this node.','line_number':2053,'multiline':False]
['text':' No need to invariant(ok()) since we are only called from methods that have done so.','line_number':2062,'multiline':False]
['text':' Establish our right sibling in case it is opaque. Otherwise, we would lose the','line_number':2070,'multiline':False]
['text':' ability to do so after the modifications below. It is important that this occur','line_number':2071,'multiline':False]
['text':' before we acquire thisRep and valueRep since otherwise we would potentially','line_number':2072,'multiline':False]
['text':' invalidate them.','line_number':2073,'multiline':False]
['text':' Get the BSONElement representations of the existing and new value, so we can','line_number':2080,'multiline':False]
['text':' check if they are size compatible.','line_number':2081,'multiline':False]
['text':' The old and new elements are size compatible. Compute the base offsets','line_number':2086,'multiline':False]
['text':' of each BSONElement in the object in which it resides. We use these to','line_number':2087,'multiline':False]
['text':' calculate the source and target offsets in the damage entries we are','line_number':2088,'multiline':False]
['text':' going to write.','line_number':2089,'multiline':False]
['text':' If this is a type change, record a damage event for the new type.','line_number':2097,'multiline':False]
['text':' Record a damage event for the new value data.','line_number':2105,'multiline':False]
['text':' We couldn't do it in place, so disable future in-place updates.','line_number':2110,'multiline':False]
['text':' If we are not rootish, then wire in the new value among our relations.','line_number':2115,'multiline':False]
['text':' Copy the rep for value to our slot so that our repIdx is unmodified.','line_number':2122,'multiline':False]
['text':' Be nice and clear out the source rep to make debugging easier.','line_number':2125,'multiline':False]
['text':' A helper for Element::writeElement below. For cases where we are building inside an','line_number':2135,'multiline':False]
['text':' array, we want to ignore field names. So the specialization for BSONArrayBuilder ignores','line_number':2136,'multiline':False]
['text':' the third parameter.','line_number':2137,'multiline':False]
['text':' BSONArrayBuilder should not be appending elements with a fieldName','line_number':2165,'multiline':False]
['text':' namespace','line_number':2173,'multiline':False]
['text':' Otherwise, this is a 'dirty leaf', which is impossible.','line_number':2188,'multiline':False]
['text':' TODO: In theory, I think we can walk rightwards building a write region from all','line_number':2205,'multiline':False]
['text':' serialized embedded children that share an obj id and form a contiguous memory','line_number':2206,'multiline':False]
['text':' region. For arrays we would need to know something about how many elements we wrote','line_number':2207,'multiline':False]
['text':' that way so that the indexes would come out right.','line_number':2208,'multiline':False]
['text':'','line_number':2209,'multiline':False]
['text':' However, that involves walking the memory twice: once to build the copy region, and','line_number':2210,'multiline':False]
['text':' another time to actually copy it. It is unclear if this is better than just walking','line_number':2211,'multiline':False]
['text':' it once with the recursive solution.','line_number':2212,'multiline':False]
['text':' OK, need to resolve left if we haven't done that yet.','line_number':2216,'multiline':False]
['text':' We need to write the element, and then walk rightwards.','line_number':2221,'multiline':False]
['text':' If we have an opaque region to the right, and we are not in an array, then we','line_number':2225,'multiline':False]
['text':' can bulk copy from the end of the element we just wrote to the end of our','line_number':2226,'multiline':False]
['text':' parent.','line_number':2227,'multiline':False]
['text':' Obtain the current parent, so we can see if we can bulk copy the right','line_number':2231,'multiline':False]
['text':' siblings.','line_number':2232,'multiline':False]
['text':' Bulk copying right only works on objects','line_number':2235,'multiline':False]
['text':' The -1 is because we don't want to copy in the terminal EOO.','line_number':2252,'multiline':False]
['text':' We are done with all children.','line_number':2255,'multiline':False]
['text':' We couldn't bulk copy, and our right sibling is opaque. We need to','line_number':2259,'multiline':False]
['text':' resolve. Note that the call to resolve may invalidate 'currentRep', so','line_number':2260,'multiline':False]
['text':' rather than falling through and acquiring the index by examining currentRep,','line_number':2261,'multiline':False]
['text':' update it with the return value of resolveRightSibling and restart the loop.','line_number':2262,'multiline':False]
['text':' Copy the provided values into the leaf builder.','line_number':2350,'multiline':False]
['text':' Copy the provided array values into the leaf builder.','line_number':2380,'multiline':False]
['text':' TODO: Alias check 'data'?','line_number':2398,'multiline':False]
['text':' Attempts to create an EOO element are translated to returning an invalid','line_number':2600,'multiline':False]
['text':' Element. For array and object nodes, we flow through the custom','line_number':2601,'multiline':False]
['text':' makeElement{Object|Array} methods, since they have special logic to deal with','line_number':2602,'multiline':False]
['text':' opaqueness. Otherwise, we can just insert via appendAs.','line_number':2603,'multiline':False]
['text':' See the above makeElement for notes on these cases.','line_number':2622,'multiline':False]
['text':' Return an invalid element to indicate that we failed.','line_number':2653,'multiline':False]
['text':' A BSONObj provided for the root Element is stored in _objects rather than being','line_number':2675,'multiline':False]
['text':' copied like all other BSONObjs.','line_number':2676,'multiline':False]
['text':' Strictly, the following is a lie: the root isn't serialized, because it doesn't','line_number':2680,'multiline':False]
['text':' have a contiguous fieldname. However, it is a useful fiction to pretend that it','line_number':2681,'multiline':False]
['text':' is, so we can easily check if we have a 'pristine' document state by checking if','line_number':2682,'multiline':False]
['text':' the root is marked as serialized.','line_number':2683,'multiline':False]
['text':' If the provided value is empty, mark it as having no children, otherwise mark the','line_number':2686,'multiline':False]
['text':' children as opaque.','line_number':2687,'multiline':False]
['text':' If the Element that we want to build from belongs to this Document, then we have','line_number':2701,'multiline':False]
['text':' to first copy it to the side, and then back in, since otherwise we might be','line_number':2702,'multiline':False]
['text':' attempting both read to and write from the underlying BufBuilder simultaneously,','line_number':2703,'multiline':False]
['text':' which will not work.','line_number':2704,'multiline':False]
['text':' If the Element belongs to another document, then we can just stream it into our','line_number':2712,'multiline':False]
['text':' builder. We still do need to dassert that the field name doesn't alias us','line_number':2713,'multiline':False]
['text':' somehow.','line_number':2714,'multiline':False]
['text':' Don't use unique_ptr<Impl>::operator* since it may generate assertions that the','line_number':2731,'multiline':False]
['text':' pointer is non-null, but we already know that to be always and forever true, and','line_number':2732,'multiline':False]
['text':' otherwise the assertion code gets spammed into every method that inlines the call to','line_number':2733,'multiline':False]
['text':' this function. We just dereference the pointer returned from 'get' ourselves.','line_number':2734,'multiline':False]
['text':' namespace mutablebson','line_number':2742,'multiline':False]
['text':' namespace mongo','line_number':2743,'multiline':False]
