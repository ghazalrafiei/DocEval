['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' Used to set RollbackImpl::_newCounts to force a collection scan to fix count.','line_number':145,'multiline':False]
['text':' The name of the insert, update and delete commands as found in oplog command entries.','line_number':150,'multiline':False]
['text':'*
 * Parses the o2 field of a drop or rename oplog entry for the count of the collection that was
 * dropped.
 ','line_number':160,'multiline':True]
['text':' TODO: Use IDL to parse o2 object. See txn_cmds.idl for example.','line_number':178,'multiline':False]
['text':' namespace','line_number':207,'multiline':False]
['text':' We clear the SizeRecoveryState before we recover to a stable timestamp. This ensures that we','line_number':270,'multiline':False]
['text':' only use size adjustment markings from the storage and replication recovery processes in this','line_number':271,'multiline':False]
['text':' rollback.','line_number':272,'multiline':False]
['text':' After successfully transitioning to the ROLLBACK state, we must always transition back to','line_number':275,'multiline':False]
['text':' SECONDARY, even if we fail at any point during the rollback process.','line_number':276,'multiline':False]
['text':' Now that we have found the common point, we make sure to proceed only if the rollback','line_number':290,'multiline':False]
['text':' period is not too long.','line_number':291,'multiline':False]
['text':' Increment the Rollback ID of this node. The Rollback ID is a natural number that it is','line_number':297,'multiline':False]
['text':' incremented by 1 every time a rollback occurs. Note that the Rollback ID must be incremented','line_number':298,'multiline':False]
['text':' before modifying any local data.','line_number':299,'multiline':False]
['text':' This function cannot fail without terminating the process.','line_number':307,'multiline':False]
['text':' We can now accept interruptions again.','line_number':311,'multiline':False]
['text':' At this point, the last applied and durable optimes on this node still point to ops on','line_number':316,'multiline':False]
['text':' the divergent branch of history. We therefore update the last optimes to the top of the','line_number':317,'multiline':False]
['text':' oplog, which should now be at the common point.','line_number':318,'multiline':False]
['text':' Don't kill the rollback thread.','line_number':358,'multiline':False]
['text':' Update the metrics for tracking user operations during state transitions.','line_number':370,'multiline':False]
['text':' Kill all user operations to ensure we can successfully acquire the RSTL. Since the node','line_number':389,'multiline':False]
['text':' must be a secondary, this is only killing readers, whose connections will be closed','line_number':390,'multiline':False]
['text':' shortly regardless.','line_number':391,'multiline':False]
['text':' Aborts all active, two-phase index builds.','line_number':417,'multiline':False]
['text':' Get a list of all databases.','line_number':421,'multiline':False]
['text':' Wait for all background operations to complete by waiting on each database. Single-phase','line_number':429,'multiline':False]
['text':' index builds are not stopped before rollback, so we must wait for these index builds to','line_number':430,'multiline':False]
['text':' complete.','line_number':431,'multiline':False]
['text':' No namespaces for a no-op.','line_number':454,'multiline':False]
['text':' CRUD ops have the proper namespace in the operation 'ns' field.','line_number':459,'multiline':False]
['text':' If the operation is a command, then we need to extract the appropriate namespaces from the','line_number':465,'multiline':False]
['text':' command object, as opposed to just using the 'ns' field of the oplog entry itself.','line_number':466,'multiline':False]
['text':' Does not handle 'applyOps' entries.','line_number':471,'multiline':False]
['text':' Add both the 'from' and 'to' namespaces.','line_number':477,'multiline':False]
['text':' There is no specific namespace to save for a drop database operation.','line_number':489,'multiline':False]
['text':' These commands do not need to be supported by rollback. 'convertToCapped' should','line_number':494,'multiline':False]
['text':' always be converted to lower level DDL operations, and 'emptycapped' is a','line_number':495,'multiline':False]
['text':' test-only command.','line_number':496,'multiline':False]
['text':' For all other command types, we should be able to parse the collection name from','line_number':514,'multiline':False]
['text':' the first command argument.','line_number':515,'multiline':False]
['text':' Every possible command type should be handled above.','line_number':530,'multiline':False]
['text':' Query for retryable writes oplog entries with a non-null 'prevWriteOpTime' value','line_number':541,'multiline':False]
['text':' less than or equal to the 'stableTimestamp'. This query intends to include no-op','line_number':542,'multiline':False]
['text':' retryable writes oplog entries that have been applied through a migration process.','line_number':543,'multiline':False]
['text':' We use the 'fromMigrate' field to differentiate migrated retryable writes entries from','line_number':547,'multiline':False]
['text':' transactions entries.','line_number':548,'multiline':False]
['text':' This is a retryable writes oplog entry with a non-null 'prevWriteOpTime' value that','line_number':571,'multiline':False]
['text':' is less than or equal to the 'stableTimestamp'.','line_number':572,'multiline':False]
['text':' It's possible that the next entry in the oplog chain has been truncated due to','line_number':588,'multiline':False]
['text':' oplog cap maintenance.','line_number':589,'multiline':False]
['text':' Perform an untimestamped write so that it will not be rolled back on recovering','line_number':606,'multiline':False]
['text':' to the 'stableTimestamp' if we were to crash. This is safe because this update is','line_number':607,'multiline':False]
['text':' meant to be consistent with the 'stableTimestamp' and not the common point.','line_number':608,'multiline':False]
['text':'fromMigrate=','line_number':610,'multiline':True]
['text':' Take a stable checkpoint so that writes to the 'config.transactions' table are','line_number':613,'multiline':False]
['text':' persisted to disk before truncating the oplog. If we were to take an unstable checkpoint, we','line_number':614,'multiline':False]
['text':' would have to update replication metadata like 'minValid.appliedThrough' to be consistent','line_number':615,'multiline':False]
['text':' with the oplog.','line_number':616,'multiline':False]
['text':'stableCheckpoint=','line_number':618,'multiline':True]
['text':' Stop and wait for all background index builds to complete before starting the rollback','line_number':623,'multiline':False]
['text':' process.','line_number':624,'multiline':False]
['text':' Before computing record store counts, abort all active transactions. This ensures that','line_number':628,'multiline':False]
['text':' the count adjustments are based on correct values where no prepared transactions are','line_number':629,'multiline':False]
['text':' active and all in-memory counts have been rolled-back.','line_number':630,'multiline':False]
['text':' Before calling recoverToStableTimestamp, we must abort the storage transaction of any','line_number':631,'multiline':False]
['text':' prepared transaction. This will require us to scan all sessions and call','line_number':632,'multiline':False]
['text':' abortPreparedTransactionForRollback() on any txnParticipant with a prepared transaction.','line_number':633,'multiline':False]
['text':' Top-level prepared transactions could have been split during secondary oplog application.','line_number':636,'multiline':False]
['text':' killSessionsAbortAllPreparedTransactions iterates the session catalog and aborts all the','line_number':637,'multiline':False]
['text':' split transactions as well as the top-level transactions. After that we need to release','line_number':638,'multiline':False]
['text':' all the split sessions tracked by SplitPrepareSessionManager.','line_number':639,'multiline':False]
['text':' Ask the record store for the pre-rollback counts of any collections whose counts will','line_number':642,'multiline':False]
['text':' change and create a map with the adjusted counts for post-rollback. While finding the','line_number':643,'multiline':False]
['text':' common point, we keep track of how much each collection's count will change during the','line_number':644,'multiline':False]
['text':' rollback. Note: these numbers are relative to the common point, not the stable timestamp,','line_number':645,'multiline':False]
['text':' and thus must be set after recovering from the oplog.','line_number':646,'multiline':False]
['text':' Write a rollback file for each namespace that has documents that would be deleted by','line_number':651,'multiline':False]
['text':' rollback. We need to do this after aborting prepared transactions. Otherwise, we risk','line_number':652,'multiline':False]
['text':' unecessary prepare conflicts when trying to read documents that were modified by','line_number':653,'multiline':False]
['text':' those prepared transactions, which we know we will abort anyway.','line_number':654,'multiline':False]
['text':' If there were rolled back operations on any session, invalidate all sessions.','line_number':661,'multiline':False]
['text':' We invalidate sessions before we recover so that we avoid invalidating sessions that had','line_number':662,'multiline':False]
['text':' just recovered prepared transactions.','line_number':663,'multiline':False]
['text':' Recover to the stable timestamp.','line_number':669,'multiline':False]
['text':' Log the total number of insert and update operations that have been rolled back as a','line_number':675,'multiline':False]
['text':' result of recovering to the stable timestamp.','line_number':676,'multiline':False]
['text':' Retryable writes create derived updates to the transactions table which can be coalesced into','line_number':690,'multiline':False]
['text':' one operation, so certain session operations history may be lost after restoring to the','line_number':691,'multiline':False]
['text':' 'stableTimestamp'. We must scan the oplog and restore the transactions table entries to','line_number':692,'multiline':False]
['text':' detail the last executed writes.','line_number':693,'multiline':False]
['text':' During replication recovery, we truncate all oplog entries with timestamps greater than the','line_number':696,'multiline':False]
['text':' oplog truncate after point. If we entered rollback, we are guaranteed to have at least one','line_number':697,'multiline':False]
['text':' oplog entry after the common point.','line_number':698,'multiline':False]
['text':' Persist the truncate point to the 'oplogTruncateAfterPoint' document. We save this value so','line_number':704,'multiline':False]
['text':' that the replication recovery logic knows where to truncate the oplog. We save this value','line_number':705,'multiline':False]
['text':' durably to match the behavior during startup recovery. This must occur after we successfully','line_number':706,'multiline':False]
['text':' recover to a stable timestamp. If recovering to a stable timestamp fails and we still','line_number':707,'multiline':False]
['text':' truncate the oplog then the oplog will not match the data files. If we crash at any earlier','line_number':708,'multiline':False]
['text':' point, we will recover, find a new sync source, and restart roll back (if necessary on the','line_number':709,'multiline':False]
['text':' new sync source). This is safe because a crash before this point would recover to a stable','line_number':710,'multiline':False]
['text':' checkpoint anyways at or earlier than the stable timestamp.','line_number':711,'multiline':False]
['text':'','line_number':712,'multiline':False]
['text':' Note that storage engine timestamp recovery only restores the database *data* to a stable','line_number':713,'multiline':False]
['text':' timestamp, but does not revert the oplog, which must be done as part of the rollback process.','line_number':714,'multiline':False]
['text':' Align the drop pending reaper state with what's on disk. Oplog recovery depends on those','line_number':719,'multiline':False]
['text':' being consistent.','line_number':720,'multiline':False]
['text':' Run the recovery process.','line_number':723,'multiline':False]
['text':' Sets the correct post-rollback counts on any collections whose counts changed during the','line_number':727,'multiline':False]
['text':' rollback.','line_number':728,'multiline':False]
['text':' Reconstruct prepared transactions after counts have been adjusted. Since prepared','line_number':736,'multiline':False]
['text':' transactions were aborted (i.e. the in-memory counts were rolled-back) before computing','line_number':737,'multiline':False]
['text':' collection counts, reconstruct the prepared transactions now, adding on any additional counts','line_number':738,'multiline':False]
['text':' to the now corrected record store.','line_number':739,'multiline':False]
['text':' This function explicitly does not check for shutdown since a clean shutdown post oplog','line_number':744,'multiline':False]
['text':' truncation is not allowed to occur until the record store counts are corrected.','line_number':745,'multiline':False]
['text':' If the collection is marked for size adjustment, then we made sure the collection size','line_number':761,'multiline':False]
['text':' was accurate at the stable timestamp and we can trust replication recovery to keep it','line_number':762,'multiline':False]
['text':' correct. This is necessary for capped collections whose deletions will be untracked','line_number':763,'multiline':False]
['text':' if we just set the collection count here.','line_number':764,'multiline':False]
['text':' If _findRecordStoreCounts() is unable to determine the correct count from the oplog','line_number':778,'multiline':False]
['text':' (most likely due to a 4.0 drop oplog entry without the count information), we will','line_number':779,'multiline':False]
['text':' determine the correct count here post-recovery using a collection scan.','line_number':780,'multiline':False]
['text':' We ignore errors here because crashing or leaving rollback would only leave','line_number':801,'multiline':False]
['text':' collection counts more inaccurate.','line_number':802,'multiline':False]
['text':' We ignore errors here because crashing or leaving rollback would only leave','line_number':816,'multiline':False]
['text':' collection counts more inaccurate.','line_number':817,'multiline':False]
['text':' Drop-pending collections are not visible to rollback via the catalog when they are','line_number':852,'multiline':False]
['text':' managed by the storage engine. See StorageEngine::supportsPendingDrops().','line_number':853,'multiline':False]
['text':'*
 * Process a single oplog entry that is getting rolled back and update the necessary rollback info
 * structures.
 ','line_number':920,'multiline':True]
['text':' For applyOps entries, we process each sub-operation individually.','line_number':930,'multiline':False]
['text':' Uncommitted prepared transactions are always aborted before rollback begins, which','line_number':933,'multiline':False]
['text':' rolls back collection counts. Processing the operation here would result in','line_number':934,'multiline':False]
['text':' double-counting the sub-operations when correcting collection counts later.','line_number':935,'multiline':False]
['text':' Additionally, this logic makes an assumption that transactions are only ever','line_number':936,'multiline':False]
['text':' committed when the prepare operation is majority committed. This implies that when a','line_number':937,'multiline':False]
['text':' prepare oplog entry is rolled-back, it is guaranteed that it has never committed.','line_number':938,'multiline':False]
['text':' This oplog entry will be processed when we rollback the implicit commit for the','line_number':942,'multiline':False]
['text':' unprepared transaction (applyOps without partialTxn field).','line_number':943,'multiline':False]
['text':' Follow chain on applyOps oplog entries to process entire unprepared transaction.','line_number':946,'multiline':False]
['text':' The beginning of the applyOps chain may precede the common point.','line_number':947,'multiline':False]
['text':' No information to record for a no-op.','line_number':957,'multiline':False]
['text':' Extract the appropriate namespaces from the oplog operation.','line_number':962,'multiline':False]
['text':' If the operation being rolled back has a session id, then we add it to the set of','line_number':971,'multiline':False]
['text':' sessions that had operations rolled back.','line_number':972,'multiline':False]
['text':' Keep track of the _ids of inserted and updated documents, as we may need to write them out to','line_number':979,'multiline':False]
['text':' a rollback file.','line_number':980,'multiline':False]
['text':' As global indexes currently lack support for multi-key, a key can be uniquely','line_number':989,'multiline':False]
['text':' identified by its document key, which maps the _id field in the global index','line_number':990,'multiline':False]
['text':' container (collection).','line_number':991,'multiline':False]
['text':' We call BSONElement::wrap() on each _id element to create a new BSONObj with an owned','line_number':997,'multiline':False]
['text':' buffer, as the underlying storage may be gone when we access this map to write','line_number':998,'multiline':False]
['text':' rollback files.','line_number':999,'multiline':False]
['text':' Check if the creation of the shard identity document is being rolled back.','line_number':1011,'multiline':False]
['text':' Check if the creation of the config server config version document is being rolled','line_number':1018,'multiline':False]
['text':' back.','line_number':1019,'multiline':False]
['text':' Rolling back an insert must decrement the count by 1.','line_number':1026,'multiline':False]
['text':' Rolling back a delete must increment the count by 1.','line_number':1029,'multiline':False]
['text':' If we roll back a create, then we do not need to change the size of that uuid.','line_number':1034,'multiline':False]
['text':' Nothing to roll back if this is a dryRun.','line_number':1041,'multiline':False]
['text':' If we roll back an import, then we do not need to change the size of that uuid.','line_number':1049,'multiline':False]
['text':' The collection count at collection drop time is op-logged in the 'o2' field.','line_number':1056,'multiline':False]
['text':' In the common case where the drop-pending collection is managed by the storage','line_number':1057,'multiline':False]
['text':' engine, the collection metadata - including the number of records at drop time -','line_number':1058,'multiline':False]
['text':' is not accessible through the catalog.','line_number':1059,'multiline':False]
['text':' Keep track of the record count stored in the 'o2' field via the _newCounts variable.','line_number':1060,'multiline':False]
['text':' This allows for cheaply restoring the collection count post rollback without an','line_number':1061,'multiline':False]
['text':' expensive collection scan.','line_number':1062,'multiline':False]
['text':' If we roll back a rename with a dropped target collection, parse the o2 field for the','line_number':1080,'multiline':False]
['text':' target collection count for use later by _findRecordStoreCounts().','line_number':1081,'multiline':False]
['text':' This will be used to reconcile collection counts in the case where the drop-pending','line_number':1082,'multiline':False]
['text':' collection is managed by the storage engine and is not accessible through the UUID','line_number':1083,'multiline':False]
['text':' catalog.','line_number':1084,'multiline':False]
['text':' Adding a _newCounts entry ensures that the count will be set after the rollback.','line_number':1085,'multiline':False]
['text':' If we are rolling-back the commit of a prepared transaction, use the prepare oplog','line_number':1108,'multiline':False]
['text':' entry to compute size adjustments. After recovering to the stable timestamp, prepared','line_number':1109,'multiline':False]
['text':' transactions are reconstituted and any count adjustments will be replayed and','line_number':1110,'multiline':False]
['text':' committed again.','line_number':1111,'multiline':False]
['text':' Keep count of major commands that will be rolled back.','line_number':1128,'multiline':False]
['text':' Roll back operations in reverse order in order to account for non-commutative','line_number':1150,'multiline':False]
['text':' members of applyOps (e.g., commands inside of multi-document transactions).','line_number':1151,'multiline':False]
['text':' We save some aggregate information about all operations that are rolled back, so that we can','line_number':1174,'multiline':False]
['text':' pass this information to the rollback op observer. In most cases, other subsystems do not','line_number':1175,'multiline':False]
['text':' need to know extensive details about every operation that rolled back, so to reduce','line_number':1176,'multiline':False]
['text':' complexity by adding observer methods for every operation type, we provide a set of','line_number':1177,'multiline':False]
['text':' information that should be suitable for most other subsystems to take the necessary actions','line_number':1178,'multiline':False]
['text':' on a rollback event. This rollback info is kept in memory, so if we crash after we collect','line_number':1179,'multiline':False]
['text':' it, it may be lost. However, if we crash any time between recovering to a stable timestamp','line_number':1180,'multiline':False]
['text':' and completing oplog recovery, we assume that this information is not needed, since the node','line_number':1181,'multiline':False]
['text':' restarting will have cleared out any invalid in-memory state anyway.','line_number':1182,'multiline':False]
['text':' Calls syncRollBackLocalOperations to find the common point and run onLocalOplogEntryFn on','line_number':1188,'multiline':False]
['text':' each oplog entry up until the common point. We only need the Timestamp of the common point','line_number':1189,'multiline':False]
['text':' for the oplog truncate after point. Along the way, we save some information about the','line_number':1190,'multiline':False]
['text':' rollback ops.','line_number':1191,'multiline':False]
['text':' This failpoint is used for testing the invariant below.','line_number':1206,'multiline':False]
['text':' Rollback common point should be >= the replication commit point.','line_number':1214,'multiline':False]
['text':' Rollback common point should be >= the committed snapshot optime.','line_number':1218,'multiline':False]
['text':' Rollback common point should be >= the stable timestamp.','line_number':1222,'multiline':False]
['text':' This is an fassert rather than an invariant, since it can happen if the server was','line_number':1225,'multiline':False]
['text':' recently upgraded to enableMajorityReadConcern=true.','line_number':1226,'multiline':False]
['text':' We check the difference between the top of the oplog and the first oplog entry after the','line_number':1254,'multiline':False]
['text':' common point when computing the rollback time limit.','line_number':1255,'multiline':False]
['text':' Drop-pending collections are not visible to rollback via the catalog when they are','line_number':1315,'multiline':False]
['text':' managed by the storage engine. See StorageEngine::supportsPendingDrops().','line_number':1316,'multiline':False]
['text':' The RemoveSaver will save the data files in a directory structure similar to the following:','line_number':1346,'multiline':False]
['text':'','line_number':1347,'multiline':False]
['text':'     rollback','line_number':1348,'multiline':False]
['text':'     ├── uuid','line_number':1349,'multiline':False]
['text':'     │   └── removed.2018-03-20T20-23-01.21.bson','line_number':1350,'multiline':False]
['text':'     ├── otheruuid','line_number':1351,'multiline':False]
['text':'     │   ├── removed.2018-03-20T20-23-01.18.bson','line_number':1352,'multiline':False]
['text':'     │   └── removed.2018-03-20T20-23-01.19.bson','line_number':1353,'multiline':False]
['text':'','line_number':1354,'multiline':False]
['text':' If this is the first data directory created, we save the full directory path in','line_number':1355,'multiline':False]
['text':' _rollbackStats. Otherwise, we store the longest common prefix of the two directories.','line_number':1356,'multiline':False]
['text':' StorageInterface::findById() does not respect the collation, but because we are using','line_number':1371,'multiline':False]
['text':' exact _id fields recorded in the oplog, we can get away with binary string','line_number':1372,'multiline':False]
['text':' comparisons.','line_number':1373,'multiline':False]
['text':' Recover to the stable timestamp while holding the global exclusive lock. This may throw,','line_number':1383,'multiline':False]
['text':' which the caller must handle.','line_number':1384,'multiline':False]
['text':' Reset the drop pending reaper state prior to recovering to the stable timestamp, which','line_number':1387,'multiline':False]
['text':' re-opens the catalog and can add drop pending idents. This prevents collisions with idents','line_number':1388,'multiline':False]
['text':' already registered with the reaper.','line_number':1389,'multiline':False]
['text':' Any exceptions thrown from onReplicationRollback() indicates a rollback failure that may','line_number':1402,'multiline':False]
['text':' have led us to some inconsistent on-disk or memory state, so we crash instead.','line_number':1403,'multiline':False]
['text':' It is possible that this node has actually been removed due to a reconfig via','line_number':1416,'multiline':False]
['text':' heartbeat during rollback. But it should be fine to transition to SECONDARY','line_number':1417,'multiline':False]
['text':' and this won't change how the node reports its member state since topology','line_number':1418,'multiline':False]
['text':' coordinator will always check if the node exists in its local config when','line_number':1419,'multiline':False]
['text':' returning member state.','line_number':1420,'multiline':False]
['text':' TODO(SERVER-38671): Remove this line when drop-pending idents are always supported with this','line_number':1437,'multiline':False]
['text':' rolback method. Until then, we should assume that pending drops can be handled by either the','line_number':1438,'multiline':False]
['text':' replication subsystem or the storage engine.','line_number':1439,'multiline':False]
['text':' namespace repl','line_number':1496,'multiline':False]
['text':' namespace mongo','line_number':1497,'multiline':False]
