['text':'*
 *    Copyright (C) 2019-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: keep','line_number':64,'multiline':False]
['text':'
 * This table must be kept in sync with Instruction::Tags. It encodes how the instruction affects
 * the stack; i.e. push(+1), pop(-1), or no effect.
 ','line_number':114,'multiline':True]
['text':' pushConstVal','line_number':119,'multiline':False]
['text':' pushAccessVal','line_number':120,'multiline':False]
['text':' pushOwnedAccessorVal','line_number':121,'multiline':False]
['text':' pushEnvAccessorVal','line_number':122,'multiline':False]
['text':' pushMoveVal','line_number':123,'multiline':False]
['text':' pushLocalVal','line_number':124,'multiline':False]
['text':' pushMoveLocalVal','line_number':125,'multiline':False]
['text':' pushLocalLambda','line_number':126,'multiline':False]
['text':' pop','line_number':127,'multiline':False]
['text':' swap','line_number':128,'multiline':False]
['text':' add','line_number':130,'multiline':False]
['text':' sub','line_number':131,'multiline':False]
['text':' mul','line_number':132,'multiline':False]
['text':' div','line_number':133,'multiline':False]
['text':' idiv','line_number':134,'multiline':False]
['text':' mod','line_number':135,'multiline':False]
['text':' negate','line_number':136,'multiline':False]
['text':' numConvert','line_number':137,'multiline':False]
['text':' logicNot','line_number':139,'multiline':False]
['text':' less','line_number':141,'multiline':False]
['text':' lessEq','line_number':142,'multiline':False]
['text':' greater','line_number':143,'multiline':False]
['text':' greaterEq','line_number':144,'multiline':False]
['text':' eq','line_number':145,'multiline':False]
['text':' neq','line_number':146,'multiline':False]
['text':' cmp3w','line_number':147,'multiline':False]
['text':' collLess','line_number':149,'multiline':False]
['text':' collLessEq','line_number':150,'multiline':False]
['text':' collGreater','line_number':151,'multiline':False]
['text':' collGreaterEq','line_number':152,'multiline':False]
['text':' collEq','line_number':153,'multiline':False]
['text':' collNeq','line_number':154,'multiline':False]
['text':' collCmp3w','line_number':155,'multiline':False]
['text':' fillEmpty','line_number':157,'multiline':False]
['text':' fillEmptyImm','line_number':158,'multiline':False]
['text':' getField','line_number':159,'multiline':False]
['text':' getFieldImm','line_number':160,'multiline':False]
['text':' getElement','line_number':161,'multiline':False]
['text':' collComparisonKey','line_number':162,'multiline':False]
['text':' getFieldOrElement','line_number':163,'multiline':False]
['text':' traverseP','line_number':164,'multiline':False]
['text':' traversePImm','line_number':165,'multiline':False]
['text':' traverseF','line_number':166,'multiline':False]
['text':' traverseFImm','line_number':167,'multiline':False]
['text':' traverseCsiCellValues','line_number':168,'multiline':False]
['text':' traverseCsiCellTypes','line_number':169,'multiline':False]
['text':' setField','line_number':170,'multiline':False]
['text':' getArraySize','line_number':171,'multiline':False]
['text':' aggSum','line_number':173,'multiline':False]
['text':' aggMin','line_number':174,'multiline':False]
['text':' aggMax','line_number':175,'multiline':False]
['text':' aggFirst','line_number':176,'multiline':False]
['text':' aggLast','line_number':177,'multiline':False]
['text':' aggCollMin','line_number':179,'multiline':False]
['text':' aggCollMax','line_number':180,'multiline':False]
['text':' exists','line_number':182,'multiline':False]
['text':' isNull','line_number':183,'multiline':False]
['text':' isObject','line_number':184,'multiline':False]
['text':' isArray','line_number':185,'multiline':False]
['text':' isInListData','line_number':186,'multiline':False]
['text':' isString','line_number':187,'multiline':False]
['text':' isNumber','line_number':188,'multiline':False]
['text':' isBinData','line_number':189,'multiline':False]
['text':' isDate','line_number':190,'multiline':False]
['text':' isNaN','line_number':191,'multiline':False]
['text':' isInfinity','line_number':192,'multiline':False]
['text':' isRecordId','line_number':193,'multiline':False]
['text':' isMinKey','line_number':194,'multiline':False]
['text':' isMaxKey','line_number':195,'multiline':False]
['text':' isTimestamp','line_number':196,'multiline':False]
['text':' typeMatchImm','line_number':197,'multiline':False]
['text':' function is special, the stack offset is encoded in the instruction itself','line_number':199,'multiline':False]
['text':' functionSmall is special, the stack offset is encoded in the instruction itself','line_number':200,'multiline':False]
['text':' jmp','line_number':202,'multiline':False]
['text':' jmpTrue','line_number':203,'multiline':False]
['text':' jmpFalse','line_number':204,'multiline':False]
['text':' jmpNothing','line_number':205,'multiline':False]
['text':' jmpNotNothing','line_number':206,'multiline':False]
['text':' ret','line_number':207,'multiline':False]
['text':' allocStack does not affect the top of stack','line_number':208,'multiline':False]
['text':' fail','line_number':210,'multiline':False]
['text':' dateTruncImm','line_number':212,'multiline':False]
['text':' valueBlockApplyLambda','line_number':214,'multiline':False]
['text':' Get the stack delta from a table.','line_number':236,'multiline':False]
['text':' And adjust it by parameters coming from frames.','line_number':238,'multiline':False]
['text':' Only if we grow the stack can we affect the maximum size.','line_number':243,'multiline':False]
['text':' 'pop' means that the location we're reading from is a temporary value on the VM stack','line_number':455,'multiline':False]
['text':' (i.e. not a local variable) and that it needs to be popped off the stack immediately','line_number':456,'multiline':False]
['text':' after we read it.','line_number':457,'multiline':False]
['text':' 'moveFrom' means that the location we're reading from is eligible to be the right hand','line_number':460,'multiline':False]
['text':' side of a "move assignment" (i.e. it's an "rvalue reference"). If 'pop' is true, then','line_number':461,'multiline':False]
['text':' 'moveFrom' must always be true as well.','line_number':462,'multiline':False]
['text':' If the parameter is not coming from a frame then we have to pop it off the stack once the','line_number':465,'multiline':False]
['text':' instruction is done.','line_number':466,'multiline':False]
['text':' Compute the absolute variable stack offset based on the current stack depth and pop','line_number':474,'multiline':False]
['text':' compensation.','line_number':475,'multiline':False]
['text':' If frame has stackPositiion defined, then compute the final relative stack offset.','line_number':478,'multiline':False]
['text':' Otherwise, register a fixup to compute the relative stack offset later.','line_number':479,'multiline':False]
['text':' Fixup all stack offsets before copying.','line_number':497,'multiline':False]
['text':' Fixup all stack offsets before copying.','line_number':513,'multiline':False]
['text':' Compute the absolute variable stack offset based on the current stack depth','line_number':575,'multiline':False]
['text':' If frame has stackPositiion defined, then compute the final relative stack offset.','line_number':578,'multiline':False]
['text':' Otherwise, register a fixup to compute the relative stack offset later.','line_number':579,'multiline':False]
['text':' For every parameter that is popped (i.e. not coming from a frame) we have to compensate frame','line_number':694,'multiline':False]
['text':' offsets.','line_number':695,'multiline':False]
['text':' Account for consumed arguments','line_number':1021,'multiline':False]
['text':' and the return value.','line_number':1023,'multiline':False]
['text':' Fixup will compute the relative jump as if it was done from the fixup offset itself,','line_number':1073,'multiline':False]
['text':' so initialize jumpOffset with the difference between jump offset and the end of','line_number':1074,'multiline':False]
['text':' instruction.','line_number':1075,'multiline':False]
['text':' Skip document length.','line_number':1128,'multiline':False]
['text':' We need to ensure that 'size_t' is wide enough to store 32-bit index.','line_number':1148,'multiline':False]
['text':' Upcast 'idxInt32' to 'int64_t' prevent overflow during the sign change.','line_number':1164,'multiline':False]
['text':' If 'arr' is an SBE array, use Array::getAt() to retrieve the element at index 'idx'.','line_number':1171,'multiline':False]
['text':' Loop through array until we meet element at position 'idx'.','line_number':1189,'multiline':False]
['text':' If the array didn't have an element at index 'idx', return Nothing.','line_number':1195,'multiline':False]
['text':' For negative indexes we use two pointers approach. We start two array enumerators at the','line_number':1203,'multiline':False]
['text':' distance of 'idx' and move them at the same time. Once one of the enumerators reaches the','line_number':1204,'multiline':False]
['text':' end of the array, the second one points to the element at position '-idx'.','line_number':1205,'multiline':False]
['text':'','line_number':1206,'multiline':False]
['text':' First, move one of the enumerators 'idx' elements forward.','line_number':1207,'multiline':False]
['text':' Array is too small to have an element at the requested index.','line_number':1215,'multiline':False]
['text':' Initiate second enumerator at the start of the array. Now the distance between','line_number':1219,'multiline':False]
['text':' 'enumerator' and 'windowEndEnumerator' is exactly 'idx' elements. Move both enumerators','line_number':1220,'multiline':False]
['text':' until the first one reaches the end of the array.','line_number':1221,'multiline':False]
['text':' Earlier in this function we bailed out if the 'arrTag' wasn't Array, ArraySet or','line_number':1233,'multiline':False]
['text':' bsonArray, so it should be impossible to reach this point.','line_number':1234,'multiline':False]
['text':' If this is an array and we can convert the "field name" to a reasonable number then treat','line_number':1244,'multiline':False]
['text':' this as getElement call.','line_number':1245,'multiline':False]
['text':' Traverse a projection path - evaluate the input lambda on every element of the input array.','line_number':1260,'multiline':False]
['text':' The traversal is recursive; i.e. we visit nested arrays if any.','line_number':1261,'multiline':False]
['text':' Traverse a filter path - evaluate the input lambda (predicate) on every element of the input','line_number':1334,'multiline':False]
['text':' array without recursion.','line_number':1335,'multiline':False]
['text':' If this is a filter over a number path then run over the whole array. More details in','line_number':1395,'multiline':False]
['text':' SERVER-27442.','line_number':1396,'multiline':False]
['text':' Transfer the ownership to the lambda','line_number':1398,'multiline':False]
['text':' If there are no doubly-nested arrays, we can avoid parsing the array info and use the simple','line_number':1417,'multiline':False]
['text':' cursor over all values in the cell.','line_number':1418,'multiline':False]
['text':' The value is too deep.','line_number':1439,'multiline':False]
['text':' When traversing cell types cannot use the simple cursor even if the cell doesn't contain','line_number':1464,'multiline':False]
['text':' doubly-nested arrays because must report types of objects and arrays and for that need to','line_number':1465,'multiline':False]
['text':' parse the array info.','line_number':1466,'multiline':False]
['text':' The dummy array/object are needed when running lambda on the type on non-empty arrays and','line_number':1473,'multiline':False]
['text':' objects. We allocate them on the stack because these values are only used in the scope of','line_number':1474,'multiline':False]
['text':' this traversal and discarded after evaluating the lambda.','line_number':1475,'multiline':False]
['text':' There is nesting on the path.','line_number':1485,'multiline':False]
['text':' Empty arrays are stored in columnstore cells as values and don't require special','line_number':1490,'multiline':False]
['text':' handling. All other arrays can be detected when their first value is seen. To apply','line_number':1491,'multiline':False]
['text':' the lambda to the leaf array type we inject a "fake" array here as the caller should','line_number':1492,'multiline':False]
['text':' only look at the returned type. Note, that we might still need to process the values','line_number':1493,'multiline':False]
['text':' inside the array.','line_number':1494,'multiline':False]
['text':' The value is inside a nested array at the leaf.','line_number':1506,'multiline':False]
['text':' Apply lambda to the types of values at the leaf.','line_number':1513,'multiline':False]
['text':' Consider using a moveFromStack optimization.','line_number':1528,'multiline':False]
['text':' Setting a field value to nothing means removing the field.','line_number':1538,'multiline':False]
['text':' Skip document length.','line_number':1548,'multiline':False]
['text':' Removing field from non-object value hardly makes any sense.','line_number':1576,'multiline':False]
['text':' New value is not Nothing. We will be returning a new Object no matter what.','line_number':1580,'multiline':False]
['text':' Skip document length.','line_number':1589,'multiline':False]
['text':' Skip aggregation step if we don't have the input.','line_number':1660,'multiline':False]
['text':' Initialize the accumulator.','line_number':1666,'multiline':False]
['text':' The order of the following three elements should match to 'AggSumValueElems'. An absent','line_number':1677,'multiline':False]
['text':' 'kDecimalTotal' element means that we've not seen any decimal value. So, we're not adding','line_number':1678,'multiline':False]
['text':' 'kDecimalTotal' element yet.','line_number':1679,'multiline':False]
['text':' Move the incoming accumulator state from the stack. Given that we are now the owner of the','line_number':1701,'multiline':False]
['text':' state we are free to do any in-place update as we see fit.','line_number':1702,'multiline':False]
['text':' Initialize the accumulator.','line_number':1705,'multiline':False]
['text':' This function is necessary because 'aggDoubleDoubleSum()' result is 'Array' type but we need','line_number':1724,'multiline':False]
['text':' to produce a scalar value out of it.','line_number':1725,'multiline':False]
['text':' For a count-like accumulator like {$sum: 1}, we use aggSum instruction. In this case, the','line_number':1737,'multiline':False]
['text':' result type is guaranteed to be either 'NumberInt32', 'NumberInt64', or 'NumberDouble'. We','line_number':1738,'multiline':False]
['text':' should transform the scalar result into an array which is the over-the-wire data format from','line_number':1739,'multiline':False]
['text':' a shard to a merging side.','line_number':1740,'multiline':False]
['text':' The merge-side expects that the first element is the BSON type, not internal slot type.','line_number':1766,'multiline':False]
['text':' Replaces the first element by the corresponding 'BSONType'.','line_number':1787,'multiline':False]
['text':' The merge-side expects that the first element is the BSON type, not internal slot type.','line_number':1801,'multiline':False]
['text':' Move the incoming accumulator state from the stack. Given that we are now the owner of the','line_number':1813,'multiline':False]
['text':' state we are free to do any in-place update as we see fit.','line_number':1814,'multiline':False]
['text':' Initialize the accumulator.','line_number':1817,'multiline':False]
['text':' The order of the following three elements should match to 'AggStdDevValueElems'.','line_number':1824,'multiline':False]
['text':' isSamp ','line_number':1848,'multiline':True]
['text':' isSamp ','line_number':1855,'multiline':True]
['text':' Skip aggregation step if we don't have the input.','line_number':1863,'multiline':False]
['text':' Initialize the accumulator.','line_number':1869,'multiline':False]
['text':' Skip aggregation step if we don't have the input.','line_number':1892,'multiline':False]
['text':' Initialize the accumulator.','line_number':1898,'multiline':False]
['text':' Skip aggregation step if we don't have the input.','line_number':1919,'multiline':False]
['text':' Initialize the accumulator.','line_number':1925,'multiline':False]
['text':' Disregard the next value, always return the first one.','line_number':1931,'multiline':False]
['text':' Skip aggregation step if we don't have the input.','line_number':1940,'multiline':False]
['text':' Initialize the accumulator.','line_number':1946,'multiline':False]
['text':' Disregard the accumulator, always return the next value.','line_number':1952,'multiline':False]
['text':' This is the last string.','line_number':1987,'multiline':False]
['text':' We operate only on objects.','line_number':2000,'multiline':False]
['text':' Build the set of fields to drop.','line_number':2005,'multiline':False]
['text':' Skip document length.','line_number':2024,'multiline':False]
['text':' We operate only on objects.','line_number':2075,'multiline':False]
['text':' Build the set of fields to keep.','line_number':2080,'multiline':False]
['text':' Skip document length.','line_number':2099,'multiline':False]
['text':' Cast to broader type 'int64_t' to prevent overflow during loop.','line_number':2145,'multiline':False]
['text':' Calculate how much memory is needed to generate the array and avoid going over the memLimit.','line_number':2154,'multiline':False]
['text':' If steps not positive then no amount of steps can get you from start to end. For example','line_number':2156,'multiline':False]
['text':' with start=5, end=7, step=-1 steps would be negative and in this case we would return an','line_number':2157,'multiline':False]
['text':' empty array.','line_number':2158,'multiline':False]
['text':' We operate only on keys.','line_number':2223,'multiline':False]
['text':' This is needed so that we can use 'tag' in the uassert() below without getting a','line_number':2268,'multiline':False]
['text':' "Reference to local binding declared in enclosing function" compile error on clang.','line_number':2269,'multiline':False]
['text':' Create a new array is it does not exist yet.','line_number':2518,'multiline':False]
['text':' Take ownership of the accumulator.','line_number':2523,'multiline':False]
['text':' Push back the value. Note that array will ignore Nothing.','line_number':2531,'multiline':False]
['text':' The value being accumulated is an SBE array that contains an integer and the accumulated array,','line_number':2539,'multiline':False]
['text':' where the integer is the total size in bytes of the elements in the array.','line_number':2540,'multiline':False]
['text':' Create a new array to hold size and added elements, if is it does not exist yet.','line_number':2554,'multiline':False]
['text':' The order is important! The accumulated array should be at index','line_number':2562,'multiline':False]
['text':' AggArrayWithSize::kValues, and the size should be at index','line_number':2563,'multiline':False]
['text':' AggArrayWithSize::kSizeOfValues.','line_number':2564,'multiline':False]
['text':' Take ownership of the accumulator.','line_number':2568,'multiline':False]
['text':' Check that the accumulated size of the array doesn't exceed the limit.','line_number':2577,'multiline':False]
['text':' Push back the new value. Note that array will ignore Nothing.','line_number':2600,'multiline':False]
['text':' Move the incoming accumulator state from the stack. Given that we are now the owner of the','line_number':2610,'multiline':False]
['text':' state we are free to do any in-place update as we see fit.','line_number':2611,'multiline':False]
['text':' Create a new object if it does not exist yet.','line_number':2615,'multiline':False]
['text':' Process the accumulated fields and if a field within the current object already exists','line_number':2635,'multiline':False]
['text':' within the existing accuultor, we set the value of that field within the accumuator to the','line_number':2636,'multiline':False]
['text':' value contained within the current object. Preserves the order of existing fields in the','line_number':2637,'multiline':False]
['text':' accumulator','line_number':2638,'multiline':False]
['text':' Copy the remaining fields of the current object being processed to the','line_number':2649,'multiline':False]
['text':' accumulator. Fields that were already present in the accumulated fields','line_number':2650,'multiline':False]
['text':' have been set already. Preserves the relative order of the new fields','line_number':2651,'multiline':False]
['text':' Create a new array is it does not exist yet.','line_number':2671,'multiline':False]
['text':' Take ownership of the accumulator.','line_number':2676,'multiline':False]
['text':' Push back the value. Note that array will ignore Nothing.','line_number':2684,'multiline':False]
['text':' Create a new array is it does not exist yet.','line_number':2700,'multiline':False]
['text':' The order is important! The accumulated array should be at index','line_number':2708,'multiline':False]
['text':' AggArrayWithSize::kValues, and the size should be at index','line_number':2709,'multiline':False]
['text':' AggArrayWithSize::kSizeOfValues.','line_number':2710,'multiline':False]
['text':' Take ownership of the accumulator.','line_number':2714,'multiline':False]
['text':' Check that the accumulated size of the set won't exceed the limit after adding the new value,','line_number':2723,'multiline':False]
['text':' and if so, add the value.','line_number':2724,'multiline':False]
['text':' Push back the new value. Note that array will ignore Nothing.','line_number':2749,'multiline':False]
['text':'collator','line_number':2771,'multiline':True]
['text':' If the collator is Nothing or if it's some unexpected type, don't push back the value','line_number':2780,'multiline':False]
['text':' and just return the accumulator.','line_number':2781,'multiline':False]
['text':' Create a new array is it does not exist yet.','line_number':2787,'multiline':False]
['text':' Take ownership of the accumulator.','line_number':2792,'multiline':False]
['text':' Push back the value. Note that array will ignore Nothing.','line_number':2800,'multiline':False]
['text':' If the collator is Nothing or if it's some unexpected type, don't push back the value','line_number':2815,'multiline':False]
['text':' and just return the accumulator.','line_number':2816,'multiline':False]
['text':' If find string is empty, return nothing, since an empty find will match every position in a','line_number':2872,'multiline':False]
['text':' string.','line_number':2873,'multiline':False]
['text':' If find string is not found, return the original string.','line_number':2878,'multiline':False]
['text':' Sweep across all tags and pick the result type.','line_number':2902,'multiline':False]
['text':' Date is a simple 64 bit integer.','line_number':2909,'multiline':False]
['text':' What to do about null and nothing?','line_number':2916,'multiline':False]
['text':' What to do about non-numeric types like arrays and objects?','line_number':2919,'multiline':False]
['text':' To the larger type','line_number':2967,'multiline':False]
['text':' To the larger type.','line_number':2975,'multiline':False]
['text':'*
 * A helper for the builtinDate method. The formal parameters yearOrWeekYear and monthOrWeek carry
 * values depending on wether the date is a year-month-day or ISOWeekYear.
 ','line_number':2990,'multiline':True]
['text':' 6th parameter is 'startOfWeek'.','line_number':3078,'multiline':False]
['text':' Get startDate.','line_number':3086,'multiline':False]
['text':' Get endDate.','line_number':3093,'multiline':False]
['text':' Get unit.','line_number':3100,'multiline':False]
['text':' Get timezone.','line_number':3111,'multiline':False]
['text':' Get startOfWeek, if 'startOfWeek' parameter was passed and time unit is the week.','line_number':3118,'multiline':False]
['text':' Get date.','line_number':3146,'multiline':False]
['text':' Get format.','line_number':3153,'multiline':False]
['text':' Get timezone.','line_number':3163,'multiline':False]
['text':' Get parameter tuples from stack.','line_number':3189,'multiline':False]
['text':' Attempt to get the date from the string. This may throw a ConversionFailure error.','line_number':3195,'multiline':False]
['text':' Format wasn't specified, so we call fromString without it.','line_number':3199,'multiline':False]
['text':' Fetch format from the stack, validate it, and call fromString with it.','line_number':3202,'multiline':False]
['text':' Upon error, we return Nothing and let the caller decide whether to raise an error.','line_number':3222,'multiline':False]
['text':' Get date.','line_number':3233,'multiline':False]
['text':' Get timezone.','line_number':3286,'multiline':False]
['text':' Get date.','line_number':3293,'multiline':False]
['text':' Get date parts.','line_number':3300,'multiline':False]
['text':' Get timezone.','line_number':3325,'multiline':False]
['text':' Get date.','line_number':3332,'multiline':False]
['text':' Get date parts.','line_number':3339,'multiline':False]
['text':' Carries a flag to indicate the desired testing behavior this was invoked under. The testing','line_number':3557,'multiline':False]
['text':' behavior is used to determine if we need to bail out of the bit position comparison early in','line_number':3558,'multiline':False]
['text':' the depending if a bit is found to be set or unset.','line_number':3559,'multiline':False]
['text':' If position to test is longer than the data to test against, zero-extend.','line_number':3577,'multiline':False]
['text':' Convert the bit position to a byte position within a byte. Note that byte positions','line_number':3580,'multiline':False]
['text':' start at position 0 in the document's value BinData array representation, and bit','line_number':3581,'multiline':False]
['text':' positions start at the least significant bit.','line_number':3582,'multiline':False]
['text':' Bail out early if we succeed with the any case or fail with the all case. To do this, we','line_number':3590,'multiline':False]
['text':' negate a test to determine if we need to continue looping over the bit position list. So','line_number':3591,'multiline':False]
['text':' the first part of the disjunction checks when a bit is set and the test is invoked by the','line_number':3592,'multiline':False]
['text':' AllSet or AnyClear expressions. The second test checks if a bit isn't set and we are','line_number':3593,'multiline':False]
['text':' checking the AllClear or the AnySet cases.','line_number':3594,'multiline':False]
['text':' Values of type StringBig and Values of type bsonSymbol have identical representations,','line_number':3720,'multiline':False]
['text':' so we can simply take ownership of the argument, change the type tag to StringBig, and','line_number':3721,'multiline':False]
['text':' return it.','line_number':3722,'multiline':False]
['text':'*
 * Converts a number to int32 assuming the input fits the range. This is used for $round "place"
 * argument, which is checked to be a whole number between -20 and 100, but could still be a
 * non-int32 type.
 ','line_number':3846,'multiline':True]
['text':' Construct 10^-precisionValue, which will be used as the quantize reference. This is passed to','line_number':3884,'multiline':False]
['text':' decimal.quantize() to indicate the precision of our rounding.','line_number':3885,'multiline':False]
['text':' Even if the original was an int to begin with - it has to be a long now.','line_number':3920,'multiline':False]
['text':' Nullish 'chars' indicates that it was not provided and the default whitespace characters will','line_number':3982,'multiline':False]
['text':' be used.','line_number':3983,'multiline':False]
['text':' We expect the new value we are adding to the accumulator to be a two-element array where','line_number':4006,'multiline':False]
['text':' the first element is the array to concatenate and the second value is the corresponding size.','line_number':4007,'multiline':False]
['text':' Create a new array to hold size and added elements, if is it does not exist yet.','line_number':4014,'multiline':False]
['text':' The order is important! The accumulated array should be at index','line_number':4022,'multiline':False]
['text':' AggArrayWithSize::kValues, and the size should be at index','line_number':4023,'multiline':False]
['text':' AggArrayWithSize::kSizeOfValues.','line_number':4024,'multiline':False]
['text':' Take ownership of the accumulator.','line_number':4028,'multiline':False]
['text':' Check that the accumulated size after concatentation won't exceed the limit.','line_number':4040,'multiline':False]
['text':' We are still under the size limit. Set the new total size in the accumulator.','line_number':4060,'multiline':False]
['text':' Check index is positive.','line_number':4142,'multiline':False]
['text':' Check for valid bounds.','line_number':4146,'multiline':False]
['text':' Check index is positive.','line_number':4157,'multiline':False]
['text':' Check for valid bounds.','line_number':4161,'multiline':False]
['text':' Check index is positive.','line_number':4190,'multiline':False]
['text':' Check for valid bounds.','line_number':4194,'multiline':False]
['text':' Check index is positive.','line_number':4205,'multiline':False]
['text':' Check for valid bounds.','line_number':4209,'multiline':False]
['text':' Handle edge case if both string and substring are empty strings.','line_number':4215,'multiline':False]
['text':' Need to get byte indexes for start and end indexes.','line_number':4220,'multiline':False]
['text':' namespace','line_number':4449,'multiline':False]
['text':' We expect the new value we are adding to the accumulator to be a two-element array where','line_number':4499,'multiline':False]
['text':' the first element is the new set of values and the second value is the corresponding size.','line_number':4500,'multiline':False]
['text':' Create a new array is it does not exist yet.','line_number':4507,'multiline':False]
['text':' The order is important! The accumulated array should be at index','line_number':4515,'multiline':False]
['text':' AggArrayWithSize::kValues, and the size should be at index','line_number':4516,'multiline':False]
['text':' AggArrayWithSize::kSizeOfValues.','line_number':4517,'multiline':False]
['text':' Take ownership of the accumulator.','line_number':4521,'multiline':False]
['text':' Extract the current size of the accumulator. As we add elements to the set, we will increment','line_number':4541,'multiline':False]
['text':' the current size accordingly and throw an exception if we ever exceed the size limit. We','line_number':4542,'multiline':False]
['text':' cannot simply sum the two sizes, since the two sets could have a substantial intersection.','line_number':4543,'multiline':False]
['text':' Update the accumulator with the new total size.','line_number':4572,'multiline':False]
['text':' Initialize the accumulator.','line_number':4585,'multiline':False]
['text':' Take ownership of the accumulator.','line_number':4589,'multiline':False]
['text':' Initialize the accumulator.','line_number':4622,'multiline':False]
['text':' Take ownership of the accumulator.','line_number':4626,'multiline':False]
['text':'collator','line_number':4661,'multiline':True]
['text':' passthrough if its not a set','line_number':4828,'multiline':False]
['text':'*
 * A helper function to extract the next match in the subject string using the compiled regex
 * pattern.
 * - pcre: The wrapper object containing the compiled pcre expression
 * - inputString: The subject string.
 * - startBytePos: The position from where the search should start given in bytes.
 * - codePointPos: The same position in terms of code points.
 * - isMatch: Boolean flag to mark if the caller function is $regexMatch, in which case the result
 * returned is true/false.
 ','line_number':4846,'multiline':True]
['text':' $regexMatch returns true or false.','line_number':4870,'multiline':False]
['text':' $regexFind and $regexFindAll build result object or return null.','line_number':4873,'multiline':False]
['text':' Create the result object {"match" : .., "idx" : ..., "captures" : ...}','line_number':4878,'multiline':False]
['text':' from the pcre::MatchData.','line_number':4879,'multiline':False]
['text':'*
 * A helper function with common logic for $regexMatch and $regexFind functions. Both extract only
 * the first match to a regular expression, but return different result objects.
 ','line_number':4916,'multiline':True]
['text':' This function should only be called if 'collator' is non-null and 'tag' is a collatable type.','line_number':4944,'multiline':False]
['text':' For strings, call CollatorInterface::getComparisonKey() to obtain the comparison key.','line_number':4948,'multiline':False]
['text':' For collatable types other than strings (such as arrays and objects), we take the slow','line_number':4954,'multiline':False]
['text':' path and round-trip the value through BSON.','line_number':4955,'multiline':False]
['text':' namespace','line_number':4969,'multiline':False]
['text':' Prepare the result array of matching objects.','line_number':5042,'multiline':False]
['text':' Move indexes after the current matched string to prepare for the next search.','line_number':5068,'multiline':False]
['text':' Compute the shard key hash value by round-tripping it through BSONObj as it is currently the','line_number':5116,'multiline':False]
['text':' only way to do it if we do not want to duplicate the hash computation code.','line_number':5117,'multiline':False]
['text':' TODO SERVER-55622','line_number':5118,'multiline':False]
['text':' We need to ensure that 'size_t' is wide enough to store 32-bit index.','line_number':5127,'multiline':False]
['text':' Upcast 'value' to 'int64_t' prevent overflow during the sign change.','line_number':5141,'multiline':False]
['text':' Earlier in this function we bailed out if the 'arrayType' wasn't Array, ArraySet or','line_number':5254,'multiline':False]
['text':' bsonArray, so it should be impossible to reach this point.','line_number':5255,'multiline':False]
['text':' We "move" the object argument into the sort spec.','line_number':5331,'multiline':False]
['text':' If the input is Nothing or not an Object and if 'nonObjInputBehavior' equals','line_number':5441,'multiline':False]
['text':' 'kReturnNothing', then return Nothing.','line_number':5442,'multiline':False]
['text':' If the input is Nothing or not an Object and if 'nonObjInputBehavior' equals','line_number':5446,'multiline':False]
['text':' 'kReturnInput', then return the input.','line_number':5447,'multiline':False]
['text':' Using intermediate vector since bsonArray and ArraySet don't','line_number':5499,'multiline':False]
['text':' support reverse iteration.','line_number':5500,'multiline':False]
['text':' Reserve space to avoid resizing on push_back calls.','line_number':5504,'multiline':False]
['text':' Run through the array backwards and copy into the result array.','line_number':5516,'multiline':False]
['text':' Earlier in this function we bailed out if the 'inputType' wasn't','line_number':5526,'multiline':False]
['text':' Array, ArraySet or bsonArray, so it should be impossible to reach','line_number':5527,'multiline':False]
['text':' this point.','line_number':5528,'multiline':False]
['text':' If a third parameter was supplied but it is not a Collator, return Nothing.','line_number':5554,'multiline':False]
['text':' Using intermediate vector since bsonArray and ArraySet don't','line_number':5588,'multiline':False]
['text':' support reverse iteration.','line_number':5589,'multiline':False]
['text':' Reserve space to avoid resizing on push_back calls.','line_number':5593,'multiline':False]
['text':' Earlier in this function we bailed out if the 'inputType' wasn't','line_number':5617,'multiline':False]
['text':' Array, ArraySet or bsonArray, so it should be impossible to reach','line_number':5618,'multiline':False]
['text':' this point.','line_number':5619,'multiline':False]
['text':' If the argument is an array, find out the min/max value and place it in the','line_number':5757,'multiline':False]
['text':' stack. If it is Nothing or another simple type, treat it as the return value.','line_number':5758,'multiline':False]
['text':' The array is empty, return Nothing.','line_number':5765,'multiline':False]
['text':' The comparison returns Nothing if one of the arguments is Nothing or if a sort order','line_number':5775,'multiline':False]
['text':' cannot be determined: bail out immediately and return Nothing.','line_number':5776,'multiline':False]
['text':' If the array is owned by the stack, make a copy of the item, or it will become invalid after','line_number':5785,'multiline':False]
['text':' the caller clears the array from it.','line_number':5786,'multiline':False]
['text':' get key','line_number':5808,'multiline':False]
['text':' get value','line_number':5813,'multiline':False]
['text':' create a new obejct','line_number':5817,'multiline':False]
['text':' insert key and value to the object','line_number':5822,'multiline':False]
['text':' insert the object to array','line_number':5827,'multiline':False]
['text':' return empty object for empty array','line_number':5853,'multiline':False]
['text':' There are two accepted input formats in an array: [ [key, val] ] or [ {k:key, v:val} ]. The','line_number':5859,'multiline':False]
['text':' first array element determines the format for the rest of the array. Mixing input formats is','line_number':5860,'multiline':False]
['text':' not allowed.','line_number':5861,'multiline':False]
['text':' Use a StringMap to store the indices in object for added fieldNames','line_number':5872,'multiline':False]
['text':' Only the last value should be added for duplicate fieldNames.','line_number':5873,'multiline':False]
['text':' add to array','line_number':6087,'multiline':False]
['text':' add values from accArr to mergeArray','line_number':6225,'multiline':False]
['text':' return accArray since it contains last n values','line_number':6240,'multiline':False]
['text':' We always output result in the order of sort pattern in according to MQL semantics.','line_number':6426,'multiline':False]
['text':' Initialize the accumulator.','line_number':6643,'multiline':False]
['text':' kLastValue','line_number':6653,'multiline':False]
['text':' kLastValueIsNothing','line_number':6655,'multiline':False]
['text':' kLastValue','line_number':6657,'multiline':False]
['text':' kLastValueIsNothing','line_number':6659,'multiline':False]
['text':' kLastRank','line_number':6661,'multiline':False]
['text':' kSameRankCount','line_number':6662,'multiline':False]
['text':' Update the last value to Nothing before comparison if the flag is set.','line_number':6670,'multiline':False]
['text':' dense ','line_number':6708,'multiline':True]
['text':' dense ','line_number':6723,'multiline':True]
['text':' dense ','line_number':6730,'multiline':True]
['text':' dense ','line_number':6745,'multiline':True]
['text':' Accumulator result has not been yet initialised. We will now','line_number':6784,'multiline':False]
['text':' set it to decimalVal','line_number':6785,'multiline':False]
['text':' Avoid overflow by processing in two parts.','line_number':6916,'multiline':False]
['text':' Narrow Decimal128 to double.','line_number':7048,'multiline':False]
['text':' Narrow Decimal128 to integral.','line_number':7054,'multiline':False]
['text':' Narrow Decimal128 to double if overflows long.','line_number':7059,'multiline':False]
['text':' Narrow double to integral.','line_number':7068,'multiline':False]
['text':' Narrow long to int','line_number':7073,'multiline':False]
['text':' kSumAcc','line_number':7089,'multiline':False]
['text':' kNanCount','line_number':7091,'multiline':False]
['text':' kPosInfinityCount','line_number':7093,'multiline':False]
['text':' kNegInfinityCount','line_number':7095,'multiline':False]
['text':' kDoubleCount','line_number':7097,'multiline':False]
['text':' kDecimalCount','line_number':7099,'multiline':False]
['text':' Initialize the accumulator.','line_number':7109,'multiline':False]
['text':'*
 * Functions that operate on `ArrayQueue`
 ','line_number':7133,'multiline':True]
['text':' Get the underlying array, and start index and end index that demarcates the queue','line_number':7136,'multiline':False]
['text':' Update the startIdex and index of the `ArrayQueue`','line_number':7163,'multiline':False]
['text':' Return the size of the queue','line_number':7173,'multiline':False]
['text':' Initialize an array queue','line_number':7179,'multiline':False]
['text':' Make the buffer has at least 1 capacity so that the start index will always be valid.','line_number':7189,'multiline':False]
['text':' kStartIdx','line_number':7195,'multiline':False]
['text':' kQueueSize','line_number':7196,'multiline':False]
['text':' Push an element {tag, value} into the queue','line_number':7201,'multiline':False]
['text':' The underlying array acts as a circular buffer for the queue with `startIdx` and `queueSize`
     * demarcating the filled region (with remaining region containing nulls). When pushing an
     * element to the queue, we set at the corresponding index [= (startIdx + queueSize) %
     * arraySize] the element to be added. If the underlying array is filled, we double the size of
     * the array (by adding nulls); the existing elements in the queue may need to be rearranged
     * when that happens.
     *
     * Eg, Push {v} :
     * => Initial State: (x = filled; _ = empty)
     *       [x x x x]
     *            |
     *         startIdx (queueSize = 4, arraySize = 4)
     *
     * => Double array size:
     *       [x x x x _ _ _ _]
     *            |
     *          startIdx (queueSize = 4, arraySize = 8)
     *
     * => Rearrange elements:
     *       [x x _ _ _ _ x x]
     *                    |
     *                    startIdx (queueSize = 4, arraySize = 8)
     *
     * => Add element:
     *       [x x v _ _ _ x x]
     *                    |
     *                   startIdx (queueSize = 5, arraySize = 8)
     ','line_number':7203,'multiline':True]
['text':' reallocate with twice size','line_number':7236,'multiline':False]
['text':' existing values wrap over the array','line_number':7246,'multiline':False]
['text':' need to rearrange the values from [startIdx, cap-1]','line_number':7247,'multiline':False]
['text':' Pops an element {tag, value} from the queue and returns it ','line_number':7263,'multiline':True]
['text':' Returns a value::Array containing N elements at the front of the queue.','line_number':7295,'multiline':False]
['text':' If the queue contains less than N elements, returns all the elements','line_number':7296,'multiline':False]
['text':' Returns a value::Array containing N elements at the back of the queue.','line_number':7319,'multiline':False]
['text':' If the queue contains less than N elements, returns all the elements','line_number':7320,'multiline':False]
['text':'*
 * Helper functions for integralAdd/Remove/Finalize
 ','line_number':7346,'multiline':True]
['text':' AggIntegralElems::kInputQueue','line_number':7478,'multiline':False]
['text':' AggIntegralElems::kSortByQueue','line_number':7482,'multiline':False]
['text':' AggIntegralElems::kIntegral','line_number':7486,'multiline':False]
['text':' AggIntegralElems::kNanCount','line_number':7490,'multiline':False]
['text':' AggIntegralElems::kUnitMillis','line_number':7493,'multiline':False]
['text':' AggIntegralElems::kIsNonRemovable','line_number':7496,'multiline':False]
['text':' verify that the input and sortby value to be removed are the first elements of the queues','line_number':7566,'multiline':False]
['text':' Return null if the sortBy delta is zero','line_number':7679,'multiline':False]
['text':' Initialize the accumulator.','line_number':7844,'multiline':False]
['text':' kSumX','line_number':7852,'multiline':False]
['text':' kSumY','line_number':7854,'multiline':False]
['text':' kCXY','line_number':7856,'multiline':False]
['text':' kCount','line_number':7857,'multiline':False]
['text':' isSamp ','line_number':7984,'multiline':True]
['text':' isSamp ','line_number':7989,'multiline':True]
['text':' Assuming we are adding value if count == 0.','line_number':8119,'multiline':False]
['text':' Initialize the accumulator.','line_number':8150,'multiline':False]
['text':' kSum','line_number':8158,'multiline':False]
['text':' kM2','line_number':8160,'multiline':False]
['text':' kCount','line_number':8161,'multiline':False]
['text':' kNonFiniteCount','line_number':8163,'multiline':False]
['text':' m2 is the sum of squared differences from the mean, so it should always be','line_number':8202,'multiline':False]
['text':' nonnegative. It may take on a small negative value due to floating point error, which','line_number':8203,'multiline':False]
['text':' breaks the sqrt calculation. In this case, the closest valid value for _m2 is 0, so','line_number':8204,'multiline':False]
['text':' we reset _m2 and return 0 for the standard deviation.','line_number':8205,'multiline':False]
['text':' If we're doing a population std dev of one element, it is also correct to return 0.','line_number':8206,'multiline':False]
['text':' isSamp ','line_number':8217,'multiline':True]
['text':' isSamp ','line_number':8222,'multiline':True]
['text':'*
 * $linearFill implementation
 ','line_number':8237,'multiline':True]
['text':' if y2 is non-null it means we have found a valid upper window bound. in that case if count is','line_number':8276,'multiline':False]
['text':' positive it means there are still more finalize calls to be made. when count == 0 we have','line_number':8277,'multiline':False]
['text':' exhausted this window.','line_number':8278,'multiline':False]
['text':' if y2 is null it means we have not yet found the upper window bound so keep on adding input','line_number':8283,'multiline':False]
['text':' values','line_number':8284,'multiline':False]
['text':' Validate the types of the values','line_number':8298,'multiline':False]
['text':' Valdiate the current sortBy value with the previous one and update prevX','line_number':8308,'multiline':False]
['text':' Update x2/y2 to the current sortby/input values','line_number':8324,'multiline':False]
['text':' If (old) y2 is non-null, it means we need to look for new end-points (x1, y1), (x2, y2)','line_number':8335,'multiline':False]
['text':' and the segment spanned be previous endpoints is exhausted. Count should be zero at','line_number':8336,'multiline':False]
['text':' this point. Update (x1, y1) to the previous (x2, y2)','line_number':8337,'multiline':False]
['text':' Given two known points (x1, y1) and (x2, y2) and a value x that lies between those two','line_number':8353,'multiline':False]
['text':' points, we solve (or fill) for y with the following formula: y = y1 + (x - x1) * ((y2 -','line_number':8354,'multiline':False]
['text':' y1)/(x2 - x1))','line_number':8355,'multiline':False]
['text':' (y2 - y1)','line_number':8362,'multiline':False]
['text':' (x2 - x1)','line_number':8366,'multiline':False]
['text':' (y2 - y1) / (x2 - x1)','line_number':8370,'multiline':False]
['text':' (x - x1)','line_number':8374,'multiline':False]
['text':' (x - x1) * ((y2 - y1) / (x2 - x1))','line_number':8378,'multiline':False]
['text':' y1 + (x - x1) * ((y2 - y1) / (x2 - x1))','line_number':8382,'multiline':False]
['text':' if y2 is null it means the current window is the last window frame in the partition','line_number':8396,'multiline':False]
['text':' If count == 0, we are currently handling the last docoument in the window frame (x2/y2)','line_number':8401,'multiline':False]
['text':' so we can return y2 directly. Note that the document represented by y1 was returned as','line_number':8402,'multiline':False]
['text':' part of previous window (when it was y2)','line_number':8403,'multiline':False]
['text':' If y1 is null it means the current window is the first window frame in the partition','line_number':8409,'multiline':False]
['text':'*
 * Implementation for $firstN/$lastN removable window function
 ','line_number':8416,'multiline':True]
['text':' Read the accumulator from the state.','line_number':8519,'multiline':False]
['text':' the order is important!!!','line_number':8544,'multiline':False]
['text':' the multiset with the values','line_number':8545,'multiline':False]
['text':' the size in bytes of the multiset','line_number':8547,'multiline':False]
['text':' collator ','line_number':8554,'multiline':True]
['text':' Check the size of the accumulator will not exceed the cap.','line_number':8579,'multiline':False]
['text':' Update the state.','line_number':8592,'multiline':False]
['text':' Convert the multiSet to Set.','line_number':8628,'multiline':False]
['text':' Read the accumulator from the state.','line_number':8652,'multiline':False]
['text':' Read N from the state','line_number':8656,'multiline':False]
['text':' Read memory usage information from state','line_number':8660,'multiline':False]
['text':' Initialize the state','line_number':8696,'multiline':False]
['text':' the order is important!!!','line_number':8702,'multiline':False]
['text':' The multiset with the values.','line_number':8704,'multiline':False]
['text':' The maximum number of elements in the multiset.','line_number':8705,'multiline':False]
['text':' The size of the multiset in bytes.','line_number':8707,'multiline':False]
['text':' The maximum possible size of the multiset in bytes.','line_number':8709,'multiline':False]
['text':' remove element','line_number':8784,'multiline':False]
['text':' Create an empty array to fill with the results','line_number':8807,'multiline':False]
['text':' If this accumulator is removable there may be more than n elements in the map, so we must','line_number':8928,'multiline':False]
['text':' skip elements that shouldn't be in the result.','line_number':8929,'multiline':False]
['text':'merging','line_number':9034,'multiline':True]
['text':'merging','line_number':9040,'multiline':True]
['text':'merging','line_number':9042,'multiline':True]
['text':'merging','line_number':9044,'multiline':True]
['text':'sign','line_number':9287,'multiline':True]
['text':'sign','line_number':9289,'multiline':True]
['text':' Swap values only if they are not physically same. This is necessary for the','line_number':9926,'multiline':False]
['text':' "swap and pop" idiom for returning a value from the top of the stack (used','line_number':9927,'multiline':False]
['text':' by ELocalBind). For example, consider the case where a series of swap, pop,','line_number':9928,'multiline':False]
['text':' swap, pop... instructions are executed and the value at stack[0] and','line_number':9929,'multiline':False]
['text':' stack[1] are physically identical, but stack[1] is owned and stack[0] is','line_number':9930,'multiline':False]
['text':' not. After swapping them, the 'pop' instruction would free the owned one and','line_number':9931,'multiline':False]
['text':' leave the unowned value dangling. The only exception to this is shallow','line_number':9932,'multiline':False]
['text':' values (values which fit directly inside a 64 bit Value and don't need','line_number':9933,'multiline':False]
['text':' to be freed explicitly).','line_number':9934,'multiline':False]
['text':' Copy value only if needed','line_number':10490,'multiline':False]
['text':' Copy value only if needed','line_number':10511,'multiline':False]
['text':' Copy value only if needed','line_number':10531,'multiline':False]
['text':' If lhs is a collatable type, call collComparisonKey() to obtain the','line_number':10559,'multiline':False]
['text':' comparison key. If lhs is not a collatable type, we can just leave it','line_number':10560,'multiline':False]
['text':' on the stack as-is.','line_number':10561,'multiline':False]
['text':' If lhs was Nothing or rhs wasn't Collator, return Nothing.','line_number':10578,'multiline':False]
['text':' Copy value only if needed','line_number':10594,'multiline':False]
['text':' Skip aggregation step if the collation is Nothing or an unexpected type.','line_number':10703,'multiline':False]
['text':' Skip aggregation step if the collation is Nothing or an unexpected type.','line_number':10745,'multiline':False]
['text':' Transfer ownership of tag/val to the caller','line_number':11058,'multiline':False]
['text':' namespace vm','line_number':11083,'multiline':False]
['text':' namespace sbe','line_number':11084,'multiline':False]
['text':' namespace mongo','line_number':11085,'multiline':False]
