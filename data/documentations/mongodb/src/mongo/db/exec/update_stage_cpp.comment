['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':'*
 * Returns true if we should throw a WriteConflictException in order to retry the operation in the
 * case of a conflict. Returns false if we should skip the document and keep going.
 ','line_number':102,'multiline':True]
['text':' When we're doing a findAndModify with a sort, the sort will have a limit of 1, so it will not','line_number':107,'multiline':False]
['text':' produce any more results even if there is another matching document. Throw a WCE here so that','line_number':108,'multiline':False]
['text':' these operations get another chance to find a matching document. The findAndModify command','line_number':109,'multiline':False]
['text':' should automatically retry if it gets a WCE.','line_number':110,'multiline':False]
['text':' namespace','line_number':127,'multiline':False]
['text':' Public constructor.','line_number':129,'multiline':False]
['text':' We should never reach here if the request is an upsert.','line_number':136,'multiline':False]
['text':' Protected constructor.','line_number':141,'multiline':False]
['text':' Should the modifiers validate their embedded docs via storage_validation::scanDocument()?','line_number':155,'multiline':False]
['text':' Only user updates should be checked. Any system or replication stuff should pass through.','line_number':156,'multiline':False]
['text':' Ask the driver to apply the mods. It may be that the driver can apply those "in','line_number':176,'multiline':False]
['text':' place", that is, some values of the old document just get adjusted without any','line_number':177,'multiline':False]
['text':' change to the binary layout on the bson layer. It may be that a whole new document','line_number':178,'multiline':False]
['text':' is needed to accomodate the new bson layout of the resulting document. In any event,','line_number':179,'multiline':False]
['text':' only enable in-place mutations if the underlying storage engine offers support for','line_number':180,'multiline':False]
['text':' writing damage events.','line_number':181,'multiline':False]
['text':' Documents coming directly from users should be validated for storage.','line_number':196,'multiline':False]
['text':' If we don't need match details, avoid doing the rematch','line_number':207,'multiline':False]
['text':' If there was a matched field, obtain it.','line_number':217,'multiline':False]
['text':' Skip adding _id field if the collection is capped (since capped collection documents can','line_number':242,'multiline':False]
['text':' neither grow nor shrink).','line_number':243,'multiline':False]
['text':' Ensure _id is first if it exists, and generate a new OID if appropriate.','line_number':246,'multiline':False]
['text':' See if the changes were applied in place','line_number':249,'multiline':False]
['text':' An interesting edge case. A modifier didn't notice that it was really a no-op','line_number':254,'multiline':False]
['text':' during its 'prepare' phase. That represents a missed optimization, but we still','line_number':255,'multiline':False]
['text':' shouldn't do any real work. Toggle 'docWasModified' to 'false'.','line_number':256,'multiline':False]
['text':'','line_number':257,'multiline':False]
['text':' Currently, an example of this is '{ $push : { x : {$each: [], $sort: 1} } }' when the 'x'','line_number':258,'multiline':False]
['text':' array exists and is already sorted.','line_number':259,'multiline':False]
['text':' Prepare to write back the modified document','line_number':266,'multiline':False]
['text':' Ensure we set the type correctly','line_number':286,'multiline':False]
['text':' newObj ','line_number':302,'multiline':True]
['text':' The updates were not in place. Apply them through the file manager.','line_number':322,'multiline':False]
['text':' If the document is indexed and the mod changes an indexed value, we might see it again.','line_number':354,'multiline':False]
['text':' For an example, see the comment above near declaration of '_updatedRecordIds'.','line_number':355,'multiline':False]
['text':'','line_number':356,'multiline':False]
['text':' This must be done after the wunit commits so we are sure we won't be rolling back.','line_number':357,'multiline':False]
['text':' Only record doc modifications if they wrote (exclude no-ops). Explains get','line_number':363,'multiline':False]
['text':' recorded as if they wrote.','line_number':364,'multiline':False]
['text':' If not modified or explaining only, then there are no changes, so default to','line_number':369,'multiline':False]
['text':' returning oldObj.','line_number':370,'multiline':False]
['text':' We're done updating if either the child has no more results to give us, or we've','line_number':380,'multiline':False]
['text':' already gotten a result back and we're not a multi-update.','line_number':381,'multiline':False]
['text':' Implictly replicated collections do not replicate updates.','line_number':393,'multiline':False]
['text':' However, user-initiated writes and some background maintenance tasks are allowed','line_number':394,'multiline':False]
['text':' to replicate as they cannot be derived from the oplog.','line_number':395,'multiline':False]
['text':' It is possible that after an update was applied, a WriteConflictException','line_number':399,'multiline':False]
['text':' occurred and prevented us from returning ADVANCED with the requested version','line_number':400,'multiline':False]
['text':' of the document.','line_number':401,'multiline':False]
['text':' We should only get here if we were trying to return something before.','line_number':403,'multiline':False]
['text':' Either retry the last WSM we worked on or get a new one from our child.','line_number':414,'multiline':False]
['text':' Need to get these things from the result returned by the child.','line_number':426,'multiline':False]
['text':' We want to free this member when we return, unless we need to retry updating or returning','line_number':431,'multiline':False]
['text':' it.','line_number':432,'multiline':False]
['text':' Updates can't have projections. This means that covering analysis will always add','line_number':438,'multiline':False]
['text':' a fetch. We should always get fetched data, and never just key data.','line_number':439,'multiline':False]
['text':' We fill this with the new RecordIds of moved doc so we don't double-update.','line_number':442,'multiline':False]
['text':' Found a RecordId that refers to a document we had already updated. Note that','line_number':444,'multiline':False]
['text':' we can never remove from _updatedRecordIds because updates by other clients','line_number':445,'multiline':False]
['text':' could cause us to encounter a document again later.','line_number':446,'multiline':False]
['text':' yieldHandler','line_number':460,'multiline':False]
['text':' There was a problem trying to detect if the document still','line_number':461,'multiline':False]
['text':' exists, so retry.','line_number':462,'multiline':False]
['text':' Either the document has been deleted, or it has been updated such that it no longer','line_number':472,'multiline':False]
['text':' matches the predicate.','line_number':473,'multiline':False]
['text':' Keep this member around so we can retry updating it.','line_number':489,'multiline':False]
['text':' Ensure that the BSONObj underlying the WorkingSetMember is owned because saveState()','line_number':498,'multiline':False]
['text':' is allowed to free the memory.','line_number':499,'multiline':False]
['text':' yieldHandler','line_number':512,'multiline':False]
['text':' If we care about the pre-updated version of the doc, save it out here.','line_number':520,'multiline':False]
['text':' Do the update, get us the new version of the doc.','line_number':530,'multiline':False]
['text':' yieldHandler','line_number':535,'multiline':False]
['text':' Keep this member around so we can retry updating it.','line_number':536,'multiline':False]
['text':' If the placement version is IGNORED and we encountered a critical section, then','line_number':546,'multiline':False]
['text':' yield, wait for critical section to finish and then we'll resume the write from','line_number':547,'multiline':False]
['text':' the point we had left. We do this to prevent large multi-writes from repeatedly','line_number':548,'multiline':False]
['text':' failing due to StaleConfig and exhausting the mongos retry attempts.','line_number':549,'multiline':False]
['text':' Keep this member around so we can retry updating it.','line_number':551,'multiline':False]
['text':' Set member's obj to be the doc we want to return.','line_number':558,'multiline':False]
['text':' This should be after transformAndUpdate to make sure we actually updated this doc.','line_number':570,'multiline':False]
['text':' Restore state after modification. As restoreState may restore (recreate) cursors, make','line_number':573,'multiline':False]
['text':' sure to restore the state outside of the WritUnitOfWork.','line_number':574,'multiline':False]
['text':' yieldHandler','line_number':584,'multiline':False]
['text':' Note we don't need to retry updating anything in this case since the update','line_number':585,'multiline':False]
['text':' already was committed. However, we still need to return the updated document (if','line_number':586,'multiline':False]
['text':' it was requested).','line_number':587,'multiline':False]
['text':' member->obj should refer to the document we want to return.','line_number':589,'multiline':False]
['text':' Keep this member around so that we can return it on the next work() call.','line_number':593,'multiline':False]
['text':' If this stage is already exhausted it won't use its children stages anymore and','line_number':602,'multiline':False]
['text':' therefore it's okay if we failed to restore them. Avoid requesting a yield to the','line_number':603,'multiline':False]
['text':' plan executor. Restoring from yield could fail due to a sharding placement','line_number':604,'multiline':False]
['text':' change. Throwing a StaleConfig error is undesirable after an "update one"','line_number':605,'multiline':False]
['text':' operation has already performed a write because the router would retry. Unset','line_number':606,'multiline':False]
['text':' _idReturning as we'll return the document in this stage iteration.','line_number':607,'multiline':False]
['text':'','line_number':608,'multiline':False]
['text':' If this plan is part of a larger encompassing WUOW it would be illegal to skip','line_number':609,'multiline':False]
['text':' returning NEED_YIELD, so we don't skip it. In this case, such as multi-doc','line_number':610,'multiline':False]
['text':' transactions, this is okay as the PlanExecutor is not allowed to auto-yield.','line_number':611,'multiline':False]
['text':' member->obj should refer to the document we want to return.','line_number':619,'multiline':False]
['text':' Keep this member around so we can return it.','line_number':622,'multiline':False]
['text':' The child is out of results, and therefore so are we.','line_number':629,'multiline':False]
['text':' We may have stepped down during the yield.','line_number':642,'multiline':False]
['text':' Single updates never yield after having already modified one document. Otherwise restore','line_number':652,'multiline':False]
['text':' could fail (e.g. due to a sharding placement change) and we'd fail to report in the response','line_number':653,'multiline':False]
['text':' the already modified documents.','line_number':654,'multiline':False]
['text':' We do not allow modifying either the current shard key value or new shard key value (if','line_number':683,'multiline':False]
['text':' resharding) without specifying the full current shard key in the query.','line_number':684,'multiline':False]
['text':' If the query is a simple equality match on _id, then '_params.canonicalQuery' will be null.','line_number':685,'multiline':False]
['text':' But if we are here, we already know that the shard key is not _id, since we have an assertion','line_number':686,'multiline':False]
['text':' earlier for requests that try to modify the immutable _id field. So it is safe to uassert if','line_number':687,'multiline':False]
['text':' '_params.canonicalQuery' is null OR if the query does not include equality matches on all','line_number':688,'multiline':False]
['text':' shard key fields.','line_number':689,'multiline':False]
['text':' We do not allow updates to the shard key when 'multi' is true.','line_number':693,'multiline':False]
['text':' With the introduction of PM-1632, we allow updating a document shard key without','line_number':698,'multiline':False]
['text':' providing a full shard key if the update is executed in a retryable write or transaction.','line_number':699,'multiline':False]
['text':' PM-1632 uses an internal transaction to execute these updates, so to make sure that we can','line_number':700,'multiline':False]
['text':' only update the document shard key in a retryable write or transaction, mongos only sets','line_number':701,'multiline':False]
['text':' $_allowShardKeyUpdatesWithoutFullShardKeyInQuery to true if the client executed write was a','line_number':702,'multiline':False]
['text':' retryable write or in a transaction.','line_number':703,'multiline':False]
['text':' If this node is a replica set primary node, an attempted update to the shard key value','line_number':712,'multiline':False]
['text':' must either be a retryable write or inside a transaction. An update without a transaction','line_number':713,'multiline':False]
['text':' number is legal if gFeatureFlagUpdateDocumentShardKeyUsingTransactionApi is enabled','line_number':714,'multiline':False]
['text':' because mongos will be able to start an internal transaction to handle the','line_number':715,'multiline':False]
['text':' wouldChangeOwningShard error thrown below. If this node is a replica set secondary node,','line_number':716,'multiline':False]
['text':' we can skip validation.','line_number':717,'multiline':False]
['text':' If this node is a replica set primary node, an attempted update to the shard key value','line_number':735,'multiline':False]
['text':' must either be a retryable write or inside a transaction. An update without a transaction','line_number':736,'multiline':False]
['text':' number is legal if gFeatureFlagUpdateDocumentShardKeyUsingTransactionApi is enabled','line_number':737,'multiline':False]
['text':' because mongos will be able to start an internal transaction to handle the','line_number':738,'multiline':False]
['text':' wouldChangeOwningShard error thrown below. If this node is a replica set secondary node,','line_number':739,'multiline':False]
['text':' we can skip validation.','line_number':740,'multiline':False]
['text':' upsert ','line_number':774,'multiline':True]
['text':' Calling mutablebson::Document::getObject() renders a full copy of the updated document. This','line_number':783,'multiline':False]
['text':' can be expensive for larger documents, so we skip calling it when the collection isn't even','line_number':784,'multiline':False]
['text':' sharded.','line_number':785,'multiline':False]
['text':' It is possible that both the existing and new shard keys are being updated, so we do not want','line_number':793,'multiline':False]
['text':' to short-circuit checking whether either is being modified.','line_number':794,'multiline':False]
['text':' If the shard key fields remain unchanged by this update we can skip the rest of the checks.','line_number':808,'multiline':False]
['text':' Using BSONObj::binaryEqual() still allows a missing shard key field to be filled in with an','line_number':809,'multiline':False]
['text':' explicit null value.','line_number':810,'multiline':False]
['text':' Assert that the updated doc has no arrays or array descendants for the shard key fields.','line_number':817,'multiline':False]
['text':' At this point we already asserted that the complete shardKey have been specified in the','line_number':822,'multiline':False]
['text':' query, this implies that mongos is not doing a broadcast update and that it attached a','line_number':823,'multiline':False]
['text':' shardVersion to the command. Thus it is safe to call getOwnershipFilter','line_number':824,'multiline':False]
['text':' If the shard key of an orphan document is allowed to change, and the document is allowed to','line_number':828,'multiline':False]
['text':' become owned by the shard, the global uniqueness assumption for _id values would be violated.','line_number':829,'multiline':False]
['text':' upsert ','line_number':840,'multiline':True]
['text':' namespace mongo','line_number':847,'multiline':False]
