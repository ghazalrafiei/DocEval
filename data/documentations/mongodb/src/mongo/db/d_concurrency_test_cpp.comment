['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "cxxabi.h"','line_number':30,'multiline':False]
['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':31,'multiline':False]
['text':' max number of threads to use for lock stress','line_number':87,'multiline':False]
['text':' max backward jumps to tolerate','line_number':89,'multiline':False]
['text':'*
 * A RAII object that instantiates a TicketHolder that limits number of allowed global lock
 * acquisitions to numTickets. The opCtx must live as long as the UseReaderWriterGlobalThrottling
 * instance.
 ','line_number':94,'multiline':True]
['text':' TODO SERVER-72616: Remove ifdefs once PriorityTicketHolder is available cross-platform.','line_number':105,'multiline':False]
['text':' For simplicity, no low priority operations will ever be expedited in these tests.','line_number':109,'multiline':False]
['text':'*
     * Returns a vector of Clients of length 'k', each of which has an OperationContext with its
     * lockState set to a LockerImpl.
     ','line_number':155,'multiline':True]
['text':' TODO SERVER-72616: Remove ifdef when PriorityTicketHolder is available cross-platform.','line_number':203,'multiline':False]
['text':' We can only test non-PriorityTicketHolder implementations on non-Linux platforms.','line_number':208,'multiline':False]
['text':' Step 0: Single thread acquires shared lock','line_number':296,'multiline':False]
['text':' Step 4: Wait for t2 to regain its shared lock','line_number':301,'multiline':False]
['text':' Step 5: After t2 becomes blocked, unlock, yielding the mutex to t3','line_number':310,'multiline':False]
['text':' Step 1: Two threads acquire shared lock','line_number':316,'multiline':False]
['text':' Step 2: Wait for t3 to attempt the exclusive lock','line_number':321,'multiline':False]
['text':' Step 3: Yield shared lock','line_number':327,'multiline':False]
['text':' Step 4: Try to regain the shared lock // transfers control to t1','line_number':331,'multiline':False]
['text':' Step 6: Check we actually got back the shared lock','line_number':334,'multiline':False]
['text':' Step 2: Third thread attempts to acquire exclusive lock','line_number':338,'multiline':False]
['text':' Step 5: Actually get the exclusive lock','line_number':341,'multiline':False]
['text':' transfers control to t2','line_number':343,'multiline':False]
['text':' If we destroy the GlobalWrite out of order relative to the DBLock, we will leave the','line_number':403,'multiline':False]
['text':' global lock resource locked in MODE_X. We have to explicitly downgrade this resource to','line_number':404,'multiline':False]
['text':' MODE_IX to allow other write operations to make progress.','line_number':405,'multiline':False]
['text':' This test case illustrates non-recommended usage of the RAII types. See SERVER-30948.','line_number':406,'multiline':False]
['text':' Downgrade global lock resource to MODE_IX to allow other write operations to make','line_number':446,'multiline':False]
['text':' progress.','line_number':447,'multiline':False]
['text':' Downgrade global lock resource to MODE_IX to allow other write operations to make','line_number':485,'multiline':False]
['text':' progress.','line_number':486,'multiline':False]
['text':' Verify that tenant lock survives move.','line_number':718,'multiline':False]
['text':' Take a global lock so that the next one times out.','line_number':735,'multiline':False]
['text':' Take a global lock so that the next one times out.','line_number':867,'multiline':False]
['text':' The main thread takes an exclusive lock, causing the spawned thread to wait when it attempts','line_number':939,'multiline':False]
['text':' to acquire a conflicting lock.','line_number':940,'multiline':False]
['text':' Killing the lock wait should throw an exception.','line_number':944,'multiline':False]
['text':' The main thread takes an exclusive lock, causing the spawned thread to wait when it attempts','line_number':962,'multiline':False]
['text':' to acquire a conflicting lock.','line_number':963,'multiline':False]
['text':' Killing the lock wait should throw an exception.','line_number':967,'multiline':False]
['text':' The main thread takes an exclusive lock, causing the spawned thread to wait when it attempts','line_number':986,'multiline':False]
['text':' to acquire a conflicting lock.','line_number':987,'multiline':False]
['text':' This thread attemps to acquire a conflicting lock, which will block until the first','line_number':990,'multiline':False]
['text':' unlocks.','line_number':991,'multiline':False]
['text':' Killing the lock wait should throw an exception.','line_number':993,'multiline':False]
['text':' The main thread takes an exclusive lock, causing the spawned thread to wait when it attempts','line_number':1005,'multiline':False]
['text':' to acquire a conflicting lock.','line_number':1006,'multiline':False]
['text':' Acquire this later to confirm that it stays unlocked.','line_number':1008,'multiline':False]
['text':' Killing the lock wait should not interrupt it, but rather leave it lock unlocked.','line_number':1011,'multiline':False]
['text':' Should not throw an exception.','line_number':1025,'multiline':False]
['text':' The main thread takes an exclusive lock, causing the spawned thread to wait when it attempts','line_number':1035,'multiline':False]
['text':' to acquire a conflicting lock.','line_number':1036,'multiline':False]
['text':' Acquire this later to confirm that it stays unlocked.','line_number':1038,'multiline':False]
['text':' Killing the lock wait should not interrupt it, but rather leave it lock unlocked.','line_number':1041,'multiline':False]
['text':' Should not throw an exception.','line_number':1054,'multiline':False]
['text':' Kill the operation before acquiring the uncontested lock.','line_number':1062,'multiline':False]
['text':' This should not throw or acquire the lock.','line_number':1067,'multiline':False]
['text':' Take the exclusive lock with the first caller.','line_number':1077,'multiline':False]
['text':' Set a max timeout on the second caller that will override provided lock request deadlines.','line_number':1080,'multiline':False]
['text':' Then requesting a lock with Date_t::max() should cause a LockTimeout error to be thrown','line_number':1081,'multiline':False]
['text':' and then caught by the Lock::InterruptBehavior::kLeaveUnlocked setting.','line_number':1082,'multiline':False]
['text':' Take the exclusive lock with the first caller.','line_number':1102,'multiline':False]
['text':' Set a max timeout on the second caller that will override provided lock request deadlines.','line_number':1105,'multiline':False]
['text':' Then requesting a lock with Date_t::max() should cause a LockTimeout error to be thrown','line_number':1106,'multiline':False]
['text':' and then caught by the Lock::InterruptBehavior::kLeaveUnlocked setting.','line_number':1107,'multiline':False]
['text':' Take the exclusive lock with the first caller.','line_number':1125,'multiline':False]
['text':' Set a max timeout on the second caller that will override provided lock request deadlines.','line_number':1128,'multiline':False]
['text':' Then requesting a lock with Date_t::max() should cause a LockTimeout error to be thrown.','line_number':1129,'multiline':False]
['text':' Take the exclusive lock with the first caller.','line_number':1153,'multiline':False]
['text':' Set a max timeout on the second caller that will override provided lock request deadlines.','line_number':1156,'multiline':False]
['text':' Then requesting a lock with Date_t::max() should cause a LockTimeout error to be thrown.','line_number':1157,'multiline':False]
['text':' Take the exclusive lock with the first caller.','line_number':1180,'multiline':False]
['text':' Set a max timeout on the second caller that will override provided lock request','line_number':1184,'multiline':False]
['text':' deadlines.','line_number':1185,'multiline':False]
['text':' Then requesting a lock with Date_t::max() should cause a LockTimeout error to be thrown.','line_number':1186,'multiline':False]
['text':' GlobalLock failed, but the RSTL should be successfully acquired and pending unlocked.','line_number':1194,'multiline':False]
['text':' The main thread takes an exclusive lock, causing the spawned thread to wait when it attempts','line_number':1208,'multiline':False]
['text':' to acquire a conflicting lock.','line_number':1209,'multiline':False]
['text':' This lock conflicts with the other DBLock.','line_number':1214,'multiline':False]
['text':' The main thread takes an exclusive lock, causing the spawned thread wait when it attempts to','line_number':1226,'multiline':False]
['text':' acquire a conflicting lock.','line_number':1227,'multiline':False]
['text':' Killing the lock wait should not interrupt it.','line_number':1230,'multiline':False]
['text':' NOLINT.','line_number':1234,'multiline':False]
['text':' Should not throw an exception.','line_number':1238,'multiline':False]
['text':' The main thread takes an exclusive lock, causing the spawned thread to wait when it attempts','line_number':1247,'multiline':False]
['text':' to acquire a conflicting lock.','line_number':1248,'multiline':False]
['text':' Killing the lock wait should not interrupt it.','line_number':1252,'multiline':False]
['text':' NOLINT.','line_number':1256,'multiline':False]
['text':' Should not throw an exception.','line_number':1261,'multiline':False]
['text':' Attempt to take a conflicting lock, which will fail.','line_number':1274,'multiline':False]
['text':' Release the conflicting lock.','line_number':1278,'multiline':False]
['text':' After the operation has been killed, the lockComplete request should fail, even though the','line_number':1286,'multiline':False]
['text':' lock is uncontested.','line_number':1287,'multiline':False]
['text':' Database ownership options to test.','line_number':1366,'multiline':False]
['text':' Owned by a tenant and not.','line_number':1368,'multiline':False]
['text':' Owned by a tenant only.','line_number':1370,'multiline':False]
['text':' Only global lock acquired.','line_number':1385,'multiline':False]
['text':' Global and tenant locks acquired.','line_number':1394,'multiline':False]
['text':' Global, tenant, db locks acquired.','line_number':1411,'multiline':False]
['text':' If database is not locked with intent lock, a collection in the database is','line_number':1463,'multiline':False]
['text':' locked for the same lock mode.','line_number':1464,'multiline':False]
['text':' Busy-wait until everybody is ready','line_number':1549,'multiline':False]
['text':' Only one upgrader legal ','line_number':1555,'multiline':True]
['text':' test locking local only -- with no preceding lock','line_number':1604,'multiline':False]
['text':' Busy-wait until everybody is ready','line_number':1673,'multiline':False]
['text':' Intentional fall through','line_number':1688,'multiline':False]
['text':' Test that throttling will correctly handle timeouts.','line_number':1737,'multiline':False]
['text':' Test that the timeout did result in at least the requested wait.','line_number':1751,'multiline':False]
['text':' Timeouts should be reasonably immediate. In maxTries attempts at least one test','line_number':1754,'multiline':False]
['text':' should be able to complete within a second, as the theoretical test duration is less','line_number':1755,'multiline':False]
['text':' than 50 ms.','line_number':1756,'multiline':False]
['text':' Prevent the enforcement of ticket throttling.','line_number':1773,'multiline':False]
['text':' Both locks should be acquired immediately because there is no throttling.','line_number':1777,'multiline':False]
['text':' Limit the locker to 1 ticket at a time.','line_number':1785,'multiline':False]
['text':' A second Locker should not be able to acquire a ticket.','line_number':1801,'multiline':False]
['text':' Now a second Locker can acquire a ticket.','line_number':1811,'multiline':False]
['text':' Now a second Locker cannot acquire a ticket.','line_number':1819,'multiline':False]
['text':' Limit the locker to 1 ticket at a time.','line_number':1827,'multiline':False]
['text':' This thread should block because it cannot acquire a ticket and then get interrupted.','line_number':1848,'multiline':False]
['text':' Limit the locker to 0 tickets at a time.','line_number':1854,'multiline':False]
['text':' Limit the locker to 0 tickets at a time.','line_number':1873,'multiline':False]
['text':' Take the only ticket available.','line_number':1919,'multiline':False]
['text':' Block until a ticket is available.','line_number':1926,'multiline':False]
['text':' NOLINT.','line_number':1930,'multiline':False]
['text':' Relase the only ticket available to unblock the other thread.','line_number':1935,'multiline':False]
['text':' This should not throw.','line_number':1939,'multiline':False]
['text':' Limit the locker to 1 ticket at a time.','line_number':1943,'multiline':False]
['text':' A second Locker should not be able to acquire a ticket.','line_number':1960,'multiline':False]
['text':' Now a second Locker can acquire a ticket.','line_number':1971,'multiline':False]
['text':' This thread should block because it cannot acquire a ticket.','line_number':1976,'multiline':False]
['text':' Limit the locker to 1 ticket at a time.','line_number':1983,'multiline':False]
['text':' Wait for the database X lock to conflict.','line_number':2013,'multiline':False]
['text':' Limit the locker to 1 ticket at a time.','line_number':2025,'multiline':False]
['text':' NOLINT.','line_number':2067,'multiline':False]
['text':' Does not throw.','line_number':2069,'multiline':False]
['text':' NOLINT.','line_number':2111,'multiline':False]
['text':' Does not throw.','line_number':2114,'multiline':False]
['text':' NOLINT.','line_number':2208,'multiline':False]
['text':' Does not throw.','line_number':2211,'multiline':False]
['text':' Currently, we are allowed to acquire IX and X lock modes for RSTL. To overcome it,','line_number':2247,'multiline':False]
['text':' this fail point will allow the test to acquire RSTL in any lock modes.','line_number':2248,'multiline':False]
['text':' Build a queue of MODE_S <- MODE_X <- MODE_IS, with MODE_S granted.','line_number':2256,'multiline':False]
['text':' A MODE_IS should be granted due to compatibleFirst policy.','line_number':2264,'multiline':False]
['text':' Currently, we are allowed to acquire IX and X lock modes for RSTL. To overcome it,','line_number':2275,'multiline':False]
['text':' this fail point will allow the test to acquire RSTL in any lock modes.','line_number':2276,'multiline':False]
['text':' Build a queue of MODE_X <- MODE_S <- MODE_IX <- MODE_IS, with MODE_X granted.','line_number':2285,'multiline':False]
['text':' Now release the MODE_X and ensure that MODE_S will switch policy to compatibleFirst','line_number':2300,'multiline':False]
['text':' Now release the MODE_S and ensure that MODE_IX gets locked.','line_number':2308,'multiline':False]
['text':' Currently, we are allowed to acquire IX and X lock modes for RSTL. To overcome it,','line_number':2315,'multiline':False]
['text':' this fail point will allow the test to acquire RSTL in any lock modes.','line_number':2316,'multiline':False]
['text':' Build a queue of MODE_X <- MODE_S <- MODE_X <- MODE_IX <- MODE_IS, with the first MODE_X','line_number':2326,'multiline':False]
['text':' granted and check that releasing it will result in the MODE_IS being granted.','line_number':2327,'multiline':False]
['text':' Now request MODE_S: it will be first in the pending list due to EnqueueAtFront policy.','line_number':2336,'multiline':False]
['text':' Now release the granted MODE_X and ensure that MODE_S will switch policy to compatibleFirst,','line_number':2349,'multiline':False]
['text':' not locking the MODE_X or MODE_IX, but instead granting the final MODE_IS.','line_number':2350,'multiline':False]
['text':' Do some busy waiting to trigger different timings. The atomic load prevents compilers','line_number':2376,'multiline':False]
['text':' from optimizing the loop away.','line_number':2377,'multiline':False]
['text':' Thread putting state in/out of read-only CompatibleFirst mode.','line_number':2388,'multiline':False]
['text':' Here, actually try to acquire a lock without waiting, and check whether','line_number':2422,'multiline':False]
['text':' we should have gotten the lock or not. Use MODE_IS in 95% of the cases,','line_number':2423,'multiline':False]
['text':' and MODE_S in only 5, as that stressing the partitioning scheme and','line_number':2424,'multiline':False]
['text':' policy changes more as thread 0 acquires/releases its MODE_S lock.','line_number':2425,'multiline':False]
['text':' If thread 0 is holding the MODE_S lock while we tried to acquire a','line_number':2432,'multiline':False]
['text':' MODE_IS or MODE_S lock, the CompatibleFirst policy guarantees success.','line_number':2433,'multiline':False]
['text':' namespace','line_number':2495,'multiline':False]
['text':' The first opCtx holds the RSTL.','line_number':2555,'multiline':False]
['text':' The second opCtx enqueues the lock request but cannot acquire it.','line_number':2562,'multiline':False]
['text':' The second opCtx times out.','line_number':2567,'multiline':False]
['text':' Check the first opCtx is still holding the RSTL.','line_number':2572,'multiline':False]
['text':' The first opCtx holds the RSTL.','line_number':2585,'multiline':False]
['text':' The second opCtx enqueues the lock request but cannot acquire it.','line_number':2594,'multiline':False]
['text':' The first opCtx unlocks so the second opCtx acquires it.','line_number':2599,'multiline':False]
['text':' The first opCtx holds the RSTL.','line_number':2618,'multiline':False]
['text':' The second opCtx enqueues the lock request but cannot acquire it.','line_number':2624,'multiline':False]
['text':' secondRSTL is going to go out of scope with the lock result as LOCK_WAITING. As a result,','line_number':2629,'multiline':False]
['text':' ReplicationStateTransitionLockGuard destructor will be called and we should expect','line_number':2630,'multiline':False]
['text':' the RSTL lock state cleaned from both locker and lock manager.','line_number':2631,'multiline':False]
['text':' Verify that the RSTL lock state is cleaned from secondOpCtx's locker.','line_number':2634,'multiline':False]
['text':' Now, make first opCtx to release the lock to test if we can reacquire the lock again.','line_number':2637,'multiline':False]
['text':' If we haven't cleaned the RSTL lock state from the conflict queue in the lock manager after','line_number':2642,'multiline':False]
['text':' the destruction of secondRSTL, first opCtx won't be able to reacquire the RSTL in X mode.','line_number':2643,'multiline':False]
['text':' MODE_S attempt.','line_number':2661,'multiline':False]
['text':' NOLINT.','line_number':2663,'multiline':False]
['text':' Wait for the thread to attempt to acquire the global lock in MODE_S.','line_number':2667,'multiline':False]
['text':' MODE_X attempt.','line_number':2678,'multiline':False]
['text':' NOLINT.','line_number':2680,'multiline':False]
['text':' Wait for the thread to attempt to acquire the global lock in MODE_X.','line_number':2684,'multiline':False]
['text':' Granted MODE_X lock, fail incoming MODE_S and MODE_X.','line_number':2702,'multiline':False]
['text':' MODE_S attempt.','line_number':2712,'multiline':False]
['text':' NOLINT.','line_number':2714,'multiline':False]
['text':' Wait for the thread to attempt to acquire the collection lock in MODE_S.','line_number':2719,'multiline':False]
['text':' MODE_X attempt.','line_number':2731,'multiline':False]
['text':' NOLINT.','line_number':2733,'multiline':False]
['text':' Wait for the thread to attempt to acquire the collection lock in MODE_X.','line_number':2738,'multiline':False]
['text':' namespace','line_number':2786,'multiline':False]
['text':' namespace mongo','line_number':2787,'multiline':False]
