['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':40,'multiline':False]
['text':' IWYU pragma: keep','line_number':56,'multiline':False]
['text':'*
 * Registers a Parser so it can be called from parseExpression and friends.
 *
 * As an example, if your expression looks like {"$foo": [1,2,3]} you would add this line:
 * REGISTER_STABLE_EXPRESSION(foo, ExpressionFoo::parse);
 *
 * An expression registered this way can be used in any featureCompatibilityVersion and will be
 * considered part of the stable API.
 ','line_number':104,'multiline':True]
['text':'*
 * Registers a Parser so it can be called from parseExpression and friends. Use this version if your
 * expression can only be persisted to a catalog data structure in a feature compatibility version
 * that enables the featureFlag.
 *
 * As an example, if your expression looks like {"$foo": [1,2,3]}, and can only be used in a feature
 * compatibility version that enables featureFlag, you would add this line:
 * REGISTER_EXPRESSION_WITH_FEATURE_FLAG(
 *  foo,
 *  ExpressionFoo::parse,
 *  AllowedWithApiStrict::kNeverInVersion1,
 *  AllowedWithClientType::kAny,
 *  featureFlag);
 *
 * Generally new language features should be excluded from the stable API for a stabilization period
 * to allow for incorporating feedback or fixing accidental semantics bugs.
 *
 * If 'allowedWithApiStrict' is set to 'kSometimes', this expression is expected to register its own
 * parser and enforce the 'sometimes' behavior during that invocation. No extra validation will be
 * done here.
 ','line_number':125,'multiline':True]
['text':'*
 * Registers a Parser only if test commands are enabled. Use this if your expression is only used
 * for testing purposes.
 ','line_number':162,'multiline':True]
['text':'*
 * You can specify a condition, evaluated during startup,
 * that decides whether to register the parser.
 *
 * For example, you could check a feature flag, and register the parser only when it's enabled.
 *
 * Note that the condition is evaluated only once, during a MONGO_INITIALIZER. Don't specify
 * a condition that can change at runtime, such as FCV. (Feature flags are ok, because they
 * cannot be toggled at runtime.)
 *
 * This is the most general REGISTER_EXPRESSION* macro, which all others should delegate to.
 ','line_number':177,'multiline':True]
['text':'*
     * Represents new paths computed by an expression. Computed paths are partitioned into renames
     * and non-renames. See the comments for Expression::getComputedPaths() for more information.
     ','line_number':211,'multiline':True]
['text':' Non-rename computed paths.','line_number':216,'multiline':False]
['text':' Mappings from the old name of a path before applying this expression, to the new one','line_number':219,'multiline':False]
['text':' after applying this expression. This map includes solely simple field renaming','line_number':220,'multiline':False]
['text':' expression.','line_number':221,'multiline':False]
['text':' Mappings from the old name of a path before applying this expression. This map includes','line_number':224,'multiline':False]
['text':' expressions which have dotted notation on the right side.','line_number':225,'multiline':False]
['text':'*
     * Optimize the Expression.
     *
     * This provides an opportunity to do constant folding, or to collapse nested operators that
     * have the same precedence, such as $add, $and, or $or.
     *
     * The Expression will be replaced with the return value, which may or may not be the same
     * object. In the case of constant folding, a computed expression may be replaced by a constant.
     *
     * Returns the optimized Expression.
     ','line_number':231,'multiline':True]
['text':'*
     * Serialize the Expression tree recursively.
     *
     * If 'explain' is false, the returned Value must result in the same Expression when parsed by
     * parseOperand().
     ','line_number':246,'multiline':True]
['text':'*
     * Evaluate the expression with respect to the Document given by 'root' and the Variables given
     * by 'variables'. It is an error to supply a Variables argument whose built-in variables (like
     * $$NOW) are not set. This method is thread-safe, so long as the 'variables' passed in here is
     * not shared between threads.
     ','line_number':254,'multiline':True]
['text':'*
     * Returns information about the paths computed by this expression. This only needs to be
     * overridden by expressions that have renaming semantics, where optimization code could take
     * advantage of knowledge of these renames.
     *
     * Partitions paths involved in this expression into the set of computed paths and the set of
     * ("new" => "old") rename mappings. Here "new" refers to the name of the path after applying
     * this expression, whereas "old" refers to the name of the path before applying this
     * expression.
     *
     * The 'exprFieldPath' is the field path at which the result of this expression will be stored.
     * This is used to determine the value of the "new" path created by the rename.
     *
     * The 'renamingVar' is needed for checking whether a field path is a rename. For example, at
     * the top level only field paths that begin with the ROOT variable, as in "$$ROOT.path", are
     * renames. A field path such as "$$var.path" is not a rename.
     *
     * Now consider the example of a rename expressed via a $map:
     *
     *    {$map: {input: "$array", as: "iter", in: {...}}}
     *
     * In this case, only field paths inside the "in" clause beginning with "iter", such as
     * "$$iter.path", are renames.
     ','line_number':262,'multiline':True]
['text':'*
     * This allows an arbitrary class to implement logic which gets dispatched to at runtime
     * depending on the type of the Expression.
     ','line_number':291,'multiline':True]
['text':'*
     * Parses a BSON Object that could represent an object literal or a functional expression like
     * $add.
     *
     * Calls parseExpression() on any sub-document (including possibly the entire document) which
     * consists of a single field name starting with a '$'.
     ','line_number':298,'multiline':True]
['text':'*
     * Parses a BSONObj which has already been determined to be a functional expression.
     *
     * Throws an error if 'obj' does not contain exactly one field, or if that field's name does not
     * match a registered expression name.
     ','line_number':309,'multiline':True]
['text':'*
     * Parses a BSONElement which is an argument to an Expression.
     *
     * An argument is allowed to be another expression, or a literal value, so this can call
     * parseObject(), ExpressionFieldPath::parse(), ExpressionArray::parse(), or
     * ExpressionConstant::parse() as necessary.
     ','line_number':319,'multiline':True]
['text':'*
     * Return whether 'name' refers to an expression in the language.
     ','line_number':330,'multiline':True]
['text':'
      Produce a field path std::string with the field prefix removed.

      Throws an error if the field prefix is not present.

      @param prefixedField the prefixed field
      @returns the field path with the prefix removed
     ','line_number':335,'multiline':True]
['text':'*
     * Registers an Parser so it can be called from parseExpression.
     *
     * DO NOT call this method directly. Instead, use the REGISTER_EXPRESSION macro defined in this
     * file.
     ','line_number':345,'multiline':True]
['text':'*
     * Helper to determine whether this expression always evaluates to the same value.
     ','line_number':380,'multiline':True]
['text':'*
     * Owning container for all sub-Expressions.
     *
     * Some derived classes contain named fields since they originate from user syntax containing
     * field names. These classes contain alternate data structures or object members for accessing
     * children. These structures or object members are expected to reference this data structure.
     * In addition this structure should not be modified by named-field derived classes to avoid
     * invalidating references.
     ','line_number':400,'multiline':True]
['text':' Tracks the latest Variable ID which is defined outside of this expression. Useful for','line_number':412,'multiline':False]
['text':' dependency analysis to avoid reporting dependencies to local variables defined by this','line_number':413,'multiline':False]
['text':' Expression.','line_number':414,'multiline':False]
['text':'*
 * A constant expression. Repeated calls to evaluate() will always return the same thing.
 ','line_number':419,'multiline':True]
['text':'*
     * Creates a new ExpressionConstant with value 'value'.
     ','line_number':432,'multiline':True]
['text':'*
     * Returns true if 'expression' is nullptr or if 'expression' is an instance of an
     * ExpressionConstant.
     ','line_number':442,'multiline':True]
['text':'*
     * Returns true if 'expression' is an instance of an ExpressionConstant.
     ','line_number':450,'multiline':True]
['text':'*
     * Returns true if every expression in 'expressions' is either a nullptr or an instance of an
     * ExpressionConstant.
     ','line_number':462,'multiline':True]
['text':'*
     * Returns the constant value represented by this Expression.
     ','line_number':479,'multiline':True]
['text':'*
 * Inherit from ExpressionVariadic or ExpressionFixedArity instead of directly from this class.
 ','line_number':506,'multiline':True]
['text':'
      Add an operand to the n-ary expression.

      @param pExpression the expression to add
    ','line_number':514,'multiline':True]
['text':'/ Inherit from ExpressionVariadic or ExpressionFixedArity instead of directly from this class.','line_number':549,'multiline':False]
['text':'/ Inherit from this class if your expression takes a variable number of arguments.','line_number':569,'multiline':False]
['text':' As a special case, we would like to serialize a variadic number of children as','line_number':579,'multiline':False]
['text':' "?array<?subtype>" if they are all constant. Check for that here, otherwise default to','line_number':580,'multiline':False]
['text':' the normal one-by-one serialization of the children.','line_number':581,'multiline':False]
['text':' We could evaluate the expression right here and now and end up with just the one','line_number':584,'multiline':False]
['text':' constant answer, but this is not an optimization funciton, it is meant to just','line_number':585,'multiline':False]
['text':' serialize what we have, so let's preserve the array of constants.','line_number':586,'multiline':False]
['text':'*
 * Inherit from this class if your expression can take a range of arguments, e.g. if it has some
 * optional arguments.
 ','line_number':606,'multiline':True]
['text':'/ Inherit from this class if your expression takes a fixed number of arguments.','line_number':627,'multiline':False]
['text':'*
 * Used to make Accumulators available as Expressions, e.g., to make $sum available as an Expression
 * use "REGISTER_STABLE_EXPRESSION(sum, ExpressionAccumulator<AccumulatorSum>::parse);".
 ','line_number':644,'multiline':True]
['text':' If a single array arg is given, loop through it passing each member to the accumulator.','line_number':660,'multiline':False]
['text':' If a single, non-array arg is given, pass it directly to the accumulator.','line_number':661,'multiline':False]
['text':' If multiple arguments are given, pass all arguments to the accumulator.','line_number':672,'multiline':False]
['text':' Return false if a single argument is given to avoid a single array argument being treated','line_number':681,'multiline':False]
['text':' as an array instead of as a list of arguments.','line_number':682,'multiline':False]
['text':' Evaluate and initialize 'n'.','line_number':728,'multiline':False]
['text':' Verify that '_output' produces an array and pass each element to 'process'.','line_number':731,'multiline':False]
['text':' On a scalar value, all percentiles are the same for all methods.','line_number':778,'multiline':False]
['text':' On small datasets, which are likely to be the inputs for the expression, creating','line_number':785,'multiline':False]
['text':' t-digests is inefficient, so instead we use DiscretePercentile algo directly for','line_number':786,'multiline':False]
['text':' both "discrete" and "approximate" methods.','line_number':787,'multiline':False]
['text':' Delegate to the accumulator. Note: it would be more efficient to use the','line_number':799,'multiline':False]
['text':' percentile algorithms directly rather than an accumulator, as it would reduce','line_number':800,'multiline':False]
['text':' heap alloc, virtual calls and avoid unnecessary for expressions memory tracking.','line_number':801,'multiline':False]
['text':' This path currently cannot be executed as we only support continuous percentiles.','line_number':802,'multiline':False]
['text':' merging ','line_number':805,'multiline':True]
['text':' toBeMerged ','line_number':807,'multiline':True]
['text':' No numeric values have been found for the expression to process.','line_number':811,'multiline':False]
['text':'*
 * Inherit from this class if your expression takes exactly one numeric argument.
 ','line_number':833,'multiline':True]
['text':'*
 * Inherit from this class if your expression takes exactly two numeric arguments.
 ','line_number':863,'multiline':True]
['text':'*
     * Evaluate performs the type checking necessary to make sure that both arguments are numeric,
     * then calls the evaluateNumericArgs on the two numeric args:
     * 1. If either input is nullish, it returns null.
     * 2. If either input is not numeric, it throws an error.
     * 3. Call evaluateNumericArgs on the two numeric args.
     ','line_number':877,'multiline':True]
['text':'*
     *  Evaluate the expression on exactly two numeric arguments.
     ','line_number':903,'multiline':True]
['text':'*
 * Inherit from this class if your expression works with date types, and accepts either a single
 * argument which is a date, or an object {date: <date>, timezone: <string>}.
 ','line_number':909,'multiline':True]
['text':'*
     * Always serializes to the full {date: <date arg>, timezone: <timezone arg>} format, leaving
     * off the timezone if not specified.
     ','line_number':935,'multiline':True]
['text':' Everything is a constant, so we can turn into a constant.','line_number':952,'multiline':False]
['text':' Assume this is an expression specification representing the date argument','line_number':968,'multiline':False]
['text':' like {$add: [<date>, 1000]}.','line_number':969,'multiline':False]
['text':' It's an object specifying the date and timezone options like {date: <date>,','line_number':975,'multiline':False]
['text':' timezone: <timezone>}.','line_number':976,'multiline':False]
['text':' We accept an argument wrapped in a single array. For example, either {$week: <date>}','line_number':1006,'multiline':False]
['text':' or {$week: [<date>]} are valid, but not {$week: [{date: <date>}]}.','line_number':1007,'multiline':False]
['text':' Exhausting the other possibilities, we are left with a literal value which should be','line_number':1011,'multiline':False]
['text':' treated as the date argument.','line_number':1012,'multiline':False]
['text':'*
     * Subclasses should implement this to do their actual date-related logic. Uses 'timezone' to
     * evaluate the expression against 'data'. If the user did not specify a time zone, 'timezone'
     * will represent the UTC zone.
     ','line_number':1024,'multiline':True]
['text':' The position of the expression representing the date argument.','line_number':1054,'multiline':False]
['text':' The position of the expression representing the timezone argument.','line_number':1057,'multiline':False]
['text':' The name of this expression, e.g. $week or $month.','line_number':1060,'multiline':False]
['text':' Pre-parsed timezone, if the above expression is a constant.','line_number':1063,'multiline':False]
['text':'*
     * Adds two values as if by {$add: [{$const: lhs}, {$const: rhs}]}.
     *
     * If either argument is nullish, returns BSONNULL.
     *
     * Otherwise, returns ErrorCodes::TypeMismatch.
     ','line_number':1088,'multiline':True]
['text':' ExpressionAdd is left associative because it processes its operands by iterating','line_number':1106,'multiline':False]
['text':' left-to-right through its _children vector, but the order of operations impacts the result','line_number':1107,'multiline':False]
['text':' due to integer overflow, floating-point rounding and type promotion.','line_number':1108,'multiline':False]
['text':'*
     * Enumeration of comparison operators. Any changes to these values require adjustment of
     * the lookup table in the implementation.
     ','line_number':1410,'multiline':True]
['text':' return true for a == b, false otherwise','line_number':1415,'multiline':False]
['text':' return true for a != b, false otherwise','line_number':1416,'multiline':False]
['text':' return true for a > b, false otherwise','line_number':1417,'multiline':False]
['text':' return true for a >= b, false otherwise','line_number':1418,'multiline':False]
['text':' return true for a < b, false otherwise','line_number':1419,'multiline':False]
['text':' return true for a <= b, false otherwise','line_number':1420,'multiline':False]
['text':' return -1, 0, 1 for a < b, a == b, a > b','line_number':1421,'multiline':False]
['text':'*
     * Returns true if this expression has parameter 'format' specified, otherwise false.
     ','line_number':1564,'multiline':True]
['text':'*
     * Returns true if this expression has parameter 'timezone' specified, otherwise false.
     ','line_number':1571,'multiline':True]
['text':'*
     * Returns true if this expression has parameter 'onError' specified, otherwise false.
     ','line_number':1578,'multiline':True]
['text':'*
     * Returns true if this expression has parameter 'onNull' specified, otherwise false.
     ','line_number':1585,'multiline':True]
['text':' Pre-parsed timezone, if the above expression is a constant.','line_number':1599,'multiline':False]
['text':'*
     * This function checks whether a field is a number.
     *
     * If 'field' is null, the default value is returned trough the 'returnValue' out
     * parameter and the function returns true.
     *
     * If 'field' is not null:
     * - if the value is "nullish", the function returns false.
     * - if the value can not be coerced to an integral value, a UserException is thrown.
     * - otherwise, the coerced integral value is returned through the 'returnValue'
     *   out parameter, and the function returns true.
     ','line_number':1638,'multiline':True]
['text':'*
     * This function has the same behavior as evaluteNumberWithDefault(), except that it uasserts if
     * the resulting value is not in the range defined by kMaxValueForDatePart and
     * kMinValueForDatePart.
     ','line_number':1657,'multiline':True]
['text':' Pre-parsed timezone, if the above expression is a constant.','line_number':1681,'multiline':False]
['text':' Some date conversions spend a long time iterating through date tables when dealing with large','line_number':1684,'multiline':False]
['text':' input numbers, so we place a reasonable limit on the magnitude of any argument to','line_number':1685,'multiline':False]
['text':' $dateFromParts: inputs that fit within a 16-bit int are permitted.','line_number':1686,'multiline':False]
['text':'*
     * The iso8601 argument controls whether to output ISO8601 elements or natural calendar.
     ','line_number':1696,'multiline':True]
['text':' Pre-parsed timezone, if the above expression is a constant.','line_number':1727,'multiline':False]
['text':'*
     * Returns true if this expression has parameter 'format' specified, otherwise false.
     ','line_number':1757,'multiline':True]
['text':'*
     * Returns true if this expression has parameter 'timezone' specified, otherwise false.
     ','line_number':1764,'multiline':True]
['text':'*
     * Returns true if this expression has parameter 'onNull' specified, otherwise false.
     ','line_number':1771,'multiline':True]
['text':' Pre-parsed timezone, if the above expression is a constant.','line_number':1784,'multiline':False]
['text':'*
 * $dateDiff expression that determines a difference between two time instants.
 ','line_number':1856,'multiline':True]
['text':'*
     * startDate - an expression that resolves to a Value that is coercible to date.
     * endDate - an expression that resolves to a Value that is coercible to date.
     * unit - expression defining a length of time interval to measure the difference in that
     * resolves to a string Value.
     * timezone - expression defining a timezone to perform the operation in that resolves to a
     * string Value. Can be nullptr.
     * startOfWeek - expression defining the week start day that resolves to a string Value. Can be
     * nullptr.
     ','line_number':1861,'multiline':True]
['text':'*
     * Returns true if this expression has parameter 'timezone' specified, otherwise false.
     ','line_number':1891,'multiline':True]
['text':'*
     * Returns true if this expression has parameter 'startOfWeek' specified, otherwise false.
     ','line_number':1898,'multiline':True]
['text':'*
     * Converts 'value' to Date_t type for $dateDiff expression for parameter 'parameterName'.
     ','line_number':1906,'multiline':True]
['text':' Starting time instant expression. Accepted types: Date_t, Timestamp, OID.','line_number':1913,'multiline':False]
['text':' Ending time instant expression. Accepted types the same as for '_startDate'.','line_number':1916,'multiline':False]
['text':' Length of time interval to measure the difference. Accepted type: std::string. Accepted','line_number':1919,'multiline':False]
['text':' values: enumerators from TimeUnit enumeration.','line_number':1920,'multiline':False]
['text':' Timezone to use for the difference calculation. Accepted type: std::string. If not specified,','line_number':1923,'multiline':False]
['text':' UTC is used.','line_number':1924,'multiline':False]
['text':' First/start day of the week to use for the date difference calculation when time unit is the','line_number':1927,'multiline':False]
['text':' week. Accepted type: std::string. If not specified, "sunday" is used.','line_number':1928,'multiline':False]
['text':' Pre-parsed time unit, if the above expression is a constant.','line_number':1931,'multiline':False]
['text':' Pre-parsed timezone, if the above expression is a constant.','line_number':1934,'multiline':False]
['text':' Pre-parsed start of week, if the above expression is a constant.','line_number':1937,'multiline':False]
['text':'*
     * Divides two values as if by {$divide: [{$const: numerator}, {$const: denominator]}.
     *
     * Returns BSONNULL if either argument is nullish.
     *
     * Returns ErrorCodes::TypeMismatch if either argument is non-nullish and non-numeric.
     * Returns ErrorCodes::BadValue if the denominator is zero.
     ','line_number':1946,'multiline':True]
['text':'*
     * Checks whether this field path is exactly "$$ROOT".
     ','line_number':1996,'multiline':True]
['text':'*
     * Checks whether this field path starts with a variable besides ROOT.
     *
     * For example, these are variable references:
     *   "$$NOW"
     *   "$$NOW.x"
     * and these are not:
     *   "$x"
     *   "$$ROOT"
     *   "$$ROOT.x"
     ','line_number':2003,'multiline':True]
['text':'
      Create a field path expression using old semantics (rooted off of CURRENT).

      // NOTE: this method is deprecated and only used by tests
      // TODO remove this method in favor of parse()

      Evaluation will extract the value associated with the given field
      path from the source document.

      @param fieldPath the field path string, without any leading document
        indicator
      @returns the newly created field path expression
     ','line_number':2022,'multiline':True]
['text':' Parse from the raw std::string from the user with the "$" prefixes.','line_number':2038,'multiline':False]
['text':' Create from a non-prefixed string. Assumes path not variable.','line_number':2042,'multiline':False]
['text':' Create from a non-prefixed string. Assumes variable not path.','line_number':2045,'multiline':False]
['text':'*
     * Returns true if this expression logically represents the path 'dottedPath'. For example, if
     * 'dottedPath' is 'a.b' and this FieldPath is '$$CURRENT.a.b', returns true.
     ','line_number':2049,'multiline':True]
['text':'*
     * Finds an applicable rename from 'renameList' and creates a copy of ExpressionFieldPath in
     * which the the rename is substituted. If there is no applicable rename, returns nullptr. Each
     * pair in 'renameList' specifies a path prefix that should be renamed (as the first element)
     * and the path components that should replace the renamed prefix (as the second element).
     ','line_number':2070,'multiline':True]
['text':'*
     * Checks if any key of 'renameList' map is a prefix of this ExpressionFieldPath's path. It
     * would mean that this ExpressionFieldPath is renameable by 'renameList' if so.
     ','line_number':2079,'multiline':True]
['text':'
      Internal implementation of evaluate(), used recursively.

      The internal implementation doesn't just use a loop because of
      the possibility that we need to skip over an array.  If the path
      is "a.b.c", and a is an array, then we fan out from there, and
      traverse "b.c" for each element of a:[...].  This requires that
      a be an array of objects in order to navigate more deeply.

      @param index current path field index to extract
      @param input current document traversed to (not the top-level one)
      @returns the field found; could be an array
     ','line_number':2102,'multiline':True]
['text':' Helper for evaluatePath to handle Array case','line_number':2117,'multiline':False]
['text':' The array to iterate over.','line_number':2158,'multiline':False]
['text':' The expression determining whether each element should be present in the result array.','line_number':2160,'multiline':False]
['text':' The name of the variable to set to each element in the array.','line_number':2163,'multiline':False]
['text':' The id of the variable to set.','line_number':2165,'multiline':False]
['text':' The optional expression determining how many elements should be present in the result array.','line_number':2167,'multiline':False]
['text':'*
     * When given 'operands' which correspond to the arguments to $indexOfArray, evaluates and
     * validates the target value, starting index, and ending index arguments and returns their
     * values as a Arguments struct. The starting index and ending index are optional, so as default
     * 'startIndex' will be 0 and 'endIndex' will be the length of the input array. Throws a
     * UserException if the values are found to be invalid in some way, e.g. if the indexes are not
     * numbers.
     ','line_number':2299,'multiline':True]
['text':'*
 * Implements indexOf behavior for strings with UTF-8 encoding.
 ','line_number':2337,'multiline':True]
['text':' Index of the last element in the '_children' list.','line_number':2399,'multiline':False]
['text':' These ids are ordered to match their corresponding _children expressions.','line_number':2404,'multiline':False]
['text':' name of variable to set','line_number':2527,'multiline':False]
['text':' id of variable to set','line_number':2528,'multiline':False]
['text':' yields array to iterate','line_number':2529,'multiline':False]
['text':' yields results to be added to output array','line_number':2530,'multiline':False]
['text':'*
     * Multiplies two values together as if by evaluate() on
     *     {$multiply: [{$const: lhs}, {$const: rhs}]}.
     *
     * Note that evaluate() does not use apply() directly, because when $multiply takes more than
     * two arguments, it uses a wider intermediate state than Value.
     *
     * Returns BSONNULL if either argument is nullish.
     *
     * Returns ErrorCodes::TypeMismatch if any argument is non-nullish, non-numeric.
     ','line_number':2656,'multiline':True]
['text':' ExpressionMultiply is left associative because it processes its operands by iterating','line_number':2677,'multiline':False]
['text':' left-to-right through its _children vector, but the order of operations impacts the result','line_number':2678,'multiline':False]
['text':' due to integer overflow, floating-point rounding and type promotion.','line_number':2679,'multiline':False]
['text':'*
 * This class is used to represent expressions that create object literals, such as the value of
 * '_id' in this group stage:
 *   {$group: {
 *     _id: {b: "$a", c: {$add: [4, "$c"]}}  <- This is represented as an ExpressionObject.
 *     ...
 *   }}
 ','line_number':2737,'multiline':True]
['text':'*
     * Parses and constructs an ExpressionObject from 'obj'.
     ','line_number':2756,'multiline':True]
['text':'*
     * This ExpressionObject must outlive the returned vector.
     ','line_number':2763,'multiline':True]
['text':' The mapping from field name to expression within this object. This needs to respect the order','line_number':2789,'multiline':False]
['text':' in which the fields were specified in the input BSON.','line_number':2790,'multiline':False]
['text':' These are owned by this->Expression::_children. They are references to intrusive_ptr instead','line_number':2925,'multiline':False]
['text':' of direct references to Expression because we need to be able to replace each child in','line_number':2926,'multiline':False]
['text':' optimize() without invalidating the references.','line_number':2927,'multiline':False]
['text':' The first element in the pair represent the position on the constant in the '_children'','line_number':3053,'multiline':False]
['text':' array. The second element is the constant set.','line_number':3054,'multiline':False]
['text':' Not final, inherited from for optimizations.','line_number':3090,'multiline':False]
['text':' Only commutative when performing binary string comparison. The first value entered when','line_number':3130,'multiline':False]
['text':' multiple collation-equal but binary-unequal values are added will dictate what is stored','line_number':3131,'multiline':False]
['text':' in the set.','line_number':3132,'multiline':False]
['text':'*
 * Expression used for distinct only. This expression unwinds all singly nested arrays along the
 * specified path, but does not descend into doubly nested arrays. The resulting array of values
 * is placed into a specially named field that is consumed by distinct.
 *
 * Aggregation's distinct behavior must match Find's, so numeric path components can be treated
 * as both array indexes and field names.
 ','line_number':3259,'multiline':True]
['text':'*
     * The base class' optimize will think this expression is const because the argument to it must
     * be const. However, the results still change based on the document. Therefore skip optimizing.
     ','line_number':3294,'multiline':True]
['text':' getString asserts if type != string, which is the correct behavior for what we want.','line_number':3308,'multiline':False]
['text':'*
     * Subtracts two values as if by {$subtract: [{$const: lhs}, {$const: rhs}]}.
     *
     * If either argument is nullish, returns BSONNULL.
     *
     * Otherwise, the arguments can be either:
     *     (numeric, numeric)
     *     (Date, Date)       Returns the time difference in milliseconds.
     *     (Date, numeric)    Returns the date shifted earlier by that many milliseconds.
     *
     * Otherwise, returns ErrorCodes::TypeMismatch.
     ','line_number':3507,'multiline':True]
['text':'*
     * Returns the number of cases in the switch expression. Each branch is made up of two
     * expressions ('case' and 'then').
     ','line_number':3568,'multiline':True]
['text':'*
     * Returns a pair of expression pointers representing the 'case' and 'then' expressions for the
     * i-th branch of the switch.
     ','line_number':3576,'multiline':True]
['text':'*
     * Returns the 'default' expression, or nullptr if there is no 'default'.
     ','line_number':3586,'multiline':True]
['text':' Helper for 'optimize()'. Deletes the 'case' and 'then' children associated with the i-th','line_number':3594,'multiline':False]
['text':' branch of the switch.','line_number':3595,'multiline':False]
['text':'*
 * This class is used to implement all three trim expressions: $trim, $ltrim, and $rtrim.
 ','line_number':3642,'multiline':True]
['text':' Returns "trim"/"ltrim"/"rtrim" based on the expression name without the $ sign. ','line_number':3676,'multiline':True]
['text':' Optional, null if not specified.','line_number':3687,'multiline':False]
['text':' "$trim", "$ltrim", or "$rtrim".','line_number':3690,'multiline':False]
['text':'*
     * Creates a $convert expression converting from 'input' to the type given by 'toType'. Leaves
     * 'onNull' and 'onError' unspecified.
     ','line_number':3906,'multiline':True]
['text':'*
     * Object to hold data that is required when calling 'execute()' or 'nextMatch()'.
     ','line_number':3942,'multiline':True]
['text':'*
         * The regex pattern, options, and captures buffer for the current execution context.
         ','line_number':3946,'multiline':True]
['text':'*
         * If 'regex' is constant, 'pcrePtr' will be shared between the active RegexExecutionState
         * and '_initialExecStateForConstantRegex'. If not, then the active RegexExecutionState is
         * the sole owner.
         ','line_number':3954,'multiline':True]
['text':'*
         * The input text and starting position for the current execution context.
         ','line_number':3961,'multiline':True]
['text':'*
         * If either the text input or regex pattern is nullish, then we consider the operation as a
         * whole nullish.
         ','line_number':3968,'multiline':True]
['text':'*
     * Validates the structure of input passed in 'inputExpr'. If valid, generates an initial
     * execution state. This returned object can later be used for calling execute() or nextMatch().
     ','line_number':3977,'multiline':True]
['text':'*
     * Checks if there is a match for the input, options, and pattern of 'executionState'.
     * Returns the pcre::MatchData yielded by that match operation.
     * Will uassert for any errors other than `pcre::Errc::ERROR_NOMATCH`.
     ','line_number':3983,'multiline':True]
['text':'*
     * Finds the next possible match for the given input and pattern that are part of
     * 'executionState'. If there is a match, the function will return a 'Value' object
     * encapsulating the matched string, the code point index of the matched string and a vector
     * representing all the captured substrings. The function will also update the parameters
     * 'startBytePos' and 'startCodePointPos' to the corresponding new indices. If there is no
     * match, the function will return null 'Value' object.
     ','line_number':3990,'multiline':True]
['text':'*
     * Optimizes '$regex*' expressions. If the expression has constant 'regex' and 'options' fields,
     * then it can be optimized. Stores the optimized regex in '_initialExecStateForConstantRegex'
     * so that it can be reused during expression evaluation.
     ','line_number':4000,'multiline':True]
['text':'*
     * If pattern or options are not constants, returns boost::none. Otherwise, return value
     * contains regex pattern and options if they are not null.
     ','line_number':4015,'multiline':True]
['text':'*
     * Expressions which, when evaluated for a given document, produce the the regex pattern, the
     * regex option flags, and the input text to which the regex should be applied.
     ','line_number':4044,'multiline':True]
['text':'*
     * This variable will be set when the $regex* expressions have constant values for their 'regex'
     * and 'options' fields, allowing us to pre-compile the regex and re-use it across the
     * Expression's lifetime.
     ','line_number':4052,'multiline':True]
['text':'*
     * Name of the regex expression.
     ','line_number':4059,'multiline':True]
['text':'*
 * Returns a double-valued random number from 0.0 to 1.0.
 ','line_number':4121,'multiline':True]
['text':'*
     * Subclasses should implement this to do their actual date arithmetics.
     ','line_number':4198,'multiline':True]
['text':' The expression representing the startDate argument.','line_number':4211,'multiline':False]
['text':' Unit of time: year, quarter, week, etc.','line_number':4214,'multiline':False]
['text':' Amount of units to be added or subtracted.','line_number':4217,'multiline':False]
['text':' The expression representing the timezone argument.','line_number':4220,'multiline':False]
['text':' Pre-parsed time unit, if the above expression is a constant.','line_number':4223,'multiline':False]
['text':' Pre-parsed timezone, if the above expression is a constant.','line_number':4226,'multiline':False]
['text':' The name of this expression, e.g. $dateAdd or $dateSubtract.','line_number':4229,'multiline':False]
['text':'*
 * This visitor is used to visit only ExpressionFieldPath nodes in an expression tree and call 'fn'
 * on them.
 *
 * Usage example:
 * bool isFoo = false;
 * FieldPathVisitor visitor([&](const ExpressionFieldPath* expr) {
 *     isFoo = isFoo || expr->isFoo();
 * });
 ','line_number':4300,'multiline':True]
['text':' To avoid overloaded-virtual warnings.','line_number':4312,'multiline':False]
['text':'*
 * $dateTrunc expression that maps a date to a lower bound of a bin of a certain size that the date
 * belongs to. It uses 2000-01-01T00:00:00.000 as a reference point.
 ','line_number':4324,'multiline':True]
['text':'*
     * date - an expression that resolves to a Value that is coercible to a Date.
     * unit - an expression defining units of bin size that resolves to a string Value.
     * binSize - an expression defining a size of bins in given units. Resolves to a Value coercible
     * to a 64-bit integer. Can be nullptr.
     * timezone - an expression defining a timezone to perform the operation in that resolves to a
     * string Value. Can be nullptr.
     * startOfWeek - an expression defining the week start day that resolves to a string Value. Can
     * be nullptr.
     ','line_number':4333,'multiline':True]
['text':'*
     * Returns true if this expression has parameter 'timezone' specified, otherwise false.
     ','line_number':4360,'multiline':True]
['text':'*
     * Returns true if this expression has parameter 'startOfWeek' specified, otherwise false.
     ','line_number':4367,'multiline':True]
['text':'*
     * Returns true if this expression has parameter 'binSize' specified, otherwise false.
     ','line_number':4374,'multiline':True]
['text':'*
     * Converts $dateTrunc expression parameter "date" 'value' to Date_t type.
     ','line_number':4403,'multiline':True]
['text':'*
     * Converts $dateTrunc expression parameter "binSize" 'value' to 64-bit integer.
     ','line_number':4408,'multiline':True]
['text':' Expression that evaluates to a date to truncate. Accepted BSON types: Date, bsonTimestamp,','line_number':4415,'multiline':False]
['text':' jstOID.','line_number':4416,'multiline':False]
['text':' Time units used to describe the size of bins. Accepted BSON type: String. Accepted values:','line_number':4419,'multiline':False]
['text':' enumerators from TimeUnit enumeration.','line_number':4420,'multiline':False]
['text':' Size of bins in time units '_unit'. Accepted BSON types: NumberInt, NumberLong, NumberDouble,','line_number':4423,'multiline':False]
['text':' NumberDecimal. Accepted are only values that can be coerced to a 64-bit integer without loss.','line_number':4424,'multiline':False]
['text':' If not specified, 1 is used.','line_number':4425,'multiline':False]
['text':' Timezone to use for the truncation operation. Accepted BSON type: String. If not specified,','line_number':4428,'multiline':False]
['text':' UTC is used.','line_number':4429,'multiline':False]
['text':' First/start day of the week to use for date truncation when the time unit is the week.','line_number':4432,'multiline':False]
['text':' Accepted BSON type: String. If not specified, "sunday" is used.','line_number':4433,'multiline':False]
['text':' Pre-parsed timezone, if the above expression is a constant.','line_number':4436,'multiline':False]
['text':' Pre-parsed time unit, if the above expression is a constant.','line_number':4439,'multiline':False]
['text':' Pre-parsed bin size, if the above expression is a constant.','line_number':4442,'multiline':False]
['text':' Pre-parsed start of week, if the above expression is a constant.','line_number':4445,'multiline':False]
['text':'*
     * Constructs a $getField expression where 'field' is an expression resolving to a constant
     * string Value and 'input' is an expression resolving to an object Value (or null).
     *
     * If 'input' is nullish (but not missing), $getField evaluates to null. Furthermore, if 'input'
     * does not contain 'field', then $getField returns missing.
     ','line_number':4458,'multiline':True]
['text':'*
     * Constructs a $setField expression where 'field' is a constant string, 'input' is an
     * expression resolving to an object Value (or null), and 'value' is any expression.
     ','line_number':4499,'multiline':True]
['text':' In two's complement, this is all 1's.','line_number':4638,'multiline':False]
['text':' namespace mongo','line_number':4755,'multiline':False]
