['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':37,'multiline':False]
['text':' IWYU pragma: keep','line_number':44,'multiline':False]
['text':'*
 * Constructs a query of the following shape:
 *  {$or: [
 *    {'fieldName': {$eq: 'values[0]'}},
 *    {'fieldName': {$eq: 'values[1]'}},
 *    ...
 *  ]}
 ','line_number':101,'multiline':True]
['text':' Parses $lookup 'from' field. The 'from' field must be a string or one of the following','line_number':130,'multiline':False]
['text':' exceptions:','line_number':131,'multiline':False]
['text':' {from: {db: "config", coll: "cache.chunks.*"}, ...} or','line_number':132,'multiline':False]
['text':' {from: {db: "local", coll: "oplog.rs"}, ...} or','line_number':133,'multiline':False]
['text':' {from: {db: "local", coll: "tenantMigration.oplogView"}, ...} .','line_number':134,'multiline':False]
['text':' The object syntax only works for 'cache.chunks.*', 'local.oplog.rs', and','line_number':137,'multiline':False]
['text':' 'local.tenantMigration.oplogViewwhich' which are not user namespaces so object type is','line_number':138,'multiline':False]
['text':' omitted from the error message below.','line_number':139,'multiline':False]
['text':' Valdate the db and coll names.','line_number':149,'multiline':False]
['text':' apiStrict ','line_number':151,'multiline':True]
['text':' Creates the conditions for joining the local and foreign fields inside of a $match.','line_number':165,'multiline':False]
['text':' Add the 'localFieldPath' of 'input' into 'localFieldList'. If 'localFieldPath' references a','line_number':169,'multiline':False]
['text':' field with an array in its path, we may need to join on multiple values, so we add each','line_number':170,'multiline':False]
['text':' element to 'localFieldList'.','line_number':171,'multiline':False]
['text':' Missing values are treated as null.','line_number':182,'multiline':False]
['text':' We construct a query of one of the following forms, depending on the contents of','line_number':186,'multiline':False]
['text':' 'localFieldList'.','line_number':187,'multiline':False]
['text':'','line_number':188,'multiline':False]
['text':'   {<foreignFieldName>: {$eq: <localFieldList[0]>}}','line_number':189,'multiline':False]
['text':'     if 'localFieldList' contains a single element.','line_number':190,'multiline':False]
['text':'','line_number':191,'multiline':False]
['text':'   {<foreignFieldName>: {$in: [<value>, <value>, ...]}}','line_number':192,'multiline':False]
['text':'     if 'localFieldList' contains more than one element but doesn't contain any that are','line_number':193,'multiline':False]
['text':'     regular expressions.','line_number':194,'multiline':False]
['text':'','line_number':195,'multiline':False]
['text':'   {$or: [{<foreignFieldName>: {$eq: <value>}}, {<foreignFieldName>: {$eq: <value>}}, ...]}','line_number':196,'multiline':False]
['text':'     if 'localFieldList' contains more than one element and it contains at least one element','line_number':197,'multiline':False]
['text':'     that is a regular expression.','line_number':198,'multiline':False]
['text':' A $lookup on an array value corresponds to finding documents in the foreign collection','line_number':203,'multiline':False]
['text':' that have a value of any of the elements in the array value, rather than finding','line_number':204,'multiline':False]
['text':' documents that have a value equal to the entire array value. These semantics are','line_number':205,'multiline':False]
['text':' automatically provided to us by using the $in query operator.','line_number':206,'multiline':False]
['text':' A regular expression inside the $in query operator will perform pattern matching on','line_number':208,'multiline':False]
['text':' any string values. Since we want regular expressions to only match other RegEx types,','line_number':209,'multiline':False]
['text':' we write the query as a $or of equality comparisons instead.','line_number':210,'multiline':False]
['text':' { <foreignFieldName> : { "$in" : <localFieldList> } }','line_number':213,'multiline':False]
['text':' Otherwise we have a simple $eq.','line_number':220,'multiline':False]
['text':' { <foreignFieldName> : { "$eq" : <localFieldList[0]> } }','line_number':221,'multiline':False]
['text':' namespace','line_number':228,'multiline':False]
['text':' We append an additional BSONObj to '_resolvedPipeline' as a placeholder for the $match stage','line_number':267,'multiline':False]
['text':' we'll eventually construct from the input document.','line_number':268,'multiline':False]
['text':' '_resolvedPipeline' will first be initialized by the constructor delegated to within this','line_number':295,'multiline':False]
['text':' constructor's initializer list. It will be populated with view pipeline prefix if 'fromNs'','line_number':296,'multiline':False]
['text':' represents a view. We will then append stages to ensure any view prefix is not overwritten.','line_number':297,'multiline':False]
['text':' Append a BSONObj to '_resolvedPipeline' as a placeholder for the stage corresponding to','line_number':302,'multiline':False]
['text':' the local/foreignField $match. It must next after $documents if present.','line_number':303,'multiline':False]
['text':' Add the user pipeline to '_resolvedPipeline' after any potential view prefix and $match','line_number':308,'multiline':False]
['text':' When local/foreignFields are included, we cannot enable the cache because the $match','line_number':312,'multiline':False]
['text':' is a correlated prefix that will not be detected. Here, local/foreignFields are absent,','line_number':313,'multiline':False]
['text':' so we enable the cache.','line_number':314,'multiline':False]
['text':' Add the user pipeline to '_resolvedPipeline' after any potential view prefix and $match','line_number':316,'multiline':False]
['text':' TODO SERVER-59628 We should be able to check for any valid data source here, not','line_number':374,'multiline':False]
['text':' just $documents.','line_number':375,'multiline':False]
['text':' Recursively lite parse the nested pipeline, if one exists.','line_number':406,'multiline':False]
['text':' If no pipeline is specified or the local/foreignField syntax was used, then assume that we're','line_number':425,'multiline':False]
['text':' reading directly from the collection.','line_number':426,'multiline':False]
['text':' Add the sub-pipeline privileges, if one was specified.','line_number':433,'multiline':False]
['text':' This stage has the SBE compatibility as least the same as that of the expression context.','line_number':458,'multiline':False]
['text':' We currently only support lowering equi-join that uses localField/foreignField','line_number':460,'multiline':False]
['text':' syntax.','line_number':461,'multiline':False]
['text':' SBE doesn't support match-like paths with numeric components. (Note: "as" field is a','line_number':464,'multiline':False]
['text':' project-like field and numbers in it are treated as literal names of fields rather','line_number':465,'multiline':False]
['text':' than indexes into arrays, which is compatible with SBE.)','line_number':466,'multiline':False]
['text':' Setting a collator on an individual $lookup stage with _internalCollation isn't supported','line_number':469,'multiline':False]
['text':' We currently don't lower $lookup against views ('_fromNs' does not correspond to a','line_number':471,'multiline':False]
['text':' view).','line_number':472,'multiline':False]
['text':' $lookup from config.cache.chunks* namespaces is permitted to run on each individual','line_number':482,'multiline':False]
['text':' shard, rather than just the primary, since each shard should have an identical copy of','line_number':483,'multiline':False]
['text':' the namespace.','line_number':484,'multiline':False]
['text':' This stage will only be on the shards pipeline if $lookup on sharded foreign collections','line_number':487,'multiline':False]
['text':' is allowed.','line_number':488,'multiline':False]
['text':' When the inner pipeline does not target a collection, it can run on any node.','line_number':491,'multiline':False]
['text':' If the pipeline is unsplit, then this $lookup can run anywhere.','line_number':494,'multiline':False]
['text':' By default, $lookup is allowed in a transaction and does not use disk.','line_number':498,'multiline':False]
['text':' However, if $lookup is specified with a pipeline, it inherits the strictest disk use, facet,','line_number':508,'multiline':False]
['text':' transaction, and lookup requirements from the children in its pipeline.','line_number':509,'multiline':False]
['text':' If this $lookup is on the merging half of the pipeline and the inner collection isn't','line_number':515,'multiline':False]
['text':' sharded (that is, it is either unsplittable or untracked), then we should merge on the shard','line_number':516,'multiline':False]
['text':' which owns the inner collection.','line_number':517,'multiline':False]
['text':' If we have not yet designated a merging shard, and are either executing on mongod, the','line_number':523,'multiline':False]
['text':' foreign collection is unsharded, or sharded $lookup is not allowed, designate the current','line_number':524,'multiline':False]
['text':' shard as the merging shard. This is done to prevent pushing this $lookup to the shards part','line_number':525,'multiline':False]
['text':' of the pipeline. This is an important optimization designating as this $lookup  as a merging','line_number':526,'multiline':False]
['text':' stage allows us to execute a single $lookup (as opposed to executing one $lookup on each','line_number':527,'multiline':False]
['text':' involved shard). When this stage is part of a deeply nested pipeline, it  prevents creating','line_number':528,'multiline':False]
['text':' an exponential explosion of cursors/resources (proportional to the level of pipeline','line_number':529,'multiline':False]
['text':' nesting).','line_number':530,'multiline':False]
['text':' If we have not absorbed a $unwind, we cannot absorb a $match. If we have absorbed a $unwind,','line_number':555,'multiline':False]
['text':' '_unwindSrc' would be non-null, and we would not have made it here.','line_number':556,'multiline':False]
['text':' We've already allocated space for the trailing $match stage in '_resolvedPipeline'.','line_number':562,'multiline':False]
['text':' If lookup on a sharded collection is disallowed and the foreign collection is sharded,','line_number':570,'multiline':False]
['text':' throw a custom exception.','line_number':571,'multiline':False]
['text':' Check if pipeline uses disk.','line_number':601,'multiline':False]
['text':' We don't want to optimize or attach a cursor source here because we need to update','line_number':612,'multiline':False]
['text':' _resolvedPipeline so we can reuse it on subsequent calls to getNext(), and we may need to','line_number':613,'multiline':False]
['text':' update _fieldMatchPipelineIdx as well in the case of a field join.','line_number':614,'multiline':False]
['text':' Resolve the view definition.','line_number':620,'multiline':False]
['text':' Store the pipeline with resolved namespaces so that we only trigger this exception on the','line_number':624,'multiline':False]
['text':' first input document.','line_number':625,'multiline':False]
['text':' The index of the field join match stage needs to be set to the length of the view','line_number':628,'multiline':False]
['text':' pipeline, as it is no longer the first stage in the resolved pipeline.','line_number':629,'multiline':False]
['text':' Update the expression context with any new namespaces the resolved pipeline has introduced.','line_number':634,'multiline':False]
['text':' Copy all 'let' variables into the foreign pipeline's expression context.','line_number':644,'multiline':False]
['text':' Resolve the 'let' variables to values per the given input document.','line_number':648,'multiline':False]
['text':' Enforce that the foreign collection must be unsharded for lookup.','line_number':656,'multiline':False]
['text':' If we don't have a cache, build and return the pipeline immediately.','line_number':662,'multiline':False]
['text':' By default, $lookup doesnt support sharded 'from' collections.','line_number':668,'multiline':False]
['text':' This exception returns the information we need to resolve a sharded view. Update the','line_number':675,'multiline':False]
['text':' pipeline with the resolved view definition.','line_number':676,'multiline':False]
['text':' We can now safely optimize and reattempt attaching the cursor source.','line_number':689,'multiline':False]
['text':' Construct the basic pipeline without a cache stage. Avoid optimizing here since we need to','line_number':696,'multiline':False]
['text':' add the cache first, as detailed below.','line_number':697,'multiline':False]
['text':' We can store the unoptimized serialization of the pipeline so that if we need to resolve','line_number':704,'multiline':False]
['text':' a sharded view later on, and we have a local-foreign field join, we will need to update','line_number':705,'multiline':False]
['text':' metadata tracking the position of this join in the _resolvedPipeline.','line_number':706,'multiline':False]
['text':' The cache has either been abandoned or has not yet been built. Attach a cursor.','line_number':712,'multiline':False]
['text':' This exception returns the information we need to resolve a sharded view. Update the','line_number':719,'multiline':False]
['text':' pipeline with the resolved view definition.','line_number':720,'multiline':False]
['text':' The serialized pipeline does not have a cache stage, so we will add it back to the','line_number':725,'multiline':False]
['text':' pipeline here if the cache has not been abandoned.','line_number':726,'multiline':False]
['text':' Try to attach the cursor source again.','line_number':739,'multiline':False]
['text':' If the cache has been abandoned, release it.','line_number':745,'multiline':False]
['text':' Add the cache stage at the end and optimize. During the optimization process, the cache will','line_number':755,'multiline':False]
['text':' either move itself to the correct position in the pipeline, or will abandon itself if no','line_number':756,'multiline':False]
['text':' suitable cache position exists. Do it only if pipeline optimization is enabled, otherwise','line_number':757,'multiline':False]
['text':' Pipeline::optimizePipeline() will exit early and correct placement of the cache will not','line_number':758,'multiline':False]
['text':' occur.','line_number':759,'multiline':False]
['text':' If the following stage is $sort and there is no internal $unwind, consider pushing it ahead','line_number':790,'multiline':False]
['text':' of $lookup.','line_number':791,'multiline':False]
['text':' If we are not already handling an $unwind stage internally, we can combine with the','line_number':801,'multiline':False]
['text':' following $unwind stage.','line_number':802,'multiline':False]
['text':' We cannot push absorbed $unwind stages into SBE.','line_number':806,'multiline':False]
['text':' Attempt to internalize any predicates of a $match upon the "_as" field.','line_number':812,'multiline':False]
['text':' We must be unwinding our result to internalize a $match. For example, consider the','line_number':820,'multiline':False]
['text':' following pipeline:','line_number':821,'multiline':False]
['text':'','line_number':822,'multiline':False]
['text':' Input: {_id: 0}','line_number':823,'multiline':False]
['text':' Foreign Collection: {a: 0, b: 0}, {a: 0, b: 5}','line_number':824,'multiline':False]
['text':' Pipeline:','line_number':825,'multiline':False]
['text':'   {$lookup: {localField: "_id", foreignField: "a", as: "foo"}}','line_number':826,'multiline':False]
['text':'   {$match: {'foo.b': {$gt: 0}}}','line_number':827,'multiline':False]
['text':' Output: {_id: 0, foo: [{a: 0, b: 0}, {a: 0, b: 5}]}','line_number':828,'multiline':False]
['text':'','line_number':829,'multiline':False]
['text':' If we executed {b: {$gt: 0}} as part of our $lookup, our output would instead be:','line_number':830,'multiline':False]
['text':' {_id: 0, foo: [{a: 0, b: 5}]}','line_number':831,'multiline':False]
['text':'','line_number':832,'multiline':False]
['text':' However, if we are already unwinding 'foo', then we can move the $match inside, since it','line_number':833,'multiline':False]
['text':' will have the same effect as filtering the unwound results, that is, the output will be:','line_number':834,'multiline':False]
['text':' {_id: 0, foo: {a: 0, b: 5}}','line_number':835,'multiline':False]
['text':'','line_number':836,'multiline':False]
['text':' Note that we cannot absorb a $match if the absorbed $unwind has','line_number':837,'multiline':False]
['text':' "preserveNullAndEmptyArrays" set to true, for the following reason: A document that had','line_number':838,'multiline':False]
['text':' an empty output array from $lookup would be preserved by the $unwind, but could be','line_number':839,'multiline':False]
['text':' removed by the $match. However, if we absorb the $match into the $lookup, our joined','line_number':840,'multiline':False]
['text':' query inside the $lookup will output an empty array, which $unwind will then preserve.','line_number':841,'multiline':False]
['text':' Thus, depending on the optimization, the user would see a different output.','line_number':842,'multiline':False]
['text':'','line_number':843,'multiline':False]
['text':' In addition, we must avoid internalizing a $match if an absorbed $unwind has an','line_number':844,'multiline':False]
['text':' "includeArrayIndex" option, since the $match will alter the indices of the returned','line_number':845,'multiline':False]
['text':' values.','line_number':846,'multiline':False]
['text':' We cannot internalize a $match if a collation has been set on the $lookup stage and it','line_number':850,'multiline':False]
['text':' differs from that of the parent pipeline.','line_number':851,'multiline':False]
['text':' Since $match splitting is handled in a generic way, we expect to have already swapped','line_number':859,'multiline':False]
['text':' portions of the $match that do not depend on the 'as' path or on an internalized $unwind's','line_number':860,'multiline':False]
['text':' index path before ourselves. But due to the early return above, we know there is no','line_number':861,'multiline':False]
['text':' internalized $unwind with an index path.','line_number':862,'multiline':False]
['text':'','line_number':863,'multiline':False]
['text':' Therefore, 'nextMatch' should only depend on the 'as' path. We now try to absorb the match on','line_number':864,'multiline':False]
['text':' the 'as' path in order to push down these predicates into the foreign collection.','line_number':865,'multiline':False]
['text':' If 'expression' is the child of a $elemMatch, we cannot internalize the $match. For','line_number':869,'multiline':False]
['text':' example, {b: {$elemMatch: {$gt: 1, $lt: 4}}}, where "b" is our "_as" field. This is','line_number':870,'multiline':False]
['text':' because there's no way to modify the expression to be a match just on 'b'--we cannot','line_number':871,'multiline':False]
['text':' change the path to an empty string, or remove the node entirely.','line_number':872,'multiline':False]
['text':' 'expression' is a leaf node; examine the path. It is important that 'outputPath'','line_number':878,'multiline':False]
['text':' not equal 'path', because we cannot change the expression {b: {$eq: 3}}, where','line_number':879,'multiline':False]
['text':' 'path' is 'b', to be a match on a subfield, since no subfield exists.','line_number':880,'multiline':False]
['text':' "nextMatch" does not contain any predicates that can be absorbed into this stage.','line_number':888,'multiline':False]
['text':' We can internalize the $match. This $lookup should already be marked as SBE incompatible','line_number':892,'multiline':False]
['text':' because a $match can only be internalized if an $unwind, which is SBE incompatible, was','line_number':893,'multiline':False]
['text':' absorbed as well.','line_number':894,'multiline':False]
['text':' We have already absorbed a $match. We need to join it with 'dependent'.','line_number':901,'multiline':False]
['text':' Remove the original $match.','line_number':905,'multiline':False]
['text':' We have internalized a $match, but have not yet computed the descended $match that should','line_number':908,'multiline':False]
['text':' be applied to our queries.','line_number':909,'multiline':False]
['text':' Add '_additionalFilter' to '_resolvedPipeline' if there is a pipeline. If there is no','line_number':915,'multiline':False]
['text':' pipeline, '_additionalFilter' can safely be added to the local/foreignField $match stage','line_number':916,'multiline':False]
['text':' during 'doGetNext()'.','line_number':917,'multiline':False]
['text':' There may be further optimization between this $lookup and the new neighbor, so we return an','line_number':923,'multiline':False]
['text':' iterator pointing to ourself.','line_number':924,'multiline':False]
['text':' We wrap the query in a $match so that it can be parsed into a DocumentSourceMatch when','line_number':948,'multiline':False]
['text':' constructing a pipeline to execute.','line_number':949,'multiline':False]
['text':' If we have one condition, do not place inside a $and. This BSON could be created many times,','line_number':954,'multiline':False]
['text':' so we want to produce simple queries for the planner if possible.','line_number':955,'multiline':False]
['text':' Loop until we get a document that has at least one match.','line_number':973,'multiline':False]
['text':' Note we may return early from this loop if our source stage is exhausted or if the unwind','line_number':974,'multiline':False]
['text':' source was asked to return empty arrays and we get a document without a match.','line_number':975,'multiline':False]
['text':' Accumulate stats from the pipeline for the previous input, if applicable. This is to','line_number':977,'multiline':False]
['text':' avoid missing the accumulation of stats on an early exit (below) if the input (i.e., left','line_number':978,'multiline':False]
['text':' side of the lookup) is done.','line_number':979,'multiline':False]
['text':' At this point, if there is a pipeline, '_additionalFilter' was added to the end of','line_number':993,'multiline':False]
['text':' '_resolvedPipeline' in doOptimizeAt(). If there is no pipeline, we must add it to the','line_number':994,'multiline':False]
['text':' $match stage created here.','line_number':995,'multiline':False]
['text':' We've already allocated space for the trailing $match stage in '_resolvedPipeline'.','line_number':999,'multiline':False]
['text':' The $lookup stage takes responsibility for disposing of its Pipeline, since it will','line_number':1005,'multiline':False]
['text':' potentially be used by multiple OperationContexts, and the $lookup stage is part of an','line_number':1006,'multiline':False]
['text':' outer Pipeline that will propagate dispose() calls before being destroyed.','line_number':1007,'multiline':False]
['text':' There were no results for this cursor, but the $unwind was asked to preserve empty','line_number':1014,'multiline':False]
['text':' arrays, so we should return a document without the array.','line_number':1015,'multiline':False]
['text':' Note this will correctly create objects in the prefix of '_as', to act as if we had','line_number':1017,'multiline':False]
['text':' created an empty array and then removed it.','line_number':1018,'multiline':False]
['text':' Move input document into output if this is the last or only result, otherwise perform a copy.','line_number':1031,'multiline':False]
['text':' Support alternative $lookup from config.cache.chunks* namespaces.','line_number':1075,'multiline':False]
['text':'','line_number':1076,'multiline':False]
['text':' Do not include the tenantId in serialized 'from' namespace.','line_number':1077,'multiline':False]
['text':' Add a pipeline field if only-pipeline syntax was used (to ensure the output is valid $lookup','line_number':1094,'multiline':False]
['text':' syntax) or if a $match was absorbed.','line_number':1095,'multiline':False]
['text':' We will use the introspection pipeline which we prebuilt during construction.','line_number':1156,'multiline':False]
['text':' We are not attempting to enforce that any referenced metadata are in fact unavailable,','line_number':1159,'multiline':False]
['text':' this is done elsewhere. We only need to know what variable dependencies exist in the','line_number':1160,'multiline':False]
['text':' subpipeline for the top-level pipeline. So without knowledge of what metadata is in fact','line_number':1161,'multiline':False]
['text':' unavailable, we "lie" and say that all metadata is available to avoid tripping any','line_number':1162,'multiline':False]
['text':' assertions.','line_number':1163,'multiline':False]
['text':' Get the subpipeline dependencies. Subpipeline stages may reference both 'let' variables','line_number':1166,'multiline':False]
['text':' declared by this $lookup and variables declared externally.','line_number':1167,'multiline':False]
['text':' Add the 'let' dependencies to the tracker.','line_number':1172,'multiline':False]
['text':' We need everything up until the first numeric component. Otherwise, a projection could','line_number':1180,'multiline':False]
['text':' treat the numeric component as a field name rather than an index into an array.','line_number':1181,'multiline':False]
['text':' We are lenient with the component, because classic $lookup treats 0-prefixed numeric','line_number':1184,'multiline':False]
['text':' fields like "00" as both an index and a field name. Allowing it in a dependency would','line_number':1185,'multiline':False]
['text':' restrict the usage to only a field name.','line_number':1186,'multiline':False]
['text':' Purposely ignore '_matchSrc' and '_unwindSrc', since those should only be absorbed if we know','line_number':1194,'multiline':False]
['text':' they are only operating on the "as" field which will be generated by this stage.','line_number':1195,'multiline':False]
['text':' Do not add SEARCH_META as a reference, since it is scoped to one pipeline.','line_number':1201,'multiline':False]
['text':' Add the 'let' variable references. Because the caller is only interested in references to','line_number':1211,'multiline':False]
['text':' external variables, filter out any subpipeline references to 'let' variables declared by this','line_number':1212,'multiline':False]
['text':' $lookup. This step must happen after gathering the sub-pipeline variable references as they','line_number':1213,'multiline':False]
['text':' may refer to let variables.','line_number':1214,'multiline':False]
['text':' If $lookup into a sharded foreign collection is allowed and the foreign namespace is sharded,','line_number':1222,'multiline':False]
['text':' top-level $lookup stages can run in parallel on the shards.','line_number':1223,'multiline':False]
['text':'','line_number':1224,'multiline':False]
['text':' Note that this decision is inherently racy and subject to become stale. This is okay because','line_number':1225,'multiline':False]
['text':' either choice will work correctly; we are simply applying a heuristic optimization.','line_number':1226,'multiline':False]
['text':' When $lookup reads from config.cache.chunks.* namespaces, it should run on each','line_number':1233,'multiline':False]
['text':' individual shard in parallel. This is a special case, and atypical for standard $lookup','line_number':1234,'multiline':False]
['text':' since a full copy of config.cache.chunks.* collections exists on all shards.','line_number':1235,'multiline':False]
['text':' {shardsStage, mergingStage, sortPattern}','line_number':1239,'multiline':False]
['text':' We have a pipeline we're going to be executing across multiple calls to getNext(), so we','line_number':1245,'multiline':False]
['text':' use Pipeline::detachFromOperationContext() to take care of updating '_fromExpCtx->opCtx'.','line_number':1246,'multiline':False]
['text':' We have a pipeline we're going to be executing across multiple calls to getNext(), so we','line_number':1256,'multiline':False]
['text':' use Pipeline::reattachToOperationContext() to take care of updating '_fromExpCtx->opCtx'.','line_number':1257,'multiline':False]
['text':' $lookup specified with only pipeline syntax.','line_number':1358,'multiline':False]
['text':' $lookup specified with pipeline syntax and local/foreignField syntax.','line_number':1367,'multiline':False]
['text':' $lookup specified with only local/foreignField syntax.','line_number':1383,'multiline':False]
['text':' namespace mongo','line_number':1411,'multiline':False]
