['text':'*
 *    Copyright (C) 2021-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' allowInexact ','line_number':77,'multiline':True]
['text':' allowInexact ','line_number':82,'multiline':True]
['text':'*
 * Helpers to clone an expression to the same type and rename the fields to which it applies.
 ','line_number':85,'multiline':True]
['text':'*
 * Helper to resolve a predicate on a non-existent field to either AlwaysTrue or AlwaysFalse.
 ','line_number':100,'multiline':True]
['text':'*
 * Rewrites filters on 'operationType' in a format that can be applied directly to the oplog.
 * Returns nullptr if the predicate cannot be rewritten.
 *
 * Examples,
 *   '{operationType: "insert"}' gets rewritten to '{op: {$eq: "i"}}'
 *   '{operationType: "drop"}' gets rewritten to
 *     '{$and: [{op: {$eq: "c"}}, {o.drop: {exists: true}}]}'
 ','line_number':111,'multiline':True]
['text':' We should only ever see predicates on the 'operationType' field.','line_number':124,'multiline':False]
['text':' If the query is on a subfield of operationType, it will always be missing.','line_number':130,'multiline':False]
['text':' Maps the operation type to the corresponding rewritten document in the oplog format.','line_number':138,'multiline':False]
['text':' Helper to convert a BSONElement opType into a rewritten MatchExpression.','line_number':156,'multiline':False]
['text':' If the operand is not a string, then this predicate will never match. If a rewrite rule','line_number':158,'multiline':False]
['text':' does not exist for the specified operation type, then it is either handled elsewhere or','line_number':159,'multiline':False]
['text':' it's an invalid type. In either case, return $alwaysFalse so that this predicate is','line_number':160,'multiline':False]
['text':' ignored.','line_number':161,'multiline':False]
['text':' Regex predicates cannot be written, and rewriting only part of an '$in' would produce','line_number':178,'multiline':False]
['text':' a more restrictive filter than the original, therefore return nullptr immediately.','line_number':179,'multiline':False]
['text':' An empty '$in' should not match with anything, return '$alwaysFalse'.','line_number':184,'multiline':False]
['text':' Add the rewritten sub-expression to the '$or' expression. Abandon the entire rewrite,','line_number':191,'multiline':False]
['text':' if any of the rewrite fails.','line_number':192,'multiline':False]
['text':'*
 * Attempt to rewrite a reference to the 'operationType' field such that, when evaluated over an
 * oplog document, it produces the expected change stream value for the field.
 ','line_number':208,'multiline':True]
['text':' If the expression is on a subfield of operationType, it will always be missing.','line_number':221,'multiline':False]
['text':' We intend to build a $switch statement which returns the correct change stream operationType','line_number':226,'multiline':False]
['text':' based on the contents of the oplog event. Start by enumerating the different opType cases.','line_number':227,'multiline':False]
['text':'*
     * NOTE: the list below MUST be kept up-to-date with any newly-added user-facing change stream
     * opTypes that are derived from oplog events (as opposed to events which are generated by
     * change stream stages themselves). Internal events of type {op: 'n'} are handled separately
     * and do not need to be considered here.
     ','line_number':230,'multiline':True]
['text':' Cases for handling CRUD events.','line_number':237,'multiline':False]
['text':' Cases for handling command events.','line_number':245,'multiline':False]
['text':' The default case, if nothing matches.','line_number':261,'multiline':False]
['text':' Build the final expression object...','line_number':265,'multiline':False]
['text':' ... and parse it into an Expression before returning.','line_number':275,'multiline':False]
['text':'*
 * Rewrites filters on 'documentKey' in a format that can be applied directly to the oplog. Returns
 * nullptr if the predicate cannot be rewritten.
 ','line_number':279,'multiline':True]
['text':' Helper to generate a filter on the 'op' field for the specified type. This filter will also','line_number':292,'multiline':False]
['text':' include a copy of 'predicate' with the path renamed to apply to the oplog.','line_number':293,'multiline':False]
['text':' The MatchExpression which will contain the final rewritten predicate.','line_number':303,'multiline':False]
['text':' Handle the case of non-CRUD events. The 'documentKey' field never exists for such events, so','line_number':306,'multiline':False]
['text':' we evaluate the predicate against a non-existent field to see whether it matches.','line_number':307,'multiline':False]
['text':' Handle update, replace, delete and insert. The predicate path can simply be renamed.','line_number':314,'multiline':False]
['text':'*
 * Attempt to rewrite a reference to the 'documentKey' field such that, when evaluated over an oplog
 * document, it produces the expected change stream value for the field.
 ','line_number':322,'multiline':True]
['text':' We intend to build a $switch statement which returns the correct change stream operationType','line_number':335,'multiline':False]
['text':' based on the contents of the oplog event. Start by enumerating the different opType cases.','line_number':336,'multiline':False]
['text':' Case for 'delete'.','line_number':339,'multiline':False]
['text':' Cases for 'insert', 'update' and 'replace'.','line_number':345,'multiline':False]
['text':' The default case, if nothing matches.','line_number':352,'multiline':False]
['text':' Build the expression BSON object.','line_number':356,'multiline':False]
['text':' Parse the expression BSON object into an Expression and return the Expression.','line_number':366,'multiline':False]
['text':'*
 * Rewrites filters on 'fullDocument' in a format that can be applied directly to the oplog. Returns
 * nullptr if the predicate cannot be rewritten.
 ','line_number':370,'multiline':True]
['text':' Because the 'fullDocument' field can be populated later in the pipeline for update events','line_number':383,'multiline':False]
['text':' (via the '{fullDocument: "updateLookup"}' option), it's impractical to try to generate a','line_number':384,'multiline':False]
['text':' rewritten predicate that matches exactly.','line_number':385,'multiline':False]
['text':' For predicates on the 'fullDocument' field or a subfield thereof, we can generate a rewritten','line_number':390,'multiline':False]
['text':' predicate that matches inexactly like so:','line_number':391,'multiline':False]
['text':'   {$or: [','line_number':392,'multiline':False]
['text':'     {$and: [{op: 'u'}, {'o._id': {$exists: false}}]},','line_number':393,'multiline':False]
['text':'     {$and: [','line_number':394,'multiline':False]
['text':'       {$or: [{op: 'i'}, {op: 'u', 'o._id': {$exists: true}}]},','line_number':395,'multiline':False]
['text':'       {o: <predicate>}','line_number':396,'multiline':False]
['text':'     ]},','line_number':397,'multiline':False]
['text':'     // The following predicates are only present if the predicate matches a missing field','line_number':398,'multiline':False]
['text':'     {op: "d"},','line_number':399,'multiline':False]
['text':'     {$nor: [{op: 'i'}, {op: 'u'}, {op: 'd'}]}','line_number':400,'multiline':False]
['text':'   ]}','line_number':401,'multiline':False]
['text':' Handle the case of non-replacement update entries. For the general case, we cannot apply the','line_number':404,'multiline':False]
['text':' predicate and must return all such events.','line_number':405,'multiline':False]
['text':' Handle the case of insert and replacement entries. We can always apply the predicate in these','line_number':412,'multiline':False]
['text':' cases, because the full document is present in the oplog.','line_number':413,'multiline':False]
['text':' Handle the case of delete and non-CRUD events. The 'fullDocument' field never exists for such','line_number':425,'multiline':False]
['text':' events, so we evaluate the predicate against a non-existent field to see whether it matches.','line_number':426,'multiline':False]
['text':'*
 * Rewrites filters on 'updateDescription' in a format that can be applied directly to the oplog.
 * Returns nullptr if the predicate cannot be rewritten.
 ','line_number':439,'multiline':True]
['text':' We can't determine whether we can perform a strict rewrite until we examine the predicate. We','line_number':453,'multiline':False]
['text':' wrap this in a helper function that we can call while building the filter. We try to rewrite','line_number':454,'multiline':False]
['text':' the predicate assuming that it will only be applied to non-replacement update oplog events.','line_number':455,'multiline':False]
['text':' $exists and null-equality checks on 'updateDescription' or its immediate subfields are','line_number':457,'multiline':False]
['text':' AlwaysTrue or AlwaysFalse, since these fields are always present in the update event.','line_number':458,'multiline':False]
['text':' An {$exists:true} predicate will always match against any of these fields.','line_number':464,'multiline':False]
['text':' We check whether this is a ComparisonMatchExpression to ensure that the predicate is','line_number':468,'multiline':False]
['text':' type-bracketed, which means that it will *only* match missing, null, or undefined.','line_number':469,'multiline':False]
['text':' None of these fields will ever be null or undefined in the change stream event.','line_number':470,'multiline':False]
['text':' For predicates on a non-dotted subfield of 'updateDescription.updatedFields' we can','line_number':477,'multiline':False]
['text':' generate a rewritten predicate that matches exactly like so:','line_number':478,'multiline':False]
['text':'','line_number':479,'multiline':False]
['text':'   {updateDescription.updatedFields.<fieldName>: <pred>}','line_number':480,'multiline':False]
['text':'     =>','line_number':481,'multiline':False]
['text':'   {$and: [','line_number':482,'multiline':False]
['text':'     {op: "u"},','line_number':483,'multiline':False]
['text':'     {"o._id": {$exists: false}},','line_number':484,'multiline':False]
['text':'     {$or: [','line_number':485,'multiline':False]
['text':'       {o.diff.i.<fieldName>: <pred>},','line_number':486,'multiline':False]
['text':'       {o.diff.u.<fieldName>: <pred>},','line_number':487,'multiline':False]
['text':'       {o.$set.<fieldName>: <pred>}','line_number':488,'multiline':False]
['text':'     ]}','line_number':489,'multiline':False]
['text':'   ]}','line_number':490,'multiline':False]
['text':' The oplog field corresponding to "updateDescription.updatedFields" can be in any one','line_number':493,'multiline':False]
['text':' of three locations. We will attempt to construct a filter to match against them all.','line_number':494,'multiline':False]
['text':' If this predicate matches against a missing field, then we must apply an $and to all','line_number':496,'multiline':False]
['text':' three potential locations, since at least two of them will always be missing. If not,','line_number':497,'multiline':False]
['text':' then we build an $or to match if the field is present at any of the locations.','line_number':498,'multiline':False]
['text':' Rewrite the predicate for each of the three potential oplog locations.','line_number':505,'multiline':False]
['text':' Return the final rewritten predicate.','line_number':510,'multiline':False]
['text':' For $eq predicates and $in predicates on 'updateDescription.removedFields' we can','line_number':514,'multiline':False]
['text':' generate a rewritten predicate that matches exactly like so:','line_number':515,'multiline':False]
['text':'','line_number':516,'multiline':False]
['text':'   {updateDescription.removedFields: {$eq: <fieldName>}}','line_number':517,'multiline':False]
['text':'     =>','line_number':518,'multiline':False]
['text':'   {$and: [','line_number':519,'multiline':False]
['text':'     {op: "u"},','line_number':520,'multiline':False]
['text':'     {"o._id": {$exists: false}},','line_number':521,'multiline':False]
['text':'     {$or: [','line_number':522,'multiline':False]
['text':'       {o.diff.d.<fieldName>: {$exists: true}},','line_number':523,'multiline':False]
['text':'       {o.$unset.<fieldName>: {$exists: true}}','line_number':524,'multiline':False]
['text':'     ]}','line_number':525,'multiline':False]
['text':'   ]}','line_number':526,'multiline':False]
['text':'','line_number':527,'multiline':False]
['text':'   {updateDescription.removedFields: {$in: [<fieldName1>, <fieldName2>, ..]}}','line_number':528,'multiline':False]
['text':'     =>','line_number':529,'multiline':False]
['text':'   {$and: [','line_number':530,'multiline':False]
['text':'     {op: "u"},','line_number':531,'multiline':False]
['text':'     {"o._id": {$exists: false}},','line_number':532,'multiline':False]
['text':'     {$or: [','line_number':533,'multiline':False]
['text':'       {o.diff.d.<fieldName1>: {$exists: true}},','line_number':534,'multiline':False]
['text':'       {o.$unset.<fieldName1>: {$exists: true}},','line_number':535,'multiline':False]
['text':'       {o.diff.d.<fieldName2>: {$exists: true}},','line_number':536,'multiline':False]
['text':'       {o.$unset.<fieldName2>: {$exists: true}},','line_number':537,'multiline':False]
['text':'       ..','line_number':538,'multiline':False]
['text':'     ]}','line_number':539,'multiline':False]
['text':'   ]}','line_number':540,'multiline':False]
['text':' Helper to rewrite an equality on "updateDescription.removedFields" into the oplog.','line_number':543,'multiline':False]
['text':' We can only rewrite equality matches on strings.','line_number':545,'multiline':False]
['text':' We can only rewrite top-level fields, i.e. no dotted subpaths.','line_number':549,'multiline':False]
['text':' The oplog field corresponding to "updateDescription.removedFields" can be in','line_number':554,'multiline':False]
['text':' either of two locations. Construct an $or filter to match against them both.','line_number':555,'multiline':False]
['text':' Because we have already validated that this is an equality string match, we do','line_number':556,'multiline':False]
['text':' not need to check whether the predicate matches a missing field in this case.','line_number':557,'multiline':False]
['text':' We can only match against a limited number of predicates here, $eq and $in.','line_number':567,'multiline':False]
['text':' Try to rewrite the predicate on "updateDescription.removedFields".','line_number':570,'multiline':False]
['text':' If this $in includes any regexes, we can't proceed with the rewrite.','line_number':575,'multiline':False]
['text':' An empty '$in' should never match anything.','line_number':580,'multiline':False]
['text':' Try to rewrite the $in as an $or of equalities on the oplog. If any','line_number':584,'multiline':False]
['text':' individual rewrite fails, we must abandon the entire rewrite.','line_number':585,'multiline':False]
['text':' Return the final rewritten predicate.','line_number':594,'multiline':False]
['text':' If we reach here, we cannot rewrite this predicate.','line_number':601,'multiline':False]
['text':' Try to rewrite the user predicate. If we can't, then we may not be able to continue.','line_number':605,'multiline':False]
['text':' If a strict rewrite is required and we could not rewrite the predicate, return nullptr. We','line_number':608,'multiline':False]
['text':' also return nullptr if the predicate matches a missing field, since it is pointless to try','line_number':609,'multiline':False]
['text':' to continue; we would have to return all updates, because we don't know whether they will','line_number':610,'multiline':False]
['text':' match, and all non-updates, because they will always match.','line_number':611,'multiline':False]
['text':' If we are here, then either we were able to rewrite the predicate, or we were not but an','line_number':616,'multiline':False]
['text':' inexact rewrite is permissible. First write a predicate to check that this is an update','line_number':617,'multiline':False]
['text':' that is not a full-document replacement, i.e. {op: "u", "o._id": {$exists: false}}.','line_number':618,'multiline':False]
['text':' If we were able to rewrite the user predicate, add it into the final predicate.','line_number':624,'multiline':False]
['text':' Handle the case of non-update events. The 'updateDescription' field never exists for these','line_number':629,'multiline':False]
['text':' events, so we evaluate the predicate against a non-existent field to see whether it matches.','line_number':630,'multiline':False]
['text':' Finally, we return the complete rewritten predicate.','line_number':638,'multiline':False]
['text':' Helper to rewrite predicates on any change stream namespace field of the form {db: "dbName",','line_number':642,'multiline':False]
['text':' coll: "collName"} into the oplog.','line_number':643,'multiline':False]
['text':' - By default, the rewrite is performed onto the given 'nsField' which specifies an oplog field','line_number':645,'multiline':False]
['text':'   containing a complete namespace string, e.g. {ns: "dbName.collName"}.','line_number':646,'multiline':False]
['text':' - If 'nsFieldIsCmdNs' is true, then 'nsField' only contains the command-namespace of the','line_number':647,'multiline':False]
['text':'   database, i.e. "dbName.$cmd".','line_number':648,'multiline':False]
['text':' - With 'nsFieldIsCmdNs set to true, the caller can also optionally provide 'collNameField' which','line_number':649,'multiline':False]
['text':'   is the field containing the collection name. The 'collNameField' may be absent, which means','line_number':650,'multiline':False]
['text':'   that the operation being rewritten has a 'db' field in the change stream event, but no 'coll'','line_number':651,'multiline':False]
['text':'   field.','line_number':652,'multiline':False]
['text':' A collection name can only be specified with 'nsFieldIsCmdNs' set to true.','line_number':659,'multiline':False]
['text':' Performs a rewrite based on the type of argument specified in the MatchExpression.','line_number':664,'multiline':False]
['text':' Handles case with full namespace object, like '{ns: {db: "db", coll: "coll"}}'.','line_number':668,'multiline':False]
['text':' There must be a single part to the field path, ie. 'ns'.','line_number':669,'multiline':False]
['text':' Extract the object from the RHS of the predicate.','line_number':674,'multiline':False]
['text':' If a full namespace, or a collNameField were specified, there must be 2 fields in','line_number':677,'multiline':False]
['text':' the object, i.e. db and coll.','line_number':678,'multiline':False]
['text':'  Otherwise, there can only be 1 field in the object, i.e. db.','line_number':682,'multiline':False]
['text':' Extract the db and collection from the 'ns' object. The 'collElem' will point to','line_number':687,'multiline':False]
['text':' the eoo, if it is not present.','line_number':688,'multiline':False]
['text':' Verify that the first field is 'db' and is of type string. We should always have','line_number':693,'multiline':False]
['text':' a db entry no matter what oplog fields we are operating on.','line_number':694,'multiline':False]
['text':' Verify that the second field is 'coll' and is of type string, if it exists.','line_number':698,'multiline':False]
['text':' If we are rewriting to a combination of cmdNs and collName, we match on','line_number':711,'multiline':False]
['text':' both.','line_number':712,'multiline':False]
['text':' Otherwise, we are rewriting to a full namespace field. Convert the object's','line_number':719,'multiline':False]
['text':' subfields into an exact match on the oplog field.','line_number':720,'multiline':False]
['text':' Handles case with field path, like '{"ns.coll": "coll"}'. There must be 2 parts','line_number':725,'multiline':False]
['text':' to the field path, ie. 'ns' and '[db | coll]'.','line_number':726,'multiline':False]
['text':' Extract the second field and verify that it is either 'db' or 'coll'.','line_number':731,'multiline':False]
['text':' If the predicate is on 'coll' but we only have a db, we will never match.','line_number':737,'multiline':False]
['text':' If the predicate is on 'db' and 'nsFieldIsCmdNs' is set to true, match the $cmd','line_number':742,'multiline':False]
['text':' namespace.','line_number':743,'multiline':False]
['text':' If the predicate is on 'coll', match the 'collNameField' if we have one.','line_number':748,'multiline':False]
['text':' Otherwise, we are rewriting this predicate to operate on a field containing the','line_number':754,'multiline':False]
['text':' full namespace. If the predicate is on 'db', match all collections in that DB. If','line_number':755,'multiline':False]
['text':' the predicate is on 'coll', match that collection in all DBs.','line_number':756,'multiline':False]
['text':' Handles case with field path having regex, like '{"ns.db": /^db$/}'. There must','line_number':771,'multiline':False]
['text':' be 2 parts to the field path, ie. 'ns' and '[db | coll]'.','line_number':772,'multiline':False]
['text':' Extract the second field and verify that it either 'db' or 'coll'.','line_number':777,'multiline':False]
['text':' If the predicate is on 'coll' but we only have a db, we will never match.','line_number':783,'multiline':False]
['text':' Rather than attempting to rewrite the regex to apply to the oplog field, we will','line_number':788,'multiline':False]
['text':' instead write an $expr to extract the dbName or collName from the oplog field,','line_number':789,'multiline':False]
['text':' and apply the unmodified regex directly to it. First get a reference to the','line_number':790,'multiline':False]
['text':' relevant field in the oplog entry.','line_number':791,'multiline':False]
['text':' Wrap the field in an expression to return MISSING if the field is not a string,','line_number':796,'multiline':False]
['text':' since this expression may execute on CRUD oplog entries with clashing fieldnames.','line_number':797,'multiline':False]
['text':' We will make this available to other expressions as the variable '$$oplogField'.','line_number':798,'multiline':False]
['text':' Now create an expression to extract the db or coll name from the oplog entry.','line_number':803,'multiline':False]
['text':' If the query is on 'coll' and we have a collName field, use it as-is.','line_number':805,'multiline':False]
['text':' Otherwise, we need to split apart a full ns string. Find the separator.','line_number':810,'multiline':False]
['text':' Return 0 if input is null in order to prevent throwing in $substrBytes.','line_number':811,'multiline':False]
['text':' If the query is on 'db', return everything up to the separator.','line_number':815,'multiline':False]
['text':' Otherwise, the query is on 'coll'. Return everything from (separator + 1)','line_number':820,'multiline':False]
['text':' to the end of the string.','line_number':821,'multiline':False]
['text':' Convert the MatchExpression $regex into a $regexMatch on the corresponding field.','line_number':826,'multiline':False]
['text':' Backslashes must be escaped to ensure they retain their special behavior.','line_number':827,'multiline':False]
['text':' Finally, wrap the regex in a $let which defines the '$$oplogField' variable.','line_number':834,'multiline':False]
['text':' Return a new ExprMatchExpression with the rewritten $regexMatch.','line_number':839,'multiline':False]
['text':' It is only feasible to attempt to rewrite a limited set of predicates here.','line_number':849,'multiline':False]
['text':' Create the BSON element from the regex match expression and return a rewritten match','line_number':857,'multiline':False]
['text':' expression, if possible.','line_number':858,'multiline':False]
['text':' An empty '$in' should not match anything.','line_number':867,'multiline':False]
['text':' For each equality expression, add the rewritten sub-expression to the '$or'','line_number':874,'multiline':False]
['text':' expression. Abandon the entire rewrite, if any of the rewrite fails.','line_number':875,'multiline':False]
['text':' For each regex expression, add the rewritten sub-expression to the '$or' expression.','line_number':884,'multiline':False]
['text':' Abandon the entire rewrite, if any of the rewrite fails.','line_number':885,'multiline':False]
['text':' If we have reached here, this is a predicate which we cannot rewrite.','line_number':901,'multiline':False]
['text':'*
 * Rewrites filters on 'ns' in a format that can be applied directly to the oplog.
 * Returns nullptr if the predicate cannot be rewritten.
 ','line_number':905,'multiline':True]
['text':' We should only ever see predicates on the 'ns' field.','line_number':913,'multiline':False]
['text':'*
     * NOTE: the list below MUST be kept up-to-date with any newly-added user-facing change stream
     * opTypes that are derived from oplog events (as opposed to events which are generated by
     * change stream stages themselves). Internal events of type {op: 'n'} are handled separately
     * and do not need to be considered here.
     ','line_number':919,'multiline':True]
['text':'','line_number':926,'multiline':False]
['text':' CRUD events','line_number':927,'multiline':False]
['text':'','line_number':928,'multiline':False]
['text':' CRUD ops are rewritten to the 'ns' field that contains a full namespace string.','line_number':930,'multiline':False]
['text':' If we can't rewrite this predicate for CRUD operations, then we don't expect to be able to','line_number':933,'multiline':False]
['text':' rewrite it for any other operations either.','line_number':934,'multiline':False]
['text':' Create the final namespace filter for CRUD operations, i.e. {op: {$ne: 'c'}}.','line_number':939,'multiline':False]
['text':'','line_number':945,'multiline':False]
['text':' Command events','line_number':946,'multiline':False]
['text':'','line_number':947,'multiline':False]
['text':' Group together all command event cases.','line_number':949,'multiline':False]
['text':' The 'rename' event is rewritten to a field that contains the full namespace string.','line_number':952,'multiline':False]
['text':' The 'drop' event is rewritten to the cmdNs in 'ns' and the collection name in 'o.drop'.','line_number':957,'multiline':False]
['text':' nsFieldIsCmdNs ','line_number':959,'multiline':True]
['text':' The 'create' event is rewritten to the cmdNs in 'ns' and the collection name in 'o.create'.','line_number':963,'multiline':False]
['text':' nsFieldIsCmdNs ','line_number':965,'multiline':True]
['text':' The 'createIndexes' event is rewritten to the cmdNs in 'ns' and the collection name in','line_number':969,'multiline':False]
['text':' 'o.createIndexes'.','line_number':970,'multiline':False]
['text':' nsFieldIsCmdNs ','line_number':972,'multiline':True]
['text':' The 'commitIndexBuild' event is rewritten to the cmdNs in 'ns' and the collection name in','line_number':976,'multiline':False]
['text':' 'o.commitIndexBuild'.','line_number':977,'multiline':False]
['text':' nsFieldIsCmdNs ','line_number':979,'multiline':True]
['text':' The 'dropIndexes' event is rewritten to the cmdNs in 'ns' and the collection name in','line_number':983,'multiline':False]
['text':' 'o.dropIndexes'.','line_number':984,'multiline':False]
['text':' nsFieldIsCmdNs ','line_number':986,'multiline':True]
['text':' The 'modify' event is rewritten to the cmdNs in 'ns' and the collection name in','line_number':990,'multiline':False]
['text':' 'o.collMod'.','line_number':991,'multiline':False]
['text':' nsFieldIsCmdNs ','line_number':993,'multiline':True]
['text':' The 'dropDatabase' event is rewritten to the cmdNs in 'ns'. It does not have a collection','line_number':997,'multiline':False]
['text':' field.','line_number':998,'multiline':False]
['text':' nsFieldIsCmdNs ','line_number':1000,'multiline':True]
['text':' Create the final namespace filter for {op: 'c'} operations.','line_number':1007,'multiline':False]
['text':'','line_number':1012,'multiline':False]
['text':' Build final 'ns' filter','line_number':1013,'multiline':False]
['text':'','line_number':1014,'multiline':False]
['text':' Construct the final rewritten predicate from each of the rewrite categories.','line_number':1016,'multiline':False]
['text':'*
 * Attempt to rewrite a reference to the 'ns' field such that, when evaluated over an oplog
 * document, it produces the expected change stream value for the field.
 ','line_number':1024,'multiline':True]
['text':' This function should only be called on the 'ns' field.','line_number':1034,'multiline':False]
['text':' If the field path is not 'ns', 'ns.db' or 'ns.coll', it does not exist.','line_number':1039,'multiline':False]
['text':' Firstly, we can always extract the database name directly from the "ns" field. Create a $let','line_number':1045,'multiline':False]
['text':' expression which will make '$$dbName' available to all subsequent expressions. Note that we','line_number':1046,'multiline':False]
['text':' do not yet complete the 'in' part of the $let, since this depends on the exact fieldPath.','line_number':1047,'multiline':False]
['text':' If the expression is on "ns.db", then we can simply complete and return the $let immediately.','line_number':1051,'multiline':False]
['text':' Otherwise, we need to compute the collection name for this event. We will build a $switch','line_number':1058,'multiline':False]
['text':' statement to do this. Create a vector to hold each of the cases.','line_number':1059,'multiline':False]
['text':' Helper function to extract the collection name from a given field, using the known $$dbName.','line_number':1062,'multiline':False]
['text':'*
     * NOTE: the list below MUST be kept up-to-date with any newly-added user-facing change stream
     * opTypes that are derived from oplog events (as opposed to events which are generated by
     * change stream stages themselves). Internal events of type {op: 'n'} are handled separately
     * and do not need to be considered here.
     ','line_number':1068,'multiline':True]
['text':' Cases for handling CRUD events.','line_number':1075,'multiline':False]
['text':' Cases for handling command events.','line_number':1079,'multiline':False]
['text':' The default case, if nothing matches.','line_number':1096,'multiline':False]
['text':' Build the collection expression object...','line_number':1100,'multiline':False]
['text':' Finally, wrap the expression in the $let which defines the '$$dbName' variable, and complete','line_number':1110,'multiline':False]
['text':' the 'in' parameter of the $let. If the length of the fieldPath is 1 then the field reference','line_number':1111,'multiline':False]
['text':' is '$ns' and we must construct the entire 'ns' object, with both 'db' and 'coll'. Otherwise,','line_number':1112,'multiline':False]
['text':' the field is '$ns.coll' and we can just return the 'collExpr' $switch we constructed above.','line_number':1113,'multiline':False]
['text':' Parse the expression BSON object into an Expression and return it.','line_number':1120,'multiline':False]
['text':'*
 * Rewrites filters on 'to' in a format that can be applied directly to the oplog.
 * Returns nullptr if the predicate cannot be rewritten.
 ','line_number':1125,'multiline':True]
['text':' We should only ever see predicates on the 'to' field.','line_number':1133,'multiline':False]
['text':'*
 * Attempt to rewrite a reference to the 'to' field such that, when evaluated over an oplog
 * document, it produces the expected change stream value for the field.
 ','line_number':1148,'multiline':True]
['text':' This function should only be called on the 'to' field.','line_number':1158,'multiline':False]
['text':' Create a case to verify if the 'op' type is command and '$o.to' field is present.','line_number':1165,'multiline':False]
['text':' Expression to extract the db component from the 'to' field.','line_number':1169,'multiline':False]
['text':' Expression to extract the collection component from the 'to' field.','line_number':1172,'multiline':False]
['text':' If there is no sub-field path, then return the full 'to' object.','line_number':1179,'multiline':False]
['text':' If the sub-path contains 'db', then return only the 'db' component.','line_number':1182,'multiline':False]
['text':' If the sub-path contains 'coll', then return only the 'coll' component.','line_number':1185,'multiline':False]
['text':' Any other field path, should match nothing.','line_number':1188,'multiline':False]
['text':' The default case, if this is not a rename command.','line_number':1192,'multiline':False]
['text':' Parse the expression BSON object into an Expression and return it.','line_number':1195,'multiline':False]
['text':'*
 * Rewrites filters on 'fullDocumentBeforeChange' in a format that can be applied directly to the
 * oplog.
 ','line_number':1200,'multiline':True]
['text':' If this predicate matches a missing value, e.g. {$eq: null}, we cannot rewrite it. Predicates','line_number':1214,'multiline':False]
['text':' such as this will match all non-update and non-delete operations, and we do not know whether','line_number':1215,'multiline':False]
['text':' the post-image will be available later in the pipeline. We also cannot continue if an exact','line_number':1216,'multiline':False]
['text':' rewrite is required. In both cases, return nullptr immediately.','line_number':1217,'multiline':False]
['text':' Only an update or a delete can possibly match a predicate on fullDocumentBeforeChange.','line_number':1222,'multiline':False]
['text':' If the predicate is on the _id field, we can apply it to the documentKey in the oplog.','line_number':1228,'multiline':False]
['text':' Example:
     *   '{'fullDocumentBeforeChange._id': {$lt: 3}}' gets rewritten to
     *                           {$or:[
     *                              {$and: [
     *                                  {op: {$eq: 'd'}},
     *                                  {'o._id': {$lt: 3}}
     *                              ]},
     *                              {$and: [
     *                                  {op: {$eq: 'u'}},
     *                                  {'o2._id': {$lt: 3}}
     *                              ]}
     *                           ]}
     ','line_number':1229,'multiline':True]
['text':' Wrap the update and delete predicates in an $or, and return the completed rewrite.','line_number':1247,'multiline':False]
['text':' Map of fields names for which a simple rename is sufficient when rewriting.','line_number':1254,'multiline':False]
['text':' Map of field names to corresponding MatchExpression rewrite functions.','line_number':1258,'multiline':False]
['text':' Map of field names to corresponding agg Expression rewrite functions.','line_number':1268,'multiline':False]
['text':' Traverse the Expression tree and rewrite as many of them as possible. Note that the rewrite is','line_number':1274,'multiline':False]
['text':' performed in-place; that is, the Expression passed into the function is mutated by it.','line_number':1275,'multiline':False]
['text':'','line_number':1276,'multiline':False]
['text':' When 'allowInexact' is true, the traversal produces a "best effort" rewrite, which rejects a','line_number':1277,'multiline':False]
['text':' subset of the oplog entries. The inexact filter is correct so long as the original filter remains','line_number':1278,'multiline':False]
['text':' in place later in the pipeline. When 'allowInexact' is false, the traversal will only return a','line_number':1279,'multiline':False]
['text':' filter that matches the exact same set of documents.','line_number':1280,'multiline':False]
['text':'','line_number':1281,'multiline':False]
['text':' Can return null when no acceptable rewrite is possible.','line_number':1282,'multiline':False]
['text':' If inexact rewrites are permitted and any children of an $and cannot be rewritten, we','line_number':1294,'multiline':False]
['text':' can omit those children without expanding the set of rejected documents.','line_number':1295,'multiline':False]
['text':' Dropping any children of an $or would expand the set of documents rejected by the','line_number':1310,'multiline':False]
['text':' filter. There is no valid rewrite of a $or if we cannot rewrite all of its children.','line_number':1311,'multiline':False]
['text':' It is, however, valid for children of an $or to be inexact.','line_number':1312,'multiline':False]
['text':' Note that children of a $not _cannot_ be inexact. If predicate P rejects a _subset_','line_number':1322,'multiline':False]
['text':' of documents, then {$not: P} will incorrectly reject a _superset_ of documents.','line_number':1323,'multiline':False]
['text':' A $or that is a direct child of a $not gets special treatment as a "nor" expression. If','line_number':1326,'multiline':False]
['text':' inexact rewrites are permitted and any children of a "nor" cannot be rewritten, we can','line_number':1327,'multiline':False]
['text':' omit those children without expanding the set of rejected documents.','line_number':1328,'multiline':False]
['text':' allowInexact ','line_number':1334,'multiline':True]
['text':' allowInexact ','line_number':1347,'multiline':True]
['text':' A reference to the $$ROOT object cannot be rewritten; any rewrite would need to transform','line_number':1353,'multiline':False]
['text':' the oplog entry into the final change stream event. This transformation may require a','line_number':1354,'multiline':False]
['text':' document lookup to populate the "fullDocument" field.','line_number':1355,'multiline':False]
['text':' The $let definition for any user-defined variable should have already been rewritten.','line_number':1360,'multiline':False]
['text':' The remaining case is a reference to a field path in the current document.','line_number':1365,'multiline':False]
['text':' Only attempt to rewrite paths that begin with one of the caller-requested fields.','line_number':1369,'multiline':False]
['text':' Some paths can be rewritten just by renaming the path.','line_number':1374,'multiline':False]
['text':' Other paths have custom rewrite logic.','line_number':1379,'multiline':False]
['text':' Others cannot be rewritten at all.','line_number':1384,'multiline':False]
['text':' Although it is possible to rewrite $let expressions in general, it is not possible when','line_number':1387,'multiline':False]
['text':' the expression rebinds the '$$CURRENT' variable. When '$$CURRENT' is rebound, we can no','line_number':1388,'multiline':False]
['text':' longer make assumptions about the structure of the document that the expression is','line_number':1389,'multiline':False]
['text':' operating on, so we can not safely rewrite it to operate on an oplog entry.','line_number':1390,'multiline':False]
['text':' Non-logical and non-fieldPath expression. Descend agnostically through it.','line_number':1399,'multiline':False]
['text':' Some expressions have null children, which we leave in place.','line_number':1403,'multiline':False]
['text':' allowInexact ','line_number':1406,'multiline':True]
['text':' Traverse the MatchExpression tree and rewrite as many predicates as possible. When 'allowInexact'','line_number':1417,'multiline':False]
['text':' is true, the traversal produces a "best effort" rewrite, which rejects a subset of the oplog','line_number':1418,'multiline':False]
['text':' entries that would later be rejected by the 'userMatch' filter. The inexact filter is correct so','line_number':1419,'multiline':False]
['text':' long as 'userMatch' remains in place later in the pipeline. When 'allowInexact' is false, the','line_number':1420,'multiline':False]
['text':' traversal will only return a filter that matches the exact same set of documents as would be','line_number':1421,'multiline':False]
['text':' matched by the 'userMatch' filter.','line_number':1422,'multiline':False]
['text':'','line_number':1423,'multiline':False]
['text':' Can return null when no acceptable rewrite is possible.','line_number':1424,'multiline':False]
['text':'','line_number':1425,'multiline':False]
['text':' Assumes that the 'root' MatchExpression passed in here only contains fields that have available','line_number':1426,'multiline':False]
['text':' rewrite or rename rules.','line_number':1427,'multiline':False]
['text':' If inexact rewrites are permitted and any children of an $and cannot be','line_number':1439,'multiline':False]
['text':' rewritten, we can omit those children without expanding the set of rejected','line_number':1440,'multiline':False]
['text':' documents.','line_number':1441,'multiline':False]
['text':' Dropping any children of an $or would expand the set of documents rejected by the','line_number':1454,'multiline':False]
['text':' filter. There is no valid rewrite of a $or if we cannot rewrite all of its','line_number':1455,'multiline':False]
['text':' children. It is, however, valid for children of an $or to be inexact.','line_number':1456,'multiline':False]
['text':' If inexact rewrites are permitted and any children of a $nor cannot be rewritten, we','line_number':1467,'multiline':False]
['text':' can omit those children without expanding the set of rejected documents. However,','line_number':1468,'multiline':False]
['text':' children of a $nor can never be inexact. If predicate P rejects a _subset_ of','line_number':1469,'multiline':False]
['text':' documents, then {$nor: [P]} will incorrectly reject a _superset_ of documents.','line_number':1470,'multiline':False]
['text':' allowInexact ','line_number':1474,'multiline':True]
['text':' Note that children of a $not _cannot_ be inexact. If predicate P rejects a _subset_','line_number':1483,'multiline':False]
['text':' of documents, then {$not: P} will incorrectly reject a _superset_ of documents.','line_number':1484,'multiline':False]
['text':' allowInexact ','line_number':1486,'multiline':True]
['text':' Agg expressions are rewritten in-place, so we must clone the expression tree.','line_number':1492,'multiline':False]
['text':' Attempt to rewrite the aggregation expression and return a new ExprMatchExpression.','line_number':1499,'multiline':False]
['text':' Only attempt to rewrite paths that begin with one of the caller-requested fields.','line_number':1511,'multiline':False]
['text':' Some paths can be rewritten just by renaming the path.','line_number':1516,'multiline':False]
['text':' Other paths have custom rewrite logic.','line_number':1521,'multiline':False]
['text':' Others cannot be rewritten at all.','line_number':1526,'multiline':False]
['text':' We don't recognize this predicate, so we do not attempt a rewrite.','line_number':1529,'multiline':False]
['text':' namespace','line_number':1534,'multiline':False]
['text':' If we get null in, we return null immediately.','line_number':1541,'multiline':False]
['text':' If the specified 'fields' set is empty, we rewrite every possible field.','line_number':1546,'multiline':False]
['text':' Remove any fields which are present in the "excludeFields" list.','line_number':1559,'multiline':False]
['text':' Attempt to rewrite the tree. Predicates on unknown or unrequested fields will be discarded.','line_number':1564,'multiline':False]
['text':' allowInexact ','line_number':1565,'multiline':True]
['text':' namespace change_stream_rewrite','line_number':1567,'multiline':False]
['text':' namespace mongo','line_number':1568,'multiline':False]
