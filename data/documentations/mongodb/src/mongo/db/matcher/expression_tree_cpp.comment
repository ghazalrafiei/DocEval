['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':32,'multiline':False]
['text':' Returns a pointer to a PathMatchExpression if 'expr' is such a pointer, otherwise returns','line_number':52,'multiline':False]
['text':' nullptr.','line_number':53,'multiline':False]
['text':'','line_number':54,'multiline':False]
['text':' One exception: while TextMatchExpressionBase derives from PathMatchExpression, text match','line_number':55,'multiline':False]
['text':' expressions cannot be serialized in the same manner as other PathMatchExpression derivatives.','line_number':56,'multiline':False]
['text':' This is because the path for a TextMatchExpression is embedded within the $text object,','line_number':57,'multiline':False]
['text':' whereas for other PathMatchExpressions it is on the left-hand-side, for example {x: {$eq:','line_number':58,'multiline':False]
['text':' 1}}.','line_number':59,'multiline':False]
['text':'','line_number':60,'multiline':False]
['text':' Rather than the following dynamic_cast, we'll do a more performant, but also more verbose','line_number':61,'multiline':False]
['text':' check.','line_number':62,'multiline':False]
['text':' dynamic_cast<PathMatchExpression*>(expr) && !dynamic_cast<TextMatchExpressionBase*>(expr)','line_number':63,'multiline':False]
['text':'','line_number':64,'multiline':False]
['text':' This version below is less obviously exhaustive, but because this is just a legibility','line_number':65,'multiline':False]
['text':' optimization, and this function also gets called on the query shape stats recording hot path,','line_number':66,'multiline':False]
['text':' we think it is worth it.','line_number':67,'multiline':False]
['text':' leaf types','line_number':69,'multiline':False]
['text':' array types','line_number':83,'multiline':False]
['text':' special types','line_number':87,'multiline':False]
['text':' Internal subclasses of PathMatchExpression:','line_number':91,'multiline':False]
['text':' purposefully skip TEXT:','line_number':105,'multiline':False]
['text':' Any other type is not considered a PathMatchExpression.','line_number':107,'multiline':False]
['text':' namespace','line_number':137,'multiline':False]
['text':' Recursively apply optimizations to child expressions.','line_number':158,'multiline':False]
['text':' The Boolean simplifier is disabled since we don't want to simplify sub-expressions,','line_number':160,'multiline':False]
['text':' but simplify the whole expression instead.','line_number':161,'multiline':False]
['text':' enableSimplification ','line_number':163,'multiline':True]
['text':' Associativity of AND and OR: an AND absorbs the children of any ANDs among its children','line_number':165,'multiline':False]
['text':' (and likewise for any OR with OR children).','line_number':166,'multiline':False]
['text':' Move this child out of the children array.','line_number':172,'multiline':False]
['text':' Null out this child's entry in _expressions, so','line_number':174,'multiline':False]
['text':' that it will be deleted by the erase call below.','line_number':175,'multiline':False]
['text':' Move all of the grandchildren from the child expression to','line_number':177,'multiline':False]
['text':' absorbedExpressions.','line_number':178,'multiline':False]
['text':' Note that 'childExpressionPtr' will now be destroyed.','line_number':186,'multiline':False]
['text':' We replaced each destroyed child expression with nullptr. Now we remove those','line_number':190,'multiline':False]
['text':' nullptrs from the array.','line_number':191,'multiline':False]
['text':' Append the absorbed children to the end of the array.','line_number':194,'multiline':False]
['text':' Remove all children of AND that are $alwaysTrue and all children of OR and NOR that are','line_number':200,'multiline':False]
['text':' $alwaysFalse.','line_number':201,'multiline':False]
['text':' We replaced each destroyed child expression with nullptr. Now we remove those','line_number':209,'multiline':False]
['text':' nullptrs from the vector.','line_number':210,'multiline':False]
['text':' Check if the above optimizations eliminated all children. An OR with no children is','line_number':214,'multiline':False]
['text':' always false.','line_number':215,'multiline':False]
['text':' An AND with no children is always true and we need to return an','line_number':219,'multiline':False]
['text':' EmptyExpression. This ensures that the empty $and[] will be returned that serializes to','line_number':220,'multiline':False]
['text':' {} (SERVER-34759). A NOR with no children is always true. We treat an empty $nor[]','line_number':221,'multiline':False]
['text':' similarly.','line_number':222,'multiline':False]
['text':' Simplify AND/OR/XOR with exactly one operand to an expression consisting of just','line_number':230,'multiline':False]
['text':' that operand.','line_number':231,'multiline':False]
['text':' Simplify NOR of exactly one operand to NOT of that operand.','line_number':236,'multiline':False]
['text':' An AND containing an expression that always evaluates to false can be','line_number':247,'multiline':False]
['text':' optimized to a single $alwaysFalse expression.','line_number':248,'multiline':False]
['text':' Likewise, an OR containing an expression that always evaluates to true can be','line_number':252,'multiline':False]
['text':' optimized to a single $and[] expression that is trivially true and serializes to','line_number':253,'multiline':False]
['text':' {}. This "normalizes" the behaviour of true statements with $and and $or','line_number':254,'multiline':False]
['text':' (SERVER-34759).','line_number':255,'multiline':False]
['text':' A NOR containing an expression that always evaluates to true can be','line_number':259,'multiline':False]
['text':' optimized to a single $alwaysFalse expression.','line_number':260,'multiline':False]
['text':' Rewrite an OR with EQ conditions on the same path as an IN-list. Example:','line_number':267,'multiline':False]
['text':' {$or: [{name: "Don"}, {name: "Alice"}]}','line_number':268,'multiline':False]
['text':' is rewritten as:','line_number':269,'multiline':False]
['text':' {name: {$in: ["Alice", "Don"]}}','line_number':270,'multiline':False]
['text':' The collation of the first equality. All other equalities must have the same','line_number':275,'multiline':False]
['text':' collation in order to transform them into a single $in since the $in can have only','line_number':276,'multiline':False]
['text':' one collation. Notice that regex ignore collations.','line_number':277,'multiline':False]
['text':' Check if all children are equality conditions or regular expressions with the','line_number':284,'multiline':False]
['text':' same path argument, and same collation.','line_number':285,'multiline':False]
['text':' Disjunctions of equalities use $eq comparison, which has different semantics from','line_number':293,'multiline':False]
['text':' $in for regular expressions. The regex under the equality is matched literally as','line_number':294,'multiline':False]
['text':' a string constant, while a regex inside $in is matched as a regular expression.','line_number':295,'multiline':False]
['text':' Furthermore, $lookup processing explicitly depends on these different semantics.','line_number':296,'multiline':False]
['text':'','line_number':297,'multiline':False]
['text':' We should not attempt to rewrite an $eq:<regex> into $in because of these','line_number':298,'multiline':False]
['text':' different comparison semantics.','line_number':299,'multiline':False]
['text':' childExpression is an equality with $in comparison semantics.','line_number':314,'multiline':False]
['text':' The current approach assumes there is one (large) group of $eq disjuncts','line_number':315,'multiline':False]
['text':' that are on the same path.','line_number':316,'multiline':False]
['text':' The path of the first equality.','line_number':318,'multiline':False]
['text':' Regex ignore collations.','line_number':322,'multiline':False]
['text':' All equalities must have the same collation.','line_number':324,'multiline':False]
['text':' subsequent equality on the same path','line_number':326,'multiline':False]
['text':' equality on another path','line_number':328,'multiline':False]
['text':' The condition above checks that there are at least two equalities that can be','line_number':335,'multiline':False]
['text':' rewritten to an $in, and the we have classified all $or conditions into two disjoint','line_number':336,'multiline':False]
['text':' groups.','line_number':337,'multiline':False]
['text':' Reset the path because when we parse a $in expression which contains a','line_number':362,'multiline':False]
['text':' regexp, we create a RegexMatchExpression with an empty path.','line_number':363,'multiline':False]
['text':' TODO SERVER-53380 convert to tassertStatusOK.','line_number':366,'multiline':False]
['text':' TODO SERVER-53380 convert to tassertStatusOK.','line_number':390,'multiline':False]
['text':' The Boolean simplifier is disabled since we don't want to simplify','line_number':404,'multiline':False]
['text':' sub-expressions, but simplify the whole IN expression instead.','line_number':405,'multiline':False]
['text':' TOOD: order doesn't matter','line_number':423,'multiline':False]
['text':' -----','line_number':431,'multiline':False]
['text':' It is possible for an AndMatchExpression to have no children, resulting in the serialized','line_number':465,'multiline':False]
['text':' expression {$and: []}, which is not a valid query object.','line_number':466,'multiline':False]
['text':' -----','line_number':479,'multiline':False]
['text':' It is possible for an OrMatchExpression to have no children, resulting in the serialized','line_number':506,'multiline':False]
['text':' expression {$or: []}, which is not a valid query object. An empty $or is logically','line_number':507,'multiline':False]
['text':' equivalent to {$alwaysFalse: 1}.','line_number':508,'multiline':False]
['text':' ----','line_number':520,'multiline':False]
['text':' -------','line_number':554,'multiline':False]
['text':' Our parser does not accept a $and directly within a $not, instead expecting the direct','line_number':586,'multiline':False]
['text':' notation like {x: {$not: {$gt: 5, $lt: 0}}}. We represent such an expression with an AND','line_number':587,'multiline':False]
['text':' internally, so we un-nest it here to be able to re-parse it.','line_number':588,'multiline':False]
['text':' It is generally easier to be correct if we just always serialize to a $nor, since this will','line_number':604,'multiline':False]
['text':' delegate the path serialization to lower in the tree where we have the information on-hand.','line_number':605,'multiline':False]
['text':' However, for legibility we preserve a $not with a single path-accepting child as a $not.','line_number':606,'multiline':False]
['text':' The Boolean simplifier is disabled since we don't want to simplify sub-expressions, but','line_number':629,'multiline':False]
['text':' simplify the whole expression instead.','line_number':630,'multiline':False]
['text':' enableSimplification ','line_number':632,'multiline':True]
['text':' namespace mongo','line_number':637,'multiline':False]
