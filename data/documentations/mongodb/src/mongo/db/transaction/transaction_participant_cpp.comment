['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: keep','line_number':47,'multiline':False]
['text':' Failpoint which will pause an operation just after allocating a point-in-time storage engine','line_number':151,'multiline':False]
['text':' transaction.','line_number':152,'multiline':False]
['text':'*
 * Returns the RetryableWriteTransactionParticipantCatalog for the given session.
 ','line_number':174,'multiline':True]
['text':'*
 * Returns the RetryableWriteTransactionParticipantCatalog for the session checked out by the
 * given 'opCtx'.
 ','line_number':185,'multiline':True]
['text':' The command names that are allowed in a prepared transaction.','line_number':195,'multiline':False]
['text':'*
 * Runs the given 'callable' with a DBDirectClient with a no-timestamp read source, and restores
 * the original timestamp read source after returning. Used for performing a read against the
 * config.transactions collection during refresh below since snapshot reads and causal consistent
 * majority reads against are not supported in that collection.
 ','line_number':226,'multiline':True]
['text':' ReadConcern must also be fixed for the new scope. It will get restored when exiting this.','line_number':235,'multiline':False]
['text':' Storage engine operations require at a least global MODE_IS lock. In multi-document','line_number':268,'multiline':False]
['text':' transactions, storage opeartions require at least a global MODE_IX lock. Prevent lock','line_number':269,'multiline':False]
['text':' upgrading in the case of a multi-document transaction.','line_number':270,'multiline':False]
['text':' When state is given, it must be a transaction, so we don't need to traverse the','line_number':312,'multiline':False]
['text':' history if it is not a committed transaction for retryable writes.','line_number':313,'multiline':False]
['text':' Helper for registering statement ids of an oplog entry for a retryable write or a retryable','line_number':322,'multiline':False]
['text':' internal transaction.','line_number':323,'multiline':False]
['text':' Restore the current timestamp read source after fetching transaction history, which may','line_number':342,'multiline':False]
['text':' change our ReadSource.','line_number':343,'multiline':False]
['text':' Oplog entries for retryable writes are expected to have a statement id.','line_number':377,'multiline':False]
['text':' Only the dead end sentinel can have this id for oplog write history','line_number':381,'multiline':False]
['text':'*
 * Returns the highest txnNumber in the given session that has corresponding internal sessions as
 * found in the config.transactions collection.
 ','line_number':405,'multiline':True]
['text':' All config.transactions entries with the parentLsid field should have a txnNumber','line_number':432,'multiline':False]
['text':' in their sessionId, but users may manually modify that collection so we can't','line_number':433,'multiline':False]
['text':' assume that.','line_number':434,'multiline':False]
['text':' Current code only supports replacement update.','line_number':452,'multiline':False]
['text':' TODO SERVER-58243: evaluate whether this is safe or whether acquiring the lock can block.','line_number':457,'multiline':False]
['text':' Since we are looking up a key inside the _id index, create a key object consisting of only','line_number':489,'multiline':False]
['text':' the _id field.','line_number':490,'multiline':False]
['text':' Upsert case.','line_number':499,'multiline':False]
['text':' Document no longer match what we expect so throw WCE to make the caller re-examine.','line_number':534,'multiline':False]
['text':' Specify kUpdateNoIndexes because the sessions collection has two indexes: {_id: 1} and','line_number':544,'multiline':False]
['text':' {parentLsid: 1, _id.txnNumber: 1, _id: 1}, and none of the fields are mutable.','line_number':545,'multiline':False]
['text':' indexesAffected ','line_number':552,'multiline':True]
['text':' opDebug ','line_number':553,'multiline':True]
['text':' Failpoint which allows different failure actions to happen after each write. Supports the','line_number':559,'multiline':False]
['text':' parameters below, which can be combined with each other (unless explicitly disallowed):','line_number':560,'multiline':False]
['text':'','line_number':561,'multiline':False]
['text':' closeConnection (bool, default = true): Closes the connection on which the write was executed.','line_number':562,'multiline':False]
['text':' failBeforeCommitExceptionCode (int, default = not specified): If set, the specified exception','line_number':563,'multiline':False]
['text':'      code will be thrown, which will cause the write to not commit; if not specified, the write','line_number':564,'multiline':False]
['text':'      will be allowed to commit.','line_number':565,'multiline':False]
['text':' namespace','line_number':568,'multiline':False]
['text':' invariant(!_o.txnState.isInProgress());','line_number':575,'multiline':False]
['text':' The locker must not have a max lock timeout when this noop write is performed, since if it','line_number':610,'multiline':False]
['text':' threw LockTimeout, this would be treated as a TransientTransactionError, which would indicate','line_number':611,'multiline':False]
['text':' it's safe to retry the entire transaction. We cannot know it is safe to attach','line_number':612,'multiline':False]
['text':' TransientTransactionError until the noop write has been performed and the writeConcern has','line_number':613,'multiline':False]
['text':' been satisfied.','line_number':614,'multiline':False]
['text':' Simulate an operation timeout and fail the noop write if the fail point is enabled. This is','line_number':617,'multiline':False]
['text':' to test that NoSuchTransaction error is not considered transient if the noop write cannot','line_number':618,'multiline':False]
['text':' occur.','line_number':619,'multiline':False]
['text':' Read from config.transactions at the stable timestamp for the oldest active transaction','line_number':642,'multiline':False]
['text':' timestamp. Use a short timeout: another thread might have the global lock e.g. to shut down','line_number':643,'multiline':False]
['text':' the server, and it both blocks this thread from querying config.transactions and waits for','line_number':644,'multiline':False]
['text':' this thread to terminate.','line_number':645,'multiline':False]
['text':' There is no config database, so there cannot be any active transactions.','line_number':663,'multiline':False]
['text':' Scan. We guess that occasional scans are cheaper than the write overhead of an index.','line_number':678,'multiline':False]
['text':' A prepared transaction must have a start timestamp.','line_number':689,'multiline':False]
['text':' This must be a non-retryable child session transaction so there can't be a conflict.','line_number':756,'multiline':False]
['text':' Servers in a sharded cluster can start a new transaction at the active transaction','line_number':785,'multiline':False]
['text':' number to allow internal retries by routers on re-targeting errors, like','line_number':786,'multiline':False]
['text':' StaleShard/DatabaseVersion or SnapshotTooOld.','line_number':787,'multiline':False]
['text':' This is a retry of a committed internal transaction for retryable writes so','line_number':795,'multiline':False]
['text':' skip resetting the state and updating the metrics.','line_number':796,'multiline':False]
['text':' New retryable write.','line_number':871,'multiline':False]
['text':' Retrying a retryable write.','line_number':880,'multiline':False]
['text':' If this retryable write's transaction id has been converted to a transaction, and that','line_number':882,'multiline':False]
['text':' transaction is in prepare, wait for it to exit prepare before throwing','line_number':883,'multiline':False]
['text':' IncompleteTransactionHistory so the error response's operationTime is inclusive of the','line_number':884,'multiline':False]
['text':' transaction's 2PC decision, guaranteeing causally consistent sessions will always read','line_number':885,'multiline':False]
['text':' the transaction's writes.','line_number':886,'multiline':False]
['text':' This indicates that the first command in the transaction failed but did not implicitly','line_number':931,'multiline':False]
['text':' abort the transaction. It is not safe to continue the transaction, in particular because','line_number':932,'multiline':False]
['text':' we have not saved the readConcern from the first statement of the transaction. Mark the','line_number':933,'multiline':False]
['text':' transaction as active here, since _abortTransactionOnSession() will assume we are','line_number':934,'multiline':False]
['text':' aborting an active transaction since there are no stashed resources.','line_number':935,'multiline':False]
['text':' Aborts any in-progress txns.','line_number':954,'multiline':False]
['text':' Don't reset the RetryableWriteTransactionParticipantCatalog upon starting an internal','line_number':963,'multiline':False]
['text':' transaction for a non-retryable write since the transaction is unrelated to the','line_number':964,'multiline':False]
['text':' retryable write or transaction in the original session that the write runs in. In','line_number':965,'multiline':False]
['text':' addition, it is incorrect to clear the transaction history in the original session since','line_number':966,'multiline':False]
['text':' the history should be kept until there is a retryable write or transaction with a higher','line_number':967,'multiline':False]
['text':' txnNumber.','line_number':968,'multiline':False]
['text':' Start tracking various transactions metrics.','line_number':975,'multiline':False]
['text':'','line_number':976,'multiline':False]
['text':' We measure the start time in both microsecond and millisecond resolution. The TickSource','line_number':977,'multiline':False]
['text':' provides microsecond resolution to record the duration of the transaction. The start','line_number':978,'multiline':False]
['text':' "wall clock" time can be considered an approximation to the microsecond measurement.','line_number':979,'multiline':False]
['text':' Make sure we are still a primary. We need to hold on to the RSTL through the end of this','line_number':1009,'multiline':False]
['text':' method, as we otherwise risk stepping down in the interim and incorrectly updating the','line_number':1010,'multiline':False]
['text':' transaction number, which can abort active transactions.','line_number':1011,'multiline':False]
['text':' Disallow multi-statement transactions on shard servers that have','line_number':1018,'multiline':False]
['text':' writeConcernMajorityJournalDefault=false unless enableTestCommands=true. But allow','line_number':1019,'multiline':False]
['text':' retryable writes (autocommit == boost::none).','line_number':1020,'multiline':False]
['text':' Requests without an autocommit field are interpreted as retryable writes. They cannot specify','line_number':1052,'multiline':False]
['text':' startTransaction, which is verified earlier when parsing the request.','line_number':1053,'multiline':False]
['text':' Attempt to continue a multi-statement transaction. In this case, it is required that','line_number':1062,'multiline':False]
['text':' autocommit be given as an argument on the request, and currently it can only be false, which','line_number':1063,'multiline':False]
['text':' is verified earlier when parsing the request.','line_number':1064,'multiline':False]
['text':' Attempt to start a multi-statement transaction, which requires startTransaction be given as','line_number':1082,'multiline':False]
['text':' an argument on the request. The 'startTransaction' argument currently can only be specified','line_number':1083,'multiline':False]
['text':' as true, which is verified earlier, when parsing the request.','line_number':1084,'multiline':False]
['text':' This is a retry for the active transaction, so we don't throw, and we also don't need to','line_number':1089,'multiline':False]
['text':' start the transaction since that already happened.','line_number':1090,'multiline':False]
['text':' We don't check or fetch any on-disk state, so treat the transaction as 'valid' for the','line_number':1100,'multiline':False]
['text':' purposes of this method and continue the transaction unconditionally','line_number':1101,'multiline':False]
['text':' Assume we need to write an abort if we abort this transaction.  This method is called only','line_number':1115,'multiline':False]
['text':' on secondaries (in which case we never write anything) and when a new primary knows about','line_number':1116,'multiline':False]
['text':' an in-progress transaction.  If a new primary knows about an in-progress transaction, it','line_number':1117,'multiline':False]
['text':' needs an abort oplog entry to be written if aborted (because the new primary could not','line_number':1118,'multiline':False]
['text':' have found out if there wasn't an oplog entry for the new primary).','line_number':1119,'multiline':False]
['text':' The participant is not in prepare, so just return a ready future.','line_number':1125,'multiline':False]
['text':' The participant is in prepare, so return a future that will be signaled when the participant','line_number':1129,'multiline':False]
['text':' transitions out of prepare.','line_number':1130,'multiline':False]
['text':' The participant is not in progress or in prepare.','line_number':1136,'multiline':False]
['text':' The participant is in progress or in prepare, so return a future that will be signaled when','line_number':1141,'multiline':False]
['text':' the participant commits or aborts.','line_number':1142,'multiline':False]
['text':' There is no conflicting internal transaction.','line_number':1164,'multiline':False]
['text':' Read concern code should have already set the timestamp on the recovery unit.','line_number':1171,'multiline':False]
['text':' For transactions with read concern level specified as 'snapshot', we will use','line_number':1181,'multiline':False]
['text':' 'kAllDurableSnapshot' which ensures a snapshot with no 'holes'; that is, it is a state','line_number':1182,'multiline':False]
['text':' of the system that could be reconstructed from the oplog.','line_number':1183,'multiline':False]
['text':' For transactions with read concern level specified as 'local' or 'majority', we will use','line_number':1192,'multiline':False]
['text':' 'kNoTimestamp' which gives us the most recent snapshot.  This snapshot may reflect oplog','line_number':1193,'multiline':False]
['text':' 'holes' from writes earlier than the last applied write which have not yet completed.','line_number':1194,'multiline':False]
['text':' Using 'kNoTimestamp' ensures that transactions with mode 'local' are always able to read','line_number':1195,'multiline':False]
['text':' writes from earlier transactions with mode 'local' on the same connection.','line_number':1196,'multiline':False]
['text':' Allocate the snapshot together with a consistent CollectionCatalog instance. As we have no','line_number':1200,'multiline':False]
['text':' critical section we use optimistic concurrency control and check that there was no write to','line_number':1201,'multiline':False]
['text':' the CollectionCatalog while we allocated the storage snapshot. Stash the catalog instance so','line_number':1202,'multiline':False]
['text':' collection lookups within this transaction are consistent with the snapshot.','line_number':1203,'multiline':False]
['text':' Catalog did not change, break out of the retry loop and use this instance','line_number':1209,'multiline':False]
['text':' Catalog change detected, reallocate the snapshot and try again.','line_number':1212,'multiline':False]
['text':' Stash the transaction on the OperationContext on the stack. At the end of this function it','line_number':1222,'multiline':False]
['text':' will be unstashed onto the OperationContext.','line_number':1223,'multiline':False]
['text':' Begin a new WUOW and reserve a slot in the oplog.','line_number':1226,'multiline':False]
['text':' Release the WUOW state since this WUOW is no longer in use.','line_number':1231,'multiline':False]
['text':' We must lock the Client to change the Locker on the OperationContext.','line_number':1234,'multiline':False]
['text':' Save the RecoveryUnit from the new transaction and replace it with an empty one.','line_number':1236,'multiline':False]
['text':' The recovery unit is detached from the OperationContext, but keep the OperationContext in the','line_number':1238,'multiline':False]
['text':' case we need to run rollback handlers.','line_number':1239,'multiline':False]
['text':' End two-phase locking on locker manually since the WUOW has been released.','line_number':1244,'multiline':False]
['text':' If the constructor did not complete, we do not attempt to abort the units of work.','line_number':1256,'multiline':False]
['text':' We should be at WUOW nesting level 1, only the top level WUOW for the oplog reservation','line_number':1258,'multiline':False]
['text':' side transaction.','line_number':1259,'multiline':False]
['text':' We must hold the Client lock to change the Locker on the OperationContext. Hence the','line_number':1267,'multiline':False]
['text':' WithLock.','line_number':1268,'multiline':False]
['text':' On secondaries, we yield the locks for transactions.','line_number':1281,'multiline':False]
['text':' Transactions have at least a global IX lock.','line_number':1284,'multiline':False]
['text':' This thread must still respect the transaction lock timeout, since it can prevent the','line_number':1288,'multiline':False]
['text':' transaction from making progress.','line_number':1289,'multiline':False]
['text':' On secondaries, max lock timeout must not be set.','line_number':1296,'multiline':False]
['text':' The recovery unit is detached from the OperationContext, but keep the OperationContext in the','line_number':1301,'multiline':False]
['text':' case we need to run rollback handlers.','line_number':1302,'multiline':False]
['text':' This should only be reached when aborting a transaction that isn't active, i.e.','line_number':1313,'multiline':False]
['text':' when starting a new transaction before completing an old one.  So we should','line_number':1314,'multiline':False]
['text':' be at WUOW nesting level 1 (only the top level WriteUnitOfWork).','line_number':1315,'multiline':False]
['text':' If locks are not yielded, release them.','line_number':1317,'multiline':False]
['text':' Perform operations that can fail the release before marking the TxnResources as released.','line_number':1326,'multiline':False]
['text':' Release any locks acquired as part of lock restoration.','line_number':1328,'multiline':False]
['text':' WUOW should be released before unlocking.','line_number':1330,'multiline':False]
['text':' Release the ticket if acquired.','line_number':1337,'multiline':False]
['text':' restoreWriteUnitOfWorkAndLock() can reacquire the ticket as well.','line_number':1338,'multiline':False]
['text':' Restore locks if they are yielded.','line_number':1344,'multiline':False]
['text':' opCtx is passed in to enable the restoration to be interrupted.','line_number':1347,'multiline':False]
['text':' Successfully reacquired the locks and tickets.','line_number':1359,'multiline':False]
['text':' It is necessary to lock the client to change the Locker on the OperationContext.','line_number':1363,'multiline':False]
['text':' We intentionally do not capture the return value of shard_role_details::swapLocker(), which','line_number':1367,'multiline':False]
['text':' is just an empty locker. At the end of the operation, if the transaction is not complete, we','line_number':1368,'multiline':False]
['text':' will stash the operation context's locker and replace it with a new empty locker.','line_number':1369,'multiline':False]
['text':' Do nothing if we are already in a SideTransactionBlock. We can tell we are already in a','line_number':1393,'multiline':False]
['text':' SideTransactionBlock because there is no top level write unit of work.','line_number':1394,'multiline':False]
['text':' Release WUOW.','line_number':1399,'multiline':False]
['text':' Remember the locking state of WUOW, opt out two-phase locking, but don't release locks.','line_number':1403,'multiline':False]
['text':' Release recovery unit, saving the recovery unit off to the side, keeping open the storage','line_number':1406,'multiline':False]
['text':' transaction.','line_number':1407,'multiline':False]
['text':' Restore locker's state about WUOW.','line_number':1416,'multiline':False]
['text':' Restore recovery unit.','line_number':1419,'multiline':False]
['text':' Restore WUOW.','line_number':1425,'multiline':False]
['text':' If this is a prepared transaction, invariant that it does not hold the RSTL lock.','line_number':1445,'multiline':False]
['text':' Transaction resources already exist for this transaction.  Transfer them from the','line_number':1466,'multiline':False]
['text':' stash to the operation context.','line_number':1467,'multiline':False]
['text':'','line_number':1468,'multiline':False]
['text':' Because TxnResources::release must acquire the Client lock midway through, and because we','line_number':1469,'multiline':False]
['text':' must hold the Client clock to mutate txnResourceStash, we jump through some hoops here to','line_number':1470,'multiline':False]
['text':' move the TxnResources in txnResourceStash into a local variable that can be manipulated','line_number':1471,'multiline':False]
['text':' without holding the Client lock.','line_number':1472,'multiline':False]
['text':' Restore the lock resources back to transaction participant.','line_number':1482,'multiline':False]
['text':' If maxTransactionLockRequestTimeoutMillis is set, then we will ensure no','line_number':1495,'multiline':False]
['text':' future lock request waits longer than maxTransactionLockRequestTimeoutMillis','line_number':1496,'multiline':False]
['text':' to acquire a lock. This is to avoid deadlocks and minimize non-transaction','line_number':1497,'multiline':False]
['text':' operation performance degradations.','line_number':1498,'multiline':False]
['text':' Verify that transaction number and mode are as expected.','line_number':1518,'multiline':False]
['text':' If this is not a multi-document transaction, there is nothing to unstash.','line_number':1550,'multiline':False]
['text':' Default is we should acquire ticket.','line_number':1559,'multiline':False]
['text':' Primaries should respect the transaction lock timeout, since it can prevent','line_number':1563,'multiline':False]
['text':' the transaction from making progress.','line_number':1564,'multiline':False]
['text':' commitTransaction and abortTransaction commands can skip ticketing mechanism as they','line_number':1566,'multiline':False]
['text':' don't acquire any new storage resources (except writing to oplog) but they release','line_number':1567,'multiline':False]
['text':' any claimed storage resources.','line_number':1568,'multiline':False]
['text':' Prepared transactions should not acquire ticket. Else, it can deadlock with other','line_number':1569,'multiline':False]
['text':' non-transactional operations that have exhausted the write tickets and are blocked on','line_number':1570,'multiline':False]
['text':' them due to prepare or lock conflict.','line_number':1571,'multiline':False]
['text':' Max lock timeout must not be set on secondaries, since secondary oplog application','line_number':1577,'multiline':False]
['text':' cannot fail.','line_number':1578,'multiline':False]
['text':' If we have no transaction resources then we cannot be prepared. If we're not in progress,','line_number':1589,'multiline':False]
['text':' we don't do anything else.','line_number':1590,'multiline':False]
['text':' At this point we're either committed and this is a 'commitTransaction' command, or we','line_number':1594,'multiline':False]
['text':' are in the process of committing.','line_number':1595,'multiline':False]
['text':' All locks of transactions must be acquired inside the global WUOW so that we can','line_number':1599,'multiline':False]
['text':' yield and restore all locks on state transition. Otherwise, we'd have to remember','line_number':1600,'multiline':False]
['text':' which locks are managed by WUOW.','line_number':1601,'multiline':False]
['text':' If maxTransactionLockRequestTimeoutMillis is set, then we will ensure no','line_number':1606,'multiline':False]
['text':' future lock request waits longer than maxTransactionLockRequestTimeoutMillis','line_number':1607,'multiline':False]
['text':' to acquire a lock. This is to avoid deadlocks and minimize non-transaction','line_number':1608,'multiline':False]
['text':' operation performance degradations.','line_number':1609,'multiline':False]
['text':' On secondaries, max lock timeout must not be set.','line_number':1616,'multiline':False]
['text':' Storage engine transactions may be started in a lazy manner. By explicitly','line_number':1620,'multiline':False]
['text':' starting here we ensure that a point-in-time snapshot is established during the','line_number':1621,'multiline':False]
['text':' first operation of a transaction.','line_number':1622,'multiline':False]
['text':'','line_number':1623,'multiline':False]
['text':' Active transactions are protected by the locking subsystem, so we must always hold at least a','line_number':1624,'multiline':False]
['text':' Global intent lock before starting a transaction.  We pessimistically acquire an intent','line_number':1625,'multiline':False]
['text':' exclusive lock here because we might be doing writes in this transaction, and it is currently','line_number':1626,'multiline':False]
['text':' not deadlock-safe to upgrade IS to IX.','line_number':1627,'multiline':False]
['text':' This begins the storage transaction and so we do it after acquiring the global lock.','line_number':1630,'multiline':False]
['text':' Stashed transaction resources do not exist for this in-progress multi-document transaction.','line_number':1633,'multiline':False]
['text':' Set up the transaction resources on the opCtx. Must be done after setting up the read','line_number':1634,'multiline':False]
['text':' snapshot.','line_number':1635,'multiline':False]
['text':' The Client lock must not be held when executing this failpoint as it will block currentOp','line_number':1638,'multiline':False]
['text':' execution.','line_number':1639,'multiline':False]
['text':' The opCtx will be used to swap locks, so it cannot hold any lock.','line_number':1654,'multiline':False]
['text':' The node must have txn resource.','line_number':1658,'multiline':False]
['text':' Transfer the txn resource back from the operation context to the stash.','line_number':1664,'multiline':False]
['text':' Prepare transaction on secondaries should always succeed.','line_number':1676,'multiline':False]
['text':' This shouldn't cause deadlocks with other prepared txns, because the acquisition','line_number':1680,'multiline':False]
['text':' of RSTL lock inside abortTransaction will be no-op since we already have it.','line_number':1681,'multiline':False]
['text':' This abortGuard gets dismissed before we release the RSTL while transitioning to','line_number':1682,'multiline':False]
['text':' the prepared state.','line_number':1683,'multiline':False]
['text':' NOLINT.','line_number':1684,'multiline':False]
['text':' It is illegal for aborting a prepared transaction to fail for any reason, so we crash','line_number':1687,'multiline':False]
['text':' instead.','line_number':1688,'multiline':False]
['text':' Ensure that no transaction operations were done against temporary collections.','line_number':1700,'multiline':False]
['text':' Transactions should not operate on temporary collections because they are for internal use','line_number':1701,'multiline':False]
['text':' only and are deleted on both repl stepup and server startup.','line_number':1702,'multiline':False]
['text':' Create a set of collection UUIDs through which to iterate, so that we do not recheck the same','line_number':1704,'multiline':False]
['text':' collection multiple times: it is a costly check.','line_number':1705,'multiline':False]
['text':' This check is necessary in order to avoid a race where a session with an active (but not','line_number':1726,'multiline':False]
['text':' prepared) transaction is killed, but it still ends up in the prepared state','line_number':1727,'multiline':False]
['text':' On secondary, we just prepare the transaction and discard the buffered ops.','line_number':1735,'multiline':False]
['text':' Even if the prepared transaction contained no statements, we always reserve at least','line_number':1741,'multiline':False]
['text':' 1 oplog slot for the prepare oplog entry.','line_number':1742,'multiline':False]
['text':' This log output is used in js tests so please leave it.','line_number':1759,'multiline':False]
['text':'prepare=','line_number':1772,'multiline':True]
['text':' Don't write oplog entry on secondaries.','line_number':1785,'multiline':False]
['text':' We write the oplog entry in a side transaction so that we do not commit the now-prepared','line_number':1787,'multiline':False]
['text':' transaction. See SERVER-34824.','line_number':1788,'multiline':False]
['text':' Ensure the lastWriteOpTime is set. This is needed so that we can correctly assign the','line_number':1813,'multiline':False]
['text':' prevOpTime for commit and abort oplog entries if a failover happens after the prepare.','line_number':1814,'multiline':False]
['text':' This value is updated in _registerCacheUpdateOnCommit, but only on primaries. We','line_number':1815,'multiline':False]
['text':' update the lastWriteOpTime here so that it is also available to secondaries. We can','line_number':1816,'multiline':False]
['text':' count on it to persist since we never invalidate prepared transactions.','line_number':1817,'multiline':False]
['text':' We unlock the RSTL to allow prepared transactions to survive state transitions. This should','line_number':1828,'multiline':False]
['text':' be the last thing we do since a state transition may happen immediately after releasing the','line_number':1829,'multiline':False]
['text':' RSTL.','line_number':1830,'multiline':False]
['text':' Ensure that we only ever add operations to an in progress transaction.','line_number':1849,'multiline':False]
['text':' Throw a uassert error instead of an invariant error if this is a retryable internal','line_number':1851,'multiline':False]
['text':' transaction since all write statements are allowed to bypass the checks in','line_number':1852,'multiline':False]
['text':' beginOrContinue if the transaction has already committed.','line_number':1853,'multiline':False]
['text':' Ensure that we only ever retrieve a transaction's completed operations when in progress','line_number':1871,'multiline':False]
['text':' or prepared.','line_number':1872,'multiline':False]
['text':' Currently the response metadata only contains a single field, which is whether or not the','line_number':1880,'multiline':False]
['text':' transaction is read-only so far.','line_number':1881,'multiline':False]
['text':' Ensure that we only ever end a prepared or in-progress transaction.','line_number':1887,'multiline':False]
['text':' Reserve all the optimes in advance, so we only need to get the optime mutex once.  We','line_number':1903,'multiline':False]
['text':' reserve enough entries for all statements in the transaction.','line_number':1904,'multiline':False]
['text':' Serialize transaction statements to BSON and determine their assignment to "applyOps"','line_number':1911,'multiline':False]
['text':' entries.','line_number':1912,'multiline':False]
['text':'prepare=','line_number':1917,'multiline':True]
['text':' Read-only transactions with all read concerns must wait for any data they read to be majority','line_number':1922,'multiline':False]
['text':' committed. For local read concern this is to match majority read concern. For both local and','line_number':1923,'multiline':False]
['text':' majority read concerns we do an untimestamped read, so we have no read timestamp to wait on.','line_number':1924,'multiline':False]
['text':' Instead, we write a noop which is guaranteed to have a greater OpTime than any writes we','line_number':1925,'multiline':False]
['text':' read.','line_number':1926,'multiline':False]
['text':'','line_number':1927,'multiline':False]
['text':' TODO (SERVER-41165): Snapshot read concern should wait on the read timestamp instead.','line_number':1928,'multiline':False]
['text':' _commitStorageTransaction can throw, but it is safe for the exception to be bubbled up to','line_number':1936,'multiline':False]
['text':' the caller, since the transaction can still be safely aborted at this point.','line_number':1937,'multiline':False]
['text':' A correctly functioning coordinator could hit this uassert. This could happen if this','line_number':1952,'multiline':False]
['text':' participant shard failed over and the new primary majority committed prepare without this','line_number':1953,'multiline':False]
['text':' node in its majority. The coordinator could legally send commitTransaction with a','line_number':1954,'multiline':False]
['text':' commitTimestamp to this shard but target the old primary (this node) that has yet to prepare','line_number':1955,'multiline':False]
['text':' the transaction. We uassert since this node cannot commit the transaction.','line_number':1956,'multiline':False]
['text':' Re-acquire the RSTL to prevent state transitions while committing the transaction. When the','line_number':1962,'multiline':False]
['text':' transaction was prepared, we dropped the RSTL.','line_number':1963,'multiline':False]
['text':' Prepared transactions cannot hold the RSTL, or else they will deadlock with state','line_number':1966,'multiline':False]
['text':' transitions. If we do not commit the transaction we must unlock the RSTL explicitly so two','line_number':1967,'multiline':False]
['text':' phase locking doesn't hold onto it.','line_number':1968,'multiline':False]
['text':' A correctly functioning coordinator could hit this uassert. This could happen if this','line_number':1990,'multiline':False]
['text':' participant shard failed over and the new primary majority committed prepare but has yet','line_number':1991,'multiline':False]
['text':' to communicate that to this node. The coordinator could legally send commitTransaction','line_number':1992,'multiline':False]
['text':' with a commitTimestamp to this shard but target the old primary (this node) that does not','line_number':1993,'multiline':False]
['text':' yet know prepare is majority committed. We uassert since the commit oplog entry would be','line_number':1994,'multiline':False]
['text':' written in an old term and be guaranteed to roll back. This makes it easier to write','line_number':1995,'multiline':False]
['text':' correct tests, consider fewer participant commit cases, and catch potential bugs since','line_number':1996,'multiline':False]
['text':' hitting this uassert correctly is unlikely.','line_number':1997,'multiline':False]
['text':' We can no longer uassert without terminating.','line_number':2006,'multiline':False]
['text':' Once entering "committing with prepare" we cannot throw an exception,','line_number':2009,'multiline':False]
['text':' and therefore our lock acquisitions cannot be interruptible.','line_number':2010,'multiline':False]
['text':' NOLINT.','line_number':2011,'multiline':False]
['text':' On secondary, we generate a fake empty oplog slot, since it's not used by opObserver.','line_number':2013,'multiline':False]
['text':' When this receiving node is not in a readable state, the cluster time gossiping','line_number':2019,'multiline':False]
['text':' protocol is not enabled, thus it is necessary to advance it explicitely,','line_number':2020,'multiline':False]
['text':' so that causal consistency is maintained in these situations.','line_number':2021,'multiline':False]
['text':' On primary, we reserve an oplog slot before committing the transaction so that no','line_number':2024,'multiline':False]
['text':' writes that are causally related to the transaction commit enter the oplog at a','line_number':2025,'multiline':False]
['text':' timestamp earlier than the commit oplog entry.','line_number':2026,'multiline':False]
['text':' We always expect a non-null commitOplogEntryOpTime to be passed in on secondaries','line_number':2035,'multiline':False]
['text':' in order to set the finishOpTime.','line_number':2036,'multiline':False]
['text':' We must have a lastWriteOpTime set, as that will be used for the prevOpTime on the oplog','line_number':2040,'multiline':False]
['text':' entry.','line_number':2041,'multiline':False]
['text':' If we are a primary committing a transaction that was split into smaller prepared','line_number':2046,'multiline':False]
['text':' transactions, cascade the commit.','line_number':2047,'multiline':False]
['text':' If commitOplogEntryOpTime is a nullopt, then we grab the OpTime from commitOplogSlot','line_number':2057,'multiline':False]
['text':' which will only be set if we are primary. Otherwise, the commitOplogEntryOpTime must','line_number':2058,'multiline':False]
['text':' have been passed in during secondary oplog application.','line_number':2059,'multiline':False]
['text':' Once the transaction is committed, the oplog entry must be written.','line_number':2067,'multiline':False]
['text':' It is illegal for committing a prepared transaction to fail for any reason, other than an','line_number':2080,'multiline':False]
['text':' invalid command, so we crash instead.','line_number':2081,'multiline':False]
['text':' We must clear the recovery unit and locker for the 'config.transactions' and oplog entry','line_number':2103,'multiline':False]
['text':' writes.','line_number':2104,'multiline':False]
['text':' We cannot throw exceptions in the middle of committing multiple split transactions,','line_number':2153,'multiline':False]
['text':' and therefore our lock acquisitions cannot be interruptible. We also must set the','line_number':2154,'multiline':False]
['text':' UninterruptibleLockGuard before unstashTransactionResources because this function','line_number':2155,'multiline':False]
['text':' can throw when reacquiring locks and tickets.','line_number':2156,'multiline':False]
['text':' NOLINT','line_number':2157,'multiline':False]
['text':' Commit the storage transaction. We do not need to acquire RSTL here since the','line_number':2165,'multiline':False]
['text':' original transaction is already holding RSTL in IX mode. We also should not','line_number':2166,'multiline':False]
['text':' try to acquire RSTL again because that could deadlock with stepdown.','line_number':2167,'multiline':False]
['text':' isSplitPreparedTxn ','line_number':2169,'multiline':True]
['text':' Features such as the "split prepared transaction" optimization will not attribute','line_number':2191,'multiline':False]
['text':' transaction metrics to the internal sessions.','line_number':2192,'multiline':False]
['text':' We must clear the recovery unit and locker so any post-transaction writes can run without','line_number':2202,'multiline':False]
['text':' transactional settings such as a read timestamp.','line_number':2203,'multiline':False]
['text':' If we have are in a retryable write, use the API parameters that the client passed in with','line_number':2215,'multiline':False]
['text':' the write, instead of the first write's API parameters.','line_number':2216,'multiline':False]
['text':' An error occurred while retrying an committed retryable internal transaction should','line_number':2238,'multiline':False]
['text':' not modify the state of the committed transaction.','line_number':2239,'multiline':False]
['text':' Normally, absence of a transaction resource stash indicates an inactive transaction.','line_number':2242,'multiline':False]
['text':' However, in the case of a failed "unstash", an active transaction may exist without a stash','line_number':2243,'multiline':False]
['text':' and be killed externally.  In that case, the opCtx will not have a transaction number.','line_number':2244,'multiline':False]
['text':' Aborting an inactive transaction.','line_number':2246,'multiline':False]
['text':' TODO SERVER-58243: evaluate whether this is safe or whether acquiring the lock can block.','line_number':2256,'multiline':False]
['text':' Re-acquire the RSTL to prevent state transitions while aborting the transaction. Since the','line_number':2260,'multiline':False]
['text':' transaction was prepared, we dropped it on preparing the transaction.','line_number':2261,'multiline':False]
['text':' Prepared transactions cannot hold the RSTL, or else they will deadlock with state','line_number':2264,'multiline':False]
['text':' transitions. If we do not abort the transaction we must unlock the RSTL explicitly so two','line_number':2265,'multiline':False]
['text':' phase locking doesn't hold onto it. Unlocking the RSTL may be a noop if it's already','line_number':2266,'multiline':False]
['text':' unlocked.','line_number':2267,'multiline':False]
['text':' We reserve an oplog slot before aborting the transaction so that no writes that are','line_number':2301,'multiline':False]
['text':' causally related to the transaction abort enter the oplog at a timestamp earlier than the','line_number':2302,'multiline':False]
['text':' abort oplog entry.','line_number':2303,'multiline':False]
['text':' If we are a primary aborting a transaction that was split into smaller prepared','line_number':2306,'multiline':False]
['text':' transactions, cascade the abort.','line_number':2307,'multiline':False]
['text':' Clean up the transaction resources on the opCtx even if the transaction resources on the','line_number':2312,'multiline':False]
['text':' session were not aborted. This actually aborts the storage-transaction.','line_number':2313,'multiline':False]
['text':' If we need to write an abort oplog entry, this function can no longer be interrupted.','line_number':2317,'multiline':False]
['text':' NOLINT.','line_number':2318,'multiline':False]
['text':' Write the abort oplog entry. This must be done after aborting the storage','line_number':2320,'multiline':False]
['text':' transaction, so that the lock state is reset, and there is no max lock timeout on the','line_number':2321,'multiline':False]
['text':' locker.','line_number':2322,'multiline':False]
['text':' It is illegal for aborting a transaction that must write an abort oplog entry to fail','line_number':2327,'multiline':False]
['text':' after aborting the storage transaction, so we crash instead.','line_number':2328,'multiline':False]
['text':' Clean up the transaction resources on the opCtx even if the transaction resources on the','line_number':2339,'multiline':False]
['text':' session were not aborted. This actually aborts the storage-transaction.','line_number':2340,'multiline':False]
['text':'','line_number':2341,'multiline':False]
['text':' These functions are allowed to throw. We are not writing an oplog entry, so the only risk','line_number':2342,'multiline':False]
['text':' is not cleaning up some internal TransactionParticipant state, updating metrics, or','line_number':2343,'multiline':False]
['text':' logging the end of the transaction. That will either be cleaned up in the','line_number':2344,'multiline':False]
['text':' ServiceEntryPoint's abortGuard or when the next transaction begins.','line_number':2345,'multiline':False]
['text':' If there are split prepared sessions, it must be because this transaction was prepared','line_number':2359,'multiline':False]
['text':' via an oplog entry applied as a secondary.','line_number':2360,'multiline':False]
['text':' We cannot throw exceptions in the middle of aborting multiple split transactions,','line_number':2385,'multiline':False]
['text':' and therefore our lock acquisitions cannot be interruptible. We also must set the','line_number':2386,'multiline':False]
['text':' UninterruptibleLockGuard before unstashTransactionResources because this function','line_number':2387,'multiline':False]
['text':' can throw when reacquiring locks and tickets.','line_number':2388,'multiline':False]
['text':' NOLINT','line_number':2389,'multiline':False]
['text':' Abort the storage transaction. We do not need to acquire RSTL here since the','line_number':2394,'multiline':False]
['text':' original transaction is already holding RSTL in IX mode. We also should not','line_number':2395,'multiline':False]
['text':' try to acquire RSTL again because that could deadlock with stepdown.','line_number':2396,'multiline':False]
['text':' isSplitPreparedTxn ','line_number':2398,'multiline':True]
['text':' Only abort the transaction in session if it's in expected states.','line_number':2412,'multiline':False]
['text':' When the state of active transaction on session is not expected, it means another','line_number':2413,'multiline':False]
['text':' thread has already aborted the transaction on session.','line_number':2414,'multiline':False]
['text':' The active transaction is not a multi-document transaction.','line_number':2420,'multiline':False]
['text':' Cannot abort these states unless they are specified in expectedStates explicitly.','line_number':2425,'multiline':False]
['text':'','line_number':2426,'multiline':False]
['text':'','line_number':2427,'multiline':False]
['text':' If _activeTxnNumber is higher than ours, it means the transaction is already aborted.','line_number':2431,'multiline':False]
['text':' Log the transaction if its duration is longer than the slowMS command threshold.','line_number':2474,'multiline':False]
['text':' Reset the WUOW. We should be able to abort empty transactions that don't have WUOW.','line_number':2483,'multiline':False]
['text':' There are two cases that are legal to abort a unit of work without RSTL:','line_number':2485,'multiline':False]
['text':' 1. We are aborting a split prepared transaction, in which case the RSTL is held by','line_number':2486,'multiline':False]
['text':'    the original prepared transaction.','line_number':2487,'multiline':False]
['text':' 2. We have failed trying to get the initial global lock, in which case we will have','line_number':2488,'multiline':False]
['text':'    a WriteUnitOfWork but not have allocated the storage transaction.','line_number':2489,'multiline':False]
['text':' We must clear the recovery unit and locker so any post-transaction writes can run without','line_number':2495,'multiline':False]
['text':' transactional settings such as a read timestamp.','line_number':2496,'multiline':False]
['text':' Cannot change committed transaction but allow retrying:','line_number':2513,'multiline':False]
['text':' - commitTransaction command.','line_number':2514,'multiline':False]
['text':' - any command if the transaction is an internal transaction for retryable writes.','line_number':2515,'multiline':False]
['text':' Disallow operations other than abort, prepare or commit on a prepared transaction','line_number':2522,'multiline':False]
['text':' The Client mutex must be held when calling this function, so it is safe to access the state','line_number':2572,'multiline':False]
['text':' of the TransactionParticipant.','line_number':2573,'multiline':False]
['text':' If we are transitioning out of prepare, fulfill and reset the exit prepare promise.','line_number':2679,'multiline':False]
['text':' If we have transitioned into prepare, initialize the exit prepare promise so other threads','line_number':2688,'multiline':False]
['text':' can wait for the participant to transition out of prepare.','line_number':2689,'multiline':False]
['text':' If we have transitioned into the in progress or prepare state, initialize the commit or','line_number':2696,'multiline':False]
['text':' abort promise so other threads can wait for the participant to commit or abort.','line_number':2697,'multiline':False]
['text':' If we have transitioned into the commited or aborted or none state, fulfill and reset the','line_number':2700,'multiline':False]
['text':' commit or abort promise. If the state transition is caused by a refresh, the promise is','line_number':2701,'multiline':False]
['text':' expected to have not been initialized and no work is required.','line_number':2702,'multiline':False]
['text':' User specified transaction parameters.','line_number':2727,'multiline':False]
['text':' Number of yields is always 0 in multi-document transactions, but it is included mainly to','line_number':2763,'multiline':False]
['text':' match the format with other slow operation logging messages.','line_number':2764,'multiline':False]
['text':' Aggregate lock statistics.','line_number':2766,'multiline':False]
['text':' It is possible for a slow transaction to have aborted in the prepared state if an','line_number':2775,'multiline':False]
['text':' exception was thrown before prepareTransaction succeeds.','line_number':2776,'multiline':False]
['text':' Total duration of the transaction.','line_number':2786,'multiline':False]
['text':' User specified transaction parameters.','line_number':2803,'multiline':False]
['text':' Number of yields is always 0 in multi-document transactions, but it is included mainly to','line_number':2835,'multiline':False]
['text':' match the format with other slow operation logging messages.','line_number':2836,'multiline':False]
['text':' Aggregate lock statistics.','line_number':2838,'multiline':False]
['text':' It is possible for a slow transaction to have aborted in the prepared state if an','line_number':2847,'multiline':False]
['text':' exception was thrown before prepareTransaction succeeds.','line_number':2848,'multiline':False]
['text':' Total duration of the transaction.','line_number':2858,'multiline':False]
['text':' Needs to be kept in sync with _transactionInfoForLog','line_number':2864,'multiline':False]
['text':' User specified transaction parameters.','line_number':2873,'multiline':False]
['text':' Number of yields is always 0 in multi-document transactions, but it is included mainly to','line_number':2911,'multiline':False]
['text':' match the format with other slow operation logging messages.','line_number':2912,'multiline':False]
['text':' Aggregate lock statistics.','line_number':2914,'multiline':False]
['text':' It is possible for a slow transaction to have aborted in the prepared state if an','line_number':2923,'multiline':False]
['text':' exception was thrown before prepareTransaction succeeds.','line_number':2924,'multiline':False]
['text':' Total duration of the transaction.','line_number':2934,'multiline':False]
['text':' Only log multi-document transactions.','line_number':2949,'multiline':False]
['text':' Abort the existing transaction if it's not prepared, committed, or aborted.','line_number':2982,'multiline':False]
['text':' If txnNumber ordering applies, abort any child transactions with a lesser txnNumber.','line_number':2986,'multiline':False]
['text':' Reset the retryable writes state','line_number':2997,'multiline':False]
['text':' Reset the transactions metrics','line_number':3000,'multiline':False]
['text':' Reset the transactional state','line_number':3003,'multiline':False]
['text':' Only observe parent sessions because retryable transactions begin the same txnNumber on','line_number':3008,'multiline':False]
['text':' their parent session.','line_number':3009,'multiline':False]
['text':' The transaction isn't open, so it can't conflict with an incoming transaction.','line_number':3075,'multiline':False]
['text':' To match the behavior of client transactions when a logically earlier prepared','line_number':3083,'multiline':False]
['text':' transaction is in progress, throw an error to block the new transaction until the','line_number':3084,'multiline':False]
['text':' earlier one exists prepare.','line_number':3085,'multiline':False]
['text':' Otherwise skip this transaction because it will be aborted when this one begins.','line_number':3090,'multiline':False]
['text':' Only abort when the transaction is in progress since other states may not be safe,','line_number':3096,'multiline':False]
['text':' e.g. prepare.','line_number':3097,'multiline':False]
['text':' This was called while refreshing from storage or applying ops on a secondary, so skip it.','line_number':3118,'multiline':False]
['text':' We should never try to abort a prepared transaction. We should have earlier thrown either','line_number':3131,'multiline':False]
['text':' RetryableTransactionInProgress or PreparedTransactionInProgress.','line_number':3132,'multiline':False]
['text':' Internal sessions for non-retryable writes only support transactions and those','line_number':3160,'multiline':False]
['text':' transactions are not retryable or related to the retryable write or transaction the','line_number':3161,'multiline':False]
['text':' original sessions that those writes run in, so there is no need to do a cross-session','line_number':3162,'multiline':False]
['text':' refresh.','line_number':3163,'multiline':False]
['text':' We should never be refreshing a prepared or in-progress transaction from','line_number':3211,'multiline':False]
['text':' storage since it should already be in a valid state after replication','line_number':3212,'multiline':False]
['text':' recovery.','line_number':3213,'multiline':False]
['text':' Populate the catalog if the session is running a retryable write, and reset it otherwise.','line_number':3248,'multiline':False]
['text':' Add parent Participant.','line_number':3251,'multiline':False]
['text':' Add child participants.','line_number':3254,'multiline':False]
['text':' Make sure that every child session has a corresponding','line_number':3257,'multiline':False]
['text':' Session/TransactionParticipant.','line_number':3258,'multiline':False]
['text':' Only write statements in retryable internal transaction can bypass the checks in','line_number':3323,'multiline':False]
['text':' beginOrContinue and get to here.','line_number':3324,'multiline':False]
['text':' Sanity check that we don't double-execute statements','line_number':3331,'multiline':False]
['text':' Do not increase consumption metrics during updating session entry, as this','line_number':3348,'multiline':False]
['text':' will cause a tenant to be billed for reading or writing on session transactions table.','line_number':3349,'multiline':False]
['text':' Do not increase consumption metrics during updating session entry, as this','line_number':3370,'multiline':False]
['text':' will cause a tenant to be billed for reading or writing on session transactions table.','line_number':3371,'multiline':False]
['text':' Reset the transactions metrics.','line_number':3384,'multiline':False]
['text':' If we are transitioning to kNone, we are either starting a new transaction or aborting a','line_number':3398,'multiline':False]
['text':' prepared transaction for rollback. In the latter case, we will need to relax the','line_number':3399,'multiline':False]
['text':' invariant that prevents transitioning from kPrepared to kNone.','line_number':3400,'multiline':False]
['text':' Swap out txnResourceStash while holding the Client lock, then release any locks held by this','line_number':3414,'multiline':False]
['text':' participant and abort the storage transaction after releasing the lock. The transaction','line_number':3415,'multiline':False]
['text':' rollback can block indefinitely if the storage engine recruits it for eviction. In that case','line_number':3416,'multiline':False]
['text':' we should not be holding the Client lock, as that would block tasks like the periodic','line_number':3417,'multiline':False]
['text':' transaction killer from making progress.','line_number':3418,'multiline':False]
['text':' Make sure we have a valid OperationContext set in the RecoveryUnit when it is destroyed as it','line_number':3424,'multiline':False]
['text':' is passed to registered rollback handlers.','line_number':3425,'multiline':False]
['text':' Invalidate the session and clear both the retryable writes and transactional states on','line_number':3439,'multiline':False]
['text':' this participant.','line_number':3440,'multiline':False]
['text':' Get the RetryableWriteTransactionParticipantCatalog without checking the opCtx has checked','line_number':3444,'multiline':False]
['text':' out this session since by design it is illegal to invalidate sessions with an opCtx that has','line_number':3445,'multiline':False]
['text':' a session checked out.','line_number':3446,'multiline':False]
['text':' Don't invalidate the RetryableWriteTransactionParticipantCatalog upon invalidating an','line_number':3450,'multiline':False]
['text':' internal transaction for a non-retryable write since the transaction is unrelated to','line_number':3451,'multiline':False]
['text':' the retryable write or transaction in the original session that the write runs in.','line_number':3452,'multiline':False]
['text':' Use a SideTransactionBlock since it is illegal to scan the oplog while in a write unit of','line_number':3467,'multiline':False]
['text':' work.','line_number':3468,'multiline':False]
['text':' If this was a retryable write, reset the transaction state so this participant can be','line_number':3574,'multiline':False]
['text':' reused for the transaction mongos will use to handle the WouldChangeOwningShard error.','line_number':3575,'multiline':False]
['text':' (Ignore FCV check): The feature flag is fully disabled.','line_number':3585,'multiline':False]
['text':' If this was a retryable transaction, add a sentinel noop to the transaction's operations','line_number':3588,'multiline':False]
['text':' so retries can detect that a WouldChangeOwningShard error was thrown and know to throw','line_number':3589,'multiline':False]
['text':' IncompleteTransactionHistory.','line_number':3590,'multiline':False]
['text':' Set the "o2" field to differentiate between a WouldChangeOwningShard noop oplog entry','line_number':3598,'multiline':False]
['text':' written while handling a WouldChangeOwningShard error and a noop oplog entry with','line_number':3599,'multiline':False]
['text':' {"o": {$wouldChangeOwningShard: 1}} written by an external client through the','line_number':3600,'multiline':False]
['text':' appendOplogNote command.','line_number':3601,'multiline':False]
['text':' Required by chunk migration and resharding.','line_number':3604,'multiline':False]
['text':' Required by chunk migration.','line_number':3613,'multiline':False]
['text':' The operation that triggers WouldChangeOwningShard should always be the first in its','line_number':3617,'multiline':False]
['text':' transaction.','line_number':3618,'multiline':False]
['text':' The cache of the last written record must always be advanced after a write so that','line_number':3640,'multiline':False]
['text':' subsequent writes have the correct point to start from.','line_number':3641,'multiline':False]
['text':' If this is the first time executing a retryable write, we should indicate that to','line_number':3662,'multiline':False]
['text':' the transaction participant.','line_number':3663,'multiline':False]
['text':' namespace mongo','line_number':3699,'multiline':False]
