['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "boost/system/detail/error_code.hpp"','line_number':75,'multiline':False]
['text':' IWYU pragma: no_include "cxxabi.h"','line_number':79,'multiline':False]
['text':' namespace','line_number':174,'multiline':False]
['text':' SERVER-35361: Arbiters will no longer downgrade their data files. To downgrade','line_number':179,'multiline':False]
['text':' binaries, the user must delete the dbpath. It's not particularly expensive for a','line_number':180,'multiline':False]
['text':' replica set to re-initialize an arbiter that comes online.','line_number':181,'multiline':False]
['text':' If the FCV document hasn't been read, trust the WT compatibility. MongoD will','line_number':187,'multiline':False]
['text':' downgrade to the same compatibility it discovered on startup.','line_number':188,'multiline':False]
['text':' (Generic FCV reference): Only consider downgrading when FCV has been fully downgraded to last','line_number':193,'multiline':False]
['text':' continuous or last LTS. It's possible for WiredTiger to introduce a data format change in a','line_number':194,'multiline':False]
['text':' continuous release. This FCV gate must remain across binary version releases.','line_number':195,'multiline':False]
['text':' If this process is run with `--replSet`, it must have run any startup replication','line_number':203,'multiline':False]
['text':' recovery and downgrading at this point is safe.','line_number':204,'multiline':False]
['text':' If we're not running with `--replSet`, don't allow downgrades if the node needed to run','line_number':209,'multiline':False]
['text':' replication recovery. Having a recovery timestamp implies recovery must be run, but it','line_number':210,'multiline':False]
['text':' was not.','line_number':211,'multiline':False]
['text':' If there is no `recoveryTimestamp`, then the data should be consistent with the top of','line_number':215,'multiline':False]
['text':' oplog and downgrading can proceed. This is expected for standalone datasets that use FCV.','line_number':216,'multiline':False]
['text':' With the introduction of continuous releases, there are two downgrade paths from kLatest.','line_number':235,'multiline':False]
['text':' Either to kLastContinuous or kLastLTS. It's possible for the data format to differ between','line_number':236,'multiline':False]
['text':' kLastContinuous and kLastLTS and we'll need to handle that appropriately here. We only','line_number':237,'multiline':False]
['text':' consider downgrading when FCV has been fully downgraded.','line_number':238,'multiline':False]
['text':' (Generic FCV reference): This FCV check should exist across LTS binary versions because the','line_number':240,'multiline':False]
['text':' logic for keeping the WiredTiger release version compatible with the server FCV version will','line_number':241,'multiline':False]
['text':' be the same across different LTS binary versions.','line_number':242,'multiline':False]
['text':' If the data format between kLatest and kLastContinuous differs, change the','line_number':244,'multiline':False]
['text':' 'kLastContinuousWTRelease' version.','line_number':245,'multiline':False]
['text':' (Generic FCV reference): This FCV check should exist across LTS binary versions because','line_number':247,'multiline':False]
['text':' the logic for keeping the WiredTiger release version compatible with the server FCV','line_number':248,'multiline':False]
['text':' version will be the same across different LTS binary versions.','line_number':249,'multiline':False]
['text':' If the data format between kLatest and kLastLTS differs, change the','line_number':251,'multiline':False]
['text':' 'kLastLTSWTRelease' version.','line_number':252,'multiline':False]
['text':' We're in a state that's not ready to downgrade. Use the latest WiredTiger version for this','line_number':256,'multiline':False]
['text':' binary.','line_number':257,'multiline':False]
['text':' deleteSelf ','line_number':269,'multiline':True]
['text':' TODO(SERVER-74657): Please revisit if this thread could be made killable.','line_number':278,'multiline':False]
['text':' Check every 10 seconds or sooner in the debug builds','line_number':290,'multiline':False]
['text':' Wake up the session sweeper thread early, we do not want the shutdown','line_number':304,'multiline':False]
['text':' to wait for us too long.','line_number':305,'multiline':False]
['text':' protects _condvar','line_number':315,'multiline':False]
['text':' The session sweeper thread idles on this condition variable for a particular time duration','line_number':316,'multiline':False]
['text':' between cleaning up expired sessions. It can be triggered early to expediate shutdown.','line_number':317,'multiline':False]
['text':' Timestamp.','line_number':324,'multiline':False]
['text':' boost::none.','line_number':327,'multiline':False]
['text':' If we've requested an ephemeral instance we store everything into memory instead of','line_number':391,'multiline':False]
['text':' backing it onto disk. Logging is not supported in this instance, thus we also have to','line_number':392,'multiline':False]
['text':' disable it.','line_number':393,'multiline':False]
['text':' In persistent mode we enable the journal and set the compression settings.','line_number':396,'multiline':False]
['text':' Enable JSON output for errors and messages.','line_number':408,'multiline':False]
['text':' Generate the settings related to the verbose configuration.','line_number':411,'multiline':False]
['text':' Do not abort the process when corruption is found in debug builds, which supports','line_number':415,'multiline':False]
['text':' increased test coverage.','line_number':416,'multiline':False]
['text':' For select debug builds, support enabling WiredTiger eviction debug mode. This uses','line_number':418,'multiline':False]
['text':' more aggressive eviction tactics, but may have a negative performance impact.','line_number':419,'multiline':False]
['text':' For applications using WT, advancing a cursor invalidates the data/memory that cursor was','line_number':426,'multiline':False]
['text':' pointing to. WT performs the optimization of managing its own memory. The unit of memory','line_number':427,'multiline':False]
['text':' allocation is a page. Walking a cursor from one key/value to the next often lands on the','line_number':428,'multiline':False]
['text':' same page, which has the effect of keeping the address of the prior key/value valid. For','line_number':429,'multiline':False]
['text':' a bug to occur, the cursor must move across pages, and the prior page must be','line_number':430,'multiline':False]
['text':' evicted. While rare, this can happen, resulting in reading random memory.','line_number':431,'multiline':False]
['text':'','line_number':432,'multiline':False]
['text':' The cursor copy debug mode will instead cause WT to malloc/free memory for each key/value','line_number':433,'multiline':False]
['text':' a cursor is positioned on. Thus, enabling when using with address sanitizer will catch','line_number':434,'multiline':False]
['text':' many cases of dereferencing invalid cursor positions. Note, there is a known caveat: a','line_number':435,'multiline':False]
['text':' free/malloc for roughly the same allocation size can often return the same memory','line_number':436,'multiline':False]
['text':' address. This is a scenario where the address sanitizer is not able to detect a','line_number':437,'multiline':False]
['text':' use-after-free error.','line_number':438,'multiline':False]
['text':'','line_number':439,'multiline':False]
['text':' Additionally, WT does not use the standard C thread model and thus TSAN can report false','line_number':440,'multiline':False]
['text':' data races when touching memory that was allocated within WT. The cursor_copy mode','line_number':441,'multiline':False]
['text':' alleviates this by copying all returned data to its own buffer before leaving the storage','line_number':442,'multiline':False]
['text':' engine.','line_number':443,'multiline':False]
['text':' TSAN builds may take longer for certain operations, increase or disable the relevant','line_number':447,'multiline':False]
['text':' timeouts.','line_number':448,'multiline':False]
['text':' Enable debug write-ahead logging for all tables when testing is enabled.','line_number':453,'multiline':False]
['text':'','line_number':454,'multiline':False]
['text':' If MongoDB startup fails, there may be clues from the previous run still left in the WT','line_number':455,'multiline':False]
['text':' log files that can provide some insight into how the system got into a bad state. When','line_number':456,'multiline':False]
['text':' testing is enabled, keep around some of these files for investigative purposes.','line_number':457,'multiline':False]
['text':'','line_number':458,'multiline':False]
['text':' We strive to keep 4 minutes of logs. Increase the retention for tests that take','line_number':459,'multiline':False]
['text':' checkpoints more often.','line_number':460,'multiline':False]
['text':'bytes in hex','line_number':504,'multiline':True]
['text':'nul terminator','line_number':504,'multiline':True]
['text':'bytes in hex','line_number':517,'multiline':True]
['text':'nul terminator','line_number':517,'multiline':True]
['text':' The oldest timestamp is set in WT. Only set the in-memory variable.','line_number':525,'multiline':False]
['text':' If there's no recovery timestamp, MDB has not produced a consistent snapshot of','line_number':531,'multiline':False]
['text':' data. `_oldestTimestamp` and `_initialDataTimestamp` are only meaningful when there's a','line_number':532,'multiline':False]
['text':' consistent snapshot of data.','line_number':533,'multiline':False]
['text':'','line_number':534,'multiline':False]
['text':' Note, this code is defensive (i.e: protects against a theorized, unobserved case) and is','line_number':535,'multiline':False]
['text':' primarily concerned with restarts of a process that was performing an eMRC=off rollback via','line_number':536,'multiline':False]
['text':' refetch.','line_number':537,'multiline':False]
['text':' Until the Replication layer installs a real callback, prevent truncating the oplog.','line_number':549,'multiline':False]
['text':' If the oldest/initial data timestamps were unset (there was no persisted durable','line_number':555,'multiline':False]
['text':' history), initialize them to the recovery timestamp.','line_number':556,'multiline':False]
['text':' Communicate the oldest timestamp to WT.','line_number':559,'multiline':False]
['text':' Pin the oldest timestamp prior to calling `setStableTimestamp` as that attempts to','line_number':563,'multiline':False]
['text':' advance the oldest timestamp. We do this pinning to give features such as resharding','line_number':564,'multiline':False]
['text':' an opportunity to re-pin the oldest timestamp after a restart. The assumptions this','line_number':565,'multiline':False]
['text':' relies on are that:','line_number':566,'multiline':False]
['text':'','line_number':567,'multiline':False]
['text':' 1) The feature stores the desired pin timestamp in some local collection.','line_number':568,'multiline':False]
['text':' 2) This temporary pinning lasts long enough for the catalog to be loaded and','line_number':569,'multiline':False]
['text':'    accessed.','line_number':570,'multiline':False]
['text':' We do not maintain any snapshot history for the ephemeral storage engine in production','line_number':586,'multiline':False]
['text':' because replication and sharded transactions do not currently run on the inMemory engine.','line_number':587,'multiline':False]
['text':' It is live in testing, however.','line_number':588,'multiline':False]
['text':' Remove server parameters that we added in the constructor, to enable unit tests to reload the','line_number':609,'multiline':False]
['text':' storage engine again in this same process.','line_number':610,'multiline':False]
['text':' Background compaction should not be executed if:','line_number':625,'multiline':False]
['text':' - checkpoints are disabled or,','line_number':626,'multiline':False]
['text':' - user writes are not allowed.','line_number':627,'multiline':False]
['text':'enable=','line_number':632,'multiline':True]
['text':'runOnce=','line_number':633,'multiline':True]
['text':'freeSpaceTargetMB=','line_number':634,'multiline':True]
['text':'excludedIdents','line_number':635,'multiline':True]
['text':' MongoDB 4.4 will always run in compatibility version 10.0.','line_number':650,'multiline':False]
['text':' WT 4.4+ will refuse to startup on datafiles left behind by 4.0 and earlier. This behavior','line_number':661,'multiline':False]
['text':' is enforced outside of `require_min`. This condition is detected via a specific error','line_number':662,'multiline':False]
['text':' message from WiredTiger.','line_number':663,'multiline':False]
['text':' In case this process was started with `--repair`, remove the "repair incomplete"','line_number':665,'multiline':False]
['text':' file.','line_number':666,'multiline':False]
['text':' MongoDB 4.4 doing clean shutdown in FCV 4.2 will use compatibility version 3.3.','line_number':675,'multiline':False]
['text':' MongoDB 4.2 uses compatibility version 3.2.','line_number':683,'multiline':False]
['text':' Always attempt to salvage metadata regardless of error code when in repair mode.','line_number':710,'multiline':False]
['text':' these must be the last things we do before _conn->close();','line_number':732,'multiline':False]
['text':'oplogRecordStore=','line_number':733,'multiline':True]
['text':'shuttingDown=','line_number':733,'multiline':True]
['text':'syncToDisk=','line_number':748,'multiline':True]
['text':' The size storer has to be destructed after the session cache has shut down. This sets the','line_number':750,'multiline':False]
['text':' shutdown flag internally in the session cache. As operations get interrupted during shutdown,','line_number':751,'multiline':False]
['text':' they release their session back to the session cache. If the shutdown flag has been set,','line_number':752,'multiline':False]
['text':' released sessions will skip flushing the size storer.','line_number':753,'multiline':False]
['text':' We want WiredTiger to leak memory for faster shutdown except when we are running tools to','line_number':756,'multiline':False]
['text':' look for memory leaks.','line_number':757,'multiline':False]
['text':' NOLINT','line_number':761,'multiline':False]
['text':' After a rollback via refetch, WT update chains for _id index keys can be logically','line_number':779,'multiline':False]
['text':' corrupt for read timestamps earlier than the `_initialDataTimestamp`. Because the stable','line_number':780,'multiline':False]
['text':' timestamp is really a read timestamp, we must avoid taking a stable checkpoint.','line_number':781,'multiline':False]
['text':'','line_number':782,'multiline':False]
['text':' If a stable timestamp is not set, there's no risk of reading corrupt history.','line_number':783,'multiline':False]
['text':' Using a side session to avoid transactional issues','line_number':836,'multiline':False]
['text':' WT may return EBUSY if the database contains dirty data. If we checkpoint and retry the','line_number':841,'multiline':False]
['text':' operation it will attempt to clean up the dirty elements during checkpointing, thus allowing','line_number':842,'multiline':False]
['text':' the operation to succeed if it was the only reason to fail.','line_number':843,'multiline':False]
['text':' Same reasoning for handling EBUSY errors as above.','line_number':864,'multiline':False]
['text':'  If the data is unsalvageable, we should completely rebuild the ident.','line_number':880,'multiline':False]
['text':' This is safe to call after moving the file because it only reads from the metadata, and not','line_number':908,'multiline':False]
['text':' the data file itself.','line_number':909,'multiline':False]
['text':' WT may return EBUSY if the database contains dirty data. If we checkpoint and retry the','line_number':921,'multiline':False]
['text':' operation it will attempt to clean up the dirty elements during checkpointing, thus allowing','line_number':922,'multiline':False]
['text':' the operation to succeed if it was the only reason to fail.','line_number':923,'multiline':False]
['text':' Immediately flush the size storer information to disk. When the node is fsync locked for','line_number':966,'multiline':False]
['text':' operations such as backup, it's imperative that we copy the most up-to-date data files.','line_number':967,'multiline':False]
['text':' If there's no journal (ephemeral), we must checkpoint all of the data.','line_number':970,'multiline':False]
['text':' We will skip updating the journal listener if the caller holds read locks.','line_number':975,'multiline':False]
['text':' The JournalListener may do writes, and taking write locks would conflict with the read locks.','line_number':976,'multiline':False]
['text':' The inMemory Storage Engine cannot create a backup cursor.','line_number':987,'multiline':False]
['text':' Persist the sizeStorer information to disk before opening the backup cursor.','line_number':992,'multiline':False]
['text':' This cursor will be freed by the backupSession being closed as the session is uncached','line_number':995,'multiline':False]
['text':' There could be a race with clean shutdown which unconditionally closes all the sessions.','line_number':1009,'multiline':False]
['text':' Prevent calling _session->close() in destructor.','line_number':1010,'multiline':False]
['text':' Opening an incremental backup cursor with the "force_stop=true" configuration option then','line_number':1016,'multiline':False]
['text':' closing the cursor will set a flag in WiredTiger that causes it to release all incremental','line_number':1017,'multiline':False]
['text':' information and resources.','line_number':1018,'multiline':False]
['text':' Opening a subsequent incremental backup cursor will reset the flag in WiredTiger and','line_number':1019,'multiline':False]
['text':' reinstate incremental backup history.','line_number':1020,'multiline':False]
['text':' TODO SERVER-13455: Replace `journal/` with the configurable journal path.','line_number':1044,'multiline':False]
['text':' We may still have backup blocks to retrieve for the existing file that','line_number':1093,'multiline':False]
['text':' _wtBackup->cursor is open on if _wtBackup->dupCursor exists. In this case, do not','line_number':1094,'multiline':False]
['text':' call next() on _wtBackup->cursor.','line_number':1095,'multiline':False]
['text':' If extendBackupCursor() is called prior to the StreamingCursor running into log','line_number':1110,'multiline':False]
['text':' files, we must ensure that subsequent calls to getNextBatch() do not return','line_number':1111,'multiline':False]
['text':' duplicate files.','line_number':1112,'multiline':False]
['text':' For a subsequent incremental backup, each BackupBlock corresponds to changes','line_number':1128,'multiline':False]
['text':' made to data files since the initial incremental backup. Each BackupBlock has a','line_number':1129,'multiline':False]
['text':' maximum size of options.blockSizeMB. Incremental backups open a duplicate cursor,','line_number':1130,'multiline':False]
['text':' which is stored in _wtBackup->dupCursor.','line_number':1131,'multiline':False]
['text':'','line_number':1132,'multiline':False]
['text':' 'backupBlocks' is an out parameter.','line_number':1133,'multiline':False]
['text':' For a full backup or the initial incremental backup, each BackupBlock corresponds','line_number':1141,'multiline':False]
['text':' to an entire file. Full backups cannot open an incremental cursor, even if they','line_number':1142,'multiline':False]
['text':' are the initial incremental backup.','line_number':1143,'multiline':False]
['text':' offset ','line_number':1151,'multiline':True]
['text':' For each file listed, open a duplicate backup cursor and get the blocks to copy.','line_number':1180,'multiline':False]
['text':' If the file is unchanged, push a BackupBlock with offset=0 and length=0. This allows us','line_number':1227,'multiline':False]
['text':' to distinguish between an unchanged file and a deleted file in an incremental backup.','line_number':1228,'multiline':False]
['text':' offset ','line_number':1236,'multiline':True]
['text':' length ','line_number':1237,'multiline':True]
['text':' If the duplicate backup cursor has been exhausted, close it and set','line_number':1241,'multiline':False]
['text':' _wtBackup->dupCursor=nullptr.','line_number':1242,'multiline':False]
['text':' '_wtBackup' is an out parameter.','line_number':1259,'multiline':False]
['text':' namespace','line_number':1262,'multiline':False]
['text':' Create ongoingBackup.lock file to signal recovery that it should delete WiredTiger.backup if','line_number':1286,'multiline':False]
['text':' we have an unclean shutdown with the cursor still open.','line_number':1287,'multiline':False]
['text':' Oplog truncation thread won't remove oplog since the checkpoint pinned by the backup cursor.','line_number':1290,'multiline':False]
['text':' Persist the sizeStorer information to disk before opening the backup cursor. We aren't','line_number':1295,'multiline':False]
['text':' guaranteed to have the most up-to-date size information after the backup as writes can still','line_number':1296,'multiline':False]
['text':' occur during a nonblocking backup.','line_number':1297,'multiline':False]
['text':' This cursor will be freed by the backupSession being closed as the session is uncached','line_number':1300,'multiline':False]
['text':' A nullptr indicates that no duplicate cursor is open during an incremental backup.','line_number':1311,'multiline':False]
['text':' Oplog truncation thread can now remove the pinned oplog.','line_number':1333,'multiline':False]
['text':' Persist the sizeStorer information to disk before extending the backup cursor.','line_number':1354,'multiline':False]
['text':' The "target=(\"log:\")" configuration string for the cursor will ensure that we only see the','line_number':1357,'multiline':False]
['text':' log files when iterating on the cursor.','line_number':1358,'multiline':False]
['text':' Once all the backup cursors have been opened on a sharded cluster, we need to ensure that the','line_number':1387,'multiline':False]
['text':' data being copied from each shard is at the same point-in-time across the entire cluster to','line_number':1388,'multiline':False]
['text':' have a consistent view of the data. For shards that opened their backup cursor before the','line_number':1389,'multiline':False]
['text':' established point-in-time for backup, they will need to create a full copy of the additional','line_number':1390,'multiline':False]
['text':' journal files returned by this method to ensure a consistent backup of the data is taken.','line_number':1391,'multiline':False]
['text':' ignore, we'll try again later.','line_number':1404,'multiline':False]
['text':' A clustered collection requires both CollectionOptions.clusteredIndex and','line_number':1447,'multiline':False]
['text':' KeyFormat::String. For a clustered record store that is not associated with a clustered','line_number':1448,'multiline':False]
['text':' collection KeyFormat::String is sufficient.','line_number':1449,'multiline':False]
['text':' Moves the data file to a temporary name so that a new RecordStore can be created with the','line_number':1511,'multiline':False]
['text':' same ident name. We will delete the new empty collection and rename the data file back so it','line_number':1512,'multiline':False]
['text':' can be salvaged.','line_number':1513,'multiline':False]
['text':'  If the data is unsalvageable, we should completely rebuild the ident.','line_number':1575,'multiline':False]
['text':' Record stores for clustered collections need to guarantee uniqueness by preventing','line_number':1601,'multiline':False]
['text':' overwrites.','line_number':1602,'multiline':False]
['text':' The oplog collection must have a size provided.','line_number':1611,'multiline':False]
['text':' Sizes should always be checked when creating a collection during rollback or replication','line_number':1620,'multiline':False]
['text':' recovery. This is in case the size storer information is no longer accurate. This may be','line_number':1621,'multiline':False]
['text':' necessary if capped deletes are rolled-back, if rollback occurs across a collection rename,','line_number':1622,'multiline':False]
['text':' or when collection creation is not part of a stable checkpoint.','line_number':1623,'multiline':False]
['text':' We don't log writes to temporary record stores.','line_number':1783,'multiline':False]
['text':' Temporary collections do not need to persist size information to the size storer.','line_number':1795,'multiline':False]
['text':' Temporary collections do not need to reconcile collection size/counts.','line_number':1797,'multiline':False]
['text':' We don't log writes to temporary record stores.','line_number':1814,'multiline':False]
['text':' internal table ','line_number':1818,'multiline':True]
['text':' Explicitly disallows metadata change, specifically index data format change, on indexes','line_number':1846,'multiline':False]
['text':' of version 11 and 12. This is extra defensive and can be reconsidered if we expand the','line_number':1847,'multiline':False]
['text':' use of 'alterIdentMetadata()' to also modify non-data-format properties.','line_number':1848,'multiline':False]
['text':' Make the alter call to update metadata without taking exclusive lock to avoid conflicts with','line_number':1857,'multiline':False]
['text':' concurrent operations.','line_number':1858,'multiline':False]
['text':' Use a dedicated session in an alter operation to avoid transaction issues.','line_number':1866,'multiline':False]
['text':' WT may return EBUSY if the database contains dirty data. If we checkpoint and retry the','line_number':1875,'multiline':False]
['text':' operation it will attempt to clean up the dirty elements during checkpointing, thus allowing','line_number':1876,'multiline':False]
['text':' the operation to succeed if it was the only reason to fail.','line_number':1877,'multiline':False]
['text':' Drop requires exclusive access to the table. EBUSY will be returned if there's a','line_number':1899,'multiline':False]
['text':' checkpoint running, there's dirty data pending to be written to disk, there are any open','line_number':1900,'multiline':False]
['text':' cursors on the ident, or the ident is otherwise in use.','line_number':1901,'multiline':False]
['text':' Ident doesn't exist, it is effectively dropped.','line_number':1915,'multiline':False]
['text':' Don't wait for the global checkpoint lock to be obtained in WiredTiger as it can take a','line_number':1926,'multiline':False]
['text':' substantial amount of time to be obtained if there is a concurrent checkpoint running. We','line_number':1927,'multiline':False]
['text':' will wait until we obtain exclusive access to the underlying table file though. As it isn't','line_number':1928,'multiline':False]
['text':' user visible at this stage in the import it should be readily available unless a backup','line_number':1929,'multiline':False]
['text':' cursor is open. In short, using "checkpoint_wait=false" and "lock_wait=true" means that we','line_number':1930,'multiline':False]
['text':' can potentially be waiting for a short period of time for WT_SESSION::drop() to run, but','line_number':1931,'multiline':False]
['text':' would rather get EBUSY than wait a long time for a checkpoint to complete.','line_number':1932,'multiline':False]
['text':' If the ident doesn't exist then it has already been dropped.','line_number':1956,'multiline':False]
['text':' Ephemeral WiredTiger instances cannot do a checkpoint to disk as there is no disk backing','line_number':1981,'multiline':False]
['text':' the data.','line_number':1982,'multiline':False]
['text':' Limits the actions of concurrent checkpoint callers as we update some internal data during a','line_number':1987,'multiline':False]
['text':' checkpoint. WT has a mutex of its own to only have one checkpoint active at all times so this','line_number':1988,'multiline':False]
['text':' is only to protect our internal updates.','line_number':1989,'multiline':False]
['text':' TODO: SERVER-64507: Investigate whether we can smartly rely on one checkpointer if two or','line_number':1990,'multiline':False]
['text':' more threads checkpoint at the same time.','line_number':1991,'multiline':False]
['text':' The amount of oplog to keep is primarily dictated by a user setting. However, in unexpected','line_number':1997,'multiline':False]
['text':' cases, durable, recover to a timestamp storage engines may need to play forward from an oplog','line_number':1998,'multiline':False]
['text':' entry that would otherwise be truncated by the user setting. Furthermore, the entries in','line_number':1999,'multiline':False]
['text':' prepared or large transactions can refer to previous entries in the same transaction.','line_number':2000,'multiline':False]
['text':'','line_number':2001,'multiline':False]
['text':' Live (replication) rollback will replay the oplog from exactly the stable timestamp. With','line_number':2002,'multiline':False]
['text':' prepared or large transactions, it may require some additional entries prior to the stable','line_number':2003,'multiline':False]
['text':' timestamp. These requirements are summarized in getOplogNeededForRollback. Truncating the','line_number':2004,'multiline':False]
['text':' oplog at this point is sufficient for in-memory configurations, but could cause an','line_number':2005,'multiline':False]
['text':' unrecoverable scenario if the node crashed and has to play from the last stable checkpoint.','line_number':2006,'multiline':False]
['text':'','line_number':2007,'multiline':False]
['text':' By recording the oplog needed for rollback "now", then taking a stable checkpoint, we can','line_number':2008,'multiline':False]
['text':' safely assume that the oplog needed for crash recovery has caught up to the recorded value.','line_number':2009,'multiline':False]
['text':' After the checkpoint, this value will be published such that actors which truncate the oplog','line_number':2010,'multiline':False]
['text':' can read an updated value.','line_number':2011,'multiline':False]
['text':' Three cases:','line_number':2013,'multiline':False]
['text':'','line_number':2014,'multiline':False]
['text':' First, initialDataTimestamp is Timestamp(0, 1) -> Take full checkpoint. This is when there is','line_number':2015,'multiline':False]
['text':' no consistent view of the data (e.g: during initial sync).','line_number':2016,'multiline':False]
['text':'','line_number':2017,'multiline':False]
['text':' Second, stableTimestamp < initialDataTimestamp: Skip checkpoints. The data on disk is prone','line_number':2018,'multiline':False]
['text':' to being rolled back. Hold off on checkpoints.  Hope that the stable timestamp surpasses the','line_number':2019,'multiline':False]
['text':' data on disk, allowing storage to persist newer copies to disk.','line_number':2020,'multiline':False]
['text':'','line_number':2021,'multiline':False]
['text':' Third, stableTimestamp >= initialDataTimestamp: Take stable checkpoint. Steady state case.','line_number':2022,'multiline':False]
['text':'useTimestamp=','line_number':2024,'multiline':True]
['text':'useTimestamp=','line_number':2046,'multiline':True]
['text':' Now that the checkpoint is durable, publish the oplog needed to recover from it.','line_number':2049,'multiline':False]
['text':' can't use WiredTigerCursor since this is called from constructor.','line_number':2076,'multiline':False]
['text':' No need for a metadata:create cursor, since it gathers extra information and is slower.','line_number':2078,'multiline':False]
['text':' No need for a metadata:create cursor, since it gathers extra information and is slower.','line_number':2092,'multiline':False]
['text':' Do not set the stable timestamp backward, unless 'force' is set.','line_number':2178,'multiline':False]
['text':' Communicate to WiredTiger what the "stable timestamp" is. Timestamp-aware checkpoints will','line_number':2184,'multiline':False]
['text':' only persist to disk transactions committed with a timestamp earlier than the "stable','line_number':2185,'multiline':False]
['text':' timestamp".','line_number':2186,'multiline':False]
['text':'','line_number':2187,'multiline':False]
['text':' After passing the "stable timestamp" to WiredTiger, communicate it to the','line_number':2188,'multiline':False]
['text':' `CheckpointThread`. It's not obvious a stale stable timestamp in the `CheckpointThread` is','line_number':2189,'multiline':False]
['text':' safe. Consider the following arguments:','line_number':2190,'multiline':False]
['text':'','line_number':2191,'multiline':False]
['text':' Setting the "stable timestamp" is only meaningful when the "initial data timestamp" is real','line_number':2192,'multiline':False]
['text':' (i.e: not `kAllowUnstableCheckpointsSentinel`). In this normal case, the `stableTimestamp`','line_number':2193,'multiline':False]
['text':' input must be greater than the current value. The only effect this can have in the','line_number':2194,'multiline':False]
['text':' `CheckpointThread` is to transition it from a state of not taking any checkpoints, to','line_number':2195,'multiline':False]
['text':' taking "stable checkpoints". In the transitioning case, it's imperative for the "stable','line_number':2196,'multiline':False]
['text':' timestamp" to have first been communicated to WiredTiger.','line_number':2197,'multiline':False]
['text':' After publishing a stable timestamp to WT, we can record the updated stable timestamp value','line_number':2209,'multiline':False]
['text':' for the necessary oplog to keep.','line_number':2210,'multiline':False]
['text':' If 'force' is set, then we have already set the oldest timestamp equal to the stable','line_number':2213,'multiline':False]
['text':' timestamp, so there is nothing left to do.','line_number':2214,'multiline':False]
['text':' Forward the oldest timestamp so that WiredTiger can clean up earlier timestamp data.','line_number':2219,'multiline':False]
['text':' Set the oldest timestamp to the stable timestamp to ensure that there is no lag window','line_number':2226,'multiline':False]
['text':' between the two.','line_number':2227,'multiline':False]
['text':' Calculate what the oldest_timestamp should be from the stable_timestamp. The oldest','line_number':2233,'multiline':False]
['text':' timestamp should lag behind stable by 'minSnapshotHistoryWindowInSeconds' to create a','line_number':2234,'multiline':False]
['text':' window of available snapshots. If the lag window is not yet large enough, we will not','line_number':2235,'multiline':False]
['text':' update/forward the oldest_timestamp yet and instead return early.','line_number':2236,'multiline':False]
['text':' This mutex is not intended to synchronize updates to the oldest timestamp, but to ensure that','line_number':2250,'multiline':False]
['text':' there are no races with pinning the oldest timestamp.','line_number':2251,'multiline':False]
['text':' The oldest timestamp should only be forced backwards during replication recovery in order','line_number':2260,'multiline':False]
['text':' to do rollback via refetch. This refetching process invalidates any timestamped snapshots','line_number':2261,'multiline':False]
['text':' until after it completes. Components that register a pinned timestamp must synchronize','line_number':2262,'multiline':False]
['text':' with events that invalidate their snapshots, unpin themselves and either fail themselves,','line_number':2263,'multiline':False]
['text':' or reacquire a new snapshot after the rollback event.','line_number':2264,'multiline':False]
['text':'','line_number':2265,'multiline':False]
['text':' Forcing the oldest timestamp forward -- potentially past a pin request raises the','line_number':2266,'multiline':False]
['text':' question of whether the pin should be honored. For now we will invariant there is no pin,','line_number':2267,'multiline':False]
['text':' but the invariant can be relaxed if there's a use-case to support.','line_number':2268,'multiline':False]
['text':' set_timestamp above ignores backwards in time if 'force' is not set.','line_number':2286,'multiline':False]
['text':' The oldest_timestamp should lag behind the stable_timestamp by','line_number':2297,'multiline':False]
['text':' 'minSnapshotHistoryWindowInSeconds' seconds.','line_number':2298,'multiline':False]
['text':' No history should be maintained for the inMemory engine because it is not used yet.','line_number':2301,'multiline':False]
['text':' The history window is larger than the timestamp history thus far. We must wait for','line_number':2307,'multiline':False]
['text':' the history to reach the window size before moving oldest_timestamp forward. This should','line_number':2308,'multiline':False]
['text':' only happen in unit tests.','line_number':2309,'multiline':False]
['text':' The stable_timestamp is not far enough ahead of the oldest_timestamp for the','line_number':2318,'multiline':False]
['text':' oldest_timestamp to be moved forward: the window is still too small.','line_number':2319,'multiline':False]
['text':' The oldest timestamp cannot be set behind the `_initialDataTimestamp`.','line_number':2323,'multiline':False]
['text':' Illegal to be called when the dataset is incomplete.','line_number':2355,'multiline':False]
['text':' The rollback_to_stable operation requires all open cursors to be closed or reset before the','line_number':2393,'multiline':False]
['text':' call, otherwise EBUSY will be returned. Occasionally, there could be an operation that hasn't','line_number':2394,'multiline':False]
['text':' been killed yet, such as the CappedInsertNotifier for a yielded oplog getMore. We will retry','line_number':2395,'multiline':False]
['text':' rollback_to_stable until the system quiesces.','line_number':2396,'multiline':False]
['text':' Dump the storage engine's internal state to assist in diagnosis.','line_number':2414,'multiline':False]
['text':' Fetch the latest all_durable value from the storage engine. This value will be a timestamp','line_number':2427,'multiline':False]
['text':' that has no holes (uncommitted transactions with lower timestamps) behind it.','line_number':2428,'multiline':False]
['text':' bytes in hex ','line_number':2429,'multiline':True]
['text':' null terminator ','line_number':2429,'multiline':True]
['text':' If all_durable is 0, treat this as lowest possible timestamp; we need to see all pre-existing','line_number':2435,'multiline':False]
['text':' data but no new (timestamped) data.','line_number':2436,'multiline':False]
['text':' Get the current stable timestamp and use it throughout this function, ignoring updates from','line_number':2476,'multiline':False]
['text':' another thread.','line_number':2477,'multiline':False]
['text':' Only one thread can set or execute this callback.','line_number':2480,'multiline':False]
['text':' The storage engine may have been told to keep oplog back to a certain timestamp.','line_number':2512,'multiline':False]
['text':' If oplog truncation is not allowed, then return the min timestamp so that no history','line_number':2518,'multiline':False]
['text':' is ever allowed to be deleted.','line_number':2519,'multiline':False]
['text':' All the oplog since `_oplogPinnedByBackup` should remain intact during the backup.','line_number':2523,'multiline':False]
['text':' If getOplogNeededForRollback fails, don't truncate any oplog right now.','line_number':2539,'multiline':False]
['text':' If we've moved the pin and are in a `WriteUnitOfWork`, assume the caller has a write that','line_number':2569,'multiline':False]
['text':' should be atomic with this pin request. If the `WriteUnitOfWork` is rolled back, either','line_number':2570,'multiline':False]
['text':' unpin the oldest timestamp or repin the previous value.','line_number':2571,'multiline':False]
['text':' When a write is updating the value from an earlier pin to a later one, use','line_number':2578,'multiline':False]
['text':' rounding to make a best effort to repin the earlier value.','line_number':2579,'multiline':False]
['text':' Halt visibility thread if running on previous record store','line_number':2650,'multiline':False]
['text':' Halt the visibility thread if we're in shutdown or the request matches the current record','line_number':2662,'multiline':False]
['text':' store.','line_number':2663,'multiline':False]
['text':'bytes in hex','line_number':2683,'multiline':True]
['text':'nul terminator','line_number':2683,'multiline':True]
['text':' Skip inMemory storage engine, encryption at rest only applies to storage backed engine.','line_number':2739,'multiline':False]
['text':' Create WiredTiger URIs from the idents.','line_number':2778,'multiline':False]
['text':' namespace mongo','line_number':2805,'multiline':False]
