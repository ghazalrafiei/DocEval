['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' canonical types namespace. (would be enum class CType: uint8_t in C++11)','line_number':83,'multiline':False]
['text':' Note 0-9 and 246-255 are disallowed and reserved for value encodings.','line_number':84,'multiline':False]
['text':' For types that encode value information in the ctype byte, the value in this list is','line_number':85,'multiline':False]
['text':' the "generic" one to be used to represent all values of that ctype, such as in the','line_number':86,'multiline':False]
['text':' encoding of fields in Objects.','line_number':87,'multiline':False]
['text':' These are ordered by the numeric value of the values encoded in each format.','line_number':106,'multiline':False]
['text':' Therefore each format can be considered independently without considering','line_number':107,'multiline':False]
['text':' cross-format comparisons.','line_number':108,'multiline':False]
['text':' <= -2**63 including -Inf','line_number':110,'multiline':False]
['text':' between 0 and -1 exclusive','line_number':119,'multiline':False]
['text':' between 0 and 1 exclusive','line_number':121,'multiline':False]
['text':' >= 2**63 including +Inf','line_number':130,'multiline':False]
['text':' namespace CType','line_number':233,'multiline':False]
['text':' Doubles smaller than this store only a single bit indicating a decimal continuation follows.','line_number':287,'multiline':False]
['text':' Amount to add to exponent of doubles tinier than kTiniestDoubleWith2BitDCM to avoid subnormals.','line_number':290,'multiline':False]
['text':' Amount to multiply tiny doubles to perform a shift of the exponent by','line_number':293,'multiline':False]
['text':' kSmallMagnitudeExponentShift.','line_number':294,'multiline':False]
['text':' Amount to multiply scaled tiny doubles by to recover the unscaled value.','line_number':297,'multiline':False]
['text':' An underestimate of 2**256.','line_number':300,'multiline':False]
['text':' An underestimate of 2**(-256).','line_number':305,'multiline':False]
['text':' First double that isn't an int64.','line_number':311,'multiline':False]
['text':' Integers larger than this may not be representable as doubles.','line_number':314,'multiline':False]
['text':' Factors for scaling a double by powers of 256 to do a logical shift left of x bytes.','line_number':317,'multiline':False]
['text':' 2**0','line_number':318,'multiline':False]
['text':' 2**8','line_number':319,'multiline':False]
['text':' 2**16','line_number':320,'multiline':False]
['text':' 2**24','line_number':321,'multiline':False]
['text':' 2**32','line_number':322,'multiline':False]
['text':' 2**40','line_number':323,'multiline':False]
['text':' 2**48','line_number':324,'multiline':False]
['text':' 2**56','line_number':325,'multiline':False]
['text':' Factors for scaling a double by negative powers of 256 to do a logical shift right of x bytes.','line_number':326,'multiline':False]
['text':' 2**0','line_number':327,'multiline':False]
['text':' 2**(-8)','line_number':328,'multiline':False]
['text':' 2**(-16)','line_number':329,'multiline':False]
['text':' 2**(-24)','line_number':330,'multiline':False]
['text':' 2**(-32)','line_number':331,'multiline':False]
['text':' 2**(-40)','line_number':332,'multiline':False]
['text':' 2**(-48)','line_number':333,'multiline':False]
['text':' 2**(-56)','line_number':334,'multiline':False]
['text':' These overlay with CType or kEnd bytes and therefor must be less/greater than all of','line_number':338,'multiline':False]
['text':' them (and their inverses). They also can't equal 0 or 255 since that would collide with','line_number':339,'multiline':False]
['text':' the encoding of NUL bytes in strings as "\x00\xff".','line_number':340,'multiline':False]
['text':' namespace','line_number':344,'multiline':False]
['text':' some utility functions','line_number':346,'multiline':False]
['text':'*
 * scratch must be empty when passed in. It will be used if there is a NUL byte in the
 * output string. In that case the returned StringData will point into scratch, otherwise
 * it will point directly into the input buffer.
 ','line_number':376,'multiline':True]
['text':' Don't alloc or copy for simple case with no NUL bytes.','line_number':384,'multiline':False]
['text':' Each time we enter this loop it means we hit a NUL byte encoded as "\x00\xFF".','line_number':388,'multiline':False]
['text':' If this isn't our first pass through the loop it means we hit an NUL byte','line_number':419,'multiline':False]
['text':' encoded as "\xFF\00" in our inverted string.','line_number':420,'multiline':False]
['text':' will be flipped to '\0' with rest of out before returning.','line_number':422,'multiline':False]
['text':' namespace','line_number':440,'multiline':False]
['text':' The discriminator forces this KeyString to compare Less/Greater than any KeyString with','line_number':613,'multiline':False]
['text':' the same prefix of keys. As an example, this can be used to land on the first key in the','line_number':614,'multiline':False]
['text':' index with the value "a" regardless of the RecordId. In compound indexes it can use a','line_number':615,'multiline':False]
['text':' prefix of the full key to ignore the later keys.','line_number':616,'multiline':False]
['text':' No discriminator byte.','line_number':625,'multiline':False]
['text':' TODO (SERVER-43178): consider omitting kEnd when using a discriminator byte. It is not a','line_number':628,'multiline':False]
['text':' storage format change since keystrings with discriminators are not allowed to be stored.','line_number':629,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':632,'multiline':False]
['text':' -----------   APPEND CODE  -------------------------------------------','line_number':633,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':634,'multiline':False]
['text':' The RecordId encoding must be able to determine the full length starting from the last','line_number':664,'multiline':False]
['text':' byte, without knowing where the first byte is since it is stored at the end of a','line_number':665,'multiline':False]
['text':' KeyString, and we need to be able to read the RecordId without decoding the whole thing.','line_number':666,'multiline':False]
['text':' This encoding places a number (N) between 0 and 7 in both the high 3 bits of the first','line_number':668,'multiline':False]
['text':' byte and the low 3 bits of the last byte. This is the number of bytes between the first','line_number':669,'multiline':False]
['text':' and last byte (ie total bytes is N + 2). The remaining bits of the first and last bytes','line_number':670,'multiline':False]
['text':' are combined with the bits of the in-between bytes to store the 64-bit RecordId in','line_number':671,'multiline':False]
['text':' big-endian order. This does not encode negative RecordIds to give maximum space to','line_number':672,'multiline':False]
['text':' positive RecordIds which are the only ones that are allowed to be stored in an index.','line_number':673,'multiline':False]
['text':' Note: we encode RecordId::minLong() and RecordId() the same which is ok, as they','line_number':677,'multiline':False]
['text':' are never stored so they will never be compared to each other.','line_number':678,'multiline':False]
['text':' ceil((bitsNeeded - 10) / 8)','line_number':685,'multiline':False]
['text':' extraBytesNeeded must fit in 3 bits.','line_number':687,'multiline':False]
['text':' firstByte combines highest 5 bits of value with extraBytesNeeded.','line_number':690,'multiline':False]
['text':' lastByte combines lowest 5 bits of value with extraBytesNeeded.','line_number':693,'multiline':False]
['text':' RecordIds are never appended inverted.','line_number':696,'multiline':False]
['text':' Only using the low-order extraBytesNeeded bytes of extraBytes.','line_number':700,'multiline':False]
['text':' Append the RecordId binary string as-is, then append the encoded binary string size.','line_number':711,'multiline':False]
['text':' The binary string size is encoded in 7-bit increments over one or more size bytes.','line_number':712,'multiline':False]
['text':' The 8th bit of a size byte is a continuation bit that is set on all size bytes except','line_number':713,'multiline':False]
['text':' the leftmost (i.e. the last) one. This allows decoding the size right-to-left until there are','line_number':714,'multiline':False]
['text':' no more size bytes remaining with continuation bits. See decodeRecordIdStrAtEnd for the','line_number':715,'multiline':False]
['text':' decoding algorithm. This 7-bit size encoding ensures backward compatibility with 5.0, which','line_number':716,'multiline':False]
['text':' supports RecordId binary strings up to 127 bytes, or what fits in 7 bits.','line_number':717,'multiline':False]
['text':' Encode size','line_number':724,'multiline':False]
['text':' Preallocate room for the RecordId binary string and its encoded size','line_number':742,'multiline':False]
['text':' to reduce the number of potential reallocs','line_number':743,'multiline':False]
['text':' Append RecordId and its encoded size','line_number':747,'multiline':False]
['text':' As an optimization, encode AllZeros as a single 0 byte.','line_number':755,'multiline':False]
['text':' see: http://en.wikipedia.org/wiki/Offset_binary','line_number':772,'multiline':False]
['text':' flip highest bit (equivalent to bias encoding)','line_number':774,'multiline':False]
['text':' Symbols and Strings compare equally','line_number':804,'multiline':False]
['text':' size fits in one byte so use one byte to encode.','line_number':825,'multiline':False]
['text':' Encode 0xff prefix to indicate that the size takes 4 bytes.','line_number':828,'multiline':False]
['text':' note: NULL is not allowed in pattern or flags','line_number':839,'multiline':False]
['text':' No generic ctype byte needed here since no name is encoded.','line_number':860,'multiline':False]
['text':' No generic ctype byte needed here since no name is encoded.','line_number':872,'multiline':False]
['text':' Tests are structured such that NaNs and infinities fall through correctly.','line_number':903,'multiline':False]
['text':' This includes subnormal numbers.','line_number':906,'multiline':False]
['text':' We are collapsing -0.0 and 0.0 to the same value here, the type bits disambiguate.','line_number':909,'multiline':False]
['text':' No fractional part','line_number':921,'multiline':False]
['text':' There is a fractional part.','line_number':928,'multiline':False]
['text':' Append the bytes of the mantissa that include fractional bits.','line_number':931,'multiline':False]
['text':' set non-fractional bits to 0;','line_number':937,'multiline':False]
['text':' Multiplying the double by 256 to the power X is logically equivalent to shifting the','line_number':950,'multiline':False]
['text':' fraction left by X bytes.','line_number':951,'multiline':False]
['text':' Merge in the bit indicating the value has a fractional part by doubling the integer','line_number':955,'multiline':False]
['text':' part and adding 1. This leaves encoding with the high 8-fractionalBytes bytes in the','line_number':956,'multiline':False]
['text':' same form they'd have with _appendPreshiftedIntegerPortion(). The remaining low bytes','line_number':957,'multiline':False]
['text':' are the fractional bytes left-shifted by 2 bits to make room for the DCM.','line_number':958,'multiline':False]
['text':' Easy case: the decimal actually is a double. True for many integers, fractions like 1.5, etc.','line_number':1019,'multiline':False]
['text':' Values smaller than the double normalized range need special handling: a regular double','line_number':1026,'multiline':False]
['text':' wouldn't give 15 digits, if any at all.','line_number':1027,'multiline':False]
['text':' Huge finite values are encoded directly. Because the value is not exact, and truncates','line_number':1034,'multiline':False]
['text':' to the maximum double, the original decimal was outside of the range of finite doubles.','line_number':1035,'multiline':False]
['text':' Because all decimals larger than the max finite double round down to that value, strict','line_number':1036,'multiline':False]
['text':' less-than would be incorrect.','line_number':1037,'multiline':False]
['text':' Exact in both double and int64_t.','line_number':1045,'multiline':False]
['text':' If the conditions below fall through, a decimal continuation is needed to represent the','line_number':1047,'multiline':False]
['text':' difference between the stored value and the actual decimal. All paths that fall through','line_number':1048,'multiline':False]
['text':' must set 'storedValue', overwriting the NaN.','line_number':1049,'multiline':False]
['text':' Large finite decimals that are not exactly equal to a double require a decimal','line_number':1053,'multiline':False]
['text':' continuation, even if they only have 15 significant digits, as there only is a single bit','line_number':1054,'multiline':False]
['text':' for the DCM.','line_number':1055,'multiline':False]
['text':' Small finite decimals not exactly equal to a double similarly require a decimal','line_number':1060,'multiline':False]
['text':' continuation if they're small enough to only have a single bit for the DCM.','line_number':1061,'multiline':False]
['text':' For doubles in this range, 'bin' may have lost precision in the integer part, which would','line_number':1066,'multiline':False]
['text':' lead to miscompares with integers. So, instead handle explicitly.','line_number':1067,'multiline':False]
['text':' A Fraction byte follows, but the leading 7 bytes already encode 53 bits of the','line_number':1084,'multiline':False]
['text':' coefficient, so just store the DCM.','line_number':1085,'multiline':False]
['text':' Common case: the coefficient less than 1E15, so at most 15 digits, and the number is','line_number':1093,'multiline':False]
['text':' in the range of double where we have 2 spare bits for the DCM, so the decimal can be','line_number':1094,'multiline':False]
['text':' represented with at least 15 digits of precision by the double 'bin'.','line_number':1095,'multiline':False]
['text':' The coefficient has more digits, but may still be 15 digits after removing trailing','line_number':1101,'multiline':False]
['text':' zeros.','line_number':1102,'multiline':False]
['text':' Harder cases: decimal continuation is needed.','line_number':1108,'multiline':False]
['text':' First store the double and kind of continuation needed.','line_number':1109,'multiline':False]
['text':' Note that 'dec' and 'bin' can be negative.','line_number':1115,'multiline':False]
['text':' Should have been set explicitly.','line_number':1118,'multiline':False]
['text':' Normalize to 34 digits to fix decDiff exponent.','line_number':1119,'multiline':False]
['text':' Now we know that we can recover the original decimal value (but not its precision, which is','line_number':1126,'multiline':False]
['text':' given by the type bits) from the binary double plus the decimal continuation.','line_number':1127,'multiline':False]
['text':' + 1 for NUL','line_number':1143,'multiline':False]
['text':'/ -- lowest level','line_number':1229,'multiline':False]
['text':' No NULs in string.','line_number':1235,'multiline':False]
['text':' replace "\x00" with "\x00\xFF"','line_number':1242,'multiline':False]
['text':' skip over the NUL byte','line_number':1244,'multiline':False]
['text':' Force the order to be based on (ctype, name, value).','line_number':1253,'multiline':False]
['text':' Not using magnitude to preserve sign bit in V0','line_number':1276,'multiline':False]
['text':' Values in the range [2**(-255), 1) get the prefix 0b11','line_number':1279,'multiline':False]
['text':' only single DCM bit here','line_number':1286,'multiline':False]
['text':' Values in the range [numeric_limits<double>::denorm_min(), 2**(-255)) get the prefixes','line_number':1287,'multiline':False]
['text':' 0b01 or 0b10. The 0b00 prefix is used by _appendHugeDecimalWithoutTypeBits for decimals','line_number':1288,'multiline':False]
['text':' smaller than that.','line_number':1289,'multiline':False]
['text':' Change the two most significant bits from 0b00 or 0b01 to 0b01 or 0b10.','line_number':1294,'multiline':False]
['text':' only single DCM bit here','line_number':1308,'multiline':False]
['text':' infinity','line_number':1323,'multiline':False]
['text':' This function is only for 'dec' that doesn't exactly equal a double, but rounds to 'bin'','line_number':1334,'multiline':False]
['text':' For decimals smaller than the smallest subnormal double, just store the decimal number','line_number':1344,'multiline':False]
['text':' Encode decimal in subnormal double range by scaling in the decimal domain. Round down at','line_number':1354,'multiline':False]
['text':' each step, but ensure not to get below the subnormal double. This will ensure that','line_number':1355,'multiline':False]
['text':' 'scaledBin' is monotonically increasing and will only be off by at most a few units in the','line_number':1356,'multiline':False]
['text':' last place, so the decimal continuation will stay in range.','line_number':1357,'multiline':False]
['text':' Here we know that scaledBin contains the first 15 significant digits of scaled dec, and','line_number':1362,'multiline':False]
['text':' sorts correctly with scaled double.','line_number':1363,'multiline':False]
['text':' Even if decDiff.isZero() we aren't exactly equal','line_number':1368,'multiline':False]
['text':' Round down, so it is certain that in all cases a non-negative continuation can be found.','line_number':1373,'multiline':False]
['text':' To allow us to use CType::kNumericNegativeLargeMagnitude we need to fit between the highest','line_number':1390,'multiline':False]
['text':' finite double and the representation of +/-Inf. We do this by forcing the high bit to 1','line_number':1391,'multiline':False]
['text':' (large doubles always have 0) and never encoding ~0 here.','line_number':1392,'multiline':False]
['text':' Handles NumberLong and NumberInt which are encoded identically except for the TypeBits.','line_number':1407,'multiline':False]
['text':' -2**63 is exactly representable as a double and not as a positive int64.','line_number':1411,'multiline':False]
['text':' Therefore we encode it as a double.','line_number':1412,'multiline':False]
['text':' Append the low bytes of value in big endian order.','line_number':1437,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':1463,'multiline':False]
['text':' ----------- DECODING CODE --------------------------------------------','line_number':1464,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':1465,'multiline':False]
['text':'*
 * Helper function to read the least significant type bits for 'num' and return a value that
 * is numerically equal to 'num', but has its exponent adjusted to match the stored exponent bits.
 ','line_number':1508,'multiline':True]
['text':'*
 * Helper function that takes a 'num' with 15 decimal digits of precision, normalizes it to 34
 * digits and reads a 64-bit (19-digit) continuation to obtain the full 34-bit value.
 ','line_number':1514,'multiline':True]
['text':' This is only used by the kNumeric.*ByteInt types, but needs to be declared up here','line_number':1545,'multiline':False]
['text':' since it is used across a fallthrough.','line_number':1546,'multiline':False]
['text':' will point to either scratch or the raw encoded bytes.','line_number':1627,'multiline':False]
['text':' Not going to optimize CodeWScope, but limit stack space usage due to recursion.','line_number':1634,'multiline':False]
['text':' BSON validation counts a CodeWithScope as two nesting levels, so match that.','line_number':1636,'multiline':False]
['text':' size was stored in 4 bytes.','line_number':1645,'multiline':False]
['text':'','line_number':1713,'multiline':False]
['text':' Numerics','line_number':1714,'multiline':False]
['text':'','line_number':1715,'multiline':False]
['text':' format is the same as positive, but inverted','line_number':1763,'multiline':False]
['text':' Backward compatibility','line_number':1774,'multiline':False]
['text':' In range of (finite) doubles','line_number':1777,'multiline':False]
['text':' remove decimal continuation marker','line_number':1779,'multiline':False]
['text':' implied leading exponent bit','line_number':1780,'multiline':False]
['text':' infinity','line_number':1784,'multiline':False]
['text':' Huge decimal number, directly output','line_number':1787,'multiline':False]
['text':' 'bin' contains the value of the input, rounded toward zero in case of decimal','line_number':1802,'multiline':False]
['text':' This can only happen for a single number.','line_number':1806,'multiline':False]
['text':' format is the same as positive, but inverted','line_number':1830,'multiline':False]
['text':' for these, the raw double was stored intact, including sign bit.','line_number':1838,'multiline':False]
['text':' Teeny tiny decimal, smaller magnitude than 2**(-1074)','line_number':1850,'multiline':False]
['text':' Tiny double or decimal, magnitude from 2**(-1074) to 2**(-255), exclusive.','line_number':1862,'multiline':False]
['text':' The exponent is shifted by 256 in order to avoid subnormals, which would','line_number':1863,'multiline':False]
['text':' result in less than 15 significant digits. Because 2**(-255) has 179','line_number':1864,'multiline':False]
['text':' decimal digits, no doubles exactly equal decimals, so all decimals have','line_number':1865,'multiline':False]
['text':' a continuation. The bit is still needed for comparison purposes.','line_number':1866,'multiline':False]
['text':' If the actual double would be subnormal, scale in decimal domain.','line_number':1883,'multiline':False]
['text':' For subnormals, we rounded down everywhere, to ensure that the','line_number':1887,'multiline':False]
['text':' continuation will always be positive. Needs to be done consistently in','line_number':1888,'multiline':False]
['text':' encoding/decoding (see storedVal in _appendTinyDecimalWithoutTypeBits).','line_number':1889,'multiline':False]
['text':' Small double, 2**(-255) or more in magnitude. Common case.','line_number':1906,'multiline':False]
['text':' Deal with decimal cases','line_number':1918,'multiline':False]
['text':' Deal with decimal continuation','line_number':1936,'multiline':False]
['text':' format is the same as positive, but inverted','line_number':1961,'multiline':False]
['text':' KeyString V0: anything fractional is a double','line_number':2008,'multiline':False]
['text':' build up the bits of a double here.','line_number':2021,'multiline':False]
['text':' clear implicit leading 1','line_number':2023,'multiline':False]
['text':'bias','line_number':2024,'multiline':True]
['text':' sign bit','line_number':2026,'multiline':False]
['text':' fold in the fractional bytes','line_number':2029,'multiline':False]
['text':' KeyString V1: all numeric values with fractions have at least 8 bytes.','line_number':2040,'multiline':False]
['text':' Start with integer part, and read until we have a full 8 bytes worth of data.','line_number':2041,'multiline':False]
['text':' Zero out the DCM and convert the whole binary fraction','line_number':2048,'multiline':False]
['text':' The two lsb's are the DCM, except for the 8-byte case, where it's already known','line_number':2055,'multiline':False]
['text':' Deal with decimal cases','line_number':2060,'multiline':False]
['text':' Deal with decimal continuation','line_number':2073,'multiline':False]
['text':' Not going to optimize CodeWScope.','line_number':2139,'multiline':False]
['text':' size was stored in 4 bytes.','line_number':2147,'multiline':False]
['text':' Read the subtype of BinData','line_number':2150,'multiline':False]
['text':' Advance by size of BinData','line_number':2152,'multiline':False]
['text':' Read the pattern','line_number':2159,'multiline':False]
['text':' Read flags','line_number':2161,'multiline':False]
['text':' Read the pattern','line_number':2164,'multiline':False]
['text':' Read flags','line_number':2166,'multiline':False]
['text':'','line_number':2191,'multiline':False]
['text':' Numerics','line_number':2192,'multiline':False]
['text':'','line_number':2193,'multiline':False]
['text':' format is the same as positive, but inverted','line_number':2205,'multiline':False]
['text':' Backward compatibility or infinity','line_number':2211,'multiline':False]
['text':' In range of (finite) doubles','line_number':2214,'multiline':False]
['text':' Huge decimal number, get the low bits','line_number':2216,'multiline':False]
['text':' It should be of type kDecimal','line_number':2217,'multiline':False]
['text':' format is the same as positive, but inverted','line_number':2230,'multiline':False]
['text':' Teeny tiny decimal, smaller magnitude than 2**(-1074)','line_number':2242,'multiline':False]
['text':' Tiny double or decimal, magnitude from 2**(-1074) to 2**(-255), exclusive.','line_number':2248,'multiline':False]
['text':' The exponent is shifted by 256 in order to avoid subnormals, which would','line_number':2249,'multiline':False]
['text':' result in less than 15 significant digits. Because 2**(-255) has 179','line_number':2250,'multiline':False]
['text':' decimal digits, no doubles exactly equal decimals, so all decimals have','line_number':2251,'multiline':False]
['text':' a continuation.','line_number':2252,'multiline':False]
['text':' Small double, 2**(-255) or more in magnitude. Common case.','line_number':2261,'multiline':False]
['text':' Deal with decimal cases','line_number':2264,'multiline':False]
['text':' Deal with decimal continuation','line_number':2271,'multiline':False]
['text':' format is the same as positive, but inverted','line_number':2291,'multiline':False]
['text':' KeyString V0: anything fractional is a double','line_number':2317,'multiline':False]
['text':' fold in the fractional bytes','line_number':2324,'multiline':False]
['text':' KeyString V1: all numeric values with fractions have at least 8 bytes.','line_number':2330,'multiline':False]
['text':' Start with integer part, and read until we have a full 8 bytes worth of data.','line_number':2331,'multiline':False]
['text':' The two lsb's are the DCM, except for the 8-byte case, where it's already known','line_number':2338,'multiline':False]
['text':' Deal with decimal cases','line_number':2343,'multiline':False]
['text':' Deal with decimal continuation','line_number':2349,'multiline':False]
['text':' The last 6 bits of the exponent are stored in the type bits. First figure out if the exponent','line_number':2360,'multiline':False]
['text':' of 'num' is too high or too low. Even for a non-zero number with only a single significant','line_number':2361,'multiline':False]
['text':' digit, there are only 34 possiblities while exponents with the given low 6 bits are spaced','line_number':2362,'multiline':False]
['text':' (1 << 6) == 64 apart. This is not quite enough to figure out whether to shift the expnent up','line_number':2363,'multiline':False]
['text':' or down when the difference is for example 32 in either direction. However, if the high part','line_number':2364,'multiline':False]
['text':' of the coefficient is zero, the coefficient can only be scaled down by up to 1E19 (increasing','line_number':2365,'multiline':False]
['text':' the exponent by 19), as 2**64 < 1E20. If scaling down to match the higher exponent isn't','line_number':2366,'multiline':False]
['text':' possible, we must be able to scale up. Scaling always must be exact and not change the value.','line_number':2367,'multiline':False]
['text':' Start by determining an exponent that's not less than num's and matches the stored bits.','line_number':2376,'multiline':False]
['text':' This must be the right exponent, as no scaling is required.','line_number':2380,'multiline':False]
['text':' For increasing the exponent, quantize the existing number. This must be','line_number':2384,'multiline':False]
['text':' exact, as the value stays in the same cohort.','line_number':2385,'multiline':False]
['text':' Increase exponent and decrease (right shift) coefficient.','line_number':2389,'multiline':False]
['text':' must be exact','line_number':2397,'multiline':False]
['text':' Decrease exponent and increase (left shift) coefficient.','line_number':2400,'multiline':False]
['text':' namespace','line_number':2414,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':2416,'multiline':False]
['text':'  --------- MISC class utils --------','line_number':2417,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':2418,'multiline':False]
['text':' Case 2: all bits in one byte; no size byte.','line_number':2447,'multiline':False]
['text':' Skip the indicator byte.','line_number':2452,'multiline':False]
['text':' Case 3: <= 127 bytes; use one size byte.','line_number':2455,'multiline':False]
['text':' Case 4: > 127 bytes; needs 4 size bytes.','line_number':2460,'multiline':False]
['text':' The next 4 bytes represent the size in little endian order.','line_number':2462,'multiline':False]
['text':' Case 1: all zeros.','line_number':2468,'multiline':False]
['text':' Grow the data buffer if needed.','line_number':2475,'multiline':False]
['text':' This means AllZeros state was encoded as an empty buffer.','line_number':2494,'multiline':False]
['text':' zeros bits 1-7','line_number':2514,'multiline':False]
['text':' 2-bit encodings','line_number':2524,'multiline':False]
['text':' fallthrough for 5-bit encodings','line_number':2538,'multiline':False]
['text':' first two bits output are ones','line_number':2545,'multiline':False]
['text':' For keyString v1, negative and decimal zeros require at least 3 more bits.','line_number':2593,'multiline':False]
['text':' We have already read the Key.','line_number':2682,'multiline':False]
['text':' Read the Key that comes after the first byte in KeyString.','line_number':2686,'multiline':False]
['text':' Key size = buffer len - number of bytes comprising the RecordId','line_number':2691,'multiline':False]
['text':' This discriminator byte only exists in KeyStrings for queries, not in KeyStrings stored in an','line_number':2695,'multiline':False]
['text':' index.','line_number':2696,'multiline':False]
['text':' Invert it back if discriminator byte got mistakenly inverted.','line_number':2707,'multiline':False]
['text':' This was just a discriminator which is logically part of the previous field. This','line_number':2732,'multiline':False]
['text':' will only be encountered on queries, not in the keys stored in an index.','line_number':2733,'multiline':False]
['text':' Note: this should probably affect the BSON key name of the last field, but it','line_number':2734,'multiline':False]
['text':' must be read *after* the value so it isn't possible.','line_number':2735,'multiline':False]
['text':' smallest possible encoding of a RecordId.','line_number':2763,'multiline':False]
['text':' stored in low 3 bits.','line_number':2765,'multiline':False]
['text':' smallest possible encoding of a RecordId.','line_number':2776,'multiline':False]
['text':' stored in low 3 bits.','line_number':2779,'multiline':False]
['text':' See decodeRecordIdStrAtEnd for the size decoding algorithm','line_number':2785,'multiline':False]
['text':' Decode RecordId binary string size','line_number':2789,'multiline':False]
['text':' Continuation bytes','line_number':2793,'multiline':False]
['text':' non-cont bytes ','line_number':2796,'multiline':True]
['text':' Last (non-continuation) byte','line_number':2800,'multiline':False]
['text':' high 3 bits in firstByte','line_number':2817,'multiline':False]
['text':' low 5 bits in firstByte','line_number':2818,'multiline':False]
['text':' fold in high 5 bits of last byte','line_number':2830,'multiline':False]
['text':' See _appendRecordIdStr for the encoding scheme.','line_number':2835,'multiline':False]
['text':' The RecordId binary string size is decoded right-to-left, up to the size byte','line_number':2836,'multiline':False]
['text':' without continuation bit.','line_number':2837,'multiline':False]
['text':' Decode RecordId binary string size','line_number':2842,'multiline':False]
['text':' Continuation bytes','line_number':2846,'multiline':False]
['text':' non-cont byte ','line_number':2852,'multiline':True]
['text':' Last (non-continuation) byte','line_number':2859,'multiline':False]
['text':' memcmp has undefined behavior if either leftBuf or rightBuf is a null pointer.','line_number':2885,'multiline':False]
['text':' keys match','line_number':2901,'multiline':False]
['text':' This function is only intended to read stored index entries. The 'kLess' and 'kGreater'','line_number':2924,'multiline':False]
['text':' "discriminator" types are used for querying and are never stored in an index.','line_number':2925,'multiline':False]
['text':' This function only gets called for a top-level key_string::Value.','line_number':2928,'multiline':False]
['text':' This function only gets called for a top-level key_string::Value.','line_number':2942,'multiline':False]
['text':' Callers discard their TypeBits.','line_number':2943,'multiline':False]
['text':' This function only gets called for a top-level key_string::Value.','line_number':2959,'multiline':False]
['text':' All users of this currently discard type bits.','line_number':2961,'multiline':False]
['text':' Serialize size of KeyString','line_number':2972,'multiline':False]
['text':' Serialize KeyString','line_number':2973,'multiline':False]
['text':' Serialize TypeBits','line_number':2974,'multiline':False]
['text':' Serialize size of KeyString','line_number':2981,'multiline':False]
['text':' Serialize KeyString','line_number':2982,'multiline':False]
['text':' Serialize TypeBits','line_number':2983,'multiline':False]
['text':' We need to rehydrate the keyString to something readable.','line_number':3001,'multiline':False]
['text':' Wildcard index documents can have more values in the keystring.','line_number':3021,'multiline':False]
['text':' invert ','line_number':3042,'multiline':True]
['text':' namespace key_string','line_number':3109,'multiline':False]
['text':' namespace mongo','line_number':3111,'multiline':False]
