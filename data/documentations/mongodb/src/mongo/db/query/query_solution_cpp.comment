['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' Create an ordred interval list which represents the bounds for all BSON elements of type String,','line_number':83,'multiline':False]
['text':' Object, or Array.','line_number':84,'multiline':False]
['text':' Helper for 'getAllSecondaryNamespaces' that deduplicates namespaces.','line_number':124,'multiline':False]
['text':' namespace','line_number':143,'multiline':False]
['text':' Remove all the fields that are present in '_ignoredFields' from the sort pattern object','line_number':148,'multiline':False]
['text':' since they do not contribute to changing the output order.','line_number':149,'multiline':False]
['text':' static','line_number':168,'multiline':False]
['text':' Nothing to do for a trivial extension.','line_number':331,'multiline':False]
['text':' At the moment, we only extend a solution plan with a tree for $group stage(s), which have','line_number':342,'multiline':False]
['text':' exactly one child. We'll replace the left-most branch descent with a full tree traversal,','line_number':343,'multiline':False]
['text':' if/when it becomes necessary.','line_number':344,'multiline':False]
['text':'','line_number':379,'multiline':False]
['text':' CollectionScanNode','line_number':380,'multiline':False]
['text':'','line_number':381,'multiline':False]
['text':' If we are scanning the collection in the descending direction, we provide the reverse','line_number':389,'multiline':False]
['text':' sort order.','line_number':390,'multiline':False]
['text':'','line_number':427,'multiline':False]
['text':' VirtualScanNode','line_number':428,'multiline':False]
['text':'','line_number':429,'multiline':False]
['text':'','line_number':460,'multiline':False]
['text':' AndHashNode','line_number':461,'multiline':False]
['text':'','line_number':462,'multiline':False]
['text':' Any WSM output from this stage came from all children stages.  If any child provides','line_number':484,'multiline':False]
['text':' fetched data, we merge that fetched data into the WSM we output.','line_number':485,'multiline':False]
['text':' A field can be provided by any of the children.','line_number':495,'multiline':False]
['text':'','line_number':509,'multiline':False]
['text':' AndSortedNode','line_number':510,'multiline':False]
['text':'','line_number':511,'multiline':False]
['text':' Any WSM output from this stage came from all children stages.  If any child provides','line_number':529,'multiline':False]
['text':' fetched data, we merge that fetched data into the WSM we output.','line_number':530,'multiline':False]
['text':' A field can be provided by any of the children.','line_number':540,'multiline':False]
['text':'','line_number':554,'multiline':False]
['text':' OrNode','line_number':555,'multiline':False]
['text':'','line_number':556,'multiline':False]
['text':' Any WSM output from this stage came exactly one child stage.  Given that we don't know','line_number':579,'multiline':False]
['text':' what child stage it came from, we require that all children provide fetched data in order','line_number':580,'multiline':False]
['text':' to guarantee that our output is fetched.','line_number':581,'multiline':False]
['text':'*
 * Any WSM output from this stage came from exactly one child stage.  Therefore, if
 * we want to guarantee that any output has a certain field, all of our children must
 * have that field.
 ','line_number':590,'multiline':True]
['text':'','line_number':612,'multiline':False]
['text':' MergeSortNode','line_number':613,'multiline':False]
['text':'','line_number':614,'multiline':False]
['text':' Any WSM output from this stage came exactly one child stage.  Given that we don't know','line_number':637,'multiline':False]
['text':' what child stage it came from, we require that all children provide fetched data in order','line_number':638,'multiline':False]
['text':' to guarantee that our output is fetched.','line_number':639,'multiline':False]
['text':'*
 * Any WSM output from this stage came from exactly one child stage.  Therefore, if
 * we want to guarantee that any output has a certain field, all of our children must
 * have that field.
 ','line_number':648,'multiline':True]
['text':'','line_number':671,'multiline':False]
['text':' FetchNode','line_number':672,'multiline':False]
['text':'','line_number':673,'multiline':False]
['text':'','line_number':697,'multiline':False]
['text':' IndexScanNode','line_number':698,'multiline':False]
['text':'','line_number':699,'multiline':False]
['text':' A $** index whose bounds overlap the object type bracket cannot provide covering, since the','line_number':739,'multiline':False]
['text':' index only contains the leaf nodes along each of the object's subpaths.','line_number':740,'multiline':False]
['text':' The index is multikey but does not have any path-level multikeyness information. Such indexes','line_number':745,'multiline':False]
['text':' can never provide covering.','line_number':746,'multiline':False]
['text':' Compound hashed indexes can be covered when the projection is not on the hashed field. Other','line_number':751,'multiline':False]
['text':' custom index access methods may return non-exact key data - this function is currently used','line_number':752,'multiline':False]
['text':' for covering exact key data only.','line_number':753,'multiline':False]
['text':' All other index types provide no fields.','line_number':760,'multiline':False]
['text':' If the index and the query collator are the same and the field is in the index we can use it','line_number':764,'multiline':False]
['text':' for sorting and search.','line_number':765,'multiline':False]
['text':' If the index has a non-simple collation and we have collation keys inside 'field', then this','line_number':772,'multiline':False]
['text':' index scan does not provide that field (and the query cannot be covered).','line_number':773,'multiline':False]
['text':' For $** indexes, the keyPattern is prefixed by a virtual field, '$_path'. We therefore','line_number':782,'multiline':False]
['text':' skip the first keyPattern field when deciding whether we can provide the requested field.','line_number':783,'multiline':False]
['text':' The index can provide this field if the requested path appears in the index key pattern,','line_number':793,'multiline':False]
['text':' and that path has no multikey components. We can't cover a field that has multikey','line_number':794,'multiline':False]
['text':' components because the index keys contain individual array elements, and we can't','line_number':795,'multiline':False]
['text':' reconstitute the array from the index keys in the right order. In order for the field to','line_number':796,'multiline':False]
['text':' be fully provided by the scan, it must be ascending (1) or descending (-1).','line_number':797,'multiline':False]
['text':' We already know that the index is either ascending, descending or hashed. If the','line_number':800,'multiline':False]
['text':' field is hashed, we only provide hashed value.','line_number':801,'multiline':False]
['text':' Indices use RecordId as an additional key after the actual index key.','line_number':811,'multiline':False]
['text':' Therefore, if we're only examining one index key, the output is sorted','line_number':812,'multiline':False]
['text':' by RecordId.','line_number':813,'multiline':False]
['text':' If it's a simple range query, it's easy to determine if the range is a point.','line_number':815,'multiline':False]
['text':' If it's a more complex bounds query, we make sure that each field is a point.','line_number':820,'multiline':False]
['text':' static','line_number':835,'multiline':False]
['text':' Produce a copy of the bounds which are all ascending, as we can only compute intersections','line_number':838,'multiline':False]
['text':' of ascending bounds.','line_number':839,'multiline':False]
['text':' With a simple range, the only cases we can say for sure do not contain strings','line_number':845,'multiline':False]
['text':' are those with point bounds.','line_number':846,'multiline':False]
['text':' If the first non-point range cannot contain strings, we don't need to','line_number':859,'multiline':False]
['text':' add it to the return set.','line_number':860,'multiline':False]
['text':' Any remaining keys could have strings.','line_number':864,'multiline':False]
['text':'*
 * Returns true if the index scan described by 'multikeyFields' and 'bounds' can legally provide the
 * 'sortPatternComponent' field, or false if the sort cannot be provided. A multikey index cannot
 * provide a sort if either of the following is true: 1) the sort spec includes a multikey field
 * that has bounds other than [minKey, maxKey], 2) there are bounds other than [minKey, maxKey] over
 * a multikey field which share a path prefix with a component of the sort pattern. These cases are
 * further explained in SERVER-31898.
 ','line_number':907,'multiline':True]
['text':' Forwardize the bounds to correctly apply checks to descending sorts and well as ascending','line_number':919,'multiline':False]
['text':' sorts.','line_number':920,'multiline':False]
['text':' If this component of the sort pattern (which must be one of the components of','line_number':924,'multiline':False]
['text':' the index spec) is not multikey, we don't need additional checks.','line_number':925,'multiline':False]
['text':' Return false if the bounds are specified as a simple range. As a future improvement, we could','line_number':929,'multiline':False]
['text':' extend this optimization to allow simple multikey scans to provide a sort.','line_number':930,'multiline':False]
['text':' Checks if the 'sortPatternComponent' has [MinKey, MaxKey].','line_number':935,'multiline':False]
['text':' Checks if there is a shared path prefix between the bounds and the sort pattern of','line_number':942,'multiline':False]
['text':' multikey fields.','line_number':943,'multiline':False]
['text':' Ignores the prefix if the bounds are [MinKey, MaxKey] or if the field is not','line_number':946,'multiline':False]
['text':' multikey.','line_number':947,'multiline':False]
['text':' The interval list name and the sort pattern name will never be equal at this point.','line_number':954,'multiline':False]
['text':' This is because if they are equal and do not have [minKey, maxKey] bounds, we would','line_number':955,'multiline':False]
['text':' already have bailed out of the function. If they do have [minKey, maxKey] bounds,','line_number':956,'multiline':False]
['text':' they will be skipped in the check for [minKey, maxKey] bounds above.','line_number':957,'multiline':False]
['text':' Checks if there's a common prefix between the interval list name and the sort pattern','line_number':959,'multiline':False]
['text':' name.','line_number':960,'multiline':False]
['text':' Find all equality predicate fields.','line_number':974,'multiline':False]
['text':' Figure out how many fields are point intervals.','line_number':976,'multiline':False]
['text':' If we have an IET for this field in our index bounds, we determine whether it','line_number':987,'multiline':False]
['text':' guarantees that, upon evaluation, we will have point bounds for the corresponding','line_number':988,'multiline':False]
['text':' field in our index. In particular, if the IET evaluates to a ConstNode, an equality','line_number':989,'multiline':False]
['text':' EvalNode, or an ExplodeNode, then this field represents an equality.','line_number':990,'multiline':False]
['text':' If we have 'constNodePtr', it must be the case that the interval that it','line_number':996,'multiline':False]
['text':' contains is the same as 'ival'.','line_number':997,'multiline':False]
['text':'*
 * Returns a 'ProvidedSortSet' with the sort orders provided by an index scan over 'index',
 * with the given 'bounds' and 'direction'.
 ','line_number':1044,'multiline':True]
['text':' If 'index' is the result of expanding a wildcard index, then its key pattern should look like','line_number':1056,'multiline':False]
['text':' {$_path: 1, <field>: 1}. The "$_path" prefix stores the value of the path associated with the','line_number':1057,'multiline':False]
['text':' key as opposed to real user data. We shouldn't report any sort orders including "$_path". In','line_number':1058,'multiline':False]
['text':' fact, $-prefixed path components are illegal in queries in most contexts, so misinterpreting','line_number':1059,'multiline':False]
['text':' this as a path in user-data could trigger subsequent assertions.','line_number':1060,'multiline':False]
['text':'','line_number':1061,'multiline':False]
['text':' An expanded compound wildcard index can be used to answer queries on non-wildcard prefix','line_number':1062,'multiline':False]
['text':' fields, in this case, the wildcard field is unknown. This expanded IndexEntry holds a key','line_number':1063,'multiline':False]
['text':' pattern with the wildcard field being the reserved path, "$_path". All following regular','line_number':1064,'multiline':False]
['text':' fields should not support any sort operation, therefore, we should strip all fields starting','line_number':1065,'multiline':False]
['text':' from the first "$_path" field.','line_number':1066,'multiline':False]
['text':' Strip '$_path' and following fields out of 'sortPattern' and then proceed with regular','line_number':1073,'multiline':False]
['text':' sort analysis.','line_number':1074,'multiline':False]
['text':' (Ignore FCV check): This is intentional because we want clusters which have wildcard','line_number':1075,'multiline':False]
['text':' indexes still be able to use the feature even if the FCV is downgraded.','line_number':1076,'multiline':False]
['text':' No sorts on the following fields should be provided if it's full scan on the','line_number':1084,'multiline':False]
['text':' '$_path' field or the bounds for '$_path' consist of multiple intervals. This','line_number':1085,'multiline':False]
['text':' can happen for existence queries. For example, {a: {$exists: true}} results','line_number':1086,'multiline':False]
['text':' in bounds [["a","a"], ["a.", "a/")] for '$_path' so that keys from documents','line_number':1087,'multiline':False]
['text':' where "a" is a nested object are in bounds.','line_number':1088,'multiline':False]
['text':'','line_number':1102,'multiline':False]
['text':' There are two buckets of field names "equality fields" and "unsupported fields". The','line_number':1103,'multiline':False]
['text':' "equality fields" are those over which we have an equality predicate. These fields can','line_number':1104,'multiline':False]
['text':' optionally be ignored when checking whether a pattern is provided or not. The "unsupported','line_number':1105,'multiline':False]
['text':' fields" are fields for which we cannot provide a sort. Currently we cannot provide sort when','line_number':1106,'multiline':False]
['text':' the field is collated or multikey.','line_number':1107,'multiline':False]
['text':'','line_number':1108,'multiline':False]
['text':' The intersection of the "equality fields" and "unsupported fields" (called 'ignoreFields')','line_number':1109,'multiline':False]
['text':' can simply be ignored. The index scan does not provide these fields in sorted order (e.g.','line_number':1110,'multiline':False]
['text':' because of a mismatched collation), but due to the point bounds in the index scan, this','line_number':1111,'multiline':False]
['text':' doesn't affect our ability to provide a sort on any subsequent fields. Fields in this','line_number':1112,'multiline':False]
['text':' intersection set can simply be dropped when constructing the "base sort pattern".','line_number':1113,'multiline':False]
['text':'','line_number':1114,'multiline':False]
['text':' The remaining are 'unsupportedFields', which we get when we do a set subtraction of','line_number':1115,'multiline':False]
['text':' the initial "unsupported fields" minus 'ignoreFields'. The index scan will never provide a','line_number':1116,'multiline':False]
['text':' sort order on this field or any subsequent fields. When we encounter such a field in the','line_number':1117,'multiline':False]
['text':' index key pattern, we truncate it and any later fields to form the "base sort pattern".','line_number':1118,'multiline':False]
['text':'','line_number':1119,'multiline':False]
['text':' When dealing with autoparameterization (that is, when 'iets' is non-empty), the requirement','line_number':1120,'multiline':False]
['text':' for a field to be considered an equality field is stricter. In particular, we must be able to','line_number':1121,'multiline':False]
['text':' prove that the index bounds will always yield point bounds for any future value of the input','line_number':1122,'multiline':False]
['text':' parameter.','line_number':1123,'multiline':False]
['text':'','line_number':1124,'multiline':False]
['text':' Example, consider an index pattern {a: 1, b: 1, c: 1, d: 1},','line_number':1125,'multiline':False]
['text':' - If the query predicate is {a: 1} and 'c' is a multikey field then, unsupportedFields = {c},','line_number':1126,'multiline':False]
['text':' equalityFields = {a}, ignoreFields = {} and baseSortPattern = {b: 1}. Field 'a' is dropped','line_number':1127,'multiline':False]
['text':' from the base sort pattern because it is an equality field. Fields 'c' and 'd' are truncted','line_number':1128,'multiline':False]
['text':' from the base sort pattern because 'c' is an unsupported field.','line_number':1129,'multiline':False]
['text':' - If the query predicate is {} and 'a' is a multikey field then, unsupportedFields = {a},','line_number':1130,'multiline':False]
['text':' equalityFields = {}, ignoreFields = {} and baseSortPattern = {}. The entire sort pattern is','line_number':1131,'multiline':False]
['text':' truncated since the first field 'a' is an unsupported field.','line_number':1132,'multiline':False]
['text':' - If the query predicate is {b: 1} with 'b' is a multikey field then, unsupportedFields = {},','line_number':1133,'multiline':False]
['text':' equalityFields = {}, ignoreFields = {b} and baseSortPattern = {a: 1, c: 1, d: 1}. Field 'b'','line_number':1134,'multiline':False]
['text':' has to be dropped from the base sort pattern, since although we are not sorted by 'b', we','line_number':1135,'multiline':False]
['text':' have point bounds on it.','line_number':1136,'multiline':False]
['text':' - If the query predicate is {b: 1, c: 1} and 'b' is a multikey field then, unsupportedFields','line_number':1137,'multiline':False]
['text':' = {}, equalityFields = {c}, ignoreFields = {b} and baseSortPattern = {a: 1, d: 1}. Field 'b'','line_number':1138,'multiline':False]
['text':' has to be dropped from the base sort pattern, since although we are not sorted by 'b', we','line_number':1139,'multiline':False]
['text':' have point bounds on it. Field 'c' is removed because of the presence of equality predicate.','line_number':1140,'multiline':False]
['text':' So we can provide sorts {a: 1, d: 1}, {a: 1, c: 1, d: 1} but not sort patterns that include','line_number':1141,'multiline':False]
['text':' field 'b'.','line_number':1142,'multiline':False]
['text':'','line_number':1143,'multiline':False]
['text':' Remove all equality predicates from sort object since they do not contribute in changing the','line_number':1171,'multiline':False]
['text':' sort order.','line_number':1172,'multiline':False]
['text':' Once a multi-key/collator field is encountered we cannot provide sort the the later','line_number':1184,'multiline':False]
['text':' fields.','line_number':1185,'multiline':False]
['text':'*
 * Computes sort orders for index scans, including DISTINCT_SCAN. Returns a pair where the first
 * field is 'ProvidedSortSet', which contains all the sort orders that can be provided by the index
 * scan. The second field is a set populated with the names of all fields that the index indicates
 * are multikey.
 ','line_number':1194,'multiline':True]
['text':' If the index is multikey but does not have path-level multikey metadata, then this index','line_number':1206,'multiline':False]
['text':' cannot provide any sorts and we need not populate 'multikeyFieldsOut'.','line_number':1207,'multiline':False]
['text':' namespace','line_number':1219,'multiline':False]
['text':' namespace','line_number':1251,'multiline':False]
['text':'','line_number':1259,'multiline':False]
['text':' ColumnIndexScanNode','line_number':1260,'multiline':False]
['text':'','line_number':1261,'multiline':False]
['text':'','line_number':1292,'multiline':False]
['text':' ReturnKeyNode','line_number':1293,'multiline':False]
['text':'','line_number':1294,'multiline':False]
['text':'','line_number':1317,'multiline':False]
['text':' MatchNode','line_number':1318,'multiline':False]
['text':'','line_number':1319,'multiline':False]
['text':'','line_number':1341,'multiline':False]
['text':' UnwindNode','line_number':1342,'multiline':False]
['text':'','line_number':1343,'multiline':False]
['text':'','line_number':1366,'multiline':False]
['text':' ReplaceRootNode','line_number':1367,'multiline':False]
['text':'','line_number':1368,'multiline':False]
['text':'','line_number':1389,'multiline':False]
['text':' ProjectionNode','line_number':1390,'multiline':False]
['text':'','line_number':1391,'multiline':False]
['text':' Our input sort is not necessarily maintained if we project some fields that are part of the','line_number':1410,'multiline':False]
['text':' sort out.','line_number':1411,'multiline':False]
['text':' ProjectionNode should not populate filter. This should be a no-op.','line_number':1424,'multiline':False]
['text':'','line_number':1451,'multiline':False]
['text':' SortKeyGeneratorNode','line_number':1452,'multiline':False]
['text':'','line_number':1453,'multiline':False]
['text':'','line_number':1473,'multiline':False]
['text':' SortNode','line_number':1474,'multiline':False]
['text':'','line_number':1475,'multiline':False]
['text':'','line_number':1511,'multiline':False]
['text':' LimitNode','line_number':1512,'multiline':False]
['text':'','line_number':1513,'multiline':False]
['text':'','line_number':1537,'multiline':False]
['text':' SkipNode','line_number':1538,'multiline':False]
['text':'','line_number':1539,'multiline':False]
['text':'','line_number':1561,'multiline':False]
['text':' GeoNear2DNode','line_number':1562,'multiline':False]
['text':'','line_number':1563,'multiline':False]
['text':'','line_number':1592,'multiline':False]
['text':' GeoNear2DSphereNode','line_number':1593,'multiline':False]
['text':'','line_number':1594,'multiline':False]
['text':'','line_number':1625,'multiline':False]
['text':' ShardingFilterNode','line_number':1626,'multiline':False]
['text':'','line_number':1627,'multiline':False]
['text':'','line_number':1651,'multiline':False]
['text':' DistinctNode','line_number':1652,'multiline':False]
['text':'','line_number':1653,'multiline':False]
['text':' Note that we don't need to save the returned multikey fields for a DISTINCT_SCAN. They are','line_number':1681,'multiline':False]
['text':' only needed for explodeForSort(), which works on IXSCAN but not DISTINCT_SCAN.','line_number':1682,'multiline':False]
['text':' iets ','line_number':1684,'multiline':True]
['text':'','line_number':1688,'multiline':False]
['text':' CountScanNode','line_number':1689,'multiline':False]
['text':'','line_number':1690,'multiline':False]
['text':'','line_number':1717,'multiline':False]
['text':' EofNode','line_number':1718,'multiline':False]
['text':'','line_number':1719,'multiline':False]
['text':'','line_number':1732,'multiline':False]
['text':' TextOrNode','line_number':1733,'multiline':False]
['text':'','line_number':1734,'multiline':False]
['text':'','line_number':1758,'multiline':False]
['text':' TextMatchNode','line_number':1759,'multiline':False]
['text':'','line_number':1760,'multiline':False]
['text':'*
 * GroupNode.
 ','line_number':1794,'multiline':True]
['text':'*
 * EqLookupNode.
 ','line_number':1843,'multiline':True]
['text':'*
 * SentinelNode.
 ','line_number':1882,'multiline':True]
['text':'*
 * WindowNode.
 ','line_number':1913,'multiline':True]
['text':' namespace mongo','line_number':1954,'multiline':False]
