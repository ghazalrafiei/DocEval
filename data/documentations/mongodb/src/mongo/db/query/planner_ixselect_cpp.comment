['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':38,'multiline':False]
['text':' Can't index negations of {$eq: <Array>}, {$lt: <Array>}, {$gt: <Array>}, {$lte: <Array>}, {$gte:','line_number':80,'multiline':False]
['text':' <Array>}, or {$in: [<Array>, ...]}. Note that we could use the index in principle, though we','line_number':81,'multiline':False]
['text':' would need to generate special bounds.','line_number':82,'multiline':False]
['text':' $** indices break nested objects into separate keys, which means we can't naturally','line_number':101,'multiline':False]
['text':' support comparison-to-object predicates. However, there is an exception: empty objects','line_number':102,'multiline':False]
['text':' are indexed like regular leaf values. This means that equality-to-empty-object can be','line_number':103,'multiline':False]
['text':' supported.','line_number':104,'multiline':False]
['text':'','line_number':105,'multiline':False]
['text':' Due to type bracketing, $lte:{} and $eq:{} are semantically equivalent.','line_number':106,'multiline':False]
['text':' We only support equality to empty array.','line_number':112,'multiline':False]
['text':' namespace','line_number':119,'multiline':False]
['text':' It is safe to use a non-multikey index for not equals null queries.','line_number':125,'multiline':False]
['text':' This is an old index without multikey path metadata.','line_number':127,'multiline':False]
['text':' This part of the index has no multikey components, it is always safe to use the index.','line_number':131,'multiline':False]
['text':' At least one component is multikey. In most circumstances, we can't index the negation of EQ','line_number':135,'multiline':False]
['text':' with a value of null if the index is multikey on one of the components of the path.','line_number':136,'multiline':False]
['text':'','line_number':137,'multiline':False]
['text':' This is quite subtle, and due to the semantics of null matching. For example, if the query is','line_number':138,'multiline':False]
['text':' {a: {$ne: null}}, you might expect us to build index bounds of [MinKey, undefined) and','line_number':139,'multiline':False]
['text':' (null, MaxKey] (or similar) on an 'a' index. However, with this query the document {a: []}','line_number':140,'multiline':False]
['text':' should match (because it does not match {a: null}), but will have an index key of undefined.','line_number':141,'multiline':False]
['text':' Similarly, the document {a: [null, null]} matches the query {'a.b': {$ne: null}}, but would','line_number':142,'multiline':False]
['text':' have an index key of null in an index on 'a.b'. Since it's possible for a key of undefined to','line_number':143,'multiline':False]
['text':' be included in the results and also possible for a value of null to be included, there are no','line_number':144,'multiline':False]
['text':' restrictions on the bounds of the index for such a predicate. Further, such an index could','line_number':145,'multiline':False]
['text':' not be used for covering, so would not provide any help to the query.','line_number':146,'multiline':False]
['text':'','line_number':147,'multiline':False]
['text':' There are two exceptions to this rule, both having to do with $elemMatch, see below.','line_number':148,'multiline':False]
['text':' See above, if there's no $elemMatch we can't use the index.','line_number':151,'multiline':False]
['text':' If this $ne clause is within a $elemMatch *value*, the semantics of $elemMatch guarantee','line_number':156,'multiline':False]
['text':' that no matching values will be null or undefined, even if the index is multikey.','line_number':157,'multiline':False]
['text':'','line_number':158,'multiline':False]
['text':' For example, the document {a: []} does *not* match the query {a: {$elemMatch: {$ne:','line_number':159,'multiline':False]
['text':' null}} because there was no element within the array that matched. While the document {a:','line_number':160,'multiline':False]
['text':' [[]]} *does* match that query, the index entry for that document would be [], not null or','line_number':161,'multiline':False]
['text':' undefined.','line_number':162,'multiline':False]
['text':' The index has no path-level multikey metadata, we can't do the analysis below so have','line_number':167,'multiline':False]
['text':' to be defensive.','line_number':168,'multiline':False]
['text':' This $ne clause is within an $elemMatch *object*. We can safely use the index so long as','line_number':172,'multiline':False]
['text':' there are no multikey paths below the $elemMatch.','line_number':173,'multiline':False]
['text':'','line_number':174,'multiline':False]
['text':' For example, take the query {"a.b": {$elemMatch: {"c.d": {$ne: null}}}}. We can use an','line_number':175,'multiline':False]
['text':' "a.b.c.d" index if _only_ "a" and/or "a.b" is/are multikey, because there will be no','line_number':176,'multiline':False]
['text':' array traversal for the "c.d" part of the query. If "a.b.c" or "a.b.c.d" are multikey,','line_number':177,'multiline':False]
['text':' we cannot use this index. As an example of what would go wrong, suppose the collection','line_number':178,'multiline':False]
['text':' contained the document {a: {b: {c: []}}}. The "a.b.c.d" index key for that document','line_number':179,'multiline':False]
['text':' would be null, and so would be excluded from the index bounds. However, that document','line_number':180,'multiline':False]
['text':' should match the query.','line_number':181,'multiline':False]
['text':' The index was multikey, but only on paths that came before the $elemMatch, so we can','line_number':190,'multiline':False]
['text':' safely use the index without having to worry about implicitly traversing arrays.','line_number':191,'multiline':False]
['text':'*
 * 2d indices don't handle wrapping so we can't use them for queries that wrap.
 ','line_number':201,'multiline':True]
['text':' We validated the parameters when creating the index.','line_number':206,'multiline':False]
['text':' FYI: old code used flat not spherical error.','line_number':208,'multiline':False]
['text':' Checks whether 'node' contains any comparison to an element of type 'type'. Nested objects and','line_number':216,'multiline':False]
['text':' arrays are not checked recursively. We assume 'node' is bounds-generating or is a recursive child','line_number':217,'multiline':False]
['text':' of a bounds-generating node, i.e. it does not contain AND, OR, ELEM_MATCH_OBJECT, or NOR.','line_number':218,'multiline':False]
['text':' static','line_number':256,'multiline':False]
['text':' Do not traverse tree beyond a NOR negation node','line_number':260,'multiline':False]
['text':' Leaf nodes with a path and some array operators.','line_number':266,'multiline':False]
['text':' If the array uses an index on its children, it's something like','line_number':271,'multiline':False]
['text':' {foo : {$elemMatch: {bar: 1}}}, in which case the predicate is really over foo.bar.','line_number':272,'multiline':False]
['text':' Note we skip empty path components since they are not allowed in index key patterns.','line_number':273,'multiline':False]
['text':' static','line_number':290,'multiline':False]
['text':' static','line_number':324,'multiline':False]
['text':' If the index is non-sparse we can use the field regardless its sparsity, otherwise we','line_number':334,'multiline':False]
['text':' should find the field that can be answered by a sparse index.','line_number':335,'multiline':False]
['text':' Filter out fields that cannot be answered by any sparse index. We know wildcard indexes are','line_number':349,'multiline':False]
['text':' sparse, so we don't want to expand the wildcard index based on such fields.','line_number':350,'multiline':False]
['text':' As a post-condition, all expanded index entries must _not_ contain a multikey path set.','line_number':365,'multiline':False]
['text':' Multikey metadata is converted to the fixed-size vector representation as part of expanding','line_number':366,'multiline':False]
['text':' indexes.','line_number':367,'multiline':False]
['text':' static','line_number':375,'multiline':False]
['text':' If the compound wildcard index is expanded to a generic CWI IndexEntry with '$_path'','line_number':391,'multiline':False]
['text':' field being the wildcard field, this index is mostly for queries on regular prefix of the','line_number':392,'multiline':False]
['text':' CWI. So such IndexEntry is ineligible to answer a query on any field after "$_path".','line_number':393,'multiline':False]
['text':' Bail out because this IndexEntry is trying to answer a field comes after "$_path"','line_number':396,'multiline':False]
['text':' field.','line_number':397,'multiline':False]
['text':' Historically one could create indices with any particular value for the index spec,','line_number':408,'multiline':False]
['text':' including values that now indicate a special index.  As such we have to make sure the','line_number':409,'multiline':False]
['text':' index type wasn't overridden before we pay attention to the string in the index key','line_number':410,'multiline':False]
['text':' pattern element.','line_number':411,'multiline':False]
['text':'','line_number':412,'multiline':False]
['text':' e.g. long ago we could have created an index {a: "2dsphere"} and it would','line_number':413,'multiline':False]
['text':' be treated as a btree index by an ancient version of MongoDB.  To try to run','line_number':414,'multiline':False]
['text':' 2dsphere queries over it would be folly.','line_number':415,'multiline':False]
['text':' We know keyPatternElt.fieldname() == node->path().','line_number':426,'multiline':False]
['text':' Expression language comparisons cannot be indexed if the field path has multikey','line_number':431,'multiline':False]
['text':' components.','line_number':432,'multiline':False]
['text':' We can't use a sparse index for certain match expressions.','line_number':441,'multiline':False]
['text':' We can't use a btree-indexed field for geo expressions.','line_number':446,'multiline':False]
['text':' There are restrictions on when we can use the index if the expression is a NOT.','line_number':452,'multiline':False]
['text':' Don't allow indexed NOT on special index types such as geo or text indices. There are','line_number':454,'multiline':False]
['text':' two exceptions to this rule:','line_number':455,'multiline':False]
['text':' - Wildcard indexes can answer {$ne: null} queries. We allow wildcard indexes to pass','line_number':456,'multiline':False]
['text':'   the test here because we subsequently enforce that {$ne:null} is the only accepted','line_number':457,'multiline':False]
['text':'   negation predicate for sparse indexes, and wildcard indexes are always sparse.','line_number':458,'multiline':False]
['text':' - Any non-hashed field in a compound hashed index can answer negated predicates. We','line_number':459,'multiline':False]
['text':'   have already determined that the specific field under consideration is not hashed,','line_number':460,'multiline':False]
['text':'   so we can safely permit a hashed index to pass the test below.','line_number':461,'multiline':False]
['text':'','line_number':462,'multiline':False]
['text':' TODO: SERVER-30994 should remove this check entirely and allow $not on the','line_number':463,'multiline':False]
['text':' 'non-special' fields of non-btree indices (e.g. {a: 1, geo: "2dsphere"}).','line_number':464,'multiline':False]
['text':' The type being INDEX_WILDCARD implies that the index is sparse.','line_number':470,'multiline':False]
['text':' Can't index negations of MOD, REGEX, TYPE_OPERATOR, or ELEM_MATCH_VALUE.','line_number':476,'multiline':False]
['text':' $gt and $lt to MinKey/MaxKey must build inexact bounds if the index is multikey and','line_number':483,'multiline':False]
['text':' therefore cannot be inverted safely in a $not.','line_number':484,'multiline':False]
['text':' Most of the time we can't use a multikey index for a $ne: null query, however there','line_number':489,'multiline':False]
['text':' are a few exceptions around $elemMatch.','line_number':490,'multiline':False]
['text':' If it's a negated $in, it can't have any REGEX's inside.','line_number':498,'multiline':False]
['text':' This is a case that we know is supported.','line_number':503,'multiline':False]
['text':' If we can't use the index for $ne to null, then we cannot use it for the','line_number':511,'multiline':False]
['text':' case {$nin: [null, <...>]}.','line_number':512,'multiline':False]
['text':' Comparisons with arrays have strange enough semantics that inverting the bounds','line_number':518,'multiline':False]
['text':' within a $not has many complex special cases. We avoid indexing these queries, even','line_number':519,'multiline':False]
['text':' though it is sometimes possible to build useful bounds.','line_number':520,'multiline':False]
['text':' If this is an $elemMatch value, make sure _all_ of the children can use the index.','line_number':526,'multiline':False]
['text':' If the index path has at least two components, and the last component of the path is','line_number':533,'multiline':False]
['text':' numeric, this component could be an array index because the preceding path component','line_number':534,'multiline':False]
['text':' may contain an array. Currently it is not known whether the preceding path component','line_number':535,'multiline':False]
['text':' could be an array because indexes which positionally index array elements are not','line_number':536,'multiline':False]
['text':' considered multikey.','line_number':537,'multiline':False]
['text':' We can only index EQ using text indices.  This is an artificial limitation imposed by','line_number':561,'multiline':False]
['text':' FTSSpec::getIndexPrefix() which will fail if there is not an EQ predicate on each','line_number':562,'multiline':False]
['text':' index prefix field of the text index.','line_number':563,'multiline':False]
['text':'','line_number':564,'multiline':False]
['text':' Example for key pattern {a: 1, b: "text"}:','line_number':565,'multiline':False]
['text':' - Allowed: node = {a: 7}','line_number':566,'multiline':False]
['text':' - Not allowed: node = {a: {$gt: 7}}','line_number':567,'multiline':False]
['text':' If we're here we know it's a text index.  Equalities are OK anywhere in a text index.','line_number':573,'multiline':False]
['text':' Not-equalities can only go in a suffix field of an index kp.  We look through the key','line_number':578,'multiline':False]
['text':' pattern to see if the field we're looking at now appears as a prefix.  If so, we','line_number':579,'multiline':False]
['text':' can't use this index for it.','line_number':580,'multiline':False]
['text':' We hit the dividing mark between prefix and suffix, so whatever field we're','line_number':582,'multiline':False]
['text':' looking at is a suffix, since it appears *after* the dividing mark between the','line_number':583,'multiline':False]
['text':' two.  As such, we can use the index.','line_number':584,'multiline':False]
['text':' If we're here, we're still looking at prefix elements.  We know that exprtype','line_number':589,'multiline':False]
['text':' isn't EQ so we can't use this index.','line_number':590,'multiline':False]
['text':' Text index implies there is a separator implies we will always hit the 'return true'','line_number':596,'multiline':False]
['text':' above.','line_number':597,'multiline':False]
['text':' within or intersect.','line_number':607,'multiline':False]
['text':' Make sure the near query is compatible with 2dsphere.','line_number':614,'multiline':False]
['text':' Make sure the near query is compatible with 2d index','line_number':629,'multiline':False]
['text':' 2d only supports within.','line_number':632,'multiline':False]
['text':' 2d indices require an R2 covering','line_number':641,'multiline':False]
['text':' 2d indices can answer centerSphere queries.','line_number':648,'multiline':False]
['text':' No wrapping around the edge of the world is allowed in 2d centerSphere.','line_number':656,'multiline':False]
['text':' The only types of queries which may not be supported by a sparse index are ones which have','line_number':676,'multiline':False]
['text':' an equality to null (or an {$exists: false}), because of the language's "null or missing"','line_number':677,'multiline':False]
['text':' semantics. {$exists: false} gets translated into a negation query (which a sparse index','line_number':678,'multiline':False]
['text':' cannot answer), so this function only needs to check if the query performs an equality to','line_number':679,'multiline':False]
['text':' null.','line_number':680,'multiline':False]
['text':' Otherwise, we can't use a sparse index for $eq (or $lte, or $gte) with a null element.','line_number':682,'multiline':False]
['text':'','line_number':683,'multiline':False]
['text':' We can use a sparse index for $_internalExprEq with a null element. Expression language','line_number':684,'multiline':False]
['text':' equality-to-null semantics are that only literal nulls match. Sparse indexes contain','line_number':685,'multiline':False]
['text':' index keys for literal nulls, but not for missing elements.','line_number':686,'multiline':False]
['text':' Equality to null inside an $elemMatch implies a match on literal 'null'.','line_number':690,'multiline':False]
['text':' Equality to null inside an $elemMatch implies a match on literal 'null'.','line_number':694,'multiline':False]
['text':' Prevent negated predicates from using sparse indices. Doing so would cause us to','line_number':704,'multiline':False]
['text':' miss documents which do not contain the indexed fields. The only case where we may','line_number':705,'multiline':False]
['text':' use a sparse index for a negation is when the query is {$ne: null}. This is due to','line_number':706,'multiline':False]
['text':' the behavior of {$eq: null} matching documents where the field does not exist OR the','line_number':707,'multiline':False]
['text':' field is equal to literal null. The negation of {$eq: null} therefore matches','line_number':708,'multiline':False]
['text':' documents where the field does exist AND the field is not equal to literal','line_number':709,'multiline':False]
['text':' null. Since the field must exist, it is safe to use a sparse index.','line_number':710,'multiline':False]
['text':' Wildcard indexes only store index keys for "leaf" nodes in an object. That is, they do not','line_number':725,'multiline':False]
['text':' store keys for nested objects, meaning that any kind of comparison to an object or array','line_number':726,'multiline':False]
['text':' cannot be answered by the index (including with a $in).','line_number':727,'multiline':False]
['text':' Hashed fields can answer simple equality predicates.','line_number':744,'multiline':False]
['text':' An $in can be answered so long as its operand contains only simple equalities.','line_number':751,'multiline':False]
['text':' {$exists:false} produces a single point-interval index bound on [null,null].','line_number':756,'multiline':False]
['text':' {$exists:true} can be answered using [MinKey, MaxKey] bounds.','line_number':760,'multiline':False]
['text':' static','line_number':764,'multiline':False]
['text':' This is the public method which does not accept an ElemMatchContext.','line_number':765,'multiline':False]
['text':' static','line_number':773,'multiline':False]
['text':' Do not traverse tree beyond logical NOR node','line_number':779,'multiline':False]
['text':' Every indexable node is tagged even when no compatible index is available.','line_number':785,'multiline':False]
['text':' If this is a NOT, we have to clone the tag and attach it to the NOT's child.','line_number':821,'multiline':False]
['text':' Note we skip empty path components since they are not allowed in index key patterns.','line_number':828,'multiline':False]
['text':' Note this StringData is unowned and references the string declared on the stack here.','line_number':831,'multiline':False]
['text':' This should be fine since we are only ever reading from this in recursive calls as','line_number':832,'multiline':False]
['text':' context to help make planning decisions.','line_number':833,'multiline':False]
['text':' If the array uses an index on its children, it's something like','line_number':837,'multiline':False]
['text':' {foo: {$elemMatch: {bar: 1}}}, in which case the predicate is really over foo.bar.','line_number':838,'multiline':False]
['text':' static','line_number':850,'multiline':False]
['text':'*
 * For every node in the subtree rooted at 'node' that has a RelevantTag, removes index
 * assignments from that tag.
 *
 * Used as a helper for stripUnneededAssignments().
 ','line_number':866,'multiline':True]
['text':'*
 * Finds bounds-generating leaf nodes in the subtree rooted at 'node' that are logically AND'ed
 * together in the match expression tree, and returns them in the 'andRelated' out-parameter.
 * Logical nodes like OR and array nodes other than elemMatch object are instead returned in the
 * 'other' out-parameter.
 ','line_number':884,'multiline':True]
['text':' namespace','line_number':906,'multiline':False]
['text':' static','line_number':908,'multiline':False]
['text':' We found a EQ child of an AND which is tagged.','line_number':923,'multiline':False]
['text':' Look through all of the indices for which this predicate can be answered with','line_number':926,'multiline':False]
['text':' the leading field of the index.','line_number':927,'multiline':False]
['text':' Found an EQ predicate which can use a single-field unique index.','line_number':933,'multiline':False]
['text':' Clear assignments from the entire tree, and add back a single assignment','line_number':934,'multiline':False]
['text':' for 'child' to the unique index.','line_number':935,'multiline':False]
['text':' Tag state has been reset in the entire subtree at 'root'; nothing','line_number':940,'multiline':False]
['text':' else for us to do.','line_number':941,'multiline':False]
['text':'','line_number':953,'multiline':False]
['text':' Helpers used by stripInvalidAssignments','line_number':954,'multiline':False]
['text':'','line_number':955,'multiline':False]
['text':'*
 * Remove 'idx' from the RelevantTag lists for 'node'.  'node' must be a leaf.
 ','line_number':957,'multiline':True]
['text':' If 'node' is an OR and our current clause satisfies the filter expression, then we may be','line_number':994,'multiline':False]
['text':' able to spare this clause from being stripped.  We only support such sparing if we're not','line_number':995,'multiline':False]
['text':' in a negation or ELEM_MATCH_OBJECT, though:','line_number':996,'multiline':False]
['text':' - If we're in a negation, then we're looking for documents that describe the inverse of','line_number':997,'multiline':False]
['text':'   the current predicate.  For example, suppose we have an index with key pattern {a: 1}','line_number':998,'multiline':False]
['text':'   and filter expression {a: {$gt: 0}}, and our OR is inside a negation and the current','line_number':999,'multiline':False]
['text':'   clause we're evaluating is {a: 10}.  If we allow use of this index, then we'd end up','line_number':1000,'multiline':False]
['text':'   generating bounds corresponding to the predicate {a: {$ne: 10}}, which does not satisfy','line_number':1001,'multiline':False]
['text':'   the filter expression (note also that the match expression parser currently does not','line_number':1002,'multiline':False]
['text':'   generate trees with OR inside NOT, but we may consider changing it to allow this in the','line_number':1003,'multiline':False]
['text':'   future).','line_number':1004,'multiline':False]
['text':' - If we're in an ELEM_MATCH_OBJECT, then every predicate in the current clause has an','line_number':1005,'multiline':False]
['text':'   implicit prefix of the elemMatch's path, so it can't be compared outright to the filter','line_number':1006,'multiline':False]
['text':'   expression.  For example, suppose we have an index with key pattern {"a.b": 1} and','line_number':1007,'multiline':False]
['text':'   filter expression {f: 1}, and we are evaluating the first clause of the $or in the','line_number':1008,'multiline':False]
['text':'   query {a: {$elemMatch: {$or: [{b: 1, f: 1}, ...]}}}.  Even though {b: 1, f: 1}','line_number':1009,'multiline':False]
['text':'   satisfies the filter expression {f: 1}, the former is referring to fields "a.b" and','line_number':1010,'multiline':False]
['text':'   "a.f" while the latter is referring to field "f", so the clause does not actually','line_number':1011,'multiline':False]
['text':'   satisfy the filter expression and should not be spared.','line_number':1012,'multiline':False]
['text':' namespace','line_number':1032,'multiline':False]
['text':'','line_number':1043,'multiline':False]
['text':' Wildcard index invalid assignments.','line_number':1044,'multiline':False]
['text':'','line_number':1045,'multiline':False]
['text':' Skip over all indexes except $**.','line_number':1049,'multiline':False]
['text':' If we have a $** index, check whether we have a TEXT node in the MatchExpression tree.','line_number':1053,'multiline':False]
['text':' If so, remove the $** index from the node's relevant tags.','line_number':1064,'multiline':False]
['text':'','line_number':1071,'multiline':False]
['text':' Text index quirks','line_number':1072,'multiline':False]
['text':'','line_number':1073,'multiline':False]
['text':'*
 * Traverse the subtree rooted at 'node' to remove invalid RelevantTag assignments to text index
 * 'idx', which has prefix paths 'prefixPaths'.
 ','line_number':1075,'multiline':True]
['text':' If we're here, there are prefixPaths and node is either:','line_number':1082,'multiline':False]
['text':' 1. a text pred which we can't use as we have nothing over its prefix, or','line_number':1083,'multiline':False]
['text':' 2. a non-text pred which we can't use as we don't have a text pred AND-related.','line_number':1084,'multiline':False]
['text':' Do not traverse tree beyond negation node.','line_number':1090,'multiline':False]
['text':' For anything to use a text index with prefixes, we require that:','line_number':1095,'multiline':False]
['text':' 1. The text pred exists in an AND,','line_number':1096,'multiline':False]
['text':' 2. The non-text preds that use the text index's prefixes are also in that AND.','line_number':1097,'multiline':False]
['text':' It's an OR or some kind of array operator.','line_number':1100,'multiline':False]
['text':' If we're here, we're an AND.  Determine whether the children satisfy the index prefix for','line_number':1107,'multiline':False]
['text':' the text index.','line_number':1108,'multiline':False]
['text':' The AND must have an EQ predicate for each prefix path.  When we encounter a child with a','line_number':1113,'multiline':False]
['text':' tag we remove it from childrenPrefixPaths.  All children exist if this set is empty at','line_number':1114,'multiline':False]
['text':' the end.','line_number':1115,'multiline':False]
['text':' 'child' could be a logical operator.  Maybe there are some assignments hiding','line_number':1123,'multiline':False]
['text':' inside.','line_number':1124,'multiline':False]
['text':' Great!  'child' was assigned to our index.','line_number':1135,'multiline':False]
['text':' One fewer prefix we're looking for, possibly.  Note that we could have a','line_number':1140,'multiline':False]
['text':' suffix assignment on the index and wind up here.  In this case the erase','line_number':1141,'multiline':False]
['text':' above won't do anything since a suffix isn't a prefix.','line_number':1142,'multiline':False]
['text':' Recurse on the children to ensure that they're not hiding any assignments','line_number':1145,'multiline':False]
['text':' to idx.','line_number':1146,'multiline':False]
['text':' Our prereqs for using the text index were not satisfied so we remove the assignments from','line_number':1151,'multiline':False]
['text':' all children of the AND.','line_number':1152,'multiline':False]
['text':' static','line_number':1160,'multiline':False]
['text':' We only care about text indices.','line_number':1166,'multiline':False]
['text':' Gather the set of paths that comprise the index prefix for this text index.','line_number':1171,'multiline':False]
['text':' Each of those paths must have an equality assignment, otherwise we can't assign','line_number':1172,'multiline':False]
['text':' *anything* to this index.','line_number':1173,'multiline':False]
['text':' We stop when we see the first string in the key pattern.  We know that','line_number':1177,'multiline':False]
['text':' the prefix precedes "text".','line_number':1178,'multiline':False]
['text':' If the index prefix is non-empty, remove invalid assignments to it.','line_number':1184,'multiline':False]
['text':'','line_number':1191,'multiline':False]
['text':' 2dsphere V2 sparse quirks','line_number':1192,'multiline':False]
['text':'','line_number':1193,'multiline':False]
['text':' We found a non-geo predicate tagged to use a V2 2dsphere index which is not','line_number':1199,'multiline':False]
['text':' and-related to a geo predicate that can use the index.','line_number':1200,'multiline':False]
['text':' Don't bother peeking inside of negations.','line_number':1207,'multiline':False]
['text':' It's an OR or some kind of array operator.','line_number':1213,'multiline':False]
['text':' Split 'node' into those leaf predicates that are logically AND-related and everything else.','line_number':1222,'multiline':False]
['text':' Traverse through non and-related leaf nodes. These are generally logical nodes like OR, and','line_number':1227,'multiline':False]
['text':' there may be some assignments hiding inside that need to be stripped.','line_number':1228,'multiline':False]
['text':' Traverse through the and-related leaf nodes. We strip all assignments to such nodes unless we','line_number':1233,'multiline':False]
['text':' find an assigned geo predicate.','line_number':1234,'multiline':False]
['text':' No tags to strip.','line_number':1239,'multiline':False]
['text':' If there is an index assignment...','line_number':1248,'multiline':False]
['text':' And it's a geo predicate...','line_number':1250,'multiline':False]
['text':' If there isn't a geo predicate our results aren't a subset of what's in the geo index, so','line_number':1258,'multiline':False]
['text':' if we use the index we'll miss results.','line_number':1259,'multiline':False]
['text':' static','line_number':1267,'multiline':False]
['text':' We only worry about 2dsphere indices.','line_number':1273,'multiline':False]
['text':' 2dsphere version 1 indices do not have the geo-sparseness property, so there's no need to','line_number':1278,'multiline':False]
['text':' strip assignments to such indices.','line_number':1279,'multiline':False]
['text':' If every field is geo don't bother doing anything.','line_number':1291,'multiline':False]
['text':' Remove bad assignments from this index.','line_number':1305,'multiline':False]
['text':' namespace mongo','line_number':1310,'multiline':False]
