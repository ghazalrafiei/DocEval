['text':'*
 *    Copyright (C) 2022-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: keep','line_number':52,'multiline':False]
['text':'costModel','line_number':95,'multiline':True]
['text':' Try to insert into the memo again.','line_number':205,'multiline':False]
['text':' Nothing was inserted.','line_number':211,'multiline':False]
['text':' Insert a different tree, this time only scan and project.','line_number':217,'multiline':False]
['text':' Nothing was inserted in first 3 groups.','line_number':230,'multiline':False]
['text':'costModel','line_number':280,'multiline':True]
['text':'costModel','line_number':354,'multiline':True]
['text':' Note: this assert depends on the order on which we consider rewrites.','line_number':359,'multiline':False]
['text':'costModel','line_number':409,'multiline':True]
['text':'retainNonArrays','line_number':444,'multiline':True]
['text':' This filter should stay above the unwind.','line_number':446,'multiline':False]
['text':' This filter should be pushed down below the unwind.','line_number':450,'multiline':False]
['text':'costModel','line_number':460,'multiline':True]
['text':'costModel','line_number':508,'multiline':True]
['text':' This collation node should stay below the unwind.','line_number':543,'multiline':False]
['text':' This collation node should go above the unwind.','line_number':547,'multiline':False]
['text':'retainNonArrays','line_number':552,'multiline':True]
['text':'costModel','line_number':560,'multiline':True]
['text':' Create two eval nodes such that the two branches of the union share a projection.','line_number':579,'multiline':False]
['text':'costModel','line_number':623,'multiline':True]
['text':' Create multiple shared projections for each child.','line_number':656,'multiline':False]
['text':' Create two filters, one for each of the two common projections.','line_number':678,'multiline':False]
['text':'costModel','line_number':728,'multiline':True]
['text':'costModel','line_number':797,'multiline':True]
['text':'costModel','line_number':874,'multiline':True]
['text':' The SargableDisjunctiveReorder rule will reorder the Sargable nodes such that the node(s)','line_number':878,'multiline':False]
['text':' without disjunctive PSRs are closest to the scan. Without the rule, none of the Sargable','line_number':879,'multiline':False]
['text':' would be reordered, producing a plan where only "c" and "d" projections would be used to','line_number':880,'multiline':False]
['text':' generate index plans.','line_number':881,'multiline':False]
['text':' Run the reordering rewrite such that the scan produces a hash partition.','line_number':957,'multiline':False]
['text':'costModel','line_number':963,'multiline':True]
['text':'costModel','line_number':1156,'multiline':True]
['text':' Displays SargableNode-specific per-key estimates.','line_number':1161,'multiline':False]
['text':' Construct a query which tests coll.find({_id: 1})','line_number':1248,'multiline':False]
['text':'costModel','line_number':1258,'multiline':True]
['text':' Assert that the cost estimate of a simple _id lookup is 1.','line_number':1266,'multiline':False]
['text':' Construct a query which tests a traverse.','line_number':1271,'multiline':False]
['text':' Assert that the cost estimate of a traverse into a simple _id lookup is 1.','line_number':1282,'multiline':False]
['text':'costModel','line_number':1305,'multiline':True]
['text':' collation','line_number':1345,'multiline':False]
['text':'isMultiKey','line_number':1346,'multiline':True]
['text':'isMultiKey','line_number':1348,'multiline':True]
['text':'costModel','line_number':1350,'multiline':True]
['text':' We remove the Traverse nodes, and combine the Not ... Eq into Neq.','line_number':1357,'multiline':False]
['text':' collation','line_number':1400,'multiline':False]
['text':'isMultiKey','line_number':1401,'multiline':True]
['text':'isMultiKey','line_number':1403,'multiline':True]
['text':'costModel','line_number':1405,'multiline':True]
['text':' Because the index is multikey, we don't remove the Traverse nodes,','line_number':1413,'multiline':False]
['text':' which prevents us from pushing down the Not.','line_number':1414,'multiline':False]
['text':' A ComposeA where both args can be negated.','line_number':1440,'multiline':False]
['text':' A ComposeA where only one arg can be negated.','line_number':1443,'multiline':False]
['text':'costModel','line_number':1454,'multiline':True]
['text':' We should push the Not down as far as possible, so that some leaves become Neq.','line_number':1461,'multiline':False]
['text':' Leaves with a Traverse in the way residualize a Not instead.','line_number':1462,'multiline':False]
['text':' Note that the top level traverse is to prevent ComposeM from being decomposed into filter','line_number':1464,'multiline':False]
['text':' nodes.','line_number':1465,'multiline':False]
['text':' A ComposeA where both args cannot be negated.','line_number':1508,'multiline':False]
['text':' A ComposeA where both args cannot be negated but can be simplified','line_number':1511,'multiline':False]
['text':'costModel','line_number':1521,'multiline':True]
['text':' We should keep ComposeA if both paths cannot be negated. If a path can be simplified (for','line_number':1528,'multiline':False]
['text':' example, Unary [Not] Constant [true] -> Constant [false]), the simplified path should','line_number':1529,'multiline':False]
['text':' reflected in ComposeA even if it is not negated.','line_number':1530,'multiline':False]
['text':' A ComposeM where both args can be negated.','line_number':1569,'multiline':False]
['text':' A ComposeM where only one arg can be negated.','line_number':1572,'multiline':False]
['text':'costModel','line_number':1582,'multiline':True]
['text':' We should push the Not down as far as possible, so that some leaves become Neq.','line_number':1589,'multiline':False]
['text':' Leaves with a Traverse in the way residualize a Not instead.','line_number':1590,'multiline':False]
['text':'costModel','line_number':1635,'multiline':True]
['text':' We should push the Not down. If the child expression of a PathConstant cannot be further','line_number':1642,'multiline':False]
['text':' simplified, we negate the expression with UnaryOp [Not].','line_number':1643,'multiline':False]
['text':'costModel','line_number':1672,'multiline':True]
['text':' We should push the Not down through another PathConstant, until EvalPath.','line_number':1679,'multiline':False]
['text':'costModel','line_number':1716,'multiline':True]
['text':' We should push the Not down and cancel out the Nots inside PathConstant.','line_number':1723,'multiline':False]
['text':' MQL: aggregate({$match:{ a: {$exists:false}}})','line_number':1745,'multiline':False]
['text':'costModel','line_number':1758,'multiline':True]
['text':' We should push the Not down through PathConstant.','line_number':1765,'multiline':False]
['text':'costModel','line_number':1796,'multiline':True]
['text':' We should push the Not down through the nested PathConstant.','line_number':1804,'multiline':False]
['text':' Example translation of {a: {$elemMatch: {b: {$ne: 2}}}}','line_number':1823,'multiline':False]
['text':' collation','line_number':1858,'multiline':False]
['text':'isMultiKey','line_number':1859,'multiline':True]
['text':'isMultiKey','line_number':1861,'multiline':True]
['text':'costModel','line_number':1863,'multiline':True]
['text':' Given the index the field is non-multikey while the $elemMatch requires an array. Thus, the','line_number':1868,'multiline':False]
['text':' plan is simplified to a ValueScan [0].','line_number':1869,'multiline':False]
['text':' collation','line_number':1899,'multiline':False]
['text':'isMultiKey','line_number':1900,'multiline':True]
['text':'isMultiKey','line_number':1902,'multiline':True]
['text':'costModel','line_number':1904,'multiline':True]
['text':' All the Traverses should be eliminated, and the Not ... Eq combined as Neq.','line_number':1911,'multiline':False]
['text':' Like 'NotPushdownUnderLambdaSuccess', but 'a' is multikey,','line_number':1926,'multiline':False]
['text':' so we can only remove the inner traverse, at 'a.b'.','line_number':1927,'multiline':False]
['text':' collation','line_number':1962,'multiline':False]
['text':'isMultiKey','line_number':1968,'multiline':True]
['text':'costModel','line_number':1970,'multiline':True]
['text':' The inner Traverses should be eliminated, and the Not ... Eq combined as Neq.','line_number':1977,'multiline':False]
['text':' We have to keep the outer traverse since 'a' is multikey.','line_number':1978,'multiline':False]
['text':' When we eliminate a Not, we can't eliminate the Lambda [x] if it would leave free','line_number':2012,'multiline':False]
['text':' occurrences of 'x'.','line_number':2013,'multiline':False]
['text':' We can eliminate the Not by combining with Eq.','line_number':2020,'multiline':False]
['text':' But the bound variable 'x' has more than one','line_number':2024,'multiline':False]
['text':' occurrence, so we can't eliminate the lambda.','line_number':2025,'multiline':False]
['text':'costModel','line_number':2037,'multiline':True]
['text':' The Not should be gone: combined into Neq.','line_number':2044,'multiline':False]
['text':' But the Lambda [x] should still be there, because 'x' is still used.','line_number':2045,'multiline':False]
['text':' MQL query: db.c1.find({stock : { $elemMatch: {$eq: 5 } } })','line_number':2066,'multiline':False]
['text':'multiKey','line_number':2082,'multiline':True]
['text':'costModel','line_number':2083,'multiline':True]
['text':'debugMode','line_number':2084,'multiline':True]
['text':'debugLevel','line_number':2084,'multiline':True]
['text':' The $elemMatch scan on stock (requiring an array) in combination with','line_number':2089,'multiline':False]
['text':' the index which ensures that stock is a non-multikey field','line_number':2090,'multiline':False]
['text':' allows the simplification of the query.','line_number':2091,'multiline':False]
['text':' MQL query: db.c1.find({stock : { $elemMatch: {size: 5} } })','line_number':2103,'multiline':False]
['text':'multiKey','line_number':2122,'multiline':True]
['text':'costModel','line_number':2123,'multiline':True]
['text':'debugMode','line_number':2124,'multiline':True]
['text':'debugLevel','line_number':2124,'multiline':True]
['text':' The $elemMatch scan on stock.size (requiring an array on stock) in combination with','line_number':2129,'multiline':False]
['text':' the index which ensures that stock is a non-multikey field','line_number':2130,'multiline':False]
['text':' allows the simplification of the query.','line_number':2131,'multiline':False]
['text':' MQL query: db.c1.find({stock : { $elemMatch: {size: 5} } })','line_number':2143,'multiline':False]
['text':'multiKey','line_number':2162,'multiline':True]
['text':'costModel','line_number':2163,'multiline':True]
['text':'debugMode','line_number':2164,'multiline':True]
['text':'debugLevel','line_number':2164,'multiline':True]
['text':' This query is the opposite of the previous test','line_number':2169,'multiline':False]
['text':' (PlanSimplificationNoRequirementOverlapElemMatchOnNonMultiKeyField) with regard to the','line_number':2170,'multiline':False]
['text':' multikeyness of the indexed field.','line_number':2171,'multiline':False]
['text':' The elemMatch operator requires field 'stock' to be an array. The collection has a key on','line_number':2172,'multiline':False]
['text':' field stock which in this case *is* a multikey field.','line_number':2173,'multiline':False]
['text':' The simplification of the sargable node based on multikeyness metadata is *not* possible and','line_number':2174,'multiline':False]
['text':' the query is *not* simplified to a simple ValueScan','line_number':2175,'multiline':False]
['text':' When we have a filter with Traverse above ComposeM, we can't immediately','line_number':2211,'multiline':False]
['text':' split the ComposeM into a top-level conjunction.  But if we can use multikeyness','line_number':2212,'multiline':False]
['text':' to remove the Traverse first, then we can split it.','line_number':2213,'multiline':False]
['text':' This query is similar to $elemMatch, but without the PathArr constraint.','line_number':2215,'multiline':False]
['text':' collation','line_number':2242,'multiline':False]
['text':'isMultiKey','line_number':2243,'multiline':True]
['text':'isMultiKey','line_number':2245,'multiline':True]
['text':'costModel','line_number':2247,'multiline':True]
['text':' We should end up with a Sargable node and no residual Filter.','line_number':2252,'multiline':False]
['text':' NOLINT (test auto-update)','line_number':2253,'multiline':False]
['text':' When we have a filter with Get a (Traverse (ComposeM _ (Traverse ...))), we should not','line_number':2271,'multiline':False]
['text':' simplify under the inner Traverse, because MultikeynessTrie contains no information about','line_number':2272,'multiline':False]
['text':' doubly-nested arrays.','line_number':2273,'multiline':False]
['text':' collation','line_number':2304,'multiline':False]
['text':' 'a' is multikey, but 'a.b' is non-multikey.','line_number':2308,'multiline':False]
['text':'isMultiKey','line_number':2311,'multiline':True]
['text':'costModel','line_number':2313,'multiline':True]
['text':' The resulting Filter node should keep all the Traverse nodes:','line_number':2318,'multiline':False]
['text':' - Keep the outermost two because 'a' is multikey.','line_number':2319,'multiline':False]
['text':' - Keep the innermost because we don't know anything about the contents','line_number':2320,'multiline':False]
['text':'   of doubly-nested arrays.','line_number':2321,'multiline':False]
['text':' (We may also get a perfOnly Sargable node; that's not the point of this test.)','line_number':2322,'multiline':False]
['text':' When we have a ComposeM that:','line_number':2355,'multiline':False]
['text':' - cannot be split into a top-level conjunction, and','line_number':2356,'multiline':False]
['text':' - has a sargable predicate on only one side','line_number':2357,'multiline':False]
['text':' then we generate a Sargable node with a perfOnly predicate.','line_number':2358,'multiline':False]
['text':' One side is sargable.','line_number':2369,'multiline':False]
['text':' One side is not sargable.','line_number':2371,'multiline':False]
['text':' A common example is Traverse inside Not: we can't push Not','line_number':2372,'multiline':False]
['text':' to the leaf because Traverse is a disjunction (over array elements).','line_number':2373,'multiline':False]
['text':'costModel','line_number':2395,'multiline':True]
['text':' Construct a query which tests "b" = 1 and "c" = 2.','line_number':2435,'multiline':False]
['text':' We have one index with 2 fields: "a", "b"','line_number':2442,'multiline':False]
['text':'isMultiKey','line_number':2452,'multiline':True]
['text':'costModel','line_number':2453,'multiline':True]
['text':'debugMode','line_number':2454,'multiline':True]
['text':'debugLevel','line_number':2454,'multiline':True]
['text':' As opposed to the test 'DiscardUnboundCandidateIndexInMultiIndexScan', the 'indexNode' should','line_number':2462,'multiline':False]
['text':' still keep its unbound candidate indexes as it is not a multi-index plan.','line_number':2463,'multiline':False]
['text':'*
 * A walker to check if all the sargable nodes have empty candidate index.
 ','line_number':2489,'multiline':True]
['text':'*
     * Returns true if all the SargableNodes in the ABT 'n' have no candidate index.
     ','line_number':2504,'multiline':True]
['text':' Construct a query which tests "b" = 1, "c" = 2, "b1" = 3, "c1" = 4','line_number':2530,'multiline':False]
['text':' We have 2 indexes with 2 fields for each: ("a", "b") and ("a1", "b1")','line_number':2539,'multiline':False]
['text':'isMultiKey','line_number':2549,'multiline':True]
['text':'isMultiKey','line_number':2553,'multiline':True]
['text':'costModel','line_number':2554,'multiline':True]
['text':'debugMode','line_number':2555,'multiline':True]
['text':'debugLevel','line_number':2555,'multiline':True]
['text':' includeRejected ','line_number':2560,'multiline':True]
['text':' Check if all the unbound candidate indexes are discarded during SargableSplit rewrites.','line_number':2562,'multiline':False]
['text':' Construct a query which tests "a" = 1 and "c" = 2 and "e" = 3.','line_number':2575,'multiline':False]
['text':' We have one index with 5 fields: "a", "b", "c", "d", "e".','line_number':2583,'multiline':False]
['text':'isMultiKey','line_number':2596,'multiline':True]
['text':'costModel','line_number':2597,'multiline':True]
['text':'debugMode','line_number':2598,'multiline':True]
['text':'debugLevel','line_number':2598,'multiline':True]
['text':' No plans explored: testing only substitution phase.','line_number':2603,'multiline':False]
['text':' The resulting sargable node is too big to explain in its entirety. We explain the important','line_number':2606,'multiline':False]
['text':' pieces.','line_number':2607,'multiline':False]
['text':' Demonstrate we encode intervals for "a", "c", and "e".','line_number':2610,'multiline':False]
['text':' We have one equality prefix for the first candidate index.','line_number':2626,'multiline':False]
['text':' The first index field ("a") is constrained to 1, the remaining fields are not constrained.','line_number':2629,'multiline':False]
['text':' NOLINT','line_number':2630,'multiline':False]
['text':' No correlated projections.','line_number':2635,'multiline':False]
['text':' First eq prefix begins at index field 0.','line_number':2638,'multiline':False]
['text':' We have two residual predicates for "c" and "e".','line_number':2641,'multiline':False]
['text':' The second candidate index has two equality prefixes.','line_number':2652,'multiline':False]
['text':' The first index field ("a") is again constrained to 1, and the remaining ones are not.','line_number':2655,'multiline':False]
['text':' NOLINT','line_number':2656,'multiline':False]
['text':' Second eq prefix begins at index field 2.','line_number':2661,'multiline':False]
['text':' The first two index fields are constrained to variables obtained from the first scan, the','line_number':2664,'multiline':False]
['text':' third one ("c") is bound to "2". The last two fields are unconstrained.','line_number':2665,'multiline':False]
['text':' NOLINT','line_number':2666,'multiline':False]
['text':' Two correlated projections.','line_number':2672,'multiline':False]
['text':' We have only one residual predicates for "e".','line_number':2675,'multiline':False]
['text':' The third candidate index has three equality prefixes.','line_number':2681,'multiline':False]
['text':' Four correlated projections.','line_number':2684,'multiline':False]
['text':' The first index field ("a") is again constrained to 1.','line_number':2687,'multiline':False]
['text':' NOLINT','line_number':2688,'multiline':False]
['text':' The first two index fields are constrained to variables obtained from the first scan, the','line_number':2693,'multiline':False]
['text':' third one ("c") is bound to "2". The last two fields are unconstrained.','line_number':2694,'multiline':False]
['text':' NOLINT','line_number':2695,'multiline':False]
['text':' The first 4 index fields are constrained to variables from the second scan, and the last one','line_number':2701,'multiline':False]
['text':' to 4.','line_number':2702,'multiline':False]
['text':' NOLINT','line_number':2703,'multiline':False]
['text':' Construct a query which tests coll.find({a: []})','line_number':2713,'multiline':False]
['text':' We have one index on "a".','line_number':2722,'multiline':False]
['text':'costModel','line_number':2727,'multiline':True]
['text':'debugMode','line_number':2728,'multiline':True]
['text':'debugLevel','line_number':2728,'multiline':True]
['text':' NOLINT (test auto-update)','line_number':2732,'multiline':False]
['text':'costModel','line_number':2773,'multiline':True]
['text':' We want to ensure no IsArray calls remain after folding.','line_number':2778,'multiline':False]
['text':' namespace','line_number':2798,'multiline':False]
['text':' namespace mongo::optimizer','line_number':2799,'multiline':False]
