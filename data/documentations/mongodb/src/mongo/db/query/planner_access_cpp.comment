['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':38,'multiline':False]
['text':'*
 * Casts 'node' to a FetchNode* if it is a FetchNode, otherwise returns null.
 ','line_number':107,'multiline':True]
['text':'*
 * If 'node' is an index scan node, casts it to IndexScanNode*. If 'node' is a FetchNode with an
 * IndexScanNode child, then returns a pointer to the child index scan node. Otherwise returns
 * null.
 ','line_number':118,'multiline':True]
['text':'*
 * Takes as input two query solution nodes returned by processIndexScans(). If both are
 * IndexScanNode or FetchNode with an IndexScanNode child and the index scan nodes are identical
 * (same bounds, same filter, same direction, etc.), then returns true. Otherwise returns false.
 ','line_number':137,'multiline':True]
['text':'*
 * If all nodes can provide the requested sort, returns a vector expressing which nodes must have
 * their index scans reversed to provide the sort. Otherwise, returns an empty vector.
 * 'nodes' must not be empty.
 ','line_number':152,'multiline':True]
['text':' namespace','line_number':174,'multiline':False]
['text':'*
 * Extracts the lower and upper bounds on the "ts" field from 'me'. This only examines comparisons
 * of "ts" against a Timestamp at the top level or inside a top-level $and.
 ','line_number':182,'multiline':True]
['text':'*
 * Returns true if 'me' is a GTE or GE predicate over the "ts" field.
 ','line_number':234,'multiline':True]
['text':'*
 * Sets the lowPriority parameter on the given index scan node.
 ','line_number':246,'multiline':True]
['text':' There is a limit with either no sort or the natural sort.','line_number':254,'multiline':False]
['text':' True if the element type is affected by a collator (i.e. it is or contains a String).','line_number':266,'multiline':False]
['text':' Set 'curr' to 'newMin' if 'newMin' < 'curr'','line_number':283,'multiline':False]
['text':' Set 'curr' to 'newMax' if 'newMax' > 'curr'','line_number':290,'multiline':False]
['text':' Set 'curr' to 'newMin' if 'newMin' < 'curr'','line_number':297,'multiline':False]
['text':' Set 'curr' to 'newMax' if 'newMax' > 'curr'','line_number':302,'multiline':False]
['text':' Returns whether element is not affected by collators or query and collection collators are','line_number':307,'multiline':False]
['text':' compatible.','line_number':308,'multiline':False]
['text':' namespace','line_number':315,'multiline':False]
['text':' If either min() or max() were provided, we can assume they are on the cluster key due to the','line_number':328,'multiline':False]
['text':' following.','line_number':329,'multiline':False]
['text':' (1) min() / max() are only legal when they match the pattern in hint()','line_number':330,'multiline':False]
['text':' (2) Only hint() on a cluster key will generate collection scan rather than an index scan','line_number':331,'multiline':False]
['text':' max() is exclusive.','line_number':339,'multiline':False]
['text':' Assumes clustered collection scans are only supported with the forward direction.','line_number':340,'multiline':False]
['text':' NOT inclusive','line_number':343,'multiline':True]
['text':' The min() is inclusive as are bounded collection scans by default.','line_number':347,'multiline':False]
['text':' inclusive','line_number':350,'multiline':True]
['text':' Recursive call on each branch of 'andMatchPtr'.','line_number':369,'multiline':False]
['text':' If one of the conjuncts excludes values of the cluster key which are affected by','line_number':380,'multiline':False]
['text':' collation, then the entire $and will also exclude those values.','line_number':381,'multiline':False]
['text':' If 'conjunct' does not apply to the cluster key, return early here, as updating bounds based','line_number':385,'multiline':False]
['text':' on this conjunct is incorrect and can result in garbage bounds.','line_number':386,'multiline':False]
['text':' TODO SERVER-62707: Allow $in with regex to use a clustered index.','line_number':391,'multiline':False]
['text':' Iterate through the $in equalities to find the min/max values. The min/max bounds for the','line_number':394,'multiline':False]
['text':' collscan need to be loose enough to cover all of these values.','line_number':395,'multiline':False]
['text':' Set coarse min/max bounds based on type when we can't set tight bounds.','line_number':406,'multiline':False]
['text':' {min,max}RecordId will bound the range of ids scanned to the highest and lowest present','line_number':419,'multiline':False]
['text':' in the InMatchExpression, but the filter is still required to filter to _exactly_ the','line_number':420,'multiline':False]
['text':' requested matches.','line_number':421,'multiline':False]
['text':' Finally, tighten the collscan bounds with the min/max bounds for the $in.','line_number':423,'multiline':False]
['text':' Not a comparison match expression.','line_number':430,'multiline':False]
['text':' Internal comparisons e.g., $_internalExprGt do _not_ carry type bracketing','line_number':436,'multiline':False]
['text':' semantics (consistent with `$expr{$gt:[a,b]}`).','line_number':437,'multiline':False]
['text':' For other comparisons which _do_ perform type bracketing, the RecordId bounds','line_number':438,'multiline':False]
['text':' may be tightened here.','line_number':439,'multiline':False]
['text':' inclusive ','line_number':442,'multiline':True]
['text':' inclusive ','line_number':446,'multiline':True]
['text':' Collator affects probe and it's not compatible with collection's collator.','line_number':451,'multiline':False]
['text':' Even if the collations don't match at this point, it's fine,','line_number':455,'multiline':False]
['text':' because the bounds exclude values that use it.','line_number':456,'multiline':False]
['text':' inclusive ','line_number':462,'multiline':True]
['text':' inclusive ','line_number':463,'multiline':True]
['text':' EXclusive ','line_number':467,'multiline':True]
['text':' inclusive ','line_number':471,'multiline':True]
['text':' EXclusive ','line_number':475,'multiline':True]
['text':' inclusive ','line_number':479,'multiline':True]
['text':' This expr is _not_ redundant, it could not be re-expressed via {min,max} record','line_number':482,'multiline':False]
['text':' Report that this expression does not need to be retained in the filter','line_number':485,'multiline':False]
['text':' _if_ recordRange is enforced - {min,max}Record will already apply equivalent','line_number':486,'multiline':False]
['text':' limits.','line_number':487,'multiline':False]
['text':' The recursive calls may have nulled some children; remove them from the','line_number':503,'multiline':False]
['text':' conjunction.','line_number':504,'multiline':False]
['text':' Removing redundant children may have made this conjunct trivially true in turn;','line_number':508,'multiline':False]
['text':' reset it.','line_number':509,'multiline':False]
['text':' Simplifying the filter might remove everything; filter can't be left','line_number':519,'multiline':False]
['text':' null, so populate with a trivially true expression.','line_number':520,'multiline':False]
['text':' The following are expensive to look up, so only do it once for each.','line_number':532,'multiline':False]
['text':' Make the (only) node, a collection scan.','line_number':537,'multiline':False]
['text':' If we have a natural hint and a time series traversal preference, let the traversal','line_number':557,'multiline':False]
['text':' preference decide what order to scan, so that we can avoid a blocking sort.','line_number':558,'multiline':False]
['text':' If the hint is {$natural: +-1} this changes the direction of the collection scan.','line_number':560,'multiline':False]
['text':' If the client requested a resume token and we are scanning the oplog, prepare','line_number':565,'multiline':False]
['text':' the collection scan to return timestamp-based tokens. Otherwise, we should','line_number':566,'multiline':False]
['text':' return generic RecordId-based tokens.','line_number':567,'multiline':False]
['text':' Extract and assign the RecordId from the 'resumeAfter' token, if present.','line_number':573,'multiline':False]
['text':' Takes Timestamp 'ts' as input, transforms it to the RecordIdBound and assigns it to the','line_number':583,'multiline':False]
['text':' output parameter 'recordId'. The RecordId format for the change collection is a string,','line_number':584,'multiline':False]
['text':' where as the RecordId format for the oplog is a long integer. The timestamp should be','line_number':585,'multiline':False]
['text':' converted to the required format before assigning it to the 'recordId'.','line_number':586,'multiline':False]
['text':' Optimizes the start and end location parameters for a collection scan for an oplog','line_number':595,'multiline':False]
['text':' collection. Not compatible with $_resumeAfter so we do not optimize in that case.','line_number':596,'multiline':False]
['text':' If the query is just a lower bound on "ts" on a forward scan, every document in the','line_number':610,'multiline':False]
['text':' collection after the first matching one must also match. To avoid wasting time','line_number':611,'multiline':False]
['text':' running the match expression on every document to be returned, we tell the','line_number':612,'multiline':False]
['text':' CollectionScan stage to stop applying the filter once it finds the first match.','line_number':613,'multiline':False]
['text':' The user may have requested 'assertMinTsHasNotFallenOffOplog' for a query that does not','line_number':619,'multiline':False]
['text':' specify a minimum timestamp. This is not a valid request, so we throw InvalidOptions.','line_number':620,'multiline':False]
['text':' If collation _exactly_ matches, it is safe to drop expressions from the filter which can be','line_number':632,'multiline':False]
['text':' entirely encoded as a {min,max}Record.','line_number':633,'multiline':False]
['text':' handleRIDRangeScan later updates hasCompatibleCollation if the filter restricts the id range','line_number':634,'multiline':False]
['text':' to values unaffected by collation e.g., numbers. This is insufficient to allow the filter to','line_number':635,'multiline':False]
['text':' be safely modified; a query which has compatible collation _given the current filter args_','line_number':636,'multiline':False]
['text':' could be cached and reused for a query with different args which _are_ affected by collation.','line_number':637,'multiline':False]
['text':' This is a clustered collection. Attempt to perform an efficient, bounded collection scan','line_number':642,'multiline':False]
['text':' via minRecord and maxRecord if applicable. During this process, we will check if the','line_number':643,'multiline':False]
['text':' query is guaranteed to exclude values of the cluster key which are affected by collation.','line_number':644,'multiline':False]
['text':' If so, then even if the query and collection collations differ, the collation difference','line_number':645,'multiline':False]
['text':' won't affect the query results. In that case, we can say hasCompatibleCollation is true.','line_number':646,'multiline':False]
['text':' min/max records may have been set if oplog or change collection.','line_number':649,'multiline':False]
['text':' makeCollectionScan','line_number':674,'multiline':False]
['text':' We're guaranteed that all GEO_NEARs are first.  This slightly violates the "sort index','line_number':683,'multiline':False]
['text':' predicates by their position in the compound index" rule but GEO_NEAR isn't an ixscan.','line_number':684,'multiline':False]
['text':' This saves our bacon when we have {foo: 1, bar: "2dsphere"} and the predicate on bar is a','line_number':685,'multiline':False]
['text':' $near.  If we didn't get the GEO_NEAR first we'd create an IndexScanNode and later cast','line_number':686,'multiline':False]
['text':' it to a GeoNear2DSphereNode','line_number':687,'multiline':False]
['text':'','line_number':688,'multiline':False]
['text':' This should gracefully deal with the case where we have a pred over foo but no geo clause','line_number':689,'multiline':False]
['text':' over bar.  In that case there is no GEO_NEAR to appear first and it's treated like a','line_number':690,'multiline':False]
['text':' straight ixscan.','line_number':691,'multiline':False]
['text':' We must not keep the expression node around.','line_number':694,'multiline':False]
['text':' We must not keep the expression node around.','line_number':719,'multiline':False]
['text':' Count the number of prefix fields before the "text" field.','line_number':726,'multiline':False]
['text':' We know that the only key pattern with a type of String is the _fts field','line_number':728,'multiline':False]
['text':' which is immediately after all prefix fields.','line_number':729,'multiline':False]
['text':' Note that indexKeyPattern.firstElement().fieldName() may not equal expr->path()','line_number':738,'multiline':False]
['text':' because expr might be inside an array operator that provides a path prefix.','line_number':739,'multiline':False]
['text':' Get the ixtag->pos-th element of the index key pattern.','line_number':745,'multiline':False]
['text':' TODO: cache this instead/with ixtag->pos?','line_number':746,'multiline':False]
['text':'','line_number':784,'multiline':False]
['text':' First handle special solution tree leaf types. In general, normal index bounds','line_number':785,'multiline':False]
['text':' building is not used for special leaf types, and hence we cannot merge leaves.','line_number':786,'multiline':False]
['text':'','line_number':787,'multiline':False]
['text':' This rule is always true for OR, but there are exceptions for AND.','line_number':788,'multiline':False]
['text':' Specifically, we can often merge a predicate with a special leaf type','line_number':789,'multiline':False]
['text':' by adding a filter to the special leaf type.','line_number':790,'multiline':False]
['text':'','line_number':791,'multiline':False]
['text':' Currently only one text predicate is allowed, but to be safe, make sure that we','line_number':794,'multiline':False]
['text':' do not try to merge two text predicates.','line_number':795,'multiline':False]
['text':' Currently only one GEO_NEAR is allowed, but to be safe, make sure that we','line_number':800,'multiline':False]
['text':' do not try to merge two GEO_NEAR predicates.','line_number':801,'multiline':False]
['text':'','line_number':805,'multiline':False]
['text':' If we're here, then we're done checking for special leaf nodes, and the leaf','line_number':806,'multiline':False]
['text':' must be a regular index scan.','line_number':807,'multiline':False]
['text':'','line_number':808,'multiline':False]
['text':' Bounds have yet to be assigned for the 'pos' position in the index. The plan enumerator','line_number':815,'multiline':False]
['text':' should have told us that it is safe to compound bounds in this case.','line_number':816,'multiline':False]
['text':' Bounds have already been assigned for the 'pos' position in the index.','line_number':820,'multiline':False]
['text':' The bounds on the 'pos' position in the index would be intersected if we merged these','line_number':822,'multiline':False]
['text':' two leaf expressions.','line_number':823,'multiline':False]
['text':' If the plan enumerator told us that it isn't safe to intersect bounds in this','line_number':825,'multiline':False]
['text':' case, then it must be because we're using a multikey index.','line_number':826,'multiline':False]
['text':' The bounds will be unionized.','line_number':831,'multiline':False]
['text':' This predicate is assigned to one of the prefix fields of the text index. Such','line_number':851,'multiline':False]
['text':' predicates must always be equalities and must always be attached to the TEXT node. In','line_number':852,'multiline':False]
['text':' order to ensure this happens, we assign INEXACT_COVERED tightness.','line_number':853,'multiline':False]
['text':' The predicate is assigned to one of the trailing fields of the text index. We','line_number':856,'multiline':False]
['text':' currently don't generate bounds for predicates assigned to trailing fields of a text','line_number':857,'multiline':False]
['text':' index, but rather attempt to attach a covered filter. However, certain predicates can','line_number':858,'multiline':False]
['text':' never be correctly covered (e.g. $exists), so we assign the tightness accordingly.','line_number':859,'multiline':False]
['text':' 2D indexes have a special format - the "2d" field stores a normally-indexed BinData','line_number':873,'multiline':False]
['text':' field, but additional array fields are *not* exploded into multi-keys - they are stored','line_number':874,'multiline':False]
['text':' directly as arrays in the index.  Also, no matter what the index expression, the "2d"','line_number':875,'multiline':False]
['text':' field is always first.','line_number':876,'multiline':False]
['text':'','line_number':877,'multiline':False]
['text':' This means that we can only generically accumulate bounds for 2D indexes over the first','line_number':878,'multiline':False]
['text':' "2d" field (pos == 0) - MatchExpressions over other fields in the 2D index may be covered','line_number':879,'multiline':False]
['text':' (can be evaluated using only the 2D index key).  The additional fields must not affect','line_number':880,'multiline':False]
['text':' the index scan bounds, since they are not stored in an IndexScan-compatible format.','line_number':881,'multiline':False]
['text':' The predicate is over a trailing field of the "2d" index. If possible, we assign it','line_number':884,'multiline':False]
['text':' as a covered filter (the INEXACT_COVERED case). Otherwise, the filter must be','line_number':885,'multiline':False]
['text':' evaluated after fetching the full documents.','line_number':886,'multiline':False]
['text':' We may have other $geoPredicates on a near index - generate bounds for these','line_number':893,'multiline':False]
['text':' See STAGE_GEO_NEAR_2D above - 2D indexes can only accumulate scan bounds over the first','line_number':903,'multiline':False]
['text':' "2d" field (pos == 0).','line_number':904,'multiline':False]
['text':' The predicate is over a trailing field of the "2d" index. If possible, we assign it','line_number':906,'multiline':False]
['text':' as a covered filter (the INEXACT_COVERED case). Otherwise, the filter must be','line_number':907,'multiline':False]
['text':' evaluated after fetching the full documents.','line_number':908,'multiline':False]
['text':' Get the ixtag->pos-th element of the index key pattern.','line_number':918,'multiline':False]
['text':' TODO: cache this instead/with ixtag->pos?','line_number':919,'multiline':False]
['text':' If we're unable to cast to FTSQueryImpl, then the given query must be an FTSQueryNoop, which','line_number':954,'multiline':False]
['text':' is only used for testing the QueryPlanner and never tries to execute the query, so we don't','line_number':955,'multiline':False]
['text':' need to construct an entire text sub-plan. Moreover, to compute index bounds we need a list','line_number':956,'multiline':False]
['text':' of terms, which can only be obtain from FTSQueryImpl.','line_number':957,'multiline':False]
['text':' If the query requires the "textScore" field or involves multiple search terms, a TEXT_OR or','line_number':962,'multiline':False]
['text':' OR stage is needed. Otherwise, we can use a single index scan directly.','line_number':963,'multiline':False]
['text':' Get all the index scans for each term in our query.','line_number':972,'multiline':False]
['text':' If we will be adding a TEXT_OR or OR stage, then it is responsible for applying the','line_number':986,'multiline':False]
['text':' filter. Otherwise, the index scan applies the filter.','line_number':987,'multiline':False]
['text':' In case the query didn't have any search term, we can simply use an EOF sub-plan, as no','line_number':995,'multiline':False]
['text':' results can be returned in this case anyway.','line_number':996,'multiline':False]
['text':' Build the union of the index scans as a TEXT_OR or an OR stage, depending on whether the','line_number':1001,'multiline':False]
['text':' projection requires the "textScore" $meta field.','line_number':1002,'multiline':False]
['text':' We use a TEXT_OR stage to get the union of the results from the index scans and then','line_number':1004,'multiline':False]
['text':' compute their text scores. This is a blocking operation.','line_number':1005,'multiline':False]
['text':' Because we don't need the text score, we can use a non-blocking OR stage to get the union','line_number':1011,'multiline':False]
['text':' of the index scans or use the index scan directly if there is only one.','line_number':1012,'multiline':False]
['text':' Unlike the TEXT_OR stage, the OR stage does not fetch the documents that it outputs. We','line_number':1028,'multiline':False]
['text':' add our own FETCH stage to satisfy the requirement of the TEXT_MATCH stage that its','line_number':1029,'multiline':False]
['text':' WorkingSetMember inputs have fetched data.','line_number':1030,'multiline':False]
['text':' If there's no prefix, the filter is already on the node and the index prefix is null.','line_number':1041,'multiline':False]
['text':' We can just return.','line_number':1042,'multiline':False]
['text':' We can't create a text stage if there aren't EQ predicates on its prefix terms.  So','line_number':1048,'multiline':False]
['text':' if we've made it this far, we should have collected the prefix predicates in the','line_number':1049,'multiline':False]
['text':' filter.','line_number':1050,'multiline':False]
['text':' Only one prefix term.','line_number':1057,'multiline':False]
['text':' Sanity check: must be an EQ.','line_number':1059,'multiline':False]
['text':' Indexed by the keyPattern position index assignment.  We want to add','line_number':1068,'multiline':False]
['text':' prefixes in order but we must order them first.','line_number':1069,'multiline':False]
['text':' Look through the AND children.  The prefix children we want to','line_number':1075,'multiline':False]
['text':' stash in prefixExprs.','line_number':1076,'multiline':False]
['text':' Skip this child if it's not part of a prefix, or if we've already assigned a','line_number':1081,'multiline':False]
['text':' predicate to this prefix position.','line_number':1082,'multiline':False]
['text':' Don't increment curChild.','line_number':1089,'multiline':False]
['text':' Go through the prefix equalities in order and create an index prefix out of them.','line_number':1092,'multiline':False]
['text':' Clear out an empty $and.','line_number':1101,'multiline':False]
['text':' Clear out unsightly only child of $and.','line_number':1105,'multiline':False]
['text':' Deletes current filter which is amExpr.','line_number':1108,'multiline':False]
['text':' In order to correctly evaluate the predicates for this index, we have to','line_number':1138,'multiline':False]
['text':' fetch the full documents. Add a fetch node above the index scan whose filter','line_number':1139,'multiline':False]
['text':' includes *all* of the predicates used to generate the ixscan.','line_number':1140,'multiline':False]
['text':' Takes ownership.','line_number':1142,'multiline':False]
['text':' Takes ownership.','line_number':1144,'multiline':False]
['text':' This an OR, at least one of the predicates used to generate 'currentScan'','line_number':1149,'multiline':False]
['text':' is inexact covered, but none is inexact fetch. This means that we can put','line_number':1150,'multiline':False]
['text':' these predicates, joined by an $or, as filters on the index scan. This avoids','line_number':1151,'multiline':False]
['text':' a fetch and allows the predicates to be covered by the index.','line_number':1152,'multiline':False]
['text':'','line_number':1153,'multiline':False]
['text':' Ex.','line_number':1154,'multiline':False]
['text':'   Say we have index {a: 1} and query {$or: [{a: /foo/}, {a: /bar/}]}.','line_number':1155,'multiline':False]
['text':'   The entire query, {$or: [{a: /foo/}, {a: /bar/}]}, should be a filter','line_number':1156,'multiline':False]
['text':'   in the index scan stage itself.','line_number':1157,'multiline':False]
['text':' If this is a $** index, update and populate the keyPattern, bounds, and multikeyPaths.','line_number':1192,'multiline':False]
['text':' Find the first field in the scan's bounds that was not filled out.','line_number':1198,'multiline':False]
['text':' TODO: could cache this.','line_number':1199,'multiline':False]
['text':' Process a case when some fields are not filled out with bounds.','line_number':1208,'multiline':False]
['text':' Skip ahead to the firstEmptyField-th element, where we begin filling in bounds.','line_number':1210,'multiline':False]
['text':' For each field in the key...','line_number':1217,'multiline':False]
['text':' There may be filled-in fields to the right of the firstEmptyField; for instance, the','line_number':1220,'multiline':False]
['text':' index {loc:"2dsphere", x:1} with a predicate over x and a near search over loc.','line_number':1221,'multiline':False]
['text':' Make sure that the length of the key is the length of the bounds we started.','line_number':1229,'multiline':False]
['text':' Build Interval Evaluation Trees used to restore index bounds from cached SBE Plans.','line_number':1233,'multiline':False]
['text':' We create bounds assuming a forward direction but can easily reverse bounds to align','line_number':1251,'multiline':False]
['text':' according to our desired direction.','line_number':1252,'multiline':False]
['text':' Scans that need to be collapsed will be adjacent to each other in the list due to how we','line_number':1276,'multiline':False]
['text':' sort the query predicate. We step through the list, either merging the current scan into','line_number':1277,'multiline':False]
['text':' the last scan in 'collapsedScans', or adding a new entry to 'collapsedScans' if it can't','line_number':1278,'multiline':False]
['text':' be merged.','line_number':1279,'multiline':False]
['text':' We collapse the entry from 'ownedScans' into the back of 'collapsedScans'.','line_number':1285,'multiline':False]
['text':' If there's no filter associated with a fetch node on 'collapseFrom', all we have to','line_number':1290,'multiline':False]
['text':' do is clear the filter on the node that we are collapsing into.','line_number':1291,'multiline':False]
['text':' If there's no filter associated with a fetch node on the back of the 'collapsedScans'','line_number':1299,'multiline':False]
['text':' list, then there's nothing more to do.','line_number':1300,'multiline':False]
['text':' Both the 'from' and 'into' nodes have filters. We join them with an','line_number':1305,'multiline':False]
['text':' OrMatchExpression.','line_number':1306,'multiline':False]
['text':' Normalize the filter and add it to 'into'.','line_number':1312,'multiline':False]
['text':' enableSimplification ','line_number':1314,'multiline':True]
['text':' Scans are not equivalent and can't be collapsed.','line_number':1316,'multiline':False]
['text':'*
 * This helper determines if a query can be covered depending on the query projection.
 ','line_number':1325,'multiline':True]
['text':' This optimization can only be used for find when the index covers the projection completely.','line_number':1333,'multiline':False]
['text':' However, if the indexed field is in the projection, the index may return an incorrect value','line_number':1334,'multiline':False]
['text':' for the field, since it does not distinguish between null and undefined (and the empty list,','line_number':1335,'multiline':False]
['text':' in the multikey case). Hence, only find queries projecting _id are covered.','line_number':1336,'multiline':False]
['text':' We can cover projections on _id and generated fields and expressions depending only on _id.','line_number':1342,'multiline':False]
['text':' However, if the projection is an exclusion, requires match details, requires the full','line_number':1343,'multiline':False]
['text':' document, or requires metadata, we will still need a FETCH stage.','line_number':1344,'multiline':False]
['text':' Note that it is not possible to project onto dotted paths of _id here, since they may be','line_number':1348,'multiline':False]
['text':' null or missing, and the index cannot differentiate between the two cases, so we would','line_number':1349,'multiline':False]
['text':' still need a FETCH stage.','line_number':1350,'multiline':False]
['text':'*
 * This helper updates a MAYBE_COVERED query tightness to one of EXACT, INEXACT_COVERED, or
 * INEXACT_FETCH, depending on whether we need a FETCH/filter to answer the query projection.
 ','line_number':1359,'multiline':True]
['text':' We need to refine the tightness in case we have a "MAYBE_COVERED" tightness bound which','line_number':1365,'multiline':False]
['text':' depends on the query's projection. We will not have information about the projection','line_number':1366,'multiline':False]
['text':' later on in order to make this determination, so we do it here.','line_number':1367,'multiline':False]
['text':' Initialize the ScanBuildingState.','line_number':1390,'multiline':False]
['text':' If there is no tag, it's not using an index.  We've sorted our children such that the','line_number':1396,'multiline':False]
['text':' children with tags are first, so we stop now.','line_number':1397,'multiline':False]
['text':' If there's a tag it must be valid.','line_number':1403,'multiline':False]
['text':' If the child can't use an index on its own field (and the child is not a negation','line_number':1406,'multiline':False]
['text':' of a bounds-generating expression), then it's indexed by virtue of one of','line_number':1407,'multiline':False]
['text':' its children having an index.','line_number':1408,'multiline':False]
['text':'','line_number':1409,'multiline':False]
['text':' NOTE: If the child is logical, it could possibly collapse into a single ixscan.  we','line_number':1410,'multiline':False]
['text':' ignore this for now.','line_number':1411,'multiline':False]
['text':' If we're here, then the child is indexed by virtue of its children.','line_number':1413,'multiline':False]
['text':' In most cases this means that we recursively build indexed data','line_number':1414,'multiline':False]
['text':' access on 'child'.','line_number':1415,'multiline':False]
['text':' If we're here, we now know that 'child' can use an index directly and the index is','line_number':1422,'multiline':False]
['text':' over the child's field.','line_number':1423,'multiline':False]
['text':' If 'child' is a NOT, then the tag we're interested in is on the NOT's','line_number':1425,'multiline':False]
['text':' child node.','line_number':1426,'multiline':False]
['text':' If the child we're looking at uses a different index than the current index scan, add','line_number':1432,'multiline':False]
['text':' the current index scan to the output as we're done with it.  The index scan created','line_number':1433,'multiline':False]
['text':' by the child then becomes our new current index scan.  Note that the current scan','line_number':1434,'multiline':False]
['text':' could be NULL, in which case we don't output it.  The rest of the logic is identical.','line_number':1435,'multiline':False]
['text':'','line_number':1436,'multiline':False]
['text':' If the child uses the same index as the current index scan, we may be able to merge','line_number':1437,'multiline':False]
['text':' the bounds for the two scans.','line_number':1438,'multiline':False]
['text':'','line_number':1439,'multiline':False]
['text':' Guiding principle: must the values we're testing come from the same array in the','line_number':1440,'multiline':False]
['text':' document?  If so, we can combine bounds (via intersection or compounding).  If not,','line_number':1441,'multiline':False]
['text':' we can't.','line_number':1442,'multiline':False]
['text':'','line_number':1443,'multiline':False]
['text':' If the index is NOT multikey, it's always semantically correct to combine bounds,','line_number':1444,'multiline':False]
['text':' as there are no arrays to worry about.','line_number':1445,'multiline':False]
['text':'','line_number':1446,'multiline':False]
['text':' If the index is multikey, there are arrays of values.  There are several','line_number':1447,'multiline':False]
['text':' complications in the multikey case that have to be obeyed both by the enumerator','line_number':1448,'multiline':False]
['text':' and here as we try to merge predicates into query solution leaves. The hairy','line_number':1449,'multiline':False]
['text':' details of these rules are documented near the top of planner_access.h.','line_number':1450,'multiline':False]
['text':' The child uses the same index we're currently building a scan for.  Merge','line_number':1452,'multiline':False]
['text':' the bounds and filters.','line_number':1453,'multiline':False]
['text':' Output the current scan before starting to construct a new out.','line_number':1461,'multiline':False]
['text':' Reset state before producing a new leaf.','line_number':1467,'multiline':False]
['text':' If the index is partial and we have reached children without index tag, check if they are','line_number':1482,'multiline':False]
['text':' covered by the index' filter expression. In this case the child can be removed. In some cases','line_number':1483,'multiline':False]
['text':' this enables to remove the fetch stage from the plan.','line_number':1484,'multiline':False]
['text':' The check could be put inside the 'handleFilterAnd()' function, but if moved then the','line_number':1485,'multiline':False]
['text':' optimization will not be applied if the predicate contains an $elemMatch expression, since','line_number':1486,'multiline':False]
['text':' then the 'handleFilterAnd()' is not called.','line_number':1487,'multiline':False]
['text':' When the documents satisfying the index filter predicate are a subset of the','line_number':1494,'multiline':False]
['text':' documents satisfying the child expression, the child predicate is redundant.','line_number':1495,'multiline':False]
['text':' Remove the child from the root's children.','line_number':1496,'multiline':False]
['text':' For example: index on 'a' with a filter {$and: [{a: {$gt: 10}}, {b: {$lt:','line_number':1497,'multiline':False]
['text':' 100}}]} and a query predicate {$and: [{a: {$gt: 20}}, {b: {$lt: 100}}]}. The','line_number':1498,'multiline':False]
['text':' non-indexed child {b: {$lt: 100}} is always satisfied by the index filter and','line_number':1499,'multiline':False]
['text':' can be removed.','line_number':1500,'multiline':False]
['text':' In case of index filter predicate with $or, this optimization is not','line_number':1502,'multiline':False]
['text':' applicable, since the subset relationship doesn't hold.','line_number':1503,'multiline':False]
['text':' For example, an index on field 'c' with a filter expression {$or: [{a: {$gt:','line_number':1504,'multiline':False]
['text':' 10}}, {b: {$lt: 100}}]} could be applicable for the query with a predicate','line_number':1505,'multiline':False]
['text':' {$and: [{c: {$gt: 100}}, {b: {$lt: 100}}]}, but the predicate will not be','line_number':1506,'multiline':False]
['text':' removed.','line_number':1507,'multiline':False]
['text':' Output the scan we're done with, if it exists.','line_number':1518,'multiline':False]
['text':' We have an AND with an ELEM_MATCH_OBJECT child. The plan enumerator produces','line_number':1535,'multiline':False]
['text':' index taggings which indicate that we should try to compound with','line_number':1536,'multiline':False]
['text':' predicates retrieved from inside the subtree rooted at the ELEM_MATCH.','line_number':1537,'multiline':False]
['text':' In order to obey the enumerator's tagging, we need to retrieve these','line_number':1538,'multiline':False]
['text':' predicates from inside the $elemMatch, and try to merge them with','line_number':1539,'multiline':False]
['text':' the current index scan.','line_number':1540,'multiline':False]
['text':' Contains tagged predicates from inside the tree rooted at 'child'','line_number':1542,'multiline':False]
['text':' which are logically part of the AND.','line_number':1543,'multiline':False]
['text':' Contains tagged nodes that are not logically part of the AND and','line_number':1546,'multiline':False]
['text':' cannot use the index directly (e.g. OR nodes which are tagged to','line_number':1547,'multiline':False]
['text':' be indexed).','line_number':1548,'multiline':False]
['text':' Populate 'emChildren' and 'emSubnodes'.','line_number':1551,'multiline':False]
['text':' Recursively build data access for the nodes inside 'emSubnodes'.','line_number':1554,'multiline':False]
['text':' 'subnode' is beneath an $elemMatch. When planning the children of array operators, we','line_number':1559,'multiline':False]
['text':' keep ownership of the match expression node. Therefore, we pass nullptr for the','line_number':1560,'multiline':False]
['text':' 'ownedRoot' argument.','line_number':1561,'multiline':False]
['text':' _buildIndexedDataAccess(...) returns NULL in error conditions, when it is unable to','line_number':1564,'multiline':False]
['text':' construct a query solution from a tagged match expression tree. If we are unable to','line_number':1565,'multiline':False]
['text':' construct a solution according to the instructions from the enumerator, then we bail','line_number':1566,'multiline':False]
['text':' out early (by returning false) rather than continuing on and potentially constructing','line_number':1567,'multiline':False]
['text':' an invalid solution tree.','line_number':1568,'multiline':False]
['text':' Output the resulting solution tree.','line_number':1573,'multiline':False]
['text':' For each predicate in 'emChildren', try to merge it with the current index scan.','line_number':1578,'multiline':False]
['text':'','line_number':1579,'multiline':False]
['text':' This loop is similar to that in processIndexScans(...), except it does not call into','line_number':1580,'multiline':False]
['text':' handleFilters(...). Instead, we leave the entire $elemMatch filter intact. This way,','line_number':1581,'multiline':False]
['text':' the complete $elemMatch expression will be affixed as a filter later on.','line_number':1582,'multiline':False]
['text':' If 'emChild' is a NOT, then the tag we're interested in is on the NOT's','line_number':1588,'multiline':False]
['text':' child node.','line_number':1589,'multiline':False]
['text':' The child uses the same index we're currently building a scan for.  Merge','line_number':1597,'multiline':False]
['text':' the bounds and filters.','line_number':1598,'multiline':False]
['text':' Reset state before producing a new leaf.','line_number':1610,'multiline':False]
['text':' We're done processing the $elemMatch child. We leave it hanging off','line_number':1622,'multiline':False]
['text':' it's AND parent so that it will be affixed as a filter later on,','line_number':1623,'multiline':False]
['text':' and move on to the next child of the AND.','line_number':1624,'multiline':False]
['text':' We may detach the current child from the tree and assume ownership.','line_number':1639,'multiline':False]
['text':' The logical sub-tree is responsible for fully evaluating itself. Any required filters or','line_number':1646,'multiline':False]
['text':' fetches are already hung on it. As such, we remove the filter branch from our tree and','line_number':1647,'multiline':False]
['text':' assume ownership of it.','line_number':1648,'multiline':False]
['text':' If inArrayOperator: takes ownership of child, which is OK, since we detached','line_number':1655,'multiline':False]
['text':' child from root.','line_number':1656,'multiline':False]
['text':' Clone the match expression before passing it to processIndexScans(), as it may trim','line_number':1672,'multiline':False]
['text':' predicates. If we end up with an index intersection solution, then we use our copy of the','line_number':1673,'multiline':False]
['text':' match expression to be sure that the FETCH stage will recheck the entire predicate. It is not','line_number':1674,'multiline':False]
['text':' correct to trim predicates for index intersection plans, as this can lead to spurious matches','line_number':1675,'multiline':False]
['text':' (see SERVER-16750).','line_number':1676,'multiline':False]
['text':'','line_number':1685,'multiline':False]
['text':' Process all non-indexed predicates.  We hang these above the AND with a fetch and','line_number':1686,'multiline':False]
['text':' filter.','line_number':1687,'multiline':False]
['text':'','line_number':1688,'multiline':False]
['text':' This is the node we're about to return.','line_number':1690,'multiline':False]
['text':' We must use an index for at least one child of the AND.  We shouldn't be here if this','line_number':1693,'multiline':False]
['text':' isn't the case.','line_number':1694,'multiline':False]
['text':' Short-circuit: an AND of one child is just the child.','line_number':1697,'multiline':False]
['text':' If we get here, we have a compound wildcard index which can answer one or more of the','line_number':1701,'multiline':False]
['text':' predicates in the $and, but we also have at least one additional node attached to the','line_number':1702,'multiline':False]
['text':' filter. Normally, we would be able to satisfy this case using a FETCH + FILTER +','line_number':1703,'multiline':False]
['text':' IXSCAN; however, in the case of a $not query which is not supported by the index, the','line_number':1704,'multiline':False]
['text':' index entry will be expanded in such a way that we won't be able to satisfy the','line_number':1705,'multiline':False]
['text':' query.','line_number':1706,'multiline':False]
['text':' $** indexes are prohibited from participating in either AND_SORTED or AND_HASH.','line_number':1711,'multiline':False]
['text':' Figure out if we want AndHashNode or AndSortedNode.','line_number':1721,'multiline':False]
['text':' The AndHashNode provides the sort order of its last child.  If any of the','line_number':1740,'multiline':False]
['text':' possible subnodes of AndHashNode provides the sort order we care about, we put','line_number':1741,'multiline':False]
['text':' that one last.','line_number':1742,'multiline':False]
['text':' We can't use sort-based intersection, and hash-based intersection is disabled.','line_number':1752,'multiline':False]
['text':' Clean up the index scans and bail out by returning NULL.','line_number':1753,'multiline':False]
['text':' Don't bother doing any kind of fetch analysis lite if we're doing it anyway above us.','line_number':1762,'multiline':False]
['text':' We got an index intersection solution, so we aren't allowed to answer predicates exactly','line_number':1768,'multiline':False]
['text':' using the index. This is because the index intersection stage finds documents that match','line_number':1769,'multiline':False]
['text':' each index's predicate, but the document isn't guaranteed to be in a state where it','line_number':1770,'multiline':False]
['text':' matches all indexed predicates simultaneously. Therefore, it is necessary to add a fetch','line_number':1771,'multiline':False]
['text':' stage which will explicitly evaluate the entire predicate (see SERVER-16750).','line_number':1772,'multiline':False]
['text':' If there are any nodes still attached to the AND, we can't answer them using the','line_number':1780,'multiline':False]
['text':' index, so we put a fetch with filter.','line_number':1781,'multiline':False]
['text':' An $and of one thing is that thing.','line_number':1786,'multiline':False]
['text':' 'autoRoot' will delete the empty $and.','line_number':1789,'multiline':False]
['text':' root->numChildren() > 1','line_number':1790,'multiline':False]
['text':' Takes ownership.','line_number':1791,'multiline':False]
['text':' takes ownership','line_number':1794,'multiline':False]
['text':' root has no children, let autoRoot get rid of it when it goes out of scope.','line_number':1798,'multiline':False]
['text':' Check if we can use a CLUSTERED_IXSCAN on the remaining children if they have no plans.','line_number':1818,'multiline':False]
['text':' Since, the only clustered index currently supported is on '_id' if we are in an array','line_number':1819,'multiline':False]
['text':' operator, we know we won't make clustered collection scans.','line_number':1820,'multiline':False]
['text':' Confirm the collection scan node is a clustered collection scan.','line_number':1832,'multiline':False]
['text':' Caching OR queries with collection scans is restricted, since it is challenging','line_number':1838,'multiline':False]
['text':' to determine which match expressions from the input query require a clustered','line_number':1839,'multiline':False]
['text':' collection scan. Therefore, we cannot correctly calculate the correct bounds for','line_number':1840,'multiline':False]
['text':' the query using the cached plan.','line_number':1841,'multiline':False]
['text':' Erase child from root.','line_number':1844,'multiline':False]
['text':' If we have a clustered collection scan, then all index scan stages must be wrapped inside','line_number':1849,'multiline':False]
['text':' a 'FETCH'. This is to avoid having an unnecessary collection scan node inside a 'FETCH',','line_number':1850,'multiline':False]
['text':' since the documents will already be fetched.','line_number':1851,'multiline':False]
['text':' TODO SERVER-77867 investigate when we can avoid adding this 'FETCH' stage.','line_number':1852,'multiline':False]
['text':' Unlike an AND, an OR cannot have filters hanging off of it.  We stop processing','line_number':1862,'multiline':False]
['text':' when any of our children lack index tags.  If a node lacks an index tag it cannot','line_number':1863,'multiline':False]
['text':' be answered via an index.','line_number':1864,'multiline':False]
['text':' We won't enumerate an OR without indices for each child, so this isn't an issue, even','line_number':1867,'multiline':False]
['text':' if we have an AND with an OR child -- we won't get here unless the OR is fully','line_number':1868,'multiline':False]
['text':' indexed.','line_number':1869,'multiline':False]
['text':' If all index scans are identical, then we collapse them into a single scan. This prevents','line_number':1877,'multiline':False]
['text':' us from creating OR plans where the branches of the OR perform duplicate work.','line_number':1878,'multiline':False]
['text':' An OR of one node is just that node.','line_number':1883,'multiline':False]
['text':' If all 'scanNodes' can provide the sort, shouldReverseScan is populated with which','line_number':1890,'multiline':False]
['text':' scans to reverse.','line_number':1891,'multiline':False]
['text':' TODO SERVER-77601 remove this conditional once SBE supports sort keys in collection','line_number':1897,'multiline':False]
['text':' scans.','line_number':1898,'multiline':False]
['text':' Each node can provide either the requested sort, or the reverse of the requested','line_number':1902,'multiline':False]
['text':' sort.','line_number':1903,'multiline':False]
['text':' Evaluate text nodes first to ensure that text scores are available.','line_number':1922,'multiline':False]
['text':' Move text nodes to front of vector.','line_number':1923,'multiline':False]
['text':' OR must have an index for each child, so we should have detached all children from','line_number':1928,'multiline':False]
['text':' 'root', and there's nothing useful to do with an empty or MatchExpression.  We let it die','line_number':1929,'multiline':False]
['text':' via autoRoot.','line_number':1930,'multiline':False]
['text':' Takes ownership of root.','line_number':1953,'multiline':False]
['text':' Takes ownership of root.','line_number':1956,'multiline':False]
['text':' No index to use here, not in the context of logical operator, so we're SOL.','line_number':1963,'multiline':False]
['text':' Make an index scan over the tagged index #.','line_number':1966,'multiline':False]
['text':' We're performing access planning for the child of an array operator such as','line_number':1989,'multiline':False]
['text':' $elemMatch value.','line_number':1990,'multiline':False]
['text':' We may be able to avoid adding an extra fetch stage even though the bounds are','line_number':1994,'multiline':False]
['text':' inexact, for instance if the query is counting null values on an indexed field','line_number':1995,'multiline':False]
['text':' without projecting that field. We therefore convert "MAYBE_COVERED" bounds into','line_number':1996,'multiline':False]
['text':' either EXACT or INEXACT, depending on the query projection.','line_number':1997,'multiline':False]
['text':' If the bounds are exact, the set of documents that satisfy the predicate is','line_number':2000,'multiline':False]
['text':' exactly equal to the set of documents that the scan provides.','line_number':2001,'multiline':False]
['text':'','line_number':2002,'multiline':False]
['text':' If the bounds are not exact, the set of documents returned from the scan is a','line_number':2003,'multiline':False]
['text':' superset of documents that satisfy the predicate, and we must check the','line_number':2004,'multiline':False]
['text':' predicate.','line_number':2005,'multiline':False]
['text':' The child is an AND.','line_number':2024,'multiline':False]
['text':' Recursively build a data access plan for the child of the $elemMatch object. We','line_number':2027,'multiline':False]
['text':' maintain ownership of 'ownedRoot'.','line_number':2028,'multiline':False]
['text':' There may be an array operator above us.','line_number':2034,'multiline':False]
['text':' Build an ixscan over the id index, use it, and return it.','line_number':2056,'multiline':False]
['text':' If it's find({}) remove the no-op root.','line_number':2072,'multiline':False]
['text':' TODO: We may not need to do the fetch if the predicates in root are covered.  But','line_number':2076,'multiline':False]
['text':' for now it's safe (though *maybe* slower).','line_number':2077,'multiline':False]
['text':' The 'node' already has either an AND or OR filter that matches 'type'. Add 'match' as','line_number':2093,'multiline':False]
['text':' another branch of the filter.','line_number':2094,'multiline':False]
['text':' The 'node' already has a filter that does not match 'type'. If 'type' is AND, then','line_number':2098,'multiline':False]
['text':' combine 'match' with the existing filter by adding an AND. If 'type' is OR, combine','line_number':2099,'multiline':False]
['text':' by adding an OR node.','line_number':2100,'multiline':False]
['text':' We must be building leaves for either and AND or an OR.','line_number':2121,'multiline':False]
['text':' We're inside an array operator. The entire array operator expression','line_number':2130,'multiline':False]
['text':' should always be affixed as a filter. We keep 'curChild' in the $and','line_number':2131,'multiline':False]
['text':' for affixing later.','line_number':2132,'multiline':False]
['text':' Detach 'child' and add it to 'curOr'.','line_number':2139,'multiline':False]
['text':' We're inside an array operator. The entire array operator expression','line_number':2151,'multiline':False]
['text':' should always be affixed as a filter. We keep 'curChild' in the $and','line_number':2152,'multiline':False]
['text':' for affixing later.','line_number':2153,'multiline':False]
['text':' The tightness of the bounds is exact. We want to remove this child so that when control','line_number':2156,'multiline':False]
['text':' returns to handleIndexedAnd we know that we don't need it to create a FETCH stage.','line_number':2157,'multiline':False]
['text':' The bounds are not exact, but the information needed to','line_number':2161,'multiline':False]
['text':' evaluate the predicate is in the index key. Remove the','line_number':2162,'multiline':False]
['text':' MatchExpression from its parent and attach it to the filter','line_number':2163,'multiline':False]
['text':' of the index scan we're building.','line_number':2164,'multiline':False]
['text':'','line_number':2165,'multiline':False]
['text':' We can only use this optimization if the index is NOT multikey.','line_number':2166,'multiline':False]
['text':' Suppose that we had the multikey index {x: 1} and a document','line_number':2167,'multiline':False]
['text':' {x: ["a", "b"]}. Now if we query for {x: /b/} the filter might','line_number':2168,'multiline':False]
['text':' ever only be applied to the index key "a". We'd incorrectly','line_number':2169,'multiline':False]
['text':' conclude that the document does not match the query :( so we','line_number':2170,'multiline':False]
['text':' gotta stick to non-multikey indices.','line_number':2171,'multiline':False]
['text':' We keep curChild in the AND for affixing later.','line_number':2177,'multiline':False]
['text':' Build an ixscan over the id index, use it, and return it.','line_number':2190,'multiline':False]
['text':' If it's find({}) remove the no-op root.','line_number':2202,'multiline':False]
['text':' TODO: We may not need to do the fetch if the predicates in root are covered.  But','line_number':2206,'multiline':False]
['text':' for now it's safe (though *maybe* slower).','line_number':2207,'multiline':False]
['text':' namespace mongo','line_number':2234,'multiline':False]
