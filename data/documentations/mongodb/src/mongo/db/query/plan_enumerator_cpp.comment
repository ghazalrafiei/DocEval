['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "boost/container/detail/flat_tree.hpp"','line_number':34,'multiline':False]
['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':41,'multiline':False]
['text':'*
 * Returns true if either 'node' or a descendent of 'node'
 * is a predicate that is required to use an index.
 ','line_number':82,'multiline':True]
['text':'*
 * Returns true if 'component' refers to a part of 'rt->path' outside the innermost $elemMatch
 * expression, and returns false otherwise. In particular, this function returns false if an
 * expression isn't contained in an $elemMatch.
 *
 * For example, consider the expression {a: {$elemMatch: {b: {$gte: 0, $lt: 10}}}. The path "a.b"
 * (component=1) is inside the $elemMatch expression, whereas the path "a" (component=0) is outside
 * the $elemMatch expression.
 ','line_number':95,'multiline':True]
['text':' No prefix of the leading index field causes the index to be multikey. In other words, the','line_number':124,'multiline':False]
['text':' index isn't multikey as a result of the leading index field. We can then safely assign','line_number':125,'multiline':False]
['text':' all predicates on it to the index and the access planner will intersect the bounds.','line_number':126,'multiline':False]
['text':' At least one prefix of the leading index field causes the index to be multikey. We can't','line_number':131,'multiline':False]
['text':' intersect bounds on the leading index field unless the predicates are joined by an','line_number':132,'multiline':False]
['text':' $elemMatch.','line_number':133,'multiline':False]
['text':' 'pred' isn't part of an $elemMatch, so we can't assign any other predicates on the','line_number':140,'multiline':False]
['text':' leading index field to the index.','line_number':141,'multiline':False]
['text':' 'pred' is part of an $elemMatch, so we group it together with any other leaf','line_number':144,'multiline':False]
['text':' expressions in the same $elemMatch context.','line_number':145,'multiline':False]
['text':' We can only assign all of the leaf expressions in the $elemMatch to the index if no prefix of','line_number':150,'multiline':False]
['text':' the leading index field that is longer than the root of the $elemMatch causes the index to be','line_number':151,'multiline':False]
['text':' multikey. For example, consider the index {'a.b': 1} and the query','line_number':152,'multiline':False]
['text':' {a: $elemMatch: {b: {$gte: 0, $lt: 10}}}. If 'a.b' refers to an array value, then the two','line_number':153,'multiline':False]
['text':' leaf expressions inside the $elemMatch can match distinct elements. We are therefore unable','line_number':154,'multiline':False]
['text':' to assign both to the index and intersect the bounds.','line_number':155,'multiline':False]
['text':' Since the multikey path components are 0-indexed, 'elemMatchRootLength' actually','line_number':170,'multiline':False]
['text':' corresponds to the path component immediately following the root of the $elemMatch.','line_number':171,'multiline':False]
['text':' The root of the $elemMatch is the longest prefix of the leading index field that','line_number':174,'multiline':False]
['text':' causes the index to be multikey, so we can assign all of the leaf expressions in the','line_number':175,'multiline':False]
['text':' $elemMatch to the index.','line_number':176,'multiline':False]
['text':' There is a path longer than the root of the $elemMatch that causes the index to be','line_number':179,'multiline':False]
['text':' multikey, so we can only assign one of the leaf expressions in the $elemMatch to the','line_number':180,'multiline':False]
['text':' index. Since we don't know which one is the most selective, we generate a plan for','line_number':181,'multiline':False]
['text':' each predicate and rank them against each other.','line_number':182,'multiline':False]
['text':'*
 * Returns true if the leaf expression associated with 'rt' can be assigned to the index given the
 * path prefixes of the queried field that cause the index to be multikey and the predicates already
 * assigned to the index. Otherwise, this function returns false if the leaf expression associated
 * with 'rt' can't be assigned to the index.
 *
 * This function modifies 'used' under the assumption that if it returns true, then the predicate
 * will be assigned to the index.
 ','line_number':190,'multiline':True]
['text':' We start by checking with the shortest prefix of the queried path to avoid needing to undo','line_number':205,'multiline':False]
['text':' any changes we make to 'used' as we go.','line_number':206,'multiline':False]
['text':' 'pathPrefix' is a prefix of a queried path that causes the index to be multikey.','line_number':208,'multiline':False]
['text':' 'pathPrefix' is a prefix of a queried path that we haven't seen before.','line_number':213,'multiline':False]
['text':' 'pathPrefix' is outside the innermost $elemMatch, so we record its $elemMatch','line_number':215,'multiline':False]
['text':' context to ensure that we don't assign another predicate to 'thisIndex' along','line_number':216,'multiline':False]
['text':' this path unless they are part of the same $elemMatch.','line_number':217,'multiline':False]
['text':' 'pathPrefix' is either inside the innermost $elemMatch or not inside an','line_number':223,'multiline':False]
['text':' $elemMatch at all. We record that we can't assign another predicate to','line_number':224,'multiline':False]
['text':' 'thisIndex' either at or beyond 'pathPrefix' without violating the intersecting','line_number':225,'multiline':False]
['text':' and compounding rules for multikey indexes.','line_number':226,'multiline':False]
['text':' Since we check starting with the shortest prefixes of the queried path that cause','line_number':229,'multiline':False]
['text':' 'thisIndex' to be multikey, marking 'used' with nullptr here means that there','line_number':230,'multiline':False]
['text':' will be no further attempts to intersect or compound bounds by assigning a','line_number':231,'multiline':False]
['text':' different predicate at or beyond 'pathPrefix'.','line_number':232,'multiline':False]
['text':' 'pathPrefix' is a prefix of a queried path that we've already assigned to','line_number':236,'multiline':False]
['text':' 'thisIndex'. We can only intersect or compound bounds by assigning 'couldAssignPred'','line_number':237,'multiline':False]
['text':' to 'thisIndex' if the leaf expressions are joined by the same $elemMatch context.','line_number':238,'multiline':False]
['text':'*
 * Tags each node of the tree with the lowest numbered index that the sub-tree rooted at that
 * node uses.
 *
 * Nodes that satisfy Indexability::nodeCanUseIndexOnOwnField are already tagged if there
 * exists an index that that node can use.
 ','line_number':249,'multiline':True]
['text':' namespace','line_number':286,'multiline':False]
['text':' Fill out our memo structure from the tagged _root.','line_number':308,'multiline':False]
['text':' Dump the tags.  We replace them with IndexTag instances.','line_number':311,'multiline':False]
['text':' Note that this needs to be kept in sync with allocateAssignment which assigns memo IDs.','line_number':320,'multiline':False]
['text':' Tag with our first solution.','line_number':410,'multiline':False]
['text':'','line_number':422,'multiline':False]
['text':' Structure creation','line_number':423,'multiline':False]
['text':'','line_number':424,'multiline':False]
['text':' We start at 1 so that the lookup of any entries not explicitly allocated','line_number':429,'multiline':False]
['text':' will refer to an invalid memo slot.','line_number':430,'multiline':False]
['text':' Shouldn't be anything there already.','line_number':433,'multiline':False]
['text':' For an OR to be indexed, all its children must be indexed.','line_number':457,'multiline':False]
['text':' Extend the path through the indexed ORs of each outside predicate.','line_number':460,'multiline':False]
['text':' If the route has already traversed through an $elemMatch object, then we cannot','line_number':464,'multiline':False]
['text':' push down through this OR. Here we remove such routes from our context object.','line_number':465,'multiline':False]
['text':'','line_number':466,'multiline':False]
['text':' For example, suppose we have index {a: 1, "b.c": 1} and the following query:','line_number':467,'multiline':False]
['text':'','line_number':468,'multiline':False]
['text':'   {a: 1, b: {$elemMatch: {$or: [{c: 2}, {c: 3}]}}}','line_number':469,'multiline':False]
['text':'','line_number':470,'multiline':False]
['text':' It is not correct to push the 'a' predicate down such that it is a sibling of','line_number':471,'multiline':False]
['text':' either of the predicates on 'c', since this would change the predicate's meaning','line_number':472,'multiline':False]
['text':' from a==1 to "b.a"==1.','line_number':473,'multiline':False]
['text':' If we're here we're fully indexed and can be in the memo.','line_number':487,'multiline':False]
['text':' Add each of our children as a subnode.  We enumerate through each subnode one at a','line_number':507,'multiline':False]
['text':' time until it's exhausted then we move on.','line_number':508,'multiline':False]
['text':' For an OR to be indexed, all its children must be indexed.','line_number':516,'multiline':False]
['text':' Map from idx id to children that have a pred over it.','line_number':536,'multiline':False]
['text':' TODO: The index intersection logic could be simplified if we could iterate over these','line_number':538,'multiline':False]
['text':' maps in a known order. Currently when iterating over these maps we have to impose an','line_number':539,'multiline':False]
['text':' ordering on each individual pair of indices in order to make sure that the','line_number':540,'multiline':False]
['text':' enumeration results are order-independent. See SERVER-12196.','line_number':541,'multiline':False]
['text':' Children that aren't predicates, and which do not necessarily need','line_number':545,'multiline':False]
['text':' to use an index.','line_number':546,'multiline':False]
['text':' Children that aren't predicates, but which *must* use an index.','line_number':549,'multiline':False]
['text':' (e.g. an OR which contains a TEXT child).','line_number':550,'multiline':False]
['text':' A list of predicates contained in the subtree rooted at 'node' obtained by traversing','line_number':553,'multiline':False]
['text':' deeply through $and and $elemMatch children.','line_number':554,'multiline':False]
['text':' Partition the childen into the children that aren't predicates which may or may not be','line_number':557,'multiline':False]
['text':' indexed ('subnodes'), children that aren't predicates which must use the index','line_number':558,'multiline':False]
['text':' ('mandatorySubnodes'). and children that are predicates ('indexedPreds').','line_number':559,'multiline':False]
['text':'','line_number':560,'multiline':False]
['text':' We have to get the subnodes with mandatory assignments rather than adding the mandatory','line_number':561,'multiline':False]
['text':' preds to 'indexedPreds'. Adding the mandatory preds directly to 'indexedPreds' would lead','line_number':562,'multiline':False]
['text':' to problems such as pulling a predicate beneath an OR into a set joined by an AND.','line_number':563,'multiline':False]
['text':' Pass in the indexed predicates as outside predicates when prepping the subnodes. But if','line_number':565,'multiline':False]
['text':' match expression optimization is disabled, skip this part: we don't want to do','line_number':566,'multiline':False]
['text':' OR-pushdown because it relies on the expression being canonicalized.','line_number':567,'multiline':False]
['text':' There can only be one mandatory predicate (at most one $text, at most one','line_number':582,'multiline':False]
['text':' $geoNear, can't combine $text/$geoNear).','line_number':583,'multiline':False]
['text':' There could be multiple indices which we could use to satisfy the mandatory','line_number':586,'multiline':False]
['text':' predicate. Keep the set of such indices. Currently only one text index is','line_number':587,'multiline':False]
['text':' allowed per collection, but there could be multiple 2d or 2dsphere indices','line_number':588,'multiline':False]
['text':' available to answer a $geoNear predicate.','line_number':589,'multiline':False]
['text':' Go through 'indexedPreds' and add the predicates to the','line_number':592,'multiline':False]
['text':' 'idxToFirst' and 'idxToNotFirst' maps.','line_number':593,'multiline':False]
['text':' 'child' is a predicate which *must* be tagged with an index.','line_number':604,'multiline':False]
['text':' This should include only TEXT and GEO_NEAR preds.','line_number':605,'multiline':False]
['text':' We expect either 0 or 1 mandatory predicates.','line_number':607,'multiline':False]
['text':' Mandatory predicates are TEXT or GEO_NEAR.','line_number':612,'multiline':False]
['text':' The mandatory predicate must have a corresponding "mandatory index".','line_number':618,'multiline':False]
['text':' Find all of the indices that could be used to satisfy the pred,','line_number':625,'multiline':False]
['text':' and add them to the 'mandatoryIndices' set.','line_number':626,'multiline':False]
['text':' If none of our children can use indices, bail out.','line_number':640,'multiline':False]
['text':' Takes ownership.','line_number':651,'multiline':False]
['text':' Predicates which must use an index might be buried inside','line_number':654,'multiline':False]
['text':' a subnode. Handle that case here.','line_number':655,'multiline':False]
['text':' We must have at least one index which can be used to answer 'mandatoryPred'.','line_number':664,'multiline':False]
['text':' Don't know what the node is at this point.','line_number':681,'multiline':False]
['text':' Text indexes are typically multikey because there is an index key for each token in the','line_number':690,'multiline':False]
['text':' source text. However, the leading and trailing non-text fields of the index cannot be','line_number':691,'multiline':False]
['text':' multikey. As a result, we should use non-multikey predicate assignment rules for such','line_number':692,'multiline':False]
['text':' indexes.','line_number':693,'multiline':False]
['text':' Since the index is not multikey, all predicates over the leading field can be assigned.','line_number':698,'multiline':False]
['text':' Since everything in assign.preds prefixes the index, they all go at position '0' in the','line_number':701,'multiline':False]
['text':' index, the first position.','line_number':702,'multiline':False]
['text':' And now we begin compound analysis. Find everything that could use assign.index but isn't a','line_number':705,'multiline':False]
['text':' pred over the first field of that index.','line_number':706,'multiline':False]
['text':' Generate index assignments for each index in 'mandatoryIndices'. We','line_number':718,'multiline':False]
['text':' must assign 'mandatoryPred' to one of these indices, but we try all','line_number':719,'multiline':False]
['text':' possibilities in 'mandatoryIndices' because some might be better than','line_number':720,'multiline':False]
['text':' others for this query.','line_number':721,'multiline':False]
['text':' We have a predicate which *must* be tagged to use an index.','line_number':725,'multiline':False]
['text':' Get the index entry for the index it should use.','line_number':726,'multiline':False]
['text':' Only text, 2d, and 2dsphere index types should be able to satisfy','line_number':729,'multiline':False]
['text':' mandatory predicates.','line_number':730,'multiline':False]
['text':' We don't have any predicate to assign to the leading field of this index.','line_number':741,'multiline':False]
['text':' This means that we cannot generate a solution using this index, so we','line_number':742,'multiline':False]
['text':' just move on to the next index.','line_number':743,'multiline':False]
['text':' Text indexes should be treated like non-multikey indexes, since the non-text fields are','line_number':749,'multiline':False]
['text':' prohibited from containing arrays.','line_number':750,'multiline':False]
['text':' 2dsphere indexes are the only special index type that should ever have path-level','line_number':755,'multiline':False]
['text':' multikey information.','line_number':756,'multiline':False]
['text':' The mandatory predicate is on the leading field of 'thisIndex'. We assign it to','line_number':764,'multiline':False]
['text':' 'thisIndex' and skip assigning any other predicates on the leading field to','line_number':765,'multiline':False]
['text':' 'thisIndex' because no additional predicate on the leading field will generate a','line_number':766,'multiline':False]
['text':' more efficient data access plan.','line_number':767,'multiline':False]
['text':' Assign any predicates on the non-leading index fields to 'indexAssign' that','line_number':773,'multiline':False]
['text':' don't violate the intersecting or compounding rules for multikey indexes.','line_number':774,'multiline':False]
['text':' We do not currently try to assign outside predicates to mandatory indexes.','line_number':775,'multiline':False]
['text':' Assign any predicates on the leading index field to 'indexAssign' that don't','line_number':780,'multiline':False]
['text':' violate the intersecting rules for multikey indexes.','line_number':781,'multiline':False]
['text':' We do not currently try to assign outside predicates to mandatory indexes.','line_number':782,'multiline':False]
['text':' Assign the mandatory predicate to 'thisIndex'. Due to how keys are generated for','line_number':786,'multiline':False]
['text':' 2dsphere indexes, it is always safe to assign a predicate on a distinct path to','line_number':787,'multiline':False]
['text':' 'thisIndex' and compound bounds; an index entry is produced for each combination','line_number':788,'multiline':False]
['text':' of unique values along all of the indexed fields, even if they are in separate','line_number':789,'multiline':False]
['text':' array elements. See SERVER-23533 for more details.','line_number':790,'multiline':False]
['text':' Copy the predicates on the non-leading index fields and remove','line_number':795,'multiline':False]
['text':' 'mandatoryPred' to avoid assigning it twice to 'thisIndex'.','line_number':796,'multiline':False]
['text':' Assign any predicates on the non-leading index fields to 'indexAssign' that','line_number':808,'multiline':False]
['text':' don't violate the intersecting or compounding rules for multikey indexes.','line_number':809,'multiline':False]
['text':' We do not currently try to assign outside predicates to mandatory indexes.','line_number':810,'multiline':False]
['text':' Special handling for multikey mandatory indices.','line_number':816,'multiline':False]
['text':' The mandatory predicate is over the first field of the index. Assign','line_number':820,'multiline':False]
['text':' it now.','line_number':821,'multiline':False]
['text':' The mandatory pred is notFirst. Assign an arbitrary predicate','line_number':825,'multiline':False]
['text':' over the first position.','line_number':826,'multiline':False]
['text':' Assign the mandatory predicate at the matching position in the compound','line_number':833,'multiline':False]
['text':' index. We do this in order to ensure that the mandatory predicate (and not','line_number':834,'multiline':False]
['text':' some other predicate over the same position in the compound index) gets','line_number':835,'multiline':False]
['text':' assigned.','line_number':836,'multiline':False]
['text':'','line_number':837,'multiline':False]
['text':' The bad thing that could happen otherwise: A non-mandatory predicate gets','line_number':838,'multiline':False]
['text':' chosen by getMultikeyCompoundablePreds(...) instead of 'mandatoryPred'.','line_number':839,'multiline':False]
['text':' We would then fail to assign the mandatory predicate, and hence generate','line_number':840,'multiline':False]
['text':' a bad data access plan.','line_number':841,'multiline':False]
['text':'','line_number':842,'multiline':False]
['text':' The mandatory predicate is assigned by calling compound(...) because','line_number':843,'multiline':False]
['text':' compound(...) has logic for matching up a predicate with the proper','line_number':844,'multiline':False]
['text':' position in the compound index.','line_number':845,'multiline':False]
['text':' At this point we have assigned a predicate over the leading field and','line_number':850,'multiline':False]
['text':' we have assigned the mandatory predicate to a trailing field.','line_number':851,'multiline':False]
['text':'','line_number':852,'multiline':False]
['text':' Ex:','line_number':853,'multiline':False]
['text':'   Say we have index {a: 1, b: 1, c: "2dsphere", d: 1}. Also suppose that','line_number':854,'multiline':False]
['text':'   there is a $near predicate over "c", with additional predicates over','line_number':855,'multiline':False]
['text':'   "a", "b", "c", and "d". We will have assigned the $near predicate at','line_number':856,'multiline':False]
['text':'   position 2 and a predicate with path "a" at position 0.','line_number':857,'multiline':False]
['text':' Compound remaining predicates in a multikey-safe way.','line_number':860,'multiline':False]
['text':' The index is not multikey.','line_number':872,'multiline':False]
['text':' The mandatory predicate must be assigned.','line_number':877,'multiline':False]
['text':' Output the assignments for this index.','line_number':883,'multiline':False]
['text':' If match expression optimization is disabled, we also disable OR-pushdown,','line_number':898,'multiline':False]
['text':' so we should never get 'outsidePreds' here.','line_number':899,'multiline':False]
['text':' This method should only be called if we can combine bounds.','line_number':908,'multiline':False]
['text':' Only indexed predicates should ever be considered as outside predicates eligible for','line_number':923,'multiline':False]
['text':' pushdown.','line_number':924,'multiline':False]
['text':' Check whether the current $elemMatch through which we are traversing is the same as the','line_number':927,'multiline':False]
['text':' outside predicate's $elemMatch context. If so, then that outside predicate hasn't','line_number':928,'multiline':False]
['text':' actually traversed through an $elemMatch (it has simply been promoted by','line_number':929,'multiline':False]
['text':' getIndexedPreds() into the set of AND-related indexed predicates). If not, then the OR','line_number':930,'multiline':False]
['text':' pushdown route descends through an $elemMatch object node, and must be marked as such.','line_number':931,'multiline':False]
['text':' Each choice in the 'andAssignment' will consist of a single subnode to index (an OR or array','line_number':944,'multiline':False]
['text':' operator) or a OneIndexAssignment. When creating a OneIndexAssignment, we ensure that at','line_number':945,'multiline':False]
['text':' least one predicate can fulfill the first position in the key pattern, then we assign all','line_number':946,'multiline':False]
['text':' predicates that can use the key pattern to the index. However, if the index is multikey,','line_number':947,'multiline':False]
['text':' certain predicates cannot be combined/compounded. We determine which predicates can be','line_number':948,'multiline':False]
['text':' combined/compounded using path-level multikey info, if available.','line_number':949,'multiline':False]
['text':' First, add the state of using each subnode.','line_number':951,'multiline':False]
['text':' Next we create OneIndexAssignments.','line_number':958,'multiline':False]
['text':' If there are any 'outsidePreds', then we are in a contained OR, and the 'outsidePreds' are','line_number':960,'multiline':False]
['text':' AND-related to the contained OR and can be pushed inside of it. Add all of the 'outsidePreds'','line_number':961,'multiline':False]
['text':' to 'idxToFirst' and 'idxToNotFirst'. We will treat them as normal predicates that can be','line_number':962,'multiline':False]
['text':' assigned to the index, but we will ensure that any OneIndexAssignment contains some','line_number':963,'multiline':False]
['text':' predicates from the current node.','line_number':964,'multiline':False]
['text':' For each FIRST, we assign predicates to it.','line_number':982,'multiline':False]
['text':' We have path-level information about what causes 'thisIndex' to be multikey and can','line_number':987,'multiline':False]
['text':' use this information to get tighter bounds by assigning additional predicates to the','line_number':988,'multiline':False]
['text':' index.','line_number':989,'multiline':False]
['text':'','line_number':990,'multiline':False]
['text':' Depending on the predicates specified and what parts of the leading index field cause','line_number':991,'multiline':False]
['text':' the index to be multikey, we may not be able to assign all of predicates to the','line_number':992,'multiline':False]
['text':' index. Since we don't know which set of predicates is the most selective, we generate','line_number':993,'multiline':False]
['text':' multiple plans and rank them against each other.','line_number':994,'multiline':False]
['text':' Output an assignment for each of the possible assignments on the leading index field.','line_number':998,'multiline':False]
['text':' Assign any predicates on the non-leading index fields to 'indexAssign' that','line_number':1009,'multiline':False]
['text':' don't violate the intersecting and compounding rules for multikey indexes.','line_number':1010,'multiline':False]
['text':' Do not output this assignment if it consists only of outside predicates.','line_number':1014,'multiline':False]
['text':' We don't have path-level information about what causes 'thisIndex' to be multikey.','line_number':1022,'multiline':False]
['text':' We therefore must assume the worst-case scenario: all prefixes of all indexed fields','line_number':1023,'multiline':False]
['text':' cause the index to be multikey. We therefore can only assign one of the predicates on','line_number':1024,'multiline':False]
['text':' the leading index field to the index. Since we don't know which one is the most','line_number':1025,'multiline':False]
['text':' selective, we generate a plan for each predicate and rank them against each other.','line_number':1026,'multiline':False]
['text':' If there are any preds that could possibly be compounded with this','line_number':1033,'multiline':False]
['text':' index...','line_number':1034,'multiline':False]
['text':' ...select the predicates that are safe to compound and compound them.','line_number':1044,'multiline':False]
['text':' Do not output this assignment if it consists only of outside predicates.','line_number':1053,'multiline':False]
['text':' The assignment we're filling out.','line_number':1061,'multiline':False]
['text':' This is the index we assign to.','line_number':1064,'multiline':False]
['text':' The index isn't multikey.  Assign all preds to it.  The planner will','line_number':1067,'multiline':False]
['text':' intersect the bounds.','line_number':1068,'multiline':False]
['text':' Find everything that could use assign.index but isn't a pred over','line_number':1073,'multiline':False]
['text':' the first field of that index.','line_number':1074,'multiline':False]
['text':' Output the assignment.','line_number':1082,'multiline':False]
['text':' Hardcoded "look at all members of the power set of size 2" search,','line_number':1097,'multiline':False]
['text':' a.k.a. "consider all pairs of indices".','line_number':1098,'multiline':False]
['text':'','line_number':1099,'multiline':False]
['text':' For each unordered pair of indices do the following:','line_number':1100,'multiline':False]
['text':'   0. Impose an ordering (idx1, idx2) using the key patterns.','line_number':1101,'multiline':False]
['text':'   (*See note below.)','line_number':1102,'multiline':False]
['text':'   1. Assign predicates which prefix idx1 to idx1.','line_number':1103,'multiline':False]
['text':'   2. Add assigned predicates to a set of predicates---the "already','line_number':1104,'multiline':False]
['text':'   assigned set".','line_number':1105,'multiline':False]
['text':'   3. Assign predicates which prefix idx2 to idx2, as long as they','line_number':1106,'multiline':False]
['text':'   been assigned to idx1 already. Add newly assigned predicates to','line_number':1107,'multiline':False]
['text':'   the "already assigned set".','line_number':1108,'multiline':False]
['text':'   4. Try to assign predicates to idx1 by compounding.','line_number':1109,'multiline':False]
['text':'   5. Add any predicates assigned to idx1 by compounding to the','line_number':1110,'multiline':False]
['text':'   "already assigned set",','line_number':1111,'multiline':False]
['text':'   6. Try to assign predicates to idx2 by compounding.','line_number':1112,'multiline':False]
['text':'   7. Determine if we have already assigned all predicates in','line_number':1113,'multiline':False]
['text':'   the "already assigned set" to a single index. If so, then','line_number':1114,'multiline':False]
['text':'   don't generate an ixisect solution, as compounding will','line_number':1115,'multiline':False]
['text':'   be better. Otherwise, output the ixisect assignments.','line_number':1116,'multiline':False]
['text':'','line_number':1117,'multiline':False]
['text':' *NOTE on ordering. Suppose we have two indices A and B, and a','line_number':1118,'multiline':False]
['text':' predicate P1 which is over the prefix of both indices A and B.','line_number':1119,'multiline':False]
['text':' If we order the indices (A, B) then P1 will get assigned to A,','line_number':1120,'multiline':False]
['text':' but if we order the indices (B, A) then P1 will get assigned to','line_number':1121,'multiline':False]
['text':' B. In order to make sure that we get the same result for the unordered','line_number':1122,'multiline':False]
['text':' pair {A, B} we have to begin by imposing an ordering. As a more concrete','line_number':1123,'multiline':False]
['text':' example, if we have indices {x: 1, y: 1} and {x: 1, z: 1} with predicate','line_number':1124,'multiline':False]
['text':' {x: 3}, we want to make sure that {x: 3} gets assigned to the same index','line_number':1125,'multiline':False]
['text':' irrespective of ordering.','line_number':1126,'multiline':False]
['text':' We create a scan per predicate so if we have >1 predicate we'll already','line_number':1134,'multiline':False]
['text':' have at least 2 scans (one predicate per scan as the planner can't','line_number':1135,'multiline':False]
['text':' intersect bounds when the index is multikey), so we stop here.','line_number':1136,'multiline':False]
['text':' Since everything in assign.preds prefixes the index, they all go at position '0' in','line_number':1141,'multiline':False]
['text':' the index, the first position.','line_number':1142,'multiline':False]
['text':' One could imagine an enormous auto-generated $all query with too many clauses to','line_number':1146,'multiline':False]
['text':' have an ixscan per clause.','line_number':1147,'multiline':False]
['text':' Only take the first kMaxSelfIntersections preds.','line_number':1150,'multiline':False]
['text':' Output (subnode, firstAssign) pairs.','line_number':1160,'multiline':False]
['text':' Since everything in assign.preds prefixes the index, they all go at position '0' in','line_number':1165,'multiline':False]
['text':' the index, the first position.','line_number':1166,'multiline':False]
['text':' Limit n^2.','line_number':1173,'multiline':False]
['text':' Start looking at all other indices to find one that we want to bundle','line_number':1185,'multiline':False]
['text':' with firstAssign.','line_number':1186,'multiline':False]
['text':' Limit n^2.','line_number':1193,'multiline':False]
['text':' If the other index we're considering is multikey with >1 pred, we don't','line_number':1203,'multiline':False]
['text':' want to have it as an additional assignment.  Eventually, it1 will be','line_number':1204,'multiline':False]
['text':' equal to the current value of secondIt and we'll assign every pred for','line_number':1205,'multiline':False]
['text':' this mapping to the index.','line_number':1206,'multiline':False]
['text':'','line_number':1211,'multiline':False]
['text':' Step #0:','line_number':1212,'multiline':False]
['text':' Impose an ordering (idx1, idx2) using the key patterns.','line_number':1213,'multiline':False]
['text':'','line_number':1214,'multiline':False]
['text':'','line_number':1222,'multiline':False]
['text':' Step #1:','line_number':1223,'multiline':False]
['text':' Assign predicates which prefix firstIndex to firstAssign.','line_number':1224,'multiline':False]
['text':'','line_number':1225,'multiline':False]
['text':' Since everything in assign.preds prefixes the index, they all go','line_number':1229,'multiline':False]
['text':' at position '0' in the index, the first position.','line_number':1230,'multiline':False]
['text':' We keep track of what preds are assigned to indices either because they','line_number':1233,'multiline':False]
['text':' prefix the index or have been assigned through compounding. We make sure','line_number':1234,'multiline':False]
['text':' that these predicates DO NOT become additional index assignments.','line_number':1235,'multiline':False]
['text':' Example: what if firstAssign is the index (x, y) and we're trying to','line_number':1236,'multiline':False]
['text':' compound? We want to make sure not to compound if the predicate is','line_number':1237,'multiline':False]
['text':' already assigned to index y.','line_number':1238,'multiline':False]
['text':'','line_number':1241,'multiline':False]
['text':' Step #2:','line_number':1242,'multiline':False]
['text':' Add indices assigned in 'firstAssign' to 'predsAssigned'.','line_number':1243,'multiline':False]
['text':'','line_number':1244,'multiline':False]
['text':'','line_number':1249,'multiline':False]
['text':' Step #3:','line_number':1250,'multiline':False]
['text':' Assign predicates which prefix secondIndex to secondAssign and','line_number':1251,'multiline':False]
['text':' have not already been assigned to firstAssign. Any newly','line_number':1252,'multiline':False]
['text':' assigned predicates are added to 'predsAssigned'.','line_number':1253,'multiline':False]
['text':'','line_number':1254,'multiline':False]
['text':' Every predicate that would use this index is already assigned in','line_number':1266,'multiline':False]
['text':' firstAssign.','line_number':1267,'multiline':False]
['text':'','line_number':1272,'multiline':False]
['text':' Step #4:','line_number':1273,'multiline':False]
['text':' Compound on firstAssign, if applicable.','line_number':1274,'multiline':False]
['text':'','line_number':1275,'multiline':False]
['text':' Can't compound with multikey indices.','line_number':1279,'multiline':False]
['text':' We must remove any elements of 'predsAssigned' from consideration.','line_number':1281,'multiline':False]
['text':'','line_number':1294,'multiline':False]
['text':' Step #5:','line_number':1295,'multiline':False]
['text':' Make sure predicates assigned by compounding in step #4 do not get','line_number':1296,'multiline':False]
['text':' assigned again.','line_number':1297,'multiline':False]
['text':'','line_number':1298,'multiline':False]
['text':'','line_number':1305,'multiline':False]
['text':' Step #6:','line_number':1306,'multiline':False]
['text':' Compound on firstAssign, if applicable.','line_number':1307,'multiline':False]
['text':'','line_number':1308,'multiline':False]
['text':' We must remove any elements of 'predsAssigned' from consideration.','line_number':1313,'multiline':False]
['text':' Add predicates in 'secondAssign' to the set of all assigned predicates.','line_number':1326,'multiline':False]
['text':'','line_number':1333,'multiline':False]
['text':' Step #7:','line_number':1334,'multiline':False]
['text':' Make sure we haven't already assigned this set of predicates by compounding.','line_number':1335,'multiline':False]
['text':' If we have, then bail out for this pair of indices.','line_number':1336,'multiline':False]
['text':'','line_number':1337,'multiline':False]
['text':' There is no need to add either 'firstAssign' or 'secondAssign'','line_number':1339,'multiline':False]
['text':' to 'andAssignment' in this case because we have already performed','line_number':1340,'multiline':False]
['text':' assignments to single indices in enumerateOneIndex(...).','line_number':1341,'multiline':False]
['text':' We're done with this particular pair of indices; output','line_number':1345,'multiline':False]
['text':' the resulting assignments.','line_number':1346,'multiline':False]
['text':' If we're in an $elemMatch context, store the','line_number':1361,'multiline':False]
['text':' innermost parent $elemMatch, as well as the','line_number':1362,'multiline':False]
['text':' inner path prefix.','line_number':1363,'multiline':False]
['text':' We're not an $elemMatch context, so we should store','line_number':1367,'multiline':False]
['text':' the prefix of the full path.','line_number':1368,'multiline':False]
['text':' Output this as a pred that can use the index.','line_number':1372,'multiline':False]
['text':' Do not extract an index predicate which is a negation inside the $elemMatch. For','line_number':1376,'multiline':False]
['text':' example, do not extract {a.b: $ne: 2} from {a: {$elemMatch: {b: $ne: 2}}}. Due to','line_number':1377,'multiline':False]
['text':' potential presence of arrays at "b", the negation predicate itself is an','line_number':1378,'multiline':False]
['text':' "under-approximation" of the elemMatch predicate (it may admit less documents than','line_number':1379,'multiline':False]
['text':' the elemMatch). Predicates extracted from the elemMatch should be','line_number':1380,'multiline':False]
['text':' "over-approximations" (admit more documents). For example {a.b: $eq: 2} would be an','line_number':1381,'multiline':False]
['text':' over-approximation to {a: {$elemMatch: {b: {$eq: 2}}}}.','line_number':1382,'multiline':False]
['text':' Output the subnode.','line_number':1418,'multiline':False]
['text':' The subnode is mandatory but cannot be indexed. This means','line_number':1425,'multiline':False]
['text':' that the entire AND cannot be indexed either.','line_number':1426,'multiline':False]
['text':' Map from a particular $elemMatch expression to the set of prefixes','line_number':1449,'multiline':False]
['text':' used so far by the predicates inside the $elemMatch. For example,','line_number':1450,'multiline':False]
['text':' {a: {$elemMatch: {b: 1, c: 2}}} would map to the set {'b', 'c'} at','line_number':1451,'multiline':False]
['text':' the end of this function's execution.','line_number':1452,'multiline':False]
['text':'','line_number':1453,'multiline':False]
['text':' NULL maps to the set of prefixes used so far outside of an $elemMatch','line_number':1454,'multiline':False]
['text':' context.','line_number':1455,'multiline':False]
['text':'','line_number':1456,'multiline':False]
['text':' As we iterate over the available indexed predicates, we keep track','line_number':1457,'multiline':False]
['text':' of the used prefixes both inside and outside of an $elemMatch context.','line_number':1458,'multiline':False]
['text':' Initialize 'used' with the starting predicates in 'assigned'. Begin by','line_number':1461,'multiline':False]
['text':' initializing the top-level scope with the prefix of the full path.','line_number':1462,'multiline':False]
['text':' If 'assigned' is a predicate inside an $elemMatch, we have to','line_number':1473,'multiline':False]
['text':' add the prefix not only to the top-level context, but also to the','line_number':1474,'multiline':False]
['text':' the $elemMatch context. For example, if 'assigned' is {a: {$elemMatch: {b: 1}}},','line_number':1475,'multiline':False]
['text':' then we will have already added "a" to the set for NULL. We now','line_number':1476,'multiline':False]
['text':' also need to add "b" to the set for the $elemMatch.','line_number':1477,'multiline':False]
['text':' Whereas getPathPrefix(usedRt->path) is the prefix of the full path,','line_number':1480,'multiline':False]
['text':' usedRt->pathPrefix contains the prefix of the portion of the','line_number':1481,'multiline':False]
['text':' path that is inside the $elemMatch. These two prefixes are the same','line_number':1482,'multiline':False]
['text':' in the top-level context, but here must be different because 'usedRt'','line_number':1483,'multiline':False]
['text':' is in an $elemMatch context.','line_number':1484,'multiline':False]
['text':' This is a new $elemMatch that we haven't seen before.','line_number':1497,'multiline':False]
['text':' If the top-level path prefix of the $elemMatch hasn't been','line_number':1503,'multiline':False]
['text':' used yet, couldCompound[i] is safe to compound.','line_number':1504,'multiline':False]
['text':' Output the predicate.','line_number':1511,'multiline':False]
['text':' We've seen this $elemMatch before, or the predicate is','line_number':1516,'multiline':False]
['text':' top-level (not in an $elemMatch context). If the prefix stored','line_number':1517,'multiline':False]
['text':' in the tag has not been used yet, then couldCompound[i] is','line_number':1518,'multiline':False]
['text':' safe to compound.','line_number':1519,'multiline':False]
['text':' Output the predicate.','line_number':1524,'multiline':False]
['text':' 'used' is a map from each prefix of a queried path that causes 'thisIndex' to be multikey to','line_number':1544,'multiline':False]
['text':' the 'elemMatchExpr' of the associated leaf expression's RelevantTag. We use it to ensure that','line_number':1545,'multiline':False]
['text':' leaf expressions sharing a prefix of their queried paths are only both assigned to','line_number':1546,'multiline':False]
['text':' 'thisIndex' if they are joined by the same $elemMatch context.','line_number':1547,'multiline':False]
['text':' Initialize 'used' with the predicates already assigned to 'thisIndex'.','line_number':1550,'multiline':False]
['text':' 'assignedPred' has already been assigned to 'thisIndex', so canAssignPredToIndex() ought','line_number':1558,'multiline':False]
['text':' to return true.','line_number':1559,'multiline':False]
['text':' However, there are cases with multikey 2dsphere indexes where the mandatory predicate','line_number':1563,'multiline':False]
['text':' is still safe to compound with, even though a prefix of it that causes the index to','line_number':1564,'multiline':False]
['text':' be multikey can be shared with the leading index field. The predicates cannot','line_number':1565,'multiline':False]
['text':' possibly be joined by an $elemMatch because $near predicates must be specified at the','line_number':1566,'multiline':False]
['text':' top-level of the query.','line_number':1567,'multiline':False]
['text':' Update 'used' with all outside predicates already assigned to 'thisIndex';','line_number':1574,'multiline':False]
['text':' Any outside predicates already assigned to 'thisIndex' were assigned in the first','line_number':1580,'multiline':False]
['text':' position.','line_number':1581,'multiline':False]
['text':' Attempt to assign the predicates to 'thisIndex' according to their position in the index','line_number':1591,'multiline':False]
['text':' key pattern.','line_number':1592,'multiline':False]
['text':' We can always intersect or compound the bounds when no prefix of the queried path','line_number':1604,'multiline':False]
['text':' causes the index to be multikey.','line_number':1605,'multiline':False]
['text':' See if any of the predicates that are already assigned to 'thisIndex' prevent us from','line_number':1610,'multiline':False]
['text':' assigning 'couldAssignPred' as well.','line_number':1611,'multiline':False]
['text':' We cannot have assigned this set of predicates already by','line_number':1629,'multiline':False]
['text':' compounding unless this is an assignment to a single index.','line_number':1630,'multiline':False]
['text':' If the set of preds in 'ixisectAssigned' is a subset of 'oneAssign.preds',','line_number':1635,'multiline':False]
['text':' then all the preds can be used by compounding on a single index.','line_number':1636,'multiline':False]
['text':' If 'ixisectAssigned' is larger than 'oneAssign.preds', then','line_number':1639,'multiline':False]
['text':' it can't be a subset.','line_number':1640,'multiline':False]
['text':' Check for subset by counting the number of elements in 'oneAssign.preds'','line_number':1645,'multiline':False]
['text':' that are contained in 'ixisectAssigned'. The elements of both 'oneAssign.preds'','line_number':1646,'multiline':False]
['text':' and 'ixisectAssigned' are unique (no repeated elements).','line_number':1647,'multiline':False]
['text':' We cannot assign the preds by compounding on 'oneAssign'.','line_number':1659,'multiline':False]
['text':' Move on to the next index.','line_number':1660,'multiline':False]
['text':' Let's try to match up the expressions in 'compExprs' with the','line_number':1682,'multiline':False]
['text':' fields in the index key pattern.','line_number':1683,'multiline':False]
['text':' Skip the first elt as it's already assigned.','line_number':1686,'multiline':False]
['text':' When we compound we store the field number that the predicate','line_number':1689,'multiline':False]
['text':' goes over in order to avoid having to iterate again and compare','line_number':1690,'multiline':False]
['text':' field names.','line_number':1691,'multiline':False]
['text':' Go through 'tryCompound' to see if there is a compoundable','line_number':1698,'multiline':False]
['text':' predicate for 'keyElt'. If there is nothing to compound, then','line_number':1699,'multiline':False]
['text':' simply move on to the next field in the compound index. We','line_number':1700,'multiline':False]
['text':' do not enforce that fields are assigned contiguously from','line_number':1701,'multiline':False]
['text':' right to left, i.e. for compound index {a: 1, b: 1, c: 1}','line_number':1702,'multiline':False]
['text':' it is okay to compound predicates over "a" and "c", skipping "b".','line_number':1703,'multiline':False]
['text':' Sigh we grab the full path from the relevant tag.','line_number':1706,'multiline':False]
['text':' preds and positions are parallel arrays.','line_number':1709,'multiline':False]
['text':'','line_number':1717,'multiline':False]
['text':' Structure navigation','line_number':1718,'multiline':False]
['text':'','line_number':1719,'multiline':False]
['text':' Add all OrPushdownTags for this index assignment.','line_number':1764,'multiline':False]
['text':' Haven't yet looped over this child entirely, not ready yet.','line_number':1798,'multiline':False]
['text':' If 'totalPossibleEnumerations' reaches the limit, we can just shortcut it. Otherwise,','line_number':1801,'multiline':False]
['text':' 'totalPossibleEnumerations' could overflow if we have a large $or.','line_number':1802,'multiline':False]
['text':' If we're able to compute a total number expected enumerations, we must have already cycled','line_number':1808,'multiline':False]
['text':' through each of the subnodes at least once. So if we've done that and then iterated all','line_number':1809,'multiline':False]
['text':' possible enumerations, we're about to repeat ourselves.','line_number':1810,'multiline':False]
['text':' We have not yet finished advancing all children simultaneously, so we'll loop over','line_number':1818,'multiline':False]
['text':' each child and advance it.','line_number':1819,'multiline':False]
['text':' Because we're doing things in a special order, we have to be careful to not duplicate','line_number':1821,'multiline':False]
['text':' ourselves. If each child has the same number of alternatives, we will eventually','line_number':1822,'multiline':False]
['text':' "carry" or roll over each child back to the beginning. When this happens, we should','line_number':1823,'multiline':False]
['text':' not return that plan again.','line_number':1824,'multiline':False]
['text':' We ran out of "lockstep runway" of sorts. At least one of the subnodes was','line_number':1833,'multiline':False]
['text':' exhausted, so this will be our last time advancing all children in lockstep.','line_number':1834,'multiline':False]
['text':' Edge case: if every child has only one option available, we are already finished','line_number':1840,'multiline':False]
['text':' enumerating.','line_number':1841,'multiline':False]
['text':' We're back at the beginning, no need to reset.','line_number':1844,'multiline':False]
['text':' Either there's more lockstep iteration to come, or the subnodes have different','line_number':1847,'multiline':False]
['text':' amounts of options. In either case, we are now in a new enumeration state so just','line_number':1848,'multiline':False]
['text':' return.','line_number':1849,'multiline':False]
['text':' Otherwise we just rolled over and went back to the first enumeration state, so we need to','line_number':1852,'multiline':False]
['text':' keep going to avoid duplicating that state. Fall through to below to start "normal", not','line_number':1853,'multiline':False]
['text':' lockstep iteration.','line_number':1854,'multiline':False]
['text':' All sub-nodes have the same enumeration state, skip this one since we already did it','line_number':1870,'multiline':False]
['text':' above. This is expected to happen pretty often. For example, if we have two subnodes each','line_number':1871,'multiline':False]
['text':' enumerating two states, we'd expect the order to be: 00, 11 (these two iterated above),','line_number':1872,'multiline':False]
['text':' then 00 (skipped here when we fall through after finishing lockstep iteration), then 10,','line_number':1873,'multiline':False]
['text':' 01, then finally 11 (skipped here).','line_number':1874,'multiline':False]
['text':'','line_number':1875,'multiline':False]
['text':' In this example, when we finally roll back to 00, enumeration is complete. We will fall','line_number':1876,'multiline':False]
['text':' through the code below which is responsible for resetting all enumeration state to the','line_number':1877,'multiline':False]
['text':' starting point (which need not reset the child nodes in this case because they already','line_number':1878,'multiline':False]
['text':' all rolled back to the starting point of 00). Finally, we return true to indicate that','line_number':1879,'multiline':False]
['text':' all possibilities have been enumerated.','line_number':1880,'multiline':False]
['text':' This special ordering is tricky to reset. Because it iterates the sub nodes in such a','line_number':1884,'multiline':False]
['text':' unique order, it can be difficult to know when it has actually finished iterating. Our','line_number':1885,'multiline':False]
['text':' strategy is just to compute a total and go back to the beginning once we hit that total.','line_number':1886,'multiline':False]
['text':' Reset!','line_number':1890,'multiline':False]
['text':' Keep advancing till it rolls over.','line_number':1894,'multiline':False]
['text':' Limit the number of OR enumerations.','line_number':1910,'multiline':False]
['text':' OR just walks through telling its children to move forward.','line_number':1921,'multiline':False]
['text':' If there's no carry, we just stop. If there's a carry, we move the next child','line_number':1923,'multiline':False]
['text':' forward.','line_number':1924,'multiline':False]
['text':' If we're here, the last subnode had a carry, therefore the OR has a carry.','line_number':1929,'multiline':False]
['text':' Limit the number of OR enumerations.','line_number':1934,'multiline':False]
['text':' moving to next on current subnode is OK','line_number':1947,'multiline':False]
['text':' Move to next subnode.','line_number':1951,'multiline':False]
['text':' One of our subnodes might have to move on to its next enumeration state.','line_number':1961,'multiline':False]
['text':' None of the subnodes had another enumeration state, so we move on to the','line_number':1969,'multiline':False]
['text':' next top-level choice.','line_number':1970,'multiline':False]
['text':' namespace mongo','line_number':1982,'multiline':False]
