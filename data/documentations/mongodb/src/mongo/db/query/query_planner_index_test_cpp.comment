['text':'*
 *    Copyright (C) 2019-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':'','line_number':170,'multiline':False]
['text':' Sparse indices, SERVER-8067','line_number':171,'multiline':False]
['text':' Each index in this block of tests is sparse.','line_number':172,'multiline':False]
['text':'','line_number':173,'multiline':False]
['text':' Sparse indexes can't support negation queries because they are sparse, and {a: {$ne: 5}}','line_number':237,'multiline':False]
['text':' will match documents which don't have an "a" field.','line_number':238,'multiline':False]
['text':' multikey','line_number':240,'multiline':False]
['text':' sparse','line_number':241,'multiline':False]
['text':' Logically, there's no reason a sparse index could not support a negation inside a','line_number':251,'multiline':False]
['text':' "$elemMatch value", but it is not something we've implemented.','line_number':252,'multiline':False]
['text':' multikey','line_number':254,'multiline':False]
['text':' sparse','line_number':255,'multiline':False]
['text':' Use a multikey index.','line_number':266,'multiline':False]
['text':' Use an index which is not multikey.','line_number':282,'multiline':False]
['text':' This matches the [[], null] pattern but also has a regex.','line_number':304,'multiline':False]
['text':' multikey','line_number':323,'multiline':False]
['text':' sparse','line_number':324,'multiline':False]
['text':' TODO: SERVER-37164: The semantics of {$gte: null} and {$lte: null} are inconsistent with and','line_number':331,'multiline':False]
['text':' without a sparse index. It is unclear whether or not a sparse index _should_ be able to support','line_number':332,'multiline':False]
['text':' these operations.','line_number':333,'multiline':False]
['text':' multikey','line_number':337,'multiline':False]
['text':' sparse','line_number':338,'multiline':False]
['text':' Create two indexes on the same key pattern; one sparse, the other non-sparse. This is','line_number':355,'multiline':False]
['text':' permitted because the 'sparse' property is part of the index signature.','line_number':356,'multiline':False]
['text':'multikey','line_number':357,'multiline':True]
['text':'sparse','line_number':357,'multiline':True]
['text':'multikey','line_number':358,'multiline':True]
['text':'sparse','line_number':358,'multiline':True]
['text':'unique','line_number':358,'multiline':True]
['text':' Plan #1: FETCH > IXSCAN with a_1 index.','line_number':362,'multiline':False]
['text':' Plan #2: FETCH > IXSCAN with a_sparse index.','line_number':363,'multiline':False]
['text':' Plan #3: COLLSCAN with filter a == 1.','line_number':364,'multiline':False]
['text':' There must be a solution that uses the sparse index "a_sparse".','line_number':367,'multiline':False]
['text':' Create two indexes on the same key pattern; one unique, the other non-unique. This is','line_number':372,'multiline':False]
['text':' permitted because the 'unique' property is part of the index signature.','line_number':373,'multiline':False]
['text':'multikey','line_number':374,'multiline':True]
['text':'sparse','line_number':374,'multiline':True]
['text':'unique','line_number':374,'multiline':True]
['text':'multikey','line_number':375,'multiline':True]
['text':'sparse','line_number':375,'multiline':True]
['text':'unique','line_number':375,'multiline':True]
['text':' Plan #1: FETCH > IXSCAN with a_1 index.','line_number':379,'multiline':False]
['text':' Plan #2: FETCH > IXSCAN with a_unique index.','line_number':380,'multiline':False]
['text':' Plan #3: COLLSCAN with filter a == 1.','line_number':381,'multiline':False]
['text':' There must be a solution that uses the unique index "a_unique".','line_number':384,'multiline':False]
['text':'','line_number':388,'multiline':False]
['text':' indexFilterApplied','line_number':389,'multiline':False]
['text':' Check that index filter flag is passed from planner params','line_number':390,'multiline':False]
['text':' to generated query solution.','line_number':391,'multiline':False]
['text':'','line_number':392,'multiline':False]
['text':' Check indexFilterApplied in query solutions;','line_number':403,'multiline':False]
['text':' Check indexFilterApplied in query solutions;','line_number':421,'multiline':False]
['text':'','line_number':429,'multiline':False]
['text':' Covering','line_number':430,'multiline':False]
['text':'','line_number':431,'multiline':False]
['text':' query, sort, proj','line_number':435,'multiline':False]
['text':'','line_number':486,'multiline':False]
['text':' Basic compound','line_number':487,'multiline':False]
['text':'','line_number':488,'multiline':False]
['text':'','line_number':532,'multiline':False]
['text':' Multikey indices','line_number':533,'multiline':False]
['text':'','line_number':534,'multiline':False]
['text':'','line_number':536,'multiline':False]
['text':' Index bounds related tests','line_number':537,'multiline':False]
['text':'','line_number':538,'multiline':False]
['text':' Given that the index over 'a' isn't multikey, we ideally won't generate any solutions','line_number':643,'multiline':False]
['text':' since we know the query describes an empty set if 'a' isn't multikey.  Any solutions','line_number':644,'multiline':False]
['text':' below are "this is how it currently works" instead of "this is how it should work."','line_number':645,'multiline':False]
['text':' It's kind of iffy to look for indexed solutions so we don't...','line_number':647,'multiline':False]
['text':' Test that planner properly unionizes the index bounds for two negation','line_number':711,'multiline':False]
['text':' predicates (SERVER-13890).','line_number':712,'multiline':False]
['text':'','line_number':741,'multiline':False]
['text':' Tests related to building index bounds for multikey','line_number':742,'multiline':False]
['text':' indices, combined with compound and $elemMatch','line_number':743,'multiline':False]
['text':'','line_number':744,'multiline':False]
['text':' SERVER-12475: make sure that we compound bounds, even','line_number':746,'multiline':False]
['text':' for a multikey index.','line_number':747,'multiline':False]
['text':' true means multikey','line_number':749,'multiline':False]
['text':' Make sure that we compound bounds but do not intersect bounds','line_number':761,'multiline':False]
['text':' for a compound multikey index.','line_number':762,'multiline':False]
['text':' true means multikey','line_number':764,'multiline':False]
['text':'','line_number':776,'multiline':False]
['text':' QueryPlannerParams option tests','line_number':777,'multiline':False]
['text':'','line_number':778,'multiline':False]
['text':'','line_number':809,'multiline':False]
['text':' Index Intersection.','line_number':810,'multiline':False]
['text':'','line_number':811,'multiline':False]
['text':' We don't exhaustively check all plans here.  Instead we check that there exists an','line_number':812,'multiline':False]
['text':' intersection plan.  The blending of >1 index plans and ==1 index plans is under development','line_number':813,'multiline':False]
['text':' but we want to make sure that we create an >1 index plan when we should.','line_number':814,'multiline':False]
['text':'','line_number':815,'multiline':False]
['text':' There's an andSorted not andHash because the two seeks are point intervals.','line_number':835,'multiline':False]
['text':' SERVER-12196','line_number':842,'multiline':False]
['text':' SERVER-12196','line_number':863,'multiline':False]
['text':' True means multikey.','line_number':886,'multiline':False]
['text':' This one goes to 11.','line_number':889,'multiline':False]
['text':' But this one only goes to 10.','line_number':892,'multiline':False]
['text':' 1','line_number':895,'multiline':False]
['text':' 2','line_number':896,'multiline':False]
['text':' 3','line_number':897,'multiline':False]
['text':' 4','line_number':898,'multiline':False]
['text':' 5','line_number':899,'multiline':False]
['text':' 6','line_number':900,'multiline':False]
['text':' 7','line_number':901,'multiline':False]
['text':' 8','line_number':902,'multiline':False]
['text':' 9','line_number':903,'multiline':False]
['text':' 10','line_number':904,'multiline':False]
['text':' This (can be) rewritten to $or:[ {a:1, b:1}, {c:1, d:1}].  We don't look for the various','line_number':936,'multiline':False]
['text':' single $or solutions as that's tested elsewhere.  We look for the intersect solution,','line_number':937,'multiline':False]
['text':' where each AND inside of the root OR is an and_sorted.','line_number':938,'multiline':False]
['text':' This provides the sort.','line_number':974,'multiline':False]
['text':' Rearrange the preds, shouldn't matter.','line_number':980,'multiline':False]
['text':' Ensure that disabling AND_HASH intersection works properly.','line_number':1006,'multiline':False]
['text':' Turn index intersection on but disable hash-based intersection.','line_number':1010,'multiline':False]
['text':' We should do an AND_SORT intersection of {b: 1} and {c: 1}, but no AND_HASH plans.','line_number':1020,'multiline':False]
['text':' Restore the old value of the has intersection switch.','line_number':1036,'multiline':False]
['text':'','line_number':1040,'multiline':False]
['text':' Index intersection cases for SERVER-12825: make sure that','line_number':1041,'multiline':False]
['text':' we don't generate an ixisect plan if a compound index is','line_number':1042,'multiline':False]
['text':' available instead.','line_number':1043,'multiline':False]
['text':'','line_number':1044,'multiline':False]
['text':' SERVER-12825','line_number':1046,'multiline':False]
['text':' SERVER-12825','line_number':1066,'multiline':False]
['text':' SERVER-12825','line_number':1086,'multiline':False]
['text':' SERVER-12825','line_number':1106,'multiline':False]
['text':' Make sure a top-level $or hits the limiting number','line_number':1126,'multiline':False]
['text':' of solutions that we are willing to consider.','line_number':1127,'multiline':False]
['text':' 6 $or clauses, each with 2 indexed predicates','line_number':1133,'multiline':False]
['text':' means 2^6 = 64 possibilities. We should hit the limit.','line_number':1134,'multiline':False]
['text':' 3 $or clauses, and a few other preds. Each $or clause can','line_number':1153,'multiline':False]
['text':' generate up to the max number of allowed $or enumerations.','line_number':1154,'multiline':False]
['text':' SERVER-13104: test that we properly enumerate all solutions for nested $or.','line_number':1163,'multiline':False]
['text':' SERVER-13104: test that we properly enumerate all solutions for nested $or.','line_number':1183,'multiline':False]
['text':' Four possibilities from indexing the $or.','line_number':1197,'multiline':False]
['text':' Two possibilties from outside the $or.','line_number':1219,'multiline':False]
['text':' Multiple indexes','line_number':1264,'multiline':False]
['text':' Sort on 'b'.','line_number':1447,'multiline':False]
['text':' Sort on 'b', 'a'.','line_number':1462,'multiline':False]
['text':' Sort on 'b', 'a' descending.','line_number':1477,'multiline':False]
['text':' Assign the result of the expression to 'x' which has no index.','line_number':1520,'multiline':False]
['text':' Cannot be covered since 'x' may be an array.','line_number':1533,'multiline':False]
['text':' Can be covered since 'b' and 'b.c' are known to not be multikey.','line_number':1546,'multiline':False]
['text':' Can be covered since 'b' is known to not be multikey.','line_number':1559,'multiline':False]
['text':' Cannot be covered since 'b' is multikey.','line_number':1572,'multiline':False]
['text':' Cannot be covered since 'b' is multikey, meaning the result of the expression '$b.c' could','line_number':1585,'multiline':False]
['text':' result in an array.','line_number':1586,'multiline':False]
['text':' namespace','line_number':1621,'multiline':False]
['text':' namespace mongo','line_number':1622,'multiline':False]
