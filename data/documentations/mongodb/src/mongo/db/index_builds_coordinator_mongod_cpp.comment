['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':'*
 * Constructs the options for the loader thread pool.
 ','line_number':114,'multiline':True]
['text':' Both the primary and secondary nodes will have an unlimited thread pool size. This is done to','line_number':121,'multiline':False]
['text':' allow secondary nodes to startup as many index builders as necessary in order to prevent','line_number':122,'multiline':False]
['text':' scheduling deadlocks during initial sync or oplog application. When commands are run from','line_number':123,'multiline':False]
['text':' user connections that need to create indexes, those commands will hang until there are less','line_number':124,'multiline':False]
['text':' than 'maxNumActiveUserIndexBuilds' running index build threads, or until the operation is','line_number':125,'multiline':False]
['text':' interrupted.','line_number':126,'multiline':False]
['text':' Ensure all threads have a client.','line_number':129,'multiline':False]
['text':' No locks should be held.','line_number':148,'multiline':False]
['text':' Retry command on error until we have been signaled either with commit or abort. This way, we','line_number':165,'multiline':False]
['text':' can make sure majority of nodes will never stop voting and wait for commit or abort signal','line_number':166,'multiline':False]
['text':' until they have received commit or abort signal.','line_number':167,'multiline':False]
['text':' Check for any interrupts, including shutdown-related ones, before starting the voting','line_number':169,'multiline':False]
['text':' process.','line_number':170,'multiline':False]
['text':' Don't hammer the network.','line_number':173,'multiline':False]
['text':' When index build started during startup recovery can try to get it's address when','line_number':175,'multiline':False]
['text':' rsConfig is uninitialized. So, retry till it gets initialized. Also, it's important, when','line_number':176,'multiline':False]
['text':' we retry, we check if we have received commit or abort signal to ensure liveness. For','line_number':177,'multiline':False]
['text':' e.g., consider a case where  index build gets restarted on startup recovery and','line_number':178,'multiline':False]
['text':' indexBuildsCoordinator thread waits for valid address w/o checking commit or abort','line_number':179,'multiline':False]
['text':' signal. Now, things can go wrong if we try to replay commitIndexBuild oplog entry for','line_number':180,'multiline':False]
['text':' that index build on startup recovery. Oplog applier would get stuck waiting on the','line_number':181,'multiline':False]
['text':' indexBuildsCoordinator thread. As a result, we won't be able to transition to secondary','line_number':182,'multiline':False]
['text':' state, get stuck on startup state.','line_number':183,'multiline':False]
['text':' All errors, including CallbackCanceled and network errors, should be retried.','line_number':199,'multiline':False]
['text':' If ErrorCodes::CallbackCanceled is due to shutdown, then checkForInterrupt() at the','line_number':200,'multiline':False]
['text':' beginning of this loop will catch it and throw an error to the caller. Or, if we','line_number':201,'multiline':False]
['text':' received the CallbackCanceled error because the index build was signaled with abort','line_number':202,'multiline':False]
['text':' or commit signal, then needToVote() would return false and we don't retry the voting','line_number':203,'multiline':False]
['text':' process.','line_number':204,'multiline':False]
['text':' Check if the command has to be retried.','line_number':214,'multiline':False]
['text':' namespace','line_number':220,'multiline':False]
['text':' Change the 'setOnUpdate' function for the server parameter to signal the condition variable','line_number':226,'multiline':False]
['text':' when the value changes.','line_number':227,'multiline':False]
['text':' Stop new scheduling.','line_number':239,'multiline':False]
['text':' Wait for all active builds to stop.','line_number':242,'multiline':False]
['text':' Wait for active threads to finish.','line_number':245,'multiline':False]
['text':' Only operations originating from user connections need to wait while there are more than','line_number':300,'multiline':False]
['text':' 'maxNumActiveUserIndexBuilds' index builds currently running.','line_number':301,'multiline':False]
['text':' The global lock acquires the RSTL lock which we use to assert that we're the','line_number':304,'multiline':False]
['text':' primary node when running user operations. Additionally, releasing this lock','line_number':305,'multiline':False]
['text':' allows the node to step down after we have checked the replication state. If this','line_number':306,'multiline':False]
['text':' node steps down after this check, similar assertions will cause the index build','line_number':307,'multiline':False]
['text':' to fail later on when locks are reacquired. Therefore, this assertion is not','line_number':308,'multiline':False]
['text':' required for correctness, but only intended to rate limit index builds started on','line_number':309,'multiline':False]
['text':' primaries.','line_number':310,'multiline':False]
['text':' The checks here catch empty index builds and also allow us to stop index','line_number':319,'multiline':False]
['text':' builds before waiting for throttling. It may race with the abort at the start','line_number':320,'multiline':False]
['text':' of migration so we do check again later.','line_number':321,'multiline':False]
['text':' System index builds have no limit and never wait, but do consume a slot.','line_number':349,'multiline':False]
['text':' Two phase index build recovery goes though a different set-up procedure because we will','line_number':377,'multiline':False]
['text':' either resume the index build or the original index will be dropped first.','line_number':378,'multiline':False]
['text':' The requested index (specs) are already built or are being built. Return success','line_number':405,'multiline':False]
['text':' early (this is v4.0 behavior compatible).','line_number':406,'multiline':False]
['text':' The builder thread updates to curOp description to be that of a createIndexes command, but we','line_number':436,'multiline':False]
['text':' still want to transfer whatever extra information there is available from the caller.','line_number':437,'multiline':False]
['text':' If this index build was started during secondary batch application, it will have a commit','line_number':445,'multiline':False]
['text':' timestamp that must be copied over to timestamp the write to initialize the index build.','line_number':446,'multiline':False]
['text':' Use a promise-future pair to wait until the index build has been started. This future will','line_number':449,'multiline':False]
['text':' only return when the index build thread has started and the initial catalog write has been','line_number':450,'multiline':False]
['text':' written, or an error has been encountered otherwise.','line_number':451,'multiline':False]
['text':' Since index builds occur in a separate thread, client attributes that are audited must be','line_number':457,'multiline':False]
['text':' extracted from the client object and passed into the thread separately.','line_number':458,'multiline':False]
['text':' The thread pool task will be responsible for signalling the condition variable when the index','line_number':462,'multiline':False]
['text':' build thread is done running.','line_number':463,'multiline':False]
['text':' Clean up if we failed to schedule the task.','line_number':487,'multiline':False]
['text':' Indicate that the index build is scheduled and running under this opCtx.','line_number':495,'multiline':False]
['text':' Set up the thread's currentOp information to display createIndexes cmd information,','line_number':498,'multiline':False]
['text':' merged with the caller's opDesc.','line_number':499,'multiline':False]
['text':' Forward the forwardable operation metadata from the external client to this thread's','line_number':502,'multiline':False]
['text':' client.','line_number':503,'multiline':False]
['text':' Load the external client's attributes into this thread's client for auditing.','line_number':506,'multiline':False]
['text':' Start collecting metrics for the index build. The metrics for this operation will','line_number':517,'multiline':False]
['text':' only be aggregated globally if the node commits or aborts while it is primary.','line_number':518,'multiline':False]
['text':' The shard version protocol is only required when setting up the index build and','line_number':526,'multiline':False]
['text':' writing the 'startIndexBuild' oplog entry. If a chunk migration is in-progress while','line_number':527,'multiline':False]
['text':' an index build is started, it will be aborted. A recipient shard will copy','line_number':528,'multiline':False]
['text':' in-progress indexes from the donor shard, and if the index build is aborted on the','line_number':529,'multiline':False]
['text':' donor, the client running createIndexes will receive an error requiring them to retry','line_number':530,'multiline':False]
['text':' the command, and the indexes will become consistent.','line_number':531,'multiline':False]
['text':' Do not exit with an incomplete future, even if setup fails, we should still','line_number':536,'multiline':False]
['text':' signal waiters.','line_number':537,'multiline':False]
['text':' Signal that the index build started successfully.','line_number':543,'multiline':False]
['text':' Runs the remainder of the index build. Sets the promise result and cleans up the','line_number':548,'multiline':False]
['text':' index build.','line_number':549,'multiline':False]
['text':' Do not exit with an incomplete future.','line_number':552,'multiline':False]
['text':' Logs the index build statistics if it took longer than the server parameter','line_number':556,'multiline':False]
['text':' `slowMs` to complete.','line_number':557,'multiline':False]
['text':' Waits until the index build has either been started or failed to start.','line_number':569,'multiline':False]
['text':' Ignore any interruption state in 'opCtx'.','line_number':570,'multiline':False]
['text':' If 'opCtx' is interrupted, the caller will be notified after startIndexBuild() returns when','line_number':571,'multiline':False]
['text':' it checks the future associated with 'sharedPromise'.','line_number':572,'multiline':False]
['text':' Index build does not exist or cannot be aborted because it is committing.','line_number':606,'multiline':False]
['text':' No need to wait for write concern.','line_number':607,'multiline':False]
['text':' Index build might have got torn down.','line_number':618,'multiline':False]
['text':' Secondary nodes will always try to vote regardless of the commit quorum value. If the','line_number':625,'multiline':False]
['text':' commit quorum is disabled, do not record their entry into the commit ready nodes.','line_number':626,'multiline':False]
['text':' If we fail to retrieve the persisted commit quorum, the index build might be in the','line_number':627,'multiline':False]
['text':' middle of tearing down.','line_number':628,'multiline':False]
['text':' Our current contract is that commit quorum can't be disabled for an active index build with','line_number':637,'multiline':False]
['text':' commit quorum on (i.e., commit value set as non-zero or a valid tag) and vice-versa. So,','line_number':638,'multiline':False]
['text':' after this point, it's not possible for the index build's commit quorum value to get updated','line_number':639,'multiline':False]
['text':' to CommitQuorumOptions::kDisabled.','line_number':640,'multiline':False]
['text':' Acquire the commitQuorumLk in shared mode to make sure commit quorum value did not change','line_number':663,'multiline':False]
['text':' after reading it from config.system.indexBuilds collection.','line_number':664,'multiline':False]
['text':' Read the index builds entry from config.system.indexBuilds collection.','line_number':667,'multiline':False]
['text':' This can occur when no vote got received and stepup tries to check if commit quorum is','line_number':673,'multiline':False]
['text':' satisfied.','line_number':674,'multiline':False]
['text':' Secondaries should always try to vote even if the commit quorum is disabled. Secondaries','line_number':704,'multiline':False]
['text':' must not read the on-disk commit quorum value as it may not be present at all times, such as','line_number':705,'multiline':False]
['text':' during initial sync.','line_number':706,'multiline':False]
['text':' Acquire the commitQuorumLk in shared mode to make sure commit quorum value did not change','line_number':711,'multiline':False]
['text':' after reading it from config.system.indexBuilds collection.','line_number':712,'multiline':False]
['text':' Read the commit quorum value from config.system.indexBuilds collection.','line_number':715,'multiline':False]
['text':' Check if the commit quorum is disabled for the index build.','line_number':721,'multiline':False]
['text':' The abort command might loop back to the same node, resulting in the command killing the','line_number':745,'multiline':False]
['text':' index builder thread (current), causing the cancellation of the command callback handle due','line_number':746,'multiline':False]
['text':' to the opCtx being interrupted. De-registering the callback due to cancellation means the','line_number':747,'multiline':False]
['text':' command did actually abort the index, so it is a non issue to just let it be cancelled. This','line_number':748,'multiline':False]
['text':' might be reflected in the logs as a cancelled command request, even if the command did','line_number':749,'multiline':False]
['text':' actually abort the build.','line_number':750,'multiline':False]
['text':' If the index build failed to abort on the primary, retrying won't solve the issue.','line_number':768,'multiline':False]
['text':' This may only happen if the build cannot be aborted because it is being committed, or','line_number':769,'multiline':False]
['text':' because it is already aborted or committed, meaning an active index build is not','line_number':770,'multiline':False]
['text':' registered. In any of these cases, the primary will eventually replicate either a','line_number':771,'multiline':False]
['text':' 'commitIndexBuild' or 'abortIndexBuild' oplog entry. So it is safe to just wait for','line_number':772,'multiline':False]
['text':' the next action after the vote request is done.','line_number':773,'multiline':False]
['text':' We should retry if the error is due to primary change.','line_number':782,'multiline':False]
['text':' Wait until the index build is externally aborted in this node, either through loopback or','line_number':793,'multiline':False]
['text':' replication, causing the index building thread to be interrupted, or the promise to be','line_number':794,'multiline':False]
['text':' fulfilled. Cleanup is done by the async command or oplog applier thread. If a','line_number':795,'multiline':False]
['text':' 'commitIndexBuild' is replicated in this state, the secondary will crash.','line_number':796,'multiline':False]
['text':' The promise was fullfilled before waiting.','line_number':805,'multiline':False]
['text':' External aborts must wait for the builder thread, so we cannot be in an already aborted','line_number':808,'multiline':False]
['text':' state.','line_number':809,'multiline':False]
['text':' The build was aborted, and the opCtx interrupted, before the thread checked the','line_number':811,'multiline':False]
['text':' future.','line_number':812,'multiline':False]
['text':' Before voting see if we are eligible to skip voting and signal','line_number':821,'multiline':False]
['text':' to commit index build if the node is primary.','line_number':822,'multiline':False]
['text':' Indicate that the index build in this node has already tried to vote for commit readiness.','line_number':838,'multiline':False]
['text':' We do not try to determine whether the vote has actually succeeded or not, as it is','line_number':839,'multiline':False]
['text':' challenging due to the asynchronous request and potential concurrent interrupts. After this','line_number':840,'multiline':False]
['text':' point, the node cannot vote to abort this index build, and if it needs to abort the index','line_number':841,'multiline':False]
['text':' build it must try to do so independently. Meaning, as a primary it will succeed, but as a','line_number':842,'multiline':False]
['text':' secondary it will fassert.','line_number':843,'multiline':False]
['text':' Command error and write concern error have to be retried.','line_number':854,'multiline':False]
['text':' Waits until the promise is fulfilled or the deadline expires.','line_number':880,'multiline':False]
['text':' Continuously drain incoming writes until the future is ready. This is an optimization that','line_number':898,'multiline':False]
['text':' allows the critical section of committing, which must drain the remainder of the side writes,','line_number':899,'multiline':False]
['text':' to be as short as possible.','line_number':900,'multiline':False]
['text':' Future wait should hold no locks.','line_number':916,'multiline':False]
['text':' Future wait can be interrupted.','line_number':923,'multiline':False]
['text':' Tenant migration abort should have been re-written as primary abort before reaching here.','line_number':931,'multiline':False]
['text':' If the index build was aborted, this serves as a final interruption point. Since the','line_number':934,'multiline':False]
['text':' index builder thread is interrupted before the action is set, this must fail if the build','line_number':935,'multiline':False]
['text':' was aborted.','line_number':936,'multiline':False]
['text':' The calling thread should have interrupted us before signaling an abort action.','line_number':970,'multiline':False]
['text':' Reset the promise as the node has stepped down. Wait for the new primary to','line_number':981,'multiline':False]
['text':' coordinate the index build and send the new signal/action.','line_number':982,'multiline':False]
['text':' Take the MODE_IX lock now, so that when we actually persist the value later, we don't need to','line_number':1018,'multiline':False]
['text':' upgrade the lock.','line_number':1019,'multiline':False]
['text':' Ensure the ReplIndexBuildState has the same indexes as 'indexNames'.','line_number':1037,'multiline':False]
['text':' See if the new commit quorum is satisfiable.','line_number':1056,'multiline':False]
['text':' Read the index builds entry from config.system.indexBuilds collection.','line_number':1063,'multiline':False]
['text':' Index build has not yet started.','line_number':1066,'multiline':False]
['text':' About to update the commit quorum value on-disk. So, take the lock in exclusive mode to','line_number':1087,'multiline':False]
['text':' prevent readers from reading the commit quorum value and making decision on commit quorum','line_number':1088,'multiline':False]
['text':' satisfied with the stale read commit quorum value.','line_number':1089,'multiline':False]
['text':' Check to see the index build hasn't received commit index build signal while updating','line_number':1107,'multiline':False]
['text':' the commit quorum value on-disk.','line_number':1108,'multiline':False]
['text':' If the index builder is already waiting for the commit quorum to be satisfied and the commit','line_number':1115,'multiline':False]
['text':' quorum changes, we need to signal the index builder to make it aware of the change.','line_number':1116,'multiline':False]
['text':' TODO: implement.','line_number':1123,'multiline':False]
['text':' TODO: implement.','line_number':1128,'multiline':False]
['text':' TODO: implement.','line_number':1133,'multiline':False]
['text':' TODO: not yet implemented.','line_number':1139,'multiline':False]
['text':' TODO: not yet implemented.','line_number':1145,'multiline':False]
['text':' namespace mongo','line_number':1148,'multiline':False]
