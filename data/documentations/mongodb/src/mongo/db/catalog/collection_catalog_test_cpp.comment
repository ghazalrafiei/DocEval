['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "cxxabi.h"','line_number':35,'multiline':False]
['text':'*
 * A test fixture that creates a CollectionCatalog and const CollectionPtr& pointer to store in it.
 ','line_number':89,'multiline':True]
['text':' Register dummy collection in catalog.','line_number':117,'multiline':False]
['text':'isDropPending=','line_number':169,'multiline':True]
['text':'isDropPending=','line_number':258,'multiline':True]
['text':'isDropPending=','line_number':327,'multiline':True]
['text':' Create an iterator over the CollectionCatalog and assert that all collections are present.','line_number':332,'multiline':False]
['text':' Iteration ends when the end of the catalog is reached.','line_number':333,'multiline':False]
['text':' Create an iterator over the CollectionCatalog and test that all collections are present.','line_number':338,'multiline':False]
['text':' Iteration ends','line_number':339,'multiline':False]
['text':' when the end of a database-specific section of the catalog is reached.','line_number':340,'multiline':False]
['text':'isDropPending=','line_number':350,'multiline':True]
['text':' Ensure the string value of the NamespaceString of the obtained Collection is equal to','line_number':361,'multiline':False]
['text':' nss.ns_forTest().','line_number':362,'multiline':False]
['text':' Ensure lookups of unknown UUIDs result in null pointers.','line_number':365,'multiline':False]
['text':' Ensure the string value of the obtained NamespaceString is equal to nss.ns_forTest().','line_number':370,'multiline':False]
['text':' Ensure namespace lookups of unknown UUIDs result in empty NamespaceStrings.','line_number':372,'multiline':False]
['text':' Ensure that looking up non-existing UUIDs doesn't affect later registration of those UUIDs.','line_number':382,'multiline':False]
['text':' Make the CollectionPtr yieldable by setting yield impl','line_number':395,'multiline':False]
['text':' Yielding resets a CollectionPtr's internal state to be restored later, provided','line_number':399,'multiline':False]
['text':' the collection has not been dropped or renamed.','line_number':400,'multiline':False]
['text':' Correct collection UUID is required for restore.','line_number':401,'multiline':False]
['text':' The global catalog is used to refresh the CollectionPtr's internal state, so we temporarily','line_number':405,'multiline':False]
['text':' replace the global instance initialized in the service context test fixture with our own.','line_number':406,'multiline':False]
['text':' Before dropping collection, confirm that the CollectionPtr can be restored successfully.','line_number':409,'multiline':False]
['text':' Reset CollectionPtr for post-drop restore test.','line_number':414,'multiline':False]
['text':'isDropPending=','line_number':418,'multiline':True]
['text':' Ensure the lookup returns a null pointer upon removing the colUUID entry.','line_number':419,'multiline':False]
['text':' After dropping the collection, we should fail to restore the CollectionPtr.','line_number':422,'multiline':False]
['text':' Make the CollectionPtr yieldable by setting yield impl','line_number':437,'multiline':False]
['text':' Yielding resets a CollectionPtr's internal state to be restored later, provided','line_number':441,'multiline':False]
['text':' the collection has not been dropped or renamed.','line_number':442,'multiline':False]
['text':' Correct collection UUID is required for restore.','line_number':443,'multiline':False]
['text':' The global catalog is used to refresh the CollectionPtr's internal state, so we temporarily','line_number':447,'multiline':False]
['text':' replace the global instance initialized in the service context test fixture with our own.','line_number':448,'multiline':False]
['text':' Before renaming collection, confirm that the CollectionPtr can be restored successfully.','line_number':451,'multiline':False]
['text':' Reset CollectionPtr for post-rename restore test.','line_number':456,'multiline':False]
['text':' After renaming the collection, we should fail to restore the CollectionPtr.','line_number':465,'multiline':False]
['text':'isDropPending=','line_number':476,'multiline':True]
['text':' Ensure that looking up non-existing UUIDs doesn't affect later registration of those UUIDs.','line_number':494,'multiline':False]
['text':' Ensure that collection still exists after opening the catalog again.','line_number':506,'multiline':False]
['text':'isDropPending=','line_number':526,'multiline':True]
['text':' Ensure that collection still exists after opening the catalog again.','line_number':537,'multiline':False]
['text':' Re-opening the catalog should increment the CollectionCatalog's epoch.','line_number':547,'multiline':False]
['text':' This is extremely contrived as we shouldn't be able to create nss's with tenantIds in','line_number':597,'multiline':False]
['text':' multitenancySupport=false mode, but the behavior of getAllDbNamesForTenant should be well','line_number':598,'multiline':False]
['text':' defined even in the event of a rollback.','line_number':599,'multiline':False]
['text':' Test setting and fetching the profile level for a database.','line_number':689,'multiline':False]
['text':' Requesting a profile level that is not in the _databaseProfileLevel map should return the','line_number':696,'multiline':False]
['text':' default server-wide setting','line_number':697,'multiline':False]
['text':' Setting the default profile level should have not change the result.','line_number':700,'multiline':False]
['text':' Changing the profile level should make fetching it different.','line_number':706,'multiline':False]
['text':'*
 * RAII type for operating at a timestamp. Will remove any timestamping when the object destructs.
 ','line_number':836,'multiline':True]
['text':' Disable table logging. When table logging is enabled, timestamps are discarded by WiredTiger.','line_number':861,'multiline':False]
['text':' Special constructor to _disable_ timestamping. Not to be used directly.','line_number':865,'multiline':False]
['text':'*
     * Starts an index build, but leaves the build in progress rather than ready. Returns the
     * IndexBuildBlock performing the build, necessary to finish the build later via
     * finishIndexBuild below.
     ','line_number':928,'multiline':True]
['text':'forRecover=','line_number':952,'multiline':True]
['text':'*
     * Finishes an index build that was started by createIndexWithoutFinishingBuild.
     ','line_number':961,'multiline':True]
['text':' Adds the collection to the durable catalog.','line_number':1125,'multiline':False]
['text':'allocateDefaultSpace=','line_number':1129,'multiline':True]
['text':' Adds the collection to the in-memory catalog.','line_number':1140,'multiline':False]
['text':' Drop all remaining indexes before dropping the collection.','line_number':1152,'multiline':False]
['text':' This also adds the index ident to the drop-pending reaper.','line_number':1160,'multiline':False]
['text':' Add the collection ident to the drop-pending reaper.','line_number':1164,'multiline':False]
['text':' Drops the collection from the durable catalog.','line_number':1168,'multiline':False]
['text':' Drops the collection from the in-memory catalog.','line_number':1173,'multiline':False]
['text':'isDropPending=','line_number':1175,'multiline':True]
['text':' Drop the collection if it exists. This triggers the same behavior as renaming with','line_number':1186,'multiline':False]
['text':' dropTarget=true.','line_number':1187,'multiline':False]
['text':'fromMigrate=','line_number':1203,'multiline':True]
['text':' This also adds the index ident to the drop-pending reaper.','line_number':1219,'multiline':False]
['text':'*
     * Simulates performing a given ddlOperation concurrently with an untimestamped openCollection
     * lookup.
     *
     * If openSnapshotBeforeCommit is true, the ddlOperation stalls right after the catalog places
     * the collection in _pendingCommitNamespaces but before writing to the durable catalog.
     * Otherwise, the ddlOperation stalls right after writing to the durable catalog but before
     * updating the in-memory catalog.
     ','line_number':1223,'multiline':True]
['text':' Register a hook either preCommit or onCommit that will block until the','line_number':1253,'multiline':False]
['text':' main thread has finished its openCollection lookup.','line_number':1254,'multiline':False]
['text':' Let the main thread know we have committed to the storage engine.','line_number':1258,'multiline':False]
['text':' Wait until the main thread has finished its openCollection lookup.','line_number':1262,'multiline':False]
['text':' The onCommit handler must be registered prior to the DDL operation so it's executed','line_number':1266,'multiline':False]
['text':' before any onCommit handlers set up in the operation.','line_number':1267,'multiline':False]
['text':' Need to use 'registerChangeForCatalogVisibility' so it can happen after storage','line_number':1269,'multiline':False]
['text':' engine commit but before the changes become visible in the catalog.','line_number':1270,'multiline':False]
['text':' The preCommit handler must be registered after the DDL operation so it's executed','line_number':1291,'multiline':False]
['text':' after any preCommit hooks set up in the operation.','line_number':1292,'multiline':False]
['text':' Wait for the thread above to start its commit of the DDL operation.','line_number':1301,'multiline':False]
['text':' Perform the openCollection lookup.','line_number':1307,'multiline':False]
['text':' Stash the catalog so we may perform multiple lookups that will be in sync with our','line_number':1310,'multiline':False]
['text':' snapshot','line_number':1311,'multiline':False]
['text':' Notify the thread that our openCollection lookup is done.','line_number':1316,'multiline':False]
['text':' Check that lookup returns the same instance as openCollection above','line_number':1332,'multiline':False]
['text':' Lookups from the catalog should return the newly opened collection.','line_number':1343,'multiline':False]
['text':' Lookups from the catalog should return the newly opened collection (in this case','line_number':1353,'multiline':False]
['text':' nullptr).','line_number':1354,'multiline':False]
['text':' Lookups from the catalog should return the newly opened collection (in this case','line_number':1361,'multiline':False]
['text':' nullptr).','line_number':1362,'multiline':False]
['text':' Fetch the latest collection instance without the indexes.','line_number':1408,'multiline':False]
['text':' Try to open the collection before it was created.','line_number':1420,'multiline':False]
['text':' Lookups from the catalog should return the newly opened collection (in this case nullptr).','line_number':1428,'multiline':False]
['text':' Open an instance of the collection before the index was created.','line_number':1446,'multiline':False]
['text':' Verify that the CollectionCatalog returns the latest collection with the index present. This','line_number':1455,'multiline':False]
['text':' has to be done in an alternative client as we already have an open snapshot from an earlier','line_number':1456,'multiline':False]
['text':' point-in-time above.','line_number':1457,'multiline':False]
['text':' Ensure the idents are shared between the collection instances.','line_number':1466,'multiline':False]
['text':' Open an instance of the collection when only one of the two indexes were present.','line_number':1491,'multiline':False]
['text':' Verify that the CollectionCatalog returns the latest collection. This has to be done in an','line_number':1500,'multiline':False]
['text':' alternative client as we already have an open snapshot from an earlier point-in-time above.','line_number':1501,'multiline':False]
['text':' Ensure the idents are shared between the collection and index instances.','line_number':1510,'multiline':False]
['text':' Setting the read timestamp to the last DDL operation on the collection returns the latest','line_number':1534,'multiline':False]
['text':' collection.','line_number':1535,'multiline':False]
['text':' Verify that the CollectionCatalog returns the latest collection.','line_number':1543,'multiline':False]
['text':' Ensure the idents are shared between the collection and index instances.','line_number':1548,'multiline':False]
['text':' Maintain a shared_ptr to "x_1", so it's not expired in drop pending map, but not for "y_1".','line_number':1578,'multiline':False]
['text':' Open the collection while both indexes were present.','line_number':1590,'multiline':False]
['text':' Collection is not shared from the latest instance. This has to be done in an  alternative','line_number':1599,'multiline':False]
['text':' client as we already have an open snapshot from an earlier point-in-time above.','line_number':1600,'multiline':False]
['text':' Check use_count(). 2 in the unit test, 1 in the opened collection.','line_number':1615,'multiline':False]
['text':' Check use_count(). 1 in the unit test, 1 in the opened collection.','line_number':1618,'multiline':False]
['text':' Verify that "x_1"'s ident was retrieved from the drop pending map for the opened collection.','line_number':1621,'multiline':False]
['text':' Maintain a shared_ptr to "z_1", so it's not expired in drop pending map. This is required so','line_number':1657,'multiline':False]
['text':' that this index entry's ident will be re-used when openCollection is called.','line_number':1658,'multiline':False]
['text':' Open the collection after the first index drop but before the second. This ensures we get a','line_number':1669,'multiline':False]
['text':' version of the collection whose indexes are {x, z} in the durable catalog, while the','line_number':1670,'multiline':False]
['text':' metadata for the in-memory latest collection contains indexes {x, {}, {}} (where {}','line_number':1671,'multiline':False]
['text':' corresponds to a default-constructed object). The index catalog entry for the z index will be','line_number':1672,'multiline':False]
['text':' contained in the drop pending reaper. So the CollectionImpl object created by openCollection','line_number':1673,'multiline':False]
['text':' will reuse index idents for indexes x and z.','line_number':1674,'multiline':False]
['text':'','line_number':1675,'multiline':False]
['text':' This test originally reproduced a bug where:','line_number':1676,'multiline':False]
['text':'     * The index catalog entry object for z contained an _indexOffset of 2, because of its','line_number':1677,'multiline':False]
['text':'       location in the latest catalog entry's metadata.indexes array','line_number':1678,'multiline':False]
['text':'     * openCollection would re-use the index catalog entry for z (with _indexOffset=2), but','line_number':1679,'multiline':False]
['text':'       it would store this entry at position 1 in its metadata.indexes array','line_number':1680,'multiline':False]
['text':'     * Something would try to check if the index was multikey, and it would use the offset of','line_number':1681,'multiline':False]
['text':'       2 contained in the IndexCatalogEntry, but this was incorrect for the CollectionImpl','line_number':1682,'multiline':False]
['text':'       object, so it would fire an invariant.','line_number':1683,'multiline':False]
['text':' Collection is not shared from the latest instance. This has to be done in an  alternative','line_number':1692,'multiline':False]
['text':' client as we already have an open snapshot from an earlier point-in-time above.','line_number':1693,'multiline':False]
['text':' Maintain a shared_ptr to the catalog so that collection "a.b" isn't expired in the drop','line_number':1718,'multiline':False]
['text':' pending map after we drop the collections.','line_number':1719,'multiline':False]
['text':' Make the collections drop pending.','line_number':1726,'multiline':False]
['text':' Set the read timestamp to be before the drop timestamp.','line_number':1730,'multiline':False]
['text':' Open "a.b", which is not expired in the drop pending map.','line_number':1736,'multiline':False]
['text':' Once snapshot is abandoned, openedColl has been released so it should not match the','line_number':1746,'multiline':False]
['text':' collection lookup.','line_number':1747,'multiline':False]
['text':' Open "c.d" which is expired in the drop pending map.','line_number':1756,'multiline':False]
['text':' Before openCollection, looking up the collection returns null.','line_number':1759,'multiline':False]
['text':' Maintain a shared_ptr to the catalog so that the collection "a.b" isn't expired in the drop','line_number':1787,'multiline':False]
['text':' pending map after we drop it.','line_number':1788,'multiline':False]
['text':' Make the collection drop pending.','line_number':1795,'multiline':False]
['text':' Open the collection before the index was created. The drop pending collection is incompatible','line_number':1798,'multiline':False]
['text':' as it has an index entry. But we can still use the drop pending collections shared state to','line_number':1799,'multiline':False]
['text':' instantiate a new collection.','line_number':1800,'multiline':False]
['text':' Ensure the idents are shared between the opened collection and the drop pending collection.','line_number':1809,'multiline':False]
['text':' Maintain a shared_ptr to the catalog so that the reaper cannot drop the collection ident.','line_number':1823,'multiline':False]
['text':' Mark the collection as drop pending. The dropToken in the ident reaper is not expired as we','line_number':1828,'multiline':False]
['text':' still have a reference.','line_number':1829,'multiline':False]
['text':' Ident is not expired and should not be removed.','line_number':1837,'multiline':False]
['text':' The ident is now expired and should be removed the next time the ident reaper runs.','line_number':1853,'multiline':False]
['text':' Remove the collection reference in UncommittedCatalogUpdates.','line_number':1858,'multiline':False]
['text':' Now we fail to open the collection as the ident has been removed.','line_number':1864,'multiline':False]
['text':' Make the collection drop pending. The dropToken in the ident reaper is now expired as we','line_number':1881,'multiline':False]
['text':' don't maintain any references to the collection.','line_number':1882,'multiline':False]
['text':' Open the collection, which marks the ident as in use before running the ident reaper.','line_number':1886,'multiline':False]
['text':' Ident is marked as in use and it should not be removed.','line_number':1898,'multiline':False]
['text':' Run the ident reaper before opening the collection.','line_number':1907,'multiline':False]
['text':' The dropToken is expired as the ident is no longer in use.','line_number':1910,'multiline':False]
['text':' Now we fail to open the collection as the ident has been removed.','line_number':1915,'multiline':False]
['text':' Perform index drops at different timestamps. By not maintaining shared_ptrs to the these','line_number':1945,'multiline':False]
['text':' indexes, their idents are expired.','line_number':1946,'multiline':False]
['text':' Maintain a shared_ptr to the catalog so that the reaper cannot drop the collection ident.','line_number':1950,'multiline':False]
['text':' Open the collection using shared state before any index drops.','line_number':1961,'multiline':False]
['text':' All idents are marked as in use and none should be removed.','line_number':1971,'multiline':False]
['text':' Open the collection using shared state after a single index was dropped.','line_number':1977,'multiline':False]
['text':' Only the collection and 'y' index idents are marked as in use. The 'x' index ident will','line_number':1992,'multiline':False]
['text':' be removed.','line_number':1993,'multiline':False]
['text':' Open the collection using shared state before any indexes were created.','line_number':1999,'multiline':False]
['text':' Try to open the collection using shared state when both indexes were present. This should','line_number':2011,'multiline':False]
['text':' fail as the ident for index 'x' was already removed.','line_number':2012,'multiline':False]
['text':' Drop all remaining idents.','line_number':2023,'multiline':False]
['text':' All idents are removed so opening the collection before any indexes were created should','line_number':2029,'multiline':False]
['text':' fail.','line_number':2030,'multiline':False]
['text':' Perform drops at different timestamps. By not maintaining shared_ptrs to the these, their','line_number':2061,'multiline':False]
['text':' idents are expired.','line_number':2062,'multiline':False]
['text':' Open the collection before any index drops.','line_number':2071,'multiline':False]
['text':' All idents are marked as in use and none should be removed.','line_number':2080,'multiline':False]
['text':' Open the collection after the 'x' index was dropped.','line_number':2086,'multiline':False]
['text':' The 'x' index ident will be removed.','line_number':2100,'multiline':False]
['text':' Open the collection before any indexes were created.','line_number':2106,'multiline':False]
['text':' Try to open the collection before any index drops. Because the 'x' index ident is already','line_number':2117,'multiline':False]
['text':' dropped, this should fail.','line_number':2118,'multiline':False]
['text':' Drop all remaining idents and try to open the collection. This should fail.','line_number':2129,'multiline':False]
['text':' Test that the collection is released when the storage snapshot is abandoned.','line_number':2157,'multiline':False]
['text':' Test that the collection is released when the storage snapshot is committed.','line_number':2176,'multiline':False]
['text':' Test that the collection is released when the storage snapshot is aborted.','line_number':2200,'multiline':False]
['text':' The storage snapshot is aborted when the WriteUnitOfWork destructor runs.','line_number':2216,'multiline':False]
['text':' When the snapshot is opened right before the create is committed to the durable catalog, the','line_number':2251,'multiline':False]
['text':' collection instance should not exist yet.','line_number':2252,'multiline':False]
['text':' When the snapshot is opened right after the create is committed to the durable catalog, the','line_number':2261,'multiline':False]
['text':' collection instance should exist.','line_number':2262,'multiline':False]
['text':' When the snapshot is opened right before the create is committed to the durable catalog, the','line_number':2273,'multiline':False]
['text':' collection instance should not exist yet.','line_number':2274,'multiline':False]
['text':' When the snapshot is opened right after the create is committed to the durable catalog, the','line_number':2285,'multiline':False]
['text':' collection instance should exist.','line_number':2286,'multiline':False]
['text':' When the snapshot is opened right before the drop is committed to the durable catalog, the','line_number':2298,'multiline':False]
['text':' collection instance should be returned.','line_number':2299,'multiline':False]
['text':' When the snapshot is opened right after the drop is committed to the durable catalog, no','line_number':2311,'multiline':False]
['text':' collection instance should be returned.','line_number':2312,'multiline':False]
['text':' When the snapshot is opened right before the drop is committed to the durable catalog, the','line_number':2328,'multiline':False]
['text':' collection instance should be returned.','line_number':2329,'multiline':False]
['text':' When the snapshot is opened right after the drop is committed to the durable catalog, no','line_number':2344,'multiline':False]
['text':' collection instance should be returned.','line_number':2345,'multiline':False]
['text':' When the snapshot is opened right before the rename is committed to the durable catalog, and','line_number':2359,'multiline':False]
['text':' the openCollection looks for the originalNss, the collection instance should be returned.','line_number':2360,'multiline':False]
['text':' When the snapshot is opened right after the rename is committed to the durable catalog, and','line_number':2377,'multiline':False]
['text':' the openCollection looks for the originalNss, no collection instance should be returned.','line_number':2378,'multiline':False]
['text':' Verify that we can find the Collection when we search by UUID when the setup occured','line_number':2381,'multiline':False]
['text':' during concurrent rename (rename is not affecting UUID), even if we can't find it by','line_number':2382,'multiline':False]
['text':' namespace.','line_number':2383,'multiline':False]
['text':' When the snapshot is opened right before the rename is committed to the durable catalog, and','line_number':2406,'multiline':False]
['text':' the openCollection looks for the newNss, no collection instance should be returned.','line_number':2407,'multiline':False]
['text':' Verify that we can find the Collection when we search by UUID when the setup occured','line_number':2410,'multiline':False]
['text':' during concurrent rename (rename is not affecting UUID), even if we can't find it by','line_number':2411,'multiline':False]
['text':' namespace.','line_number':2412,'multiline':False]
['text':' When the snapshot is opened right after the rename is committed to the durable catalog, and','line_number':2432,'multiline':False]
['text':' the openCollection looks for the newNss, the collection instance should be returned.','line_number':2433,'multiline':False]
['text':' When the snapshot is opened right before the rename is committed to the durable catalog, and','line_number':2450,'multiline':False]
['text':' the openCollection looks for the originalNss, the collection instance should be returned.','line_number':2451,'multiline':False]
['text':' Verify that we cannot find the Collection when we search by the new namespace as','line_number':2454,'multiline':False]
['text':' the rename was committed when we read.','line_number':2455,'multiline':False]
['text':' When the snapshot is opened right after the rename is committed to the durable catalog, and','line_number':2475,'multiline':False]
['text':' the openCollection looks for the originalNss, no collection instance should be returned.','line_number':2476,'multiline':False]
['text':' Verify that we cannot find the Collection','line_number':2487,'multiline':False]
['text':' when we search by the original namespace as','line_number':2488,'multiline':False]
['text':' the rename was committed when we read.','line_number':2489,'multiline':False]
['text':' We expect to find the UUID for the original collection','line_number':2507,'multiline':False]
['text':' When the snapshot is opened right before the rename is committed to the durable catalog, and','line_number':2512,'multiline':False]
['text':' the openCollection looks for the targetNss, we find the target collection.','line_number':2513,'multiline':False]
['text':' Verify that we can find the original Collection when we search by original UUID.','line_number':2516,'multiline':False]
['text':' We expect to find the UUID for the original collection','line_number':2538,'multiline':False]
['text':' When the snapshot is opened right after the rename is committed to the durable catalog, and','line_number':2546,'multiline':False]
['text':' the openCollection looks for the targetNss, we find the original collection.','line_number':2547,'multiline':False]
['text':' Verify that search by UUID is as expected and returns the target collection','line_number':2550,'multiline':False]
['text':' We expect to find the UUID for the original collection','line_number':2574,'multiline':False]
['text':' When the snapshot is opened right before the rename is committed to the durable catalog, and','line_number':2583,'multiline':False]
['text':' the openCollection looks for the original UUID, we should find the original collection','line_number':2584,'multiline':False]
['text':' Verify that we can find the original Collection when we search by namespace as rename','line_number':2595,'multiline':False]
['text':' has not committed yet.','line_number':2596,'multiline':False]
['text':' Verify that we can find the target Collection when we search by namespace as rename','line_number':2602,'multiline':False]
['text':' has not committed yet.','line_number':2603,'multiline':False]
['text':' We expect to find the UUID for the original collection','line_number':2622,'multiline':False]
['text':' When the snapshot is opened right after the rename is committed to the durable catalog, and','line_number':2628,'multiline':False]
['text':' the openCollection looks for the newNss, no collection instance should be returned.','line_number':2629,'multiline':False]
['text':' Verify that we cannot find the Collection when we search by the original namespace.','line_number':2640,'multiline':False]
['text':' Verify that we can find the original Collection UUID when we search by namespace.','line_number':2645,'multiline':False]
['text':' When the snapshot is opened right before the rename is committed to the durable catalog, and','line_number':2672,'multiline':False]
['text':' the openCollection looks for the original UUID, we should find the original collection','line_number':2673,'multiline':False]
['text':' Verify that we can find the original Collection when we search by namespace as rename','line_number':2684,'multiline':False]
['text':' has not committed yet.','line_number':2685,'multiline':False]
['text':' Verify that we can find the target Collection when we search by namespace as rename','line_number':2691,'multiline':False]
['text':' has not committed yet.','line_number':2692,'multiline':False]
['text':' We expect to find the UUID for the original collection','line_number':2711,'multiline':False]
['text':' When the snapshot is opened right after the rename is committed to the durable catalog, and','line_number':2720,'multiline':False]
['text':' the openCollection looks for the newNss, no collection instance should be returned.','line_number':2721,'multiline':False]
['text':' Verify that we can find the original Collection UUID when we search by namespace.','line_number':2732,'multiline':False]
['text':' When the snapshot is opened right before the second index create is committed to the durable','line_number':2754,'multiline':False]
['text':' catalog, the collection instance should not have the second index.','line_number':2755,'multiline':False]
['text':' When the snapshot is opened right before the second index create is committed to the durable','line_number':2788,'multiline':False]
['text':' catalog, the collection instance should not have the second index.','line_number':2789,'multiline':False]
['text':' When the snapshot is opened right before the second index create is committed to the durable','line_number':2817,'multiline':False]
['text':' catalog, the collection instance should have both indexes.','line_number':2818,'multiline':False]
['text':' When the snapshot is opened right after the second index create is committed to the durable','line_number':2851,'multiline':False]
['text':' catalog, the collection instance should have both indexes.','line_number':2852,'multiline':False]
['text':' When the snapshot is opened right before the second index create is committed to the durable','line_number':2883,'multiline':False]
['text':' catalog, the collection instance should not have the second index.','line_number':2884,'multiline':False]
['text':' When the snapshot is opened right before the second index create is committed to the durable','line_number':2921,'multiline':False]
['text':' catalog, the collection instance should not have the second index.','line_number':2922,'multiline':False]
['text':' When the snapshot is opened right before the second index create is committed to the durable','line_number':2953,'multiline':False]
['text':' catalog, the collection instance should have both indexes.','line_number':2954,'multiline':False]
['text':' When the snapshot is opened right after the second index create is committed to the durable','line_number':2991,'multiline':False]
['text':' catalog, the collection instance should have both indexes.','line_number':2992,'multiline':False]
['text':' When the snapshot is opened right before the index drop is committed to the durable','line_number':3026,'multiline':False]
['text':' catalog, the collection instance should not have the second index.','line_number':3027,'multiline':False]
['text':' When the snapshot is opened right before the index drop is committed to the durable','line_number':3058,'multiline':False]
['text':' catalog, the collection instance should not have the second index.','line_number':3059,'multiline':False]
['text':' When the snapshot is opened right before the index drop is committed to the durable','line_number':3084,'multiline':False]
['text':' catalog, the collection instance should not have the second index.','line_number':3085,'multiline':False]
['text':' When the snapshot is opened right after the index drop is committed to the durable','line_number':3116,'multiline':False]
['text':' catalog, the collection instance should not have the second index.','line_number':3117,'multiline':False]
['text':' When the snapshot is opened right before the index drop is committed to the durable','line_number':3145,'multiline':False]
['text':' catalog, the collection instance should not have the second index.','line_number':3146,'multiline':False]
['text':' When the snapshot is opened right before the index drop is committed to the durable','line_number':3181,'multiline':False]
['text':' catalog, the collection instance should not have the second index.','line_number':3182,'multiline':False]
['text':' When the snapshot is opened right before the index drop is committed to the durable','line_number':3210,'multiline':False]
['text':' catalog, the collection instance should not have the second index.','line_number':3211,'multiline':False]
['text':' When the snapshot is opened right after the index drop is committed to the durable','line_number':3246,'multiline':False]
['text':' catalog, the collection instance should not have the second index.','line_number':3247,'multiline':False]
['text':' Confirm openCollection with timestamp createCollectionTs indicates no indexes.','line_number':3267,'multiline':False]
['text':' Lookups from the catalog should return the newly opened collection.','line_number':3277,'multiline':False]
['text':' Confirm openCollection with timestamp createIndexTs returns the same value as before, once','line_number':3288,'multiline':False]
['text':' the index build has finished (since it can no longer use the latest state).','line_number':3289,'multiline':False]
['text':' Lookups from the catalog should return the newly opened collection.','line_number':3299,'multiline':False]
['text':' Resolving the UUID throws NamespaceNotFound as the collection is no longer in the latest','line_number':3322,'multiline':False]
['text':' collection catalog.','line_number':3323,'multiline':False]
['text':' Resolving the UUID looks in OpenedCollections to try to resolve the UUID.','line_number':3336,'multiline':False]
['text':' Start but do not finish an index build.','line_number':3348,'multiline':False]
['text':' In a different client, open the latest collection instance and verify the index is not ready.','line_number':3361,'multiline':False]
['text':' Now finish the index build on the original client.','line_number':3377,'multiline':False]
['text':' The index entry in the different client remains untouched.','line_number':3389,'multiline':False]
['text':' This tests checks the following sequence: untimestamped collection create','line_number':3397,'multiline':False]
['text':' -> timestamped drop -> untimestamped collection recreate.','line_number':3398,'multiline':False]
['text':' Initialize the oldest timestamp.','line_number':3401,'multiline':False]
['text':' Create and drop the collection. We have a time window where the namespace exists.','line_number':3408,'multiline':False]
['text':' allowMixedModeWrite ','line_number':3409,'multiline':True]
['text':' Before performing cleanup, re-create the collection.','line_number':3412,'multiline':False]
['text':' allowMixedModeWrite ','line_number':3413,'multiline':True]
['text':' Perform collection catalog cleanup.','line_number':3415,'multiline':False]
['text':' Drop the re-created collection.','line_number':3422,'multiline':False]
['text':' Cleanup again.','line_number':3425,'multiline':False]
['text':' namespace','line_number':3433,'multiline':False]
['text':' namespace mongo','line_number':3434,'multiline':False]
