['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "cxxabi.h"','line_number':43,'multiline':False]
['text':'*
 * If a collection is initially created with an untimestamped write, but later DDL operations
 * (including drop) on this collection are timestamped, set this decoration to 'true' for
 * HistoricalCatalogIdTracker to support this mixed mode write sequence for a collection.
 *
 * CAUTION: This decoration is not to support other mixed mode write sequences (such as
 * timestamped collection creation followed by untimestamped drop) that violates wiredtiger's
 * timestamp rules.
 ','line_number':95,'multiline':True]
['text':' Catalog instance for batched write when ongoing. The atomic bool is used to determine if a','line_number':117,'multiline':False]
['text':' batched write is ongoing without having to take locks.','line_number':118,'multiline':False]
['text':' Set to keep track of all collection instances cloned in this batched writer that do not currently','line_number':121,'multiline':False]
['text':' need to be re-cloned.','line_number':122,'multiline':False]
['text':' Set to keep track of all collection instances that have been cloned in a WUOW that needs to be','line_number':124,'multiline':False]
['text':' restored in case of rollback.','line_number':125,'multiline':False]
['text':'*
 * Returns true if the collection is compatible with the read timestamp.
 ','line_number':131,'multiline':True]
['text':' Collection is valid in all snapshots.','line_number':142,'multiline':False]
['text':' CSFLE 1 collections have a schema validator with the encrypt keyword','line_number':176,'multiline':False]
['text':' namespace','line_number':218,'multiline':False]
['text':'*
 * Defines a new serverStatus section "collectionCatalog".
 ','line_number':220,'multiline':True]
['text':'*
 * Publishes all uncommitted Collection actions registered on UncommittedCatalogUpdates to the
 * catalog. All catalog updates are performed under the same write to ensure no external observer
 * can see a partial update. Cleans up UncommittedCatalogUpdates on both commit and rollback to
 * make it behave like a decoration on a WriteUnitOfWork.
 *
 * It needs to be registered with registerChangeForCatalogVisibility so other commit handlers can
 * still write to this Collection.
 ','line_number':259,'multiline':True]
['text':' Nothing to do, avoid calling CollectionCatalog::write.','line_number':309,'multiline':False]
['text':' First do a pass to check that we are not conflicting with any namespace that we are','line_number':313,'multiline':False]
['text':' trying to create.','line_number':314,'multiline':False]
['text':' We did not conflict with any namespace, mark all the collections as pending commit.','line_number':322,'multiline':False]
['text':' Mark the namespace as pending commit even if we don't have a collection instance.','line_number':328,'multiline':False]
['text':' If we have a collection instance for this entry also mark the uuid as pending','line_number':333,'multiline':False]
['text':' Drops do not have a collection instance but set their UUID in the entry. Mark','line_number':337,'multiline':False]
['text':' it as pending with no collection instance.','line_number':338,'multiline':False]
['text':' Mark that we've successfully run preCommit, this allows rollback to clean up the','line_number':344,'multiline':False]
['text':' collections marked as pending commit. We need to make sure we do not clean anything','line_number':345,'multiline':False]
['text':' up for other transactions.','line_number':346,'multiline':False]
['text':' Create catalog write jobs for all updates registered in this WriteUnitOfWork','line_number':355,'multiline':False]
['text':' We just need to do modifications on 'from' here. 'to' is taken care','line_number':370,'multiline':False]
['text':' of by a separate kWritableCollection entry.','line_number':371,'multiline':False]
['text':' Override existing Collection on this namespace','line_number':398,'multiline':False]
['text':'ts=','line_number':401,'multiline':True]
['text':' Write all catalog updates to the catalog in the same write to ensure atomicity.','line_number':446,'multiline':False]
['text':' Skip rollback logic if we failed to preCommit this transaction. We must make sure we','line_number':459,'multiline':False]
['text':' don't clean anything up for other transactions.','line_number':460,'multiline':False]
['text':' Nothing to do, avoid calling CollectionCatalog::write.','line_number':467,'multiline':False]
['text':' Entry without collection, nothing more to do','line_number':480,'multiline':False]
['text':'*
 * Helper to manage the lifetime of cloned collection instances during batch writes.
 *
 * Batched writes and writes under the exclusive global lock are special in the way that they do not
 * require a WUOW to perform the writes. However, WUOW may be used and they may roll back for any
 * reason even when the global lock is held in exclusive mode. The copy-on-write semantics on the
 * Collection type should behave as close in this case as regular Collection writes under exclusive
 * Collection lock.
 *
 * The first request for a writable Collection should make a clone that may be used for writes until
 * any of the following:
 * 1. The WUOW commits
 * 2. The WUOW rolls back
 * 3. The batched catalog write ends (the case when no WUOW is used)
 *
 * If the WUOW rolls back, the cloned collection instance should be discarded and the original
 * instance should be stored in the catalog instance used for the batched write.
 *
 * If further writes to this collection is needed within the same batched write but after the WUOW
 * has committed or rolled back a new clone is needed.
 ','line_number':494,'multiline':True]
['text':' Mark this instance as cloned for the batched writer, this will prevent further clones for','line_number':521,'multiline':False]
['text':' this Collection.','line_number':522,'multiline':False]
['text':' Do not update min valid timestamp in batched write as the write is not corresponding to','line_number':525,'multiline':False]
['text':' an oplog entry. If the write require an update to this timestamp it is the responsibility','line_number':526,'multiline':False]
['text':' of the user.','line_number':527,'multiline':False]
['text':' Nothing more to do if we are not in a WUOW.','line_number':531,'multiline':False]
['text':' Register one change to the recovery unit, as we are in a batched write it is likely that','line_number':536,'multiline':False]
['text':' we will clone multiple collections. This allows all of them to re-use a single recovery','line_number':537,'multiline':False]
['text':' unit change.','line_number':538,'multiline':False]
['text':' Register commit/rollback handlers _if_ we are in an WUOW.','line_number':544,'multiline':False]
['text':' Push this instance to the set of collections cloned in this WUOW.','line_number':548,'multiline':False]
['text':' Clear the flag that this instance is used for batch write, this will trigger new','line_number':554,'multiline':False]
['text':' copy-on-write next time it is needed.','line_number':555,'multiline':False]
['text':' Mark that this WUOW is finished.','line_number':559,'multiline':False]
['text':' Restore the original collection instances to the batched catalog','line_number':564,'multiline':False]
['text':' Clear the flag that this instance is used for batch write, this will trigger new','line_number':568,'multiline':False]
['text':' copy-on-write next time it is needed.','line_number':569,'multiline':False]
['text':' Mark that this WUOW is finished.','line_number':573,'multiline':False]
['text':' If there is a batched catalog write ongoing and we are the one doing it return this instance','line_number':647,'multiline':False]
['text':' so we can observe our own writes. There may be other callers that reads the CollectionCatalog','line_number':648,'multiline':False]
['text':' without any locks, they must see the immutable regular instance. We can do a relaxed load','line_number':649,'multiline':False]
['text':' here because the value only matters for the thread that set it. The wrong value for other','line_number':650,'multiline':False]
['text':' threads always results in the non-batched write branch to be taken. Futhermore, the second','line_number':651,'multiline':False]
['text':' part of the condition is checking the lock state will give us sequentially consistent','line_number':652,'multiline':False]
['text':' ordering.','line_number':653,'multiline':False]
['text':' We should never have ongoing batching here. When batching is in progress the caller should','line_number':667,'multiline':False]
['text':' use the overload with OperationContext so we can verify that the global exlusive lock is','line_number':668,'multiline':False]
['text':' being held.','line_number':669,'multiline':False]
['text':' It is potentially expensive to copy the collection catalog so we batch the operations by only','line_number':672,'multiline':False]
['text':' having one concurrent thread copying the catalog and executing all the write jobs.','line_number':673,'multiline':False]
['text':' Used to wait for job to complete by worker thread','line_number':681,'multiline':False]
['text':' Exception storage if we threw during job execution, so we can transfer the exception','line_number':685,'multiline':False]
['text':' back to the calling thread','line_number':686,'multiline':False]
['text':' The job is completed when the catalog we modified has been committed back to the','line_number':689,'multiline':False]
['text':' storage or if we threw during its execution','line_number':690,'multiline':False]
['text':' Shared state for completion info as JobEntry's gets deleted when we are finished','line_number':694,'multiline':False]
['text':' executing. No shared state means that this job belongs to the same thread executing them.','line_number':695,'multiline':False]
['text':' Protecting the two globals above','line_number':702,'multiline':False]
['text':' Current batch of jobs to execute','line_number':706,'multiline':False]
['text':' If worker already exists, then wait on our condition variable until the job is completed','line_number':712,'multiline':False]
['text':' Throw any exception that was caught during execution of our job. Make sure we destroy','line_number':722,'multiline':False]
['text':' the exception_ptr on the same thread that throws the exception to avoid a data race','line_number':723,'multiline':False]
['text':' between destroying the exception_ptr and reading the exception.','line_number':724,'multiline':False]
['text':' No worker existed, then we take this responsibility','line_number':731,'multiline':False]
['text':' Implementation for thread with worker responsibility below, only one thread at a time can be','line_number':736,'multiline':False]
['text':' in here. Keep track of completed jobs so we can notify them when we've written back the','line_number':737,'multiline':False]
['text':' catalog to storage','line_number':738,'multiline':False]
['text':' hold onto base so if we need to delete it we can do it outside of the lock','line_number':743,'multiline':False]
['text':' copy the collection catalog, this could be expensive, but we will only have one pending','line_number':745,'multiline':False]
['text':' collection in flight at a given time','line_number':746,'multiline':False]
['text':' Execute jobs until we drain the queue','line_number':749,'multiline':False]
['text':' Store any exception thrown during job execution so we can notify the calling thread','line_number':752,'multiline':False]
['text':' Transfer the jobs we just executed to the completed list','line_number':762,'multiline':False]
['text':' Queue is empty, store catalog and relinquish responsibility of being worker thread','line_number':767,'multiline':False]
['text':' Transfer jobs in queue to the pending list','line_number':773,'multiline':False]
['text':' Calling the writer must be done with the GlobalLock held. Otherwise we risk having the','line_number':794,'multiline':False]
['text':' BatchedCollectionCatalogWriter and this caller concurrently modifying the catalog. This is','line_number':795,'multiline':False]
['text':' because normal operations calling this will all be serialized, but','line_number':796,'multiline':False]
['text':' BatchedCollectionCatalogWriter skips this mechanism as it knows it is the sole user of the','line_number':797,'multiline':False]
['text':' server by holding a Global MODE_X lock.','line_number':798,'multiline':False]
['text':' If global MODE_X lock are held we can re-use a cloned CollectionCatalog instance when','line_number':801,'multiline':False]
['text':' 'ongoingBatchedWrite' and 'batchedCatalogWriteInstance' are set. Make sure we are the one','line_number':802,'multiline':False]
['text':' holding the write lock.','line_number':803,'multiline':False]
['text':' Usually, CappedSnapshots must be established before opening the storage snapshot. Thus,','line_number':968,'multiline':False]
['text':' the lookup must be done from the in-memory catalog. It is possible that the required','line_number':969,'multiline':False]
['text':' CappedSnapshot was not properly established when this operation was collection creation,','line_number':970,'multiline':False]
['text':' because a Collection instance was not found in the in-memory catalog.','line_number':971,'multiline':False]
['text':' This can only be the case with concurrent collection creation (MODE_IX), and it is','line_number':973,'multiline':False]
['text':' semantically correct to establish an empty snapshot, causing the reader to see no','line_number':974,'multiline':False]
['text':' records. Other DDL ops should have successfully established the snapshot, because a','line_number':975,'multiline':False]
['text':' Collection must have been found in the in-memory catalog.','line_number':976,'multiline':False]
['text':'isNewCollection=','line_number':978,'multiline':True]
['text':' We iterate both already committed and uncommitted changes and validate them with','line_number':993,'multiline':False]
['text':' the storage snapshot','line_number':994,'multiline':False]
['text':' Don't need to open the collection if it was already previously instantiated.','line_number':1012,'multiline':False]
['text':' The implementation of openCollection() is quite different at a timestamp compared to at','line_number':1039,'multiline':False]
['text':' latest. Separated the implementation into helper functions and we call the right one','line_number':1040,'multiline':False]
['text':' depending on the input parameters.','line_number':1041,'multiline':False]
['text':' When openCollection is called with no timestamp, the namespace must be pending commit. We','line_number':1053,'multiline':False]
['text':' compare the collection instance in _pendingCommitNamespaces and the collection instance in','line_number':1054,'multiline':False]
['text':' the in-memory catalog with the durable catalog entry to determine which instance to return.','line_number':1055,'multiline':False]
['text':' At least one of latest and pending should be a valid pointer.','line_number':1076,'multiline':False]
['text':' If pendingCollection is nullptr then it is a concurrent drop and the uuid should exist at','line_number':1084,'multiline':False]
['text':' latest.','line_number':1085,'multiline':False]
['text':' If pendingCollection is nullptr, the collection is being dropped, so latestCollection','line_number':1103,'multiline':False]
['text':' must be non-nullptr and must contain a uuid.','line_number':1104,'multiline':False]
['text':' If the catalog entry is not found in our snapshot then the collection is being dropped and we','line_number':1108,'multiline':False]
['text':' can observe the drop. Lookups by this namespace or uuid should not find a collection.','line_number':1109,'multiline':False]
['text':' If we performed this lookup by UUID we could be in a case where we're looking up','line_number':1111,'multiline':False]
['text':' concurrently with a rename with dropTarget=true where the UUID that we use is the target','line_number':1112,'multiline':False]
['text':' that got dropped. If that rename has committed we need to put the correct collection','line_number':1113,'multiline':False]
['text':' under open collection for this namespace. We can detect this case by comparing the','line_number':1114,'multiline':False]
['text':' catalogId with what is pending for this namespace.','line_number':1115,'multiline':False]
['text':' When trying to open the latest collection by namespace and the catalog entry has a different','line_number':1128,'multiline':False]
['text':' namespace in our snapshot, then there is a rename operation concurrent with this call.','line_number':1129,'multiline':False]
['text':' There are two types of rename depending on the dropTarget flag.','line_number':1132,'multiline':False]
['text':' When there is a rename with dropTarget=true the two possible choices for the','line_number':1135,'multiline':False]
['text':' collection we need to observe are different logical collections, they have different','line_number':1136,'multiline':False]
['text':' UUID and catalogId. In this case storing a single entry in open collections is','line_number':1137,'multiline':False]
['text':' sufficient. We know that the instance we are looking for must be under','line_number':1138,'multiline':False]
['text':' 'latestCollection' as we used the catalogId from 'pendingCollection' when fetching','line_number':1139,'multiline':False]
['text':' durable catalog entry and the namespace in it did not match the namespace for','line_number':1140,'multiline':False]
['text':' 'pendingCollection' (the rename has not been comitted yet)','line_number':1141,'multiline':False]
['text':' For a regular rename of the same logical collection with dropTarget=false have the same','line_number':1146,'multiline':False]
['text':' UUID and catalogId for the two choices. In this case we need to store entries under open','line_number':1147,'multiline':False]
['text':' collections for two namespaces (rename 'from' and 'to') so we can make sure lookups by','line_number':1148,'multiline':False]
['text':' UUID is supported and will return a Collection with its namespace in sync with the','line_number':1149,'multiline':False]
['text':' storage snapshot. Like above, the correct instance is either in the catalog or under','line_number':1150,'multiline':False]
['text':' pending. First lookup in pending by UUID to determine if it contains the right namespace.','line_number':1151,'multiline':False]
['text':' If pending by UUID does not contain the right namespace, a regular lookup in','line_number':1158,'multiline':False]
['text':' the catalog by UUID should have it.','line_number':1159,'multiline':False]
['text':' Last, mark 'nss' as not existing','line_number':1165,'multiline':False]
['text':' When trying to open the latest collection by UUID and the Collection instances has different','line_number':1170,'multiline':False]
['text':' namespaces, then there is a rename operation concurrent with this call. We need to store','line_number':1171,'multiline':False]
['text':' entries under uncommitted catalog changes for two namespaces (rename 'from' and 'to') so we','line_number':1172,'multiline':False]
['text':' can make sure lookups by UUID is supported and will return a Collection with its namespace in','line_number':1173,'multiline':False]
['text':' sync with the storage snapshot.','line_number':1174,'multiline':False]
['text':' If this is a rename with dropTarget=true and we're looking up with the 'from' UUID','line_number':1178,'multiline':False]
['text':' before the rename committed, the namespace would correspond to a valid collection','line_number':1179,'multiline':False]
['text':' that we need to store under open collections.','line_number':1180,'multiline':False]
['text':' Use the pendingCollection if there is no latestCollection or if the metadata of the','line_number':1207,'multiline':False]
['text':' latestCollection doesn't match the durable catalogEntry.','line_number':1208,'multiline':False]
['text':' If the latest collection doesn't exist then the pending collection must exist as it's','line_number':1210,'multiline':False]
['text':' being created in this snapshot. Otherwise, if the latest collection is incompatible','line_number':1211,'multiline':False]
['text':' with this snapshot, then the change came from an uncommitted update by an operation','line_number':1212,'multiline':False]
['text':' operating on this snapshot. If both latestCollection and pendingCollection exists check','line_number':1213,'multiline':False]
['text':' if their uuid differs in which case this is a rename with dropTarget=true that just','line_number':1214,'multiline':False]
['text':' committed.','line_number':1215,'multiline':False]
['text':' If neither `latestCollection` or `pendingCollection` match the metadata we fully instantiate','line_number':1224,'multiline':False]
['text':' a new collection instance from durable storage that is guaranteed to match. This can happen','line_number':1225,'multiline':False]
['text':' when multikey is not consistent with the storage snapshot. We use 'pendingCollection' as the','line_number':1226,'multiline':False]
['text':' base when available as it might contain an index that is about to be added. Dropped indexes','line_number':1227,'multiline':False]
['text':' can be found through other means in the drop pending state.','line_number':1228,'multiline':False]
['text':'readTimestamp=','line_number':1235,'multiline':True]
['text':' This may nullptr if the collection was not instantiated successfully. This is the case when','line_number':1238,'multiline':False]
['text':' timestamps aren't used (e.g. standalone mode) even though the durable catalog entry was','line_number':1239,'multiline':False]
['text':' found. When timestamps aren't used, the drop pending reaper immediately drops idents which','line_number':1240,'multiline':False]
['text':' may be needed to instantiate this collection.','line_number':1241,'multiline':False]
['text':' Try to find a catalog entry matching 'readTimestamp'.','line_number':1252,'multiline':False]
['text':' Return the in-memory Collection instance if it is compatible with the read timestamp.','line_number':1274,'multiline':False]
['text':' Use the shared collection state from the latest Collection in the in-memory collection','line_number':1280,'multiline':False]
['text':' catalog if it is compatible.','line_number':1281,'multiline':False]
['text':' There is no state in-memory that matches the catalog entry. Try to instantiate a new','line_number':1290,'multiline':False]
['text':' Collection instance from scratch.','line_number':1291,'multiline':False]
['text':' Insert catalogId for both the namespace and UUID if the catalog entry is found.','line_number':1340,'multiline':False]
['text':' We shouldn't receive kUnknown when we don't have a timestamp since no timestamp means','line_number':1356,'multiline':False]
['text':' we're operating on the latest.','line_number':1357,'multiline':False]
['text':' Scan durable catalog when we don't have accurate catalogId mapping for this timestamp.','line_number':1360,'multiline':False]
['text':' If no entry is found or the entry contains a different namespace, the mapping might be','line_number':1373,'multiline':False]
['text':' incorrect since it is incomplete after startup; scans durable catalog to confirm.','line_number':1374,'multiline':False]
['text':' Check if the collection is drop pending, not expired, and compatible with the read timestamp.','line_number':1389,'multiline':False]
['text':' If either the latest or drop pending collection exists, instantiate a new collection using','line_number':1403,'multiline':False]
['text':' the shared state.','line_number':1404,'multiline':False]
['text':'rs=','line_number':1419,'multiline':True]
['text':' The ident is expired, but it still may not have been dropped by the reaper. Try to mark it as','line_number':1441,'multiline':False]
['text':' in use.','line_number':1442,'multiline':False]
['text':' Instantiate a new collection without any shared state.','line_number':1453,'multiline':False]
['text':' Set the ident to the one returned by the ident reaper. This is to prevent the ident from','line_number':1466,'multiline':False]
['text':' being dropping prematurely.','line_number':1467,'multiline':False]
['text':'collection=','line_number':1477,'multiline':True]
['text':' When we already have a drop and recreate the collection, we want to seamlessly swap out the','line_number':1507,'multiline':False]
['text':' collection in the catalog under a single critical section. So we register the recreated','line_number':1508,'multiline':False]
['text':' collection in the same commit handler that we unregister the dropped collection (as opposed','line_number':1509,'multiline':False]
['text':' to registering the new collection inside of a preCommitHook).','line_number':1510,'multiline':False]
['text':' Requesting a writable collection normally ensures we have registered PublishCatalogUpdates','line_number':1550,'multiline':False]
['text':' with the recovery unit. However, when the writable Collection was requested in Inplace mode','line_number':1551,'multiline':False]
['text':' (or is the oplog) this is not the case. So make sure we are registered in all cases.','line_number':1552,'multiline':False]
['text':' It's important to look in UncommittedCatalogUpdates before OpenedCollections because in a','line_number':1588,'multiline':False]
['text':' multi-document transaction it's permitted to perform a lookup on a non-existent','line_number':1589,'multiline':False]
['text':' collection followed by creating the collection. This lookup will store a nullptr in','line_number':1590,'multiline':False]
['text':' OpenedCollections.','line_number':1591,'multiline':False]
['text':' Return any previously instantiated collection on this namespace for this snapshot','line_number':1598,'multiline':False]
['text':' The uncommittedPtr will be nullptr in the case of drop.','line_number':1612,'multiline':False]
['text':' If the collection is newly created, invariant on the collection being locked in MODE_IX.','line_number':1618,'multiline':False]
['text':' Skip cloning and return directly if allowed.','line_number':1635,'multiline':False]
['text':' If we are in a batch write, set this Collection instance in the batched catalog write','line_number':1643,'multiline':False]
['text':' instance. We don't want to store as uncommitted in this case as we need to observe the write','line_number':1644,'multiline':False]
['text':' on the thread doing the batch write and it would trigger the regular path where we do a','line_number':1645,'multiline':False]
['text':' copy-on-write on the catalog when committing.','line_number':1646,'multiline':False]
['text':' If UUID is managed by UncommittedCatalogUpdates (but not newly created) return the pointer','line_number':1661,'multiline':False]
['text':' which will be nullptr in case of a drop. It's important to look in UncommittedCatalogUpdates','line_number':1662,'multiline':False]
['text':' before OpenedCollections because in a multi-document transaction it's permitted to perform a','line_number':1663,'multiline':False]
['text':' lookup on a non-existent collection followed by creating the collection. This lookup will','line_number':1664,'multiline':False]
['text':' store a nullptr in OpenedCollections.','line_number':1665,'multiline':False]
['text':' Return any previously instantiated collection on this namespace for this snapshot','line_number':1672,'multiline':False]
['text':' It's important to look in UncommittedCatalogUpdates before OpenedCollections because in a','line_number':1696,'multiline':False]
['text':' multi-document transaction it's permitted to perform a lookup on a non-existent','line_number':1697,'multiline':False]
['text':' collection followed by creating the collection. This lookup will store a nullptr in','line_number':1698,'multiline':False]
['text':' OpenedCollections.','line_number':1699,'multiline':False]
['text':' Report the drop or rename as nothing new was created.','line_number':1706,'multiline':False]
['text':' Return any previously instantiated collection on this namespace for this snapshot','line_number':1711,'multiline':False]
['text':' Oplog is special and can only be modified in a few contexts. It is modified inplace and care','line_number':1722,'multiline':False]
['text':' need to be taken for concurrency.','line_number':1723,'multiline':False]
['text':' If uncommittedPtr is valid, found is always true. Return the pointer as the collection still','line_number':1732,'multiline':False]
['text':' exists.','line_number':1733,'multiline':False]
['text':' If the collection is newly created, invariant on the collection being locked in MODE_IX.','line_number':1735,'multiline':False]
['text':' Report the drop or rename as nothing new was created.','line_number':1742,'multiline':False]
['text':' Skip cloning and return directly if allowed.','line_number':1755,'multiline':False]
['text':' If we are in a batch write, set this Collection instance in the batched catalog write','line_number':1763,'multiline':False]
['text':' instance. We don't want to store as uncommitted in this case as we need to observe the write','line_number':1764,'multiline':False]
['text':' on the thread doing the batch write and it would trigger the regular path where we do a','line_number':1765,'multiline':False]
['text':' copy-on-write on the catalog when committing.','line_number':1766,'multiline':False]
['text':' If uncommittedPtr is valid, found is always true. Return the pointer as the collection still','line_number':1781,'multiline':False]
['text':' exists. It's important to look in UncommittedCatalogUpdates before OpenedCollections because','line_number':1782,'multiline':False]
['text':' in a multi-document transaction it's permitted to perform a lookup on a non-existent','line_number':1783,'multiline':False]
['text':' collection followed by creating the collection. This lookup will store a nullptr in','line_number':1784,'multiline':False]
['text':' OpenedCollections.','line_number':1785,'multiline':False]
['text':' Report the drop or rename as nothing new was created.','line_number':1791,'multiline':False]
['text':' Return any previously instantiated collection on this namespace for this snapshot','line_number':1796,'multiline':False]
['text':' It's important to look in UncommittedCatalogUpdates before OpenedCollections because in a','line_number':1807,'multiline':False]
['text':' multi-document transaction it's permitted to perform a lookup on a non-existent','line_number':1808,'multiline':False]
['text':' collection followed by creating the collection. This lookup will store a nullptr in','line_number':1809,'multiline':False]
['text':' OpenedCollections.','line_number':1810,'multiline':False]
['text':' If UUID is managed by uncommittedCatalogUpdates return its corresponding namespace if the','line_number':1813,'multiline':False]
['text':' Collection exists, boost::none otherwise.','line_number':1814,'multiline':False]
['text':' Return any previously instantiated collection on this namespace for this snapshot','line_number':1821,'multiline':False]
['text':' Only in the case that the catalog is closed and a UUID is currently unknown, resolve it','line_number':1836,'multiline':False]
['text':' using the pre-close state. This ensures that any tasks reloading the catalog can see their','line_number':1837,'multiline':False]
['text':' own updates.','line_number':1838,'multiline':False]
['text':' It's important to look in UncommittedCatalogUpdates before OpenedCollections because in a','line_number':1849,'multiline':False]
['text':' multi-document transaction it's permitted to perform a lookup on a non-existent','line_number':1850,'multiline':False]
['text':' collection followed by creating the collection. This lookup will store a nullptr in','line_number':1851,'multiline':False]
['text':' OpenedCollections.','line_number':1852,'multiline':False]
['text':' Return any previously instantiated collection on this namespace for this snapshot','line_number':1862,'multiline':False]
['text':' Any writable Collection instance created under MODE_X lock is considered to belong to this','line_number':1881,'multiline':False]
['text':' catalog instance','line_number':1882,'multiline':False]
['text':' Verify that we store the same instance in this catalog','line_number':1893,'multiline':False]
['text':' If there is nothing in the main catalog check for pending commit, we could have just','line_number':1896,'multiline':False]
['text':' committed a newly created collection which would be considered latest.','line_number':1897,'multiline':False]
['text':' We want to avoid lookups on invalid collection names.','line_number':1941,'multiline':False]
['text':' ApplyOps should work on a valid existing collection, despite the presence of bad views','line_number':1946,'multiline':False]
['text':' otherwise the server would crash. The view catalog will remain invalid until the bad view','line_number':1947,'multiline':False]
['text':' definitions are removed.','line_number':1948,'multiline':False]
['text':' _orderedCollections is sorted by <dbName, uuid>. upper_bound will return the iterator to the','line_number':2033,'multiline':False]
['text':' first element in _orderedCollections greater than <firstDbName, maxUuid>.','line_number':2034,'multiline':False]
['text':' Move on to the next database after `dbName`.','line_number':2050,'multiline':False]
['text':' Make sure no entry related to this uuid.','line_number':2168,'multiline':False]
['text':' When restarting from standalone mode to a replica set, the stable timestamp may be null.','line_number':2185,'multiline':False]
['text':' We still need to register the nss and UUID with the catalog.','line_number':2186,'multiline':False]
['text':' Make sure collection object exists.','line_number':2228,'multiline':False]
['text':' Since writing to system.views requires an X lock, we only need to cross-check collection','line_number':2287,'multiline':False]
['text':' namespaces here.','line_number':2288,'multiline':False]
['text':' Unfinished index builds return a nullptr for getSharedIdent(). Use getIdent() instead.','line_number':2383,'multiline':False]
['text':' It's possible that the ident doesn't exist in either map when the collection catalog is','line_number':2393,'multiline':False]
['text':' re-opened, the _dropPendingIdent map is cleared. During rollback-to-stable we re-open the','line_number':2394,'multiline':False]
['text':' collection catalog. The TimestampMonitor is a background thread that continues to run during','line_number':2395,'multiline':False]
['text':' rollback-to-stable and maintains its own drop pending ident information. It generates a set','line_number':2396,'multiline':False]
['text':' of drop pending idents outside of the global lock. However, during rollback-to-stable, we','line_number':2397,'multiline':False]
['text':' clear the TimestampMonitors drop pending state. But it's possible that the TimestampMonitor','line_number':2398,'multiline':False]
['text':' already generated a set of idents to drop for its next iteration, which would call into this','line_number':2399,'multiline':False]
['text':' function, for idents we've already cleared from the collection catalogs in-memory state.','line_number':2400,'multiline':False]
['text':' We may skip cloning the Collection instance if and only if have already cloned it for write','line_number':2458,'multiline':False]
['text':' use in this batch writer.','line_number':2459,'multiline':False]
['text':' hold onto base so if we need to delete it we can do it outside of the lock','line_number':2470,'multiline':False]
['text':' copy the collection catalog, this could be expensive, store it for future writes during this','line_number':2472,'multiline':False]
['text':' batcher','line_number':2473,'multiline':False]
['text':' Publish out batched instance, validate that no other writers have been able to write during','line_number':2482,'multiline':False]
['text':' the batcher.','line_number':2483,'multiline':False]
['text':' Clear out batched pointer so no more attempts of batching are made','line_number':2488,'multiline':False]
['text':' namespace mongo','line_number':2495,'multiline':False]
