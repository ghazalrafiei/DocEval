['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':36,'multiline':False]
['text':'*
 * Append min, max and version information from chunk to the buffer for logChange purposes.
 ','line_number':142,'multiline':True]
['text':'*
 * Check that the chunk still exists and return its metadata.
 ','line_number':155,'multiline':True]
['text':' Must use local read concern because we're going to perform subsequent writes.','line_number':171,'multiline':False]
['text':' limit ','line_number':179,'multiline':True]
['text':'*
 * Returns a chunk different from the one being migrated or 'none' if one doesn't exist.
 ','line_number':239,'multiline':True]
['text':'*
 * Helper function to find collection and shard placement versions.
 ','line_number':270,'multiline':True]
['text':'*
 * Helper function to get the collection entry and version for nss. Always uses kLocalReadConcern.
 ','line_number':293,'multiline':True]
['text':' Query all chunks for this namespace.','line_number':325,'multiline':False]
['text':' Sort by version.','line_number':326,'multiline':False]
['text':' Limit 1.','line_number':327,'multiline':False]
['text':' Sort by version.','line_number':348,'multiline':False]
['text':' The query to find 'nss' chunks belonging to the donor shard didn't return any chunks,','line_number':352,'multiline':False]
['text':' meaning the last chunk for fromShard was donated. Gracefully handle the error.','line_number':353,'multiline':False]
['text':' Bubble up any other error','line_number':358,'multiline':False]
['text':' Find the newest chunk','line_number':382,'multiline':False]
['text':' query ','line_number':388,'multiline':True]
['text':' sort ','line_number':389,'multiline':True]
['text':' limit ','line_number':390,'multiline':True]
['text':' Update the newest chunk to have the new (bumped) version','line_number':405,'multiline':False]
['text':' query','line_number':413,'multiline':False]
['text':' update','line_number':414,'multiline':False]
['text':' upsert','line_number':415,'multiline':False]
['text':' multi','line_number':416,'multiline':False]
['text':' Prepare deletion of existing chunks in the range','line_number':482,'multiline':False]
['text':' Prepare insertion of new chunks covering the whole range','line_number':498,'multiline':False]
['text':'
 * Check if the placement of the parent collection is impacted by the migrated chunk(s).
 ','line_number':527,'multiline':True]
['text':' Check if the donor will stop owning data of the parent collection once the migration is','line_number':535,'multiline':False]
['text':' committed.','line_number':536,'multiline':False]
['text':' Check if the recipient isn't owning data of the parent collection prior to the migration','line_number':541,'multiline':False]
['text':' commit.','line_number':542,'multiline':False]
['text':' limit ','line_number':553,'multiline':True]
['text':' namespace','line_number':561,'multiline':False]
['text':' query','line_number':584,'multiline':False]
['text':' update','line_number':585,'multiline':False]
['text':' upsert','line_number':586,'multiline':False]
['text':' multi','line_number':587,'multiline':False]
['text':' There exists a constraint that a chunk version must be unique for a given namespace,','line_number':602,'multiline':False]
['text':' so the minor version is incremented for each chunk placed.','line_number':603,'multiline':False]
['text':' We need to use a shared pointer to prevent an scenario where the operation context is','line_number':618,'multiline':False]
['text':' interrupted and the scope containing SyncTransactionWithRetries goes away but the callback is','line_number':619,'multiline':False]
['text':' called from the executor thread.','line_number':620,'multiline':False]
['text':' TODO SERVER-75189: remove after SERVER-66261 is committed.','line_number':621,'multiline':False]
['text':' Verify that the range matches exactly a single chunk','line_number':656,'multiline':False]
['text':' Verify the split points are all within the chunk','line_number':689,'multiline':False]
['text':' Verify the split points came in increasing order','line_number':697,'multiline':False]
['text':' Verify that splitPoints are not repeated','line_number':704,'multiline':False]
['text':' verify that splits don't use disallowed BSON object format','line_number':711,'multiline':False]
['text':' splits only update the 'minor' portion of version','line_number':715,'multiline':False]
['text':' First chunk takes ID of the original chunk and all other chunks get new','line_number':718,'multiline':False]
['text':' IDs. This occurs because we perform an update operation below (with','line_number':719,'multiline':False]
['text':' upsert true). Keeping the original ID ensures we overwrite the old chunk','line_number':720,'multiline':False]
['text':' (before the split) without having to perform a delete.','line_number':721,'multiline':False]
['text':' build an update operation against the chunks collection of the config','line_number':735,'multiline':False]
['text':' database with upsert true','line_number':736,'multiline':False]
['text':' remember this chunk info for logging later','line_number':745,'multiline':False]
['text':' TODO: SERVER-72431 Make split chunk commit idempotent, with that we won't need anymore the','line_number':776,'multiline':False]
['text':' transaction precondition and we will be able to remove the try/catch on the transaction run','line_number':777,'multiline':False]
['text':' Makes sure that the last thing we read from config.chunks collection gets majority','line_number':781,'multiline':False]
['text':' written before to return from this command, otherwise next RoutingInfo cache refresh from','line_number':782,'multiline':False]
['text':' the shard may not see those newest information.','line_number':783,'multiline':False]
['text':' Mark opCtx as interruptible to ensure that all reads and writes to the metadata collections','line_number':801,'multiline':False]
['text':' under the exclusive _kChunkOpLock happen on the same term.','line_number':802,'multiline':False]
['text':' Take _kChunkOpLock in exclusive mode to prevent concurrent chunk modifications and generate','line_number':805,'multiline':False]
['text':' strictly monotonously increasing collection placement versions','line_number':806,'multiline':False]
['text':' Get collection entry and max chunk version for this namespace.','line_number':809,'multiline':False]
['text':' Return an error if collection epoch does not match epoch of request.','line_number':828,'multiline':False]
['text':' Find the chunk history.','line_number':839,'multiline':False]
['text':' log changes','line_number':855,'multiline':False]
['text':' Stop logging if the last log op failed because the primary stepped down','line_number':899,'multiline':False]
['text':'shardPlacementVersion','line_number':906,'multiline':True]
['text':'collectionPlacementVersion','line_number':907,'multiline':True]
['text':' Check the merge chunk precondition, chunks must not have moved.','line_number':922,'multiline':False]
['text':' Construct the new chunk by taking `min` from the first merged chunk and `max`','line_number':941,'multiline':False]
['text':' from the last.','line_number':942,'multiline':False]
['text':' Fill in additional details for sending through transaction.','line_number':951,'multiline':False]
['text':' Delete the rest of the chunks to be merged. Remember not to delete the','line_number':972,'multiline':False]
['text':' first chunk we're expanding.','line_number':973,'multiline':False]
['text':' Mark opCtx as interruptible to ensure that all reads and writes to the metadata collections','line_number':1022,'multiline':False]
['text':' under the exclusive _kChunkOpLock happen on the same term.','line_number':1023,'multiline':False]
['text':' Take _kChunkOpLock in exclusive mode to prevent concurrent chunk modifications and generate','line_number':1026,'multiline':False]
['text':' strictly monotonously increasing collection placement versions','line_number':1027,'multiline':False]
['text':' 1. Retrieve the initial collection placement version info to build up the logging info.','line_number':1030,'multiline':False]
['text':' 2. Retrieve the list of chunks belonging to the requested shard + key range.','line_number':1045,'multiline':False]
['text':' Check if the chunk(s) have already been merged. If so, return success.','line_number':1065,'multiline':False]
['text':' Makes sure that the last thing we read in getCollectionAndVersion and','line_number':1079,'multiline':False]
['text':' getShardPlacementVersion gets majority written before to return from this command,','line_number':1080,'multiline':False]
['text':' otherwise next RoutingInfo cache refresh from the shard may not see those newest','line_number':1081,'multiline':False]
['text':' information.','line_number':1082,'multiline':False]
['text':' 3. Prepare the data for the merge','line_number':1088,'multiline':False]
['text':'    and ensure that the retrieved list of chunks covers the whole range.','line_number':1089,'multiline':False]
['text':' The `validAfter` field must always be set. If not existing, it means the chunk','line_number':1091,'multiline':False]
['text':' always belonged to the same shard, hence it's valid to set `0` as the time at','line_number':1092,'multiline':False]
['text':' which the chunk started being valid.','line_number':1093,'multiline':False]
['text':' Get the `validAfter` field from the most recent chunk placed on the shard','line_number':1117,'multiline':False]
['text':' 4. apply the batch of updates to local metadata','line_number':1138,'multiline':False]
['text':' 5. log changes','line_number':1142,'multiline':False]
['text':'shardPlacementVersion','line_number':1153,'multiline':True]
['text':'collectionPlacementVersion','line_number':1154,'multiline':True]
['text':' Mark opCtx as interruptible to ensure that all reads and writes to the metadata collections','line_number':1162,'multiline':False]
['text':' under the exclusive _kChunkOpLock happen on the same term.','line_number':1163,'multiline':False]
['text':' Retry the commit a fixed number of  times before failing: the discovery of chunks to merge','line_number':1166,'multiline':False]
['text':' happens before acquiring the `_kChunkOpLock` in order not to block  for too long concurrent','line_number':1167,'multiline':False]
['text':' chunk operations. This implies that other chunk operations for the same collection could','line_number':1168,'multiline':False]
['text':' potentially commit before acquiring the lock, forcing to repeat the discovey.','line_number':1169,'multiline':False]
['text':' 1. Retrieve the collection entry and the initial version.','line_number':1174,'multiline':False]
['text':' 2. Retrieve the list of mergeable chunks belonging to the requested shard/collection.','line_number':1187,'multiline':False]
['text':' A chunk is mergeable when the following conditions are honored:','line_number':1188,'multiline':False]
['text':' - Non-jumbo','line_number':1189,'multiline':False]
['text':' - The last migration occurred before the current history window','line_number':1190,'multiline':False]
['text':' TODO SERVER-78701 scan cursor rather than getting the whole vector of chunks','line_number':1194,'multiline':False]
['text':' sort ','line_number':1206,'multiline':True]
['text':' limit ','line_number':1207,'multiline':True]
['text':' 3. Prepare the data for the merge.','line_number':1210,'multiline':False]
['text':' Track the total and per-range number of merged chunks','line_number':1212,'multiline':False]
['text':' Lambda generating the new chunk to be committed if a merge can be issued on the range','line_number':1223,'multiline':False]
['text':' Initialize bounds lower than any zone [(), Minkey) so that it can be later advanced','line_number':1246,'multiline':False]
['text':' This lambda advances zones taking into account the whole shard key space,','line_number':1250,'multiline':False]
['text':' also considering the "no-zone" as a zone itself.','line_number':1251,'multiline':False]
['text':'','line_number':1252,'multiline':False]
['text':' Example:','line_number':1253,'multiline':False]
['text':' - Zones set by the user: [1, 10), [20, 30), [30, 40)','line_number':1254,'multiline':False]
['text':' - Real zones: [Minkey, 1), [1, 10), [10, 20), [20, 30), [30, 40), [40, MaxKey)','line_number':1255,'multiline':False]
['text':'','line_number':1256,'multiline':False]
['text':' Returns a bool indicating whether the zone has changed or not.','line_number':1257,'multiline':False]
['text':' Advance cursor','line_number':1273,'multiline':False]
['text':' If there is no mergeable chunk for the given shard, return success.','line_number':1316,'multiline':False]
['text':' Makes sure that the last thing we read in getCollectionAndVersion and','line_number':1321,'multiline':False]
['text':' getShardPlacementVersion gets majority written before to return from this command,','line_number':1322,'multiline':False]
['text':' otherwise next RoutingInfo cache refresh from the shard may not see those newest','line_number':1323,'multiline':False]
['text':' information.','line_number':1324,'multiline':False]
['text':' Take _kChunkOpLock in exclusive mode to prevent concurrent chunk modifications','line_number':1332,'multiline':False]
['text':' Precondition for merges to be safely committed: make sure the current collection','line_number':1335,'multiline':False]
['text':' placement version fits the one retrieved before acquiring the lock.','line_number':1336,'multiline':False]
['text':' 4. Commit the new routing table changes to the sharding catalog.','line_number':1345,'multiline':False]
['text':' 5. Log changes','line_number':1348,'multiline':False]
['text':' we can know the prevVersion since newChunks vector is sorted by version','line_number':1363,'multiline':False]
['text':'shardPlacementVersion','line_number':1368,'multiline':True]
['text':'collPlacementVersion','line_number':1369,'multiline':True]
['text':' Mark opCtx as interruptible to ensure that all reads and writes to the metadata collections','line_number':1392,'multiline':False]
['text':' under the exclusive _kChunkOpLock happen on the same term.','line_number':1393,'multiline':False]
['text':' Must hold the shard lock until the entire commit finishes to serialize with removeShard.','line_number':1396,'multiline':False]
['text':' Take _kChunkOpLock in exclusive mode to prevent concurrent chunk modifications and generate','line_number':1416,'multiline':False]
['text':' strictly monotonously increasing collection placement versions','line_number':1417,'multiline':False]
['text':' Check that current collection epoch and timestamp still matches the one sent by the shard.','line_number':1469,'multiline':False]
['text':' This is to spot scenarios in which the collection has been dropped and recreated or had its','line_number':1470,'multiline':False]
['text':' shard key refined since the migration began.','line_number':1471,'multiline':False]
['text':' Check if range still exists and which shard owns it','line_number':1489,'multiline':False]
['text':' The commit was already done successfully','line_number':1504,'multiline':False]
['text':' Makes sure that the last thing we read in findChunkContainingRange,','line_number':1507,'multiline':False]
['text':' getShardPlacementVersion, and getCollectionAndVersion gets majority written before to','line_number':1508,'multiline':False]
['text':' return from this command, otherwise next RoutingInfo cache refresh from the shard may not','line_number':1509,'multiline':False]
['text':' see those newest information.','line_number':1510,'multiline':False]
['text':' Generate the new versions of migratedChunk and controlChunk. Migrating chunk's minor version','line_number':1533,'multiline':False]
['text':' will be 0.','line_number':1534,'multiline':False]
['text':' Set the commit time of the migration.','line_number':1545,'multiline':False]
['text':' Copy the complete history.','line_number':1549,'multiline':False]
['text':' Drop old history. Keep at least 1 entry so ChunkInfo::getShardIdAt finds valid history for','line_number':1552,'multiline':False]
['text':' any query younger than the history window.','line_number':1553,'multiline':False]
['text':' This scope handles the `moveRange` scenario, potentially create chunks on the sides of','line_number':1588,'multiline':False]
['text':' the moved range','line_number':1589,'multiline':False]
['text':' Left chunk: inherits history and min of the original chunk, max equal to the min of','line_number':1595,'multiline':False]
['text':' the new moved range. Major version equal to the new chunk's one, min version bumped.','line_number':1596,'multiline':False]
['text':' Right chunk: min equal to the max of the new moved range, inherits history and min of','line_number':1607,'multiline':False]
['text':' the original chunk. Major version equal to the new chunk's one, min version bumped.','line_number':1608,'multiline':False]
['text':' Find the chunk history.','line_number':1629,'multiline':False]
['text':' Setting control chunk's minor version to 1 on the donor shard.','line_number':1633,'multiline':False]
['text':' We migrated the last chunk from the donor shard.','line_number':1645,'multiline':False]
['text':' Mark opCtx as interruptible to ensure that all reads and writes to the metadata collections','line_number':1693,'multiline':False]
['text':' under the exclusive _kChunkOpLock happen on the same term.','line_number':1694,'multiline':False]
['text':' Take _kChunkOpLock in exclusive mode to prevent concurrent chunk splits, merges, and','line_number':1697,'multiline':False]
['text':' migrations.','line_number':1698,'multiline':False]
['text':' Find the chunk history','line_number':1737,'multiline':False]
['text':' Bump the major version in order to be guaranteed to trigger refresh on every shard','line_number':1753,'multiline':False]
['text':' Construct the fresh history.','line_number':1778,'multiline':False]
['text':' Set the 'historyIsAt40' field so that it gets skipped if the command is re-run','line_number':1783,'multiline':False]
['text':' Run the update','line_number':1787,'multiline':False]
['text':' Wait for the writes to become majority committed so that the subsequent shard refreshes can','line_number':1797,'multiline':False]
['text':' see them','line_number':1798,'multiline':False]
['text':' Mark opCtx as interruptible to ensure that all reads and writes to the metadata collections','line_number':1821,'multiline':False]
['text':' under the exclusive _kChunkOpLock happen on the same term.','line_number':1822,'multiline':False]
['text':' Take _kChunkOpLock in exclusive mode to prevent concurrent chunk modifications and generate','line_number':1825,'multiline':False]
['text':' strictly monotonously increasing collection placement versions','line_number':1826,'multiline':False]
['text':' Must use local read concern because we will perform subsequent writes.','line_number':1871,'multiline':False]
['text':' Check that current collection epoch and timestamp still matches the one sent by the shard.','line_number':1891,'multiline':False]
['text':' This is to spot scenarios in which the collection have been dropped and recreated or had its','line_number':1892,'multiline':False]
['text':' shard key refined since the migration began.','line_number':1893,'multiline':False]
['text':' Update the newest chunk to have the new (bumped) version','line_number':1914,'multiline':False]
['text':' upsert ','line_number':1926,'multiline':True]
['text':' Mark opCtx as interruptible to ensure that all reads and writes to the metadata collections','line_number':1940,'multiline':False]
['text':' under the exclusive _kChunkOpLock happen on the same term.','line_number':1941,'multiline':False]
['text':' Take _kChunkOpLock in exclusive mode to prevent concurrent chunk modifications and generate','line_number':1944,'multiline':False]
['text':' strictly monotonously increasing collection placement versions','line_number':1945,'multiline':False]
['text':' Ensure waiting for writeConcern of the data read.','line_number':1949,'multiline':False]
['text':' sort ','line_number':1961,'multiline':True]
['text':' Get the chunk matching the requested chunk.','line_number':1980,'multiline':False]
['text':' sort ','line_number':1990,'multiline':True]
['text':' limit ','line_number':1991,'multiline':True]
['text':' This can happen in a number of cases, such as that the collection has been','line_number':1994,'multiline':False]
['text':' dropped, its shard key has been refined, the chunk has been split, or the chunk','line_number':1995,'multiline':False]
['text':' has been merged.','line_number':1996,'multiline':False]
['text':' Get the chunk with the current collection placement version for this epoch.','line_number':2023,'multiline':False]
['text':' sort ','line_number':2034,'multiline':True]
['text':' limit ','line_number':2035,'multiline':True]
['text':' Generate a new version for the chunk by incrementing the collection placement version's major','line_number':2052,'multiline':False]
['text':' version.','line_number':2053,'multiline':False]
['text':' Update the chunk, if it still exists, to have the bumped version.','line_number':2058,'multiline':False]
['text':' upsert ','line_number':2065,'multiline':True]
['text':' Mark opCtx as interruptible to ensure that all reads and writes to the metadata collections','line_number':2120,'multiline':False]
['text':' under the exclusive _kChunkOpLock happen on the same term.','line_number':2121,'multiline':False]
['text':' Take _kChunkOpLock in exclusive mode to prevent concurrent chunk splits, merges, and','line_number':2124,'multiline':False]
['text':' migrations','line_number':2125,'multiline':False]
['text':' Limit the search to one split point: this code path is reached when a migration fails due','line_number':2162,'multiline':False]
['text':' to ErrorCodes::ChunkTooBig. In case there is a too frequent shard key, only select the','line_number':2163,'multiline':False]
['text':' next key in order to split the range in jumbo chunk + remaining range.','line_number':2164,'multiline':False]
['text':' Take _kChunkOpLock in exclusive mode to prevent concurrent chunk modifications. Note','line_number':2179,'multiline':False]
['text':' that the operation below doesn't increment the chunk marked as jumbo's version, which','line_number':2180,'multiline':False]
['text':' means that a subsequent incremental refresh will not see it. However, it is being','line_number':2181,'multiline':False]
['text':' marked in memory through the call to 'markAsJumbo' above so subsequent balancer','line_number':2182,'multiline':False]
['text':' iterations will not consider it for migration.','line_number':2183,'multiline':False]
['text':' Resize the vector because in multiversion scenarios the `autoSplitVector` command may end','line_number':2221,'multiline':False]
['text':' up ignoring the `limit` parameter and returning the whole list of split points.','line_number':2222,'multiline':False]
['text':' Mark opCtx as interruptible to ensure that all reads and writes to the metadata','line_number':2242,'multiline':False]
['text':' collections under the exclusive _kChunkOpLock happen on the same term.','line_number':2243,'multiline':False]
['text':' Take _kChunkOpLock in exclusive mode to prevent concurrent chunk splits, merges, and','line_number':2246,'multiline':False]
['text':' migrations','line_number':2247,'multiline':False]
['text':' Find the newest chunk','line_number':2301,'multiline':False]
['text':' From now on migrations are not allowed anymore, so it is not possible that new shards','line_number':2348,'multiline':False]
['text':' will own chunks for this collection.','line_number':2349,'multiline':False]
['text':' ensure the unsigned value fits in the signed long long','line_number':2362,'multiline':False]
['text':' Take _kChunkOpLock in exclusive mode to prevent concurrent chunk modifications and generate','line_number':2365,'multiline':False]
['text':' strictly monotonously increasing collection placement versions','line_number':2366,'multiline':False]
['text':' upsert ','line_number':2381,'multiline':True]
['text':' Take _kChunkOpLock in exclusive mode to prevent concurrent chunk splits, merges, and','line_number':2389,'multiline':False]
['text':' migrations','line_number':2390,'multiline':False]
['text':' 1. Update the config.chunks collection with new entries.','line_number':2431,'multiline':False]
['text':' 2. If the placement of the parent collection is not impacted by the migrated chunks, end','line_number':2476,'multiline':False]
['text':' the transaction as there is no need to update the placement history.','line_number':2477,'multiline':False]
['text':' 3. Use the updated content of config.chunks to build the collection placement metadata.','line_number':2483,'multiline':False]
['text':' The request is equivalent to "configDb.chunks.distinct('shard',{uuid:collUuid})".','line_number':2484,'multiline':False]
['text':' 4. Persist new data to the config.placementHistory collection.','line_number':2495,'multiline':False]
['text':' namespace mongo','line_number':2528,'multiline':False]
