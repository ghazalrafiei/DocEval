['text':'*
 *    Copyright (C) 2022-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: keep','line_number':37,'multiline':False]
['text':' Populated in the first phase of collection(s) acquisition.','line_number':96,'multiline':False]
['text':' Populated only for locked acquisitions in the second phase of collection(s) acquisition.','line_number':100,'multiline':False]
['text':' Resources for lock free reads.','line_number':104,'multiline':False]
['text':'*
 * Takes the input acquisitions, populates the NSS and returns a map sorted by NSS, suitable for
 * locking them in NSS order.
 ','line_number':139,'multiline':True]
['text':' In most cases we expect modifications for system.views to upgrade MODE_IX to MODE_X','line_number':195,'multiline':False]
['text':' before taking the lock. One exception is a query by UUID of system.views in a','line_number':196,'multiline':False]
['text':' transaction. Usual queries of system.views (by name, not UUID) within a transaction are','line_number':197,'multiline':False]
['text':' rejected. However, if the query is by UUID we can't determine whether the namespace is','line_number':198,'multiline':False]
['text':' actually system.views until we take the lock here. So we have these last two assertions.','line_number':199,'multiline':False]
['text':' Verify that we are using the latest instance if we intend to perform writes.','line_number':209,'multiline':False]
['text':' TODO SERVER-79401: To mimic the previous behaviour with AutoGetCollectionForRead we only','line_number':263,'multiline':False]
['text':' check for usage of the correct read concern on reads. Otherwise multi-document','line_number':264,'multiline':False]
['text':' transactions cannot perform commits since they perform writes with an "invalid" read','line_number':265,'multiline':False]
['text':' concern for the user (snapshot).','line_number':266,'multiline':False]
['text':' TODO: This will be removed when we no longer snapshot sharding state on CollectionPtr.','line_number':318,'multiline':False]
['text':' If the uuid wasn't originally set on the AcquisitionRequest, set it now on the','line_number':358,'multiline':False]
['text':' prerequisites so that on restore from yield we can check we are restoring the','line_number':359,'multiline':False]
['text':' same instance of the ns.','line_number':360,'multiline':False]
['text':' It's a view.','line_number':390,'multiline':False]
['text':'
 * Establish a capped snapshot if necessary on the provided namespace.
 ','line_number':406,'multiline':True]
['text':' We only have to check placement for collections that come from a router, which','line_number':481,'multiline':False]
['text':' will have the namespace set.','line_number':482,'multiline':False]
['text':' Stash the catalog, it will be automatically unstashed when the snapshot is released.','line_number':506,'multiline':False]
['text':' TODO SERVER-77067 simplify conditions','line_number':511,'multiline':False]
['text':' Lock-free reads are not supported:','line_number':513,'multiline':False]
['text':'   * in multi-document transactions.','line_number':514,'multiline':False]
['text':'   * under an IX lock (nested reads under IX lock holding operations).','line_number':515,'multiline':False]
['text':'   * if a storage txn is already open w/o the lock-free reads operation flag set.','line_number':516,'multiline':False]
['text':' namespace','line_number':522,'multiline':False]
['text':' Acquisitions by uuid cannot possibly have a corresponding ShardVersion attached.','line_number':532,'multiline':False]
['text':' Acquisitions by uuid cannot possibly have a corresponding ShardVersion attached.','line_number':564,'multiline':False]
['text':' If the TransactionResources have failed to restore or yield we've released all the resources.','line_number':628,'multiline':False]
['text':' Our reference to the acquisition is invalid and we've already removed it from the list of','line_number':629,'multiline':False]
['text':' acquisitions.','line_number':630,'multiline':False]
['text':' The collectionDescription will only not be set if the caller as acquired the acquisition','line_number':664,'multiline':False]
['text':' using the kLocalCatalogOnlyWithPotentialDataLoss placement concern','line_number':665,'multiline':False]
['text':' The collectionDescription will only not be set if the caller has acquired the acquisition','line_number':671,'multiline':False]
['text':' using the kLocalCatalogOnlyWithPotentialDataLoss placement concern','line_number':672,'multiline':False]
['text':' If the TransactionResources have failed to restore or yield we've released all the resources.','line_number':731,'multiline':False]
['text':' Our reference to the acquisition is invalid and we've already removed it from the list of','line_number':732,'multiline':False]
['text':' acquisitions.','line_number':733,'multiline':False]
['text':' Transform the CollectionAcquisitionRequests to NamespaceOrViewAcquisitionRequests.','line_number':771,'multiline':False]
['text':' Acquire the collections','line_number':777,'multiline':False]
['text':' Transform the acquisitions to CollectionAcquisitions','line_number':780,'multiline':False]
['text':' It must be a collection, because that's what the acquisition request stated.','line_number':783,'multiline':False]
['text':' Transform the CollectionAcquisitionRequests to NamespaceOrViewAcquisitionRequests.','line_number':804,'multiline':False]
['text':' Acquire the collections','line_number':810,'multiline':False]
['text':' Transform the acquisitions to CollectionAcquisitions','line_number':814,'multiline':False]
['text':' It must be a collection, because that's what the acquisition request stated.','line_number':817,'multiline':False]
['text':' The read source used can change depending on replication state, so we must fetch the repl','line_number':834,'multiline':False]
['text':' state beforehand, to compare with afterwards.','line_number':835,'multiline':False]
['text':' If the collection requires capped snapshots (i.e. it is unreplicated, capped, not the','line_number':867,'multiline':False]
['text':' oplog, and not clustered), establish a capped snapshot. This must happen before opening','line_number':868,'multiline':False]
['text':' the storage snapshot to ensure a reader using tailable cursors would not miss any writes.','line_number':869,'multiline':False]
['text':'','line_number':870,'multiline':False]
['text':' It is safe to establish the capped snapshot here, on the Collection object in the latest','line_number':871,'multiline':False]
['text':' version of the catalog, even if establishConsistentCollection is eventually called to','line_number':872,'multiline':False]
['text':' construct a Collection object from the durable catalog because the only way that can be','line_number':873,'multiline':False]
['text':' required for a collection that uses capped snapshots (i.e. a collection that is','line_number':874,'multiline':False]
['text':' unreplicated and capped) is:','line_number':875,'multiline':False]
['text':'  * The present read operation is reading without a timestamp (since unreplicated','line_number':876,'multiline':False]
['text':'  collections don't support timestamped reads), and','line_number':877,'multiline':False]
['text':'  * When opening the storage snapshot (and thus when establishing the capped snapshot),','line_number':878,'multiline':False]
['text':'  there was a DDL operation pending on the namespace or UUID requested for this read (because','line_number':879,'multiline':False]
['text':'  this is the only time we need to construct a Collection object from the durable catalog for','line_number':880,'multiline':False]
['text':'  an untimestamped read).','line_number':881,'multiline':False]
['text':'','line_number':882,'multiline':False]
['text':' Because DDL operations require a collection X lock, there cannot have been any ongoing','line_number':883,'multiline':False]
['text':' concurrent writes to the collection while establishing the capped snapshot. This means','line_number':884,'multiline':False]
['text':' that if there was a capped snapshot, it should not have contained any uncommitted writes,','line_number':885,'multiline':False]
['text':' and so the _lowestUncommittedRecord must be null.','line_number':886,'multiline':False]
['text':'','line_number':887,'multiline':False]
['text':' The exception to the above is collection creation, which only requires an IX lock. Concurrent','line_number':888,'multiline':False]
['text':' readers will have to open a Collection object from the durable catalog, and at that point it','line_number':889,'multiline':False]
['text':' is assumed safe to establish an empty CappedSnapshot (even if the storage snapshot is already','line_number':890,'multiline':False]
['text':' open) and cause a reader's cursor to return no data.','line_number':891,'multiline':False]
['text':' We were successful, nothing to clean up.','line_number':918,'multiline':False]
['text':' We don't care about ordering in this case, use a mock ResourceId as the key.','line_number':960,'multiline':False]
['text':' We shouldn't have an open snapshot unless a previous lock-free acquisition opened and','line_number':975,'multiline':False]
['text':' stashed it already.','line_number':976,'multiline':False]
['text':' Wait for a configured amount of time after acquiring locks if the failpoint is enabled','line_number':981,'multiline':False]
['text':' Make sure the sharding placement is correct before opening the storage snapshot, we will','line_number':985,'multiline':False]
['text':' check it again after opening it to make sure it is consistent. This is specially','line_number':986,'multiline':False]
['text':' important in secondaries since they can be lagging and might not be aware of the latests','line_number':987,'multiline':False]
['text':' routing changes.','line_number':988,'multiline':False]
['text':' Open a consistent catalog snapshot if needed.','line_number':991,'multiline':False]
['text':' Second sharding placement check.','line_number':997,'multiline':False]
['text':' namespace shard_role_details','line_number':1010,'multiline':False]
['text':' Optimistically populate the nss and uuid parts of the resolved acquisition requests and','line_number':1023,'multiline':False]
['text':' sort them','line_number':1024,'multiline':False]
['text':' At this point, sortedAcquisitionRequests contains fully resolved (both nss and uuid)','line_number':1028,'multiline':False]
['text':' namespace or view requests in sorted order. However, there is still no guarantee that the','line_number':1029,'multiline':False]
['text':' nss <-> uuid mapping won't change from underneath.','line_number':1030,'multiline':False]
['text':'','line_number':1031,'multiline':False]
['text':' Lock the collection locks in the sorted order and recheck the UUIDS. If it fails, we need','line_number':1032,'multiline':False]
['text':' to start over.','line_number':1033,'multiline':False]
['text':' Wait for a configured amount of time after acquiring locks if the failpoint is','line_number':1072,'multiline':False]
['text':' enabled','line_number':1073,'multiline':False]
['text':' Recheck UUIDs. We only do this for resolutions performed via UUID exclusively as','line_number':1080,'multiline':False]
['text':' otherwise we have the correct mapping between nss <-> uuid since the nss is already the','line_number':1081,'multiline':False]
['text':' user provided one. Note that multi-document transactions will get a WCE thrown later','line_number':1082,'multiline':False]
['text':' during the checks performed by verifyDbAndCollection if the collection metadata has','line_number':1083,'multiline':False]
['text':' changed.','line_number':1084,'multiline':False]
['text':' Retry optimistic resolution.','line_number':1100,'multiline':False]
['text':' Open a consistent catalog snapshot if needed.','line_number':1104,'multiline':False]
['text':' Clear the collectionPtr from the acquisition to indicate that it should not be used until','line_number':1185,'multiline':False]
['text':' the caller is done with the DDL modifications','line_number':1186,'multiline':False]
['text':' If the uuid wasn't originally set on the prerequisites, because the collection didn't','line_number':1203,'multiline':False]
['text':' exist, set it now so that on restore from yield we can check we are restoring the','line_number':1204,'multiline':False]
['text':' same instance of the ns.','line_number':1205,'multiline':False]
['text':' Yielding kLocalCatalogOnlyWithPotentialDataLoss acquisitions is not allowed.','line_number':1254,'multiline':False]
['text':' Yielding view acquisitions is not supported.','line_number':1262,'multiline':False]
['text':' Yielding kLocalCatalogOnlyWithPotentialDataLoss acquisitions is not allowed.','line_number':1290,'multiline':False]
['text':' Yielding view acquisitions is not supported.','line_number':1298,'multiline':False]
['text':' TODO SERVER-77213: This should mostly go away once the Locker resides inside','line_number':1303,'multiline':False]
['text':' TransactionResources and the underlying locks point to it instead of the opCtx.','line_number':1304,'multiline':False]
['text':'','line_number':1305,'multiline':False]
['text':' Release all locks acquired since we are going to yield externally and our opCtx is going to','line_number':1306,'multiline':False]
['text':' be destroyed.','line_number':1307,'multiline':False]
['text':' Nothing to restore.','line_number':1327,'multiline':False]
['text':' On failure to restore, release the yielded resources.','line_number':1334,'multiline':False]
['text':' Reacquire locks. External yields do not have a lock snapshot so we only restore for','line_number':1341,'multiline':False]
['text':' internal yields.','line_number':1342,'multiline':False]
['text':' Reestablish a consistent catalog snapshot (multi document transactions don't yield).','line_number':1348,'multiline':False]
['text':' Reacquire service snapshots. Will throw if placement concern can no longer be met.','line_number':1352,'multiline':False]
['text':' Just reacquire the CollectionPtr. Reads don't care about placement changes','line_number':1365,'multiline':False]
['text':' because they have already established a ScopedCollectionFilter that acts as','line_number':1366,'multiline':False]
['text':' RangePreserver.','line_number':1367,'multiline':False]
['text':' We do not support yielding view acquisitions. Therefore it is not possible','line_number':1370,'multiline':False]
['text':' that upon restore 'acquireLocalCollectionOrView' snapshoted a view -- it','line_number':1371,'multiline':False]
['text':' would not have met the prerequisite that the collection instance is still the','line_number':1372,'multiline':False]
['text':' same as the one before yielding.','line_number':1373,'multiline':False]
['text':' Update the services snapshot on TransactionResources','line_number':1379,'multiline':False]
['text':' Make sure that the placement is still correct.','line_number':1382,'multiline':False]
['text':' We do not support yielding view acquisitions. Therefore it is not possible','line_number':1392,'multiline':False]
['text':' that upon restore 'acquireLocalCollectionOrView' snapshoted a view -- it','line_number':1393,'multiline':False]
['text':' would not have met the prerequisite that the collection instance is still the','line_number':1394,'multiline':False]
['text':' same as the one before yielding.','line_number':1395,'multiline':False]
['text':' Update the services snapshot on TransactionResources','line_number':1403,'multiline':False]
['text':' TODO: This will be removed when we no longer snapshot sharding state on CollectionPtr','line_number':1412,'multiline':False]
['text':' If ShardVersion is IGNORED and we encountered a critical section, then yield,','line_number':1429,'multiline':False]
['text':' wait for the critical section to finish and then we'll resume the write from','line_number':1430,'multiline':False]
['text':' the point we had left. We do this to prevent large multi-writes from','line_number':1431,'multiline':False]
['text':' repeatedly failing due to StaleConfig and exhausting the mongos retry','line_number':1432,'multiline':False]
['text':' attempts. Yield the locks.','line_number':1433,'multiline':False]
['text':' Wait for the critical section to finish.','line_number':1439,'multiline':False]
['text':' Try again to restore.','line_number':1443,'multiline':False]
['text':' We have attempted to restore the resources but failed, the transaction resources have','line_number':1499,'multiline':False]
['text':' been moved to the opCtx, so we must move them back to the stashed object.','line_number':1500,'multiline':False]
['text':' Reacquire the locks requested by the acquisitions. All acquisitions with the same','line_number':1510,'multiline':False]
['text':' acquireCallCount share the same Global/DB/Lock-free locks. Acquisitions are inserted','line_number':1511,'multiline':False]
['text':' in order, so we can perform a single pass over the list to rebuild the locks.','line_number':1512,'multiline':False]
['text':'','line_number':1513,'multiline':False]
['text':' The following shared_ptrs are set by the first acquisition with a different','line_number':1514,'multiline':False]
['text':' acquireCollectionCallNum different from the previous one.','line_number':1515,'multiline':False]
['text':' TODO SERVER-77213: This should mostly go away once the Locker resides inside','line_number':1521,'multiline':False]
['text':' TransactionResources and the underlying locks point to it instead of the opCtx.','line_number':1522,'multiline':False]
['text':' Unlike the other locks, this one is always acquired per acquisition if it is not a','line_number':1555,'multiline':False]
['text':' lock-free acquisition.','line_number':1556,'multiline':False]
['text':' Wait for a configured amount of time after acquiring locks if the failpoint is enabled','line_number':1565,'multiline':False]
['text':' If the resources for the entire transaction are still valid and we haven't dismissed','line_number':1581,'multiline':False]
['text':' the resources due to a failure, we yield and stash them.','line_number':1582,'multiline':False]
['text':' Otherwise, the transaction resources for this operation have to be destroyed since','line_number':1585,'multiline':False]
['text':' the operation has failed.','line_number':1586,'multiline':False]
['text':' Since the opCtx must always have valid TransactionResources we reattach the original','line_number':1590,'multiline':False]
['text':' resources.','line_number':1591,'multiline':False]
['text':' namespace mongo','line_number':1601,'multiline':False]
