['text':'*
 *    Copyright (C) 2023-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':32,'multiline':False]
['text':' The number of times we'll try to continue a batch op if no progress is being made. This only','line_number':100,'multiline':False]
['text':' applies when no writes are occurring and metadata is not changing on reload.','line_number':101,'multiline':False]
['text':'*
 * Send and process the child batches. Each child batch is targeted at a unique shard: therefore one
 * shard will have only one batch incoming.
 ','line_number':104,'multiline':True]
['text':' Transform the request into a sendable BSON.','line_number':120,'multiline':False]
['text':' Per-operation write concern is not supported in transactions.','line_number':126,'multiline':False]
['text':' Mongos needs to send to the shard with w > 0 so it will be able to see the','line_number':132,'multiline':False]
['text':' writeErrors','line_number':133,'multiline':False]
['text':' When running a debug build, verify that estSize is at least the BSON','line_number':141,'multiline':False]
['text':' serialization size.','line_number':142,'multiline':False]
['text':'','line_number':143,'multiline':False]
['text':' The estimated size doesn't take into account the size of the internal','line_number':144,'multiline':False]
['text':' '_allowShardKeyUpdatesWithoutFullShardKeyInQuery' field for updates. When','line_number':145,'multiline':False]
['text':' allowShardKeyUpdatesWithoutFullShardKeyInQuery is set, we are running a single','line_number':146,'multiline':False]
['text':' updateOne without shard key in its own child batch. So it doesn't matter what the','line_number':147,'multiline':False]
['text':' estimated size is, skip the debug check.','line_number':148,'multiline':False]
['text':' Note we check this rather than `isRetryableWrite()` because we do not want to retry','line_number':158,'multiline':False]
['text':' commands within retryable internal transactions.','line_number':159,'multiline':False]
['text':' Use MultiStatementTransactionRequestsSender to send any ready sub-batches to targeted','line_number':162,'multiline':False]
['text':' shard endpoints. Requests are sent on construction.','line_number':163,'multiline':False]
['text':' The BulkWriteOp may be marked finished early if we are in a transaction and encounter an','line_number':172,'multiline':False]
['text':' error, which aborts the transaction. In those cases, we do not bother waiting for any','line_number':173,'multiline':False]
['text':' outstanding responses from shards.','line_number':174,'multiline':False]
['text':' Block until a response is available.','line_number':176,'multiline':False]
['text':' When the responseStatus is not OK, this means that mongos was unable to receive a','line_number':182,'multiline':False]
['text':' response from the shard the write batch was sent to, or mongos faced some other local','line_number':183,'multiline':False]
['text':' error (for example, mongos was shutting down).','line_number':184,'multiline':False]
['text':' The status being OK does not mean that all operations within the bulkWrite succeeded, nor','line_number':185,'multiline':False]
['text':' that we got an ok:1 response from the shard.','line_number':186,'multiline':False]
['text':' namespace','line_number':207,'multiline':False]
['text':' BulkWrite needs only _id, not index.','line_number':223,'multiline':False]
['text':' response.toStatus() is not OK but there is no errDetails so the','line_number':263,'multiline':False]
['text':' top level status should be not OK instead. Raising an exception.','line_number':264,'multiline':False]
['text':' TODO (SERVER-81280): Handle write concern errors.','line_number':268,'multiline':False]
['text':' stats ','line_number':300,'multiline':True]
['text':'targetEpoch','line_number':300,'multiline':True]
['text':'currentOpIdx=','line_number':308,'multiline':True]
['text':' stats ','line_number':312,'multiline':True]
['text':'targetEpoch','line_number':312,'multiline':True]
['text':' stats ','line_number':324,'multiline':True]
['text':'targetEpoch','line_number':324,'multiline':True]
['text':' If Queryable encryption adds support for update with multi: true, we might have to update','line_number':337,'multiline':False]
['text':' the way we make replies here to handle SERVER-15292 correctly.','line_number':338,'multiline':False]
['text':' Get the index of the targeted operation in the client bulkWrite request.','line_number':356,'multiline':False]
['text':' Construct a single-op update request based on the update operation at opIdx.','line_number':359,'multiline':False]
['text':' resourceYielder ','line_number':368,'multiline':True]
['text':' Execute the singleUpdateRequest (a bulkWrite command) in an internal transaction to perform','line_number':371,'multiline':False]
['text':' the retryable timeseries update operation. This separate bulkWrite command will get executed','line_number':372,'multiline':False]
['text':' on its own via bulkWrite execute() logic again as a transaction, which handles retries of all','line_number':373,'multiline':False]
['text':' kinds. This function is just a client of the internal transaction spawned. As a result, we','line_number':374,'multiline':False]
['text':' must only receive a single final (non-retryable) response for the timeseries update','line_number':375,'multiline':False]
['text':' operation.','line_number':376,'multiline':False]
['text':' Set an error for the operation.','line_number':396,'multiline':False]
['text':' cursorId','line_number':398,'multiline':False]
['text':' We should get back just one reply item for the single update we are running.','line_number':403,'multiline':False]
['text':' If the targetStatus value is 'WithoutShardKeyOrId', then we have detected an','line_number':425,'multiline':False]
['text':' updateOne/deleteOne request without a shard key or _id. We will use a two','line_number':426,'multiline':False]
['text':' phase protocol to apply the write.','line_number':427,'multiline':False]
['text':' Get the index of the targeted operation in the client bulkWrite request.','line_number':430,'multiline':False]
['text':' If there is only 1 targetable shard, we can skip using the two phase write protocol.','line_number':439,'multiline':False]
['text':' Execute the two phase write protocol for writes that cannot directly target a shard.','line_number':448,'multiline':False]
['text':' If there is a targeted write with a sampleId, use that write instead in order to pass','line_number':451,'multiline':False]
['text':' the sampleId to the two phase write protocol. Otherwise, just choose the first','line_number':452,'multiline':False]
['text':' targeted write.','line_number':453,'multiline':False]
['text':' shardId ','line_number':454,'multiline':True]
['text':' For a write without shard key, we expect each TargetedWriteBatch in childBatches','line_number':457,'multiline':False]
['text':' to contain only one TargetedWrite directed to each shard.','line_number':458,'multiline':False]
['text':' TODO (SERVER-81261): Handle writeConcernErrors.','line_number':481,'multiline':False]
['text':' When we get an empty response, it means that the predicate didn't match anything','line_number':487,'multiline':False]
['text':' and no write was done. So we can just set a trivial ok response.','line_number':488,'multiline':False]
['text':' cursorId','line_number':490,'multiline':False]
['text':' Set an error for the operation.','line_number':506,'multiline':False]
['text':' cursorId','line_number':508,'multiline':False]
['text':' We should get back just one reply item for the single update we are running.','line_number':513,'multiline':False]
['text':' 1: Target remaining ops with the appropriate targeter based on the namespace index and','line_number':547,'multiline':False]
['text':' re-batch ops based on their targeted shard id.','line_number':548,'multiline':False]
['text':' Divide and group ("target") the operations in the bulk write command. Some operations may','line_number':551,'multiline':False]
['text':' be split up (such as an update that needs to go to more than one shard), while others may','line_number':552,'multiline':False]
['text':' be grouped together if they need to go to the same shard.','line_number':553,'multiline':False]
['text':' These operations are grouped by shardId in the TargetedBatchMap childBatches.','line_number':554,'multiline':False]
['text':' The target error comes from one of the targeters. But to avoid getting another target','line_number':561,'multiline':False]
['text':' error from another targeter in retry, we simply refresh all targeters and only retry','line_number':562,'multiline':False]
['text':' once for target errors. The performance hit should be negligible as target errors','line_number':563,'multiline':False]
['text':' should be rare.','line_number':564,'multiline':False]
['text':' Send the child batches and wait for responses.','line_number':577,'multiline':False]
['text':'allowShardKeyUpdatesWithoutFullShardKeyInQuery=','line_number':583,'multiline':True]
['text':' If we saw any staleness errors, tell the targeters to invalidate their cache','line_number':586,'multiline':False]
['text':' so that they may be refreshed.','line_number':587,'multiline':False]
['text':' No need to refresh the targeters if we are done.','line_number':594,'multiline':False]
['text':' Refresh the targeter(s) if we received a target error or a stale config/db error.','line_number':598,'multiline':False]
['text':' getTargeterFn:','line_number':681,'multiline':False]
['text':' getWriteSizeFn:','line_number':687,'multiline':False]
['text':' If retryable writes are used, MongoS needs to send an additional array of stmtId(s)','line_number':689,'multiline':False]
['text':' corresponding to the statements that got routed to each individual shard, so they','line_number':690,'multiline':False]
['text':' need to be accounted in the potential request size so it does not exceed the max BSON','line_number':691,'multiline':False]
['text':' size.','line_number':692,'multiline':False]
['text':' A single bulk command request batch may contain operations of different','line_number':710,'multiline':False]
['text':' types, i.e. they may be inserts, updates or deletes.','line_number':711,'multiline':False]
['text':' Set the nsInfo's shardVersion & databaseVersion fields based on the endpoint','line_number':735,'multiline':False]
['text':' of each operation. Since some operations may be on the same namespace, this','line_number':736,'multiline':False]
['text':' might result in the same nsInfo entry being written to multiple times. This','line_number':737,'multiline':False]
['text':' is OK, since we know that in a single batch, all operations on the same','line_number':738,'multiline':False]
['text':' namespace MUST have the same shardVersion & databaseVersion.','line_number':739,'multiline':False]
['text':' Invariant checks that either the shardVersion & databaseVersion in nsInfo are','line_number':740,'multiline':False]
['text':' null OR the new versions in the targetedWrite match the existing version in','line_number':741,'multiline':False]
['text':' nsInfo.','line_number':742,'multiline':False]
['text':' For tracked timeseries collections, only the bucket collections are tracked. This','line_number':752,'multiline':False]
['text':' sets the namespace to the namespace of the tracked bucket collection.','line_number':753,'multiline':False]
['text':' If we are using the two phase write protocol introduced in PM-1632, we allow shard key','line_number':758,'multiline':False]
['text':' updates without specifying the full shard key in the query if we execute the update in a','line_number':759,'multiline':False]
['text':' retryable write/transaction.','line_number':760,'multiline':False]
['text':' It isn't necessary to copy the cursor options over, because the cursor options','line_number':784,'multiline':False]
['text':' are for use in the interaction between the mongos and the client and not','line_number':785,'multiline':False]
['text':' internally between the mongos and the mongods.','line_number':786,'multiline':False]
['text':' We encountered some error requiring us to abort execution. Note this may mean that some ops','line_number':802,'multiline':False]
['text':' are left in state pending.','line_number':803,'multiline':False]
['text':' TODO: Track ops lifetime.','line_number':808,'multiline':False]
['text':' Only return the first error if we are ordered.','line_number':841,'multiline':False]
['text':'*
 * Checks if an error reply has the TransientTransactionError label. We use this in cases where we
 * want to defer to whether a shard attached the label to an error it gave us.
 ','line_number':850,'multiline':True]
['text':' TODO (SERVER-76958): Iterate through the cursor rather than looking only at the first','line_number':888,'multiline':False]
['text':' batch.','line_number':889,'multiline':False]
['text':' Capture the errors if any exist and mark the writes in the TargetedWriteBatch so that','line_number':898,'multiline':False]
['text':' they may be re-targeted if needed.','line_number':899,'multiline':False]
['text':' If we are in a transaction, we must abort execution on any error, excluding','line_number':905,'multiline':False]
['text':' WouldChangeOwningShard. We do not abort on WouldChangeOwningShard because the error is','line_number':906,'multiline':False]
['text':' returned from the shard and recorded here as a placeholder, as we will end up processing','line_number':907,'multiline':False]
['text':' the update (as a delete + insert on the corresponding shards in a txn) at the level of','line_number':908,'multiline':False]
['text':' ClusterBulkWriteCmd.','line_number':909,'multiline':False]
['text':' Transient transaction errors should be returned directly as top level errors to allow','line_number':917,'multiline':False]
['text':' the client to retry.','line_number':918,'multiline':False]
['text':' To support errorsOnly:true we need to keep separate track of the index in the replyItems','line_number':939,'multiline':False]
['text':' array and the index of the write ops we need to mark. This is because with errorsOnly we do','line_number':940,'multiline':False]
['text':' not guarantee that writeOps.size == replyItems.size, successful writes do not return a reply.','line_number':941,'multiline':False]
['text':' We need to be able to check if the write','line_number':942,'multiline':False]
['text':' op has the same index as the next reply we received, which is why we need to track 2','line_number':943,'multiline':False]
['text':' different indexes in this loop. Our goal is to iterate the arrays as such','line_number':944,'multiline':False]
['text':' writes:  [0, 1, 2, 3] -> [0, 1, 2, 3] -> [0, 1, 2, 3] -> [0, 1, 2, 3]','line_number':945,'multiline':False]
['text':'           ^                  ^                  ^                  ^','line_number':946,'multiline':False]
['text':' replies: [1, 3]       -> [1, 3]       -> [1, 3]       -> [1, 3]','line_number':947,'multiline':False]
['text':'           ^               ^                  ^               ^','line_number':948,'multiline':False]
['text':' Only moving forward in replies when we see a matching write op.','line_number':949,'multiline':False]
['text':' This is only possible if we ran an errorsOnly:true command and succeeded all writes.','line_number':957,'multiline':False]
['text':' When an error is encountered on an ordered bulk write, it is impossible for any of the','line_number':968,'multiline':False]
['text':' remaining operations to have been executed. For that reason we reset them here so they','line_number':969,'multiline':False]
['text':' may be retargeted and retried if the error we saw is one we can retry after (e.g.','line_number':970,'multiline':False]
['text':' StaleConfig.).','line_number':971,'multiline':False]
['text':' On most errors (for example, a DuplicateKeyError) unordered bulkWrite on a shard attempts','line_number':980,'multiline':False]
['text':' to execute following operations even if a preceding operation errored. This isn't true','line_number':981,'multiline':False]
['text':' for StaleConfig, StaleDbVersion of ShardCannotRefreshDueToLocksHeld errors. On these','line_number':982,'multiline':False]
['text':' errors, since the shard knows that following operations will fail for the same reason, it','line_number':983,'multiline':False]
['text':' stops right away (except for unordered timeseries inserts, see SERVER-80796).','line_number':984,'multiline':False]
['text':' As a consequence, although typically we can expect the size of replyItems to match the','line_number':985,'multiline':False]
['text':' size of the number of operations sent (even in the case of errors), when a','line_number':986,'multiline':False]
['text':' staleness/cache busy error is received the size of replyItems will be <= the size of the','line_number':987,'multiline':False]
['text':' number of operations. When this is the case, we treat all the remaining operations which','line_number':988,'multiline':False]
['text':' may not have a replyItem as having failed due to the same cause.','line_number':989,'multiline':False]
['text':' Decrement the replyIndex so it keeps pointing to the same error (i.e. the','line_number':996,'multiline':False]
['text':' last error, which is a staleness error).','line_number':997,'multiline':False]
['text':' This can only happen when running an errorsOnly:true bulkWrite. We will only receive a','line_number':1008,'multiline':False]
['text':' bulkWriteReplyItem for an error response when this flag is enabled. This means that','line_number':1009,'multiline':False]
['text':' any writeOp which does not have a reply must have succeeded.','line_number':1010,'multiline':False]
['text':' Since both the writeOps and the replies are stored in ascending index order this is','line_number':1011,'multiline':False]
['text':' a safe assumption.','line_number':1012,'multiline':False]
['text':' writeOpIdx can be > than reply.getIdx when we are duplicating the last error','line_number':1013,'multiline':False]
['text':' as described in the block above.','line_number':1014,'multiline':False]
['text':' We need to keep the replyIndex where it is until we see the op matching its index.','line_number':1020,'multiline':False]
['text':' We don't always want to track errors per-namespace, e.g. when we encounter errors','line_number':1034,'multiline':False]
['text':' local to mongos.','line_number':1035,'multiline':False]
['text':' Stale routing info errors need to be tracked in order to trigger a refresh of','line_number':1039,'multiline':False]
['text':' the targeter. On the other hand, errors caused by the catalog cache being','line_number':1040,'multiline':False]
['text':' temporarily unavailable (such as ShardCannotRefreshDueToLocksHeld) are','line_number':1041,'multiline':False]
['text':' ignored in this context, since no deduction can be made around possible','line_number':1042,'multiline':False]
['text':' placement changes.','line_number':1043,'multiline':False]
['text':' Note that the targeting logic already handles recording the error for the appropriate','line_number':1071,'multiline':False]
['text':' WriteOp, so we only need to update the BulkWriteOp state here.','line_number':1072,'multiline':False]
['text':' Throw when there is a transient transaction error since this should be a top','line_number':1076,'multiline':False]
['text':' level error and not just a write error.','line_number':1077,'multiline':False]
['text':' hasWriteConcernError ','line_number':1079,'multiline':True]
['text':' isCommitOrAbort ','line_number':1080,'multiline':True]
['text':' If we see a local shutdown error, it means mongos itself is shutting down. A remote shutdown','line_number':1089,'multiline':False]
['text':' error would have been returned with response.swResponse.getStatus() being OK.','line_number':1090,'multiline':False]
['text':' If we see a local CallbackCanceled error, it is likely also due to mongos shutting down,','line_number':1091,'multiline':False]
['text':' therefore shutting down executor thread pools and cancelling any work scheduled on them.','line_number':1092,'multiline':False]
['text':' While we don't currently know of any other cases we'd see CallbackCanceled here, we check','line_number':1093,'multiline':False]
['text':' the shutdown flag as well to ensure the cancellation is due to shutdown.','line_number':1094,'multiline':False]
['text':' While the shutdown flag check is deprecated, that is because modules shouldn't consult it','line_number':1095,'multiline':False]
['text':' to coordinate their own shutdowns. But it is OK to use here because we are only checking','line_number':1096,'multiline':False]
['text':' whether a shutdown has started.','line_number':1097,'multiline':False]
['text':' We shouldn't continue execution (even if unordered) if we are shutting down since','line_number':1100,'multiline':False]
['text':' further batches will fail to execute as well.','line_number':1101,'multiline':False]
['text':' We want to throw such an error at the top level so that it can be returned to the client','line_number':1104,'multiline':False]
['text':' directly with the appropriate error labels,  allowing them to retry it.','line_number':1105,'multiline':False]
['text':' If we are in a transaction, we must stop immediately (even for unordered).','line_number':1109,'multiline':False]
['text':' Even if we aren't throwing a top-level error, we won't continue processing any','line_number':1111,'multiline':False]
['text':' outstanding writes after seeing this error since the transaction is aborted.','line_number':1112,'multiline':False]
['text':' Throw when there is a transient transaction error as those must be returned to the client','line_number':1115,'multiline':False]
['text':' at the top level to allow them to retry.','line_number':1116,'multiline':False]
['text':' Treat an error to get a batch response as failures of the contained write(s).','line_number':1150,'multiline':False]
['text':' This error isn't actually specific to any namespaces and so we do not want to track it.','line_number':1160,'multiline':False]
['text':' retriedStmtIds ','line_number':1163,'multiline':True]
['text':' errorsPerNamespace','line_number':1164,'multiline':True]
['text':' Cancel all childOps if any.','line_number':1174,'multiline':False]
['text':' If we encountered an error causing us to abort execution we may not have waited for','line_number':1221,'multiline':False]
['text':' responses to all outstanding requests.','line_number':1222,'multiline':False]
['text':' TODO (SERVER-79611): Improve mongos metrics.','line_number':1226,'multiline':False]
['text':' TODO SERVER-79510: Remove this. This is necessary right now because the nModified','line_number':1250,'multiline':False]
['text':'  field is lost in the BulkWriteReplyItem -> WriteError transformation but','line_number':1251,'multiline':False]
['text':' we want to return nModified for failed updates. However, this does not actually','line_number':1252,'multiline':False]
['text':' return a correct value for multi:true updates that partially succeed (i.e. succeed','line_number':1253,'multiline':False]
['text':' on one or more shard and fail on one or more shards). In SERVER-79510 we should','line_number':1254,'multiline':False]
['text':' return a correct nModified count by summing the success responses' nModified','line_number':1255,'multiline':False]
['text':' values.','line_number':1256,'multiline':False]
['text':' We only count nErrors at the end of the command because it is simpler and less error','line_number':1260,'multiline':False]
['text':' prone. If we counted errors as we encountered them we could hit edge cases where we','line_number':1261,'multiline':False]
['text':' accidentally count the same error multiple times. At this point in the execution we','line_number':1262,'multiline':False]
['text':' have already resolved any repeat errors.','line_number':1263,'multiline':False]
['text':' Only return the first error if we are ordered.','line_number':1265,'multiline':False]
['text':' We must use the namespace from the original client request instead of the targeter's','line_number':1303,'multiline':False]
['text':' namespace because the targeter's namespace could be pointing to the bucket collection for','line_number':1304,'multiline':False]
['text':' tracked timeseries collections.','line_number':1305,'multiline':False]
['text':' For simplicity, we build a dummy bulk write command request that contains all the common','line_number':1343,'multiline':False]
['text':' fields and serialize it to get the base command size.','line_number':1344,'multiline':False]
['text':' We only bother to copy over variable-size and/or optional fields, since the value of fields','line_number':1345,'multiline':False]
['text':' that are fixed-size and always present (e.g. 'ordered') won't affect the size calculation.','line_number':1346,'multiline':False]
['text':' These have not been set yet, but will be set later on for each namespace as part of the','line_number':1349,'multiline':False]
['text':' write targeting and batch building process. To ensure we save space for these fields, we','line_number':1350,'multiline':False]
['text':' add dummy versions to the namespaces before serializing.','line_number':1351,'multiline':False]
['text':' This could be a timeseries view. To be conservative about the estimate, we','line_number':1361,'multiline':False]
['text':' speculatively account for the additional size needed for the timeseries bucket','line_number':1362,'multiline':False]
['text':' transalation and the 'isTimeseriesCollection' field.','line_number':1363,'multiline':False]
['text':' We'll account for the size to store each individual op as we add them, so just put an empty','line_number':1373,'multiline':False]
['text':' vector as a placeholder for the array. This will ensure we properly count the size of the','line_number':1374,'multiline':False]
['text':' field name and the empty array.','line_number':1375,'multiline':False]
['text':' We'll account for the size to store each individual stmtId as we add ops, so similar to','line_number':1379,'multiline':False]
['text':' above with ops, we just put an empty vector as a placeholder for now.','line_number':1380,'multiline':False]
['text':' Add writeConcern and lsid/txnNumber to ensure we save space for them.','line_number':1386,'multiline':False]
['text':' namespace bulk_write_exec','line_number':1420,'multiline':False]
['text':' namespace mongo','line_number':1422,'multiline':False]
