['text':'*
 *    Copyright (C) 2020-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]
['text':' This would hang for a very long time if the behavior were incorrect.','line_number':237,'multiline':False]
['text':' This would hang for a very long time if the behavior were incorrect.','line_number':249,'multiline':False]
['text':' Advance the time some, but not enough to be past the delay yet.','line_number':267,'multiline':False]
['text':' Advance the time past the delay.','line_number':275,'multiline':False]
['text':' Due to the backoff, the delays are going to be 1000 seconds and 2000 seconds.','line_number':298,'multiline':False]
['text':' Advance the time some, but not enough to be past the first delay.','line_number':299,'multiline':False]
['text':' Advance the time past the first delay.','line_number':308,'multiline':False]
['text':' Advance the time some more, but not enough to be past the second delay.','line_number':317,'multiline':False]
['text':' Advance the time past the second delay.','line_number':326,'multiline':False]
['text':' This should hang forever if it is not canceled.','line_number':470,'multiline':False]
['text':' Arbitrary delay used, enforce only one loop body execution with timesRanCallback','line_number':479,'multiline':False]
['text':' Enforce cancellation during loop body execution','line_number':488,'multiline':False]
['text':' Enforce cancellation after loop body executes once','line_number':508,'multiline':False]
['text':' Access the move-only result via a const reference.','line_number':617,'multiline':False]
['text':' Consume the (move-only) result.','line_number':622,'multiline':False]
['text':' Finish resolving remaining with success.','line_number':670,'multiline':False]
['text':' Start at 1 since the 0'th input was already set with an error.','line_number':672,'multiline':False]
['text':' Finish resolving remaining with an error. Start at 1 since the 0'th input was already set','line_number':688,'multiline':False]
['text':' with an error. It's not strictly necessary to do this explicitly since they'd fail with','line_number':689,'multiline':False]
['text':' BrokenPromise anyways when the promises are destroyed, but this makes the test case more','line_number':690,'multiline':False]
['text':' clear.','line_number':691,'multiline':False]
['text':' Emplace all but the last promise with a value.','line_number':703,'multiline':False]
['text':' Set an error on the last input.','line_number':711,'multiline':False]
['text':' Emplace success on all input futures. The result should not be ready','line_number':736,'multiline':False]
['text':' until the last one is emplaced.','line_number':737,'multiline':False]
['text':' Create a random order of indexes in which to resolve the input futures.','line_number':756,'multiline':False]
['text':' The output should be in the same order as the input, regardless of the','line_number':773,'multiline':False]
['text':' order in which the futures resolved.','line_number':774,'multiline':False]
['text':' Turn raw input Futures into ExecutorFutures.','line_number':784,'multiline':False]
['text':' Create a random order of indexes in which to resolve the input futures.','line_number':816,'multiline':False]
['text':' The output should be in the same order as the input, regardless of the','line_number':833,'multiline':False]
['text':' order in which the futures resolved.','line_number':834,'multiline':False]
['text':' Test whenAllSucceed with void input futures.','line_number':840,'multiline':False]
['text':' Start at 1 since the 0'th input was already set with an error.','line_number':872,'multiline':False]
['text':' Finish resolving remaining with an error. Start at 1 since the 0'th input was already set','line_number':888,'multiline':False]
['text':' with an error. It's not strictly necessary to do this explicitly since they'd fail with','line_number':889,'multiline':False]
['text':' BrokenPromise anyways when the promises are destroyed, but this makes the test case more','line_number':890,'multiline':False]
['text':' clear.','line_number':891,'multiline':False]
['text':' Emplace all but the last promise with a value.','line_number':903,'multiline':False]
['text':' Set an error on the last input.','line_number':909,'multiline':False]
['text':' Turn raw input Futures into ExecutorFutures.','line_number':962,'multiline':False]
['text':' Iterate over inputs backwards, resolving them one at a time.','line_number':1099,'multiline':False]
['text':' Turn raw input Futures into ExecutorFutures.','line_number':1126,'multiline':False]
['text':' Make sure there's no problem when these resolve after whenAny has resolved due to an error.','line_number':1236,'multiline':False]
['text':' Make sure there's no problem when these resolve after whenAny has resolved due to an error.','line_number':1301,'multiline':False]
['text':' Turn raw input Futures into ExecutorFutures.','line_number':1313,'multiline':False]
['text':' Turn raw input Futures into ExecutorFutures.','line_number':1352,'multiline':False]
['text':' Canceling after the fact shouldn't hang or cause crashes.','line_number':1385,'multiline':False]
['text':' Canceling after the fact shouldn't hang or cause crashes.','line_number':1401,'multiline':False]
['text':' Keep from getting a BrokenPromise assertion when the input promise is destroyed.','line_number':1413,'multiline':False]
['text':' If we get an inline result, we immediately see the State destruct.','line_number':1505,'multiline':False]
['text':' The guard will not destruct while we have the AsyncState on the local stack.','line_number':1518,'multiline':False]
['text':' We don't have to use the AsyncState immediately. Imagine that we create the state under lock,','line_number':1522,'multiline':False]
['text':' do a bunch of other synchronized work, then release the lock and invoke thenWithState.','line_number':1523,'multiline':False]
['text':' If we get an inline result, we immediately see the State destruct.','line_number':1525,'multiline':False]
['text':' If we get an inline error, we immediately see the State destruct.','line_number':1538,'multiline':False]
['text':' If we get an exception, we never invoke the callback for thenWithState().','line_number':1558,'multiline':False]
['text':' Use a different code so that we can assert we don't return from here.','line_number':1560,'multiline':False]
['text':' If we get an exception, we immediately see the State destruct.','line_number':1568,'multiline':False]
['text':' If we delay the inline result, we see the State destruct when we emplace the promise.','line_number':1580,'multiline':False]
['text':' Return current counter output (post-guard) from a future continuation.','line_number':1589,'multiline':False]
['text':' Check that the guard does not run until we emplace the promise.','line_number':1593,'multiline':False]
['text':' Confirm that the future continuation ran.','line_number':1597,'multiline':False]
['text':' If we delay the inline result, we see the State destruct when we emplace the promise.','line_number':1603,'multiline':False]
['text':' Return current counter output (post-guard) from a future continuation.','line_number':1612,'multiline':False]
['text':' Check that the guard does not run until we emplace the promise.','line_number':1616,'multiline':False]
['text':' Confirm that the future continuation observed the right result.','line_number':1621,'multiline':False]
['text':' If we delay the inline result, we see the State destruct when we emplace the promise.','line_number':1627,'multiline':False]
['text':' We've bound the pointer to guard, which should remain valid in the','line_number':1632,'multiline':False]
['text':' continuation.','line_number':1633,'multiline':False]
['text':' Return current counter output (post-guard) from a future continuation.','line_number':1639,'multiline':False]
['text':' Check that the guard does not run until we emplace the promise.','line_number':1643,'multiline':False]
['text':' Confirm that the future continuation observed the right result.','line_number':1648,'multiline':False]
['text':' namespace','line_number':1653,'multiline':False]
['text':' namespace mongo','line_number':1654,'multiline':False]
