['text':'
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 ','line_number':1,'multiline':True]
['text':'-************************************
*  Compiler specific
*************************************','line_number':12,'multiline':True]
['text':' Visual Studio ','line_number':15,'multiline':True]
['text':' fgets ','line_number':16,'multiline':True]
['text':' disable: C4127: conditional expression is constant ','line_number':17,'multiline':True]
['text':' disable: C4204: non-constant aggregate initializer ','line_number':18,'multiline':True]
['text':'-************************************
*  Includes
*************************************','line_number':22,'multiline':True]
['text':' free ','line_number':25,'multiline':True]
['text':' fgets, sscanf ','line_number':26,'multiline':True]
['text':' strcmp ','line_number':27,'multiline':True]
['text':' time(), time_t ','line_number':28,'multiline':True]
['text':' always enable assert() ','line_number':29,'multiline':True]
['text':' ZSTD_compressContinue, ZSTD_compressBlock ','line_number':31,'multiline':True]
['text':' DEBUG_STATIC_ASSERT ','line_number':32,'multiline':True]
['text':' No deprecation warnings, we still test some deprecated functions ','line_number':34,'multiline':True]
['text':' ZSTD_VERSION_STRING ','line_number':35,'multiline':True]
['text':' ZSTD_getErrorCode ','line_number':36,'multiline':True]
['text':' ZDICT_trainFromBuffer ','line_number':38,'multiline':True]
['text':' RDG_genBuffer ','line_number':40,'multiline':True]
['text':' XXH64_state_t ','line_number':41,'multiline':True]
['text':' XXH64 ','line_number':42,'multiline':True]
['text':' SEC_TO_MICRO, UTIL_time_t, UTIL_TIME_INITIALIZER, UTIL_clockSpanMicro, UTIL_getTime ','line_number':44,'multiline':True]
['text':' must be included after util.h, due to ERROR macro redefinition issue on Visual Studio ','line_number':45,'multiline':True]
['text':' ZSTD_WORKSPACETOOLARGE_MAXDURATION, ZSTD_WORKSPACETOOLARGE_FACTOR, KB, MB ','line_number':46,'multiline':True]
['text':' ZSTD_pthread_create, ZSTD_pthread_join ','line_number':47,'multiline':True]
['text':'-************************************
*  Constants
*************************************','line_number':50,'multiline':True]
['text':'-************************************
*  Display Macros
*************************************','line_number':59,'multiline':True]
['text':'-*******************************************************
*  Compile time test
********************************************************','line_number':77,'multiline':True]
['text':' Declaring the function, to avoid -Wmissing-prototype ','line_number':82,'multiline':True]
['text':' these constants shall not depend on MIN() macro ','line_number':85,'multiline':True]
['text':'-*******************************************************
*  Internal functions
********************************************************','line_number':91,'multiline':True]
['text':'=============================================
*   Test macros
=============================================','line_number':119,'multiline':True]
['text':'=============================================
*   Memory Tests
=============================================','line_number':146,'multiline':True]
['text':' malloc_size ','line_number':151,'multiline':True]
['text':' OS-X specific ','line_number':169,'multiline':True]
['text':' OS-X specific ','line_number':183,'multiline':True]
['text':' test only played in verbose mode, as they are long ','line_number':198,'multiline':True]
['text':' Create compressible noise ','line_number':201,'multiline':True]
['text':'auto','line_number':206,'multiline':True]
['text':' simple compression tests ','line_number':208,'multiline':True]
['text':' streaming compression tests ','line_number':221,'multiline':True]
['text':' advanced MT API test ','line_number':238,'multiline':True]
['text':' advanced MT streaming API test ','line_number':256,'multiline':True]
['text':' 85.3 MB ','line_number':282,'multiline':True]
['text':' Create compressible noise ','line_number':288,'multiline':True]
['text':' err ','line_number':424,'multiline':True]
['text':' err ','line_number':426,'multiline':True]
['text':' ZSTD_MULTITHREAD ','line_number':461,'multiline':True]
['text':'=============================================
*   Unit tests
=============================================','line_number':463,'multiline':True]
['text':' check ZSTD_compressBound == ZSTD_COMPRESSBOUND
     * for a large range of known valid values ','line_number':471,'multiline':True]
['text':' Ensure error if srcSize too big ','line_number':480,'multiline':True]
['text':' must fail ','line_number':482,'multiline':True]
['text':' Simple compression, with size : should provide size; ','line_number':493,'multiline':True]
['text':' Simple small compression without size : should provide 1 block size ','line_number':501,'multiline':True]
['text':' Attempt to overflow 32-bit intermediate multiplication result
     * This requires dBound >= 4 GB, aka 2^32.
     * This requires 2^32 / 2^17 = 2^15 blocks
     * => create 2^15 blocks (can be empty, or just 1 byte). ','line_number':514,'multiline':True]
['text':' large margin ','line_number':521,'multiline':True]
['text':' 4 GB ','line_number':534,'multiline':True]
['text':' valid cparams ','line_number':550,'multiline':True]
['text':' invalid cparams (must fail) ','line_number':554,'multiline':True]
['text':' Create compressible noise ','line_number':573,'multiline':True]
['text':' Basic tests ','line_number':581,'multiline':True]
['text':' must fail ','line_number':710,'multiline':True]
['text':' must fail ','line_number':711,'multiline':True]
['text':' %p takes a void*. In ISO C, it's illegal to cast a function pointer
         * to a data pointer. (Although in POSIX you're required to be allowed
         * to do it...) So we have to fall back to our trusty friend memcpy. ','line_number':734,'multiline':True]
['text':' create compressed buffer with checksumming enabled ','line_number':822,'multiline':True]
['text':' copy the compressed buffer and corrupt the checksum ','line_number':835,'multiline':True]
['text':' wrong checksum size should still throw error ','line_number':851,'multiline':True]
['text':' create compressed buffer with content size missing ','line_number':861,'multiline':True]
['text':' ensure frame content size is missing ','line_number':869,'multiline':True]
['text':' ensure CNBuffSize <= decompressBound ','line_number':874,'multiline':True]
['text':' create a large frame and then a bunch of small frames ','line_number':892,'multiline':True]
['text':' decompressStream and make sure that dctx size was reduced at least once ','line_number':900,'multiline':True]
['text':' success! size was reduced from the previous frame ','line_number':908,'multiline':True]
['text':' Force an LDM to exist that crosses block boundary into uncompressible block ','line_number':1069,'multiline':True]
['text':' Enable MT, LDM, and opt parser ','line_number':1072,'multiline':True]
['text':' Flushes a block of 128 KB and block of 5 bytes ','line_number':1078,'multiline':True]
['text':' Compress the rest ','line_number':1081,'multiline':True]
['text':' Enable checksum to verify round trip. ','line_number':1108,'multiline':True]
['text':' Disable content size to skip single-pass decompression. ','line_number':1110,'multiline':True]
['text':' Round trip once with a dictionary. ','line_number':1119,'multiline':True]
['text':' Streaming decompression to catch out of bounds offsets. ','line_number':1125,'multiline':True]
['text':' Round trip once with a dictionary. ','line_number':1135,'multiline':True]
['text':' Streaming decompression to catch out of bounds offsets. ','line_number':1152,'multiline':True]
['text':' Note: this test takes 0.5 seconds to run ','line_number':1167,'multiline':True]
['text':' test a big buffer so that ldm can take effect ','line_number':1170,'multiline':True]
['text':' make dict and src the same uncompressible data ','line_number':1187,'multiline':True]
['text':' set level 1 and windowLog to cover src ','line_number':1192,'multiline':True]
['text':' compress on level 1 using just refPrefix and no ldm ','line_number':1196,'multiline':True]
['text':' test round trip just refPrefix ','line_number':1201,'multiline':True]
['text':' compress on level 1 using refPrefix and ldm ','line_number':1208,'multiline':True]
['text':' test round trip refPrefix + ldm','line_number':1214,'multiline':True]
['text':' make sure that refPrefixCompressedSize is significantly greater ','line_number':1221,'multiline':True]
['text':' make sure the ldm compressed size is less than 1% of original ','line_number':1223,'multiline':True]
['text':' Generate data without any matches ','line_number':1300,'multiline':True]
['text':' Generate 32K of compressible data ','line_number':1302,'multiline':True]
['text':' Add a match of offset=12, length=8 at idx=16, 32, 48, 64  ','line_number':1305,'multiline':True]
['text':' Add a match of offset=16, length=8 at idx=64K + 64.
         * This generates a sequence with llen=64K, and repeat code 1.
         * The block splitter thought this was ll0, and corrupted the
         * repeat offset history.
         ','line_number':1311,'multiline':True]
['text':' Add a match of offset=16, length=8 at idx=128K + 16.
         * This should generate a sequence with repeat code = 1.
         * But the block splitters mistake caused zstd to generate
         * repeat code = 2, corrupting the data.
         ','line_number':1321,'multiline':True]
['text':' Generate a golden file from this data in case datagen changes and
         * doesn't generate the exact same data. We will also test this golden file.
         ','line_number':1331,'multiline':True]
['text':' This is the number of bytes to stream before ending. This value
         * was obtained by trial and error :/. ','line_number':1362,'multiline':True]
['text':' The first 1/5 of the buffer is compressible and the last 4/5 is
         * uncompressible. This is an approximation of the type of data
         * the fuzzer generated to catch this bug. Streams like this were making
         * zstd generate noCompress superblocks (which are larger than the src
         * they come from). Do this enough times, and we'll run out of room
         * and throw a dstSize_tooSmall error. ','line_number':1368,'multiline':True]
['text':' Setting target block size so that superblock is used ','line_number':1380,'multiline':True]
['text':' This is trying to catch a dstSize_tooSmall error ','line_number':1395,'multiline':True]
['text':' Generate the same data 20 times over ','line_number':1406,'multiline':True]
['text':' auto ','line_number':1411,'multiline':True]
['text':'auto','line_number':1430,'multiline':True]
['text':' This tests whether or not we leave enough room for the checksum at the end
     * of the dst buffer. The bug that motivated this test was found by the
     * stream_round_trip fuzzer but this crashes for the same reason and is
     * far more compact than re-creating the stream_round_trip fuzzer's code path ','line_number':1432,'multiline':True]
['text':' content size unknown ','line_number':1477,'multiline':True]
['text':' ensure no possibility to "concatenate" and determine the content size ','line_number':1478,'multiline':True]
['text':' single scan decompression ','line_number':1481,'multiline':True]
['text':' streaming decompression ','line_number':1486,'multiline':True]
['text':' block size will be adapted if pledgedSrcSize is enabled ','line_number':1512,'multiline':True]
['text':'pledgedSrcSize','line_number':1513,'multiline':True]
['text':' creates a block size of 1 ','line_number':1514,'multiline':True]
['text':' re-use same parameters ','line_number':1516,'multiline':True]
['text':' will fail if blockSize is not resized ','line_number':1520,'multiline':True]
['text':' ensure no match during initial section ','line_number':1530,'multiline':True]
['text':' create one match, starting from beginning of sample, which is the difficult case (see #1241) ','line_number':1531,'multiline':True]
['text':' force streaming, as output buffer is not large enough to guarantee success ','line_number':1548,'multiline':True]
['text':' force streaming, as output buffer is not large enough to guarantee success ','line_number':1559,'multiline':True]
['text':' start with something, so that context is already used ','line_number':1583,'multiline':True]
['text':' will break internal assert if stats_init is not disabled ','line_number':1584,'multiline':True]
['text':' cancel output ','line_number':1586,'multiline':True]
['text':' too small size : compression will be skipped ','line_number':1589,'multiline':True]
['text':' too small size : compression will be skipped ','line_number':1594,'multiline':True]
['text':' small enough to attempt compression ','line_number':1598,'multiline':True]
['text':' large enough to trigger stats_init, but no longer at beginning ','line_number':1603,'multiline':True]
['text':' will break internal assert if stats_init is not disabled ','line_number':1604,'multiline':True]
['text':' Start a compression job ','line_number':1630,'multiline':True]
['text':' Reset the CCtx ','line_number':1636,'multiline':True]
['text':' Reset the parameters ','line_number':1642,'multiline':True]
['text':' Set invalid cParams == no change. ','line_number':1658,'multiline':True]
['text':' Set invalid params == no change. ','line_number':1726,'multiline':True]
['text':' Even if LDM will be enabled by default in the applied params (since wlog >= 27 and strategy >= btopt),
         * we should not modify the actual parameter specified by the user within the CCtx
         ','line_number':1786,'multiline':True]
['text':' this test is really too long, and should be made faster ','line_number':1800,'multiline':True]
['text':' ensure U32 overflow protection is triggered ','line_number':1804,'multiline':True]
['text':' re-use same parameters ','line_number':1811,'multiline':True]
['text':' streaming implies ZSTD_CONTENTSIZE_UNKNOWN, which maximizes memory usage ','line_number':1821,'multiline':True]
['text':' size of context must be measured after compression ','line_number':1823,'multiline':True]
['text':' note : "too large" definition is handled within zstd_compress.c .
                                                                 * make this test case extreme, so that it doesn't depend on a possibly fluctuating definition ','line_number':1830,'multiline':True]
['text':' nb of usages before triggering size down is handled within zstd_compress.c.
                                                   * currently defined as 128x, but could be adjusted in the future.
                                                   * make this test long enough so that it's not too much tied to the current definition within zstd_compress.c ','line_number':1835,'multiline':True]
['text':' sized down ','line_number':1841,'multiline':True]
['text':' no sizedown happened ','line_number':1844,'multiline':True]
['text':' Static CCtx tests ','line_number':1851,'multiline':True]
['text':' ensure size down scenario ','line_number':1907,'multiline':True]
['text':' note : doesn't allocate ','line_number':1949,'multiline':True]
['text':' now allocates, should fail ','line_number':1952,'multiline':True]
['text':' note : doesn't allocate ','line_number':1960,'multiline':True]
['text':' note : doesn't allocate ','line_number':1968,'multiline':True]
['text':' Test ZSTD_estimateCCtxSize_usingCCtxParams','line_number':1991,'multiline':False]
['text':' Test ZSTD_estimateCStreamSize_usingCCtxParams','line_number':2010,'multiline':False]
['text':' Test ZSTD_estimateCCtxSize_usingCCtxParams','line_number':2033,'multiline':False]
['text':' Test ZSTD_estimateCStreamSize_usingCCtxParams','line_number':2054,'multiline':False]
['text':' ZSTDMT simple MT compression test ','line_number':2093,'multiline':True]
['text':' Set rsyncable and don't give the ZSTD_compressBound(CNBuffSize) so
         * ZSTDMT is forced to not take the shortcut.
         ','line_number':2196,'multiline':True]
['text':' Check that the overlap log and job size are unset. ','line_number':2211,'multiline':True]
['text':' Set and check the overlap log and job size. ','line_number':2216,'multiline':True]
['text':' Set the number of workers and check the overlap log and job size. ','line_number':2223,'multiline':True]
['text':' Simple API multiframe test ','line_number':2233,'multiline':True]
['text':' only use the first half so we don't push against size limit of compressedBuffer ','line_number':2238,'multiline':True]
['text':' insert skippable frame ','line_number':2252,'multiline':True]
['text':' Simple API skippable frame test ','line_number':2284,'multiline':True]
['text':' Dictionary and CCtx Duplication tests ','line_number':2325,'multiline':True]
['text':' error must be detected ','line_number':2334,'multiline':True]
['text':' Begin_usingDict implies unknown srcSize, so match that ','line_number':2339,'multiline':True]
['text':' should be identical ==> same size ','line_number':2365,'multiline':True]
['text':' Note : these tests should be replaced by proper regression tests,
         *         but existing ones do not focus on small data + dictionary + all levels.
         ','line_number':2410,'multiline':True]
['text':' test only valid with known input ','line_number':2413,'multiline':True]
['text':' These upper bounds are generally within a few bytes of the compressed size ','line_number':2418,'multiline':True]
['text':' clevels with strategies that support rowhash on small inputs ','line_number':2431,'multiline':True]
['text':' Compression with ZSTD_compress2 and row match finder force enabled.
             * Give some slack for force-enabled row matchfinder since we're on a small input (9KB)
             ','line_number':2467,'multiline':True]
['text':' Dict compression with DMS ','line_number':2488,'multiline':True]
['text':' Dictionary and dictBuilder tests ','line_number':2514,'multiline':True]
['text':' less samples for faster tests ','line_number':2570,'multiline':True]
['text':' less samples for faster tests ','line_number':2586,'multiline':True]
['text':' non-conformant (content-only) dictionary ','line_number':2647,'multiline':True]
['text':' non-conformant (content-only) dictionary ','line_number':2653,'multiline':True]
['text':' non-conformant (content-only) dictionary ','line_number':2691,'multiline':True]
['text':' frameSize ','line_number':2735,'multiline':True]
['text':' checksum ','line_number':2735,'multiline':True]
['text':' noDictID','line_number':2735,'multiline':True]
['text':' Either operation is allowed to fail, but one must fail. ','line_number':2846,'multiline':True]
['text':' Force the dictionary to be reloaded in raw content mode ','line_number':2870,'multiline':True]
['text':' We should fail to decompress without a dictionary. ','line_number':3008,'multiline':True]
['text':' We should succeed to decompress with the dictionary. ','line_number':3012,'multiline':True]
['text':' The dictionary should persist across calls. ','line_number':3016,'multiline':True]
['text':' When we reset the context the dictionary is cleared. ','line_number':3018,'multiline':True]
['text':' We should succeed to decompress with the ddict. ','line_number':3031,'multiline':True]
['text':' The ddict should persist across calls. ','line_number':3035,'multiline':True]
['text':' When we reset the context the ddict is cleared. ','line_number':3037,'multiline':True]
['text':' We should succeed to decompress with the prefix. ','line_number':3050,'multiline':True]
['text':' The prefix should be cleared after the first compression. ','line_number':3054,'multiline':True]
['text':' Set windowLog to 25 so hash/chain logs don't get sized down ','line_number':3068,'multiline':True]
['text':' Set srcSizeHint to 2^25 so hash/chain logs don't get sized down ','line_number':3072,'multiline':True]
['text':' Set windowLog to 25 so hash/chain logs don't get sized down ','line_number':3095,'multiline':True]
['text':' Set srcSizeHint to 2^25 so hash/chain logs don't get sized down ','line_number':3099,'multiline':True]
['text':' Force enable row based match finder, and disable dedicated dict search. ','line_number':3122,'multiline':True]
['text':' Set windowLog to 29 so hash/chain logs don't get sized down ','line_number':3126,'multiline':True]
['text':' Set srcSizeHint to 2^29 so hash/chain logs don't get sized down ','line_number':3129,'multiline':True]
['text':' Set all the repcodes to non-default ','line_number':3150,'multiline':True]
['text':' Find the repcodes ','line_number':3154,'multiline':True]
['text':' Set the last 8 bytes to 'x' ','line_number':3164,'multiline':True]
['text':' The optimal parser checks all the repcodes.
         * Make sure at least one is a match >= targetLength so that it is
         * immediately chosen. This will make sure that the compressor and
         * decompressor agree on at least one of the repcodes.
         ','line_number':3167,'multiline':True]
['text':' Create new compressed buffer that will hold frames with differing dictIDs ','line_number':3201,'multiline':True]
['text':' Modifiable copy of fixed full dict buffer ','line_number':3202,'multiline':True]
['text':' Create a bunch of DDicts with random dict IDs ','line_number':3205,'multiline':True]
['text':' Compress a few frames using random CDicts ','line_number':3215,'multiline':True]
['text':' only use the first half so we don't push against size limit of compressedBuffer ','line_number':3218,'multiline':True]
['text':' We should succeed to decompression even though different dicts were used on different frames ','line_number':3233,'multiline':True]
['text':' Reference every single ddict we made ','line_number':3236,'multiline':True]
['text':' Streaming decompression should also work ','line_number':3241,'multiline':True]
['text':' COVER dictionary builder tests ','line_number':3265,'multiline':True]
['text':' Decompression defense tests ','line_number':3319,'multiline':True]
['text':' too small input ','line_number':3321,'multiline':True]
['text':' content size verification test ','line_number':3332,'multiline':True]
['text':' negative compression level test : ensure simple API and advanced API produce same result ','line_number':3348,'multiline':True]
['text':' parameters order test ','line_number':3371,'multiline':True]
['text':' must result in same compressed result, hence same size ','line_number':3401,'multiline':True]
['text':' must result in exactly same content, hence same hash ','line_number':3402,'multiline':True]
['text':' advanced parameters for decompression ','line_number':3409,'multiline':True]
['text':' custom formats tests ','line_number':3441,'multiline':True]
['text':' won't cause pb with small dict size ','line_number':3444,'multiline':True]
['text':' basic block compression ','line_number':3447,'multiline':True]
['text':' one shot ','line_number':3472,'multiline':True]
['text':' streaming ','line_number':3477,'multiline':True]
['text':' basic block compression ','line_number':3487,'multiline':True]
['text':' one shot ','line_number':3502,'multiline':True]
['text':' streaming ','line_number':3507,'multiline':True]
['text':' Attempt to future proof this to new parameters. ','line_number':3524,'multiline':True]
['text':' block API tests ','line_number':3549,'multiline':True]
['text':' won't cause pb with small dict size ','line_number':3553,'multiline':True]
['text':' basic block compression ','line_number':3557,'multiline':True]
['text':' very long stream of block compression ','line_number':3570,'multiline':True]
['text':' we just want to quickly overflow internal U32 index ','line_number':3572,'multiline':True]
['text':' > 4 GB ','line_number':3574,'multiline':True]
['text':' dictionary block compression ','line_number':3584,'multiline':True]
['text':' create a non-compressible second block ','line_number':3588,'multiline':True]
['text':' for cctx history consistency ','line_number':3589,'multiline':True]
['text':' non-compressible block ','line_number':3590,'multiline':True]
['text':' send non-compressed block (without header) ','line_number':3591,'multiline':True]
['text':' insert non-compressed block into dctx history ','line_number':3604,'multiline':True]
['text':' ensure regenerated content is identical to origin ','line_number':3610,'multiline':True]
['text':' long rle test ','line_number':3626,'multiline':True]
['text':' block 1, 2: compressed, block 3: RLE, zstd 1.4.4 ','line_number':3628,'multiline':True]
['text':' Populate src with random data ','line_number':3654,'multiline':True]
['text':' Test with block delimiters roundtrip ','line_number':3657,'multiline':True]
['text':' Test no block delimiters roundtrip ','line_number':3662,'multiline':True]
['text':' Populate src with random data ','line_number':3689,'multiline':True]
['text':' Roundtrip Test with block delimiters generated by ZSTD_generateSequences() ','line_number':3692,'multiline':True]
['text':' Roundtrip Test with no block delimiters  ','line_number':3708,'multiline':True]
['text':' Multiple blocks of zeros test ','line_number':3731,'multiline':True]
['text':' 1MB of zeros ','line_number':3732,'multiline':True]
['text':' All zeroes test (test bug #137) ','line_number':3743,'multiline':True]
['text':' nbSeq limit test ','line_number':3755,'multiline':True]
['text':' creates a buffer full of 3-bytes sequences ','line_number':3760,'multiline':True]
['text':' create batch of 3-bytes sequences ','line_number':3764,'multiline':True]
['text':' randomly fills CNBuffer with prepared 3-bytes sequences ','line_number':3772,'multiline':True]
['text':' note : CNBuffer size > _3BYTESTESTLENGTH+3 ','line_number':3774,'multiline':True]
['text':' Check every sequence for the first 100, then skip more rapidly. ','line_number':3787,'multiline':True]
['text':' Check every size for the first 100, then skip more rapidly. ','line_number':3816,'multiline':True]
['text':' Train a dictionary on low characters ','line_number':3828,'multiline':True]
['text':' Reverse the characters to make the dictionary ill suited ','line_number':3839,'multiline':True]
['text':' Compress the data ','line_number':3844,'multiline':True]
['text':' findFrameCompressedSize on skippable frames ','line_number':3861,'multiline':True]
['text':' error string tests ','line_number':3868,'multiline':True]
['text':' Calling FSE_normalizeCount() on a uniform distribution should not
         * cause a division by zero.
         ','line_number':3912,'multiline':True]
['text':' useLowProbCount ','line_number':3915,'multiline':True]
['text':' Ensure that this write doesn't write out of bounds, and that
         * FSE_writeNCount_generic() is *not* called with writeIsSafe == 1.
         ','line_number':3927,'multiline':True]
['text':' need non-const seed to avoid compiler warning for FUZ_rand(&seed) ','line_number':3937,'multiline':True]
['text':' CLZ and CTZ are undefined on 0 ','line_number':3945,'multiline':True]
['text':' CLZ and CTZ are undefined on 0 ','line_number':3946,'multiline':True]
['text':' Test ZSTD_countTrailingZeros32 ','line_number':3948,'multiline':True]
['text':' Test ZSTD_countLeadingZeros32 ','line_number':3953,'multiline':True]
['text':' Test ZSTD_countTrailingZeros64 ','line_number':3958,'multiline':True]
['text':' Test ZSTD_countLeadingZeros64 ','line_number':3962,'multiline':True]
['text':' Test ZSTD_highbit32 ','line_number':3966,'multiline':True]
['text':' Test ZSTD_NbCommonBytes ','line_number':3970,'multiline':True]
['text':' Test MEM_ intrinsics ','line_number':3989,'multiline':True]
['text':' Test fallbacks vs intrinsics on a range of small integers ','line_number':3993,'multiline':True]
['text':' A little more than ZSTDMT_JOBSIZE_MIN ','line_number':4006,'multiline':True]
['text':' Make sure there is no ZSTD_MAGIC_NUMBER ','line_number':4015,'multiline':True]
['text':' something more than 1 ','line_number':4018,'multiline':True]
['text':' lie and claim this is a full dict ','line_number':4020,'multiline':True]
['text':' should fail because its not a full dict like we said it was ','line_number':4025,'multiline':True]
['text':' A little more than ZSTDMT_JOBSIZE_MIN ','line_number':4036,'multiline':True]
['text':' Make sure there is no ZSTD_MAGIC_NUMBER ','line_number':4046,'multiline':True]
['text':' Enable MT, LDM, and use refPrefix() for a small dict ','line_number':4049,'multiline':True]
['text':' ZSTD_MULTITHREAD ','line_number':4133,'multiline':True]
['text':' Create compressible noise ','line_number':4158,'multiline':True]
['text':' note : this test is rather long, it would be great to find a way to speed up its execution ','line_number':4166,'multiline':True]
['text':' ZSTD_CURRENT_MAX from zstd_compress_internal.h ','line_number':4170,'multiline':True]
['text':' Provision enough space in a static context so that we can do all
         * this without ever reallocating, which would reset the indices. ','line_number':4172,'multiline':True]
['text':' bump the indices so the following compressions happen at high
         * indices. ','line_number':4178,'multiline':True]
['text':' spew a bunch of stuff into the table area ','line_number':4194,'multiline':True]
['text':' now crank the indices so we overflow ','line_number':4205,'multiline':True]
['text':' do a bunch of compressions again in low indices and ensure we don't
         * hit untracked invalid indices ','line_number':4220,'multiline':True]
['text':' Enable checksum to verify round trip. ','line_number':4243,'multiline':True]
['text':' Round trip once with ldm. ','line_number':4248,'multiline':True]
['text':' Round trip once without ldm. ','line_number':4258,'multiline':True]
['text':' allocation ','line_number':4415,'multiline':True]
['text':' Create initial samples ','line_number':4425,'multiline':True]
['text':' pure noise ','line_number':4426,'multiline':True]
['text':' barely compressible ','line_number':4427,'multiline':True]
['text':' highly compressible ','line_number':4429,'multiline':True]
['text':' sparse content ','line_number':4430,'multiline':True]
['text':' catch up testNb ','line_number':4432,'multiline':True]
['text':' main test loop ','line_number':4435,'multiline':True]
['text':' jumping pointer ','line_number':4437,'multiline':True]
['text':' notification ','line_number':4446,'multiline':True]
['text':' srcBuffer selection [0-4] ','line_number':4453,'multiline':True]
['text':' most common : compressible (P) ','line_number':4455,'multiline':True]
['text':' barely/highly compressible ','line_number':4459,'multiline':True]
['text':' not compressible / sparse ','line_number':4462,'multiline':True]
['text':' select src segment ','line_number':4468,'multiline':True]
['text':' create sample buffer (to catch read error with valgrind & sanitizers)  ','line_number':4471,'multiline':True]
['text':' compression tests ','line_number':4478,'multiline':True]
['text':' test negative cLevel ','line_number':4484,'multiline':True]
['text':' compression failure test : too small dest buffer ','line_number':4490,'multiline':True]
['text':' frame header decompression test ','line_number':4504,'multiline':True]
['text':' Decompressed size test ','line_number':4510,'multiline':True]
['text':' successful decompression test ','line_number':4515,'multiline':True]
['text':' no longer useful after this point ','line_number':4524,'multiline':True]
['text':' truncated src decompression test ','line_number':4526,'multiline':True]
['text':' no problem, as cSize > 4 (frameHeaderSizer) ','line_number':4528,'multiline':True]
['text':' valgrind will catch read overflows ','line_number':4530,'multiline':True]
['text':' too small dst decompression test ','line_number':4538,'multiline':True]
['text':' no problem, as cSize > 4 (frameHeaderSizer) ','line_number':4541,'multiline':True]
['text':' noisy src decompression test ','line_number':4550,'multiline':True]
['text':' insert noise into src ','line_number':4552,'multiline':True]
['text':' preserve magic number (too easy to detect) ','line_number':4554,'multiline':True]
['text':' keep some original src ','line_number':4556,'multiline':True]
['text':' add noise ','line_number':4563,'multiline':True]
['text':' decompress noisy source ','line_number':4574,'multiline':True]
['text':' result *may* be an unlikely success, but even then, it must strictly respect dst buffer boundaries ','line_number':4579,'multiline':True]
['text':' noisy src decompression test ','line_number':4585,'multiline':True]
['text':'=====   Bufferless streaming compression test, scattered segments and dictionary   =====','line_number':4587,'multiline':True]
['text':' needed also for decompression ','line_number':4598,'multiline':True]
['text':' contentSizeFlag ','line_number':4608,'multiline':True]
['text':' contentChecksumFlag','line_number':4609,'multiline':True]
['text':'NodictID','line_number':4610,'multiline':True]
['text':' note : since dictionary is fake, dictIDflag has no impact ','line_number':4610,'multiline':True]
['text':' avoid invalid dstBufferTooSmall ','line_number':4625,'multiline':True]
['text':' streaming decompression test ','line_number':4644,'multiline':True]
['text':' ensure memory requirement is good enough (should always be true) ','line_number':4646,'multiline':True]
['text':' disable dictionary ','line_number':4656,'multiline':True]
['text':' for ( ; (testNb <= nbTests) ','line_number':4674,'multiline':True]
['text':'_*******************************************************
*  Command line
********************************************************','line_number':4697,'multiline':True]
['text':'! readU32FromChar() :
    @return : unsigned integer value read from input in `char` format
    allows and interprets K, KB, KiB, M, MB and MiB suffix.
    Will also modify `*stringPtr`, advancing it to position where it stopped reading.
    Note : function result can overflow if digit string > MAX_UINT ','line_number':4717,'multiline':True]
['text':'* longCommandWArg() :
 *  check if *stringPtr is the same as longCommand.
 *  If yes, @return 1 and advances *stringPtr to the position which immediately follows longCommand.
 *  @return 0 and doesn't modify *stringPtr otherwise.
 ','line_number':4737,'multiline':True]
['text':' Check command line ','line_number':4767,'multiline':True]
['text':' Protection if argument empty ','line_number':4770,'multiline':True]
['text':' Handle commands. Aggregated commands are allowed ','line_number':4772,'multiline':True]
['text':' pause at the end ','line_number':4799,'multiline':True]
['text':' seconds ','line_number':4813,'multiline':True]
['text':' minutes ','line_number':4814,'multiline':True]
['text':' compressibility % ','line_number':4829,'multiline':True]
['text':' for (argNb=1; argNb<argc; argNb++) ','line_number':4837,'multiline':True]
['text':' Get Seed ','line_number':4839,'multiline':True]
['text':' constant seed for predictability ','line_number':4861,'multiline':True]
