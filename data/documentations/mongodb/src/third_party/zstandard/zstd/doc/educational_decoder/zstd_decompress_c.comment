['text':'
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under both the BSD-style license (found in the
 * LICENSE file in the root directory of this source tree) and the GPLv2 (found
 * in the COPYING file in the root directory of this source tree).
 * You may select, at your option, one of the above-listed licenses.
 ','line_number':1,'multiline':True]
['text':'/ Zstandard educational decoder implementation','line_number':11,'multiline':False]
['text':'/ See https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md','line_number':12,'multiline':False]
['text':' uint8_t, etc.','line_number':14,'multiline':False]
['text':' malloc, free, exit','line_number':15,'multiline':False]
['text':' fprintf','line_number':16,'multiline':False]
['text':' memset, memcpy','line_number':17,'multiline':False]
['text':'****** IMPORTANT CONSTANTS ********************************************','line_number':21,'multiline':True]
['text':' Zstandard frame','line_number':23,'multiline':False]
['text':' "Magic_Number','line_number':24,'multiline':False]
['text':' 4 Bytes, little-endian format. Value : 0xFD2FB528"','line_number':25,'multiline':False]
['text':' The size of `Block_Content` is limited by `Block_Maximum_Size`,','line_number':28,'multiline':False]
['text':' literal blocks can't be larger than their block','line_number':31,'multiline':False]
['text':'****** UTILITY MACROS AND TYPES ********************************************','line_number':35,'multiline':True]
['text':'/ This decoder calls exit(1) when it encounters an error, however a production','line_number':45,'multiline':False]
['text':'/ library should propagate error codes','line_number':46,'multiline':False]
['text':'****** END UTILITY MACROS AND TYPES ****************************************','line_number':69,'multiline':True]
['text':'****** IMPLEMENTATION PRIMITIVE PROTOTYPES *********************************','line_number':71,'multiline':True]
['text':'/ The implementations for these functions can be found at the bottom of this','line_number':72,'multiline':False]
['text':'/ file.  They implement low-level functionality needed for the higher level','line_number':73,'multiline':False]
['text':'/ decompression functions.','line_number':74,'multiline':False]
['text':'** IO STREAM OPERATIONS ************','line_number':76,'multiline':True]
['text':'/ ostream_t/istream_t are used to wrap the pointers/length data passed into','line_number':78,'multiline':False]
['text':'/ ZSTD_decompress, so that all IO operations are safely bounds checked','line_number':79,'multiline':False]
['text':'/ They are written/read forward, and reads are treated as little-endian','line_number':80,'multiline':False]
['text':'/ They should be used opaquely to ensure safety','line_number':81,'multiline':False]
['text':' Input often reads a few bits at a time, so maintain an internal offset','line_number':91,'multiline':False]
['text':'/ The following two functions are the only ones that allow the istream to be','line_number':95,'multiline':False]
['text':'/ non-byte aligned','line_number':96,'multiline':False]
['text':'/ Reads `num` bits from a bitstream, and updates the internal offset','line_number':98,'multiline':False]
['text':'/ Backs-up the stream by `num` bits so they can be read again','line_number':100,'multiline':False]
['text':'/ If the remaining bits in a byte will be unused, advance to the end of the','line_number':102,'multiline':False]
['text':'/ byte','line_number':103,'multiline':False]
['text':'/ Write the given byte into the output stream','line_number':106,'multiline':False]
['text':'/ Returns the number of bytes left to be read in this stream.  The stream must','line_number':109,'multiline':False]
['text':'/ be byte aligned.','line_number':110,'multiline':False]
['text':'/ Advances the stream by `len` bytes, and returns a pointer to the chunk that','line_number':113,'multiline':False]
['text':'/ was skipped.  The stream must be byte aligned.','line_number':114,'multiline':False]
['text':'/ Advances the stream by `len` bytes, and returns a pointer to the chunk that','line_number':116,'multiline':False]
['text':'/ was skipped so it can be written to.','line_number':117,'multiline':False]
['text':'/ Advance the inner state by `len` bytes.  The stream must be byte aligned.','line_number':120,'multiline':False]
['text':'/ Returns an `ostream_t` constructed from the given pointer and length.','line_number':123,'multiline':False]
['text':'/ Returns an `istream_t` constructed from the given pointer and length.','line_number':125,'multiline':False]
['text':'/ Returns an `istream_t` with the same base as `in`, and length `len`.','line_number':128,'multiline':False]
['text':'/ Then, advance `in` to account for the consumed bytes.','line_number':129,'multiline':False]
['text':'/ `in` must be byte aligned.','line_number':130,'multiline':False]
['text':'** END IO STREAM OPERATIONS ********','line_number':132,'multiline':True]
['text':'** BITSTREAM OPERATIONS ************','line_number':134,'multiline':True]
['text':'/ Read `num` bits (up to 64) from `src + offset`, where `offset` is in bits,','line_number':135,'multiline':False]
['text':'/ and return them interpreted as a little-endian unsigned integer.','line_number':136,'multiline':False]
['text':'/ Read bits from the end of a HUF or FSE bitstream.  `offset` is in bits, so','line_number':140,'multiline':False]
['text':'/ it updates `offset` to `offset - bits`, and then reads `bits` bits from','line_number':141,'multiline':False]
['text':'/ `src + offset`.  If the offset becomes negative, the extra bits at the','line_number':142,'multiline':False]
['text':'/ bottom are filled in with `0` bits instead of reading from before `src`.','line_number':143,'multiline':False]
['text':'** END BITSTREAM OPERATIONS ********','line_number':146,'multiline':True]
['text':'** BIT COUNTING OPERATIONS *********','line_number':148,'multiline':True]
['text':'/ Returns the index of the highest set bit in `num`, or `-1` if `num == 0`','line_number':149,'multiline':False]
['text':'** END BIT COUNTING OPERATIONS *****','line_number':151,'multiline':True]
['text':'** HUFFMAN PRIMITIVES **************','line_number':153,'multiline':True]
['text':' Table decode method uses exponential memory, so we need to limit depth','line_number':154,'multiline':False]
['text':' Limit the maximum number of symbols to 256 so we can store a symbol in a byte','line_number':157,'multiline':False]
['text':'/ Structure containing all tables necessary for efficient Huffman decoding','line_number':160,'multiline':False]
['text':'/ Decode a single symbol and read in enough bits to refresh the state','line_number':167,'multiline':False]
['text':'/ Read in a full state's worth of bits to initialize it','line_number':171,'multiline':False]
['text':'/ Decompresses a single Huffman stream, returns the number of bytes decoded.','line_number':176,'multiline':False]
['text':'/ `src_len` must be the exact length of the Huffman-coded block.','line_number':177,'multiline':False]
['text':'/ Same as previous but decodes 4 streams, formatted as in the Zstandard','line_number':180,'multiline':False]
['text':'/ specification.','line_number':181,'multiline':False]
['text':'/ `src_len` must be the exact length of the Huffman-coded block.','line_number':182,'multiline':False]
['text':'/ Initialize a Huffman decoding table using the table of bit counts provided','line_number':186,'multiline':False]
['text':'/ Initialize a Huffman decoding table using the table of weights provided','line_number':189,'multiline':False]
['text':'/ Weights follow the definition provided in the Zstandard specification','line_number':190,'multiline':False]
['text':'/ Free the malloc'ed parts of a decoding table','line_number':195,'multiline':False]
['text':'** END HUFFMAN PRIMITIVES **********','line_number':197,'multiline':True]
['text':'** FSE PRIMITIVES ******************','line_number':199,'multiline':True]
['text':'/ For more description of FSE see','line_number':200,'multiline':False]
['text':'/ https://github.com/Cyan4973/FiniteStateEntropy/','line_number':201,'multiline':False]
['text':' FSE table decoding uses exponential memory, so limit the maximum accuracy','line_number':203,'multiline':False]
['text':' Limit the maximum number of symbols so they can be stored in a single byte','line_number':205,'multiline':False]
['text':'/ The tables needed to decode FSE encoded streams','line_number':208,'multiline':False]
['text':'/ Return the symbol for the current state','line_number':216,'multiline':False]
['text':'/ Read the number of bits necessary to update state, update, and shift offset','line_number':219,'multiline':False]
['text':'/ back to reflect the bits read','line_number':220,'multiline':False]
['text':'/ Combine peek and update: decode a symbol and update the state','line_number':225,'multiline':False]
['text':'/ Read bits from the stream to initialize the state and shift offset back','line_number':230,'multiline':False]
['text':'/ Decompress two interleaved bitstreams (e.g. compressed Huffman weights)','line_number':235,'multiline':False]
['text':'/ using an FSE decoding table.  `src_len` must be the exact length of the','line_number':236,'multiline':False]
['text':'/ block.','line_number':237,'multiline':False]
['text':'/ Initialize a decoding table using normalized frequencies.','line_number':242,'multiline':False]
['text':'/ Decode an FSE header as defined in the Zstandard format specification and','line_number':247,'multiline':False]
['text':'/ use the decoded frequencies to initialize a decoding table.','line_number':248,'multiline':False]
['text':'/ Initialize an FSE table that will always return the same symbol and consume','line_number':252,'multiline':False]
['text':'/ 0 bits per symbol, to be used for RLE mode in sequence commands','line_number':253,'multiline':False]
['text':'/ Free the malloc'ed parts of a decoding table','line_number':256,'multiline':False]
['text':'** END FSE PRIMITIVES **************','line_number':258,'multiline':True]
['text':'****** END IMPLEMENTATION PRIMITIVE PROTOTYPES *****************************','line_number':260,'multiline':True]
['text':'****** ZSTD HELPER STRUCTS AND PROTOTYPES **********************************','line_number':262,'multiline':True]
['text':'/ A small structure that can be reused in various places that need to access','line_number':264,'multiline':False]
['text':'/ frame header information','line_number':265,'multiline':False]
['text':' The size of window that we need to be able to contiguously store for','line_number':267,'multiline':False]
['text':' references','line_number':268,'multiline':False]
['text':' The total output size of this compressed frame','line_number':270,'multiline':False]
['text':' The dictionary id if this frame uses one','line_number':273,'multiline':False]
['text':' Whether or not the content of this frame has a checksum','line_number':276,'multiline':False]
['text':' Whether or not the output for this frame is in a single segment','line_number':278,'multiline':False]
['text':'/ The context needed to decode blocks in a frame','line_number':282,'multiline':False]
['text':' The total amount of data available for backreferences, to determine if an','line_number':286,'multiline':False]
['text':' offset too large to be correct','line_number':287,'multiline':False]
['text':' Entropy encoding tables so they can be repeated by future blocks instead','line_number':293,'multiline':False]
['text':' of retransmitting','line_number':294,'multiline':False]
['text':' The last 3 offsets for the special "repeat offsets".','line_number':300,'multiline':False]
['text':'/ The decoded contents of a dictionary so that it doesn't have to be repeated','line_number':304,'multiline':False]
['text':'/ for each frame that uses it','line_number':305,'multiline':False]
['text':' Entropy tables','line_number':307,'multiline':False]
['text':' Raw content for backreferences','line_number':313,'multiline':False]
['text':' Offset history to prepopulate the frame's history','line_number':317,'multiline':False]
['text':'/ A tuple containing the parts necessary to decode and execute a ZSTD sequence','line_number':323,'multiline':False]
['text':'/ command','line_number':324,'multiline':False]
['text':'/ The decoder works top-down, starting at the high level like Zstd frames, and','line_number':331,'multiline':False]
['text':'/ working down to lower more technical levels such as blocks, literals, and','line_number':332,'multiline':False]
['text':'/ sequences.  The high-level functions roughly follow the outline of the','line_number':333,'multiline':False]
['text':'/ format specification:','line_number':334,'multiline':False]
['text':'/ https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md','line_number':335,'multiline':False]
['text':'/ Before the implementation of each high-level function declared here, the','line_number':337,'multiline':False]
['text':'/ prototypes for their helper functions are defined and explained','line_number':338,'multiline':False]
['text':'/ Decode a single Zstd frame, or error if the input is not a valid frame.','line_number':340,'multiline':False]
['text':'/ Accepts a dict argument, which may be NULL indicating no dictionary.','line_number':341,'multiline':False]
['text':'/ See','line_number':342,'multiline':False]
['text':'/ https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md#frame-concatenation','line_number':343,'multiline':False]
['text':' Decode data in a compressed block','line_number':347,'multiline':False]
['text':' Decode the literals section of a block','line_number':351,'multiline':False]
['text':' Decode the sequences part of a block','line_number':355,'multiline':False]
['text':' Execute the decoded sequences on the literals block','line_number':359,'multiline':False]
['text':' Copies literals and returns the total literal length that was copied','line_number':366,'multiline':False]
['text':' Given an offset code from a sequence command (either an actual offset value','line_number':370,'multiline':False]
['text':' or an index for previous offset), computes the correct offset and updates','line_number':371,'multiline':False]
['text':' the offset history','line_number':372,'multiline':False]
['text':' Given an offset, match length, and total output, as well as the frame','line_number':375,'multiline':False]
['text':' context for the dictionary, determines if the dictionary is used and','line_number':376,'multiline':False]
['text':' executes the copy operation','line_number':377,'multiline':False]
['text':'****** END ZSTD HELPER STRUCTS AND PROTOTYPES ******************************','line_number':382,'multiline':True]
['text':' "A content compressed by Zstandard is transformed into a Zstandard frame.','line_number':400,'multiline':False]
['text':' Multiple frames can be appended into a single file or stream. A frame is','line_number':401,'multiline':False]
['text':' totally independent, has a defined beginning and end, and a set of','line_number':402,'multiline':False]
['text':' parameters which tells the decoder how to decompress it."','line_number':403,'multiline':False]
['text':' this decoder assumes decompression of a single frame ','line_number':405,'multiline':True]
['text':'****** FRAME DECODING *****************************************************','line_number':411,'multiline':True]
['text':' ZSTD frame','line_number':431,'multiline':False]
['text':' not a real frame or a skippable frame','line_number':437,'multiline':False]
['text':'/ Decode a frame that contains compressed data.  Not all frames do as there','line_number':441,'multiline':False]
['text':'/ are skippable frames.','line_number':442,'multiline':False]
['text':'/ See','line_number':443,'multiline':False]
['text':'/ https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md#general-structure-of-zstandard-frame-format','line_number':444,'multiline':False]
['text':' Initialize the context that needs to be carried from block to block','line_number':449,'multiline':False]
['text':'/ Takes the information provided in the header and dictionary, and initializes','line_number':462,'multiline':False]
['text':'/ the context for this frame','line_number':463,'multiline':False]
['text':' Most fields in context are correct when initialized to 0','line_number':467,'multiline':False]
['text':' Parse data from the frame header','line_number':470,'multiline':False]
['text':' Set up the offset history for the repeat offset commands','line_number':473,'multiline':False]
['text':' Apply details from the dict if it exists','line_number':478,'multiline':False]
['text':' "The first header's byte is called the Frame_Header_Descriptor. It tells','line_number':494,'multiline':False]
['text':' which other fields are present. Decoding this byte is enough to tell the','line_number':495,'multiline':False]
['text':' size of Frame_Header.','line_number':496,'multiline':False]
['text':'','line_number':497,'multiline':False]
['text':' Bit number   Field name','line_number':498,'multiline':False]
['text':' 7-6  Frame_Content_Size_flag','line_number':499,'multiline':False]
['text':' 5    Single_Segment_flag','line_number':500,'multiline':False]
['text':' 4    Unused_bit','line_number':501,'multiline':False]
['text':' 3    Reserved_bit','line_number':502,'multiline':False]
['text':' 2    Content_Checksum_flag','line_number':503,'multiline':False]
['text':' 1-0  Dictionary_ID_flag"','line_number':504,'multiline':False]
['text':' decode frame header descriptor into flags','line_number':507,'multiline':False]
['text':' decode window size','line_number':521,'multiline':False]
['text':' "Provides guarantees on maximum back-reference distance that will be','line_number':523,'multiline':False]
['text':' used within compressed data. This information is important for','line_number':524,'multiline':False]
['text':' decoders to allocate enough memory.','line_number':525,'multiline':False]
['text':'','line_number':526,'multiline':False]
['text':' Bit numbers  7-3         2-0','line_number':527,'multiline':False]
['text':' Field name   Exponent    Mantissa"','line_number':528,'multiline':False]
['text':' Use the algorithm from the specification to compute window size','line_number':533,'multiline':False]
['text':' https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md#window_descriptor','line_number':534,'multiline':False]
['text':' decode dictionary id if it exists','line_number':540,'multiline':False]
['text':' "This is a variable size field, which contains the ID of the','line_number':542,'multiline':False]
['text':' dictionary required to properly decode the frame. Note that this','line_number':543,'multiline':False]
['text':' field is optional. When it's not present, it's up to the caller to','line_number':544,'multiline':False]
['text':' make sure it uses the correct dictionary. Format is little-endian."','line_number':545,'multiline':False]
['text':' decode frame content size if it exists','line_number':554,'multiline':False]
['text':' "This is the original (uncompressed) size. This information is','line_number':556,'multiline':False]
['text':' optional. The Field_Size is provided according to value of','line_number':557,'multiline':False]
['text':' Frame_Content_Size_flag. The Field_Size can be equal to 0 (not','line_number':558,'multiline':False]
['text':' present), 1, 2, 4 or 8 bytes. Format is little-endian."','line_number':559,'multiline':False]
['text':'','line_number':560,'multiline':False]
['text':' if frame_content_size_flag == 0 but single_segment_flag is set, we','line_number':561,'multiline':False]
['text':' still have a 1 byte field','line_number':562,'multiline':False]
['text':' "When Field_Size is 2, the offset of 256 is added."','line_number':568,'multiline':False]
['text':' "The Window_Descriptor byte is optional. It is absent when','line_number':576,'multiline':False]
['text':' Single_Segment_flag is set. In this case, the maximum back-reference','line_number':577,'multiline':False]
['text':' distance is the content size itself, which can be any value from 1 to','line_number':578,'multiline':False]
['text':' 2^64-1 bytes (16 EB)."','line_number':579,'multiline':False]
['text':'/ Decompress the data from a frame block by block','line_number':584,'multiline':False]
['text':' "A frame encapsulates one or multiple blocks. Each block can be','line_number':587,'multiline':False]
['text':' compressed or not, and has a guaranteed maximum content size, which','line_number':588,'multiline':False]
['text':' depends on frame parameters. Unlike frames, each block depends on','line_number':589,'multiline':False]
['text':' previous blocks for proper decoding. However, each block can be','line_number':590,'multiline':False]
['text':' decompressed without waiting for its successor, allowing streaming','line_number':591,'multiline':False]
['text':' operations."','line_number':592,'multiline':False]
['text':' "Last_Block','line_number':595,'multiline':False]
['text':'','line_number':596,'multiline':False]
['text':' The lowest bit signals if this block is the last one. Frame ends','line_number':597,'multiline':False]
['text':' right after this block.','line_number':598,'multiline':False]
['text':'','line_number':599,'multiline':False]
['text':' Block_Type and Block_Size','line_number':600,'multiline':False]
['text':'','line_number':601,'multiline':False]
['text':' The next 2 bits represent the Block_Type, while the remaining 21 bits','line_number':602,'multiline':False]
['text':' represent the Block_Size. Format is little-endian."','line_number':603,'multiline':False]
['text':' "Raw_Block - this is an uncompressed block. Block_Size is the','line_number':610,'multiline':False]
['text':' number of bytes to read and copy."','line_number':611,'multiline':False]
['text':' Copy the raw data into the output','line_number':615,'multiline':False]
['text':' "RLE_Block - this is a single byte, repeated N times. In which','line_number':622,'multiline':False]
['text':' case, Block_Size is the size to regenerate, while the','line_number':623,'multiline':False]
['text':' "compressed" block is just 1 byte (the byte to repeat)."','line_number':624,'multiline':False]
['text':' Copy `block_len` copies of `read_ptr[0]` to the output','line_number':628,'multiline':False]
['text':' "Compressed_Block - this is a Zstandard compressed block,','line_number':635,'multiline':False]
['text':' detailed in another section of this specification. Block_Size is','line_number':636,'multiline':False]
['text':' the compressed size.','line_number':637,'multiline':False]
['text':' Create a sub-stream for the block','line_number':639,'multiline':False]
['text':' "Reserved - this is not a block. This value cannot be used with','line_number':645,'multiline':False]
['text':' current version of this specification."','line_number':646,'multiline':False]
['text':' This program does not support checking the checksum, so skip over it','line_number':655,'multiline':False]
['text':' if it's present','line_number':656,'multiline':False]
['text':'****** END FRAME DECODING **************************************************','line_number':660,'multiline':True]
['text':'****** BLOCK DECOMPRESSION *************************************************','line_number':662,'multiline':True]
['text':' "A compressed block consists of 2 sections :','line_number':665,'multiline':False]
['text':'','line_number':666,'multiline':False]
['text':' Literals_Section','line_number':667,'multiline':False]
['text':' Sequences_Section"','line_number':668,'multiline':False]
['text':' Part 1: decode the literals block','line_number':671,'multiline':False]
['text':' Part 2: decode the sequences block','line_number':675,'multiline':False]
['text':' Part 3: combine literals and sequence commands to generate output','line_number':680,'multiline':False]
['text':'****** END BLOCK DECOMPRESSION *********************************************','line_number':686,'multiline':True]
['text':'****** LITERALS DECODING ***************************************************','line_number':688,'multiline':True]
['text':' "Literals can be stored uncompressed or compressed using Huffman prefix','line_number':703,'multiline':False]
['text':' codes. When compressed, an optional tree description can be present,','line_number':704,'multiline':False]
['text':' followed by 1 or 4 streams."','line_number':705,'multiline':False]
['text':'','line_number':706,'multiline':False]
['text':' "Literals_Section_Header','line_number':707,'multiline':False]
['text':'','line_number':708,'multiline':False]
['text':' Header is in charge of describing how literals are packed. It's a','line_number':709,'multiline':False]
['text':' byte-aligned variable-size bitfield, ranging from 1 to 5 bytes, using','line_number':710,'multiline':False]
['text':' little-endian convention."','line_number':711,'multiline':False]
['text':'','line_number':712,'multiline':False]
['text':' "Literals_Block_Type','line_number':713,'multiline':False]
['text':'','line_number':714,'multiline':False]
['text':' This field uses 2 lowest bits of first byte, describing 4 different block','line_number':715,'multiline':False]
['text':' types"','line_number':716,'multiline':False]
['text':'','line_number':717,'multiline':False]
['text':' size_format takes between 1 and 2 bits','line_number':718,'multiline':False]
['text':' Raw or RLE literals block','line_number':723,'multiline':False]
['text':' Huffman compressed literals','line_number':727,'multiline':False]
['text':'/ Decodes literals blocks in raw or RLE form','line_number':733,'multiline':False]
['text':' These cases are in the form ?0','line_number':739,'multiline':False]
['text':' In this case, the ? bit is actually part of the size field','line_number':740,'multiline':False]
['text':' "Size_Format uses 1 bit. Regenerated_Size uses 5 bits (0-31)."','line_number':743,'multiline':False]
['text':' "Size_Format uses 2 bits. Regenerated_Size uses 12 bits (0-4095)."','line_number':748,'multiline':False]
['text':' "Size_Format uses 2 bits. Regenerated_Size uses 20 bits (0-1048575)."','line_number':752,'multiline':False]
['text':' Size format is in range 0-3','line_number':756,'multiline':False]
['text':' "Raw_Literals_Block - Literals are stored uncompressed."','line_number':771,'multiline':False]
['text':' "RLE_Literals_Block - Literals consist of a single byte value repeated N times."','line_number':777,'multiline':False]
['text':'/ Decodes Huffman compressed literals','line_number':789,'multiline':False]
['text':' Only size_format=0 has 1 stream, so default to 4','line_number':796,'multiline':False]
['text':' "A single stream. Both Compressed_Size and Regenerated_Size use 10','line_number':800,'multiline':False]
['text':' bits (0-1023)."','line_number':801,'multiline':False]
['text':' Fall through as it has the same size format','line_number':803,'multiline':False]
['text':' fallthrough ','line_number':804,'multiline':True]
['text':' "4 streams. Both Compressed_Size and Regenerated_Size use 10 bits','line_number':806,'multiline':False]
['text':' (0-1023)."','line_number':807,'multiline':False]
['text':' "4 streams. Both Compressed_Size and Regenerated_Size use 14 bits','line_number':812,'multiline':False]
['text':' (0-16383)."','line_number':813,'multiline':False]
['text':' "4 streams. Both Compressed_Size and Regenerated_Size use 18 bits','line_number':818,'multiline':False]
['text':' (0-262143)."','line_number':819,'multiline':False]
['text':' Impossible','line_number':824,'multiline':False]
['text':' Decode the provided Huffman table','line_number':840,'multiline':False]
['text':' "This section is only present when Literals_Block_Type type is','line_number':841,'multiline':False]
['text':' Compressed_Literals_Block (2)."','line_number':842,'multiline':False]
['text':' If the previous Huffman table is being repeated, ensure it exists','line_number':847,'multiline':False]
['text':' Decode the Huffman table description','line_number':867,'multiline':False]
['text':' "All literal values from zero (included) to last present one (excluded)','line_number':869,'multiline':False]
['text':' are represented by Weight with values from 0 to Max_Number_of_Bits."','line_number':870,'multiline':False]
['text':' "This is a single byte value (0-255), which describes how to decode the list of weights."','line_number':872,'multiline':False]
['text':' "This is a direct representation, where each Weight is written','line_number':881,'multiline':False]
['text':' directly as a 4 bits field (0-15). The full representation occupies','line_number':882,'multiline':False]
['text':' ((Number_of_Symbols+1)/2) bytes, meaning it uses a last full byte','line_number':883,'multiline':False]
['text':' even if Number_of_Symbols is odd. Number_of_Symbols = headerByte -','line_number':884,'multiline':False]
['text':' 127"','line_number':885,'multiline':False]
['text':' "They are encoded forward, 2','line_number':892,'multiline':False]
['text':' weights to a byte with the first weight taking the top four bits','line_number':893,'multiline':False]
['text':' and the second taking the bottom four (e.g. the following','line_number':894,'multiline':False]
['text':' operations could be used to read the weights: Weight[0] =','line_number':895,'multiline':False]
['text':' (Byte[0] >> 4), Weight[1] = (Byte[0] & 0xf), etc.)."','line_number':896,'multiline':False]
['text':' The weights are FSE encoded, decode them before we can construct the','line_number':904,'multiline':False]
['text':' table','line_number':905,'multiline':False]
['text':' Construct the table using the decoded weights','line_number':911,'multiline':False]
['text':' "An FSE bitstream starts by a header, describing probabilities','line_number':921,'multiline':False]
['text':' distribution. It will create a Decoding Table. For a list of Huffman','line_number':922,'multiline':False]
['text':' weights, maximum accuracy is 7 bits."','line_number':923,'multiline':False]
['text':' Decode the weights','line_number':926,'multiline':False]
['text':'****** END LITERALS DECODING ***********************************************','line_number':931,'multiline':True]
['text':'****** SEQUENCE DECODING ***************************************************','line_number':933,'multiline':True]
['text':'/ The combination of FSE states needed to decode sequences','line_number':934,'multiline':False]
['text':'/ Different modes to signal to decode_seq_tables what to do','line_number':945,'multiline':False]
['text':'/ The predefined FSE distribution tables for `seq_predefined` mode','line_number':959,'multiline':False]
['text':'/ The sequence decoding baseline and number of additional bits to read/add','line_number':971,'multiline':False]
['text':'/ https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md#the-codes-for-literals-lengths-match-lengths-and-offsets','line_number':972,'multiline':False]
['text':'/ Offset decoding is simpler so we just need a maximum code value','line_number':991,'multiline':False]
['text':' "A compressed block is a succession of sequences . A sequence is a','line_number':1006,'multiline':False]
['text':' literal copy command, followed by a match copy command. A literal copy','line_number':1007,'multiline':False]
['text':' command specifies a length. It is the number of bytes to be copied (or','line_number':1008,'multiline':False]
['text':' extracted) from the literal section. A match copy command specifies an','line_number':1009,'multiline':False]
['text':' offset and a length. The offset gives the position to copy from, which','line_number':1010,'multiline':False]
['text':' can be within a previous block."','line_number':1011,'multiline':False]
['text':' "Number_of_Sequences','line_number':1015,'multiline':False]
['text':'','line_number':1016,'multiline':False]
['text':' This is a variable size field using between 1 and 3 bytes. Let's call its','line_number':1017,'multiline':False]
['text':' first byte byte0."','line_number':1018,'multiline':False]
['text':' "There are no sequences. The sequence section stops there.','line_number':1021,'multiline':False]
['text':' Regenerated content is defined entirely by literals section."','line_number':1022,'multiline':False]
['text':' "Number_of_Sequences = byte0 . Uses 1 byte."','line_number':1026,'multiline':False]
['text':' "Number_of_Sequences = ((byte0-128) << 8) + byte1 . Uses 2 bytes."','line_number':1029,'multiline':False]
['text':' "Number_of_Sequences = byte1 + (byte2<<8) + 0x7F00 . Uses 3 bytes."','line_number':1032,'multiline':False]
['text':'/ Decompress the FSE encoded sequence commands','line_number':1045,'multiline':False]
['text':' "The Sequences_Section regroup all symbols required to decode commands.','line_number':1049,'multiline':False]
['text':' There are 3 symbol types : literals lengths, offsets and match lengths.','line_number':1050,'multiline':False]
['text':' They are encoded together, interleaved, in a single bitstream."','line_number':1051,'multiline':False]
['text':' "Symbol compression modes','line_number':1053,'multiline':False]
['text':'','line_number':1054,'multiline':False]
['text':' This is a single byte, defining the compression mode of each symbol','line_number':1055,'multiline':False]
['text':' type."','line_number':1056,'multiline':False]
['text':'','line_number':1057,'multiline':False]
['text':' Bit number : Field name','line_number':1058,'multiline':False]
['text':' 7-6        : Literals_Lengths_Mode','line_number':1059,'multiline':False]
['text':' 5-4        : Offsets_Mode','line_number':1060,'multiline':False]
['text':' 3-2        : Match_Lengths_Mode','line_number':1061,'multiline':False]
['text':' 1-0        : Reserved','line_number':1062,'multiline':False]
['text':' Reserved bits set','line_number':1066,'multiline':False]
['text':' "Following the header, up to 3 distribution tables can be described. When','line_number':1070,'multiline':False]
['text':' present, they are in this order :','line_number':1071,'multiline':False]
['text':'','line_number':1072,'multiline':False]
['text':' Literals lengths','line_number':1073,'multiline':False]
['text':' Offsets','line_number':1074,'multiline':False]
['text':' Match Lengths"','line_number':1075,'multiline':False]
['text':' Update the tables we have stored in the context','line_number':1076,'multiline':False]
['text':' Initialize the decoding tables','line_number':1089,'multiline':False]
['text':' "After writing the last bit containing information, the compressor writes','line_number':1099,'multiline':False]
['text':' a single 1-bit and then fills the byte with 0-7 0 bits of padding."','line_number':1100,'multiline':False]
['text':' The offset starts at the end because FSE streams are read backwards','line_number':1102,'multiline':False]
['text':' "The bitstream starts with initial state values, each using the required','line_number':1105,'multiline':False]
['text':' number of bits in their respective accuracy, decoded previously from','line_number':1106,'multiline':False]
['text':' their normalized distribution.','line_number':1107,'multiline':False]
['text':'','line_number':1108,'multiline':False]
['text':' It starts by Literals_Length_State, followed by Offset_State, and finally','line_number':1109,'multiline':False]
['text':' Match_Length_State."','line_number':1110,'multiline':False]
['text':' Decode sequences one by one','line_number':1116,'multiline':False]
['text':' Decode a single sequence and update the state','line_number':1125,'multiline':False]
['text':' "Each symbol is a code in its own context, which specifies Baseline and','line_number':1129,'multiline':False]
['text':' Number_of_Bits to add. Codes are FSE compressed, and interleaved with raw','line_number':1130,'multiline':False]
['text':' additional bits in the same bitstream."','line_number':1131,'multiline':False]
['text':' Decode symbols, but don't update states','line_number':1133,'multiline':False]
['text':' Offset doesn't need a max value as it's not decoded using a table','line_number':1138,'multiline':False]
['text':' Read the interleaved bits','line_number':1144,'multiline':False]
['text':' "Decoding starts by reading the Number_of_Bits required to decode Offset.','line_number':1146,'multiline':False]
['text':' It then does the same for Match_Length, and then for Literals_Length."','line_number':1147,'multiline':False]
['text':' "If it is not the last sequence in the block, the next operation is to','line_number':1158,'multiline':False]
['text':' update states. Using the rules pre-calculated in the decoding tables,','line_number':1159,'multiline':False]
['text':' Literals_Length_State is updated, followed by Match_Length_State, and','line_number':1160,'multiline':False]
['text':' then Offset_State."','line_number':1161,'multiline':False]
['text':' If the stream is complete don't read bits to update state','line_number':1162,'multiline':False]
['text':'/ Given a sequence part and table mode, decode the FSE distribution','line_number':1172,'multiline':False]
['text':'/ Errors if the mode is `seq_repeat` without a pre-existing table in `table`','line_number':1173,'multiline':False]
['text':' Constant arrays indexed by seq_part_t','line_number':1176,'multiline':False]
['text':' Free old one before overwriting','line_number':1186,'multiline':False]
['text':' "Predefined_Mode : uses a predefined distribution table."','line_number':1192,'multiline':False]
['text':' "RLE_Mode : it's a single code, repeated Number_of_Sequences times."','line_number':1201,'multiline':False]
['text':' "FSE_Compressed_Mode : standard FSE compression. A distribution table','line_number':1207,'multiline':False]
['text':' will be present "','line_number':1208,'multiline':False]
['text':' "Repeat_Mode : re-use distribution table from previous compressed','line_number':1213,'multiline':False]
['text':' block."','line_number':1214,'multiline':False]
['text':' Nothing to do here, table will be unchanged','line_number':1215,'multiline':False]
['text':' This mode is invalid if we don't already have a table','line_number':1217,'multiline':False]
['text':' Impossible, as mode is from 0-3','line_number':1222,'multiline':False]
['text':'****** END SEQUENCE DECODING ***********************************************','line_number':1228,'multiline':True]
['text':'****** SEQUENCE EXECUTION **************************************************','line_number':1230,'multiline':True]
['text':' Copy any leftover literals','line_number':1257,'multiline':False]
['text':' If the sequence asks for more literals than are left, the','line_number':1269,'multiline':False]
['text':' sequence must be corrupted','line_number':1270,'multiline':False]
['text':' Copy literals to output','line_number':1278,'multiline':False]
['text':' Offsets are special, we need to handle the repeat offsets','line_number':1286,'multiline':False]
['text':' "The first 3 values define a repeated offset and we will call','line_number':1288,'multiline':False]
['text':' them Repeated_Offset1, Repeated_Offset2, and Repeated_Offset3.','line_number':1289,'multiline':False]
['text':' They are sorted in recency order, with Repeated_Offset1 meaning','line_number':1290,'multiline':False]
['text':' 'most recent one'".','line_number':1291,'multiline':False]
['text':' Use 0 indexing for the array','line_number':1293,'multiline':False]
['text':' "There is an exception though, when current sequence's','line_number':1296,'multiline':False]
['text':' literals length is 0. In this case, repeated offsets are','line_number':1297,'multiline':False]
['text':' shifted by one, so Repeated_Offset1 becomes Repeated_Offset2,','line_number':1298,'multiline':False]
['text':' Repeated_Offset2 becomes Repeated_Offset3, and','line_number':1299,'multiline':False]
['text':' Repeated_Offset3 becomes Repeated_Offset1 - 1_byte."','line_number':1300,'multiline':False]
['text':' If idx == 3 then literal length was 0 and the offset was 3,','line_number':1307,'multiline':False]
['text':' as per the exception listed above','line_number':1308,'multiline':False]
['text':' If idx == 1 we don't need to modify offset_hist[2], since','line_number':1311,'multiline':False]
['text':' we're using the second-most recent code','line_number':1312,'multiline':False]
['text':' When it's not a repeat offset:','line_number':1320,'multiline':False]
['text':' "if (Offset_Value > 3) offset = Offset_Value - 3;"','line_number':1321,'multiline':False]
['text':' Shift back history','line_number':1324,'multiline':False]
['text':' In this case offset might go back into the dictionary','line_number':1337,'multiline':False]
['text':' The offset goes beyond even the dictionary','line_number':1339,'multiline':False]
['text':' "The rest of the dictionary is its content. The content act','line_number':1344,'multiline':False]
['text':' as a "past" in front of data to compress or decompress, so it','line_number':1345,'multiline':False]
['text':' can be referenced in sequence commands."','line_number':1346,'multiline':False]
['text':' We must copy byte by byte because the match length might be larger','line_number':1360,'multiline':False]
['text':' than the offset','line_number':1361,'multiline':False]
['text':' ex: if the output so far was "abc", a command with offset=3 and','line_number':1362,'multiline':False]
['text':' match_length=6 would produce "abcabcabc" as the new output','line_number':1363,'multiline':False]
['text':'****** END SEQUENCE EXECUTION **********************************************','line_number':1369,'multiline':True]
['text':'****** OUTPUT SIZE COUNTING ************************************************','line_number':1371,'multiline':True]
['text':'/ Get the decompressed size of an input stream so memory can be allocated in','line_number':1372,'multiline':False]
['text':'/ advance.','line_number':1373,'multiline':False]
['text':'/ This implementation assumes `src` points to a single ZSTD-compressed frame','line_number':1374,'multiline':False]
['text':' get decompressed size from ZSTD frame header','line_number':1378,'multiline':False]
['text':' ZSTD frame','line_number':1383,'multiline':False]
['text':' Content size not provided, we can't tell','line_number':1388,'multiline':False]
['text':' not a real frame or skippable frame','line_number':1394,'multiline':False]
['text':'****** END OUTPUT SIZE COUNTING ********************************************','line_number':1399,'multiline':True]
['text':'****** DICTIONARY PARSING **************************************************','line_number':1401,'multiline':True]
['text':'/ Free an allocated dictionary','line_number':1410,'multiline':False]
['text':' cannot initialize dictionary with null src ','line_number':1436,'multiline':True]
['text':' raw content dict','line_number':1447,'multiline':False]
['text':' "Entropy_Tables : following the same format as the tables in compressed','line_number':1455,'multiline':False]
['text':' blocks. They are stored in following order : Huffman tables for literals,','line_number':1456,'multiline':False]
['text':' FSE table for offsets, FSE table for match lengths, and FSE table for','line_number':1457,'multiline':False]
['text':' literals lengths. It's finally followed by 3 offset values, populating','line_number':1458,'multiline':False]
['text':' recent offsets (instead of using {1,4,8}), stored in order, 4-bytes','line_number':1459,'multiline':False]
['text':' little-endian each, for a total of 12 bytes. Each recent offset must have','line_number':1460,'multiline':False]
['text':' a value < dictionary size."','line_number':1461,'multiline':False]
['text':' Read in the previous offset history','line_number':1467,'multiline':False]
['text':' Ensure the provided offsets aren't too large','line_number':1472,'multiline':False]
['text':' "Each recent offset must have a value < dictionary size."','line_number':1473,'multiline':False]
['text':' "Content : The rest of the dictionary is its content. The content act as','line_number':1480,'multiline':False]
['text':' a "past" in front of data to compress or decompress, so it can be','line_number':1481,'multiline':False]
['text':' referenced in sequence commands."','line_number':1482,'multiline':False]
['text':' Copy in the content','line_number':1488,'multiline':False]
['text':'/ A dictionary acts as initializing values for the frame context before','line_number':1541,'multiline':False]
['text':'/ decompression, so we implement it by applying it's predetermined','line_number':1542,'multiline':False]
['text':'/ tables and content to the context before beginning decompression','line_number':1543,'multiline':False]
['text':' If the content pointer is NULL then it must be an empty dict','line_number':1546,'multiline':False]
['text':' If the requested dictionary_id is non-zero, the correct dictionary must','line_number':1550,'multiline':False]
['text':' be present','line_number':1551,'multiline':False]
['text':' Copy the dict content to the context for references during sequence','line_number':1557,'multiline':False]
['text':' execution','line_number':1558,'multiline':False]
['text':' If it's a formatted dict copy the precomputed tables in so they can','line_number':1562,'multiline':False]
['text':' be used in the table repeat modes','line_number':1563,'multiline':False]
['text':' Deep copy the entropy tables so they can be freed independently of','line_number':1565,'multiline':False]
['text':' the dictionary struct','line_number':1566,'multiline':False]
['text':' Copy the repeated offsets','line_number':1572,'multiline':False]
['text':' ZDEC_NO_DICTIONARY is defined','line_number':1578,'multiline':False]
['text':'****** END DICTIONARY PARSING **********************************************','line_number':1587,'multiline':True]
['text':'****** IO STREAM OPERATIONS ************************************************','line_number':1589,'multiline':True]
['text':'/ Reads `num` bits from a bitstream, and updates the internal offset','line_number':1591,'multiline':False]
['text':'/ If a non-zero number of bits have been read from the current byte, advance','line_number':1612,'multiline':False]
['text':'/ the offset to the next byte','line_number':1613,'multiline':False]
['text':' move the offset back by `num_bits` bits','line_number':1619,'multiline':False]
['text':' determine the number of whole bytes we have to rewind, rounding up to an','line_number':1621,'multiline':False]
['text':' integer number (e.g. if `new_offset == -5`, `bytes == 1`)','line_number':1622,'multiline':False]
['text':' make sure the resulting `bit_offset` is positive, as mod in C does not','line_number':1627,'multiline':False]
['text':' convert numbers from negative to positive (e.g. -22 % 8 == -6)','line_number':1628,'multiline':False]
['text':'/ If the remaining bits in a byte will be unused, advance to the end of the','line_number':1632,'multiline':False]
['text':'/ byte','line_number':1633,'multiline':False]
['text':'/ Write the given byte into the output stream','line_number':1645,'multiline':False]
['text':'/ Returns the number of bytes left to be read in this stream.  The stream must','line_number':1656,'multiline':False]
['text':'/ be byte aligned.','line_number':1657,'multiline':False]
['text':'/ Returns a pointer where `len` bytes can be read, and advances the internal','line_number':1662,'multiline':False]
['text':'/ state.  The stream must be byte aligned.','line_number':1663,'multiline':False]
['text':'/ Returns a pointer to write `len` bytes to, and advances the internal state','line_number':1677,'multiline':False]
['text':'/ Advance the inner state by `len` bytes','line_number':1689,'multiline':False]
['text':'/ Returns an `ostream_t` constructed from the given pointer and length','line_number':1702,'multiline':False]
['text':'/ Returns an `istream_t` constructed from the given pointer and length','line_number':1707,'multiline':False]
['text':'/ Returns an `istream_t` with the same base as `in`, and length `len`','line_number':1712,'multiline':False]
['text':'/ Then, advance `in` to account for the consumed bytes','line_number':1713,'multiline':False]
['text':'/ `in` must be byte aligned','line_number':1714,'multiline':False]
['text':' Consume `len` bytes of the parent stream','line_number':1716,'multiline':False]
['text':' Make a substream using the pointer to those `len` bytes','line_number':1719,'multiline':False]
['text':'****** END IO STREAM OPERATIONS ********************************************','line_number':1722,'multiline':True]
['text':'****** BITSTREAM OPERATIONS ************************************************','line_number':1724,'multiline':True]
['text':'/ Read `num` bits (up to 64) from `src + offset`, where `offset` is in bits','line_number':1725,'multiline':False]
['text':' Skip over bytes that aren't in range','line_number':1732,'multiline':False]
['text':' Read the next byte, shift it to account for the offset, and then mask','line_number':1741,'multiline':False]
['text':' out the top part if we don't need all the bits','line_number':1742,'multiline':False]
['text':'/ Read bits from the end of a HUF or FSE bitstream.  `offset` is in bits, so','line_number':1752,'multiline':False]
['text':'/ it updates `offset` to `offset - bits`, and then reads `bits` bits from','line_number':1753,'multiline':False]
['text':'/ `src + offset`.  If the offset becomes negative, the extra bits at the','line_number':1754,'multiline':False]
['text':'/ bottom are filled in with `0` bits instead of reading from before `src`.','line_number':1755,'multiline':False]
['text':' Don't actually read bits from before the start of src, so if `*offset <','line_number':1761,'multiline':False]
['text':' 0` fix actual_off and actual_bits to reflect the quantity to read','line_number':1762,'multiline':False]
['text':' Fill in the bottom "overflowed" bits with 0's','line_number':1770,'multiline':False]
['text':'****** END BITSTREAM OPERATIONS ********************************************','line_number':1775,'multiline':True]
['text':'****** BIT COUNTING OPERATIONS *********************************************','line_number':1777,'multiline':True]
['text':'/ Returns `x`, where `2^x` is the largest power of 2 less than or equal to','line_number':1778,'multiline':False]
['text':'/ `num`, or `-1` if `num == 0`.','line_number':1779,'multiline':False]
['text':'****** END BIT COUNTING OPERATIONS *****************************************','line_number':1788,'multiline':True]
['text':'****** HUFFMAN PRIMITIVES **************************************************','line_number':1790,'multiline':True]
['text':' Look up the symbol and number of bits to read','line_number':1794,'multiline':False]
['text':' Shift `bits` bits out of the state, keeping the low order bits that','line_number':1798,'multiline':False]
['text':' weren't necessary to determine this symbol.  Then add in the new bits','line_number':1799,'multiline':False]
['text':' read from the stream.','line_number':1800,'multiline':False]
['text':' Read in a full `dtable->max_bits` bits to initialize the state','line_number':1809,'multiline':False]
['text':' "Each bitstream must be read backward, that is starting from the end down','line_number':1823,'multiline':False]
['text':' to the beginning. Therefore it's necessary to know the size of each','line_number':1824,'multiline':False]
['text':' bitstream.','line_number':1825,'multiline':False]
['text':'','line_number':1826,'multiline':False]
['text':' It's also necessary to know exactly which bit is the latest. This is','line_number':1827,'multiline':False]
['text':' detected by a final bit flag : the highest bit of latest byte is a','line_number':1828,'multiline':False]
['text':' final-bit-flag. Consequently, a last byte of 0 is not possible. And the','line_number':1829,'multiline':False]
['text':' final-bit-flag itself is not part of the useful bitstream. Hence, the','line_number':1830,'multiline':False]
['text':' last byte contains between 0 and 7 useful bits."','line_number':1831,'multiline':False]
['text':' Offset starts at the end because HUF streams are read backwards','line_number':1834,'multiline':False]
['text':' Iterate over the stream, decoding one symbol at a time','line_number':1842,'multiline':False]
['text':' "The process continues up to reading the required number of symbols per','line_number':1846,'multiline':False]
['text':' stream. If a bitstream is not entirely and exactly consumed, hence','line_number':1847,'multiline':False]
['text':' reaching exactly its beginning position with all bits consumed, the','line_number':1848,'multiline':False]
['text':' decoding process is considered faulty."','line_number':1849,'multiline':False]
['text':' When all symbols have been decoded, the final state value shouldn't have','line_number':1851,'multiline':False]
['text':' any data from the stream, so it should have "read" dtable->max_bits from','line_number':1852,'multiline':False]
['text':' before the start of `src`','line_number':1853,'multiline':False]
['text':' Therefore `offset`, the edge to start reading new bits at, should be','line_number':1854,'multiline':False]
['text':' dtable->max_bits before the start of the stream','line_number':1855,'multiline':False]
['text':' "Compressed size is provided explicitly : in the 4-streams variant,','line_number':1865,'multiline':False]
['text':' bitstreams are preceded by 3 unsigned little-endian 16-bits values. Each','line_number':1866,'multiline':False]
['text':' value represents the compressed size of one stream, in order. The last','line_number':1867,'multiline':False]
['text':' stream size is deducted from total compressed size and from previously','line_number':1868,'multiline':False]
['text':' decoded stream sizes"','line_number':1869,'multiline':False]
['text':' Decode each stream independently for simplicity','line_number':1880,'multiline':False]
['text':' If we wanted to we could decode all 4 at the same time for speed,','line_number':1881,'multiline':False]
['text':' utilizing more execution units','line_number':1882,'multiline':False]
['text':'/ Initializes a Huffman table using canonical Huffman codes','line_number':1891,'multiline':False]
['text':'/ For more explanation on canonical Huffman codes see','line_number':1892,'multiline':False]
['text':'/ https://www.cs.scranton.edu/~mccloske/courses/cmps340/huff_canonical_dec2015.html','line_number':1893,'multiline':False]
['text':'/ Codes within a level are allocated in symbol order (i.e. smaller symbols get','line_number':1894,'multiline':False]
['text':'/ earlier codes)','line_number':1895,'multiline':False]
['text':' Count the number of symbols for each number of bits, and determine the','line_number':1907,'multiline':False]
['text':' depth of the tree','line_number':1908,'multiline':False]
['text':' "Symbols are sorted by Weight. Within same Weight, symbols keep natural','line_number':1928,'multiline':False]
['text':' order. Symbols with a Weight of zero are removed. Then, starting from','line_number':1929,'multiline':False]
['text':' lowest weight, prefix codes are distributed in order."','line_number':1930,'multiline':False]
['text':' Initialize the starting codes for each rank (number of bits)','line_number':1933,'multiline':False]
['text':' The entire range takes the same number of bits so we can memset it','line_number':1937,'multiline':False]
['text':' Allocate codes and fill in the table','line_number':1945,'multiline':False]
['text':' Allocate a code for this symbol and set its range in the table','line_number':1948,'multiline':False]
['text':' Since the code doesn't care about the bottom `max_bits - bits[i]`','line_number':1950,'multiline':False]
['text':' bits of state, it gets a range that spans all possible values of','line_number':1951,'multiline':False]
['text':' the lower bits','line_number':1952,'multiline':False]
['text':' +1 because the last weight is not transmitted in the header','line_number':1963,'multiline':False]
['text':' Weights are in the same range as bit count','line_number':1972,'multiline':False]
['text':' Find the first power of 2 larger than the sum','line_number':1979,'multiline':False]
['text':' If the left over isn't a power of 2, the weights are invalid','line_number':1982,'multiline':False]
['text':' left_over is used to find the last weight as it's not transmitted','line_number':1987,'multiline':False]
['text':' by inverting 2^(weight - 1) we can determine the value of last_weight','line_number':1988,'multiline':False]
['text':' "Number_of_Bits = Number_of_Bits ? Max_Number_of_Bits + 1 - Weight : 0"','line_number':1992,'multiline':False]
['text':' Last weight is always non-zero','line_number':1996,'multiline':False]
['text':'****** END HUFFMAN PRIMITIVES **********************************************','line_number':2006,'multiline':True]
['text':'****** FSE PRIMITIVES ******************************************************','line_number':2008,'multiline':True]
['text':'/ For more description of FSE see','line_number':2009,'multiline':False]
['text':'/ https://github.com/Cyan4973/FiniteStateEntropy/','line_number':2010,'multiline':False]
['text':'/ Allow a symbol to be decoded without updating state','line_number':2012,'multiline':False]
['text':'/ Consumes bits from the input and uses the current state to determine the','line_number':2018,'multiline':False]
['text':'/ next state','line_number':2019,'multiline':False]
['text':'/ Decodes a single FSE symbol and updates the offset','line_number':2028,'multiline':False]
['text':' Read in a full `accuracy_log` bits to initialize the state','line_number':2040,'multiline':False]
['text':' "Each bitstream must be read backward, that is starting from the end down','line_number':2054,'multiline':False]
['text':' to the beginning. Therefore it's necessary to know the size of each','line_number':2055,'multiline':False]
['text':' bitstream.','line_number':2056,'multiline':False]
['text':'','line_number':2057,'multiline':False]
['text':' It's also necessary to know exactly which bit is the latest. This is','line_number':2058,'multiline':False]
['text':' detected by a final bit flag : the highest bit of latest byte is a','line_number':2059,'multiline':False]
['text':' final-bit-flag. Consequently, a last byte of 0 is not possible. And the','line_number':2060,'multiline':False]
['text':' final-bit-flag itself is not part of the useful bitstream. Hence, the','line_number':2061,'multiline':False]
['text':' last byte contains between 0 and 7 useful bits."','line_number':2062,'multiline':False]
['text':' "The first state (State1) encodes the even indexed symbols, and the','line_number':2067,'multiline':False]
['text':' second (State2) encodes the odd indexes. State1 is initialized first, and','line_number':2068,'multiline':False]
['text':' then State2, and they take turns decoding a single symbol and updating','line_number':2069,'multiline':False]
['text':' their state."','line_number':2070,'multiline':False]
['text':' Decode until we overflow the stream','line_number':2074,'multiline':False]
['text':' Since we decode in reverse order, overflowing the stream is offset going','line_number':2075,'multiline':False]
['text':' negative','line_number':2076,'multiline':False]
['text':' "The number of symbols to decode is determined by tracking bitStream','line_number':2079,'multiline':False]
['text':' overflow condition: If updating state after decoding a symbol would','line_number':2080,'multiline':False]
['text':' require more bits than remain in the stream, it is assumed the extra','line_number':2081,'multiline':False]
['text':' bits are 0. Then, the symbols for each of the final states are','line_number':2082,'multiline':False]
['text':' decoded and the process is complete."','line_number':2083,'multiline':False]
['text':' There's still a symbol to decode in state2','line_number':2087,'multiline':False]
['text':' There's still a symbol to decode in state1','line_number':2096,'multiline':False]
['text':' Used to determine how many bits need to be read for each state,','line_number':2127,'multiline':False]
['text':' and where the destination range should start','line_number':2128,'multiline':False]
['text':' Needs to be u16 because max value is 2 * max number of symbols,','line_number':2129,'multiline':False]
['text':' which can be larger than a byte can store','line_number':2130,'multiline':False]
['text':' "Symbols are scanned in their natural order for "less than 1"','line_number':2133,'multiline':False]
['text':' probabilities. Symbols with this probability are being attributed a','line_number':2134,'multiline':False]
['text':' single cell, starting from the end of the table. These symbols define a','line_number':2135,'multiline':False]
['text':' full state reset, reading Accuracy_Log bits."','line_number':2136,'multiline':False]
['text':' Scan for low probability symbols to put at the top','line_number':2139,'multiline':False]
['text':' "All remaining symbols are sorted in their natural order. Starting from','line_number':2146,'multiline':False]
['text':' symbol 0 and table position 0, each symbol gets attributed as many cells','line_number':2147,'multiline':False]
['text':' as its probability. Cell allocation is spread, not linear."','line_number':2148,'multiline':False]
['text':' Place the rest in the table','line_number':2149,'multiline':False]
['text':' Give `norm_freqs[s]` states to symbol s','line_number':2161,'multiline':False]
['text':' "A position is skipped if already occupied, typically by a "less','line_number':2163,'multiline':False]
['text':' than 1" probability symbol."','line_number':2164,'multiline':False]
['text':' Note: no other collision checking is necessary as `step` is','line_number':2169,'multiline':False]
['text':' coprime to `size`, so the cycle will visit each position exactly','line_number':2170,'multiline':False]
['text':' once','line_number':2171,'multiline':False]
['text':' Now we can fill baseline and num bits','line_number':2178,'multiline':False]
['text':' Fills in the table appropriately, next_state_desc increases by symbol','line_number':2182,'multiline':False]
['text':' over time, decreasing number of bits','line_number':2183,'multiline':False]
['text':' Baseline increases until the bit threshold is passed, at which point','line_number':2185,'multiline':False]
['text':' it resets to 0','line_number':2186,'multiline':False]
['text':'/ Decode an FSE header as defined in the Zstandard format specification and','line_number':2192,'multiline':False]
['text':'/ use the decoded frequencies to initialize a decoding table.','line_number':2193,'multiline':False]
['text':' "An FSE distribution table describes the probabilities of all symbols','line_number':2196,'multiline':False]
['text':' from 0 to the last present one (included) on a normalized scale of 1 <<','line_number':2197,'multiline':False]
['text':' Accuracy_Log .','line_number':2198,'multiline':False]
['text':'','line_number':2199,'multiline':False]
['text':' It's a bitstream which is read forward, in little-endian fashion. It's','line_number':2200,'multiline':False]
['text':' not necessary to know its exact size, since it will be discovered and','line_number':2201,'multiline':False]
['text':' reported by the decoding process.','line_number':2202,'multiline':False]
['text':' The bitstream starts by reporting on which scale it operates.','line_number':2207,'multiline':False]
['text':' Accuracy_Log = low4bits + 5. Note that maximum Accuracy_Log for literal','line_number':2208,'multiline':False]
['text':' and match lengths is 9, and for offsets is 8. Higher values are','line_number':2209,'multiline':False]
['text':' considered errors."','line_number':2210,'multiline':False]
['text':' "Then follows each symbol value, from 0 to last present one. The number','line_number':2216,'multiline':False]
['text':' of bits used by each field is variable. It depends on :','line_number':2217,'multiline':False]
['text':'','line_number':2218,'multiline':False]
['text':' Remaining probabilities + 1 : example : Presuming an Accuracy_Log of 8,','line_number':2219,'multiline':False]
['text':' and presuming 100 probabilities points have already been distributed, the','line_number':2220,'multiline':False]
['text':' decoder may read any value from 0 to 255 - 100 + 1 == 156 (inclusive).','line_number':2221,'multiline':False]
['text':' Therefore, it must read log2sup(156) == 8 bits.','line_number':2222,'multiline':False]
['text':'','line_number':2223,'multiline':False]
['text':' Value decoded : small values use 1 less bit : example : Presuming values','line_number':2224,'multiline':False]
['text':' from 0 to 156 (inclusive) are possible, 255-156 = 99 values are remaining','line_number':2225,'multiline':False]
['text':' in an 8-bits field. They are used this way : first 99 values (hence from','line_number':2226,'multiline':False]
['text':' 0 to 98) use only 7 bits, values from 99 to 156 use 8 bits. "','line_number':2227,'multiline':False]
['text':' Log of the number of possible values we could read','line_number':2234,'multiline':False]
['text':' Try to mask out the lower bits to see if it qualifies for the "small','line_number':2239,'multiline':False]
['text':' value" threshold','line_number':2240,'multiline':False]
['text':' "Probability is obtained from Value decoded by following formula :','line_number':2251,'multiline':False]
['text':' Proba = value - 1"','line_number':2252,'multiline':False]
['text':' "It means value 0 becomes negative probability -1. -1 is a special','line_number':2255,'multiline':False]
['text':' probability, which means "less than 1". Its effect on distribution','line_number':2256,'multiline':False]
['text':' table is described in next paragraph. For the purpose of calculating','line_number':2257,'multiline':False]
['text':' cumulated distribution, it counts as one."','line_number':2258,'multiline':False]
['text':' "When a symbol has a probability of zero, it is followed by a 2-bits','line_number':2264,'multiline':False]
['text':' repeat flag. This repeat flag tells how many probabilities of zeroes','line_number':2265,'multiline':False]
['text':' follow the current one. It provides a number ranging from 0 to 3. If','line_number':2266,'multiline':False]
['text':' it is a 3, another 2-bits repeat flag follows, and so on."','line_number':2267,'multiline':False]
['text':' Read the next two bits to see how many more 0s','line_number':2269,'multiline':False]
['text':' "When last symbol reaches cumulated total of 1 << Accuracy_Log, decoding','line_number':2286,'multiline':False]
['text':' is complete. If the last symbol makes cumulated total go above 1 <<','line_number':2287,'multiline':False]
['text':' Accuracy_Log, distribution is considered corrupted."','line_number':2288,'multiline':False]
['text':' Initialize the decoding table using the determined weights','line_number':2293,'multiline':False]
['text':' This setup will always have a state of 0, always return symbol `symb`,','line_number':2306,'multiline':False]
['text':' and never consume any bits','line_number':2307,'multiline':False]
['text':'****** END FSE PRIMITIVES **************************************************','line_number':2320,'multiline':True]
