['text':' The Antithesis Instrumentation Library has three main uses:','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' 1. Enabling the system under test, or its test harness, to request input from the Fuzzer.','line_number':3,'multiline':False]
['text':' 2. Enabling the system under test, or its test harness, to send arbitrary messages, guidance, or information','line_number':4,'multiline':False]
['text':'    about current status back to the Fuzzer. This information can either be used by the Fuzzer to make further','line_number':5,'multiline':False]
['text':'    decisions (e.g. in strategies), or logged to BigQuery for post-hoc analysis.','line_number':6,'multiline':False]
['text':' 3. Providing the callbacks which programs that have been *instrumented* use to send coverage data back to ','line_number':7,'multiline':False]
['text':'    the Fuzzer.','line_number':8,'multiline':False]
['text':'','line_number':9,'multiline':False]
['text':'','line_number':10,'multiline':False]
['text':' Purpose (1) is "input". Purposes (2) and (3) are conceptually both forms of "output", but are treated separately','line_number':11,'multiline':False]
['text':' because in practice they are used very differently. Output of type (2) is more commonly associated with test','line_number':12,'multiline':False]
['text':' harnesses and wrappers, though perhaps someday our customers will add it to their programs directly using a ','line_number':13,'multiline':False]
['text':' descendant of this library. Output of type (3) is generally performed by the target program directly. It does this ','line_number':14,'multiline':False]
['text':' if it has been transformed ("instrumented") by an "instrumentor", sometimes at compile-time, sometimes afterwards, but ','line_number':15,'multiline':False]
['text':' in either case conceptually part of the build. This process of "instrumentation" involves adding callbacks to all or ','line_number':16,'multiline':False]
['text':' most of the program edges in the customer program, such that every time the edge is reached, the callback is executed,','line_number':17,'multiline':False]
['text':' sending coverage information back to the Fuzzer.','line_number':18,'multiline':False]
['text':'','line_number':19,'multiline':False]
['text':' This means that in some sense, the word "instrumentation" itself is overloaded, as it can refer both to the general','line_number':20,'multiline':False]
['text':' category of I/O handled by this library, and to the specific kinds grouped under type (3) above. Sorry about that.','line_number':21,'multiline':False]
['text':'','line_number':22,'multiline':False]
['text':' There are three distinct implementations of this interface:','line_number':23,'multiline':False]
['text':'','line_number':24,'multiline':False]
['text':' * libvoidstar.so','line_number':25,'multiline':False]
['text':' * libinstrumentation_legacy.so','line_number':26,'multiline':False]
['text':' * libinstrumentation_determ.so','line_number':27,'multiline':False]
['text':' ','line_number':28,'multiline':False]
['text':' libvoidstar.so is the stub implementation of this library. Its output functions either do nothing or print to the','line_number':29,'multiline':False]
['text':' console. Its input functions are a shim to the real `getchar`. The primary purpose of this stub is to be ','line_number':30,'multiline':False]
['text':' distributed to customers, so that they can link it as part of their build. When it comes time to actually test','line_number':31,'multiline':False]
['text':' the customer's software, we then use LD_PRELOAD or similar to substitute one of the two "real" instrumentation ','line_number':32,'multiline':False]
['text':' libraries in its place. A nice benefit of this is that we can change all kinds of details about the real ','line_number':33,'multiline':False]
['text':' implementations without requiring our customers to re-compile their software, so long as we don't modify the interface.','line_number':34,'multiline':False]
['text':'','line_number':35,'multiline':False]
['text':' libinstrumentation_legacy.so is the "real" implementation for tests running outside of our deterministic hypervisor. It','line_number':36,'multiline':False]
['text':' communicates with the Fuzzer over local Unix sockets, using a protocol that is decoded on the Fuzzer side by the','line_number':37,'multiline':False]
['text':' `LegacyTarget` class. In practice this is used relatively rarely these days, since it is only useful for ','line_number':38,'multiline':False]
['text':' fuzzing targets that are naturally deterministic. Consequently, many of the methods have various limitations','line_number':39,'multiline':False]
['text':' in this version of the library, or in a few cases are just stubs. Still, it can be convenient to have for local ','line_number':40,'multiline':False]
['text':' testing.','line_number':41,'multiline':False]
['text':'','line_number':42,'multiline':False]
['text':' libinstrumentation_determ.so is the "real" implementation for tests running inside of our deterministic hypervisor. ','line_number':43,'multiline':False]
['text':' It communicates with the Fuzzer using the libsyncio library, which in turn performs a hypercall that causes the ','line_number':44,'multiline':False]
['text':' hypervisor to halt execution of the running VM and exchange data with the Fuzzer (see the libsyncio documentation for ','line_number':45,'multiline':False]
['text':' details). Note that because of this, it is *not possible* to run with this library outside of the hypervisor -- your','line_number':46,'multiline':False]
['text':' CPU will consider the hypercall to be an invalid instruction, and you will get a SIGILL.','line_number':47,'multiline':False]
['text':' *********************************************','line_number':59,'multiline':False]
['text':' (1) Input functions','line_number':60,'multiline':False]
['text':' *********************************************','line_number':61,'multiline':False]
['text':' Request an additional byte of input from the Fuzzer. This will lead to the creation and logging of a new `State`.','line_number':63,'multiline':False]
['text':' Indeed, you could actually define a State to be the duration of system time between successive calls to ','line_number':64,'multiline':False]
['text':' `fuzz_getchar`.','line_number':65,'multiline':False]
['text':'','line_number':66,'multiline':False]
['text':' This method is thread-safe. It's fine for multiple systems/test harnesses to call this function, though that may','line_number':67,'multiline':False]
['text':' in some cases make it more challenging to write intelligent strategies and tactics in the Fuzzer.','line_number':68,'multiline':False]
['text':'','line_number':69,'multiline':False]
['text':' This method is not only synchronous, but in some sense "globally" synchronous. Tests using libinstrumentation_legacy.so ','line_number':70,'multiline':False]
['text':' are presumed to be naturally deterministic, hence single-threaded and single-process. Meanwhile, the ','line_number':71,'multiline':False]
['text':' libinstrumentation_determ.so version of this function will, due to the way that libsyncio works, freeze the entire ','line_number':72,'multiline':False]
['text':' guest system until a reply is received from the Fuzzer (obviously a context switch could still occur between ','line_number':73,'multiline':False]
['text':' returning from the syncio library and returning from `fuzz_getchar`).','line_number':74,'multiline':False]
['text':'','line_number':75,'multiline':False]
['text':' Before anything happens, this will also trigger a flush of any buffered output messages sent via this copy of the ','line_number':76,'multiline':False]
['text':' instrumentation library (equivalent to calling `fuzz_flush` as described below).','line_number':77,'multiline':False]
['text':' Returns a pseudorandom number that is a deterministic function of the sequence of prior calls to `fuzz_getchar` by this ','line_number':80,'multiline':False]
['text':' or *other* copies of the instrumentation library, the sequence of prior random number accesses, and of nothing else.','line_number':81,'multiline':False]
['text':'','line_number':82,'multiline':False]
['text':' This method is thread-safe in libinstrumentation_determ (the legacy instrumentation should never be used with','line_number':83,'multiline':False]
['text':' multi-threaded programs).','line_number':84,'multiline':False]
['text':' Returns a boolean that is a deterministic function of the sequence of prior calls to `fuzz_getchar` by this ','line_number':87,'multiline':False]
['text':' or *other* copies of the instrumentation library, the sequence of prior random number accesses, and of nothing else.','line_number':88,'multiline':False]
['text':'','line_number':89,'multiline':False]
['text':' This method is thread-safe in libinstrumentation_determ (the legacy instrumentation should never be used with','line_number':90,'multiline':False]
['text':' multi-threaded programs).','line_number':91,'multiline':False]
['text':' A rarely-used function that requests an entire large blob of input from the Fuzzer. This is NEVER called during ','line_number':94,'multiline':False]
['text':' normal testing operations, and is primarily used during the test setup phase as a means of optionally injecting','line_number':95,'multiline':False]
['text':' data or configuration into the guest system. We have moved away from using this method of injecting things into the','line_number':96,'multiline':False]
['text':' guest system, though, and recommend that that occur as part of the LiveCD build instead.','line_number':97,'multiline':False]
['text':'','line_number':98,'multiline':False]
['text':' The libinstrumentation_legacy.so version of this function is just a shim to `fuzz_getchar` and only ever returns one byte.','line_number':99,'multiline':False]
['text':'','line_number':100,'multiline':False]
['text':' This method is thread-safe.','line_number':101,'multiline':False]
['text':'','line_number':102,'multiline':False]
['text':' TODO: Decide whether to remove this method from the public instrumentation interface.','line_number':103,'multiline':False]
['text':' *********************************************','line_number':106,'multiline':False]
['text':' (2) Output functions (non-coverage)','line_number':107,'multiline':False]
['text':' *********************************************','line_number':108,'multiline':False]
['text':' Sets a name that will be associated with all future output messages *and* coverage output coming from this copy of ','line_number':110,'multiline':False]
['text':' the instrumentation library. Useful for disambiguation when multiple harnesses/programs are concurrently sending ','line_number':111,'multiline':False]
['text':' output and/or coverage to the Fuzzer. The name is plumbed all the way through to Notebook for analysis.','line_number':112,'multiline':False]
['text':'','line_number':113,'multiline':False]
['text':' This method only needs to be called once per instantiation of this library, and the configured source name will','line_number':114,'multiline':False]
['text':' persist until this method is called again. It does not need to be called once per thread. Currently multiple','line_number':115,'multiline':False]
['text':' threads in a program that has loaded this library *must* share a source name.','line_number':116,'multiline':False]
['text':'','line_number':117,'multiline':False]
['text':' This method is implicitly called by the instrumentor-injected module initializers (see discussion below). Calling it ','line_number':118,'multiline':False]
['text':' again in an instrumented program will override their naming scheme.','line_number':119,'multiline':False]
['text':'','line_number':120,'multiline':False]
['text':' This method is thread-safe.','line_number':121,'multiline':False]
['text':'','line_number':122,'multiline':False]
['text':' The maximum length for a source name is 64 characters.','line_number':123,'multiline':False]
['text':' This family of methods is the primary means of sending unstructured data from the system under test and the test','line_number':126,'multiline':False]
['text':' harnesses back to the Fuzzer. Examples of things that are commonly sent with these methods include log messages,','line_number':127,'multiline':False]
['text':' exceptions or error messages, program text output, and even "hand" instrumentation information.','line_number':128,'multiline':False]
['text':'','line_number':129,'multiline':False]
['text':' If the Fuzzer is configured to log program output, these messages will be available for analysis in the Notebook.','line_number':130,'multiline':False]
['text':' Every message will be associated with: (1) the state in which it was generated, (2) the source name that produced ','line_number':131,'multiline':False]
['text':' the message (if `fuzz_set_source_name` has been called), (3) whether the message was `ERROR` or `INFO`, and (4) the ','line_number':132,'multiline':False]
['text':' VTime at which the message was generated (if running in the hypervisor). Sorting, filtering, grouping, etc. on these ','line_number':133,'multiline':False]
['text':' metadata fields is relatively straightforward in the Notebook.','line_number':134,'multiline':False]
['text':'','line_number':135,'multiline':False]
['text':' Strategies may also make use of these messages as a form of guidance. See, e.g. `MessageFeature` and','line_number':136,'multiline':False]
['text':' `MessageMatchRegexFeature` in the Fuzzer.','line_number':137,'multiline':False]
['text':'','line_number':138,'multiline':False]
['text':' The "message" versions of these functions expect a null-terminated C-style string, the "data" versions expect a ','line_number':139,'multiline':False]
['text':' pointer and a length. They are otherwise identical.','line_number':140,'multiline':False]
['text':'','line_number':141,'multiline':False]
['text':' These methods are thread-safe.','line_number':142,'multiline':False]
['text':' ','line_number':143,'multiline':False]
['text':' WARNING: These methods buffer output data to be sent to the Fuzzer in batches. They do *not* immediately send','line_number':144,'multiline':False]
['text':' data when called. It is guaranteed that output messages will never be buffered across state boundaries **WITHIN','line_number':145,'multiline':False]
['text':' A SINGLE COPY OF THE INSTRUMENTATION LIBRARY**, however if a guest vm contains multiple output sources, it is ','line_number':146,'multiline':False]
['text':' completely possible for their outputs to be almost arbitrarily interleaved, *including* across state boundaries.','line_number':147,'multiline':False]
['text':' Moreover the VTime that is eventually attributed to a message is the VTime at which it was sent, not the VTime at ','line_number':148,'multiline':False]
['text':' which this function was called and the message was buffered.','line_number':149,'multiline':False]
['text':'','line_number':150,'multiline':False]
['text':' If you want a message to be sent immediately, you should call `fuzz_flush` after buffering the message.','line_number':151,'multiline':False]
['text':' Slight variation on `fuzz_info_data` which assumes that the data is PNG-encoded, and informs the Fuzzer of that','line_number':157,'multiline':False]
['text':' fact. Primarily used for sending screenshots of the system under test for analysis or visualization.','line_number':158,'multiline':False]
['text':'','line_number':159,'multiline':False]
['text':' All guarantees/invariants/warnings listed for `fuzz_info_message` are also true for this method.','line_number':160,'multiline':False]
['text':' Variation on fuzz_info_data and fuzz_error_data for any blob of binary data.','line_number':163,'multiline':False]
['text':' Variation on `fuzz_info_data` which instructs the Fuzzer to interpret the payload as an array of uint32 key-value','line_number':166,'multiline':False]
['text':' pairs, packed like: 'KVKVKV...'. The data can be unpacked on the Fuzzer side using a `KV32ValueFeature`, which can','line_number':167,'multiline':False]
['text':' in turn be logged or used in a strategy like any other feature.','line_number':168,'multiline':False]
['text':'','line_number':169,'multiline':False]
['text':' It is NOT recommended that you call this multiple times within a single state with the same Key, unless you also do so','line_number':170,'multiline':False]
['text':' with the same Value every time. A `KV32ValueFeature` evaluated on a state where the same Key has been logged ','line_number':171,'multiline':False]
['text':' multiple times will pick *one* of the possible Values, but you should not make any assumptions about which one!','line_number':172,'multiline':False]
['text':'','line_number':173,'multiline':False]
['text':' `length` is the total length of the array passed in, twice the number of features.','line_number':174,'multiline':False]
['text':'','line_number':175,'multiline':False]
['text':' All guarantees/invariants/warnings listed for `fuzz_info_message` are also true for this method.','line_number':176,'multiline':False]
['text':' Causes all previously buffered output messages in this copy of the library to be sent immediately, and does not return','line_number':179,'multiline':False]
['text':' until a response is received. From the perspective of the system under test, this happens "almost instantaneously". ','line_number':180,'multiline':False]
['text':' but from the point of view of real world performance, this triggers a network roundtrip to and from the Fuzzer, which ','line_number':181,'multiline':False]
['text':' may involve significant latency.','line_number':182,'multiline':False]
['text':'','line_number':183,'multiline':False]
['text':' This method is thread-safe.','line_number':184,'multiline':False]
['text':' Sends a termination message to the Fuzzer with the provided exit code, then causes this process to exit without cleanup.','line_number':187,'multiline':False]
['text':' This output message is not buffered, but will be sent *immediately* (no need to call `fuzz_flush`). The state in which ','line_number':188,'multiline':False]
['text':' this message was sent will be marked as Terminal by the Fuzzer, meaning no descendants of the state will ever be ','line_number':189,'multiline':False]
['text':' produced. Note however that some Fuzzer strategies may still choose to remember Terminal states, for instance in order','line_number':190,'multiline':False]
['text':' to apply `BackupTactic` or `MutationTactic` to them.','line_number':191,'multiline':False]
['text':'','line_number':192,'multiline':False]
['text':' Exit codes are logged, and available for analysis in the Notebook.','line_number':193,'multiline':False]
['text':'','line_number':194,'multiline':False]
['text':' This method is thread-safe.','line_number':195,'multiline':False]
['text':' *********************************************','line_number':198,'multiline':False]
['text':' (3) Output functions (coverage callbacks)','line_number':199,'multiline':False]
['text':' *********************************************','line_number':200,'multiline':False]
['text':' Programs using LLVM instrumentation have this callback inserted by the compiler as a module constructor into every DSO.','line_number':202,'multiline':False]
['text':' Developers generally should not have to manually call this function. It is thread-safe and may be called multiple ','line_number':203,'multiline':False]
['text':' times with the same parameters.','line_number':204,'multiline':False]
['text':'','line_number':205,'multiline':False]
['text':' Our implementation of the LLVM module initializer callback does 3 things:','line_number':206,'multiline':False]
['text':' ','line_number':207,'multiline':False]
['text':' (1) Initializes all edge guards to 1 (see documentation for `__sanitizer_cov_trace_pc_guard`).','line_number':208,'multiline':False]
['text':' (2) Finds the PID of this process and reads the value of the `ANT_SOURCE_NAME` environment variable. If the variable is','line_number':209,'multiline':False]
['text':'     non-empty, sets the source name for this copy of the library to "${ANT_SOURCE_NAME}-${PID}", if it is empty, sets','line_number':210,'multiline':False]
['text':'     it to "instrumentation-${PID}". See documentation for `fuzz_set_source_name` for more on what that means.','line_number':211,'multiline':False]
['text':' (3) Sends to the Fuzzer information about all of the memory segments in which this module has code loaded. This ','line_number':212,'multiline':False]
['text':'     information is used by the Fuzzer in the symbolization process.','line_number':213,'multiline':False]
['text':'','line_number':214,'multiline':False]
['text':' The module information is not buffered, but sent immediately.','line_number':215,'multiline':False]
['text':'','line_number':216,'multiline':False]
['text':' The following symbols are indeed reserved identifiers, since we're implementing functions defined','line_number':217,'multiline':False]
['text':' in the compiler runtime. Not clear how to get Clang on board with that besides narrowly suppressing','line_number':218,'multiline':False]
['text':' the warning in this case. The sample code on the CoverageSanitizer documentation page fails this ','line_number':219,'multiline':False]
['text':' warning!','line_number':220,'multiline':False]
['text':' Programs using LLVM instrumentation have this callback inserted by the compiler on every edge in the control flow (some','line_number':225,'multiline':False]
['text':' optimizations apply). Developers generally should not have to manually call this function. It is thread-safe and may be ','line_number':226,'multiline':False]
['text':' called multiple times with the same parameters. Typically, the compiler will emit the code like this:','line_number':227,'multiline':False]
['text':'','line_number':228,'multiline':False]
['text':'    if(*guard)','line_number':229,'multiline':False]
['text':'      __sanitizer_cov_trace_pc_guard(guard);','line_number':230,'multiline':False]
['text':'','line_number':231,'multiline':False]
['text':' But for large functions it will emit a simple call:','line_number':232,'multiline':False]
['text':'','line_number':233,'multiline':False]
['text':'    __sanitizer_cov_trace_pc_guard(guard);','line_number':234,'multiline':False]
['text':'','line_number':235,'multiline':False]
['text':' Thus, by setting *guard to 0 the function will *usually* not be called again for a given edge.','line_number':236,'multiline':False]
['text':'','line_number':237,'multiline':False]
['text':' Our implementation of the LLVM edge callback buffers a message to the Fuzzer containing the address of the instruction','line_number':238,'multiline':False]
['text':' that triggered the callback. The first time the callback is triggered for a given edge, the coverage message is ','line_number':239,'multiline':False]
['text':' buffered unconditionally. Sucessive invocations have their behavior governed by the `ANT_DISABLE_REUSED_EDGE` ','line_number':240,'multiline':False]
['text':' environment variable. If the variable is unset, or set to "1", the callback will only send coverage information the','line_number':241,'multiline':False]
['text':' first time. If set to anything other than "1", the callback will send coverage information every time.','line_number':242,'multiline':False]
['text':'','line_number':243,'multiline':False]
['text':' Setting `ANT_DISABLE_REUSED_EDGE` to something other than 1 is necessary for the functioning of certain Fuzzer','line_number':244,'multiline':False]
['text':' strategies (for example TransitionCoverageStrategy), however the volume of edge data that results currently causes a ','line_number':245,'multiline':False]
['text':' massive performance overhead, so it is not enabled by default, and not practical for many fuzzing targets.','line_number':246,'multiline':False]
['text':'','line_number':247,'multiline':False]
['text':' There are many features in the Fuzzer's feature algebra that are functions of coverage data, and many strategies that','line_number':248,'multiline':False]
['text':' make use of them. Coverage information can also be visualized and analyzed in the Notebook.','line_number':249,'multiline':False]
['text':' Each independently instrumented module should call init_coverage_module() once.  The symbol file name will be used','line_number':253,'multiline':False]
['text':' to look up symbols, and should generally be different for each instrumented module.  The edge_count is the number','line_number':254,'multiline':False]
['text':' of possible edges in the module.','line_number':255,'multiline':False]
['text':' The return value is a module identifier which should be added to edge IDs in the range [0,edge_count) and passed','line_number':256,'multiline':False]
['text':' to notify_coverage().','line_number':257,'multiline':False]
['text':' This function is thread safe, but it is the responsibility of the caller to call it exactly once for each module,','line_number':258,'multiline':False]
['text':' before calling notify_coverage().','line_number':259,'multiline':False]
['text':' Each time an edge occurs, call notify_coverage( E+M ), where E is the edge ID recorded in the symbol file','line_number':262,'multiline':False]
['text':' (0 <= E < edge_count) and M is the return value of init_coverage_module(edge_count, ...)','line_number':263,'multiline':False]
['text':' If the return value is false, the caller *may* omit subsequent calls with the same parameter.  (If it has always been true for that parameter, it must not.)','line_number':264,'multiline':False]
