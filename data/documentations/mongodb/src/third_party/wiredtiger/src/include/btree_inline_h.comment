['text':'-
 * Copyright (c) 2014-present MongoDB, Inc.
 * Copyright (c) 2008-2014 WiredTiger, Inc.
 *	All rights reserved.
 *
 * See the file LICENSE for redistribution information.
 ','line_number':1,'multiline':True]
['text':'
 * __wt_ref_is_root --
 *     Return if the page reference is for the root page.
 ','line_number':9,'multiline':True]
['text':'
 * __wt_ref_cas_state_int --
 *     Try to do a compare and swap, if successful update the ref history in diagnostic mode.
 ','line_number':19,'multiline':True]
['text':' Parameters that are used in a macro for diagnostic builds ','line_number':29,'multiline':True]
['text':'
     * The history update here has potential to race; if the state gets updated again after the CAS
     * above but before the history has been updated.
     ','line_number':37,'multiline':True]
['text':'
 * __wt_btree_disable_bulk --
 *     Disable bulk loads into a tree.
 ','line_number':47,'multiline':True]
['text':'
     * Once a tree (other than the LSM primary) is no longer empty, eviction should pay attention to
     * it, and it's no longer possible to bulk-load into it.
     ','line_number':58,'multiline':True]
['text':' Make the next test faster. ','line_number':65,'multiline':True]
['text':'
     * We use a compare-and-swap here to avoid races among the first inserts into a tree. Eviction
     * is disabled when an empty tree is opened, and it must only be enabled once.
     ','line_number':69,'multiline':True]
['text':'
 * __wt_page_is_empty --
 *     Return if the page is empty.
 ','line_number':79,'multiline':True]
['text':'
     * Be cautious modifying this function: it's reading fields set by checkpoint reconciliation,
     * and we're not blocking checkpoints (although we must block eviction as it might clear and
     * free these structures).
     ','line_number':86,'multiline':True]
['text':'
 * __wt_page_evict_soon_check --
 *     Check whether the page should be evicted urgently.
 ','line_number':94,'multiline':True]
['text':'
     * Attempt to evict pages with the special "oldest" read generation. This is set for pages that
     * grow larger than the configured memory_page_max setting, when we see many deleted items, and
     * when we are attempting to scan without trashing the cache.
     *
     * Checkpoint should not queue pages for urgent eviction if they require dirty eviction: there
     * is a special exemption that allows checkpoint to evict dirty pages in a tree that is being
     * checkpointed, and no other thread can help with that. Checkpoints don't rely on this code for
     * dirty eviction: that is handled explicitly in __wt_sync_file.
     ','line_number':107,'multiline':True]
['text':'
 * __wt_page_evict_clean --
 *     Return if the page can be evicted without dirtying the tree.
 ','line_number':124,'multiline':True]
['text':'
     * Be cautious modifying this function: it's reading fields set by checkpoint reconciliation,
     * and we're not blocking checkpoints (although we must block eviction as it might clear and
     * free these structures).
     ','line_number':131,'multiline':True]
['text':'
 * __wt_page_is_modified --
 *     Return if the page is dirty.
 ','line_number':140,'multiline':True]
['text':'
     * Be cautious modifying this function: it's reading fields set by checkpoint reconciliation,
     * and we're not blocking checkpoints (although we must block eviction as it might clear and
     * free these structures).
     ','line_number':147,'multiline':True]
['text':'
 * __wt_page_is_reconciling --
 *     Return if the page is being reconciled.
 ','line_number':155,'multiline':True]
['text':'
     * Be cautious modifying this function: it's reading fields set by checkpoint reconciliation,
     * and we're not blocking checkpoints (although we must block eviction as it might clear and
     * free these structures).
     ','line_number':162,'multiline':True]
['text':'
 * __wt_btree_block_free --
 *     Helper function to free a block from the current tree.
 ','line_number':170,'multiline':True]
['text':'
 * __wt_btree_bytes_inuse --
 *     Return the number of bytes in use.
 ','line_number':186,'multiline':True]
['text':'
 * __wt_btree_bytes_evictable --
 *     Return the number of bytes that can be evicted (i.e. bytes apart from the pinned root page).
 ','line_number':202,'multiline':True]
['text':'
 * __wt_btree_dirty_inuse --
 *     Return the number of dirty bytes in use.
 ','line_number':226,'multiline':True]
['text':'
 * __wt_btree_dirty_leaf_inuse --
 *     Return the number of bytes in use by dirty leaf pages.
 ','line_number':243,'multiline':True]
['text':'
 * __wt_btree_bytes_updates --
 *     Return the number of bytes in use by dirty leaf pages.
 ','line_number':259,'multiline':True]
['text':'
 * __wt_cache_page_inmem_incr --
 *     Increment a page's memory footprint in the cache.
 ','line_number':275,'multiline':True]
['text':'
     * Always increase the size in sequence of cache, btree, and page as we may race with other
     * threads that are trying to decrease the sizes concurrently.
     ','line_number':292,'multiline':True]
['text':'
         * For application threads, track the transaction bytes added to cache usage. We want to
         * capture only the application's own changes to page data structures. Exclude changes to
         * internal pages or changes that are the result of the application thread being co-opted
         * into eviction work.
         ','line_number':305,'multiline':True]
['text':'
 * __wt_cache_decr_check_size --
 *     Decrement a size_t cache value and check for underflow.
 ','line_number':333,'multiline':True]
['text':'
     * It's a bug if this accounting underflowed but allow the application to proceed - the
     * consequence is we use more cache than configured.
     ','line_number':343,'multiline':True]
['text':'
 * __wt_cache_decr_check_uint64 --
 *     Decrement a uint64_t cache value and check for underflow.
 ','line_number':355,'multiline':True]
['text':'
     * It's a bug if this accounting underflowed but allow the application to proceed - the
     * consequence is we use more cache than configured.
     ','line_number':367,'multiline':True]
['text':'
 * __wt_cache_page_byte_dirty_decr --
 *     Decrement the page's dirty byte count, guarding from underflow.
 ','line_number':380,'multiline':True]
['text':' [-Wconditional-uninitialized] ','line_number':394,'multiline':True]
['text':'
     * We don't have exclusive access and there are ways of decrementing the
     * page's dirty byte count by a too-large value. For example:
     *	T1: __wt_cache_page_inmem_incr(page, size)
     *		page is clean, don't increment dirty byte count
     *	T2: mark page dirty
     *	T1: __wt_cache_page_inmem_decr(page, size)
     *		page is dirty, decrement dirty byte count
     * and, of course, the reverse where the page is dirty at the increment
     * and clean at the decrement.
     *
     * The page's dirty-byte value always reflects bytes represented in the
     * cache's dirty-byte count, decrement the page/cache as much as we can
     * without underflow. If we can't decrement the dirty byte counts after
     * few tries, give up: the cache's value will be wrong, but consistent,
     * and we'll fix it the next time this page is marked clean, or evicted.
     *
     * Always decrease the size in sequence of page, btree, and cache as we may race with other
     * threads that are trying to increase the sizes concurrently.
     ','line_number':396,'multiline':True]
['text':'
         * Take care to read the dirty-byte count only once in case we're racing with updates.
         ','line_number':417,'multiline':True]
['text':'
 * __wt_cache_page_byte_updates_decr --
 *     Decrement the page's update byte count, guarding from underflow.
 ','line_number':442,'multiline':True]
['text':' [-Wconditional-uninitialized] ','line_number':456,'multiline':True]
['text':' See above for why this can race. ','line_number':460,'multiline':True]
['text':'
 * __wt_cache_page_inmem_decr --
 *     Decrement a page's memory footprint in the cache.
 ','line_number':474,'multiline':True]
['text':'
     * Always decrease the size in sequence of page, btree, and cache as we may race with other
     * threads that are trying to increase the sizes concurrently.
     ','line_number':489,'multiline':True]
['text':' Track internal size in cache. ','line_number':500,'multiline':True]
['text':'
 * __wt_cache_dirty_incr --
 *     Page switch from clean to dirty: increment the cache dirty page/byte counts.
 ','line_number':509,'multiline':True]
['text':'
     * Always increase the size in sequence of cache, btree, and page as we may race with other
     * threads that are trying to decrease the sizes concurrently.
     *
     * Take care to read the memory_footprint once in case we are racing with updates.
     ','line_number':523,'multiline':True]
['text':'
 * __wt_cache_dirty_decr --
 *     Page switch from dirty to clean: decrement the cache dirty page/byte counts.
 ','line_number':546,'multiline':True]
['text':'
 * __wt_cache_page_image_decr --
 *     Decrement a page image's size to the cache.
 ','line_number':569,'multiline':True]
['text':'
 * __wt_cache_page_image_incr --
 *     Increment a page image's size to the cache.
 ','line_number':588,'multiline':True]
['text':'
 * __wt_cache_page_evict --
 *     Evict pages from the cache.
 ','line_number':604,'multiline':True]
['text':' Update the bytes in-memory to reflect the eviction. ','line_number':619,'multiline':True]
['text':' Update the bytes_internal value to reflect the eviction ','line_number':625,'multiline':True]
['text':' Update the cache's dirty-byte count. ','line_number':633,'multiline':True]
['text':' Update the cache's updates-byte count. ','line_number':648,'multiline':True]
['text':' Update bytes and pages evicted. ','line_number':656,'multiline':True]
['text':'
     * Track if eviction makes progress. This is used in various places to determine whether
     * eviction is stuck.
     ','line_number':660,'multiline':True]
['text':'
 * __wt_update_list_memsize --
 *     The size in memory of a list of updates.
 ','line_number':668,'multiline':True]
['text':'
 * __wt_page_modify_init --
 *     A page is about to be modified, allocate the modification structure.
 ','line_number':683,'multiline':True]
['text':'
 * __wt_page_only_modify_set --
 *     Mark the page (but only the page) dirty.
 ','line_number':693,'multiline':True]
['text':'
     * We depend on the atomic operation being a write barrier, that is, a barrier to ensure all
     * changes to the page are flushed before updating the page state and/or marking the tree dirty,
     * otherwise checkpoints and/or page reconciliation might be looking at a clean page/tree.
     *
     * Every time the page transitions from clean to dirty, update the cache and transactional
     * information.
     *
     * The page state can only ever be incremented above dirty by the number of concurrently running
     * threads, so the counter will never approach the point where it would wrap.
     ','line_number':711,'multiline':True]
['text':'
         * In the event we dirty a page which is flagged for eviction soon, we update its read
         * generation to avoid evicting a dirty page prematurely.
         ','line_number':725,'multiline':True]
['text':'
         * We won the race to dirty the page, but another thread could have committed in the
         * meantime, and the last_running field been updated past it. That is all very unlikely, but
         * not impossible, so we take care to read the global state before the atomic increment.
         *
         * If the page was dirty on entry, then last_running == 0. The page could have become clean
         * since then, if reconciliation completed. In that case, we leave the previous value for
         * first_dirty_txn rather than potentially racing to update it, at worst, we'll
         * unnecessarily write a page in a checkpoint.
         ','line_number':732,'multiline':True]
['text':' Check if this is the largest transaction ID to update the page. ','line_number':746,'multiline':True]
['text':'
 * __wt_tree_modify_set --
 *     Mark the tree dirty.
 ','line_number':751,'multiline':True]
['text':'
     * Test before setting the dirty flag, it's a hot cache line.
     *
     * The tree's modified flag is cleared by the checkpoint thread: set it and insert a barrier
     * before dirtying the page. (I don't think it's a problem if the tree is marked dirty with all
     * the pages clean, it might result in an extra checkpoint that doesn't do any work but it
     * shouldn't cause problems; regardless, let's play it safe.)
     ','line_number':758,'multiline':True]
['text':' Assert we never dirty a checkpoint handle. ','line_number':767,'multiline':True]
['text':'
         * There is a potential race where checkpoint walks the tree and marks it as clean before a
         * page is subsequently marked as dirty, leaving us with a dirty page on a clean tree. Yield
         * here to encourage this scenario and ensure we're handling it correctly.
         ','line_number':773,'multiline':True]
['text':'
     * The btree may already be marked dirty while the connection is still clean; mark the
     * connection dirty outside the test of the btree state.
     ','line_number':781,'multiline':True]
['text':'
 * __wt_page_modify_clear --
 *     Clean a modified page.
 ','line_number':789,'multiline':True]
['text':'
     * The page must be held exclusive when this call is made, this call can only be used when the
     * page is owned by a single thread.
     *
     * Allow the call to be made on clean pages.
     ','line_number':796,'multiline':True]
['text':'
         * The only part where ordering matters is during reconciliation where updates on other
         * threads are performing writes to the page state that need to be visible to the
         * reconciliation thread.
         *
         * Since clearing of the page state is not going to be happening during reconciliation on a
         * separate thread, there's no write barrier needed here.
         ','line_number':808,'multiline':True]
['text':'
 * __wt_page_modify_set --
 *     Mark the page and tree dirty.
 ','line_number':822,'multiline':True]
['text':'
     * Prepared records in the datastore require page updates, even for read-only handles, don't
     * mark the tree or page dirty.
     ','line_number':829,'multiline':True]
['text':'
     * Mark the tree dirty (even if the page is already marked dirty), newly created pages to
     * support "empty" files are dirty, but the file isn't marked dirty until there's a real change
     * needing to be written.
     ','line_number':836,'multiline':True]
['text':'
     * We need to make sure a checkpoint doesn't come through and mark the tree clean before we have
     * a chance to mark the page dirty. Otherwise, the checkpoint may also visit the page before it
     * is marked dirty and skip it without also marking the tree clean. Worst case scenario with
     * this approach is that a future checkpoint reviews the tree again unnecessarily - however, it
     * is likely this is necessary since the update triggering this modify set would not be included
     * in the checkpoint. If hypothetically a checkpoint came through after the page was modified
     * and before the tree is marked dirty again, that is fine. The transaction installing this
     * update wasn't visible to the checkpoint, so it's reasonable for the tree to remain dirty.
     ','line_number':845,'multiline':True]
['text':'
 * __wt_page_parent_modify_set --
 *     Mark the parent page, and optionally the tree, dirty.
 ','line_number':858,'multiline':True]
['text':'
     * This function exists as a place to stash this comment. There are a few places where we need
     * to dirty a page's parent. The trick is the page's parent might split at any point, and the
     * page parent might be the wrong parent at any particular time. We ignore this and dirty
     * whatever page the page's reference structure points to. This is safe because if we're
     * pointing to the wrong parent, that parent must have split, deepening the tree, which implies
     * marking the original parent and all of the newly-created children as dirty. In other words,
     * if we have the wrong parent page, everything was marked dirty already.
     ','line_number':867,'multiline':True]
['text':'
 * __wt_off_page --
 *     Return if a pointer references off-page data.
 ','line_number':885,'multiline':True]
['text':'
     * There may be no underlying page, in which case the reference is off-page by definition.
     ','line_number':892,'multiline':True]
['text':'
 * __wt_ref_key --
 *     Return a reference to a row-store internal page key as cheaply as possible.
 ','line_number':899,'multiline':True]
['text':'
 * An internal page key is in one of two places: if we instantiated the
 * key (for example, when reading the page), WT_REF.ref_ikey references
 * a WT_IKEY structure, otherwise WT_REF.ref_ikey references an on-page
 * key offset/length pair.
 *
 * Now the magic: allocated memory must be aligned to store any standard
 * type, and we expect some standard type to require at least quad-byte
 * alignment, so allocated memory should have some clear low-order bits.
 * On-page objects consist of an offset/length pair: the maximum page
 * size currently fits into 29 bits, so we use the low-order bits of the
 * pointer to mark the other bits of the pointer as encoding the key's
 * location and length.  This breaks if allocated memory isn't aligned,
 * of course.
 *
 * In this specific case, we use bit 0x01 to mark an on-page key, else
 * it's a WT_IKEY reference.  The bit pattern for internal row-store
 * on-page keys is:
 *	32 bits		key length
 *	31 bits		page offset of the key's bytes,
 *	 1 bits		flags
 ','line_number':908,'multiline':True]
['text':'
 * __wt_ref_key_onpage_set --
 *     Set a WT_REF to reference an on-page key.
 ','line_number':945,'multiline':True]
['text':'
     * See the comment in __wt_ref_key for an explanation of the magic.
     ','line_number':954,'multiline':True]
['text':'
 * __wt_ref_key_instantiated --
 *     Return if a WT_REF key is instantiated.
 ','line_number':962,'multiline':True]
['text':'
     * See the comment in __wt_ref_key for an explanation of the magic.
     ','line_number':971,'multiline':True]
['text':'
 * __wt_ref_key_clear --
 *     Clear a WT_REF key.
 ','line_number':978,'multiline':True]
['text':'
     * The key union has 2 8B fields; this is equivalent to:
     *
     *	ref->ref_recno = WT_RECNO_OOB;
     *	ref->ref_ikey = NULL;
     ','line_number':985,'multiline':True]
['text':'
 * __wt_row_leaf_key_info --
 *     Return a row-store leaf page key referenced by a WT_ROW if it can be had without unpacking a
 *     cell, and information about the cell, if the key isn't cheaply available.
 ','line_number':994,'multiline':True]
['text':'
     * A row-store leaf page key is in one of two places: if instantiated, the WT_ROW pointer
     * references a WT_IKEY structure, otherwise, it references an on-page item. Further, on-page
     * items are in one of two states: if the key is a simple key (not an overflow key, which is
     * likely), the key's offset, size and prefix is encoded in the 8B of pointer. Otherwise, the
     * offset is to the key's on-page cell.
     *
     * This function returns information from a set of things about the key (WT_IKEY reference, cell
     * reference and/or key/length/prefix triplet). Our callers know the order we resolve items and
     * what information will be returned. Specifically, the caller gets a key (in the form of a
     * pointer to the bytes, a length and a prefix length in all cases where we can get it without
     * unpacking a cell), plus an optional WT_IKEY reference, and in all cases, a pointer to the
     * on-page cell. Our caller's test is generally if there is a returned key or not, falling back
     * to the returned cell.
     *
     * Now the magic: allocated memory must be aligned to store any standard type and we expect some
     * standard type to require at least quad-byte alignment, so allocated memory should have two
     * clear low-order bits. On-page objects consist of an offset/length pair and a prefix in the
     * case of a key: the maximum page size is 29 bits (512MB), the remaining bits hold the key or
     * value location and bytes. This breaks if allocated memory isn't aligned, of course.
     *
     * In this specific case, we use bit 0x01 to mark an on-page cell, bit 0x02 to mark an on-page
     * key, 0x03 to mark an on-page key/value pair, otherwise it's a WT_IKEY reference. The bit
     * pattern for on-page cells is:
     *
     *  29 bits		offset of the key's cell (512MB)
     *   2 bits		0x01 flag
     *
     * The on-page cell is our fallback: if a key or value won't fit into our encoding (unlikely,
     * but possible), we fall back to using a cell reference, which obviously has enough room for
     * all possible values.
     *
     * The next encoding is for on-page keys:
     *
     *  19 bits		key's length (512KB)
     *   6 bits		offset of the key's bytes from the key's cell (32B)
     *   8 bits		key's prefix length (256B, the maximum possible value)
     *  29 bits		offset of the key's cell (512MB)
     *   2 bits		0x02 flag
     *
     * But, while that allows us to skip decoding simple key cells, we also want to skip decoding
     * value cells in the case where the value cell is also simple/short. We use bit 0x03 to mark
     * an encoded on-page key and value pair. The encoding for on-page key/value pairs is:
     *
     *  13 bits		value's length (8KB)
     *   6 bits		offset of the value's bytes from the end of the key's cell (32B)
     *  12 bits		key's length (4KB)
     *   6 bits		offset of the key's bytes from the key's cell (32B)
     *   8 bits		key's prefix length (256B, the maximum possible value)
     *  17 bits		offset of the key's cell (128KB)
     *   2 bits		0x03 flag
     *
     * A reason for the complexity here is we need to be able to find the key and value cells from
     * the encoded form: for that reason we store an offset to the key cell plus a second offset to
     * the start of the key's bytes. Finding the value cell is reasonably straight-forward, we use
     * the location of the key to find the cell immediately following the key.
     *
     * A simple extension of this encoding would be to encode zero-length values similarly to how we
     * encode short values. However, zero-length values are noted by adjacent key cells on the page,
     * and we detect that without decoding the second cell by checking the cell's type byte. Tests
     * indicate it's slightly slower to encode missing value cells than to check the cell type, so
     * we don't bother with the encoding.
     *
     * Generally, the bitfields are expected to be larger than the stored items (4/8KB keys/values,
     * 128KB pages), but the underlying limits are larger and we can see items we cannot encode in
     * this way.  For example, if an application creates pages larger than 128KB, encoded key/value
     * offsets after the maximum offset (the offsets of cells at the end of the page), couldn't be
     * encoded. If that's not working, these bit patterns can be changed as they are in-memory only
     * (we could even tune for specific workloads in specific trees).
     ','line_number':1008,'multiline':True]
['text':' key cell offset field size can hold maximum value, WT_CELL_MAX_KEY_CELL_OFFSET not needed. ','line_number':1081,'multiline':True]
['text':' Key prefix field size can hold maximum value, WT_K_MAX_KEY_PREFIX not needed. ','line_number':1092,'multiline':True]
['text':' Key cell offset field size can hold maximum value, WT_K_MAX_KEY_CELL_OFFSET not needed. ','line_number':1095,'multiline':True]
['text':' Key offset encoding is the same for key and key/value forms, WT_KV_MAX_KEY_OFFSET not needed. ','line_number':1109,'multiline':True]
['text':' Key prefix encoding is the same for key and key/value forms, WT_KV_MAX_KEY_PREFIX not needed. ','line_number':1112,'multiline':True]
['text':' On-page cell. ','line_number':1120,'multiline':True]
['text':' Encoded key. ','line_number':1131,'multiline':True]
['text':' Encoded key/value pair. ','line_number':1143,'multiline':True]
['text':' Instantiated key. ','line_number':1155,'multiline':True]
['text':'
 * __wt_row_leaf_key_set --
 *     Set a WT_ROW to reference an on-page row-store leaf key.
 ','line_number':1172,'multiline':True]
['text':'
     * See the comment in __wt_row_leaf_key_info for an explanation of the magic.
     *
     * Not checking the prefix and cell offset sizes, the fields hold any legitimate value.
     ','line_number':1181,'multiline':True]
['text':'
 * __wt_row_leaf_value_set --
 *     Set a WT_ROW to reference an on-page row-store leaf key and value pair, if possible.
 ','line_number':1198,'multiline':True]
['text':' The row-store key can change underfoot; explicitly take a copy. ','line_number':1207,'multiline':True]
['text':'
     * See the comment in __wt_row_leaf_key_info for an explanation of the magic.
     *
     * Only encoded keys can be upgraded to encoded key/value pairs.
     ','line_number':1210,'multiline':True]
['text':' Key cell offset ','line_number':1218,'multiline':True]
['text':'
     * Not checking the prefix size, the field sizes are the same in both encodings.
     *
     * Not checking the key offset, the field sizes are the same in both encodings.
     ','line_number':1220,'multiline':True]
['text':' Key len ','line_number':1225,'multiline':True]
['text':' Value offset ','line_number':1229,'multiline':True]
['text':' Value length ','line_number':1232,'multiline':True]
['text':'
 * __wt_row_leaf_key_free --
 *     Discard any memory allocated for an instantiated key.
 ','line_number':1243,'multiline':True]
['text':' The row-store key can change underfoot; explicitly take a copy. ','line_number':1253,'multiline':True]
['text':'
     * If the key was a WT_IKEY allocation (that is, if it points somewhere other than the original
     * page), free the memory.
     ','line_number':1256,'multiline':True]
['text':'
 * __wt_row_leaf_key --
 *     Set a buffer to reference a row-store leaf page key as cheaply as possible.
 ','line_number':1264,'multiline':True]
['text':'
     * A front-end for __wt_row_leaf_key_work, here to inline fast paths.
     *
     * The row-store key can change underfoot; explicitly take a copy.
     ','line_number':1279,'multiline':True]
['text':'
     * Handle keys taken directly from the disk image (which should be a common case), instantiated
     * keys (rare initially, but possibly more common as leaf page search instantiates keys), and
     * keys built using the most-used page key prefix.
     *
     * The most-used page key prefix: the longest group of compressed key prefixes on the page that
     * can be built from a single, fully instantiated key on the page, was tracked when the page was
     * read. Build keys in that group by appending the key's bytes to the root key from which it was
     * compressed.
     ','line_number':1286,'multiline':True]
['text':' The row-store key can change underfoot; explicitly take a copy. ','line_number':1304,'multiline':True]
['text':'
     * The alternative is an on-page cell with some kind of compressed or overflow key that's never
     * been instantiated. Call the underlying worker function to figure it out.
     ','line_number':1316,'multiline':True]
['text':'
 * __wt_row_leaf_key_instantiate --
 *     Instantiate the keys on a leaf page as needed.
 ','line_number':1323,'multiline':True]
['text':'
     * Cursor previous traversals will be too slow in the case of a set of prefix-compressed keys
     * requiring long roll-forward processing. In the worst case, each key would require processing
     * every key appearing before it on the page as we walk backwards through the page. If we're
     * doing a cursor previous call, and this page has never been checked for excessively long
     * stretches of prefix-compressed keys, do it now.
     ','line_number':1341,'multiline':True]
['text':' Walk the keys, making sure there's something easy to work with periodically. ','line_number':1352,'multiline':True]
['text':'
         * Get the key's information. The row-store key can change underfoot; explicitly take a
         * copy.
         ','line_number':1355,'multiline':True]
['text':'
         * If the key isn't prefix compressed, or is a prefix-compressed key we can derive from the
         * group record, we're done.
         ','line_number':1362,'multiline':True]
['text':'
         * Skip overflow keys: we'll instantiate them on demand and they don't require any special
         * processing (but they don't help with long strings of prefix compressed keys, either, so
         * we'll likely want to instantiate the first key we find after a long stretch of overflow
         * keys). More importantly, we don't want to instantiate them for a cursor traversal, we
         * only want to instantiate them for a tree search, as that's likely to happen repeatedly.
         ','line_number':1373,'multiline':True]
['text':'
         * If we skip 10 keys, instantiate one, limiting how far we're forced to roll backward. (The
         * value 10 was chosen for no particular reason.) There are still cases where we might not
         * need to instantiate this key (for example, a key too large to be encoded, but still
         * on-page and not prefix-compressed). Let the underlying worker function figure that out,
         * we should have found the vast majority of cases by now.
         ','line_number':1385,'multiline':True]
['text':'
 * __wt_row_leaf_value_is_encoded --
 *     Return if the value for a row-store leaf page is an encoded key/value pair.
 ','line_number':1405,'multiline':True]
['text':' The row-store key can change underfoot; explicitly take a copy. ','line_number':1414,'multiline':True]
['text':'
     * See the comment in __wt_row_leaf_key_info for an explanation of the magic.
     ','line_number':1417,'multiline':True]
['text':'
 * __wt_row_leaf_value --
 *     Return the value for a row-store leaf page encoded key/value pair.
 ','line_number':1423,'multiline':True]
['text':' The row-store key can change underfoot; explicitly take a copy. ','line_number':1432,'multiline':True]
['text':'
         * See the comment in __wt_row_leaf_key_info for an explanation of the magic.
         *
         * Normally a value is represented by the value's cell in the disk image (or an update), but
         * there is a fast path for returning a simple value, where it's worth the additional effort
         * of encoding the value in the per-row reference and retrieving it. This function does that
         * work, while most value retrieval goes through the "return the unpacked cell" version.
         *
         * The value's data is the page offset of the key's cell, plus the key's offset, plus the
         * key's size, plus the value's offset: in other words, we know where the key's cell starts,
         * the key's data ends the key's cell, and the value cell immediately follows, Skip past the
         * key cell to the value cell, then skip to the start of the value's data.
         ','line_number':1436,'multiline':True]
['text':'
 * __wt_row_leaf_value_cell --
 *     Return the unpacked value for a row-store leaf page key.
 ','line_number':1457,'multiline':True]
['text':' The row-store key can change underfoot; explicitly take a copy. ','line_number':1470,'multiline':True]
['text':' We have a direct reference the key's cell, step past it to the value's cell. ','line_number':1476,'multiline':True]
['text':' We have an encoded on-page key, the value's cell follows the key's data. ','line_number':1480,'multiline':True]
['text':' We have an encoded on-page key/value pair, the value's cell follows the key's data. ','line_number':1485,'multiline':True]
['text':' We have an instantiated key, the key cell's offset is included in the structure. ','line_number':1490,'multiline':True]
['text':' If we only have the key cell, unpack it and skip past it to the value cell. ','line_number':1497,'multiline':True]
['text':'
 * WT_ADDR_COPY --
 *	We have to lock the WT_REF to look at a WT_ADDR: a structure we can use to quickly get a
 * copy of the WT_REF address information.
 ','line_number':1506,'multiline':True]
['text':' Fast-truncate page information ','line_number':1519,'multiline':True]
['text':'
 * __wt_ref_addr_copy --
 *     Return a copy of the WT_REF address information.
 ','line_number':1523,'multiline':True]
['text':'
     * To look at an on-page cell, we need to look at the parent page's disk image, and that can be
     * dangerous. The problem is if the parent page splits, deepening the tree. As part of that
     * process, the WT_REF WT_ADDRs pointing into the parent's disk image are copied into off-page
     * WT_ADDRs and swapped into place. The content of the two WT_ADDRs are identical, and we don't
     * care which version we get as long as we don't mix-and-match the two.
     ','line_number':1538,'multiline':True]
['text':' If NULL, there is no information. ','line_number':1547,'multiline':True]
['text':' If off-page, the pointer references a WT_ADDR structure. ','line_number':1551,'multiline':True]
['text':'
         * FIXME-WT-11062 - We've checked that ref->addr is non-null a few lines above and we only
         * enter this function when the page is on-disk or clean. However, it is possible that once
         * we've entered this function the page gets dirtied *and* reconciled. If this happens for a
         * page with rec_result == 0 we will free the addr being copied - possibly after the null
         * check above - and this function will attempt to copy from freed memory.
         ','line_number':1555,'multiline':True]
['text':' If on-page, the pointer references a cell. ','line_number':1567,'multiline':True]
['text':' Copy out any fast-truncate information. ','line_number':1579,'multiline':True]
['text':' It's a legacy page; create default delete information. ','line_number':1584,'multiline':True]
['text':' FALLTHROUGH ','line_number':1591,'multiline':True]
['text':'
 * __wt_ref_block_free --
 *     Free the on-disk block for a reference and clear the address.
 ','line_number':1600,'multiline':True]
['text':' Clear the address (so we don't free it twice). ','line_number':1614,'multiline':True]
['text':'
 * __wt_page_del_visible_all --
 *     Check if a truncate operation is visible to everyone and the data under it is obsolete.
 ','line_number':1619,'multiline':True]
['text':'
     * Like other visible_all checks, use the durable timestamp to avoid complications: there is
     * potentially a window where a prepared and committed transaction can be visible but not yet
     * durable, and in that window the changes under it are not obsolete yet.
     *
     * The hide_prepared argument causes prepared but not committed transactions to be treated as
     * invisible. (Apparently prepared and uncommitted transactions can be visible_all, but we need
     * to not see them in some cases; for example, prepared deletions can't exist on disk because
     * the on-disk format doesn't have space for the extra "I'm prepared" bit, so we avoid seeing
     * them in reconciliation. Similarly, we can't skip over a page just because a transaction has
     * deleted it and prepared; only committed transactions are suitable.)
     *
     * In all cases, the ref owning the page_deleted structure should be locked and its pre-lock
     * state should be WT_REF_DELETED. This prevents the page from being instantiated while we look
     * at it, and locks out other operations that might simultaneously discard the structure (either
     * after checking visibility, or because its transaction aborted).
     ','line_number':1628,'multiline':True]
['text':' If the page delete info is NULL, the deletion was previously found to be globally visible. ','line_number':1646,'multiline':True]
['text':' We discard page_del on transaction abort, so should never see an aborted one. ','line_number':1650,'multiline':True]
['text':'
 * __wt_page_del_visible --
 *     Return if a truncate operation is visible to the caller. The same considerations apply as in
 *     the visible_all version.
 ','line_number':1662,'multiline':True]
['text':' If the page delete info is NULL, the deletion was previously found to be globally visible. ','line_number':1672,'multiline':True]
['text':' We discard page_del on transaction abort, so should never see an aborted one. ','line_number':1676,'multiline':True]
['text':'
 * __wt_page_del_committed_set --
 *     Return if a truncate operation is resolved. (Since truncations that abort are removed
 *     immediately, "resolved" and "committed" are equivalent here.) The caller should have already
 *     locked the ref and confirmed that the ref's previous state was WT_REF_DELETED. The page_del
 *     argument should be the ref's page_del member. This function should only be used for pages in
 *     WT_REF_DELETED state. For deleted pages that have been instantiated in memory, the update
 *     list in the page modify structure should be checked instead, as the page_del structure might
 *     have been discarded already. (The update list is non-null if the transaction is unresolved.)
 ','line_number':1689,'multiline':True]
['text':'
     * There are two possible cases: either page_del is NULL (in which case the deletion is globally
     * visible and must have been committed) or it is not, in which case page_del->committed tells
     * us what we want to know.
     ','line_number':1702,'multiline':True]
['text':'
 * __wt_btree_syncing_by_other_session --
 *     Returns true if the session's current btree is being synced by another thread.
 ','line_number':1714,'multiline':True]
['text':'
 * __wt_leaf_page_can_split --
 *     Check whether a page can be split in memory.
 ','line_number':1728,'multiline':True]
['text':'
     * Checkpoints can't do in-memory splits in the tree they are walking: that can lead to
     * corruption when the parent internal page is updated.
     ','line_number':1743,'multiline':True]
['text':'
     * Only split a page once, otherwise workloads that update in the middle of the page could
     * continually split without benefit.
     ','line_number':1750,'multiline':True]
['text':'
     * Check for pages with append-only workloads. A common application pattern is to have multiple
     * threads frantically appending to the tree. We want to reconcile and evict this page, but we'd
     * like to do it without making the appending threads wait. See if it's worth doing a split to
     * let the threads continue before doing eviction.
     *
     * Ignore anything other than large, dirty leaf pages. We depend on the page being dirty for
     * correctness (the page must be reconciled again before being evicted after the split,
     * information from a previous reconciliation will be wrong, so we can't evict immediately).
     ','line_number':1757,'multiline':True]
['text':'
     * There is no point doing an in-memory split unless there is a lot of data in the last skiplist
     * on the page. Split if there are enough items and the skiplist does not fit within a single
     * disk page.
     ','line_number':1774,'multiline':True]
['text':'
 * In the extreme case, where the page is much larger than the maximum size, split as soon as there
 * are 5 items on the page.
 ','line_number':1786,'multiline':True]
['text':'
 * Rather than scanning the whole list, walk a higher level, which gives a sample of the items -- at
 * level 0 we have all the items, at level 1 we have 1/4 and at level 2 we have 1/16th. If we see
 * more than 30 items and more data than would fit in a disk page, split.
 ','line_number':1803,'multiline':True]
['text':' At level 2, we see 1/16th entries ','line_number':1810,'multiline':True]
['text':'
         * Account for the case where the maximum in-memory page size is configured to be smaller
         * than the maximum on-disk page size. Even with that configuration it is beneficial to be
         * able to in-memory split for append workloads, and allow the reconciliation to happen in a
         * background thread.
         ','line_number':1817,'multiline':True]
['text':'
 * __wt_page_evict_retry --
 *     Avoid busy-spinning attempting to evict the same page all the time.
 ','line_number':1832,'multiline':True]
['text':'
     * If the page hasn't been through one round of update/restore, give it a try.
     ','line_number':1845,'multiline':True]
['text':'
     * Retry if a reasonable amount of eviction time has passed, the choice of 5 eviction passes as
     * a reasonable amount of time is currently pretty arbitrary.
     ','line_number':1851,'multiline':True]
['text':' Retry if the global transaction state has moved forward. ','line_number':1859,'multiline':True]
['text':'
     * It is possible that we have not started using the timestamps just yet. So, check for the last
     * time we evicted only if there is a timestamp set.
     ','line_number':1864,'multiline':True]
['text':'
 * __wt_page_can_evict --
 *     Check whether a page can be evicted.
 ','line_number':1877,'multiline':True]
['text':' Pages without modify structures can always be evicted, it's just discarding a disk image. ','line_number':1894,'multiline':True]
['text':'
     * Check the fast-truncate information. Pages with an uncommitted truncate cannot be evicted.
     *
     * Because the page is in memory, we look at mod.inst_updates. If it's not NULL, that means the
     * truncate operation isn't committed.
     *
     * The list of updates in mod.inst_updates will be discarded when the transaction they belong to
     * is resolved.
     *
     * Note that we are not using __wt_page_del_committed here because (a) examining the page_del
     * structure requires locking the ref, and (b) once in memory the page_del structure only
     * remains until the next reconciliation, and nothing prevents that from occurring before the
     * transaction commits.
     ','line_number':1898,'multiline':True]
['text':'
     * We can't split or evict multiblock row-store pages where the parent's key for the page is an
     * overflow item, because the split into the parent frees the backing blocks for no-longer-used
     * overflow keys, which will corrupt the checkpoint's block management. (This is only for
     * historical tables, reconciliation no longer writes overflow cookies on internal pages, no
     * matter the size of the key.)
     ','line_number':1917,'multiline':True]
['text':'
     * Check for in-memory splits before other eviction tests. If the page should split in-memory,
     * return success immediately and skip more detailed eviction tests. We don't need further tests
     * since the page won't be written or discarded from the cache.
     ','line_number':1930,'multiline':True]
['text':'
     * If the file is being checkpointed, other threads can't evict dirty pages: if a page is
     * written and the previous version freed, that previous version might be referenced by an
     * internal page already written in the checkpoint, leaving the checkpoint inconsistent.
     ','line_number':1943,'multiline':True]
['text':'
     * Check we are not evicting an accessible internal page with an active split generation.
     *
     * If a split created new internal pages, those newly created internal pages cannot be evicted
     * until all threads are known to have exited the original parent page's index, because evicting
     * an internal page discards its WT_REF array, and a thread traversing the original parent page
     * index might see a freed WT_REF.
     *
     * One special case where we know this is safe is if the handle is dead or locked exclusively,
     * that is, no readers can be looking at an old index.
     ','line_number':1953,'multiline':True]
['text':' If the metadata page is clean but has modifications that appear too new to evict, skip it. ','line_number':1971,'multiline':True]
['text':'
     * FIXME-WT-12127 Allow pages on the pre-fetch queue to be considered for eviction once a
     * satisfactory workaround has been found for ensuring certain eviction flows don't invalidate
     * refs on the pre-fetch queue.
     ','line_number':1978,'multiline':True]
['text':'
 * __wt_page_release --
 *     Release a reference to a page.
 ','line_number':1989,'multiline':True]
['text':'
     * Discard our hazard pointer. Ignore pages we don't have and the root page, which sticks in
     * memory, regardless.
     ','line_number':2002,'multiline':True]
['text':'
     * If hazard pointers aren't necessary for this file, we can't be evicting, we're done.
     ','line_number':2009,'multiline':True]
['text':'
     * If the session is configured with the release_evict_pages debug option, we will attempt to
     * evict the pages when they are no longer needed.
     ','line_number':2015,'multiline':True]
['text':'
         * If the operation has disabled eviction or splitting, or the session is preventing from
         * reconciling, then just queue the page for urgent eviction. Otherwise, attempt to release
         * and evict it.
         ','line_number':2025,'multiline':True]
['text':'
 * __wt_skip_choose_depth --
 *     Randomly choose a depth for a skiplist insert.
 ','line_number':2042,'multiline':True]
['text':' Go from 1/4 chance of having a link to the next element to ~90%. ','line_number':2053,'multiline':True]
['text':' ~90% of the value of uint32 max. ','line_number':2055,'multiline':True]
['text':'
 * __wt_btree_lsm_over_size --
 *     Return if the size of an in-memory tree with a single leaf page is over a specified maximum.
 *     If called on anything other than a simple tree with a single leaf page, returns true so our
 *     LSM caller will switch to a new tree.
 ','line_number':2063,'multiline':True]
['text':' Check for a non-existent tree. ','line_number':2080,'multiline':True]
['text':' A tree that can be evicted always requires a switch. ','line_number':2084,'multiline':True]
['text':' Check for a tree with a single leaf page. ','line_number':2088,'multiline':True]
['text':' > 1 child page, switch ','line_number':2090,'multiline':True]
['text':' no child page, ignore ','line_number':2094,'multiline':True]
['text':'
     * We're reaching down into the page without a hazard pointer, but that's OK because we know
     * that no-eviction is set and so the page cannot disappear.
     ','line_number':2097,'multiline':True]
['text':' not a single leaf page ','line_number':2102,'multiline':True]
['text':'
 * __wt_split_descent_race --
 *     Return if we raced with an internal page split when descending the tree.
 ','line_number':2108,'multiline':True]
['text':' No test when starting the descent (there's no home to check). ','line_number':2117,'multiline':True]
['text':'
     * A place to hang this comment...
     *
     * There's a page-split race when we walk the tree: if we're splitting
     * an internal page into its parent, we update the parent's page index
     * before updating the split page's page index, and it's not an atomic
     * update. A thread can read the parent page's original page index and
     * then read the split page's replacement index.
     *
     * For example, imagine a search descending the tree.
     *
     * Because internal page splits work by truncating the original page to
     * the initial part of the original page, the result of this race is we
     * will have a search key that points past the end of the current page.
     * This is only an issue when we search past the end of the page, if we
     * find a WT_REF in the page with the namespace we're searching for, we
     * don't care if the WT_REF moved or not while we were searching, we
     * have the correct page.
     *
     * For example, imagine an internal page with 3 child pages, with the
     * namespaces a-f, g-h and i-j; the first child page splits. The parent
     * starts out with the following page-index:
     *
     *	| ... | a | g | i | ... |
     *
     * which changes to this:
     *
     *	| ... | a | c | e | g | i | ... |
     *
     * The child starts out with the following page-index:
     *
     *	| a | b | c | d | e | f |
     *
     * which changes to this:
     *
     *	| a | b |
     *
     * The thread searches the original parent page index for the key "cat",
     * it couples to the "a" child page; if it uses the replacement child
     * page index, it will search past the end of the page and couple to the
     * "b" page, which is wrong.
     *
     * To detect the problem, we remember the parent page's page index used
     * to descend the tree. Whenever we search past the end of a page, we
     * check to see if the parent's page index has changed since our use of
     * it during descent. As the problem only appears if we read the split
     * page's replacement index, the parent page's index must already have
     * changed, ensuring we detect the problem.
     *
     * It's possible for the opposite race to happen (a thread could read
     * the parent page's replacement page index and then read the split
     * page's original index). This isn't a problem because internal splits
     * work by truncating the split page, so the split page search is for
     * content the split page retains after the split, and we ignore this
     * race.
     *
     * This code is a general purpose check for a descent race and we call
     * it in other cases, for example, a cursor traversing backwards through
     * the tree.
     *
     * Presumably we acquired a page index on the child page before calling
     * this code, don't re-order that acquisition with this check.
     ','line_number':2121,'multiline':True]
['text':'
 * __wt_page_swap_func --
 *     Swap one page's hazard pointer for another one when hazard pointer coupling up/down the tree.
 ','line_number':2189,'multiline':True]
['text':'
     * This function is here to simplify the error handling during hazard pointer coupling so we
     * never leave a hazard pointer dangling. The assumption is we're holding a hazard pointer on
     * "held", and want to acquire a hazard pointer on "want", releasing the hazard pointer on
     * "held" when we're done.
     *
     * When walking the tree, we sometimes swap to the same page. Fast-path that to avoid thinking
     * about error handling.
     ','line_number':2204,'multiline':True]
['text':' Get the wanted page. ','line_number':2216,'multiline':True]
['text':'
     * Expected failures: page not found or restart. Our callers list the errors they're expecting
     * to handle.
     ','line_number':2224,'multiline':True]
['text':' Discard the original held page on either success or error. ','line_number':2233,'multiline':True]
['text':' Fast-path expected success. ','line_number':2237,'multiline':True]
['text':'
     * If there was an error at any point that our caller isn't prepared to handle, discard any page
     * we acquired.
     ','line_number':2241,'multiline':True]
['text':'
     * If we're returning an error, don't let it be one our caller expects to handle as returned by
     * page-in: the expectation includes the held page not having been released, and that's not the
     * case.
     ','line_number':2248,'multiline':True]
['text':'
 * __wt_btcur_bounds_early_exit --
 *     Performs bound comparison to check if the key is within bounds, if not, increment the
 *     appropriate stat, early exit, and return WT_NOTFOUND.
 ','line_number':2261,'multiline':True]
['text':'
 * __wt_btcur_skip_page --
 *     Return if the cursor is pointing to a page with deleted records and can be skipped for cursor
 *     traversal.
 ','line_number':2288,'multiline':True]
['text':' Default to reading ','line_number':2304,'multiline':True]
['text':' Don't skip pages in FLCS trees; deleted records need to read back as 0. ','line_number':2308,'multiline':True]
['text':'
     * Determine if all records on the page have been deleted and all the tombstones are visible to
     * our transaction. If so, we can avoid reading the records on the page and move to the next
     * page.
     *
     * Skip this test on an internal page, as we rely on reconciliation to mark the internal page
     * dirty. There could be a period of time when the internal page is marked clean but the leaf
     * page is dirty and has newer data than let on by the internal page's aggregated information.
     ','line_number':2312,'multiline':True]
['text':'
     * We are making these decisions while holding a lock for the page as checkpoint or eviction can
     * make changes to the data structures (i.e., aggregate timestamps) we are reading.
     ','line_number':2324,'multiline':True]
['text':'
     * Check the fast-truncate information; there are 3 cases:
     *
     * (1) The page is in the WT_REF_DELETED state and page_del is NULL. The page is deleted. This
     *     case is folded into the next because __wt_page_del_visible handles it.
     * (2) The page is in the WT_REF_DELETED state and page_del is not NULL. The page is deleted
     *     if the truncate operation is visible. Look at page_del; we could use the info from the
     *     address cell below too, but that's slower.
     * (3) The page is in memory and has been instantiated. The delete info from the address cell
     *     will serve for readonly/unmodified pages, and for modified pages we can't skip the page.
     *     (This case is checked further below.)
     *
     * In all cases, make use of the option to __wt_page_del_visible to hide prepared transactions,
     * as we shouldn't skip pages where the deletion is prepared but not committed.
     ','line_number':2330,'multiline':True]
['text':'
     * Look at the disk address, if it exists, and if the page is unmodified. We must skip this test
     * if the page has been modified since it was reconciled, since neither the delete information
     * nor the timestamp information is necessarily up to date.
     ','line_number':2350,'multiline':True]
['text':' If there's delete information in the disk address, we can use it. ','line_number':2358,'multiline':True]
['text':'
         * Otherwise, check the timestamp information. We base this decision on the aggregate stop
         * point added to the page during the last reconciliation.
         ','line_number':2364,'multiline':True]
