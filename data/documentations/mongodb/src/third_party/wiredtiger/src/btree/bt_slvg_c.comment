['text':'-
 * Copyright (c) 2014-present MongoDB, Inc.
 * Copyright (c) 2008-2014 WiredTiger, Inc.
 *	All rights reserved.
 *
 * See the file LICENSE for redistribution information.
 ','line_number':1,'multiline':True]
['text':'
 * There's a bunch of stuff we pass around during salvage, group it together to make the code
 * prettier.
 ','line_number':18,'multiline':True]
['text':' Salvage session ','line_number':23,'multiline':True]
['text':' Pages ','line_number':25,'multiline':True]
['text':' Next empty slot ','line_number':26,'multiline':True]
['text':' Bytes allocated ','line_number':27,'multiline':True]
['text':' Overflow pages ','line_number':29,'multiline':True]
['text':' Next empty slot ','line_number':30,'multiline':True]
['text':' Bytes allocated ','line_number':31,'multiline':True]
['text':' Created root page ','line_number':33,'multiline':True]
['text':' Page type ','line_number':35,'multiline':True]
['text':' If need to free blocks backing merged page ranges. ','line_number':37,'multiline':True]
['text':' Verbose print buffer ','line_number':40,'multiline':True]
['text':' Verbose print buffer ','line_number':41,'multiline':True]
['text':' Progress counter ','line_number':43,'multiline':True]
['text':'
 * WT_TRACK_SHARED --
 *	Information shared between pages being merged.
 ','line_number':46,'multiline':True]
['text':' Reference count ','line_number':51,'multiline':True]
['text':'
     * Physical information about the file block.
     ','line_number':53,'multiline':True]
['text':' Timestamp information ','line_number':56,'multiline':True]
['text':' Page address ','line_number':57,'multiline':True]
['text':' Page size ','line_number':58,'multiline':True]
['text':' Page generation ','line_number':59,'multiline':True]
['text':'
     * Pages that reference overflow pages contain a list of the overflow pages they reference. We
     * start out with a list of addresses, and convert to overflow array slots during the
     * reconciliation of page references to overflow records.
     ','line_number':61,'multiline':True]
['text':' Overflow pages by address ','line_number':66,'multiline':True]
['text':' Overflow pages by slot ','line_number':67,'multiline':True]
['text':' Overflow reference count ','line_number':68,'multiline':True]
['text':'
 * WT_TRACK --
 *	Structure to track chunks, one per chunk; we start out with a chunk per
 * page (either leaf or overflow), but when we find overlapping key ranges, we
 * split the leaf page chunks up, one chunk for each unique key range.
 ','line_number':71,'multiline':True]
['text':' Shared information ','line_number':86,'multiline':True]
['text':' Enclosing stuff ','line_number':88,'multiline':True]
['text':' Row-store start range ','line_number':94,'multiline':True]
['text':' Row-store stop range ','line_number':97,'multiline':True]
['text':' Col-store start range ','line_number':103,'multiline':True]
['text':' Col-store stop range ','line_number':106,'multiline':True]
['text':' Col-store missing range ','line_number':109,'multiline':True]
['text':' AUTOMATIC FLAG VALUE GENERATION START 0 ','line_number':113,'multiline':True]
['text':' Row: initial key updated ','line_number':114,'multiline':True]
['text':' Row: last key updated ','line_number':115,'multiline':True]
['text':' Page requires merging ','line_number':116,'multiline':True]
['text':' Overflow page referenced ','line_number':117,'multiline':True]
['text':' AUTOMATIC FLAG VALUE GENERATION STOP 32 ','line_number':118,'multiline':True]
['text':'
 * __slvg_checkpoint --
 *     Create the post-salvage checkpoint.
 ','line_number':157,'multiline':True]
['text':'
     * XXX The salvage process reads and discards previous checkpoints, so the underlying block
     * manager has to ignore any previous checkpoint entries when creating a new checkpoint. In
     * other words, we can't use the metadata checkpoint list, it lists the previous checkpoints and
     * we don't care about them. Build a clean checkpoint list and use it instead.
     *
     * Don't first clear the metadata checkpoint list and call the function to get a list of
     * checkpoints: a crash between clearing the metadata checkpoint list and creating a new
     * checkpoint list would look like a create or open of a file without a checkpoint to
     * roll-forward from, and the contents of the file would be discarded.
     ','line_number':175,'multiline':True]
['text':'
     * We may not have found any pages during salvage and there's no tree to flush.
     ','line_number':194,'multiline':True]
['text':' Make sure that the saved checkpoint information has been cleared. ','line_number':198,'multiline':True]
['text':'
     * If no checkpoint was created, clear all recorded checkpoints for the file. This is expected
     * if we didn't find any leaf pages to salvage.
     *
     * If a checkpoint was created, life is good, replace any existing list of checkpoints with the
     * single new one.
     ','line_number':208,'multiline':True]
['text':'
 * __wt_salvage --
 *     Salvage a Btree.
 ','line_number':226,'multiline':True]
['text':' Allocate temporary buffers. ','line_number':249,'multiline':True]
['text':'
     * !!! (Don't format the comment.)
     * Step 1:
     * Inform the underlying block manager that we're salvaging the file.
     ','line_number':253,'multiline':True]
['text':'
     * !!! (Don't format the comment.)
     * Step 2:
     * Read the file and build in-memory structures that reference any leaf or overflow page. Any
     * pages other than leaf or overflow pages are added to the free list.
     *
     * Turn off read checksum and verification error messages while we're reading the file, we
     * expect to see corrupted blocks.
     ','line_number':260,'multiline':True]
['text':'
     * !!! (Don't format the comment.)
     * Step 3:
     * Discard any page referencing a non-existent overflow page.  We do this before checking
     * overlapping key ranges on the grounds that a bad key range we can use is better than a
     * terrific key range that references pages we don't have. On the other hand, we subsequently
     * discard key ranges where there are better overlapping ranges, and it would be better if
     * we let the availability of an overflow value inform our choices as to the key ranges we
     * select, ideally on a per-key basis.
     *
     * A complicating problem is found in variable-length column-store objects, where we
     * potentially split key ranges within RLE units.  For example, if there's a page with rows
     * 15-20 and we later find row 17 with a larger LSN, the range splits into 3 chunks, 15-16,
     * 17, and 18-20.  If rows 15-20 were originally a single value (an RLE of 6), and that
     * record is an overflow record, we end up with two chunks, both of which want to reference
     * the same overflow value.
     *
     * Instead of the approach just described, we're first discarding any pages referencing
     * non-existent overflow pages, then we're reviewing our key ranges and discarding any
     * that overlap.  We're doing it that way for a few reasons: absent corruption, missing
     * overflow items are strong arguments the page was replaced (on the other hand, some kind
     * of file corruption is probably why we're here); it's a significant amount of additional
     * complexity to simultaneously juggle overlapping ranges and missing overflow items; finally,
     * real-world applications usually don't have a lot of overflow items, as WiredTiger supports
     * very large page sizes, overflow items shouldn't be common.
     *
     * Step 4:
     * Add unreferenced overflow page blocks to the free list so they are reused immediately.
     ','line_number':274,'multiline':True]
['text':'
     * !!! (Don't format the comment.)
     * Step 5:
     * Walk the list of pages looking for overlapping ranges to resolve.  If we find a range
     * that needs to be resolved, set a global flag and a per WT_TRACK flag on the pages requiring
     * modification.
     *
     * This requires sorting the page list by key, and secondarily by LSN.
     *
     * !!!
     * It's vanishingly unlikely and probably impossible for fixed-length column-store files
     * to have overlapping key ranges.  It's possible for an entire key range to go missing (if
     * a page is corrupted and lost), but because pages can't split, it shouldn't be possible to
     * find pages where the key ranges overlap.  That said, we check for it and clean up after
     * it in reconciliation because it doesn't cost much and future column-store formats or
     * operations might allow for fixed-length format ranges to overlap during salvage, and I
     * don't want to have to retrofit the code later.
     ','line_number':306,'multiline':True]
['text':'
     * !!! (Don't format the comment.)
     * Step 6:
     * We may have lost key ranges in column-store databases, that is, some part of the record
     * number space is gone; look for missing ranges.
     ','line_number':330,'multiline':True]
['text':'
     * !!! (Don't format the comment.)
     * Step 7:
     * Track the maximum write gen of the leaf pages and set that as the btree write gen.
     * Build an internal page that references all of the leaf pages, and write it, as well as any
     * merged pages, to the file.
     *
     * In the case of metadata, we will bump the connection base write gen to the metadata write gen
     * after metadata salvage completes.
     *
     * Count how many leaf pages we have (we could track this during the array shuffling/splitting,
     * but that's a lot harder).
     ','line_number':345,'multiline':True]
['text':'
     * !!! (Don't format the comment.)
     * Step 8:
     * If we had to merge key ranges, we have to do a final pass through the leaf page array
     * and discard file pages used during key merges. We can't do it earlier: if we free'd the
     * leaf pages we're merging as we merged them, the write of subsequent leaf pages or the
     * internal page might allocate those free'd file blocks, and if the salvage run subsequently
     * fails, we'd have overwritten pages used to construct the final key range. In other words,
     * if the salvage run fails, we don't want to overwrite data the next salvage run might need.
     ','line_number':377,'multiline':True]
['text':'
     * !!! (Don't format the comment.)
     * Step 9:
     * Evict any newly created root page, creating a checkpoint.
     ','line_number':390,'multiline':True]
['text':'
     * !!! (Don't format the comment.)
     * Step 10:
     * Inform the underlying block manager that we're done.
     ','line_number':398,'multiline':True]
['text':' Discard any root page we created. ','line_number':405,'multiline':True]
['text':' Discard the leaf and overflow page memory. ','line_number':409,'multiline':True]
['text':' Discard temporary buffers. ','line_number':412,'multiline':True]
['text':'
 * __slvg_read --
 *     Read the file and build a table of the pages we can use.
 ','line_number':419,'multiline':True]
['text':' Get the next block address from the block manager. ','line_number':440,'multiline':True]
['text':' Report progress occasionally. ','line_number':445,'multiline':True]
['text':'
         * Read (and potentially decompress) the block; the underlying block manager might return
         * only good blocks if checksums are configured, or both good and bad blocks if we're
         * relying on compression.
         *
         * Report the block's status to the block manager.
         ','line_number':450,'multiline':True]
['text':' Create a printable version of the address. ','line_number':469,'multiline':True]
['text':'
         * Make sure it's an expected page type for the file.
         *
         * We only care about leaf and overflow pages from here on out; discard all of the others.
         * We put them on the free list now, because we might as well overwrite them, we want the
         * file to grow as little as possible, or shrink, and future salvage calls don't need them
         * either.
         ','line_number':472,'multiline':True]
['text':'
         * Verify the page. It's unlikely a page could have a valid checksum and still be broken,
         * but paranoia is healthy in salvage. Regardless, verify does return failure because it
         * detects failures we'd expect to see in a corrupted file, like overflow references past
         * the end of the file or overflow references to non-existent pages, might as well discard
         * these pages now.
         ','line_number':491,'multiline':True]
['text':'
 * __slvg_trk_init --
 *     Initialize tracking information for a page.
 ','line_number':534,'multiline':True]
['text':'
 * __slvg_trk_leaf --
 *     Track a leaf page.
 ','line_number':565,'multiline':True]
['text':' Re-allocate the array of pages, as necessary. ','line_number':586,'multiline':True]
['text':' Allocate a WT_TRACK entry for this new page and fill it in. ','line_number':589,'multiline':True]
['text':'
         * Column-store fixed-sized format: start and stop keys can be taken from the block's
         * header, and doesn't contain overflow items.
         ','line_number':594,'multiline':True]
['text':'
         * Read the auxiliary header. Because pages that fail verify are tossed before salvage, we
         * shouldn't fail.
         ','line_number':602,'multiline':True]
['text':'
             * Nothing to do besides update the time aggregate with a stable timestamp. This is
             * necessary mechanically because a time aggregate initialized for merging will fail
             * validation if not touched, and necessary conceptually because we have notionally
             * iterated through all these values (which are all stable) and aggregated in their
             * timestamps.
             ','line_number':610,'multiline':True]
['text':'
             * Visit the time windows. Note: we're going to visit them all and produce the
             * corresponding time aggregate, even though we might end up discarding some of the
             * values later. The time aggregate will get updated to reflect that change when the
             * page is reconciled after salvage, and in the meantime having the time aggregate be
             * possibly wider than strictly necessary should not cause anything horribly wrong to
             * happen.
             ','line_number':623,'multiline':True]
['text':' If we have keys with no time windows, or none, aggregate in a stable one. ','line_number':642,'multiline':True]
['text':'
         * Column-store variable-length format: the start key can be taken from the block's header,
         * stop key requires walking the page.
         ','line_number':653,'multiline':True]
['text':' VLCS pages can contain overflow items. ','line_number':673,'multiline':True]
['text':'
         * Row-store format: copy the first and last keys on the page. Keys are prefix-compressed,
         * the simplest and slowest thing to do is instantiate the in-memory page, then instantiate
         * and copy the full keys, then free the page. We do this on every leaf page, and if you
         * need to speed up the salvage, it's probably a great place to start.
         *
         * Page flags are 0 because we aren't releasing the memory used to read the page into memory
         * and we don't want page discard to free it.
         ','line_number':683,'multiline':True]
['text':' Row-store pages can contain overflow items. ','line_number':705,'multiline':True]
['text':'
 * __slvg_trk_ovfl --
 *     Track an overflow page.
 ','line_number':720,'multiline':True]
['text':'
     * Reallocate the overflow page array as necessary, then save the page's location information.
     ','line_number':730,'multiline':True]
['text':'
 * __slvg_trk_leaf_ovfl --
 *     Search a leaf page for overflow items.
 ','line_number':741,'multiline':True]
['text':' Count page overflow items. ','line_number':751,'multiline':True]
['text':'
     * Second pass for overflow items: copy the addresses into an allocated array.
     ','line_number':761,'multiline':True]
['text':'
 * !!! (Don't format the comment.)
 * When pages split, the key range is split across multiple pages.  If not all
 * of the old versions of the page are overwritten, or not all of the new pages
 * are written, or some of the pages are corrupted, salvage will read different
 * pages with overlapping key ranges, at different LSNs.
 *
 * We salvage all of the key ranges we find, at the latest LSN value: this means
 * we may resurrect pages of deleted items, as page deletion doesn't write leaf
 * pages and salvage will read and instantiate the contents of an old version of
 * the deleted page.
 *
 * The leaf page array is sorted in key order, and secondarily on LSN: what this
 * means is that for each new key range, the first page we find is the best page
 * for that key. The process is to walk forward from each page until we reach a
 * page with a starting key after the current page's stopping key.
 *
 * For each of page, check to see if they overlap the current page's key range.
 * If they do, resolve the overlap.  Because WiredTiger rarely splits pages,
 * overlap resolution usually means discarding a page because the key ranges
 * are the same, and one of the pages is simply an old version of the other.
 *
 * However, it's possible more complex resolution is necessary.  For example,
 * here's an improbably complex list of page ranges and LSNs:
 *
 *	Page	Range	LSN
 *	 30	 A-G	 3
 *	 31	 C-D	 4
 *	 32	 B-C	 5
 *	 33	 C-F	 6
 *	 34	 C-D	 7
 *	 35	 F-M	 8
 *	 36	 H-O	 9
 *
 * We walk forward from each page reviewing all other pages in the array that
 * overlap the range.  For each overlap, the current or the overlapping
 * page is updated so the page with the most recent information for any range
 * "owns" that range.  Here's an example for page 30.
 *
 * Review page 31: because page 31 has the range C-D and a higher LSN than page
 * 30, page 30 would "split" into two ranges, A-C and E-G, conceding the C-D
 * range to page 31.  The new track element would be inserted into array with
 * the following result:
 *
 *	Page	Range	LSN
 *	 30	 A-C	 3		<< Changed WT_TRACK element
 *	 31	 C-D	 4
 *	 32	 B-C	 5
 *	 33	 C-F	 6
 *	 34	 C-D	 7
 *	 30	 E-G	 3		<< New WT_TRACK element
 *	 35	 F-M	 8
 *	 36	 H-O	 9
 *
 * Continue the review of the first element, using its new values.
 *
 * Review page 32: because page 31 has the range B-C and a higher LSN than page
 * 30, page 30's A-C range would be truncated, conceding the B-C range to page
 * 32.
 *	 30	 A-B	 3
 *		 E-G	 3
 *	 31	 C-D	 4
 *	 32	 B-C	 5
 *	 33	 C-F	 6
 *	 34	 C-D	 7
 *
 * Review page 33: because page 33 has a starting key (C) past page 30's ending
 * key (B), we stop evaluating page 30's A-B range, as there can be no further
 * overlaps.
 *
 * This process is repeated for each page in the array.
 *
 * When page 33 is processed, we'd discover that page 33's C-F range overlaps
 * page 30's E-G range, and page 30's E-G range would be updated, conceding the
 * E-F range to page 33.
 *
 * This is not computationally expensive because we don't walk far forward in
 * the leaf array because it's sorted by starting key, and because WiredTiger
 * splits are rare, the chance of finding the kind of range overlap requiring
 * re-sorting the array is small.
 ','line_number':787,'multiline':True]
['text':'
 * __slvg_col_range --
 *     Figure out the leaf pages we need and free the leaf pages we don't.
 ','line_number':868,'multiline':True]
['text':'
     * DO NOT MODIFY THIS CODE WITHOUT REVIEWING THE CORRESPONDING ROW- OR COLUMN-STORE CODE: THEY
     * ARE IDENTICAL OTHER THAN THE PAGES THAT ARE BEING HANDLED.
     *
     * Walk the page array looking for overlapping key ranges, adjusting the ranges based on the LSN
     * until there are no overlaps.
     *
     * DO NOT USE POINTERS INTO THE ARRAY: THE ARRAY IS RE-SORTED IN PLACE AS ENTRIES ARE SPLIT, SO
     * ARRAY REFERENCES MUST ALWAYS BE ARRAY BASE PLUS OFFSET.
     ','line_number':878,'multiline':True]
['text':' Check for pages that overlap our page. ','line_number':892,'multiline':True]
['text':'
             * We're done if this page starts after our stop, no subsequent pages can overlap our
             * page.
             ','line_number':896,'multiline':True]
['text':' There's an overlap, fix it up. ','line_number':903,'multiline':True]
['text':'
             * If the overlap resolution changed the entry's start key, the entry might have moved
             * and the page array re-sorted, and pages[j] would reference a different page. We don't
             * move forward if that happened, we re-process the slot again (by decrementing j before
             * the loop's increment).
             ','line_number':907,'multiline':True]
['text':'
 * __slvg_col_range_overlap --
 *     Two column-store key ranges overlap, deal with it.
 ','line_number':920,'multiline':True]
['text':'
     * DO NOT MODIFY THIS CODE WITHOUT REVIEWING THE CORRESPONDING ROW- OR COLUMN-STORE CODE: THEY
     * ARE IDENTICAL OTHER THAN THE PAGES THAT ARE BEING HANDLED.
     ','line_number':931,'multiline':True]
['text':'
     * !!! (Don't format the comment.)
     * The key ranges of two WT_TRACK pages in the array overlap -- choose
     * the ranges we're going to take from each.
     *
     * We can think of the overlap possibilities as 11 different cases:
     *
     *		AAAAAAAAAAAAAAAAAA
     * #1		BBBBBBBBBBBBBBBBBB		pages are the same
     * #2	BBBBBBBBBBBBB				overlaps the beginning
     * #3			BBBBBBBBBBBBBBBB	overlaps the end
     * #4		BBBBB				B is a prefix of A
     * #5			BBBBBB			B is middle of A
     * #6			BBBBBBBBBB		B is a suffix of A
     *
     * and:
     *
     *		BBBBBBBBBBBBBBBBBB
     * #7	AAAAAAAAAAAAA				same as #3
     * #8			AAAAAAAAAAAAAAAA	same as #2
     * #9		AAAAA				A is a prefix of B
     * #10			AAAAAA			A is middle of B
     * #11			AAAAAAAAAA		A is a suffix of B
     *
     * Note the leaf page array was sorted by key and a_trk appears earlier
     * in the array than b_trk, so cases #2/8, #10 and #11 are impossible.
     *
     * Finally, there's one additional complicating factor -- final ranges
     * are assigned based on the page's LSN.
     ','line_number':942,'multiline':True]
['text':' Case #2/8, #10, #11 ','line_number':972,'multiline':True]
['text':' Case #1, #4 and #9 ','line_number':976,'multiline':True]
['text':'
                                                 * The secondary sort of the leaf page array was the
                                                 * page's LSN, in high-to-low order, which means
                                                 * a_trk has a higher LSN, and is more desirable,
                                                 * than b_trk. In cases #1 and #4 and #9, where the
                                                 * start of the range is the same for the two pages,
                                                 * this simplifies things, it guarantees a_trk has a
                                                 * higher LSN than b_trk.
                                                 ','line_number':977,'multiline':True]
['text':'
             * Case #1, #4: a_trk is a superset of b_trk, and a_trk is more desirable -- discard
             * b_trk.
             ','line_number':987,'multiline':True]
['text':'
         * Case #9: b_trk is a superset of a_trk, but a_trk is more desirable: keep both but delete
         * a_trk's key range from b_trk.
         ','line_number':993,'multiline':True]
['text':' Case #6 ','line_number':1003,'multiline':True]
['text':'
             * Case #6: a_trk is a superset of b_trk and a_trk is more desirable -- discard b_trk.
             ','line_number':1005,'multiline':True]
['text':'
         * Case #6: a_trk is a superset of b_trk, but b_trk is more desirable: keep both but delete
         * b_trk's key range from a_trk.
         ','line_number':1010,'multiline':True]
['text':' Case #3/7 ','line_number':1019,'multiline':True]
['text':'
             * Case #3/7: a_trk is more desirable, delete a_trk's key range from b_trk;
             ','line_number':1021,'multiline':True]
['text':'
             * Case #3/7: b_trk is more desirable, delete b_trk's key range from a_trk;
             ','line_number':1028,'multiline':True]
['text':'
     * Case #5: a_trk is a superset of b_trk and a_trk is more desirable -- discard b_trk.
     ','line_number':1037,'multiline':True]
['text':'
         * After page and overflow reconciliation, one (and only one) page can reference an overflow
         * record. But, if we split a page into multiple chunks, any of the chunks might own any of
         * the backing overflow records, so overflow records won't normally be discarded until after
         * the merge phase completes. (The merge phase is where the final pages are written, and we
         * figure out which overflow records are actually used.) If freeing a chunk and there are no
         * other references to the underlying shared information, the overflow records must be
         * useless, discard them to keep the final file size small.
         ','line_number':1042,'multiline':True]
['text':'
     * Case #5: b_trk is more desirable and is a middle chunk of a_trk. Split a_trk into two parts,
     * the key range before b_trk and the key range after b_trk.
     *
     * Allocate a new WT_TRACK object, and extend the array of pages as necessary.
     ','line_number':1057,'multiline':True]
['text':'
     * First, set up the track share (we do this after the allocation to ensure the shared reference
     * count is never incorrect).
     ','line_number':1070,'multiline':True]
['text':'
     * Second, insert the new element into the array after the existing element (that's probably
     * wrong, but we'll fix it up in a second).
     ','line_number':1078,'multiline':True]
['text':'
     * Third, set its start key to be the first key after the stop key of the middle chunk (that's
     * b_trk), and its stop key to be the stop key of the original chunk, and call
     * __slvg_col_trk_update_start. That function will re-sort the WT_TRACK array as necessary to
     * move our new entry into the right sorted location.
     ','line_number':1087,'multiline':True]
['text':'
     * Fourth, set the original WT_TRACK information to reference only the initial key space in the
     * page, that is, everything up to the starting key of the middle chunk (that's b_trk).
     ','line_number':1097,'multiline':True]
['text':'
 * __slvg_col_trk_update_start --
 *     Update a column-store page's start key after an overlap.
 ','line_number':1113,'multiline':True]
['text':'
     * If we deleted an initial piece of the WT_TRACK name space, it may no
     * longer be in the right location.
     *
     * For example, imagine page #1 has the key range 30-50, it split, and
     * we wrote page #2 with key range 30-40, and page #3 key range with 40-50, where pages #2 and
     * #3 have larger LSNs than page #1.  When the
     * key ranges were sorted, page #2 came first, then page #1 (because of
     * their earlier start keys than page #3), and page #2 came before page #1 because of its LSN.
     * When we resolve the overlap between page #2
     * and page #1, we truncate the initial key range of page #1, and it now
     * sorts after page #3, because it has the same starting key of 40, and
     * a lower LSN.
     *
     * We have already updated b_trk's start key; what we may have to do is
     * re-sort some number of elements in the list.
     ','line_number':1125,'multiline':True]
['text':'
 * __slvg_col_range_missing --
 *     Detect missing ranges from column-store files.
 ','line_number':1153,'multiline':True]
['text':'
             * We need to instantiate deleted items for the missing record range.
             ','line_number':1173,'multiline':True]
['text':'
 * __slvg_modify_init --
 *     Initialize a salvage page's modification information.
 ','line_number':1183,'multiline':True]
['text':'
 * __slvg_col_build_internal --
 *     Build a column-store in-memory page that references all of the leaf pages we've found.
 ','line_number':1196,'multiline':True]
['text':' Allocate a column-store root (internal) page and fill it in. ','line_number':1213,'multiline':True]
['text':'
         * If the page's key range is unmodified from when we read it (in other words, we didn't
         * merge part of this page with another page), we can use the page without change, and the
         * only thing we need to do is mark all overflow records the page references as in-use.
         *
         * If we did merge with another page, we have to build a page reflecting the updated key
         * range. Note, that requires an additional pass to free the merge page's backing blocks.
         ','line_number':1238,'multiline':True]
['text':'
 * __slvg_col_build_leaf --
 *     Build a column-store leaf page for a merged page.
 ','line_number':1265,'multiline':True]
['text':' Get the original page, including the full in-memory setup. ','line_number':1287,'multiline':True]
['text':'
     * Calculate the number of K/V entries we are going to skip, and the total number of K/V entries
     * we'll take from this page.
     ','line_number':1294,'multiline':True]
['text':' Set the referenced flag on overflow pages we're using. ','line_number':1306,'multiline':True]
['text':'
     * If we're missing some part of the range, the real start range is in trk->col_missing, else,
     * it's in trk->col_start. Update the parent's reference as well as the page itself.
     ','line_number':1310,'multiline':True]
['text':'
     * We can't discard the original blocks associated with this page now. (The problem is we don't
     * want to overwrite any original information until the salvage run succeeds -- if we free the
     * blocks now, the next merge page we write might allocate those blocks and overwrite them, and
     * should the salvage run eventually fail, the original information would have been lost.) Clear
     * the reference addr so eviction doesn't free the underlying blocks.
     ','line_number':1325,'multiline':True]
['text':'
     * Reconciliation may skip a key/value pair (based on timestamps), and in that case, if the
     * value is an overflow item, reconciliation will free the underlying object's backing blocks.
     * Additionally, salvage of a column-store page can have start/stop points in the middle of a
     * cell, and reconciliation therefore does all of the usual processing of cells, but skips the
     * write if they're outside the salvage range. If the value is an overflow item and it's never
     * used, reconciliation will free the underlying object's backing blocks, which is fine, but we
     * need to adjust our list of overflow blocks so we don't free the overflow item twice.
     * Intercept any attempt by reconciliation to free blocks.
     ','line_number':1334,'multiline':True]
['text':' Write the new version of the leaf page to disk. ','line_number':1348,'multiline':True]
['text':' Reset the page. ','line_number':1352,'multiline':True]
['text':' Discard our hazard pointer and evict the page, updating the parent's reference. ','line_number':1356,'multiline':True]
['text':'
 * __slvg_col_ovfl_single --
 *     Find a single overflow record in the merge page's list, and mark it as referenced.
 ','line_number':1373,'multiline':True]
['text':'
     * Search the list of overflow records for this page -- we should find exactly one match, and we
     * mark it as referenced.
     ','line_number':1383,'multiline':True]
['text':'
 * __slvg_col_ovfl --
 *     Mark overflow items referenced by the merged page.
 ','line_number':1397,'multiline':True]
['text':'
     * Reconciliation of a salvaged column-store page processes all of the page's cells, skipping
     * the write if a cell is outside the salvage range. If the value is an overflow item and it's
     * never used, reconciliation will free the underlying object's backing blocks. We'll set up a
     * callback to track the blocks that are freed, mark all page overflow values as "referenced" so
     * that tracking succeeds.
     ','line_number':1410,'multiline':True]
['text':'
         * When handling overlapping ranges on variable-length column-store leaf pages, we split
         * ranges without considering if we were splitting RLE units. (See note at the beginning of
         * this file for explanation of the overall process.) If the RLE unit was on-page, we can
         * simply write it again. If the RLE unit was an overflow value that's already been used by
         * another row (from some other page created by a range split), there's not much to do, this
         * row can't reference an overflow record we don't have: delete the row.
         ','line_number':1423,'multiline':True]
['text':'
 * __slvg_row_range --
 *     Figure out the leaf pages we need and discard everything else. At the same time, tag the
 *     overflow pages they reference.
 ','line_number':1441,'multiline':True]
['text':'
     * DO NOT MODIFY THIS CODE WITHOUT REVIEWING THE CORRESPONDING ROW- OR COLUMN-STORE CODE: THEY
     * ARE IDENTICAL OTHER THAN THE PAGES THAT ARE BEING HANDLED.
     *
     * Walk the page array looking for overlapping key ranges, adjusting the ranges based on the LSN
     * until there are no overlaps.
     *
     * DO NOT USE POINTERS INTO THE ARRAY: THE ARRAY IS RE-SORTED IN PLACE AS ENTRIES ARE SPLIT, SO
     * ARRAY REFERENCES MUST ALWAYS BE ARRAY BASE PLUS OFFSET.
     ','line_number':1456,'multiline':True]
['text':' Check for pages that overlap our page. ','line_number':1470,'multiline':True]
['text':'
             * We're done if this page starts after our stop, no subsequent pages can overlap our
             * page.
             ','line_number':1474,'multiline':True]
['text':' There's an overlap, fix it up. ','line_number':1483,'multiline':True]
['text':'
             * If the overlap resolution changed the entry's start key, the entry might have moved
             * and the page array re-sorted, and pages[j] would reference a different page. We don't
             * move forward if that happened, we re-process the slot again (by decrementing j before
             * the loop's increment).
             ','line_number':1487,'multiline':True]
['text':'
 * __slvg_row_range_overlap --
 *     Two row-store key ranges overlap, deal with it.
 ','line_number':1500,'multiline':True]
['text':'
     * DO NOT MODIFY THIS CODE WITHOUT REVIEWING THE CORRESPONDING ROW- OR COLUMN-STORE CODE: THEY
     * ARE IDENTICAL OTHER THAN THE PAGES THAT ARE BEING HANDLED.
     ','line_number':1513,'multiline':True]
['text':'
 * !!! (Don't format the comment.)
 * The key ranges of two WT_TRACK pages in the array overlap -- choose the ranges we're going to
 * take from each.
 *
 * We can think of the overlap possibilities as 11 different cases:
 *
 *		AAAAAAAAAAAAAAAAAA
 * #1		BBBBBBBBBBBBBBBBBB		pages are the same
 * #2	BBBBBBBBBBBBB				overlaps the beginning
 * #3			BBBBBBBBBBBBBBBB	overlaps the end
 * #4		BBBBB				B is a prefix of A
 * #5			BBBBBB			B is middle of A
 * #6			BBBBBBBBBB		B is a suffix of A
 *
 * and:
 *
 *		BBBBBBBBBBBBBBBBBB
 * #7	AAAAAAAAAAAAA				same as #3
 * #8			AAAAAAAAAAAAAAAA	same as #2
 * #9		AAAAA				A is a prefix of B
 * #10			AAAAAA			A is middle of B
 * #11			AAAAAAAAAA		A is a suffix of B
 *
 * Note the leaf page array was sorted by key and a_trk appears earlier in the array than b_trk, so
 * cases #2/8, #10 and #11 are impossible.
 *
 * Finally, there's one additional complicating factor -- final ranges are assigned based on the
 * page's LSN.
 ','line_number':1526,'multiline':True]
['text':' Case #2/8, #10, #11 ','line_number':1566,'multiline':True]
['text':' Case #1, #4, #9 ','line_number':1569,'multiline':True]
['text':'
                           * The secondary sort of the leaf page array was the page's LSN, in
                           * high-to-low order, which means a_trk has a higher LSN, and is more
                           * desirable, than b_trk. In cases #1 and #4 and #9, where the start of
                           * the range is the same for the two pages, this simplifies things, it
                           * guarantees a_trk has a higher LSN than b_trk.
                           ','line_number':1570,'multiline':True]
['text':'
             * Case #1, #4: a_trk is a superset of b_trk, and a_trk is more desirable -- discard
             * b_trk.
             ','line_number':1578,'multiline':True]
['text':'
         * Case #9: b_trk is a superset of a_trk, but a_trk is more desirable: keep both but delete
         * a_trk's key range from b_trk.
         ','line_number':1584,'multiline':True]
['text':' Case #6 ','line_number':1593,'multiline':True]
['text':'
             * Case #6: a_trk is a superset of b_trk and a_trk is more desirable -- discard b_trk.
             ','line_number':1595,'multiline':True]
['text':'
         * Case #6: a_trk is a superset of b_trk, but b_trk is more desirable: keep both but delete
         * b_trk's key range from a_trk.
         ','line_number':1600,'multiline':True]
['text':' Case #3/7 ','line_number':1609,'multiline':True]
['text':'
             * Case #3/7: a_trk is more desirable, delete a_trk's key range from b_trk;
             ','line_number':1611,'multiline':True]
['text':'
             * Case #3/7: b_trk is more desirable, delete b_trk's key range from a_trk;
             ','line_number':1617,'multiline':True]
['text':'
     * Case #5: a_trk is a superset of b_trk and a_trk is more desirable -- discard b_trk.
     ','line_number':1626,'multiline':True]
['text':'
         * After page and overflow reconciliation, one (and only one) page can reference an overflow
         * record. But, if we split a page into multiple chunks, any of the chunks might own any of
         * the backing overflow records, so overflow records won't normally be discarded until after
         * the merge phase completes. (The merge phase is where the final pages are written, and we
         * figure out which overflow records are actually used.) If freeing a chunk and there are no
         * other references to the underlying shared information, the overflow records must be
         * useless, discard them to keep the final file size small.
         ','line_number':1631,'multiline':True]
['text':'
     * Case #5: b_trk is more desirable and is a middle chunk of a_trk. Split a_trk into two parts,
     * the key range before b_trk and the key range after b_trk.
     *
     * Allocate a new WT_TRACK object, and extend the array of pages as necessary.
     ','line_number':1646,'multiline':True]
['text':'
     * First, set up the track share (we do this after the allocation to ensure the shared reference
     * count is never incorrect).
     ','line_number':1659,'multiline':True]
['text':'
     * Second, insert the new element into the array after the existing element (that's probably
     * wrong, but we'll fix it up in a second).
     ','line_number':1667,'multiline':True]
['text':'
     * Third, set its stop key to be the stop key of the original chunk, and call
     * __slvg_row_trk_update_start. That function will both set the start key to be the first key
     * after the stop key of the middle chunk (that's b_trk), and re-sort the WT_TRACK array as
     * necessary to move our new entry into the right sorted location.
     ','line_number':1676,'multiline':True]
['text':'
     * Fourth, set the original WT_TRACK information to reference only the initial key space in the
     * page, that is, everything up to the starting key of the middle chunk (that's b_trk).
     ','line_number':1685,'multiline':True]
['text':'
 * __slvg_row_trk_update_start --
 *     Update a row-store page's start key after an overlap.
 ','line_number':1703,'multiline':True]
['text':'
     * If we deleted an initial piece of the WT_TRACK name space, it may no
     * longer be in the right location.
     *
     * For example, imagine page #1 has the key range 30-50, it split, and
     * we wrote page #2 with key range 30-40, and page #3 key range with 40-50, where pages #2 and
     * #3 have larger LSNs than page #1.  When the
     * key ranges were sorted, page #2 came first, then page #1 (because of
     * their earlier start keys than page #3), and page #2 came before page #1 because of its LSN.
     * When we resolve the overlap between page #2
     * and page #1, we truncate the initial key range of page #1, and it now
     * sorts after page #3, because it has the same starting key of 40, and
     * a lower LSN.
     *
     * First, update the WT_TRACK start key based on the specified stop key.
     *
     * Read and instantiate the WT_TRACK page (we don't have to verify the
     * page, nor do we have to be quiet on error, we've already read this
     * page successfully).
     *
     * Page flags are 0 because we aren't releasing the memory used to read
     * the page into memory and we don't want page discard to free it.
     ','line_number':1727,'multiline':True]
['text':'
     * Walk the page, looking for a key sorting greater than the specified stop key -- that's our
     * new start key.
     ','line_number':1754,'multiline':True]
['text':'
     * We know that at least one key on the page sorts after the specified stop key, otherwise the
     * page would have entirely overlapped and we would have discarded it, we wouldn't be here.
     * Therefore, this test is safe. (But, it never hurts to check.)
     ','line_number':1768,'multiline':True]
['text':'
     * We may need to re-sort some number of elements in the list. Walk forward in the list until
     * reaching an entry which cannot overlap the adjusted entry. If it's more than a single slot,
     * re-sort the entries.
     ','line_number':1777,'multiline':True]
['text':'
 * __slvg_row_build_internal --
 *     Build a row-store in-memory page that references all of the leaf pages we've found.
 ','line_number':1802,'multiline':True]
['text':' Allocate a row-store root (internal) page and fill it in. ','line_number':1819,'multiline':True]
['text':'
         * If the page's key range is unmodified from when we read it (in other words, we didn't
         * merge part of this page with another page), we can use the page without change, and the
         * only thing we need to do is mark all overflow records the page references as in-use.
         *
         * If we did merge with another page, we have to build a page reflecting the updated key
         * range. Note, that requires an additional pass to free the merge page's backing blocks.
         ','line_number':1844,'multiline':True]
['text':'
         * !!!
         * There's a risk the page we're building is too large for the cache. The right fix would be
         * to write the keys out to an on-disk file and delay allocating the page image until we're
         * ready to reconcile the new root page, and then read keys in from that backing file during
         * the reconciliation of the root page. For now, make sure the eviction threads don't see us
         * as a threat.
         ','line_number':1864,'multiline':True]
['text':'
 * __slvg_row_build_leaf --
 *     Build a row-store leaf page for a merged page.
 ','line_number':1885,'multiline':True]
['text':' Allocate temporary space in which to instantiate the keys. ','line_number':1908,'multiline':True]
['text':' Get the original page, including the full in-memory setup. ','line_number':1911,'multiline':True]
['text':'
     * Figure out how many page keys we want to take and how many we want to skip.
     *
     * If checking the starting range key, the key we're searching for will be equal to the starting
     * range key. This is because we figured out the true merged-page start key as part of
     * discarding initial keys from the page (see the __slvg_row_range_overlap function, and its
     * calls to __slvg_row_trk_update_start for more information).
     *
     * If checking the stopping range key, we want the keys on the page that are less-than the
     * stopping range key. This is because we copied a key from another page to define this page's
     * stop range: that page is the page that owns the "equal to" range space.
     ','line_number':1915,'multiline':True]
['text':'
             * >= is correct: see the comment above.
             ','line_number':1932,'multiline':True]
['text':'
             * < is correct: see the comment above.
             ','line_number':1948,'multiline':True]
['text':' We should have selected some entries, but not the entire page. ','line_number':1961,'multiline':True]
['text':'
     * Take a copy of this page's first key to define the start of its range. The key may require
     * processing, otherwise, it's a copy from the page.
     ','line_number':1964,'multiline':True]
['text':' Set the referenced flag on overflow pages we're using. ','line_number':1972,'multiline':True]
['text':'
     * Change the page to reflect the correct record count: there is no need to copy anything on the
     * page itself, the entries value limits the number of page items.
     ','line_number':1976,'multiline':True]
['text':'
     * We can't discard the original blocks associated with this page now. (The problem is we don't
     * want to overwrite any original information until the salvage run succeeds -- if we free the
     * blocks now, the next merge page we write might allocate those blocks and overwrite them, and
     * should the salvage run eventually fail, the original information would have been lost.) Clear
     * the reference addr so eviction doesn't free the underlying blocks.
     ','line_number':1983,'multiline':True]
['text':'
     * Reconciliation may skip a key/value pair (based on timestamps), and in that case, if the
     * key/value is an overflow item, reconciliation will free the underlying object's backing
     * blocks. That's a problem when merging pages if the key is an overflow item: if we're
     * processing a page multiple times to handle overlapping ranges, and if the first build and
     * reconcile removes the overflow key, the second build/reconcile will fail when it can't read
     * the key. Intercept any attempt by reconciliation to free blocks.
     ','line_number':1992,'multiline':True]
['text':' Write the new version of the leaf page to disk. ','line_number':2004,'multiline':True]
['text':' Reset the page. ','line_number':2008,'multiline':True]
['text':' Discard our hazard pointer and evict the page, updating the parent's reference. ','line_number':2011,'multiline':True]
['text':'
 * __slvg_row_ovfl_single --
 *     Find a single overflow record in the merge page's list, and mark it as referenced.
 ','line_number':2029,'multiline':True]
['text':' Check if it's an overflow record. ','line_number':2039,'multiline':True]
['text':'
     * Search the list of overflow records for this page -- we should find exactly one match, and we
     * mark it as referenced.
     ','line_number':2043,'multiline':True]
['text':'
 * __slvg_row_ovfl --
 *     Mark overflow items referenced by the merged page.
 ','line_number':2057,'multiline':True]
['text':'
     * We're merging a row-store page, and we took some number of records, figure out which (if any)
     * overflow records we used.
     ','line_number':2070,'multiline':True]
['text':'
 * __slvg_reconcile_free --
 *     Block manager replacement to update blocks reconciliation wants removed.
 ','line_number':2085,'multiline':True]
['text':'
     * Search the list of overflow records for this page -- we should find exactly one referenced
     * match, and we clear that reference.
     ','line_number':2098,'multiline':True]
['text':'
 * __slvg_trk_compare_addr --
 *     Compare two WT_TRACK array entries by address cookie.
 ','line_number':2117,'multiline':True]
['text':'
     * We don't care about the order because these are opaque cookies -- we're just sorting them so
     * we can binary search instead of linear search.
     ','line_number':2131,'multiline':True]
['text':'
 * __slvg_ovfl_compare --
 *     Bsearch comparison routine for the overflow array.
 ','line_number':2142,'multiline':True]
['text':'
 * __slvg_ovfl_reconcile --
 *     Review relationships between leaf pages and the overflow pages, delete leaf pages until
 *     there's a one-to-one relationship between leaf and overflow pages.
 ','line_number':2164,'multiline':True]
['text':'
     * If an overflow page is referenced more than once, discard leaf pages with the lowest LSNs
     * until overflow pages are only referenced once.
     *
     * This requires sorting the page list by LSN, and the overflow array by address cookie.
     ','line_number':2179,'multiline':True]
['text':'
     * Walk the list of pages and discard any pages referencing non-existent overflow pages or
     * referencing overflow pages also referenced by pages with higher LSNs. Our caller sorted the
     * page list by LSN, high to low, so we don't have to do explicit testing of the page LSNs, the
     * first page to reference an overflow page is the best page to own it.
     ','line_number':2188,'multiline':True]
['text':'
             * It is possible that salvage found a leaf page that points to an overflow item, but
             * there were no overflow items at all.
             ','line_number':2201,'multiline':True]
['text':'
             * If the overflow page doesn't exist or if another page has already claimed it, this
             * leaf page isn't usable.
             ','line_number':2209,'multiline':True]
['text':'
                 * Convert each block address into a slot in the list of overflow pages as we go.
                 ','line_number':2214,'multiline':True]
['text':'
             * Clear the "referenced" flag for any overflow pages already claimed by this leaf page
             * some other page might claim them.
             ','line_number':2226,'multiline':True]
['text':'
         * We now have a reference to the overflow WT_TRACK, and so no longer need the page's
         * address array, discard it. Note, we potentially freed the WT_TRACK in the loop above,
         * check it's still valid.
         ','line_number':2237,'multiline':True]
['text':'
 * __slvg_trk_compare_key --
 *     Compare two WT_TRACK array entries by key, and secondarily, by LSN.
 ','line_number':2258,'multiline':True]
['text':'
         * XXX
         * __wt_compare can potentially fail, and we're ignoring that
         * error because this routine is called as an underlying qsort
         * routine.
         ','line_number':2291,'multiline':True]
['text':'
     * If the primary keys compare equally, differentiate based on LSN. Sort from highest LSN to
     * lowest, that is, the earlier pages in the array are more desirable.
     ','line_number':2305,'multiline':True]
['text':'
 * __slvg_trk_compare_gen --
 *     Compare two WT_TRACK array entries by LSN.
 ','line_number':2314,'multiline':True]
['text':'
     * Sort from highest LSN to lowest, that is, the earlier pages in the array are more desirable.
     ','line_number':2327,'multiline':True]
['text':'
 * __slvg_merge_block_free --
 *     Clean up backing file and overflow blocks after the merge phase.
 ','line_number':2335,'multiline':True]
['text':' Free any underlying file blocks for merged pages. ','line_number':2345,'multiline':True]
['text':' Free any unused overflow records. ','line_number':2353,'multiline':True]
['text':'
 * __slvg_ovfl_ref --
 *     Reference an overflow page, checking for multiple references.
 ','line_number':2357,'multiline':True]
['text':'
 * __slvg_ovfl_ref_all --
 *     Reference all of the page's overflow pages.
 ','line_number':2375,'multiline':True]
['text':'
 * __slvg_ovfl_discard --
 *     Discard unused overflow pages.
 ','line_number':2390,'multiline':True]
['text':'
     * Walk the overflow page array: if an overflow page isn't referenced, add its file blocks to
     * the free list.
     *
     * Clear the reference flag (it's reused to figure out if the overflow record is referenced, but
     * never used, by merged pages).
     ','line_number':2400,'multiline':True]
['text':'
 * __slvg_cleanup --
 *     Discard memory allocated to the page and overflow arrays.
 ','line_number':2423,'multiline':True]
['text':' Discard the leaf page array. ','line_number':2432,'multiline':True]
['text':' Discard the ovfl page array. ','line_number':2438,'multiline':True]
['text':'
 * __slvg_trk_free_addr --
 *     Discard address information.
 ','line_number':2447,'multiline':True]
['text':'
 * __slvg_trk_free_block --
 *     Discard underlying blocks.
 ','line_number':2463,'multiline':True]
['text':'
     * If freeing underlying file blocks or overflow pages, this is a page we were tracking but
     * eventually decided not to use.
     ','line_number':2474,'multiline':True]
['text':'
 * __slvg_trk_free --
 *     Discard a WT_TRACK structure and (optionally) its underlying blocks.
 ','line_number':2484,'multiline':True]
['text':'
     * If we're the last user of shared information, clean up.
     ','line_number':2496,'multiline':True]
['text':'
         * If the free-on-last-ref flag is set, this chunk isn't going to use the backing physical
         * blocks. As we're the last user of those blocks, nobody is going to use them and they can
         * be discarded.
         ','line_number':2501,'multiline':True]
