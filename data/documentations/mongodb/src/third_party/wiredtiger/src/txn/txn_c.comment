['text':'-
 * Copyright (c) 2014-present MongoDB, Inc.
 * Copyright (c) 2008-2014 WiredTiger, Inc.
 *	All rights reserved.
 *
 * See the file LICENSE for redistribution information.
 ','line_number':1,'multiline':True]
['text':'
 * __snapsort_partition --
 *     Custom quick sort partitioning for snapshots.
 ','line_number':11,'multiline':True]
['text':'
 * __snapsort_impl --
 *     Custom quick sort implementation for snapshots.
 ','line_number':36,'multiline':True]
['text':'
 * __snapsort --
 *     Sort an array of transaction IDs.
 ','line_number':53,'multiline':True]
['text':'
 * __txn_remove_from_global_table --
 *     Remove the transaction id from the global transaction table.
 ','line_number':64,'multiline':True]
['text':'
 * __txn_sort_snapshot --
 *     Sort a snapshot for faster searching and set the min/max bounds.
 ','line_number':90,'multiline':True]
['text':'
 * __wt_txn_release_snapshot --
 *     Release the snapshot in the current transaction.
 ','line_number':112,'multiline':True]
['text':' Clear a checkpoint's pinned ID and timestamp. ','line_number':135,'multiline':True]
['text':'
 * __wt_txn_active --
 *     Check if a transaction is still active. If not, it is either committed, prepared, or rolled
 *     back. It is possible that we race with commit, prepare or rollback and a transaction is still
 *     active before the start of the call is eventually reported as resolved.
 ','line_number':142,'multiline':True]
['text':' We're going to scan the table: wait for the lock. ','line_number':162,'multiline':True]
['text':' Walk the array of concurrent transactions. ','line_number':171,'multiline':True]
['text':' If the transaction is in the list, it is uncommitted. ','line_number':176,'multiline':True]
['text':'
 * __txn_get_snapshot_int --
 *     Allocate a snapshot, optionally update our shared txn ids.
 ','line_number':187,'multiline':True]
['text':' Fast path if we already have the current snapshot. ','line_number':207,'multiline':True]
['text':' We're going to scan the table: wait for the lock. ','line_number':215,'multiline':True]
['text':'
     * Include the checkpoint transaction, if one is running: we should ignore any uncommitted
     * changes the checkpoint has written to the metadata. We don't have to keep the checkpoint's
     * changes pinned so don't go including it in the published pinned ID.
     *
     * We can assume that if a function calls without intention to publish then it is the special
     * case of checkpoint calling it twice. In which case do not include the checkpoint id.
     ','line_number':221,'multiline':True]
['text':' For pure read-only workloads, avoid scanning. ','line_number':236,'multiline':True]
['text':' Check that the oldest ID has not moved in the meantime. ','line_number':239,'multiline':True]
['text':' Walk the array of concurrent transactions. ','line_number':244,'multiline':True]
['text':'
         * Build our snapshot of any concurrent transaction IDs.
         *
         * Ignore:
         *  - Our own ID: we always read our own updates.
         *  - The ID if it is older than the oldest ID we saw. This
         *    can happen if we race with a thread that is allocating
         *    an ID -- the ID will not be used because the thread will
         *    keep spinning until it gets a valid one.
         *  - The ID if it is higher than the current ID we saw. This
         *    can happen if the transaction is already finished. In
         *    this case, we ignore this transaction because it would
         *    not be visible to the current snapshot.
         ','line_number':249,'multiline':True]
['text':'
             * If the transaction is still allocating its ID, then we spin here until it gets its
             * valid ID.
             ','line_number':265,'multiline':True]
['text':'
                 * There is still a chance that fetched ID is not valid after ID allocation, so we
                 * check again here. The read of transaction ID should be carefully ordered: we want
                 * to re-read ID from transaction state after this transaction completes ID
                 * allocation.
                 ','line_number':271,'multiline':True]
['text':'
     * If we got a new snapshot, update the published pinned ID for this session.
     ','line_number':289,'multiline':True]
['text':'
 * __wt_txn_get_snapshot --
 *     Common case, allocate a snapshot and update our shared ids.
 ','line_number':301,'multiline':True]
['text':'
 * __wt_txn_bump_snapshot --
 *     Uncommon case, allocate a snapshot but skip updating our shared ids.
 ','line_number':311,'multiline':True]
['text':'
 * __txn_oldest_scan --
 *     Sweep the running transactions to calculate the oldest ID required.
 ','line_number':321,'multiline':True]
['text':' The oldest ID cannot change while we are holding the scan lock. ','line_number':340,'multiline':True]
['text':' Walk the array of concurrent transactions. ','line_number':346,'multiline':True]
['text':' Update the last running transaction ID. ','line_number':351,'multiline':True]
['text':'
             * If the transaction is still allocating its ID, then we spin here until it gets its
             * valid ID.
             ','line_number':354,'multiline':True]
['text':'
                 * There is still a chance that fetched ID is not valid after ID allocation, so we
                 * check again here. The read of transaction ID should be carefully ordered: we want
                 * to re-read ID from transaction state after this transaction completes ID
                 * allocation.
                 ','line_number':360,'multiline':True]
['text':' Update the metadata pinned ID. ','line_number':375,'multiline':True]
['text':'
         * !!!
         * Note: Don't ignore pinned ID values older than the previous
         * oldest ID.  Read-uncommitted operations publish pinned ID
         * values without acquiring the scan lock to protect the global
         * table.  See the comment in __wt_txn_cursor_op for more
         * details.
         ','line_number':379,'multiline':True]
['text':' The metadata pinned ID can't move past the oldest ID. ','line_number':396,'multiline':True]
['text':'
 * __wt_txn_update_oldest --
 *     Sweep the running transactions to update the oldest ID required.
 ','line_number':406,'multiline':True]
['text':' Try to move the pinned timestamp forward. ','line_number':431,'multiline':True]
['text':'
     * For pure read-only workloads, or if the update isn't forced and the oldest ID isn't too far
     * behind, avoid scanning.
     ','line_number':435,'multiline':True]
['text':' First do a read-only scan. ','line_number':443,'multiline':True]
['text':'
     * If the state hasn't changed (or hasn't moved far enough for non-forced updates), give up.
     ','line_number':451,'multiline':True]
['text':' It looks like an update is necessary, wait for exclusive access. ','line_number':461,'multiline':True]
['text':'
     * If the oldest ID has been updated while we waited, don't bother scanning.
     ','line_number':467,'multiline':True]
['text':'
     * Re-scan now that we have exclusive access. This is necessary because threads get transaction
     * snapshots with read locks, and we have to be sure that there isn't a thread that has got a
     * snapshot locally but not yet published its snap_min.
     ','line_number':475,'multiline':True]
['text':' Update the public IDs. ','line_number':482,'multiline':True]
['text':' Output a verbose message about long-running transactions,
         * but only when some progress is being made. ','line_number':490,'multiline':True]
['text':'
 * __txn_config_operation_timeout --
 *     Configure a transactions operation timeout duration.
 ','line_number':505,'multiline':True]
['text':' Retrieve the maximum operation time. ','line_number':520,'multiline':True]
['text':'
     * The default configuration value is 0, we can't tell if they're setting it back to 0 or, if
     * the default was automatically passed in.
     ','line_number':523,'multiline':True]
['text':'
         * The op timer will generally be started on entry to the API call however when we configure
         * it internally we need to start it separately.
         ','line_number':529,'multiline':True]
['text':'
 * __wt_txn_config --
 *     Configure a transaction.
 ','line_number':539,'multiline':True]
['text':'
     * The default sync setting is inherited from the connection, but can be overridden by an
     * explicit "sync" setting for this transaction.
     *
     * We want to distinguish between inheriting implicitly and explicitly.
     ','line_number':564,'multiline':True]
['text':'
         * This is an explicit setting of sync. Set the flag so that we know not to overwrite it in
         * commit_transaction.
         ','line_number':573,'multiline':True]
['text':'
     * If sync is turned off explicitly, clear the transaction's sync field.
     ','line_number':579,'multiline':True]
['text':' Check if prepared updates should be ignored during reads. ','line_number':585,'multiline':True]
['text':' Check if commits without a timestamp are allowed. ','line_number':592,'multiline':True]
['text':'
     * Check if the prepare timestamp and the commit timestamp of a prepared transaction need to be
     * rounded up.
     ','line_number':597,'multiline':True]
['text':' Check if read timestamp needs to be rounded up. ','line_number':605,'multiline':True]
['text':'
         * In the event that we error during configuration we should clear the flags on the
         * transaction so they are not set in a subsequent call to transaction begin.
         ','line_number':618,'multiline':True]
['text':'
 * __wt_txn_reconfigure --
 *     WT_SESSION::reconfigure for transactions.
 ','line_number':626,'multiline':True]
['text':'
 * __wt_txn_release --
 *     Release the resources associated with the current transaction.
 ','line_number':651,'multiline':True]
['text':' Clear the transaction's ID from the global table. ','line_number':666,'multiline':True]
['text':'
         * Be extra careful to cleanup everything for checkpoints: once the global checkpoint ID is
         * cleared, we can no longer tell if this session is doing a checkpoint.
         ','line_number':671,'multiline':True]
['text':'
         * If transaction is prepared, this would have been done in prepare.
         ','line_number':677,'multiline':True]
['text':' Free the scratch buffer allocated for logging. ','line_number':689,'multiline':True]
['text':' Discard any memory from the session's stash that we can. ','line_number':692,'multiline':True]
['text':'
     * Reset the transaction state to not running and release the snapshot.
     ','line_number':696,'multiline':True]
['text':' Clear the read timestamp. ','line_number':700,'multiline':True]
['text':'
     * Ensure the transaction flags are cleared on exit
     *
     * Purposely do NOT clear the commit and durable timestamps on release. Other readers may still
     * find these transactions in the durable queue and will need to see those timestamps.
     ','line_number':706,'multiline':True]
['text':' Clear operation timer. ','line_number':715,'multiline':True]
['text':'
 * __txn_prepare_rollback_restore_hs_update --
 *     Restore the history store update to the update chain before roll back prepared update evicted
 *     to disk
 ','line_number':719,'multiline':True]
['text':' Get current value. ','line_number':745,'multiline':True]
['text':' The value older than the prepared update in the history store must be a full value. ','line_number':748,'multiline':True]
['text':' Use time window in cell to initialize the update. ','line_number':751,'multiline':True]
['text':'
     * Set the flag to indicate that this update has been restored from history store for the
     * rollback of a prepared transaction.
     ','line_number':758,'multiline':True]
['text':' If the history store record has a valid stop time point, append it. ','line_number':770,'multiline':True]
['text':'
         * Set the flag to indicate that this update has been restored from history store for the
         * rollback of a prepared transaction.
         ','line_number':778,'multiline':True]
['text':' Walk to the end of the chain and we can only have prepared updates on the update chain. ','line_number':793,'multiline':True]
['text':' Append the update to the end of the chain. ','line_number':802,'multiline':True]
['text':'
 * __txn_timestamp_usage_check --
 *     Check if a commit will violate timestamp rules.
 ','line_number':816,'multiline':True]
['text':' Timestamps are ignored on logged files. ','line_number':837,'multiline':True]
['text':'
     * Do not check for timestamp usage in recovery. We don't expect recovery to be using timestamps
     * when applying commits, and it is possible that timestamps may be out-of-order in log replay.
     ','line_number':841,'multiline':True]
['text':' Check for disallowed timestamps. ','line_number':850,'multiline':True]
['text':'
     * Ordered consistency requires all updates use timestamps, once they are first used, but this
     * test can be turned off on a per-transaction basis.
     ','line_number':866,'multiline':True]
['text':' Ordered consistency requires all updates be in timestamp order. ','line_number':883,'multiline':True]
['text':'
 * __txn_fixup_hs_update --
 *     Fix the history store update with the max stop time point if we commit the prepared update.
 ','line_number':899,'multiline':True]
['text':'
     * If the history update already has a stop time point there is no work to do. This happens if a
     * deleted key is reinserted by a prepared update.
     ','line_number':919,'multiline':True]
['text':'
     * Transaction error is cleared temporarily as cursor functions are not allowed after an error
     * or a prepared transaction.
     ','line_number':928,'multiline':True]
['text':'
     * The API layer will immediately return an error if the WT_TXN_PREPARE flag is set before
     * attempting cursor operations. However, we can't clear the WT_TXN_PREPARE flag because a
     * function in the eviction flow may attempt to forcibly rollback the transaction if it is not
     * marked as a prepared transaction. The flag WT_TXN_PREPARE_IGNORE_API_CHECK is set so that
     * cursor operations can proceed without having to clear the WT_TXN_PREPARE flag.
     ','line_number':935,'multiline':True]
['text':' Get current value. ','line_number':945,'multiline':True]
['text':' The old stop timestamp must be max. ','line_number':949,'multiline':True]
['text':' The value older than the prepared update in the history store must be a full value. ','line_number':951,'multiline':True]
['text':'
     * Set the stop time point to be the committing transaction's time point and copy the start time
     * point from the current history store update.
     ','line_number':954,'multiline':True]
['text':'
     * We need to update the stop durable timestamp stored in the history store value.
     *
     * Pack the value using cursor api.
     ','line_number':963,'multiline':True]
['text':'
 * __txn_search_prepared_op --
 *     Search for an operation's prepared update.
 ','line_number':982,'multiline':True]
['text':'
     * Transaction error is cleared temporarily as cursor functions are not allowed after an error.
     ','line_number':1009,'multiline':True]
['text':'
     * The API layer will immediately return an error if the WT_TXN_PREPARE flag is set before
     * attempting cursor operations. However, we can't clear the WT_TXN_PREPARE flag because a
     * function in the eviction flow may attempt to forcibly rollback the transaction if it is not
     * marked as a prepared transaction. The flag WT_TXN_PREPARE_IGNORE_API_CHECK is set so that
     * cursor operations can proceed without having to clear the WT_TXN_PREPARE flag.
     ','line_number':1014,'multiline':True]
['text':'
     * We cannot guarantee that we find an update when collators are being used as we cannot sort
     * modifications on collated b-trees.
     ','line_number':1048,'multiline':True]
['text':'
 * __txn_append_tombstone --
 *     Append a tombstone to the end of a keys update chain.
 ','line_number':1058,'multiline':True]
['text':'
 * __txn_resolve_prepared_update_chain --
 *     Helper for resolving updates. Recursively visit the update chain and resolve the updates on
 *     the way back out, so older updates are resolved first; this avoids a race with reconciliation
 *     (see WT-6778).
 ','line_number':1085,'multiline':True]
['text':' If we've reached the end of the chain, we're done looking. ','line_number':1095,'multiline':True]
['text':'
     * Aborted updates can exist in the update chain of our transaction. Generally this will occur
     * due to a reserved update. As such we should skip over these updates entirely.
     ','line_number':1099,'multiline':True]
['text':'
     * If the transaction id is then different and not aborted we know we've reached the end of our
     * update chain and don't need to look deeper.
     ','line_number':1108,'multiline':True]
['text':' Go down the chain. Do the resolves on the way back up. ','line_number':1115,'multiline':True]
['text':'
     * Performing an update on the same key where the truncate operation is performed can lead to
     * updates that are already resolved in the updated list. Ignore the already resolved updates.
     ','line_number':1124,'multiline':True]
['text':' Resolve the prepared update to be a committed update. ','line_number':1133,'multiline':True]
['text':' Sleep for 100ms in the prepared resolution path if configured. ','line_number':1136,'multiline':True]
['text':'
 * __txn_resolve_prepared_op --
 *     Resolve a transaction's operations indirect references.
 ','line_number':1142,'multiline':True]
['text':'
     * Aborted updates can exist in the update chain of our transaction. Generally this will occur
     * due to a reserved update. As such we should skip over these updates.
     ','line_number':1187,'multiline':True]
['text':'
     * The head of the update chain is not a prepared update, which means all the prepared updates
     * of the key are resolved. The head of the update chain can also be null in the scenario that
     * we rolled back all associated updates in the previous iteration of this function.
     ','line_number':1195,'multiline':True]
['text':' A prepared operation that is rolled back will not have a timestamp worth asserting on. ','line_number':1203,'multiline':True]
['text':'
     * Get the underlying btree and the in-memory page with the prepared updates that are to be
     * resolved. The hazard pointer on the page is already acquired during the cursor search
     * operation to prevent eviction evicting the page while resolving the prepared updates.
     ','line_number':1213,'multiline':True]
['text':'
     * If the prepared update is a single tombstone, we don't need to do anything special and we can
     * directly resolve it in memory.
     *
     * If the prepared update is not a tombstone or we have multiple prepared updates in the same
     * transaction. There are four base cases:
     *
     * 1) Prepared updates are on the update chain and hasn't been reconciled to write to data
     *    store.
     *     Simply resolve the prepared updates in memory.
     *
     * 2) Prepared updates are written to the data store.
     *     If there is no older updates written to the history store:
     *         commit: simply resolve the prepared updates in memory.
     *         rollback: delete the whole key.
     *
     *     If there are older updates written to the history store:
     *         commit: fix the stop timestamp of the newest update in the history store if it has a
     *                 max timestamp.
     *         rollback: restore the newest update in the history store to the data store and mark
     *                   it to be deleted from the history store in the future reconciliation.
     *
     * 3) Prepared updates are successfully reconciled to a new disk image in eviction but the
     *    eviction fails and the updates are restored back to the old disk image.
     *     If there is no older updates written to the history store:
     *         commit: simply resolve the prepared updates in memory.
     *         rollback: delete the whole key.
     *
     *     If there are older updates written to the history store:
     *          commit: fix the stop timestamp of the newest update in the history store if it has a
     *                  max timestamp.
     *          rollback: mark the data update (or tombstone and data update) that is older
     *                    than the prepared updates to be deleted from the history store in the
     *                    future reconciliation.
     *
     * 4) We are running an in-memory database:
     *     commit: resolve the prepared updates in memory.
     *     rollback: if the prepared update is written to the disk image, delete the whole key.
     ','line_number':1221,'multiline':True]
['text':'
     * We also need to handle the on disk prepared updates if we have a prepared delete and a
     * prepared update on the disk image.
     ','line_number':1261,'multiline':True]
['text':'
     * If the first committed update older than the prepared update has already been marked to be
     * deleted from the history store, we are in the case that there was an older prepared update
     * that was rolled back.
     *
     * 1) We have a prepared update Up and an update U on the update chain initially.
     * 2) An eviction writes Up to the disk and U to the history store.
     * 3) The eviction fails and everything is restored.
     * 4) We rollback Up and mark U to be deleted from the history store.
     * 5) We add another prepared update to the update chain.
     *
     * Check the WT_UPDATE_TO_DELETE_FROM_HS to see if we have already handled the older prepared
     * update or not. Ignore if it is already handled.
     ','line_number':1270,'multiline':True]
['text':'
         * If we see the first committed update has been moved to the history store, we must have
         * done a successful reconciliation on the page but failed to evict it. Also reconciliation
         * could not possibly empty the page because the prepared update is not globally visible.
         * Therefore, reconciliation must have either split the page or done a page rewrite.
         *
         * In this case, we still need to resolve the prepared update as if we have successfully
         * evicted the page because the value older than the prepared update has been written to the
         * history store with the max timestamp.
         ','line_number':1294,'multiline':True]
['text':'
         * Marked the update older than the prepared update that is already in the history store to
         * be deleted from the history store.
         ','line_number':1307,'multiline':True]
['text':' We may not find a full update following the tombstone if it is obsolete. ','line_number':1318,'multiline':True]
['text':' Fall through. ','line_number':1327,'multiline':True]
['text':'
         * Open a history store table cursor and scan the history store for the given btree and key
         * with maximum start timestamp to let the search point to the last version of the key.
         ','line_number':1331,'multiline':True]
['text':'
         * Locate the previous update from the history store. We know there may be content in the
         * history store if the prepared update is written to the disk image or first committed
         * update older than the prepared update is marked as WT_UPDATE_HS. The second case is rare
         * but can happen if the previous eviction that writes the prepared update to the disk image
         * fails after reconciliation.
         *
         * We need to locate the history store update before we resolve the prepared updates because
         * if we abort the prepared updates first, the history store search may race with other
         * sessions modifying the same key and checkpoint moving the new updates to the history
         * store.
         ','line_number':1346,'multiline':True]
['text':' We should only get not found if the prepared update is on disk. ','line_number':1360,'multiline':True]
['text':'
             * Restore the history store update to the update chain if we are rolling back the
             * prepared update written to the disk image.
             ','line_number':1364,'multiline':True]
['text':'
             * Allocate a tombstone and prepend it to the row so when we reconcile the update chain
             * we don't copy the prepared cell, which is now associated with a rolled back prepare,
             * and instead write nothing.
             ','line_number':1372,'multiline':True]
['text':'
         * For in-memory configurations of WiredTiger if a prepared update is reconciled and then
         * rolled back the on-page value will not be marked as aborted until the next eviction. In
         * the special case where this rollback results in the update chain being entirely comprised
         * of aborted updates other transactions attempting to write to the same key will look at
         * the on-page value, think the prepared transaction is still active, and falsely report a
         * write conflict. To prevent this scenario append a tombstone to the update chain when
         * rolling back a prepared reconciled update would result in only aborted updates on the
         * update chain.
         ','line_number':1382,'multiline':True]
['text':'
     * Newer updates are inserted at head of update chain, and transaction operations are added at
     * the tail of the transaction modify chain.
     *
     * For example, a transaction has modified [k,v] as
     *	[k, v]  -> [k, u1]   (txn_op : txn_op1)
     *	[k, u1] -> [k, u2]   (txn_op : txn_op2)
     *	update chain : u2->u1
     *	txn_mod      : txn_op1->txn_op2.
     *
     * Only the key is saved in the transaction operation structure, hence we cannot identify
     * whether "txn_op1" corresponds to "u2" or "u1" during commit/rollback.
     *
     * To make things simpler we will handle all the updates that match the key saved in a
     * transaction operation in a single go. As a result, multiple updates of a key, if any will be
     * resolved as part of the first transaction operation resolution of that key, and subsequent
     * transaction operation resolution of the same key will be effectively a no-op.
     *
     * In the above example, we will resolve "u2" and "u1" as part of resolving "txn_op1" and will
     * not do any significant thing as part of "txn_op2".
     ','line_number':1403,'multiline':True]
['text':' Mark the page dirty once the prepared updates are resolved. ','line_number':1426,'multiline':True]
['text':'
     * Fix the history store record's stop time point if we are committing the prepared update and
     * the previous update is written to the history store.
     ','line_number':1429,'multiline':True]
['text':'
     * If we are committing a prepared transaction we can check that we resolved the whole update
     * chain. As long as we don't walk past a globally visible update we are guaranteed that the
     * update chain won't be freed concurrently. In the commit case prepared updates cannot become
     * globally visible before we finish resolving them, this is an implicit contract within
     * WiredTiger.
     *
     * In the rollback case the updates are changed to aborted and in theory a newer update could be
     * added to the chain concurrently and become globally visible. Thus our updates could be freed.
     * We don't walk the chain in rollback for that reason.
     ','line_number':1437,'multiline':True]
['text':'
             * Ignore aborted updates. We could have them in the middle of the relevant update
             * chain, as a result of the cursor reserve API.
             ','line_number':1450,'multiline':True]
['text':' Exit once we have visited all updates from the current transaction. ','line_number':1456,'multiline':True]
['text':' Any update we find should be resolved. ','line_number':1459,'multiline':True]
['text':'
 * __txn_mod_sortable_key --
 *     Given an operation return a boolean indicating if it has a sortable key.
 ','line_number':1471,'multiline':True]
['text':'
 * __txn_mod_compare --
 *     Qsort comparison routine for transaction modify list.
 ','line_number':1494,'multiline':True]
['text':'
     * We want to sort on two things:
     *  - B-tree ID
     *  - Key
     * However, there are a number of modification types that don't have a key to be sorted on. This
     * requires us to add a stage between sorting on B-tree ID and key. At this intermediate stage,
     * we sort on whether the modifications have a key.
     *
     * We need to uphold the contract that all modifications on the same key are contiguous in the
     * final modification array. Technically they could be separated by non key modifications,
     * but for simplicity's sake we sort them apart.
     *
     * Qsort comparators are expected to return -1 if the first argument is smaller than the second,
     * 1 if the second argument is smaller than the first, and 0 if both arguments are equal.
     ','line_number':1508,'multiline':True]
['text':' Order by b-tree ID. ','line_number':1524,'multiline':True]
['text':'
     * Order by whether the given operation has a key. We don't want to call key compare incorrectly
     * especially given that u is a union which would create undefined behavior.
     ','line_number':1530,'multiline':True]
['text':'
     * In the case where both arguments don't have a key they are considered to be equal, we don't
     * care exactly how they get sorted.
     ','line_number':1540,'multiline':True]
['text':' Finally, order by key. We cannot sort if there is a collator as we need a session pointer. ','line_number':1547,'multiline':True]
['text':'
 * __wt_txn_commit --
 *     Commit the current transaction.
 ','line_number':1560,'multiline':True]
['text':' Permit the commit if the transaction failed, but was read-only. ','line_number':1596,'multiline':True]
['text':' Configure the timeout for this commit operation. ','line_number':1600,'multiline':True]
['text':'
     * Clear the prepared round up flag if the transaction is not prepared. There is no rounding up
     * to do in that case.
     ','line_number':1603,'multiline':True]
['text':' Set the commit and the durable timestamps. ','line_number':1610,'multiline':True]
['text':'
     * Release our snapshot in case it is keeping data pinned (this is particularly important for
     * checkpoints). Before releasing our snapshot, copy values into any positioned cursors so they
     * don't point to updates that could be freed once we don't have a snapshot. If this transaction
     * is prepared, then copying values would have been done during prepare.
     ','line_number':1630,'multiline':True]
['text':'
     * Resolving prepared updates is expensive. Sort prepared modifications so all updates for each
     * page within each file are done at the same time.
     ','line_number':1642,'multiline':True]
['text':' If we are logging, write a commit log record. ','line_number':1649,'multiline':True]
['text':' Assert environment and tree are logging compatible, the fast-check is short-hand. ','line_number':1651,'multiline':True]
['text':'
         * The default sync setting is inherited from the connection, but can be overridden by an
         * explicit "sync" setting for this transaction.
         ','line_number':1655,'multiline':True]
['text':'
         * If the user chose the default setting, check whether sync is enabled for this transaction
         * (either inherited or via begin_transaction). If sync is disabled, clear the field to
         * avoid the log write being flushed.
         *
         * Otherwise check for specific settings. We don't need to check for "on" because that is
         * the default inherited from the connection. If the user set anything in begin_transaction,
         * we only override with an explicit setting.
         ','line_number':1661,'multiline':True]
['text':'
             * If the caller already set sync on begin_transaction then they should not be using
             * sync on commit_transaction. Flag that as an error.
             ','line_number':1674,'multiline':True]
['text':'
             * We don't need to check for "on" here because that is the default to inherit from the
             * connection setting.
             ','line_number':1682,'multiline':True]
['text':'
         * We hold the visibility lock for reading from the time we write our log record until the
         * time we release our transaction so that the LSN any checkpoint gets will always reflect
         * visible data.
         ','line_number':1688,'multiline':True]
['text':' Process updates. ','line_number':1698,'multiline':True]
['text':'
                 * Switch reserved operations to abort to simplify obsolete update list truncation.
                 ','line_number':1710,'multiline':True]
['text':'
                 * Don't reset the timestamp of the history store records with history store
                 * transaction timestamp. Those records should already have the original time window
                 * when they are inserted into the history store.
                 ','line_number':1718,'multiline':True]
['text':'
                 * If an operation has the key repeated flag set, skip resolving prepared updates as
                 * the work will happen on a different modification in this txn.
                 ','line_number':1729,'multiline':True]
['text':'
                 * Sleep for some number of updates between resolving prepared operations when
                 * configured, however, avoid causing too much stress when there are a large number
                 * of updates. Multiplying by 36 provides a reasonable chance of calling the stress
                 * (as it's a highly composite number) without exceeding a total of 36 calls over
                 * the total mod_count.
                 ','line_number':1736,'multiline':True]
['text':' Other operations don't need timestamps. ','line_number':1756,'multiline':True]
['text':' If we used the cursor to resolve prepared updates, the key now has been freed. ','line_number':1760,'multiline':True]
['text':'
     * Note: we're going to commit: nothing can fail after this point. Set a check, it's too easy to
     * call an error handling macro between here and the end of the function.
     ','line_number':1775,'multiline':True]
['text':'
     * Free updates.
     *
     * Resolve any fast-truncate transactions and allow eviction to proceed on instantiated pages.
     * This isn't done as part of the initial processing because until now the commit could still
     * switch to an abort. The action allowing eviction to proceed is clearing the WT_UPDATE list,
     * (if any), associated with the commit. We're the only consumer of that list and we no longer
     * need it, and eviction knows it means abort or commit has completed on instantiated pages.
     ','line_number':1781,'multiline':True]
['text':'
             * Only two cases are possible. First: the state is WT_REF_DELETED. In this case
             * page_del cannot be NULL yet because an uncommitted operation cannot have reached
             * global visibility. Otherwise: there is an uncommitted delete operation we're
             * handling, so the page can't be in a non-deleted state, and the tree can't be
             * readonly. Therefore the page must have been instantiated, the state must be
             * WT_REF_MEM, and there should be an update list in modify->inst_updates. There may
             * also be a non-NULL page_del to update.
             ','line_number':1794,'multiline':True]
['text':'
     * If durable is set, we'll try to update the global durable timestamp with that value. If
     * durable isn't set, durable is implied to be the same as commit so we'll use that instead.
     ','line_number':1815,'multiline':True]
['text':'
     * If we have made some updates visible, start a new commit generation: any cached snapshots
     * have to be refreshed.
     ','line_number':1829,'multiline':True]
['text':' First check if we've made something durable in the future. ','line_number':1836,'multiline':True]
['text':'
     * If it looks like we'll need to move the global durable timestamp, attempt atomic cas and
     * re-check.
     ','line_number':1844,'multiline':True]
['text':'
     * Stable timestamp cannot be concurrently increased greater than or equal to the prepared
     * transaction's durable timestamp. Otherwise, checkpoint may only write partial updates of the
     * transaction.
     ','line_number':1858,'multiline':True]
['text':'
     * We're between transactions, if we need to block for eviction, it's a good time to do so.
     * Ignore error returns, the return must reflect the fate of the transaction.
     ','line_number':1870,'multiline':True]
['text':' Check for a failure after we can no longer fail. ','line_number':1886,'multiline':True]
['text':'
     * Check for a prepared transaction, and quit: we can't ignore the error and we can't roll back
     * a prepared transaction.
     ','line_number':1891,'multiline':True]
['text':'
 * __wt_txn_prepare --
 *     Prepare the current transaction.
 ','line_number':1903,'multiline':True]
['text':'
     * A transaction should not have updated any of the logged tables, if debug mode logging is not
     * turned on.
     ','line_number':1921,'multiline':True]
['text':' Set the prepare timestamp. ','line_number':1928,'multiline':True]
['text':'
     * We are about to release the snapshot: copy values into any positioned cursors so they don't
     * point to updates that could be freed once we don't have a snapshot.
     ','line_number':1938,'multiline':True]
['text':' Assert it's not an update to the history store file. ','line_number':1948,'multiline':True]
['text':' Metadata updates should never be prepared. ','line_number':1951,'multiline':True]
['text':'
         * Logged table updates should never be prepared. As these updates are immediately durable,
         * it is not possible to roll them back if the prepared transaction is rolled back.
         ','line_number':1956,'multiline':True]
['text':'
             * Switch reserved operation to abort to simplify obsolete update list truncation. The
             * object free function clears the operation type so we don't try to visit this update
             * again: it can be discarded.
             ','line_number':1974,'multiline':True]
['text':'
             * If there are older updates to this key by the same transaction, set the repeated key
             * flag on this operation. This is later used in txn commit/rollback so we only resolve
             * each set of prepared updates once. Skip reserved updates, they're ignored as they're
             * simply discarded when we find them. Also ignore updates created by instantiating fast
             * truncation pages, they aren't linked into the transaction's modify list and so can't
             * be considered.
             ','line_number':1990,'multiline':True]
['text':' Other operations don't need timestamps. ','line_number':2011,'multiline':True]
['text':' Set transaction state to prepare. ','line_number':2021,'multiline':True]
['text':' Release our snapshot in case it is keeping data pinned. ','line_number':2024,'multiline':True]
['text':'
     * Clear the transaction's ID from the global table, to facilitate prepared data visibility, but
     * not from local transaction structure.
     ','line_number':2027,'multiline':True]
['text':'
 * __wt_txn_rollback --
 *     Roll back the current transaction.
 ','line_number':2037,'multiline':True]
['text':' Configure the timeout for this rollback operation. ','line_number':2065,'multiline':True]
['text':'
     * Resolving prepared updates is expensive. Sort prepared modifications so all updates for each
     * page within each file are done at the same time.
     ','line_number':2068,'multiline':True]
['text':' Rollback and free updates. ','line_number':2075,'multiline':True]
['text':' Assert it's not an update to the history store file. ','line_number':2077,'multiline':True]
['text':' Metadata updates should never be rolled back. ','line_number':2080,'multiline':True]
['text':'
                 * If an operation has the key repeated flag set, skip resolving prepared updates as
                 * the work will happen on a different modification in this txn.
                 ','line_number':2101,'multiline':True]
['text':'
             * Nothing to do: these operations are only logged for recovery. The in-memory changes
             * will be rolled back with a combination of WT_TXN_OP_REF_DELETE and WT_TXN_OP_INMEM
             * operations.
             ','line_number':2117,'multiline':True]
['text':' If we used the cursor to resolve prepared updates, the key now has been freed. ','line_number':2126,'multiline':True]
['text':'
     * We're between transactions, if we need to block for eviction, it's a good time to do so.
     * Ignore error returns, the return must reflect the fate of the transaction.
     ','line_number':2143,'multiline':True]
['text':'
 * __wt_txn_rollback_required --
 *     Prepare to log a reason if the user attempts to use the transaction to do anything other than
 *     rollback.
 ','line_number':2153,'multiline':True]
['text':'
 * __wt_txn_init --
 *     Initialize a session's transaction data.
 ','line_number':2165,'multiline':True]
['text':' Allocate the WT_TXN structure, including a variable length array of snapshot information. ','line_number':2174,'multiline':True]
['text':'
     * Take care to clean these out in case we are reusing the transaction for eviction.
     ','line_number':2186,'multiline':True]
['text':'
 * __wt_txn_init_checkpoint_cursor --
 *     Create a transaction object for a checkpoint cursor. On success, takes charge of the snapshot
 *     array passed down, which should have been allocated separately, and nulls the pointer. (On
 *     failure, the caller must destroy it.)
 ','line_number':2195,'multiline':True]
['text':'
     * Allocate the WT_TXN structure. Don't use the variable-length array at the end, because the
     * code for reading the snapshot allocates the snapshot list itself; copying it serves no
     * purpose, and twisting up the read code to allow controlling the allocation from here is not
     * worthwhile.
     *
     * Allocate a byte at the end so that __snapshot (at the end of the struct) doesn't point at an
     * adjacent malloc block; we'd like to be able to assert that in checkpoint cursor transactions
     * snapshot doesn't point at __snapshot, to make sure an ordinary transaction doesn't flow to
     * the checkpoint cursor close function. If an adjacent malloc block, that might not be true.
     ','line_number':2207,'multiline':True]
['text':' We have no transaction ID and won't gain one, being read-only. ','line_number':2220,'multiline':True]
['text':' Use snapshot isolation. ','line_number':2223,'multiline':True]
['text':' Save the snapshot data. ','line_number':2226,'multiline':True]
['text':'
     * At this point we have taken charge of the snapshot's transaction list; it has been moved to
     * the dummy transaction. Null the caller's copy so it doesn't get freed twice if something
     * above us fails after we return.
     ','line_number':2232,'multiline':True]
['text':' Set the read, stable and oldest timestamps.  ','line_number':2239,'multiline':True]
['text':' Set the flag that indicates if we have a timestamp. ','line_number':2244,'multiline':True]
['text':'
     * Set other relevant flags. Always ignore prepared values; they can get into checkpoints.
     *
     * Prepared values don't get written out by checkpoints by default, but can appear if pages get
     * evicted. So whether any given prepared value from any given prepared but yet-uncommitted
     * transaction shows up or not is arbitrary and unpredictable. Therefore, failing on it serves
     * no data integrity purpose and will only make the system flaky.
     *
     * There is a problem, however. Prepared transactions are allowed to commit before stable if
     * stable moves forward, as long as the durable timestamp is after stable. Such transactions can
     * therefore be committed after (in execution time) the checkpoint is taken but with a commit
     * timestamp less than the checkpoint's stable timestamp. They will then exist in the live
     * database and be visible if read as of the checkpoint timestamp, but not exist in the
     * checkpoint, which is inconsistent. There is probably nothing that can be done about this
     * without making prepared transactions durable in prepared state, which is a Big Deal, so
     * applications using prepared transactions and using this commit leeway need to be cognizant of
     * the issue.
     ','line_number':2248,'multiline':True]
['text':'
 * __wt_txn_close_checkpoint_cursor --
 *     Dispose of the private transaction object in a checkpoint cursor.
 ','line_number':2274,'multiline':True]
['text':' The snapshot list isn't at the end of the transaction structure here; free it explicitly. ','line_number':2286,'multiline':True]
['text':'
 * __wt_txn_stats_update --
 *     Update the transaction statistics for return to the application.
 ','line_number':2293,'multiline':True]
['text':'
 * __wt_txn_release_resources --
 *     Release resources for a session's transaction data.
 ','line_number':2359,'multiline':True]
['text':'
 * __wt_txn_destroy --
 *     Destroy a session's transaction data.
 ','line_number':2377,'multiline':True]
['text':'
 * __wt_txn_global_init --
 *     Initialize the global transaction state.
 ','line_number':2388,'multiline':True]
['text':'
 * __wt_txn_global_destroy --
 *     Destroy the global transaction state.
 ','line_number':2418,'multiline':True]
['text':'
 * __wt_txn_activity_drain --
 *     Wait for transactions to quiesce.
 ','line_number':2439,'multiline':True]
['text':'
     * It's possible that the eviction server is in the middle of a long operation, with a
     * transaction ID pinned. In that case, we will loop here until the transaction ID is released,
     * when the oldest transaction ID will catch up with the current ID.
     ','line_number':2448,'multiline':True]
['text':'
 * __wt_txn_global_shutdown --
 *     Shut down the global transaction state.
 ','line_number':2465,'multiline':True]
['text':'
     * Perform a system-wide checkpoint so that all tables are consistent with each other. All
     * transactions are resolved but ignore timestamps to make sure all data gets to disk. Do this
     * before shutting down all the subsystems. We have shut down all user sessions, but send in
     * true for waiting for internal races.
     ','line_number':2484,'multiline':True]
['text':'
         * Perform rollback to stable to ensure that the stable version is written to disk on a
         * clean shutdown.
         ','line_number':2499,'multiline':True]
['text':' Time since the shutdown RTS has started. ','line_number':2510,'multiline':True]
['text':'
             * Mark the metadata dirty so we flush it on close, allowing recovery to be skipped.
             ','line_number':2534,'multiline':True]
['text':' Time since the shutdown checkpoint has started. ','line_number':2541,'multiline':True]
['text':'
 * __wt_txn_is_blocking --
 *     Return an error if this transaction is likely blocking eviction because of a pinned
 *     transaction ID, called by eviction to determine if a worker thread should be released from
 *     eviction.
 ','line_number':2552,'multiline':True]
['text':' We can't roll back prepared transactions. ','line_number':2569,'multiline':True]
['text':'
     * FIXME: SERVER-44870
     *
     * MongoDB can't (yet) handle rolling back read only transactions. For this reason, don't check
     * unless there's at least one update or we're configured to time out thread operations (a way
     * to confirm our caller is prepared for rollback).
     ','line_number':2574,'multiline':True]
['text':'
     * Most applications that are not using transactions to read/walk with a cursor cannot handle
     * having rollback returned nor should the API reset and retry the operation, losing the
     * cursor's position. Skip the check if there are no updates, the thread operation did not time
     * out and the operation is not running in a transaction.
     ','line_number':2584,'multiline':True]
['text':'
     * Check if either the transaction's ID or its pinned ID is equal to the oldest transaction ID.
     ','line_number':2594,'multiline':True]
['text':'
 * __wt_verbose_dump_txn_one --
 *     Output diagnostic information about a transaction structure.
 ','line_number':2602,'multiline':True]
['text':'
     * Dump the information of the passed transaction into a buffer, to be logged with an optional
     * error message.
     ','line_number':2632,'multiline':True]
['text':'
     * Log a message and return an error if error code and an optional error string has been passed.
     ','line_number':2660,'multiline':True]
['text':'
 * __wt_verbose_dump_txn --
 *     Output diagnostic information about the global transaction state.
 ','line_number':2672,'multiline':True]
['text':'
     * Walk each session transaction state and dump information. Accessing the content of session
     * handles is not thread safe, so some information may change while traversing if other threads
     * are active at the same time, which is OK since this is diagnostic code.
     ','line_number':2729,'multiline':True]
['text':' Skip sessions with no active transaction ','line_number':2737,'multiline':True]
