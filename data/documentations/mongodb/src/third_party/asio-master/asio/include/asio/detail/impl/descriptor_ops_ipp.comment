['text':'','line_number':1,'multiline':False]
['text':' detail/impl/descriptor_ops.ipp','line_number':2,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':3,'multiline':False]
['text':'','line_number':4,'multiline':False]
['text':' Copyright (c) 2003-2018 Christopher M. Kohlhoff (chris at kohlhoff dot com)','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0. (See accompanying','line_number':7,'multiline':False]
['text':' file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]
['text':'','line_number':9,'multiline':False]
['text':' defined(_MSC_VER) && (_MSC_VER >= 1200)','line_number':16,'multiline':False]
['text':' According to UNIX Network Programming Vol. 1, it is possible for','line_number':54,'multiline':False]
['text':' close() to fail with EWOULDBLOCK under certain circumstances. What','line_number':55,'multiline':False]
['text':' isn't clear is the state of the descriptor after this error. The one','line_number':56,'multiline':False]
['text':' current OS where this behaviour is seen, Windows, says that the socket','line_number':57,'multiline':False]
['text':' remains open. Therefore we'll put the descriptor back into blocking','line_number':58,'multiline':False]
['text':' mode and have another attempt at closing it.','line_number':59,'multiline':False]
['text':' defined(__SYMBIAN32__)','line_number':64,'multiline':False]
['text':' defined(__SYMBIAN32__)','line_number':67,'multiline':False]
['text':' defined(__SYMBIAN32__)','line_number':98,'multiline':False]
['text':' defined(__SYMBIAN32__)','line_number':101,'multiline':False]
['text':' Clearing the user-set non-blocking mode always overrides any','line_number':110,'multiline':False]
['text':' internally-set non-blocking flag. Any subsequent asynchronous','line_number':111,'multiline':False]
['text':' operations will need to re-enable non-blocking I/O.','line_number':112,'multiline':False]
['text':' It does not make sense to clear the internal non-blocking flag if the','line_number':132,'multiline':False]
['text':' user still wants non-blocking behaviour. Return an error and let the','line_number':133,'multiline':False]
['text':' caller figure out whether to update the user-set non-blocking flag.','line_number':134,'multiline':False]
['text':' defined(__SYMBIAN32__)','line_number':148,'multiline':False]
['text':' defined(__SYMBIAN32__)','line_number':151,'multiline':False]
['text':' A request to read 0 bytes on a stream is a no-op.','line_number':175,'multiline':False]
['text':' Read some data.','line_number':182,'multiline':False]
['text':' Try to complete the operation without blocking.','line_number':185,'multiline':False]
['text':' Check if operation succeeded.','line_number':190,'multiline':False]
['text':' Check for EOF.','line_number':194,'multiline':False]
['text':' Operation failed.','line_number':201,'multiline':False]
['text':' Wait for descriptor to become ready.','line_number':207,'multiline':False]
['text':' Read some data.','line_number':218,'multiline':False]
['text':' Check for end of stream.','line_number':223,'multiline':False]
['text':' Retry operation if interrupted by signal.','line_number':230,'multiline':False]
['text':' Check if we need to run the operation again.','line_number':234,'multiline':False]
['text':' Operation is complete.','line_number':239,'multiline':False]
['text':' A request to write 0 bytes on a stream is a no-op.','line_number':261,'multiline':False]
['text':' Write some data.','line_number':268,'multiline':False]
['text':' Try to complete the operation without blocking.','line_number':271,'multiline':False]
['text':' Check if operation succeeded.','line_number':276,'multiline':False]
['text':' Operation failed.','line_number':280,'multiline':False]
['text':' Wait for descriptor to become ready.','line_number':286,'multiline':False]
['text':' Write some data.','line_number':297,'multiline':False]
['text':' Retry operation if interrupted by signal.','line_number':302,'multiline':False]
['text':' Check if we need to run the operation again.','line_number':306,'multiline':False]
['text':' Operation is complete.','line_number':311,'multiline':False]
['text':' When updating the non-blocking mode we always perform the ioctl syscall,','line_number':340,'multiline':False]
['text':' even if the flags would otherwise indicate that the descriptor is','line_number':341,'multiline':False]
['text':' already in the correct state. This ensures that the underlying','line_number':342,'multiline':False]
['text':' descriptor is put into the state that has been requested by the user. If','line_number':343,'multiline':False]
['text':' the ioctl syscall was successful then we need to update the flags to','line_number':344,'multiline':False]
['text':' match.','line_number':345,'multiline':False]
['text':' Clearing the non-blocking mode always overrides any internally-set','line_number':354,'multiline':False]
['text':' non-blocking flag. Any subsequent asynchronous operations will need','line_number':355,'multiline':False]
['text':' to re-enable non-blocking I/O.','line_number':356,'multiline':False]
['text':' namespace descriptor_ops','line_number':464,'multiline':False]
['text':' namespace detail','line_number':465,'multiline':False]
['text':' namespace asio','line_number':466,'multiline':False]
['text':' !defined(ASIO_WINDOWS)','line_number':470,'multiline':False]
['text':'   && !defined(ASIO_WINDOWS_RUNTIME)','line_number':471,'multiline':False]
['text':'   && !defined(__CYGWIN__)','line_number':472,'multiline':False]
['text':' ASIO_DETAIL_IMPL_DESCRIPTOR_OPS_IPP','line_number':474,'multiline':False]
