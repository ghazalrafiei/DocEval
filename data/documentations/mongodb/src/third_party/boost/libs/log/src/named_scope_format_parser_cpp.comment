['text':'
 *          Copyright Andrey Semashev 2007 - 2015.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE_1_0.txt or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 ','line_number':1,'multiline':True]
['text':'!
 * \file   named_scope_format_parser.cpp
 * \author Andrey Semashev
 * \date   14.11.2012
 *
 * \brief  This header is the Boost.Log library implementation, see the library documentation
 *         at http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html.
 ','line_number':7,'multiline':True]
['text':'! The function skips any spaces from the current position','line_number':45,'multiline':False]
['text':'! The function checks if the given character can be part of a function/type/namespace name','line_number':53,'multiline':False]
['text':'! The function checks if there is 'operator' keyword at the specified position','line_number':59,'multiline':False]
['text':'! The function tries to parse operator signature','line_number':65,'multiline':False]
['text':' Check that it's not a function name ending with 'operator', like detect_operator','line_number':70,'multiline':False]
['text':' Check to see where the operator token ends','line_number':78,'multiline':False]
['text':' Handle operator()','line_number':82,'multiline':False]
['text':' Handle operator[]','line_number':93,'multiline':False]
['text':' Handle operator<=, operator>=, operator<<, operator>>, operator<<=, operator>>=','line_number':105,'multiline':False]
['text':' Handle operator->, operator->*','line_number':116,'multiline':False]
['text':' Fall through to other cases involving '-'','line_number':126,'multiline':False]
['text':' Handle operator=, operator==, operator+=, operator++, operator||, operator&&, etc.','line_number':133,'multiline':False]
['text':' Handle operator*, operator*=, etc.','line_number':145,'multiline':False]
['text':' Handle operator,, operator~, etc.','line_number':156,'multiline':False]
['text':' Handle operator""','line_number':161,'multiline':False]
['text':' Skip through the literal suffix','line_number':165,'multiline':False]
['text':' Handle type conversion operators. We can't find the end of the type reliably here.','line_number':175,'multiline':False]
['text':'! The function skips all template parameters','line_number':181,'multiline':False]
['text':' Skip operators (e.g. when an operator is a non-type template parameter)','line_number':200,'multiline':False]
['text':'! The function seeks for the opening parenthesis and also tries to find the function name beginning','line_number':220,'multiline':False]
['text':' no significant (non-space) characters have been encountered so far','line_number':225,'multiline':False]
['text':' some name has started; the name is a contiguous sequence of characters that may constitute a function or scope name','line_number':226,'multiline':False]
['text':' the previous characters were the scope operator ("::"), so the name is not finished yet','line_number':227,'multiline':False]
['text':' the name has ended; in particular, this means that there were significant characters previously in the string','line_number':228,'multiline':False]
['text':' operator has been found in the string, don't parse for scopes anymore; this is needed for conversion operators','line_number':229,'multiline':False]
['text':' If the opening brace is the first meaningful character in the string then this can't be a function signature.','line_number':242,'multiline':False]
['text':' Pretend we didn't find the paranthesis to fail the parsing process.','line_number':243,'multiline':False]
['text':' Template parameters cannot start as the first meaningful character in the signature.','line_number':251,'multiline':False]
['text':' Pretend we didn't find the paranthesis to fail the parsing process.','line_number':252,'multiline':False]
['text':' Include the starting "::" in the full name','line_number':271,'multiline':False]
['text':' Weird case, a single colon. Maybe, some compilers would put things like "public:" in front of the signature.','line_number':280,'multiline':False]
['text':' Fall through to process this character as other characters','line_number':298,'multiline':False]
['text':' check for '~' in case of a destructor','line_number':304,'multiline':False]
['text':'! The function seeks for the closing parenthesis','line_number':328,'multiline':False]
['text':' Fall through to process this character as other characters','line_number':362,'multiline':False]
['text':' The algorithm tries to match several patterns to recognize function signatures. The most obvious is:','line_number':382,'multiline':False]
['text':'','line_number':383,'multiline':False]
['text':' A B(C)','line_number':384,'multiline':False]
['text':'','line_number':385,'multiline':False]
['text':' or just:','line_number':386,'multiline':False]
['text':'','line_number':387,'multiline':False]
['text':' B(C)','line_number':388,'multiline':False]
['text':'','line_number':389,'multiline':False]
['text':' in case of constructors, destructors and type conversion operators. The algorithm looks for the opening parenthesis and while doing that','line_number':390,'multiline':False]
['text':' it detects the beginning of B. As a result B is the function name.','line_number':391,'multiline':False]
['text':'','line_number':392,'multiline':False]
['text':' The first significant complication is function and array return types, in which case the syntax becomes nested:','line_number':393,'multiline':False]
['text':'','line_number':394,'multiline':False]
['text':' A (*B(C))(D)','line_number':395,'multiline':False]
['text':' A (&B(C))[D]','line_number':396,'multiline':False]
['text':'','line_number':397,'multiline':False]
['text':' In addition to that MSVC adds calling convention, such as __cdecl, to function types. In order to detect these cases the algorithm','line_number':398,'multiline':False]
['text':' seeks for the closing parenthesis after the opening one. If there is an opening parenthesis or square bracket after the closing parenthesis','line_number':399,'multiline':False]
['text':' then this is a function or array return type. The case of arrays is additionally complicated by GCC output:','line_number':400,'multiline':False]
['text':'','line_number':401,'multiline':False]
['text':' A B(C) [D]','line_number':402,'multiline':False]
['text':'','line_number':403,'multiline':False]
['text':' where D is template parameters description and is not part of the signature. To discern this special case from the array return type, the algorithm','line_number':404,'multiline':False]
['text':' checks for the first significant character within the parenthesis. This character is '&' in case of arrays and something else otherwise.','line_number':405,'multiline':False]
['text':'','line_number':406,'multiline':False]
['text':' Speaking of template parameters, the parsing algorithm ignores them completely, assuming they are part of the name being parsed. This includes','line_number':407,'multiline':False]
['text':' any possible parenthesis, nested template parameters and even operators, which may be present there as non-type template parameters.','line_number':408,'multiline':False]
['text':'','line_number':409,'multiline':False]
['text':' Operators pose another problem. This is especially the case for type conversion operators, and even more so for conversion operators to','line_number':410,'multiline':False]
['text':' function types. In this latter case at least MSVC is known to produce incomprehensible strings which we cannot parse. In other cases it is','line_number':411,'multiline':False]
['text':' too difficult to parse the type correctly. So we cheat a little. Whenever we find "operator", we know that we've found the function name','line_number':412,'multiline':False]
['text':' already, and the name ends at the opening parenthesis. For other operators we are able to parse them correctly but that doesn't really matter.','line_number':413,'multiline':False]
['text':'','line_number':414,'multiline':False]
['text':' Note that the algorithm should be tolerant to different flavors of the input strings from different compilers, so we can't rely on spaces','line_number':415,'multiline':False]
['text':' delimiting function names and other elements. Also, the algorithm should behave well in case of the fallback string generated by','line_number':416,'multiline':False]
['text':' BOOST_CURRENT_FUNCTION (which is "(unknown)" currently). In case of any parsing failure the algorithm should return false, in which case the','line_number':417,'multiline':False]
['text':' full original string will be used as the output.','line_number':418,'multiline':False]
['text':' Find the opening parenthesis. While looking for it, also find the function name.','line_number':424,'multiline':False]
['text':' first_name_begin is the beginning of the function scope, last_name_begin is the actual function name.','line_number':425,'multiline':False]
['text':' Find the closing parenthesis. Also peek at the first character in the parenthesis, which we'll use to detect array return types.','line_number':430,'multiline':False]
['text':' Detect function and array return types','line_number':438,'multiline':False]
['text':' This is a function or array return type, the actual function name is within the parenthesis.','line_number':441,'multiline':False]
['text':' Re-parse the string within the parenthesis as a function signature.','line_number':442,'multiline':False]
['text':' We found something that looks like a function signature','line_number':448,'multiline':False]
['text':'! Parses the named scope format string and constructs the formatter function','line_number':634,'multiline':False]
['text':' a single '%' character at the end of the string','line_number':705,'multiline':False]
['text':' namespace','line_number':716,'multiline':False]
['text':'! Parses the named scope format string and constructs the formatter function','line_number':721,'multiline':False]
['text':' BOOST_LOG_USE_CHAR','line_number':728,'multiline':False]
['text':'! Parses the named scope format string and constructs the formatter function','line_number':732,'multiline':False]
['text':' BOOST_LOG_USE_WCHAR_T','line_number':739,'multiline':False]
['text':' namespace aux','line_number':741,'multiline':False]
['text':' namespace expressions','line_number':743,'multiline':False]
['text':' namespace log','line_number':745,'multiline':False]
['text':' namespace boost','line_number':747,'multiline':False]
