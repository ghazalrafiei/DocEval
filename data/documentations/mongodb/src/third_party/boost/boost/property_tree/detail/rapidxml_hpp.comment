['text':' ----------------------------------------------------------------------------','line_number':1,'multiline':False]
['text':' Copyright (C) 2006, 2009 Marcin Kalicinski','line_number':2,'multiline':False]
['text':'','line_number':3,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0. ','line_number':4,'multiline':False]
['text':' (See accompanying file LICENSE_1_0.txt or copy at ','line_number':5,'multiline':False]
['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':6,'multiline':False]
['text':'','line_number':7,'multiline':False]
['text':' For more information, see www.boost.org','line_number':8,'multiline':False]
['text':' ----------------------------------------------------------------------------','line_number':9,'multiline':False]
['text':'! \file rapidxml.hpp This file contains rapidxml parser and DOM implementation','line_number':13,'multiline':False]
['text':' For std::size_t','line_number':17,'multiline':False]
['text':' For placement new','line_number':18,'multiline':False]
['text':' On MSVC, disable "conditional expression is constant" warning (level 4). ','line_number':20,'multiline':False]
['text':' This warning is almost impossible to avoid with certain types of templated code','line_number':21,'multiline':False]
['text':' Conditional expression is constant','line_number':24,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':27,'multiline':False]
['text':' BOOST_PROPERTY_TREE_RAPIDXML_PARSE_ERROR','line_number':28,'multiline':False]
['text':' For std::exception','line_number':30,'multiline':False]
['text':'! Parse error exception. ','line_number':37,'multiline':False]
['text':'! This exception is thrown by the parser when an error occurs. ','line_number':38,'multiline':False]
['text':'! Use what() function to get human-readable error message. ','line_number':39,'multiline':False]
['text':'! Use where() function to get a pointer to position within source text where error was detected.','line_number':40,'multiline':False]
['text':'! <br><br>','line_number':41,'multiline':False]
['text':'! If throwing exceptions by the parser is undesirable, ','line_number':42,'multiline':False]
['text':'! it can be disabled by defining RAPIDXML_NO_EXCEPTIONS macro before rapidxml.hpp is included.','line_number':43,'multiline':False]
['text':'! This will cause the parser to call rapidxml::parse_error_handler() function instead of throwing an exception.','line_number':44,'multiline':False]
['text':'! This function must be defined by the user.','line_number':45,'multiline':False]
['text':'! <br><br>','line_number':46,'multiline':False]
['text':'! This class derives from <code>std::exception</code> class.','line_number':47,'multiline':False]
['text':'! Constructs parse error','line_number':53,'multiline':False]
['text':'! Gets human readable description of error.','line_number':60,'multiline':False]
['text':'! \return Pointer to null terminated description of the error.','line_number':61,'multiline':False]
['text':'! Gets pointer to character data where error happened.','line_number':67,'multiline':False]
['text':'! Ch should be the same as char type of xml_document that produced the error.','line_number':68,'multiline':False]
['text':'! \return Pointer to location within the parsed string where error occurred.','line_number':69,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':84,'multiline':False]
['text':' Pool sizes','line_number':85,'multiline':False]
['text':' Size of static memory block of memory_pool.','line_number':88,'multiline':False]
['text':' Define BOOST_PROPERTY_TREE_RAPIDXML_STATIC_POOL_SIZE before including rapidxml.hpp if you want to override the default value.','line_number':89,'multiline':False]
['text':' No dynamic memory allocations are performed by memory_pool until static memory is exhausted.','line_number':90,'multiline':False]
['text':' Size of dynamic memory block of memory_pool.','line_number':95,'multiline':False]
['text':' Define BOOST_PROPERTY_TREE_RAPIDXML_DYNAMIC_POOL_SIZE before including rapidxml.hpp if you want to override the default value.','line_number':96,'multiline':False]
['text':' After the static block is exhausted, dynamic blocks with approximately this size are allocated by memory_pool.','line_number':97,'multiline':False]
['text':' Memory allocation alignment.','line_number':102,'multiline':False]
['text':' Define BOOST_PROPERTY_TREE_RAPIDXML_ALIGNMENT before including rapidxml.hpp if you want to override the default value, which is the size of pointer.','line_number':103,'multiline':False]
['text':' All memory allocations for nodes, attributes and strings will be aligned to this value.','line_number':104,'multiline':False]
['text':' This must be a power of 2 and at least 1, otherwise memory_pool will not work.','line_number':105,'multiline':False]
['text':' Forward declarations','line_number':111,'multiline':False]
['text':'! Enumeration listing all node types produced by the parser.','line_number':116,'multiline':False]
['text':'! Use xml_node::type() function to query node type.','line_number':117,'multiline':False]
['text':'!< A document node. Name and value are empty.','line_number':120,'multiline':False]
['text':'!< An element node. Name contains element name. Value contains text of first data node.','line_number':121,'multiline':False]
['text':'!< A data node. Name is empty. Value contains data text.','line_number':122,'multiline':False]
['text':'!< A CDATA node. Name is empty. Value contains data text.','line_number':123,'multiline':False]
['text':'!< A comment node. Name is empty. Value contains comment text.','line_number':124,'multiline':False]
['text':'!< A declaration node. Name and value are empty. Declaration parameters (version, encoding and standalone) are in node attributes.','line_number':125,'multiline':False]
['text':'!< A DOCTYPE node. Name is empty. Value contains DOCTYPE text.','line_number':126,'multiline':False]
['text':'!< A PI node. Name contains target. Value contains instructions.','line_number':127,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':130,'multiline':False]
['text':' Parsing flags','line_number':131,'multiline':False]
['text':'! Parse flag instructing the parser to not create data nodes. ','line_number':133,'multiline':False]
['text':'! Text of first data node will still be placed in value of parent element, unless rapidxml::parse_no_element_values flag is also specified.','line_number':134,'multiline':False]
['text':'! Can be combined with other flags by use of | operator.','line_number':135,'multiline':False]
['text':'! <br><br>','line_number':136,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':137,'multiline':False]
['text':'! Parse flag instructing the parser to not use text of first data node as a value of parent element.','line_number':140,'multiline':False]
['text':'! Can be combined with other flags by use of | operator.','line_number':141,'multiline':False]
['text':'! Note that child data nodes of element node take precedence over its value when printing.','line_number':142,'multiline':False]
['text':'! That is, if element has one or more child data nodes <em>and</em> a value, the value will be ignored.','line_number':143,'multiline':False]
['text':'! Use rapidxml::parse_no_data_nodes flag to prevent creation of data nodes if you want to manipulate data using values of elements.','line_number':144,'multiline':False]
['text':'! <br><br>','line_number':145,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':146,'multiline':False]
['text':'! Parse flag instructing the parser to not place zero terminators after strings in the source text.','line_number':149,'multiline':False]
['text':'! By default zero terminators are placed, modifying source text.','line_number':150,'multiline':False]
['text':'! Can be combined with other flags by use of | operator.','line_number':151,'multiline':False]
['text':'! <br><br>','line_number':152,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':153,'multiline':False]
['text':'! Parse flag instructing the parser to not translate entities in the source text.','line_number':156,'multiline':False]
['text':'! By default entities are translated, modifying source text.','line_number':157,'multiline':False]
['text':'! Can be combined with other flags by use of | operator.','line_number':158,'multiline':False]
['text':'! <br><br>','line_number':159,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':160,'multiline':False]
['text':'! Parse flag instructing the parser to disable UTF-8 handling and assume plain 8 bit characters.','line_number':163,'multiline':False]
['text':'! By default, UTF-8 handling is enabled.','line_number':164,'multiline':False]
['text':'! Can be combined with other flags by use of | operator.','line_number':165,'multiline':False]
['text':'! <br><br>','line_number':166,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':167,'multiline':False]
['text':'! Parse flag instructing the parser to create XML declaration node.','line_number':170,'multiline':False]
['text':'! By default, declaration node is not created.','line_number':171,'multiline':False]
['text':'! Can be combined with other flags by use of | operator.','line_number':172,'multiline':False]
['text':'! <br><br>','line_number':173,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':174,'multiline':False]
['text':'! Parse flag instructing the parser to create comments nodes.','line_number':177,'multiline':False]
['text':'! By default, comment nodes are not created.','line_number':178,'multiline':False]
['text':'! Can be combined with other flags by use of | operator.','line_number':179,'multiline':False]
['text':'! <br><br>','line_number':180,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':181,'multiline':False]
['text':'! Parse flag instructing the parser to create DOCTYPE node.','line_number':184,'multiline':False]
['text':'! By default, doctype node is not created.','line_number':185,'multiline':False]
['text':'! Although W3C specification allows at most one DOCTYPE node, RapidXml will silently accept documents with more than one.','line_number':186,'multiline':False]
['text':'! Can be combined with other flags by use of | operator.','line_number':187,'multiline':False]
['text':'! <br><br>','line_number':188,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':189,'multiline':False]
['text':'! Parse flag instructing the parser to create PI nodes.','line_number':192,'multiline':False]
['text':'! By default, PI nodes are not created.','line_number':193,'multiline':False]
['text':'! Can be combined with other flags by use of | operator.','line_number':194,'multiline':False]
['text':'! <br><br>','line_number':195,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':196,'multiline':False]
['text':'! Parse flag instructing the parser to validate closing tag names. ','line_number':199,'multiline':False]
['text':'! If not set, name inside closing tag is irrelevant to the parser.','line_number':200,'multiline':False]
['text':'! By default, closing tags are not validated.','line_number':201,'multiline':False]
['text':'! Can be combined with other flags by use of | operator.','line_number':202,'multiline':False]
['text':'! <br><br>','line_number':203,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':204,'multiline':False]
['text':'! Parse flag instructing the parser to trim all leading and trailing whitespace of data nodes.','line_number':207,'multiline':False]
['text':'! By default, whitespace is not trimmed. ','line_number':208,'multiline':False]
['text':'! This flag does not cause the parser to modify source text.','line_number':209,'multiline':False]
['text':'! Can be combined with other flags by use of | operator.','line_number':210,'multiline':False]
['text':'! <br><br>','line_number':211,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':212,'multiline':False]
['text':'! Parse flag instructing the parser to condense all whitespace runs of data nodes to a single space character.','line_number':215,'multiline':False]
['text':'! Trimming of leading and trailing whitespace of data is controlled by rapidxml::parse_trim_whitespace flag.','line_number':216,'multiline':False]
['text':'! By default, whitespace is not normalized. ','line_number':217,'multiline':False]
['text':'! If this flag is specified, source text will be modified.','line_number':218,'multiline':False]
['text':'! Can be combined with other flags by use of | operator.','line_number':219,'multiline':False]
['text':'! <br><br>','line_number':220,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':221,'multiline':False]
['text':' Compound flags','line_number':224,'multiline':False]
['text':'! Parse flags which represent default behaviour of the parser. ','line_number':226,'multiline':False]
['text':'! This is always equal to 0, so that all other flags can be simply ored together.','line_number':227,'multiline':False]
['text':'! Normally there is no need to inconveniently disable flags by anding with their negated (~) values.','line_number':228,'multiline':False]
['text':'! This also means that meaning of each flag is a <i>negation</i> of the default setting. ','line_number':229,'multiline':False]
['text':'! For example, if flag name is rapidxml::parse_no_utf8, it means that utf-8 is <i>enabled</i> by default,','line_number':230,'multiline':False]
['text':'! and using the flag will disable it.','line_number':231,'multiline':False]
['text':'! <br><br>','line_number':232,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':233,'multiline':False]
['text':'! A combination of parse flags that forbids any modifications of the source text. ','line_number':236,'multiline':False]
['text':'! This also results in faster parsing. However, note that the following will occur:','line_number':237,'multiline':False]
['text':'! <ul>','line_number':238,'multiline':False]
['text':'! <li>names and values of nodes will not be zero terminated, you have to use xml_base::name_size() and xml_base::value_size() functions to determine where name and value ends</li>','line_number':239,'multiline':False]
['text':'! <li>entities will not be translated</li>','line_number':240,'multiline':False]
['text':'! <li>whitespace will not be normalized</li>','line_number':241,'multiline':False]
['text':'! </ul>','line_number':242,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':243,'multiline':False]
['text':'! A combination of parse flags resulting in fastest possible parsing, without sacrificing important data.','line_number':246,'multiline':False]
['text':'! <br><br>','line_number':247,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':248,'multiline':False]
['text':'! A combination of parse flags resulting in largest amount of data being extracted. ','line_number':251,'multiline':False]
['text':'! This usually results in slowest parsing.','line_number':252,'multiline':False]
['text':'! <br><br>','line_number':253,'multiline':False]
['text':'! See xml_document::parse() function.','line_number':254,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':257,'multiline':False]
['text':' Internals','line_number':258,'multiline':False]
['text':'! \cond internal','line_number':260,'multiline':False]
['text':' Struct that contains lookup tables for the parser','line_number':264,'multiline':False]
['text':' It must be a template to allow correct linking (because it has static data members, which are defined in a header file).','line_number':265,'multiline':False]
['text':' Whitespace table','line_number':269,'multiline':False]
['text':' Node name table','line_number':270,'multiline':False]
['text':' Text table','line_number':271,'multiline':False]
['text':' Text table','line_number':272,'multiline':False]
['text':' Text table','line_number':273,'multiline':False]
['text':' Attribute name table','line_number':274,'multiline':False]
['text':' Attribute data table with single quote','line_number':275,'multiline':False]
['text':' Attribute data table with single quote','line_number':276,'multiline':False]
['text':' Attribute data table with double quotes','line_number':277,'multiline':False]
['text':' Attribute data table with double quotes','line_number':278,'multiline':False]
['text':' Digits','line_number':279,'multiline':False]
['text':' To uppercase conversion table for ASCII characters','line_number':280,'multiline':False]
['text':' Find length of the string','line_number':283,'multiline':False]
['text':' Compare strings for equality','line_number':293,'multiline':False]
['text':' If not ASCII char, its semantic is same as plain 'z'.','line_number':317,'multiline':False]
['text':' char could be signed, so first stretch and make unsigned.','line_number':318,'multiline':False]
['text':'! \endcond','line_number':327,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':329,'multiline':False]
['text':' Memory pool','line_number':330,'multiline':False]
['text':'! This class is used by the parser to create new nodes and attributes, without overheads of dynamic memory allocation.','line_number':332,'multiline':False]
['text':'! In most cases, you will not need to use this class directly. ','line_number':333,'multiline':False]
['text':'! However, if you need to create nodes manually or modify names/values of nodes, ','line_number':334,'multiline':False]
['text':'! you are encouraged to use memory_pool of relevant xml_document to allocate the memory. ','line_number':335,'multiline':False]
['text':'! Not only is this faster than allocating them by using <code>new</code> operator, ','line_number':336,'multiline':False]
['text':'! but also their lifetime will be tied to the lifetime of document, ','line_number':337,'multiline':False]
['text':'! possibly simplifying memory management.','line_number':338,'multiline':False]
['text':'! <br><br>','line_number':339,'multiline':False]
['text':'! Call allocate_node() or allocate_attribute() functions to obtain new nodes or attributes from the pool. ','line_number':340,'multiline':False]
['text':'! You can also call allocate_string() function to allocate strings.','line_number':341,'multiline':False]
['text':'! Such strings can then be used as names or values of nodes without worrying about their lifetime.','line_number':342,'multiline':False]
['text':'! Note that there is no <code>free()</code> function -- all allocations are freed at once when clear() function is called, ','line_number':343,'multiline':False]
['text':'! or when the pool is destroyed.','line_number':344,'multiline':False]
['text':'! <br><br>','line_number':345,'multiline':False]
['text':'! It is also possible to create a standalone memory_pool, and use it ','line_number':346,'multiline':False]
['text':'! to allocate nodes, whose lifetime will not be tied to any document.','line_number':347,'multiline':False]
['text':'! <br><br>','line_number':348,'multiline':False]
['text':'! Pool maintains <code>BOOST_PROPERTY_TREE_RAPIDXML_STATIC_POOL_SIZE</code> bytes of statically allocated memory. ','line_number':349,'multiline':False]
['text':'! Until static memory is exhausted, no dynamic memory allocations are done.','line_number':350,'multiline':False]
['text':'! When static memory is exhausted, pool allocates additional blocks of memory of size <code>BOOST_PROPERTY_TREE_RAPIDXML_DYNAMIC_POOL_SIZE</code> each,','line_number':351,'multiline':False]
['text':'! by using global <code>new[]</code> and <code>delete[]</code> operators. ','line_number':352,'multiline':False]
['text':'! This behaviour can be changed by setting custom allocation routines. ','line_number':353,'multiline':False]
['text':'! Use set_allocator() function to set them.','line_number':354,'multiline':False]
['text':'! <br><br>','line_number':355,'multiline':False]
['text':'! Allocations for nodes, attributes and strings are aligned at <code>BOOST_PROPERTY_TREE_RAPIDXML_ALIGNMENT</code> bytes.','line_number':356,'multiline':False]
['text':'! This value defaults to the size of pointer on target architecture.','line_number':357,'multiline':False]
['text':'! <br><br>','line_number':358,'multiline':False]
['text':'! To obtain absolutely top performance from the parser,','line_number':359,'multiline':False]
['text':'! it is important that all nodes are allocated from a single, contiguous block of memory.','line_number':360,'multiline':False]
['text':'! Otherwise, cache misses when jumping between two (or more) disjoint blocks of memory can slow down parsing quite considerably.','line_number':361,'multiline':False]
['text':'! If required, you can tweak <code>BOOST_PROPERTY_TREE_RAPIDXML_STATIC_POOL_SIZE</code>, <code>BOOST_PROPERTY_TREE_RAPIDXML_DYNAMIC_POOL_SIZE</code> and <code>BOOST_PROPERTY_TREE_RAPIDXML_ALIGNMENT</code> ','line_number':362,'multiline':False]
['text':'! to obtain best wasted memory to performance compromise.','line_number':363,'multiline':False]
['text':'! To do it, define their values before rapidxml.hpp file is included.','line_number':364,'multiline':False]
['text':'! \param Ch Character type of created nodes. ','line_number':365,'multiline':False]
['text':'! \cond internal','line_number':372,'multiline':False]
['text':' Prefixed names to work around weird MSVC lookup bug.','line_number':373,'multiline':False]
['text':' Type of user-defined function used to allocate memory','line_number':374,'multiline':False]
['text':' Type of user-defined function used to free memory','line_number':375,'multiline':False]
['text':'! \endcond','line_number':376,'multiline':False]
['text':'! Constructs empty pool with default allocator functions.','line_number':378,'multiline':False]
['text':'! Destroys pool and frees all the memory. ','line_number':386,'multiline':False]
['text':'! This causes memory occupied by nodes allocated by the pool to be freed.','line_number':387,'multiline':False]
['text':'! Nodes allocated from the pool are no longer valid.','line_number':388,'multiline':False]
['text':'! Allocates a new node from the pool, and optionally assigns name and value to it. ','line_number':394,'multiline':False]
['text':'! If the allocation request cannot be accommodated, this function will throw <code>std::bad_alloc</code>.','line_number':395,'multiline':False]
['text':'! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function','line_number':396,'multiline':False]
['text':'! will call rapidxml::parse_error_handler() function.','line_number':397,'multiline':False]
['text':'! \param type Type of node to create.','line_number':398,'multiline':False]
['text':'! \param name Name to assign to the node, or 0 to assign no name.','line_number':399,'multiline':False]
['text':'! \param value Value to assign to the node, or 0 to assign no value.','line_number':400,'multiline':False]
['text':'! \param name_size Size of name to assign, or 0 to automatically calculate size from name string.','line_number':401,'multiline':False]
['text':'! \param value_size Size of value to assign, or 0 to automatically calculate size from value string.','line_number':402,'multiline':False]
['text':'! \return Pointer to allocated node. This pointer will never be NULL.','line_number':403,'multiline':False]
['text':'! Allocates a new attribute from the pool, and optionally assigns name and value to it.','line_number':427,'multiline':False]
['text':'! If the allocation request cannot be accommodated, this function will throw <code>std::bad_alloc</code>.','line_number':428,'multiline':False]
['text':'! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function','line_number':429,'multiline':False]
['text':'! will call rapidxml::parse_error_handler() function.','line_number':430,'multiline':False]
['text':'! \param name Name to assign to the attribute, or 0 to assign no name.','line_number':431,'multiline':False]
['text':'! \param value Value to assign to the attribute, or 0 to assign no value.','line_number':432,'multiline':False]
['text':'! \param name_size Size of name to assign, or 0 to automatically calculate size from name string.','line_number':433,'multiline':False]
['text':'! \param value_size Size of value to assign, or 0 to automatically calculate size from value string.','line_number':434,'multiline':False]
['text':'! \return Pointer to allocated attribute. This pointer will never be NULL.','line_number':435,'multiline':False]
['text':'! Allocates a char array of given size from the pool, and optionally copies a given string to it.','line_number':458,'multiline':False]
['text':'! If the allocation request cannot be accommodated, this function will throw <code>std::bad_alloc</code>.','line_number':459,'multiline':False]
['text':'! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function','line_number':460,'multiline':False]
['text':'! will call rapidxml::parse_error_handler() function.','line_number':461,'multiline':False]
['text':'! \param source String to initialize the allocated memory with, or 0 to not initialize it.','line_number':462,'multiline':False]
['text':'! \param size Number of characters to allocate, or zero to calculate it automatically from source string length; if size is 0, source string must be specified and null terminated.','line_number':463,'multiline':False]
['text':'! \return Pointer to allocated char array. This pointer will never be NULL.','line_number':464,'multiline':False]
['text':' Either source or size (or both) must be specified','line_number':467,'multiline':False]
['text':'! Clones an xml_node and its hierarchy of child nodes and attributes.','line_number':477,'multiline':False]
['text':'! Nodes and attributes are allocated from this memory pool.','line_number':478,'multiline':False]
['text':'! Names and values are not cloned, they are shared between the clone and the source.','line_number':479,'multiline':False]
['text':'! Result node can be optionally specified as a second parameter, ','line_number':480,'multiline':False]
['text':'! in which case its contents will be replaced with cloned source node.','line_number':481,'multiline':False]
['text':'! This is useful when you want to clone entire document.','line_number':482,'multiline':False]
['text':'! \param source Node to clone.','line_number':483,'multiline':False]
['text':'! \param result Node to put results in, or 0 to automatically allocate result node','line_number':484,'multiline':False]
['text':'! \return Pointer to cloned node. This pointer will never be NULL.','line_number':485,'multiline':False]
['text':' Prepare result node','line_number':488,'multiline':False]
['text':' Clone name and value','line_number':498,'multiline':False]
['text':' Clone child nodes and attributes','line_number':502,'multiline':False]
['text':'! Clears the pool. ','line_number':511,'multiline':False]
['text':'! This causes memory occupied by nodes allocated by the pool to be freed.','line_number':512,'multiline':False]
['text':'! Any nodes or strings allocated from the pool will no longer be valid.','line_number':513,'multiline':False]
['text':'! Sets or resets the user-defined memory allocation functions for the pool.','line_number':528,'multiline':False]
['text':'! This can only be called when no memory is allocated from the pool yet, otherwise results are undefined.','line_number':529,'multiline':False]
['text':'! Allocation function must not return invalid pointer on failure. It should either throw,','line_number':530,'multiline':False]
['text':'! stop the program, or use <code>longjmp()</code> function to pass control to other place of program. ','line_number':531,'multiline':False]
['text':'! If it returns invalid pointer, results are undefined.','line_number':532,'multiline':False]
['text':'! <br><br>','line_number':533,'multiline':False]
['text':'! User defined allocation functions must have the following forms:','line_number':534,'multiline':False]
['text':'! <br><code>','line_number':535,'multiline':False]
['text':'! <br>void *allocate(std::size_t size);','line_number':536,'multiline':False]
['text':'! <br>void free(void *pointer);','line_number':537,'multiline':False]
['text':'! </code><br>','line_number':538,'multiline':False]
['text':'! \param af Allocation function, or 0 to restore default function','line_number':539,'multiline':False]
['text':'! \param ff Free function, or 0 to restore default function','line_number':540,'multiline':False]
['text':' Verify that no memory is allocated yet','line_number':543,'multiline':False]
['text':' Allocate','line_number':570,'multiline':False]
['text':' Allocate memory using either user-specified allocation function or global operator new[]','line_number':572,'multiline':False]
['text':' Allocator is not allowed to return 0, on failure it must either throw, stop the program or use longjmp','line_number':575,'multiline':False]
['text':' Calculate aligned pointer','line_number':586,'multiline':False]
['text':' If not enough memory left in current pool, allocate a new pool','line_number':589,'multiline':False]
['text':' Calculate required pool size (may be bigger than BOOST_PROPERTY_TREE_RAPIDXML_DYNAMIC_POOL_SIZE)','line_number':592,'multiline':False]
['text':' Allocate','line_number':597,'multiline':False]
['text':' 2 alignments required in worst case: one for header, one for actual allocation','line_number':598,'multiline':False]
['text':' Setup new pool in allocated memory','line_number':601,'multiline':False]
['text':' Calculate aligned pointer again using new pool','line_number':609,'multiline':False]
['text':' Update pool and return aligned pointer','line_number':613,'multiline':False]
['text':' Start of raw memory making up current pool','line_number':618,'multiline':False]
['text':' First free byte in current pool','line_number':619,'multiline':False]
['text':' One past last available byte in current pool','line_number':620,'multiline':False]
['text':' Static raw memory','line_number':621,'multiline':False]
['text':' Allocator function, or 0 if default is to be used','line_number':622,'multiline':False]
['text':' Free function, or 0 if default is to be used','line_number':623,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':626,'multiline':False]
['text':' XML base','line_number':627,'multiline':False]
['text':'! Base class for xml_node and xml_attribute implementing common functions: ','line_number':629,'multiline':False]
['text':'! name(), name_size(), value(), value_size() and parent().','line_number':630,'multiline':False]
['text':'! \param Ch Character type to use','line_number':631,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':638,'multiline':False]
['text':' Construction & destruction','line_number':639,'multiline':False]
['text':' Construct a base with empty name, value and parent','line_number':641,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':649,'multiline':False]
['text':' Node data access','line_number':650,'multiline':False]
['text':'! Gets name of the node. ','line_number':652,'multiline':False]
['text':'! Interpretation of name depends on type of node.','line_number':653,'multiline':False]
['text':'! Note that name will not be zero-terminated if rapidxml::parse_no_string_terminators option was selected during parse.','line_number':654,'multiline':False]
['text':'! <br><br>','line_number':655,'multiline':False]
['text':'! Use name_size() function to determine length of the name.','line_number':656,'multiline':False]
['text':'! \return Name of node, or empty string if node has no name.','line_number':657,'multiline':False]
['text':'! Gets size of node name, not including terminator character.','line_number':663,'multiline':False]
['text':'! This function works correctly irrespective of whether name is or is not zero terminated.','line_number':664,'multiline':False]
['text':'! \return Size of node name, in characters.','line_number':665,'multiline':False]
['text':'! Gets value of node. ','line_number':671,'multiline':False]
['text':'! Interpretation of value depends on type of node.','line_number':672,'multiline':False]
['text':'! Note that value will not be zero-terminated if rapidxml::parse_no_string_terminators option was selected during parse.','line_number':673,'multiline':False]
['text':'! <br><br>','line_number':674,'multiline':False]
['text':'! Use value_size() function to determine length of the value.','line_number':675,'multiline':False]
['text':'! \return Value of node, or empty string if node has no value.','line_number':676,'multiline':False]
['text':'! Gets size of node value, not including terminator character.','line_number':682,'multiline':False]
['text':'! This function works correctly irrespective of whether value is or is not zero terminated.','line_number':683,'multiline':False]
['text':'! \return Size of node value, in characters.','line_number':684,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':690,'multiline':False]
['text':' Node modification','line_number':691,'multiline':False]
['text':'! Sets name of node to a non zero-terminated string.','line_number':693,'multiline':False]
['text':'! See \ref ownership_of_strings.','line_number':694,'multiline':False]
['text':'! <br><br>','line_number':695,'multiline':False]
['text':'! Note that node does not own its name or value, it only stores a pointer to it. ','line_number':696,'multiline':False]
['text':'! It will not delete or otherwise free the pointer on destruction.','line_number':697,'multiline':False]
['text':'! It is responsibility of the user to properly manage lifetime of the string.','line_number':698,'multiline':False]
['text':'! The easiest way to achieve it is to use memory_pool of the document to allocate the string -','line_number':699,'multiline':False]
['text':'! on destruction of the document the string will be automatically freed.','line_number':700,'multiline':False]
['text':'! <br><br>','line_number':701,'multiline':False]
['text':'! Size of name must be specified separately, because name does not have to be zero terminated.','line_number':702,'multiline':False]
['text':'! Use name(const Ch *) function to have the length automatically calculated (string must be zero terminated).','line_number':703,'multiline':False]
['text':'! \param n Name of node to set. Does not have to be zero terminated.','line_number':704,'multiline':False]
['text':'! \param size Size of name, in characters. This does not include zero terminator, if one is present.','line_number':705,'multiline':False]
['text':'! Sets name of node to a zero-terminated string.','line_number':712,'multiline':False]
['text':'! See also \ref ownership_of_strings and xml_node::name(const Ch *, std::size_t).','line_number':713,'multiline':False]
['text':'! \param n Name of node to set. Must be zero terminated.','line_number':714,'multiline':False]
['text':'! Sets value of node to a non zero-terminated string.','line_number':720,'multiline':False]
['text':'! See \ref ownership_of_strings.','line_number':721,'multiline':False]
['text':'! <br><br>','line_number':722,'multiline':False]
['text':'! Note that node does not own its name or value, it only stores a pointer to it. ','line_number':723,'multiline':False]
['text':'! It will not delete or otherwise free the pointer on destruction.','line_number':724,'multiline':False]
['text':'! It is responsibility of the user to properly manage lifetime of the string.','line_number':725,'multiline':False]
['text':'! The easiest way to achieve it is to use memory_pool of the document to allocate the string -','line_number':726,'multiline':False]
['text':'! on destruction of the document the string will be automatically freed.','line_number':727,'multiline':False]
['text':'! <br><br>','line_number':728,'multiline':False]
['text':'! Size of value must be specified separately, because it does not have to be zero terminated.','line_number':729,'multiline':False]
['text':'! Use value(const Ch *) function to have the length automatically calculated (string must be zero terminated).','line_number':730,'multiline':False]
['text':'! <br><br>','line_number':731,'multiline':False]
['text':'! If an element has a child node of type node_data, it will take precedence over element value when printing.','line_number':732,'multiline':False]
['text':'! If you want to manipulate data of elements using values, use parser flag rapidxml::parse_no_data_nodes to prevent creation of data nodes by the parser.','line_number':733,'multiline':False]
['text':'! \param val Value of node to set. Does not have to be zero terminated.','line_number':734,'multiline':False]
['text':'! \param size Size of value, in characters. This does not include zero terminator, if one is present.','line_number':735,'multiline':False]
['text':'! Sets value of node to a zero-terminated string.','line_number':742,'multiline':False]
['text':'! See also \ref ownership_of_strings and xml_node::value(const Ch *, std::size_t).','line_number':743,'multiline':False]
['text':'! \param val Name of node to set. Must be zero terminated.','line_number':744,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':750,'multiline':False]
['text':' Related nodes access','line_number':751,'multiline':False]
['text':'! Gets node parent.','line_number':753,'multiline':False]
['text':'! \return Pointer to parent node, or 0 if there is no parent.','line_number':754,'multiline':False]
['text':' Return empty string','line_number':762,'multiline':False]
['text':' Name of node, or 0 if no name','line_number':769,'multiline':False]
['text':' Value of node, or 0 if no value','line_number':770,'multiline':False]
['text':' Length of node name, or undefined of no name','line_number':771,'multiline':False]
['text':' Length of node value, or undefined if no value','line_number':772,'multiline':False]
['text':' Pointer to parent node, or 0 if none','line_number':773,'multiline':False]
['text':'! Class representing attribute node of XML document. ','line_number':777,'multiline':False]
['text':'! Each attribute has name and value strings, which are available through name() and value() functions (inherited from xml_base).','line_number':778,'multiline':False]
['text':'! Note that after parse, both name and value of attribute will point to interior of source text used for parsing. ','line_number':779,'multiline':False]
['text':'! Thus, this text must persist in memory for the lifetime of attribute.','line_number':780,'multiline':False]
['text':'! \param Ch Character type to use.','line_number':781,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':790,'multiline':False]
['text':' Construction & destruction','line_number':791,'multiline':False]
['text':'! Constructs an empty attribute with the specified type. ','line_number':793,'multiline':False]
['text':'! Consider using memory_pool of appropriate xml_document if allocating attributes manually.','line_number':794,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':799,'multiline':False]
['text':' Related nodes access','line_number':800,'multiline':False]
['text':'! Gets document of which attribute is a child.','line_number':802,'multiline':False]
['text':'! \return Pointer to document that contains this attribute, or 0 if there is no parent document.','line_number':803,'multiline':False]
['text':'! Gets previous attribute, optionally matching attribute name. ','line_number':816,'multiline':False]
['text':'! \param n Name of attribute to find, or 0 to return previous attribute regardless of its name; this string doesn't have to be zero-terminated if nsize is non-zero','line_number':817,'multiline':False]
['text':'! \param nsize Size of name, in characters, or 0 to have size calculated automatically from string','line_number':818,'multiline':False]
['text':'! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters','line_number':819,'multiline':False]
['text':'! \return Pointer to found attribute, or 0 if not found.','line_number':820,'multiline':False]
['text':'! Gets next attribute, optionally matching attribute name. ','line_number':836,'multiline':False]
['text':'! \param n Name of attribute to find, or 0 to return next attribute regardless of its name; this string doesn't have to be zero-terminated if nsize is non-zero','line_number':837,'multiline':False]
['text':'! \param nsize Size of name, in characters, or 0 to have size calculated automatically from string','line_number':838,'multiline':False]
['text':'! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters','line_number':839,'multiline':False]
['text':'! \return Pointer to found attribute, or 0 if not found.','line_number':840,'multiline':False]
['text':' Pointer to previous sibling of attribute, or 0 if none; only valid if parent is non-zero','line_number':858,'multiline':False]
['text':' Pointer to next sibling of attribute, or 0 if none; only valid if parent is non-zero','line_number':859,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':863,'multiline':False]
['text':' XML node','line_number':864,'multiline':False]
['text':'! Class representing a node of XML document. ','line_number':866,'multiline':False]
['text':'! Each node may have associated name and value strings, which are available through name() and value() functions. ','line_number':867,'multiline':False]
['text':'! Interpretation of name and value depends on type of the node.','line_number':868,'multiline':False]
['text':'! Type of node can be determined by using type() function.','line_number':869,'multiline':False]
['text':'! <br><br>','line_number':870,'multiline':False]
['text':'! Note that after parse, both name and value of node, if any, will point interior of source text used for parsing. ','line_number':871,'multiline':False]
['text':'! Thus, this text must persist in the memory for the lifetime of node.','line_number':872,'multiline':False]
['text':'! \param Ch Character type to use.','line_number':873,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':880,'multiline':False]
['text':' Construction & destruction','line_number':881,'multiline':False]
['text':'! Constructs an empty node with the specified type. ','line_number':883,'multiline':False]
['text':'! Consider using memory_pool of appropriate document to allocate nodes manually.','line_number':884,'multiline':False]
['text':'! \param t Type of node to construct.','line_number':885,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':893,'multiline':False]
['text':' Node data access','line_number':894,'multiline':False]
['text':'! Gets type of node.','line_number':896,'multiline':False]
['text':'! \return Type of node.','line_number':897,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':903,'multiline':False]
['text':' Related nodes access','line_number':904,'multiline':False]
['text':'! Gets document of which node is a child.','line_number':906,'multiline':False]
['text':'! \return Pointer to document that contains this node, or 0 if there is no parent document.','line_number':907,'multiline':False]
['text':'! Gets first child node, optionally matching node name.','line_number':916,'multiline':False]
['text':'! \param n Name of child to find, or 0 to return first child regardless of its name; this string doesn't have to be zero-terminated if nsize is non-zero','line_number':917,'multiline':False]
['text':'! \param nsize Size of name, in characters, or 0 to have size calculated automatically from string','line_number':918,'multiline':False]
['text':'! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters','line_number':919,'multiline':False]
['text':'! \return Pointer to found child, or 0 if not found.','line_number':920,'multiline':False]
['text':'! Gets last child node, optionally matching node name. ','line_number':936,'multiline':False]
['text':'! Behaviour is undefined if node has no children.','line_number':937,'multiline':False]
['text':'! Use first_node() to test if node has children.','line_number':938,'multiline':False]
['text':'! \param n Name of child to find, or 0 to return last child regardless of its name; this string doesn't have to be zero-terminated if nsize is non-zero','line_number':939,'multiline':False]
['text':'! \param nsize Size of name, in characters, or 0 to have size calculated automatically from string','line_number':940,'multiline':False]
['text':'! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters','line_number':941,'multiline':False]
['text':'! \return Pointer to found child, or 0 if not found.','line_number':942,'multiline':False]
['text':' Cannot query for last child if node has no children','line_number':945,'multiline':False]
['text':'! Gets previous sibling node, optionally matching node name. ','line_number':959,'multiline':False]
['text':'! Behaviour is undefined if node has no parent.','line_number':960,'multiline':False]
['text':'! Use parent() to test if node has a parent.','line_number':961,'multiline':False]
['text':'! \param n Name of sibling to find, or 0 to return previous sibling regardless of its name; this string doesn't have to be zero-terminated if nsize is non-zero','line_number':962,'multiline':False]
['text':'! \param nsize Size of name, in characters, or 0 to have size calculated automatically from string','line_number':963,'multiline':False]
['text':'! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters','line_number':964,'multiline':False]
['text':'! \return Pointer to found sibling, or 0 if not found.','line_number':965,'multiline':False]
['text':' Cannot query for siblings if node has no parent','line_number':968,'multiline':False]
['text':'! Gets next sibling node, optionally matching node name. ','line_number':982,'multiline':False]
['text':'! Behaviour is undefined if node has no parent.','line_number':983,'multiline':False]
['text':'! Use parent() to test if node has a parent.','line_number':984,'multiline':False]
['text':'! \param n Name of sibling to find, or 0 to return next sibling regardless of its name; this string doesn't have to be zero-terminated if nsize is non-zero','line_number':985,'multiline':False]
['text':'! \param nsize Size of name, in characters, or 0 to have size calculated automatically from string','line_number':986,'multiline':False]
['text':'! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters','line_number':987,'multiline':False]
['text':'! \return Pointer to found sibling, or 0 if not found.','line_number':988,'multiline':False]
['text':' Cannot query for siblings if node has no parent','line_number':991,'multiline':False]
['text':'! Gets first attribute of node, optionally matching attribute name.','line_number':1005,'multiline':False]
['text':'! \param n Name of attribute to find, or 0 to return first attribute regardless of its name; this string doesn't have to be zero-terminated if nsize is non-zero','line_number':1006,'multiline':False]
['text':'! \param nsize Size of name, in characters, or 0 to have size calculated automatically from string','line_number':1007,'multiline':False]
['text':'! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters','line_number':1008,'multiline':False]
['text':'! \return Pointer to found attribute, or 0 if not found.','line_number':1009,'multiline':False]
['text':'! Gets last attribute of node, optionally matching attribute name.','line_number':1025,'multiline':False]
['text':'! \param n Name of attribute to find, or 0 to return last attribute regardless of its name; this string doesn't have to be zero-terminated if nsize is non-zero','line_number':1026,'multiline':False]
['text':'! \param nsize Size of name, in characters, or 0 to have size calculated automatically from string','line_number':1027,'multiline':False]
['text':'! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters','line_number':1028,'multiline':False]
['text':'! \return Pointer to found attribute, or 0 if not found.','line_number':1029,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':1045,'multiline':False]
['text':' Node modification','line_number':1046,'multiline':False]
['text':'! Sets type of node.','line_number':1048,'multiline':False]
['text':'! \param t Type of node to set.','line_number':1049,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':1055,'multiline':False]
['text':' Node manipulation','line_number':1056,'multiline':False]
['text':'! Prepends a new child node.','line_number':1058,'multiline':False]
['text':'! The prepended child becomes the first child, and all existing children are moved one position back.','line_number':1059,'multiline':False]
['text':'! \param child Node to prepend.','line_number':1060,'multiline':False]
['text':'! Appends a new child node. ','line_number':1079,'multiline':False]
['text':'! The appended child becomes the last child.','line_number':1080,'multiline':False]
['text':'! \param child Node to append.','line_number':1081,'multiline':False]
['text':'! Inserts a new child node at specified place inside the node. ','line_number':1100,'multiline':False]
['text':'! All children after and including the specified node are moved one position back.','line_number':1101,'multiline':False]
['text':'! \param where Place where to insert the child, or 0 to insert at the back.','line_number':1102,'multiline':False]
['text':'! \param child Node to insert.','line_number':1103,'multiline':False]
['text':'! Removes first child node. ','line_number':1122,'multiline':False]
['text':'! If node has no children, behaviour is undefined.','line_number':1123,'multiline':False]
['text':'! Use first_node() to test if node has children.','line_number':1124,'multiline':False]
['text':'! Removes last child of the node. ','line_number':1137,'multiline':False]
['text':'! If node has no children, behaviour is undefined.','line_number':1138,'multiline':False]
['text':'! Use first_node() to test if node has children.','line_number':1139,'multiline':False]
['text':'! Removes specified child from the node','line_number':1154,'multiline':False]
['text':' \param where Pointer to child to be removed.','line_number':1155,'multiline':False]
['text':'! Removes all child nodes (but not attributes).','line_number':1172,'multiline':False]
['text':'! Prepends a new attribute to the node.','line_number':1180,'multiline':False]
['text':'! \param attribute Attribute to prepend.','line_number':1181,'multiline':False]
['text':'! Appends a new attribute to the node.','line_number':1200,'multiline':False]
['text':'! \param attribute Attribute to append.','line_number':1201,'multiline':False]
['text':'! Inserts a new attribute at specified place inside the node. ','line_number':1220,'multiline':False]
['text':'! All attributes after and including the specified attribute are moved one position back.','line_number':1221,'multiline':False]
['text':'! \param where Place where to insert the attribute, or 0 to insert at the back.','line_number':1222,'multiline':False]
['text':'! \param attribute Attribute to insert.','line_number':1223,'multiline':False]
['text':'! Removes first attribute of the node. ','line_number':1242,'multiline':False]
['text':'! If node has no attributes, behaviour is undefined.','line_number':1243,'multiline':False]
['text':'! Use first_attribute() to test if node has attributes.','line_number':1244,'multiline':False]
['text':'! Removes last attribute of the node. ','line_number':1259,'multiline':False]
['text':'! If node has no attributes, behaviour is undefined.','line_number':1260,'multiline':False]
['text':'! Use first_attribute() to test if node has attributes.','line_number':1261,'multiline':False]
['text':'! Removes specified attribute from node.','line_number':1276,'multiline':False]
['text':'! \param where Pointer to attribute to be removed.','line_number':1277,'multiline':False]
['text':'! Removes all attributes of node.','line_number':1293,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':1303,'multiline':False]
['text':' Restrictions','line_number':1304,'multiline':False]
['text':' No copying','line_number':1306,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':1310,'multiline':False]
['text':' Data members','line_number':1311,'multiline':False]
['text':' Note that some of the pointers below have UNDEFINED values if certain other pointers are 0.','line_number':1313,'multiline':False]
['text':' This is required for maximum performance, as it allows the parser to omit initialization of ','line_number':1314,'multiline':False]
['text':' unneeded/redundant values.','line_number':1315,'multiline':False]
['text':'','line_number':1316,'multiline':False]
['text':' The rules are as follows:','line_number':1317,'multiline':False]
['text':' 1. first_node and first_attribute contain valid pointers, or 0 if node has no children/attributes respectively','line_number':1318,'multiline':False]
['text':' 2. last_node and last_attribute are valid only if node has at least one child/attribute respectively, otherwise they contain garbage','line_number':1319,'multiline':False]
['text':' 3. prev_sibling and next_sibling are valid only if node has a parent, otherwise they contain garbage','line_number':1320,'multiline':False]
['text':' Type of node; always valid','line_number':1322,'multiline':False]
['text':' Pointer to first child node, or 0 if none; always valid','line_number':1323,'multiline':False]
['text':' Pointer to last child node, or 0 if none; this value is only valid if m_first_node is non-zero','line_number':1324,'multiline':False]
['text':' Pointer to first attribute of node, or 0 if none; always valid','line_number':1325,'multiline':False]
['text':' Pointer to last attribute of node, or 0 if none; this value is only valid if m_first_attribute is non-zero','line_number':1326,'multiline':False]
['text':' Pointer to previous sibling of node, or 0 if none; this value is only valid if m_parent is non-zero','line_number':1327,'multiline':False]
['text':' Pointer to next sibling of node, or 0 if none; this value is only valid if m_parent is non-zero','line_number':1328,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':1332,'multiline':False]
['text':' XML document','line_number':1333,'multiline':False]
['text':'! This class represents root of the DOM hierarchy. ','line_number':1335,'multiline':False]
['text':'! It is also an xml_node and a memory_pool through public inheritance.','line_number':1336,'multiline':False]
['text':'! Use parse() function to build a DOM tree from a zero-terminated XML text string.','line_number':1337,'multiline':False]
['text':'! parse() function allocates memory for nodes and attributes by using functions of xml_document, ','line_number':1338,'multiline':False]
['text':'! which are inherited from memory_pool.','line_number':1339,'multiline':False]
['text':'! To access root node of the document, use the document itself, as if it was an xml_node.','line_number':1340,'multiline':False]
['text':'! \param Ch Character type to use.','line_number':1341,'multiline':False]
['text':'! Constructs empty XML document','line_number':1348,'multiline':False]
['text':'! Parses zero-terminated XML string according to given flags.','line_number':1354,'multiline':False]
['text':'! Passed string will be modified by the parser, unless rapidxml::parse_non_destructive flag is used.','line_number':1355,'multiline':False]
['text':'! The string must persist for the lifetime of the document.','line_number':1356,'multiline':False]
['text':'! In case of error, rapidxml::parse_error exception will be thrown.','line_number':1357,'multiline':False]
['text':'! <br><br>','line_number':1358,'multiline':False]
['text':'! If you want to parse contents of a file, you must first load the file into the memory, and pass pointer to its beginning.','line_number':1359,'multiline':False]
['text':'! Make sure that data is zero-terminated.','line_number':1360,'multiline':False]
['text':'! <br><br>','line_number':1361,'multiline':False]
['text':'! Document can be parsed into multiple times. ','line_number':1362,'multiline':False]
['text':'! Each new call to parse removes previous nodes and attributes (if any), but does not clear memory pool.','line_number':1363,'multiline':False]
['text':'! \param text XML data to parse; pointer is non-const to denote fact that this data may be modified by the parser.','line_number':1364,'multiline':False]
['text':' Remove current contents','line_number':1370,'multiline':False]
['text':' Parse BOM, if any','line_number':1374,'multiline':False]
['text':' Parse children','line_number':1377,'multiline':False]
['text':' Skip whitespace before node','line_number':1380,'multiline':False]
['text':' Parse and append new child','line_number':1385,'multiline':False]
['text':' Skip '<'','line_number':1388,'multiline':False]
['text':'! Clears the document by deleting all nodes and clearing the memory pool.','line_number':1398,'multiline':False]
['text':'! All nodes owned by document pool are destroyed.','line_number':1399,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':1409,'multiline':False]
['text':' Internal character utility functions','line_number':1410,'multiline':False]
['text':' Detect whitespace character','line_number':1412,'multiline':False]
['text':' Detect node name character','line_number':1421,'multiline':False]
['text':' Detect attribute name character','line_number':1430,'multiline':False]
['text':' Detect text character (PCDATA)','line_number':1439,'multiline':False]
['text':' Detect text character (PCDATA) that does not require processing','line_number':1448,'multiline':False]
['text':' Detect text character (PCDATA) that does not require processing','line_number':1457,'multiline':False]
['text':' Detect attribute value character','line_number':1466,'multiline':False]
['text':' Should never be executed, to avoid warnings on Comeau','line_number':1476,'multiline':False]
['text':' Detect attribute value character','line_number':1480,'multiline':False]
['text':' Should never be executed, to avoid warnings on Comeau','line_number':1490,'multiline':False]
['text':' Insert coded character, using UTF8 or 8-bit ASCII','line_number':1494,'multiline':False]
['text':' Insert 8-bit ASCII character','line_number':1500,'multiline':False]
['text':' Todo: possibly verify that code is less than 256 and use replacement char otherwise?','line_number':1501,'multiline':False]
['text':' Insert UTF8 sequence','line_number':1507,'multiline':False]
['text':' 1 byte sequence','line_number':1508,'multiline':False]
['text':' 2 byte sequence','line_number':1513,'multiline':False]
['text':' 3 byte sequence','line_number':1519,'multiline':False]
['text':' 4 byte sequence','line_number':1526,'multiline':False]
['text':' Invalid, only codes up to 0x10FFFF are allowed in Unicode','line_number':1534,'multiline':False]
['text':' Skip characters until predicate evaluates to true','line_number':1541,'multiline':False]
['text':' Skip characters until predicate evaluates to true while doing the following:','line_number':1551,'multiline':False]
['text':' - replacing XML character entity references with proper characters (&apos; &amp; &quot; &lt; &gt; &#...;)','line_number':1552,'multiline':False]
['text':' - condensing whitespace sequences to single space character','line_number':1553,'multiline':False]
['text':' If entity translation, whitespace condense and whitespace trimming is disabled, use plain skip','line_number':1557,'multiline':False]
['text':' Use simple skip until first modification is detected','line_number':1566,'multiline':False]
['text':' Use translation skip','line_number':1569,'multiline':False]
['text':' If entity translation is enabled    ','line_number':1574,'multiline':False]
['text':' Test if replacement is needed','line_number':1577,'multiline':False]
['text':' &amp; &apos;','line_number':1583,'multiline':False]
['text':' &quot;','line_number':1601,'multiline':False]
['text':' &gt;','line_number':1612,'multiline':False]
['text':' &lt;','line_number':1623,'multiline':False]
['text':' &#...; - assumes ASCII','line_number':1634,'multiline':False]
['text':' Skip &#x','line_number':1639,'multiline':False]
['text':' Put character in output','line_number':1648,'multiline':False]
['text':' Skip &#','line_number':1653,'multiline':False]
['text':' Put character in output','line_number':1662,'multiline':False]
['text':' Something else','line_number':1670,'multiline':False]
['text':' Ignore, just copy '&' verbatim','line_number':1672,'multiline':False]
['text':' If whitespace condensing is enabled','line_number':1679,'multiline':False]
['text':' Test if condensing is needed                 ','line_number':1682,'multiline':False]
['text':' Put single space in dest','line_number':1685,'multiline':False]
['text':' Skip first whitespace char','line_number':1686,'multiline':False]
['text':' Skip remaining whitespace chars','line_number':1687,'multiline':False]
['text':' No replacement, only copy character','line_number':1694,'multiline':False]
['text':' Return new end','line_number':1699,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':1705,'multiline':False]
['text':' Internal parsing functions','line_number':1706,'multiline':False]
['text':' Parse UTF-8 BOM, if any','line_number':1708,'multiline':False]
['text':' Parse UTF-16/32 BOM, if any','line_number':1720,'multiline':False]
['text':' Parse XML declaration (<?xml...)','line_number':1731,'multiline':False]
['text':' If parsing of declaration is disabled','line_number':1735,'multiline':False]
['text':' Skip until end of declaration','line_number':1738,'multiline':False]
['text':' Skip '?>'','line_number':1745,'multiline':False]
['text':' Create declaration','line_number':1749,'multiline':False]
['text':' Skip whitespace before attributes or ?>','line_number':1752,'multiline':False]
['text':' Parse declaration attributes','line_number':1755,'multiline':False]
['text':' Skip ?>','line_number':1758,'multiline':False]
['text':' Parse XML comment (<!--...)','line_number':1766,'multiline':False]
['text':' If parsing of comments is disabled','line_number':1770,'multiline':False]
['text':' Skip until end of comment','line_number':1773,'multiline':False]
['text':' Skip '-->'','line_number':1780,'multiline':False]
['text':' Do not produce comment node','line_number':1781,'multiline':False]
['text':' Remember value start','line_number':1784,'multiline':False]
['text':' Skip until end of comment','line_number':1787,'multiline':False]
['text':' Create comment node','line_number':1795,'multiline':False]
['text':' Place zero terminator after comment value','line_number':1799,'multiline':False]
['text':' Skip '-->'','line_number':1803,'multiline':False]
['text':' Parse DOCTYPE','line_number':1807,'multiline':False]
['text':' Remember value start','line_number':1811,'multiline':False]
['text':' Skip to >','line_number':1814,'multiline':False]
['text':' Determine character type','line_number':1817,'multiline':False]
['text':' If '[' encountered, scan for matching ending ']' using naive algorithm with depth','line_number':1821,'multiline':False]
['text':' This works for all W3C test files except for 2 most wicked','line_number':1822,'multiline':False]
['text':' Skip '['','line_number':1825,'multiline':False]
['text':' Error on end of text','line_number':1841,'multiline':False]
['text':' Other character, skip it','line_number':1845,'multiline':False]
['text':' If DOCTYPE nodes enabled','line_number':1852,'multiline':False]
['text':' Create a new doctype node','line_number':1855,'multiline':False]
['text':' Place zero terminator after value','line_number':1859,'multiline':False]
['text':' skip '>'','line_number':1863,'multiline':False]
['text':' skip '>'','line_number':1868,'multiline':False]
['text':' Parse PI','line_number':1874,'multiline':False]
['text':' If creation of PI nodes is enabled','line_number':1878,'multiline':False]
['text':' Create pi node','line_number':1881,'multiline':False]
['text':' Extract PI target name','line_number':1884,'multiline':False]
['text':' Skip whitespace between pi target and pi','line_number':1891,'multiline':False]
['text':' Remember start of pi','line_number':1894,'multiline':False]
['text':' Skip to '?>'','line_number':1897,'multiline':False]
['text':' Set pi value (verbatim, no entity expansion or whitespace normalization)','line_number':1905,'multiline':False]
['text':' Place zero terminator after name and value','line_number':1908,'multiline':False]
['text':' Skip '?>'','line_number':1915,'multiline':False]
['text':' Skip to '?>'','line_number':1920,'multiline':False]
['text':' Skip '?>'','line_number':1927,'multiline':False]
['text':' Parse and append data','line_number':1932,'multiline':False]
['text':' Return character that ends data.','line_number':1933,'multiline':False]
['text':' This is necessary because this character might have been overwritten by a terminating 0','line_number':1934,'multiline':False]
['text':' Backup to contents start if whitespace trimming is disabled','line_number':1938,'multiline':False]
['text':' Skip until end of data','line_number':1942,'multiline':False]
['text':' Trim trailing whitespace if flag is set; leading was already trimmed by whitespace skip after >','line_number':1949,'multiline':False]
['text':' Whitespace is already condensed to single space characters by skipping function, so just trim 1 char off the end','line_number':1954,'multiline':False]
['text':' Backup until non-whitespace character is found','line_number':1960,'multiline':False]
['text':' If characters are still left between end and value (this test is only necessary if normalization is enabled)','line_number':1966,'multiline':False]
['text':' Create new data node','line_number':1967,'multiline':False]
['text':' Add data to parent node if no data exists yet','line_number':1975,'multiline':False]
['text':' Place zero terminator after value','line_number':1980,'multiline':False]
['text':' Return character that ends data; this is required because zero terminator overwritten it','line_number':1985,'multiline':False]
['text':' Return character that ends data','line_number':1988,'multiline':False]
['text':' Parse CDATA','line_number':1992,'multiline':False]
['text':' If CDATA is disabled','line_number':1996,'multiline':False]
['text':' Skip until end of cdata','line_number':1999,'multiline':False]
['text':' Skip ]]>','line_number':2006,'multiline':False]
['text':' Do not produce CDATA node','line_number':2007,'multiline':False]
['text':' Skip until end of cdata','line_number':2010,'multiline':False]
['text':' Create new cdata node','line_number':2019,'multiline':False]
['text':' Place zero terminator after value','line_number':2023,'multiline':False]
['text':' Skip ]]>','line_number':2027,'multiline':False]
['text':' Parse element node','line_number':2031,'multiline':False]
['text':' Create element node','line_number':2035,'multiline':False]
['text':' Extract element name','line_number':2038,'multiline':False]
['text':' Skip whitespace between element name and attributes or >','line_number':2045,'multiline':False]
['text':' Parse attributes, if any','line_number':2048,'multiline':False]
['text':' Determine ending type','line_number':2051,'multiline':False]
['text':' Place zero terminator after name','line_number':2067,'multiline':False]
['text':' Return parsed element','line_number':2071,'multiline':False]
['text':' Determine node type, and parse it','line_number':2075,'multiline':False]
['text':' Parse proper node type','line_number':2079,'multiline':False]
['text':' <...','line_number':2083,'multiline':False]
['text':' Parse and append element node','line_number':2085,'multiline':False]
['text':' <?...','line_number':2088,'multiline':False]
['text':' Skip ?','line_number':2090,'multiline':False]
['text':' '<?xml ' - xml declaration','line_number':2096,'multiline':False]
['text':' Skip 'xml '','line_number':2097,'multiline':False]
['text':' Parse PI','line_number':2102,'multiline':False]
['text':' <!...','line_number':2106,'multiline':False]
['text':' Parse proper subset of <! node','line_number':2109,'multiline':False]
['text':' <!-','line_number':2113,'multiline':False]
['text':' '<!--' - xml comment','line_number':2117,'multiline':False]
['text':' Skip '!--'','line_number':2118,'multiline':False]
['text':' <![','line_number':2123,'multiline':False]
['text':' '<![CDATA[' - cdata','line_number':2128,'multiline':False]
['text':' Skip '![CDATA['','line_number':2129,'multiline':False]
['text':' <!D','line_number':2134,'multiline':False]
['text':' '<!DOCTYPE ' - doctype','line_number':2140,'multiline':False]
['text':' skip '!DOCTYPE '','line_number':2141,'multiline':False]
['text':' switch','line_number':2148,'multiline':False]
['text':' Attempt to skip other, unrecognized node types starting with <!','line_number':2150,'multiline':False]
['text':' Skip !','line_number':2151,'multiline':False]
['text':' Skip '>'','line_number':2158,'multiline':False]
['text':' No node recognized','line_number':2159,'multiline':False]
['text':' Parse contents of the node - children, data etc.','line_number':2164,'multiline':False]
['text':' For all children and text','line_number':2168,'multiline':False]
['text':' Skip whitespace between > and node contents','line_number':2171,'multiline':False]
['text':' Store start of node contents before whitespace is skipped','line_number':2172,'multiline':False]
['text':' After data nodes, instead of continuing the loop, control jumps here.','line_number':2177,'multiline':False]
['text':' This is because zero termination inside parse_and_append_data() function','line_number':2178,'multiline':False]
['text':' would wreak havoc with the above code.','line_number':2179,'multiline':False]
['text':' Also, skipping whitespace after data nodes is unnecessary.','line_number':2180,'multiline':False]
['text':' Determine what comes next: node closing, child node, data node, or 0?','line_number':2183,'multiline':False]
['text':' Node closing or child node','line_number':2187,'multiline':False]
['text':' Node closing','line_number':2191,'multiline':False]
['text':' Skip '</'','line_number':2192,'multiline':False]
['text':' Skip and validate closing tag name','line_number':2195,'multiline':False]
['text':' No validation, just skip name','line_number':2203,'multiline':False]
['text':' Skip remaining whitespace after node name','line_number':2206,'multiline':False]
['text':' Skip '>'','line_number':2210,'multiline':False]
['text':' Node closed, finished parsing contents','line_number':2211,'multiline':False]
['text':' Child node','line_number':2215,'multiline':False]
['text':' Skip '<'','line_number':2216,'multiline':False]
['text':' End of data - error','line_number':2222,'multiline':False]
['text':' Data node','line_number':2226,'multiline':False]
['text':' Bypass regular processing after data nodes','line_number':2229,'multiline':False]
['text':' Parse XML attributes of the node','line_number':2235,'multiline':False]
['text':' For all attributes ','line_number':2239,'multiline':False]
['text':' Extract attribute name','line_number':2242,'multiline':False]
['text':' Skip first character of attribute name','line_number':2244,'multiline':False]
['text':' Create new attribute','line_number':2249,'multiline':False]
['text':' Skip whitespace after attribute name','line_number':2254,'multiline':False]
['text':' Skip =','line_number':2257,'multiline':False]
['text':' Add terminating zero after name','line_number':2262,'multiline':False]
['text':' Skip whitespace after =','line_number':2266,'multiline':False]
['text':' Skip quote and remember if it was ' or "','line_number':2269,'multiline':False]
['text':' Extract attribute value and expand char refs in it','line_number':2275,'multiline':False]
['text':' No whitespace normalization in attributes','line_number':2277,'multiline':False]
['text':' Set attribute value','line_number':2283,'multiline':False]
['text':' Make sure that end quote is present','line_number':2286,'multiline':False]
['text':' Skip quote','line_number':2289,'multiline':False]
['text':' Add terminating zero after value','line_number':2291,'multiline':False]
['text':' Skip whitespace after attribute value','line_number':2295,'multiline':False]
['text':'! \cond internal','line_number':2302,'multiline':False]
['text':' Whitespace (space \n \r \t)','line_number':2306,'multiline':False]
['text':' 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F','line_number':2310,'multiline':False]
['text':' 0','line_number':2311,'multiline':False]
['text':' 1','line_number':2312,'multiline':False]
['text':' 2','line_number':2313,'multiline':False]
['text':' 3','line_number':2314,'multiline':False]
['text':' 4','line_number':2315,'multiline':False]
['text':' 5','line_number':2316,'multiline':False]
['text':' 6','line_number':2317,'multiline':False]
['text':' 7','line_number':2318,'multiline':False]
['text':' 8','line_number':2319,'multiline':False]
['text':' 9','line_number':2320,'multiline':False]
['text':' A','line_number':2321,'multiline':False]
['text':' B','line_number':2322,'multiline':False]
['text':' C','line_number':2323,'multiline':False]
['text':' D','line_number':2324,'multiline':False]
['text':' E','line_number':2325,'multiline':False]
['text':' F','line_number':2326,'multiline':False]
['text':' Node name (anything but space \n \r \t / > ? \0)','line_number':2329,'multiline':False]
['text':' 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F','line_number':2333,'multiline':False]
['text':' 0','line_number':2334,'multiline':False]
['text':' 1','line_number':2335,'multiline':False]
['text':' 2','line_number':2336,'multiline':False]
['text':' 3','line_number':2337,'multiline':False]
['text':' 4','line_number':2338,'multiline':False]
['text':' 5','line_number':2339,'multiline':False]
['text':' 6','line_number':2340,'multiline':False]
['text':' 7','line_number':2341,'multiline':False]
['text':' 8','line_number':2342,'multiline':False]
['text':' 9','line_number':2343,'multiline':False]
['text':' A','line_number':2344,'multiline':False]
['text':' B','line_number':2345,'multiline':False]
['text':' C','line_number':2346,'multiline':False]
['text':' D','line_number':2347,'multiline':False]
['text':' E','line_number':2348,'multiline':False]
['text':' F','line_number':2349,'multiline':False]
['text':' Text (i.e. PCDATA) (anything but < \0)','line_number':2352,'multiline':False]
['text':' 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F','line_number':2356,'multiline':False]
['text':' 0','line_number':2357,'multiline':False]
['text':' 1','line_number':2358,'multiline':False]
['text':' 2','line_number':2359,'multiline':False]
['text':' 3','line_number':2360,'multiline':False]
['text':' 4','line_number':2361,'multiline':False]
['text':' 5','line_number':2362,'multiline':False]
['text':' 6','line_number':2363,'multiline':False]
['text':' 7','line_number':2364,'multiline':False]
['text':' 8','line_number':2365,'multiline':False]
['text':' 9','line_number':2366,'multiline':False]
['text':' A','line_number':2367,'multiline':False]
['text':' B','line_number':2368,'multiline':False]
['text':' C','line_number':2369,'multiline':False]
['text':' D','line_number':2370,'multiline':False]
['text':' E','line_number':2371,'multiline':False]
['text':' F','line_number':2372,'multiline':False]
['text':' Text (i.e. PCDATA) that does not require processing when ws normalization is disabled ','line_number':2375,'multiline':False]
['text':' (anything but < \0 &)','line_number':2376,'multiline':False]
['text':' 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F','line_number':2380,'multiline':False]
['text':' 0','line_number':2381,'multiline':False]
['text':' 1','line_number':2382,'multiline':False]
['text':' 2','line_number':2383,'multiline':False]
['text':' 3','line_number':2384,'multiline':False]
['text':' 4','line_number':2385,'multiline':False]
['text':' 5','line_number':2386,'multiline':False]
['text':' 6','line_number':2387,'multiline':False]
['text':' 7','line_number':2388,'multiline':False]
['text':' 8','line_number':2389,'multiline':False]
['text':' 9','line_number':2390,'multiline':False]
['text':' A','line_number':2391,'multiline':False]
['text':' B','line_number':2392,'multiline':False]
['text':' C','line_number':2393,'multiline':False]
['text':' D','line_number':2394,'multiline':False]
['text':' E','line_number':2395,'multiline':False]
['text':' F','line_number':2396,'multiline':False]
['text':' Text (i.e. PCDATA) that does not require processing when ws normalizations is enabled','line_number':2399,'multiline':False]
['text':' (anything but < \0 & space \n \r \t)','line_number':2400,'multiline':False]
['text':' 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F','line_number':2404,'multiline':False]
['text':' 0','line_number':2405,'multiline':False]
['text':' 1','line_number':2406,'multiline':False]
['text':' 2','line_number':2407,'multiline':False]
['text':' 3','line_number':2408,'multiline':False]
['text':' 4','line_number':2409,'multiline':False]
['text':' 5','line_number':2410,'multiline':False]
['text':' 6','line_number':2411,'multiline':False]
['text':' 7','line_number':2412,'multiline':False]
['text':' 8','line_number':2413,'multiline':False]
['text':' 9','line_number':2414,'multiline':False]
['text':' A','line_number':2415,'multiline':False]
['text':' B','line_number':2416,'multiline':False]
['text':' C','line_number':2417,'multiline':False]
['text':' D','line_number':2418,'multiline':False]
['text':' E','line_number':2419,'multiline':False]
['text':' F','line_number':2420,'multiline':False]
['text':' Attribute name (anything but space \n \r \t / < > = ? ! \0)','line_number':2423,'multiline':False]
['text':' 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F','line_number':2427,'multiline':False]
['text':' 0','line_number':2428,'multiline':False]
['text':' 1','line_number':2429,'multiline':False]
['text':' 2','line_number':2430,'multiline':False]
['text':' 3','line_number':2431,'multiline':False]
['text':' 4','line_number':2432,'multiline':False]
['text':' 5','line_number':2433,'multiline':False]
['text':' 6','line_number':2434,'multiline':False]
['text':' 7','line_number':2435,'multiline':False]
['text':' 8','line_number':2436,'multiline':False]
['text':' 9','line_number':2437,'multiline':False]
['text':' A','line_number':2438,'multiline':False]
['text':' B','line_number':2439,'multiline':False]
['text':' C','line_number':2440,'multiline':False]
['text':' D','line_number':2441,'multiline':False]
['text':' E','line_number':2442,'multiline':False]
['text':' F','line_number':2443,'multiline':False]
['text':' Attribute data with single quote (anything but ' \0)','line_number':2446,'multiline':False]
['text':' 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F','line_number':2450,'multiline':False]
['text':' 0','line_number':2451,'multiline':False]
['text':' 1','line_number':2452,'multiline':False]
['text':' 2','line_number':2453,'multiline':False]
['text':' 3','line_number':2454,'multiline':False]
['text':' 4','line_number':2455,'multiline':False]
['text':' 5','line_number':2456,'multiline':False]
['text':' 6','line_number':2457,'multiline':False]
['text':' 7','line_number':2458,'multiline':False]
['text':' 8','line_number':2459,'multiline':False]
['text':' 9','line_number':2460,'multiline':False]
['text':' A','line_number':2461,'multiline':False]
['text':' B','line_number':2462,'multiline':False]
['text':' C','line_number':2463,'multiline':False]
['text':' D','line_number':2464,'multiline':False]
['text':' E','line_number':2465,'multiline':False]
['text':' F','line_number':2466,'multiline':False]
['text':' Attribute data with single quote that does not require processing (anything but ' \0 &)','line_number':2469,'multiline':False]
['text':' 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F','line_number':2473,'multiline':False]
['text':' 0','line_number':2474,'multiline':False]
['text':' 1','line_number':2475,'multiline':False]
['text':' 2','line_number':2476,'multiline':False]
['text':' 3','line_number':2477,'multiline':False]
['text':' 4','line_number':2478,'multiline':False]
['text':' 5','line_number':2479,'multiline':False]
['text':' 6','line_number':2480,'multiline':False]
['text':' 7','line_number':2481,'multiline':False]
['text':' 8','line_number':2482,'multiline':False]
['text':' 9','line_number':2483,'multiline':False]
['text':' A','line_number':2484,'multiline':False]
['text':' B','line_number':2485,'multiline':False]
['text':' C','line_number':2486,'multiline':False]
['text':' D','line_number':2487,'multiline':False]
['text':' E','line_number':2488,'multiline':False]
['text':' F','line_number':2489,'multiline':False]
['text':' Attribute data with double quote (anything but " \0)','line_number':2492,'multiline':False]
['text':' 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F','line_number':2496,'multiline':False]
['text':' 0','line_number':2497,'multiline':False]
['text':' 1','line_number':2498,'multiline':False]
['text':' 2','line_number':2499,'multiline':False]
['text':' 3','line_number':2500,'multiline':False]
['text':' 4','line_number':2501,'multiline':False]
['text':' 5','line_number':2502,'multiline':False]
['text':' 6','line_number':2503,'multiline':False]
['text':' 7','line_number':2504,'multiline':False]
['text':' 8','line_number':2505,'multiline':False]
['text':' 9','line_number':2506,'multiline':False]
['text':' A','line_number':2507,'multiline':False]
['text':' B','line_number':2508,'multiline':False]
['text':' C','line_number':2509,'multiline':False]
['text':' D','line_number':2510,'multiline':False]
['text':' E','line_number':2511,'multiline':False]
['text':' F','line_number':2512,'multiline':False]
['text':' Attribute data with double quote that does not require processing (anything but " \0 &)','line_number':2515,'multiline':False]
['text':' 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F','line_number':2519,'multiline':False]
['text':' 0','line_number':2520,'multiline':False]
['text':' 1','line_number':2521,'multiline':False]
['text':' 2','line_number':2522,'multiline':False]
['text':' 3','line_number':2523,'multiline':False]
['text':' 4','line_number':2524,'multiline':False]
['text':' 5','line_number':2525,'multiline':False]
['text':' 6','line_number':2526,'multiline':False]
['text':' 7','line_number':2527,'multiline':False]
['text':' 8','line_number':2528,'multiline':False]
['text':' 9','line_number':2529,'multiline':False]
['text':' A','line_number':2530,'multiline':False]
['text':' B','line_number':2531,'multiline':False]
['text':' C','line_number':2532,'multiline':False]
['text':' D','line_number':2533,'multiline':False]
['text':' E','line_number':2534,'multiline':False]
['text':' F','line_number':2535,'multiline':False]
['text':' Digits (dec and hex, 255 denotes end of numeric character reference)','line_number':2538,'multiline':False]
['text':' 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F','line_number':2542,'multiline':False]
['text':' 0','line_number':2543,'multiline':False]
['text':' 1','line_number':2544,'multiline':False]
['text':' 2','line_number':2545,'multiline':False]
['text':' 3','line_number':2546,'multiline':False]
['text':' 4','line_number':2547,'multiline':False]
['text':' 5','line_number':2548,'multiline':False]
['text':' 6','line_number':2549,'multiline':False]
['text':' 7','line_number':2550,'multiline':False]
['text':' 8','line_number':2551,'multiline':False]
['text':' 9','line_number':2552,'multiline':False]
['text':' A','line_number':2553,'multiline':False]
['text':' B','line_number':2554,'multiline':False]
['text':' C','line_number':2555,'multiline':False]
['text':' D','line_number':2556,'multiline':False]
['text':' E','line_number':2557,'multiline':False]
['text':' F','line_number':2558,'multiline':False]
['text':' Upper case conversion','line_number':2561,'multiline':False]
['text':' 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  A   B   C   D   E   F','line_number':2565,'multiline':False]
['text':' 0','line_number':2566,'multiline':False]
['text':' 1','line_number':2567,'multiline':False]
['text':' 2','line_number':2568,'multiline':False]
['text':' 3','line_number':2569,'multiline':False]
['text':' 4','line_number':2570,'multiline':False]
['text':' 5','line_number':2571,'multiline':False]
['text':' 6','line_number':2572,'multiline':False]
['text':' 7','line_number':2573,'multiline':False]
['text':' 8','line_number':2574,'multiline':False]
['text':' 9','line_number':2575,'multiline':False]
['text':' A','line_number':2576,'multiline':False]
['text':' B','line_number':2577,'multiline':False]
['text':' C','line_number':2578,'multiline':False]
['text':' D','line_number':2579,'multiline':False]
['text':' E','line_number':2580,'multiline':False]
['text':' F','line_number':2581,'multiline':False]
['text':'! \endcond','line_number':2584,'multiline':False]
['text':' Undefine internal macros','line_number':2588,'multiline':False]
['text':' On MSVC, restore warnings state','line_number':2591,'multiline':False]
