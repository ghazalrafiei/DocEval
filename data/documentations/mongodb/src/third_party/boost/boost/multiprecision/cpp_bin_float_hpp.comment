['text':'/////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'  Copyright 2013 John Maddock. Distributed under the Boost','line_number':2,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt','line_number':4,'multiline':False]
['text':'','line_number':25,'multiline':False]
['text':' Some includes we need from Boost.Math, since we rely on that library to provide these functions:','line_number':26,'multiline':False]
['text':'','line_number':27,'multiline':False]
['text':' multiple assignment operators specified, comparison of two constants','line_number':53,'multiline':False]
['text':' namespace detail','line_number':95,'multiline':False]
['text':' rvalue copy:','line_number':147,'multiline':False]
['text':' Overflow:','line_number':213,'multiline':False]
['text':' Underflow:','line_number':219,'multiline':False]
['text':' rvalue copy:','line_number':227,'multiline':False]
['text':' Overflow:','line_number':241,'multiline':False]
['text':' Underflow:','line_number':247,'multiline':False]
['text':'&& (std::numeric_limits<Float>::digits <= static_cast<int>(bit_count))','line_number':288,'multiline':False]
['text':'&& (std::numeric_limits<Float>::digits <= static_cast<int>(bit_count))','line_number':296,'multiline':False]
['text':'version','line_number':608,'multiline':True]
['text':' Precondition: exponent of res must have been set before this function is called','line_number':624,'multiline':False]
['text':' as we may need to adjust it based on how many bits_to_keep in arg are set.','line_number':625,'multiline':False]
['text':' cancellation may have resulted in arg being all zeros:','line_number':634,'multiline':False]
['text':' Must have had cancellation in subtraction,','line_number':645,'multiline':False]
['text':' or be converting from a narrower type, so shift left:','line_number':646,'multiline':False]
['text':' We have more bits_to_keep than we need, so round as required,','line_number':653,'multiline':False]
['text':' first get the rounding bit:','line_number':654,'multiline':False]
['text':' Then check for a tie:','line_number':656,'multiline':False]
['text':' Ties round towards even:','line_number':659,'multiline':False]
['text':' Shift off the bits_to_keep we don't need:','line_number':663,'multiline':False]
['text':' This happens very very rairly, all the bits left after','line_number':673,'multiline':False]
['text':' truncation must be 1's and we're rounding up an order of magnitude:','line_number':674,'multiline':False]
['text':' We get here when bits_to_keep is zero but we're rounding up,','line_number':681,'multiline':False]
['text':' as a result we end up with a single digit that is a 1:','line_number':682,'multiline':False]
['text':' Normalize result when we're rounding to fewer bits than we can hold, only happens in conversions','line_number':688,'multiline':False]
['text':' to narrower types:','line_number':689,'multiline':False]
['text':' We're keeping zero bits and did not round up, so result is zero:','line_number':701,'multiline':False]
['text':' Result must be normalized:','line_number':705,'multiline':False]
['text':' Overflow:','line_number':710,'multiline':False]
['text':' Underflow:','line_number':716,'multiline':False]
['text':' Special cases first:','line_number':742,'multiline':False]
['text':' result is still infinite.','line_number':757,'multiline':False]
['text':' result is still a NaN.','line_number':760,'multiline':False]
['text':' result is infinite.','line_number':771,'multiline':False]
['text':' result is a NaN.','line_number':774,'multiline':False]
['text':' Special cases first:','line_number':809,'multiline':False]
['text':' result is still a NaN.','line_number':833,'multiline':False]
['text':' result is a NaN.','line_number':844,'multiline':False]
['text':' result is still a NaN.','line_number':847,'multiline':False]
['text':' Special cases first:','line_number':963,'multiline':False]
['text':' We will certainly overflow:','line_number':1011,'multiline':False]
['text':' We will certainly underflow:','line_number':1023,'multiline':False]
['text':' saved for later in case a and res are the same object.','line_number':1055,'multiline':False]
['text':' Special cases first:','line_number':1057,'multiline':False]
['text':' comparison of two constants','line_number':1118,'multiline':False]
['text':'','line_number':1126,'multiline':False]
['text':' Special cases first:','line_number':1127,'multiline':False]
['text':'','line_number':1128,'multiline':False]
['text':' We can scale u and v so that both are integers, then perform integer','line_number':1182,'multiline':False]
['text':' division to obtain quotient q and remainder r, such that:','line_number':1183,'multiline':False]
['text':'','line_number':1184,'multiline':False]
['text':' q * v + r = u','line_number':1185,'multiline':False]
['text':'','line_number':1186,'multiline':False]
['text':' and hense:','line_number':1187,'multiline':False]
['text':'','line_number':1188,'multiline':False]
['text':' q + r/v = u/v','line_number':1189,'multiline':False]
['text':'','line_number':1190,'multiline':False]
['text':' From this, assuming q has cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count','line_number':1191,'multiline':False]
['text':' bits we only need to determine whether','line_number':1192,'multiline':False]
['text':' r/v is less than, equal to, or greater than 0.5 to determine rounding -','line_number':1193,'multiline':False]
['text':' this we can do with a shift and comparison.','line_number':1194,'multiline':False]
['text':'','line_number':1195,'multiline':False]
['text':' We can set the exponent and sign of the result up front:','line_number':1196,'multiline':False]
['text':'','line_number':1197,'multiline':False]
['text':' Check for overflow:','line_number':1200,'multiline':False]
['text':' Check for underflow:','line_number':1211,'multiline':False]
['text':' We will certainly underflow:','line_number':1214,'multiline':False]
['text':'','line_number':1223,'multiline':False]
['text':' Now get the quotient and remainder:','line_number':1224,'multiline':False]
['text':'','line_number':1225,'multiline':False]
['text':'','line_number':1229,'multiline':False]
['text':' We now have either "cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count"','line_number':1230,'multiline':False]
['text':' or "cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count+1" significant','line_number':1231,'multiline':False]
['text':' bits in q.','line_number':1232,'multiline':False]
['text':'','line_number':1233,'multiline':False]
['text':'','line_number':1237,'multiline':False]
['text':' OK we have cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count+1 bits,','line_number':1238,'multiline':False]
['text':' so we already have rounding info,','line_number':1239,'multiline':False]
['text':' we just need to changes things if the last bit is 1 and either the','line_number':1240,'multiline':False]
['text':' remainder is non-zero (ie we do not have a tie) or the quotient would','line_number':1241,'multiline':False]
['text':' be odd if it were shifted to the correct number of bits (ie a tiebreak).','line_number':1242,'multiline':False]
['text':'','line_number':1243,'multiline':False]
['text':'','line_number':1252,'multiline':False]
['text':' We have exactly "cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count" bits in q.','line_number':1253,'multiline':False]
['text':' Get rounding info, which we can get by comparing 2r with v.','line_number':1254,'multiline':False]
['text':' We want to call copy_and_round to handle rounding and general cleanup,','line_number':1255,'multiline':False]
['text':' so we'll left shift q and add some fake digits on the end to represent','line_number':1256,'multiline':False]
['text':' how we'll be rounding.','line_number':1257,'multiline':False]
['text':'','line_number':1258,'multiline':False]
['text':' comparison of two constants','line_number':1291,'multiline':False]
['text':'','line_number':1299,'multiline':False]
['text':' Special cases first:','line_number':1300,'multiline':False]
['text':'','line_number':1301,'multiline':False]
['text':' We can scale u and v so that both are integers, then perform integer','line_number':1331,'multiline':False]
['text':' division to obtain quotient q and remainder r, such that:','line_number':1332,'multiline':False]
['text':'','line_number':1333,'multiline':False]
['text':' q * v + r = u','line_number':1334,'multiline':False]
['text':'','line_number':1335,'multiline':False]
['text':' and hense:','line_number':1336,'multiline':False]
['text':'','line_number':1337,'multiline':False]
['text':' q + r/v = u/v','line_number':1338,'multiline':False]
['text':'','line_number':1339,'multiline':False]
['text':' From this, assuming q has "cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count" cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count, we only need to determine whether','line_number':1340,'multiline':False]
['text':' r/v is less than, equal to, or greater than 0.5 to determine rounding -','line_number':1341,'multiline':False]
['text':' this we can do with a shift and comparison.','line_number':1342,'multiline':False]
['text':'','line_number':1343,'multiline':False]
['text':' We can set the exponent and sign of the result up front:','line_number':1344,'multiline':False]
['text':'','line_number':1345,'multiline':False]
['text':'','line_number':1349,'multiline':False]
['text':' Now get the quotient and remainder:','line_number':1350,'multiline':False]
['text':'','line_number':1351,'multiline':False]
['text':'','line_number':1355,'multiline':False]
['text':' We now have either "cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count" or "cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count+1" significant cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count in q.','line_number':1356,'multiline':False]
['text':'','line_number':1357,'multiline':False]
['text':'','line_number':1361,'multiline':False]
['text':' OK we have cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count+1 cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count, so we already have rounding info,','line_number':1362,'multiline':False]
['text':' we just need to changes things if the last bit is 1 and the','line_number':1363,'multiline':False]
['text':' remainder is non-zero (ie we do not have a tie).','line_number':1364,'multiline':False]
['text':'','line_number':1365,'multiline':False]
['text':'','line_number':1374,'multiline':False]
['text':' We have exactly "cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count" cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count in q.','line_number':1375,'multiline':False]
['text':' Get rounding info, which we can get by comparing 2r with v.','line_number':1376,'multiline':False]
['text':' We want to call copy_and_round to handle rounding and general cleanup,','line_number':1377,'multiline':False]
['text':' so we'll left shift q and add some fake cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count on the end to represent','line_number':1378,'multiline':False]
['text':' how we'll be rounding.','line_number':1379,'multiline':False]
['text':'','line_number':1380,'multiline':False]
['text':' We have more bits in long_long_type than the float, so it's OK to left shift:','line_number':1489,'multiline':False]
['text':' We have more bits in ulong_long_type than the float, so it's OK to left shift:','line_number':1553,'multiline':False]
['text':'','line_number':1588,'multiline':False]
['text':' Special cases first:','line_number':1589,'multiline':False]
['text':'','line_number':1590,'multiline':False]
['text':'','line_number':1621,'multiline':False]
['text':' Check for super large exponent that must be converted to infinity:','line_number':1622,'multiline':False]
['text':'','line_number':1623,'multiline':False]
['text':'','line_number':1638,'multiline':False]
['text':' Figure out how many digits we will have in our result,','line_number':1639,'multiline':False]
['text':' allowing for a possibly denormalized result:','line_number':1640,'multiline':False]
['text':'','line_number':1641,'multiline':False]
['text':' Result must be zero:','line_number':1651,'multiline':False]
['text':'','line_number':1657,'multiline':False]
['text':' Perform rounding first, then afterwards extract the digits:','line_number':1658,'multiline':False]
['text':'','line_number':1659,'multiline':False]
['text':' Overflow:','line_number':1722,'multiline':False]
['text':' Underflow:','line_number':1728,'multiline':False]
['text':'
* Sign manipulation
','line_number':1761,'multiline':True]
['text':' fallthrough...','line_number':1818,'multiline':False]
['text':' We have exactly the right number of cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count in the result, round as required:','line_number':1845,'multiline':False]
['text':' fallthrough...','line_number':1867,'multiline':False]
['text':' Either arg is already an integer, or a special value:','line_number':1878,'multiline':False]
['text':' Must have extended result by one bit in the increment:','line_number':1895,'multiline':False]
['text':' fallthrough...','line_number':1911,'multiline':False]
['text':' Either arg is already an integer, or a special value:','line_number':1921,'multiline':False]
['text':' takes care of signed zeros','line_number':1927,'multiline':False]
['text':' Must have extended result by one bit in the increment:','line_number':1940,'multiline':False]
['text':' namespace backends','line_number':1962,'multiline':False]
['text':'','line_number':1969,'multiline':False]
['text':' The type used for trigonometric reduction needs 3 times the precision of the base type.','line_number':1970,'multiline':False]
['text':' This is double the precision of the original type, plus the largest exponent supported.','line_number':1971,'multiline':False]
['text':' As a practical measure the largest argument supported is 1/eps, as supporting larger','line_number':1972,'multiline':False]
['text':' arguments requires the division of argument by PI/2 to also be done at higher precision,','line_number':1973,'multiline':False]
['text':' otherwise the result (an integer) can not be represented exactly.','line_number':1974,'multiline':False]
['text':' ','line_number':1975,'multiline':False]
['text':' See ARGUMENT REDUCTION FOR HUGE ARGUMENTS. K C Ng.','line_number':1976,'multiline':False]
['text':'','line_number':1977,'multiline':False]
['text':' namespace detail','line_number':1992,'multiline':False]
['text':' namespace multiprecision','line_number':2032,'multiline':False]
['text':' namespace math','line_number':2039,'multiline':False]
['text':' namespace boost','line_number':2041,'multiline':False]
['text':'','line_number':2048,'multiline':False]
['text':' numeric_limits [partial] specializations for the types declared in this header:','line_number':2049,'multiline':False]
['text':'','line_number':2050,'multiline':False]
['text':' conditional expression is constant','line_number':2072,'multiline':False]
['text':' We jump through hoops here using the backend type directly just to keep VC12 happy','line_number':2084,'multiline':False]
['text':' (ie compiler workaround, for very strange compiler bug):','line_number':2085,'multiline':False]
['text':' Is this really correct???','line_number':2112,'multiline':False]
['text':' We jump through hoops here just to keep VC12 happy (ie compiler workaround, for very strange compiler bug):','line_number':2123,'multiline':False]
['text':' What value should this be????','line_number':2131,'multiline':False]
['text':' returns 0.5','line_number':2134,'multiline':False]
['text':' We jump through hoops here just to keep VC12 happy (ie compiler workaround, for very strange compiler bug):','line_number':2139,'multiline':False]
['text':' namespace std','line_number':2234,'multiline':False]
