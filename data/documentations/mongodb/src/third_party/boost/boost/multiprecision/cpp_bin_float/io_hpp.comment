['text':'/////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'  Copyright 2013 John Maddock. Distributed under the Boost','line_number':2,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt','line_number':4,'multiline':False]
['text':'','line_number':15,'multiline':False]
['text':' Multiplies a by b and shifts the result so it fits inside max_bits bits,','line_number':16,'multiline':False]
['text':' returns by how much the result was shifted.','line_number':17,'multiline':False]
['text':'','line_number':18,'multiline':False]
['text':' The error rate increases by the error of both a and b,','line_number':30,'multiline':False]
['text':' this may be overly pessimistic in many case as we're assuming','line_number':31,'multiline':False]
['text':' that a and b have the same level of uncertainty...','line_number':32,'multiline':False]
['text':'','line_number':52,'multiline':False]
['text':' Computes a^e shifted to the right so it fits in max_bits, returns how far','line_number':53,'multiline':False]
['text':' to the right we are shifted.','line_number':54,'multiline':False]
['text':'','line_number':55,'multiline':False]
['text':'','line_number':87,'multiline':False]
['text':' Can we round what at /location/, if the error in what is /error/ in','line_number':88,'multiline':False]
['text':' units of 0.5ulp.  Return:','line_number':89,'multiline':False]
['text':'','line_number':90,'multiline':False]
['text':' -1: Can't round.','line_number':91,'multiline':False]
['text':'  0: leave as is.','line_number':92,'multiline':False]
['text':'  1: tie.','line_number':93,'multiline':False]
['text':'  2: round up.','line_number':94,'multiline':False]
['text':'','line_number':95,'multiline':False]
['text':' Either a tie or can't round depending on whether we have any error','line_number':104,'multiline':False]
['text':' no error, round up.','line_number':106,'multiline':False]
['text':'','line_number':122,'multiline':False]
['text':' Lets suppose we have an inexact division by d+delta, where the true','line_number':123,'multiline':False]
['text':' value for the divisor is d, and with |delta| <= error/2, then','line_number':124,'multiline':False]
['text':' we have calculated q and r such that:','line_number':125,'multiline':False]
['text':'','line_number':126,'multiline':False]
['text':' n                  r','line_number':127,'multiline':False]
['text':' ---       = q + -----------','line_number':128,'multiline':False]
['text':' d + error        d + error','line_number':129,'multiline':False]
['text':'','line_number':130,'multiline':False]
['text':' Rearranging for n / d we get:','line_number':131,'multiline':False]
['text':'','line_number':132,'multiline':False]
['text':'    n         delta*q + r','line_number':133,'multiline':False]
['text':'   --- = q + -------------','line_number':134,'multiline':False]
['text':'    d              d','line_number':135,'multiline':False]
['text':'','line_number':136,'multiline':False]
['text':' So rounding depends on whether 2r + error * q > d.','line_number':137,'multiline':False]
['text':'','line_number':138,'multiline':False]
['text':' We return:','line_number':139,'multiline':False]
['text':'  0 = down down.','line_number':140,'multiline':False]
['text':'  1 = tie.','line_number':141,'multiline':False]
['text':'  2 = round up.','line_number':142,'multiline':False]
['text':' -1 = couldn't decide.','line_number':143,'multiline':False]
['text':'','line_number':144,'multiline':False]
['text':' namespace cpp_bf_io_detail','line_number':166,'multiline':False]
['text':'','line_number':178,'multiline':False]
['text':' Extract the sign:','line_number':179,'multiline':False]
['text':'','line_number':180,'multiline':False]
['text':'','line_number':188,'multiline':False]
['text':' Special cases first:','line_number':189,'multiline':False]
['text':'','line_number':190,'multiline':False]
['text':'','line_number':202,'multiline':False]
['text':' Digits before the point:','line_number':203,'multiline':False]
['text':'','line_number':204,'multiline':False]
['text':' The decimal point (we really should localise this!!)','line_number':213,'multiline':False]
['text':'','line_number':216,'multiline':False]
['text':' Digits after the point:','line_number':217,'multiline':False]
['text':'','line_number':218,'multiline':False]
['text':'','line_number':230,'multiline':False]
['text':' Digits we're skipping:','line_number':231,'multiline':False]
['text':'','line_number':232,'multiline':False]
['text':'','line_number':235,'multiline':False]
['text':' See if there's an exponent:','line_number':236,'multiline':False]
['text':'','line_number':237,'multiline':False]
['text':'','line_number':262,'multiline':False]
['text':' Oops unexpected input at the end of the number:','line_number':263,'multiline':False]
['text':'','line_number':264,'multiline':False]
['text':' Result is necessarily zero:','line_number':269,'multiline':False]
['text':'','line_number':275,'multiline':False]
['text':' Set our working precision - this is heuristic based, we want','line_number':276,'multiline':False]
['text':' a value as small as possible > cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count to avoid large computations','line_number':277,'multiline':False]
['text':' and excessive memory usage, but we also want to avoid having to','line_number':278,'multiline':False]
['text':' up the computation and start again at a higher precision.','line_number':279,'multiline':False]
['text':' So we round cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count up to the nearest whole number of limbs, and add','line_number':280,'multiline':False]
['text':' one limb for good measure.  This works very well for small exponents,','line_number':281,'multiline':False]
['text':' but for larger exponents we may may need to restart, we could add some','line_number':282,'multiline':False]
['text':' extra precision right from the start for larger exponents, but this','line_number':283,'multiline':False]
['text':' seems to be slightly slower in the *average* case:','line_number':284,'multiline':False]
['text':'','line_number':285,'multiline':False]
['text':' Nice and simple, the result is an integer...','line_number':297,'multiline':False]
['text':' Underflow:','line_number':339,'multiline':False]
['text':' Result is the ratio of two integers: we need to organise the','line_number':357,'multiline':False]
['text':' division so as to produce at least an N-bit result which we can','line_number':358,'multiline':False]
['text':' round according to the remainder.','line_number':359,'multiline':False]
['text':'cpp_int d = pow(cpp_int(5), -decimal_exp);','line_number':360,'multiline':False]
['text':'','line_number':376,'multiline':False]
['text':' Check for rounding conditions we have to','line_number':377,'multiline':False]
['text':' handle ourselves:','line_number':378,'multiline':False]
['text':'','line_number':379,'multiline':False]
['text':' Exactly the right number of bits, use the remainder to round:','line_number':383,'multiline':False]
['text':' Too many bits in q and the bits in q indicate a tie, but we can break that using r,','line_number':388,'multiline':False]
['text':' note that the radius of error in r is error/2 * q:','line_number':389,'multiline':False]
['text':' We might have been rounding up, or got the wrong quotient: can't tell!','line_number':403,'multiline':False]
['text':' Overflow:','line_number':425,'multiline':False]
['text':' Underflow:','line_number':431,'multiline':False]
['text':'','line_number':446,'multiline':False]
['text':' Check for scaling and/or over/under-flow:','line_number':447,'multiline':False]
['text':'','line_number':448,'multiline':False]
['text':' Overflow:','line_number':452,'multiline':False]
['text':' Underflow:','line_number':458,'multiline':False]
['text':' How far to left-shift in order to demormalise the mantissa:','line_number':483,'multiline':False]
['text':'','line_number':487,'multiline':False]
['text':' For fixed formatting we want /dig/ digits after the decimal point,','line_number':488,'multiline':False]
['text':' so if the exponent is zero, allowing for the one digit before the','line_number':489,'multiline':False]
['text':' decimal point, we want 1 + dig digits etc.','line_number':490,'multiline':False]
['text':'','line_number':491,'multiline':False]
['text':' Fixed precision, no significant digits, and nothing to round!','line_number':498,'multiline':False]
['text':'','line_number':505,'multiline':False]
['text':' power10 is the base10 exponent we need to multiply/divide by in order','line_number':506,'multiline':False]
['text':' to convert our denormalised number to an integer with the right number of digits:','line_number':507,'multiline':False]
['text':'','line_number':508,'multiline':False]
['text':'','line_number':510,'multiline':False]
['text':' If we calculate 5^power10 rather than 10^power10 we need to move','line_number':511,'multiline':False]
['text':' 2^power10 into /shift/','line_number':512,'multiline':False]
['text':'','line_number':513,'multiline':False]
['text':' 0=no rounding, 1=tie, 2=up','line_number':516,'multiline':False]
['text':'','line_number':518,'multiline':False]
['text':' Set our working precision - this is heuristic based, we want','line_number':519,'multiline':False]
['text':' a value as small as possible > cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count to avoid large computations','line_number':520,'multiline':False]
['text':' and excessive memory usage, but we also want to avoid having to','line_number':521,'multiline':False]
['text':' up the computation and start again at a higher precision.','line_number':522,'multiline':False]
['text':' So we round cpp_bin_float<Digits, DigitBase, Allocator, Exponent, MinE, MaxE>::bit_count up to the nearest whole number of limbs, and add','line_number':523,'multiline':False]
['text':' one limb for good measure.  This works very well for small exponents,','line_number':524,'multiline':False]
['text':' but for larger exponents we add a few extra limbs to max_bits:','line_number':525,'multiline':False]
['text':'','line_number':526,'multiline':False]
['text':'','line_number':538,'multiline':False]
['text':' Our integer result is: bits() * 2^-shift * 5^power10','line_number':539,'multiline':False]
['text':'','line_number':540,'multiline':False]
['text':' We go straight to the answer with all integer arithmetic,','line_number':546,'multiline':False]
['text':' the result is always exact and never needs rounding:','line_number':547,'multiline':False]
['text':' Must still be true!','line_number':558,'multiline':False]
['text':'','line_number':577,'multiline':False]
['text':' Our integer is bits() * 2^-shift * 10^power10','line_number':578,'multiline':False]
['text':'','line_number':579,'multiline':False]
['text':' We only get here if we were asked for a crazy number of decimal digits -','line_number':591,'multiline':False]
['text':' more than are present in a 2^max_bits number.','line_number':592,'multiline':False]
['text':' We're right shifting, *and* dividing by 5^-power10,','line_number':619,'multiline':False]
['text':' so 5^-power10 can never be that large or we'd simply','line_number':620,'multiline':False]
['text':' get zero as a result, and that case is already handled above:','line_number':621,'multiline':False]
['text':'','line_number':633,'multiline':False]
['text':' Check if we got the right number of digits, this','line_number':634,'multiline':False]
['text':' is really a test of whether we calculated the','line_number':635,'multiline':False]
['text':' decimal exponent correctly:','line_number':636,'multiline':False]
['text':'','line_number':637,'multiline':False]
['text':' strange but true.','line_number':643,'multiline':False]
['text':'','line_number':653,'multiline':False]
['text':' Check whether we need to round up: note that we could equally round up','line_number':654,'multiline':False]
['text':' the integer /i/ above, but since we need to perform the rounding *after*','line_number':655,'multiline':False]
['text':' the conversion to a string and the digit count check, we might as well','line_number':656,'multiline':False]
['text':' do it here:','line_number':657,'multiline':False]
['text':'','line_number':658,'multiline':False]
['text':' namespace backends','line_number':688,'multiline':False]
['text':' namespace boost::multiprecision','line_number':689,'multiline':False]
