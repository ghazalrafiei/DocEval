['text':'//////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'  Copyright 2012 John Maddock. Distributed under the Boost','line_number':2,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt','line_number':4,'multiline':False]
['text':' integral constant overflow (oveflow is in a branch not taken when it would overflow)','line_number':38,'multiline':False]
['text':' conditional expression is constant','line_number':39,'multiline':False]
['text':' Unreachable code (reachability depends on template params)','line_number':40,'multiline':False]
['text':' see https://github.com/boostorg/multiprecision/issues/413','line_number':43,'multiline':False]
['text':' and https://github.com/boostorg/multiprecision/issues/431','line_number':44,'multiline':False]
['text':' namespace backends','line_number':52,'multiline':False]
['text':' namespace detail','line_number':60,'multiline':False]
['text':' Namespace detail','line_number':70,'multiline':False]
['text':'','line_number':74,'multiline':False]
['text':' Traits class determines the maximum and minimum precision values:','line_number':75,'multiline':False]
['text':'','line_number':76,'multiline':False]
['text':'','line_number':95,'multiline':False]
['text':' Traits class determines whether the number of bits precision requested could fit in a native type,','line_number':96,'multiline':False]
['text':' we call this a "trivial" cpp_int:','line_number':97,'multiline':False]
['text':'','line_number':98,'multiline':False]
['text':' namespace backends','line_number':118,'multiline':False]
['text':'','line_number':119,'multiline':False]
['text':' Traits class to determine whether a cpp_int_backend is signed or not:','line_number':120,'multiline':False]
['text':'','line_number':121,'multiline':False]
['text':'','line_number':128,'multiline':False]
['text':' Traits class determines whether T should be implicitly convertible to U, or','line_number':129,'multiline':False]
['text':' whether the constructor should be made explicit.  The latter happens if we','line_number':130,'multiline':False]
['text':' are losing the sign, or have fewer digits precision in the target type:','line_number':131,'multiline':False]
['text':'','line_number':132,'multiline':False]
['text':'','line_number':145,'multiline':False]
['text':' Traits class to determine whether operations on a cpp_int may throw:','line_number':146,'multiline':False]
['text':'','line_number':147,'multiline':False]
['text':'','line_number':155,'multiline':False]
['text':' Traits class, determines whether the cpp_int is fixed precision or not:','line_number':156,'multiline':False]
['text':'','line_number':157,'multiline':False]
['text':'new_size','line_number':172,'multiline':True]
['text':'min_size','line_number':172,'multiline':True]
['text':' When we mask out "limb" with "mask", do we loose bits?  If so it's an overflow error:','line_number':177,'multiline':False]
['text':'b','line_number':182,'multiline':True]
['text':'limb','line_number':182,'multiline':True]
['text':'mask','line_number':182,'multiline':True]
['text':' namespace detail','line_number':184,'multiline':False]
['text':'','line_number':186,'multiline':False]
['text':' Now define the various data layouts that are possible as partial specializations of the base class,','line_number':187,'multiline':False]
['text':' starting with the default arbitrary precision signed integer type:','line_number':188,'multiline':False]
['text':'','line_number':189,'multiline':False]
['text':'','line_number':202,'multiline':False]
['text':' Interface invariants:','line_number':203,'multiline':False]
['text':'','line_number':204,'multiline':False]
['text':'','line_number':257,'multiline':False]
['text':' Direct construction:','line_number':258,'multiline':False]
['text':'','line_number':259,'multiline':False]
['text':'','line_number':287,'multiline':False]
['text':' Aliasing constructor aliases data:','line_number':288,'multiline':False]
['text':'','line_number':289,'multiline':False]
['text':' This next constructor is for constructing const objects from const limb_type*'s only.','line_number':335,'multiline':False]
['text':' Unfortunately we appear to have no way to assert that within the language, and the const_cast','line_number':336,'multiline':False]
['text':' is a side effect of that :(','line_number':337,'multiline':False]
['text':'','line_number':350,'multiline':False]
['text':' Helper functions for getting at our internal data, and manipulating storage:','line_number':351,'multiline':False]
['text':'','line_number':352,'multiline':False]
['text':' Check for zero value:','line_number':363,'multiline':False]
['text':' We never resize beyond MaxSize:','line_number':373,'multiline':False]
['text':' See if we have enough capacity already:','line_number':377,'multiline':False]
['text':' We must not be an alias, memory allocation here defeats the whole point of aliasing:','line_number':381,'multiline':False]
['text':' Allocate a new buffer and copy everything over:','line_number':383,'multiline':False]
['text':' rvalue copy:','line_number':419,'multiline':False]
['text':' Check for zero value:','line_number':497,'multiline':False]
['text':'','line_number':535,'multiline':False]
['text':' There is currently no support for unsigned arbitrary precision arithmetic, largely','line_number':536,'multiline':False]
['text':' because it's not clear what subtraction should do:','line_number':537,'multiline':False]
['text':'','line_number':538,'multiline':False]
['text':'','line_number':541,'multiline':False]
['text':' Fixed precision (i.e. no allocator), signed-magnitude type with limb-usage count:','line_number':542,'multiline':False]
['text':'','line_number':543,'multiline':False]
['text':'','line_number':557,'multiline':False]
['text':' Interface invariants:','line_number':558,'multiline':False]
['text':'','line_number':559,'multiline':False]
['text':'','line_number':605,'multiline':False]
['text':' Direct construction:','line_number':606,'multiline':False]
['text':'','line_number':607,'multiline':False]
['text':'','line_number':637,'multiline':False]
['text':' These are deprecated in C++20 unless we make them explicit:','line_number':638,'multiline':False]
['text':'','line_number':639,'multiline':False]
['text':'','line_number':641,'multiline':False]
['text':' Helper functions for getting at our internal data, and manipulating storage:','line_number':642,'multiline':False]
['text':'','line_number':643,'multiline':False]
['text':' Check for zero value:','line_number':651,'multiline':False]
['text':' zero is always unsigned','line_number':671,'multiline':False]
['text':' Not defaulted, it breaks constexpr support in the Intel compiler for some reason:','line_number':675,'multiline':False]
['text':' Defaulted functions:','line_number':680,'multiline':False]
['text':'~cpp_int_base() noexcept {}','line_number':681,'multiline':False]
['text':' Check for zero value:','line_number':703,'multiline':False]
['text':'','line_number':735,'multiline':False]
['text':' Fixed precision (i.e. no allocator), unsigned type with limb-usage count:','line_number':736,'multiline':False]
['text':'','line_number':737,'multiline':False]
['text':'','line_number':750,'multiline':False]
['text':' Interface invariants:','line_number':751,'multiline':False]
['text':'','line_number':752,'multiline':False]
['text':'','line_number':797,'multiline':False]
['text':' Direct construction:','line_number':798,'multiline':False]
['text':'','line_number':799,'multiline':False]
['text':'','line_number':830,'multiline':False]
['text':' Helper functions for getting at our internal data, and manipulating storage:','line_number':831,'multiline':False]
['text':'','line_number':832,'multiline':False]
['text':' Defaulted functions:','line_number':862,'multiline':False]
['text':'~cpp_int_base() noexcept {}','line_number':863,'multiline':False]
['text':'','line_number':864,'multiline':False]
['text':' These are deprecated in C++20 unless we make them explicit:','line_number':865,'multiline':False]
['text':'','line_number':866,'multiline':False]
['text':' Not so much a negate as a complement - this gets called when subtraction','line_number':896,'multiline':False]
['text':' would result in a "negative" number:','line_number':897,'multiline':False]
['text':' negating zero is always zero, and always OK.','line_number':899,'multiline':False]
['text':'','line_number':934,'multiline':False]
['text':' Traits classes to figure out a native type with N bits, these vary from boost::uint_t<N> only','line_number':935,'multiline':False]
['text':' because some platforms have native integer types longer than long long, "really long long" anyone??','line_number':936,'multiline':False]
['text':'','line_number':937,'multiline':False]
['text':'','line_number':953,'multiline':False]
['text':' Backend for fixed precision signed-magnitude type which will fit entirely inside a "double_limb_type":','line_number':954,'multiline':False]
['text':'','line_number':955,'multiline':False]
['text':'','line_number':978,'multiline':False]
['text':' Interface invariants:','line_number':979,'multiline':False]
['text':'','line_number':980,'multiline':False]
['text':'','line_number':1013,'multiline':False]
['text':' Direct construction:','line_number':1014,'multiline':False]
['text':'','line_number':1015,'multiline':False]
['text':'','line_number':1041,'multiline':False]
['text':' conversion from float to __int128 is broken on clang/mingw, ','line_number':1042,'multiline':False]
['text':' see: https://bugs.llvm.org/show_bug.cgi?id=48940','line_number':1043,'multiline':False]
['text':' Since no floating point type has more than 64 bits of','line_number':1044,'multiline':False]
['text':' precision, we can simply cast to an intermediate type to','line_number':1045,'multiline':False]
['text':' solve the issue:','line_number':1046,'multiline':False]
['text':'','line_number':1047,'multiline':False]
['text':'','line_number':1072,'multiline':False]
['text':' These are deprecated in C++20 unless we make them explicit:','line_number':1073,'multiline':False]
['text':'','line_number':1074,'multiline':False]
['text':'','line_number':1079,'multiline':False]
['text':' Helper functions for getting at our internal data, and manipulating storage:','line_number':1080,'multiline':False]
['text':'','line_number':1081,'multiline':False]
['text':' Check for zero value:','line_number':1089,'multiline':False]
['text':' new_size ','line_number':1095,'multiline':True]
['text':' zero is always unsigned','line_number':1102,'multiline':False]
['text':'~cpp_int_base() noexcept {}','line_number':1111,'multiline':False]
['text':' Check for zero value:','line_number':1120,'multiline':False]
['text':'','line_number':1136,'multiline':False]
['text':' Backend for unsigned fixed precision (i.e. no allocator) type which will fit entirely inside a "double_limb_type":','line_number':1137,'multiline':False]
['text':'','line_number':1138,'multiline':False]
['text':'','line_number':1161,'multiline':False]
['text':' Interface invariants:','line_number':1162,'multiline':False]
['text':'','line_number':1163,'multiline':False]
['text':'','line_number':1196,'multiline':False]
['text':' Direct construction:','line_number':1197,'multiline':False]
['text':'','line_number':1198,'multiline':False]
['text':'','line_number':1245,'multiline':False]
['text':' These are deprecated in C++20 unless we make them explicit:','line_number':1246,'multiline':False]
['text':'','line_number':1247,'multiline':False]
['text':'','line_number':1252,'multiline':False]
['text':' Helper functions for getting at our internal data, and manipulating storage:','line_number':1253,'multiline':False]
['text':'','line_number':1254,'multiline':False]
['text':'~cpp_int_base() noexcept {}','line_number':1277,'multiline':False]
['text':'','line_number':1303,'multiline':False]
['text':' Traits class, lets us know whether type T can be directly converted to the base type,','line_number':1304,'multiline':False]
['text':' used to enable/disable constructors etc:','line_number':1305,'multiline':False]
['text':'','line_number':1306,'multiline':False]
['text':'','line_number':1317,'multiline':False]
['text':' Now the actual backend, normalising parameters passed to the base class:','line_number':1318,'multiline':False]
['text':'','line_number':1319,'multiline':False]
['text':' rvalue copy:','line_number':1360,'multiline':False]
['text':'','line_number':1369,'multiline':False]
['text':' Direct construction from arithmetic type:','line_number':1370,'multiline':False]
['text':'','line_number':1371,'multiline':False]
['text':'','line_number':1375,'multiline':False]
['text':' Aliasing constructor: the result will alias the memory referenced, unless','line_number':1376,'multiline':False]
['text':' we have fixed precision and storage, in which case we copy the memory:','line_number':1377,'multiline':False]
['text':'','line_number':1378,'multiline':False]
['text':' Assigning trivial type to trivial type:','line_number':1390,'multiline':False]
['text':' non-trivial to trivial narrowing conversion:','line_number':1399,'multiline':False]
['text':' trivial to non-trivial, treat the trivial argument as if it were an unsigned arithmetic type, then set the sign afterwards:','line_number':1419,'multiline':False]
['text':' regular non-trivial to non-trivial assign:','line_number':1429,'multiline':False]
['text':' rvalue copy:','line_number':1497,'multiline':False]
['text':' clang 7 has an issue converting long double to unsigned long long in','line_number':1648,'multiline':False]
['text':' release mode (bits get dropped, conversion appears to go via float)','line_number':1649,'multiline':False]
['text':' Never extract more than double bits at a time:','line_number':1650,'multiline':False]
['text':' extract int sized bits from f:','line_number':1657,'multiline':False]
['text':' clang 7 requires extra cast to double to avoid buggy code generation:','line_number':1668,'multiline':False]
['text':'','line_number':1771,'multiline':False]
['text':' Exception guarantee: create the result in stack variable "result"','line_number':1772,'multiline':False]
['text':' then do a swap at the end.  In the event of a throw, *this will','line_number':1773,'multiline':False]
['text':' be left unchanged.','line_number':1774,'multiline':False]
['text':'','line_number':1775,'multiline':False]
['text':' will throw if this is a checked integer that cannot be resized','line_number':1791,'multiline':False]
['text':' will throw if this is a checked integer that cannot be resized','line_number':1829,'multiline':False]
['text':' Deal with the bits in val that overflow into the next limb:','line_number':1846,'multiline':False]
['text':' If this is the most-significant-limb, we may need to allocate an extra one for the overflow:','line_number':1850,'multiline':False]
['text':' Base 10, we extract blocks of size 10^9 at a time, that way','line_number':1867,'multiline':False]
['text':' the number of multiplications is kept to a minimum:','line_number':1868,'multiline':False]
['text':' Even though we have only one limb, we can't do IO on it :-(','line_number':1928,'multiline':False]
['text':'','line_number':1964,'multiline':False]
['text':' Get rid of leading zeros:','line_number':1965,'multiline':False]
['text':'','line_number':1966,'multiline':False]
['text':'','line_number':2050,'multiline':False]
['text':' Get rid of leading zeros:','line_number':2051,'multiline':False]
['text':'','line_number':2052,'multiline':False]
['text':'digits','line_number':2112,'multiline':True]
['text':'','line_number':2121,'multiline':False]
['text':' We assume that c is a sequence of (unsigned) bytes with the most significant byte first:','line_number':2122,'multiline':False]
['text':'','line_number':2123,'multiline':False]
['text':' May throw','line_number':2131,'multiline':False]
['text':'','line_number':2149,'multiline':False]
['text':' We assume that c is a sequence of (unsigned) bytes with the most significant byte first:','line_number':2150,'multiline':False]
['text':'','line_number':2151,'multiline':False]
['text':'','line_number':2174,'multiline':False]
['text':' We assume that c is a sequence of (unsigned) bytes with the most significant byte first:','line_number':2175,'multiline':False]
['text':'','line_number':2176,'multiline':False]
['text':' Only do the compare if the same sign:','line_number':2185,'multiline':False]
['text':' braindead version:','line_number':2249,'multiline':False]
['text':' namespace backends','line_number':2256,'multiline':False]
['text':' namespace default_ops','line_number':2278,'multiline':False]
['text':' Fixed precision unsigned types:','line_number':2300,'multiline':False]
['text':' Fixed precision signed types:','line_number':2306,'multiline':False]
['text':' Over again, but with checking enabled this time:','line_number':2312,'multiline':False]
['text':' Fixed precision unsigned types:','line_number':2316,'multiline':False]
['text':' Fixed precision signed types:','line_number':2322,'multiline':False]
['text':' see https://github.com/boostorg/multiprecision/issues/413','line_number':2329,'multiline':False]
['text':' and https://github.com/boostorg/multiprecision/issues/431','line_number':2330,'multiline':False]
['text':' namespace boost::multiprecision','line_number':2337,'multiline':False]
['text':'','line_number':2339,'multiline':False]
['text':' Last of all we include the implementations of all the eval_* non member functions:','line_number':2340,'multiline':False]
['text':'','line_number':2341,'multiline':False]
