['text':'/////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'  Copyright 2012 John Maddock. Distributed under the Boost','line_number':2,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt','line_number':4,'multiline':False]
['text':'','line_number':5,'multiline':False]
['text':' Comparison operators for cpp_int_backend:','line_number':6,'multiline':False]
['text':'','line_number':7,'multiline':False]
['text':'
    Very simple, fairly braindead long division.
    Start by setting the remainder equal to x, and the
    result equal to 0.  Then in each loop we calculate our
    "best guess" for how many times y divides into r,
    add our guess to the result, and subtract guess*y
    from the remainder r.  One wrinkle is that the remainder
    may go negative, in which case we subtract the current guess
    from the result rather than adding.  The value of the guess
    is determined by dividing the most-significant-limb of the
    current remainder by the most-significant-limb of y.

    Note that there are more efficient algorithms than this
    available, in particular see Knuth Vol 2.  However for small
    numbers of limbs this generally outperforms the alternatives
    and avoids the normalisation step which would require extra storage.
    ','line_number':36,'multiline':True]
['text':'','line_number':64,'multiline':False]
['text':' Find the most significant words of numerator and denominator.','line_number':65,'multiline':False]
['text':'','line_number':66,'multiline':False]
['text':'','line_number':71,'multiline':False]
['text':' Only a single non-zero limb in the denominator, in this case','line_number':72,'multiline':False]
['text':' we can use a specialized divide-by-single-limb routine which is','line_number':73,'multiline':False]
['text':' much faster.  This also handles division by zero:','line_number':74,'multiline':False]
['text':'','line_number':75,'multiline':False]
['text':' x is zero, so is the result:','line_number':86,'multiline':False]
['text':'','line_number':97,'multiline':False]
['text':' Check if the remainder is already less than the divisor, if so','line_number':98,'multiline':False]
['text':' we already have the result.  Note we try and avoid a full compare','line_number':99,'multiline':False]
['text':' if we can:','line_number':100,'multiline':False]
['text':'','line_number':101,'multiline':False]
['text':'','line_number':113,'multiline':False]
['text':' See if we can short-circuit long division, and use basic arithmetic instead:','line_number':114,'multiline':False]
['text':'','line_number':115,'multiline':False]
['text':'','line_number':137,'multiline':False]
['text':' prepare result:','line_number':138,'multiline':False]
['text':'','line_number':139,'multiline':False]
['text':' This is initialised just to keep the compiler from emitting useless warnings later on:','line_number':143,'multiline':False]
['text':'','line_number':155,'multiline':False]
['text':' Calculate our best guess for how many times y divides into r:','line_number':156,'multiline':False]
['text':'','line_number':157,'multiline':False]
['text':' If the guess ever gets to zero we go on forever....','line_number':182,'multiline':False]
['text':'','line_number':183,'multiline':False]
['text':' Update result:','line_number':184,'multiline':False]
['text':'','line_number':185,'multiline':False]
['text':'','line_number':213,'multiline':False]
['text':' Calculate guess * y, we use a fused mutiply-shift O(N) for this','line_number':214,'multiline':False]
['text':' rather than a full O(N^2) multiply:','line_number':215,'multiline':False]
['text':'','line_number':216,'multiline':False]
['text':'','line_number':245,'multiline':False]
['text':' Update r in a way that won't actually produce a negative result','line_number':246,'multiline':False]
['text':' in case the argument types are unsigned:','line_number':247,'multiline':False]
['text':'','line_number':248,'multiline':False]
['text':' We need to calculate 2^n + t - r','line_number':251,'multiline':False]
['text':' where n is the number of bits in this type.','line_number':252,'multiline':False]
['text':' Simplest way is to get 2^n - r by complementing','line_number':253,'multiline':False]
['text':' r, then add t to it.  Note that we can't call eval_complement','line_number':254,'multiline':False]
['text':' in case this is a signed checked type:','line_number':255,'multiline':False]
['text':'','line_number':274,'multiline':False]
['text':' First time through we need to strip any leading zero, otherwise','line_number':275,'multiline':False]
['text':' the termination condition goes belly-up:','line_number':276,'multiline':False]
['text':'','line_number':277,'multiline':False]
['text':'','line_number':284,'multiline':False]
['text':' Update r_order:','line_number':285,'multiline':False]
['text':'','line_number':286,'multiline':False]
['text':' Termination condition is really just a check that r > y, but with a common','line_number':291,'multiline':False]
['text':' short-circuit case handled first:','line_number':292,'multiline':False]
['text':'','line_number':295,'multiline':False]
['text':' We now just have to normalise the result:','line_number':296,'multiline':False]
['text':'','line_number':297,'multiline':False]
['text':' We have one too many in the result:','line_number':300,'multiline':False]
['text':' remainder must be less than the divisor or our code has failed','line_number':312,'multiline':False]
['text':' As above, but simplified for integer divisor:','line_number':337,'multiline':False]
['text':'','line_number':345,'multiline':False]
['text':' Find the most significant word of numerator.','line_number':346,'multiline':False]
['text':'','line_number':347,'multiline':False]
['text':'','line_number':350,'multiline':False]
['text':' Set remainder and result to their initial values:','line_number':351,'multiline':False]
['text':'','line_number':352,'multiline':False]
['text':'','line_number':357,'multiline':False]
['text':' check for x < y, try to do this without actually having to','line_number':358,'multiline':False]
['text':' do a full comparison:','line_number':359,'multiline':False]
['text':'','line_number':360,'multiline':False]
['text':'','line_number':368,'multiline':False]
['text':' See if we can short-circuit long division, and use basic arithmetic instead:','line_number':369,'multiline':False]
['text':'','line_number':370,'multiline':False]
['text':' This is initialised just to keep the compiler from emitting useless warnings later on:','line_number':395,'multiline':False]
['text':' just in case we don't set the most significant limb below.','line_number':402,'multiline':False]
['text':'','line_number':407,'multiline':False]
['text':' Calculate our best guess for how many times y divides into r:','line_number':408,'multiline':False]
['text':'','line_number':409,'multiline':False]
['text':' No remainder, division was exact.','line_number':421,'multiline':False]
['text':' No remainder, division was exact.','line_number':434,'multiline':False]
['text':' Termination condition is really just a check that r >= y, but with two common','line_number':441,'multiline':False]
['text':' short-circuit cases handled first:','line_number':442,'multiline':False]
['text':' remainder must be less than the divisor or our code has failed','line_number':453,'multiline':False]
['text':' There is no in place divide:','line_number':501,'multiline':False]
['text':' There is no in place divide:','line_number':512,'multiline':False]
['text':' There is no in place divide:','line_number':523,'multiline':False]
['text':'','line_number':556,'multiline':False]
['text':' We must not modify result until here in case','line_number':557,'multiline':False]
['text':' result and a are the same object:','line_number':558,'multiline':False]
['text':'','line_number':559,'multiline':False]
['text':' There is no in place divide:','line_number':583,'multiline':False]
['text':' Single limb modulus is in place:','line_number':594,'multiline':False]
['text':' Single limb modulus is in place:','line_number':604,'multiline':False]
['text':'','line_number':608,'multiline':False]
['text':' Over again for trivial cpp_int's:','line_number':609,'multiline':False]
['text':'','line_number':610,'multiline':False]
['text':' namespace boost::multiprecision::backends','line_number':649,'multiline':False]
