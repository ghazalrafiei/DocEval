['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'  Copyright 2011-21 John Maddock.','line_number':2,'multiline':False]
['text':'  Copyright 2021 Iskandarov Lev. Distributed under the Boost','line_number':3,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]
['text':'to_type','line_number':44,'multiline':True]
['text':'from_type','line_number':44,'multiline':True]
['text':'to_type','line_number':46,'multiline':True]
['text':'from_type','line_number':46,'multiline':True]
['text':'to_type','line_number':48,'multiline':True]
['text':'from_type','line_number':48,'multiline':True]
['text':'to_type','line_number':50,'multiline':True]
['text':'from_type','line_number':50,'multiline':True]
['text':'to_type','line_number':52,'multiline':True]
['text':'from_type','line_number':52,'multiline':True]
['text':' namespace detail','line_number':57,'multiline':False]
['text':' warning C4127: conditional expression is constant','line_number':79,'multiline':False]
['text':' warning C4146: unary minus operator applied to unsigned type, result still unsigned','line_number':80,'multiline':False]
['text':'','line_number':84,'multiline':False]
['text':' Default versions of mixed arithmetic, these just construct a temporary','line_number':85,'multiline':False]
['text':' from the arithmetic value and then do the arithmetic on that, two versions','line_number':86,'multiline':False]
['text':' of each depending on whether the backend can be directly constructed from type V.','line_number':87,'multiline':False]
['text':'','line_number':88,'multiline':False]
['text':' Note that we have to provide *all* the template parameters to class number when used in','line_number':89,'multiline':False]
['text':' enable_if as MSVC-10 won't compile the code if we rely on a computed-default parameter.','line_number':90,'multiline':False]
['text':' Since the result of the test doesn't depend on whether expression templates are on or off','line_number':91,'multiline':False]
['text':' we just use et_on everywhere.  We could use a BOOST_WORKAROUND but that just obfuscates the','line_number':92,'multiline':False]
['text':' code even more....','line_number':93,'multiline':False]
['text':'','line_number':94,'multiline':False]
['text':'','line_number':260,'multiline':False]
['text':' Default versions of 3-arg arithmetic functions, these mostly just forward to the 2 arg versions:','line_number':261,'multiline':False]
['text':'','line_number':262,'multiline':False]
['text':' since most (all?) backends require a const char* to construct from, we just','line_number':973,'multiline':False]
['text':' convert to that:','line_number':974,'multiline':False]
['text':' since most (all?) backends require a const char* to construct from, we just','line_number':981,'multiline':False]
['text':' convert to that:','line_number':982,'multiline':False]
['text':' Find which list we're looking through:','line_number':1027,'multiline':False]
['text':' Can t fit in an R?','line_number':1043,'multiline':False]
['text':'','line_number':1106,'multiline':False]
['text':' We ran out of types to try for the conversion, try','line_number':1107,'multiline':False]
['text':' a lexical_cast and hope for the best:','line_number':1108,'multiline':False]
['text':'','line_number':1109,'multiline':False]
['text':' we should never get here, exception above will be raised.','line_number':1121,'multiline':False]
['text':'','line_number':1136,'multiline':False]
['text':' Last chance conversion to an unsigned integer.','line_number':1137,'multiline':False]
['text':' We ran out of types to try for the conversion, try','line_number':1138,'multiline':False]
['text':' a lexical_cast and hope for the best:','line_number':1139,'multiline':False]
['text':'','line_number':1140,'multiline':False]
['text':' We should never really get here...','line_number':1151,'multiline':False]
['text':' Using standalone mode','line_number':1156,'multiline':False]
['text':'','line_number':1181,'multiline':False]
['text':' We ran out of types to try for the conversion, try','line_number':1182,'multiline':False]
['text':' a generic conversion and hope for the best:','line_number':1183,'multiline':False]
['text':'','line_number':1184,'multiline':False]
['text':'','line_number':1227,'multiline':False]
['text':' Functions:','line_number':1228,'multiline':False]
['text':'','line_number':1229,'multiline':False]
['text':' fallthrough...','line_number':1475,'multiline':False]
['text':'','line_number':1619,'multiline':False]
['text':' This implementation is really really rubbish - it does','line_number':1620,'multiline':False]
['text':' a linear scan for the most-significant-bit.  We should really','line_number':1621,'multiline':False]
['text':' do a binary search, but as none of our backends actually needs','line_number':1622,'multiline':False]
['text':' this implementation, we'll leave it for now.  In fact for most','line_number':1623,'multiline':False]
['text':' backends it's likely that there will always be a more efficient','line_number':1624,'multiline':False]
['text':' native implementation possible.','line_number':1625,'multiline':False]
['text':'','line_number':1626,'multiline':False]
['text':' we can calculate it faster with std::sqrt','line_number':1700,'multiline':False]
['text':' https://hal.inria.fr/file/index/docid/72854/filename/RR-3805.pdf','line_number':1722,'multiline':False]
['text':' we substract after, so it works for unsigned integers too','line_number':1746,'multiline':False]
['text':'','line_number':1762,'multiline':False]
['text':' This is slow bit-by-bit integer square root, see for example','line_number':1763,'multiline':False]
['text':' http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_.28base_2.29','line_number':1764,'multiline':False]
['text':' There are better methods such as http://hal.inria.fr/docs/00/07/28/54/PDF/RR-3805.pdf','line_number':1765,'multiline':False]
['text':' and http://hal.inria.fr/docs/00/07/21/13/PDF/RR-4475.pdf which should be implemented','line_number':1766,'multiline':False]
['text':' at some point.','line_number':1767,'multiline':False]
['text':'','line_number':1768,'multiline':False]
['text':' recursive Karatsuba sqrt can cause issues in constexpr context:','line_number':1821,'multiline':False]
['text':' assume non-complex result.','line_number':1842,'multiline':False]
['text':' assume non-complex result.','line_number':1847,'multiline':False]
['text':'','line_number':1850,'multiline':False]
['text':' These have to implemented by the backend, declared here so that our macro generated code compiles OK.','line_number':1851,'multiline':False]
['text':'','line_number':1852,'multiline':False]
['text':' TODO implement default versions of these:','line_number':1865,'multiline':False]
['text':'','line_number':1873,'multiline':False]
['text':' eval_logb and eval_scalbn simply assume base 2 and forward to','line_number':1874,'multiline':False]
['text':' eval_ldexp and eval_frexp:','line_number':1875,'multiline':False]
['text':'','line_number':1876,'multiline':False]
['text':'','line_number':1985,'multiline':False]
['text':' Normalize x and y, so that both are positive and x >= y:','line_number':1986,'multiline':False]
['text':'','line_number':1987,'multiline':False]
['text':' Special case, see C99 Annex F.','line_number':1996,'multiline':False]
['text':' The order of the if's is important: do not change!','line_number':1997,'multiline':False]
['text':'','line_number':2063,'multiline':False]
['text':' Real and imaginary parts:','line_number':2064,'multiline':False]
['text':'','line_number':2065,'multiline':False]
['text':' namespace default_ops','line_number':2078,'multiline':False]
['text':' namespace default_ops_adl','line_number':2098,'multiline':False]
['text':'','line_number':2129,'multiline':False]
['text':' These functions are implemented in separate files, but expanded inline here,','line_number':2130,'multiline':False]
['text':' DO NOT CHANGE THE ORDER OF THESE INCLUDES:','line_number':2131,'multiline':False]
['text':'','line_number':2132,'multiline':False]
['text':' namespace default_ops','line_number':2137,'multiline':False]
['text':'','line_number':2139,'multiline':False]
['text':' Default versions of floating point classification routines:','line_number':2140,'multiline':False]
['text':'','line_number':2141,'multiline':False]
['text':' Default versions of sign manipulation functions, if individual backends can do better than this','line_number':2200,'multiline':False]
['text':' (for example with signed zero), then they should overload these functions further:','line_number':2201,'multiline':False]
['text':'','line_number':2259,'multiline':False]
['text':' real and imag:','line_number':2260,'multiline':False]
['text':'','line_number':2261,'multiline':False]
['text':'','line_number':2303,'multiline':False]
['text':' Complex number functions, these are overloaded at the Backend level, we just provide the','line_number':2304,'multiline':False]
['text':' expression template versions here, plus overloads for non-complex types:','line_number':2305,'multiline':False]
['text':'','line_number':2306,'multiline':False]
['text':' BOOST_MP_MATH_AVAILABLE','line_number':2341,'multiline':False]
['text':'','line_number':2394,'multiline':False]
['text':' We also allow the first argument to polar to be an arithmetic type (probably a literal):','line_number':2395,'multiline':False]
['text':'','line_number':2396,'multiline':False]
['text':'','line_number':2412,'multiline':False]
['text':' Single argument overloads:','line_number':2413,'multiline':False]
['text':'','line_number':2414,'multiline':False]
['text':' namespace multiprecision','line_number':2428,'multiline':False]
['text':'','line_number':2432,'multiline':False]
['text':' Import Math functions here, so they can be found by Boost.Math:','line_number':2433,'multiline':False]
['text':'','line_number':2434,'multiline':False]
['text':' namespace policies','line_number':2481,'multiline':False]
['text':' namespace math','line_number':2484,'multiline':False]
['text':' BOOST_MP_MATH_AVAILABLE','line_number':2723,'multiline':False]
['text':'','line_number':2984,'multiline':False]
['text':' frexp does not return an expression template since we require the','line_number':2985,'multiline':False]
['text':' integer argument to be evaluated even if the returned value is','line_number':2986,'multiline':False]
['text':' not assigned to anything...','line_number':2987,'multiline':False]
['text':'','line_number':2988,'multiline':False]
['text':'','line_number':3053,'multiline':False]
['text':' modf does not return an expression template since we require the','line_number':3054,'multiline':False]
['text':' second argument to be evaluated even if the returned value is','line_number':3055,'multiline':False]
['text':' not assigned to anything...','line_number':3056,'multiline':False]
['text':'','line_number':3057,'multiline':False]
['text':'','line_number':3077,'multiline':False]
['text':' Integer square root:','line_number':3078,'multiline':False]
['text':'','line_number':3079,'multiline':False]
['text':'','line_number':3101,'multiline':False]
['text':' fma:','line_number':3102,'multiline':False]
['text':'','line_number':3103,'multiline':False]
['text':' namespace default_ops','line_number':3116,'multiline':False]
['text':' namespace default_ops','line_number':3246,'multiline':False]
['text':' clang-format off','line_number':3335,'multiline':False]
['text':'','line_number':3336,'multiline':False]
['text':' Regrettably, when the argument to a function is an rvalue we must return by value, and not return an ','line_number':3337,'multiline':False]
['text':' expression template, otherwise we can end up with dangling references.  ','line_number':3338,'multiline':False]
['text':' See https://github.com/boostorg/multiprecision/issues/175.','line_number':3339,'multiline':False]
['text':'','line_number':3340,'multiline':False]
['text':' clang-format on','line_number':3711,'multiline':False]
['text':' namespace detail','line_number':3742,'multiline':False]
['text':'HETERO_BINARY_OP_FUNCTOR(frexp, short*, number_kind_floating_point)','line_number':3857,'multiline':False]
['text':'HETERO_BINARY_OP_FUNCTOR_B(frexp, int*, number_kind_floating_point)','line_number':3859,'multiline':False]
['text':'HETERO_BINARY_OP_FUNCTOR_B(frexp, long*, number_kind_floating_point)','line_number':3861,'multiline':False]
['text':'HETERO_BINARY_OP_FUNCTOR_B(frexp, long long*, number_kind_floating_point)','line_number':3863,'multiline':False]
['text':'','line_number':3883,'multiline':False]
['text':' Complex functions:','line_number':3884,'multiline':False]
['text':'','line_number':3885,'multiline':False]
['text':'','line_number':3904,'multiline':False]
['text':' Integer functions:','line_number':3905,'multiline':False]
['text':'','line_number':3906,'multiline':False]
['text':'','line_number':3914,'multiline':False]
['text':' ilogb:','line_number':3915,'multiline':False]
['text':'','line_number':3916,'multiline':False]
['text':'namespace multiprecision','line_number':3934,'multiline':False]
['text':'','line_number':3937,'multiline':False]
['text':' Overload of Boost.Math functions that find the wrong overload when used with number:','line_number':3938,'multiline':False]
['text':'','line_number':3939,'multiline':False]
['text':' namespace detail','line_number':3945,'multiline':False]
['text':' namespace math','line_number':3980,'multiline':False]
['text':' namespace integer','line_number':3987,'multiline':False]
['text':' namespace boost','line_number':3989,'multiline':False]
['text':'','line_number':3991,'multiline':False]
['text':' This has to come last of all:','line_number':3992,'multiline':False]
['text':'','line_number':3993,'multiline':False]
['text':'','line_number':3996,'multiline':False]
['text':' min/max overloads:','line_number':3997,'multiline':False]
['text':'','line_number':3998,'multiline':False]
