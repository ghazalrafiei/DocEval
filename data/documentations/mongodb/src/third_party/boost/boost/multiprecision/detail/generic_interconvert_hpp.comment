['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'  Copyright 2011 John Maddock. Distributed under the Boost','line_number':2,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':4,'multiline':False]
['text':'to_type','line_number':36,'multiline':True]
['text':'from_type','line_number':36,'multiline':True]
['text':' smallest unsigned type handled natively by "From" is likely to be it's limb_type:','line_number':45,'multiline':False]
['text':' get the corresponding type that we can assign to "To":','line_number':47,'multiline':False]
['text':' Pick off the first limb:','line_number':53,'multiline':False]
['text':'','line_number':61,'multiline':False]
['text':' Then keep picking off more limbs until "t" is zero:','line_number':62,'multiline':False]
['text':'','line_number':63,'multiline':False]
['text':'','line_number':76,'multiline':False]
['text':' Finish off by setting the sign:','line_number':77,'multiline':False]
['text':'','line_number':78,'multiline':False]
['text':'to_type','line_number':84,'multiline':True]
['text':'from_type','line_number':84,'multiline':True]
['text':' smallest unsigned type handled natively by "From" is likely to be it's limb_type:','line_number':93,'multiline':False]
['text':' get the corresponding type that we can assign to "To":','line_number':95,'multiline':False]
['text':' Pick off the first limb:','line_number':101,'multiline':False]
['text':'','line_number':109,'multiline':False]
['text':' Then keep picking off more limbs until "t" is zero:','line_number':110,'multiline':False]
['text':'','line_number':111,'multiline':False]
['text':'','line_number':124,'multiline':False]
['text':' Finish off by setting the sign:','line_number':125,'multiline':False]
['text':'','line_number':126,'multiline':False]
['text':'to_type','line_number':132,'multiline':True]
['text':'from_type','line_number':132,'multiline':True]
['text':'#pragma warning(disable : 4127)','line_number':136,'multiline':False]
['text':'','line_number':138,'multiline':False]
['text':' The code here only works when the radix of "From" is 2, we could try shifting by other','line_number':139,'multiline':False]
['text':' radixes but it would complicate things.... use a string conversion when the radix is other','line_number':140,'multiline':False]
['text':' than 2:','line_number':141,'multiline':False]
['text':'','line_number':142,'multiline':False]
['text':'','line_number':159,'multiline':False]
['text':' First classify the input, then handle the special cases:','line_number':160,'multiline':False]
['text':'','line_number':161,'multiline':False]
['text':' extract int sized bits from f:','line_number':192,'multiline':False]
['text':'to_type','line_number':225,'multiline':True]
['text':'from_type','line_number':225,'multiline':True]
['text':'to_type','line_number':236,'multiline':True]
['text':'from_type','line_number':236,'multiline':True]
['text':'','line_number':274,'multiline':False]
['text':' Calculate and add on the remainder, only if there are more','line_number':275,'multiline':False]
['text':' digits in the mantissa that the size of the exponent, in','line_number':276,'multiline':False]
['text':' other words if we are dropping digits in the conversion','line_number':277,'multiline':False]
['text':' otherwise:','line_number':278,'multiline':False]
['text':'','line_number':279,'multiline':False]
['text':'','line_number':294,'multiline':False]
['text':' If we get here, then there's something about one type or the other','line_number':295,'multiline':False]
['text':' that prevents an exactly rounded result from being calculated','line_number':296,'multiline':False]
['text':' (or at least it's not clear how to implement such a thing).','line_number':297,'multiline':False]
['text':'','line_number':298,'multiline':False]
['text':'','line_number':307,'multiline':False]
['text':' If we get here, then there's something about one type or the other','line_number':308,'multiline':False]
['text':' that prevents an exactly rounded result from being calculated','line_number':309,'multiline':False]
['text':' (or at least it's not clear how to implement such a thing).','line_number':310,'multiline':False]
['text':'','line_number':311,'multiline':False]
['text':'','line_number':321,'multiline':False]
['text':' If we get here, then the precision of type To is known, and the integer type is unbounded','line_number':322,'multiline':False]
['text':' so we can use integer division plus manipulation of the remainder to get an exactly','line_number':323,'multiline':False]
['text':' rounded result.','line_number':324,'multiline':False]
['text':'','line_number':325,'multiline':False]
['text':'','line_number':348,'multiline':False]
['text':' Round up if 2 * r > denom:','line_number':349,'multiline':False]
['text':'','line_number':350,'multiline':False]
['text':'','line_number':363,'multiline':False]
['text':' We basically already have the rounding info:','line_number':364,'multiline':False]
['text':'','line_number':365,'multiline':False]
['text':'','line_number':390,'multiline':False]
['text':' Type From is always a Backend to number<>, or an','line_number':391,'multiline':False]
['text':' instance of number<>, but we allow','line_number':392,'multiline':False]
['text':' To to be either a Backend type, or a real number type,','line_number':393,'multiline':False]
['text':' that way we can call this from generic conversions, and','line_number':394,'multiline':False]
['text':' from specific conversions to built in types.','line_number':395,'multiline':False]
['text':'','line_number':396,'multiline':False]
['text':'to_type','line_number':407,'multiline':True]
['text':'from_type','line_number':407,'multiline':True]
['text':'radix','line_number':413,'multiline':True]
['text':'radix','line_number':441,'multiline':True]
['text':'','line_number':447,'multiline':False]
['text':' This is almost the same as the binary case above, but we have to use','line_number':448,'multiline':False]
['text':' scalbn and ilogb rather than ldexp and frexp, we also only extract','line_number':449,'multiline':False]
['text':' one Radix digit at a time which is terribly inefficient!','line_number':450,'multiline':False]
['text':'','line_number':451,'multiline':False]
['text':'to_type','line_number':486,'multiline':True]
['text':'from_type','line_number':486,'multiline':True]
['text':'to_type','line_number':492,'multiline':True]
['text':'from_type','line_number':492,'multiline':True]
['text':'radix','line_number':500,'multiline':True]
['text':'radix','line_number':533,'multiline':True]
['text':'','line_number':537,'multiline':False]
['text':' This is almost the same as the binary case above, but we have to use','line_number':538,'multiline':False]
['text':' scalbn and ilogb rather than ldexp and frexp, we also only extract','line_number':539,'multiline':False]
['text':' one Radix digit at a time which is terribly inefficient!','line_number':540,'multiline':False]
['text':'','line_number':541,'multiline':False]
['text':'to_type','line_number':560,'multiline':True]
['text':'from_type','line_number':560,'multiline':True]
['text':' We just want the real part, and "to" is the correct type already:','line_number':568,'multiline':False]
['text':'','line_number':581,'multiline':False]
['text':' Get the real part and copy-construct the result from it:','line_number':582,'multiline':False]
['text':'','line_number':583,'multiline':False]
['text':'','line_number':594,'multiline':False]
['text':' Get the real part and use a generic_interconvert to type To:','line_number':595,'multiline':False]
['text':'','line_number':596,'multiline':False]
['text':'to_type','line_number':604,'multiline':True]
['text':'from_type','line_number':604,'multiline':True]
['text':'to_type','line_number':612,'multiline':True]
['text':'from_type','line_number':612,'multiline':True]
['text':'to_type','line_number':620,'multiline':True]
['text':'from_type','line_number':620,'multiline':True]
['text':'to_type','line_number':628,'multiline':True]
['text':'from_type','line_number':628,'multiline':True]
['text':'to_type','line_number':643,'multiline':True]
['text':'from_type','line_number':643,'multiline':True]
['text':'to_type','line_number':658,'multiline':True]
['text':'from_type','line_number':658,'multiline':True]
['text':'to','line_number':673,'multiline':True]
['text':'from','line_number':673,'multiline':True]
['text':'to_type','line_number':673,'multiline':True]
['text':'from_type','line_number':673,'multiline':True]
['text':' namespace boost::multiprecision::detail','line_number':680,'multiline':False]
['text':' BOOST_MP_GENERIC_INTERCONVERT_HPP','line_number':686,'multiline':False]
