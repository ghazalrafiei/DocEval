['text':'/////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'  Copyright 2020 Madhur Chauhan. ','line_number':2,'multiline':False]
['text':'  Copyright 2020 John Maddock. Distributed under the Boost','line_number':3,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at https://www.boost.org/LICENSE_1_0.txt','line_number':5,'multiline':False]
['text':'','line_number':19,'multiline':False]
['text':' This is the generic, C++ only version of addition.','line_number':20,'multiline':False]
['text':' It's also used for all constexpr branches, hence the name.','line_number':21,'multiline':False]
['text':' Nothing fancy, just let uintmax_t take the strain:','line_number':22,'multiline':False]
['text':'','line_number':23,'multiline':False]
['text':' First where a and b overlap:','line_number':45,'multiline':False]
['text':' Now where only a has digits:','line_number':58,'multiline':False]
['text':' We overflowed, need to add one more limb:','line_number':78,'multiline':False]
['text':'','line_number':86,'multiline':False]
['text':' Core subtraction routine for all non-trivial cpp_int's:','line_number':87,'multiline':False]
['text':'','line_number':88,'multiline':False]
['text':'','line_number':93,'multiline':False]
['text':' This is the generic, C++ only version of subtraction.','line_number':94,'multiline':False]
['text':' It's also used for all constexpr branches, hence the name.','line_number':95,'multiline':False]
['text':' Nothing fancy, just let uintmax_t take the strain:','line_number':96,'multiline':False]
['text':'','line_number':97,'multiline':False]
['text':'','line_number':101,'multiline':False]
['text':' special cases for small limb counts:','line_number':102,'multiline':False]
['text':'','line_number':103,'multiline':False]
['text':' This isn't used till later, but comparison has to occur before we resize the result,','line_number':118,'multiline':False]
['text':' as that may also resize a or b if this is an inplace operation:','line_number':119,'multiline':False]
['text':' Set up the result vector:','line_number':121,'multiline':False]
['text':' Now that a, b, and result are stable, get pointers to their limbs:','line_number':123,'multiline':False]
['text':' First where a and b overlap:','line_number':140,'multiline':False]
['text':' Now where only a has digits, only as long as we've borrowed:','line_number':148,'multiline':False]
['text':' Any remaining digits are the same as those in pa:','line_number':156,'multiline':False]
['text':'','line_number':161,'multiline':False]
['text':' We may have lost digits, if so update limb usage count:','line_number':162,'multiline':False]
['text':'','line_number':163,'multiline':False]
['text':'','line_number':172,'multiline':False]
['text':' This is the key addition routine where all the argument types are non-trivial cpp_int's:','line_number':173,'multiline':False]
['text':'','line_number':174,'multiline':False]
['text':'','line_number':175,'multiline':False]
['text':' This optimization is limited to: GCC, LLVM, ICC (Intel), MSVC for x86_64 and i386.','line_number':176,'multiline':False]
['text':' If your architecture and compiler supports ADC intrinsic, please file a bug','line_number':177,'multiline':False]
['text':'','line_number':178,'multiline':False]
['text':' As of May, 2020 major compilers don't recognize carry chain though adc','line_number':179,'multiline':False]
['text':' intrinsics are used to hint compilers to use ADC and still compilers don't','line_number':180,'multiline':False]
['text':' unroll the loop efficiently (except LLVM) so manual unrolling is done.','line_number':181,'multiline':False]
['text':'','line_number':182,'multiline':False]
['text':' Also note that these intrinsics were only introduced by Intel as part of the','line_number':183,'multiline':False]
['text':' ADX processor extensions, even though the addc instruction has been available','line_number':184,'multiline':False]
['text':' for basically all x86 processors.  That means gcc-9, clang-9, msvc-14.2 and up','line_number':185,'multiline':False]
['text':' are required to support these intrinsics.','line_number':186,'multiline':False]
['text':'','line_number':187,'multiline':False]
['text':' Nothing fancy, just let uintmax_t take the strain:','line_number':201,'multiline':False]
['text':' First where a and b overlap:','line_number':220,'multiline':False]
['text':'','line_number':224,'multiline':False]
['text':' Special case for 32-bit limbs on 64-bit architecture - we can process','line_number':225,'multiline':False]
['text':' 2 limbs with each instruction.','line_number':226,'multiline':False]
['text':'','line_number':227,'multiline':False]
['text':' We know carry is 1, so we just need to increment pa[i] (ie add a literal 1) and capture the carry:','line_number':247,'multiline':False]
['text':' We overflowed, need to add one more limb:','line_number':251,'multiline':False]
['text':' Copy remaining digits only if we need to:','line_number':257,'multiline':False]
['text':' Nothing fancy, just let uintmax_t take the strain:','line_number':277,'multiline':False]
['text':'','line_number':280,'multiline':False]
['text':' special cases for small limb counts:','line_number':281,'multiline':False]
['text':'','line_number':282,'multiline':False]
['text':' This isn't used till later, but comparison has to occur before we resize the result,','line_number':297,'multiline':False]
['text':' as that may also resize a or b if this is an inplace operation:','line_number':298,'multiline':False]
['text':' Set up the result vector:','line_number':300,'multiline':False]
['text':' Now that a, b, and result are stable, get pointers to their limbs:','line_number':302,'multiline':False]
['text':' First where a and b overlap:','line_number':320,'multiline':False]
['text':'','line_number':322,'multiline':False]
['text':' Special case for 32-bit limbs on 64-bit architecture - we can process','line_number':323,'multiline':False]
['text':' 2 limbs with each instruction.','line_number':324,'multiline':False]
['text':'','line_number':325,'multiline':False]
['text':' Now where only a has digits, only as long as we've borrowed:','line_number':345,'multiline':False]
['text':' Any remaining digits are the same as those in pa:','line_number':351,'multiline':False]
['text':'','line_number':356,'multiline':False]
['text':' We may have lost digits, if so update limb usage count:','line_number':357,'multiline':False]
['text':'','line_number':358,'multiline':False]
['text':' constepxr.','line_number':363,'multiline':False]
['text':' namespaces','line_number':382,'multiline':False]
