['text':' Copyright Christopher Kormanyos 2002 - 2011.','line_number':2,'multiline':False]
['text':' Copyright 2011 John Maddock.','line_number':3,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0.','line_number':4,'multiline':False]
['text':'    (See accompanying file LICENSE_1_0.txt or copy at','line_number':5,'multiline':False]
['text':'          http://www.boost.org/LICENSE_1_0.txt)','line_number':6,'multiline':False]
['text':' This work is based on an earlier work:','line_number':8,'multiline':False]
['text':' "Algorithm 910: A Portable C++ Multiple-Precision System for Special-Function Calculations",','line_number':9,'multiline':False]
['text':' in ACM TOMS, {VOL 37, ISSUE 4, (February 2011)} (C) ACM, 2011. http://doi.acm.org/10.1145/1916461.1916469','line_number':10,'multiline':False]
['text':'','line_number':11,'multiline':False]
['text':' This file has no include guards or namespaces - it's expanded inline inside default_ops.hpp','line_number':12,'multiline':False]
['text':'','line_number':13,'multiline':False]
['text':' comparison of two constants','line_number':21,'multiline':False]
['text':' conditional expression is constant','line_number':22,'multiline':False]
['text':' Compute the series representation of Hypergeometric0F1 taken from','line_number':31,'multiline':False]
['text':' http://functions.wolfram.com/HypergeometricFunctions/Hypergeometric0F1/06/01/01/','line_number':32,'multiline':False]
['text':' There are no checks on input range or parameter boundaries.','line_number':33,'multiline':False]
['text':' Series expansion of hyperg_0f1(; b; x).','line_number':56,'multiline':False]
['text':'','line_number':111,'multiline':False]
['text':' We need to perform argument reduction at 3 times the precision of arg','line_number':112,'multiline':False]
['text':' in order to ensure a correct result up to arg = 1/epsilon.  Beyond that','line_number':113,'multiline':False]
['text':' the value of n will have been incorrectly calculated anyway since it will','line_number':114,'multiline':False]
['text':' have a value greater than 1/epsilon and no longer be an exact integer value.','line_number':115,'multiline':False]
['text':'','line_number':116,'multiline':False]
['text':' More information in ARGUMENT REDUCTION FOR HUGE ARGUMENTS. K C Ng.','line_number':117,'multiline':False]
['text':'','line_number':118,'multiline':False]
['text':' There are two mutually exclusive ways to achieve this, both of which are ','line_number':119,'multiline':False]
['text':' supported here:','line_number':120,'multiline':False]
['text':' 1) To define a fixed precision type with 3 times the precision for the calculation.','line_number':121,'multiline':False]
['text':' 2) To dynamically increase the precision of the variables.','line_number':122,'multiline':False]
['text':'','line_number':123,'multiline':False]
['text':'','line_number':125,'multiline':False]
['text':' Make a copy of the arg at higher precision:','line_number':126,'multiline':False]
['text':'','line_number':127,'multiline':False]
['text':'','line_number':129,'multiline':False]
['text':' Dynamically increase precision when supported, this increases the default','line_number':130,'multiline':False]
['text':' and ups the precision of big_arg to match:','line_number':131,'multiline':False]
['text':'','line_number':132,'multiline':False]
['text':'','line_number':134,'multiline':False]
['text':' High precision PI:','line_number':135,'multiline':False]
['text':'','line_number':136,'multiline':False]
['text':' divide by 2','line_number':138,'multiline':False]
['text':'','line_number':149,'multiline':False]
['text':' If arg is a variable precision type, then we have just copied the','line_number':150,'multiline':False]
['text':' precision of big_arg s well it's value.  Reduce the precision now:','line_number':151,'multiline':False]
['text':'','line_number':152,'multiline':False]
['text':' Local copy of the argument','line_number':193,'multiline':False]
['text':' Analyze and prepare the phase of the argument.','line_number':196,'multiline':False]
['text':' Make a local, positive copy of the argument, xx.','line_number':197,'multiline':False]
['text':' The argument xx will be reduced to 0 <= xx <= pi/2.','line_number':198,'multiline':False]
['text':' divide by 2','line_number':209,'multiline':False]
['text':' Remove multiples of pi/2.','line_number':210,'multiline':False]
['text':'','line_number':234,'multiline':False]
['text':' If n_pi is > 1/epsilon, then it is no longer an exact integer value','line_number':235,'multiline':False]
['text':' but an approximation.  As a result we can no longer reliably reduce','line_number':236,'multiline':False]
['text':' xx to 0 <= xx < pi/2, nor can we tell the sign of the result as we need','line_number':237,'multiline':False]
['text':' n_pi % 4 for that, but that will always be zero in this situation.','line_number':238,'multiline':False]
['text':' We could use a higher precision type for n_pi, along with division at','line_number':239,'multiline':False]
['text':' higher precision, but that's rather expensive.  So for now we do not support','line_number':240,'multiline':False]
['text':' this, and will see if anyone complains and has a legitimate use case.','line_number':241,'multiline':False]
['text':'','line_number':242,'multiline':False]
['text':'','line_number':250,'multiline':False]
['text':' Post reduction we may be a few ulp below zero or above pi/2','line_number':251,'multiline':False]
['text':' given that n_pi was calculated at working precision and not','line_number':252,'multiline':False]
['text':' at the higher precision used for reduction.  Correct that now:','line_number':253,'multiline':False]
['text':'','line_number':254,'multiline':False]
['text':' Check if the reduced argument is very close to 0 or pi/2.','line_number':283,'multiline':False]
['text':' Scale to a small argument for an efficient Taylor series,','line_number':316,'multiline':False]
['text':' implemented as a hypergeometric function. Use a standard','line_number':317,'multiline':False]
['text':' divide by three identity a certain number of times.','line_number':318,'multiline':False]
['text':' Here we use division by 3^9 --> (19683 = 3^9).','line_number':319,'multiline':False]
['text':' Now with small arguments, we are ready for a series expansion.','line_number':326,'multiline':False]
['text':' Convert back using multiple angle identity.','line_number':335,'multiline':False]
['text':' Rescale the cosine value using the multiple angle identity.','line_number':338,'multiline':False]
['text':' Local copy of the argument','line_number':385,'multiline':False]
['text':' Analyze and prepare the phase of the argument.','line_number':388,'multiline':False]
['text':' Make a local, positive copy of the argument, xx.','line_number':389,'multiline':False]
['text':' The argument xx will be reduced to 0 <= xx <= pi/2.','line_number':390,'multiline':False]
['text':' divide by 2','line_number':401,'multiline':False]
['text':' Remove even multiples of pi.','line_number':402,'multiline':False]
['text':'','line_number':407,'multiline':False]
['text':' If n_pi is > 1/epsilon, then it is no longer an exact integer value','line_number':408,'multiline':False]
['text':' but an approximation.  As a result we can no longer reliably reduce','line_number':409,'multiline':False]
['text':' xx to 0 <= xx < pi/2, nor can we tell the sign of the result as we need','line_number':410,'multiline':False]
['text':' n_pi % 4 for that, but that will always be zero in this situation.','line_number':411,'multiline':False]
['text':' We could use a higher precision type for n_pi, along with division at','line_number':412,'multiline':False]
['text':' higher precision, but that's rather expensive.  So for now we do not support','line_number':413,'multiline':False]
['text':' this, and will see if anyone complains and has a legitimate use case.','line_number':414,'multiline':False]
['text':'','line_number':415,'multiline':False]
['text':'','line_number':448,'multiline':False]
['text':' Post reduction we may be a few ulp below zero or above pi/2','line_number':449,'multiline':False]
['text':' given that n_pi was calculated at working precision and not','line_number':450,'multiline':False]
['text':' at the higher precision used for reduction.  Correct that now:','line_number':451,'multiline':False]
['text':'','line_number':452,'multiline':False]
['text':' Compute the series representation of hyperg_2f1 taken from','line_number':508,'multiline':False]
['text':' Abramowitz and Stegun 15.1.1.','line_number':509,'multiline':False]
['text':' There are no checks on input range or parameter boundaries.','line_number':510,'multiline':False]
['text':' Series expansion of hyperg_2f1(a, b; c; x).','line_number':540,'multiline':False]
['text':' http://functions.wolfram.com/ElementaryFunctions/ArcSin/26/01/01/','line_number':628,'multiline':False]
['text':' http://functions.wolfram.com/ElementaryFunctions/ArcSin/26/01/01/','line_number':639,'multiline':False]
['text':' This branch is simlilar in complexity to Newton iterations down to','line_number':640,'multiline':False]
['text':' the above limit.  It is *much* more accurate.','line_number':641,'multiline':False]
['text':' Get initial estimate using standard math function asin.','line_number':664,'multiline':False]
['text':' Newton-Raphson iteration, we should double our precision with each iteration,','line_number':670,'multiline':False]
['text':' in practice this seems to not quite work in all cases... so terminate when we','line_number':671,'multiline':False]
['text':' have at least 2/3 of the digits correct on the assumption that the correction','line_number':672,'multiline':False]
['text':' we've just added will finish the job...','line_number':673,'multiline':False]
['text':' Newton-Raphson iteration','line_number':680,'multiline':False]
['text':' divide by two.','line_number':717,'multiline':False]
['text':' https://functions.wolfram.com/ElementaryFunctions/ArcCos/26/01/01/','line_number':749,'multiline':False]
['text':' https://functions.wolfram.com/ElementaryFunctions/ArcCos/26/01/01/','line_number':770,'multiline':False]
['text':' This branch is simlilar in complexity to Newton iterations down to','line_number':771,'multiline':False]
['text':' the above limit.  It is *much* more accurate.','line_number':772,'multiline':False]
['text':' Get initial estimate using standard math function asin.','line_number':791,'multiline':False]
['text':' Newton-Raphson iteration, we should double our precision with each iteration,','line_number':797,'multiline':False]
['text':' in practice this seems to not quite work in all cases... so terminate when we','line_number':798,'multiline':False]
['text':' have at least 2/3 of the digits correct on the assumption that the correction','line_number':799,'multiline':False]
['text':' we've just added will finish the job...','line_number':800,'multiline':False]
['text':' Newton-Raphson iteration','line_number':807,'multiline':False]
['text':' Get initial estimate using standard math function atan.','line_number':890,'multiline':False]
['text':' Newton-Raphson iteration, we should double our precision with each iteration,','line_number':895,'multiline':False]
['text':' in practice this seems to not quite work in all cases... so terminate when we','line_number':896,'multiline':False]
['text':' have at least 2/3 of the digits correct on the assumption that the correction','line_number':897,'multiline':False]
['text':' we've just added will finish the job...','line_number':898,'multiline':False]
['text':' Note we allow atan2(0,0) to be +-zero, even though it's mathematically undefined','line_number':957,'multiline':False]
['text':' 3Pi/4','line_number':967,'multiline':False]
['text':' Pi/4','line_number':975,'multiline':False]
['text':' Determine quadrant (sign) based on signs of x, y','line_number':1021,'multiline':False]
