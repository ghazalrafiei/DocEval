['text':'=============================================================================
    Copyright (c) 2004 Angus Leeming
    Copyright (c) 2004 Joel de Guzman

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
==============================================================================','line_number':1,'multiline':True]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':22,'multiline':False]
['text':'','line_number':23,'multiline':False]
['text':'  STL container member functions','line_number':24,'multiline':False]
['text':'','line_number':25,'multiline':False]
['text':'      Lazy functions for STL container member functions','line_number':26,'multiline':False]
['text':'','line_number':27,'multiline':False]
['text':'      These functions provide a mechanism for the lazy evaluation of the','line_number':28,'multiline':False]
['text':'      public member functions of the STL containers. For an overview of','line_number':29,'multiline':False]
['text':'      what is meant by 'lazy evaluation', see the comments in operators.hpp','line_number':30,'multiline':False]
['text':'      and functions.hpp.','line_number':31,'multiline':False]
['text':'','line_number':32,'multiline':False]
['text':'      Lazy functions are provided for all of the member functions of the','line_number':33,'multiline':False]
['text':'      following containers:','line_number':34,'multiline':False]
['text':'','line_number':35,'multiline':False]
['text':'      deque - list - map - multimap - vector - set - multiset.','line_number':36,'multiline':False]
['text':'','line_number':37,'multiline':False]
['text':'      Indeed, should *your* class have member functions with the same names','line_number':38,'multiline':False]
['text':'      and signatures as those listed below, then it will automatically be','line_number':39,'multiline':False]
['text':'      supported. To summarize, lazy functions are provided for member','line_number':40,'multiline':False]
['text':'      functions:','line_number':41,'multiline':False]
['text':'','line_number':42,'multiline':False]
['text':'          assign - at - back - begin - capacity - clear - empty - end -','line_number':43,'multiline':False]
['text':'          erase - front - get_allocator - insert - key_comp - max_size -','line_number':44,'multiline':False]
['text':'          pop_back - pop_front - push_back - push_front - rbegin - rend -','line_number':45,'multiline':False]
['text':'          reserve - resize . size - splice - value_comp.','line_number':46,'multiline':False]
['text':'','line_number':47,'multiline':False]
['text':'      The lazy functions' names are the same as the corresponding member','line_number':48,'multiline':False]
['text':'      function. Sample usage:','line_number':49,'multiline':False]
['text':'','line_number':50,'multiline':False]
['text':'      "Normal" version                 "Lazy" version','line_number':51,'multiline':False]
['text':'      ----------------                 --------------','line_number':52,'multiline':False]
['text':'      my_vector.at(5)                  phoenix::at(arg1, 5)','line_number':53,'multiline':False]
['text':'      my_list.size()                   phoenix::size(arg1)','line_number':54,'multiline':False]
['text':'      my_vector1.swap(my_vector2)      phoenix::swap(arg1, arg2)','line_number':55,'multiline':False]
['text':'','line_number':56,'multiline':False]
['text':'      Notice that member functions with names that clash with a','line_number':57,'multiline':False]
['text':'      function in stl algorithms are absent. This will be provided','line_number':58,'multiline':False]
['text':'      in Phoenix's algorithm module.','line_number':59,'multiline':False]
['text':'','line_number':60,'multiline':False]
['text':'      No support is provided here for lazy versions of operator+=,','line_number':61,'multiline':False]
['text':'      operator[] etc. Such operators are not specific to STL containers and','line_number':62,'multiline':False]
['text':'      lazy versions can therefore be found in operators.hpp.','line_number':63,'multiline':False]
['text':'','line_number':64,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':65,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':67,'multiline':False]
['text':'','line_number':68,'multiline':False]
['text':'  Lazy member function implementaions.','line_number':69,'multiline':False]
['text':'','line_number':70,'multiline':False]
['text':'      The structs below provide the guts of the implementation. Thereafter,','line_number':71,'multiline':False]
['text':'      the corresponding lazy function itself is simply:','line_number':72,'multiline':False]
['text':'','line_number':73,'multiline':False]
['text':'          function<stl::assign> const assign = stl::assign();','line_number':74,'multiline':False]
['text':'','line_number':75,'multiline':False]
['text':'      The structs provide a nested "result" class template whose','line_number':76,'multiline':False]
['text':'      "type" typedef enables the lazy function to ascertain the type','line_number':77,'multiline':False]
['text':'      to be returned when it is invoked.','line_number':78,'multiline':False]
['text':'','line_number':79,'multiline':False]
['text':'      They also provide operator() member functions with signatures','line_number':80,'multiline':False]
['text':'      corresponding to those of the underlying member function of','line_number':81,'multiline':False]
['text':'      the STL container.','line_number':82,'multiline':False]
['text':'','line_number':83,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':84,'multiline':False]
['text':'typedef typename const_qualified_reference_of<C>::type type;','line_number':159,'multiline':False]
['text':' MSVC and libc++ always returns iterator even in C++03 mode.','line_number':289,'multiline':False]
['text':'&& (BOOST_MSVC <= 1500)','line_number':294,'multiline':True]
['text':'  This mouthful can differentiate between the generic erase','line_number':316,'multiline':False]
['text':'  functions (Container == std::deque, std::list, std::vector) and','line_number':317,'multiline':False]
['text':'  that specific to Associative Containers.','line_number':318,'multiline':False]
['text':'','line_number':319,'multiline':False]
['text':'  where C is a std::deque, std::list, std::vector:','line_number':320,'multiline':False]
['text':'','line_number':321,'multiline':False]
['text':'      1) iterator C::erase(iterator where);','line_number':322,'multiline':False]
['text':'      2) iterator C::erase(iterator first, iterator last);','line_number':323,'multiline':False]
['text':'','line_number':324,'multiline':False]
['text':'  where C is a std::map, std::multimap, std::set, or std::multiset:','line_number':325,'multiline':False]
['text':'','line_number':326,'multiline':False]
['text':'      3) size_type M::erase(const Key& keyval);','line_number':327,'multiline':False]
['text':'      4-a) void M::erase(iterator where);','line_number':328,'multiline':False]
['text':'      4-b) iterator M::erase(iterator where);','line_number':329,'multiline':False]
['text':'      5-a) void M::erase(iterator first, iterator last);','line_number':330,'multiline':False]
['text':'      5-b) iterator M::erase(iterator first, iterator last);','line_number':331,'multiline':False]
['text':'  This mouthful can differentiate between the generic insert','line_number':449,'multiline':False]
['text':'  functions (Container == deque, list, vector) and those','line_number':450,'multiline':False]
['text':'  specific to the two map-types, std::map and std::multimap.','line_number':451,'multiline':False]
['text':'','line_number':452,'multiline':False]
['text':'  where C is a std::deque, std::list, std::vector:','line_number':453,'multiline':False]
['text':'','line_number':454,'multiline':False]
['text':'      1) iterator C::insert(iterator where, value_type value);','line_number':455,'multiline':False]
['text':'      2) void C::insert(','line_number':456,'multiline':False]
['text':'          iterator where, size_type count, value_type value);','line_number':457,'multiline':False]
['text':'      3) template <typename Iter>','line_number':458,'multiline':False]
['text':'         void C::insert(iterator where, Iter first, Iter last);','line_number':459,'multiline':False]
['text':'','line_number':460,'multiline':False]
['text':'  where M is a std::map and MM is a std::multimap:','line_number':461,'multiline':False]
['text':'','line_number':462,'multiline':False]
['text':'      4) pair<iterator, bool> M::insert(value_type const&);','line_number':463,'multiline':False]
['text':'      5) iterator MM::insert(value_type const&);','line_number':464,'multiline':False]
['text':'','line_number':465,'multiline':False]
['text':'  where M is a std::map or std::multimap:','line_number':466,'multiline':False]
['text':'','line_number':467,'multiline':False]
['text':'      6) template <typename Iter>','line_number':468,'multiline':False]
['text':'         void M::insert(Iter first, Iter last);','line_number':469,'multiline':False]
['text':' namespace stl','line_number':780,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':782,'multiline':False]
['text':'','line_number':783,'multiline':False]
['text':'  The lazy functions themselves.','line_number':784,'multiline':False]
['text':'','line_number':785,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':786,'multiline':False]
['text':' namespace boost::phoenix','line_number':826,'multiline':False]
['text':' BOOST_PHOENIX_STL_CONTAINERS_HPP','line_number':828,'multiline':False]
