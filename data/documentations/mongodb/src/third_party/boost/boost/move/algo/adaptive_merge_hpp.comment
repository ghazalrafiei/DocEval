['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' (C) Copyright Ion Gaztanaga 2015-2016.','line_number':3,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0.','line_number':4,'multiline':False]
['text':' (See accompanying file LICENSE_1_0.txt or copy at','line_number':5,'multiline':False]
['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':6,'multiline':False]
['text':'','line_number':7,'multiline':False]
['text':' See http://www.boost.org/libs/move for documentation.','line_number':8,'multiline':False]
['text':'','line_number':9,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////////////','line_number':10,'multiline':False]
['text':'/@cond','line_number':26,'multiline':False]
['text':'Outputs','line_number':60,'multiline':False]
['text':'Outputs','line_number':69,'multiline':False]
['text':'Outputs','line_number':92,'multiline':False]
['text':'l_block','line_number':108,'multiline':False]
['text':'use_internal_buf','line_number':109,'multiline':False]
['text':'This is the minimum number of keys to implement the ideal algorithm','line_number':133,'multiline':False]
['text':'This is the minimum number of keys to implement the ideal algorithm','line_number':148,'multiline':False]
['text':'This is the minimum number of keys to implement the ideal algorithm','line_number':164,'multiline':False]
['text':' Main explanation of the merge algorithm.','line_number':179,'multiline':False]
['text':'','line_number':180,'multiline':False]
['text':' csqrtlen = ceil(sqrt(len));','line_number':181,'multiline':False]
['text':'','line_number':182,'multiline':False]
['text':' * First, csqrtlen [to be used as buffer] + (len/csqrtlen - 1) [to be used as keys] => to_collect','line_number':183,'multiline':False]
['text':'   unique elements are extracted from elements to be sorted and placed in the beginning of the range.','line_number':184,'multiline':False]
['text':'','line_number':185,'multiline':False]
['text':' * Step "combine_blocks": the leading (len1-to_collect) elements plus trailing len2 elements','line_number':186,'multiline':False]
['text':'   are merged with a non-trivial ("smart") algorithm to form an ordered range trailing "len-to_collect" elements.','line_number':187,'multiline':False]
['text':'','line_number':188,'multiline':False]
['text':'   Explanation of the "combine_blocks" step:','line_number':189,'multiline':False]
['text':'','line_number':190,'multiline':False]
['text':'         * Trailing [first+to_collect, first+len1) elements are divided in groups of cqrtlen elements.','line_number':191,'multiline':False]
['text':'           Remaining elements that can't form a group are grouped in front of those elements.','line_number':192,'multiline':False]
['text':'         * Trailing [first+len1, first+len1+len2) elements are divided in groups of cqrtlen elements.','line_number':193,'multiline':False]
['text':'           Remaining elements that can't form a group are grouped in the back of those elements.','line_number':194,'multiline':False]
['text':'         * In parallel the following two steps are performed:','line_number':195,'multiline':False]
['text':'             *  Groups are selection-sorted by first or last element (depending whether they are going','line_number':196,'multiline':False]
['text':'                to be merged to left or right) and keys are reordered accordingly as an imitation-buffer.','line_number':197,'multiline':False]
['text':'             * Elements of each block pair are merged using the csqrtlen buffer taking into account','line_number':198,'multiline':False]
['text':'                if they belong to the first half or second half (marked by the key).','line_number':199,'multiline':False]
['text':'','line_number':200,'multiline':False]
['text':' * In the final merge step leading "to_collect" elements are merged with rotations','line_number':201,'multiline':False]
['text':'   with the rest of merged elements in the "combine_blocks" step.','line_number':202,'multiline':False]
['text':'','line_number':203,'multiline':False]
['text':' Corner cases:','line_number':204,'multiline':False]
['text':'','line_number':205,'multiline':False]
['text':' * If no "to_collect" elements can be extracted:','line_number':206,'multiline':False]
['text':'','line_number':207,'multiline':False]
['text':'    * If more than a minimum number of elements is extracted','line_number':208,'multiline':False]
['text':'      then reduces the number of elements used as buffer and keys in the','line_number':209,'multiline':False]
['text':'      and "combine_blocks" steps. If "combine_blocks" has no enough keys due to this reduction','line_number':210,'multiline':False]
['text':'      then uses a rotation based smart merge.','line_number':211,'multiline':False]
['text':'','line_number':212,'multiline':False]
['text':'    * If the minimum number of keys can't be extracted, a rotation-based merge is performed.','line_number':213,'multiline':False]
['text':'','line_number':214,'multiline':False]
['text':' * If auxiliary memory is more or equal than min(len1, len2), a buffered merge is performed.','line_number':215,'multiline':False]
['text':'','line_number':216,'multiline':False]
['text':' * If the len1 or len2 are less than 2*csqrtlen then a rotation-based merge is performed.','line_number':217,'multiline':False]
['text':'','line_number':218,'multiline':False]
['text':' * If auxiliary memory is more than csqrtlen+n_keys*sizeof(std::size_t),','line_number':219,'multiline':False]
['text':'   then no csqrtlen need to be extracted and "combine_blocks" will use integral','line_number':220,'multiline':False]
['text':'   keys to combine blocks.','line_number':221,'multiline':False]
['text':'Calculate ideal parameters and try to collect needed unique keys','line_number':239,'multiline':False]
['text':'One range is not big enough to extract keys and the internal buffer so a','line_number':242,'multiline':False]
['text':'rotation-based based merge will do just fine','line_number':243,'multiline':False]
['text':'Detail the number of keys and internal buffer. If xbuf has enough memory, no','line_number':249,'multiline':False]
['text':'internal buffer is needed so l_intbuf will remain 0.','line_number':250,'multiline':False]
['text':'Try to extract needed unique values from the first range','line_number':254,'multiline':False]
['text':'Not the minimum number of keys is not available on the first range, so fallback to rotations','line_number':258,'multiline':False]
['text':'If not enough keys but more than minimum, adjust the internal buffer and key count','line_number':265,'multiline':False]
['text':'If use_internal_buf is false, then then internal buffer will be zero and rotation-based combination will be used','line_number':271,'multiline':False]
['text':'Merge trailing elements using smart merges','line_number':276,'multiline':False]
['text':'Merge buffer and keys with the rest of the values','line_number':278,'multiline':False]
['text':'namespace detail_adaptive {','line_number':283,'multiline':False]
['text':'/@endcond','line_number':285,'multiline':False]
['text':'! <b>Effects</b>: Merges two consecutive sorted ranges [first, middle) and [middle, last)','line_number':287,'multiline':False]
['text':'!   into one sorted range [first, last) according to the given comparison function comp.','line_number':288,'multiline':False]
['text':'!   The algorithm is stable (if there are equivalent elements in the original two ranges,','line_number':289,'multiline':False]
['text':'!   the elements from the first range (preserving their original order) precede the elements','line_number':290,'multiline':False]
['text':'!   from the second range (preserving their original order).','line_number':291,'multiline':False]
['text':'!','line_number':292,'multiline':False]
['text':'! <b>Requires</b>:','line_number':293,'multiline':False]
['text':'!   - RandIt must meet the requirements of ValueSwappable and RandomAccessIterator.','line_number':294,'multiline':False]
['text':'!   - The type of dereferenced RandIt must meet the requirements of MoveAssignable and MoveConstructible.','line_number':295,'multiline':False]
['text':'!','line_number':296,'multiline':False]
['text':'! <b>Parameters</b>:','line_number':297,'multiline':False]
['text':'!   - first: the beginning of the first sorted range. ','line_number':298,'multiline':False]
['text':'!   - middle: the end of the first sorted range and the beginning of the second','line_number':299,'multiline':False]
['text':'!   - last: the end of the second sorted range','line_number':300,'multiline':False]
['text':'!   - comp: comparison function object which returns true if the first argument is is ordered before the second.','line_number':301,'multiline':False]
['text':'!   - uninitialized, uninitialized_len: raw storage starting on "uninitialized", able to hold "uninitialized_len"','line_number':302,'multiline':False]
['text':'!      elements of type iterator_traits<RandIt>::value_type. Maximum performance is achieved when uninitialized_len','line_number':303,'multiline':False]
['text':'!      is min(std::distance(first, middle), std::distance(middle, last)).','line_number':304,'multiline':False]
['text':'!','line_number':305,'multiline':False]
['text':'! <b>Throws</b>: If comp throws or the move constructor, move assignment or swap of the type','line_number':306,'multiline':False]
['text':'!   of dereferenced RandIt throws.','line_number':307,'multiline':False]
['text':'!','line_number':308,'multiline':False]
['text':'! <b>Complexity</b>: Always K x O(N) comparisons and move assignments/constructors/swaps.','line_number':309,'multiline':False]
['text':'!   Constant factor for comparisons and data movement is minimized when uninitialized_len','line_number':310,'multiline':False]
['text':'!   is min(std::distance(first, middle), std::distance(middle, last)).','line_number':311,'multiline':False]
['text':'!   Pretty good enough performance is achieved when uninitialized_len is','line_number':312,'multiline':False]
['text':'!   ceil(sqrt(std::distance(first, last)))*2.','line_number':313,'multiline':False]
['text':'!','line_number':314,'multiline':False]
['text':'! <b>Caution</b>: Experimental implementation, not production-ready.','line_number':315,'multiline':False]
['text':'Reduce ranges to merge if possible','line_number':328,'multiline':False]
['text':'namespace movelib {','line_number':354,'multiline':False]
['text':'namespace boost {','line_number':355,'multiline':False]
['text':'#define BOOST_MOVE_ADAPTIVE_MERGE_HPP','line_number':363,'multiline':False]
