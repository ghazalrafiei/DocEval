['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' (C) Copyright Ion Gaztanaga 2015-2016.','line_number':3,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0.','line_number':4,'multiline':False]
['text':' (See accompanying file LICENSE_1_0.txt or copy at','line_number':5,'multiline':False]
['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':6,'multiline':False]
['text':'','line_number':7,'multiline':False]
['text':' See http://www.boost.org/libs/move for documentation.','line_number':8,'multiline':False]
['text':'','line_number':9,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////////////','line_number':10,'multiline':False]
['text':'/@cond','line_number':28,'multiline':False]
['text':'Move buffer to the total combination right','line_number':37,'multiline':False]
['text':'Rotate does less moves but it seems slower due to cache issues','line_number':43,'multiline':False]
['text':'rotate_gcd(first-l_block, first+len-l_block, first+len);','line_number':44,'multiline':False]
['text':'Move buffer to the total combination right','line_number':54,'multiline':False]
['text':'Rotate does less moves but it seems slower due to cache issues','line_number':60,'multiline':False]
['text':'rotate_gcd(first-l_block, first+len-l_block, first+len);','line_number':61,'multiline':False]
['text':' build blocks of length 2*l_build_buf. l_build_buf is power of two','line_number':65,'multiline':False]
['text':' input: [0, l_build_buf) elements are buffer, rest unsorted elements','line_number':66,'multiline':False]
['text':' output: [0, l_build_buf) elements are buffer, blocks 2*l_build_buf and last subblock sorted','line_number':67,'multiline':False]
['text':'','line_number':68,'multiline':False]
['text':' First elements are merged from right to left until elements start','line_number':69,'multiline':False]
['text':' at first. All old elements [first, first + l_build_buf) are placed at the end','line_number':70,'multiline':False]
['text':' [first+len-l_build_buf, first+len). To achieve this:','line_number':71,'multiline':False]
['text':' - If we have external memory to merge, we save elements from the buffer','line_number':72,'multiline':False]
['text':'   so that a non-swapping merge is used. Buffer elements are restored','line_number':73,'multiline':False]
['text':'   at the end of the buffer from the external memory.','line_number':74,'multiline':False]
['text':'','line_number':75,'multiline':False]
['text':' - When the external memory is not available or it is insufficient','line_number':76,'multiline':False]
['text':'   for a merge operation, left swap merging is used.','line_number':77,'multiline':False]
['text':'','line_number':78,'multiline':False]
['text':' Once elements are merged left to right in blocks of l_build_buf, then a single left','line_number':79,'multiline':False]
['text':' to right merge step is performed to achieve merged blocks of size 2K.','line_number':80,'multiline':False]
['text':' If external memory is available, usual merge is used, swap merging otherwise.','line_number':81,'multiline':False]
['text':'','line_number':82,'multiline':False]
['text':' As a last step, if auxiliary memory is available in-place merge is performed.','line_number':83,'multiline':False]
['text':' until all is merged or auxiliary memory is not large enough.','line_number':84,'multiline':False]
['text':'Place the start pointer after the buffer','line_number':99,'multiline':False]
['text':'////////////////////////////////','line_number':103,'multiline':False]
['text':' Start of merge to left step','line_number':104,'multiline':False]
['text':'////////////////////////////////','line_number':105,'multiline':False]
['text':'If there is no enough buffer for the insertion sort step, just avoid the external buffer','line_number':109,'multiline':False]
['text':'Backup internal buffer values in external buffer so they can be overwritten','line_number':114,'multiline':False]
['text':'Now combine them using the buffer. Elements from buffer can be','line_number':118,'multiline':False]
['text':'overwritten since they've been saved to xbuf','line_number':119,'multiline':False]
['text':'Restore internal buffer from external buffer unless kbuf was l_build_buf,','line_number':123,'multiline':False]
['text':'in that case restoration will happen later','line_number':124,'multiline':False]
['text':'Now combine elements using the buffer. Elements from buffer can't be','line_number':134,'multiline':False]
['text':'overwritten since xbuf was not big enough, so merge swapping elements.','line_number':135,'multiline':False]
['text':'////////////////////////////////','line_number':141,'multiline':False]
['text':' Start of merge to right step','line_number':142,'multiline':False]
['text':'////////////////////////////////','line_number':143,'multiline':False]
['text':'If kbuf is l_build_buf then we can merge right without swapping','line_number':145,'multiline':False]
['text':'Saved data is still in xbuf','line_number':146,'multiline':False]
['text':'Restore internal buffer from external buffer if kbuf was l_build_buf.','line_number':149,'multiline':False]
['text':'as this operation was previously delayed.','line_number':150,'multiline':False]
['text':'2*l_build_buf or total already merged','line_number':157,'multiline':False]
['text':'Now merge blocks','line_number':191,'multiline':False]
['text':'Outputs','line_number':199,'multiline':False]
['text':'Outputs','line_number':229,'multiline':False]
['text':'Returns true if buffer is placed in ','line_number':242,'multiline':False]
['text':'[buffer+len-l_intbuf, buffer+len). Otherwise, buffer is','line_number':243,'multiline':False]
['text':'[buffer,buffer+l_intbuf)','line_number':244,'multiline':False]
['text':'Backup data to external buffer once if possible','line_number':261,'multiline':False]
['text':'If l_intbuf is non-zero, use that internal buffer.','line_number':274,'multiline':False]
['text':'    Implies l_block == l_intbuf && use_internal_buf == true','line_number':275,'multiline':False]
['text':'If l_intbuf is zero, see if half keys can be reused as a reduced emergency buffer,','line_number':276,'multiline':False]
['text':'    Implies l_block == n_keys/2 && use_internal_buf == true','line_number':277,'multiline':False]
['text':'Otherwise, just give up and and use all keys to merge using rotations (use_internal_buf = false)','line_number':278,'multiline':False]
['text':'Put the buffer just after l_total_combined','line_number':292,'multiline':False]
['text':'Combine to form l_merged*2 segments','line_number':307,'multiline':False]
['text':'Restore data from to external common buffer if used','line_number':340,'multiline':False]
['text':'BOOST_ASSERT(n_keys || xbuf.size() == l_intbuf);','line_number':362,'multiline':False]
['text':'Use stable sort as some buffer elements might not be unique (see non_unique_buf)','line_number':369,'multiline':False]
['text':'Use stable sort as some buffer elements might not be unique (see non_unique_buf)','line_number':376,'multiline':False]
['text':'Calculate ideal parameters and try to collect needed unique keys','line_number':402,'multiline':False]
['text':'Try to find a value near sqrt(len) that is 2^N*l_base where','line_number':405,'multiline':False]
['text':'l_base <= AdaptiveSortInsertionSortThreshold. This property is important','line_number':406,'multiline':False]
['text':'as build_blocks merges to the left iteratively duplicating the','line_number':407,'multiline':False]
['text':'merged size and all the buffer must be used just before the final','line_number':408,'multiline':False]
['text':'merge to right step. This guarantees "build_blocks" produces ','line_number':409,'multiline':False]
['text':'segments of size l_build_buf*2, maximizing the classic merge phase.','line_number':410,'multiline':False]
['text':'The internal buffer can be expanded if there is enough external memory','line_number':413,'multiline':False]
['text':'This is the minimum number of keys to implement the ideal algorithm','line_number':418,'multiline':False]
['text':'','line_number':419,'multiline':False]
['text':'l_intbuf is used as buffer plus the key count','line_number':420,'multiline':False]
['text':'Try to achieve a l_build_buf of length l_intbuf*2, so that we can merge with that','line_number':434,'multiline':False]
['text':'l_intbuf*2 buffer in "build_blocks" and use half of them as buffer and the other half','line_number':435,'multiline':False]
['text':'as keys in combine_all_blocks. In that case n_keys >= n_min_ideal_keys but by a small margin.','line_number':436,'multiline':False]
['text':'','line_number':437,'multiline':False]
['text':'If available memory is 2*sqrt(l), then only sqrt(l) unique keys are needed,','line_number':438,'multiline':False]
['text':'(to be used for keys in combine_all_blocks) as the whole l_build_buf','line_number':439,'multiline':False]
['text':'will be backuped in the buffer during build_blocks.','line_number':440,'multiline':False]
['text':'If available memory is 2*sqrt(l), then for "build_params" ','line_number':445,'multiline':False]
['text':'the situation is the same as if 2*l_intbuf were collected.','line_number':446,'multiline':False]
['text':'l_intbuf*2 elements found. Use all of them in the build phase ','line_number':452,'multiline':False]
['text':'If collected keys are not enough, try to fix n_keys and l_intbuf. If no fix','line_number':460,'multiline':False]
['text':'is possible (due to very low unique keys), then go to a slow sort based on rotations.','line_number':461,'multiline':False]
['text':'No combination possible with less that 4 keys','line_number':464,'multiline':False]
['text':' make it power or 2','line_number':469,'multiline':False]
['text':'AdaptiveSortInsertionSortThreshold is always power of two so the minimum is power of two','line_number':474,'multiline':False]
['text':' Main explanation of the sort algorithm.','line_number':485,'multiline':False]
['text':'','line_number':486,'multiline':False]
['text':' csqrtlen = ceil(sqrt(len));','line_number':487,'multiline':False]
['text':'','line_number':488,'multiline':False]
['text':' * First, 2*csqrtlen unique elements elements are extracted from elements to be','line_number':489,'multiline':False]
['text':'   sorted and placed in the beginning of the range.','line_number':490,'multiline':False]
['text':'','line_number':491,'multiline':False]
['text':' * Step "build_blocks": In this nearly-classic merge step, 2*csqrtlen unique elements','line_number':492,'multiline':False]
['text':'   will be used as auxiliary memory, so trailing len-2*csqrtlen elements are','line_number':493,'multiline':False]
['text':'   are grouped in blocks of sorted 4*csqrtlen elements. At the end of the step','line_number':494,'multiline':False]
['text':'   2*csqrtlen unique elements are again the leading elements of the whole range.','line_number':495,'multiline':False]
['text':'','line_number':496,'multiline':False]
['text':' * Step "combine_blocks": pairs of previously formed blocks are merged with a different','line_number':497,'multiline':False]
['text':'   ("smart") algorithm to form blocks of 8*csqrtlen elements. This step is slower than the','line_number':498,'multiline':False]
['text':'   "build_blocks" step and repeated iteratively (forming blocks of 16*csqrtlen, 32*csqrtlen','line_number':499,'multiline':False]
['text':'   elements, etc) of until all trailing (len-2*csqrtlen) elements are merged.','line_number':500,'multiline':False]
['text':'','line_number':501,'multiline':False]
['text':'   In "combine_blocks" len/csqrtlen elements used are as "keys" (markers) to','line_number':502,'multiline':False]
['text':'   know if elements belong to the first or second block to be merged and another ','line_number':503,'multiline':False]
['text':'   leading csqrtlen elements are used as buffer. Explanation of the "combine_blocks" step:','line_number':504,'multiline':False]
['text':'','line_number':505,'multiline':False]
['text':'   Iteratively until all trailing (len-2*csqrtlen) elements are merged:','line_number':506,'multiline':False]
['text':'      Iteratively for each pair of previously merged block:','line_number':507,'multiline':False]
['text':'         * Blocks are divided groups of csqrtlen elements and','line_number':508,'multiline':False]
['text':'           2*merged_block/csqrtlen keys are sorted to be used as markers','line_number':509,'multiline':False]
['text':'         * Groups are selection-sorted by first or last element (depending whether they are going','line_number':510,'multiline':False]
['text':'           to be merged to left or right) and keys are reordered accordingly as an imitation-buffer.','line_number':511,'multiline':False]
['text':'         * Elements of each block pair are merged using the csqrtlen buffer taking into account','line_number':512,'multiline':False]
['text':'           if they belong to the first half or second half (marked by the key).','line_number':513,'multiline':False]
['text':'','line_number':514,'multiline':False]
['text':' * In the final merge step leading elements (2*csqrtlen) are sorted and merged with','line_number':515,'multiline':False]
['text':'   rotations with the rest of sorted elements in the "combine_blocks" step.','line_number':516,'multiline':False]
['text':'','line_number':517,'multiline':False]
['text':' Corner cases:','line_number':518,'multiline':False]
['text':'','line_number':519,'multiline':False]
['text':' * If no 2*csqrtlen elements can be extracted:','line_number':520,'multiline':False]
['text':'','line_number':521,'multiline':False]
['text':'    * If csqrtlen+len/csqrtlen are extracted, then only csqrtlen elements are used','line_number':522,'multiline':False]
['text':'      as buffer in the "build_blocks" step forming blocks of 2*csqrtlen elements. This','line_number':523,'multiline':False]
['text':'      means that an additional "combine_blocks" step will be needed to merge all elements.','line_number':524,'multiline':False]
['text':'    ','line_number':525,'multiline':False]
['text':'    * If no csqrtlen+len/csqrtlen elements can be extracted, but still more than a minimum,','line_number':526,'multiline':False]
['text':'      then reduces the number of elements used as buffer and keys in the "build_blocks"','line_number':527,'multiline':False]
['text':'      and "combine_blocks" steps. If "combine_blocks" has no enough keys due to this reduction','line_number':528,'multiline':False]
['text':'      then uses a rotation based smart merge.','line_number':529,'multiline':False]
['text':'','line_number':530,'multiline':False]
['text':'    * If the minimum number of keys can't be extracted, a rotation-based sorting is performed.','line_number':531,'multiline':False]
['text':'','line_number':532,'multiline':False]
['text':' * If auxiliary memory is more or equal than ceil(len/2), half-copying mergesort is used.','line_number':533,'multiline':False]
['text':'','line_number':534,'multiline':False]
['text':' * If auxiliary memory is more than csqrtlen+n_keys*sizeof(std::size_t),','line_number':535,'multiline':False]
['text':'   then only csqrtlen elements need to be extracted and "combine_blocks" will use integral','line_number':536,'multiline':False]
['text':'   keys to combine blocks.','line_number':537,'multiline':False]
['text':'','line_number':538,'multiline':False]
['text':' * If auxiliary memory is available, the "build_blocks" will be extended to build bigger blocks','line_number':539,'multiline':False]
['text':'   using classic merge and "combine_blocks" will use bigger blocks when merging.','line_number':540,'multiline':False]
['text':'Small sorts go directly to insertion sort','line_number':551,'multiline':False]
['text':'Make sure it is at least four','line_number':559,'multiline':False]
['text':'Calculate and extract needed unique elements. If a minimum is not achieved','line_number':567,'multiline':False]
['text':'fallback to a slow stable sort','line_number':568,'multiline':False]
['text':'Otherwise, continue the adaptive_sort','line_number':574,'multiline':False]
['text':'l_build_buf is always power of two if l_intbuf is zero','line_number':577,'multiline':False]
['text':'Classic merge sort until internal buffer and xbuf are exhausted','line_number':580,'multiline':False]
['text':'Non-trivial merge','line_number':587,'multiline':False]
['text':'Sort keys and buffer and merge the whole sequence','line_number':591,'multiline':False]
['text':'namespace detail_adaptive {','line_number':597,'multiline':False]
['text':'/@endcond','line_number':599,'multiline':False]
['text':'! <b>Effects</b>: Sorts the elements in the range [first, last) in ascending order according','line_number':601,'multiline':False]
['text':'!   to comparison functor "comp". The sort is stable (order of equal elements','line_number':602,'multiline':False]
['text':'!   is guaranteed to be preserved). Performance is improved if additional raw storage is','line_number':603,'multiline':False]
['text':'!   provided.','line_number':604,'multiline':False]
['text':'!','line_number':605,'multiline':False]
['text':'! <b>Requires</b>:','line_number':606,'multiline':False]
['text':'!   - RandIt must meet the requirements of ValueSwappable and RandomAccessIterator.','line_number':607,'multiline':False]
['text':'!   - The type of dereferenced RandIt must meet the requirements of MoveAssignable and MoveConstructible.','line_number':608,'multiline':False]
['text':'!','line_number':609,'multiline':False]
['text':'! <b>Parameters</b>:','line_number':610,'multiline':False]
['text':'!   - first, last: the range of elements to sort','line_number':611,'multiline':False]
['text':'!   - comp: comparison function object which returns true if the first argument is is ordered before the second.','line_number':612,'multiline':False]
['text':'!   - uninitialized, uninitialized_len: raw storage starting on "uninitialized", able to hold "uninitialized_len"','line_number':613,'multiline':False]
['text':'!      elements of type iterator_traits<RandIt>::value_type. Maximum performance is achieved when uninitialized_len','line_number':614,'multiline':False]
['text':'!      is ceil(std::distance(first, last)/2).','line_number':615,'multiline':False]
['text':'!','line_number':616,'multiline':False]
['text':'! <b>Throws</b>: If comp throws or the move constructor, move assignment or swap of the type','line_number':617,'multiline':False]
['text':'!   of dereferenced RandIt throws.','line_number':618,'multiline':False]
['text':'!','line_number':619,'multiline':False]
['text':'! <b>Complexity</b>: Always K x O(Nxlog(N)) comparisons and move assignments/constructors/swaps.','line_number':620,'multiline':False]
['text':'!   Comparisons are close to minimum even with no additional memory. Constant factor for data movement is minimized','line_number':621,'multiline':False]
['text':'!   when uninitialized_len is ceil(std::distance(first, last)/2). Pretty good enough performance is achieved when','line_number':622,'multiline':False]
['text':'!   ceil(sqrt(std::distance(first, last)))*2.','line_number':623,'multiline':False]
['text':'!','line_number':624,'multiline':False]
['text':'! <b>Caution</b>: Experimental implementation, not production-ready.','line_number':625,'multiline':False]
['text':'namespace movelib {','line_number':645,'multiline':False]
['text':'namespace boost {','line_number':646,'multiline':False]
['text':'#define BOOST_MOVE_ADAPTIVE_SORT_HPP','line_number':654,'multiline':False]
