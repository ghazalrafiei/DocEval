['text':' boost random/detail/qrng_base.hpp header file
 *
 * Copyright Justinas Vygintas Daugmaudis 2010-2018
 * Distributed under the Boost Software License, Version 1.0. (See
 * accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 ','line_number':1,'multiline':True]
['text':'!\file','line_number':29,'multiline':False]
['text':'!Describes the quasi-random number generator base class template.','line_number':30,'multiline':False]
['text':' If the seed is a signed integer type, then we need to','line_number':37,'multiline':False]
['text':' check that the value is positive:','line_number':38,'multiline':False]
['text':' Guard against invalid dimensions before creating the lattice','line_number':65,'multiline':False]
['text':' default copy c-tor is fine','line_number':72,'multiline':False]
['text':' default assignment operator is fine','line_number':74,'multiline':False]
['text':'!Returns: The dimension of of the quasi-random domain.','line_number':76,'multiline':False]
['text':'!','line_number':77,'multiline':False]
['text':'!Throws: nothing.','line_number':78,'multiline':False]
['text':'!Returns: Returns a successive element of an s-dimensional','line_number':81,'multiline':False]
['text':'!(s = X::dimension()) vector at each invocation. When all elements are','line_number':82,'multiline':False]
['text':'!exhausted, X::operator() begins anew with the starting element of a','line_number':83,'multiline':False]
['text':'!subsequent s-dimensional vector.','line_number':84,'multiline':False]
['text':'!','line_number':85,'multiline':False]
['text':'!Throws: range_error.','line_number':86,'multiline':False]
['text':'!Fills a range with quasi-random values.','line_number':92,'multiline':False]
['text':'!Effects: Advances *this state as if z consecutive','line_number':99,'multiline':False]
['text':'!X::operator() invocations were executed.','line_number':100,'multiline':False]
['text':'!','line_number':101,'multiline':False]
['text':'!Throws: range_error.','line_number':102,'multiline':False]
['text':' Compiler knows how to optimize subsequent x / y and x % y','line_number':107,'multiline':False]
['text':' statements. In fact, gcc does this even at -O1, so don't','line_number':108,'multiline':False]
['text':' be tempted to "optimize" % via subtraction and multiplication.','line_number':109,'multiline':False]
['text':' Avoid overdiscarding by branchlessly correcting the triple','line_number':117,'multiline':False]
['text':' (D, S + 1, 0) to (D, S, D) (see equality operator)','line_number':118,'multiline':False]
['text':' Discards vec_n (with correction) consecutive s-dimensional vectors','line_number':121,'multiline':False]
['text':' disable unary minus operator applied to an unsigned type,','line_number':126,'multiline':False]
['text':' result still unsigned.','line_number':127,'multiline':False]
['text':' Sets up the proper position of the element-to-read','line_number':131,'multiline':False]
['text':' curr_elem = carry + corr*dimension_value','line_number':132,'multiline':False]
['text':'!Writes the textual representation of the generator to a @c std::ostream.','line_number':140,'multiline':False]
['text':'!Reads the textual representation of the generator from a @c std::istream.','line_number':147,'multiline':False]
['text':' initialize iff success!','line_number':153,'multiline':False]
['text':' Check seed sign before resizing the lattice and/or recomputing state','line_number':155,'multiline':False]
['text':' Fast-forward to the correct state','line_number':163,'multiline':False]
['text':'!Returns true if the two generators will produce identical sequences of outputs.','line_number':170,'multiline':False]
['text':' Note that two generators with different seq_counts and curr_elems can','line_number':175,'multiline':False]
['text':' produce the same sequence because the generator triple','line_number':176,'multiline':False]
['text':' (D, S, D) is equivalent to (D, S + 1, 0), where D is dimension, S -- seq_count,','line_number':177,'multiline':False]
['text':' and the last one is curr_elem.','line_number':178,'multiline':False]
['text':' |x.seq_count - y.seq_count| <= 1','line_number':181,'multiline':False]
['text':' Potential overflows don't matter here, since we've already ascertained','line_number':184,'multiline':False]
['text':' that sequence counts differ by no more than 1, so if they overflow, they','line_number':185,'multiline':False]
['text':' can overflow together.','line_number':186,'multiline':False]
['text':'!Returns true if the two generators will produce different sequences of outputs.','line_number':191,'multiline':False]
['text':' Getters','line_number':198,'multiline':False]
['text':' Setters','line_number':204,'multiline':False]
['text':' Load the result from the saved state.','line_number':217,'multiline':False]
['text':' Discards z consecutive s-dimensional vectors,','line_number':235,'multiline':False]
['text':' and preserves the position of the element-to-read','line_number':236,'multiline':False]
['text':' Don't allow seq_count + z overflows here','line_number':241,'multiline':False]
['text':' Member variables are so ordered with the intention','line_number':257,'multiline':False]
['text':' that the typical memory access pattern would be','line_number':258,'multiline':False]
['text':' incremental. Moreover, lattice is put before quasi_state','line_number':259,'multiline':False]
['text':' because we want to construct lattice first. Lattices','line_number':260,'multiline':False]
['text':' can do some kind of dimension sanity check (as in','line_number':261,'multiline':False]
['text':' dimension_assert below), and if that fails then we don't','line_number':262,'multiline':False]
['text':' need to do any more work.','line_number':263,'multiline':False]
['text':' namespace qrng_detail','line_number':284,'multiline':False]
['text':' namespace random','line_number':286,'multiline':False]
['text':' namespace boost','line_number':287,'multiline':False]
['text':' BOOST_RANDOM_DETAIL_QRNG_BASE_HPP','line_number':291,'multiline':False]
