['text':'
 * Distributed under the Boost Software License, Version 1.0.
 * (See accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 *
 * Copyright (c) 2009 Helge Bahmann
 * Copyright (c) 2012 Tim Blechmann
 * Copyright (c) 2014 Andrey Semashev
 ','line_number':1,'multiline':True]
['text':'!
 * \file   atomic/detail/core_arch_ops_gcc_x86.hpp
 *
 * This header contains implementation of the \c core_arch_operations template.
 ','line_number':10,'multiline':True]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':158,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':167,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':255,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':264,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':351,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':360,'multiline':False]
['text':' Note: In the 32-bit PIC code guarded with BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX below we have to avoid using memory','line_number':405,'multiline':False]
['text':' operand constraints because the compiler may choose to use ebx as the base register for that operand. At least, clang','line_number':406,'multiline':False]
['text':' is known to do that. For this reason we have to pre-compute a pointer to storage and pass it in edi. For the same reason','line_number':407,'multiline':False]
['text':' we cannot save ebx to the stack with a mov instruction, so we use esi as a scratch register and restore it afterwards.','line_number':408,'multiline':False]
['text':' Alternatively, we could push/pop the register to the stack, but exchanging the registers is faster.','line_number':409,'multiline':False]
['text':' The need to pass a pointer in edi is a bit wasteful because normally the memory operand would use a base pointer','line_number':410,'multiline':False]
['text':' with an offset (e.g. `this` + offset). But unfortunately, there seems to be no way around it.','line_number':411,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX)','line_number':478,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX)','line_number':490,'multiline':False]
['text':' Note that despite const qualification cmpxchg8b below may issue a store to the storage. The storage value','line_number':533,'multiline':False]
['text':' will not change, but this prevents the storage to reside in read-only memory.','line_number':534,'multiline':False]
['text':' We don't care for comparison result here; the previous value will be stored into value anyway.','line_number':540,'multiline':False]
['text':' Also we don't care for ebx and ecx values, they just have to be equal to eax and edx before cmpxchg8b.','line_number':541,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':553,'multiline':False]
['text':' We don't care for comparison result here; the previous value will be stored into value anyway.','line_number':555,'multiline':False]
['text':' Also we don't care for ebx and ecx values, they just have to be equal to eax and edx before cmpxchg8b.','line_number':556,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':567,'multiline':False]
['text':' Clang cannot allocate eax:edx register pairs but it has sync intrinsics','line_number':578,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':597,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':608,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX)','line_number':612,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':624,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':633,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX)','line_number':637,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':670,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':688,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX)','line_number':689,'multiline':False]
['text':' MinGW gcc up to 4.6 has problems with allocating registers in the asm blocks below','line_number':692,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':729,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':745,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_ASM_PRESERVE_EBX)','line_number':746,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':802,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':811,'multiline':False]
['text':' Note that despite const qualification cmpxchg16b below may issue a store to the storage. The storage value','line_number':888,'multiline':False]
['text':' will not change, but this prevents the storage to reside in read-only memory.','line_number':889,'multiline':False]
['text':' We don't care for comparison result here; the previous value will be stored into value anyway.','line_number':895,'multiline':False]
['text':' Also we don't care for rbx and rcx values, they just have to be equal to rax and rdx before cmpxchg16b.','line_number':896,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':911,'multiline':False]
['text':' We don't care for comparison result here; the previous value will be stored into value anyway.','line_number':915,'multiline':False]
['text':' Also we don't care for rbx and rcx values, they just have to be equal to rax and rdx before cmpxchg16b.','line_number':916,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':929,'multiline':False]
['text':' Clang cannot allocate rax:rdx register pairs but it has sync intrinsics','line_number':937,'multiline':False]
['text':' Some compilers can't allocate rax:rdx register pair either but also don't support 128-bit __sync_val_compare_and_swap','line_number':944,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':957,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':969,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_ASM_HAS_FLAG_OUTPUTS)','line_number':978,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':982,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':1010,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_NO_ASM_AX_DX_PAIRS)','line_number':1025,'multiline':False]
['text':' defined(BOOST_ATOMIC_DETAIL_X86_HAS_CMPXCHG16B)','line_number':1035,'multiline':False]
['text':' namespace detail','line_number':1037,'multiline':False]
['text':' namespace atomics','line_number':1038,'multiline':False]
['text':' namespace boost','line_number':1039,'multiline':False]
['text':' BOOST_ATOMIC_DETAIL_CORE_ARCH_OPS_GCC_X86_HPP_INCLUDED_','line_number':1043,'multiline':False]
