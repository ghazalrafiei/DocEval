['text':'','line_number':1,'multiline':False]
['text':' detail/impl/epoll_reactor.ipp','line_number':2,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':3,'multiline':False]
['text':'','line_number':4,'multiline':False]
['text':' Copyright (c) 2003-2022 Christopher M. Kohlhoff (chris at kohlhoff dot com)','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0. (See accompanying','line_number':7,'multiline':False]
['text':' file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]
['text':'','line_number':9,'multiline':False]
['text':' defined(_MSC_VER) && (_MSC_VER >= 1200)','line_number':16,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_TIMERFD)','line_number':31,'multiline':False]
['text':' Add the interrupter's descriptor to epoll.','line_number':50,'multiline':False]
['text':' Add the timer descriptor to epoll.','line_number':57,'multiline':False]
['text':' Add the interrupter's descriptor to epoll.','line_number':112,'multiline':False]
['text':' Add the timer descriptor to epoll.','line_number':119,'multiline':False]
['text':' Re-register all descriptors with epoll.','line_number':129,'multiline':False]
['text':' This file descriptor type is not supported by epoll. However, if it is','line_number':180,'multiline':False]
['text':' a regular file then operations on it will not block. We will allow','line_number':181,'multiline':False]
['text':' this descriptor to be used and fail later if an operation on it would','line_number':182,'multiline':False]
['text':' otherwise require a trip through the reactor.','line_number':183,'multiline':False]
['text':' The descriptor will be automatically removed from the epoll set when','line_number':388,'multiline':False]
['text':' it is closed.','line_number':389,'multiline':False]
['text':' Leave descriptor_data set so that it will be freed by the subsequent','line_number':419,'multiline':False]
['text':' call to cleanup_descriptor_data.','line_number':420,'multiline':False]
['text':' We are shutting down, so prevent cleanup_descriptor_data from freeing','line_number':424,'multiline':False]
['text':' the descriptor_data object and let the destructor free it instead.','line_number':425,'multiline':False]
['text':' Leave descriptor_data set so that it will be freed by the subsequent','line_number':456,'multiline':False]
['text':' call to cleanup_descriptor_data.','line_number':457,'multiline':False]
['text':' We are shutting down, so prevent cleanup_descriptor_data from freeing','line_number':461,'multiline':False]
['text':' the descriptor_data object and let the destructor free it instead.','line_number':462,'multiline':False]
['text':' This code relies on the fact that the scheduler queues the reactor task','line_number':479,'multiline':False]
['text':' behind all descriptor operations generated by this function. This means,','line_number':480,'multiline':False]
['text':' that by the time we reach this point, any previously returned descriptor','line_number':481,'multiline':False]
['text':' operations have already been dequeued. Therefore it is now safe for us to','line_number':482,'multiline':False]
['text':' reuse and return them for the scheduler to queue again.','line_number':483,'multiline':False]
['text':' Calculate timeout. Check the timer queues only if timerfd is not in use.','line_number':485,'multiline':False]
['text':' Block on the epoll descriptor.','line_number':499,'multiline':False]
['text':' Trace the waiting events.','line_number':504,'multiline':False]
['text':' Ignore.','line_number':510,'multiline':False]
['text':' Ignore.','line_number':515,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_TIMERFD)','line_number':517,'multiline':False]
['text':' defined(BOOST_ASIO_ENABLE_HANDLER_TRACKING)','line_number':531,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_TIMERFD)','line_number':535,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_TIMERFD)','line_number':537,'multiline':False]
['text':' Dispatch the waiting events.','line_number':539,'multiline':False]
['text':' No need to reset the interrupter since we're leaving the descriptor','line_number':545,'multiline':False]
['text':' in a ready-to-read state and relying on edge-triggered notifications','line_number':546,'multiline':False]
['text':' to make it so that we only get woken up when the descriptor's epoll','line_number':547,'multiline':False]
['text':' registration is updated.','line_number':548,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_TIMERFD)','line_number':553,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_TIMERFD)','line_number':555,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_TIMERFD)','line_number':562,'multiline':False]
['text':' The descriptor operation doesn't count as work in and of itself, so we','line_number':565,'multiline':False]
['text':' don't call work_started() here. This still allows the scheduler to','line_number':566,'multiline':False]
['text':' stop if the only remaining operations are descriptor operations.','line_number':567,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_TIMERFD)','line_number':594,'multiline':False]
['text':' defined(EPOLL_CLOEXEC)','line_number':610,'multiline':False]
['text':' defined(EPOLL_CLOEXEC)','line_number':613,'multiline':False]
['text':' defined(TFD_CLOEXEC)','line_number':637,'multiline':False]
['text':' defined(TFD_CLOEXEC)','line_number':640,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_TIMERFD)','line_number':650,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_TIMERFD)','line_number':652,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_TIMERFD)','line_number':691,'multiline':False]
['text':' By default we will wait no longer than 5 minutes. This will ensure that','line_number':697,'multiline':False]
['text':' any changes to the system clock are detected after no longer than this.','line_number':698,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_TIMERFD)','line_number':716,'multiline':False]
['text':' Post the remaining completed operations for invocation.','line_number':729,'multiline':False]
['text':' A user-initiated operation has completed, but there's no need to','line_number':733,'multiline':False]
['text':' explicitly call work_finished() here. Instead, we'll take advantage of','line_number':734,'multiline':False]
['text':' the fact that the scheduler will call work_finished() once we return.','line_number':735,'multiline':False]
['text':' No user-initiated operations have completed, so we need to compensate','line_number':739,'multiline':False]
['text':' for the work_finished() call that the scheduler will make once this','line_number':740,'multiline':False]
['text':' operation returns.','line_number':741,'multiline':False]
['text':' Exception operations must be processed first to ensure that any','line_number':763,'multiline':False]
['text':' out-of-band data is read before normal data.','line_number':764,'multiline':False]
['text':' The first operation will be returned for completion now. The others will','line_number':789,'multiline':False]
['text':' be posted for later by the io_cleanup object's destructor.','line_number':790,'multiline':False]
['text':' namespace detail','line_number':811,'multiline':False]
['text':' namespace asio','line_number':812,'multiline':False]
['text':' namespace boost','line_number':813,'multiline':False]
['text':' defined(BOOST_ASIO_HAS_EPOLL)','line_number':817,'multiline':False]
['text':' BOOST_ASIO_DETAIL_IMPL_EPOLL_REACTOR_IPP','line_number':819,'multiline':False]
