['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' (C) Copyright Ion Gaztanaga 2005-2012. Distributed under the Boost','line_number':3,'multiline':False]
['text':' Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]
['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':' See http://www.boost.org/libs/interprocess for documentation.','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////////////','line_number':9,'multiline':False]
['text':' interprocess','line_number':25,'multiline':False]
['text':' interprocess/detail','line_number':32,'multiline':False]
['text':' container','line_number':37,'multiline':False]
['text':' container/detail','line_number':39,'multiline':False]
['text':' move/detail','line_number':41,'multiline':False]
['text':'make_unsigned, alignment_of','line_number':42,'multiline':False]
['text':'make_unsigned, alignment_of','line_number':43,'multiline':False]
['text':' intrusive','line_number':44,'multiline':False]
['text':' other boost','line_number':47,'multiline':False]
['text':' std','line_number':50,'multiline':False]
['text':'#define BOOST_INTERPROCESS_RBTREE_BEST_FIT_ABI_V1_HPP','line_number':54,'multiline':False]
['text':'to maintain ABI compatible with the original version','line_number':55,'multiline':False]
['text':'ABI had to be updated to fix compatibility issues when','line_number':56,'multiline':False]
['text':'sharing shared memory between 32 adn 64 bit processes.','line_number':57,'multiline':False]
['text':'!\file','line_number':59,'multiline':False]
['text':'!Describes a best-fit algorithm based in an intrusive red-black tree used to allocate','line_number':60,'multiline':False]
['text':'!objects in shared memory. This class is intended as a base class for single segment','line_number':61,'multiline':False]
['text':'!and multi-segment implementations.','line_number':62,'multiline':False]
['text':'!This class implements an algorithm that stores the free nodes in a red-black tree','line_number':67,'multiline':False]
['text':'!to have logarithmic search/insert times.','line_number':68,'multiline':False]
['text':'Non-copyable','line_number':73,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':88,'multiline':False]
['text':'!Shared mutex family used for the rest of the Interprocess framework','line_number':91,'multiline':False]
['text':'!Pointer type to be used with the rest of the Interprocess framework','line_number':93,'multiline':False]
['text':'!This block's memory size (including block_ctrl','line_number':112,'multiline':False]
['text':'!header) in Alignment units','line_number':113,'multiline':False]
['text':'!Block control structure','line_number':120,'multiline':False]
['text':'!Shared mutex to protect memory allocate/deallocate','line_number':142,'multiline':False]
['text':'!This struct includes needed data and derives from','line_number':150,'multiline':False]
['text':'!mutex_type to allow EBO when using null mutex_type','line_number':151,'multiline':False]
['text':'!The extra size required by the segment','line_number':156,'multiline':False]
['text':'!Allocated bytes for internal checking','line_number':158,'multiline':False]
['text':'!The size of the memory segment','line_number':160,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':169,'multiline':False]
['text':'!Constructor. "size" is the total size of the managed memory segment,','line_number':171,'multiline':False]
['text':'!"extra_hdr_bytes" indicates the extra bytes beginning in the sizeof(rbtree_best_fit)','line_number':172,'multiline':False]
['text':'!offset that the allocator should not use at all.','line_number':173,'multiline':False]
['text':'!Destructor.','line_number':176,'multiline':False]
['text':'!Obtains the minimum size needed by the algorithm','line_number':179,'multiline':False]
['text':'Functions for single segment management','line_number':182,'multiline':False]
['text':'!Allocates bytes, returns 0 if there is not more memory','line_number':184,'multiline':False]
['text':'Experimental. Dont' use','line_number':189,'multiline':False]
['text':'!Multiple element allocation, same size','line_number':191,'multiline':False]
['text':'-----------------------','line_number':194,'multiline':False]
['text':'-----------------------','line_number':196,'multiline':False]
['text':'!Multiple element allocation, different size','line_number':200,'multiline':False]
['text':'-----------------------','line_number':203,'multiline':False]
['text':'-----------------------','line_number':205,'multiline':False]
['text':'!Multiple element allocation, different size','line_number':209,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':212,'multiline':False]
['text':'!Deallocates previously allocated bytes','line_number':214,'multiline':False]
['text':'!Returns the size of the memory segment','line_number':217,'multiline':False]
['text':'!Returns the number of free bytes of the segment','line_number':220,'multiline':False]
['text':'!Initializes to zero all the memory that's not in use.','line_number':223,'multiline':False]
['text':'!This function is normally used for security reasons.','line_number':224,'multiline':False]
['text':'!Increases managed memory in','line_number':227,'multiline':False]
['text':'!extra_size bytes more','line_number':228,'multiline':False]
['text':'!Decreases managed memory as much as possible','line_number':231,'multiline':False]
['text':'!Returns true if all allocated memory has been deallocated','line_number':234,'multiline':False]
['text':'!Makes an internal sanity check','line_number':237,'multiline':False]
['text':'!and returns true if success','line_number':238,'multiline':False]
['text':'!Returns the size of the buffer previously allocated pointed by ptr','line_number':249,'multiline':False]
['text':'!Allocates aligned bytes, returns 0 if there is not more memory.','line_number':252,'multiline':False]
['text':'!Alignment must be power of 2','line_number':253,'multiline':False]
['text':'!Real allocation algorithm with min allocation option','line_number':268,'multiline':False]
['text':'!Obtains the block control structure of the user buffer','line_number':273,'multiline':False]
['text':'!Obtains the pointer returned to the user from the block control','line_number':276,'multiline':False]
['text':'!Returns the number of total units that a user buffer','line_number':279,'multiline':False]
['text':'!of "userbytes" bytes really occupies (including header)','line_number':280,'multiline':False]
['text':'!Real expand function implementation','line_number':283,'multiline':False]
['text':'!Real expand to both sides implementation','line_number':286,'multiline':False]
['text':'!Returns true if the previous block is allocated','line_number':294,'multiline':False]
['text':'!Get a pointer of the "end" block from the first block of the segment','line_number':297,'multiline':False]
['text':'!Get a pointer of the "first" block from the end block of the segment','line_number':300,'multiline':False]
['text':'!Get poitner of the previous block (previous block must be free)','line_number':303,'multiline':False]
['text':'!Get the size in the tail of the previous block','line_number':306,'multiline':False]
['text':'!Check if this block is free (not allocated)','line_number':309,'multiline':False]
['text':'!Marks the block as allocated','line_number':312,'multiline':False]
['text':'!Marks the block as allocated','line_number':315,'multiline':False]
['text':'!Marks the block as allocated','line_number':319,'multiline':False]
['text':'!Checks if block has enough memory and splits/unlinks the block','line_number':322,'multiline':False]
['text':'!returning the address to the users','line_number':323,'multiline':False]
['text':'!Real deallocation algorithm','line_number':327,'multiline':False]
['text':'!Makes a new memory portion available for allocation','line_number':330,'multiline':False]
['text':'Due to embedded bits in size, Alignment must be at least 4','line_number':342,'multiline':False]
['text':'Due to rbtree size optimizations, Alignment must have at least pointer alignment','line_number':344,'multiline':False]
['text':'Make sure the maximum alignment is power of two','line_number':356,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':358,'multiline':False]
['text':'Check alignment','line_number':383,'multiline':False]
['text':'Check size','line_number':385,'multiline':False]
['text':'Initialize the first big block and the "end" node','line_number':388,'multiline':False]
['text':'The "end" node is just a node of size 0 with the "end" bit set','line_number':393,'multiline':False]
['text':'This will overwrite the prev part of the "end" node','line_number':397,'multiline':False]
['text':'Some check to validate the algorithm, since it makes some assumptions','line_number':414,'multiline':False]
['text':'to optimize the space wasted in bookkeeping:','line_number':415,'multiline':False]
['text':'Check that the sizes of the header are placed before the rbtree','line_number':417,'multiline':False]
['text':'Insert it in the intrusive containers','line_number':420,'multiline':False]
['text':'Initialize the header','line_number':449,'multiline':False]
['text':'Now write calculate the offset of the first big block that will','line_number':454,'multiline':False]
['text':'cover the whole segment','line_number':455,'multiline':False]
['text':'There is a memory leak!','line_number':464,'multiline':False]
['text':'   BOOST_ASSERT(m_header.m_allocated == 0);','line_number':465,'multiline':False]
['text':'   BOOST_ASSERT(m_header.m_root.m_next->m_next == block_ctrl_ptr(&m_header.m_root));','line_number':466,'multiline':False]
['text':'Get the address of the first block','line_number':472,'multiline':False]
['text':'Update managed buffer's size','line_number':478,'multiline':False]
['text':'We need at least MinBlockUnits blocks to create a new block','line_number':481,'multiline':False]
['text':'Now create a new block between the old end and the new end','line_number':486,'multiline':False]
['text':'the last and first block are special:','line_number':491,'multiline':False]
['text':'new_end_block->m_size & first_block->m_prev_size store the absolute value','line_number':492,'multiline':False]
['text':'between them','line_number':493,'multiline':False]
['text':'The old end block is the new block','line_number':506,'multiline':False]
['text':'Now deallocate the newly created block','line_number':516,'multiline':False]
['text':'Get the address of the first block','line_number':523,'multiline':False]
['text':'block_ctrl *old_end_block = priv_end_block(first_block);','line_number':527,'multiline':False]
['text':'Check if no memory is allocated between the first and last block','line_number':534,'multiline':False]
['text':'If so check if we can allocate memory','line_number':536,'multiline':False]
['text':'If not, return, we can't shrink','line_number':540,'multiline':False]
['text':'If we can, mark the position just after the new allocation as the new end','line_number':543,'multiline':False]
['text':'If memory is allocated, check if the last block is allocated','line_number':553,'multiline':False]
['text':'If not, mark last block after the free block','line_number':556,'multiline':False]
['text':'Erase block from the free tree, since we will erase it','line_number':562,'multiline':False]
['text':'Write new end block attributes','line_number':571,'multiline':False]
['text':'Update managed buffer's size','line_number':587,'multiline':False]
['text':'-----------------------','line_number':621,'multiline':False]
['text':'-----------------------','line_number':623,'multiline':False]
['text':'-----------------------','line_number':638,'multiline':False]
['text':'-----------------------','line_number':640,'multiline':False]
['text':'Iterate through all blocks obtaining their size','line_number':645,'multiline':False]
['text':'Check allocated bytes are less than size','line_number':653,'multiline':False]
['text':'Check free bytes are less than size','line_number':661,'multiline':False]
['text':'-----------------------','line_number':672,'multiline':False]
['text':'-----------------------','line_number':674,'multiline':False]
['text':'-----------------------','line_number':684,'multiline':False]
['text':'-----------------------','line_number':686,'multiline':False]
['text':'-----------------------','line_number':742,'multiline':False]
['text':'-----------------------','line_number':744,'multiline':False]
['text':'We need no synchronization since this block's size is not going','line_number':756,'multiline':False]
['text':'to be modified by anyone else','line_number':757,'multiline':False]
['text':'Obtain the real size of the block','line_number':758,'multiline':False]
['text':'-----------------------','line_number':765,'multiline':False]
['text':'-----------------------','line_number':767,'multiline':False]
['text':'Iterate through all blocks obtaining their size','line_number':770,'multiline':False]
['text':'Just clear user the memory part reserved for the user','line_number':772,'multiline':False]
['text':'This surprisingly is optimized out by Visual C++ 7.1 in release mode!','line_number':779,'multiline':False]
['text':'std::memset( reinterpret_cast<char*>(&*ib) + BlockCtrlBytes','line_number':780,'multiline':False]
['text':'           , 0','line_number':781,'multiline':False]
['text':'           , ib->m_size*Alignment - BlockCtrlBytes);','line_number':782,'multiline':False]
['text':'Obtain the real size of the block','line_number':814,'multiline':False]
['text':'Sanity check','line_number':817,'multiline':False]
['text':'If the previous block is not free, there is nothing to do','line_number':822,'multiline':False]
['text':'Some sanity checks','line_number':830,'multiline':False]
['text':'Check if previous block has enough size','line_number':844,'multiline':False]
['text':'Now take all next space. This will succeed','line_number':846,'multiline':False]
['text':'We need a minimum size to split the previous one','line_number':854,'multiline':False]
['text':'Free old previous buffer','line_number':859,'multiline':False]
['text':'Update the old previous block in the free blocks tree','line_number':870,'multiline':False]
['text':'If the new size fulfills tree invariants do nothing,','line_number':871,'multiline':False]
['text':'otherwise erase() + insert()','line_number':872,'multiline':False]
['text':'Check alignment','line_number':886,'multiline':False]
['text':'If the backwards expansion has remaining bytes in the','line_number':889,'multiline':False]
['text':'first bytes, fill them with a pattern','line_number':890,'multiline':False]
['text':'Check if there is no place to create a new block and','line_number':897,'multiline':False]
['text':'the whole new block is multiple of the backwards expansion multiple','line_number':898,'multiline':False]
['text':'Erase old previous block, since we will change it','line_number':901,'multiline':False]
['text':'Just merge the whole previous block','line_number':904,'multiline':False]
['text':'prev_block->m_size*Alignment is multiple of lcm (and backwards_multiple)','line_number':905,'multiline':False]
['text':'Now update sizes','line_number':909,'multiline':False]
['text':'If the backwards expansion has remaining bytes in the','line_number':914,'multiline':False]
['text':'first bytes, fill them with a pattern','line_number':915,'multiline':False]
['text':'Alignment issues','line_number':922,'multiline':False]
['text':'-----------------------','line_number':933,'multiline':False]
['text':'-----------------------','line_number':935,'multiline':False]
['text':'Number of units to request (including block_ctrl header)','line_number':960,'multiline':False]
['text':'Number of units to request (including block_ctrl header)','line_number':963,'multiline':False]
['text':'Expand in place','line_number':966,'multiline':False]
['text':'Now try to expand both sides with min size','line_number':992,'multiline':False]
['text':'Obtain the real size of the block','line_number':1033,'multiline':False]
['text':'The block must be marked as allocated and the sizes must be equal','line_number':1037,'multiline':False]
['text':'Put this to a safe value','line_number':1040,'multiline':False]
['text':'Now translate it to Alignment units','line_number':1045,'multiline':False]
['text':'Some parameter checks','line_number':1049,'multiline':False]
['text':'Is "block" + "next_block" big enough?','line_number':1059,'multiline':False]
['text':'Now get the expansion size','line_number':1062,'multiline':False]
['text':'Now get the maximum size the user can allocate','line_number':1070,'multiline':False]
['text':'These are total units of the merged block (supposing the next block can be split)','line_number':1074,'multiline':False]
['text':'Check if we can split the next one in two parts','line_number':1077,'multiline':False]
['text':'This block is bigger than needed, split it in','line_number':1079,'multiline':False]
['text':'two blocks, the first one will be merged and','line_number':1080,'multiline':False]
['text':'the second's size will be the remaining space','line_number':1081,'multiline':False]
['text':'Check if we we need to update the old next block in the free blocks tree','line_number':1085,'multiline':False]
['text':'If the new size fulfills tree invariants, we just need to replace the node','line_number':1086,'multiline':False]
['text':'(the block start has been displaced), otherwise erase() + insert().','line_number':1087,'multiline':False]
['text':'','line_number':1088,'multiline':False]
['text':'This fixup must be done in two parts, because the new next block might','line_number':1089,'multiline':False]
['text':'overwrite the tree hook of the old next block. So we first erase the','line_number':1090,'multiline':False]
['text':'old if needed and we'll insert the new one after creating the new next','line_number':1091,'multiline':False]
['text':'This is the remaining block','line_number':1095,'multiline':False]
['text':'Write the new length','line_number':1104,'multiline':False]
['text':'There is no free space to create a new node: just merge both blocks','line_number':1109,'multiline':False]
['text':'Now we have to update the data in the tree','line_number':1111,'multiline':False]
['text':'Write the new length','line_number':1114,'multiline':False]
['text':'The first block's logic is different from the rest of blocks: stores in m_prev_size the absolute','line_number':1141,'multiline':False]
['text':'distance with the end block','line_number':1142,'multiline':False]
['text':'The first block's logic is different from the rest of blocks: stores in m_prev_size the absolute','line_number':1158,'multiline':False]
['text':'distance with the end block','line_number':1159,'multiline':False]
['text':'This block is bigger than needed, split it in','line_number':1247,'multiline':False]
['text':'two blocks, the first's size will be "units" and','line_number':1248,'multiline':False]
['text':'the second's size "block->m_size-units"','line_number':1249,'multiline':False]
['text':'This is the remaining block','line_number':1254,'multiline':False]
['text':'Now we have to update the data in the tree.','line_number':1262,'multiline':False]
['text':'Use the position of the erased one as a hint','line_number':1263,'multiline':False]
['text':'We need block_ctrl for deallocation stuff, so','line_number':1273,'multiline':False]
['text':'return memory user can overwrite','line_number':1274,'multiline':False]
['text':'Mark the block as allocated','line_number':1278,'multiline':False]
['text':'Clear the memory occupied by the tree hook, since this won't be','line_number':1281,'multiline':False]
['text':'cleared with zero_free_memory','line_number':1282,'multiline':False]
['text':'Just clear the memory part reserved for the user','line_number':1284,'multiline':False]
['text':'volatile char *ptr =','line_number':1286,'multiline':False]
['text':'-----------------------','line_number':1298,'multiline':False]
['text':'-----------------------','line_number':1300,'multiline':False]
['text':'The blocks must be marked as allocated and the sizes must be equal','line_number':1311,'multiline':False]
['text':'Check if alignment and block size are right','line_number':1314,'multiline':False]
['text':'Update used memory count','line_number':1320,'multiline':False]
['text':'The block to insert in the tree','line_number':1323,'multiline':False]
['text':'Get the next block','line_number':1326,'multiline':False]
['text':'Merge logic. First just update block sizes, then fix free blocks tree','line_number':1331,'multiline':False]
['text':'Merge if the previous is free','line_number':1333,'multiline':False]
['text':'Get the previous block','line_number':1335,'multiline':False]
['text':'Merge if the next is free','line_number':1341,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':1353,'multiline':False]
['text':'namespace interprocess {','line_number':1355,'multiline':False]
['text':'namespace boost {','line_number':1356,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_MEM_ALGO_RBTREE_BEST_FIT_HPP','line_number':1360,'multiline':False]
