['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' (C) Copyright Ion Gaztanaga 2005-2012. Distributed under the Boost','line_number':3,'multiline':False]
['text':' Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]
['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':' See http://www.boost.org/libs/interprocess for documentation.','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////////////','line_number':9,'multiline':False]
['text':'','line_number':10,'multiline':False]
['text':' This interface is inspired by Howard Hinnant's lock proposal.','line_number':11,'multiline':False]
['text':' http://home.twcny.rr.com/hinnant/cpp_extensions/threads_move.html','line_number':12,'multiline':False]
['text':'','line_number':13,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////////////','line_number':14,'multiline':False]
['text':'!\file','line_number':37,'multiline':False]
['text':'!Describes the scoped_lock class.','line_number':38,'multiline':False]
['text':'!scoped_lock is meant to carry out the tasks for locking, unlocking, try-locking','line_number':44,'multiline':False]
['text':'!and timed-locking (recursive or not) for the Mutex. The Mutex need not supply all','line_number':45,'multiline':False]
['text':'!of this functionality. If the client of scoped_lock<Mutex> does not use','line_number':46,'multiline':False]
['text':'!functionality which the Mutex does not supply, no harm is done. Mutex ownership','line_number':47,'multiline':False]
['text':'!transfer is supported through the syntax of move semantics. Ownership transfer','line_number':48,'multiline':False]
['text':'!is allowed both by construction and assignment. The scoped_lock does not support','line_number':49,'multiline':False]
['text':'!copy semantics. A compile time error results if copy construction or copy','line_number':50,'multiline':False]
['text':'!assignment is attempted. Mutex ownership can also be moved from an','line_number':51,'multiline':False]
['text':'!upgradable_lock and sharable_lock via constructor. In this role, scoped_lock','line_number':52,'multiline':False]
['text':'!shares the same functionality as a write_lock.','line_number':53,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':62,'multiline':False]
['text':'!Effects: Default constructs a scoped_lock.','line_number':67,'multiline':False]
['text':'!Postconditions: owns() == false and mutex() == 0.','line_number':68,'multiline':False]
['text':'!Effects: m.lock().','line_number':73,'multiline':False]
['text':'!Postconditions: owns() == true and mutex() == &m.','line_number':74,'multiline':False]
['text':'!Notes: The constructor will take ownership of the mutex. If another thread','line_number':75,'multiline':False]
['text':'!   already owns the mutex, this thread will block until the mutex is released.','line_number':76,'multiline':False]
['text':'!   Whether or not this constructor handles recursive locking depends upon the mutex.','line_number':77,'multiline':False]
['text':'!Postconditions: owns() == false, and mutex() == &m.','line_number':82,'multiline':False]
['text':'!Notes: The constructor will not take ownership of the mutex. There is no effect','line_number':83,'multiline':False]
['text':'!   required on the referenced mutex.','line_number':84,'multiline':False]
['text':'!Postconditions: owns() == true, and mutex() == &m.','line_number':89,'multiline':False]
['text':'!Notes: The constructor will suppose that the mutex is already locked. There','line_number':90,'multiline':False]
['text':'!   is no effect required on the referenced mutex.','line_number':91,'multiline':False]
['text':'!Effects: m.try_lock().','line_number':96,'multiline':False]
['text':'!Postconditions: mutex() == &m. owns() == the return value of the','line_number':97,'multiline':False]
['text':'!   m.try_lock() executed within the constructor.','line_number':98,'multiline':False]
['text':'!Notes: The constructor will take ownership of the mutex if it can do','line_number':99,'multiline':False]
['text':'!   so without waiting. Whether or not this constructor handles recursive','line_number':100,'multiline':False]
['text':'!   locking depends upon the mutex. If the mutex_type does not support try_lock,','line_number':101,'multiline':False]
['text':'!   this constructor will fail at compile time if instantiated, but otherwise','line_number':102,'multiline':False]
['text':'!   have no effect.','line_number':103,'multiline':False]
['text':'!Effects: m.timed_lock(abs_time).','line_number':108,'multiline':False]
['text':'!Postconditions: mutex() == &m. owns() == the return value of the','line_number':109,'multiline':False]
['text':'!   m.timed_lock(abs_time) executed within the constructor.','line_number':110,'multiline':False]
['text':'!Notes: The constructor will take ownership of the mutex if it can do','line_number':111,'multiline':False]
['text':'!   it until abs_time is reached. Whether or not this constructor','line_number':112,'multiline':False]
['text':'!   handles recursive locking depends upon the mutex. If the mutex_type','line_number':113,'multiline':False]
['text':'!   does not support try_lock, this constructor will fail at compile','line_number':114,'multiline':False]
['text':'!   time if instantiated, but otherwise have no effect.','line_number':115,'multiline':False]
['text':'!Postconditions: mutex() == the value scop.mutex() had before the','line_number':121,'multiline':False]
['text':'!   constructor executes. s1.mutex() == 0. owns() == the value of','line_number':122,'multiline':False]
['text':'!   scop.owns() before the constructor executes. scop.owns().','line_number':123,'multiline':False]
['text':'!Notes: If the scop scoped_lock owns the mutex, ownership is moved','line_number':124,'multiline':False]
['text':'!   to thisscoped_lock with no blocking. If the scop scoped_lock does not','line_number':125,'multiline':False]
['text':'!   own the mutex, then neither will this scoped_lock. Only a moved','line_number':126,'multiline':False]
['text':'!   scoped_lock's will match this signature. An non-moved scoped_lock','line_number':127,'multiline':False]
['text':'!   can be moved with the expression: "boost::move(lock);". This','line_number':128,'multiline':False]
['text':'!   constructor does not alter the state of the mutex, only potentially','line_number':129,'multiline':False]
['text':'!   who owns it.','line_number':130,'multiline':False]
['text':'!Effects: If upgr.owns() then calls unlock_upgradable_and_lock() on the','line_number':135,'multiline':False]
['text':'!   referenced mutex. upgr.release() is called.','line_number':136,'multiline':False]
['text':'!Postconditions: mutex() == the value upgr.mutex() had before the construction.','line_number':137,'multiline':False]
['text':'!   upgr.mutex() == 0. owns() == upgr.owns() before the construction.','line_number':138,'multiline':False]
['text':'!   upgr.owns() == false after the construction.','line_number':139,'multiline':False]
['text':'!Notes: If upgr is locked, this constructor will lock this scoped_lock while','line_number':140,'multiline':False]
['text':'!   unlocking upgr. If upgr is unlocked, then this scoped_lock will be','line_number':141,'multiline':False]
['text':'!   unlocked as well. Only a moved upgradable_lock's will match this','line_number':142,'multiline':False]
['text':'!   signature. An non-moved upgradable_lock can be moved with','line_number':143,'multiline':False]
['text':'!   the expression: "boost::move(lock);" This constructor may block if','line_number':144,'multiline':False]
['text':'!   other threads hold a sharable_lock on this mutex (sharable_lock's can','line_number':145,'multiline':False]
['text':'!   share ownership with an upgradable_lock).','line_number':146,'multiline':False]
['text':'!Effects: If upgr.owns() then calls try_unlock_upgradable_and_lock() on the','line_number':160,'multiline':False]
['text':'!referenced mutex:','line_number':161,'multiline':False]
['text':'!   a)if try_unlock_upgradable_and_lock() returns true then mutex() obtains','line_number':162,'multiline':False]
['text':'!      the value from upgr.release() and owns() is set to true.','line_number':163,'multiline':False]
['text':'!   b)if try_unlock_upgradable_and_lock() returns false then upgr is','line_number':164,'multiline':False]
['text':'!      unaffected and this scoped_lock construction as the same effects as','line_number':165,'multiline':False]
['text':'!      a default construction.','line_number':166,'multiline':False]
['text':'!   c)Else upgr.owns() is false. mutex() obtains the value from upgr.release()','line_number':167,'multiline':False]
['text':'!      and owns() is set to false','line_number':168,'multiline':False]
['text':'!Notes: This construction will not block. It will try to obtain mutex','line_number':169,'multiline':False]
['text':'!   ownership from upgr immediately, while changing the lock type from a','line_number':170,'multiline':False]
['text':'!   "read lock" to a "write lock". If the "read lock" isn't held in the','line_number':171,'multiline':False]
['text':'!   first place, the mutex merely changes type to an unlocked "write lock".','line_number':172,'multiline':False]
['text':'!   If the "read lock" is held, then mutex transfer occurs only if it can','line_number':173,'multiline':False]
['text':'!   do so in a non-blocking manner.','line_number':174,'multiline':False]
['text':'!Effects: If upgr.owns() then calls timed_unlock_upgradable_and_lock(abs_time)','line_number':191,'multiline':False]
['text':'!   on the referenced mutex:','line_number':192,'multiline':False]
['text':'!   a)if timed_unlock_upgradable_and_lock(abs_time) returns true then mutex()','line_number':193,'multiline':False]
['text':'!      obtains the value from upgr.release() and owns() is set to true.','line_number':194,'multiline':False]
['text':'!   b)if timed_unlock_upgradable_and_lock(abs_time) returns false then upgr','line_number':195,'multiline':False]
['text':'!      is unaffected and this scoped_lock construction as the same effects','line_number':196,'multiline':False]
['text':'!      as a default construction.','line_number':197,'multiline':False]
['text':'!   c)Else upgr.owns() is false. mutex() obtains the value from upgr.release()','line_number':198,'multiline':False]
['text':'!      and owns() is set to false','line_number':199,'multiline':False]
['text':'!Notes: This construction will not block. It will try to obtain mutex ownership','line_number':200,'multiline':False]
['text':'!   from upgr immediately, while changing the lock type from a "read lock" to a','line_number':201,'multiline':False]
['text':'!   "write lock". If the "read lock" isn't held in the first place, the mutex','line_number':202,'multiline':False]
['text':'!   merely changes type to an unlocked "write lock". If the "read lock" is held,','line_number':203,'multiline':False]
['text':'!   then mutex transfer occurs only if it can do so in a non-blocking manner.','line_number':204,'multiline':False]
['text':'!Effects: If shar.owns() then calls try_unlock_sharable_and_lock() on the','line_number':221,'multiline':False]
['text':'!referenced mutex.','line_number':222,'multiline':False]
['text':'!   a)if try_unlock_sharable_and_lock() returns true then mutex() obtains','line_number':223,'multiline':False]
['text':'!      the value from shar.release() and owns() is set to true.','line_number':224,'multiline':False]
['text':'!   b)if try_unlock_sharable_and_lock() returns false then shar is','line_number':225,'multiline':False]
['text':'!      unaffected and this scoped_lock construction has the same','line_number':226,'multiline':False]
['text':'!      effects as a default construction.','line_number':227,'multiline':False]
['text':'!   c)Else shar.owns() is false. mutex() obtains the value from','line_number':228,'multiline':False]
['text':'!      shar.release() and owns() is set to false','line_number':229,'multiline':False]
['text':'!Notes: This construction will not block. It will try to obtain mutex','line_number':230,'multiline':False]
['text':'!   ownership from shar immediately, while changing the lock type from a','line_number':231,'multiline':False]
['text':'!   "read lock" to a "write lock". If the "read lock" isn't held in the','line_number':232,'multiline':False]
['text':'!   first place, the mutex merely changes type to an unlocked "write lock".','line_number':233,'multiline':False]
['text':'!   If the "read lock" is held, then mutex transfer occurs only if it can','line_number':234,'multiline':False]
['text':'!   do so in a non-blocking manner.','line_number':235,'multiline':False]
['text':'!Effects: if (owns()) mp_mutex->unlock().','line_number':252,'multiline':False]
['text':'!Notes: The destructor behavior ensures that the mutex lock is not leaked.*/','line_number':253,'multiline':False]
['text':'!Effects: If owns() before the call, then unlock() is called on mutex().','line_number':260,'multiline':False]
['text':'!   *this gets the state of scop and scop gets set to a default constructed state.','line_number':261,'multiline':False]
['text':'!Notes: With a recursive mutex it is possible that both this and scop own','line_number':262,'multiline':False]
['text':'!   the same mutex before the assignment. In this case, this will own the','line_number':263,'multiline':False]
['text':'!   mutex after the assignment (and scop will not), but the mutex's lock','line_number':264,'multiline':False]
['text':'!   count will be decremented by one.','line_number':265,'multiline':False]
['text':'!Effects: If mutex() == 0 or if already locked, throws a lock_exception()','line_number':275,'multiline':False]
['text':'!   exception. Calls lock() on the referenced mutex.','line_number':276,'multiline':False]
['text':'!Postconditions: owns() == true.','line_number':277,'multiline':False]
['text':'!Notes: The scoped_lock changes from a state of not owning the mutex, to','line_number':278,'multiline':False]
['text':'!   owning the mutex, blocking if necessary.','line_number':279,'multiline':False]
['text':'!Effects: If mutex() == 0 or if already locked, throws a lock_exception()','line_number':288,'multiline':False]
['text':'!   exception. Calls try_lock() on the referenced mutex.','line_number':289,'multiline':False]
['text':'!Postconditions: owns() == the value returned from mutex()->try_lock().','line_number':290,'multiline':False]
['text':'!Notes: The scoped_lock changes from a state of not owning the mutex, to','line_number':291,'multiline':False]
['text':'!   owning the mutex, but only if blocking was not required. If the','line_number':292,'multiline':False]
['text':'!   mutex_type does not support try_lock(), this function will fail at','line_number':293,'multiline':False]
['text':'!   compile time if instantiated, but otherwise have no effect.*/','line_number':294,'multiline':False]
['text':'!Effects: If mutex() == 0 or if already locked, throws a lock_exception()','line_number':303,'multiline':False]
['text':'!   exception. Calls timed_lock(abs_time) on the referenced mutex.','line_number':304,'multiline':False]
['text':'!Postconditions: owns() == the value returned from mutex()-> timed_lock(abs_time).','line_number':305,'multiline':False]
['text':'!Notes: The scoped_lock changes from a state of not owning the mutex, to','line_number':306,'multiline':False]
['text':'!   owning the mutex, but only if it can obtain ownership by the specified','line_number':307,'multiline':False]
['text':'!   time. If the mutex_type does not support timed_lock (), this function','line_number':308,'multiline':False]
['text':'!   will fail at compile time if instantiated, but otherwise have no effect.*/','line_number':309,'multiline':False]
['text':'!Effects: If mutex() == 0 or if already locked, throws a lock_exception()','line_number':319,'multiline':False]
['text':'!   exception. Calls try_lock_until(abs_time) on the referenced mutex.','line_number':320,'multiline':False]
['text':'!Postconditions: owns() == the value returned from mutex()-> timed_lock(abs_time).','line_number':321,'multiline':False]
['text':'!Notes: The scoped_lock changes from a state of not owning the mutex, to','line_number':322,'multiline':False]
['text':'!   owning the mutex, but only if it can obtain ownership by the specified','line_number':323,'multiline':False]
['text':'!   time. If the mutex_type does not support timed_lock (), this function','line_number':324,'multiline':False]
['text':'!   will fail at compile time if instantiated, but otherwise have no effect.*/','line_number':325,'multiline':False]
['text':'!Effects: If mutex() == 0 or if already locked, throws a lock_exception()','line_number':335,'multiline':False]
['text':'!   exception. Calls try_lock_until(abs_time) on the referenced mutex.','line_number':336,'multiline':False]
['text':'!Postconditions: owns() == the value returned from mutex()-> timed_lock(abs_time).','line_number':337,'multiline':False]
['text':'!Notes: The scoped_lock changes from a state of not owning the mutex, to','line_number':338,'multiline':False]
['text':'!   owning the mutex, but only if it can obtain ownership by the specified','line_number':339,'multiline':False]
['text':'!   time. If the mutex_type does not support timed_lock (), this function','line_number':340,'multiline':False]
['text':'!   will fail at compile time if instantiated, but otherwise have no effect.*/','line_number':341,'multiline':False]
['text':'!Effects: If mutex() == 0 or if not locked, throws a lock_exception()','line_number':351,'multiline':False]
['text':'!   exception. Calls unlock() on the referenced mutex.','line_number':352,'multiline':False]
['text':'!Postconditions: owns() == false.','line_number':353,'multiline':False]
['text':'!Notes: The scoped_lock changes from a state of owning the mutex, to not','line_number':354,'multiline':False]
['text':'!   owning the mutex.*/','line_number':355,'multiline':False]
['text':'!Effects: Returns true if this scoped_lock has acquired','line_number':364,'multiline':False]
['text':'!the referenced mutex.','line_number':365,'multiline':False]
['text':'!Conversion to bool.','line_number':369,'multiline':False]
['text':'!Returns owns().','line_number':370,'multiline':False]
['text':'!Effects: Returns a pointer to the referenced mutex, or 0 if','line_number':374,'multiline':False]
['text':'!there is no mutex to reference.','line_number':375,'multiline':False]
['text':'!Effects: Returns a pointer to the referenced mutex, or 0 if there is no','line_number':379,'multiline':False]
['text':'!   mutex to reference.','line_number':380,'multiline':False]
['text':'!Postconditions: mutex() == 0 and owns() == false.','line_number':381,'multiline':False]
['text':'!Effects: Swaps state with moved lock.','line_number':390,'multiline':False]
['text':'!Throws: Nothing.','line_number':391,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':402,'multiline':False]
['text':' namespace interprocess','line_number':405,'multiline':False]
['text':' namespace boost','line_number':406,'multiline':False]
['text':' BOOST_INTERPROCESS_SCOPED_LOCK_HPP','line_number':410,'multiline':False]
