['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' (C) Copyright Ion Gaztanaga 2005-2015. Distributed under the Boost','line_number':3,'multiline':False]
['text':' Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]
['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':' See http://www.boost.org/libs/interprocess for documentation.','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////////////','line_number':9,'multiline':False]
['text':'alignment_of, aligned_storage','line_number':34,'multiline':False]
['text':'!\file','line_number':44,'multiline':False]
['text':'!Describes a smart pointer that stores the offset between this pointer and','line_number':45,'multiline':False]
['text':'!target pointee, called offset_ptr.','line_number':46,'multiline':False]
['text':'Predeclarations','line_number':52,'multiline':False]
['text':'#if !defined(BOOST_INTERPROCESS_DOXYGEN_INVOKED)','line_number':56,'multiline':False]
['text':'Distance between this object and pointee address','line_number':73,'multiline':False]
['text':'for offset_type_alignment m_offset will be enough','line_number':76,'multiline':False]
['text':'Note: using the address of a local variable to point to another address','line_number':81,'multiline':False]
['text':'is not standard conforming and this can be optimized-away by the compiler.','line_number':82,'multiline':False]
['text':'Non-inlining is a method to remain illegal but correct','line_number':83,'multiline':False]
['text':'Undef BOOST_INTERPROCESS_OFFSET_PTR_INLINE_XXX if your compiler can inline','line_number':85,'multiline':False]
['text':'this code without breaking the library','line_number':86,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////','line_number':88,'multiline':False]
['text':'','line_number':89,'multiline':False]
['text':'                      offset_ptr_to_raw_pointer','line_number':90,'multiline':False]
['text':'','line_number':91,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////','line_number':92,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////','line_number':114,'multiline':False]
['text':'','line_number':115,'multiline':False]
['text':'                      offset_ptr_to_offset','line_number':116,'multiline':False]
['text':'','line_number':117,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////','line_number':118,'multiline':False]
['text':'offset == 1 && ptr != 0 is not legal for this pointer','line_number':125,'multiline':False]
['text':'const OffsetType other = -OffsetType(ptr != 0);','line_number':135,'multiline':False]
['text':'const OffsetType offset = (caster_t(ptr).offset() - caster_t(this_ptr).offset()) & other;','line_number':136,'multiline':False]
['text':'return offset + OffsetType(!other);','line_number':137,'multiline':False]
['text':'','line_number':138,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////','line_number':148,'multiline':False]
['text':'','line_number':149,'multiline':False]
['text':'                      offset_ptr_to_offset_from_other','line_number':150,'multiline':False]
['text':'','line_number':151,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////','line_number':152,'multiline':False]
['text':'OffsetType mask = -OffsetType(other_offset != 1);','line_number':175,'multiline':False]
['text':'OffsetType offset = caster_t(other_ptr).offset() - caster_t(this_ptr).offset();','line_number':176,'multiline':False]
['text':'offset &= mask;','line_number':177,'multiline':False]
['text':'return offset + other_offset;','line_number':178,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////','line_number':182,'multiline':False]
['text':'','line_number':183,'multiline':False]
['text':' Let's assume cast to void and cv cast don't change any target address','line_number':184,'multiline':False]
['text':'','line_number':185,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////','line_number':186,'multiline':False]
['text':'namespace ipcdetail {','line_number':210,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':211,'multiline':False]
['text':'!A smart pointer that stores the offset between between the pointer and the','line_number':213,'multiline':False]
['text':'!the object it points. This allows offset allows special properties, since','line_number':214,'multiline':False]
['text':'!the pointer is independent from the address of the pointee, if the','line_number':215,'multiline':False]
['text':'!pointer and the pointee are still separated by the same offset. This feature','line_number':216,'multiline':False]
['text':'!converts offset_ptr in a smart pointer that can be placed in shared memory and','line_number':217,'multiline':False]
['text':'!memory mapped files mapped in different addresses in every process.','line_number':218,'multiline':False]
['text':'!','line_number':219,'multiline':False]
['text':'! \tparam PointedType The type of the pointee.','line_number':220,'multiline':False]
['text':'! \tparam DifferenceType A signed integer type that can represent the arithmetic operations on the pointer','line_number':221,'multiline':False]
['text':'! \tparam OffsetType An unsigned integer type that can represent the','line_number':222,'multiline':False]
['text':'!   distance between two pointers reinterpret_cast-ed as unsigned integers. This type','line_number':223,'multiline':False]
['text':'!   should be at least of the same size of std::uintptr_t. In some systems it's possible to communicate','line_number':224,'multiline':False]
['text':'!   between 32 and 64 bit processes using 64 bit offsets.','line_number':225,'multiline':False]
['text':'! \tparam OffsetAlignment Alignment of the OffsetType stored inside. In some systems might be necessary','line_number':226,'multiline':False]
['text':'!   to align it to 64 bits in order to communicate 32 and 64 bit processes using 64 bit offsets.','line_number':227,'multiline':False]
['text':'!','line_number':228,'multiline':False]
['text':'!<b>Note</b>: offset_ptr uses implementation defined properties, present in most platforms, for','line_number':229,'multiline':False]
['text':'!performance reasons:','line_number':230,'multiline':False]
['text':'!   - Assumes that OffsetType representation of nullptr is (OffsetType)zero.','line_number':231,'multiline':False]
['text':'!   - Assumes that incrementing a OffsetType obtained from a pointer is equivalent','line_number':232,'multiline':False]
['text':'!     to incrementing the pointer and then converting it back to OffsetType.','line_number':233,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':241,'multiline':False]
['text':'Public Functions','line_number':256,'multiline':False]
['text':'!Default constructor (null pointer).','line_number':258,'multiline':False]
['text':'!Never throws.','line_number':259,'multiline':False]
['text':'!Constructor from raw pointer (allows "0" pointer conversion).','line_number':264,'multiline':False]
['text':'!Never throws.','line_number':265,'multiline':False]
['text':'!Constructor from other pointer.','line_number':270,'multiline':False]
['text':'!Never throws.','line_number':271,'multiline':False]
['text':'!Constructor from other offset_ptr','line_number':278,'multiline':False]
['text':'!Never throws.','line_number':279,'multiline':False]
['text':'!Constructor from other offset_ptr. Only takes part in overload resolution','line_number':284,'multiline':False]
['text':'!if T2* is convertible to PointedType*. Never throws.','line_number':285,'multiline':False]
['text':'!Constructor from other offset_ptr. Only takes part in overload resolution','line_number':305,'multiline':False]
['text':'!if PointedType* is constructible from T2* other than via a conversion (e.g. cast to a derived class). Never throws.','line_number':306,'multiline':False]
['text':'!Emulates static_cast operator.','line_number':318,'multiline':False]
['text':'!Never throws.','line_number':319,'multiline':False]
['text':'!Emulates const_cast operator.','line_number':325,'multiline':False]
['text':'!Never throws.','line_number':326,'multiline':False]
['text':'!Emulates dynamic_cast operator.','line_number':332,'multiline':False]
['text':'!Never throws.','line_number':333,'multiline':False]
['text':'!Emulates reinterpret_cast operator.','line_number':339,'multiline':False]
['text':'!Never throws.','line_number':340,'multiline':False]
['text':'!Obtains raw pointer from offset.','line_number':346,'multiline':False]
['text':'!Never throws.','line_number':347,'multiline':False]
['text':'!Pointer-like -> operator. It can return 0 pointer.','line_number':354,'multiline':False]
['text':'!Never throws.','line_number':355,'multiline':False]
['text':'!Dereferencing operator, if it is a null offset_ptr behavior','line_number':359,'multiline':False]
['text':'!   is undefined. Never throws.','line_number':360,'multiline':False]
['text':'!Indexing operator.','line_number':368,'multiline':False]
['text':'!Never throws.','line_number':369,'multiline':False]
['text':'!Assignment from pointer (saves extra conversion).','line_number':373,'multiline':False]
['text':'!Never throws.','line_number':374,'multiline':False]
['text':'!Assignment from other offset_ptr.','line_number':381,'multiline':False]
['text':'!Never throws.','line_number':382,'multiline':False]
['text':'!Assignment from related offset_ptr. If pointers of pointee types','line_number':389,'multiline':False]
['text':'!   are assignable, offset_ptrs will be assignable. Never throws.','line_number':390,'multiline':False]
['text':'!offset_ptr += difference_type.','line_number':406,'multiline':False]
['text':'!Never throws.','line_number':407,'multiline':False]
['text':'!offset_ptr -= difference_type.','line_number':411,'multiline':False]
['text':'!Never throws.','line_number':412,'multiline':False]
['text':'!++offset_ptr.','line_number':416,'multiline':False]
['text':'!Never throws.','line_number':417,'multiline':False]
['text':'!offset_ptr++.','line_number':421,'multiline':False]
['text':'!Never throws.','line_number':422,'multiline':False]
['text':'!--offset_ptr.','line_number':430,'multiline':False]
['text':'!Never throws.','line_number':431,'multiline':False]
['text':'!offset_ptr--.','line_number':435,'multiline':False]
['text':'!Never throws.','line_number':436,'multiline':False]
['text':'!safe bool conversion operator.','line_number':444,'multiline':False]
['text':'!Never throws.','line_number':445,'multiline':False]
['text':'!Not operator. Not needed in theory, but improves portability.','line_number':454,'multiline':False]
['text':'!Never throws','line_number':455,'multiline':False]
['text':'!Compatibility with pointer_traits','line_number':459,'multiline':False]
['text':'!','line_number':460,'multiline':False]
['text':'BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':470,'multiline':False]
['text':'!Compatibility with pointer_traits','line_number':473,'multiline':False]
['text':'!','line_number':474,'multiline':False]
['text':'!difference_type + offset_ptr','line_number':478,'multiline':False]
['text':'!operation','line_number':479,'multiline':False]
['text':'!offset_ptr + difference_type','line_number':483,'multiline':False]
['text':'!operation','line_number':484,'multiline':False]
['text':'!offset_ptr - diff','line_number':488,'multiline':False]
['text':'!operation','line_number':489,'multiline':False]
['text':'!offset_ptr - diff','line_number':493,'multiline':False]
['text':'!operation','line_number':494,'multiline':False]
['text':'!offset_ptr - offset_ptr','line_number':498,'multiline':False]
['text':'!operation','line_number':499,'multiline':False]
['text':'Comparison','line_number':503,'multiline':False]
['text':'Comparison to raw ptr to support literal 0','line_number':522,'multiline':False]
['text':'Comparison','line_number':541,'multiline':False]
['text':'no need to pointer adjustment','line_number':570,'multiline':False]
['text':'we must convert to raw before calculating the offset','line_number':576,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':596,'multiline':False]
['text':'!operator<<','line_number':599,'multiline':False]
['text':'!for offset ptr','line_number':600,'multiline':False]
['text':'!operator>>','line_number':606,'multiline':False]
['text':'!for offset ptr','line_number':607,'multiline':False]
['text':'!Simulation of static_cast between pointers. Never throws.','line_number':613,'multiline':False]
['text':'!Simulation of const_cast between pointers. Never throws.','line_number':622,'multiline':False]
['text':'!Simulation of dynamic_cast between pointers. Never throws.','line_number':631,'multiline':False]
['text':'!Simulation of reinterpret_cast between pointers. Never throws.','line_number':640,'multiline':False]
['text':'namespace interprocess {','line_number':649,'multiline':False]
['text':'/has_trivial_destructor<> == true_type specialization for optimizations','line_number':653,'multiline':False]
['text':'/has_trivial_destructor<> == true_type specialization for optimizations','line_number':662,'multiline':False]
['text':'namespace move_detail {','line_number':669,'multiline':False]
['text':'!to_raw_pointer() enables boost::mem_fn to recognize offset_ptr.','line_number':673,'multiline':False]
['text':'!Never throws.','line_number':674,'multiline':False]
['text':'namespace interprocess','line_number':679,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':682,'multiline':False]
['text':'namespace boost {','line_number':683,'multiline':False]
['text':'This is to support embedding a bit in the pointer','line_number':689,'multiline':False]
['text':'for intrusive containers, saving space','line_number':690,'multiline':False]
['text':'Predeclaration to avoid including header','line_number':693,'multiline':False]
['text':'The offset ptr can embed one bit less than the alignment since it','line_number':700,'multiline':False]
['text':'uses offset == 1 to store the null pointer.','line_number':701,'multiline':False]
['text':'Predeclaration','line_number':705,'multiline':False]
['text':'Bits are stored in the lower bits of the pointer except the LSB,','line_number':713,'multiline':False]
['text':'because this bit is used to represent the null pointer.','line_number':714,'multiline':False]
['text':'We must ALWAYS take argument "n" by reference as a copy of a null pointer','line_number':718,'multiline':False]
['text':'with a bit (e.g. offset == 3) would be incorrectly copied and interpreted as non-null.','line_number':719,'multiline':False]
['text':'namespace intrusive','line_number':752,'multiline':False]
['text':'Predeclaration','line_number':754,'multiline':False]
['text':'Backwards compatibility with pointer_to_other','line_number':758,'multiline':False]
['text':'namespace boost{','line_number':766,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_DOXYGEN_INVOKED','line_number':767,'multiline':False]
['text':'#ifndef BOOST_INTERPROCESS_OFFSET_PTR_HPP','line_number':775,'multiline':False]
