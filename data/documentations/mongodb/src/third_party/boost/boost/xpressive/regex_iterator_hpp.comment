['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'/ \file regex_iterator.hpp','line_number':2,'multiline':False]
['text':'/ Contains the definition of the regex_iterator type, an STL-compatible iterator','line_number':3,'multiline':False]
['text':'/ for stepping through all the matches in a sequence.','line_number':4,'multiline':False]
['text':'','line_number':5,'multiline':False]
['text':'  Copyright 2008 Eric Niebler. Distributed under the Boost','line_number':6,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':7,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]
['text':' MS compatible compilers support #pragma once','line_number':13,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////////','line_number':28,'multiline':False]
['text':' regex_iterator_impl','line_number':29,'multiline':False]
['text':'','line_number':30,'multiline':False]
['text':' Report position() correctly by setting the base different from prefix().first','line_number':65,'multiline':False]
['text':' namespace detail','line_number':91,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////////','line_number':93,'multiline':False]
['text':' regex_iterator','line_number':94,'multiline':False]
['text':'','line_number':95,'multiline':False]
['text':'/ INTERNAL ONLY','line_number':106,'multiline':False]
['text':' Empty regexes are guaranteed to match nothing','line_number':123,'multiline':False]
['text':' Empty regexes are guaranteed to match nothing','line_number':141,'multiline':False]
['text':' COW','line_number':150,'multiline':False]
['text':' COW','line_number':156,'multiline':False]
['text':'/ If what.prefix().first != what[0].second and if the element match_prev_avail is not set in','line_number':185,'multiline':False]
['text':'/ flags then sets it. Then behaves as if by calling regex_search(what[0].second, end, what, *pre, flags),','line_number':186,'multiline':False]
['text':'/ with the following variation: in the event that the previous match found was of zero length','line_number':187,'multiline':False]
['text':'/ (what[0].length() == 0) then attempts to find a non-zero length match starting at what[0].second,','line_number':188,'multiline':False]
['text':'/ only if that fails and provided what[0].second != suffix().second does it look for a (possibly','line_number':189,'multiline':False]
['text':'/ zero length) match starting from what[0].second + 1.  If no further match is found then sets','line_number':190,'multiline':False]
['text':'/ *this equal to the end of sequence iterator.','line_number':191,'multiline':False]
['text':'/ \post (*this)-\>size() == pre-\>mark_count() + 1','line_number':192,'multiline':False]
['text':'/ \post (*this)-\>empty() == false','line_number':193,'multiline':False]
['text':'/ \post (*this)-\>prefix().first == An iterator denoting the end point of the previous match found','line_number':194,'multiline':False]
['text':'/ \post (*this)-\>prefix().last == (**this)[0].first','line_number':195,'multiline':False]
['text':'/ \post (*this)-\>prefix().matched == (*this)-\>prefix().first != (*this)-\>prefix().second','line_number':196,'multiline':False]
['text':'/ \post (*this)-\>suffix().first == (**this)[0].second','line_number':197,'multiline':False]
['text':'/ \post (*this)-\>suffix().last == end','line_number':198,'multiline':False]
['text':'/ \post (*this)-\>suffix().matched == (*this)-\>suffix().first != (*this)-\>suffix().second','line_number':199,'multiline':False]
['text':'/ \post (**this)[0].first == The starting iterator for this match.','line_number':200,'multiline':False]
['text':'/ \post (**this)[0].second == The ending iterator for this match.','line_number':201,'multiline':False]
['text':'/ \post (**this)[0].matched == true if a full match was found, and false if it was a partial match (found as a result of the match_partial flag being set).','line_number':202,'multiline':False]
['text':'/ \post (**this)[n].first == For all integers n \< (*this)-\>size(), the start of the sequence that matched sub-expression n. Alternatively, if sub-expression n did not participate in the match, then end.','line_number':203,'multiline':False]
['text':'/ \post (**this)[n].second == For all integers n \< (*this)-\>size(), the end of the sequence that matched sub-expression n. Alternatively, if sub-expression n did not participate in the match, then end.','line_number':204,'multiline':False]
['text':'/ \post (**this)[n].matched == For all integers n \< (*this)-\>size(), true if sub-expression n participated in the match, false otherwise.','line_number':205,'multiline':False]
['text':'/ \post (*this)-\>position() == The distance from the start of the original sequence being iterated, to the start of this match.','line_number':206,'multiline':False]
['text':' un-share the implementation','line_number':209,'multiline':False]
['text':'/ INTERNAL ONLY','line_number':223,'multiline':False]
['text':' This is OK, the use_count is > 1','line_number':228,'multiline':False]
['text':'/ INTERNAL ONLY','line_number':245,'multiline':False]
['text':' namespace boost::xpressive','line_number':258,'multiline':False]
