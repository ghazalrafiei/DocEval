['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'/ \file make_expr.hpp','line_number':2,'multiline':False]
['text':'/ Definition of the \c make_expr() and \c unpack_expr() utilities for','line_number':3,'multiline':False]
['text':'/ building Proto expression nodes from child nodes or from a Fusion','line_number':4,'multiline':False]
['text':'/ sequence of child nodes, respectively.','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':'  Copyright 2008 Eric Niebler. Distributed under the Boost','line_number':7,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':8,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':9,'multiline':False]
['text':' qualifier applied to function type has no meaning; ignored','line_number':50,'multiline':False]
['text':' function 'xxx' marked as __forceinline not inlined','line_number':51,'multiline':False]
['text':'/ INTERNAL ONLY','line_number':56,'multiline':False]
['text':'/','line_number':57,'multiline':False]
['text':'','line_number':63,'multiline':True]
['text':'/ INTERNAL ONLY','line_number':65,'multiline':False]
['text':'/','line_number':66,'multiline':False]
['text':'','line_number':72,'multiline':True]
['text':' Definition of detail::unpack_expr_','line_number':96,'multiline':False]
['text':' Definition of detail::make_expr_','line_number':99,'multiline':False]
['text':'/ \brief Metafunction that computes the return type of the','line_number':105,'multiline':False]
['text':'/ \c make_expr() function, with a domain deduced from the','line_number':106,'multiline':False]
['text':'/ domains of the children.','line_number':107,'multiline':False]
['text':'/','line_number':108,'multiline':False]
['text':'/ Use the <tt>result_of::make_expr\<\></tt> metafunction to','line_number':109,'multiline':False]
['text':'/ compute the return type of the \c make_expr() function.','line_number':110,'multiline':False]
['text':'/','line_number':111,'multiline':False]
['text':'/ In this specialization, the domain is deduced from the','line_number':112,'multiline':False]
['text':'/ domains of the child types. (If','line_number':113,'multiline':False]
['text':'/ <tt>is_domain\<A0\>::value</tt> is \c true, then another','line_number':114,'multiline':False]
['text':'/ specialization is selected.)','line_number':115,'multiline':False]
['text':' = void','line_number':119,'multiline':False]
['text':' = void','line_number':120,'multiline':False]
['text':'/ Same as <tt>result_of::make_expr\<Tag, D, A0, ... AN\>::type</tt>','line_number':124,'multiline':False]
['text':'/ where \c D is the deduced domain, which is calculated as follows:','line_number':125,'multiline':False]
['text':'/','line_number':126,'multiline':False]
['text':'/ For each \c x in <tt>[0,N)</tt> (proceeding in order beginning with','line_number':127,'multiline':False]
['text':'/ <tt>x=0</tt>), if <tt>domain_of\<Ax\>::type</tt> is not','line_number':128,'multiline':False]
['text':'/ \c default_domain, then \c D is <tt>domain_of\<Ax\>::type</tt>.','line_number':129,'multiline':False]
['text':'/ Otherwise, \c D is \c default_domain.','line_number':130,'multiline':False]
['text':'/ \brief Metafunction that computes the return type of the','line_number':140,'multiline':False]
['text':'/ \c make_expr() function, within the specified domain.','line_number':141,'multiline':False]
['text':'/','line_number':142,'multiline':False]
['text':'/ Use the <tt>result_of::make_expr\<\></tt> metafunction to compute','line_number':143,'multiline':False]
['text':'/ the return type of the \c make_expr() function.','line_number':144,'multiline':False]
['text':'/ If \c Tag is <tt>tag::terminal</tt>, then \c type is a','line_number':157,'multiline':False]
['text':'/ typedef for <tt>boost::result_of\<Domain(expr\<tag::terminal,','line_number':158,'multiline':False]
['text':'/ term\<A0\> \>)\>::type</tt>.','line_number':159,'multiline':False]
['text':'/','line_number':160,'multiline':False]
['text':'/ Otherwise, \c type is a typedef for <tt>boost::result_of\<Domain(expr\<Tag,','line_number':161,'multiline':False]
['text':'/ listN\< as_child\<A0\>::type, ... as_child\<AN\>::type\>)','line_number':162,'multiline':False]
['text':'/ \>::type</tt>, where \c N is the number of non-void template','line_number':163,'multiline':False]
['text':'/ arguments, and <tt>as_child\<A\>::type</tt> is evaluated as','line_number':164,'multiline':False]
['text':'/ follows:','line_number':165,'multiline':False]
['text':'/','line_number':166,'multiline':False]
['text':'/ \li If <tt>is_expr\<A\>::value</tt> is \c true, then the','line_number':167,'multiline':False]
['text':'/ child type is \c A.','line_number':168,'multiline':False]
['text':'/ \li If \c A is <tt>B &</tt> or <tt>cv boost::reference_wrapper\<B\></tt>,','line_number':169,'multiline':False]
['text':'/ and <tt>is_expr\<B\>::value</tt> is \c true, then the','line_number':170,'multiline':False]
['text':'/ child type is <tt>B &</tt>.','line_number':171,'multiline':False]
['text':'/ \li If <tt>is_expr\<A\>::value</tt> is \c false, then the','line_number':172,'multiline':False]
['text':'/ child type is <tt>boost::result_of\<Domain(expr\<tag::terminal, term\<A\> \>','line_number':173,'multiline':False]
['text':'/ )\>::type</tt>.','line_number':174,'multiline':False]
['text':'/ \li If \c A is <tt>B &</tt> or <tt>cv boost::reference_wrapper\<B\></tt>,','line_number':175,'multiline':False]
['text':'/ and <tt>is_expr\<B\>::value</tt> is \c false, then the','line_number':176,'multiline':False]
['text':'/ child type is <tt>boost::result_of\<Domain(expr\<tag::terminal, term\<B &\> \>','line_number':177,'multiline':False]
['text':'/ )\>::type</tt>.','line_number':178,'multiline':False]
['text':'/ \brief Metafunction that computes the return type of the','line_number':188,'multiline':False]
['text':'/ \c unpack_expr() function, with a domain deduced from the','line_number':189,'multiline':False]
['text':'/ domains of the children.','line_number':190,'multiline':False]
['text':'/','line_number':191,'multiline':False]
['text':'/ Use the <tt>result_of::unpack_expr\<\></tt> metafunction to','line_number':192,'multiline':False]
['text':'/ compute the return type of the \c unpack_expr() function.','line_number':193,'multiline':False]
['text':'/','line_number':194,'multiline':False]
['text':'/ \c Sequence is a Fusion Forward Sequence.','line_number':195,'multiline':False]
['text':'/','line_number':196,'multiline':False]
['text':'/ In this specialization, the domain is deduced from the','line_number':197,'multiline':False]
['text':'/ domains of the child types. (If','line_number':198,'multiline':False]
['text':'/ <tt>is_domain\<Sequence>::value</tt> is \c true, then another','line_number':199,'multiline':False]
['text':'/ specialization is selected.)','line_number':200,'multiline':False]
['text':' = void','line_number':204,'multiline':False]
['text':' = void','line_number':205,'multiline':False]
['text':'/ Let \c S be the type of a Fusion Random Access Sequence','line_number':209,'multiline':False]
['text':'/ equivalent to \c Sequence. Then \c type is the','line_number':210,'multiline':False]
['text':'/ same as <tt>result_of::make_expr\<Tag,','line_number':211,'multiline':False]
['text':'/ fusion::result_of::value_at_c\<S, 0\>::type, ...','line_number':212,'multiline':False]
['text':'/ fusion::result_of::value_at_c\<S, N-1\>::type\>::type</tt>,','line_number':213,'multiline':False]
['text':'/ where \c N is the size of \c S.','line_number':214,'multiline':False]
['text':'/ \brief Metafunction that computes the return type of the','line_number':225,'multiline':False]
['text':'/ \c unpack_expr() function, within the specified domain.','line_number':226,'multiline':False]
['text':'/','line_number':227,'multiline':False]
['text':'/ Use the <tt>result_of::make_expr\<\></tt> metafunction to compute','line_number':228,'multiline':False]
['text':'/ the return type of the \c make_expr() function.','line_number':229,'multiline':False]
['text':'/ Let \c S be the type of a Fusion Random Access Sequence','line_number':233,'multiline':False]
['text':'/ equivalent to \c Sequence. Then \c type is the','line_number':234,'multiline':False]
['text':'/ same as <tt>result_of::make_expr\<Tag, Domain,','line_number':235,'multiline':False]
['text':'/ fusion::result_of::value_at_c\<S, 0\>::type, ...','line_number':236,'multiline':False]
['text':'/ fusion::result_of::value_at_c\<S, N-1\>::type\>::type</tt>,','line_number':237,'multiline':False]
['text':'/ where \c N is the size of \c S.','line_number':238,'multiline':False]
['text':'/ \brief A callable function object equivalent to the','line_number':252,'multiline':False]
['text':'/ \c proto::make_expr() function.','line_number':253,'multiline':False]
['text':'/','line_number':254,'multiline':False]
['text':'/ In all cases, <tt>functional::make_expr\<Tag, Domain\>()(a0, ... aN)</tt>','line_number':255,'multiline':False]
['text':'/ is equivalent to <tt>proto::make_expr\<Tag, Domain\>(a0, ... aN)</tt>.','line_number':256,'multiline':False]
['text':'/','line_number':257,'multiline':False]
['text':'/ <tt>functional::make_expr\<Tag\>()(a0, ... aN)</tt>','line_number':258,'multiline':False]
['text':'/ is equivalent to <tt>proto::make_expr\<Tag\>(a0, ... aN)</tt>.','line_number':259,'multiline':False]
['text':' = deduce_domain','line_number':260,'multiline':True]
['text':'/ Construct an expression node with tag type \c Tag','line_number':281,'multiline':False]
['text':'/ and in the domain \c Domain.','line_number':282,'multiline':False]
['text':'/','line_number':283,'multiline':False]
['text':'/ \return <tt>proto::make_expr\<Tag, Domain\>(a0,...aN)</tt>','line_number':284,'multiline':False]
['text':' Additional overloads generated by the preprocessor ...','line_number':301,'multiline':False]
['text':'/ INTERNAL ONLY','line_number':304,'multiline':False]
['text':'/','line_number':305,'multiline':False]
['text':'/ \brief A callable function object equivalent to the','line_number':322,'multiline':False]
['text':'/ \c proto::unpack_expr() function.','line_number':323,'multiline':False]
['text':'/','line_number':324,'multiline':False]
['text':'/ In all cases, <tt>functional::unpack_expr\<Tag, Domain\>()(seq)</tt>','line_number':325,'multiline':False]
['text':'/ is equivalent to <tt>proto::unpack_expr\<Tag, Domain\>(seq)</tt>.','line_number':326,'multiline':False]
['text':'/','line_number':327,'multiline':False]
['text':'/ <tt>functional::unpack_expr\<Tag\>()(seq)</tt>','line_number':328,'multiline':False]
['text':'/ is equivalent to <tt>proto::unpack_expr\<Tag\>(seq)</tt>.','line_number':329,'multiline':False]
['text':' = deduce_domain','line_number':330,'multiline':True]
['text':'/ Construct an expression node with tag type \c Tag','line_number':350,'multiline':False]
['text':'/ and in the domain \c Domain.','line_number':351,'multiline':False]
['text':'/','line_number':352,'multiline':False]
['text':'/ \param sequence A Fusion Forward Sequence','line_number':353,'multiline':False]
['text':'/ \return <tt>proto::unpack_expr\<Tag, Domain\>(sequence)</tt>','line_number':354,'multiline':False]
['text':' namespace functional','line_number':369,'multiline':False]
['text':'/ \brief Construct an expression of the requested tag type','line_number':371,'multiline':False]
['text':'/ with a domain and with the specified arguments as children.','line_number':372,'multiline':False]
['text':'/','line_number':373,'multiline':False]
['text':'/ This function template may be invoked either with or without','line_number':374,'multiline':False]
['text':'/ specifying a \c Domain argument. If no domain is specified,','line_number':375,'multiline':False]
['text':'/ the domain is deduced by examining in order the domains of','line_number':376,'multiline':False]
['text':'/ the given arguments and taking the first that is not','line_number':377,'multiline':False]
['text':'/ \c default_domain, if any such domain exists, or','line_number':378,'multiline':False]
['text':'/ \c default_domain otherwise.','line_number':379,'multiline':False]
['text':'/','line_number':380,'multiline':False]
['text':'/ Let \c wrap_(x) be defined such that:','line_number':381,'multiline':False]
['text':'/ \li If \c x is a <tt>boost::reference_wrapper\<\></tt>,','line_number':382,'multiline':False]
['text':'/ \c wrap_(x) is equivalent to <tt>as_child\<Domain\>(x.get())</tt>.','line_number':383,'multiline':False]
['text':'/ \li Otherwise, \c wrap_(x) is equivalent to','line_number':384,'multiline':False]
['text':'/ <tt>as_expr\<Domain\>(x)</tt>.','line_number':385,'multiline':False]
['text':'/','line_number':386,'multiline':False]
['text':'/ Let <tt>make_\<Tag\>(b0,...bN)</tt> be defined as','line_number':387,'multiline':False]
['text':'/ <tt>expr\<Tag, listN\<C0,...CN\> \>::make(c0,...cN)</tt>','line_number':388,'multiline':False]
['text':'/ where \c Bx is the type of \c bx.','line_number':389,'multiline':False]
['text':'/','line_number':390,'multiline':False]
['text':'/ \return <tt>Domain()(make_\<Tag\>(wrap_(a0),...wrap_(aN)))</tt>.','line_number':391,'multiline':False]
['text':'/ \overload','line_number':410,'multiline':False]
['text':'/','line_number':411,'multiline':False]
['text':' Additional overloads generated by the preprocessor...','line_number':428,'multiline':False]
['text':'/ \brief Construct an expression of the requested tag type','line_number':431,'multiline':False]
['text':'/ with a domain and with childres from the specified Fusion','line_number':432,'multiline':False]
['text':'/ Forward Sequence.','line_number':433,'multiline':False]
['text':'/','line_number':434,'multiline':False]
['text':'/ This function template may be invoked either with or without','line_number':435,'multiline':False]
['text':'/ specifying a \c Domain argument. If no domain is specified,','line_number':436,'multiline':False]
['text':'/ the domain is deduced by examining in order the domains of the','line_number':437,'multiline':False]
['text':'/ elements of \c sequence and taking the first that is not','line_number':438,'multiline':False]
['text':'/ \c default_domain, if any such domain exists, or','line_number':439,'multiline':False]
['text':'/ \c default_domain otherwise.','line_number':440,'multiline':False]
['text':'/','line_number':441,'multiline':False]
['text':'/ Let \c s be a Fusion Random Access Sequence equivalent to \c sequence.','line_number':442,'multiline':False]
['text':'/ Let <tt>wrap_\<N\>(s)</tt>, where \c s has type \c S, be defined','line_number':443,'multiline':False]
['text':'/ such that:','line_number':444,'multiline':False]
['text':'/ \li If <tt>fusion::result_of::value_at_c\<S,N\>::type</tt> is a reference,','line_number':445,'multiline':False]
['text':'/ <tt>wrap_\<N\>(s)</tt> is equivalent to','line_number':446,'multiline':False]
['text':'/ <tt>as_child\<Domain\>(fusion::at_c\<N\>(s))</tt>.','line_number':447,'multiline':False]
['text':'/ \li Otherwise, <tt>wrap_\<N\>(s)</tt> is equivalent to','line_number':448,'multiline':False]
['text':'/ <tt>as_expr\<Domain\>(fusion::at_c\<N\>(s))</tt>.','line_number':449,'multiline':False]
['text':'/','line_number':450,'multiline':False]
['text':'/ Let <tt>make_\<Tag\>(b0,...bN)</tt> be defined as','line_number':451,'multiline':False]
['text':'/ <tt>expr\<Tag, listN\<B0,...BN\> \>::make(b0,...bN)</tt>','line_number':452,'multiline':False]
['text':'/ where \c Bx is the type of \c bx.','line_number':453,'multiline':False]
['text':'/','line_number':454,'multiline':False]
['text':'/ \param sequence a Fusion Forward Sequence.','line_number':455,'multiline':False]
['text':'/ \return <tt>Domain()(make_\<Tag\>(wrap_\<0\>(s),...wrap_\<N-1\>(s)))</tt>,','line_number':456,'multiline':False]
['text':'/ where N is the size of \c Sequence.','line_number':457,'multiline':False]
['text':'/ \overload','line_number':474,'multiline':False]
['text':'/','line_number':475,'multiline':False]
['text':'/ INTERNAL ONLY','line_number':489,'multiline':False]
['text':'/','line_number':490,'multiline':False]
['text':'/ INTERNAL ONLY','line_number':496,'multiline':False]
['text':'/','line_number':497,'multiline':False]
['text':' BOOST_PROTO_MAKE_EXPR_HPP_EAN_04_01_2005','line_number':509,'multiline':False]
