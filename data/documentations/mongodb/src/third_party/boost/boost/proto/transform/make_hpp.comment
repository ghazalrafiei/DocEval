['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'/ \file make.hpp','line_number':2,'multiline':False]
['text':'/ Contains definition of the make<> transform.','line_number':3,'multiline':False]
['text':'','line_number':4,'multiline':False]
['text':'  Copyright 2008 Eric Niebler. Distributed under the Boost','line_number':5,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':6,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]
['text':' function 'xxx' marked as __forceinline not inlined','line_number':38,'multiline':False]
['text':' work around GCC bug','line_number':104,'multiline':False]
['text':' work around GCC bug','line_number':112,'multiline':False]
['text':' Other overloads generated by the preprocessor','line_number':132,'multiline':False]
['text':' Other overloads generated by the preprocessor','line_number':147,'multiline':False]
['text':'/ \brief A PrimitiveTransform which prevents another PrimitiveTransform','line_number':153,'multiline':False]
['text':'/ from being applied in an \c ObjectTransform.','line_number':154,'multiline':False]
['text':'/','line_number':155,'multiline':False]
['text':'/ When building higher order transforms with <tt>make\<\></tt> or','line_number':156,'multiline':False]
['text':'/ <tt>lazy\<\></tt>, you sometimes would like to build types that','line_number':157,'multiline':False]
['text':'/ are parameterized with Proto transforms. In such lambda-style','line_number':158,'multiline':False]
['text':'/ transforms, Proto will unhelpfully find all nested transforms','line_number':159,'multiline':False]
['text':'/ and apply them, even if you don't want them to be applied. Consider','line_number':160,'multiline':False]
['text':'/ the following transform, which will replace the \c _ in','line_number':161,'multiline':False]
['text':'/ <tt>Bar<_>()</tt> with <tt>proto::terminal\<int\>::type</tt>:','line_number':162,'multiline':False]
['text':'/','line_number':163,'multiline':False]
['text':'/ \code','line_number':164,'multiline':False]
['text':'/ template<typename T>','line_number':165,'multiline':False]
['text':'/ struct Bar','line_number':166,'multiline':False]
['text':'/ {};','line_number':167,'multiline':False]
['text':'/ ','line_number':168,'multiline':False]
['text':'/ struct Foo','line_number':169,'multiline':False]
['text':'/   : proto::when<_, Bar<_>() >','line_number':170,'multiline':False]
['text':'/ {};','line_number':171,'multiline':False]
['text':'/ ','line_number':172,'multiline':False]
['text':'/ proto::terminal<int>::type i = {0};','line_number':173,'multiline':False]
['text':'/ ','line_number':174,'multiline':False]
['text':'/ int main()','line_number':175,'multiline':False]
['text':'/ {','line_number':176,'multiline':False]
['text':'/     Foo()(i);','line_number':177,'multiline':False]
['text':'/     std::cout << typeid(Foo()(i)).name() << std::endl;','line_number':178,'multiline':False]
['text':'/ }','line_number':179,'multiline':False]
['text':'/ \endcode','line_number':180,'multiline':False]
['text':'/','line_number':181,'multiline':False]
['text':'/ If you actually wanted to default-construct an object of type','line_number':182,'multiline':False]
['text':'/ <tt>Bar\<_\></tt>, you would have to protect the \c _ to prevent','line_number':183,'multiline':False]
['text':'/ it from being applied. You can use <tt>proto::protect\<\></tt>','line_number':184,'multiline':False]
['text':'/ as follows:','line_number':185,'multiline':False]
['text':'/','line_number':186,'multiline':False]
['text':'/ \code','line_number':187,'multiline':False]
['text':'/ // OK: replace anything with Bar<_>()','line_number':188,'multiline':False]
['text':'/ struct Foo','line_number':189,'multiline':False]
['text':'/   : proto::when<_, Bar<protect<_> >() >','line_number':190,'multiline':False]
['text':'/ {};','line_number':191,'multiline':False]
['text':'/ \endcode','line_number':192,'multiline':False]
['text':'/ \brief A PrimitiveTransform which computes a type by evaluating any','line_number':203,'multiline':False]
['text':'/ nested transforms and then constructs an object of that type.','line_number':204,'multiline':False]
['text':'/','line_number':205,'multiline':False]
['text':'/ The <tt>make\<\></tt> transform checks to see if \c Object is a template.','line_number':206,'multiline':False]
['text':'/ If it is, the template type is disassembled to find nested transforms.','line_number':207,'multiline':False]
['text':'/ Proto considers the following types to represent transforms:','line_number':208,'multiline':False]
['text':'/','line_number':209,'multiline':False]
['text':'/ \li Function types','line_number':210,'multiline':False]
['text':'/ \li Function pointer types','line_number':211,'multiline':False]
['text':'/ \li Types for which <tt>proto::is_callable\< type \>::value</tt> is \c true','line_number':212,'multiline':False]
['text':'/','line_number':213,'multiline':False]
['text':'/ <tt>boost::result_of\<make\<T\<X0,X1,...\> \>(Expr, State, Data)\>::type</tt>','line_number':214,'multiline':False]
['text':'/ is evaluated as follows. For each \c X in <tt>X0,X1,...</tt>, do:','line_number':215,'multiline':False]
['text':'/','line_number':216,'multiline':False]
['text':'/ \li If \c X is a template like <tt>U\<Y0,Y1,...\></tt>, then let <tt>X'</tt>','line_number':217,'multiline':False]
['text':'/     be <tt>boost::result_of\<make\<U\<Y0,Y1,...\> \>(Expr, State, Data)\>::type</tt>','line_number':218,'multiline':False]
['text':'/     (which evaluates this procedure recursively). Note whether any','line_number':219,'multiline':False]
['text':'/     substitutions took place during this operation.','line_number':220,'multiline':False]
['text':'/ \li Otherwise, if \c X is a transform, then let <tt>X'</tt> be','line_number':221,'multiline':False]
['text':'/     <tt>boost::result_of\<when\<_, X\>(Expr, State, Data)\>::type</tt>.','line_number':222,'multiline':False]
['text':'/     Note that a substitution took place.','line_number':223,'multiline':False]
['text':'/ \li Otherwise, let <tt>X'</tt> be \c X, and note that no substitution','line_number':224,'multiline':False]
['text':'/     took place.','line_number':225,'multiline':False]
['text':'/ \li If any substitutions took place in any of the above steps and','line_number':226,'multiline':False]
['text':'/     <tt>T\<X0',X1',...\></tt> has a nested <tt>::type</tt> typedef,','line_number':227,'multiline':False]
['text':'/     the result type is <tt>T\<X0',X1',...\>::type</tt>.','line_number':228,'multiline':False]
['text':'/ \li Otherwise, the result type is <tt>T\<X0',X1',...\></tt>.','line_number':229,'multiline':False]
['text':'/','line_number':230,'multiline':False]
['text':'/ Note that <tt>when\<\></tt> is implemented in terms of <tt>call\<\></tt>','line_number':231,'multiline':False]
['text':'/ and <tt>make\<\></tt>, so the above procedure is evaluated recursively.','line_number':232,'multiline':False]
['text':'/ \return <tt>result_type()</tt>','line_number':241,'multiline':False]
['text':'/ INTERNAL ONLY','line_number':254,'multiline':False]
['text':' Other specializations generated by the preprocessor.','line_number':260,'multiline':False]
['text':'/ INTERNAL ONLY','line_number':264,'multiline':False]
['text':'/','line_number':265,'multiline':False]
['text':'/ INTERNAL ONLY','line_number':271,'multiline':False]
['text':'/','line_number':272,'multiline':False]
