['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'/ \file callable.hpp','line_number':2,'multiline':False]
['text':'/ Definintion of callable_context\<\>, an evaluation context for','line_number':3,'multiline':False]
['text':'/ proto::eval() that explodes each node and calls the derived context','line_number':4,'multiline':False]
['text':'/ type with the expressions constituents. If the derived context doesn't','line_number':5,'multiline':False]
['text':'/ have an overload that handles this node, fall back to some other','line_number':6,'multiline':False]
['text':'/ context.','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':'  Copyright 2008 Eric Niebler. Distributed under the Boost','line_number':9,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':10,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':11,'multiline':False]
['text':' for child_c','line_number':32,'multiline':False]
['text':'/ \brief A BinaryFunction that accepts a Proto expression and a','line_number':78,'multiline':False]
['text':'/ callable context and calls the context with the expression tag','line_number':79,'multiline':False]
['text':'/ and children as arguments, effectively fanning the expression','line_number':80,'multiline':False]
['text':'/ out.','line_number':81,'multiline':False]
['text':'/','line_number':82,'multiline':False]
['text':'/ <tt>callable_eval\<\></tt> requires that \c Context is a','line_number':83,'multiline':False]
['text':'/ PolymorphicFunctionObject that can be invoked with \c Expr's','line_number':84,'multiline':False]
['text':'/ tag and children as expressions, as follows:','line_number':85,'multiline':False]
['text':'/','line_number':86,'multiline':False]
['text':'/ \code','line_number':87,'multiline':False]
['text':'/ context(Expr::proto_tag(), child_c<0>(expr), child_c<1>(expr), ...)','line_number':88,'multiline':False]
['text':'/ \endcode','line_number':89,'multiline':False]
['text':' = Expr::proto_arity_c','line_number':93,'multiline':False]
['text':'/ \brief A BinaryFunction that accepts a Proto expression and a','line_number':98,'multiline':False]
['text':'/ callable context and calls the context with the expression tag','line_number':99,'multiline':False]
['text':'/ and children as arguments, effectively fanning the expression','line_number':100,'multiline':False]
['text':'/ out.','line_number':101,'multiline':False]
['text':'/','line_number':102,'multiline':False]
['text':'/ <tt>callable_eval\<\></tt> requires that \c Context is a','line_number':103,'multiline':False]
['text':'/ PolymorphicFunctionObject that can be invoked with \c Expr's','line_number':104,'multiline':False]
['text':'/ tag and children as expressions, as follows:','line_number':105,'multiline':False]
['text':'/','line_number':106,'multiline':False]
['text':'/ \code','line_number':107,'multiline':False]
['text':'/ context(Expr::proto_tag(), value(expr))','line_number':108,'multiline':False]
['text':'/ \endcode','line_number':109,'multiline':False]
['text':'/ \param expr The current expression','line_number':121,'multiline':False]
['text':'/ \param context The callable evaluation context','line_number':122,'multiline':False]
['text':'/ \return <tt>context(Expr::proto_tag(), value(expr))</tt>','line_number':123,'multiline':False]
['text':'/ \brief An evaluation context adaptor that makes authoring a','line_number':130,'multiline':False]
['text':'/ context a simple matter of writing function overloads, rather','line_number':131,'multiline':False]
['text':'/ then writing template specializations.','line_number':132,'multiline':False]
['text':'/','line_number':133,'multiline':False]
['text':'/ <tt>callable_context\<\></tt> is a base class that implements','line_number':134,'multiline':False]
['text':'/ the context protocol by passing fanned-out expression nodes to','line_number':135,'multiline':False]
['text':'/ the derived context, making it easy to customize the handling','line_number':136,'multiline':False]
['text':'/ of expression types by writing function overloads. Only those','line_number':137,'multiline':False]
['text':'/ expression types needing special handling require explicit','line_number':138,'multiline':False]
['text':'/ handling. All others are dispatched to a user-specified','line_number':139,'multiline':False]
['text':'/ default context, \c DefaultCtx.','line_number':140,'multiline':False]
['text':'/','line_number':141,'multiline':False]
['text':'/ <tt>callable_context\<\></tt> is defined simply as:','line_number':142,'multiline':False]
['text':'/','line_number':143,'multiline':False]
['text':'/ \code','line_number':144,'multiline':False]
['text':'/ template<typename Context, typename DefaultCtx = default_context>','line_number':145,'multiline':False]
['text':'/ struct callable_context','line_number':146,'multiline':False]
['text':'/ {','line_number':147,'multiline':False]
['text':'/    template<typename Expr, typename ThisContext = Context>','line_number':148,'multiline':False]
['text':'/     struct eval','line_number':149,'multiline':False]
['text':'/       : mpl::if_<','line_number':150,'multiline':False]
['text':'/             is_expr_handled_<Expr, Context> // For exposition','line_number':151,'multiline':False]
['text':'/           , callable_eval<Expr, ThisContext>','line_number':152,'multiline':False]
['text':'/           , typename DefaultCtx::template eval<Expr, Context>','line_number':153,'multiline':False]
['text':'/         >::type','line_number':154,'multiline':False]
['text':'/     {};','line_number':155,'multiline':False]
['text':'/ };','line_number':156,'multiline':False]
['text':'/ \endcode','line_number':157,'multiline':False]
['text':'/','line_number':158,'multiline':False]
['text':'/ The Boolean metafunction <tt>is_expr_handled_\<\></tt> uses','line_number':159,'multiline':False]
['text':'/ metaprogramming tricks to determine whether \c Context has','line_number':160,'multiline':False]
['text':'/ an overloaded function call operator that accepts the','line_number':161,'multiline':False]
['text':'/ fanned-out constituents of an expression of type \c Expr.','line_number':162,'multiline':False]
['text':'/ If so, the handling of the expression is dispatched to','line_number':163,'multiline':False]
['text':'/ <tt>callable_eval\<\></tt>. If not, it is dispatched to','line_number':164,'multiline':False]
['text':'/ the user-specified \c DefaultCtx.','line_number':165,'multiline':False]
['text':'/','line_number':166,'multiline':False]
['text':'/ Below is an example of how to use <tt>callable_context\<\></tt>:','line_number':167,'multiline':False]
['text':'/','line_number':168,'multiline':False]
['text':'/ \code','line_number':169,'multiline':False]
['text':'/ // An evaluation context that increments all','line_number':170,'multiline':False]
['text':'/ // integer terminals in-place.','line_number':171,'multiline':False]
['text':'/ struct increment_ints','line_number':172,'multiline':False]
['text':'/  : callable_context<','line_number':173,'multiline':False]
['text':'/         increment_ints const    // derived context','line_number':174,'multiline':False]
['text':'/       , null_context const      // fall-back context','line_number':175,'multiline':False]
['text':'/     >','line_number':176,'multiline':False]
['text':'/ {','line_number':177,'multiline':False]
['text':'/     typedef void result_type;','line_number':178,'multiline':False]
['text':'/','line_number':179,'multiline':False]
['text':'/     // Handle int terminals here:','line_number':180,'multiline':False]
['text':'/     void operator()(proto::tag::terminal, int &i) const','line_number':181,'multiline':False]
['text':'/     {','line_number':182,'multiline':False]
['text':'/        ++i;','line_number':183,'multiline':False]
['text':'/     }','line_number':184,'multiline':False]
['text':'/ };','line_number':185,'multiline':False]
['text':'/ \endcode','line_number':186,'multiline':False]
['text':'/','line_number':187,'multiline':False]
['text':'/ With \c increment_ints, we can do the following:','line_number':188,'multiline':False]
['text':'/','line_number':189,'multiline':False]
['text':'/ \code','line_number':190,'multiline':False]
['text':'/ literal<int> i = 0, j = 10;','line_number':191,'multiline':False]
['text':'/ proto::eval( i - j * 3.14, increment_ints() );','line_number':192,'multiline':False]
['text':'/','line_number':193,'multiline':False]
['text':'/ assert( i.get() == 1 && j.get() == 11 );','line_number':194,'multiline':False]
['text':'/ \endcode','line_number':195,'multiline':False]
['text':' = default_context','line_number':198,'multiline':False]
['text':'/ A BinaryFunction that accepts an \c Expr and a','line_number':202,'multiline':False]
['text':'/ \c Context, and either fans out the expression and passes','line_number':203,'multiline':False]
['text':'/ it to the context, or else hands off the expression to','line_number':204,'multiline':False]
['text':'/ \c DefaultCtx.','line_number':205,'multiline':False]
['text':'/','line_number':206,'multiline':False]
['text':'/ If \c Context is a PolymorphicFunctionObject such that','line_number':207,'multiline':False]
['text':'/ it can be invoked with the tag and children of \c Expr,','line_number':208,'multiline':False]
['text':'/ as <tt>ctx(Expr::proto_tag(), child_c\<0\>(expr), child_c\<1\>(expr)...)</tt>,','line_number':209,'multiline':False]
['text':'/ then <tt>eval\<Expr, ThisContext\></tt> inherits from','line_number':210,'multiline':False]
['text':'/ <tt>callable_eval\<Expr, ThisContext\></tt>. Otherwise,','line_number':211,'multiline':False]
['text':'/ <tt>eval\<Expr, ThisContext\></tt> inherits from','line_number':212,'multiline':False]
['text':'/ <tt>DefaultCtx::eval\<Expr, Context\></tt>.','line_number':213,'multiline':False]
