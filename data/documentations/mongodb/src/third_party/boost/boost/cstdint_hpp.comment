['text':'  boost cstdint.hpp header file  ------------------------------------------//','line_number':1,'multiline':False]
['text':'  (C) Copyright Beman Dawes 1999.','line_number':3,'multiline':False]
['text':'  (C) Copyright Jens Mauer 2001','line_number':4,'multiline':False]
['text':'  (C) Copyright John Maddock 2001','line_number':5,'multiline':False]
['text':'  Distributed under the Boost','line_number':6,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':7,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]
['text':'  See http://www.boost.org/libs/integer for documentation.','line_number':10,'multiline':False]
['text':'  Revision History','line_number':12,'multiline':False]
['text':'   31 Oct 01  use BOOST_HAS_LONG_LONG to check for "long long" (Jens M.)','line_number':13,'multiline':False]
['text':'   16 Apr 01  check LONGLONG_MAX when looking for "long long" (Jens Maurer)','line_number':14,'multiline':False]
['text':'   23 Jan 01  prefer "long" over "int" for int32_t and intmax_t (Jens Maurer)','line_number':15,'multiline':False]
['text':'   12 Nov 00  Merged <boost/stdint.h> (Jens Maurer)','line_number':16,'multiline':False]
['text':'   23 Sep 00  Added INTXX_C macro support (John Maddock).','line_number':17,'multiline':False]
['text':'   22 Sep 00  Better 64-bit support (John Maddock)','line_number':18,'multiline':False]
['text':'   29 Jun 00  Reimplement to avoid including stdint.h within namespace boost','line_number':19,'multiline':False]
['text':'    8 Aug 99  Initial version (Beman Dawes)','line_number':20,'multiline':False]
['text':'','line_number':26,'multiline':False]
['text':' Since we always define the INT#_C macros as per C++0x,','line_number':27,'multiline':False]
['text':' define __STDC_CONSTANT_MACROS so that <stdint.h> does the right','line_number':28,'multiline':False]
['text':' thing if possible, and so that the user knows that the macros','line_number':29,'multiline':False]
['text':' are actually defined as per C99.','line_number':30,'multiline':False]
['text':'','line_number':31,'multiline':False]
['text':'','line_number':37,'multiline':False]
['text':' For the following code we get several warnings along the lines of:','line_number':38,'multiline':False]
['text':'','line_number':39,'multiline':False]
['text':' boost/cstdint.hpp:428:35: error: use of C99 long long integer constant','line_number':40,'multiline':False]
['text':'','line_number':41,'multiline':False]
['text':' So we declare this a system header to suppress these warnings.','line_number':42,'multiline':False]
['text':' See also https://github.com/boostorg/config/issues/190','line_number':43,'multiline':False]
['text':'','line_number':44,'multiline':False]
['text':'','line_number':49,'multiline':False]
['text':' Note that GLIBC is a bit inconsistent about whether int64_t is defined or not','line_number':50,'multiline':False]
['text':' depending upon what headers happen to have been included first...','line_number':51,'multiline':False]
['text':' so we disable use of stdint.h when GLIBC does not define __GLIBC_HAVE_LONG_LONG.','line_number':52,'multiline':False]
['text':' See https://svn.boost.org/trac/boost/ticket/3548 and http://sources.redhat.com/bugzilla/show_bug.cgi?id=10990','line_number':53,'multiline':False]
['text':'','line_number':54,'multiline':False]
['text':' The following #include is an implementation artifact; not part of interface.','line_number':60,'multiline':False]
['text':' HP-UX has a vaguely nice <stdint.h> in a non-standard location','line_number':62,'multiline':False]
['text':' this is triggered with GCC, because it defines __cplusplus < 199707L','line_number':65,'multiline':False]
['text':' There is a bug in Cygwin two _C macros','line_number':73,'multiline':False]
['text':' QNX (Dinkumware stdlib) defines these as non-standard names.','line_number':85,'multiline':False]
['text':' Reflect to the standard names.','line_number':86,'multiline':False]
['text':' namespace boost','line_number':152,'multiline':False]
['text':' FreeBSD and Tru64 have an <inttypes.h> that contains much of what we need.','line_number':155,'multiline':False]
['text':' namespace boost','line_number':200,'multiline':False]
['text':' BOOST_HAS_STDINT_H','line_number':202,'multiline':False]
['text':' implementation artifact; not part of interface','line_number':204,'multiline':False]
['text':' needed for limits macros','line_number':205,'multiline':False]
['text':'  These are fairly safe guesses for some 16-bit, and most 32-bit and 64-bit','line_number':211,'multiline':False]
['text':'  platforms.  For other systems, they will have to be hand tailored.','line_number':212,'multiline':False]
['text':'','line_number':213,'multiline':False]
['text':'  Because the fast types are assumed to be the same as the undecorated types,','line_number':214,'multiline':False]
['text':'  it may be possible to hand tailor a more efficient implementation.  Such','line_number':215,'multiline':False]
['text':'  an optimization may be illusionary; on the Intel x86-family 386 on, for','line_number':216,'multiline':False]
['text':'  example, byte arithmetic and load/stores are as fast as "int" sized ones.','line_number':217,'multiline':False]
['text':'  8-bit types  ------------------------------------------------------------//','line_number':219,'multiline':False]
['text':'  16-bit types  -----------------------------------------------------------//','line_number':232,'multiline':False]
['text':' The Cray X1 has a 16-bit short, however it is not recommend','line_number':236,'multiline':False]
['text':' for use in performance critical code.','line_number':237,'multiline':False]
['text':' On MTA / XMT short is 32 bits unless the -short16 compiler flag is specified','line_number':253,'multiline':False]
['text':' MTA / XMT does support the following non-standard integer types','line_number':254,'multiline':False]
['text':' no 16-bit types on Cray:','line_number':262,'multiline':False]
['text':'  32-bit types  -----------------------------------------------------------//','line_number':271,'multiline':False]
['text':' Integers are 64 bits on the MTA / XMT','line_number':295,'multiline':False]
['text':'  64-bit types + intmax_t and uintmax_t  ----------------------------------//','line_number':306,'multiline':False]
['text':' HP-UX's value of ULONG_LONG_MAX is unusable in preprocessor expressions','line_number':313,'multiline':False]
['text':' 2**64 - 1','line_number':315,'multiline':False]
['text':' 2**64 - 1','line_number':331,'multiline':False]
['text':'','line_number':353,'multiline':False]
['text':' we have Borland/Intel/Microsoft __int64:','line_number':354,'multiline':False]
['text':'','line_number':355,'multiline':False]
['text':' assume no 64-bit integers','line_number':364,'multiline':False]
['text':' namespace boost','line_number':370,'multiline':False]
['text':' BOOST_HAS_STDINT_H','line_number':373,'multiline':False]
['text':' intptr_t/uintptr_t are defined separately because they are optional and not universally available','line_number':375,'multiline':False]
['text':' Older MSVC don't have stdint.h and have intptr_t/uintptr_t defined in stddef.h','line_number':377,'multiline':False]
['text':' Clang pretends to be GCC, so it'll match this condition','line_number':393,'multiline':False]
['text':' BOOST_CSTDINT_HPP','line_number':404,'multiline':False]
['text':'***************************************************

Macro definition section:

Added 23rd September 2000 (John Maddock).
Modified 11th September 2001 to be excluded when
BOOST_HAS_STDINT_H is defined (John Maddock).
Modified 11th Dec 2009 to always define the
INT#_C macros if they're not already defined (John Maddock).

*****************************************************','line_number':407,'multiline':True]
['text':'','line_number':421,'multiline':False]
['text':' Undef the macros as a precaution, since we may get here if <stdint.h> has failed','line_number':422,'multiline':False]
['text':' to define them all, see https://svn.boost.org/trac/boost/ticket/12786','line_number':423,'multiline':False]
['text':'','line_number':424,'multiline':False]
['text':'','line_number':439,'multiline':False]
['text':' Borland/Intel/Microsoft compilers have width specific suffixes:','line_number':440,'multiline':False]
['text':'','line_number':441,'multiline':False]
['text':' Borland bug: appending ui8 makes the type a signed char','line_number':455,'multiline':False]
['text':'  do it the old fashioned way:','line_number':475,'multiline':False]
['text':'  8-bit types  ------------------------------------------------------------//','line_number':477,'multiline':False]
['text':'  16-bit types  -----------------------------------------------------------//','line_number':484,'multiline':False]
['text':'  32-bit types  -----------------------------------------------------------//','line_number':491,'multiline':False]
['text':'  64-bit types + intmax_t and uintmax_t  ----------------------------------//','line_number':502,'multiline':False]
['text':' HP-UX's value of ULONG_LONG_MAX is unusable in preprocessor expressions','line_number':508,'multiline':False]
['text':' 2**64 - 1','line_number':524,'multiline':False]
['text':' Usual macros not defined, work things out for ourselves:','line_number':531,'multiline':False]
['text':' Borland/Microsoft specific width suffixes','line_number':550,'multiline':False]
['text':' INT#_C macros.','line_number':552,'multiline':False]
