['text':' Copyright 2003-2015 Joaquin M Lopez Munoz.
 * Distributed under the Boost Software License, Version 1.0.
 * (See accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 *
 * See http://www.boost.org/libs/multi_index for library home page.
 ','line_number':1,'multiline':True]
['text':' keep it first to prevent nasty warns in MSVC ','line_number':16,'multiline':True]
['text':' A composite key stores n key extractors and "computes" the
 * result on a given value as a packed reference to the value and
 * the composite key itself. Actual invocations to the component
 * key extractors are lazily performed when executing an operation
 * on composite_key results (equality, comparison, hashing.)
 * As the other key extractors in Boost.MultiIndex, composite_key<T,...>
 * is  overloaded to work on chained pointers to T and reference_wrappers
 * of T.
 ','line_number':47,'multiline':True]
['text':' This user_definable macro limits the number of elements of a composite
 * key; useful for shortening resulting symbol names (MSVC++ 6.0, for
 * instance has problems coping with very long symbol names.)
 * NB: This cannot exceed the maximum number of arguments of
 * boost::tuple. In Boost 1.32, the limit is 10.
 ','line_number':57,'multiline':True]
['text':' maximum number of key extractors in a composite key ','line_number':68,'multiline':True]
['text':' max length of a tuple ','line_number':70,'multiline':True]
['text':' BOOST_PP_ENUM of BOOST_MULTI_INDEX_COMPOSITE_KEY_SIZE elements ','line_number':77,'multiline':True]
['text':' BOOST_PP_ENUM_PARAMS of BOOST_MULTI_INDEX_COMPOSITE_KEY_SIZE elements ','line_number':82,'multiline':True]
['text':' if n==0 ->   text0
 * otherwise -> textn=tuples::null_type
 ','line_number':87,'multiline':True]
['text':' const textn& kn=textn() ','line_number':94,'multiline':True]
['text':' typename list(0)<list(1),n>::type ','line_number':99,'multiline':True]
['text':' fwd decl. ','line_number':108,'multiline':True]
['text':' n-th key extractor of a composite key ','line_number':114,'multiline':True]
['text':' nth_composite_key_##name<CompositeKey,N>::type yields
 * functor<nth_key_from_value<CompositeKey,N> >, or tuples::null_type
 * if N exceeds the length of the composite key.
 ','line_number':127,'multiline':True]
['text':' nth_composite_key_equal_to
 * nth_composite_key_less
 * nth_composite_key_greater
 * nth_composite_key_hash
 ','line_number':152,'multiline':True]
['text':' used for defining equality and comparison ops of composite_key_result ','line_number':163,'multiline':True]
['text':' Metaprogramming machinery for implementing equality, comparison and
 * hashing operations of composite_key_result.
 *
 * equal_* checks for equality between composite_key_results and
 * between those and tuples, accepting a tuple of basic equality functors.
 * compare_* does lexicographical comparison.
 * hash_* computes a combination of elementwise hash values.
 ','line_number':189,'multiline':True]
['text':' fwd decl. ','line_number':204,'multiline':True]
['text':' fwd decl. ','line_number':268,'multiline':True]
['text':' fwd decl. ','line_number':345,'multiline':True]
['text':' fwd decl. ','line_number':410,'multiline':True]
['text':' fwd decl. ','line_number':484,'multiline':True]
['text':' same hashing formula as boost::hash_combine ','line_number':502,'multiline':True]
['text':' fwd decl. ','line_number':523,'multiline':True]
['text':' namespace multi_index::detail ','line_number':558,'multiline':True]
['text':' composite_key_result ','line_number':560,'multiline':True]
['text':' composite_key ','line_number':586,'multiline':True]
['text':' comparison operators ','line_number':643,'multiline':True]
['text':' == ','line_number':645,'multiline':True]
['text':' < ','line_number':769,'multiline':True]
['text':' rest of comparison operators ','line_number':874,'multiline':True]
['text':' composite_key_equal_to ','line_number':935,'multiline':True]
['text':' composite_key_compare ','line_number':1090,'multiline':True]
['text':' composite_key_hash ','line_number':1265,'multiline':True]
['text':' Instantiations of the former functors with "natural" basic components:
 * composite_key_result_equal_to uses std::equal_to of the values.
 * composite_key_result_less     uses std::less.
 * composite_key_result_greater  uses std::greater.
 * composite_key_result_hash     uses boost::hash.
 ','line_number':1341,'multiline':True]
['text':' the argument is a PP list ','line_number':1352,'multiline':True]
['text':' the argument is a PP list ','line_number':1378,'multiline':True]
['text':' the argument is a PP list ','line_number':1404,'multiline':True]
['text':' the argument is a PP list ','line_number':1430,'multiline':True]
['text':' namespace multi_index ','line_number':1451,'multiline':True]
['text':' namespace boost ','line_number':1453,'multiline':True]
['text':' Specializations of std::equal_to, std::less, std::greater and boost::hash
 * for composite_key_results enabling interoperation with tuples of values.
 ','line_number':1455,'multiline':True]
['text':' namespace std ','line_number':1485,'multiline':True]
['text':' namespace boost ','line_number':1497,'multiline':True]
