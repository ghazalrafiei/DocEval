['text':'-----------------------------------------------------------------------------','line_number':1,'multiline':False]
['text':' boost variant/variant_fwd.hpp header file','line_number':2,'multiline':False]
['text':' See http://www.boost.org for updates, documentation, and revision history.','line_number':3,'multiline':False]
['text':'-----------------------------------------------------------------------------','line_number':4,'multiline':False]
['text':'','line_number':5,'multiline':False]
['text':' Copyright (c) 2003 Eric Friedman, Itay Maman','line_number':6,'multiline':False]
['text':' Copyright (c) 2013-2022 Antony Polukhin','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0. (See','line_number':9,'multiline':False]
['text':' accompanying file LICENSE_1_0.txt or copy at','line_number':10,'multiline':False]
['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':11,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':28,'multiline':False]
['text':' macro BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT','line_number':29,'multiline':False]
['text':'','line_number':30,'multiline':False]
['text':' Defined if variant does not support make_variant_over (see below). ','line_number':31,'multiline':False]
['text':'','line_number':32,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':37,'multiline':False]
['text':' macro BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT','line_number':38,'multiline':False]
['text':'','line_number':39,'multiline':False]
['text':' Defined if make_recursive_variant cannot be supported as documented.','line_number':40,'multiline':False]
['text':'','line_number':41,'multiline':False]
['text':' Note: Currently, MPL lambda facility is used as workaround if defined, and','line_number':42,'multiline':False]
['text':' so only types declared w/ MPL lambda workarounds will work.','line_number':43,'multiline':False]
['text':'','line_number':44,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':54,'multiline':False]
['text':' macro BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES','line_number':55,'multiline':False]
['text':'','line_number':56,'multiline':False]
['text':' 
    GCC before 4.0 had no variadic tempaltes; 
    GCC 4.6 has incomplete implementation of variadic templates.

    MSVC2015 Update 1 has variadic templates, but they have issues.

    NOTE: Clang compiler defines __GNUC__
','line_number':58,'multiline':True]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':94,'multiline':False]
['text':' BOOST_VARIANT_ENUM_PARAMS and BOOST_VARIANT_ENUM_SHIFTED_PARAMS','line_number':95,'multiline':False]
['text':'','line_number':96,'multiline':False]
['text':' Convenience macro for enumeration of variant params.','line_number':97,'multiline':False]
['text':' When variadic templates are available expands:','line_number':98,'multiline':False]
['text':'      BOOST_VARIANT_ENUM_PARAMS(class Something)      => class Something0, class... SomethingN','line_number':99,'multiline':False]
['text':'      BOOST_VARIANT_ENUM_PARAMS(typename Something)   => typename Something0, typename... SomethingN','line_number':100,'multiline':False]
['text':'      BOOST_VARIANT_ENUM_PARAMS(Something)            => Something0, SomethingN...','line_number':101,'multiline':False]
['text':'      BOOST_VARIANT_ENUM_PARAMS(Something)            => Something0, SomethingN...','line_number':102,'multiline':False]
['text':'      BOOST_VARIANT_ENUM_SHIFTED_PARAMS(class Something)      => class... SomethingN','line_number':103,'multiline':False]
['text':'      BOOST_VARIANT_ENUM_SHIFTED_PARAMS(typename Something)   => typename... SomethingN','line_number':104,'multiline':False]
['text':'      BOOST_VARIANT_ENUM_SHIFTED_PARAMS(Something)            => SomethingN...','line_number':105,'multiline':False]
['text':'      BOOST_VARIANT_ENUM_SHIFTED_PARAMS(Something)            => SomethingN...','line_number':106,'multiline':False]
['text':'','line_number':107,'multiline':False]
['text':' Rationale: Cleaner, simpler code for clients of variant library. Minimal ','line_number':108,'multiline':False]
['text':' code modifications to move from C++03 to C++11.','line_number':109,'multiline':False]
['text':'','line_number':110,'multiline':False]
['text':' With BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES defined','line_number':111,'multiline':False]
['text':' will be used BOOST_VARIANT_ENUM_PARAMS and BOOST_VARIANT_ENUM_SHIFTED_PARAMS from below `#else`','line_number':112,'multiline':False]
['text':'','line_number':113,'multiline':False]
['text':'','line_number':118,'multiline':True]
['text':'','line_number':122,'multiline':True]
['text':' defined(BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES)','line_number':124,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':126,'multiline':False]
['text':' macro BOOST_VARIANT_LIMIT_TYPES','line_number':127,'multiline':False]
['text':'','line_number':128,'multiline':False]
['text':' Implementation-defined preprocessor symbol describing the actual','line_number':129,'multiline':False]
['text':' length of variant's pseudo-variadic template parameter list.','line_number':130,'multiline':False]
['text':'','line_number':131,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':136,'multiline':False]
['text':' macro BOOST_VARIANT_RECURSIVE_VARIANT_MAX_ARITY','line_number':137,'multiline':False]
['text':'','line_number':138,'multiline':False]
['text':' Exposes maximum allowed arity of class templates with recursive_variant','line_number':139,'multiline':False]
['text':' arguments. That is,','line_number':140,'multiline':False]
['text':'   make_recursive_variant< ..., T<[1], recursive_variant_, ... [N]> >.','line_number':141,'multiline':False]
['text':'','line_number':142,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':147,'multiline':False]
['text':' macro BOOST_VARIANT_ENUM_PARAMS','line_number':148,'multiline':False]
['text':'','line_number':149,'multiline':False]
['text':' Convenience macro for enumeration of BOOST_VARIANT_LIMIT_TYPES params.','line_number':150,'multiline':False]
['text':'','line_number':151,'multiline':False]
['text':' Rationale: Cleaner, simpler code for clients of variant library.','line_number':152,'multiline':False]
['text':'','line_number':153,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':157,'multiline':False]
['text':' macro BOOST_VARIANT_ENUM_SHIFTED_PARAMS','line_number':158,'multiline':False]
['text':'','line_number':159,'multiline':False]
['text':' Convenience macro for enumeration of BOOST_VARIANT_LIMIT_TYPES-1 params.','line_number':160,'multiline':False]
['text':'','line_number':161,'multiline':False]
['text':' BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES workaround','line_number':165,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':172,'multiline':False]
['text':' (detail) class void_ and class template convert_void','line_number':173,'multiline':False]
['text':' ','line_number':174,'multiline':False]
['text':' Provides the mechanism by which void(NN) types are converted to','line_number':175,'multiline':False]
['text':' mpl::void_ (and thus can be passed to mpl::list).','line_number':176,'multiline':False]
['text':'','line_number':177,'multiline':False]
['text':' Rationale: This is particularly needed for the using-declarations','line_number':178,'multiline':False]
['text':' workaround (below), but also to avoid associating mpl namespace with','line_number':179,'multiline':False]
['text':' variant in argument dependent lookups (which used to happen because of','line_number':180,'multiline':False]
['text':' defaulting of template parameters to mpl::void_).','line_number':181,'multiline':False]
['text':'','line_number':182,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':198,'multiline':False]
['text':' (workaround) BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE','line_number':199,'multiline':False]
['text':'','line_number':200,'multiline':False]
['text':' Needed to work around compilers that don't support using-declaration','line_number':201,'multiline':False]
['text':' overloads. (See the variant::initializer workarounds below.)','line_number':202,'multiline':False]
['text':'','line_number':203,'multiline':False]
['text':' (detail) tags voidNN -- NN defined on [0, BOOST_VARIANT_LIMIT_TYPES)','line_number':206,'multiline':False]
['text':'','line_number':207,'multiline':False]
['text':' Defines void types that are each unique and specializations of','line_number':208,'multiline':False]
['text':' convert_void that yields mpl::na for each voidNN type.','line_number':209,'multiline':False]
['text':'','line_number':210,'multiline':False]
['text':'','line_number':220,'multiline':True]
['text':' BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE workaround','line_number':230,'multiline':False]
['text':' namespace detail::variant','line_number':232,'multiline':False]
['text':' defined(BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES)','line_number':236,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':238,'multiline':False]
['text':' (detail) macro BOOST_VARIANT_AUX_DECLARE_PARAM','line_number':239,'multiline':False]
['text':'','line_number':240,'multiline':False]
['text':' Template parameter list for variant and recursive_variant declarations.','line_number':241,'multiline':False]
['text':'','line_number':242,'multiline':False]
['text':'','line_number':248,'multiline':True]
['text':' defined(BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE)','line_number':250,'multiline':False]
['text':'','line_number':254,'multiline':True]
['text':' BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE workaround','line_number':256,'multiline':False]
['text':'','line_number':264,'multiline':True]
['text':' BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES workaround','line_number':266,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':268,'multiline':False]
['text':' class template variant (concept inspired by Andrei Alexandrescu)','line_number':269,'multiline':False]
['text':'','line_number':270,'multiline':False]
['text':' Efficient, type-safe bounded discriminated union.','line_number':271,'multiline':False]
['text':'','line_number':272,'multiline':False]
['text':' Preconditions:','line_number':273,'multiline':False]
['text':'  - Each type must be unique.','line_number':274,'multiline':False]
['text':'  - No type may be const-qualified.','line_number':275,'multiline':False]
['text':'','line_number':276,'multiline':False]
['text':' Proper declaration form:','line_number':277,'multiline':False]
['text':'   variant<types>    (where types is a type-sequence)','line_number':278,'multiline':False]
['text':' or','line_number':279,'multiline':False]
['text':'   variant<T0,T1,...,Tn>  (where T0 is NOT a type-sequence)','line_number':280,'multiline':False]
['text':'','line_number':281,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':284,'multiline':False]
['text':' metafunction make_recursive_variant','line_number':285,'multiline':False]
['text':'','line_number':286,'multiline':False]
['text':' Exposes a boost::variant with recursive_variant_ tags (below) substituted','line_number':287,'multiline':False]
['text':' with the variant itself (wrapped as needed with boost::recursive_wrapper).','line_number':288,'multiline':False]
['text':'','line_number':289,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':295,'multiline':False]
['text':' type recursive_variant_','line_number':296,'multiline':False]
['text':'','line_number':297,'multiline':False]
['text':' Tag type indicates where recursive variant substitution should occur.','line_number':298,'multiline':False]
['text':'','line_number':299,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':306,'multiline':False]
['text':' metafunction make_variant_over','line_number':307,'multiline':False]
['text':'','line_number':308,'multiline':False]
['text':' Result is a variant w/ types of the specified type sequence.','line_number':309,'multiline':False]
['text':'','line_number':310,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':313,'multiline':False]
['text':' metafunction make_recursive_variant_over','line_number':314,'multiline':False]
['text':'','line_number':315,'multiline':False]
['text':' Result is a recursive variant w/ types of the specified type sequence.','line_number':316,'multiline':False]
['text':'','line_number':317,'multiline':False]
['text':' namespace boost','line_number':320,'multiline':False]
['text':' BOOST_VARIANT_VARIANT_FWD_HPP','line_number':322,'multiline':False]
