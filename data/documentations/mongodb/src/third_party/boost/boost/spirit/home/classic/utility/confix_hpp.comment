['text':'=============================================================================
    Copyright (c) 2002-2003 Hartmut Kaiser
    http://spirit.sourceforge.net/

  Distributed under the Boost Software License, Version 1.0. (See accompanying
  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
=============================================================================','line_number':1,'multiline':True]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':11,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':20,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':25,'multiline':False]
['text':'','line_number':26,'multiline':False]
['text':'  confix_parser class','line_number':27,'multiline':False]
['text':'','line_number':28,'multiline':False]
['text':'      Parses a sequence of 3 sub-matches. This class may','line_number':29,'multiline':False]
['text':'      be used to parse structures, where the opening part is possibly','line_number':30,'multiline':False]
['text':'      contained in the expression part and the whole sequence is only','line_number':31,'multiline':False]
['text':'      parsed after seeing the closing part matching the first opening','line_number':32,'multiline':False]
['text':'      subsequence. Example: C-comments:','line_number':33,'multiline':False]
['text':'','line_number':34,'multiline':False]
['text':'      /* This is a C-comment */','line_number':35,'multiline':False]
['text':'','line_number':36,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':37,'multiline':False]
['text':'assignment operator could not be generated','line_number':41,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':83,'multiline':False]
['text':'','line_number':84,'multiline':False]
['text':'  Confix parser generator template','line_number':85,'multiline':False]
['text':'','line_number':86,'multiline':False]
['text':'      This is a helper for generating a correct confix_parser<> from','line_number':87,'multiline':False]
['text':'      auxiliary parameters. There are the following types supported as','line_number':88,'multiline':False]
['text':'      parameters yet: parsers, single characters and strings (see','line_number':89,'multiline':False]
['text':'      as_parser).','line_number':90,'multiline':False]
['text':'','line_number':91,'multiline':False]
['text':'      If the body parser is an action_parser_category type parser (a parser','line_number':92,'multiline':False]
['text':'      with an attached semantic action) we have to do something special. This','line_number':93,'multiline':False]
['text':'      happens, if the user wrote something like:','line_number':94,'multiline':False]
['text':'','line_number':95,'multiline':False]
['text':'          confix_p(open, body[f], close)','line_number':96,'multiline':False]
['text':'','line_number':97,'multiline':False]
['text':'      where 'body' is the parser matching the body of the confix sequence','line_number':98,'multiline':False]
['text':'      and 'f' is a functor to be called after matching the body. If we would','line_number':99,'multiline':False]
['text':'      do nothing, the resulting code would parse the sequence as follows:','line_number':100,'multiline':False]
['text':'','line_number':101,'multiline':False]
['text':'          start >> (body[f] - close) >> close','line_number':102,'multiline':False]
['text':'','line_number':103,'multiline':False]
['text':'      what in most cases is not what the user expects.','line_number':104,'multiline':False]
['text':'      (If this _is_ what you've expected, then please use the confix_p','line_number':105,'multiline':False]
['text':'      generator function 'direct()', which will inhibit','line_number':106,'multiline':False]
['text':'      re-attaching the actor to the body parser).','line_number':107,'multiline':False]
['text':'','line_number':108,'multiline':False]
['text':'      To make the confix parser behave as expected:','line_number':109,'multiline':False]
['text':'','line_number':110,'multiline':False]
['text':'          start >> (body - close)[f] >> close','line_number':111,'multiline':False]
['text':'','line_number':112,'multiline':False]
['text':'      the actor attached to the 'body' parser has to be re-attached to the','line_number':113,'multiline':False]
['text':'      (body - close) parser construct, which will make the resulting confix','line_number':114,'multiline':False]
['text':'      parser 'do the right thing'. This refactoring is done by the help of','line_number':115,'multiline':False]
['text':'      the refactoring parsers (see the files refactoring.[hi]pp).','line_number':116,'multiline':False]
['text':'','line_number':117,'multiline':False]
['text':'      Additionally special care must be taken, if the body parser is a','line_number':118,'multiline':False]
['text':'      unary_parser_category type parser as','line_number':119,'multiline':False]
['text':'','line_number':120,'multiline':False]
['text':'          confix_p(open, *anychar_p, close)','line_number':121,'multiline':False]
['text':'','line_number':122,'multiline':False]
['text':'      which without any refactoring would result in','line_number':123,'multiline':False]
['text':'','line_number':124,'multiline':False]
['text':'          start >> (*anychar_p - close) >> close','line_number':125,'multiline':False]
['text':'','line_number':126,'multiline':False]
['text':'      and will not give the expected result (*anychar_p will eat up all the','line_number':127,'multiline':False]
['text':'      input up to the end of the input stream). So we have to refactor this','line_number':128,'multiline':False]
['text':'      into:','line_number':129,'multiline':False]
['text':'','line_number':130,'multiline':False]
['text':'          start >> *(anychar_p - close) >> close','line_number':131,'multiline':False]
['text':'','line_number':132,'multiline':False]
['text':'      what will give the correct result.','line_number':133,'multiline':False]
['text':'','line_number':134,'multiline':False]
['text':'      The case, where the body parser is a combination of the two mentioned','line_number':135,'multiline':False]
['text':'      problems (i.e. the body parser is a unary parser  with an attached','line_number':136,'multiline':False]
['text':'      action), is handled accordingly too:','line_number':137,'multiline':False]
['text':'','line_number':138,'multiline':False]
['text':'          confix_p(start, (*anychar_p)[f], end)','line_number':139,'multiline':False]
['text':'','line_number':140,'multiline':False]
['text':'      will be parsed as expected:','line_number':141,'multiline':False]
['text':'','line_number':142,'multiline':False]
['text':'          start >> (*(anychar_p - end))[f] >> end.','line_number':143,'multiline':False]
['text':'','line_number':144,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':145,'multiline':False]
['text':' Generic generator function for creation of concrete confix parsers','line_number':150,'multiline':False]
['text':' Generic generator function for creation of concrete confix parsers','line_number':179,'multiline':False]
['text':' which have an action directly attached to the ExprT part of the','line_number':180,'multiline':False]
['text':' parser (see comment above, no automatic refactoring)','line_number':181,'multiline':False]
['text':' do not re-attach action','line_number':190,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':211,'multiline':False]
['text':'','line_number':212,'multiline':False]
['text':'  Predefined non_nested confix parser generators','line_number':213,'multiline':False]
['text':'','line_number':214,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':215,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':220,'multiline':False]
['text':'','line_number':221,'multiline':False]
['text':'  Comments are special types of confix parsers','line_number':222,'multiline':False]
['text':'','line_number':223,'multiline':False]
['text':'      Comment parser generator template. This is a helper for generating a','line_number':224,'multiline':False]
['text':'      correct confix_parser<> from auxiliary parameters, which is able to','line_number':225,'multiline':False]
['text':'      parse comment constructs: (StartToken >> Comment text >> EndToken).','line_number':226,'multiline':False]
['text':'','line_number':227,'multiline':False]
['text':'      There are the following types supported as parameters yet: parsers,','line_number':228,'multiline':False]
['text':'      single characters and strings (see as_parser).','line_number':229,'multiline':False]
['text':'','line_number':230,'multiline':False]
['text':'      There are two diffenerent predefined comment parser generators','line_number':231,'multiline':False]
['text':'      (comment_p and comment_nest_p, see below), which may be used for','line_number':232,'multiline':False]
['text':'      creating special comment parsers in two different ways.','line_number':233,'multiline':False]
['text':'','line_number':234,'multiline':False]
['text':'      If these are used with one parameter, a comment starting with the given','line_number':235,'multiline':False]
['text':'      first parser parameter up to the end of the line is matched. So for','line_number':236,'multiline':False]
['text':'      instance the following parser matches C++ style comments:','line_number':237,'multiline':False]
['text':'','line_number':238,'multiline':False]
['text':'          comment_p("//").','line_number':239,'multiline':False]
['text':'','line_number':240,'multiline':False]
['text':'      If these are used with two parameters, a comment starting with the','line_number':241,'multiline':False]
['text':'      first parser parameter up to the second parser parameter is matched.','line_number':242,'multiline':False]
['text':'      For instance a C style comment parser should be constrcuted as:','line_number':243,'multiline':False]
['text':'','line_number':244,'multiline':False]
['text':'          comment_p("/*", "*/").','line_number':245,'multiline':False]
['text':'','line_number':246,'multiline':False]
['text':'      Please note, that a comment is parsed implicitly as if the whole','line_number':247,'multiline':False]
['text':'      comment_p(...) statement were embedded into a lexeme_d[] directive.','line_number':248,'multiline':False]
['text':'','line_number':249,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':250,'multiline':False]
['text':' Generic generator function for creation of concrete comment parsers','line_number':255,'multiline':False]
['text':' from an open token. The newline parser eol_p is used as the','line_number':256,'multiline':False]
['text':' closing token.','line_number':257,'multiline':False]
['text':' there is no action to re-attach','line_number':266,'multiline':False]
['text':' insert implicit lexeme_d[]','line_number':268,'multiline':False]
['text':' Generic generator function for creation of concrete comment parsers','line_number':287,'multiline':False]
['text':' from an open and a close tokens.','line_number':288,'multiline':False]
['text':' there is no action to re-attach','line_number':297,'multiline':False]
['text':' insert implicit lexeme_d[]','line_number':299,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':318,'multiline':False]
['text':'','line_number':319,'multiline':False]
['text':'  Predefined non_nested comment parser generator','line_number':320,'multiline':False]
['text':'','line_number':321,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':322,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':327,'multiline':False]
['text':'','line_number':328,'multiline':False]
['text':'  comment_nest_parser class','line_number':329,'multiline':False]
['text':'','line_number':330,'multiline':False]
['text':'      Parses a nested comments.','line_number':331,'multiline':False]
['text':'      Example: nested PASCAL-comments:','line_number':332,'multiline':False]
['text':'','line_number':333,'multiline':False]
['text':'      { This is a { nested } PASCAL-comment }','line_number':334,'multiline':False]
['text':'','line_number':335,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':336,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':372,'multiline':False]
['text':'','line_number':373,'multiline':False]
['text':'  Predefined nested comment parser generator','line_number':374,'multiline':False]
['text':'','line_number':375,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':376,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':400,'multiline':False]
['text':' namespace BOOST_SPIRIT_CLASSIC_NS','line_number':403,'multiline':False]
