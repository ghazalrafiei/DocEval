['text':'=============================================================================
    Copyright (c) 1998-2003 Joel de Guzman
    Copyright (c) 2001-2003 Hartmut Kaiser
    http://spirit.sourceforge.net/

    Use, modification and distribution is subject to the Boost Software
    License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
=============================================================================','line_number':1,'multiline':True]
['text':' forward declaration only','line_number':20,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':24,'multiline':False]
['text':'','line_number':25,'multiline':False]
['text':'  Extract the prefix sign (- or +)','line_number':26,'multiline':False]
['text':'','line_number':27,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':28,'multiline':False]
['text':'  Extract the sign','line_number':33,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':46,'multiline':False]
['text':'','line_number':47,'multiline':False]
['text':'  Traits class for radix specific number conversion','line_number':48,'multiline':False]
['text':'','line_number':49,'multiline':False]
['text':'      Convert a digit from character representation, ch, to binary','line_number':50,'multiline':False]
['text':'      representation, returned in val.','line_number':51,'multiline':False]
['text':'      Returns whether the conversion was successful.','line_number':52,'multiline':False]
['text':'','line_number':53,'multiline':False]
['text':'        template<typename CharT> static bool digit(CharT ch, T& val);','line_number':54,'multiline':False]
['text':'','line_number':55,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':56,'multiline':False]
['text':'//////////////////////////////// Binary','line_number':60,'multiline':False]
['text':'//////////////////////////////// Octal','line_number':72,'multiline':False]
['text':'//////////////////////////////// Decimal','line_number':84,'multiline':False]
['text':'//////////////////////////////// Hexadecimal','line_number':96,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':116,'multiline':False]
['text':'','line_number':117,'multiline':False]
['text':'      Helper templates for encapsulation of radix specific','line_number':118,'multiline':False]
['text':'      conversion of an input string to an integral value.','line_number':119,'multiline':False]
['text':'','line_number':120,'multiline':False]
['text':'      main entry point:','line_number':121,'multiline':False]
['text':'','line_number':122,'multiline':False]
['text':'          extract_int<Radix, MinDigits, MaxDigits, Accumulate>','line_number':123,'multiline':False]
['text':'              ::f(first, last, n, count);','line_number':124,'multiline':False]
['text':'','line_number':125,'multiline':False]
['text':'          The template parameter Radix represents the radix of the','line_number':126,'multiline':False]
['text':'          number contained in the parsed string. The template','line_number':127,'multiline':False]
['text':'          parameter MinDigits specifies the minimum digits to','line_number':128,'multiline':False]
['text':'          accept. The template parameter MaxDigits specifies the','line_number':129,'multiline':False]
['text':'          maximum digits to parse. A -1 value for MaxDigits will','line_number':130,'multiline':False]
['text':'          make it parse an arbitrarilly large number as long as the','line_number':131,'multiline':False]
['text':'          numeric type can hold it. Accumulate is either','line_number':132,'multiline':False]
['text':'          positive_accumulate<Radix> (default) for parsing positive','line_number':133,'multiline':False]
['text':'          numbers or negative_accumulate<Radix> otherwise.','line_number':134,'multiline':False]
['text':'          Checking is only performed when std::numeric_limits<T>::','line_number':135,'multiline':False]
['text':'          is_specialized is true. Otherwise, there's no way to','line_number':136,'multiline':False]
['text':'          do the check.','line_number':137,'multiline':False]
['text':'','line_number':138,'multiline':False]
['text':'          scan.first and scan.last are iterators as usual (i.e.','line_number':139,'multiline':False]
['text':'          first is mutable and is moved forward when a match is','line_number':140,'multiline':False]
['text':'          found), n is a variable that holds the number (passed by','line_number':141,'multiline':False]
['text':'          reference). The number of parsed characters is added to','line_number':142,'multiline':False]
['text':'          count (also passed by reference)','line_number':143,'multiline':False]
['text':'','line_number':144,'multiline':False]
['text':'      NOTE:','line_number':145,'multiline':False]
['text':'              Returns a non-match, if the number to parse','line_number':146,'multiline':False]
['text':'              overflows (or underflows) the used type.','line_number':147,'multiline':False]
['text':'','line_number':148,'multiline':False]
['text':'      BEWARE:','line_number':149,'multiline':False]
['text':'              the parameters 'n' and 'count' should be properly','line_number':150,'multiline':False]
['text':'              initialized before calling this function.','line_number':151,'multiline':False]
['text':'','line_number':152,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':153,'multiline':False]
['text':'conditional expression is constant','line_number':156,'multiline':False]
['text':'  Use this accumulator if number is positive','line_number':162,'multiline':False]
['text':'  Use this accumulator if number is negative','line_number':192,'multiline':False]
['text':'////////////////////////////////','line_number':234,'multiline':False]
['text':' Overflow','line_number':251,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':258,'multiline':False]
['text':'','line_number':259,'multiline':False]
['text':'  uint_parser_impl class','line_number':260,'multiline':False]
['text':'','line_number':261,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':262,'multiline':False]
['text':' return no-match if number overflows','line_number':294,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':300,'multiline':False]
['text':'','line_number':301,'multiline':False]
['text':'  int_parser_impl class','line_number':302,'multiline':False]
['text':'','line_number':303,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':304,'multiline':False]
['text':' return no-match if number overflows or underflows','line_number':348,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':354,'multiline':False]
['text':'','line_number':355,'multiline':False]
['text':'  real_parser_impl class','line_number':356,'multiline':False]
['text':'','line_number':357,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':358,'multiline':False]
['text':'  We got the decimal point. Now we will try to parse','line_number':397,'multiline':False]
['text':'  the fraction if it is there. If not, it defaults','line_number':398,'multiline':False]
['text':'  to zero (0) only if we already got a number.','line_number':399,'multiline':False]
['text':' allow for ADL to find pow()','line_number':404,'multiline':False]
['text':'  We have reached a point where we','line_number':424,'multiline':False]
['text':'  still haven't seen a number at all.','line_number':425,'multiline':False]
['text':'  We return early with a no-match.','line_number':426,'multiline':False]
['text':'  If we must expect a dot and we didn't see','line_number':430,'multiline':False]
['text':'  an exponent, return early with a no-match.','line_number':431,'multiline':False]
['text':'  We got the exponent prefix. Now we will try to parse the','line_number':439,'multiline':False]
['text':'  actual exponent. It is an error if it is not there.','line_number':440,'multiline':False]
['text':' allow for ADL to find pow()','line_number':444,'multiline':False]
['text':'  Oops, no exponent, return a no-match','line_number':451,'multiline':False]
['text':'  namespace impl','line_number':471,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':473,'multiline':False]
['text':' namespace boost::spirit','line_number':476,'multiline':False]
