['text':'=============================================================================
    Phoenix V1.2.1
    Copyright (c) 2001-2002 Joel de Guzman
    MT code Copyright (c) 2002-2003 Martin Wille

  Distributed under the Boost Software License, Version 1.0. (See accompanying
  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
==============================================================================','line_number':1,'multiline':True]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':12,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':21,'multiline':False]
['text':'assignment operator could not be generated','line_number':26,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':29,'multiline':False]
['text':'','line_number':30,'multiline':False]
['text':'  Adaptable closures','line_number':31,'multiline':False]
['text':'','line_number':32,'multiline':False]
['text':'      The framework will not be complete without some form of closures','line_number':33,'multiline':False]
['text':'      support. Closures encapsulate a stack frame where local','line_number':34,'multiline':False]
['text':'      variables are created upon entering a function and destructed','line_number':35,'multiline':False]
['text':'      upon exiting. Closures provide an environment for local','line_number':36,'multiline':False]
['text':'      variables to reside. Closures can hold heterogeneous types.','line_number':37,'multiline':False]
['text':'','line_number':38,'multiline':False]
['text':'      Phoenix closures are true hardware stack based closures. At the','line_number':39,'multiline':False]
['text':'      very least, closures enable true reentrancy in lambda functions.','line_number':40,'multiline':False]
['text':'      A closure provides access to a function stack frame where local','line_number':41,'multiline':False]
['text':'      variables reside. Modeled after Pascal nested stack frames,','line_number':42,'multiline':False]
['text':'      closures can be nested just like nested functions where code in','line_number':43,'multiline':False]
['text':'      inner closures may access local variables from in-scope outer','line_number':44,'multiline':False]
['text':'      closures (accessing inner scopes from outer scopes is an error','line_number':45,'multiline':False]
['text':'      and will cause a run-time assertion failure).','line_number':46,'multiline':False]
['text':'','line_number':47,'multiline':False]
['text':'      There are three (3) interacting classes:','line_number':48,'multiline':False]
['text':'','line_number':49,'multiline':False]
['text':'      1) closure:','line_number':50,'multiline':False]
['text':'','line_number':51,'multiline':False]
['text':'      At the point of declaration, a closure does not yet create a','line_number':52,'multiline':False]
['text':'      stack frame nor instantiate any variables. A closure declaration','line_number':53,'multiline':False]
['text':'      declares the types and names[note] of the local variables. The','line_number':54,'multiline':False]
['text':'      closure class is meant to be subclassed. It is the','line_number':55,'multiline':False]
['text':'      responsibility of a closure subclass to supply the names for','line_number':56,'multiline':False]
['text':'      each of the local variable in the closure. Example:','line_number':57,'multiline':False]
['text':'','line_number':58,'multiline':False]
['text':'          struct my_closure : closure<int, string, double> {','line_number':59,'multiline':False]
['text':'','line_number':60,'multiline':False]
['text':'              member1 num;        // names the 1st (int) local variable','line_number':61,'multiline':False]
['text':'              member2 message;    // names the 2nd (string) local variable','line_number':62,'multiline':False]
['text':'              member3 real;       // names the 3rd (double) local variable','line_number':63,'multiline':False]
['text':'          };','line_number':64,'multiline':False]
['text':'','line_number':65,'multiline':False]
['text':'          my_closure clos;','line_number':66,'multiline':False]
['text':'','line_number':67,'multiline':False]
['text':'      Now that we have a closure 'clos', its local variables can be','line_number':68,'multiline':False]
['text':'      accessed lazily using the dot notation. Each qualified local','line_number':69,'multiline':False]
['text':'      variable can be used just like any primitive actor (see','line_number':70,'multiline':False]
['text':'      primitives.hpp). Examples:','line_number':71,'multiline':False]
['text':'','line_number':72,'multiline':False]
['text':'          clos.num = 30','line_number':73,'multiline':False]
['text':'          clos.message = arg1','line_number':74,'multiline':False]
['text':'          clos.real = clos.num * 1e6','line_number':75,'multiline':False]
['text':'','line_number':76,'multiline':False]
['text':'      The examples above are lazily evaluated. As usual, these','line_number':77,'multiline':False]
['text':'      expressions return composite actors that will be evaluated','line_number':78,'multiline':False]
['text':'      through a second function call invocation (see operators.hpp).','line_number':79,'multiline':False]
['text':'      Each of the members (clos.xxx) is an actor. As such, applying','line_number':80,'multiline':False]
['text':'      the operator() will reveal its identity:','line_number':81,'multiline':False]
['text':'','line_number':82,'multiline':False]
['text':'          clos.num() // will return the current value of clos.num','line_number':83,'multiline':False]
['text':'','line_number':84,'multiline':False]
['text':'      *** [note] Acknowledgement: Juan Carlos Arevalo-Baeza (JCAB)','line_number':85,'multiline':False]
['text':'      introduced and initilally implemented the closure member names','line_number':86,'multiline':False]
['text':'      that uses the dot notation.','line_number':87,'multiline':False]
['text':'','line_number':88,'multiline':False]
['text':'      2) closure_member','line_number':89,'multiline':False]
['text':'','line_number':90,'multiline':False]
['text':'      The named local variables of closure 'clos' above are actually','line_number':91,'multiline':False]
['text':'      closure members. The closure_member class is an actor and','line_number':92,'multiline':False]
['text':'      conforms to its conceptual interface. member1..memberN are','line_number':93,'multiline':False]
['text':'      predefined typedefs that correspond to each of the listed types','line_number':94,'multiline':False]
['text':'      in the closure template parameters.','line_number':95,'multiline':False]
['text':'','line_number':96,'multiline':False]
['text':'      3) closure_frame','line_number':97,'multiline':False]
['text':'','line_number':98,'multiline':False]
['text':'      When a closure member is finally evaluated, it should refer to','line_number':99,'multiline':False]
['text':'      an actual instance of the variable in the hardware stack.','line_number':100,'multiline':False]
['text':'      Without doing so, the process is not complete and the evaluated','line_number':101,'multiline':False]
['text':'      member will result to an assertion failure. Remember that the','line_number':102,'multiline':False]
['text':'      closure is just a declaration. The local variables that a','line_number':103,'multiline':False]
['text':'      closure refers to must still be instantiated.','line_number':104,'multiline':False]
['text':'','line_number':105,'multiline':False]
['text':'      The closure_frame class does the actual instantiation of the','line_number':106,'multiline':False]
['text':'      local variables and links these variables with the closure and','line_number':107,'multiline':False]
['text':'      all its members. There can be multiple instances of','line_number':108,'multiline':False]
['text':'      closure_frames typically situated in the stack inside a','line_number':109,'multiline':False]
['text':'      function. Each closure_frame instance initiates a stack frame','line_number':110,'multiline':False]
['text':'      with a new set of closure local variables. Example:','line_number':111,'multiline':False]
['text':'','line_number':112,'multiline':False]
['text':'          void foo()','line_number':113,'multiline':False]
['text':'          {','line_number':114,'multiline':False]
['text':'              closure_frame<my_closure> frame(clos);','line_number':115,'multiline':False]
['text':'              /* do something */','line_number':116,'multiline':False]
['text':'          }','line_number':117,'multiline':False]
['text':'','line_number':118,'multiline':False]
['text':'      where 'clos' is an instance of our closure 'my_closure' above.','line_number':119,'multiline':False]
['text':'      Take note that the usage above precludes locally declared','line_number':120,'multiline':False]
['text':'      classes. If my_closure is a locally declared type, we can still','line_number':121,'multiline':False]
['text':'      use its self_type as a parameter to closure_frame:','line_number':122,'multiline':False]
['text':'','line_number':123,'multiline':False]
['text':'          closure_frame<my_closure::self_type> frame(clos);','line_number':124,'multiline':False]
['text':'','line_number':125,'multiline':False]
['text':'      Upon instantiation, the closure_frame links the local variables','line_number':126,'multiline':False]
['text':'      to the closure. The previous link to another closure_frame','line_number':127,'multiline':False]
['text':'      instance created before is saved. Upon destruction, the','line_number':128,'multiline':False]
['text':'      closure_frame unlinks itself from the closure and relinks the','line_number':129,'multiline':False]
['text':'      preceding closure_frame prior to this instance.','line_number':130,'multiline':False]
['text':'','line_number':131,'multiline':False]
['text':'      The local variables in the closure 'clos' above is default','line_number':132,'multiline':False]
['text':'      constructed in the stack inside function 'foo'. Once 'foo' is','line_number':133,'multiline':False]
['text':'      exited, all of these local variables are destructed. In some','line_number':134,'multiline':False]
['text':'      cases, default construction is not desirable and we need to','line_number':135,'multiline':False]
['text':'      initialize the local closure variables with some values. This','line_number':136,'multiline':False]
['text':'      can be done by passing in the initializers in a compatible','line_number':137,'multiline':False]
['text':'      tuple. A compatible tuple is one with the same number of','line_number':138,'multiline':False]
['text':'      elements as the destination and where each element from the','line_number':139,'multiline':False]
['text':'      destination can be constructed from each corresponding element','line_number':140,'multiline':False]
['text':'      in the source. Example:','line_number':141,'multiline':False]
['text':'','line_number':142,'multiline':False]
['text':'          tuple<int, char const*, int> init(123, "Hello", 1000);','line_number':143,'multiline':False]
['text':'          closure_frame<my_closure> frame(clos, init);','line_number':144,'multiline':False]
['text':'','line_number':145,'multiline':False]
['text':'      Here now, our closure_frame's variables are initialized with','line_number':146,'multiline':False]
['text':'      int: 123, char const*: "Hello" and int: 1000.','line_number':147,'multiline':False]
['text':'','line_number':148,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':149,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////','line_number':153,'multiline':False]
['text':' closure_frame_holder is a simple class that encapsulates the','line_number':154,'multiline':False]
['text':' storage for a frame pointer. It uses thread specific data in','line_number':155,'multiline':False]
['text':' case when multithreading is enabled, an ordinary pointer otherwise','line_number':156,'multiline':False]
['text':'','line_number':157,'multiline':False]
['text':' it has get() and set() member functions. set() has to be used','line_number':158,'multiline':False]
['text':' _after_ get(). get() contains intialisation code in the multi','line_number':159,'multiline':False]
['text':' threading case','line_number':160,'multiline':False]
['text':'','line_number':161,'multiline':False]
['text':' closure_frame_holder is used by the closure<> class to store','line_number':162,'multiline':False]
['text':' the pointer to the current frame.','line_number':163,'multiline':False]
['text':'','line_number':164,'multiline':False]
['text':' no copies, no assignments','line_number':180,'multiline':False]
['text':' no copies, no assignments','line_number':207,'multiline':False]
['text':' namespace phoenix::impl','line_number':212,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':214,'multiline':False]
['text':'','line_number':215,'multiline':False]
['text':'  closure_frame class','line_number':216,'multiline':False]
['text':'','line_number':217,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':218,'multiline':False]
['text':' no copy','line_number':238,'multiline':False]
['text':' no assign','line_number':239,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':245,'multiline':False]
['text':'','line_number':246,'multiline':False]
['text':'  closure_member class','line_number':247,'multiline':False]
['text':'','line_number':248,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':249,'multiline':False]
['text':'args','line_number':270,'multiline':True]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':282,'multiline':False]
['text':'','line_number':283,'multiline':False]
['text':'  closure class','line_number':284,'multiline':False]
['text':'','line_number':285,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':286,'multiline':False]
['text':' no copy','line_number':391,'multiline':False]
['text':' no assign','line_number':392,'multiline':False]
['text':'  namespace phoenix','line_number':449,'multiline':False]
