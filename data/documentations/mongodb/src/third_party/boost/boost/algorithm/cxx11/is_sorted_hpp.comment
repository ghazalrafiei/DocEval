['text':'  Copyright (c) 2010 Nuovation System Designs, LLC','line_number':1,'multiline':False]
['text':'    Grant Erickson <gerickson@nuovations.com>','line_number':2,'multiline':False]
['text':'','line_number':3,'multiline':False]
['text':'  Reworked somewhat by Marshall Clow; August 2010','line_number':4,'multiline':False]
['text':'  ','line_number':5,'multiline':False]
['text':'  Distributed under the Boost Software License, Version 1.0. (See','line_number':6,'multiline':False]
['text':'  accompanying file LICENSE_1_0.txt or copy at','line_number':7,'multiline':False]
['text':'  http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]
['text':'','line_number':9,'multiline':False]
['text':'  See http://www.boost.org/ for latest version.','line_number':10,'multiline':False]
['text':'','line_number':11,'multiline':False]
['text':'/ \fn is_sorted_until ( ForwardIterator first, ForwardIterator last, Pred p )','line_number':29,'multiline':False]
['text':'/ \return the point in the sequence [first, last) where the elements are unordered','line_number':30,'multiline':False]
['text':'/     (according to the comparison predicate 'p').','line_number':31,'multiline':False]
['text':'/ ','line_number':32,'multiline':False]
['text':'/ \param first The start of the sequence to be tested.','line_number':33,'multiline':False]
['text':'/ \param last  One past the end of the sequence','line_number':34,'multiline':False]
['text':'/ \param p     A binary predicate that returns true if two elements are ordered.','line_number':35,'multiline':False]
['text':'/','line_number':36,'multiline':False]
['text':' the empty sequence is ordered','line_number':40,'multiline':False]
['text':'/ \fn is_sorted_until ( ForwardIterator first, ForwardIterator last )','line_number':51,'multiline':False]
['text':'/ \return the point in the sequence [first, last) where the elements are unordered','line_number':52,'multiline':False]
['text':'/ ','line_number':53,'multiline':False]
['text':'/ \param first The start of the sequence to be tested.','line_number':54,'multiline':False]
['text':'/ \param last  One past the end of the sequence','line_number':55,'multiline':False]
['text':'/','line_number':56,'multiline':False]
['text':'/ \fn is_sorted ( ForwardIterator first, ForwardIterator last, Pred p )','line_number':65,'multiline':False]
['text':'/ \return whether or not the entire sequence is sorted','line_number':66,'multiline':False]
['text':'/ ','line_number':67,'multiline':False]
['text':'/ \param first The start of the sequence to be tested.','line_number':68,'multiline':False]
['text':'/ \param last  One past the end of the sequence','line_number':69,'multiline':False]
['text':'/ \param p     A binary predicate that returns true if two elements are ordered.','line_number':70,'multiline':False]
['text':'/','line_number':71,'multiline':False]
['text':'/ \fn is_sorted ( ForwardIterator first, ForwardIterator last )','line_number':78,'multiline':False]
['text':'/ \return whether or not the entire sequence is sorted','line_number':79,'multiline':False]
['text':'/ ','line_number':80,'multiline':False]
['text':'/ \param first The start of the sequence to be tested.','line_number':81,'multiline':False]
['text':'/ \param last  One past the end of the sequence','line_number':82,'multiline':False]
['text':'/','line_number':83,'multiline':False]
['text':'/','line_number':90,'multiline':False]
['text':'/ -- Range based versions of the C++11 functions','line_number':91,'multiline':False]
['text':'/','line_number':92,'multiline':False]
['text':'/ \fn is_sorted_until ( const R &range, Pred p )','line_number':94,'multiline':False]
['text':'/ \return the point in the range R where the elements are unordered','line_number':95,'multiline':False]
['text':'/     (according to the comparison predicate 'p').','line_number':96,'multiline':False]
['text':'/ ','line_number':97,'multiline':False]
['text':'/ \param range The range to be tested.','line_number':98,'multiline':False]
['text':'/ \param p     A binary predicate that returns true if two elements are ordered.','line_number':99,'multiline':False]
['text':'/','line_number':100,'multiline':False]
['text':'/ \fn is_sorted_until ( const R &range )','line_number':111,'multiline':False]
['text':'/ \return the point in the range R where the elements are unordered','line_number':112,'multiline':False]
['text':'/ ','line_number':113,'multiline':False]
['text':'/ \param range The range to be tested.','line_number':114,'multiline':False]
['text':'/','line_number':115,'multiline':False]
['text':'/ \fn is_sorted ( const R &range, Pred p )','line_number':122,'multiline':False]
['text':'/ \return whether or not the entire range R is sorted','line_number':123,'multiline':False]
['text':'/     (according to the comparison predicate 'p').','line_number':124,'multiline':False]
['text':'/ ','line_number':125,'multiline':False]
['text':'/ \param range The range to be tested.','line_number':126,'multiline':False]
['text':'/ \param p     A binary predicate that returns true if two elements are ordered.','line_number':127,'multiline':False]
['text':'/','line_number':128,'multiline':False]
['text':'/ \fn is_sorted ( const R &range )','line_number':137,'multiline':False]
['text':'/ \return whether or not the entire range R is sorted','line_number':138,'multiline':False]
['text':'/ ','line_number':139,'multiline':False]
['text':'/ \param range The range to be tested.','line_number':140,'multiline':False]
['text':'/','line_number':141,'multiline':False]
['text':'/','line_number':149,'multiline':False]
['text':'/ -- Range based versions of the C++11 functions','line_number':150,'multiline':False]
['text':'/','line_number':151,'multiline':False]
['text':'/ \fn is_increasing ( ForwardIterator first, ForwardIterator last )','line_number':153,'multiline':False]
['text':'/ \return true if the entire sequence is increasing; i.e, each item is greater than or  ','line_number':154,'multiline':False]
['text':'/     equal to the previous one.','line_number':155,'multiline':False]
['text':'/ ','line_number':156,'multiline':False]
['text':'/ \param first The start of the sequence to be tested.','line_number':157,'multiline':False]
['text':'/ \param last  One past the end of the sequence','line_number':158,'multiline':False]
['text':'/','line_number':159,'multiline':False]
['text':'/ \note This function will return true for sequences that contain items that compare','line_number':160,'multiline':False]
['text':'/     equal. If that is not what you intended, you should use is_strictly_increasing instead.','line_number':161,'multiline':False]
['text':'/ \fn is_increasing ( const R &range )','line_number':170,'multiline':False]
['text':'/ \return true if the entire sequence is increasing; i.e, each item is greater than or  ','line_number':171,'multiline':False]
['text':'/     equal to the previous one.','line_number':172,'multiline':False]
['text':'/ ','line_number':173,'multiline':False]
['text':'/ \param range The range to be tested.','line_number':174,'multiline':False]
['text':'/','line_number':175,'multiline':False]
['text':'/ \note This function will return true for sequences that contain items that compare','line_number':176,'multiline':False]
['text':'/     equal. If that is not what you intended, you should use is_strictly_increasing instead.','line_number':177,'multiline':False]
['text':'/ \fn is_decreasing ( ForwardIterator first, ForwardIterator last )','line_number':186,'multiline':False]
['text':'/ \return true if the entire sequence is decreasing; i.e, each item is less than ','line_number':187,'multiline':False]
['text':'/     or equal to the previous one.','line_number':188,'multiline':False]
['text':'/ ','line_number':189,'multiline':False]
['text':'/ \param first The start of the sequence to be tested.','line_number':190,'multiline':False]
['text':'/ \param last  One past the end of the sequence','line_number':191,'multiline':False]
['text':'/','line_number':192,'multiline':False]
['text':'/ \note This function will return true for sequences that contain items that compare','line_number':193,'multiline':False]
['text':'/     equal. If that is not what you intended, you should use is_strictly_decreasing instead.','line_number':194,'multiline':False]
['text':'/ \fn is_decreasing ( const R &range )','line_number':202,'multiline':False]
['text':'/ \return true if the entire sequence is decreasing; i.e, each item is less than ','line_number':203,'multiline':False]
['text':'/     or equal to the previous one.','line_number':204,'multiline':False]
['text':'/ ','line_number':205,'multiline':False]
['text':'/ \param range The range to be tested.','line_number':206,'multiline':False]
['text':'/','line_number':207,'multiline':False]
['text':'/ \note This function will return true for sequences that contain items that compare','line_number':208,'multiline':False]
['text':'/     equal. If that is not what you intended, you should use is_strictly_decreasing instead.','line_number':209,'multiline':False]
['text':'/ \fn is_strictly_increasing ( ForwardIterator first, ForwardIterator last )','line_number':218,'multiline':False]
['text':'/ \return true if the entire sequence is strictly increasing; i.e, each item is greater','line_number':219,'multiline':False]
['text':'/     than the previous one','line_number':220,'multiline':False]
['text':'/ ','line_number':221,'multiline':False]
['text':'/ \param first The start of the sequence to be tested.','line_number':222,'multiline':False]
['text':'/ \param last  One past the end of the sequence','line_number':223,'multiline':False]
['text':'/','line_number':224,'multiline':False]
['text':'/ \note This function will return false for sequences that contain items that compare','line_number':225,'multiline':False]
['text':'/     equal. If that is not what you intended, you should use is_increasing instead.','line_number':226,'multiline':False]
['text':'/ \fn is_strictly_increasing ( const R &range )','line_number':234,'multiline':False]
['text':'/ \return true if the entire sequence is strictly increasing; i.e, each item is greater','line_number':235,'multiline':False]
['text':'/     than the previous one','line_number':236,'multiline':False]
['text':'/ ','line_number':237,'multiline':False]
['text':'/ \param range The range to be tested.','line_number':238,'multiline':False]
['text':'/','line_number':239,'multiline':False]
['text':'/ \note This function will return false for sequences that contain items that compare','line_number':240,'multiline':False]
['text':'/     equal. If that is not what you intended, you should use is_increasing instead.','line_number':241,'multiline':False]
['text':'/ \fn is_strictly_decreasing ( ForwardIterator first, ForwardIterator last )','line_number':249,'multiline':False]
['text':'/ \return true if the entire sequence is strictly decreasing; i.e, each item is less than','line_number':250,'multiline':False]
['text':'/     the previous one','line_number':251,'multiline':False]
['text':'/ ','line_number':252,'multiline':False]
['text':'/ \param first The start of the sequence to be tested.','line_number':253,'multiline':False]
['text':'/ \param last  One past the end of the sequence','line_number':254,'multiline':False]
['text':'/','line_number':255,'multiline':False]
['text':'/ \note This function will return false for sequences that contain items that compare','line_number':256,'multiline':False]
['text':'/     equal. If that is not what you intended, you should use is_decreasing instead.','line_number':257,'multiline':False]
['text':'/ \fn is_strictly_decreasing ( const R &range )','line_number':265,'multiline':False]
['text':'/ \return true if the entire sequence is strictly decreasing; i.e, each item is less than','line_number':266,'multiline':False]
['text':'/     the previous one','line_number':267,'multiline':False]
['text':'/ ','line_number':268,'multiline':False]
['text':'/ \param range The range to be tested.','line_number':269,'multiline':False]
['text':'/','line_number':270,'multiline':False]
['text':'/ \note This function will return false for sequences that contain items that compare','line_number':271,'multiline':False]
['text':'/     equal. If that is not what you intended, you should use is_decreasing instead.','line_number':272,'multiline':False]
['text':' namespace boost','line_number':279,'multiline':False]
['text':' BOOST_ALGORITHM_ORDERED_HPP','line_number':281,'multiline':False]
