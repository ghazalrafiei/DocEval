['text':'  (C) Copyright John Maddock 2006.','line_number':1,'multiline':False]
['text':'  Use, modification and distribution are subject to the','line_number':2,'multiline':False]
['text':'  Boost Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':4,'multiline':False]
['text':'','line_number':30,'multiline':False]
['text':' Implementation of Beta(a,b) using the Lanczos approximation:','line_number':31,'multiline':False]
['text':'','line_number':32,'multiline':False]
['text':' for ADL of std names','line_number':36,'multiline':False]
['text':' Special cases:','line_number':48,'multiline':False]
['text':'
   //
   // This code appears to be no longer necessary: it was
   // used to offset errors introduced from the Lanczos
   // approximation, but the current Lanczos approximations
   // are sufficiently accurate for all z that we can ditch
   // this.  It remains in the file for future reference...
   //
   // If a or b are less than 1, shift to greater than 1:
   if(a < 1)
   {
      prefix *= c / a;
      c += 1;
      a += 1;
   }
   if(b < 1)
   {
      prefix *= c / b;
      c += 1;
      b += 1;
   }
   ','line_number':64,'multiline':True]
['text':' Lanczos calculation:','line_number':90,'multiline':False]
['text':' Special case where the base of the power term is close to 1','line_number':98,'multiline':False]
['text':' compute (1+x)^y instead:','line_number':99,'multiline':False]
['text':' this avoids possible overflow, but appears to be marginally less accurate:','line_number':107,'multiline':False]
['text':' If a and b were originally less than 1 we need to scale the result:','line_number':113,'multiline':False]
['text':' template <class T, class Lanczos> beta_imp(T a, T b, const Lanczos&)','line_number':117,'multiline':False]
['text':'','line_number':119,'multiline':False]
['text':' Generic implementation of Beta(a,b) without Lanczos approximation support','line_number':120,'multiline':False]
['text':' (Caution this is slow!!!):','line_number':121,'multiline':False]
['text':'','line_number':122,'multiline':False]
['text':' Special cases:','line_number':135,'multiline':False]
['text':' Regular cases start here:','line_number':151,'multiline':False]
['text':'','line_number':178,'multiline':False]
['text':' Recursion:','line_number':179,'multiline':False]
['text':'','line_number':180,'multiline':False]
['text':' template <class T>T beta_imp(T a, T b, const lanczos::undefined_lanczos& l)','line_number':192,'multiline':False]
['text':'','line_number':195,'multiline':False]
['text':' Compute the leading power terms in the incomplete Beta:','line_number':196,'multiline':False]
['text':'','line_number':197,'multiline':False]
['text':' (x^a)(y^b)/Beta(a,b) when normalised, and','line_number':198,'multiline':False]
['text':' (x^a)(y^b) otherwise.','line_number':199,'multiline':False]
['text':'','line_number':200,'multiline':False]
['text':' Almost all of the error in the incomplete beta comes from this','line_number':201,'multiline':False]
['text':' function: particularly when a and b are large. Computing large','line_number':202,'multiline':False]
['text':' powers are *hard* though, and using logarithms just leads to','line_number':203,'multiline':False]
['text':' horrendous cancellation errors.','line_number':204,'multiline':False]
['text':'','line_number':205,'multiline':False]
['text':' can we do better here?','line_number':221,'multiline':False]
['text':' combine power terms with Lanczos approximation:','line_number':229,'multiline':False]
['text':' combine with the leftover terms from the Lanczos approximation:','line_number':235,'multiline':False]
['text':' l1 and l2 are the base of the exponents minus one:','line_number':239,'multiline':False]
['text':' when the base of the exponent is very near 1 we get really','line_number':244,'multiline':False]
['text':' gross errors unless extra care is taken:','line_number':245,'multiline':False]
['text':'','line_number':248,'multiline':False]
['text':' This first branch handles the simple cases where either:','line_number':249,'multiline':False]
['text':'','line_number':250,'multiline':False]
['text':' * The two power terms both go in the same direction','line_number':251,'multiline':False]
['text':' (towards zero or towards infinity).  In this case if either','line_number':252,'multiline':False]
['text':' term overflows or underflows, then the product of the two must','line_number':253,'multiline':False]
['text':' do so also.','line_number':254,'multiline':False]
['text':' *Alternatively if one exponent is less than one, then we','line_number':255,'multiline':False]
['text':' can't productively use it to eliminate overflow or underflow','line_number':256,'multiline':False]
['text':' from the other term.  Problems with spurious overflow/underflow','line_number':257,'multiline':False]
['text':' can't be ruled out in this case, but it is *very* unlikely','line_number':258,'multiline':False]
['text':' since one of the power terms will evaluate to a number close to 1.','line_number':259,'multiline':False]
['text':'','line_number':260,'multiline':False]
['text':'','line_number':284,'multiline':False]
['text':' Both exponents are near one and both the exponents are','line_number':285,'multiline':False]
['text':' greater than one and further these two','line_number':286,'multiline':False]
['text':' power terms tend in opposite directions (one towards zero,','line_number':287,'multiline':False]
['text':' the other towards infinity), so we have to combine the terms','line_number':288,'multiline':False]
['text':' to avoid any risk of overflow or underflow.','line_number':289,'multiline':False]
['text':'','line_number':290,'multiline':False]
['text':' We do this by moving one power term inside the other, we have:','line_number':291,'multiline':False]
['text':'','line_number':292,'multiline':False]
['text':'    (1 + l1)^a * (1 + l2)^b','line_number':293,'multiline':False]
['text':'  = ((1 + l1)*(1 + l2)^(b/a))^a','line_number':294,'multiline':False]
['text':'  = (1 + l1 + l3 + l1*l3)^a   ;  l3 = (1 + l2)^(b/a) - 1','line_number':295,'multiline':False]
['text':'                                    = exp((b/a) * log(1 + l2)) - 1','line_number':296,'multiline':False]
['text':'','line_number':297,'multiline':False]
['text':' The tricky bit is deciding which term to move inside :-)','line_number':298,'multiline':False]
['text':' By preference we move the larger term inside, so that the','line_number':299,'multiline':False]
['text':' size of the largest exponent is reduced.  However, that can','line_number':300,'multiline':False]
['text':' only be done as long as l3 (see above) is also small.','line_number':301,'multiline':False]
['text':'','line_number':302,'multiline':False]
['text':' First base near 1 only:','line_number':324,'multiline':False]
['text':' Second base near 1 only:','line_number':340,'multiline':False]
['text':' general case:','line_number':357,'multiline':False]
['text':' Oops, under/overflow, sidestep if we can:','line_number':372,'multiline':False]
['text':' finally the normal case:','line_number':411,'multiline':False]
['text':'','line_number':421,'multiline':False]
['text':' Compute the leading power terms in the incomplete Beta:','line_number':422,'multiline':False]
['text':'','line_number':423,'multiline':False]
['text':' (x^a)(y^b)/Beta(a,b) when normalised, and','line_number':424,'multiline':False]
['text':' (x^a)(y^b) otherwise.','line_number':425,'multiline':False]
['text':'','line_number':426,'multiline':False]
['text':' Almost all of the error in the incomplete beta comes from this','line_number':427,'multiline':False]
['text':' function: particularly when a and b are large. Computing large','line_number':428,'multiline':False]
['text':' powers are *hard* though, and using logarithms just leads to','line_number':429,'multiline':False]
['text':' horrendous cancellation errors.','line_number':430,'multiline':False]
['text':'','line_number':431,'multiline':False]
['text':' This version is generic, slow, and does not use the Lanczos approximation.','line_number':432,'multiline':False]
['text':'','line_number':433,'multiline':False]
['text':' We have to use logs :(','line_number':479,'multiline':False]
['text':'','line_number':523,'multiline':False]
['text':' Series approximation to the incomplete beta:','line_number':524,'multiline':False]
['text':'','line_number':525,'multiline':False]
['text':' incomplete beta power term, combined with the Lanczos approximation:','line_number':558,'multiline':False]
['text':'','line_number':566,'multiline':False]
['text':' Check for over/underflow in the power terms:','line_number':567,'multiline':False]
['text':'','line_number':568,'multiline':False]
['text':'','line_number':589,'multiline':False]
['text':' Oh dear, we need logs, and this *will* cancel:','line_number':590,'multiline':False]
['text':'','line_number':591,'multiline':False]
['text':' Non-normalised, just compute the power:','line_number':600,'multiline':False]
['text':' Safeguard: series can't cope with denorms.','line_number':604,'multiline':False]
['text':'','line_number':611,'multiline':False]
['text':' Incomplete Beta series again, this time without Lanczos support:','line_number':612,'multiline':False]
['text':'','line_number':613,'multiline':False]
['text':' Non-normalised, just compute the power:','line_number':661,'multiline':False]
['text':' Safeguard: series can't cope with denorms.','line_number':665,'multiline':False]
['text':'','line_number':673,'multiline':False]
['text':' Continued fraction for the incomplete beta:','line_number':674,'multiline':False]
['text':'','line_number':675,'multiline':False]
['text':'','line_number':702,'multiline':False]
['text':' Evaluate the incomplete beta via the continued fraction representation:','line_number':703,'multiline':False]
['text':'','line_number':704,'multiline':False]
['text':'','line_number':725,'multiline':False]
['text':' Computes the difference between ibeta(a,b,x) and ibeta(a+k,b,x):','line_number':726,'multiline':False]
['text':'','line_number':727,'multiline':False]
['text':' series summation from 0 to k-1:','line_number':746,'multiline':False]
['text':'','line_number':756,'multiline':False]
['text':' This function is only needed for the non-regular incomplete beta,','line_number':757,'multiline':False]
['text':' it computes the delta in:','line_number':758,'multiline':False]
['text':' beta(a,b,x) = prefix + delta * beta(a+k,b,x)','line_number':759,'multiline':False]
['text':' it is currently only called for small k.','line_number':760,'multiline':False]
['text':'','line_number':761,'multiline':False]
['text':' calculate:','line_number':765,'multiline':False]
['text':' (a)(a+1)(a+2)...(a+k-1)','line_number':766,'multiline':False]
['text':' _______________________','line_number':767,'multiline':False]
['text':' (b)(b+1)(b+2)...(b+k-1)','line_number':768,'multiline':False]
['text':' This is only called with small k, for large k','line_number':770,'multiline':False]
['text':' it is grossly inefficient, do not use outside it's','line_number':771,'multiline':False]
['text':' intended purpose!!!','line_number':772,'multiline':False]
['text':'','line_number':781,'multiline':False]
['text':' Routine for a > 15, b < 1','line_number':782,'multiline':False]
['text':'','line_number':783,'multiline':False]
['text':' Begin by figuring out how large our table of Pn's should be,','line_number':784,'multiline':False]
['text':' quoted accuracies are "guesstimates" based on empirical observation.','line_number':785,'multiline':False]
['text':' Note that the table size should never exceed the size of our','line_number':786,'multiline':False]
['text':' tables of factorials.','line_number':787,'multiline':False]
['text':'','line_number':788,'multiline':False]
['text':' This is likely to be enough for ~35-50 digit accuracy','line_number':792,'multiline':False]
['text':' but it's hard to quantify exactly:','line_number':793,'multiline':False]
['text':' ~8-15 digit accuracy','line_number':803,'multiline':False]
['text':' 16-20 digit accuracy','line_number':809,'multiline':False]
['text':' ~35-50 digit accuracy','line_number':815,'multiline':False]
['text':'','line_number':824,'multiline':False]
['text':' This is DiDonato and Morris's BGRAT routine, see Eq's 9 through 9.6.','line_number':825,'multiline':False]
['text':'','line_number':826,'multiline':False]
['text':' Some values we'll need later, these are Eq 9.1:','line_number':827,'multiline':False]
['text':'','line_number':828,'multiline':False]
['text':' and from from 9.2:','line_number':837,'multiline':False]
['text':'','line_number':852,'multiline':False]
['text':' now we need the quantity Pn, unfortunately this is computed','line_number':853,'multiline':False]
['text':' recursively, and requires a full history of all the previous values','line_number':854,'multiline':False]
['text':' so no choice but to declare a big table and hope it's big enough...','line_number':855,'multiline':False]
['text':'','line_number':856,'multiline':False]
['text':' see 9.3.','line_number':857,'multiline':False]
['text':'','line_number':858,'multiline':False]
['text':' Now an initial value for J, see 9.6:','line_number':859,'multiline':False]
['text':'','line_number':860,'multiline':False]
['text':'','line_number':862,'multiline':False]
['text':' Now we can start to pull things together and evaluate the sum in Eq 9:','line_number':863,'multiline':False]
['text':'','line_number':864,'multiline':False]
['text':' Value at N = 0','line_number':865,'multiline':False]
['text':' some variables we'll need:','line_number':866,'multiline':False]
['text':' 2*N+1','line_number':867,'multiline':False]
['text':'
      // debugging code, enable this if you want to determine whether
      // the table of Pn's is large enough...
      //
      static int max_count = 2;
      if(n > max_count)
      {
         max_count = n;
         std::cerr << "Max iterations in BGRAT was " << n << std::endl;
      }
      ','line_number':876,'multiline':True]
['text':'','line_number':887,'multiline':False]
['text':' begin by evaluating the next Pn from Eq 9.4:','line_number':888,'multiline':False]
['text':'','line_number':889,'multiline':False]
['text':'','line_number':902,'multiline':False]
['text':' Now we want Jn from Jn-1 using Eq 9.6:','line_number':903,'multiline':False]
['text':'','line_number':904,'multiline':False]
['text':'','line_number':908,'multiline':False]
['text':' pull it together with Eq 9:','line_number':909,'multiline':False]
['text':'','line_number':910,'multiline':False]
['text':' template <class T, class Lanczos>T beta_small_b_large_a_series(T a, T b, T x, T y, T s0, T mult, const Lanczos& l, bool normalised)','line_number':925,'multiline':False]
['text':'','line_number':927,'multiline':False]
['text':' For integer arguments we can relate the incomplete beta to the','line_number':928,'multiline':False]
['text':' complement of the binomial distribution cdf and use this finite sum.','line_number':929,'multiline':False]
['text':'','line_number':930,'multiline':False]
['text':' ADL of std names','line_number':934,'multiline':False]
['text':' First term underflows so we need to start at the mode of the','line_number':949,'multiline':False]
['text':' distribution and work outwards:','line_number':950,'multiline':False]
['text':' OK, starting slightly above the mode didn't work,','line_number':957,'multiline':False]
['text':' we'll have to sum the terms the old fashioned way:','line_number':958,'multiline':False]
['text':'','line_number':986,'multiline':False]
['text':' The incomplete beta function implementation:','line_number':987,'multiline':False]
['text':' This is just a big bunch of spaghetti code to divide up the','line_number':988,'multiline':False]
['text':' input range and select the right implementation method for','line_number':989,'multiline':False]
['text':' each domain:','line_number':990,'multiline':False]
['text':'','line_number':991,'multiline':False]
['text':' for ADL of std math functions.','line_number':997,'multiline':False]
['text':' value not set.','line_number':1012,'multiline':False]
['text':' extend to a few very special cases:','line_number':1023,'multiline':False]
['text':' We have an arcsine distribution:','line_number':1063,'multiline':False]
['text':'','line_number':1081,'multiline':False]
['text':' Special case see: http://functions.wolfram.com/GammaBetaErf/BetaRegularized/03/01/01/','line_number':1082,'multiline':False]
['text':'','line_number':1083,'multiline':False]
['text':' Both a,b < 1:','line_number':1116,'multiline':False]
['text':' Sidestep on a, and then use the series representation:','line_number':1154,'multiline':False]
['text':' One of a, b < 1 only:','line_number':1182,'multiline':False]
['text':' Sidestep to improve errors:','line_number':1236,'multiline':False]
['text':' Both a,b >= 1:','line_number':1266,'multiline':False]
['text':' relate to the binomial distribution and use a finite sum:','line_number':1288,'multiline':False]
['text':' sidestep so we can use the series representation:','line_number':1313,'multiline':False]
['text':' The formula here for the non-normalised case is tricky to figure','line_number':1334,'multiline':False]
['text':' out (for me!!), and requires two pochhammer calculations rather','line_number':1335,'multiline':False]
['text':' than one, so leave it for now and only use this in the normalized case....','line_number':1336,'multiline':False]
['text':' Note this line would need changing if we ever enable this branch in non-normalized case','line_number':1347,'multiline':False]
['text':' overflow, return an arbitrarily large value:','line_number':1380,'multiline':False]
['text':' template <class T, class Lanczos>T ibeta_imp(T a, T b, T x, const Lanczos& l, bool inv, bool normalised)','line_number':1390,'multiline':False]
['text':'','line_number':1402,'multiline':False]
['text':' start with the usual error checks:','line_number':1403,'multiline':False]
['text':'','line_number':1404,'multiline':False]
['text':'','line_number':1411,'multiline':False]
['text':' Now the corner cases:','line_number':1412,'multiline':False]
['text':'','line_number':1413,'multiline':False]
['text':'','line_number':1424,'multiline':False]
['text':' Now the regular cases:','line_number':1425,'multiline':False]
['text':'','line_number':1426,'multiline':False]
['text':'','line_number':1432,'multiline':False]
['text':' Some forwarding functions that dis-ambiguate the third argument type:','line_number':1433,'multiline':False]
['text':'','line_number':1434,'multiline':False]
['text':' namespace detail','line_number':1458,'multiline':False]
['text':'','line_number':1460,'multiline':False]
['text':' The actual function entry-points now follow, these just figure out','line_number':1461,'multiline':False]
['text':' which Lanczos approximation to use','line_number':1462,'multiline':False]
['text':' and forward to the implementation functions:','line_number':1463,'multiline':False]
['text':'','line_number':1464,'multiline':False]
['text':' namespace math','line_number':1589,'multiline':False]
['text':' namespace boost','line_number':1590,'multiline':False]
['text':' BOOST_MATH_SPECIAL_BETA_HPP','line_number':1595,'multiline':False]
