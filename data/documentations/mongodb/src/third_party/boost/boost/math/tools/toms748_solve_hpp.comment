['text':'  (C) Copyright John Maddock 2006.','line_number':1,'multiline':False]
['text':'  Use, modification and distribution are subject to the','line_number':2,'multiline':False]
['text':'  Boost Software License, Version 1.0. (See accompanying file','line_number':3,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':4,'multiline':False]
['text':'','line_number':91,'multiline':False]
['text':' Given a point c inside the existing enclosing interval','line_number':92,'multiline':False]
['text':' [a, b] sets a = c if f(c) == 0, otherwise finds the new ','line_number':93,'multiline':False]
['text':' enclosing interval: either [a, c] or [c, b] and sets','line_number':94,'multiline':False]
['text':' d and fd to the point that has just been removed from','line_number':95,'multiline':False]
['text':' the interval.  In other words d is the third best guess','line_number':96,'multiline':False]
['text':' to the root.','line_number':97,'multiline':False]
['text':'','line_number':98,'multiline':False]
['text':' For ADL of std math functions','line_number':99,'multiline':False]
['text':'','line_number':101,'multiline':False]
['text':' If the interval [a,b] is very small, or if c is too close ','line_number':102,'multiline':False]
['text':' to one end of the interval then we need to adjust the','line_number':103,'multiline':False]
['text':' location of c accordingly:','line_number':104,'multiline':False]
['text':'','line_number':105,'multiline':False]
['text':'','line_number':118,'multiline':False]
['text':' OK, lets invoke f(c):','line_number':119,'multiline':False]
['text':'','line_number':120,'multiline':False]
['text':'','line_number':122,'multiline':False]
['text':' if we have a zero then we have an exact solution to the root:','line_number':123,'multiline':False]
['text':'','line_number':124,'multiline':False]
['text':'','line_number':133,'multiline':False]
['text':' Non-zero fc, update the interval:','line_number':134,'multiline':False]
['text':'','line_number':135,'multiline':False]
['text':'','line_number':155,'multiline':False]
['text':' return num / denom without overflow,','line_number':156,'multiline':False]
['text':' return r if overflow would occur.','line_number':157,'multiline':False]
['text':'','line_number':158,'multiline':False]
['text':' For ADL of std math functions','line_number':159,'multiline':False]
['text':'','line_number':172,'multiline':False]
['text':' Performs standard secant interpolation of [a,b] given','line_number':173,'multiline':False]
['text':' function evaluations f(a) and f(b).  Performs a bisection','line_number':174,'multiline':False]
['text':' if secant interpolation would leave us very close to either','line_number':175,'multiline':False]
['text':' a or b.  Rationale: we only call this function when at least','line_number':176,'multiline':False]
['text':' one other form of interpolation has already failed, so we know','line_number':177,'multiline':False]
['text':' that the function is unlikely to be smooth with a root very','line_number':178,'multiline':False]
['text':' close to a or b.','line_number':179,'multiline':False]
['text':'','line_number':180,'multiline':False]
['text':' For ADL of std math functions','line_number':181,'multiline':False]
['text':'','line_number':195,'multiline':False]
['text':' Performs quadratic interpolation to determine the next point,','line_number':196,'multiline':False]
['text':' takes count Newton steps to find the location of the','line_number':197,'multiline':False]
['text':' quadratic polynomial.','line_number':198,'multiline':False]
['text':'','line_number':199,'multiline':False]
['text':' Point d must lie outside of the interval [a,b], it is the third','line_number':200,'multiline':False]
['text':' best approximation to the root, after a and b.','line_number':201,'multiline':False]
['text':'','line_number':202,'multiline':False]
['text':' Note: this does not guarantee to find a root','line_number':203,'multiline':False]
['text':' inside [a, b], so we fall back to a secant step should','line_number':204,'multiline':False]
['text':' the result be out of range.','line_number':205,'multiline':False]
['text':'','line_number':206,'multiline':False]
['text':' Start by obtaining the coefficients of the quadratic polynomial:','line_number':207,'multiline':False]
['text':'','line_number':208,'multiline':False]
['text':' failure to determine coefficients, try a secant step:','line_number':215,'multiline':False]
['text':'','line_number':218,'multiline':False]
['text':' Determine the starting point of the Newton steps:','line_number':219,'multiline':False]
['text':'','line_number':220,'multiline':False]
['text':'','line_number':230,'multiline':False]
['text':' Take the Newton steps:','line_number':231,'multiline':False]
['text':'','line_number':232,'multiline':False]
['text':'c -= safe_div(B * c, (B + A * (2 * c - a - b)), 1 + c - a);','line_number':235,'multiline':False]
['text':' Oops, failure, try a secant step:','line_number':240,'multiline':False]
['text':'','line_number':251,'multiline':False]
['text':' Uses inverse cubic interpolation of f(x) at points ','line_number':252,'multiline':False]
['text':' [a,b,d,e] to obtain an approximate root of f(x).','line_number':253,'multiline':False]
['text':' Points d and e lie outside the interval [a,b]','line_number':254,'multiline':False]
['text':' and are the third and forth best approximations','line_number':255,'multiline':False]
['text':' to the root that we have found so far.','line_number':256,'multiline':False]
['text':'','line_number':257,'multiline':False]
['text':' Note: this does not guarantee to find a root','line_number':258,'multiline':False]
['text':' inside [a, b], so we fall back to quadratic','line_number':259,'multiline':False]
['text':' interpolation in case of an erroneous result.','line_number':260,'multiline':False]
['text':'','line_number':261,'multiline':False]
['text':' Out of bounds step, fall back to quadratic interpolation:','line_number':284,'multiline':False]
['text':' namespace detail','line_number':293,'multiline':False]
['text':'','line_number':298,'multiline':False]
['text':' Main entry point and logic for Toms Algorithm 748','line_number':299,'multiline':False]
['text':' root finder.','line_number':300,'multiline':False]
['text':'','line_number':301,'multiline':False]
['text':' For ADL of std math functions','line_number':302,'multiline':False]
['text':'','line_number':306,'multiline':False]
['text':' Sanity check - are we allowed to iterate at all?','line_number':307,'multiline':False]
['text':'','line_number':308,'multiline':False]
['text':' initialise a, b and fa, fb:','line_number':316,'multiline':False]
['text':' dummy value for fd, e and fe:','line_number':340,'multiline':False]
['text':'','line_number':345,'multiline':False]
['text':' On the first step we take a secant step:','line_number':346,'multiline':False]
['text':'','line_number':347,'multiline':False]
['text':'','line_number':355,'multiline':False]
['text':' On the second step we take a quadratic interpolation:','line_number':356,'multiline':False]
['text':'','line_number':357,'multiline':False]
['text':' save our brackets:','line_number':369,'multiline':False]
['text':'','line_number':372,'multiline':False]
['text':' Starting with the third step taken','line_number':373,'multiline':False]
['text':' we can use either quadratic or cubic interpolation.','line_number':374,'multiline':False]
['text':' Cubic interpolation requires that all four function values','line_number':375,'multiline':False]
['text':' fa, fb, fd, and fe are distinct, should that not be the case','line_number':376,'multiline':False]
['text':' then variable prof will get set to true, and we'll end up','line_number':377,'multiline':False]
['text':' taking a quadratic step instead.','line_number':378,'multiline':False]
['text':'','line_number':379,'multiline':False]
['text':'','line_number':391,'multiline':False]
['text':' re-bracket, and check for termination:','line_number':392,'multiline':False]
['text':'','line_number':393,'multiline':False]
['text':'','line_number':400,'multiline':False]
['text':' Now another interpolated step:','line_number':401,'multiline':False]
['text':'','line_number':402,'multiline':False]
['text':'','line_number':413,'multiline':False]
['text':' Bracket again, and check termination condition, update e:','line_number':414,'multiline':False]
['text':'','line_number':415,'multiline':False]
['text':'','line_number':420,'multiline':False]
['text':' Now we take a double-length secant step:','line_number':421,'multiline':False]
['text':'','line_number':422,'multiline':False]
['text':'','line_number':438,'multiline':False]
['text':' Bracket again, and check termination condition:','line_number':439,'multiline':False]
['text':'','line_number':440,'multiline':False]
['text':'','line_number':448,'multiline':False]
['text':' And finally... check to see if an additional bisection step is ','line_number':449,'multiline':False]
['text':' to be taken, we do this if we're not converging fast enough:','line_number':450,'multiline':False]
['text':'','line_number':451,'multiline':False]
['text':'','line_number':454,'multiline':False]
['text':' bracket again on a bisection:','line_number':455,'multiline':False]
['text':'','line_number':456,'multiline':False]
['text':' while loop','line_number':463,'multiline':False]
['text':'','line_number':506,'multiline':False]
['text':' Set up initial brackets:','line_number':507,'multiline':False]
['text':'','line_number':508,'multiline':False]
['text':'','line_number':513,'multiline':False]
['text':' Set up invocation count:','line_number':514,'multiline':False]
['text':'','line_number':515,'multiline':False]
['text':'','line_number':522,'multiline':False]
['text':' Zero is to the right of b, so walk upwards','line_number':523,'multiline':False]
['text':' until we find it:','line_number':524,'multiline':False]
['text':'','line_number':525,'multiline':False]
['text':'','line_number':530,'multiline':False]
['text':' Heuristic: normally it's best not to increase the step sizes as we'll just end up','line_number':531,'multiline':False]
['text':' with a really wide range to search for the root.  However, if the initial guess was *really*','line_number':532,'multiline':False]
['text':' bad then we need to speed up the search otherwise we'll take forever if we're orders of','line_number':533,'multiline':False]
['text':' magnitude out.  This happens most often if the guess is a small value (say 1) and the result','line_number':534,'multiline':False]
['text':' we're looking for is close to std::numeric_limits<T>::min().','line_number':535,'multiline':False]
['text':'','line_number':536,'multiline':False]
['text':'','line_number':542,'multiline':False]
['text':' Now go ahead and move our guess by "factor":','line_number':543,'multiline':False]
['text':'','line_number':544,'multiline':False]
['text':'','line_number':555,'multiline':False]
['text':' Zero is to the left of a, so walk downwards','line_number':556,'multiline':False]
['text':' until we find it:','line_number':557,'multiline':False]
['text':'','line_number':558,'multiline':False]
['text':' Escape route just in case the answer is zero!','line_number':563,'multiline':False]
['text':'','line_number':570,'multiline':False]
['text':' Heuristic: normally it's best not to increase the step sizes as we'll just end up','line_number':571,'multiline':False]
['text':' with a really wide range to search for the root.  However, if the initial guess was *really*','line_number':572,'multiline':False]
['text':' bad then we need to speed up the search otherwise we'll take forever if we're orders of','line_number':573,'multiline':False]
['text':' magnitude out.  This happens most often if the guess is a small value (say 1) and the result','line_number':574,'multiline':False]
['text':' we're looking for is close to std::numeric_limits<T>::min().','line_number':575,'multiline':False]
['text':'','line_number':576,'multiline':False]
['text':'','line_number':582,'multiline':False]
['text':' Now go ahead and move are guess by "factor":','line_number':583,'multiline':False]
['text':'','line_number':584,'multiline':False]
['text':' namespace tools','line_number':616,'multiline':False]
['text':' namespace math','line_number':617,'multiline':False]
['text':' namespace boost','line_number':618,'multiline':False]
['text':' BOOST_MATH_TOOLS_SOLVE_ROOT_HPP','line_number':621,'multiline':False]
