['text':'/////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'  Copyright 2013 John Maddock','line_number':2,'multiline':False]
['text':'  Distributed under the Boost','line_number':3,'multiline':False]
['text':'  Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]
['text':'  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]
['text':'','line_number':26,'multiline':False]
['text':' Asymptotic expansion for B2n due to','line_number':27,'multiline':False]
['text':' Luschny LogB3 formula (http://www.luschny.de/math/primes/bernincl.html)','line_number':28,'multiline':False]
['text':'','line_number':29,'multiline':False]
['text':' Just get B2n and convert to a Tangent number:','line_number':51,'multiline':False]
['text':'','line_number':63,'multiline':False]
['text':' We need to know the approximate value of /n/ which will','line_number':64,'multiline':False]
['text':' cause bernoulli_b2n<T>(n) to return infinity - this allows','line_number':65,'multiline':False]
['text':' us to elude a great deal of runtime checking for values below','line_number':66,'multiline':False]
['text':' n, and only perform the full overflow checks when we know that we're','line_number':67,'multiline':False]
['text':' getting close to the point where our calculations will overflow.','line_number':68,'multiline':False]
['text':' We use Luschny's LogB3 formula (http://www.luschny.de/math/primes/bernincl.html) ','line_number':69,'multiline':False]
['text':' to find the limit, and since we're dealing with the log of the Bernoulli numbers','line_number':70,'multiline':False]
['text':' we need only perform the calculation at double precision and not with T','line_number':71,'multiline':False]
['text':' (which may be a multiprecision type).  The limit returned is within 1 of the true','line_number':72,'multiline':False]
['text':' limit for all the types tested.  Note that although the code below is basically','line_number':73,'multiline':False]
['text':' the same as b2n_asymptotic above, it has been recast as a continuous real-valued ','line_number':74,'multiline':False]
['text':' function as this makes the root finding go smoother/faster.  It also omits the','line_number':75,'multiline':False]
['text':' sign of the Bernoulli number.','line_number':76,'multiline':False]
['text':'','line_number':77,'multiline':False]
['text':' Luschny LogB3(n) formula.','line_number':85,'multiline':False]
['text':' Set a limit on how large the result can ever be:','line_number':104,'multiline':False]
['text':' This routine is called at program startup if it's called at all:','line_number':127,'multiline':False]
['text':' that guarantees safe initialization of the static variable.','line_number':128,'multiline':False]
['text':'','line_number':134,'multiline':False]
['text':' The tangent numbers grow larger much more rapidly than the Bernoulli numbers do....','line_number':135,'multiline':False]
['text':' so to compute the Bernoulli numbers from the tangent numbers, we need to avoid spurious','line_number':136,'multiline':False]
['text':' overflow in the calculation, we can do this by scaling all the tangent number by some scale factor:','line_number':137,'multiline':False]
['text':'','line_number':138,'multiline':False]
['text':'','line_number':152,'multiline':False]
['text':' We need something to act as a cache for our calculated Bernoulli numbers.  In order to','line_number':153,'multiline':False]
['text':' ensure both fast access and thread safety, we need a stable table which may be extended','line_number':154,'multiline':False]
['text':' in size, but which never reallocates: that way values already calculated may be accessed','line_number':155,'multiline':False]
['text':' concurrently with another thread extending the table with new values.','line_number':156,'multiline':False]
['text':'','line_number':157,'multiline':False]
['text':' Very very simple vector class that will never allocate more than once, we could use','line_number':158,'multiline':False]
['text':' boost::container::static_vector here, but that allocates on the stack, which may well','line_number':159,'multiline':False]
['text':' cause issues for the amount of memory we want in the extreme case...','line_number':160,'multiline':False]
['text':'','line_number':161,'multiline':False]
['text':'T(1U)','line_number':232,'multiline':True]
['text':' T(1U)','line_number':234,'multiline':True]
['text':' already filled the tn...','line_number':266,'multiline':False]
['text':'','line_number':294,'multiline':False]
['text':' Not only do we need to take care to avoid spurious over/under flow in','line_number':295,'multiline':False]
['text':' the calculation, but we also need to avoid overflow altogether in case','line_number':296,'multiline':False]
['text':' we're calculating with a type where "bad things" happen in that case:','line_number':297,'multiline':False]
['text':'','line_number':298,'multiline':False]
['text':'','line_number':329,'multiline':False]
['text':' There are basically 3 thread safety options:','line_number':330,'multiline':False]
['text':'','line_number':331,'multiline':False]
['text':' 1) There are no threads (BOOST_HAS_THREADS is not defined).','line_number':332,'multiline':False]
['text':' 2) There are threads, but we do not have a true atomic integer type, ','line_number':333,'multiline':False]
['text':'    in this case we just use a mutex to guard against race conditions.','line_number':334,'multiline':False]
['text':' 3) There are threads, and we have an atomic integer: in this case we can','line_number':335,'multiline':False]
['text':'    use the double-checked locking pattern to avoid thread synchronisation','line_number':336,'multiline':False]
['text':'    when accessing values already in the cache.','line_number':337,'multiline':False]
['text':'','line_number':338,'multiline':False]
['text':' First off handle the common case for overflow and/or asymptotic expansion:','line_number':339,'multiline':False]
['text':'','line_number':340,'multiline':False]
['text':' Add a static_assert on instantiation if we have threads, but no C++11 threading support.','line_number':366,'multiline':False]
['text':'','line_number':369,'multiline':False]
['text':' Single threaded code, very simple:','line_number':370,'multiline':False]
['text':'','line_number':371,'multiline':False]
['text':'','line_number':391,'multiline':False]
['text':' Double-checked locking pattern, lets us access cached already cached values','line_number':392,'multiline':False]
['text':' without locking:','line_number':393,'multiline':False]
['text':'','line_number':394,'multiline':False]
['text':' Get the counter and see if we need to calculate more constants:','line_number':395,'multiline':False]
['text':'','line_number':396,'multiline':False]
['text':' BOOST_HAS_THREADS','line_number':428,'multiline':False]
['text':'','line_number':435,'multiline':False]
['text':' There are basically 3 thread safety options:','line_number':436,'multiline':False]
['text':'','line_number':437,'multiline':False]
['text':' 1) There are no threads (BOOST_HAS_THREADS is not defined).','line_number':438,'multiline':False]
['text':' 2) There are threads, but we do not have a true atomic integer type, ','line_number':439,'multiline':False]
['text':'    in this case we just use a mutex to guard against race conditions.','line_number':440,'multiline':False]
['text':' 3) There are threads, and we have an atomic integer: in this case we can','line_number':441,'multiline':False]
['text':'    use the double-checked locking pattern to avoid thread synchronisation','line_number':442,'multiline':False]
['text':'    when accessing values already in the cache.','line_number':443,'multiline':False]
['text':'','line_number':444,'multiline':False]
['text':'','line_number':445,'multiline':False]
['text':' First off handle the common case for overflow and/or asymptotic expansion:','line_number':446,'multiline':False]
['text':'','line_number':447,'multiline':False]
['text':'','line_number':473,'multiline':False]
['text':' Single threaded code, very simple:','line_number':474,'multiline':False]
['text':'','line_number':475,'multiline':False]
['text':'','line_number':505,'multiline':False]
['text':' Double-checked locking pattern, lets us access cached already cached values','line_number':506,'multiline':False]
['text':' without locking:','line_number':507,'multiline':False]
['text':'','line_number':508,'multiline':False]
['text':' Get the counter and see if we need to calculate more constants:','line_number':509,'multiline':False]
['text':'','line_number':510,'multiline':False]
['text':' BOOST_HAS_THREADS','line_number':550,'multiline':False]
['text':'','line_number':555,'multiline':False]
['text':' The caches for Bernoulli and tangent numbers, once allocated,','line_number':556,'multiline':False]
['text':' these must NEVER EVER reallocate as it breaks our thread','line_number':557,'multiline':False]
['text':' safety guarantees:','line_number':558,'multiline':False]
['text':'','line_number':559,'multiline':False]
['text':' The value at which we know overflow has already occurred for the Bn:','line_number':562,'multiline':False]
['text':' BOOST_HAS_THREADS','line_number':571,'multiline':False]
['text':'','line_number':577,'multiline':False]
['text':' When numeric_limits<>::digits is zero, the type has either not specialized numeric_limits at all','line_number':578,'multiline':False]
['text':' or it's precision can vary at runtime.  So make the cache thread_local so that each thread can','line_number':579,'multiline':False]
['text':' have it's own precision if required:','line_number':580,'multiline':False]
['text':'','line_number':581,'multiline':False]
['text':'','line_number':592,'multiline':False]
['text':' Note that we rely on C++11 thread-safe initialization here:','line_number':593,'multiline':False]
['text':'','line_number':594,'multiline':False]
['text':' BOOST_MATH_BERNOULLI_DETAIL_HPP','line_number':601,'multiline':False]
