['text':' Details for templated Spreadsort-based float_sort.','line_number':1,'multiline':False]
['text':'          Copyright Steven J. Ross 2001 - 2014.','line_number':3,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0.','line_number':4,'multiline':False]
['text':'    (See accompanying file LICENSE_1_0.txt or copy at','line_number':5,'multiline':False]
['text':'          http://www.boost.org/LICENSE_1_0.txt)','line_number':6,'multiline':False]
['text':' See http://www.boost.org/libs/sort for library home page.','line_number':8,'multiline':False]
['text':'
Some improvements suggested by:
Phil Endecott and Frank Gennari
float_mem_cast fix provided by:
Scott McMurray
','line_number':10,'multiline':True]
['text':'Casts a RandomAccessIter to the specified integer type','line_number':34,'multiline':False]
['text':'Only cast IEEE floating-point numbers, and only to same-sized integers','line_number':41,'multiline':False]
['text':' Return true if the list is sorted.  Otherwise, find the minimum and','line_number':50,'multiline':False]
['text':' maximum.  Values are Right_shifted 0 bits before comparison.','line_number':51,'multiline':False]
['text':' Return true if the list is sorted.  Otherwise, find the minimum and','line_number':72,'multiline':False]
['text':' maximum.  Uses comp to check if the data is already sorted.','line_number':73,'multiline':False]
['text':'Specialized swap loops for floating-point casting','line_number':96,'multiline':False]
['text':'Three-way swap; if the item to be swapped doesn't belong in the','line_number':114,'multiline':False]
['text':'current bin, swap it to where it belongs','line_number':115,'multiline':False]
['text':' Return true if the list is sorted.  Otherwise, find the minimum and','line_number':141,'multiline':False]
['text':' maximum.  Values are cast to Cast_type before comparison.','line_number':142,'multiline':False]
['text':'Special-case sorting of positive floats with casting','line_number':163,'multiline':False]
['text':'Calculating the size of each bin','line_number':183,'multiline':False]
['text':'Swap into place','line_number':192,'multiline':False]
['text':'Return if we've completed bucketsorting','line_number':199,'multiline':False]
['text':'Recursing','line_number':203,'multiline':False]
['text':'Sorting negative floats','line_number':221,'multiline':False]
['text':'Bins are iterated in reverse because max_neg_float = min_neg_int','line_number':222,'multiline':False]
['text':'Calculating the size of each bin','line_number':243,'multiline':False]
['text':'Swap into place','line_number':251,'multiline':False]
['text':'The last bin will always have the correct elements in it','line_number':253,'multiline':False]
['text':'Update the end position because we don't process the last bin','line_number':257,'multiline':False]
['text':'Return if we've completed bucketsorting','line_number':260,'multiline':False]
['text':'Recursing','line_number':264,'multiline':False]
['text':'Sorting negative floats','line_number':282,'multiline':False]
['text':'Bins are iterated in reverse order because max_neg_float = min_neg_int','line_number':283,'multiline':False]
['text':'Calculating the size of each bin','line_number':303,'multiline':False]
['text':'Swap into place','line_number':310,'multiline':False]
['text':'The last bin will always have the correct elements in it','line_number':312,'multiline':False]
['text':'Update the end position of the unprocessed last bin','line_number':316,'multiline':False]
['text':'Return if we've completed bucketsorting','line_number':319,'multiline':False]
['text':'Recursing','line_number':323,'multiline':False]
['text':'Calculating the size of each bin','line_number':361,'multiline':False]
['text':'Swap into place','line_number':368,'multiline':False]
['text':'The last bin will always have the correct elements in it','line_number':370,'multiline':False]
['text':'Update the end position of the unprocessed last bin','line_number':374,'multiline':False]
['text':'Return if we've completed bucketsorting','line_number':377,'multiline':False]
['text':'Recursing','line_number':381,'multiline':False]
['text':'Casting special-case for floating-point sorting','line_number':401,'multiline':False]
['text':'Calculating the size of each bin','line_number':421,'multiline':False]
['text':'The index of the first positive bin','line_number':425,'multiline':False]
['text':'Must be divided small enough to fit into an integer','line_number':426,'multiline':False]
['text':'Resetting if all bins are negative','line_number':428,'multiline':False]
['text':'Reversing the order of the negative bins','line_number':431,'multiline':False]
['text':'Note that because of the negative/positive ordering direction flip','line_number':432,'multiline':False]
['text':'We can not depend upon bin order and positions matching up','line_number':433,'multiline':False]
['text':'so bin_sizes must be reused to contain the end of the bin','line_number':434,'multiline':False]
['text':'Handling positives following negatives','line_number':441,'multiline':False]
['text':'Swap into place','line_number':454,'multiline':False]
['text':'Handling negative values first','line_number':465,'multiline':False]
['text':'sort negative values using reversed-bin spreadsort','line_number':478,'multiline':False]
['text':'sort positive values using normal spreadsort','line_number':491,'multiline':False]
['text':'Functor implementation for recursive sorting','line_number':498,'multiline':False]
['text':'Calculating the size of each bin','line_number':518,'multiline':False]
['text':'The index of the first positive bin','line_number':521,'multiline':False]
['text':'Resetting if all bins are negative','line_number':523,'multiline':False]
['text':'Reversing the order of the negative bins','line_number':526,'multiline':False]
['text':'Note that because of the negative/positive ordering direction flip','line_number':527,'multiline':False]
['text':'We can not depend upon bin order and positions matching up','line_number':528,'multiline':False]
['text':'so bin_sizes must be reused to contain the end of the bin','line_number':529,'multiline':False]
['text':'Handling positives following negatives','line_number':536,'multiline':False]
['text':'Swap into place','line_number':549,'multiline':False]
['text':'Return if we've completed bucketsorting','line_number':557,'multiline':False]
['text':'Handling negative values first','line_number':561,'multiline':False]
['text':'sort negative values using reversed-bin spreadsort','line_number':574,'multiline':False]
['text':'sort positive values using normal spreadsort','line_number':588,'multiline':False]
['text':'Calculating the size of each bin','line_number':616,'multiline':False]
['text':'The index of the first positive bin','line_number':619,'multiline':False]
['text':'Resetting if all bins are negative','line_number':622,'multiline':False]
['text':'Reversing the order of the negative bins','line_number':625,'multiline':False]
['text':'Note that because of the negative/positive ordering direction flip','line_number':626,'multiline':False]
['text':'We can not depend upon bin order and positions matching up','line_number':627,'multiline':False]
['text':'so bin_sizes must be reused to contain the end of the bin','line_number':628,'multiline':False]
['text':'Handling positives following negatives','line_number':635,'multiline':False]
['text':'Swap into place','line_number':648,'multiline':False]
['text':'Return if we've completed bucketsorting','line_number':656,'multiline':False]
['text':'Handling negative values first','line_number':660,'multiline':False]
['text':'sort negative values using reversed-bin spreadsort','line_number':673,'multiline':False]
['text':'sort positive values using normal spreadsort','line_number':688,'multiline':False]
['text':'Checking whether the value type is a float, and trying a 32-bit integer','line_number':697,'multiline':False]
['text':'Checking whether the value type is a double, and using a 64-bit integer','line_number':712,'multiline':False]
['text':'These approaches require the user to do the typecast','line_number':746,'multiline':False]
['text':'with rshift but default comparision','line_number':747,'multiline':False]
['text':'maximum integer size with rshift but default comparision','line_number':760,'multiline':False]
['text':'sizeof(Div_type) doesn't match, so use boost::sort::pdqsort','line_number':773,'multiline':False]
['text':'specialized comparison','line_number':784,'multiline':False]
['text':'max-sized integer with specialized comparison','line_number':799,'multiline':False]
['text':'sizeof(Div_type) doesn't match, so use boost::sort::pdqsort','line_number':814,'multiline':False]
