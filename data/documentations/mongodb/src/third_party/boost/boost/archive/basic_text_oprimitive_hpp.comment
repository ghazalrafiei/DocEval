['text':' MS compatible compilers support #pragma once','line_number':4,'multiline':False]
['text':'///////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8','line_number':9,'multiline':False]
['text':' basic_text_oprimitive.hpp','line_number':10,'multiline':False]
['text':' (C) Copyright 2002 Robert Ramey - http://www.rrsd.com .','line_number':12,'multiline':False]
['text':' Use, modification and distribution is subject to the Boost Software','line_number':13,'multiline':False]
['text':' License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at','line_number':14,'multiline':False]
['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':15,'multiline':False]
['text':'  See http://www.boost.org for updates, documentation, and revision history.','line_number':17,'multiline':False]
['text':' archives stored as text - note these ar templated on the basic','line_number':19,'multiline':False]
['text':' stream templates to accommodate wide (and other?) kind of characters','line_number':20,'multiline':False]
['text':'','line_number':21,'multiline':False]
['text':' note the fact that on libraries without wide characters, ostream is','line_number':22,'multiline':False]
['text':' is not a specialization of basic_ostream which in fact is not defined','line_number':23,'multiline':False]
['text':' in such cases.   So we can't use basic_ostream<OStream::char_type> but rather','line_number':24,'multiline':False]
['text':' use two template parameters','line_number':25,'multiline':False]
['text':' size_t','line_number':29,'multiline':False]
['text':' namespace std','line_number':46,'multiline':False]
['text':' must be the last header','line_number':58,'multiline':False]
['text':'///////////////////////////////////////////////////////////////////////','line_number':63,'multiline':False]
['text':' class basic_text_oprimitive - output of prmitives to stream','line_number':64,'multiline':False]
['text':' note order! - if you change this, libstd++ will fail!','line_number':74,'multiline':False]
['text':' a) create new locale with new codecvt facet','line_number':75,'multiline':False]
['text':' b) save current locale','line_number':76,'multiline':False]
['text':' c) change locale to new one','line_number':77,'multiline':False]
['text':' d) use stream buffer','line_number':78,'multiline':False]
['text':' e) change locale back to original','line_number':79,'multiline':False]
['text':' f) destroy new codecvt facet','line_number':80,'multiline':False]
['text':'///////////////////////////////////////////////////////','line_number':89,'multiline':False]
['text':' fundamental types that need special treatment','line_number':90,'multiline':False]
['text':' trap usage of invalid uninitialized boolean which would','line_number':92,'multiline':False]
['text':' otherwise crash on load.','line_number':93,'multiline':False]
['text':'///////////////////////////////////////////////////////','line_number':121,'multiline':False]
['text':' saving of any types not listed above','line_number':122,'multiline':False]
['text':'///////////////////////////////////////////////////////','line_number':133,'multiline':False]
['text':' floating point types need even more special treatment','line_number':134,'multiline':False]
['text':' the following determines whether the type T is some sort','line_number':135,'multiline':False]
['text':' of floating point type.  Note that we then assume that','line_number':136,'multiline':False]
['text':' the stream << operator is defined on that type - if not','line_number':137,'multiline':False]
['text':' we'll get a compile time error. This is meant to automatically','line_number':138,'multiline':False]
['text':' support synthesized types which support floating point','line_number':139,'multiline':False]
['text':' operations. Also it should handle compiler dependent types','line_number':140,'multiline':False]
['text':' such long double.  Due to John Maddock.','line_number':141,'multiline':False]
['text':' must be a user mistake - can't serialize un-initialized data','line_number':156,'multiline':False]
['text':' The formulae for the number of decimla digits required is given in','line_number':162,'multiline':False]
['text':' http://www2.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1822.pdf','line_number':163,'multiline':False]
['text':' which is derived from Kahan's paper:','line_number':164,'multiline':False]
['text':' www.eecs.berkeley.edu/~wkahan/ieee754status/ieee754.ps','line_number':165,'multiline':False]
['text':' const unsigned int digits = (std::numeric_limits<T>::digits * 3010) / 10000;','line_number':166,'multiline':False]
['text':' note: I've commented out the above because I didn't get good results.  e.g.','line_number':167,'multiline':False]
['text':' in one case I got a difference of 19 units.','line_number':168,'multiline':False]
['text':' unformatted append of one character','line_number':188,'multiline':False]
['text':' unformatted append of null terminated string','line_number':196,'multiline':False]
['text':'namespace boost','line_number':205,'multiline':False]
['text':'namespace archive','line_number':206,'multiline':False]
['text':' pops abi_suffix.hpp pragmas','line_number':208,'multiline':False]
['text':' BOOST_ARCHIVE_BASIC_TEXT_OPRIMITIVE_HPP','line_number':210,'multiline':False]
