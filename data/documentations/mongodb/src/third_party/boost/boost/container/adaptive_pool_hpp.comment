['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' (C) Copyright Ion Gaztanaga 2005-2013. Distributed under the Boost','line_number':3,'multiline':False]
['text':' Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]
['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':' See http://www.boost.org/libs/container for documentation.','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////////////','line_number':9,'multiline':False]
['text':'!An STL node allocator that uses a modified DLMalloc as memory','line_number':45,'multiline':False]
['text':'!source.','line_number':46,'multiline':False]
['text':'!','line_number':47,'multiline':False]
['text':'!This node allocator shares a segregated storage between all instances','line_number':48,'multiline':False]
['text':'!of adaptive_pool with equal sizeof(T).','line_number':49,'multiline':False]
['text':'!','line_number':50,'multiline':False]
['text':'!NodesPerBlock is the number of nodes allocated at once when the allocator','line_number':51,'multiline':False]
['text':'!needs runs out of nodes. MaxFreeBlocks is the maximum number of totally free blocks','line_number':52,'multiline':False]
['text':'!that the adaptive node pool will hold. The rest of the totally free blocks will be','line_number':53,'multiline':False]
['text':'!deallocated to the memory manager.','line_number':54,'multiline':False]
['text':'!','line_number':55,'multiline':False]
['text':'!OverheadPercent is the (approximated) maximum size overhead (1-20%) of the allocator:','line_number':56,'multiline':False]
['text':'!(memory usable for nodes / total memory allocated from the memory allocator)','line_number':57,'multiline':False]
['text':'!If Version is 1, the allocator is a STL conforming allocator. If Version is 2,','line_number':66,'multiline':False]
['text':'!the allocator offers advanced expand in place and burst allocation capabilities.','line_number':67,'multiline':False]
['text':'-------','line_number':83,'multiline':False]
['text':'#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED','line_number':103,'multiline':False]
['text':'!Obtains adaptive_pool from','line_number':105,'multiline':False]
['text':'!adaptive_pool','line_number':106,'multiline':False]
['text':'!Not assignable from related adaptive_pool','line_number':121,'multiline':False]
['text':'#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED','line_number':126,'multiline':False]
['text':'!Default constructor','line_number':129,'multiline':False]
['text':'!Copy constructor from other adaptive_pool.','line_number':133,'multiline':False]
['text':'!Copy assignment from other adaptive_pool.','line_number':137,'multiline':False]
['text':'!Copy constructor from related adaptive_pool.','line_number':141,'multiline':False]
['text':'!Destructor','line_number':148,'multiline':False]
['text':'!Returns the number of elements that could be allocated.','line_number':152,'multiline':False]
['text':'!Never throws','line_number':153,'multiline':False]
['text':'!Allocate memory for an array of count elements.','line_number':157,'multiline':False]
['text':'!Throws bad_alloc if there is no enough memory','line_number':158,'multiline':False]
['text':'!Deallocate allocated memory.','line_number':175,'multiline':False]
['text':'!Never throws','line_number':176,'multiline':False]
['text':'!Returns maximum the number of objects the previously allocated memory','line_number':202,'multiline':False]
['text':'!pointed by p can hold.','line_number':203,'multiline':False]
['text':'!Allocates just one object. Memory allocated with this function','line_number':207,'multiline':False]
['text':'!must be deallocated only with deallocate_one().','line_number':208,'multiline':False]
['text':'!Throws bad_alloc if there is no enough memory','line_number':209,'multiline':False]
['text':'!Allocates many elements of size == 1.','line_number':218,'multiline':False]
['text':'!Elements must be individually deallocated with deallocate_one()','line_number':219,'multiline':False]
['text':'typename shared_pool_t::multiallocation_chain ch;','line_number':226,'multiline':False]
['text':'singleton_t::instance().allocate_nodes(num_elements, ch);','line_number':227,'multiline':False]
['text':'chain.incorporate_after','line_number':228,'multiline':False]
['text':'(chain.before_begin(), (T*)&*ch.begin(), (T*)&*ch.last(), ch.size());','line_number':229,'multiline':False]
['text':'!Deallocates memory previously allocated with allocate_one().','line_number':232,'multiline':False]
['text':'!You should never use deallocate_one to deallocate memory allocated','line_number':233,'multiline':False]
['text':'!with other functions different from allocate_one(). Never throws','line_number':234,'multiline':False]
['text':'typename shared_pool_t::multiallocation_chain ch(&*chain.begin(), &*chain.last(), chain.size());','line_number':248,'multiline':False]
['text':'singleton_t::instance().deallocate_nodes(ch);','line_number':249,'multiline':False]
['text':'!Allocates many elements of size elem_size.','line_number':253,'multiline':False]
['text':'!Elements must be individually deallocated with deallocate()','line_number':254,'multiline':False]
['text':'
      dlmalloc_memchain ch;
      BOOST_CONTAINER_MEMCHAIN_INIT(&ch);
      if(BOOST_UNLIKELY(!dlmalloc_multialloc_nodes(n_elements, elem_size*sizeof(T), BOOST_CONTAINER_DL_MULTIALLOC_DEFAULT_CONTIGUOUS, &ch))){
         boost::container::throw_bad_alloc();
      }
      chain.incorporate_after(chain.before_begin()
                             ,(T*)BOOST_CONTAINER_MEMCHAIN_FIRSTMEM(&ch)
                             ,(T*)BOOST_CONTAINER_MEMCHAIN_LASTMEM(&ch)
                             ,BOOST_CONTAINER_MEMCHAIN_SIZE(&ch) );','line_number':257,'multiline':True]
['text':'!Allocates n_elements elements, each one of size elem_sizes[i]','line_number':274,'multiline':False]
['text':'!Elements must be individually deallocated with deallocate()','line_number':275,'multiline':False]
['text':'
      dlmalloc_memchain ch;
      BOOST_CONTAINER_MEMCHAIN_INIT(&ch);
      if(BOOST_UNLIKELY(!dlmalloc_multialloc_arrays(n_elements, elem_sizes, sizeof(T), BOOST_CONTAINER_DL_MULTIALLOC_DEFAULT_CONTIGUOUS, &ch))){
         boost::container::throw_bad_alloc();
      }
      chain.incorporate_after(chain.before_begin()
                             ,(T*)BOOST_CONTAINER_MEMCHAIN_FIRSTMEM(&ch)
                             ,(T*)BOOST_CONTAINER_MEMCHAIN_LASTMEM(&ch)
                             ,BOOST_CONTAINER_MEMCHAIN_SIZE(&ch) );','line_number':278,'multiline':True]
['text':'
      dlmalloc_memchain ch;
      void *beg(&*chain.begin()), *last(&*chain.last());
      size_t size(chain.size());
      BOOST_CONTAINER_MEMCHAIN_INIT_FROM(&ch, beg, last, size);
      dlmalloc_multidealloc(&ch);','line_number':296,'multiline':True]
['text':'!Deallocates all free blocks of the pool','line_number':305,'multiline':False]
['text':'!Swaps allocators. Does not throw. If each allocator is placed in a','line_number':314,'multiline':False]
['text':'!different memory segment, the result is undefined.','line_number':315,'multiline':False]
['text':'!An allocator always compares to true, as memory allocated with one','line_number':319,'multiline':False]
['text':'!instance can be deallocated by another instance','line_number':320,'multiline':False]
['text':'!An allocator always compares to false, as memory allocated with one','line_number':324,'multiline':False]
['text':'!instance can be deallocated by another instance','line_number':325,'multiline':False]
['text':'!If Version is 1, the allocator is a STL conforming allocator. If Version is 2,','line_number':379,'multiline':False]
['text':'!the allocator offers advanced expand in place and burst allocation capabilities.','line_number':380,'multiline':False]
['text':'-------','line_number':400,'multiline':False]
['text':'#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED','line_number':420,'multiline':False]
['text':'!Obtains private_adaptive_pool from','line_number':422,'multiline':False]
['text':'!private_adaptive_pool','line_number':423,'multiline':False]
['text':'!Not assignable from related private_adaptive_pool','line_number':438,'multiline':False]
['text':'#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED','line_number':442,'multiline':False]
['text':'!Default constructor','line_number':445,'multiline':False]
['text':'!Copy constructor from other private_adaptive_pool.','line_number':449,'multiline':False]
['text':'!Copy assignment from other adaptive_pool.','line_number':453,'multiline':False]
['text':'!Copy constructor from related private_adaptive_pool.','line_number':457,'multiline':False]
['text':'!Destructor','line_number':464,'multiline':False]
['text':'!Returns the number of elements that could be allocated.','line_number':468,'multiline':False]
['text':'!Never throws','line_number':469,'multiline':False]
['text':'!Allocate memory for an array of count elements.','line_number':473,'multiline':False]
['text':'!Throws bad_alloc if there is no enough memory','line_number':474,'multiline':False]
['text':'!Deallocate allocated memory.','line_number':488,'multiline':False]
['text':'!Never throws','line_number':489,'multiline':False]
['text':'!Returns maximum the number of objects the previously allocated memory','line_number':512,'multiline':False]
['text':'!pointed by p can hold.','line_number':513,'multiline':False]
['text':'!Allocates just one object. Memory allocated with this function','line_number':517,'multiline':False]
['text':'!must be deallocated only with deallocate_one().','line_number':518,'multiline':False]
['text':'!Throws bad_alloc if there is no enough memory','line_number':519,'multiline':False]
['text':'!Allocates many elements of size == 1.','line_number':525,'multiline':False]
['text':'!Elements must be individually deallocated with deallocate_one()','line_number':526,'multiline':False]
['text':'!Deallocates memory previously allocated with allocate_one().','line_number':532,'multiline':False]
['text':'!You should never use deallocate_one to deallocate memory allocated','line_number':533,'multiline':False]
['text':'!with other functions different from allocate_one(). Never throws','line_number':534,'multiline':False]
['text':'!Allocates many elements of size elem_size.','line_number':545,'multiline':False]
['text':'!Elements must be individually deallocated with deallocate()','line_number':546,'multiline':False]
['text':'!Allocates n_elements elements, each one of size elem_sizes[i]','line_number':557,'multiline':False]
['text':'!Elements must be individually deallocated with deallocate()','line_number':558,'multiline':False]
['text':'!Deallocates all free blocks of the pool','line_number':574,'multiline':False]
['text':'!Swaps allocators. Does not throw. If each allocator is placed in a','line_number':580,'multiline':False]
['text':'!different memory segment, the result is undefined.','line_number':581,'multiline':False]
['text':'!An allocator always compares to true, as memory allocated with one','line_number':585,'multiline':False]
['text':'!instance can be deallocated by another instance','line_number':586,'multiline':False]
['text':'!An allocator always compares to false, as memory allocated with one','line_number':590,'multiline':False]
['text':'!instance can be deallocated by another instance','line_number':591,'multiline':False]
['text':'namespace container {','line_number':618,'multiline':False]
['text':'namespace boost {','line_number':619,'multiline':False]
['text':'#ifndef BOOST_CONTAINER_ADAPTIVE_POOL_HPP','line_number':623,'multiline':False]
