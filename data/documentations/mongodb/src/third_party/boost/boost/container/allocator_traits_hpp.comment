['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' (C) Copyright Pablo Halpern 2009. Distributed under the Boost','line_number':3,'multiline':False]
['text':' Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]
['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////////////','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':' (C) Copyright Ion Gaztanaga 2011-2013. Distributed under the Boost','line_number':9,'multiline':False]
['text':' Software License, Version 1.0. (See accompanying file','line_number':10,'multiline':False]
['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':11,'multiline':False]
['text':'','line_number':12,'multiline':False]
['text':' See http://www.boost.org/libs/container for documentation.','line_number':13,'multiline':False]
['text':'','line_number':14,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////////////','line_number':15,'multiline':False]
['text':' container','line_number':30,'multiline':False]
['text':'is_empty','line_number':33,'multiline':False]
['text':' intrusive','line_number':38,'multiline':False]
['text':' move','line_number':41,'multiline':False]
['text':' move/detail','line_number':43,'multiline':False]
['text':' other boost','line_number':47,'multiline':False]
['text':'#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED','line_number':82,'multiline':False]
['text':'namespace allocator_traits_detail {','line_number':97,'multiline':False]
['text':'workaround needed for C++03 compilers with no construct()','line_number':101,'multiline':False]
['text':'supporting rvalue references','line_number':102,'multiline':False]
['text':'namespace dtl {','line_number':133,'multiline':False]
['text':'#ifndef BOOST_CONTAINER_DOXYGEN_INVOKED','line_number':135,'multiline':False]
['text':'! The class template allocator_traits supplies a uniform interface to all allocator types.','line_number':137,'multiline':False]
['text':'! This class is a C++03-compatible implementation of std::allocator_traits','line_number':138,'multiline':False]
['text':'allocator_type','line_number':142,'multiline':False]
['text':'value_type','line_number':144,'multiline':False]
['text':'! Allocator::pointer if such a type exists; otherwise, value_type*','line_number':148,'multiline':False]
['text':'!','line_number':149,'multiline':False]
['text':'! Allocator::const_pointer if such a type exists ; otherwise, pointer_traits<pointer>::rebind<const','line_number':151,'multiline':False]
['text':'!','line_number':152,'multiline':False]
['text':'! Non-standard extension','line_number':154,'multiline':False]
['text':'! Allocator::reference if such a type exists; otherwise, value_type&','line_number':155,'multiline':False]
['text':'! Non-standard extension','line_number':157,'multiline':False]
['text':'! Allocator::const_reference if such a type exists ; otherwise, const value_type&','line_number':158,'multiline':False]
['text':'! Allocator::void_pointer if such a type exists ; otherwise, pointer_traits<pointer>::rebind<void>.','line_number':160,'multiline':False]
['text':'!','line_number':161,'multiline':False]
['text':'! Allocator::const_void_pointer if such a type exists ; otherwise, pointer_traits<pointer>::rebind<const','line_number':163,'multiline':False]
['text':'!','line_number':164,'multiline':False]
['text':'! Allocator::difference_type if such a type exists ; otherwise, pointer_traits<pointer>::difference_type.','line_number':166,'multiline':False]
['text':'!','line_number':167,'multiline':False]
['text':'! Allocator::size_type if such a type exists ; otherwise, make_unsigned<difference_type>::type','line_number':169,'multiline':False]
['text':'!','line_number':170,'multiline':False]
['text':'! Allocator::propagate_on_container_copy_assignment if such a type exists, otherwise a type','line_number':172,'multiline':False]
['text':'! with an internal constant static boolean member <code>value</code> == false.','line_number':173,'multiline':False]
['text':'! Allocator::propagate_on_container_move_assignment if such a type exists, otherwise a type','line_number':175,'multiline':False]
['text':'! with an internal constant static boolean member <code>value</code> == false.','line_number':176,'multiline':False]
['text':'! Allocator::propagate_on_container_swap if such a type exists, otherwise a type','line_number':178,'multiline':False]
['text':'! with an internal constant static boolean member <code>value</code> == false.','line_number':179,'multiline':False]
['text':'! Allocator::is_always_equal if such a type exists, otherwise a type','line_number':181,'multiline':False]
['text':'! with an internal constant static boolean member <code>value</code> == is_empty<Allocator>::value','line_number':182,'multiline':False]
['text':'! Allocator::is_partially_propagable if such a type exists, otherwise a type','line_number':184,'multiline':False]
['text':'! with an internal constant static boolean member <code>value</code> == false','line_number':185,'multiline':False]
['text':'! <b>Note</b>: Non-standard extension used to implement `small_vector_allocator`.','line_number':186,'multiline':False]
['text':'! Defines an allocator: Allocator::rebind<T>::other if such a type exists; otherwise, Allocator<T, Args>','line_number':188,'multiline':False]
['text':'! if Allocator is a class template instantiation of the form Allocator<U, Args>, where Args is zero or','line_number':189,'multiline':False]
['text':'! more type arguments ; otherwise, the instantiation of rebind_alloc is ill-formed.','line_number':190,'multiline':False]
['text':'!','line_number':191,'multiline':False]
['text':'! In C++03 compilers <code>rebind_alloc</code> is a struct derived from an allocator','line_number':192,'multiline':False]
['text':'! deduced by previously detailed rules.','line_number':193,'multiline':False]
['text':'! In C++03 compilers <code>rebind_traits</code> is a struct derived from','line_number':196,'multiline':False]
['text':'! <code>allocator_traits<OtherAlloc></code>, where <code>OtherAlloc</code> is','line_number':197,'multiline':False]
['text':'! the allocator deduced by rules explained in <code>rebind_alloc</code>.','line_number':198,'multiline':False]
['text':'! Non-standard extension: Portable allocator rebind for C++03 and C++11 compilers.','line_number':201,'multiline':False]
['text':'! <code>type</code> is an allocator related to Allocator deduced deduced by rules explained in <code>rebind_alloc</code>.','line_number':202,'multiline':False]
['text':'pointer','line_number':207,'multiline':False]
['text':'const_pointer','line_number':211,'multiline':False]
['text':'reference','line_number':216,'multiline':False]
['text':'const_reference','line_number':220,'multiline':False]
['text':'void_pointer','line_number':224,'multiline':False]
['text':'const_void_pointer','line_number':229,'multiline':False]
['text':'difference_type','line_number':234,'multiline':False]
['text':'size_type','line_number':238,'multiline':False]
['text':'propagate_on_container_copy_assignment','line_number':242,'multiline':False]
['text':'propagate_on_container_move_assignment','line_number':246,'multiline':False]
['text':'propagate_on_container_swap','line_number':250,'multiline':False]
['text':'is_always_equal','line_number':254,'multiline':False]
['text':'is_partially_propagable','line_number':258,'multiline':False]
['text':'rebind_alloc & rebind_traits','line_number':263,'multiline':False]
['text':'C++11','line_number':265,'multiline':False]
['text':' #if !defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)','line_number':268,'multiline':False]
['text':'Some workaround for C++03 or C++11 compilers with no template aliases','line_number':269,'multiline':False]
['text':' #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)','line_number':277,'multiline':False]
['text':'','line_number':281,'multiline':False]
['text':' #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)','line_number':284,'multiline':False]
['text':' #if !defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)','line_number':291,'multiline':False]
['text':'portable_rebind_alloc','line_number':293,'multiline':False]
['text':'BOOST_CONTAINER_DOXYGEN_INVOKED','line_number':297,'multiline':False]
['text':'! <b>Returns</b>: <code>a.allocate(n)</code>','line_number':299,'multiline':False]
['text':'!','line_number':300,'multiline':False]
['text':'! <b>Returns</b>: <code>a.deallocate(p, n)</code>','line_number':304,'multiline':False]
['text':'!','line_number':305,'multiline':False]
['text':'! <b>Throws</b>: Nothing','line_number':306,'multiline':False]
['text':'! <b>Effects</b>: calls <code>a.allocate(n, p)</code> if that call is well-formed;','line_number':310,'multiline':False]
['text':'! otherwise, invokes <code>a.allocate(n)</code>','line_number':311,'multiline':False]
['text':'! <b>Effects</b>: calls <code>a.destroy(p)</code> if that call is well-formed;','line_number':321,'multiline':False]
['text':'! otherwise, invokes <code>p->~T()</code>.','line_number':322,'multiline':False]
['text':'! <b>Returns</b>: <code>a.max_size()</code> if that expression is well-formed; otherwise,','line_number':334,'multiline':False]
['text':'! <code>numeric_limits<size_type>::max()</code>.','line_number':335,'multiline':False]
['text':'! <b>Returns</b>: <code>a.select_on_container_copy_construction()</code> if that expression is well-formed;','line_number':343,'multiline':False]
['text':'! otherwise, a.','line_number':344,'multiline':False]
['text':'! <b>Effects</b>: calls <code>a.construct(p, std::forward<Args>(args)...)</code> if that call is well-formed;','line_number':358,'multiline':False]
['text':'! otherwise, invokes <code>`placement new` (static_cast<void*>(p)) T(std::forward<Args>(args)...)</code>','line_number':359,'multiline':False]
['text':'! <b>Returns</b>: <code>a.storage_is_unpropagable(p)</code> if is_partially_propagable::value is true; otherwise,','line_number':373,'multiline':False]
['text':'! <code>false</code>.','line_number':374,'multiline':False]
['text':'! <b>Returns</b>: <code>true</code> if <code>is_always_equal::value == true</code>, otherwise,','line_number':381,'multiline':False]
['text':'! <code>a == b</code>.','line_number':382,'multiline':False]
['text':' #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)','line_number':425,'multiline':False]
['text':'','line_number':440,'multiline':False]
['text':'///////////////////////////////','line_number':445,'multiline':False]
['text':' priv_construct','line_number':446,'multiline':False]
['text':'///////////////////////////////','line_number':447,'multiline':False]
['text':'','line_number':456,'multiline':False]
['text':' #if !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)','line_number':460,'multiline':False]
['text':'#if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)','line_number':478,'multiline':False]
['text':'#if defined(BOOST_CONTAINER_DOXYGEN_INVOKED)','line_number':495,'multiline':False]
['text':'namespace container {','line_number':497,'multiline':False]
['text':'namespace boost {','line_number':498,'multiline':False]
['text':' ! defined(BOOST_CONTAINER_ALLOCATOR_ALLOCATOR_TRAITS_HPP)','line_number':502,'multiline':False]
