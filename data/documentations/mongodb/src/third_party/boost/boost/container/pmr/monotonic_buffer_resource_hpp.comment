['text':'////////////////////////////////////////////////////////////////////////////','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' (C) Copyright Ion Gaztanaga 2015-2015. Distributed under the Boost','line_number':3,'multiline':False]
['text':' Software License, Version 1.0. (See accompanying file','line_number':4,'multiline':False]
['text':' LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':' See http://www.boost.org/libs/container for documentation.','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////////////','line_number':9,'multiline':False]
['text':'! A monotonic_buffer_resource is a special-purpose memory resource intended for','line_number':31,'multiline':False]
['text':'! very fast memory allocations in situations where memory is used to build up a','line_number':32,'multiline':False]
['text':'! few objects and then is released all at once when the memory resource object','line_number':33,'multiline':False]
['text':'! is destroyed. It has the following qualities:','line_number':34,'multiline':False]
['text':'! ','line_number':35,'multiline':False]
['text':'! - A call to deallocate has no effect, thus the amount of memory consumed','line_number':36,'multiline':False]
['text':'!   increases monotonically until the resource is destroyed.','line_number':37,'multiline':False]
['text':'! ','line_number':38,'multiline':False]
['text':'! - The program can supply an initial buffer, which the allocator uses to satisfy','line_number':39,'multiline':False]
['text':'!   memory requests.','line_number':40,'multiline':False]
['text':'! ','line_number':41,'multiline':False]
['text':'! - When the initial buffer (if any) is exhausted, it obtains additional buffers','line_number':42,'multiline':False]
['text':'!   from an upstream memory resource supplied at construction. Each additional','line_number':43,'multiline':False]
['text':'!   buffer is larger than the previous one, following a geometric progression.','line_number':44,'multiline':False]
['text':'! ','line_number':45,'multiline':False]
['text':'! - It is intended for access from one thread of control at a time. Specifically,','line_number':46,'multiline':False]
['text':'!   calls to allocate and deallocate do not synchronize with one another.','line_number':47,'multiline':False]
['text':'! ','line_number':48,'multiline':False]
['text':'! - It owns the allocated memory and frees it on destruction, even if deallocate has','line_number':49,'multiline':False]
['text':'!   not been called for some of the allocated blocks.','line_number':50,'multiline':False]
['text':'/ @cond','line_number':61,'multiline':False]
['text':'/ @endcond','line_number':65,'multiline':False]
['text':'! The number of bytes that will be requested by the default in the first call','line_number':69,'multiline':False]
['text':'! to the upstream allocator','line_number':70,'multiline':False]
['text':'!','line_number':71,'multiline':False]
['text':'! <b>Note</b>: Non-standard extension.','line_number':72,'multiline':False]
['text':'! <b>Requires</b>: `upstream` shall be the address of a valid memory resource or `nullptr`','line_number':75,'multiline':False]
['text':'!','line_number':76,'multiline':False]
['text':'! <b>Effects</b>: If `upstream` is not nullptr, sets the internal resource to `upstream`,','line_number':77,'multiline':False]
['text':'!   to get_default_resource() otherwise.','line_number':78,'multiline':False]
['text':'!   Sets the internal `current_buffer` to `nullptr` and the internal `next_buffer_size` to an','line_number':79,'multiline':False]
['text':'!   implementation-defined size.','line_number':80,'multiline':False]
['text':'! <b>Requires</b>: `upstream` shall be the address of a valid memory resource or `nullptr`','line_number':83,'multiline':False]
['text':'!   and `initial_size` shall be greater than zero.','line_number':84,'multiline':False]
['text':'!','line_number':85,'multiline':False]
['text':'! <b>Effects</b>: If `upstream` is not nullptr, sets the internal resource to `upstream`,','line_number':86,'multiline':False]
['text':'!   to get_default_resource() otherwise. Sets the internal `current_buffer` to `nullptr` and','line_number':87,'multiline':False]
['text':'!   `next_buffer_size` to at least `initial_size`.','line_number':88,'multiline':False]
['text':'! <b>Requires</b>: `upstream` shall be the address of a valid memory resource or `nullptr`,','line_number':91,'multiline':False]
['text':'!   `buffer_size` shall be no larger than the number of bytes in buffer.','line_number':92,'multiline':False]
['text':'!','line_number':93,'multiline':False]
['text':'! <b>Effects</b>: If `upstream` is not nullptr, sets the internal resource to `upstream`,','line_number':94,'multiline':False]
['text':'!   to get_default_resource() otherwise. Sets the internal `current_buffer` to `buffer`,','line_number':95,'multiline':False]
['text':'!   and `next_buffer_size` to `buffer_size` (but not less than an implementation-defined size),','line_number':96,'multiline':False]
['text':'!   then increases `next_buffer_size` by an implementation-defined growth factor (which need not be integral).','line_number':97,'multiline':False]
['text':'! <b>Effects</b>: Calls','line_number':110,'multiline':False]
['text':'!   `this->release()`.','line_number':111,'multiline':False]
['text':'! <b>Effects</b>: `upstream_resource()->deallocate()` as necessary to release all allocated memory.','line_number':114,'multiline':False]
['text':'!   [Note: memory is released back to `upstream_resource()` even if some blocks that were allocated','line_number':115,'multiline':False]
['text':'!   from this have not been deallocated from this. - end note]','line_number':116,'multiline':False]
['text':'! <b>Returns</b>: The value of','line_number':119,'multiline':False]
['text':'!   the internal resource.','line_number':120,'multiline':False]
['text':'! <b>Returns</b>:','line_number':123,'multiline':False]
['text':'!   The number of bytes of storage available for the specified alignment and','line_number':124,'multiline':False]
['text':'!   the number of bytes wasted due to the requested alignment.','line_number':125,'multiline':False]
['text':'!','line_number':126,'multiline':False]
['text':'! <b>Note</b>: Non-standard extension.','line_number':127,'multiline':False]
['text':'! <b>Returns</b>:','line_number':130,'multiline':False]
['text':'!   The number of bytes of storage available for the specified alignment.','line_number':131,'multiline':False]
['text':'!','line_number':132,'multiline':False]
['text':'! <b>Note</b>: Non-standard extension.','line_number':133,'multiline':False]
['text':'! <b>Returns</b>:','line_number':136,'multiline':False]
['text':'!   The address pointing to the start of the current free storage.','line_number':137,'multiline':False]
['text':'!','line_number':138,'multiline':False]
['text':'! <b>Note</b>: Non-standard extension.','line_number':139,'multiline':False]
['text':'! <b>Returns</b>:','line_number':142,'multiline':False]
['text':'!   The number of bytes that will be requested for the next buffer once the','line_number':143,'multiline':False]
['text':'!   current one is exhausted.','line_number':144,'multiline':False]
['text':'!','line_number':145,'multiline':False]
['text':'! <b>Note</b>: Non-standard extension.','line_number':146,'multiline':False]
['text':'! <b>Returns</b>: A pointer to allocated storage with a size of at least `bytes`. The size','line_number':151,'multiline':False]
['text':'!   and alignment of the allocated memory shall meet the requirements for a class derived','line_number':152,'multiline':False]
['text':'!   from `memory_resource`.','line_number':153,'multiline':False]
['text':'!','line_number':154,'multiline':False]
['text':'! <b>Effects</b>: If the unused space in the internal `current_buffer` can fit a block with the specified','line_number':155,'multiline':False]
['text':'!   bytes and alignment, then allocate the return block from the internal `current_buffer`; otherwise sets','line_number':156,'multiline':False]
['text':'!   the internal `current_buffer` to `upstream_resource()->allocate(n, m)`, where `n` is not less than','line_number':157,'multiline':False]
['text':'!   `max(bytes, next_buffer_size)` and `m` is not less than alignment, and increase','line_number':158,'multiline':False]
['text':'!   `next_buffer_size` by an implementation-defined growth factor (which need not be integral),','line_number':159,'multiline':False]
['text':'!   then allocate the return block from the newly-allocated internal `current_buffer`.','line_number':160,'multiline':False]
['text':'!','line_number':161,'multiline':False]
['text':'! <b>Throws</b>: Nothing unless `upstream_resource()->allocate()` throws.','line_number':162,'multiline':False]
['text':'! <b>Effects</b>: None','line_number':165,'multiline':False]
['text':'!','line_number':166,'multiline':False]
['text':'! <b>Throws</b>: Nothing','line_number':167,'multiline':False]
['text':'!','line_number':168,'multiline':False]
['text':'! <b>Remarks</b>: Memory used by this resource increases monotonically until its destruction.','line_number':169,'multiline':False]
['text':'! <b>Returns</b>:','line_number':172,'multiline':False]
['text':'!   `this == dynamic_cast<const monotonic_buffer_resource*>(&other)`.','line_number':173,'multiline':False]
['text':'namespace pmr {','line_number':177,'multiline':False]
['text':'namespace container {','line_number':178,'multiline':False]
['text':'namespace boost {','line_number':179,'multiline':False]
['text':'BOOST_CONTAINER_PMR_MONOTONIC_BUFFER_RESOURCE_HPP','line_number':183,'multiline':False]
