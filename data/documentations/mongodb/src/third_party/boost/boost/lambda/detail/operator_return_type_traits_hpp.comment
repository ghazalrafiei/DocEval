['text':'  operator_return_type_traits.hpp -- Boost Lambda Library ------------------','line_number':1,'multiline':False]
['text':' Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)','line_number':3,'multiline':False]
['text':'','line_number':4,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0. (See','line_number':5,'multiline':False]
['text':' accompanying file LICENSE_1_0.txt or copy at','line_number':6,'multiline':False]
['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':' For more information, see www.boost.org','line_number':9,'multiline':False]
['text':' needed for the ptrdiff_t','line_number':26,'multiline':False]
['text':' for istream and ostream','line_number':27,'multiline':False]
['text':' needed for operator&','line_number':29,'multiline':False]
['text':' -- general helper templates for type deduction ------------------','line_number':35,'multiline':False]
['text':' Much of the type deduction code for standard arithmetic types from Gary Powell','line_number':37,'multiline':False]
['text':' this means that a code is not defined for A','line_number':40,'multiline':False]
['text':' -- the next 5 types are needed in if_then_else_return ','line_number':42,'multiline':False]
['text':' the promotion order is not important, but they must have distinct values.','line_number':43,'multiline':False]
['text':' ----------','line_number':49,'multiline':False]
['text':' TODO: wchar_t','line_number':60,'multiline':False]
['text':' forward delcaration of complex.','line_number':62,'multiline':False]
['text':' namespace detail','line_number':64,'multiline':False]
['text':' namespace lambda ','line_number':65,'multiline':False]
['text':' namespace boost','line_number':66,'multiline':False]
['text':' -- int promotion -------------------------------------------','line_number':76,'multiline':False]
['text':' The unsigned short int promotion rule is this:','line_number':85,'multiline':False]
['text':' unsigned short int to signed int if a signed int can hold all values ','line_number':86,'multiline':False]
['text':' of unsigned short int, otherwise go to unsigned int.','line_number':87,'multiline':False]
['text':' I had the logic reversed but ">" messes up the parsing.','line_number':92,'multiline':False]
['text':' TODO: think, should there be default behaviour for non-standard types?','line_number':98,'multiline':False]
['text':' namespace detail','line_number':100,'multiline':False]
['text':' ------------------------------------------ ','line_number':102,'multiline':False]
['text':' Unary actions ----------------------------','line_number':103,'multiline':False]
['text':' ------------------------------------------ ','line_number':104,'multiline':False]
['text':' bitwise not, operator~()','line_number':133,'multiline':False]
['text':' prefix increment and decrement operators return ','line_number':143,'multiline':False]
['text':' their argument by default as a non-const reference','line_number':144,'multiline':False]
['text':' post decrement just returns the same plain type.','line_number':159,'multiline':False]
['text':' logical not, operator!()','line_number':175,'multiline':False]
['text':' address of action ---------------------------------------','line_number':190,'multiline':False]
['text':' If no user defined specialization for A, then return the','line_number':201,'multiline':False]
['text':' cv qualified pointer to A','line_number':202,'multiline':False]
['text':' contentsof action ------------------------------------','line_number':210,'multiline':False]
['text':' TODO: this deduction may lead to fail directly, ','line_number':212,'multiline':False]
['text':' (if A has no specialization for iterator_traits and has no','line_number':213,'multiline':False]
['text':' typedef A::reference.','line_number':214,'multiline':False]
['text':' There is no easy way around this, cause there doesn't seem to be a way','line_number':215,'multiline':False]
['text':' to test whether a class is an iterator or not.','line_number':216,'multiline':False]
['text':' The default works with std::iterators.','line_number':218,'multiline':False]
['text':' A is a nonreference type','line_number':222,'multiline':False]
['text':' this is since the nullary () in lambda_functor is always instantiated','line_number':227,'multiline':False]
['text':' standard iterator traits should take care of the pointer types ','line_number':245,'multiline':False]
['text':' but just to be on the safe side, we have the specializations here:','line_number':246,'multiline':False]
['text':' these work even if A is cv-qualified.','line_number':247,'multiline':False]
['text':' end detail','line_number':278,'multiline':False]
['text':' If no user defined specialization for A, then return the','line_number':289,'multiline':False]
['text':' cv qualified pointer to A','line_number':290,'multiline':False]
['text':' ------------------------------------------------------------------','line_number':302,'multiline':False]
['text':' binary actions ---------------------------------------------------','line_number':303,'multiline':False]
['text':' ------------------------------------------------------------------','line_number':304,'multiline':False]
['text':' here the default case is: no user defined versions:','line_number':306,'multiline':False]
['text':' error classes','line_number':314,'multiline':False]
['text':' pointer arithmetic type deductions ----------------------','line_number':317,'multiline':False]
['text':' value = false means that this is not a pointer arithmetic case','line_number':318,'multiline':False]
['text':' value = true means, that this can be a pointer arithmetic case, but not necessarily is','line_number':319,'multiline':False]
['text':' This means, that for user defined operators for pointer types, say for some operator+(X, *Y),','line_number':320,'multiline':False]
['text':' the deductions must be coded at an earliel level (return_type_2).','line_number':321,'multiline':False]
['text':' can't add two pointers.','line_number':339,'multiline':False]
['text':' note, that we do not check wether the other type is valid for ','line_number':340,'multiline':False]
['text':' addition with a pointer.','line_number':341,'multiline':False]
['text':' the compiler will catch it in the apply function','line_number':342,'multiline':False]
['text':' ptr - ptr has type ptrdiff_t','line_number':382,'multiline':False]
['text':' note, that we do not check if, in ptr - B, B is ','line_number':383,'multiline':False]
['text':' valid for subtraction with a pointer.','line_number':384,'multiline':False]
['text':' the compiler will catch it in the apply function','line_number':385,'multiline':False]
['text':' namespace detail','line_number':398,'multiline':False]
['text':' -- arithmetic actions ---------------------------------------------','line_number':400,'multiline':False]
['text':' namespace detail','line_number':410,'multiline':False]
['text':' drop any qualifiers from the argument types within arithmetic_action','line_number':413,'multiline':False]
['text':' if user defined return type, do not enter the whole arithmetic deductions','line_number':423,'multiline':False]
['text':' perform integral promotion, no pointer arithmetic','line_number':436,'multiline':False]
['text':' pointer_arithmetic','line_number':447,'multiline':False]
['text':' specialization for unsigned int.','line_number':464,'multiline':False]
['text':' We only have to do these two specialization because the value promotion will','line_number':465,'multiline':False]
['text':' take care of the other cases.','line_number':466,'multiline':False]
['text':' The unsigned int promotion rule is this:','line_number':467,'multiline':False]
['text':' unsigned int to long if a long can hold all values of unsigned int,','line_number':468,'multiline':False]
['text':' otherwise go to unsigned long.','line_number':469,'multiline':False]
['text':' struct so I don't have to type this twice.','line_number':471,'multiline':False]
['text':' enums for KCC','line_number':494,'multiline':False]
['text':' namespace detail','line_number':507,'multiline':False]
['text':' --  bitwise actions -------------------------------------------','line_number':509,'multiline':False]
['text':' note: for integral types deuduction is similar to arithmetic actions. ','line_number':510,'multiline':False]
['text':' drop any qualifiers from the argument types within arithmetic action','line_number':512,'multiline':False]
['text':' if user defined return type, do not enter type deductions','line_number':523,'multiline':False]
['text':' plus_action is just a random pick, has to be a concrete instance','line_number':531,'multiline':False]
['text':' TODO: This check is only valid for built-in types, overloaded types might','line_number':533,'multiline':False]
['text':' accept floating point operators','line_number':534,'multiline':False]
['text':' bitwise operators not defined for floating point types','line_number':536,'multiline':False]
['text':' these test are not strictly needed here, since the error will be caught in','line_number':537,'multiline':False]
['text':' the apply function','line_number':538,'multiline':False]
['text':'reference to the stream ','line_number':563,'multiline':False]
['text':'reference to the stream ','line_number':575,'multiline':False]
['text':' end detail','line_number':582,'multiline':False]
['text':' ostream','line_number':584,'multiline':False]
['text':' if user defined return type, do not enter type deductions','line_number':594,'multiline':False]
['text':' istream','line_number':603,'multiline':False]
['text':' if user defined return type, do not enter type deductions','line_number':613,'multiline':False]
['text':' -- logical actions ----------------------------------------','line_number':622,'multiline':False]
['text':' always bool','line_number':623,'multiline':False]
['text':' NOTE: this may not be true for some weird user-defined types,','line_number':624,'multiline':False]
['text':' -- relational actions ----------------------------------------','line_number':642,'multiline':False]
['text':' always bool','line_number':643,'multiline':False]
['text':' NOTE: this may not be true for some weird user-defined types,','line_number':644,'multiline':False]
['text':' Assingment actions -----------------------------------------------','line_number':660,'multiline':False]
['text':' return type is the type of the first argument as reference','line_number':661,'multiline':False]
['text':' note that cv-qualifiers are preserved.','line_number':663,'multiline':False]
['text':' Yes, assignment operator can be const!','line_number':664,'multiline':False]
['text':' NOTE: this may not be true for some weird user-defined types,','line_number':666,'multiline':False]
['text':' -- other actions ----------------------------------------','line_number':724,'multiline':False]
['text':' comma action ----------------------------------','line_number':726,'multiline':False]
['text':' Note: this may not be true for some weird user-defined types,','line_number':727,'multiline':False]
['text':' NOTE! This only tries the plain_return_type_2 layer and gives','line_number':729,'multiline':False]
['text':' detail::unspecified as default. If no such specialization is found, the ','line_number':730,'multiline':False]
['text':' type rule in the spcecialization of the return_type_2_prot is used','line_number':731,'multiline':False]
['text':' to give the type of the right argument (which can be a reference too)','line_number':732,'multiline':False]
['text':' (The built in operator, can return a l- or rvalue).','line_number':733,'multiline':False]
['text':' subscript action -----------------------------------------------','line_number':746,'multiline':False]
['text':' A and B are nonreference types','line_number':750,'multiline':False]
['text':' these 3 specializations are needed to make gcc <3 happy','line_number':773,'multiline':False]
['text':' end detail','line_number':784,'multiline':False]
['text':' T == std::map<Key, T, Cmp, Allocator>::mapped_type; ','line_number':812,'multiline':False]
['text':' T == std::map<Key, T, Cmp, Allocator>::mapped_type; ','line_number':818,'multiline':False]
['text':' deque','line_number':821,'multiline':False]
['text':' vector','line_number':831,'multiline':False]
['text':' basic_string','line_number':841,'multiline':False]
['text':' namespace lambda','line_number':887,'multiline':False]
['text':' namespace boost','line_number':888,'multiline':False]
