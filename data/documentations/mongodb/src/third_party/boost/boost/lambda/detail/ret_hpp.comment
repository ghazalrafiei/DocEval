['text':' Boost Lambda Library  ret.hpp -----------------------------------------','line_number':1,'multiline':False]
['text':' Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)','line_number':3,'multiline':False]
['text':'','line_number':4,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0. (See','line_number':5,'multiline':False]
['text':' accompanying file LICENSE_1_0.txt or copy at','line_number':6,'multiline':False]
['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':' For more information, see www.boost.org','line_number':9,'multiline':False]
['text':' TODO:','line_number':18,'multiline':False]
['text':'  Add specializations for function references for ret, protect and unlambda','line_number':20,'multiline':False]
['text':'  e.g void foo(); unlambda(foo); fails, as it would add a const qualifier','line_number':21,'multiline':False]
['text':' for a function type. ','line_number':22,'multiline':False]
['text':' on the other hand unlambda(*foo) does work','line_number':23,'multiline':False]
['text':' -- ret -------------------------','line_number':26,'multiline':False]
['text':' the explicit return type template ','line_number':27,'multiline':False]
['text':' TODO: It'd be nice to make ret a nop for other than lambda functors','line_number':29,'multiline':False]
['text':' but causes an ambiguiyty with gcc (not with KCC), check what is the','line_number':30,'multiline':False]
['text':' right interpretation.','line_number':31,'multiline':False]
['text':'  // ret for others than lambda functors has no effect','line_number':33,'multiline':False]
['text':' template <class U, class T>','line_number':34,'multiline':False]
['text':' inline const T& ret(const T& t) { return t; }','line_number':35,'multiline':False]
['text':' protect ------------------','line_number':56,'multiline':False]
['text':' protecting others than lambda functors has no effect','line_number':58,'multiline':False]
['text':' -------------------------------------------------------------------','line_number':80,'multiline':False]
['text':' Hides the lambda functorness of a lambda functor. ','line_number':82,'multiline':False]
['text':' After this, the functor is immune to argument substitution, etc.','line_number':83,'multiline':False]
['text':' This can be used, e.g. to make it safe to pass lambda functors as ','line_number':84,'multiline':False]
['text':' arguments to functions, which might use them as target functions','line_number':85,'multiline':False]
['text':' note, unlambda and protect are different things. Protect hides the lambda','line_number':87,'multiline':False]
['text':' functor for one application, unlambda for good.','line_number':88,'multiline':False]
['text':' This functor defines the result_type typedef.','line_number':96,'multiline':False]
['text':' The result type must be deducible without knowing the arguments','line_number':97,'multiline':False]
['text':' Due to a language restriction, lambda functors cannot be made to','line_number':143,'multiline':False]
['text':' accept non-const rvalue arguments. Usually iterators do not return ','line_number':144,'multiline':False]
['text':' temporaries, but sometimes they do. That's why a workaround is provided.','line_number':145,'multiline':False]
['text':' Note, that this potentially breaks const correctness, so be careful!','line_number':146,'multiline':False]
['text':' any lambda functor can be turned into a const_incorrect_lambda_functor','line_number':148,'multiline':False]
['text':' The operator() takes arguments as consts and then casts constness','line_number':149,'multiline':False]
['text':' away. So this breaks const correctness!!! but is a necessary workaround','line_number':150,'multiline':False]
['text':' in some cases due to language limitations.','line_number':151,'multiline':False]
['text':' Note, that this is not a lambda_functor anymore, so it can not be used','line_number':152,'multiline':False]
['text':' as a sub lambda expression.','line_number':153,'multiline':False]
['text':' The nullary case is not needed (no arguments, no parameter type problems)','line_number':168,'multiline':False]
['text':' ------------------------------------------------------------------------','line_number':189,'multiline':False]
['text':' any lambda functor can be turned into a const_parameter_lambda_functor','line_number':190,'multiline':False]
['text':' The operator() takes arguments as const.','line_number':191,'multiline':False]
['text':' This is useful if lambda functors are called with non-const rvalues.','line_number':192,'multiline':False]
['text':' Note, that this is not a lambda_functor anymore, so it can not be used','line_number':193,'multiline':False]
['text':' as a sub lambda expression.','line_number':194,'multiline':False]
['text':' The nullary case is not needed: no arguments, no constness problems.','line_number':209,'multiline':False]
['text':' make void ------------------------------------------------','line_number':246,'multiline':False]
['text':' make_void( x ) turns a lambda functor x with some return type y into','line_number':247,'multiline':False]
['text':' another lambda functor, which has a void return type','line_number':248,'multiline':False]
['text':' when called, the original return type is discarded','line_number':249,'multiline':False]
['text':' we use this action. The action class will be called, which means that','line_number':251,'multiline':False]
['text':' the wrapped lambda functor is evaluated, but we just don't do anything','line_number':252,'multiline':False]
['text':' with the result.','line_number':253,'multiline':False]
['text':' for non-lambda functors, make_void does nothing ','line_number':279,'multiline':False]
['text':' (the argument gets evaluated immediately)','line_number':280,'multiline':False]
['text':' std_functor -----------------------------------------------------','line_number':292,'multiline':False]
['text':'  The STL uses the result_type typedef as the convention to let binders know','line_number':294,'multiline':False]
['text':'  the return type of a function object. ','line_number':295,'multiline':False]
['text':'  LL uses the sig template.','line_number':296,'multiline':False]
['text':'  To let LL know that the function object has the result_type typedef ','line_number':297,'multiline':False]
['text':'  defined, it can be wrapped with the std_functor function.','line_number':298,'multiline':False]
['text':' Just inherit form the template parameter (the standard functor), ','line_number':301,'multiline':False]
['text':' and provide a sig template. So we have a class which is still the','line_number':302,'multiline':False]
['text':' same functor + the sig template.','line_number':303,'multiline':False]
['text':' namespace lambda ','line_number':315,'multiline':False]
['text':' namespace boost','line_number':316,'multiline':False]
