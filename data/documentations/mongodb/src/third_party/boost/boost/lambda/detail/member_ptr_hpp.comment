['text':' Boost Lambda Library -- member_ptr.hpp ---------------------','line_number':1,'multiline':False]
['text':' Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)','line_number':3,'multiline':False]
['text':' Copyright (C) 2000 Gary Powell (gary.powell@sierra.com)','line_number':4,'multiline':False]
['text':'','line_number':5,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0. (See','line_number':6,'multiline':False]
['text':' accompanying file LICENSE_1_0.txt or copy at','line_number':7,'multiline':False]
['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':8,'multiline':False]
['text':'','line_number':9,'multiline':False]
['text':' For more information, see www.boost.org','line_number':10,'multiline':False]
['text':' --------------------------------------------------------------------------','line_number':12,'multiline':False]
['text':' the boost type_traits member_pointer traits are not enough, ','line_number':26,'multiline':False]
['text':' need to know more details.','line_number':27,'multiline':False]
['text':' -- nonconst member functions --','line_number':73,'multiline':False]
['text':' -- const member functions --','line_number':158,'multiline':False]
['text':' -- volatile --','line_number':243,'multiline':False]
['text':' -- const volatile','line_number':328,'multiline':False]
['text':' detail','line_number':412,'multiline':False]
['text':' this class holds a pointer to a member function and the object.','line_number':416,'multiline':False]
['text':' when called, it just calls the member function with the parameters ','line_number':417,'multiline':False]
['text':' provided','line_number':418,'multiline':False]
['text':' It would have been possible to use existing lambda_functors to represent','line_number':420,'multiline':False]
['text':' a bound member function like this, but to have a separate template is ','line_number':421,'multiline':False]
['text':' safer, since now this functor doesn't mix and match with lambda_functors','line_number':422,'multiline':False]
['text':' only thing you can do with this is to call it','line_number':423,'multiline':False]
['text':' note that previously instantiated classes ','line_number':425,'multiline':False]
['text':' (other_action<member_pointer_action> and member_pointer_action_helper','line_number':426,'multiline':False]
['text':' guarantee, that A and B are ','line_number':427,'multiline':False]
['text':' such types, that for objects a and b of corresponding types, a->*b leads ','line_number':428,'multiline':False]
['text':' to the builtin ->* to be called. So types that would end in a  call to ','line_number':429,'multiline':False]
['text':' a user defined ->* do not create a member_pointer_caller object.','line_number':430,'multiline':False]
['text':' helper templates for return type deduction and action classes','line_number':495,'multiline':False]
['text':' different cases for data member, function member, neither','line_number':496,'multiline':False]
['text':' true-true case','line_number':498,'multiline':False]
['text':' cannot be both, no body provided','line_number':501,'multiline':False]
['text':' data member case','line_number':503,'multiline':False]
['text':' this means, that B is a data member and A is a pointer type,','line_number':504,'multiline':False]
['text':' so either built-in ->* should be called, or there is an error','line_number':505,'multiline':False]
['text':' we remove the reference now, as we may have to add cv:s ','line_number':521,'multiline':False]
['text':' A is a reference to pointer','line_number':524,'multiline':False]
['text':' remove the top level cv qualifiers and reference','line_number':525,'multiline':False]
['text':' A is a pointer type, so take the type pointed to','line_number':529,'multiline':False]
['text':' For non-reference types, we must add const and/or volatile if','line_number':533,'multiline':False]
['text':' the pointer type has these qualifiers','line_number':534,'multiline':False]
['text':' If the member is a reference, these do not have any effect','line_number':535,'multiline':False]
['text':'   (cv T == T if T is a reference type)','line_number':536,'multiline':False]
['text':' add reference back','line_number':547,'multiline':False]
['text':' neither case','line_number':552,'multiline':False]
['text':' not a built in member pointer operator, just call ->*','line_number':558,'multiline':False]
['text':' an overloaded member pointer operators, user should have specified','line_number':561,'multiline':False]
['text':' the return type','line_number':562,'multiline':False]
['text':' At this point we know that there is no matching specialization for','line_number':563,'multiline':False]
['text':' return_type_2, so try return_type_2_plain','line_number':564,'multiline':False]
['text':' member pointer function case','line_number':576,'multiline':False]
['text':' This is a built in ->* call for a member function, ','line_number':577,'multiline':False]
['text':' the only thing that you can do with that, is to give it some arguments','line_number':578,'multiline':False]
['text':' note, it is guaranteed that A is a pointer type, and thus it cannot','line_number':579,'multiline':False]
['text':' be a call to overloaded ->*','line_number':580,'multiline':False]
['text':' we always strip cv:s to ','line_number':591,'multiline':False]
['text':' make the two routes (calling and type deduction)','line_number':592,'multiline':False]
['text':' to give the same results (and the const does not make any functional','line_number':593,'multiline':False]
['text':' difference)','line_number':594,'multiline':False]
['text':' detail','line_number':608,'multiline':False]
['text':' return type deduction --','line_number':626,'multiline':False]
['text':' If the right argument is a pointer to data member, ','line_number':628,'multiline':False]
['text':' and the left argument is of compatible pointer to class type','line_number':629,'multiline':False]
['text':' return type is a reference to the data member type','line_number':630,'multiline':False]
['text':' if right argument is a pointer to a member function, and the left ','line_number':632,'multiline':False]
['text':' argument is of a compatible type, the return type is a ','line_number':633,'multiline':False]
['text':' member_pointer_caller (see above)','line_number':634,'multiline':False]
['text':' Otherwise, return type deduction fails. There is either an error, ','line_number':636,'multiline':False]
['text':' or the user is trying to call an overloaded ->*','line_number':637,'multiline':False]
['text':' In such a case either ret<> must be used, or a return_type_2 user ','line_number':638,'multiline':False]
['text':' defined specialization must be provided','line_number':639,'multiline':False]
['text':' this is the way the generic lambda_functor_base functions instantiate','line_number':655,'multiline':False]
['text':' return type deduction. We turn it into return_type_2, so that the ','line_number':656,'multiline':False]
['text':' user can provide specializations on that level.','line_number':657,'multiline':False]
['text':' namespace lambda ','line_number':727,'multiline':False]
['text':' namespace boost','line_number':728,'multiline':False]
