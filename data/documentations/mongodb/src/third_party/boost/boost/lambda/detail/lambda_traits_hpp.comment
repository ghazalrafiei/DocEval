['text':' - lambda_traits.hpp --- Boost Lambda Library ----------------------------','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)','line_number':3,'multiline':False]
['text':'','line_number':4,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0. (See','line_number':5,'multiline':False]
['text':' accompanying file LICENSE_1_0.txt or copy at','line_number':6,'multiline':False]
['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':' For more information, see www.boost.org','line_number':9,'multiline':False]
['text':' -------------------------------------------------------------------------','line_number':10,'multiline':False]
['text':' -- if construct ------------------------------------------------','line_number':24,'multiline':False]
['text':' Proposed by Krzysztof Czarnecki and Ulrich Eisenecker','line_number':25,'multiline':False]
['text':' An if construct that doesn't instantiate the non-matching template:','line_number':36,'multiline':False]
['text':' Called as: ','line_number':38,'multiline':False]
['text':'  IF_type<condition, A, B>::type ','line_number':39,'multiline':False]
['text':' The matching template must define the typeded 'type'','line_number':40,'multiline':False]
['text':' I.e. A::type if condition is true, B::type if condition is false','line_number':41,'multiline':False]
['text':' Idea from Vesa Karvonen (from C&E as well I guess)','line_number':42,'multiline':False]
['text':' helper that can be used to give typedef T to some type','line_number':57,'multiline':False]
['text':' An if construct for finding an integral constant 'value'','line_number':60,'multiline':False]
['text':' Does not instantiate the non-matching branch','line_number':61,'multiline':False]
['text':' Called as IF_value<condition, A, B>::value','line_number':62,'multiline':False]
['text':' If condition is true A::value must be defined, otherwise B::value','line_number':63,'multiline':False]
['text':' --------------------------------------------------------------','line_number':79,'multiline':False]
['text':' removes reference from other than function types:','line_number':81,'multiline':False]
['text':' returns a reference to the element of tuple T','line_number':104,'multiline':False]
['text':' returns the cv and reverence stripped type of a tuple element','line_number':112,'multiline':False]
['text':' is_lambda_functor -------------------------------------------------   ','line_number':120,'multiline':False]
['text':' end detail','line_number':130,'multiline':False]
['text':' -- parameter_traits_ ---------------------------------------------','line_number':144,'multiline':False]
['text':' An internal parameter type traits class that respects','line_number':146,'multiline':False]
['text':' the reference_wrapper class.','line_number':147,'multiline':False]
['text':' The conversions performed are:','line_number':149,'multiline':False]
['text':' references -> compile_time_error','line_number':150,'multiline':False]
['text':' T1 -> T2, ','line_number':151,'multiline':False]
['text':' reference_wrapper<T> -> T&','line_number':152,'multiline':False]
['text':' const array -> ref to const array','line_number':153,'multiline':False]
['text':' array -> ref to array','line_number':154,'multiline':False]
['text':' function -> ref to function','line_number':155,'multiline':False]
['text':' ------------------------------------------------------------------------','line_number':157,'multiline':False]
['text':' Do not instantiate with reference types','line_number':164,'multiline':False]
['text':' Arrays can't be stored as plain types; convert them to references','line_number':171,'multiline':False]
['text':' Are the volatile versions needed?','line_number':226,'multiline':False]
['text':' end namespace detail','line_number':237,'multiline':False]
['text':' ------------------------------------------------------------------------','line_number':240,'multiline':False]
['text':' traits classes for lambda expressions (bind functions, operators ...)   ','line_number':241,'multiline':False]
['text':' must be instantiated with non-reference types','line_number':243,'multiline':False]
['text':' The default is const plain type -------------------------','line_number':245,'multiline':False]
['text':' const T -> const T, ','line_number':246,'multiline':False]
['text':' T -> const T, ','line_number':247,'multiline':False]
['text':' references -> compile_time_error','line_number':248,'multiline':False]
['text':' reference_wrapper<T> -> T&','line_number':249,'multiline':False]
['text':' array -> const ref array','line_number':250,'multiline':False]
['text':' T may be a function type. Without the IF test, const would be added ','line_number':260,'multiline':False]
['text':' to a function type, which is illegal.','line_number':261,'multiline':False]
['text':' all arrays are converted to const.','line_number':263,'multiline':False]
['text':' This traits template is used for 'const T&' parameter passing ','line_number':264,'multiline':False]
['text':' and thus the knowledge of the potential ','line_number':265,'multiline':False]
['text':' non-constness of an actual argument is lost.   ','line_number':266,'multiline':False]
['text':' do not instantiate with references','line_number':276,'multiline':False]
['text':'  typedef typename detail::generate_error<T&>::references_not_allowed type;','line_number':277,'multiline':False]
['text':' Does the same as const_copy_argument, but passes references through as such','line_number':291,'multiline':False]
['text':' The default is non-const reference -------------------------','line_number':302,'multiline':False]
['text':' const T -> const T&, ','line_number':303,'multiline':False]
['text':' T -> T&, ','line_number':304,'multiline':False]
['text':' references -> compile_time_error','line_number':305,'multiline':False]
['text':' reference_wrapper<T> -> T&','line_number':306,'multiline':False]
['text':' Are the volatile versions needed?','line_number':327,'multiline':False]
['text':' Array to pointer conversion','line_number':345,'multiline':False]
['text':' ---------------------------------------------------------------------------','line_number':370,'multiline':False]
['text':' The call_traits for bind','line_number':371,'multiline':False]
['text':' Respects the reference_wrapper class.','line_number':372,'multiline':False]
['text':' These templates are used outside of bind functions as well.','line_number':374,'multiline':False]
['text':' the bind_tuple_mapper provides a shorter notation for default','line_number':375,'multiline':False]
['text':' bound argument storing semantics, if all arguments are treated','line_number':376,'multiline':False]
['text':' uniformly.','line_number':377,'multiline':False]
['text':' from template<class T> foo(const T& t) : bind_traits<const T>::type','line_number':379,'multiline':False]
['text':' from template<class T> foo(T& t) : bind_traits<T>::type','line_number':380,'multiline':False]
['text':' Conversions:','line_number':382,'multiline':False]
['text':' T -> const T,','line_number':383,'multiline':False]
['text':' cv T -> cv T, ','line_number':384,'multiline':False]
['text':' T& -> T& ','line_number':385,'multiline':False]
['text':' reference_wrapper<T> -> T&','line_number':386,'multiline':False]
['text':' const reference_wrapper<T> -> T&','line_number':387,'multiline':False]
['text':' array -> const ref array','line_number':388,'multiline':False]
['text':' make bound arguments const, this is a deliberate design choice, the','line_number':390,'multiline':False]
['text':' purpose is to prevent side effects to bound arguments that are stored','line_number':391,'multiline':False]
['text':' as copies','line_number':392,'multiline':False]
['text':' null_types are an exception, we always want to store them as non const','line_number':403,'multiline':False]
['text':' so that other templates can assume that null_type is always without const','line_number':404,'multiline':False]
['text':' the bind_tuple_mapper, bind_type_generators may ','line_number':410,'multiline':False]
['text':' introduce const to null_type','line_number':411,'multiline':False]
['text':' Arrays can't be stored as plain types; convert them to references.','line_number':417,'multiline':False]
['text':' All arrays are converted to const. This is because bind takes its','line_number':418,'multiline':False]
['text':' parameters as const T& and thus the knowledge of the potential ','line_number':419,'multiline':False]
['text':' non-constness of actual argument is lost.','line_number':420,'multiline':False]
['text':' bind_traits, except map const T& -> const T','line_number':526,'multiline':False]
['text':' this is needed e.g. in currying. Const reference arguments can','line_number':527,'multiline':False]
['text':' refer to temporaries, so it is not safe to store them as references.','line_number':528,'multiline':False]
['text':' maps the bind argument types to the resulting lambda functor type','line_number':538,'multiline':False]
['text':' detail','line_number':573,'multiline':False]
['text':' end of namespace lambda','line_number':578,'multiline':False]
['text':' end of namespace boost','line_number':579,'multiline':False]
['text':' BOOST_LAMBDA_TRAITS_HPP','line_number':583,'multiline':False]
