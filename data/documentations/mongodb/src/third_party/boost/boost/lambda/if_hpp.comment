['text':' Boost Lambda Library -- if.hpp ------------------------------------------','line_number':1,'multiline':False]
['text':' Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)','line_number':3,'multiline':False]
['text':' Copyright (C) 2000 Gary Powell (powellg@amazon.com)','line_number':4,'multiline':False]
['text':' Copyright (C) 2001-2002 Joel de Guzman','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0. (See','line_number':7,'multiline':False]
['text':' accompanying file LICENSE_1_0.txt or copy at','line_number':8,'multiline':False]
['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':9,'multiline':False]
['text':'','line_number':10,'multiline':False]
['text':' For more information, see www.boost.org','line_number':11,'multiline':False]
['text':' --------------------------------------------------------------------------','line_number':13,'multiline':False]
['text':' Arithmetic type promotion needed for if_then_else_return','line_number':20,'multiline':False]
['text':' -- if control construct actions ----------------------','line_number':27,'multiline':False]
['text':' Specialization for if_then.','line_number':33,'multiline':False]
['text':' If Then','line_number':50,'multiline':False]
['text':' Specialization for if_then_else.','line_number':69,'multiline':False]
['text':' If then else','line_number':90,'multiline':False]
['text':' Our version of operator?:()','line_number':111,'multiline':False]
['text':' return type specialization for conditional expression begins -----------','line_number':139,'multiline':False]
['text':' start reading below and move upwards','line_number':140,'multiline':False]
['text':' PHASE 6:1 ','line_number':142,'multiline':False]
['text':' check if A is conbertible to B and B to A','line_number':143,'multiline':False]
['text':' if A can be converted to B and vice versa -> ambiguous','line_number':147,'multiline':False]
['text':' ambiguous type in conditional expression','line_number':152,'multiline':False]
['text':' if A can be converted to B and vice versa and are of same type','line_number':154,'multiline':False]
['text':' A can be converted to B','line_number':161,'multiline':False]
['text':' B can be converted to A','line_number':167,'multiline':False]
['text':' neither can be converted. Then we drop the potential references, and','line_number':173,'multiline':False]
['text':' try again','line_number':174,'multiline':False]
['text':' it is safe to add const, since the result will be an rvalue and thus','line_number':177,'multiline':False]
['text':' const anyway. The const are needed eg. if the types ','line_number':178,'multiline':False]
['text':' are 'const int*' and 'void *'. The remaining type should be 'const void*'','line_number':179,'multiline':False]
['text':' TODO: Add support for volatile ?','line_number':182,'multiline':False]
['text':' PHASE 6:2','line_number':194,'multiline':False]
['text':' types_do_not_match_in_conditional_expression ','line_number':199,'multiline':False]
['text':' PHASE 5: now we know that types are not arithmetic.','line_number':204,'multiline':False]
['text':' phase 1 ','line_number':209,'multiline':False]
['text':' PHASE 4 : ','line_number':217,'multiline':False]
['text':' the base case covers arithmetic types with differing promote codes','line_number':218,'multiline':False]
['text':' use the type deduction of arithmetic_actions','line_number':219,'multiline':False]
['text':' plus_action is just a random pick, has to be a concrete instance','line_number':224,'multiline':False]
['text':' this case covers the case of artihmetic types with the same promote codes. ','line_number':227,'multiline':False]
['text':' non numeric deduction is used since e.g. integral promotion is not ','line_number':228,'multiline':False]
['text':' performed with operator ?: ','line_number':229,'multiline':False]
['text':' if either A or B has promote code -1 it is not an arithmetic type','line_number':235,'multiline':False]
['text':' PHASE 3 : Are the types same?','line_number':252,'multiline':False]
['text':' No, check if they are arithmetic or not','line_number':253,'multiline':False]
['text':' Yes, clear.','line_number':266,'multiline':False]
['text':' detail','line_number':271,'multiline':False]
['text':' PHASE 2 : Perform first the potential array_to_pointer conversion ','line_number':273,'multiline':False]
['text':' PHASE 1 : Deduction is based on the second and third operand','line_number':284,'multiline':False]
['text':' return type specialization for conditional expression ends -----------','line_number':287,'multiline':False]
['text':' Specialization of lambda_functor_base for if_then_else_return.','line_number':290,'multiline':False]
['text':' The code below is from Joel de Guzman, some name changes etc. ','line_number':319,'multiline':False]
['text':' has been made.','line_number':320,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':322,'multiline':False]
['text':'','line_number':323,'multiline':False]
['text':'  if_then_else_composite','line_number':324,'multiline':False]
['text':'','line_number':325,'multiline':False]
['text':'      This composite has two (2) forms:','line_number':326,'multiline':False]
['text':'','line_number':327,'multiline':False]
['text':'          if_(condition)','line_number':328,'multiline':False]
['text':'          [','line_number':329,'multiline':False]
['text':'              statement','line_number':330,'multiline':False]
['text':'          ]','line_number':331,'multiline':False]
['text':'','line_number':332,'multiline':False]
['text':'      and','line_number':333,'multiline':False]
['text':'','line_number':334,'multiline':False]
['text':'          if_(condition)','line_number':335,'multiline':False]
['text':'          [','line_number':336,'multiline':False]
['text':'              true_statement','line_number':337,'multiline':False]
['text':'          ]','line_number':338,'multiline':False]
['text':'          .else_','line_number':339,'multiline':False]
['text':'          [','line_number':340,'multiline':False]
['text':'              false_statement','line_number':341,'multiline':False]
['text':'          ]','line_number':342,'multiline':False]
['text':'','line_number':343,'multiline':False]
['text':'      where condition is an lambda_functor that evaluates to bool. If condition','line_number':344,'multiline':False]
['text':'      is true, the true_statement (again an lambda_functor) is executed','line_number':345,'multiline':False]
['text':'      otherwise, the false_statement (another lambda_functor) is executed. The','line_number':346,'multiline':False]
['text':'      result type of this is void. Note the trailing underscore after','line_number':347,'multiline':False]
['text':'      if_ and the leading dot and the trailing underscore before','line_number':348,'multiline':False]
['text':'      and after .else_.','line_number':349,'multiline':False]
['text':'','line_number':350,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////////','line_number':351,'multiline':False]
['text':'  lambda_functors','line_number':375,'multiline':False]
['text':'////////////////////////////////','line_number':378,'multiline':False]
['text':'////////////////////////////////','line_number':400,'multiline':False]
['text':'  lambda_functors','line_number':417,'multiline':False]
['text':'////////////////////////////////','line_number':421,'multiline':False]
['text':'////////////////////////////////','line_number':447,'multiline':False]
['text':' lambda','line_number':457,'multiline':False]
['text':' boost','line_number':458,'multiline':False]
['text':' BOOST_LAMBDA_IF_HPP','line_number':460,'multiline':False]
