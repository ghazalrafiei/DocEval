['text':'  return_type_traits.hpp -- Boost Lambda Library ---------------------------','line_number':1,'multiline':False]
['text':' Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)','line_number':3,'multiline':False]
['text':'','line_number':4,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0. (See','line_number':5,'multiline':False]
['text':' accompanying file LICENSE_1_0.txt or copy at','line_number':6,'multiline':False]
['text':' http://www.boost.org/LICENSE_1_0.txt)','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':' For more information, see www.boost.org','line_number':9,'multiline':False]
['text':' needed for the ptrdiff_t','line_number':17,'multiline':False]
['text':' Much of the type deduction code for standard arithmetic types ','line_number':22,'multiline':False]
['text':' from Gary Powell','line_number':23,'multiline':False]
['text':' different arities:','line_number':25,'multiline':False]
['text':' 1-ary actions','line_number':26,'multiline':False]
['text':' 2-ary','line_number':27,'multiline':False]
['text':' >3- ary','line_number':28,'multiline':False]
['text':' 2-ary','line_number':31,'multiline':False]
['text':' >3-ary','line_number':32,'multiline':False]
['text':' In some cases return type deduction should fail (an invalid lambda ','line_number':39,'multiline':False]
['text':' expression). Sometimes the lambda expression can be ok, the return type','line_number':40,'multiline':False]
['text':' just is not deducible (user defined operators). Then return type deduction','line_number':41,'multiline':False]
['text':' should never be entered at all, and the use of ret<> does this.','line_number':42,'multiline':False]
['text':' However, for nullary lambda functors, return type deduction is always','line_number':43,'multiline':False]
['text':' entered, and there seems to be no way around this.','line_number':44,'multiline':False]
['text':' (the return type is part of the prototype of the non-template','line_number':46,'multiline':False]
['text':' operator()(). The prototype is instantiated, even though the body ','line_number':47,'multiline':False]
['text':' is not.) ','line_number':48,'multiline':False]
['text':' So, in the case the return type deduction should fail, it should not','line_number':50,'multiline':False]
['text':' fail directly, but rather result in a valid but wrong return type,','line_number':51,'multiline':False]
['text':' causing a compile time error only if the function is really called.','line_number':52,'multiline':False]
['text':' end detail','line_number':56,'multiline':False]
['text':' return_type_X_prot classes --------------------------------------------','line_number':60,'multiline':False]
['text':' These classes are the first layer that gets instantiated from the ','line_number':61,'multiline':False]
['text':' lambda_functor_base sig templates. It will check whether ','line_number':62,'multiline':False]
['text':' the action is protectable and one of arguments is "protected" or its','line_number':63,'multiline':False]
['text':' evaluation will otherwise result in another lambda functor.','line_number':64,'multiline':False]
['text':' If this is a case, the result type will be another lambda functor.','line_number':65,'multiline':False]
['text':' The arguments are always non-reference types, except for comma action','line_number':67,'multiline':False]
['text':' where the right argument can be a reference too. This is because it ','line_number':68,'multiline':False]
['text':' matters (in the builtin case) whether the argument is an lvalue or ','line_number':69,'multiline':False]
['text':' rvalue: int i; i, 1 -> rvalue; 1, i -> lvalue','line_number':70,'multiline':False]
['text':' take care of the unavoidable instantiation for nullary case','line_number':87,'multiline':False]
['text':' Unary actions (result from unary operators)','line_number':92,'multiline':False]
['text':' do not have a default return type.','line_number':93,'multiline':False]
['text':' add const to rvalues, so that all rvalues are stored as const in ','line_number':107,'multiline':False]
['text':' the args tuple','line_number':108,'multiline':False]
['text':' handles funtion and array ','line_number':112,'multiline':False]
['text':' types correctly','line_number':113,'multiline':False]
['text':' end detail','line_number':116,'multiline':False]
['text':' experimental feature','line_number':120,'multiline':False]
['text':' We may have a lambda functor as a result type of a subexpression ','line_number':121,'multiline':False]
['text':' (if protect) has  been used.','line_number':122,'multiline':False]
['text':' Thus, if one of the parameter types is a lambda functor, the result','line_number':123,'multiline':False]
['text':' is a lambda functor as well. ','line_number':124,'multiline':False]
['text':' We need to make a conservative choise here.','line_number':125,'multiline':False]
['text':' The resulting lambda functor stores all const reference arguments as','line_number':126,'multiline':False]
['text':' const copies. References to non-const are stored as such.','line_number':127,'multiline':False]
['text':' So if the source of the argument is a const open argument, a bound','line_number':128,'multiline':False]
['text':' argument stored as a const reference, or a function returning a ','line_number':129,'multiline':False]
['text':' const reference, that information is lost. There is no way of ','line_number':130,'multiline':False]
['text':' telling apart 'real const references' from just 'LL internal','line_number':131,'multiline':False]
['text':' const references' (or it would be really hard)','line_number':132,'multiline':False]
['text':' The return type is a subclass of lambda_functor, which has a converting ','line_number':134,'multiline':False]
['text':' copy constructor. It can copy any lambda functor, that has the same ','line_number':135,'multiline':False]
['text':' action type and code, and a copy compatible argument tuple.','line_number':136,'multiline':False]
['text':' take care of the unavoidable instantiation for nullary case','line_number':157,'multiline':False]
['text':' take care of the unavoidable instantiation for nullary case','line_number':161,'multiline':False]
['text':' take care of the unavoidable instantiation for nullary case','line_number':165,'multiline':False]
['text':' comma is a special case, as the user defined operator can return','line_number':170,'multiline':False]
['text':' an lvalue (reference) too, hence it must be handled at this level.','line_number':171,'multiline':False]
['text':' it is protectable','line_number':180,'multiline':False]
['text':' if no user defined return_type_2 (or plain_return_type_2) specialization','line_number':193,'multiline':False]
['text':' matches, then return the righthand argument','line_number':194,'multiline':False]
['text':' currently there are no protectable actions with > 2 args','line_number':205,'multiline':False]
['text':' take care of the unavoidable instantiation for nullary case','line_number':211,'multiline':False]
['text':' handle different kind of actions ------------------------','line_number':216,'multiline':False]
['text':' use the return type given in the bind invocation as bind<Ret>(...)','line_number':218,'multiline':False]
['text':' ::result_type support','line_number':224,'multiline':False]
['text':' namespace detail','line_number':241,'multiline':False]
['text':' Ret is detail::unspecified, so try to deduce return type','line_number':243,'multiline':False]
['text':' in the case of function action, the first element in Args is ','line_number':247,'multiline':False]
['text':' some type of function','line_number':248,'multiline':False]
['text':' pass the function to function_adaptor, and get the return type from ','line_number':253,'multiline':False]
['text':' that','line_number':254,'multiline':False]
['text':' namespace lambda','line_number':263,'multiline':False]
['text':' namespace boost','line_number':264,'multiline':False]
