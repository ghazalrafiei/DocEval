['text':'
 *
 * Copyright (c) 2002
 * John Maddock
 *
 * Use, modification and distribution are subject to the 
 * Boost Software License, Version 1.0. (See accompanying file 
 * LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 *
 ','line_number':1,'multiline':True]
['text':'
  *   LOCATION:    see http://www.boost.org for most recent version.
  *   FILE         perl_matcher_common.cpp
  *   VERSION      see <boost/version.hpp>
  *   DESCRIPTION: Definitions of perl_matcher member functions that are 
  *                common to both the recursive and non-recursive versions.
  ','line_number':12,'multiline':True]
['text':' precondition failure: e is not a valid regex.','line_number':62,'multiline':False]
['text':' find the value to use for matching word boundaries:','line_number':96,'multiline':False]
['text':' find bitmask to use for matching '.':','line_number':98,'multiline':False]
['text':' Disable match_any if requested in the state machine:','line_number':100,'multiline':False]
['text':'','line_number':111,'multiline':False]
['text':' How many states should we allow our machine to visit before giving up?','line_number':112,'multiline':False]
['text':' This is a heuristic: it takes the greater of O(N^2) and O(NS^2)','line_number':113,'multiline':False]
['text':' where N is the length of the string, and S is the number of states','line_number':114,'multiline':False]
['text':' in the machine.  It's tempting to up this to O(N^2S) or even O(N^2S^2)','line_number':115,'multiline':False]
['text':' but these take unreasonably amounts of time to bale out in pathological','line_number':116,'multiline':False]
['text':' cases.','line_number':117,'multiline':False]
['text':'','line_number':118,'multiline':False]
['text':' Calculate NS^2 first:','line_number':119,'multiline':False]
['text':'','line_number':120,'multiline':False]
['text':'','line_number':149,'multiline':False]
['text':' Now calculate N^2:','line_number':150,'multiline':False]
['text':'','line_number':151,'multiline':False]
['text':'','line_number':165,'multiline':False]
['text':' N^2 can be a very large number indeed, to prevent things getting out','line_number':166,'multiline':False]
['text':' of control, cap the max states:','line_number':167,'multiline':False]
['text':'','line_number':168,'multiline':False]
['text':'','line_number':171,'multiline':False]
['text':' If (the possibly capped) N^2 is larger than our first estimate,','line_number':172,'multiline':False]
['text':' use this instead:','line_number':173,'multiline':False]
['text':'','line_number':174,'multiline':False]
['text':' we don't know how long the sequence is:','line_number':182,'multiline':False]
['text':' initialise our stack if we are non-recursive:','line_number':212,'multiline':False]
['text':' reset our state machine:','line_number':221,'multiline':False]
['text':' unwind all pushed states, apart from anything else this','line_number':240,'multiline':False]
['text':' ensures that all the states are correctly destructed','line_number':241,'multiline':False]
['text':' not just the memory freed.','line_number':242,'multiline':False]
['text':' initialise our stack if we are non-recursive:','line_number':273,'multiline':False]
['text':' reset our state machine:','line_number':285,'multiline':False]
['text':' start again:','line_number':295,'multiline':False]
['text':' If last match was null and match_not_null was not set then increment','line_number':297,'multiline':False]
['text':' our start position, otherwise we go into an infinite loop:','line_number':298,'multiline':False]
['text':' reset $` start:','line_number':306,'multiline':False]
['text':'if((base != search_base) && (base == backstop))','line_number':308,'multiline':False]
['text':'   m_match_flags |= match_prev_avail;','line_number':309,'multiline':False]
['text':' find out what kind of expression we have:','line_number':318,'multiline':False]
['text':' call the appropriate search routine:','line_number':323,'multiline':False]
['text':' unwind all pushed states, apart from anything else this','line_number':331,'multiline':False]
['text':' ensures that all the states are correctly destructed','line_number':332,'multiline':False]
['text':' not just the memory freed.','line_number':333,'multiline':False]
['text':'','line_number':362,'multiline':False]
['text':' we have a match, reverse the capture information:','line_number':363,'multiline':False]
['text':'','line_number':364,'multiline':False]
['text':' reset search postion','line_number':373,'multiline':False]
['text':' reset for further searches','line_number':375,'multiline':False]
['text':'','line_number':385,'multiline':False]
['text':' compare string with what we stored in','line_number':386,'multiline':False]
['text':' our records:','line_number':387,'multiline':False]
['text':' check the previous value character:','line_number':415,'multiline':False]
['text':' we're not yet at the end so *first is always valid:','line_number':441,'multiline':False]
['text':' check that we're not in the middle of \r\n sequence','line_number':446,'multiline':False]
['text':' indcates whether next character is a word character','line_number':483,'multiline':False]
['text':' prev and this character must be opposites:','line_number':486,'multiline':False]
['text':' no match if we get to here...','line_number':513,'multiline':False]
['text':' both prev and this character must be m_word_mask:','line_number':521,'multiline':False]
['text':' can't be starting a word if we're already at the end of input','line_number':546,'multiline':False]
['text':' next character isn't a word character','line_number':548,'multiline':False]
['text':' no previous input','line_number':552,'multiline':False]
['text':' otherwise inside buffer:','line_number':556,'multiline':False]
['text':' previous character not non-word','line_number':560,'multiline':False]
['text':' OK we have a match:','line_number':562,'multiline':False]
['text':' start of buffer can't be end of word','line_number':571,'multiline':False]
['text':' previous character wasn't a word character','line_number':575,'multiline':False]
['text':' end of buffer but not end of word','line_number':580,'multiline':False]
['text':' otherwise inside buffer:','line_number':584,'multiline':False]
['text':' next character is a word character','line_number':586,'multiline':False]
['text':' if we fall through to here then we've succeeded','line_number':589,'multiline':False]
['text':' OK match:','line_number':597,'multiline':False]
['text':' OK match:','line_number':607,'multiline':False]
['text':'','line_number':615,'multiline':False]
['text':' Compare with what we previously matched.','line_number':616,'multiline':False]
['text':' Note that this succeeds if the backref did not partisipate','line_number':617,'multiline':False]
['text':' in the match, this is in line with ECMAScript, but not Perl','line_number':618,'multiline':False]
['text':' or PCRE.','line_number':619,'multiline':False]
['text':'','line_number':620,'multiline':False]
['text':' let the traits class do the work:','line_number':653,'multiline':False]
['text':' return true if marked sub-expression N has been matched:','line_number':759,'multiline':False]
['text':' Magic value for a (DEFINE) block:','line_number':764,'multiline':False]
['text':' Have we matched subexpression "index"?','line_number':769,'multiline':False]
['text':' Check if index is a hash value:','line_number':770,'multiline':False]
['text':' Have we recursed into subexpression "index"?','line_number':792,'multiline':False]
['text':' If index == 0 then check for any recursion at all, otherwise for recursion to -index-1.','line_number':793,'multiline':False]
['text':' Just force a backtrack:','line_number':818,'multiline':False]
['text':' skip everything we can't match:','line_number':845,'multiline':False]
['text':' run out of characters, try a null match if possible:','line_number':850,'multiline':False]
['text':' now try and obtain a match:','line_number':855,'multiline':False]
['text':' do search optimised for word starts:','line_number':875,'multiline':False]
['text':' do search optimised for line starts:','line_number':907,'multiline':False]
['text':'++position;','line_number':932,'multiline':False]
['text':' can't possibly match if we're at the end already','line_number':950,'multiline':False]
['text':' dwa 10/20/2000 - warning suppression for MWCW','line_number':987,'multiline':False]
['text':'we could do better than this...','line_number':991,'multiline':False]
['text':' we need to check for a partial match:','line_number':998,'multiline':False]
['text':' namespace BOOST_REGEX_DETAIL_NS','line_number':1007,'multiline':False]
['text':' namespace boost','line_number':1009,'multiline':False]
