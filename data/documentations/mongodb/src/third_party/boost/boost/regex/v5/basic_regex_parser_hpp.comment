['text':'
 *
 * Copyright (c) 2004
 * John Maddock
 *
 * Use, modification and distribution are subject to the 
 * Boost Software License, Version 1.0. (See accompanying file 
 * LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 *
 ','line_number':1,'multiline':True]
['text':'
  *   LOCATION:    see http://www.boost.org for most recent version.
  *   FILE         basic_regex_parser.cpp
  *   VERSION      see <boost/version.hpp>
  *   DESCRIPTION: Declares template class basic_regex_parser.
  ','line_number':12,'multiline':True]
['text':' Get out clause here, just in case numeric_limits is unspecialized:','line_number':35,'multiline':False]
['text':' the main parser to use','line_number':90,'multiline':False]
['text':' the start of the string being parsed','line_number':91,'multiline':False]
['text':' the end of the string being parsed','line_number':92,'multiline':False]
['text':' our current parser position','line_number':93,'multiline':False]
['text':' how many sub-expressions we have','line_number':94,'multiline':False]
['text':' used to indicate that we're inside a (?|...) block.','line_number':95,'multiline':False]
['text':' largest mark count seen inside a (?|...) block.','line_number':96,'multiline':False]
['text':' where the last seen ')' began (where repeats are inserted).','line_number':97,'multiline':False]
['text':' where to insert the next alternative','line_number':98,'multiline':False]
['text':' true if somewhere in the current block the case has changed','line_number':99,'multiline':False]
['text':' How many times we've called parse_all.','line_number':100,'multiline':False]
['text':' Largest index of any backref.','line_number':101,'multiline':False]
['text':' This is an ugly warning suppression workaround (for warnings *inside* std::vector','line_number':103,'multiline':False]
['text':' that can not otherwise be suppressed)...','line_number':104,'multiline':False]
['text':' list of alternative in the current scope.','line_number':106,'multiline':False]
['text':' list of alternative in the current scope.','line_number':108,'multiline':False]
['text':' pass l_flags on to base class:','line_number':125,'multiline':False]
['text':' set up pointers:','line_number':127,'multiline':False]
['text':' empty strings are errors:','line_number':130,'multiline':False]
['text':' select which parser to use:','line_number':141,'multiline':False]
['text':'','line_number':147,'multiline':False]
['text':' Add a leading paren with index zero to give recursions a target:','line_number':148,'multiline':False]
['text':'','line_number':149,'multiline':False]
['text':' Oops, someone has managed to set more than one of the main option flags, ','line_number':162,'multiline':False]
['text':' so this must be an error:','line_number':163,'multiline':False]
['text':' parse all our characters:','line_number':168,'multiline':False]
['text':'','line_number':170,'multiline':False]
['text':' Unwind our alternatives:','line_number':171,'multiline':False]
['text':'','line_number':172,'multiline':False]
['text':' reset l_flags as a global scope (?imsx) may have altered them:','line_number':174,'multiline':False]
['text':' if we haven't gobbled up all the characters then we must','line_number':176,'multiline':False]
['text':' have had an unexpected ')' :','line_number':177,'multiline':False]
['text':' if an error has been set then give up now:','line_number':183,'multiline':False]
['text':' fill in our sub-expression count:','line_number':186,'multiline':False]
['text':'','line_number':188,'multiline':False]
['text':' Check we don't have backreferences to sub-expressions which don't exist:','line_number':189,'multiline':False]
['text':'','line_number':190,'multiline':False]
['text':' get the error message:','line_number':201,'multiline':False]
['text':' update the error code if not already set','line_number':209,'multiline':False]
['text':' don't bother parsing anything else','line_number':211,'multiline':False]
['text':'','line_number':213,'multiline':False]
['text':' Augment error message with the regular expression text:','line_number':214,'multiline':False]
['text':'','line_number':215,'multiline':False]
['text':' suppress warnings.','line_number':241,'multiline':False]
['text':' exceeded internal limits','line_number':250,'multiline':False]
['text':'','line_number':395,'multiline':False]
['text':' If we have a mod_x flag set, then skip until','line_number':396,'multiline':False]
['text':' we get to a newline character:','line_number':397,'multiline':False]
['text':'','line_number':398,'multiline':False]
['text':' append this as a literal provided it's not a space character','line_number':423,'multiline':False]
['text':' or the perl option regbase::mod_x is not set:','line_number':424,'multiline':False]
['text':'','line_number':438,'multiline':False]
['text':' skip the '(' and error check:','line_number':439,'multiline':False]
['text':'','line_number':440,'multiline':False]
['text':'','line_number':446,'multiline':False]
['text':' begin by checking for a perl-style (?...) extension:','line_number':447,'multiline':False]
['text':'','line_number':448,'multiline':False]
['text':'','line_number':459,'multiline':False]
['text':' update our mark count, and append the required state:','line_number':460,'multiline':False]
['text':'','line_number':461,'multiline':False]
['text':' back up insertion point for alternations, and set new point:','line_number':473,'multiline':False]
['text':'','line_number':477,'multiline':False]
['text':' back up the current flags in case we have a nested (?imsx) group:','line_number':478,'multiline':False]
['text':'','line_number':479,'multiline':False]
['text':' no changes to this scope as yet...','line_number':482,'multiline':False]
['text':'','line_number':483,'multiline':False]
['text':' Back up branch reset data in case we have a nested (?|...)','line_number':484,'multiline':False]
['text':'','line_number':485,'multiline':False]
['text':'','line_number':488,'multiline':False]
['text':' now recursively add more states, this will terminate when we get to a','line_number':489,'multiline':False]
['text':' matching ')' :','line_number':490,'multiline':False]
['text':'','line_number':491,'multiline':False]
['text':'','line_number':493,'multiline':False]
['text':' Unwind pushed alternatives:','line_number':494,'multiline':False]
['text':'','line_number':495,'multiline':False]
['text':'','line_number':498,'multiline':False]
['text':' restore flags:','line_number':499,'multiline':False]
['text':'','line_number':500,'multiline':False]
['text':' the case has changed in one or more of the alternatives','line_number':503,'multiline':False]
['text':' within the scoped (...) block: we have to add a state','line_number':504,'multiline':False]
['text':' to reset the case sensitivity:','line_number':505,'multiline':False]
['text':'','line_number':512,'multiline':False]
['text':' restore branch reset:','line_number':513,'multiline':False]
['text':'','line_number':514,'multiline':False]
['text':'','line_number':516,'multiline':False]
['text':' we either have a ')' or we have run out of characters prematurely:','line_number':517,'multiline':False]
['text':'','line_number':518,'multiline':False]
['text':'','line_number':529,'multiline':False]
['text':' append closing parenthesis state:','line_number':530,'multiline':False]
['text':'','line_number':531,'multiline':False]
['text':'','line_number':536,'multiline':False]
['text':' restore the alternate insertion point:','line_number':537,'multiline':False]
['text':'','line_number':538,'multiline':False]
['text':' not supported yet:','line_number':677,'multiline':False]
['text':' in case this is a character class escape: \w \d etc','line_number':699,'multiline':False]
['text':'','line_number':724,'multiline':False]
['text':' not a class, just a regular unknown escape:','line_number':725,'multiline':False]
['text':'','line_number':726,'multiline':False]
['text':' maybe have \p{ddd}','line_number':784,'multiline':False]
['text':' skip forward until we find enclosing brace:','line_number':788,'multiline':False]
['text':' maybe have \g{ddd}','line_number':858,'multiline':False]
['text':' Check for a named capture, get the leftmost one if there is more than one:','line_number':894,'multiline':False]
['text':'','line_number':946,'multiline':False]
['text':' we have a '.' that can match any character:','line_number':947,'multiline':False]
['text':'','line_number':948,'multiline':False]
['text':' ','line_number':965,'multiline':False]
['text':' when we get to here we may have a non-greedy ? mark still to come:','line_number':966,'multiline':False]
['text':'','line_number':967,'multiline':False]
['text':' OK we have a perl or emacs regex, check for a '?':','line_number':975,'multiline':False]
['text':' whitespace skip:','line_number':978,'multiline':False]
['text':' for perl regexes only check for possessive ++ repeats.','line_number':987,'multiline':False]
['text':' insert a repeat before the '(' matching the last ')':','line_number':1003,'multiline':False]
['text':' the last state was a literal with more than one character, split it in two:','line_number':1008,'multiline':False]
['text':' now append new state:','line_number':1012,'multiline':False]
['text':' repeat the last state whatever it was, need to add some error checking here:','line_number':1020,'multiline':False]
['text':' can't legally repeat any of the above:','line_number':1038,'multiline':False]
['text':' do nothing...','line_number':1042,'multiline':False]
['text':'','line_number':1047,'multiline':False]
['text':' OK we now know what to repeat, so insert the repeat around it:','line_number':1048,'multiline':False]
['text':'','line_number':1049,'multiline':False]
['text':' store our repeater position for later:','line_number':1055,'multiline':False]
['text':' and append a back jump to the repeat:','line_number':1057,'multiline':False]
['text':' now fill in the alt jump for the repeat:','line_number':1061,'multiline':False]
['text':'','line_number':1064,'multiline':False]
['text':' If the repeat is possessive then bracket the repeat with a (?>...)','line_number':1065,'multiline':False]
['text':' independent sub-expression construct:','line_number':1066,'multiline':False]
['text':'','line_number':1067,'multiline':False]
['text':'','line_number':1072,'multiline':False]
['text':' Check for illegal following quantifier, we have to do this here, because','line_number':1073,'multiline':False]
['text':' the extra states we insert below circumvents our usual error checking :-(','line_number':1074,'multiline':False]
['text':'','line_number':1075,'multiline':False]
['text':' whitespace skip:','line_number':1081,'multiline':False]
['text':' Do we have a comment?  If so we need to skip it here...','line_number':1096,'multiline':False]
['text':'','line_number':1133,'multiline':False]
['text':' parse a repeat-range:','line_number':1134,'multiline':False]
['text':'','line_number':1135,'multiline':False]
['text':' skip whitespace:','line_number':1138,'multiline':False]
['text':' Treat the opening '{' as a literal character, rewind to start of error:','line_number':1148,'multiline':False]
['text':' get min:','line_number':1153,'multiline':False]
['text':' skip whitespace:','line_number':1155,'multiline':False]
['text':' Treat the opening '{' as a literal character, rewind to start of error:','line_number':1163,'multiline':False]
['text':' Treat the opening '{' as a literal character, rewind to start of error:','line_number':1177,'multiline':False]
['text':' see if we have a comma:','line_number':1183,'multiline':False]
['text':' move on and error check:','line_number':1186,'multiline':False]
['text':' skip whitespace:','line_number':1188,'multiline':False]
['text':' Treat the opening '{' as a literal character, rewind to start of error:','line_number':1198,'multiline':False]
['text':' get the value if any:','line_number':1203,'multiline':False]
['text':' no comma, max = min:','line_number':1209,'multiline':False]
['text':' skip whitespace:','line_number':1212,'multiline':False]
['text':' OK now check trailing }:','line_number':1215,'multiline':False]
['text':' Treat the opening '{' as a literal character, rewind to start of error:','line_number':1223,'multiline':False]
['text':' Treat the opening '{' as a literal character, rewind to start of error:','line_number':1249,'multiline':False]
['text':'','line_number':1254,'multiline':False]
['text':' finally go and add the repeat, unless error:','line_number':1255,'multiline':False]
['text':'','line_number':1256,'multiline':False]
['text':' Backtrack to error location:','line_number':1259,'multiline':False]
['text':'','line_number':1272,'multiline':False]
['text':' error check: if there have been no previous states,','line_number':1273,'multiline':False]
['text':' or if the last state was a '(' then error:','line_number':1274,'multiline':False]
['text':'','line_number':1275,'multiline':False]
['text':'','line_number':1289,'multiline':False]
['text':' Reset mark count if required:','line_number':1290,'multiline':False]
['text':'','line_number':1291,'multiline':False]
['text':'','line_number':1298,'multiline':False]
['text':' we need to append a trailing jump: ','line_number':1299,'multiline':False]
['text':'','line_number':1300,'multiline':False]
['text':'','line_number':1303,'multiline':False]
['text':' now insert the alternative:','line_number':1304,'multiline':False]
['text':'','line_number':1305,'multiline':False]
['text':'','line_number':1310,'multiline':False]
['text':' update m_alt_insert_point so that the next alternate gets','line_number':1311,'multiline':False]
['text':' inserted at the start of the second of the two we've just created:','line_number':1312,'multiline':False]
['text':'','line_number':1313,'multiline':False]
['text':'','line_number':1315,'multiline':False]
['text':' the start of this alternative must have a case changes state','line_number':1316,'multiline':False]
['text':' if the current block has messed around with case changes:','line_number':1317,'multiline':False]
['text':'','line_number':1318,'multiline':False]
['text':'','line_number':1325,'multiline':False]
['text':' push the alternative onto our stack, a recursive','line_number':1326,'multiline':False]
['text':' implementation here is easier to understand (and faster','line_number':1327,'multiline':False]
['text':' as it happens), but causes all kinds of stack overflow problems','line_number':1328,'multiline':False]
['text':' on programs with small stacks (COM+).','line_number':1329,'multiline':False]
['text':'','line_number':1330,'multiline':False]
['text':' where the '[' was','line_number':1347,'multiline':False]
['text':' where the '[' or '^' was','line_number':1348,'multiline':False]
['text':' ','line_number':1386,'multiline':False]
['text':' look ahead and see if this is a character class shortcut','line_number':1387,'multiline':False]
['text':' \d \w \s etc...','line_number':1388,'multiline':False]
['text':'','line_number':1389,'multiline':False]
['text':' negated character class:','line_number':1405,'multiline':False]
['text':' not a character class, just a regular escape:','line_number':1414,'multiline':False]
['text':'','line_number':1431,'multiline':False]
['text':' we have either a character class [:name:]','line_number':1432,'multiline':False]
['text':' a collating element [.name.]','line_number':1433,'multiline':False]
['text':' or an equivalence class [=name=]','line_number':1434,'multiline':False]
['text':'','line_number':1435,'multiline':False]
['text':'','line_number':1444,'multiline':False]
['text':' a collating element is treated as a literal:','line_number':1445,'multiline':False]
['text':'','line_number':1446,'multiline':False]
['text':' check that character classes are actually enabled:','line_number':1452,'multiline':False]
['text':' skip the ':'','line_number':1460,'multiline':False]
['text':' skip at least one character, then find the matching ':]'','line_number':1467,'multiline':False]
['text':'','line_number':1488,'multiline':False]
['text':' check for negated class:','line_number':1489,'multiline':False]
['text':'','line_number':1490,'multiline':False]
['text':' maybe a special case:','line_number':1503,'multiline':False]
['text':' skip the '='','line_number':1537,'multiline':False]
['text':' skip at least one character, then find the matching '=]'','line_number':1544,'multiline':False]
['text':' we have a range:','line_number':1600,'multiline':False]
['text':' trailing - :','line_number':1619,'multiline':False]
['text':' see if we are at the end of the set:','line_number':1642,'multiline':False]
['text':' check to see if escapes are supported first:','line_number':1653,'multiline':False]
['text':' skip at least one character, then find the matching ':]'','line_number':1682,'multiline':False]
['text':'','line_number':1723,'multiline':False]
['text':' does a value fit in the specified charT type?','line_number':1724,'multiline':False]
['text':'','line_number':1725,'multiline':False]
['text':' v will alsways fit in a charT','line_number':1734,'multiline':False]
['text':' Rewind to start of escape:','line_number':1785,'multiline':False]
['text':' Rewind to start of escape:','line_number':1797,'multiline':False]
['text':' maybe have \x{ddd}','line_number':1803,'multiline':False]
['text':' Rewind to start of escape:','line_number':1809,'multiline':False]
['text':' Rewind to start of escape:','line_number':1821,'multiline':False]
['text':' Rewind to start of escape:','line_number':1837,'multiline':False]
['text':' an octal escape sequence, the first character must be a zero','line_number':1848,'multiline':False]
['text':' followed by up to 3 octal digits:','line_number':1849,'multiline':False]
['text':' Rewind to start of escape:','line_number':1855,'multiline':False]
['text':' Oops not an octal escape after all:','line_number':1858,'multiline':False]
['text':' Rewind to start of escape:','line_number':1865,'multiline':False]
['text':' Rewind to start of escape:','line_number':1878,'multiline':False]
['text':' maybe have \N{name}','line_number':1884,'multiline':False]
['text':' skip forward until we find enclosing brace:','line_number':1888,'multiline':False]
['text':' Rewind to start of escape:','line_number':1893,'multiline':False]
['text':' Rewind to start of escape:','line_number':1902,'multiline':False]
['text':' fall through is a failure:','line_number':1913,'multiline':False]
['text':' Rewind to start of escape:','line_number':1914,'multiline':False]
['text':' not a backref at all but an octal escape sequence:','line_number':1939,'multiline':False]
['text':' Rewind to start of escape:','line_number':1954,'multiline':False]
['text':'','line_number':1970,'multiline':False]
['text':' parse a \Q...\E sequence:','line_number':1971,'multiline':False]
['text':'','line_number':1972,'multiline':False]
['text':' skip the Q','line_number':1973,'multiline':False]
['text':'  a \Q...\E sequence may terminate with the end of the expression:','line_number':1983,'multiline':False]
['text':' skip the escape','line_number':1987,'multiline':False]
['text':' check to see if it's a \E:','line_number':1992,'multiline':False]
['text':' otherwise go round again:','line_number':1999,'multiline':False]
['text':'','line_number':2001,'multiline':False]
['text':' now add all the character between the two escapes as literals:','line_number':2002,'multiline':False]
['text':'','line_number':2003,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2020,'multiline':False]
['text':'','line_number':2026,'multiline':False]
['text':' treat comments as a special case, as these','line_number':2027,'multiline':False]
['text':' are the only ones that don't start with a leading','line_number':2028,'multiline':False]
['text':' startmark state:','line_number':2029,'multiline':False]
['text':'','line_number':2030,'multiline':False]
['text':'','line_number':2038,'multiline':False]
['text':' backup some state, and prepare the way:','line_number':2039,'multiline':False]
['text':'','line_number':2040,'multiline':False]
['text':' back up insertion point for alternations, and set new point:','line_number':2046,'multiline':False]
['text':'','line_number':2061,'multiline':False]
['text':' select the actual extension used:','line_number':2062,'multiline':False]
['text':'','line_number':2063,'multiline':False]
['text':'','line_number':2070,'multiline':False]
['text':' a non-capturing mark:','line_number':2071,'multiline':False]
['text':'','line_number':2072,'multiline':False]
['text':'','line_number':2078,'multiline':False]
['text':' a recursive subexpression:','line_number':2079,'multiline':False]
['text':'','line_number':2080,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2084,'multiline':False]
['text':'','line_number':2101,'multiline':False]
['text':' A forward-relative recursive subexpression:','line_number':2102,'multiline':False]
['text':'','line_number':2103,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2108,'multiline':False]
['text':'','line_number':2122,'multiline':False]
['text':' Possibly a backward-relative recursive subexpression:','line_number':2123,'multiline':False]
['text':'','line_number':2124,'multiline':False]
['text':' Oops not a relative recursion at all, but a (?-imsx) group:','line_number':2130,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2136,'multiline':False]
['text':' a lookbehind assertion:','line_number':2159,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2162,'multiline':False]
['text':' Probably a named capture which also starts (?< :','line_number':2175,'multiline':False]
['text':'','line_number':2188,'multiline':False]
['text':' an independent sub-expression:','line_number':2189,'multiline':False]
['text':'','line_number':2190,'multiline':False]
['text':' a conditional expression:','line_number':2199,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2203,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2212,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2222,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2235,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2251,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2259,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2273,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2284,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2292,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2300,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2314,'multiline':False]
['text':' special magic value!','line_number':2321,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2324,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2332,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2345,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2353,'multiline':False]
['text':' verify that we have a lookahead or lookbehind assert:','line_number':2362,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2365,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2373,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2383,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2392,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2405,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2417,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2437,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2447,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2464,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2480,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2494,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2508,'multiline':False]
['text':'','line_number':2518,'multiline':False]
['text':' lets assume that we have a (?imsx) group and try and parse it:','line_number':2519,'multiline':False]
['text':'','line_number':2520,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2525,'multiline':False]
['text':' make a note of whether we have a case change:','line_number':2531,'multiline':False]
['text':' update flags and carry on as normal:','line_number':2536,'multiline':False]
['text':' defer end of scope by one ')'','line_number':2539,'multiline':False]
['text':' update flags and carry on until the matching ')' is found:','line_number':2543,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2549,'multiline':False]
['text':' finally append a case change state if we need it:','line_number':2556,'multiline':False]
['text':'','line_number':2565,'multiline':False]
['text':' now recursively add more states, this will terminate when we get to a','line_number':2566,'multiline':False]
['text':' matching ')' :','line_number':2567,'multiline':False]
['text':'','line_number':2568,'multiline':False]
['text':'','line_number':2570,'multiline':False]
['text':' Unwind alternatives:','line_number':2571,'multiline':False]
['text':'','line_number':2572,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2575,'multiline':False]
['text':'','line_number':2581,'multiline':False]
['text':' we either have a ')' or we have run out of characters prematurely:','line_number':2582,'multiline':False]
['text':'','line_number':2583,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2586,'multiline':False]
['text':'','line_number':2594,'multiline':False]
['text':' restore the flags:','line_number':2595,'multiline':False]
['text':'','line_number':2596,'multiline':False]
['text':' append a case change state if we need it:','line_number':2599,'multiline':False]
['text':'','line_number':2608,'multiline':False]
['text':' set up the jump pointer if we have one:','line_number':2609,'multiline':False]
['text':'','line_number':2610,'multiline':False]
['text':' Oops... we didn't have anything inside the assertion.','line_number':2618,'multiline':False]
['text':' Note we don't get here for negated forward lookahead as (?!)','line_number':2619,'multiline':False]
['text':' does have some uses.','line_number':2620,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2621,'multiline':False]
['text':'','line_number':2628,'multiline':False]
['text':' verify that if this is conditional expression, that we do have','line_number':2629,'multiline':False]
['text':' an alternative, if not add one:','line_number':2630,'multiline':False]
['text':'','line_number':2631,'multiline':False]
['text':' Make sure we have exactly one alternative following this state:','line_number':2635,'multiline':False]
['text':' Can't have seen more than one alternative:','line_number':2643,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2644,'multiline':False]
['text':' We must *not* have seen an alternative inside a (DEFINE) block:','line_number':2652,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2656,'multiline':False]
['text':' check for invalid repetition of next state:','line_number':2663,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2669,'multiline':False]
['text':'','line_number':2676,'multiline':False]
['text':' append closing parenthesis state:','line_number':2677,'multiline':False]
['text':'','line_number':2678,'multiline':False]
['text':'','line_number':2683,'multiline':False]
['text':' restore the alternate insertion point:','line_number':2684,'multiline':False]
['text':'','line_number':2685,'multiline':False]
['text':'','line_number':2687,'multiline':False]
['text':' and the case change data:','line_number':2688,'multiline':False]
['text':'','line_number':2689,'multiline':False]
['text':'','line_number':2691,'multiline':False]
['text':' And the mark_reset data:','line_number':2692,'multiline':False]
['text':'','line_number':2693,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2744,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2755,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2765,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2779,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2789,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2803,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2813,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2828,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2838,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2853,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2863,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2878,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2888,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2901,'multiline':False]
['text':'','line_number':2914,'multiline':False]
['text':' parses an emacs style \sx or \Sx construct.','line_number':2915,'multiline':False]
['text':'','line_number':2916,'multiline':False]
['text':' Rewind to start of sequence:','line_number':2919,'multiline':False]
['text':' we have a (?imsx-imsx) group, convert it into a set of flags:','line_number':2996,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':3022,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':3037,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':3066,'multiline':False]
['text':'','line_number':3081,'multiline':False]
['text':' If we didn't actually add any states after the last ','line_number':3082,'multiline':False]
['text':' alternative then that's an error:','line_number':3083,'multiline':False]
['text':'','line_number':3084,'multiline':False]
['text':' ','line_number':3098,'multiline':False]
['text':' Fix up our alternatives:','line_number':3099,'multiline':False]
['text':'','line_number':3100,'multiline':False]
['text':'','line_number':3103,'multiline':False]
['text':' fix up the jump to point to the end of the states','line_number':3104,'multiline':False]
['text':' that we've just added:','line_number':3105,'multiline':False]
['text':'','line_number':3106,'multiline':False]
['text':' Something really bad happened, this used to be an assert, ','line_number':3113,'multiline':False]
['text':' but we'll make it an error just in case we should ever get here.','line_number':3114,'multiline':False]
['text':' namespace BOOST_REGEX_DETAIL_NS','line_number':3127,'multiline':False]
['text':' namespace boost','line_number':3128,'multiline':False]
