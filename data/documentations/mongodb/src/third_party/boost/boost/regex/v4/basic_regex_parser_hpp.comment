['text':'
 *
 * Copyright (c) 2004
 * John Maddock
 *
 * Use, modification and distribution are subject to the 
 * Boost Software License, Version 1.0. (See accompanying file 
 * LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 *
 ','line_number':1,'multiline':True]
['text':'
  *   LOCATION:    see http://www.boost.org for most recent version.
  *   FILE         basic_regex_parser.cpp
  *   VERSION      see <boost/version.hpp>
  *   DESCRIPTION: Declares template class basic_regex_parser.
  ','line_number':12,'multiline':True]
['text':' Get out clause here, just in case numeric_limits is unspecialized:','line_number':49,'multiline':False]
['text':' the main parser to use','line_number':104,'multiline':False]
['text':' the start of the string being parsed','line_number':105,'multiline':False]
['text':' the end of the string being parsed','line_number':106,'multiline':False]
['text':' our current parser position','line_number':107,'multiline':False]
['text':' how many sub-expressions we have','line_number':108,'multiline':False]
['text':' used to indicate that we're inside a (?|...) block.','line_number':109,'multiline':False]
['text':' largest mark count seen inside a (?|...) block.','line_number':110,'multiline':False]
['text':' where the last seen ')' began (where repeats are inserted).','line_number':111,'multiline':False]
['text':' where to insert the next alternative','line_number':112,'multiline':False]
['text':' true if somewhere in the current block the case has changed','line_number':113,'multiline':False]
['text':' How many times we've called parse_all.','line_number':114,'multiline':False]
['text':' This is an ugly warning suppression workaround (for warnings *inside* std::vector','line_number':116,'multiline':False]
['text':' that can not otherwise be suppressed)...','line_number':117,'multiline':False]
['text':' list of alternative in the current scope.','line_number':119,'multiline':False]
['text':' list of alternative in the current scope.','line_number':121,'multiline':False]
['text':' pass l_flags on to base class:','line_number':138,'multiline':False]
['text':' set up pointers:','line_number':140,'multiline':False]
['text':' empty strings are errors:','line_number':143,'multiline':False]
['text':' select which parser to use:','line_number':154,'multiline':False]
['text':'','line_number':160,'multiline':False]
['text':' Add a leading paren with index zero to give recursions a target:','line_number':161,'multiline':False]
['text':'','line_number':162,'multiline':False]
['text':' Oops, someone has managed to set more than one of the main option flags, ','line_number':175,'multiline':False]
['text':' so this must be an error:','line_number':176,'multiline':False]
['text':' parse all our characters:','line_number':181,'multiline':False]
['text':'','line_number':183,'multiline':False]
['text':' Unwind our alternatives:','line_number':184,'multiline':False]
['text':'','line_number':185,'multiline':False]
['text':' reset l_flags as a global scope (?imsx) may have altered them:','line_number':187,'multiline':False]
['text':' if we haven't gobbled up all the characters then we must','line_number':189,'multiline':False]
['text':' have had an unexpected ')' :','line_number':190,'multiline':False]
['text':' if an error has been set then give up now:','line_number':196,'multiline':False]
['text':' fill in our sub-expression count:','line_number':199,'multiline':False]
['text':' get the error message:','line_number':207,'multiline':False]
['text':' update the error code if not already set','line_number':215,'multiline':False]
['text':' don't bother parsing anything else','line_number':217,'multiline':False]
['text':'','line_number':220,'multiline':False]
['text':' Augment error message with the regular expression text:','line_number':221,'multiline':False]
['text':'','line_number':222,'multiline':False]
['text':' suppress warnings.','line_number':249,'multiline':False]
['text':' exceeded internal limits','line_number':258,'multiline':False]
['text':'','line_number':403,'multiline':False]
['text':' If we have a mod_x flag set, then skip until','line_number':404,'multiline':False]
['text':' we get to a newline character:','line_number':405,'multiline':False]
['text':'','line_number':406,'multiline':False]
['text':' append this as a literal provided it's not a space character','line_number':431,'multiline':False]
['text':' or the perl option regbase::mod_x is not set:','line_number':432,'multiline':False]
['text':'','line_number':446,'multiline':False]
['text':' skip the '(' and error check:','line_number':447,'multiline':False]
['text':'','line_number':448,'multiline':False]
['text':'','line_number':454,'multiline':False]
['text':' begin by checking for a perl-style (?...) extension:','line_number':455,'multiline':False]
['text':'','line_number':456,'multiline':False]
['text':'','line_number':467,'multiline':False]
['text':' update our mark count, and append the required state:','line_number':468,'multiline':False]
['text':'','line_number':469,'multiline':False]
['text':' back up insertion point for alternations, and set new point:','line_number':486,'multiline':False]
['text':'','line_number':490,'multiline':False]
['text':' back up the current flags in case we have a nested (?imsx) group:','line_number':491,'multiline':False]
['text':'','line_number':492,'multiline':False]
['text':' no changes to this scope as yet...','line_number':495,'multiline':False]
['text':'','line_number':496,'multiline':False]
['text':' Back up branch reset data in case we have a nested (?|...)','line_number':497,'multiline':False]
['text':'','line_number':498,'multiline':False]
['text':'','line_number':501,'multiline':False]
['text':' now recursively add more states, this will terminate when we get to a','line_number':502,'multiline':False]
['text':' matching ')' :','line_number':503,'multiline':False]
['text':'','line_number':504,'multiline':False]
['text':'','line_number':506,'multiline':False]
['text':' Unwind pushed alternatives:','line_number':507,'multiline':False]
['text':'','line_number':508,'multiline':False]
['text':'','line_number':511,'multiline':False]
['text':' restore flags:','line_number':512,'multiline':False]
['text':'','line_number':513,'multiline':False]
['text':' the case has changed in one or more of the alternatives','line_number':516,'multiline':False]
['text':' within the scoped (...) block: we have to add a state','line_number':517,'multiline':False]
['text':' to reset the case sensitivity:','line_number':518,'multiline':False]
['text':'','line_number':525,'multiline':False]
['text':' restore branch reset:','line_number':526,'multiline':False]
['text':'','line_number':527,'multiline':False]
['text':'','line_number':529,'multiline':False]
['text':' we either have a ')' or we have run out of characters prematurely:','line_number':530,'multiline':False]
['text':'','line_number':531,'multiline':False]
['text':'','line_number':547,'multiline':False]
['text':' append closing parenthesis state:','line_number':548,'multiline':False]
['text':'','line_number':549,'multiline':False]
['text':'','line_number':554,'multiline':False]
['text':' restore the alternate insertion point:','line_number':555,'multiline':False]
['text':'','line_number':556,'multiline':False]
['text':'','line_number':558,'multiline':False]
['text':' allow backrefs to this mark:','line_number':559,'multiline':False]
['text':'','line_number':560,'multiline':False]
['text':' not supported yet:','line_number':700,'multiline':False]
['text':' in case this is a character class escape: \w \d etc','line_number':722,'multiline':False]
['text':'','line_number':747,'multiline':False]
['text':' not a class, just a regular unknown escape:','line_number':748,'multiline':False]
['text':'','line_number':749,'multiline':False]
['text':' maybe have \p{ddd}','line_number':807,'multiline':False]
['text':' skip forward until we find enclosing brace:','line_number':811,'multiline':False]
['text':' maybe have \g{ddd}','line_number':881,'multiline':False]
['text':' Check for a named capture, get the leftmost one if there is more than one:','line_number':917,'multiline':False]
['text':'','line_number':967,'multiline':False]
['text':' we have a '.' that can match any character:','line_number':968,'multiline':False]
['text':'','line_number':969,'multiline':False]
['text':' ','line_number':986,'multiline':False]
['text':' when we get to here we may have a non-greedy ? mark still to come:','line_number':987,'multiline':False]
['text':'','line_number':988,'multiline':False]
['text':' OK we have a perl or emacs regex, check for a '?':','line_number':996,'multiline':False]
['text':' whitespace skip:','line_number':999,'multiline':False]
['text':' for perl regexes only check for possessive ++ repeats.','line_number':1008,'multiline':False]
['text':' insert a repeat before the '(' matching the last ')':','line_number':1024,'multiline':False]
['text':' the last state was a literal with more than one character, split it in two:','line_number':1029,'multiline':False]
['text':' now append new state:','line_number':1033,'multiline':False]
['text':' repeat the last state whatever it was, need to add some error checking here:','line_number':1041,'multiline':False]
['text':' can't legally repeat any of the above:','line_number':1059,'multiline':False]
['text':' do nothing...','line_number':1063,'multiline':False]
['text':'','line_number':1068,'multiline':False]
['text':' OK we now know what to repeat, so insert the repeat around it:','line_number':1069,'multiline':False]
['text':'','line_number':1070,'multiline':False]
['text':' store our repeater position for later:','line_number':1076,'multiline':False]
['text':' and append a back jump to the repeat:','line_number':1078,'multiline':False]
['text':' now fill in the alt jump for the repeat:','line_number':1082,'multiline':False]
['text':'','line_number':1085,'multiline':False]
['text':' If the repeat is possessive then bracket the repeat with a (?>...)','line_number':1086,'multiline':False]
['text':' independent sub-expression construct:','line_number':1087,'multiline':False]
['text':'','line_number':1088,'multiline':False]
['text':'','line_number':1093,'multiline':False]
['text':' Check for illegal following quantifier, we have to do this here, because','line_number':1094,'multiline':False]
['text':' the extra states we insert below circumvents our usual error checking :-(','line_number':1095,'multiline':False]
['text':'','line_number':1096,'multiline':False]
['text':' whitespace skip:','line_number':1102,'multiline':False]
['text':' Do we have a comment?  If so we need to skip it here...','line_number':1117,'multiline':False]
['text':'','line_number':1154,'multiline':False]
['text':' parse a repeat-range:','line_number':1155,'multiline':False]
['text':'','line_number':1156,'multiline':False]
['text':' skip whitespace:','line_number':1159,'multiline':False]
['text':' Treat the opening '{' as a literal character, rewind to start of error:','line_number':1169,'multiline':False]
['text':' get min:','line_number':1174,'multiline':False]
['text':' skip whitespace:','line_number':1176,'multiline':False]
['text':' Treat the opening '{' as a literal character, rewind to start of error:','line_number':1184,'multiline':False]
['text':' Treat the opening '{' as a literal character, rewind to start of error:','line_number':1198,'multiline':False]
['text':' see if we have a comma:','line_number':1204,'multiline':False]
['text':' move on and error check:','line_number':1207,'multiline':False]
['text':' skip whitespace:','line_number':1209,'multiline':False]
['text':' Treat the opening '{' as a literal character, rewind to start of error:','line_number':1219,'multiline':False]
['text':' get the value if any:','line_number':1224,'multiline':False]
['text':' no comma, max = min:','line_number':1230,'multiline':False]
['text':' skip whitespace:','line_number':1233,'multiline':False]
['text':' OK now check trailing }:','line_number':1236,'multiline':False]
['text':' Treat the opening '{' as a literal character, rewind to start of error:','line_number':1244,'multiline':False]
['text':' Treat the opening '{' as a literal character, rewind to start of error:','line_number':1270,'multiline':False]
['text':'','line_number':1275,'multiline':False]
['text':' finally go and add the repeat, unless error:','line_number':1276,'multiline':False]
['text':'','line_number':1277,'multiline':False]
['text':' Backtrack to error location:','line_number':1280,'multiline':False]
['text':'','line_number':1293,'multiline':False]
['text':' error check: if there have been no previous states,','line_number':1294,'multiline':False]
['text':' or if the last state was a '(' then error:','line_number':1295,'multiline':False]
['text':'','line_number':1296,'multiline':False]
['text':'','line_number':1310,'multiline':False]
['text':' Reset mark count if required:','line_number':1311,'multiline':False]
['text':'','line_number':1312,'multiline':False]
['text':'','line_number':1319,'multiline':False]
['text':' we need to append a trailing jump: ','line_number':1320,'multiline':False]
['text':'','line_number':1321,'multiline':False]
['text':'','line_number':1324,'multiline':False]
['text':' now insert the alternative:','line_number':1325,'multiline':False]
['text':'','line_number':1326,'multiline':False]
['text':'','line_number':1331,'multiline':False]
['text':' update m_alt_insert_point so that the next alternate gets','line_number':1332,'multiline':False]
['text':' inserted at the start of the second of the two we've just created:','line_number':1333,'multiline':False]
['text':'','line_number':1334,'multiline':False]
['text':'','line_number':1336,'multiline':False]
['text':' the start of this alternative must have a case changes state','line_number':1337,'multiline':False]
['text':' if the current block has messed around with case changes:','line_number':1338,'multiline':False]
['text':'','line_number':1339,'multiline':False]
['text':'','line_number':1346,'multiline':False]
['text':' push the alternative onto our stack, a recursive','line_number':1347,'multiline':False]
['text':' implementation here is easier to understand (and faster','line_number':1348,'multiline':False]
['text':' as it happens), but causes all kinds of stack overflow problems','line_number':1349,'multiline':False]
['text':' on programs with small stacks (COM+).','line_number':1350,'multiline':False]
['text':'','line_number':1351,'multiline':False]
['text':' where the '[' was','line_number':1368,'multiline':False]
['text':' where the '[' or '^' was','line_number':1369,'multiline':False]
['text':' ','line_number':1407,'multiline':False]
['text':' look ahead and see if this is a character class shortcut','line_number':1408,'multiline':False]
['text':' \d \w \s etc...','line_number':1409,'multiline':False]
['text':'','line_number':1410,'multiline':False]
['text':' negated character class:','line_number':1426,'multiline':False]
['text':' not a character class, just a regular escape:','line_number':1435,'multiline':False]
['text':'','line_number':1452,'multiline':False]
['text':' we have either a character class [:name:]','line_number':1453,'multiline':False]
['text':' a collating element [.name.]','line_number':1454,'multiline':False]
['text':' or an equivalence class [=name=]','line_number':1455,'multiline':False]
['text':'','line_number':1456,'multiline':False]
['text':'','line_number':1465,'multiline':False]
['text':' a collating element is treated as a literal:','line_number':1466,'multiline':False]
['text':'','line_number':1467,'multiline':False]
['text':' check that character classes are actually enabled:','line_number':1473,'multiline':False]
['text':' skip the ':'','line_number':1481,'multiline':False]
['text':' skip at least one character, then find the matching ':]'','line_number':1488,'multiline':False]
['text':'','line_number':1509,'multiline':False]
['text':' check for negated class:','line_number':1510,'multiline':False]
['text':'','line_number':1511,'multiline':False]
['text':' maybe a special case:','line_number':1524,'multiline':False]
['text':' skip the '='','line_number':1558,'multiline':False]
['text':' skip at least one character, then find the matching '=]'','line_number':1565,'multiline':False]
['text':' we have a range:','line_number':1621,'multiline':False]
['text':' trailing - :','line_number':1640,'multiline':False]
['text':' see if we are at the end of the set:','line_number':1663,'multiline':False]
['text':' check to see if escapes are supported first:','line_number':1674,'multiline':False]
['text':' skip at least one character, then find the matching ':]'','line_number':1703,'multiline':False]
['text':'','line_number':1744,'multiline':False]
['text':' does a value fit in the specified charT type?','line_number':1745,'multiline':False]
['text':'','line_number':1746,'multiline':False]
['text':' v will alsways fit in a charT','line_number':1755,'multiline':False]
['text':' Rewind to start of escape:','line_number':1806,'multiline':False]
['text':' Rewind to start of escape:','line_number':1818,'multiline':False]
['text':' maybe have \x{ddd}','line_number':1824,'multiline':False]
['text':' Rewind to start of escape:','line_number':1830,'multiline':False]
['text':' Rewind to start of escape:','line_number':1842,'multiline':False]
['text':' Rewind to start of escape:','line_number':1858,'multiline':False]
['text':' an octal escape sequence, the first character must be a zero','line_number':1869,'multiline':False]
['text':' followed by up to 3 octal digits:','line_number':1870,'multiline':False]
['text':' Rewind to start of escape:','line_number':1876,'multiline':False]
['text':' Oops not an octal escape after all:','line_number':1879,'multiline':False]
['text':' Rewind to start of escape:','line_number':1886,'multiline':False]
['text':' Rewind to start of escape:','line_number':1899,'multiline':False]
['text':' maybe have \N{name}','line_number':1905,'multiline':False]
['text':' skip forward until we find enclosing brace:','line_number':1909,'multiline':False]
['text':' Rewind to start of escape:','line_number':1914,'multiline':False]
['text':' Rewind to start of escape:','line_number':1923,'multiline':False]
['text':' fall through is a failure:','line_number':1934,'multiline':False]
['text':' Rewind to start of escape:','line_number':1935,'multiline':False]
['text':' not a backref at all but an octal escape sequence:','line_number':1960,'multiline':False]
['text':' Rewind to start of escape:','line_number':1973,'multiline':False]
['text':'','line_number':1989,'multiline':False]
['text':' parse a \Q...\E sequence:','line_number':1990,'multiline':False]
['text':'','line_number':1991,'multiline':False]
['text':' skip the Q','line_number':1992,'multiline':False]
['text':'  a \Q...\E sequence may terminate with the end of the expression:','line_number':2002,'multiline':False]
['text':' skip the escape','line_number':2006,'multiline':False]
['text':' check to see if it's a \E:','line_number':2011,'multiline':False]
['text':' otherwise go round again:','line_number':2018,'multiline':False]
['text':'','line_number':2020,'multiline':False]
['text':' now add all the character between the two escapes as literals:','line_number':2021,'multiline':False]
['text':'','line_number':2022,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2039,'multiline':False]
['text':'','line_number':2045,'multiline':False]
['text':' treat comments as a special case, as these','line_number':2046,'multiline':False]
['text':' are the only ones that don't start with a leading','line_number':2047,'multiline':False]
['text':' startmark state:','line_number':2048,'multiline':False]
['text':'','line_number':2049,'multiline':False]
['text':'','line_number':2057,'multiline':False]
['text':' backup some state, and prepare the way:','line_number':2058,'multiline':False]
['text':'','line_number':2059,'multiline':False]
['text':' back up insertion point for alternations, and set new point:','line_number':2065,'multiline':False]
['text':'','line_number':2080,'multiline':False]
['text':' select the actual extension used:','line_number':2081,'multiline':False]
['text':'','line_number':2082,'multiline':False]
['text':'','line_number':2089,'multiline':False]
['text':' a non-capturing mark:','line_number':2090,'multiline':False]
['text':'','line_number':2091,'multiline':False]
['text':'','line_number':2097,'multiline':False]
['text':' a recursive subexpression:','line_number':2098,'multiline':False]
['text':'','line_number':2099,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2103,'multiline':False]
['text':'','line_number':2120,'multiline':False]
['text':' A forward-relative recursive subexpression:','line_number':2121,'multiline':False]
['text':'','line_number':2122,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2127,'multiline':False]
['text':'','line_number':2141,'multiline':False]
['text':' Possibly a backward-relative recursive subexpression:','line_number':2142,'multiline':False]
['text':'','line_number':2143,'multiline':False]
['text':' Oops not a relative recursion at all, but a (?-imsx) group:','line_number':2149,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2155,'multiline':False]
['text':' a lookbehind assertion:','line_number':2178,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2181,'multiline':False]
['text':' Probably a named capture which also starts (?< :','line_number':2194,'multiline':False]
['text':'','line_number':2207,'multiline':False]
['text':' an independent sub-expression:','line_number':2208,'multiline':False]
['text':'','line_number':2209,'multiline':False]
['text':' a conditional expression:','line_number':2218,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2222,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2231,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2241,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2254,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2270,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2278,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2292,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2303,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2311,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2319,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2333,'multiline':False]
['text':' special magic value!','line_number':2340,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2343,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2351,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2364,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2372,'multiline':False]
['text':' verify that we have a lookahead or lookbehind assert:','line_number':2381,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2384,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2392,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2402,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2411,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2424,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2436,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2461,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2471,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2488,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2504,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2518,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2532,'multiline':False]
['text':'','line_number':2542,'multiline':False]
['text':' lets assume that we have a (?imsx) group and try and parse it:','line_number':2543,'multiline':False]
['text':'','line_number':2544,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2549,'multiline':False]
['text':' make a note of whether we have a case change:','line_number':2555,'multiline':False]
['text':' update flags and carry on as normal:','line_number':2560,'multiline':False]
['text':' defer end of scope by one ')'','line_number':2563,'multiline':False]
['text':' update flags and carry on until the matching ')' is found:','line_number':2567,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2573,'multiline':False]
['text':' finally append a case change state if we need it:','line_number':2580,'multiline':False]
['text':'','line_number':2589,'multiline':False]
['text':' now recursively add more states, this will terminate when we get to a','line_number':2590,'multiline':False]
['text':' matching ')' :','line_number':2591,'multiline':False]
['text':'','line_number':2592,'multiline':False]
['text':'','line_number':2594,'multiline':False]
['text':' Unwind alternatives:','line_number':2595,'multiline':False]
['text':'','line_number':2596,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2599,'multiline':False]
['text':'','line_number':2605,'multiline':False]
['text':' we either have a ')' or we have run out of characters prematurely:','line_number':2606,'multiline':False]
['text':'','line_number':2607,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2610,'multiline':False]
['text':'','line_number':2618,'multiline':False]
['text':' restore the flags:','line_number':2619,'multiline':False]
['text':'','line_number':2620,'multiline':False]
['text':' append a case change state if we need it:','line_number':2623,'multiline':False]
['text':'','line_number':2632,'multiline':False]
['text':' set up the jump pointer if we have one:','line_number':2633,'multiline':False]
['text':'','line_number':2634,'multiline':False]
['text':' Oops... we didn't have anything inside the assertion.','line_number':2642,'multiline':False]
['text':' Note we don't get here for negated forward lookahead as (?!)','line_number':2643,'multiline':False]
['text':' does have some uses.','line_number':2644,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2645,'multiline':False]
['text':'','line_number':2652,'multiline':False]
['text':' verify that if this is conditional expression, that we do have','line_number':2653,'multiline':False]
['text':' an alternative, if not add one:','line_number':2654,'multiline':False]
['text':'','line_number':2655,'multiline':False]
['text':' Make sure we have exactly one alternative following this state:','line_number':2659,'multiline':False]
['text':' Can't have seen more than one alternative:','line_number':2667,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2668,'multiline':False]
['text':' We must *not* have seen an alternative inside a (DEFINE) block:','line_number':2676,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2680,'multiline':False]
['text':' check for invalid repetition of next state:','line_number':2687,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':2693,'multiline':False]
['text':'','line_number':2700,'multiline':False]
['text':' append closing parenthesis state:','line_number':2701,'multiline':False]
['text':'','line_number':2702,'multiline':False]
['text':'','line_number':2707,'multiline':False]
['text':' restore the alternate insertion point:','line_number':2708,'multiline':False]
['text':'','line_number':2709,'multiline':False]
['text':'','line_number':2711,'multiline':False]
['text':' and the case change data:','line_number':2712,'multiline':False]
['text':'','line_number':2713,'multiline':False]
['text':'','line_number':2715,'multiline':False]
['text':' And the mark_reset data:','line_number':2716,'multiline':False]
['text':'','line_number':2717,'multiline':False]
['text':'','line_number':2735,'multiline':False]
['text':' allow backrefs to this mark:','line_number':2736,'multiline':False]
['text':'','line_number':2737,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2777,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2788,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2798,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2812,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2822,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2836,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2846,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2861,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2871,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2886,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2896,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2911,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2921,'multiline':False]
['text':' Rewind to start of (* sequence:','line_number':2934,'multiline':False]
['text':'','line_number':2947,'multiline':False]
['text':' parses an emacs style \sx or \Sx construct.','line_number':2948,'multiline':False]
['text':'','line_number':2949,'multiline':False]
['text':' Rewind to start of sequence:','line_number':2952,'multiline':False]
['text':' we have a (?imsx-imsx) group, convert it into a set of flags:','line_number':3029,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':3055,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':3070,'multiline':False]
['text':' Rewind to start of (? sequence:','line_number':3099,'multiline':False]
['text':'','line_number':3114,'multiline':False]
['text':' If we didn't actually add any states after the last ','line_number':3115,'multiline':False]
['text':' alternative then that's an error:','line_number':3116,'multiline':False]
['text':'','line_number':3117,'multiline':False]
['text':' ','line_number':3131,'multiline':False]
['text':' Fix up our alternatives:','line_number':3132,'multiline':False]
['text':'','line_number':3133,'multiline':False]
['text':'','line_number':3136,'multiline':False]
['text':' fix up the jump to point to the end of the states','line_number':3137,'multiline':False]
['text':' that we've just added:','line_number':3138,'multiline':False]
['text':'','line_number':3139,'multiline':False]
['text':' Something really bad happened, this used to be an assert, ','line_number':3146,'multiline':False]
['text':' but we'll make it an error just in case we should ever get here.','line_number':3147,'multiline':False]
['text':' namespace BOOST_REGEX_DETAIL_NS','line_number':3160,'multiline':False]
['text':' namespace boost','line_number':3161,'multiline':False]
