['text':'
 *
 * Copyright (c) 1998-2009
 * John Maddock
 *
 * Use, modification and distribution are subject to the 
 * Boost Software License, Version 1.0. (See accompanying file 
 * LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 *
 ','line_number':1,'multiline':True]
['text':'
  *   LOCATION:    see http://www.boost.org for most recent version.
  *   FILE         match_results.cpp
  *   VERSION      see <boost/version.hpp>
  *   DESCRIPTION: Declares template class match_results.
  ','line_number':12,'multiline':True]
['text':' construct/copy/destroy:','line_number':60,'multiline':False]
['text':'','line_number':63,'multiline':False]
['text':' IMPORTANT: in the code below, the crazy looking checks around m_is_singular are','line_number':64,'multiline':False]
['text':' all required because it is illegal to copy a singular iterator.','line_number':65,'multiline':False]
['text':' See https://svn.boost.org/trac/boost/ticket/3632.','line_number':66,'multiline':False]
['text':'','line_number':67,'multiline':False]
['text':' size:','line_number':92,'multiline':False]
['text':' element access:','line_number':99,'multiline':False]
['text':'','line_number':210,'multiline':False]
['text':' Named sub-expressions:','line_number':211,'multiline':False]
['text':'','line_number':212,'multiline':False]
['text':'','line_number':215,'multiline':False]
['text':' Scan for the leftmost *matched* subexpression with the specified named:','line_number':216,'multiline':False]
['text':'','line_number':217,'multiline':False]
['text':'','line_number':238,'multiline':False]
['text':' Scan for the leftmost *matched* subexpression with the specified named.','line_number':239,'multiline':False]
['text':' If none found then return the leftmost expression with that name,','line_number':240,'multiline':False]
['text':' otherwise an invalid index:','line_number':241,'multiline':False]
['text':'','line_number':242,'multiline':False]
['text':' format:','line_number':320,'multiline':False]
['text':' format with locale:','line_number':346,'multiline':False]
['text':'','line_number':440,'multiline':False]
['text':' private access functions:','line_number':441,'multiline':False]
['text':' set up prefix:','line_number':502,'multiline':False]
['text':' set up $0:','line_number':505,'multiline':False]
['text':' zero out everything else:','line_number':507,'multiline':False]
['text':'','line_number':537,'multiline':False]
['text':' Error handler called when an uninitialized match_results is accessed:','line_number':538,'multiline':False]
['text':'','line_number':539,'multiline':False]
['text':' subexpressions','line_number':551,'multiline':False]
['text':' where the search started from','line_number':552,'multiline':False]
['text':' a null match','line_number':553,'multiline':False]
['text':' Shared copy of named subs in the regex object','line_number':554,'multiline':False]
['text':' Last ) to be seen - used for formatting','line_number':555,'multiline':False]
['text':' True if our stored iterators are singular','line_number':556,'multiline':False]
['text':'','line_number':570,'multiline':False]
['text':' Distances are measured from the start of *this* match, unless this isn't','line_number':571,'multiline':False]
['text':' a valid match in which case we use the start of the whole sequence.  Note that','line_number':572,'multiline':False]
['text':' no subsequent match-candidate can ever be to the left of the first match found.','line_number':573,'multiline':False]
['text':' This ensures that when we are using bidirectional iterators, that distances ','line_number':574,'multiline':False]
['text':' measured are as short as possible, and therefore as efficient as possible','line_number':575,'multiline':False]
['text':' to compute.  Finally note that we don't use the "matched" data member to test','line_number':576,'multiline':False]
['text':' whether a sub-expression is a valid match, because partial matches set this','line_number':577,'multiline':False]
['text':' to false for sub-expression 0.','line_number':578,'multiline':False]
['text':'','line_number':579,'multiline':False]
['text':'','line_number':589,'multiline':False]
['text':' Leftmost takes priority over longest; handle special cases','line_number':590,'multiline':False]
['text':' where distances need not be computed first (an optimisation','line_number':591,'multiline':False]
['text':' for bidirectional iterators: ensure that we don't accidently','line_number':592,'multiline':False]
['text':' compute the length of the whole sequence, as this can be really','line_number':593,'multiline':False]
['text':' expensive).','line_number':594,'multiline':False]
['text':'','line_number':595,'multiline':False]
['text':' p2 must be better than p1, and no need to calculate','line_number':600,'multiline':False]
['text':' actual distances:','line_number':601,'multiline':False]
['text':' *p1 and *p2 are either unmatched or match end-of sequence,','line_number':608,'multiline':False]
['text':' either way no need to calculate distances:','line_number':609,'multiline':False]
['text':' p1 better than p2, and no need to calculate distances:','line_number':619,'multiline':False]
['text':' namespace boost','line_number':663,'multiline':False]
