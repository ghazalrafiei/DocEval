['text':'
 *
 * Copyright (c) 2004
 * John Maddock
 *
 * Use, modification and distribution are subject to the 
 * Boost Software License, Version 1.0. (See accompanying file 
 * LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 *
 ','line_number':1,'multiline':True]
['text':'
  *   LOCATION:    see http://www.boost.org for most recent version.
  *   FILE         basic_regex_creator.cpp
  *   VERSION      see <boost/version.hpp>
  *   DESCRIPTION: Declares template class basic_regex_creator which fills in
  *                the data members of a regex_data object.
  ','line_number':12,'multiline':True]
['text':'m_empty = false;','line_number':131,'multiline':False]
['text':'','line_number':134,'multiline':False]
['text':' accessor functions:','line_number':135,'multiline':False]
['text':'','line_number':136,'multiline':False]
['text':' a list of single characters to match','line_number':184,'multiline':False]
['text':' a list of end points of our ranges','line_number':185,'multiline':False]
['text':' true if the set is to be negated','line_number':186,'multiline':False]
['text':' true if we have digraphs present','line_number':187,'multiline':False]
['text':' character classes to match','line_number':188,'multiline':False]
['text':' negated character classes to match','line_number':189,'multiline':False]
['text':' whether we've added anything yet','line_number':190,'multiline':False]
['text':' a list of equivalence classes','line_number':191,'multiline':False]
['text':' pointer to the basic_regex_data struct we are filling in','line_number':240,'multiline':False]
['text':' convenience reference to traits class','line_number':242,'multiline':False]
['text':' the last state we added','line_number':243,'multiline':False]
['text':' true for case insensitive matches','line_number':244,'multiline':False]
['text':' the state_id of the next repeater','line_number':245,'multiline':False]
['text':' true if there are actually any backrefs','line_number':246,'multiline':False]
['text':' bitmask of permitted backrefs','line_number':247,'multiline':False]
['text':' bitmask of repeats we can't deduce a startmap for;','line_number':248,'multiline':False]
['text':' set when we have recursive expressions to fixup','line_number':249,'multiline':False]
['text':' notes which recursions we've followed while analysing this expression','line_number':250,'multiline':False]
['text':' mask used to determine if a character is a word character','line_number':251,'multiline':False]
['text':' mask used to determine if a character is a word character','line_number':252,'multiline':False]
['text':' mask used to determine if a character is a lowercase character','line_number':253,'multiline':False]
['text':' mask used to determine if a character is an uppercase character','line_number':254,'multiline':False]
['text':' mask used to determine if a character is an alphabetic character','line_number':255,'multiline':False]
['text':' if the state is a backref then make a note of it:','line_number':301,'multiline':False]
['text':' append a new state, start by aligning our last one:','line_number':304,'multiline':False]
['text':' set the offset to the next state in our last one:','line_number':306,'multiline':False]
['text':' now actually extend our data:','line_number':309,'multiline':False]
['text':' fill in boilerplate options in the new state:','line_number':311,'multiline':False]
['text':' append a new state, start by aligning our last one:','line_number':320,'multiline':False]
['text':' set the offset to the next state in our last one:','line_number':322,'multiline':False]
['text':' remember the last state position:','line_number':325,'multiline':False]
['text':' now actually insert our data:','line_number':327,'multiline':False]
['text':' fill in boilerplate options in the new state:','line_number':329,'multiline':False]
['text':' start by seeing if we have an existing re_literal we can extend:','line_number':340,'multiline':False]
['text':' no existing re_literal, create a new one:','line_number':343,'multiline':False]
['text':' we have an existing re_literal, extend it:','line_number':350,'multiline':False]
['text':'','line_number':381,'multiline':False]
['text':' fill in the basics:','line_number':382,'multiline':False]
['text':'','line_number':383,'multiline':False]
['text':' adjust classes as needed:','line_number':391,'multiline':False]
['text':'','line_number':400,'multiline':False]
['text':' remember where the state is for later:','line_number':401,'multiline':False]
['text':'','line_number':402,'multiline':False]
['text':'','line_number':404,'multiline':False]
['text':' now extend with all the singles:','line_number':405,'multiline':False]
['text':'','line_number':406,'multiline':False]
['text':'','line_number':428,'multiline':False]
['text':' now extend with all the ranges:','line_number':429,'multiline':False]
['text':'','line_number':430,'multiline':False]
['text':' first grab the endpoints of the range:','line_number':435,'multiline':False]
['text':' different actions now depending upon whether collation is turned on:','line_number':445,'multiline':False]
['text':' we need to transform our range into sort keys:','line_number':448,'multiline':False]
['text':' Oops error:','line_number':477,'multiline':False]
['text':'','line_number':487,'multiline':False]
['text':' now process the equivalence classes:','line_number':488,'multiline':False]
['text':'','line_number':489,'multiline':False]
['text':' invalid or unsupported equivalence class','line_number':503,'multiline':False]
['text':'','line_number':509,'multiline':False]
['text':' finally reset the address of our last state:','line_number':510,'multiline':False]
['text':'','line_number':511,'multiline':False]
['text':'','line_number':541,'multiline':False]
['text':' handle singles first:','line_number':542,'multiline':False]
['text':'','line_number':543,'multiline':False]
['text':'','line_number':558,'multiline':False]
['text':' OK now handle ranges:','line_number':559,'multiline':False]
['text':'','line_number':560,'multiline':False]
['text':' first grab the endpoints of the range:','line_number':565,'multiline':False]
['text':' different actions now depending upon whether collation is turned on:','line_number':570,'multiline':False]
['text':' we need to transform our range into sort keys:','line_number':573,'multiline':False]
['text':' Oops error:','line_number':580,'multiline':False]
['text':' Oops error:','line_number':596,'multiline':False]
['text':' everything in range matches:','line_number':599,'multiline':False]
['text':'','line_number':603,'multiline':False]
['text':' and now the classes:','line_number':604,'multiline':False]
['text':'','line_number':605,'multiline':False]
['text':' adjust m as needed:','line_number':610,'multiline':False]
['text':'','line_number':622,'multiline':False]
['text':' and now the negated classes:','line_number':623,'multiline':False]
['text':'','line_number':624,'multiline':False]
['text':' adjust m as needed:','line_number':628,'multiline':False]
['text':'','line_number':640,'multiline':False]
['text':' now process the equivalence classes:','line_number':641,'multiline':False]
['text':'','line_number':642,'multiline':False]
['text':' invalid or unsupported equivalence class','line_number':651,'multiline':False]
['text':' we've added all the states we need, now finish things off.','line_number':676,'multiline':False]
['text':' start by adding a terminating state:','line_number':677,'multiline':False]
['text':' extend storage to store original expression:','line_number':679,'multiline':False]
['text':' fill in our other data...','line_number':686,'multiline':False]
['text':' successful parsing implies a zero status:','line_number':687,'multiline':False]
['text':' get the first state of the machine:','line_number':689,'multiline':False]
['text':' fixup pointers in the machine:','line_number':691,'multiline':False]
['text':' create nested startmaps:','line_number':702,'multiline':False]
['text':' create main startmap:','line_number':704,'multiline':False]
['text':' get the restart type:','line_number':712,'multiline':False]
['text':' optimise a leading repeat if there is one:','line_number':714,'multiline':False]
['text':' set the state_id of this repeat:','line_number':737,'multiline':False]
['text':' just check that the index is valid:','line_number':767,'multiline':False]
['text':' check of sub-expression that doesn't exist:','line_number':777,'multiline':False]
['text':' update the error code if not already set','line_number':778,'multiline':False]
['text':'','line_number':780,'multiline':False]
['text':' clear the expression, we should be empty:','line_number':781,'multiline':False]
['text':'','line_number':782,'multiline':False]
['text':'','line_number':785,'multiline':False]
['text':' and throw if required:','line_number':786,'multiline':False]
['text':'','line_number':787,'multiline':False]
['text':'','line_number':806,'multiline':False]
['text':' There may be more than one capture group with this hash, just do what Perl','line_number':807,'multiline':False]
['text':' does and recurse to the leftmost:','line_number':808,'multiline':False]
['text':'','line_number':809,'multiline':False]
['text':'','line_number':822,'multiline':False]
['text':' We've found the target of the recursion, set the jump target:','line_number':823,'multiline':False]
['text':'','line_number':824,'multiline':False]
['text':' ','line_number':827,'multiline':False]
['text':' Now scan the target for nested repeats:','line_number':828,'multiline':False]
['text':'','line_number':829,'multiline':False]
['text':' recursion to sub-expression that doesn't exist:','line_number':866,'multiline':False]
['text':' update the error code if not already set','line_number':867,'multiline':False]
['text':'','line_number':869,'multiline':False]
['text':' clear the expression, we should be empty:','line_number':870,'multiline':False]
['text':'','line_number':871,'multiline':False]
['text':'','line_number':874,'multiline':False]
['text':' and throw if required:','line_number':875,'multiline':False]
['text':'','line_number':876,'multiline':False]
['text':' non-recursive implementation:','line_number':896,'multiline':False]
['text':' create the last map in the machine first, so that earlier maps','line_number':897,'multiline':False]
['text':' can make use of the result...','line_number':898,'multiline':False]
['text':'','line_number':899,'multiline':False]
['text':' This was originally a recursive implementation, but that caused stack','line_number':900,'multiline':False]
['text':' overflows with complex expressions on small stacks (think COM+).','line_number':901,'multiline':False]
['text':' start by saving the case setting:','line_number':903,'multiline':False]
['text':' we need to track case changes here:','line_number':912,'multiline':False]
['text':' just push the state onto our stack for now:','line_number':922,'multiline':False]
['text':' we need to calculate how big the backstep is:','line_number':927,'multiline':False]
['text':' Oops error:','line_number':932,'multiline':False]
['text':' update the error code if not already set','line_number':933,'multiline':False]
['text':'','line_number':935,'multiline':False]
['text':' clear the expression, we should be empty:','line_number':936,'multiline':False]
['text':'','line_number':937,'multiline':False]
['text':'','line_number':940,'multiline':False]
['text':' and throw if required:','line_number':941,'multiline':False]
['text':'','line_number':942,'multiline':False]
['text':' now work through our list, building all the maps as we go:','line_number':956,'multiline':False]
['text':' Initialize m_recursion_checks if we need it:','line_number':959,'multiline':False]
['text':' Build maps:','line_number':968,'multiline':False]
['text':' adjust the type of the state to allow for faster matching:','line_number':976,'multiline':False]
['text':' restore case sensitivity:','line_number':979,'multiline':False]
['text':' adjust the type of the state to allow for faster matching:','line_number':1027,'multiline':False]
['text':' track case sensitivity:','line_number':1096,'multiline':False]
['text':' don't set anything in *pnull, set each element in l_map','line_number':1109,'multiline':False]
['text':' that could match the first character in the literal:','line_number':1110,'multiline':False]
['text':' next character must be a line separator (if there is one):','line_number':1125,'multiline':False]
['text':' now figure out if we can match a NULL string at this point:','line_number':1134,'multiline':False]
['text':' Infinite recursion!!','line_number':1145,'multiline':False]
['text':' update the error code if not already set','line_number':1146,'multiline':False]
['text':'','line_number':1148,'multiline':False]
['text':' clear the expression, we should be empty:','line_number':1149,'multiline':False]
['text':'','line_number':1150,'multiline':False]
['text':'','line_number':1153,'multiline':False]
['text':' and throw if required:','line_number':1154,'multiline':False]
['text':'','line_number':1155,'multiline':False]
['text':' can't handle nested recursion here...','line_number':1172,'multiline':False]
['text':' can be null, and any character can match:','line_number':1176,'multiline':False]
['text':' can't be null, any character can match:','line_number':1182,'multiline':False]
['text':' must be null, any character can match:','line_number':1189,'multiline':False]
['text':' recurse, then AND with all the word characters:','line_number':1197,'multiline':False]
['text':' recurse, then AND with all the word characters:','line_number':1212,'multiline':False]
['text':' we *must be null* :','line_number':1227,'multiline':False]
['text':' take the jump:','line_number':1263,'multiline':False]
['text':' copy previous results:','line_number':1279,'multiline':False]
['text':' we haven't created a startmap for this alternative yet','line_number':1295,'multiline':False]
['text':' so take the union of the two options:','line_number':1296,'multiline':False]
['text':' match newline or null:','line_number':1314,'multiline':False]
['text':' need to handle independent subs as a special case:','line_number':1325,'multiline':False]
['text':' can be null, any character can match:','line_number':1328,'multiline':False]
['text':' recursion termination:','line_number':1336,'multiline':False]
['text':'','line_number':1342,'multiline':False]
['text':' Normally we just go to the next state... but if this sub-expression is','line_number':1343,'multiline':False]
['text':' the target of a recursion, then we might be ending a recursion, in which','line_number':1344,'multiline':False]
['text':' case we should check whatever follows that recursion, as well as whatever','line_number':1345,'multiline':False]
['text':' follows this state:','line_number':1346,'multiline':False]
['text':'','line_number':1347,'multiline':False]
['text':' Continue scanning so we can figure out whether we can be null:','line_number':1376,'multiline':False]
['text':' need to handle independent subs as a special case:','line_number':1380,'multiline':False]
['text':'','line_number':1397,'multiline':False]
['text':' find out how the machine starts, so we can optimise the search:','line_number':1398,'multiline':False]
['text':'','line_number':1399,'multiline':False]
['text':'','line_number':1427,'multiline':False]
['text':' set mask in all of bits elements, ','line_number':1428,'multiline':False]
['text':' if bits[0] has mask_init not set then we can ','line_number':1429,'multiline':False]
['text':' optimise this to a call to memset:','line_number':1430,'multiline':False]
['text':'','line_number':1431,'multiline':False]
['text':' run out of bits, assume we can't traverse this one.','line_number':1458,'multiline':False]
['text':' check to see if we are repeating a single state:','line_number':1495,'multiline':False]
['text':' enumerate our states, and see if we have a leading repeat ','line_number':1521,'multiline':False]
['text':' for which failed search restarts can be optimized;','line_number':1522,'multiline':False]
['text':' skip past the zero width assertion:','line_number':1540,'multiline':False]
['text':' Have to skip the leading jump state:','line_number':1549,'multiline':False]
['text':' namespace BOOST_REGEX_DETAIL_NS','line_number':1579,'multiline':False]
['text':' namespace boost','line_number':1581,'multiline':False]
