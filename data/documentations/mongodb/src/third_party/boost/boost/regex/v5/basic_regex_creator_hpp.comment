['text':'
 *
 * Copyright (c) 2004
 * John Maddock
 *
 * Use, modification and distribution are subject to the 
 * Boost Software License, Version 1.0. (See accompanying file 
 * LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 *
 ','line_number':1,'multiline':True]
['text':'
  *   LOCATION:    see http://www.boost.org for most recent version.
  *   FILE         basic_regex_creator.cpp
  *   VERSION      see <boost/version.hpp>
  *   DESCRIPTION: Declares template class basic_regex_creator which fills in
  *                the data members of a regex_data object.
  ','line_number':12,'multiline':True]
['text':'m_empty = false;','line_number':119,'multiline':False]
['text':'','line_number':122,'multiline':False]
['text':' accessor functions:','line_number':123,'multiline':False]
['text':'','line_number':124,'multiline':False]
['text':' a list of single characters to match','line_number':172,'multiline':False]
['text':' a list of end points of our ranges','line_number':173,'multiline':False]
['text':' true if the set is to be negated','line_number':174,'multiline':False]
['text':' true if we have digraphs present','line_number':175,'multiline':False]
['text':' character classes to match','line_number':176,'multiline':False]
['text':' negated character classes to match','line_number':177,'multiline':False]
['text':' whether we've added anything yet','line_number':178,'multiline':False]
['text':' a list of equivalence classes','line_number':179,'multiline':False]
['text':' pointer to the basic_regex_data struct we are filling in','line_number':228,'multiline':False]
['text':' convenience reference to traits class','line_number':230,'multiline':False]
['text':' the last state we added','line_number':231,'multiline':False]
['text':' true for case insensitive matches','line_number':232,'multiline':False]
['text':' the state_id of the next repeater','line_number':233,'multiline':False]
['text':' true if there are actually any backrefs','line_number':234,'multiline':False]
['text':' bitmask of repeats we can't deduce a startmap for;','line_number':235,'multiline':False]
['text':' set when we have recursive expressions to fixup','line_number':236,'multiline':False]
['text':' notes which recursions we've followed while analysing this expression','line_number':237,'multiline':False]
['text':' mask used to determine if a character is a word character','line_number':238,'multiline':False]
['text':' mask used to determine if a character is a word character','line_number':239,'multiline':False]
['text':' mask used to determine if a character is a lowercase character','line_number':240,'multiline':False]
['text':' mask used to determine if a character is an uppercase character','line_number':241,'multiline':False]
['text':' mask used to determine if a character is an alphabetic character','line_number':242,'multiline':False]
['text':' if the state is a backref then make a note of it:','line_number':288,'multiline':False]
['text':' append a new state, start by aligning our last one:','line_number':291,'multiline':False]
['text':' set the offset to the next state in our last one:','line_number':293,'multiline':False]
['text':' now actually extend our data:','line_number':296,'multiline':False]
['text':' fill in boilerplate options in the new state:','line_number':298,'multiline':False]
['text':' append a new state, start by aligning our last one:','line_number':307,'multiline':False]
['text':' set the offset to the next state in our last one:','line_number':309,'multiline':False]
['text':' remember the last state position:','line_number':312,'multiline':False]
['text':' now actually insert our data:','line_number':314,'multiline':False]
['text':' fill in boilerplate options in the new state:','line_number':316,'multiline':False]
['text':' start by seeing if we have an existing re_literal we can extend:','line_number':327,'multiline':False]
['text':' no existing re_literal, create a new one:','line_number':330,'multiline':False]
['text':' we have an existing re_literal, extend it:','line_number':337,'multiline':False]
['text':'','line_number':368,'multiline':False]
['text':' fill in the basics:','line_number':369,'multiline':False]
['text':'','line_number':370,'multiline':False]
['text':' adjust classes as needed:','line_number':378,'multiline':False]
['text':'','line_number':387,'multiline':False]
['text':' remember where the state is for later:','line_number':388,'multiline':False]
['text':'','line_number':389,'multiline':False]
['text':'','line_number':391,'multiline':False]
['text':' now extend with all the singles:','line_number':392,'multiline':False]
['text':'','line_number':393,'multiline':False]
['text':'','line_number':415,'multiline':False]
['text':' now extend with all the ranges:','line_number':416,'multiline':False]
['text':'','line_number':417,'multiline':False]
['text':' first grab the endpoints of the range:','line_number':422,'multiline':False]
['text':' different actions now depending upon whether collation is turned on:','line_number':432,'multiline':False]
['text':' we need to transform our range into sort keys:','line_number':435,'multiline':False]
['text':' Oops error:','line_number':464,'multiline':False]
['text':'','line_number':474,'multiline':False]
['text':' now process the equivalence classes:','line_number':475,'multiline':False]
['text':'','line_number':476,'multiline':False]
['text':' invalid or unsupported equivalence class','line_number':490,'multiline':False]
['text':'','line_number':496,'multiline':False]
['text':' finally reset the address of our last state:','line_number':497,'multiline':False]
['text':'','line_number':498,'multiline':False]
['text':'','line_number':528,'multiline':False]
['text':' handle singles first:','line_number':529,'multiline':False]
['text':'','line_number':530,'multiline':False]
['text':'','line_number':545,'multiline':False]
['text':' OK now handle ranges:','line_number':546,'multiline':False]
['text':'','line_number':547,'multiline':False]
['text':' first grab the endpoints of the range:','line_number':552,'multiline':False]
['text':' different actions now depending upon whether collation is turned on:','line_number':557,'multiline':False]
['text':' we need to transform our range into sort keys:','line_number':560,'multiline':False]
['text':' Oops error:','line_number':567,'multiline':False]
['text':' Oops error:','line_number':583,'multiline':False]
['text':' everything in range matches:','line_number':586,'multiline':False]
['text':'','line_number':590,'multiline':False]
['text':' and now the classes:','line_number':591,'multiline':False]
['text':'','line_number':592,'multiline':False]
['text':' adjust m as needed:','line_number':597,'multiline':False]
['text':'','line_number':609,'multiline':False]
['text':' and now the negated classes:','line_number':610,'multiline':False]
['text':'','line_number':611,'multiline':False]
['text':' adjust m as needed:','line_number':615,'multiline':False]
['text':'','line_number':627,'multiline':False]
['text':' now process the equivalence classes:','line_number':628,'multiline':False]
['text':'','line_number':629,'multiline':False]
['text':' invalid or unsupported equivalence class','line_number':638,'multiline':False]
['text':' we've added all the states we need, now finish things off.','line_number':663,'multiline':False]
['text':' start by adding a terminating state:','line_number':664,'multiline':False]
['text':' extend storage to store original expression:','line_number':666,'multiline':False]
['text':' fill in our other data...','line_number':673,'multiline':False]
['text':' successful parsing implies a zero status:','line_number':674,'multiline':False]
['text':' get the first state of the machine:','line_number':676,'multiline':False]
['text':' fixup pointers in the machine:','line_number':678,'multiline':False]
['text':' create nested startmaps:','line_number':689,'multiline':False]
['text':' create main startmap:','line_number':691,'multiline':False]
['text':' get the restart type:','line_number':699,'multiline':False]
['text':' optimise a leading repeat if there is one:','line_number':701,'multiline':False]
['text':' set the state_id of this repeat:','line_number':724,'multiline':False]
['text':' just check that the index is valid:','line_number':754,'multiline':False]
['text':' check of sub-expression that doesn't exist:','line_number':764,'multiline':False]
['text':' update the error code if not already set','line_number':765,'multiline':False]
['text':'','line_number':767,'multiline':False]
['text':' clear the expression, we should be empty:','line_number':768,'multiline':False]
['text':'','line_number':769,'multiline':False]
['text':'','line_number':772,'multiline':False]
['text':' and throw if required:','line_number':773,'multiline':False]
['text':'','line_number':774,'multiline':False]
['text':'','line_number':793,'multiline':False]
['text':' There may be more than one capture group with this hash, just do what Perl','line_number':794,'multiline':False]
['text':' does and recurse to the leftmost:','line_number':795,'multiline':False]
['text':'','line_number':796,'multiline':False]
['text':'','line_number':809,'multiline':False]
['text':' We've found the target of the recursion, set the jump target:','line_number':810,'multiline':False]
['text':'','line_number':811,'multiline':False]
['text':' ','line_number':814,'multiline':False]
['text':' Now scan the target for nested repeats:','line_number':815,'multiline':False]
['text':'','line_number':816,'multiline':False]
['text':' recursion to sub-expression that doesn't exist:','line_number':853,'multiline':False]
['text':' update the error code if not already set','line_number':854,'multiline':False]
['text':'','line_number':856,'multiline':False]
['text':' clear the expression, we should be empty:','line_number':857,'multiline':False]
['text':'','line_number':858,'multiline':False]
['text':'','line_number':861,'multiline':False]
['text':' and throw if required:','line_number':862,'multiline':False]
['text':'','line_number':863,'multiline':False]
['text':' non-recursive implementation:','line_number':883,'multiline':False]
['text':' create the last map in the machine first, so that earlier maps','line_number':884,'multiline':False]
['text':' can make use of the result...','line_number':885,'multiline':False]
['text':'','line_number':886,'multiline':False]
['text':' This was originally a recursive implementation, but that caused stack','line_number':887,'multiline':False]
['text':' overflows with complex expressions on small stacks (think COM+).','line_number':888,'multiline':False]
['text':' start by saving the case setting:','line_number':890,'multiline':False]
['text':' we need to track case changes here:','line_number':899,'multiline':False]
['text':' just push the state onto our stack for now:','line_number':909,'multiline':False]
['text':' we need to calculate how big the backstep is:','line_number':914,'multiline':False]
['text':' Oops error:','line_number':919,'multiline':False]
['text':' update the error code if not already set','line_number':920,'multiline':False]
['text':'','line_number':922,'multiline':False]
['text':' clear the expression, we should be empty:','line_number':923,'multiline':False]
['text':'','line_number':924,'multiline':False]
['text':'','line_number':927,'multiline':False]
['text':' and throw if required:','line_number':928,'multiline':False]
['text':'','line_number':929,'multiline':False]
['text':' now work through our list, building all the maps as we go:','line_number':943,'multiline':False]
['text':' Initialize m_recursion_checks if we need it:','line_number':946,'multiline':False]
['text':' Build maps:','line_number':955,'multiline':False]
['text':' adjust the type of the state to allow for faster matching:','line_number':963,'multiline':False]
['text':' restore case sensitivity:','line_number':966,'multiline':False]
['text':' adjust the type of the state to allow for faster matching:','line_number':1014,'multiline':False]
['text':' track case sensitivity:','line_number':1083,'multiline':False]
['text':' don't set anything in *pnull, set each element in l_map','line_number':1096,'multiline':False]
['text':' that could match the first character in the literal:','line_number':1097,'multiline':False]
['text':' next character must be a line separator (if there is one):','line_number':1112,'multiline':False]
['text':' now figure out if we can match a NULL string at this point:','line_number':1121,'multiline':False]
['text':' Infinite recursion!!','line_number':1132,'multiline':False]
['text':' update the error code if not already set','line_number':1133,'multiline':False]
['text':'','line_number':1135,'multiline':False]
['text':' clear the expression, we should be empty:','line_number':1136,'multiline':False]
['text':'','line_number':1137,'multiline':False]
['text':'','line_number':1140,'multiline':False]
['text':' and throw if required:','line_number':1141,'multiline':False]
['text':'','line_number':1142,'multiline':False]
['text':' can't handle nested recursion here...','line_number':1159,'multiline':False]
['text':' can be null, and any character can match:','line_number':1163,'multiline':False]
['text':' can't be null, any character can match:','line_number':1169,'multiline':False]
['text':' must be null, any character can match:','line_number':1176,'multiline':False]
['text':' recurse, then AND with all the word characters:','line_number':1184,'multiline':False]
['text':' recurse, then AND with all the word characters:','line_number':1199,'multiline':False]
['text':' we *must be null* :','line_number':1214,'multiline':False]
['text':' take the jump:','line_number':1250,'multiline':False]
['text':' copy previous results:','line_number':1266,'multiline':False]
['text':' we haven't created a startmap for this alternative yet','line_number':1282,'multiline':False]
['text':' so take the union of the two options:','line_number':1283,'multiline':False]
['text':' match newline or null:','line_number':1301,'multiline':False]
['text':' need to handle independent subs as a special case:','line_number':1312,'multiline':False]
['text':' can be null, any character can match:','line_number':1315,'multiline':False]
['text':' recursion termination:','line_number':1323,'multiline':False]
['text':'','line_number':1329,'multiline':False]
['text':' Normally we just go to the next state... but if this sub-expression is','line_number':1330,'multiline':False]
['text':' the target of a recursion, then we might be ending a recursion, in which','line_number':1331,'multiline':False]
['text':' case we should check whatever follows that recursion, as well as whatever','line_number':1332,'multiline':False]
['text':' follows this state:','line_number':1333,'multiline':False]
['text':'','line_number':1334,'multiline':False]
['text':' Continue scanning so we can figure out whether we can be null:','line_number':1363,'multiline':False]
['text':' need to handle independent subs as a special case:','line_number':1367,'multiline':False]
['text':'','line_number':1384,'multiline':False]
['text':' find out how the machine starts, so we can optimise the search:','line_number':1385,'multiline':False]
['text':'','line_number':1386,'multiline':False]
['text':'','line_number':1414,'multiline':False]
['text':' set mask in all of bits elements, ','line_number':1415,'multiline':False]
['text':' if bits[0] has mask_init not set then we can ','line_number':1416,'multiline':False]
['text':' optimise this to a call to memset:','line_number':1417,'multiline':False]
['text':'','line_number':1418,'multiline':False]
['text':' run out of bits, assume we can't traverse this one.','line_number':1445,'multiline':False]
['text':' check to see if we are repeating a single state:','line_number':1482,'multiline':False]
['text':' enumerate our states, and see if we have a leading repeat ','line_number':1508,'multiline':False]
['text':' for which failed search restarts can be optimized;','line_number':1509,'multiline':False]
['text':' skip past the zero width assertion:','line_number':1527,'multiline':False]
['text':' Have to skip the leading jump state:','line_number':1536,'multiline':False]
['text':' namespace BOOST_REGEX_DETAIL_NS','line_number':1566,'multiline':False]
['text':' namespace boost','line_number':1568,'multiline':False]
