['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' Redistribution and use in source and binary forms, with or without','line_number':3,'multiline':False]
['text':' modification, are permitted provided that the following conditions are','line_number':4,'multiline':False]
['text':' met:','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':'     * Redistributions of source code must retain the above copyright','line_number':7,'multiline':False]
['text':' notice, this list of conditions and the following disclaimer.','line_number':8,'multiline':False]
['text':'     * Redistributions in binary form must reproduce the above','line_number':9,'multiline':False]
['text':' copyright notice, this list of conditions and the following disclaimer','line_number':10,'multiline':False]
['text':' in the documentation and/or other materials provided with the','line_number':11,'multiline':False]
['text':' distribution.','line_number':12,'multiline':False]
['text':'     * Neither the name of Google Inc. nor the names of its','line_number':13,'multiline':False]
['text':' contributors may be used to endorse or promote products derived from','line_number':14,'multiline':False]
['text':' this software without specific prior written permission.','line_number':15,'multiline':False]
['text':'','line_number':16,'multiline':False]
['text':' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS','line_number':17,'multiline':False]
['text':' "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT','line_number':18,'multiline':False]
['text':' LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR','line_number':19,'multiline':False]
['text':' A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT','line_number':20,'multiline':False]
['text':' OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,','line_number':21,'multiline':False]
['text':' SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT','line_number':22,'multiline':False]
['text':' LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,','line_number':23,'multiline':False]
['text':' DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY','line_number':24,'multiline':False]
['text':' THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT','line_number':25,'multiline':False]
['text':' (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE','line_number':26,'multiline':False]
['text':' OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.','line_number':27,'multiline':False]
['text':' MongoDB customization: includes basetsd.h under Windows where SSIZE_T is declared.','line_number':29,'multiline':False]
['text':' Fixes missing ssize_t under Windows.','line_number':54,'multiline':False]
['text':' Used in IncrementalCopy and IncrementalCopyFastPath.','line_number':55,'multiline':False]
['text':' See:','line_number':56,'multiline':False]
['text':'    https://code.google.com/p/snappy/issues/detail?id=79','line_number':57,'multiline':False]
['text':'    http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx#SSIZE_T','line_number':58,'multiline':False]
['text':'    http://src.chromium.org/viewvc/chrome/trunk/src/third_party/snappy/win32/snappy-stubs-public.h','line_number':59,'multiline':False]
['text':' _WIN32','line_number':62,'multiline':False]
['text':' Any hash function will produce a valid compressed bitstream, but a good','line_number':73,'multiline':False]
['text':' hash function reduces the number of collisions and thus yields better','line_number':74,'multiline':False]
['text':' compression for compressible input, and more speed for incompressible','line_number':75,'multiline':False]
['text':' input. Of course, it doesn't hurt if the hash function is reasonably fast','line_number':76,'multiline':False]
['text':' either, as it gets called a lot.','line_number':77,'multiline':False]
['text':' Compressed data can be defined as:','line_number':87,'multiline':False]
['text':'    compressed := item* literal*','line_number':88,'multiline':False]
['text':'    item       := literal* copy','line_number':89,'multiline':False]
['text':'','line_number':90,'multiline':False]
['text':' The trailing literal sequence has a space blowup of at most 62/60','line_number':91,'multiline':False]
['text':' since a literal of length 60 needs one tag byte + one extra byte','line_number':92,'multiline':False]
['text':' for length information.','line_number':93,'multiline':False]
['text':'','line_number':94,'multiline':False]
['text':' Item blowup is trickier to measure.  Suppose the "copy" op copies','line_number':95,'multiline':False]
['text':' 4 bytes of data.  Because of a special check in the encoding code,','line_number':96,'multiline':False]
['text':' we produce a 4-byte copy only if the offset is < 65536.  Therefore','line_number':97,'multiline':False]
['text':' the copy op takes 3 bytes to encode, and this type of item leads','line_number':98,'multiline':False]
['text':' to at most the 62/60 blowup for representing literals.','line_number':99,'multiline':False]
['text':'','line_number':100,'multiline':False]
['text':' Suppose the "copy" op copies 5 bytes of data.  If the offset is big','line_number':101,'multiline':False]
['text':' enough, it will take 5 bytes to encode the copy op.  Therefore the','line_number':102,'multiline':False]
['text':' worst case here is a one-byte literal followed by a five-byte copy.','line_number':103,'multiline':False]
['text':' I.e., 6 bytes of input turn into 7 bytes of "compressed" data.','line_number':104,'multiline':False]
['text':'','line_number':105,'multiline':False]
['text':' This last factor dominates the blowup, so the final estimate is:','line_number':106,'multiline':False]
['text':' TODO(alkis): Remove this when we upgrade to a recent compiler that emits','line_number':119,'multiline':False]
['text':' SSE2 moves for memcpy(dst, src, 16).','line_number':120,'multiline':False]
['text':' Copy [src, src+(op_limit-op)) to [op, (op_limit-op)) a byte at a time. Used','line_number':131,'multiline':False]
['text':' for handling COPY operations where the input and output regions may overlap.','line_number':132,'multiline':False]
['text':' For example, suppose:','line_number':133,'multiline':False]
['text':'    src       == "ab"','line_number':134,'multiline':False]
['text':'    op        == src + 2','line_number':135,'multiline':False]
['text':'    op_limit  == op + 20','line_number':136,'multiline':False]
['text':' After IncrementalCopySlow(src, op, op_limit), the result will have eleven','line_number':137,'multiline':False]
['text':' copies of "ab"','line_number':138,'multiline':False]
['text':'    ababababababababababab','line_number':139,'multiline':False]
['text':' Note that this does not match the semantics of either memcpy() or memmove().','line_number':140,'multiline':False]
['text':' Copy [src, src+(op_limit-op)) to [op, (op_limit-op)) but faster than','line_number':149,'multiline':False]
['text':' IncrementalCopySlow. buf_limit is the address past the end of the writable','line_number':150,'multiline':False]
['text':' region of the buffer.','line_number':151,'multiline':False]
['text':' Terminology:','line_number':154,'multiline':False]
['text':'','line_number':155,'multiline':False]
['text':' slop = buf_limit - op','line_number':156,'multiline':False]
['text':' pat  = op - src','line_number':157,'multiline':False]
['text':' len  = limit - op','line_number':158,'multiline':False]
['text':' NOTE: The compressor always emits 4 <= len <= 64. It is ok to assume that','line_number':161,'multiline':False]
['text':' to optimize this function but we have to also handle these cases in case','line_number':162,'multiline':False]
['text':' the input does not satisfy these conditions.','line_number':163,'multiline':False]
['text':' The cases are split into different branches to allow the branch predictor,','line_number':166,'multiline':False]
['text':' FDO, and static prediction hints to work better. For each input we list the','line_number':167,'multiline':False]
['text':' ratio of invocations that match each condition.','line_number':168,'multiline':False]
['text':'','line_number':169,'multiline':False]
['text':' input        slop < 16   pat < 8  len > 16','line_number':170,'multiline':False]
['text':' ------------------------------------------','line_number':171,'multiline':False]
['text':' html|html4|cp   0%         1.01%    27.73%','line_number':172,'multiline':False]
['text':' urls            0%         0.88%    14.79%','line_number':173,'multiline':False]
['text':' jpg             0%        64.29%     7.14%','line_number':174,'multiline':False]
['text':' pdf             0%         2.56%    58.06%','line_number':175,'multiline':False]
['text':' txt[1-4]        0%         0.23%     0.97%','line_number':176,'multiline':False]
['text':' pb              0%         0.96%    13.88%','line_number':177,'multiline':False]
['text':' bin             0.01%     22.27%    41.17%','line_number':178,'multiline':False]
['text':'','line_number':179,'multiline':False]
['text':' It is very rare that we don't have enough slop for doing block copies. It','line_number':180,'multiline':False]
['text':' is also rare that we need to expand a pattern. Small patterns are common','line_number':181,'multiline':False]
['text':' for incompressible formats and for those we are plenty fast already.','line_number':182,'multiline':False]
['text':' Lengths are normally not greater than 16 but they vary depending on the','line_number':183,'multiline':False]
['text':' input. In general if we always predict len <= 16 it would be an ok','line_number':184,'multiline':False]
['text':' prediction.','line_number':185,'multiline':False]
['text':'','line_number':186,'multiline':False]
['text':' In order to be fast we want a pattern >= 8 bytes and an unrolled loop','line_number':187,'multiline':False]
['text':' copying 2x 8 bytes at a time.','line_number':188,'multiline':False]
['text':' Handle the uncommon case where pattern is less than 8 bytes.','line_number':190,'multiline':False]
['text':' Expand pattern to at least 8 bytes. The worse case scenario in terms of','line_number':192,'multiline':False]
['text':' buffer usage is when the pattern is size 3. ^ is the original position','line_number':193,'multiline':False]
['text':' of op. x are irrelevant bytes copied by the last UnalignedCopy64.','line_number':194,'multiline':False]
['text':'','line_number':195,'multiline':False]
['text':' abc','line_number':196,'multiline':False]
['text':' abcabcxxxxx','line_number':197,'multiline':False]
['text':' abcabcabcabcxxxxx','line_number':198,'multiline':False]
['text':'    ^','line_number':199,'multiline':False]
['text':' The last x is 14 bytes after ^.','line_number':200,'multiline':False]
['text':' Copy 2x 8 bytes at a time. Because op - src can be < 16, a single','line_number':214,'multiline':False]
['text':' UnalignedCopy128 might overwrite data in op. UnalignedCopy64 is safe','line_number':215,'multiline':False]
['text':' because expanding the pattern to at least 8 bytes guarantees that','line_number':216,'multiline':False]
['text':' op - src >= 8.','line_number':217,'multiline':False]
['text':' We only take this branch if we didn't have enough slop and we can do a','line_number':225,'multiline':False]
['text':' single 8 byte copy.','line_number':226,'multiline':False]
['text':' namespace','line_number':235,'multiline':False]
['text':' The vast majority of copies are below 16 bytes, for which a','line_number':241,'multiline':False]
['text':' call to memcpy is overkill. This fast path can sometimes','line_number':242,'multiline':False]
['text':' copy up to 15 bytes too much, but that is okay in the','line_number':243,'multiline':False]
['text':' main loop, since we have a bit to go on for both sides:','line_number':244,'multiline':False]
['text':'','line_number':245,'multiline':False]
['text':'   - The input will always have kInputMarginBytes = 15 extra','line_number':246,'multiline':False]
['text':'     available bytes, as long as we're in the main loop, and','line_number':247,'multiline':False]
['text':'     if not, allow_fast_path = false.','line_number':248,'multiline':False]
['text':'   - The output will always have 32 spare bytes (see','line_number':249,'multiline':False]
['text':'     MaxCompressedLength).','line_number':250,'multiline':False]
['text':' Zero-length literals are disallowed','line_number':251,'multiline':False]
['text':' Fits in tag byte','line_number':254,'multiline':False]
['text':' Fits in tag byte','line_number':262,'multiline':False]
['text':' Encode in upcoming bytes','line_number':265,'multiline':False]
['text':' offset fits in 11 bits.  The 3 highest go in the top of the first byte,','line_number':290,'multiline':False]
['text':' and the rest go in the second byte.','line_number':291,'multiline':False]
['text':' Write 4 bytes, though we only care about 3 of them.  The output buffer','line_number':295,'multiline':False]
['text':' is required to have some slack, so the extra byte won't overrun it.','line_number':296,'multiline':False]
['text':' A special case for len <= 64 might help, but so far measurements suggest','line_number':310,'multiline':False]
['text':' it's in the noise.','line_number':311,'multiline':False]
['text':' Emit 64 byte copies but make sure to keep at least four bytes reserved.','line_number':313,'multiline':False]
['text':' One or two copies will now finish the job.','line_number':319,'multiline':False]
['text':' Emit remainder.','line_number':325,'multiline':False]
['text':' Use smaller hash table when input.size() is smaller, since we','line_number':344,'multiline':False]
['text':' fill the table, incurring O(hash table size) overhead for','line_number':345,'multiline':False]
['text':' compression, and if the input is short, we won't need that','line_number':346,'multiline':False]
['text':' many hash table entries anyway.','line_number':347,'multiline':False]
['text':' end namespace internal','line_number':368,'multiline':False]
['text':' For 0 <= offset <= 4, GetUint32AtOffset(GetEightBytesAt(p), offset) will','line_number':370,'multiline':False]
['text':' equal UNALIGNED_LOAD32(p + offset).  Motivation: On x86-64 hardware we have','line_number':371,'multiline':False]
['text':' empirically found that overlapping loads such as','line_number':372,'multiline':False]
['text':'  UNALIGNED_LOAD32(p) ... UNALIGNED_LOAD32(p+1) ... UNALIGNED_LOAD32(p+2)','line_number':373,'multiline':False]
['text':' are slower than UNALIGNED_LOAD64(p) followed by shifts and casts to uint32.','line_number':374,'multiline':False]
['text':'','line_number':375,'multiline':False]
['text':' We have different versions for 64- and 32-bit; ideally we would avoid the','line_number':376,'multiline':False]
['text':' two functions and just inline the UNALIGNED_LOAD64 call into','line_number':377,'multiline':False]
['text':' GetUint32AtOffset, but GCC (at least not as of 4.6) is seemingly not clever','line_number':378,'multiline':False]
['text':' enough to avoid loading the value multiple times then. For 64-bit, the load','line_number':379,'multiline':False]
['text':' is done when GetEightBytesAt() is called, whereas for 32-bit, the load is','line_number':380,'multiline':False]
['text':' done at GetUint32AtOffset() time.','line_number':381,'multiline':False]
['text':' Flat array compression that does not emit the "uncompressed length"','line_number':413,'multiline':False]
['text':' prefix. Compresses "input" string to the "*op" buffer.','line_number':414,'multiline':False]
['text':'','line_number':415,'multiline':False]
['text':' REQUIRES: "input" is at most "kBlockSize" bytes long.','line_number':416,'multiline':False]
['text':' REQUIRES: "op" points to an array of memory that is at least','line_number':417,'multiline':False]
['text':' "MaxCompressedLength(input.size())" in size.','line_number':418,'multiline':False]
['text':' REQUIRES: All elements in "table[0..table_size-1]" are initialized to zero.','line_number':419,'multiline':False]
['text':' REQUIRES: "table_size" is a power of two','line_number':420,'multiline':False]
['text':'','line_number':421,'multiline':False]
['text':' Returns an "end" pointer into "op" buffer.','line_number':422,'multiline':False]
['text':' "end - op" is the compressed size of "input".','line_number':423,'multiline':False]
['text':' "ip" is the input pointer, and "op" is the output pointer.','line_number':430,'multiline':False]
['text':' table must be power of two','line_number':433,'multiline':False]
['text':' Bytes in [next_emit, ip) will be emitted as literal bytes.  Or','line_number':438,'multiline':False]
['text':' [next_emit, ip_end) after the main loop.','line_number':439,'multiline':False]
['text':' The body of this loop calls EmitLiteral once and then EmitCopy one or','line_number':448,'multiline':False]
['text':' more times.  (The exception is that when we're close to exhausting','line_number':449,'multiline':False]
['text':' the input we goto emit_remainder.)','line_number':450,'multiline':False]
['text':'','line_number':451,'multiline':False]
['text':' In the first iteration of this loop we're just starting, so','line_number':452,'multiline':False]
['text':' there's nothing to copy, so calling EmitLiteral once is','line_number':453,'multiline':False]
['text':' necessary.  And we only start a new iteration when the','line_number':454,'multiline':False]
['text':' current iteration has determined that a call to EmitLiteral will','line_number':455,'multiline':False]
['text':' precede the next call to EmitCopy (if any).','line_number':456,'multiline':False]
['text':'','line_number':457,'multiline':False]
['text':' Step 1: Scan forward in the input looking for a 4-byte-long match.','line_number':458,'multiline':False]
['text':' If we get close to exhausting the input then goto emit_remainder.','line_number':459,'multiline':False]
['text':'','line_number':460,'multiline':False]
['text':' Heuristic match skipping: If 32 bytes are scanned with no matches','line_number':461,'multiline':False]
['text':' found, start looking only at every other byte. If 32 more bytes are','line_number':462,'multiline':False]
['text':' scanned (or skipped), look at every third byte, etc.. When a match is','line_number':463,'multiline':False]
['text':' found, immediately go back to looking at every byte. This is a small','line_number':464,'multiline':False]
['text':' loss (~5% performance, ~0.1% density) for compressible data due to more','line_number':465,'multiline':False]
['text':' bookkeeping, but for non-compressible data (such as JPEG) it's a huge','line_number':466,'multiline':False]
['text':' win since the compressor quickly "realizes" the data is incompressible','line_number':467,'multiline':False]
['text':' and doesn't bother looking for matches everywhere.','line_number':468,'multiline':False]
['text':'','line_number':469,'multiline':False]
['text':' The "skip" variable keeps track of how many bytes there are since the','line_number':470,'multiline':False]
['text':' last match; dividing it by 32 (ie. right-shifting by five) gives the','line_number':471,'multiline':False]
['text':' number of bytes to move ahead for each iteration.','line_number':472,'multiline':False]
['text':' Step 2: A 4-byte match has been found.  We'll later see if more','line_number':496,'multiline':False]
['text':' than 4 bytes match.  But, prior to the match, input','line_number':497,'multiline':False]
['text':' bytes [next_emit, ip) are unmatched.  Emit them as "literal bytes."','line_number':498,'multiline':False]
['text':' Step 3: Call EmitCopy, and then see if another EmitCopy could','line_number':502,'multiline':False]
['text':' be our next move.  Repeat until we find no match for the','line_number':503,'multiline':False]
['text':' input immediately after what was consumed by the last EmitCopy call.','line_number':504,'multiline':False]
['text':'','line_number':505,'multiline':False]
['text':' If we exit this loop normally then we need to call EmitLiteral next,','line_number':506,'multiline':False]
['text':' though we don't yet know how big the literal will be.  We handle that','line_number':507,'multiline':False]
['text':' by proceeding to the next iteration of the main loop.  We also can exit','line_number':508,'multiline':False]
['text':' this loop via goto if we get close to exhausting the input.','line_number':509,'multiline':False]
['text':' We have a 4-byte match at ip, and no need to emit any','line_number':514,'multiline':False]
['text':' "literal bytes" prior to ip.','line_number':515,'multiline':False]
['text':' We are now looking for a 4-byte match again.  We read','line_number':528,'multiline':False]
['text':' table[Hash(ip, shift)] for that.  To improve compression,','line_number':529,'multiline':False]
['text':' we also update table[Hash(ip - 1, shift)] and table[Hash(ip, shift)].','line_number':530,'multiline':False]
['text':' Emit the remaining bytes as a literal','line_number':546,'multiline':False]
['text':' end namespace internal','line_number':553,'multiline':False]
['text':' Called back at avery compression call to trace parameters and sizes.','line_number':555,'multiline':False]
['text':' Signature of output types needed by decompression code.','line_number':559,'multiline':False]
['text':' The decompression code is templatized on a type that obeys this','line_number':560,'multiline':False]
['text':' signature so that we do not pay virtual function call overhead in','line_number':561,'multiline':False]
['text':' the middle of a tight decompression loop.','line_number':562,'multiline':False]
['text':'','line_number':563,'multiline':False]
['text':' class DecompressionWriter {','line_number':564,'multiline':False]
['text':'  public:','line_number':565,'multiline':False]
['text':'   // Called before decompression','line_number':566,'multiline':False]
['text':'   void SetExpectedLength(size_t length);','line_number':567,'multiline':False]
['text':'','line_number':568,'multiline':False]
['text':'   // Called after decompression','line_number':569,'multiline':False]
['text':'   bool CheckLength() const;','line_number':570,'multiline':False]
['text':'','line_number':571,'multiline':False]
['text':'   // Called repeatedly during decompression','line_number':572,'multiline':False]
['text':'   bool Append(const char* ip, size_t length);','line_number':573,'multiline':False]
['text':'   bool AppendFromSelf(uint32 offset, size_t length);','line_number':574,'multiline':False]
['text':'','line_number':575,'multiline':False]
['text':'   // The rules for how TryFastAppend differs from Append are somewhat','line_number':576,'multiline':False]
['text':'   // convoluted:','line_number':577,'multiline':False]
['text':'   //','line_number':578,'multiline':False]
['text':'   //  - TryFastAppend is allowed to decline (return false) at any','line_number':579,'multiline':False]
['text':'   //    time, for any reason -- just "return false" would be','line_number':580,'multiline':False]
['text':'   //    a perfectly legal implementation of TryFastAppend.','line_number':581,'multiline':False]
['text':'   //    The intention is for TryFastAppend to allow a fast path','line_number':582,'multiline':False]
['text':'   //    in the common case of a small append.','line_number':583,'multiline':False]
['text':'   //  - TryFastAppend is allowed to read up to <available> bytes','line_number':584,'multiline':False]
['text':'   //    from the input buffer, whereas Append is allowed to read','line_number':585,'multiline':False]
['text':'   //    <length>. However, if it returns true, it must leave','line_number':586,'multiline':False]
['text':'   //    at least five (kMaximumTagLength) bytes in the input buffer','line_number':587,'multiline':False]
['text':'   //    afterwards, so that there is always enough space to read the','line_number':588,'multiline':False]
['text':'   //    next tag without checking for a refill.','line_number':589,'multiline':False]
['text':'   //  - TryFastAppend must always return decline (return false)','line_number':590,'multiline':False]
['text':'   //    if <length> is 61 or more, as in this case the literal length is not','line_number':591,'multiline':False]
['text':'   //    decoded fully. In practice, this should not be a big problem,','line_number':592,'multiline':False]
['text':'   //    as it is unlikely that one would implement a fast path accepting','line_number':593,'multiline':False]
['text':'   //    this much data.','line_number':594,'multiline':False]
['text':'   //','line_number':595,'multiline':False]
['text':'   bool TryFastAppend(const char* ip, size_t available, size_t length);','line_number':596,'multiline':False]
['text':' };','line_number':597,'multiline':False]
['text':' Mapping from i in range [0,4] to a mask to extract the bottom 8*i bits','line_number':601,'multiline':False]
['text':' end namespace internal','line_number':606,'multiline':False]
['text':' Helper class for decompression','line_number':608,'multiline':False]
['text':' Underlying source of bytes to decompress','line_number':611,'multiline':False]
['text':' Points to next buffered byte','line_number':612,'multiline':False]
['text':' Points just past buffered bytes','line_number':613,'multiline':False]
['text':' Bytes peeked from reader (need to skip)','line_number':614,'multiline':False]
['text':' Hit end of input without an error?','line_number':615,'multiline':False]
['text':' See RefillTag().','line_number':616,'multiline':False]
['text':' Ensure that all of the tag metadata for the next tag is available','line_number':618,'multiline':False]
['text':' in [ip_..ip_limit_-1].  Also ensures that [ip,ip+4] is readable even','line_number':619,'multiline':False]
['text':' if (ip_limit_ - ip_ < 5).','line_number':620,'multiline':False]
['text':'','line_number':621,'multiline':False]
['text':' Returns true on success, false on error or end of input.','line_number':622,'multiline':False]
['text':' Advance past any bytes we peeked at from the reader','line_number':635,'multiline':False]
['text':' Returns true iff we have hit the end of the input without an error.','line_number':639,'multiline':False]
['text':' Read the uncompressed length stored at the start of the compressed data.','line_number':644,'multiline':False]
['text':' On succcess, stores the length in *result and returns true.','line_number':645,'multiline':False]
['text':' On failure, returns false.','line_number':646,'multiline':False]
['text':' Must not have read anything yet','line_number':648,'multiline':False]
['text':' Length is encoded in 1..5 bytes','line_number':649,'multiline':False]
['text':' Process the next item found in the input.','line_number':670,'multiline':False]
['text':' Returns true if successful, false on error or end of input.','line_number':671,'multiline':False]
['text':' For position-independent executables, accessing global arrays can be','line_number':675,'multiline':False]
['text':' slow.  Move wordmask array onto the stack to mitigate this.','line_number':676,'multiline':False]
['text':' Do not use memcpy to copy internal::wordmask to','line_number':678,'multiline':False]
['text':' wordmask.  LLVM converts stack arrays to global arrays if it detects','line_number':679,'multiline':False]
['text':' const stack arrays and this hurts the performance of position','line_number':680,'multiline':False]
['text':' independent code. This change is temporary and can be reverted when','line_number':681,'multiline':False]
['text':' https://reviews.llvm.org/D30759 is approved.','line_number':682,'multiline':False]
['text':' We could have put this refill fragment only at the beginning of the loop.','line_number':689,'multiline':False]
['text':' However, duplicating it at the end of each branch gives the compiler more','line_number':690,'multiline':False]
['text':' scope to optimize the <ip_limit_ - ip> expression based on the local','line_number':691,'multiline':False]
['text':' context, which overall increases speed.','line_number':692,'multiline':False]
['text':' Add loop alignment directive. Without this directive, we observed','line_number':701,'multiline':False]
['text':' significant performance degradation on several intel architectures','line_number':702,'multiline':False]
['text':' in snappy benchmark built with LLVM. The degradation was caused by','line_number':703,'multiline':False]
['text':' increased branch miss prediction.','line_number':704,'multiline':False]
['text':' Ratio of iterations that have LITERAL vs non-LITERAL for different','line_number':711,'multiline':False]
['text':' inputs.','line_number':712,'multiline':False]
['text':'','line_number':713,'multiline':False]
['text':' input          LITERAL  NON_LITERAL','line_number':714,'multiline':False]
['text':' -----------------------------------','line_number':715,'multiline':False]
['text':' html|html4|cp   23%        77%','line_number':716,'multiline':False]
['text':' urls            36%        64%','line_number':717,'multiline':False]
['text':' jpg             47%        53%','line_number':718,'multiline':False]
['text':' pdf             19%        81%','line_number':719,'multiline':False]
['text':' txt[1-4]        25%        75%','line_number':720,'multiline':False]
['text':' pb              24%        76%','line_number':721,'multiline':False]
['text':' bin             24%        76%','line_number':722,'multiline':False]
['text':' NOTE(user): There is no MAYBE_REFILL() here, as TryFastAppend()','line_number':728,'multiline':False]
['text':' will not return true unless there's already at least five spare','line_number':729,'multiline':False]
['text':' bytes in addition to the literal.','line_number':730,'multiline':False]
['text':' Long literal.','line_number':734,'multiline':False]
['text':' Premature end of input','line_number':750,'multiline':False]
['text':' copy_offset/256 is encoded in bits 8..10.  By just fetching','line_number':764,'multiline':False]
['text':' those bits, we get copy_offset (since the bit-field starts at','line_number':765,'multiline':False]
['text':' bit 8).','line_number':766,'multiline':False]
['text':' Fetch a new fragment from the reader','line_number':782,'multiline':False]
['text':' All peeked bytes are used up','line_number':783,'multiline':False]
['text':' Read the tag character','line_number':792,'multiline':False]
['text':' +1 byte for 'c'','line_number':796,'multiline':False]
['text':' Read more bytes from reader if needed','line_number':799,'multiline':False]
['text':' Stitch together bytes from ip and reader to form the word','line_number':802,'multiline':False]
['text':' contents.  We store the needed bytes in "scratch_".  They','line_number':803,'multiline':False]
['text':' will be consumed immediately by the caller since we do not','line_number':804,'multiline':False]
['text':' read more than we need.','line_number':805,'multiline':False]
['text':' All peeked bytes are used up','line_number':807,'multiline':False]
['text':' Have enough bytes, but move into scratch_ so that we do not','line_number':822,'multiline':False]
['text':' read past end of input','line_number':823,'multiline':False]
['text':' All peeked bytes are used up','line_number':825,'multiline':False]
['text':' Pass pointer to buffer returned by reader_.','line_number':830,'multiline':False]
['text':' Read the uncompressed length from the front of the compressed input','line_number':838,'multiline':False]
['text':' Process the entire input','line_number':856,'multiline':False]
['text':' Get next block to compress (without copying if possible)','line_number':881,'multiline':False]
['text':' premature end of input','line_number':884,'multiline':False]
['text':' Buffer returned by reader is large enough','line_number':890,'multiline':False]
['text':' Read into scratch buffer','line_number':894,'multiline':False]
['text':' If this is the last iteration, we want to allocate N bytes','line_number':896,'multiline':False]
['text':' of space, otherwise the max possible kBlockSize space.','line_number':897,'multiline':False]
['text':' num_to_read contains exactly the correct value','line_number':898,'multiline':False]
['text':' Get encoding table for compression','line_number':917,'multiline':False]
['text':' Compress input_fragment and append to dest','line_number':921,'multiline':False]
['text':' If the byte sink doesn't have room for us directly, allocate a scratch','line_number':924,'multiline':False]
['text':' buffer.','line_number':925,'multiline':False]
['text':'','line_number':926,'multiline':False]
['text':' Since we encode kBlockSize regions followed by a region','line_number':927,'multiline':False]
['text':' which is <= kBlockSize in length, a previously allocated','line_number':928,'multiline':False]
['text':' scratch_output[] region is big enough for this iteration.','line_number':929,'multiline':False]
['text':' -----------------------------------------------------------------------','line_number':951,'multiline':False]
['text':' IOVec interfaces','line_number':952,'multiline':False]
['text':' -----------------------------------------------------------------------','line_number':953,'multiline':False]
['text':' A type that writes to an iovec.','line_number':955,'multiline':False]
['text':' Note that this is not a "ByteSink", but a type that matches the','line_number':956,'multiline':False]
['text':' Writer template argument to SnappyDecompressor::DecompressAllTags().','line_number':957,'multiline':False]
['text':' We are currently writing into output_iov_[curr_iov_index_].','line_number':963,'multiline':False]
['text':' Bytes written to output_iov_[curr_iov_index_] so far.','line_number':966,'multiline':False]
['text':' Total bytes decompressed into output_iov_ so far.','line_number':969,'multiline':False]
['text':' Maximum number of bytes that will be decompressed into output_iov_.','line_number':972,'multiline':False]
['text':' Does not take ownership of iov. iov must be valid during the','line_number':981,'multiline':False]
['text':' entire lifetime of the SnappyIOVecWriter.','line_number':982,'multiline':False]
['text':' This iovec is full. Go to the next one.','line_number':1008,'multiline':False]
['text':' Fast path, used for the majority (about 95%) of invocations.','line_number':1034,'multiline':False]
['text':' Locate the iovec from which we need to start the copy.','line_number':1054,'multiline':False]
['text':' Copy <len> bytes starting from the iovec pointed to by from_iov_index to','line_number':1069,'multiline':False]
['text':' the current iovec.','line_number':1070,'multiline':False]
['text':' This iovec is full. Go to the next one.','line_number':1089,'multiline':False]
['text':' -----------------------------------------------------------------------','line_number':1129,'multiline':False]
['text':' Flat array interfaces','line_number':1130,'multiline':False]
['text':' -----------------------------------------------------------------------','line_number':1131,'multiline':False]
['text':' A type that writes to a flat array.','line_number':1133,'multiline':False]
['text':' Note that this is not a "ByteSink", but a type that matches the','line_number':1134,'multiline':False]
['text':' Writer template argument to SnappyDecompressor::DecompressAllTags().','line_number':1135,'multiline':False]
['text':' Fast path, used for the majority (about 95%) of invocations.','line_number':1172,'multiline':False]
['text':' Check if we try to append from before the start of the buffer.','line_number':1184,'multiline':False]
['text':' Normally this would just be a check for "produced < offset",','line_number':1185,'multiline':False]
['text':' but "produced <= offset - 1u" is equivalent for every case','line_number':1186,'multiline':False]
['text':' except the one where offset==0, where the right side will wrap around','line_number':1187,'multiline':False]
['text':' to a very big number. This is convenient, as offset==0 is another','line_number':1188,'multiline':False]
['text':' invalid case that we also want to catch, so that we do not go','line_number':1189,'multiline':False]
['text':' into an infinite loop.','line_number':1190,'multiline':False]
['text':' On 32-bit builds: max_size() < kuint32max.  Check for that instead','line_number':1218,'multiline':False]
['text':' of crashing (e.g., consider externally specified compressed data).','line_number':1219,'multiline':False]
['text':' A Writer that drops everything on the floor and just does validation','line_number':1227,'multiline':False]
['text':' See SnappyArrayWriter::AppendFromSelf for an explanation of','line_number':1249,'multiline':False]
['text':' the "offset - 1u" trick.','line_number':1250,'multiline':False]
['text':' Compute how many bytes were added','line_number':1277,'multiline':False]
['text':' Pre-grow the buffer to the max length of the compressed output','line_number':1282,'multiline':False]
['text':' -----------------------------------------------------------------------','line_number':1292,'multiline':False]
['text':' Sink interface','line_number':1293,'multiline':False]
['text':' -----------------------------------------------------------------------','line_number':1294,'multiline':False]
['text':' A type that decompresses into a Sink. The template parameter','line_number':1296,'multiline':False]
['text':' Allocator must export one method "char* Allocate(int size);", which','line_number':1297,'multiline':False]
['text':' allocates a buffer of "size" and appends that to the destination.','line_number':1298,'multiline':False]
['text':' We need random access into the data generated so far.  Therefore','line_number':1303,'multiline':False]
['text':' we keep track of all of the generated data as an array of blocks.','line_number':1304,'multiline':False]
['text':' All of the blocks except the last have length kBlockSize.','line_number':1305,'multiline':False]
['text':' Total size of all fully generated blocks so far','line_number':1309,'multiline':False]
['text':' Pointer into current output block','line_number':1312,'multiline':False]
['text':' Base of output block','line_number':1313,'multiline':False]
['text':' Pointer to next unfilled byte in block','line_number':1314,'multiline':False]
['text':' Pointer just past block','line_number':1315,'multiline':False]
['text':' Return the number of bytes actually uncompressed so far','line_number':1342,'multiline':False]
['text':' Fast path','line_number':1350,'multiline':False]
['text':' Fast path, used for the majority (about 95%) of invocations.','line_number':1364,'multiline':False]
['text':' See SnappyArrayWriter::AppendFromSelf for an explanation of','line_number':1375,'multiline':False]
['text':' the "offset - 1u" trick.','line_number':1376,'multiline':False]
['text':' Fast path: src and dst in current block.','line_number':1379,'multiline':False]
['text':' Called at the end of the decompress. We ask the allocator','line_number':1386,'multiline':False]
['text':' write all blocks to the sink.','line_number':1387,'multiline':False]
['text':' Completely fill this block','line_number':1395,'multiline':False]
['text':' Bounds check','line_number':1403,'multiline':False]
['text':' Make new block','line_number':1408,'multiline':False]
['text':' Overflow check','line_number':1425,'multiline':False]
['text':' See SnappyArrayWriter::AppendFromSelf for an explanation of','line_number':1426,'multiline':False]
['text':' the "offset - 1u" trick.','line_number':1427,'multiline':False]
['text':' Currently we shouldn't ever hit this path because Compress() chops the','line_number':1432,'multiline':False]
['text':' input into blocks and does not create cross-block copies. However, it is','line_number':1433,'multiline':False]
['text':' nice if we do not rely on that, since we can get better compression if we','line_number':1434,'multiline':False]
['text':' allow cross-block copies and thus might want to change the compressor in','line_number':1435,'multiline':False]
['text':' the future.','line_number':1436,'multiline':False]
['text':' We flush only at the end, because the writer wants','line_number':1457,'multiline':False]
['text':' random access to the blocks and once we hand the','line_number':1458,'multiline':False]
['text':' block over to the sink, we can't access it anymore.','line_number':1459,'multiline':False]
['text':' Also we don't write more than has been actually written','line_number':1460,'multiline':False]
['text':' to the blocks.','line_number':1461,'multiline':False]
['text':' Note: copying this object is allowed','line_number':1488,'multiline':False]
['text':' Read the uncompressed length from the front of the compressed input','line_number':1499,'multiline':False]
['text':' If we can get a flat buffer, then use it, otherwise do block by block','line_number':1512,'multiline':False]
['text':' uncompression','line_number':1513,'multiline':False]
['text':' end namespace snappy','line_number':1528,'multiline':False]
