['text':' Copyright 2011 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' Redistribution and use in source and binary forms, with or without','line_number':3,'multiline':False]
['text':' modification, are permitted provided that the following conditions are','line_number':4,'multiline':False]
['text':' met:','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':'     * Redistributions of source code must retain the above copyright','line_number':7,'multiline':False]
['text':' notice, this list of conditions and the following disclaimer.','line_number':8,'multiline':False]
['text':'     * Redistributions in binary form must reproduce the above','line_number':9,'multiline':False]
['text':' copyright notice, this list of conditions and the following disclaimer','line_number':10,'multiline':False]
['text':' in the documentation and/or other materials provided with the','line_number':11,'multiline':False]
['text':' distribution.','line_number':12,'multiline':False]
['text':'     * Neither the name of Google Inc. nor the names of its','line_number':13,'multiline':False]
['text':' contributors may be used to endorse or promote products derived from','line_number':14,'multiline':False]
['text':' this software without specific prior written permission.','line_number':15,'multiline':False]
['text':'','line_number':16,'multiline':False]
['text':' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS','line_number':17,'multiline':False]
['text':' "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT','line_number':18,'multiline':False]
['text':' LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR','line_number':19,'multiline':False]
['text':' A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT','line_number':20,'multiline':False]
['text':' OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,','line_number':21,'multiline':False]
['text':' SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT','line_number':22,'multiline':False]
['text':' LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,','line_number':23,'multiline':False]
['text':' DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY','line_number':24,'multiline':False]
['text':' THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT','line_number':25,'multiline':False]
['text':' (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE','line_number':26,'multiline':False]
['text':' OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.','line_number':27,'multiline':False]
['text':' A Sink is an interface that consumes a sequence of bytes.','line_number':36,'multiline':False]
['text':' Append "bytes[0,n-1]" to this.','line_number':42,'multiline':False]
['text':' Returns a writable buffer of the specified length for appending.','line_number':45,'multiline':False]
['text':' May return a pointer to the caller-owned scratch buffer which','line_number':46,'multiline':False]
['text':' must have at least the indicated length.  The returned buffer is','line_number':47,'multiline':False]
['text':' only valid until the next operation on this Sink.','line_number':48,'multiline':False]
['text':'','line_number':49,'multiline':False]
['text':' After writing at most "length" bytes, call Append() with the','line_number':50,'multiline':False]
['text':' pointer returned from this function and the number of bytes','line_number':51,'multiline':False]
['text':' written.  Many Append() implementations will avoid copying','line_number':52,'multiline':False]
['text':' bytes if this function returned an internal buffer.','line_number':53,'multiline':False]
['text':'','line_number':54,'multiline':False]
['text':' If a non-scratch buffer is returned, the caller may only pass a','line_number':55,'multiline':False]
['text':' prefix of it to Append().  That is, it is not correct to pass an','line_number':56,'multiline':False]
['text':' interior pointer of the returned array to Append().','line_number':57,'multiline':False]
['text':'','line_number':58,'multiline':False]
['text':' The default implementation always returns the scratch buffer.','line_number':59,'multiline':False]
['text':' For higher performance, Sink implementations can provide custom','line_number':62,'multiline':False]
['text':' AppendAndTakeOwnership() and GetAppendBufferVariable() methods.','line_number':63,'multiline':False]
['text':' These methods can reduce the number of copies done during','line_number':64,'multiline':False]
['text':' compression/decompression.','line_number':65,'multiline':False]
['text':' Append "bytes[0,n-1] to the sink. Takes ownership of "bytes"','line_number':67,'multiline':False]
['text':' and calls the deleter function as (*deleter)(deleter_arg, bytes, n)','line_number':68,'multiline':False]
['text':' to free the buffer. deleter function must be non NULL.','line_number':69,'multiline':False]
['text':'','line_number':70,'multiline':False]
['text':' The default implementation just calls Append and frees "bytes".','line_number':71,'multiline':False]
['text':' Other implementations may avoid a copy while appending the buffer.','line_number':72,'multiline':False]
['text':' Returns a writable buffer for appending and writes the buffer's capacity to','line_number':77,'multiline':False]
['text':' *allocated_size. Guarantees *allocated_size >= min_size.','line_number':78,'multiline':False]
['text':' May return a pointer to the caller-owned scratch buffer which must have','line_number':79,'multiline':False]
['text':' scratch_size >= min_size.','line_number':80,'multiline':False]
['text':'','line_number':81,'multiline':False]
['text':' The returned buffer is only valid until the next operation','line_number':82,'multiline':False]
['text':' on this ByteSink.','line_number':83,'multiline':False]
['text':'','line_number':84,'multiline':False]
['text':' After writing at most *allocated_size bytes, call Append() with the','line_number':85,'multiline':False]
['text':' pointer returned from this function and the number of bytes written.','line_number':86,'multiline':False]
['text':' Many Append() implementations will avoid copying bytes if this function','line_number':87,'multiline':False]
['text':' returned an internal buffer.','line_number':88,'multiline':False]
['text':'','line_number':89,'multiline':False]
['text':' If the sink implementation allocates or reallocates an internal buffer,','line_number':90,'multiline':False]
['text':' it should use the desired_size_hint if appropriate. If a caller cannot','line_number':91,'multiline':False]
['text':' provide a reasonable guess at the desired capacity, it should set','line_number':92,'multiline':False]
['text':' desired_size_hint = 0.','line_number':93,'multiline':False]
['text':'','line_number':94,'multiline':False]
['text':' If a non-scratch buffer is returned, the caller may only pass','line_number':95,'multiline':False]
['text':' a prefix to it to Append(). That is, it is not correct to pass an','line_number':96,'multiline':False]
['text':' interior pointer to Append().','line_number':97,'multiline':False]
['text':'','line_number':98,'multiline':False]
['text':' The default implementation always returns the scratch buffer.','line_number':99,'multiline':False]
['text':' No copying','line_number':105,'multiline':False]
['text':' A Source is an interface that yields a sequence of bytes','line_number':110,'multiline':False]
['text':' Return the number of bytes left to read from the source','line_number':116,'multiline':False]
['text':' Peek at the next flat region of the source.  Does not reposition','line_number':119,'multiline':False]
['text':' the source.  The returned region is empty iff Available()==0.','line_number':120,'multiline':False]
['text':'','line_number':121,'multiline':False]
['text':' Returns a pointer to the beginning of the region and store its','line_number':122,'multiline':False]
['text':' length in *len.','line_number':123,'multiline':False]
['text':'','line_number':124,'multiline':False]
['text':' The returned region is valid until the next call to Skip() or','line_number':125,'multiline':False]
['text':' until this object is destroyed, whichever occurs first.','line_number':126,'multiline':False]
['text':'','line_number':127,'multiline':False]
['text':' The returned region may be larger than Available() (for example','line_number':128,'multiline':False]
['text':' if this ByteSource is a view on a substring of a larger source).','line_number':129,'multiline':False]
['text':' The caller is responsible for ensuring that it only reads the','line_number':130,'multiline':False]
['text':' Available() bytes.','line_number':131,'multiline':False]
['text':' Skip the next n bytes.  Invalidates any buffer returned by','line_number':134,'multiline':False]
['text':' a previous call to Peek().','line_number':135,'multiline':False]
['text':' REQUIRES: Available() >= n','line_number':136,'multiline':False]
['text':' No copying','line_number':140,'multiline':False]
['text':' A Source implementation that yields the contents of a flat array','line_number':145,'multiline':False]
['text':' A Sink implementation that writes to a flat array without any bound checks.','line_number':158,'multiline':False]
['text':' Return the current output pointer so that a caller can see how','line_number':172,'multiline':False]
['text':' many bytes were produced.','line_number':173,'multiline':False]
['text':' Note: this is not a Sink method.','line_number':174,'multiline':False]
['text':' namespace snappy','line_number':180,'multiline':False]
['text':' THIRD_PARTY_SNAPPY_SNAPPY_SINKSOURCE_H_','line_number':182,'multiline':False]
