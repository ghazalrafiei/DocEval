['text':'','line_number':1,'multiline':False]
['text':' Copyright (c) 2001 - 2019 The SCons Foundation','line_number':2,'multiline':False]
['text':'','line_number':3,'multiline':False]
['text':' Permission is hereby granted, free of charge, to any person obtaining','line_number':4,'multiline':False]
['text':' a copy of this software and associated documentation files (the','line_number':5,'multiline':False]
['text':' "Software"), to deal in the Software without restriction, including','line_number':6,'multiline':False]
['text':' without limitation the rights to use, copy, modify, merge, publish,','line_number':7,'multiline':False]
['text':' distribute, sublicense, and/or sell copies of the Software, and to','line_number':8,'multiline':False]
['text':' permit persons to whom the Software is furnished to do so, subject to','line_number':9,'multiline':False]
['text':' the following conditions:','line_number':10,'multiline':False]
['text':'','line_number':11,'multiline':False]
['text':' The above copyright notice and this permission notice shall be included','line_number':12,'multiline':False]
['text':' in all copies or substantial portions of the Software.','line_number':13,'multiline':False]
['text':'','line_number':14,'multiline':False]
['text':' THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY','line_number':15,'multiline':False]
['text':' KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE','line_number':16,'multiline':False]
['text':' WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND','line_number':17,'multiline':False]
['text':' NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE','line_number':18,'multiline':False]
['text':' LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION','line_number':19,'multiline':False]
['text':' OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION','line_number':20,'multiline':False]
['text':' WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.','line_number':21,'multiline':False]
['text':'','line_number':22,'multiline':False]
['text':'','line_number':34,'multiline':False]
['text':' First "subsystem" of regular expressions that we set up:','line_number':35,'multiline':False]
['text':'','line_number':36,'multiline':False]
['text':' Stuff to turn the C preprocessor directives in a file's contents into','line_number':37,'multiline':False]
['text':' a list of tuples that we can process easily.','line_number':38,'multiline':False]
['text':'','line_number':39,'multiline':False]
['text':' A table of regular expressions that fetch the arguments from the rest of','line_number':41,'multiline':False]
['text':' a C preprocessor line.  Different directives have different arguments','line_number':42,'multiline':False]
['text':' that we want to fetch, using the regular expressions to which the lists','line_number':43,'multiline':False]
['text':' of preprocessor directives map.','line_number':44,'multiline':False]
['text':' Fetch the rest of a #if/#elif as one argument,','line_number':46,'multiline':False]
['text':' with white space optional.','line_number':47,'multiline':False]
['text':' Fetch the rest of a #ifdef/#ifndef as one argument,','line_number':50,'multiline':False]
['text':' separated from the keyword by white space.','line_number':51,'multiline':False]
['text':' Fetch the rest of a #import/#include/#include_next line as one','line_number':54,'multiline':False]
['text':' argument, with white space optional.','line_number':55,'multiline':False]
['text':' We don't care what comes after a #else or #endif line.','line_number':59,'multiline':False]
['text':' Fetch three arguments from a #define line:','line_number':62,'multiline':False]
['text':'   1) The #defined keyword.','line_number':63,'multiline':False]
['text':'   2) The optional parentheses and arguments (if it's a function-like','line_number':64,'multiline':False]
['text':'      macro, '' if it's not).','line_number':65,'multiline':False]
['text':'   3) The expansion value.','line_number':66,'multiline':False]
['text':' Fetch the #undefed keyword from a #undef line.','line_number':69,'multiline':False]
['text':' Create a table that maps each individual C preprocessor directive to','line_number':73,'multiline':False]
['text':' the corresponding compiled regular expression that fetches the arguments','line_number':74,'multiline':False]
['text':' we care about.','line_number':75,'multiline':False]
['text':' Create a list of the expressions we'll use to match all of the','line_number':85,'multiline':False]
['text':' preprocessor directives.  These are the same as the directives','line_number':86,'multiline':False]
['text':' themselves *except* that we must use a negative lookahead assertion','line_number':87,'multiline':False]
['text':' when matching "if" so it doesn't match the "if" in "ifdef" or "ifndef".','line_number':88,'multiline':False]
['text':' Turn the list of expressions into one big honkin' regular expression','line_number':95,'multiline':False]
['text':' that will match all the preprocessor lines at once.  This will return','line_number':96,'multiline':False]
['text':' a list of tuples, one for each preprocessor line.  The preprocessor','line_number':97,'multiline':False]
['text':' directive will be the first element in each tuple, and the rest of','line_number':98,'multiline':False]
['text':' the line will be the second element.','line_number':99,'multiline':False]
['text':' And last but not least, compile the expression.','line_number':102,'multiline':False]
['text':'','line_number':108,'multiline':False]
['text':' Second "subsystem" of regular expressions that we set up:','line_number':109,'multiline':False]
['text':'','line_number':110,'multiline':False]
['text':' Stuff to translate a C preprocessor expression (as found on a #if or','line_number':111,'multiline':False]
['text':' #elif line) into an equivalent Python expression that we can eval().','line_number':112,'multiline':False]
['text':'','line_number':113,'multiline':False]
['text':' A dictionary that maps the C representation of Boolean operators','line_number':115,'multiline':False]
['text':' to their Python equivalents.','line_number':116,'multiline':False]
['text':' We have to sort the keys by length so that longer expressions','line_number':129,'multiline':False]
['text':' come *before* shorter expressions--in particular, "!=" must','line_number':130,'multiline':False]
['text':' come before "!" in the alternation.  Without this, the Python','line_number':131,'multiline':False]
['text':' re module, as late as version 2.2.2, empirically matches the','line_number':132,'multiline':False]
['text':' "!" in "!=" first, instead of finding the longest match.','line_number':133,'multiline':False]
['text':' What's up with that?','line_number':134,'multiline':False]
['text':' Turn the list of keys into one regular expression that will allow us','line_number':137,'multiline':False]
['text':' to substitute all of the operators at once.','line_number':138,'multiline':False]
['text':' ...and compile the expression.','line_number':141,'multiline':False]
['text':' A separate list of expressions to be evaluated and substituted','line_number':144,'multiline':False]
['text':' sequentially, not all at once.','line_number':145,'multiline':False]
['text':' Replace the string representations of the regular expressions in the','line_number':155,'multiline':False]
['text':' list with compiled versions.','line_number':156,'multiline':False]
['text':' Wrap up all of the above into a handy function.','line_number':160,'multiline':False]
['text':' Create a dictionary that maps the macro arguments to the','line_number':203,'multiline':False]
['text':' corresponding values in this "call."  We'll use this when we','line_number':204,'multiline':False]
['text':' eval() the expansion so that arguments will get expanded to','line_number':205,'multiline':False]
['text':' the right values.','line_number':206,'multiline':False]
['text':' Find line continuations.','line_number':222,'multiline':False]
['text':' Search for a "function call" macro on an expansion.  Returns the','line_number':225,'multiline':False]
['text':' two-tuple of the "function" name itself, and a string containing the','line_number':226,'multiline':False]
['text':' arguments within the call parentheses.','line_number':227,'multiline':False]
['text':' Split a string containing comma-separated function call arguments into','line_number':230,'multiline':False]
['text':' the separate arguments.','line_number':231,'multiline':False]
['text':' Initialize our C preprocessor namespace for tracking the','line_number':250,'multiline':False]
['text':' values of #defined keywords.  We use this namespace to look','line_number':251,'multiline':False]
['text':' for keywords on #ifdef/#ifndef lines, and to eval() the','line_number':252,'multiline':False]
['text':' expressions on #if/#elif lines (after massaging them from C to','line_number':253,'multiline':False]
['text':' Python).','line_number':254,'multiline':False]
['text':' For efficiency, a dispatch table maps each C preprocessor','line_number':261,'multiline':False]
['text':' directive (#if, #define, etc.) to the method that should be','line_number':262,'multiline':False]
['text':' called when we see it.  We accomodate state changes (#if,','line_number':263,'multiline':False]
['text':' #ifdef, #ifndef) by pushing the current dispatch table on a','line_number':264,'multiline':False]
['text':' stack and changing what method gets called for each relevant','line_number':265,'multiline':False]
['text':' directive we might see next at this level (#else, #elif).','line_number':266,'multiline':False]
['text':' #endif will simply pop the stack.','line_number':267,'multiline':False]
['text':' Controlling methods.','line_number':275,'multiline':False]
['text':' Uncomment to see the list of tuples being processed (e.g.,','line_number':315,'multiline':False]
['text':' to validate the CPP lines are being translated correctly).','line_number':316,'multiline':False]
['text':'print(t)','line_number':317,'multiline':False]
['text':' Dispatch table stack manipulation methods.','line_number':321,'multiline':False]
['text':' Utility methods.','line_number':339,'multiline':False]
['text':' Start and stop processing include lines.','line_number':387,'multiline':False]
['text':' Default methods for handling all of the preprocessor directives.','line_number':420,'multiline':False]
['text':' (Note that what actually gets called for a given directive at any','line_number':421,'multiline':False]
['text':' point in time is really controlled by the dispatch_table.)','line_number':422,'multiline':False]
['text':' XXX finish this -- maybe borrow/share logic from do_include()...?','line_number':506,'multiline':False]
['text':'print("include_file =", include_file)','line_number':516,'multiline':False]
['text':' Date: Tue, 22 Nov 2005 20:26:09 -0500','line_number':524,'multiline':False]
['text':' From: Stefan Seefeld <seefeld@sympatico.ca>','line_number':525,'multiline':False]
['text':'','line_number':526,'multiline':False]
['text':' By the way, #include_next is not the same as #include. The difference','line_number':527,'multiline':False]
['text':' being that #include_next starts its search in the path following the','line_number':528,'multiline':False]
['text':' path that let to the including file. In other words, if your system','line_number':529,'multiline':False]
['text':' include paths are ['/foo', '/bar'], and you are looking at a header','line_number':530,'multiline':False]
['text':' '/foo/baz.h', it might issue an '#include_next <baz.h>' which would','line_number':531,'multiline':False]
['text':' correctly resolve to '/bar/baz.h' (if that exists), but *not* see','line_number':532,'multiline':False]
['text':' '/foo/baz.h' again. See http://www.delorie.com/gnu/docs/gcc/cpp_11.html','line_number':533,'multiline':False]
['text':' for more reasoning.','line_number':534,'multiline':False]
['text':'','line_number':535,'multiline':False]
['text':' I have no idea in what context 'import' might be used.','line_number':536,'multiline':False]
['text':' XXX is #include_next really the same as #include ?','line_number':538,'multiline':False]
['text':' Utility methods for handling resolution of include files.','line_number':541,'multiline':False]
['text':'print("s =", s)','line_number':555,'multiline':False]
['text':' Local Variables:','line_number':591,'multiline':False]
['text':' tab-width:4','line_number':592,'multiline':False]
['text':' indent-tabs-mode:nil','line_number':593,'multiline':False]
['text':' End:','line_number':594,'multiline':False]
['text':' vim: set expandtab tabstop=4 shiftwidth=4:','line_number':595,'multiline':False]
