['text':'
**********************************************************************
*   Copyright (C) 1999-2015, International Business Machines
*   Corporation and others.  All Rights Reserved.
**********************************************************************
*   Date        Name        Description
*   10/20/99    alan        Creation.
**********************************************************************
','line_number':1,'multiline':True]
['text':' Define UChar constants using hex for EBCDIC compatibility','line_number':30,'multiline':False]
['text':' Used #define to reduce private static exports and memory access time.','line_number':31,'multiline':False]
['text':'[','line_number':32,'multiline':True]
['text':']','line_number':33,'multiline':True]
['text':'-','line_number':34,'multiline':True]
['text':'^','line_number':35,'multiline':True]
['text':':','line_number':36,'multiline':True]
['text':'\','line_number':37,'multiline':True]
['text':'&','line_number':38,'multiline':True]
['text':'U','line_number':39,'multiline':True]
['text':'u','line_number':40,'multiline':True]
['text':'{','line_number':41,'multiline':True]
['text':'}','line_number':42,'multiline':True]
['text':'P','line_number':43,'multiline':True]
['text':'p','line_number':44,'multiline':True]
['text':'N','line_number':45,'multiline':True]
['text':'=','line_number':46,'multiline':True]
['text':' HIGH_VALUE > all valid values. 110000 for codepoints','line_number':48,'multiline':False]
['text':' LOW <= all valid values. ZERO for codepoints','line_number':51,'multiline':False]
['text':' initial storage. Must be >= 0','line_number':54,'multiline':False]
['text':' extra amount for growth. Must be >= 0','line_number':57,'multiline':False]
['text':'*
 * Modify the given UChar32 variable so that it is in range, by
 * pinning values < UNICODESET_LOW to UNICODESET_LOW, and
 * pinning values > UNICODESET_HIGH-1 to UNICODESET_HIGH-1.
 * It modifies its argument in-place and also returns it.
 ','line_number':66,'multiline':True]
['text':'----------------------------------------------------------------','line_number':81,'multiline':False]
['text':' Debugging','line_number':82,'multiline':False]
['text':'----------------------------------------------------------------','line_number':83,'multiline':False]
['text':' DO NOT DELETE THIS CODE.  This code is used to debug memory leaks.','line_number':85,'multiline':False]
['text':' To enable the debugging, define the symbol DEBUG_MEM in the line','line_number':86,'multiline':False]
['text':' below.  This will result in text being sent to stdout that looks','line_number':87,'multiline':False]
['text':' like this:','line_number':88,'multiline':False]
['text':'   DEBUG UnicodeSet: ct 0x00A39B20; 397 [\u0A81-\u0A83\u0A85-','line_number':89,'multiline':False]
['text':'   DEBUG UnicodeSet: dt 0x00A39B20; 396 [\u0A81-\u0A83\u0A85-','line_number':90,'multiline':False]
['text':' Each line lists a construction (ct) or destruction (dt) event, the','line_number':91,'multiline':False]
['text':' object address, the number of outstanding objects after the event,','line_number':92,'multiline':False]
['text':' and the pattern of the object in question.','line_number':93,'multiline':False]
['text':' #define DEBUG_MEM','line_number':95,'multiline':False]
['text':'----------------------------------------------------------------','line_number':124,'multiline':False]
['text':' UnicodeString in UVector support','line_number':125,'multiline':False]
['text':'----------------------------------------------------------------','line_number':126,'multiline':False]
['text':'----------------------------------------------------------------','line_number':138,'multiline':False]
['text':' Constructors &c','line_number':139,'multiline':False]
['text':'----------------------------------------------------------------','line_number':140,'multiline':False]
['text':'*
 * Constructs an empty set.
 ','line_number':142,'multiline':True]
['text':' If memory allocation failed, set to bogus state.','line_number':158,'multiline':False]
['text':'*
 * Constructs a set containing the given range. If <code>end >
 * start</code> then an empty set is created.
 *
 * @param start first character, inclusive, of range
 * @param end last character, inclusive, of range
 ','line_number':165,'multiline':True]
['text':' If memory allocation failed, set to bogus state.','line_number':186,'multiline':False]
['text':'*
 * Constructs a set that is identical to the given UnicodeSet.
 ','line_number':193,'multiline':True]
['text':' If memory allocation failed, set to bogus state.','line_number':212,'multiline':False]
['text':' Copy-construct as thawed.','line_number':219,'multiline':False]
['text':' asThawed ','line_number':220,'multiline':True]
['text':' *this = o except for bmpSet and stringSpan','line_number':235,'multiline':False]
['text':' Invalid strings.','line_number':240,'multiline':False]
['text':' If memory allocation failed, set to bogus state.','line_number':247,'multiline':False]
['text':'*
 * Destructs the set.
 ','line_number':254,'multiline':True]
['text':' first!','line_number':258,'multiline':False]
['text':'*
 * Assigns this object to be a copy of another.
 ','line_number':269,'multiline':True]
['text':' There is no way to report this error :-(','line_number':286,'multiline':False]
['text':' Check for memory allocation error.','line_number':294,'multiline':False]
['text':' Invalid strings.','line_number':301,'multiline':False]
['text':' Check for memory allocation error.','line_number':309,'multiline':False]
['text':'*
 * Returns a copy of this object.  All UnicodeMatcher objects have
 * to support cloning in order to allow classes using
 * UnicodeMatchers, such as Transliterator, to implement cloning.
 ','line_number':321,'multiline':True]
['text':'*
 * Compares the specified object with this set for equality.  Returns
 * <tt>true</tt> if the two sets
 * have the same size, and every member of the specified set is
 * contained in this set (or equivalently, every member of this set is
 * contained in the specified set).
 *
 * @param o set to be compared for equality with this set.
 * @return <tt>true</tt> if the specified set is equal to this set.
 ','line_number':334,'multiline':True]
['text':'*
 * Returns the hash code value for this set.
 *
 * @return the hash code value for this set.
 * @see Object#hashCode()
 ','line_number':353,'multiline':True]
['text':'----------------------------------------------------------------','line_number':368,'multiline':False]
['text':' Public API','line_number':369,'multiline':False]
['text':'----------------------------------------------------------------','line_number':370,'multiline':False]
['text':'*
 * Returns the number of elements in this set (its cardinality),
 * Note than the elements of a set may include both individual
 * codepoints and strings.
 *
 * @return the number of elements in this set (its cardinality).
 ','line_number':372,'multiline':True]
['text':'*
 * Returns <tt>true</tt> if this set contains no elements.
 *
 * @return <tt>true</tt> if this set contains no elements.
 ','line_number':388,'multiline':True]
['text':'*
 * Returns true if this set contains the given character.
 * @param c character to be checked for containment
 * @return true if the test condition is met
 ','line_number':397,'multiline':True]
['text':' Set i to the index of the start item greater than ch','line_number':403,'multiline':False]
['text':' We know we will terminate without length test!','line_number':404,'multiline':False]
['text':' LATER: for large sets, add binary search','line_number':405,'multiline':False]
['text':'int32_t i = -1;','line_number':406,'multiline':False]
['text':'for (;;) {','line_number':407,'multiline':False]
['text':'    if (c < list[++i]) break;','line_number':408,'multiline':False]
['text':'}','line_number':409,'multiline':False]
['text':' Don't need to check LOW bound','line_number':416,'multiline':False]
['text':' return true if odd','line_number':420,'multiline':False]
['text':'*
 * Returns the smallest value i such that c < list[i].  Caller
 * must ensure that c is a legal value or this method will enter
 * an infinite loop.  This method performs a binary search.
 * @param c a character in the range MIN_VALUE..MAX_VALUE
 * inclusive
 * @return the smallest integer i in the range 0..len-1,
 * inclusive, such that c < list[i]
 ','line_number':423,'multiline':True]
['text':' Examples:
                                       findCodePoint(c)
       set              list[]         c=0 1 3 4 7 8
       ===              ==============   ===========
       []               [110000]         0 0 0 0 0 0
       [\u0000-\u0003]  [0, 4, 110000]   1 1 1 2 2 2
       [\u0004-\u0007]  [4, 8, 110000]   0 0 0 1 1 2
       [:Any:]          [0, 110000]      1 1 1 1 1 1
     ','line_number':433,'multiline':True]
['text':' Return the smallest i such that c < list[i].  Assume','line_number':443,'multiline':False]
['text':' list[len - 1] == HIGH and that c is legal (0..HIGH-1).','line_number':444,'multiline':False]
['text':' High runner test.  c is often after the last range, so an','line_number':447,'multiline':False]
['text':' initial check for this condition pays off.','line_number':448,'multiline':False]
['text':' invariant: c >= list[lo]','line_number':453,'multiline':False]
['text':' invariant: c < list[hi]','line_number':454,'multiline':False]
['text':' Found!','line_number':458,'multiline':False]
['text':'*
 * Returns true if this set contains every character
 * of the given range.
 * @param start first character, inclusive, of the range
 * @param end last character, inclusive, of the range
 * @return true if the test condition is met
 ','line_number':468,'multiline':True]
['text':'int32_t i = -1;','line_number':476,'multiline':False]
['text':'for (;;) {','line_number':477,'multiline':False]
['text':'    if (start < list[++i]) break;','line_number':478,'multiline':False]
['text':'}','line_number':479,'multiline':False]
['text':'*
 * Returns <tt>true</tt> if this set contains the given
 * multicharacter string.
 * @param s string to be checked for containment
 * @return <tt>true</tt> if this set contains the specified string
 ','line_number':484,'multiline':True]
['text':'*
 * Returns true if this set contains all the characters and strings
 * of the given set.
 * @param c set to be checked for containment
 * @return true if the test condition is met
 ','line_number':500,'multiline':True]
['text':' The specified set is a subset if all of its pairs are contained in','line_number':507,'multiline':False]
['text':' this set.  It's possible to code this more efficiently in terms of','line_number':508,'multiline':False]
['text':' direct manipulation of the inversion lists if the need arises.','line_number':509,'multiline':False]
['text':'*
 * Returns true if this set contains all the characters
 * of the given string.
 * @param s string containing characters to be checked for containment
 * @return true if the test condition is met
 ','line_number':520,'multiline':True]
['text':'*
 * Returns true if this set contains none of the characters
 * of the given range.
 * @param start first character, inclusive, of the range
 * @param end last character, inclusive, of the range
 * @return true if the test condition is met
 ','line_number':531,'multiline':True]
['text':'int32_t i = -1;','line_number':539,'multiline':False]
['text':'for (;;) {','line_number':540,'multiline':False]
['text':'    if (start < list[++i]) break;','line_number':541,'multiline':False]
['text':'}','line_number':542,'multiline':False]
['text':'*
 * Returns true if this set contains none of the characters and strings
 * of the given set.
 * @param c set to be checked for containment
 * @return true if the test condition is met
 ','line_number':547,'multiline':True]
['text':' The specified set is a subset if all of its pairs are contained in','line_number':554,'multiline':False]
['text':' this set.  It's possible to code this more efficiently in terms of','line_number':555,'multiline':False]
['text':' direct manipulation of the inversion lists if the need arises.','line_number':556,'multiline':False]
['text':'*
 * Returns true if this set contains none of the characters
 * of the given string.
 * @param s string containing characters to be checked for containment
 * @return true if the test condition is met
 ','line_number':567,'multiline':True]
['text':'*
 * Returns <tt>true</tt> if this set contains any character whose low byte
 * is the given value.  This is used by <tt>RuleBasedTransliterator</tt> for
 * indexing.
 ','line_number':578,'multiline':True]
['text':' The index value v, in the range [0,255], is contained in this set if
     * it is contained in any pair of this set.  Pairs either have the high
     * bytes equal, or unequal.  If the high bytes are equal, then we have
     * aaxx..aayy, where aa is the high byte.  Then v is contained if xx <=
     * v <= yy.  If the high bytes are unequal we have aaxx..bbyy, bb>aa.
     * Then v is contained if xx <= v || v <= yy.  (This is identical to the
     * time zone month containment logic.)
     ','line_number':584,'multiline':True]
['text':'if (s.length() == 0) {','line_number':608,'multiline':False]
['text':'    // Empty strings match everything','line_number':609,'multiline':False]
['text':'    return TRUE;','line_number':610,'multiline':False]
['text':'}','line_number':611,'multiline':False]
['text':' assert(s.length() != 0); // We enforce this elsewhere','line_number':612,'multiline':False]
['text':'*
 * Implementation of UnicodeMatcher::matches().  Always matches the
 * longest possible multichar string.
 ','line_number':622,'multiline':True]
['text':' Strings, if any, have length != 0, so we don't worry','line_number':631,'multiline':False]
['text':' about them here.  If we ever allow zero-length strings','line_number':632,'multiline':False]
['text':' we much check for them here.','line_number':633,'multiline':False]
['text':' try strings first','line_number':640,'multiline':False]
['text':' might separate forward and backward loops later','line_number':642,'multiline':False]
['text':' for now they are combined','line_number':643,'multiline':False]
['text':' TODO Improve efficiency of this, at least in the forward','line_number':645,'multiline':False]
['text':' direction, if not in both.  In the forward direction we','line_number':646,'multiline':False]
['text':' can assume the strings are sorted.','line_number':647,'multiline':False]
['text':' firstChar is the leftmost char to match in the','line_number':652,'multiline':False]
['text':' forward direction or the rightmost char to match in','line_number':653,'multiline':False]
['text':' the reverse direction.','line_number':654,'multiline':False]
['text':' If there are multiple strings that can match we','line_number':657,'multiline':False]
['text':' return the longest match.','line_number':658,'multiline':False]
['text':'if (trial.length() == 0) {','line_number':664,'multiline':False]
['text':'    return U_MATCH; // null-string always matches','line_number':665,'multiline':False]
['text':'}','line_number':666,'multiline':False]
['text':' assert(trial.length() != 0); // We ensure this elsewhere','line_number':667,'multiline':False]
['text':' Strings are sorted, so we can optimize in the','line_number':671,'multiline':False]
['text':' forward direction.','line_number':672,'multiline':False]
['text':' We have successfully matched but only up to limit.','line_number':681,'multiline':False]
['text':' We have successfully matched the whole string.','line_number':687,'multiline':False]
['text':' In the forward direction we know strings','line_number':691,'multiline':False]
['text':' are sorted so we can bail early.','line_number':692,'multiline':False]
['text':' We've checked all strings without a partial match.','line_number':700,'multiline':False]
['text':' If we have full matches, return the longest one.','line_number':701,'multiline':False]
['text':'*
 * Returns the longest match for s in text at the given position.
 * If limit > start then match forward from start+1 to limit
 * matching all characters except s.charAt(0).  If limit < start,
 * go backward starting from start-1 matching all characters
 * except s.charAt(s.length()-1).  This method assumes that the
 * first character, text.charAt(start), matches s, so it does not
 * check it.
 * @param text the text to match
 * @param start the first character to match.  In the forward
 * direction, text.charAt(start) is matched against s.charAt(0).
 * In the reverse direction, it is matched against
 * s.charAt(s.length()-1).
 * @param limit the limit offset for matching, either last+1 in
 * the forward direction, or last-1 in the reverse direction,
 * where last is the index of the last character to match.
 * @return If part of s matches up to the limit, return |limit -
 * start|.  If all of s matches before reaching the limit, return
 * s.length().  If there is a mismatch between s and text, return
 * 0
 ','line_number':711,'multiline':True]
['text':' <=> slen = s.length() - 1;','line_number':747,'multiline':False]
['text':'*
 * Implement of UnicodeMatcher
 ','line_number':755,'multiline':True]
['text':'*
 * Returns the index of the given character within this set, where
 * the set is ordered by ascending code point.  If the character
 * is not in this set, return -1.  The inverse of this method is
 * <code>charAt()</code>.
 * @return an index from 0..size()-1, or -1
 ','line_number':762,'multiline':True]
['text':'*
 * Returns the character at the given index within this set, where
 * the set is ordered by ascending code point.  If the index is
 * out of range, return (UChar32)-1.  The inverse of this method is
 * <code>indexOf()</code>.
 * @param index an index from 0..size()-1
 * @return the character at the given index, or (UChar32)-1.
 ','line_number':788,'multiline':True]
['text':' len2 is the largest even integer <= len, that is, it is len','line_number':798,'multiline':False]
['text':' for even values and len-1 for odd values.  With odd values','line_number':799,'multiline':False]
['text':' the last entry is UNICODESET_HIGH.','line_number':800,'multiline':False]
['text':'*
 * Make this object represent the range <code>start - end</code>.
 * If <code>end > start</code> then this object is set to an
 * an empty range.
 *
 * @param start first character in the set, inclusive
 * @rparam end last character in the set, inclusive
 ','line_number':814,'multiline':True]
['text':'*
 * Adds the specified range to this set if it is not already
 * present.  If this set already contains the specified range,
 * the call leaves this set unchanged.  If <code>end > start</code>
 * then an empty range is added, leaving the set unchanged.
 *
 * @param start first character, inclusive, of range to be added
 * to this set.
 * @param end last character, inclusive, of range to be added
 * to this set.
 ','line_number':828,'multiline':True]
['text':' #define DEBUG_US_ADD','line_number':849,'multiline':False]
['text':'*
 * Adds the specified character to this set if it is not already
 * present.  If this set already contains the specified character,
 * the call leaves this set unchanged.
 ','line_number':870,'multiline':True]
['text':' find smallest i such that c < list[i]','line_number':876,'multiline':False]
['text':' if odd, then it is IN the set','line_number':877,'multiline':False]
['text':' if even, then it is OUT of the set','line_number':878,'multiline':False]
['text':' already in set?','line_number':881,'multiline':False]
['text':' HIGH is 0x110000','line_number':884,'multiline':False]
['text':' assert(list[len-1] == HIGH);','line_number':885,'multiline':False]
['text':' empty = [HIGH]','line_number':887,'multiline':False]
['text':' [start_0, limit_0, start_1, limit_1, HIGH]','line_number':888,'multiline':False]
['text':' [..., start_k-1, limit_k-1, start_k, limit_k, ..., HIGH]','line_number':890,'multiline':False]
['text':'                             ^','line_number':891,'multiline':False]
['text':'                             list[i]','line_number':892,'multiline':False]
['text':' i == 0 means c is before the first range','line_number':894,'multiline':False]
['text':' c is before start of next range','line_number':906,'multiline':False]
['text':' if we touched the HIGH mark, then add a new one','line_number':908,'multiline':False]
['text':' There is no way to report this error :-(','line_number':913,'multiline':False]
['text':' collapse adjacent ranges','line_number':918,'multiline':False]
['text':' [..., start_k-1, c, c, limit_k, ..., HIGH]','line_number':920,'multiline':False]
['text':'                     ^','line_number':921,'multiline':False]
['text':'                     list[i]','line_number':922,'multiline':False]
['text':'for (int32_t k=i-1; k<len-2; ++k) {','line_number':924,'multiline':False]
['text':'    list[k] = list[k+2];','line_number':925,'multiline':False]
['text':'}','line_number':926,'multiline':False]
['text':' c is after end of prior range','line_number':937,'multiline':False]
['text':' no need to check for collapse here','line_number':939,'multiline':False]
['text':' At this point we know the new char is not adjacent to','line_number':943,'multiline':False]
['text':' any existing ranges, and it is not 10FFFF.','line_number':944,'multiline':False]
['text':' [..., start_k-1, limit_k-1, start_k, limit_k, ..., HIGH]','line_number':947,'multiline':False]
['text':'                             ^','line_number':948,'multiline':False]
['text':'                             list[i]','line_number':949,'multiline':False]
['text':' [..., start_k-1, limit_k-1, c, c+1, start_k, limit_k, ..., HIGH]','line_number':951,'multiline':False]
['text':'                             ^','line_number':952,'multiline':False]
['text':'                             list[i]','line_number':953,'multiline':False]
['text':' There is no way to report this error :-(','line_number':958,'multiline':False]
['text':'for (int32_t k=len-1; k>=i; --k) {','line_number':961,'multiline':False]
['text':'    list[k+2] = list[k];','line_number':962,'multiline':False]
['text':'}','line_number':963,'multiline':False]
['text':' Corrupt array!','line_number':980,'multiline':False]
['text':'*
 * Adds the specified multicharacter to this set if it is not already
 * present.  If this set already contains the multicharacter,
 * the call leaves this set unchanged.
 * Thus "ch" => {"ch"}
 * <br><b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
 * @param s the source string
 * @return the modified set, for chaining
 ','line_number':991,'multiline':True]
['text':'*
 * Adds the given string, in order, to 'strings'.  The given string
 * must have been checked by the caller to not be empty and to not
 * already be in 'strings'.
 ','line_number':1014,'multiline':True]
['text':' Check for memory allocation error.','line_number':1024,'multiline':False]
['text':'*
 * @return a code point IF the string consists of a single one.
 * otherwise returns -1.
 * @param string to test
 ','line_number':1036,'multiline':True]
['text':'if (s.length() < 1) {','line_number':1042,'multiline':False]
['text':'    throw new IllegalArgumentException("Can't use zero-length strings in UnicodeSet");','line_number':1043,'multiline':False]
['text':'}','line_number':1044,'multiline':False]
['text':' at this point, len = 2','line_number':1048,'multiline':False]
['text':' is surrogate pair','line_number':1050,'multiline':False]
['text':'*
 * Adds each of the characters in this string to the set. Thus "ch" => {"c", "h"}
 * If this set already any particular character, it has no effect on that character.
 * @param the source string
 * @return the modified set, for chaining
 ','line_number':1056,'multiline':True]
['text':'*
 * Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
 * If this set already any particular character, it has no effect on that character.
 * @param the source string
 * @return the modified set, for chaining
 ','line_number':1071,'multiline':True]
['text':'*
 * Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
 * If this set already any particular character, it has no effect on that character.
 * @param the source string
 * @return the modified set, for chaining
 ','line_number':1084,'multiline':True]
['text':'*
 * Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
 * If this set already any particular character, it has no effect on that character.
 * @param the source string
 * @return the modified set, for chaining
 ','line_number':1097,'multiline':True]
['text':'*
 * Makes a set from a multicharacter string. Thus "ch" => {"ch"}
 * <br><b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
 * @param the source string
 * @return a newly created set containing the given string
 ','line_number':1116,'multiline':True]
['text':' Check for memory allocation error.','line_number':1124,'multiline':False]
['text':'*
 * Makes a set from each of the characters in the string. Thus "ch" => {"c", "h"}
 * @param the source string
 * @return a newly created set containing the given characters
 ','line_number':1131,'multiline':True]
['text':' Check for memory allocation error.','line_number':1138,'multiline':False]
['text':'*
 * Retain only the elements in this set that are contained in the
 * specified range.  If <code>end > start</code> then an empty range is
 * retained, leaving the set empty.
 *
 * @param start first character, inclusive, of range to be retained
 * to this set.
 * @param end last character, inclusive, of range to be retained
 * to this set.
 ','line_number':1144,'multiline':True]
['text':'*
 * Removes the specified range from this set if it is present.
 * The set will not contain the specified range once the call
 * returns.  If <code>end > start</code> then an empty range is
 * removed, leaving the set unchanged.
 *
 * @param start first character, inclusive, of range to be removed
 * from this set.
 * @param end last character, inclusive, of range to be removed
 * from this set.
 ','line_number':1168,'multiline':True]
['text':'*
 * Removes the specified character from this set if it is present.
 * The set will not contain the specified range once the call
 * returns.
 ','line_number':1187,'multiline':True]
['text':'*
 * Removes the specified string from this set if it is present.
 * The set will not contain the specified character once the call
 * returns.
 * @param the source string
 * @return the modified set, for chaining
 ','line_number':1196,'multiline':True]
['text':'*
 * Complements the specified range in this set.  Any character in
 * the range will be removed if it is in this set, or will be
 * added if it is not in this set.  If <code>end > start</code>
 * then an empty range is xor'ed, leaving the set unchanged.
 *
 * @param start first character, inclusive, of range to be removed
 * from this set.
 * @param end last character, inclusive, of range to be removed
 * from this set.
 ','line_number':1215,'multiline':True]
['text':'*
 * This is equivalent to
 * <code>complement(MIN_VALUE, MAX_VALUE)</code>.
 ','line_number':1242,'multiline':True]
['text':'*
 * Complement the specified string in this set.
 * The set will not contain the specified string once the call
 * returns.
 * <br><b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
 * @param s the string to complement
 * @return this object, for chaining
 ','line_number':1272,'multiline':True]
['text':'*
 * Adds all of the elements in the specified set to this set if
 * they're not already present.  This operation effectively
 * modifies this set so that its value is the <i>union</i> of the two
 * sets.  The behavior of this operation is unspecified if the specified
 * collection is modified while the operation is in progress.
 *
 * @param c set whose elements are to be added to this set.
 * @see #add(char, char)
 ','line_number':1296,'multiline':True]
['text':' Add strings in order','line_number':1311,'multiline':False]
['text':'*
 * Retains only the elements in this set that are contained in the
 * specified set.  In other words, removes from this set all of
 * its elements that are not contained in the specified set.  This
 * operation effectively modifies this set so that its value is
 * the <i>intersection</i> of the two sets.
 *
 * @param c set that defines which elements this set will retain.
 ','line_number':1323,'multiline':True]
['text':'*
 * Removes from this set all of its elements that are contained in the
 * specified set.  This operation effectively modifies this
 * set so that its value is the <i>asymmetric set difference</i> of
 * the two sets.
 *
 * @param c set that defines which elements will be removed from
 *          this set.
 ','line_number':1341,'multiline':True]
['text':'*
 * Complements in this set all elements contained in the specified
 * set.  Any character in the other set will be removed if it is
 * in this set, or will be added if it is not in this set.
 *
 * @param c set that defines which elements will be xor'ed from
 *          this set.
 ','line_number':1359,'multiline':True]
['text':'*
 * Removes all of the elements from this set.  This set will be
 * empty after this call returns.
 ','line_number':1382,'multiline':True]
['text':' Remove bogus','line_number':1399,'multiline':False]
['text':'*
 * Iteration method that returns the number of ranges contained in
 * this set.
 * @see #getRangeStart
 * @see #getRangeEnd
 ','line_number':1405,'multiline':True]
['text':'*
 * Iteration method that returns the first character in the
 * specified range of this set.
 * @see #getRangeCount
 * @see #getRangeEnd
 ','line_number':1415,'multiline':True]
['text':'*
 * Iteration method that returns the last character in the
 * specified range of this set.
 * @see #getRangeStart
 * @see #getRangeEnd
 ','line_number':1425,'multiline':True]
['text':'*
 * Reallocate this objects internal structures to take up the least
 * possible space, without changing this object's value.
 ','line_number':1443,'multiline':True]
['text':' Delete buffer first to defragment memory less.','line_number':1451,'multiline':False]
['text':' Make the capacity equal to len or 1.','line_number':1457,'multiline':False]
['text':' We don't want to realloc of 0 size.','line_number':1458,'multiline':False]
['text':' else what the heck happened?! We allocated less memory!','line_number':1465,'multiline':False]
['text':' Oh well. We'll keep our original array.','line_number':1466,'multiline':False]
['text':'*
 * Deserialize constructor.
 ','line_number':1475,'multiline':True]
['text':' bmp?','line_number':1502,'multiline':False]
['text':' copy bmp','line_number':1516,'multiline':False]
['text':' copy smp','line_number':1524,'multiline':False]
['text':' terminator','line_number':1532,'multiline':False]
['text':' count necessary 16-bit units ','line_number':1549,'multiline':True]
['text':' Subtract 1 to ignore final UNICODESET_HIGH','line_number':1550,'multiline':False]
['text':' assert(length>=0);','line_number':1551,'multiline':False]
['text':' empty set ','line_number':1553,'multiline':True]
['text':' now length>0 ','line_number':1561,'multiline':True]
['text':' all BMP ','line_number':1564,'multiline':True]
['text':' all supplementary ','line_number':1567,'multiline':True]
['text':' some BMP, some supplementary ','line_number':1571,'multiline':True]
['text':' length: number of 16-bit array units ','line_number':1578,'multiline':True]
['text':' there are only 15 bits for the length in the first serialized word ','line_number':1580,'multiline':True]
['text':'
     * total serialized length:
     * number of 16-bit array units (length) +
     * 1 length unit (always) +
     * 1 bmpLength unit (if there are supplementary values)
     ','line_number':1585,'multiline':True]
['text':' write the BMP part of the array ','line_number':1606,'multiline':True]
['text':' write the supplementary part of the array ','line_number':1615,'multiline':True]
['text':'----------------------------------------------------------------','line_number':1629,'multiline':False]
['text':' Implementation: Utility methods','line_number':1630,'multiline':False]
['text':'----------------------------------------------------------------','line_number':1631,'multiline':False]
['text':'*
 * Allocate our strings vector and return TRUE if successful.
 ','line_number':1633,'multiline':True]
['text':' Check for memory allocation error.','line_number':1642,'multiline':False]
['text':' else we keep the original contents on the memory failure.','line_number':1665,'multiline':False]
['text':' else we keep the original contents on the memory failure.','line_number':1679,'multiline':False]
['text':'*
 * Swap list and buffer.
 ','line_number':1682,'multiline':True]
['text':' swap list and buffer','line_number':1686,'multiline':False]
['text':' Remove everything in the set.','line_number':1697,'multiline':False]
['text':'----------------------------------------------------------------','line_number':1701,'multiline':False]
['text':' Implementation: Fundamental operators','line_number':1702,'multiline':False]
['text':'----------------------------------------------------------------','line_number':1703,'multiline':False]
['text':' polarity = 0, 3 is normal: x xor y','line_number':1709,'multiline':False]
['text':' polarity = 1, 2: x xor ~y == x === y','line_number':1710,'multiline':False]
['text':' skip base if already LOW','line_number':1727,'multiline':False]
['text':' simplest of all the routines','line_number':1734,'multiline':False]
['text':' sort the values, discarding identicals!','line_number':1735,'multiline':False]
['text':' at this point, a == b','line_number':1743,'multiline':False]
['text':' discard both values!','line_number':1744,'multiline':False]
['text':' DONE!','line_number':1747,'multiline':False]
['text':' polarity = 0 is normal: x union y','line_number':1757,'multiline':False]
['text':' polarity = 2: x union ~y','line_number':1758,'multiline':False]
['text':' polarity = 1: ~x union y','line_number':1759,'multiline':False]
['text':' polarity = 3: ~x union ~y','line_number':1760,'multiline':False]
['text':' change from xor is that we have to check overlapping pairs','line_number':1775,'multiline':False]
['text':' polarity bit 1 means a is second, bit 2 means b is.','line_number':1776,'multiline':False]
['text':' both first; take lower if unequal','line_number':1779,'multiline':False]
['text':' take a','line_number':1780,'multiline':False]
['text':' Back up over overlapping ranges in buffer[]','line_number':1781,'multiline':False]
['text':' Pick latter end value in buffer[] vs. list[]','line_number':1783,'multiline':False]
['text':' No overlap','line_number':1786,'multiline':False]
['text':' Common if/else code factored out','line_number':1790,'multiline':False]
['text':' take b','line_number':1792,'multiline':False]
['text':' a == b, take a, drop b','line_number':1801,'multiline':False]
['text':' This is symmetrical; it doesn't matter if','line_number':1803,'multiline':False]
['text':' we backtrack with a or b. - liu','line_number':1804,'multiline':False]
['text':' No overlap','line_number':1808,'multiline':False]
['text':' both second; take higher if unequal, and drop other','line_number':1818,'multiline':False]
['text':' take a','line_number':1819,'multiline':False]
['text':' take b','line_number':1822,'multiline':False]
['text':' factored common code','line_number':1827,'multiline':False]
['text':' a second, b first; if b < a, overlap','line_number':1831,'multiline':False]
['text':' no overlap, take a','line_number':1832,'multiline':False]
['text':' OVERLAP, drop b','line_number':1834,'multiline':False]
['text':' a == b, drop both!','line_number':1837,'multiline':False]
['text':' a first, b second; if a < b, overlap','line_number':1845,'multiline':False]
['text':' no overlap, take b','line_number':1846,'multiline':False]
['text':' OVERLAP, drop a','line_number':1850,'multiline':False]
['text':' a == b, drop both!','line_number':1853,'multiline':False]
['text':' terminate','line_number':1864,'multiline':False]
['text':' polarity = 0 is normal: x intersect y','line_number':1870,'multiline':False]
['text':' polarity = 2: x intersect ~y == set-minus','line_number':1871,'multiline':False]
['text':' polarity = 1: ~x intersect y','line_number':1872,'multiline':False]
['text':' polarity = 3: ~x intersect ~y','line_number':1873,'multiline':False]
['text':' change from xor is that we have to check overlapping pairs','line_number':1888,'multiline':False]
['text':' polarity bit 1 means a is second, bit 2 means b is.','line_number':1889,'multiline':False]
['text':' both first; drop the smaller','line_number':1892,'multiline':False]
['text':' drop a','line_number':1893,'multiline':False]
['text':' drop b','line_number':1896,'multiline':False]
['text':' a == b, take one, drop other','line_number':1899,'multiline':False]
['text':' both second; take lower if unequal','line_number':1908,'multiline':False]
['text':' take a','line_number':1909,'multiline':False]
['text':' take b','line_number':1913,'multiline':False]
['text':' a == b, take one, drop other','line_number':1917,'multiline':False]
['text':' a second, b first;','line_number':1926,'multiline':False]
['text':' NO OVERLAP, drop a','line_number':1927,'multiline':False]
['text':' OVERLAP, take b','line_number':1930,'multiline':False]
['text':' a == b, drop both!','line_number':1934,'multiline':False]
['text':' a first, b second; if a < b, overlap','line_number':1942,'multiline':False]
['text':' no overlap, drop b','line_number':1943,'multiline':False]
['text':' OVERLAP, take a','line_number':1946,'multiline':False]
['text':' a == b, drop both!','line_number':1950,'multiline':False]
['text':' terminate','line_number':1961,'multiline':False]
['text':'*
 * Append the <code>toPattern()</code> representation of a
 * string to the given <code>StringBuffer</code>.
 ','line_number':1967,'multiline':True]
['text':'*
 * Append the <code>toPattern()</code> representation of a
 * character to the given <code>StringBuffer</code>.
 ','line_number':1979,'multiline':True]
['text':' Use hex escape notation (\uxxxx or \Uxxxxxxxx) for anything','line_number':1986,'multiline':False]
['text':' unprintable','line_number':1987,'multiline':False]
['text':' Okay to let ':' pass through','line_number':1992,'multiline':False]
['text':' Escape whitespace','line_number':2007,'multiline':False]
['text':'*
 * Append a string representation of this set to result.  This will be
 * a cleaned version of the string passed to applyPattern(), if there
 * is one.  Otherwise it will be generated.
 ','line_number':2016,'multiline':True]
['text':' If the unprintable character is preceded by an odd','line_number':2031,'multiline':False]
['text':' number of backslashes, then it has been escaped.','line_number':2032,'multiline':False]
['text':' Before unescaping it, we delete the final','line_number':2033,'multiline':False]
['text':' backslash.','line_number':2034,'multiline':False]
['text':'*
 * Returns a string representation of this set.  If the result of
 * calling this function is passed to a UnicodeSet constructor, it
 * will produce another set that is equal to this one.
 ','line_number':2055,'multiline':True]
['text':'*
 * Generate and append a string representation of this set to result.
 * This does not use this.pat, the cleaned up copy of the string
 * passed to applyPattern().
 ','line_number':2067,'multiline':True]
['text':'  // Check against the predefined categories.  We implicitly build','line_number':2077,'multiline':False]
['text':'  // up ALL category sets the first time toPattern() is called.','line_number':2078,'multiline':False]
['text':'  for (int8_t cat=0; cat<Unicode::GENERAL_TYPES_COUNT; ++cat) {','line_number':2079,'multiline':False]
['text':'      if (*this == getCategorySet(cat)) {','line_number':2080,'multiline':False]
['text':'          result.append(COLON);','line_number':2081,'multiline':False]
['text':'          result.append(CATEGORY_NAMES, cat*2, 2);','line_number':2082,'multiline':False]
['text':'          return result.append(CATEGORY_CLOSE);','line_number':2083,'multiline':False]
['text':'      }','line_number':2084,'multiline':False]
['text':'  }','line_number':2085,'multiline':False]
['text':' If the set contains at least 2 intervals and includes both','line_number':2089,'multiline':False]
['text':' MIN_VALUE and MAX_VALUE, then the inverse representation will','line_number':2090,'multiline':False]
['text':' be more economical.','line_number':2091,'multiline':False]
['text':' Emit the inverse','line_number':2096,'multiline':False]
['text':' Default; emit the ranges as pairs','line_number':2112,'multiline':False]
['text':'*
* Release existing cached pattern
','line_number':2137,'multiline':True]
['text':'*
* Set the new pattern to cache.
','line_number':2148,'multiline':True]
['text':' else we don't care if malloc failed. This was just a nice cache.','line_number':2160,'multiline':False]
['text':' We can regenerate an equivalent pattern later when requested.','line_number':2161,'multiline':False]
['text':' Do most of what compact() does before freezing because','line_number':2166,'multiline':False]
['text':' compact() will not work when the set is frozen.','line_number':2167,'multiline':False]
['text':' Small modification: Don't shrink if the savings would be tiny (<=GROW_EXTRA).','line_number':2168,'multiline':False]
['text':' Delete buffer first to defragment memory less.','line_number':2170,'multiline':False]
['text':' Make the capacity equal to len or 1.','line_number':2176,'multiline':False]
['text':' We don't want to realloc of 0 size.','line_number':2177,'multiline':False]
['text':' Check for memory allocation error.','line_number':2180,'multiline':False]
['text':' Optimize contains() and span() and similar functions.','line_number':2186,'multiline':False]
['text':' All strings are irrelevant for span() etc. because','line_number':2190,'multiline':False]
['text':' all of each string's code points are contained in this set.','line_number':2191,'multiline':False]
['text':' Do not check needsStringSpanUTF8() because UTF-8 has at most as','line_number':2192,'multiline':False]
['text':' many relevant strings as UTF-16.','line_number':2193,'multiline':False]
['text':' (Thus needsStringSpanUTF8() implies needsStringSpanUTF16().)','line_number':2194,'multiline':False]
['text':' No span-relevant strings: Optimize for code point spans.','line_number':2200,'multiline':False]
['text':' Check for memory allocation error.','line_number':2202,'multiline':False]
['text':' Pin to 0/1 values.','line_number':2233,'multiline':False]
['text':' Pin to 0/1 values.','line_number':2270,'multiline':False]
['text':' Pin to 0/1 values.','line_number':2308,'multiline':False]
['text':' Pin to 0/1 values.','line_number':2346,'multiline':False]
