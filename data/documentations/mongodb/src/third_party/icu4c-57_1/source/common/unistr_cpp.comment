['text':'
******************************************************************************
* Copyright (C) 1999-2016, International Business Machines Corporation and
* others. All Rights Reserved.
******************************************************************************
*
* File unistr.cpp
*
* Modification History:
*
*   Date        Name        Description
*   09/25/98    stephen     Creation.
*   04/20/99    stephen     Overhauled per 4/16 code review.
*   07/09/99    stephen     Renamed {hi,lo},{byte,word} to icu_X for HP/UX
*   11/18/99    aliu        Added handleReplaceBetween() to make inherit from
*                           Replaceable.
*   06/25/01    grhoten     Removed the dependency on iostream
******************************************************************************
','line_number':1,'multiline':True]
['text':'DEBUGGING','line_number':40,'multiline':False]
['text':' END DEBUGGING','line_number':73,'multiline':False]
['text':' Local function definitions for now','line_number':76,'multiline':False]
['text':' need to copy areas that may overlap','line_number':78,'multiline':False]
['text':' u_unescapeAt() callback to get a UChar from a UnicodeString','line_number':89,'multiline':False]
['text':' The Replaceable virtual destructor can't be defined in the header
   due to how AIX works with multiple definitions of virtual functions.
','line_number':99,'multiline':True]
['text':'========================================','line_number':114,'multiline':False]
['text':' Reference Counting functions, put at top of file so that optimizing compilers','line_number':115,'multiline':False]
['text':'                               have a chance to automatically inline.','line_number':116,'multiline':False]
['text':'========================================','line_number':117,'multiline':False]
['text':'========================================','line_number':143,'multiline':False]
['text':' Constructors','line_number':144,'multiline':False]
['text':'========================================','line_number':145,'multiline':False]
['text':' The default constructor is inline in unistr.h.','line_number':147,'multiline':False]
['text':' just allocate and do not do anything else','line_number':152,'multiline':False]
['text':' count > 0, allocate and fill the new string with count c's','line_number':155,'multiline':False]
['text':' fill the new string with c','line_number':164,'multiline':False]
['text':' fill with length UChars','line_number':166,'multiline':False]
['text':' get the code units for c','line_number':171,'multiline':False]
['text':' now it must be i==unitCount','line_number':175,'multiline':False]
['text':' for Unicode, unitCount can only be 1, 2, 3, or 4','line_number':178,'multiline':False]
['text':' 1 is handled above','line_number':179,'multiline':False]
['text':' We test isError so that the compiler does not complain that we don't.','line_number':202,'multiline':False]
['text':' If isError then i==0 which is what we want anyway.','line_number':203,'multiline':False]
['text':' treat as an empty string, do not alias','line_number':225,'multiline':False]
['text':' text is terminated, or else it would have failed the above test','line_number':234,'multiline':False]
['text':' treat as an empty string, do not alias','line_number':246,'multiline':False]
['text':' fLength = u_strlen(buff); but do not look beyond buffCapacity','line_number':252,'multiline':False]
['text':' treat as an empty string','line_number':266,'multiline':False]
['text':' if there's nothing to convert, do nothing','line_number':291,'multiline':False]
['text':' else see unistr_cnv.cpp','line_number':301,'multiline':False]
['text':' Replaceable base class clone() default implementation, does not clone','line_number':329,'multiline':False]
['text':' UnicodeString overrides clone() with a real implementation','line_number':335,'multiline':False]
['text':'========================================','line_number':341,'multiline':False]
['text':' array allocation','line_number':342,'multiline':False]
['text':'========================================','line_number':343,'multiline':False]
['text':' count bytes for the refCounter and the string capacity, and','line_number':350,'multiline':False]
['text':' round up to a multiple of 16; then divide by 4 and allocate int32_t's','line_number':351,'multiline':False]
['text':' to be safely aligned for the refCount','line_number':352,'multiline':False]
['text':' the +1 is for the NUL terminator, to avoid reallocation in getTerminatedBuffer()','line_number':353,'multiline':False]
['text':' set initial refCount and point behind the refCount','line_number':357,'multiline':False]
['text':' have fArray point to the first UChar','line_number':360,'multiline':False]
['text':'========================================','line_number':374,'multiline':False]
['text':' Destructor','line_number':375,'multiline':False]
['text':'========================================','line_number':376,'multiline':False]
['text':' UnicodeString::kMaxShortLength+1','line_number':379,'multiline':False]
['text':' Count lengths of strings at the end of their lifetime.','line_number':398,'multiline':False]
['text':' Useful for discussion of a desirable stack buffer size.','line_number':399,'multiline':False]
['text':' Count the contents length, not the optional NUL terminator nor further capacity.','line_number':400,'multiline':False]
['text':' Ignore open-buffer strings and strings which alias external storage.','line_number':401,'multiline':False]
['text':'========================================','line_number':414,'multiline':False]
['text':' Factory methods','line_number':415,'multiline':False]
['text':'========================================','line_number':416,'multiline':False]
['text':' Most UTF-32 strings will be BMP-only and result in a same-length','line_number':427,'multiline':False]
['text':' UTF-16 string. We overestimate the capacity just slightly,','line_number':428,'multiline':False]
['text':' just in case there are a few supplementary characters.','line_number':429,'multiline':False]
['text':' Substitution character.','line_number':441,'multiline':False]
['text':' Don't care about number of substitutions.','line_number':442,'multiline':False]
['text':' +1 for the terminating NUL.','line_number':446,'multiline':False]
['text':'========================================','line_number':456,'multiline':False]
['text':' Assignment','line_number':457,'multiline':False]
['text':'========================================','line_number':458,'multiline':False]
['text':' if assigning to ourselves, do nothing','line_number':472,'multiline':False]
['text':' is the right side bogus?','line_number':477,'multiline':False]
['text':' delete the current contents','line_number':483,'multiline':False]
['text':' empty string - use the stack buffer','line_number':487,'multiline':False]
['text':' fLength>0 and not an "open" src.getBuffer(minCapacity)','line_number':492,'multiline':False]
['text':' short string using the stack buffer, do the same','line_number':496,'multiline':False]
['text':' src uses a refCounted string buffer, use that buffer with refCount','line_number':501,'multiline':False]
['text':' src is const, use a cast - we don't actually change it','line_number':502,'multiline':False]
['text':' copy all fields, share the reference-counted buffer','line_number':504,'multiline':False]
['text':' src is a readonly alias, do the same','line_number':513,'multiline':False]
['text':' -> maintain the readonly alias as such','line_number':514,'multiline':False]
['text':' else if(!fastCopy) fall through to case kWritableAlias','line_number':522,'multiline':False]
['text':' -> allocate a new buffer and copy the contents','line_number':523,'multiline':False]
['text':' src is a writable alias; we make a copy of that instead','line_number':526,'multiline':False]
['text':' if there is not enough memory, then fall through to setting to bogus','line_number':533,'multiline':False]
['text':' if src is bogus, set ourselves to bogus','line_number':537,'multiline':False]
['text':' do not call setToBogus() here because fArray and flags are not consistent here','line_number':538,'multiline':False]
['text':' No explicit check for self move assignment, consistent with standard library.','line_number':549,'multiline':False]
['text':' Self move assignment causes no crash nor leak but might make the object bogus.','line_number':550,'multiline':False]
['text':' Same as moveFrom() except without memory management.','line_number':556,'multiline':False]
['text':' Short string using the stack buffer, copy the contents.','line_number':560,'multiline':False]
['text':' Check for self assignment to prevent "overlap in memcpy" warnings,','line_number':561,'multiline':False]
['text':' although it should be harmless to copy a buffer to itself exactly.','line_number':562,'multiline':False]
['text':' In all other cases, copy all fields.','line_number':568,'multiline':False]
['text':' Set src to bogus without releasing any memory.','line_number':575,'multiline':False]
['text':' Empty short string: Known not to need releaseArray().','line_number':584,'multiline':False]
['text':' Copy fields without resetting source values in between.','line_number':585,'multiline':False]
['text':' Set temp to an empty string so that other's memory is not released twice.','line_number':589,'multiline':False]
['text':'========================================','line_number':593,'multiline':False]
['text':' Miscellaneous operations','line_number':594,'multiline':False]
['text':'========================================','line_number':595,'multiline':False]
['text':' construct with capacity','line_number':598,'multiline':False]
['text':''\\'','line_number':610,'multiline':True]
['text':' advances i','line_number':612,'multiline':False]
['text':' return empty string','line_number':614,'multiline':False]
['text':' invalid escape sequence','line_number':615,'multiline':False]
['text':'========================================','line_number':628,'multiline':False]
['text':' Read-only implementation','line_number':629,'multiline':False]
['text':'========================================','line_number':630,'multiline':False]
['text':' Requires: this & text not bogus and have same lengths.','line_number':633,'multiline':False]
['text':' Byte-wise comparison works for equality regardless of endianness.','line_number':634,'multiline':False]
['text':' compare illegal string values','line_number':645,'multiline':False]
['text':' pin indices to legal values','line_number':650,'multiline':False]
['text':' treat const UChar *srcChars==NULL as an empty string','line_number':654,'multiline':False]
['text':' get the correct pointer','line_number':658,'multiline':False]
['text':' get the srcLength if necessary','line_number':667,'multiline':False]
['text':' are we comparing different lengths?','line_number':672,'multiline':False]
['text':'
   * note that uprv_memcmp() returns an int but we return an int8_t;
   * we need to take care not to truncate the result -
   * one way to do this is to right-shift the value to
   * move the sign bit into the lower 8 bits and making sure that this
   * does not become 0 itself
   ','line_number':686,'multiline':True]
['text':' big-endian: byte comparison works','line_number':698,'multiline':False]
['text':' little-endian: compare UChar units','line_number':704,'multiline':False]
['text':' String compare in code point order - doCompare() compares in code unit order. ','line_number':716,'multiline':True]
['text':' compare illegal string values','line_number':724,'multiline':False]
['text':' treat const UChar *srcChars==NULL as an empty string','line_number':725,'multiline':False]
['text':' pin indices to legal values','line_number':730,'multiline':False]
['text':' translate the 32-bit result into an 8-bit one ','line_number':738,'multiline':True]
['text':' if(isBogus()) then fArray==0 and start==0 - u_countChar32() checks for NULL','line_number':801,'multiline':False]
['text':' if(isBogus()) then fArray==0 and start==0 - u_strHasMoreChar32Than() checks for NULL','line_number':808,'multiline':False]
['text':' pin index','line_number':814,'multiline':False]
['text':' pin indices to legal values','line_number':838,'multiline':False]
['text':' do not copy anything if we alias dst itself','line_number':841,'multiline':False]
['text':' if the arguments are illegal, then do nothing','line_number':874,'multiline':False]
['text':' pin the indices to legal values','line_number':879,'multiline':False]
['text':' not getArrayStart() to check kIsBogus & kOpenGetBuffer','line_number':892,'multiline':False]
['text':' anything not NULL because that would make an empty string','line_number':894,'multiline':False]
['text':' bogus result string','line_number':895,'multiline':False]
['text':' Standard substitution character.','line_number':908,'multiline':False]
['text':' Don't care about number of substitutions.','line_number':909,'multiline':False]
['text':' if the arguments are illegal, then do nothing','line_number':919,'multiline':False]
['text':'dstSize < 0 || ','line_number':920,'multiline':True]
['text':' else see unistr_cnv.cpp','line_number':926,'multiline':False]
['text':' When converting from UTF-16 to UTF-8, the result will have at most 3 times','line_number':938,'multiline':False]
['text':' as many bytes as the source has UChars.','line_number':939,'multiline':False]
['text':' The "worst cases" are writing systems like Indic, Thai and CJK with','line_number':940,'multiline':False]
['text':' 3:1 bytes:UChars.','line_number':941,'multiline':False]
['text':' Standard substitution character.','line_number':957,'multiline':False]
['text':' Don't care about number of substitutions.','line_number':958,'multiline':False]
['text':' Standard substitution character.','line_number':967,'multiline':False]
['text':' Don't care about number of substitutions.','line_number':968,'multiline':False]
['text':' getBuffer() and u_strToUTF32WithSub() check for illegal arguments.','line_number':988,'multiline':False]
['text':' Substitution character.','line_number':991,'multiline':False]
['text':' Don't care about number of substitutions.','line_number':992,'multiline':False]
['text':' UnicodeString does not find empty substrings','line_number':1009,'multiline':False]
['text':' get the indices within bounds','line_number':1014,'multiline':False]
['text':' find the first occurrence of the substring','line_number':1017,'multiline':False]
['text':' pin indices','line_number':1032,'multiline':False]
['text':' find the first occurrence of c','line_number':1035,'multiline':False]
['text':' pin indices','line_number':1049,'multiline':False]
['text':' find the first occurrence of c','line_number':1052,'multiline':False]
['text':' UnicodeString does not find empty substrings','line_number':1073,'multiline':False]
['text':' get the indices within bounds','line_number':1078,'multiline':False]
['text':' find the last occurrence of the substring','line_number':1081,'multiline':False]
['text':' pin indices','line_number':1100,'multiline':False]
['text':' find the last occurrence of c','line_number':1103,'multiline':False]
['text':' pin indices','line_number':1117,'multiline':False]
['text':' find the last occurrence of c','line_number':1120,'multiline':False]
['text':'========================================','line_number':1130,'multiline':False]
['text':' Write implementation','line_number':1131,'multiline':False]
['text':'========================================','line_number':1132,'multiline':False]
['text':' no more oldText's here: done','line_number':1159,'multiline':False]
['text':' we found oldText, replace it by newText and go beyond it','line_number':1162,'multiline':False]
['text':' turn a bogus string into an empty one','line_number':1183,'multiline':False]
['text':' If len<capacity on a read-only alias, then array[len] is','line_number':1200,'multiline':False]
['text':' either the original NUL (if constructed with (TRUE, s, length))','line_number':1201,'multiline':False]
['text':' or one of the original string contents characters (if later truncated),','line_number':1202,'multiline':False]
['text':' therefore we can assume that array[len] is initialized memory.','line_number':1203,'multiline':False]
['text':' kRefCounted: Do not write the NUL if the buffer is shared.','line_number':1208,'multiline':False]
['text':' That is mostly safe, except when the length of one copy was modified','line_number':1209,'multiline':False]
['text':' without copy-on-write, e.g., via truncate(newLength) or remove(void).','line_number':1210,'multiline':False]
['text':' Then the NUL would be written into the middle of another copy's string.','line_number':1211,'multiline':False]
['text':' Otherwise, the buffer is fully writable and it is anyway safe to write the NUL.','line_number':1213,'multiline':False]
['text':' Do not test if there is a NUL already because it might be uninitialized memory.','line_number':1214,'multiline':False]
['text':' (That would be safe, but tools like valgrind & Purify would complain.)','line_number':1215,'multiline':False]
['text':' setTo() analogous to the readonly-aliasing constructor with the same signature','line_number':1229,'multiline':False]
['text':' do not modify a string that has an "open" getBuffer(minCapacity)','line_number':1236,'multiline':False]
['text':' treat as an empty string, do not alias','line_number':1241,'multiline':False]
['text':' text is terminated, or else it would have failed the above test','line_number':1258,'multiline':False]
['text':' setTo() analogous to the writable-aliasing constructor with the same signature','line_number':1266,'multiline':False]
['text':' do not modify a string that has an "open" getBuffer(minCapacity)','line_number':1272,'multiline':False]
['text':' treat as an empty string, do not alias','line_number':1277,'multiline':False]
['text':' buffLength = u_strlen(buff); but do not look beyond buffCapacity','line_number':1287,'multiline':False]
['text':' The UTF-16 string will be at most as long as the UTF-8 string.','line_number':1306,'multiline':False]
['text':' +1 for the terminating NUL.','line_number':1310,'multiline':False]
['text':' Substitution character.','line_number':1317,'multiline':False]
['text':' Don't care about number of substitutions.','line_number':1318,'multiline':False]
['text':' We test isError so that the compiler does not complain that we don't.','line_number':1352,'multiline':False]
['text':' If isError (srcChar is not a valid code point) then count==0 which means','line_number':1353,'multiline':False]
['text':' we remove the source segment rather than replacing it with srcChar.','line_number':1354,'multiline':False]
['text':' We test isError so that the compiler does not complain that we don't.','line_number':1364,'multiline':False]
['text':' If isError then _length==0 which turns the doAppend() into a no-op anyway.','line_number':1365,'multiline':False]
['text':' pin the indices to legal values','line_number':1376,'multiline':False]
['text':' get the characters from src','line_number':1379,'multiline':False]
['text':' and replace the range in ourselves with them','line_number':1380,'multiline':False]
['text':' optimize (read-only alias).remove(0, start) and .remove(start, end)','line_number':1397,'multiline':False]
['text':' remove prefix by adjusting the array pointer','line_number':1400,'multiline':False]
['text':' remove suffix by reducing the length (like truncate())','line_number':1409,'multiline':False]
['text':' not NUL-terminated any more','line_number':1411,'multiline':False]
['text':' get the srcLength if necessary','line_number':1424,'multiline':False]
['text':' pin the indices to legal values','line_number':1428,'multiline':False]
['text':' calculate the size of the string after the replace','line_number':1431,'multiline':False]
['text':' cloneArrayIfNeeded(doCopyArray=FALSE) may change fArray but will not copy the current contents;','line_number':1434,'multiline':False]
['text':' therefore we need to keep the current fArray','line_number':1435,'multiline':False]
['text':' copy the stack buffer contents because it will be overwritten with','line_number':1439,'multiline':False]
['text':' fUnion.fFields values','line_number':1440,'multiline':False]
['text':' clone our array and allocate a bigger array if needed','line_number':1447,'multiline':False]
['text':' now do the replace','line_number':1455,'multiline':False]
['text':' if fArray changed, then we need to copy everything except what will change','line_number':1459,'multiline':False]
['text':' fArray did not change; copy only the portion that isn't changing, leaving a hole','line_number':1465,'multiline':False]
['text':' now fill in the hole with the new string','line_number':1471,'multiline':False]
['text':' delayed delete in case srcChars == fArray when we started, and','line_number':1476,'multiline':False]
['text':' to keep oldArray alive for the above operations','line_number':1477,'multiline':False]
['text':' Versions of doReplace() only for append() variants.','line_number':1485,'multiline':False]
['text':' doReplace() and doAppend() optimize for different cases.','line_number':1486,'multiline':False]
['text':' pin the indices to legal values','line_number':1494,'multiline':False]
['text':' get the srcLength if necessary','line_number':1506,'multiline':False]
['text':' optimize append() onto a large-enough, owned string','line_number':1514,'multiline':False]
['text':' Do not copy characters when','line_number':1518,'multiline':False]
['text':'   UChar *buffer=str.getAppendBuffer(...);','line_number':1519,'multiline':False]
['text':' is followed by','line_number':1520,'multiline':False]
['text':'   str.append(buffer, length);','line_number':1521,'multiline':False]
['text':' or','line_number':1522,'multiline':False]
['text':'   str.appendString(buffer, length)','line_number':1523,'multiline':False]
['text':' or similar.','line_number':1524,'multiline':False]
['text':'*
 * Replaceable API
 ','line_number':1533,'multiline':True]
['text':'*
 * Replaceable API
 ','line_number':1543,'multiline':True]
['text':' Nothing to do; avoid bogus malloc call','line_number':1549,'multiline':False]
['text':' Check to make sure text is not null.','line_number':1552,'multiline':False]
['text':'*
 * Replaceable API
 *
 * NOTE: This is for the Replaceable class.  There is no rep.cpp,
 * so we implement this function here.
 ','line_number':1560,'multiline':True]
['text':'*
 * Replaceable API
 ','line_number':1570,'multiline':True]
['text':' pin the indices to legal values','line_number':1583,'multiline':False]
['text':' pinIndices() might have shrunk the length','line_number':1585,'multiline':False]
['text':' -1 for inclusive boundary (length>=2)','line_number':1590,'multiline':False]
['text':' Before the loop we know left<right because length>=2.','line_number':1594,'multiline':False]
['text':' Make sure to test the middle code unit of an odd-length string.','line_number':1600,'multiline':False]
['text':' Redundant if the length is even.','line_number':1601,'multiline':False]
['text':' if there are supplementary code points in the reversed range, then re-swap their surrogates ','line_number':1604,'multiline':True]
['text':' -1 so that we can look at *(left+1) if left<right','line_number':1609,'multiline':False]
['text':' move contents up by padding width','line_number':1631,'multiline':False]
['text':' fill in padding character','line_number':1636,'multiline':False]
['text':' fill in padding character','line_number':1653,'multiline':False]
['text':'========================================','line_number':1664,'multiline':False]
['text':' Hashing','line_number':1665,'multiline':False]
['text':'========================================','line_number':1666,'multiline':False]
['text':' Delegate hash computation to uhash.  This makes UnicodeString
     * hashing consistent with UChar* hashing.  ','line_number':1670,'multiline':True]
['text':'========================================','line_number':1679,'multiline':False]
['text':' External Buffer','line_number':1680,'multiline':False]
['text':'========================================','line_number':1681,'multiline':False]
['text':' set the new fLength','line_number':1697,'multiline':False]
['text':' the new length is the string length, capped by fCapacity','line_number':1700,'multiline':False]
['text':'========================================','line_number':1714,'multiline':False]
['text':' Miscellaneous','line_number':1715,'multiline':False]
['text':'========================================','line_number':1716,'multiline':False]
['text':' default parameters need to be static, therefore','line_number':1723,'multiline':False]
['text':' the defaults are -1 to have convenience defaults','line_number':1724,'multiline':False]
['text':' while a getBuffer(minCapacity) is "open",','line_number':1729,'multiline':False]
['text':' prevent any modifications of the string by returning FALSE here','line_number':1730,'multiline':False]
['text':' if the string is bogus, then only an assignment or similar can revive it','line_number':1731,'multiline':False]
['text':'
   * We need to make a copy of the array if
   * the buffer is read-only, or
   * the buffer is refCounted (shared), and refCount>1, or
   * the buffer is too small.
   * Return FALSE if memory could not be allocated.
   ','line_number':1736,'multiline':True]
['text':' check growCapacity for default value and use of the stack buffer','line_number':1748,'multiline':False]
['text':' save old values','line_number':1755,'multiline':False]
['text':' kRefCounted and kUsingStackBuffer are mutally exclusive ','line_number':1762,'multiline':True]
['text':' copy the stack buffer contents because it will be overwritten with','line_number':1764,'multiline':False]
['text':' fUnion.fFields values','line_number':1765,'multiline':False]
['text':' no need to copy from the stack buffer to itself','line_number':1769,'multiline':False]
['text':' when stack buffer is not used, oldArray must have a non-NULL reference ','line_number':1773,'multiline':True]
['text':' allocate a new array','line_number':1776,'multiline':False]
['text':' copy the contents','line_number':1781,'multiline':False]
['text':' do not copy more than what fits - it may be smaller than before','line_number':1782,'multiline':False]
['text':' release the old array','line_number':1796,'multiline':False]
['text':' the array is refCounted; decrement and release if 0','line_number':1798,'multiline':False]
['text':' Note: cast to (void *) is needed with MSVC, where u_atomic_int32_t','line_number':1802,'multiline':False]
['text':' is defined as volatile. (Volatile has useful non-standard behavior','line_number':1803,'multiline':False]
['text':'   with this compiler.)','line_number':1804,'multiline':False]
['text':' the caller requested to delete it himself','line_number':1807,'multiline':False]
['text':' not enough memory for growCapacity and not even for the smaller newCapacity','line_number':1813,'multiline':False]
['text':' reset the old values for setToBogus() to release the array','line_number':1814,'multiline':False]
['text':' UnicodeStringAppendable ------------------------------------------------- ***','line_number':1826,'multiline':False]
['text':' Moved here from uhash_us.cpp so that using a UVector of UnicodeString*','line_number':1882,'multiline':False]
['text':' does not depend on hashtable code.','line_number':1883,'multiline':False]
['text':'
This should never be called. It is defined here to make sure that the
virtual vector deleting destructor is defined within unistr.cpp.
The vector deleting destructor is already a part of UObject,
but defining it here makes sure that it is included with this object file.
This makes sure that static library dependencies are kept to a minimum.
','line_number':1898,'multiline':True]
