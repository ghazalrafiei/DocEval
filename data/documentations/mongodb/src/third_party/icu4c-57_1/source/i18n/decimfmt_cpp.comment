['text':'
*******************************************************************************
* Copyright (C) 1997-2015, International Business Machines Corporation and    *
* others. All Rights Reserved.                                                *
*******************************************************************************
*
* File DECIMFMT.CPP
*
* Modification History:
*
*   Date        Name        Description
*   02/19/97    aliu        Converted from java.
*   03/20/97    clhuang     Implemented with new APIs.
*   03/31/97    aliu        Moved isLONG_MIN to DigitList, and fixed it.
*   04/3/97     aliu        Rewrote parsing and formatting completely, and
*                           cleaned up and debugged.  Actually works now.
*                           Implemented NAN and INF handling, for both parsing
*                           and formatting.  Extensive testing & debugging.
*   04/10/97    aliu        Modified to compile on AIX.
*   04/16/97    aliu        Rewrote to use DigitList, which has been resurrected.
*                           Changed DigitCount to int per code review.
*   07/09/97    helena      Made ParsePosition into a class.
*   08/26/97    aliu        Extensive changes to applyPattern; completely
*                           rewritten from the Java.
*   09/09/97    aliu        Ported over support for exponential formats.
*   07/20/98    stephen     JDK 1.2 sync up.
*                             Various instances of '0' replaced with 'NULL'
*                             Check for grouping size in subFormat()
*                             Brought subParse() in line with Java 1.2
*                             Added method appendAffix()
*   08/24/1998  srl         Removed Mutex calls. This is not a thread safe class!
*   02/22/99    stephen     Removed character literals for EBCDIC safety
*   06/24/99    helena      Integrated Alan's NF enhancements and Java2 bug fixes
*   06/28/99    stephen     Fixed bugs in toPattern().
*   06/29/99    stephen     Fixed operator= to copy fFormatWidth, fPad,
*                             fPadPosition
********************************************************************************
','line_number':1,'multiline':True]
['text':'
 * On certain platforms, round is a macro defined in math.h
 * This undefine is to avoid conflict between the macro and
 * the function defined below.
 ','line_number':64,'multiline':True]
['text':' For currency parsing purose,
 * Need to remember all prefix patterns and suffix patterns of
 * every currency format pattern,
 * including the pattern of default currecny style
 * and plural currency style. And the patterns are set through applyPattern.
 ','line_number':93,'multiline':True]
['text':' negative prefix pattern','line_number':100,'multiline':False]
['text':' negative suffix pattern','line_number':102,'multiline':False]
['text':' positive prefix pattern','line_number':104,'multiline':False]
['text':' positive suffix pattern','line_number':106,'multiline':False]
['text':' affix for currency formatting when the currency sign in the pattern
 * equals to 3, such as the pattern contains 3 currency sign or
 * the formatter style is currency plural format style.
 ','line_number':132,'multiline':True]
['text':' negative prefix','line_number':137,'multiline':False]
['text':' negative suffix','line_number':139,'multiline':False]
['text':' positive prefix','line_number':141,'multiline':False]
['text':' positive suffix','line_number':143,'multiline':False]
['text':'*
 * @internal ICU 4.2
 ','line_number':170,'multiline':True]
['text':' *****************************************************************************','line_number':198,'multiline':False]
['text':' class DecimalFormat','line_number':199,'multiline':False]
['text':' *****************************************************************************','line_number':200,'multiline':False]
['text':' Constants for characters used in programmatic (unlocalized) patterns.','line_number':204,'multiline':False]
['text':''0'','line_number':205,'multiline':True]
['text':''@'','line_number':206,'multiline':True]
['text':'','','line_number':207,'multiline':True]
['text':''.'','line_number':208,'multiline':True]
['text':''%'','line_number':210,'multiline':True]
['text':''#'','line_number':211,'multiline':True]
['text':'';'','line_number':212,'multiline':True]
['text':''E'','line_number':213,'multiline':True]
['text':''+'','line_number':214,'multiline':True]
['text':''-'','line_number':215,'multiline':True]
['text':''*'','line_number':216,'multiline':True]
['text':''\''','line_number':217,'multiline':True]
['text':'*
 * The CURRENCY_SIGN is the standard Unicode symbol for currency.  It
 * is used in patterns and substitued with either the currency symbol,
 * or if it is doubled, with the international currency symbol.  If the
 * CURRENCY_SIGN is seen in a pattern, then the decimal separator is
 * replaced with the monetary decimal separator.
 ','line_number':218,'multiline':True]
['text':' ','line_number':226,'multiline':True]
['text':'*
 * These are the tags we expect to see in normal resource bundle files associated
 * with a locale.
 ','line_number':233,'multiline':True]
['text':' Deprecated - not used','line_number':237,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':247,'multiline':False]
['text':' Constructs a DecimalFormat instance in the default locale.','line_number':248,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':256,'multiline':False]
['text':' Constructs a DecimalFormat instance with the specified number format','line_number':257,'multiline':False]
['text':' pattern in the default locale.','line_number':258,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':267,'multiline':False]
['text':' Constructs a DecimalFormat instance with the specified number format','line_number':268,'multiline':False]
['text':' pattern and the number format symbols in the default locale.  The','line_number':269,'multiline':False]
['text':' created instance owns the symbols.','line_number':270,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':292,'multiline':False]
['text':' Constructs a DecimalFormat instance with the specified number format','line_number':293,'multiline':False]
['text':' pattern and the number format symbols in the default locale.  The','line_number':294,'multiline':False]
['text':' created instance owns the clone of the symbols.','line_number':295,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':305,'multiline':False]
['text':' Constructs a DecimalFormat instance with the specified number format','line_number':306,'multiline':False]
['text':' pattern, the number format symbols, and the number format style.','line_number':307,'multiline':False]
['text':' The created instance owns the clone of the symbols.','line_number':308,'multiline':False]
['text':'-----------------------------------------------------------------------------','line_number':320,'multiline':False]
['text':' Common DecimalFormat initialization.','line_number':321,'multiline':False]
['text':'    Put all fields of an uninitialized object into a known state.','line_number':322,'multiline':False]
['text':'    Common code, shared by all constructors.','line_number':323,'multiline':False]
['text':'    Can not fail. Leave the object in good enough shape that the destructor','line_number':324,'multiline':False]
['text':'    or assignment operator can run successfully.','line_number':325,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':340,'multiline':False]
['text':' Constructs a DecimalFormat instance with the specified number format','line_number':341,'multiline':False]
['text':' pattern and the number format symbols in the desired locale.  The','line_number':342,'multiline':False]
['text':' created instance owns the symbols.','line_number':343,'multiline':False]
['text':' Uses the default locale's number format pattern if there isn't','line_number':372,'multiline':False]
['text':' one specified.','line_number':373,'multiline':False]
['text':' apply pattern','line_number':421,'multiline':False]
['text':' the pattern used in format is not fixed until formatting,','line_number':428,'multiline':False]
['text':' in which, the number is known and','line_number':429,'multiline':False]
['text':' will be used to pick the right pattern based on plural count.','line_number':430,'multiline':False]
['text':' Here, set the pattern as the pattern of plural count == "other".','line_number':431,'multiline':False]
['text':' For most locale, the patterns are probably the same for all','line_number':432,'multiline':False]
['text':' plural count. If not, the right pattern need to be re-applied','line_number':433,'multiline':False]
['text':' during format.','line_number':434,'multiline':False]
['text':' TODO(refactor): Revisit, we are setting the pattern twice.','line_number':436,'multiline':False]
['text':' initialize for currency, not only for plural format,','line_number':446,'multiline':False]
['text':' but also for mix parsing','line_number':447,'multiline':False]
['text':' need it for mix parsing','line_number':454,'multiline':False]
['text':' Save the default currency patterns of this locale.','line_number':504,'multiline':False]
['text':' Here, chose onlyApplyPatternWithoutExpandAffix without','line_number':505,'multiline':False]
['text':' expanding the affix patterns into affixes.','line_number':506,'multiline':False]
['text':' save the unique currency plural patterns of this locale.','line_number':543,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':574,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':583,'multiline':False]
['text':' copy constructor','line_number':584,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':592,'multiline':False]
['text':' assignment operator','line_number':593,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':631,'multiline':False]
['text':' NumberFormat::operator== guarantees this cast is safe','line_number':639,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':649,'multiline':False]
['text':' Create a fixed decimal from a DigitList.','line_number':716,'multiline':False]
['text':'    The digit list may be modified.','line_number':717,'multiline':False]
['text':'    Internal function only.','line_number':718,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':739,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':769,'multiline':False]
['text':' ignored ','line_number':776,'multiline':True]
['text':'------------------------------------------------------------------------------','line_number':798,'multiline':False]
['text':' ignored ','line_number':805,'multiline':True]
['text':'------------------------------------------------------------------------------','line_number':827,'multiline':False]
['text':' indicate failure','line_number':899,'multiline':False]
['text':'*
 * Parses the given text as a number, optionally providing a currency amount.
 * @param text the string to parse
 * @param result output parameter for the numeric result.
 * @param parsePosition input-output position; on input, the
 * position within text to match; must have 0 <= pos.getIndex() <
 * text.length(); on output, the position after the last matched
 * character. If the parse fails, the position in unchanged upon
 * output.
 * @param currency if non-NULL, it should point to a 4-UChar buffer.
 * In this case the text is parsed as a currency format, and the
 * ISO 4217 code for the parsed currency is put into the buffer.
 * Otherwise the text is parsed as a non-currency format.
 ','line_number':907,'multiline':True]
['text':' clear any old contents in the result.  In particular, clears any DigitList','line_number':928,'multiline':False]
['text':'   that it may be holding.','line_number':929,'multiline':False]
['text':' Handle NaN as a special case:','line_number':937,'multiline':False]
['text':' Skip padding characters, if around prefix','line_number':940,'multiline':False]
['text':' skip any leading whitespace','line_number':948,'multiline':False]
['text':' If the text is composed of the representation of NaN, returns NaN.length','line_number':952,'multiline':False]
['text':' NaN parse failed; start over','line_number':966,'multiline':False]
['text':' status is used to record whether a number is infinite.','line_number':970,'multiline':False]
['text':' get one from the stack buffer','line_number':973,'multiline':False]
['text':' no way to report error from here.','line_number':975,'multiline':False]
['text':' Handle infinity','line_number':997,'multiline':False]
['text':' TODO:  set the dl to infinity, and let it fall into the code below.','line_number':1001,'multiline':False]
['text':' Negative zero special case:','line_number':1027,'multiline':False]
['text':'    if parsing integerOnly, change to +0, which goes into an int32 in a Formattable.','line_number':1028,'multiline':False]
['text':'    if not parsing integerOnly, leave as -0, which a double can represent.','line_number':1029,'multiline':False]
['text':' First, parse against current pattern.','line_number':1057,'multiline':False]
['text':' Since current pattern could be set by applyPattern(),','line_number':1058,'multiline':False]
['text':' it could be an arbitrary pattern, and it may not be the one','line_number':1059,'multiline':False]
['text':' defined in current locale.','line_number':1060,'multiline':False]
['text':' Then, parse against affix patterns.','line_number':1089,'multiline':False]
['text':' Those are currency patterns and currency plural patterns.','line_number':1090,'multiline':False]
['text':' Finally, parse against simple affix to find the match.','line_number':1126,'multiline':False]
['text':' For example, in TestMonster suite,','line_number':1127,'multiline':False]
['text':' if the to-be-parsed text is "-\u00A40,00".','line_number':1128,'multiline':False]
['text':' complexAffixCompare will not find match,','line_number':1129,'multiline':False]
['text':' since there is no ISO code matches "\u00A4",','line_number':1130,'multiline':False]
['text':' and the parse stops at "\u00A4".','line_number':1131,'multiline':False]
['text':' We will just use simple affix comparison (look for exact match)','line_number':1132,'multiline':False]
['text':' to pass it.','line_number':1133,'multiline':False]
['text':'','line_number':1134,'multiline':False]
['text':' TODO: We should parse against simple affix first when','line_number':1135,'multiline':False]
['text':' output currency is not requested. After the complex currency','line_number':1136,'multiline':False]
['text':' parsing implementation was introduced, the default currency','line_number':1137,'multiline':False]
['text':' instance parsing slowed down because of the new code flow.','line_number':1138,'multiline':False]
['text':' I filed #10312 - Yoshito','line_number':1139,'multiline':False]
['text':' Disable complex currency parsing and try it again.','line_number':1144,'multiline':False]
['text':' disable complex currency parsing ','line_number':1150,'multiline':True]
['text':'parsePosition.setIndex(origPos);','line_number':1168,'multiline':False]
['text':'*
 * Parse the given text into a number.  The text is parsed beginning at
 * parsePosition, until an unparseable character is seen.
 * @param text the string to parse.
 * @param negPrefix negative prefix.
 * @param negSuffix negative suffix.
 * @param posPrefix positive prefix.
 * @param posSuffix positive suffix.
 * @param complexCurrencyParsing whether it is complex currency parsing or not.
 * @param type the currency type to parse against, LONG_NAME only or not.
 * @param parsePosition The position at which to being parsing.  Upon
 * return, the first unparsed character.
 * @param digits the DigitList to set to the parsed value.
 * @param status output param containing boolean status flags indicating
 * whether the value was infinite and whether it was positive.
 * @param currency return value for parsed currency, for generic
 * currency parsing mode, or NULL for normal parsing. In generic
 * currency parsing mode, any currency is parsed, not just the
 * currency that this formatter is set to.
 ','line_number':1178,'multiline':True]
['text':'  The parsing process builds up the number as char string, in the neutral format that','line_number':1209,'multiline':False]
['text':'  will be acceptable to the decNumber library, then at the end passes that string','line_number':1210,'multiline':False]
['text':'  off for conversion to a decNumber.','line_number':1211,'multiline':False]
['text':' One less pointer to follow','line_number':1218,'multiline':False]
['text':' TRUE iff fast parse is OK ','line_number':1240,'multiline':True]
['text':' UBool fastParseHadDecimal = FALSE; /* true if fast parse saw a decimal point. */','line_number':1241,'multiline':False]
['text':'            (negPrefix==NULL||negPrefix->isEmpty()) &&','line_number':1247,'multiline':False]
['text':'            (negSuffix==NULL||(negSuffix->isEmpty()) ) &&','line_number':1248,'multiline':False]
['text':' optimized path','line_number':1249,'multiline':False]
['text':' not allowed','line_number':1261,'multiline':False]
['text':' Don't look for decimals.','line_number':1262,'multiline':False]
['text':' Look for this decimal','line_number':1264,'multiline':False]
['text':' NO decimal set','line_number':1266,'multiline':False]
['text':'Set counter to end of line, so that we break. Unknown decimal situation.','line_number':1268,'multiline':False]
['text':' '-'','line_number':1277,'multiline':False]
['text':'=break - negative number.','line_number':1278,'multiline':False]
['text':'
          parsedNum.append('-',err); 
          j+=U16_LENGTH(ch);
          if(j<l) ch = text.char32At(j);
        ','line_number':1280,'multiline':True]
['text':' break out','line_number':1295,'multiline':False]
['text':' no more decimals.','line_number':1300,'multiline':False]
['text':' fastParseHadDecimal=TRUE;','line_number':1301,'multiline':False]
['text':' ignore grouping char. No decimals, so it has to be an ignorable grouping sep','line_number':1303,'multiline':False]
['text':' parsing integer only and can fall through','line_number':1305,'multiline':False]
['text':' fail - fall through to slow parse','line_number':1307,'multiline':False]
['text':' for next  ','line_number':1311,'multiline':False]
['text':' end OR only parsing integer','line_number':1314,'multiline':False]
['text':' and have at least one digit','line_number':1315,'multiline':False]
['text':' Fast parse OK!','line_number':1316,'multiline':False]
['text':' for testing, try it the slow way. also ','line_number':1320,'multiline':True]
['text':' was not OK. reset, retry','line_number':1328,'multiline':False]
['text':' Match padding before prefix','line_number':1354,'multiline':False]
['text':' Match positive and negative prefixes; prefer longest match.','line_number':1359,'multiline':False]
['text':' Temporary set positive. This might be changed after checking suffix','line_number':1379,'multiline':False]
['text':' Match padding before prefix','line_number':1383,'multiline':False]
['text':' process digits or Inf, find decimal position','line_number':1392,'multiline':False]
['text':' infLen is non-zero when it does equal to infinity','line_number':1396,'multiline':False]
['text':' We now have a string of digits, possibly with grouping symbols,','line_number':1402,'multiline':False]
['text':' and decimal points.  We want to process these into a DigitList.','line_number':1403,'multiline':False]
['text':' We don't want to put a bunch of leading zeros into the DigitList','line_number':1404,'multiline':False]
['text':' though, so we keep track of the location of the decimal point,','line_number':1405,'multiline':False]
['text':' put only significant digits into the DigitList, and adjust the','line_number':1406,'multiline':False]
['text':' exponent as needed.','line_number':1407,'multiline':False]
['text':' did we exit with a strict parse failure?','line_number':1410,'multiline':False]
['text':' where did we last see a grouping separator?','line_number':1411,'multiline':False]
['text':' equivalent grouping and decimal support','line_number':1433,'multiline':False]
['text':' We need to test groupingChar and decimalChar separately from groupingSet and decimalSet, if the sets are even initialized.','line_number':1449,'multiline':False]
['text':' If sawDecimal is TRUE, only consider sawDecimalChar and NOT decimalSet','line_number':1450,'multiline':False]
['text':' If a character matches decimalSet, don't consider it to be a member of the groupingSet.','line_number':1451,'multiline':False]
['text':' We have to track digitCount ourselves, because digits.fCount will','line_number':1453,'multiline':False]
['text':' pin when the maximum allowable digits is reached.','line_number':1454,'multiline':False]
['text':' We recognize all digit ranges, not only the Latin digit range
             * '0'..'9'.  We do so by using the Character.digit() method,
             * which converts a valid Unicode digit to the range 0..9.
             *
             * The character 'ch' may be a digit.  If so, place its value
             * from 0 to 9 in 'digit'.  First try using the locale digit,
             * which may or MAY NOT be a standard Unicode digit range.  If
             * this fails, try using the standard Unicode digit ranges by
             * calling Character.digit().  If this also fails, digit will 
             * have a value outside the range 0..9.
             ','line_number':1462,'multiline':True]
['text':' As a last resort, look through the localized digits if the zero digit','line_number':1479,'multiline':False]
['text':' is not a "standard" Unicode digit.','line_number':1480,'multiline':False]
['text':' comma followed by digit, so group before comma is a','line_number':1496,'multiline':False]
['text':' secondary group.  If there was a group separator','line_number':1497,'multiline':False]
['text':' before that, the group must == the secondary group','line_number':1498,'multiline':False]
['text':' length, else it can be <= the the secondary group','line_number':1499,'multiline':False]
['text':' length.','line_number':1500,'multiline':False]
['text':' Cancel out backup setting (see grouping handler below)','line_number':1510,'multiline':False]
['text':' Note: this will append leading zeros','line_number':1514,'multiline':False]
['text':' count any digit that's not a leading zero','line_number':1517,'multiline':False]
['text':' count any integer digit that's not a leading zero','line_number':1521,'multiline':False]
['text':' leading group, or two group separators in a row','line_number':1540,'multiline':False]
['text':' Ignore grouping characters, if we are using them, but require','line_number':1546,'multiline':False]
['text':' that they be followed by a digit.  Otherwise we backup and','line_number':1547,'multiline':False]
['text':' reprocess them.','line_number':1548,'multiline':False]
['text':' Once we see a grouping character, we only accept that grouping character from then on.','line_number':1552,'multiline':False]
['text':' If we're only parsing integers, or if we ALREADY saw the','line_number':1565,'multiline':False]
['text':' decimal, then don't parse this one.','line_number':1566,'multiline':False]
['text':' Once we see a decimal character, we only accept that decimal character from then on.','line_number':1574,'multiline':False]
['text':' decimalSet is considered to consist of (ch,ch)','line_number':1576,'multiline':False]
['text':' don't parse if this is set unless..','line_number':1580,'multiline':False]
['text':' .. it's an exponent format - ignore setting and parse anyways','line_number':1581,'multiline':False]
['text':' TODO: CASE','line_number':1584,'multiline':False]
['text':' error code is set below if !sawDigit ','line_number':1585,'multiline':False]
['text':' Parse sign, if present','line_number':1587,'multiline':False]
['text':' Advance past the exponent','line_number':1630,'multiline':False]
['text':' Whether we fail or succeed, we exit this loop','line_number':1633,'multiline':False]
['text':' not parsing exponent','line_number':1637,'multiline':False]
['text':' if we didn't see a decimal and it is required, check to see if the pattern had one','line_number':1643,'multiline':False]
['text':' only set with strictParse and a grouping separator error','line_number':1667,'multiline':False]
['text':' If there was no decimal point we have an integer','line_number':1675,'multiline':False]
['text':' If none of the text string was recognized.  For example, parse','line_number':1677,'multiline':False]
['text':' "x" with pattern "#0.00" (return index and error index both 0)','line_number':1678,'multiline':False]
['text':' parse "$" with pattern "$#0.00". (return index 0 and error index','line_number':1679,'multiline':False]
['text':' 1).','line_number':1680,'multiline':False]
['text':' Match padding before suffix','line_number':1692,'multiline':False]
['text':' Match positive and negative suffixes; prefer longest match.','line_number':1699,'multiline':False]
['text':' Fail if neither or both','line_number':1714,'multiline':False]
['text':' Match padding before suffix','line_number':1723,'multiline':False]
['text':' end SLOW parse ','line_number':1734,'multiline':True]
['text':' uint32_t bits = (fastParseOk?kFastpathOk:0) |','line_number':1753,'multiline':False]
['text':'   (fastParseHadDecimal?0:kNoDecimal);','line_number':1754,'multiline':False]
['text':'printf("FPOK=%d, FPHD=%d, bits=%08X\n", fastParseOk, fastParseHadDecimal, bits);','line_number':1755,'multiline':False]
['text':'bits','line_number':1758,'multiline':False]
['text':' check if we missed a required decimal point','line_number':1769,'multiline':False]
['text':'*
 * Starting at position, advance past a run of pad characters, if any.
 * Return the index of the first character after position that is not a pad
 * character.  Result is >= position.
 ','line_number':1785,'multiline':True]
['text':'*
 * Return the length matched by the given affix, or -1 if none.
 * Runs of white space in the affix, match runs of white space in
 * the input.  Pattern white space and input white space are
 * determined differently; see code.
 * @param text input text
 * @param pos offset into input at which to begin matching
 * @param isNegative
 * @param isPrefix
 * @param affixPat affix pattern used for currency affix comparison.
 * @param complexCurrencyParsing whether it is currency parsing or not
 * @param type the currency type to parse against, LONG_NAME only or not.
 * @param currency return value for parsed currency, for generic
 * currency parsing mode, or null for normal parsing. In generic
 * currency parsing mode, any currency is parsed, not just the
 * currency that this formatter is set to.
 * @return length of input that matches, or -1 if match failure
 ','line_number':1799,'multiline':True]
['text':' should already be loaded','line_number':1858,'multiline':False]
['text':' check for LRM 0x200E, RLM 0x200F, ALM 0x061C','line_number':1865,'multiline':False]
['text':'*
 * Return the length matched by the given affix, or -1 if none.
 * Runs of white space in the affix, match runs of white space in
 * the input.  Pattern white space and input white space are
 * determined differently; see code.
 * @param affix pattern string, taken as a literal
 * @param input input text
 * @param pos offset into input at which to begin matching
 * @return length of input that matches, or -1 if match failure
 ','line_number':1888,'multiline':True]
['text':' For more efficiency we should keep lazily-created trimmed affixes around in','line_number':1904,'multiline':False]
['text':' instance variables instead of trimming each time they are used (the next step)','line_number':1905,'multiline':False]
['text':' should already be loaded','line_number':1914,'multiline':False]
['text':' If the trimmedAffix is exactly one character long and that character','line_number':1922,'multiline':False]
['text':' is in the dash set and the very next input character is also','line_number':1923,'multiline':False]
['text':' in the dash set, return a match.','line_number':1924,'multiline':False]
['text':' skip any trailing bidi marks','line_number':1929,'multiline':False]
['text':' We may have a pattern like: \u200F \u0020','line_number':1938,'multiline':False]
['text':'        and input text like: \u200F \u0020','line_number':1939,'multiline':False]
['text':' Note that U+200F and U+0020 are Pattern_White_Space but only','line_number':1940,'multiline':False]
['text':' U+0020 is UWhiteSpace.  So we have to first do a direct','line_number':1941,'multiline':False]
['text':' match of the run of Pattern_White_Space in the pattern,','line_number':1942,'multiline':False]
['text':' then match any extra characters.','line_number':1943,'multiline':False]
['text':' just skip over this input text','line_number':1960,'multiline':False]
['text':' Advance over run in pattern','line_number':1966,'multiline':False]
['text':' Advance over run in input text','line_number':1969,'multiline':False]
['text':' Must see at least one white space char in input,','line_number':1970,'multiline':False]
['text':' unless we've already matched some characters literally.','line_number':1971,'multiline':False]
['text':' If we skip UWhiteSpace in the input text, we need to skip it in the pattern.','line_number':1978,'multiline':False]
['text':' Otherwise, the previous lines may have skipped over text (such as U+00A0) that','line_number':1979,'multiline':False]
['text':' is also in the trimmedAffix.','line_number':1980,'multiline':False]
['text':' just skip over this input text','line_number':1991,'multiline':False]
['text':'i = skipRuleWhiteSpace(trimmedAffix, i);','line_number':2019,'multiline':False]
['text':'*
 * Skip over a run of zero or more Pattern_White_Space characters at
 * pos in text.
 ','line_number':2047,'multiline':True]
['text':'*
 * Skip over a run of zero or more isUWhiteSpace() characters at pos
 * in text.
 ','line_number':2056,'multiline':True]
['text':'*
 * Skip over a run of zero or more isUWhiteSpace() characters or bidi marks at pos
 * in text.
 ','line_number':2071,'multiline':True]
['text':' u_isUWhiteSpace doesn't include LRM,RLM,ALM','line_number':2078,'multiline':False]
['text':'*
 * Skip over a run of zero or more bidi marks at pos in text.
 ','line_number':2086,'multiline':True]
['text':'*
 * Return the length matched by the given affix, or -1 if none.
 * @param affixPat pattern string
 * @param input input text
 * @param pos offset into input at which to begin matching
 * @param type the currency type to parse against, LONG_NAME only or not.
 * @param currency return value for parsed currency, for generic
 * currency parsing mode, or null for normal parsing. In generic
 * currency parsing mode, any currency is parsed, not just the
 * currency that this formatter is set to.
 * @return length of input that matches, or -1 if match failure
 ','line_number':2100,'multiline':True]
['text':' since the currency names in choice format is saved','line_number':2135,'multiline':False]
['text':' the same way as other currency names,','line_number':2136,'multiline':False]
['text':' do not need to do currency choice parsing here.','line_number':2137,'multiline':False]
['text':' the general currency parsing parse against all names,','line_number':2138,'multiline':False]
['text':' including names in choice format.','line_number':2139,'multiline':False]
['text':' Parse generic currency -- anything for which we','line_number':2151,'multiline':False]
['text':' have a display name, or any 3-letter ISO code.','line_number':2152,'multiline':False]
['text':' Try to parse display name for our locale; first','line_number':2153,'multiline':False]
['text':' determine our locale.','line_number':2154,'multiline':False]
['text':' Delegate parse of display name => ISO code to Currency','line_number':2159,'multiline':False]
['text':' If parse succeeds, populate currency[0]','line_number':2162,'multiline':False]
['text':' The formatter is currency-style but the client has not requested','line_number':2167,'multiline':False]
['text':' the value of the parsed currency. In this case, if that value does','line_number':2168,'multiline':False]
['text':' not match the formatter's current value, then the parse fails.','line_number':2169,'multiline':False]
['text':' fall through to affix!=0 test, which will fail','line_number':2196,'multiline':False]
['text':'*
 * Match a single character at text[pos] and return the index of the
 * next character upon success.  Return -1 on failure.  If
 * ch is a Pattern_White_Space then match a run of white space in text.
 ','line_number':2214,'multiline':True]
['text':' Advance over run of white space in input text','line_number':2221,'multiline':False]
['text':' Must see at least one white space char in input','line_number':2222,'multiline':False]
['text':'*
 * Match a string at text[pos] and return the index of the next
 * character upon success.  Return -1 on failure.  Match a run of
 * white space in str with a run of white space in text.
 ','line_number':2234,'multiline':True]
['text':'decimalChar','line_number':2278,'multiline':True]
['text':' previously found','line_number':2281,'multiline':False]
['text':' char from symbols','line_number':2283,'multiline':False]
['text':' in groupingSet but...','line_number':2285,'multiline':False]
['text':' Exclude decimalSet from groupingSet','line_number':2286,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2294,'multiline':False]
['text':' Gets the pointer to the localized decimal format symbols','line_number':2295,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2303,'multiline':False]
['text':' De-owning the current localized symbols and adopt the new symbols.','line_number':2304,'multiline':False]
['text':' do not allow caller to set fSymbols to NULL','line_number':2310,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2314,'multiline':False]
['text':' Setting the symbols is equlivalent to adopting a newly created localized','line_number':2315,'multiline':False]
['text':' symbols.','line_number':2316,'multiline':False]
['text':' re-set currency affix patterns and currency affixes.','line_number':2338,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2356,'multiline':False]
['text':' Gets the positive prefix of the number pattern.','line_number':2357,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2365,'multiline':False]
['text':' Sets the positive prefix of the number pattern.','line_number':2366,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2374,'multiline':False]
['text':' Gets the negative prefix  of the number pattern.','line_number':2375,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2383,'multiline':False]
['text':' Gets the negative prefix  of the number pattern.','line_number':2384,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2392,'multiline':False]
['text':' Gets the positive suffix of the number pattern.','line_number':2393,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2401,'multiline':False]
['text':' Sets the positive suffix of the number pattern.','line_number':2402,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2410,'multiline':False]
['text':' Gets the negative suffix of the number pattern.','line_number':2411,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2419,'multiline':False]
['text':' Sets the negative suffix of the number pattern.','line_number':2420,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2428,'multiline':False]
['text':' Gets the multiplier of the number pattern.','line_number':2429,'multiline':False]
['text':'   Multipliers are stored as decimal numbers (DigitLists) because that','line_number':2430,'multiline':False]
['text':'      is the most convenient for muliplying or dividing the numbers to be formatted.','line_number':2431,'multiline':False]
['text':'   A NULL multiplier implies one, and the scaling operations are skipped.','line_number':2432,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2440,'multiline':False]
['text':' Sets the multiplier of the number pattern.','line_number':2441,'multiline':False]
['text':'*
 * Get the rounding increment.
 * @return A positive rounding increment, or 0.0 if rounding
 * is not in effect.
 * @see #setRoundingIncrement
 * @see #getRoundingMode
 * @see #setRoundingMode
 ','line_number':2448,'multiline':True]
['text':'*
 * Set the rounding increment.  This method also controls whether
 * rounding is enabled.
 * @param newValue A positive rounding increment, or 0.0 to disable rounding.
 * Negative increments are equivalent to 0.0.
 * @see #getRoundingIncrement
 * @see #getRoundingMode
 * @see #setRoundingMode
 ','line_number':2460,'multiline':True]
['text':'*
 * Get the rounding mode.
 * @return A rounding mode
 * @see #setRoundingIncrement
 * @see #getRoundingIncrement
 * @see #setRoundingMode
 ','line_number':2473,'multiline':True]
['text':'*
 * Set the rounding mode.  This has no effect unless the rounding
 * increment is greater than zero.
 * @param roundingMode A rounding mode
 * @see #setRoundingIncrement
 * @see #getRoundingIncrement
 * @see #getRoundingMode
 ','line_number':2484,'multiline':True]
['text':'*
 * Get the width to which the output of <code>format()</code> is padded.
 * @return the format width, or zero if no padding is in effect
 * @see #setFormatWidth
 * @see #getPadCharacter
 * @see #setPadCharacter
 * @see #getPadPosition
 * @see #setPadPosition
 ','line_number':2496,'multiline':True]
['text':'*
 * Set the width to which the output of <code>format()</code> is padded.
 * This method also controls whether padding is enabled.
 * @param width the width to which to pad the result of
 * <code>format()</code>, or zero to disable padding.  A negative
 * width is equivalent to 0.
 * @see #getFormatWidth
 * @see #getPadCharacter
 * @see #setPadCharacter
 * @see #getPadPosition
 * @see #setPadPosition
 ','line_number':2509,'multiline':True]
['text':'*
 * Get the position at which padding will take place.  This is the location
 * at which padding will be inserted if the result of <code>format()</code>
 * is shorter than the format width.
 * @return the pad position, one of <code>kPadBeforePrefix</code>,
 * <code>kPadAfterPrefix</code>, <code>kPadBeforeSuffix</code>, or
 * <code>kPadAfterSuffix</code>.
 * @see #setFormatWidth
 * @see #getFormatWidth
 * @see #setPadCharacter
 * @see #getPadCharacter
 * @see #setPadPosition
 * @see #kPadBeforePrefix
 * @see #kPadAfterPrefix
 * @see #kPadBeforeSuffix
 * @see #kPadAfterSuffix
 ','line_number':2558,'multiline':True]
['text':'*
 * <strong><font face=helvetica color=red>NEW</font></strong>
 * Set the position at which padding will take place.  This is the location
 * at which padding will be inserted if the result of <code>format()</code>
 * is shorter than the format width.  This has no effect unless padding is
 * enabled.
 * @param padPos the pad position, one of <code>kPadBeforePrefix</code>,
 * <code>kPadAfterPrefix</code>, <code>kPadBeforeSuffix</code>, or
 * <code>kPadAfterSuffix</code>.
 * @see #setFormatWidth
 * @see #getFormatWidth
 * @see #setPadCharacter
 * @see #getPadCharacter
 * @see #getPadPosition
 * @see #kPadBeforePrefix
 * @see #kPadAfterPrefix
 * @see #kPadBeforeSuffix
 * @see #kPadAfterSuffix
 ','line_number':2596,'multiline':True]
['text':'*
 * Return whether or not scientific notation is used.
 * @return TRUE if this object formats and parses scientific notation
 * @see #setScientificNotation
 * @see #getMinimumExponentDigits
 * @see #setMinimumExponentDigits
 * @see #isExponentSignAlwaysShown
 * @see #setExponentSignAlwaysShown
 ','line_number':2619,'multiline':True]
['text':'*
 * Set whether or not scientific notation is used.
 * @param useScientific TRUE if this object formats and parses scientific
 * notation
 * @see #isScientificNotation
 * @see #getMinimumExponentDigits
 * @see #setMinimumExponentDigits
 * @see #isExponentSignAlwaysShown
 * @see #setExponentSignAlwaysShown
 ','line_number':2632,'multiline':True]
['text':'*
 * Return the minimum exponent digits that will be shown.
 * @return the minimum exponent digits that will be shown
 * @see #setScientificNotation
 * @see #isScientificNotation
 * @see #setMinimumExponentDigits
 * @see #isExponentSignAlwaysShown
 * @see #setExponentSignAlwaysShown
 ','line_number':2646,'multiline':True]
['text':'*
 * Set the minimum exponent digits that will be shown.  This has no
 * effect unless scientific notation is in use.
 * @param minExpDig a value >= 1 indicating the fewest exponent digits
 * that will be shown.  Values less than 1 will be treated as 1.
 * @see #setScientificNotation
 * @see #isScientificNotation
 * @see #getMinimumExponentDigits
 * @see #isExponentSignAlwaysShown
 * @see #setExponentSignAlwaysShown
 ','line_number':2659,'multiline':True]
['text':'*
 * Return whether the exponent sign is always shown.
 * @return TRUE if the exponent is always prefixed with either the
 * localized minus sign or the localized plus sign, false if only negative
 * exponents are prefixed with the localized minus sign.
 * @see #setScientificNotation
 * @see #isScientificNotation
 * @see #setMinimumExponentDigits
 * @see #getMinimumExponentDigits
 * @see #setExponentSignAlwaysShown
 ','line_number':2675,'multiline':True]
['text':'*
 * Set whether the exponent sign is always shown.  This has no effect
 * unless scientific notation is in use.
 * @param expSignAlways TRUE if the exponent is always prefixed with either
 * the localized minus sign or the localized plus sign, false if only
 * negative exponents are prefixed with the localized minus sign.
 * @see #setScientificNotation
 * @see #isScientificNotation
 * @see #setMinimumExponentDigits
 * @see #getMinimumExponentDigits
 * @see #isExponentSignAlwaysShown
 ','line_number':2690,'multiline':True]
['text':'------------------------------------------------------------------------------','line_number':2706,'multiline':False]
['text':' Gets the grouping size of the number pattern.  For example, thousand or 10','line_number':2707,'multiline':False]
['text':' thousand groupings.','line_number':2708,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2716,'multiline':False]
['text':' Gets the grouping size of the number pattern.','line_number':2717,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2725,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2733,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2741,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2749,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2757,'multiline':False]
['text':' Checks if to show the decimal separator.','line_number':2758,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2766,'multiline':False]
['text':' Sets to always show the decimal separator.','line_number':2767,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2775,'multiline':False]
['text':' Checks if decimal point pattern match is required','line_number':2776,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2783,'multiline':False]
['text':' Checks if decimal point pattern match is required','line_number':2784,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2793,'multiline':False]
['text':' Emits the pattern of this DecimalFormat instance.','line_number':2794,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2802,'multiline':False]
['text':' Emits the localized pattern this DecimalFormat instance.','line_number':2803,'multiline':False]
['text':' toLocalizedPattern is deprecated, so we just make it the same as','line_number':2808,'multiline':False]
['text':' toPattern.','line_number':2809,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2813,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2821,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2830,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2838,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2848,'multiline':False]
['text':'*
 * Sets the maximum number of digits allowed in the integer portion of a
 * number. 
 * @see NumberFormat#setMaximumIntegerDigits
 ','line_number':2850,'multiline':True]
['text':'*
 * Sets the minimum number of digits allowed in the integer portion of a
 * number. This override limits the integer digit count to 309.
 * @see NumberFormat#setMinimumIntegerDigits
 ','line_number':2861,'multiline':True]
['text':'*
 * Sets the maximum number of digits allowed in the fraction portion of a
 * number. This override limits the fraction digit count to 340.
 * @see NumberFormat#setMaximumFractionDigits
 ','line_number':2872,'multiline':True]
['text':'*
 * Sets the minimum number of digits allowed in the fraction portion of a
 * number. This override limits the fraction digit count to 340.
 * @see NumberFormat#setMinimumFractionDigits
 ','line_number':2883,'multiline':True]
['text':' pin max sig dig to >= min','line_number':2906,'multiline':False]
['text':' pin min sig dig to 1..max','line_number':2915,'multiline':False]
['text':' set the currency before compute affixes to get the right currency names','line_number':2930,'multiline':False]
['text':' Deprecated variant with no UErrorCode parameter','line_number':2943,'multiline':False]
['text':' ok for intl to go out of scope','line_number':2959,'multiline':False]
['text':'* The position at which padding will take place. ','line_number':3123,'multiline':True]
['text':' These are stored in fBoolFlags ','line_number':3137,'multiline':True]
['text':' TBD: what should this return?','line_number':3193,'multiline':False]
['text':' TBD: what should this return?','line_number':3203,'multiline':False]
['text':' These are stored in fBoolFlags ','line_number':3233,'multiline':True]
['text':' undefined ','line_number':3253,'multiline':True]
['text':' #if !UCONFIG_NO_FORMATTING ','line_number':3264,'multiline':True]
['text':'eof','line_number':3266,'multiline':False]
