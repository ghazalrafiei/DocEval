['text':'
*******************************************************************************
* Copyright (C) 1997-2016, International Business Machines Corporation and    *
* others. All Rights Reserved.                                                *
*******************************************************************************
*
* File SMPDTFMT.CPP
*
* Modification History:
*
*   Date        Name        Description
*   02/19/97    aliu        Converted from java.
*   03/31/97    aliu        Modified extensively to work with 50 locales.
*   04/01/97    aliu        Added support for centuries.
*   07/09/97    helena      Made ParsePosition into a class.
*   07/21/98    stephen     Added initializeDefaultCentury.
*                             Removed getZoneIndex (added in DateFormatSymbols)
*                             Removed subParseLong
*                             Removed chk
*   02/22/99    stephen     Removed character literals for EBCDIC safety
*   10/14/99    aliu        Updated 2-digit year parsing so that only "00" thru
*                           "99" are recognized. {j28 4182066}
*   11/15/99    weiv        Added support for week of year/day of week format
********************************************************************************
','line_number':1,'multiline':True]
['text':' *****************************************************************************','line_number':75,'multiline':False]
['text':' class SimpleDateFormat','line_number':76,'multiline':False]
['text':' *****************************************************************************','line_number':77,'multiline':False]
['text':'*
 * Last-resort string to use for "GMT" when constructing time zone strings.
 ','line_number':81,'multiline':True]
['text':' For time zones that have no names, use strings GMT+minutes and','line_number':84,'multiline':False]
['text':' GMT-minutes. For instance, in France the time zone is GMT+60.','line_number':85,'multiline':False]
['text':' Also accepted are GMT+H:MM or GMT-H:MM.','line_number':86,'multiline':False]
['text':' Currently not being used','line_number':87,'multiline':False]
['text':'static const UChar gGmt[]      = {0x0047, 0x004D, 0x0054, 0x0000};         // "GMT"','line_number':88,'multiline':False]
['text':'static const UChar gGmtPlus[]  = {0x0047, 0x004D, 0x0054, 0x002B, 0x0000}; // "GMT+"','line_number':89,'multiline':False]
['text':'static const UChar gGmtMinus[] = {0x0047, 0x004D, 0x0054, 0x002D, 0x0000}; // "GMT-"','line_number':90,'multiline':False]
['text':'static const UChar gDefGmtPat[]       = {0x0047, 0x004D, 0x0054, 0x007B, 0x0030, 0x007D, 0x0000}; /* GMT{0} */','line_number':91,'multiline':False]
['text':'static const UChar gDefGmtNegHmsPat[] = {0x002D, 0x0048, 0x0048, 0x003A, 0x006D, 0x006D, 0x003A, 0x0073, 0x0073, 0x0000}; /* -HH:mm:ss */','line_number':92,'multiline':False]
['text':'static const UChar gDefGmtNegHmPat[]  = {0x002D, 0x0048, 0x0048, 0x003A, 0x006D, 0x006D, 0x0000}; /* -HH:mm */','line_number':93,'multiline':False]
['text':'static const UChar gDefGmtPosHmsPat[] = {0x002B, 0x0048, 0x0048, 0x003A, 0x006D, 0x006D, 0x003A, 0x0073, 0x0073, 0x0000}; /* +HH:mm:ss */','line_number':94,'multiline':False]
['text':'static const UChar gDefGmtPosHmPat[]  = {0x002B, 0x0048, 0x0048, 0x003A, 0x006D, 0x006D, 0x0000}; /* +HH:mm */','line_number':95,'multiline':False]
['text':'static const UChar gUt[]       = {0x0055, 0x0054, 0x0000};  // "UT"','line_number':96,'multiline':False]
['text':'static const UChar gUtc[]      = {0x0055, 0x0054, 0x0043, 0x0000};  // "UT"','line_number':97,'multiline':False]
['text':' Stuff needed for numbering system overrides','line_number':110,'multiline':False]
['text':' This is a pattern-of-last-resort used when we can't load a usable pattern out','line_number':151,'multiline':False]
['text':' of a resource.','line_number':152,'multiline':False]
['text':' "yyyyMMdd hh:mm a" ','line_number':156,'multiline':True]
['text':' This prefix is designed to NEVER MATCH real text, in order to','line_number':158,'multiline':False]
['text':' suppress the parsing of negative numbers.  Adjust as needed (if','line_number':159,'multiline':False]
['text':' this becomes valid Unicode).','line_number':160,'multiline':False]
['text':'*
 * These are the tags we expect to see in normal resource bundle files associated
 * with a locale.
 ','line_number':163,'multiline':True]
['text':'static const UChar gEtcUTC[] = {0x45, 0x74, 0x63, 0x2F, 0x55, 0x54, 0x43, 0x00}; // "Etc/UTC"','line_number':169,'multiline':False]
['text':' Single quote','line_number':170,'multiline':False]
['text':'
 * The field range check bias for each UDateFormatField.
 * The bias is added to the minimum and maximum values
 * before they are compared to the parsed number.
 * For example, the calendar stores zero-based month numbers
 * but the parsed month numbers start at 1, so the bias is 1.
 *
 * A value of -1 means that the value is not checked.
 ','line_number':172,'multiline':True]
['text':' 'G' - UDAT_ERA_FIELD','line_number':182,'multiline':False]
['text':' 'y' - UDAT_YEAR_FIELD','line_number':183,'multiline':False]
['text':' 'M' - UDAT_MONTH_FIELD','line_number':184,'multiline':False]
['text':' 'd' - UDAT_DATE_FIELD','line_number':185,'multiline':False]
['text':' 'k' - UDAT_HOUR_OF_DAY1_FIELD','line_number':186,'multiline':False]
['text':' 'H' - UDAT_HOUR_OF_DAY0_FIELD','line_number':187,'multiline':False]
['text':' 'm' - UDAT_MINUTE_FIELD','line_number':188,'multiline':False]
['text':' 's' - UDAT_SECOND_FIELD','line_number':189,'multiline':False]
['text':' 'S' - UDAT_FRACTIONAL_SECOND_FIELD (0-999?)','line_number':190,'multiline':False]
['text':' 'E' - UDAT_DAY_OF_WEEK_FIELD (1-7?)','line_number':191,'multiline':False]
['text':' 'D' - UDAT_DAY_OF_YEAR_FIELD (1 - 366?)','line_number':192,'multiline':False]
['text':' 'F' - UDAT_DAY_OF_WEEK_IN_MONTH_FIELD (1-5?)','line_number':193,'multiline':False]
['text':' 'w' - UDAT_WEEK_OF_YEAR_FIELD (1-52?)','line_number':194,'multiline':False]
['text':' 'W' - UDAT_WEEK_OF_MONTH_FIELD (1-5?)','line_number':195,'multiline':False]
['text':' 'a' - UDAT_AM_PM_FIELD','line_number':196,'multiline':False]
['text':' 'h' - UDAT_HOUR1_FIELD','line_number':197,'multiline':False]
['text':' 'K' - UDAT_HOUR0_FIELD','line_number':198,'multiline':False]
['text':' 'z' - UDAT_TIMEZONE_FIELD','line_number':199,'multiline':False]
['text':' 'Y' - UDAT_YEAR_WOY_FIELD','line_number':200,'multiline':False]
['text':' 'e' - UDAT_DOW_LOCAL_FIELD','line_number':201,'multiline':False]
['text':' 'u' - UDAT_EXTENDED_YEAR_FIELD','line_number':202,'multiline':False]
['text':' 'g' - UDAT_JULIAN_DAY_FIELD','line_number':203,'multiline':False]
['text':' 'A' - UDAT_MILLISECONDS_IN_DAY_FIELD','line_number':204,'multiline':False]
['text':' 'Z' - UDAT_TIMEZONE_RFC_FIELD','line_number':205,'multiline':False]
['text':' 'v' - UDAT_TIMEZONE_GENERIC_FIELD','line_number':206,'multiline':False]
['text':' 'c' - UDAT_STANDALONE_DAY_FIELD','line_number':207,'multiline':False]
['text':' 'L' - UDAT_STANDALONE_MONTH_FIELD','line_number':208,'multiline':False]
['text':' 'Q' - UDAT_QUARTER_FIELD (1-4?)','line_number':209,'multiline':False]
['text':' 'q' - UDAT_STANDALONE_QUARTER_FIELD','line_number':210,'multiline':False]
['text':' 'V' - UDAT_TIMEZONE_SPECIAL_FIELD','line_number':211,'multiline':False]
['text':' 'U' - UDAT_YEAR_NAME_FIELD','line_number':212,'multiline':False]
['text':' 'O' - UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD','line_number':213,'multiline':False]
['text':' 'X' - UDAT_TIMEZONE_ISO_FIELD','line_number':214,'multiline':False]
['text':' 'x' - UDAT_TIMEZONE_ISO_LOCAL_FIELD','line_number':215,'multiline':False]
['text':' 'r' - UDAT_RELATED_YEAR_FIELD','line_number':216,'multiline':False]
['text':' ':' - UDAT_TIME_SEPARATOR_FIELD','line_number':218,'multiline':False]
['text':' (no pattern character currently) - UDAT_TIME_SEPARATOR_FIELD','line_number':220,'multiline':False]
['text':' When calendar uses hebr numbering (i.e. he@calendar=hebrew),','line_number':224,'multiline':False]
['text':' offset the years within the current millenium down to 1-999','line_number':225,'multiline':False]
['text':' no matter what the locale's default number format looked like, we want','line_number':249,'multiline':False]
['text':' to modify it so that it doesn't use thousands separators, doesn't always','line_number':250,'multiline':False]
['text':' show the decimal point, and recognizes integers only when parsing','line_number':251,'multiline':False]
['text':' To prevent "Jan 1.00, 1997.00"','line_number':259,'multiline':False]
['text':' Single threaded cache of non const NumberFormats. Designed to be stack','line_number':327,'multiline':False]
['text':' allocated and used for a single format call.','line_number':328,'multiline':False]
['text':' Returns a non-const clone of nf which can be safely modified.','line_number':334,'multiline':False]
['text':' Subsequent calls with same nf will return the same non-const clone.','line_number':335,'multiline':False]
['text':' This object maintains ownership of all returned non-const','line_number':336,'multiline':False]
['text':' NumberFormat objects. On memory allocation error returns NULL.','line_number':337,'multiline':False]
['text':' Caller must check for NULL return value.','line_number':338,'multiline':False]
['text':' +1 extra for sentinel. If each field had its own NumberFormat, this','line_number':356,'multiline':False]
['text':' cache would have to allocate UDAT_FIELD_COUNT mutable versions worst','line_number':357,'multiline':False]
['text':' case.','line_number':358,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':364,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':381,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':395,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':415,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':439,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':461,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':487,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':509,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':531,'multiline':False]
['text':' Not for public consumption; used by DateFormat','line_number':533,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':551,'multiline':False]
['text':'*
 * Not for public consumption; used by DateFormat.  This constructor
 * never fails.  If the resource data is not available, it uses the
 * the last resort symbols.
 ','line_number':553,'multiline':True]
['text':' This constructor doesn't fail; it uses last resort data','line_number':575,'multiline':False]
['text':' test for NULL ','line_number':577,'multiline':True]
['text':'----------------------------------------------------------------------','line_number':593,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':607,'multiline':False]
['text':' TimeZoneFormat in ICU4C only depends on a locale for now','line_number':632,'multiline':False]
['text':' forces lazy instantiation with the other locale','line_number':635,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':663,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':671,'multiline':False]
['text':' The DateFormat::operator== check for fCapitalizationContext equality above','line_number':677,'multiline':False]
['text':'   is sufficient to check equality of all derived context-related data.','line_number':678,'multiline':False]
['text':' DateFormat::operator== guarantees following cast is safe','line_number':679,'multiline':False]
['text':' Check for pathological object','line_number':682,'multiline':False]
['text':' Check for pathological object','line_number':683,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':691,'multiline':False]
['text':' called by several constructors to load pattern data from the resources','line_number':698,'multiline':False]
['text':' We will need the calendar to know what type of symbols to load.','line_number':701,'multiline':False]
['text':' create a symbols object from the locale','line_number':720,'multiline':False]
['text':' test for NULL ','line_number':723,'multiline':True]
['text':' if the pattern should include both date and time information, use the date/time','line_number':734,'multiline':False]
['text':' pattern string as a guide to tell use how to glue together the appropriate date','line_number':735,'multiline':False]
['text':' and time pattern strings.','line_number':736,'multiline':False]
['text':' Get proper date time format','line_number':794,'multiline':False]
['text':' if the pattern includes just time data or just date date, load the appropriate','line_number':802,'multiline':False]
['text':' pattern string from the resources','line_number':803,'multiline':False]
['text':' setTo() - see DateFormatSymbols::assignArray comments','line_number':804,'multiline':False]
['text':' and if it includes _neither_, that's an error','line_number':858,'multiline':False]
['text':' finally, finish initializing by creating a Calendar and a NumberFormat','line_number':862,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':866,'multiline':False]
['text':' We don't need to check that the row count is >= 1, since all 2d arrays have at','line_number':883,'multiline':False]
['text':' least one row','line_number':884,'multiline':False]
['text':'fNumberFormat->setLenient(TRUE); // Java uses a custom DateNumberFormat to format/parse','line_number':889,'multiline':False]
['text':' Initialize the fields we use to disambiguate ambiguous years. Separate
 * so we can call it from readObject().
 ','line_number':902,'multiline':True]
['text':'
 * Initialize the boolean attributes. Separate so we can call it from all constructors.
 ','line_number':919,'multiline':True]
['text':' Define one-century window into which to disambiguate dates using
 * two-digit years. Make public in JDK 1.2.
 ','line_number':932,'multiline':True]
['text':'----------------------------------------------------------------------','line_number':953,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':963,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':973,'multiline':False]
['text':' Different calendar type','line_number':985,'multiline':False]
['text':' We use the time and time zone from the input calendar, but','line_number':986,'multiline':False]
['text':' do not use the input calendar for field calculation.','line_number':987,'multiline':False]
['text':' Create temporary cache of mutable number format objects. This way','line_number':1006,'multiline':False]
['text':' subFormat won't have to clone the const NumberFormat for each field.','line_number':1007,'multiline':False]
['text':' if several fields share the same NumberFormat, which will almost','line_number':1008,'multiline':False]
['text':' always be the case, this is a big save.','line_number':1009,'multiline':False]
['text':' loop through the pattern string character by character','line_number':1011,'multiline':False]
['text':' Use subFormat() to format a repeated pattern character','line_number':1015,'multiline':False]
['text':' when a different pattern or non-pattern character is seen','line_number':1016,'multiline':False]
['text':' Consecutive single quotes are a single quote literal,','line_number':1022,'multiline':False]
['text':' either outside of quotes or between quotes','line_number':1023,'multiline':False]
['text':' ch is a date-time pattern character to be interpreted','line_number':1032,'multiline':False]
['text':' by subFormat(); count the number of times it is repeated','line_number':1033,'multiline':False]
['text':' Append quoted characters and unquoted non-pattern characters','line_number':1038,'multiline':False]
['text':' Format the last item in the pattern, if any','line_number':1043,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':1055,'multiline':False]
['text':' Map calendar field into calendar field level.
 * the larger the level, the smaller the field unit.
 * For example, UCAL_ERA level is 0, UCAL_YEAR level is 10,
 * UCAL_MONTH level is 20.
 * NOTE: if new fields adds in, the table needs to update.
 ','line_number':1057,'multiline':True]
['text':'GyM','line_number':1066,'multiline':True]
['text':'wW','line_number':1067,'multiline':True]
['text':'dDEF','line_number':1068,'multiline':True]
['text':'ahHm','line_number':1069,'multiline':True]
['text':'sS','line_number':1070,'multiline':True]
['text':'z?Y','line_number':1071,'multiline':True]
['text':'eug','line_number':1072,'multiline':True]
['text':'A?.','line_number':1073,'multiline':True]
['text':' Map date field LETTER into calendar field level.','line_number':1077,'multiline':False]
['text':' the larger the level, the smaller the field unit.','line_number':1078,'multiline':False]
['text':' NOTE: if new fields adds in, the table needs to update.','line_number':1079,'multiline':False]
['text':'','line_number':1082,'multiline':False]
['text':'       !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /','line_number':1084,'multiline':False]
['text':'   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?','line_number':1087,'multiline':False]
['text':'   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?','line_number':1090,'multiline':False]
['text':'   @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O','line_number':1093,'multiline':False]
['text':'   P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _','line_number':1095,'multiline':False]
['text':'   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o','line_number':1097,'multiline':False]
['text':'   p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~','line_number':1099,'multiline':False]
['text':'','line_number':1108,'multiline':False]
['text':'','line_number':1110,'multiline':False]
['text':'','line_number':1112,'multiline':False]
['text':'','line_number':1114,'multiline':False]
['text':'         !      "      #      $      %      &      '','line_number':1116,'multiline':False]
['text':'  (      )      *      +      ,      -      .      /','line_number':1118,'multiline':False]
['text':'  0      1      2      3      4      5      6      7','line_number':1120,'multiline':False]
['text':'  8      9      :      ;      <      =      >      ?','line_number':1123,'multiline':False]
['text':'  8      9      :      ;      <      =      >      ?','line_number':1126,'multiline':False]
['text':'  @      A      B      C      D      E      F      G','line_number':1129,'multiline':False]
['text':'  H      I      J      K      L      M      N      O','line_number':1131,'multiline':False]
['text':'  P      Q      R      S      T      U      V      W','line_number':1133,'multiline':False]
['text':'  X      Y      Z      [      \      ]      ^      _','line_number':1135,'multiline':False]
['text':'  `      a      b      c      d      e      f      g','line_number':1137,'multiline':False]
['text':'  h      i      j      k      l      m      n      o','line_number':1139,'multiline':False]
['text':'  p      q      r      s      t      u      v      w','line_number':1141,'multiline':False]
['text':'  x      y      z      {      |      }      ~','line_number':1143,'multiline':False]
['text':' Map index into pattern character string to Calendar field number.','line_number':1150,'multiline':False]
['text':'GyM','line_number':1154,'multiline':True]
['text':'dkH','line_number':1155,'multiline':True]
['text':'msS','line_number':1156,'multiline':True]
['text':'EDF','line_number':1157,'multiline':True]
['text':'wWa','line_number':1158,'multiline':True]
['text':'hKz','line_number':1159,'multiline':True]
['text':'Yeu','line_number':1160,'multiline':True]
['text':'gAZ','line_number':1161,'multiline':True]
['text':'v','line_number':1162,'multiline':True]
['text':'c','line_number':1163,'multiline':True]
['text':'L','line_number':1164,'multiline':True]
['text':'Q','line_number':1165,'multiline':True]
['text':'q','line_number':1166,'multiline':True]
['text':'V','line_number':1167,'multiline':True]
['text':'U','line_number':1168,'multiline':True]
['text':'O','line_number':1169,'multiline':True]
['text':'Xx','line_number':1170,'multiline':True]
['text':'r','line_number':1171,'multiline':True]
['text':'bB','line_number':1172,'multiline':True]
['text':' no mappings to calendar fields','line_number':1172,'multiline':False]
['text':':','line_number':1174,'multiline':True]
['text':' => no useful mapping to any calendar field ','line_number':1174,'multiline':True]
['text':'no pattern char for UDAT_TIME_SEPARATOR_FIELD','line_number':1176,'multiline':True]
['text':' => no useful mapping to any calendar field ','line_number':1176,'multiline':True]
['text':' Map index into pattern character string to DateFormat field number','line_number':1180,'multiline':False]
['text':'GyM','line_number':1183,'multiline':True]
['text':'dkH','line_number':1184,'multiline':True]
['text':'msS','line_number':1185,'multiline':True]
['text':'EDF','line_number':1186,'multiline':True]
['text':'wWa','line_number':1187,'multiline':True]
['text':'hKz','line_number':1188,'multiline':True]
['text':'Yeu','line_number':1189,'multiline':True]
['text':'gAZ','line_number':1190,'multiline':True]
['text':'v','line_number':1191,'multiline':True]
['text':'c','line_number':1192,'multiline':True]
['text':'L','line_number':1193,'multiline':True]
['text':'Q','line_number':1194,'multiline':True]
['text':'q','line_number':1195,'multiline':True]
['text':'V','line_number':1196,'multiline':True]
['text':'U','line_number':1197,'multiline':True]
['text':'O','line_number':1198,'multiline':True]
['text':'Xx','line_number':1199,'multiline':True]
['text':'r','line_number':1200,'multiline':True]
['text':'bB','line_number':1201,'multiline':True]
['text':':','line_number':1203,'multiline':True]
['text':'no pattern char for UDAT_TIME_SEPARATOR_FIELD','line_number':1205,'multiline':True]
['text':'----------------------------------------------------------------------','line_number':1209,'multiline':False]
['text':'*
 * Append symbols[value] to dst.  Make sure the array index is not out
 * of bounds.
 ','line_number':1211,'multiline':True]
['text':'----------------------------------------------------------------------','line_number':1239,'multiline':False]
['text':' Simple override string such as "hebrew"','line_number':1288,'multiline':False]
['text':' Field specific override string such as "y=hebrew"','line_number':1291,'multiline':False]
['text':' We just need the first character.','line_number':1293,'multiline':False]
['text':' See if the numbering system is in the override list, if not, then add it.','line_number':1297,'multiline':False]
['text':' Now that we have an appropriate number formatter, fill in the appropriate spaces in the','line_number':1338,'multiline':False]
['text':' number formatters table.','line_number':1339,'multiline':False]
['text':' if the pattern character is unrecognized, signal an error and bail out','line_number':1360,'multiline':False]
['text':'---------------------------------------------------------------------','line_number':1380,'multiline':False]
['text':' this function gets called by format() to produce the appropriate substitution','line_number':1396,'multiline':False]
['text':' text for an individual pattern symbol (e.g., "HH" or "yyyy")','line_number':1397,'multiline':False]
['text':' if the pattern character is unrecognized, signal an error and dump out','line_number':1408,'multiline':False]
['text':' pattern char 'l' (SMALL LETTER L) just gets ignored','line_number':1411,'multiline':False]
['text':' Don't get value unless it is useful','line_number':1419,'multiline':False]
['text':' for any "G" symbol, write out the appropriate era string','line_number':1436,'multiline':False]
['text':' "GGGG" is wide era name, "GGGGG" is narrow era name, anything else is abbreviated name','line_number':1437,'multiline':False]
['text':' as in ICU4J','line_number':1440,'multiline':False]
['text':' the Calendar YEAR field runs 1 through 60 for cyclic years','line_number':1457,'multiline':False]
['text':' else fall through to numeric year handling, do not break here','line_number':1461,'multiline':False]
['text':' OLD: for "yyyy", write out the whole year; for "yy", write out the last 2 digits','line_number':1464,'multiline':False]
['text':' NEW: UTS#35:','line_number':1465,'multiline':False]
['text':'Year         y     yy     yyy     yyyy     yyyyy','line_number':1466,'multiline':False]
['text':'AD 1         1     01     001     0001     00001','line_number':1467,'multiline':False]
['text':'AD 12       12     12     012     0012     00012','line_number':1468,'multiline':False]
['text':'AD 123     123     23     123     0123     00123','line_number':1469,'multiline':False]
['text':'AD 1234   1234     34    1234     1234     01234','line_number':1470,'multiline':False]
['text':'AD 12345 12345     45   12345    12345     12345','line_number':1471,'multiline':False]
['text':' for "MMMM"/"LLLL", write out the whole month name, for "MMM"/"LLL", write out the month','line_number':1483,'multiline':False]
['text':' abbreviation, for "M"/"L" or "MM"/"LL", write out the month as a number with the','line_number':1484,'multiline':False]
['text':' appropriate number of digits','line_number':1485,'multiline':False]
['text':' for "MMMMM"/"LLLLL", use the narrow form','line_number':1486,'multiline':False]
['text':' Show alternate form for Adar II in leap years in Hebrew calendar.','line_number':1492,'multiline':False]
['text':' Adjust the month number down 1 in Hebrew non-leap years, i.e. Adar is 6, not 7.','line_number':1494,'multiline':False]
['text':' should consolidate the next section by using arrays of pointers & counts for the right symbols...','line_number':1499,'multiline':False]
['text':' for "k" and "kk", write out the hour, adjusting midnight to appear as "24"','line_number':1538,'multiline':False]
['text':' Fractional seconds left-justify','line_number':1547,'multiline':False]
['text':' for "ee" or "e", use local numeric day-of-the-week','line_number':1565,'multiline':False]
['text':' for "EEEEEE" or "eeeeee", write out the short day-of-the-week name','line_number':1566,'multiline':False]
['text':' for "EEEEE" or "eeeee", write out the narrow day-of-the-week name','line_number':1567,'multiline':False]
['text':' for "EEEE" or "eeee", write out the wide day-of-the-week name','line_number':1568,'multiline':False]
['text':' for "EEE" or "EE" or "E" or "eee", write out the abbreviated day-of-the-week name','line_number':1569,'multiline':False]
['text':' fall through to EEEEE-EEE handling, but for that we don't want local day-of-week,','line_number':1575,'multiline':False]
['text':' we want standard day-of-week, so first fix value to work for EEEEE-EEE.','line_number':1576,'multiline':False]
['text':' fall through, do not break here','line_number':1581,'multiline':False]
['text':' for "ccc", write out the abbreviated day-of-the-week name','line_number':1603,'multiline':False]
['text':' for "cccc", write out the wide day-of-the-week name','line_number':1604,'multiline':False]
['text':' for "ccccc", use the narrow day-of-the-week name','line_number':1605,'multiline':False]
['text':' for "ccccc", use the short day-of-the-week name','line_number':1606,'multiline':False]
['text':' fall through to alpha DOW handling, but for that we don't want local day-of-week,','line_number':1612,'multiline':False]
['text':' we want standard day-of-week, so first fix value.','line_number':1613,'multiline':False]
['text':' count == 3','line_number':1630,'multiline':False]
['text':' for "a" symbol, write out the whole AM/PM string','line_number':1637,'multiline':False]
['text':' if we see pattern character for UDAT_TIME_SEPARATOR_FIELD (none currently defined),','line_number':1648,'multiline':False]
['text':' write out the time separator string. Leave support in for future definition.','line_number':1649,'multiline':False]
['text':' for "h" and "hh", write out the hour, adjusting noon and midnight to show up','line_number':1657,'multiline':False]
['text':' as "12"','line_number':1658,'multiline':False]
['text':' 'z'','line_number':1666,'multiline':False]
['text':' 'Z'','line_number':1667,'multiline':False]
['text':' 'v'','line_number':1668,'multiline':False]
['text':' 'V'','line_number':1669,'multiline':False]
['text':' 'O'','line_number':1670,'multiline':False]
['text':' 'X'','line_number':1671,'multiline':False]
['text':' 'x'','line_number':1672,'multiline':False]
['text':' "z", "zz", "zzz"','line_number':1681,'multiline':False]
['text':' "zzzz" or longer','line_number':1685,'multiline':False]
['text':' "Z"','line_number':1692,'multiline':False]
['text':' "ZZZZZ"','line_number':1695,'multiline':False]
['text':' "ZZ", "ZZZ", "ZZZZ"','line_number':1698,'multiline':False]
['text':' "v"','line_number':1704,'multiline':False]
['text':' "vvvv"','line_number':1708,'multiline':False]
['text':' "V"','line_number':1715,'multiline':False]
['text':' "VV"','line_number':1718,'multiline':False]
['text':' "VVV"','line_number':1721,'multiline':False]
['text':' "VVVV"','line_number':1724,'multiline':False]
['text':' "O"','line_number':1731,'multiline':False]
['text':' "OOOO"','line_number':1734,'multiline':False]
['text':' "X"','line_number':1740,'multiline':False]
['text':' "XX"','line_number':1743,'multiline':False]
['text':' "XXX"','line_number':1746,'multiline':False]
['text':' "XXXX"','line_number':1749,'multiline':False]
['text':' "XXXXX"','line_number':1752,'multiline':False]
['text':' "x"','line_number':1758,'multiline':False]
['text':' "xx"','line_number':1761,'multiline':False]
['text':' "xxx"','line_number':1764,'multiline':False]
['text':' "xxxx"','line_number':1767,'multiline':False]
['text':' "xxxxx"','line_number':1770,'multiline':False]
['text':' Note: "midnight" can be ambiguous as to whether it refers to beginning of day or end of day.','line_number':1809,'multiline':False]
['text':' For ICU 57 output of "midnight" is temporarily suppressed.','line_number':1810,'multiline':False]
['text':' For "midnight" and "noon":','line_number':1812,'multiline':False]
['text':' Time, as displayed, must be exactly noon or midnight.','line_number':1813,'multiline':False]
['text':' This means minutes and seconds, if present, must be zero.','line_number':1814,'multiline':False]
['text':'hour == 0 ||','line_number':1815,'multiline':True]
['text':' Stealing am/pm value to use as our array index.','line_number':1818,'multiline':False]
['text':' It works out: am/midnight are both 0, pm/noon are both 1,','line_number':1819,'multiline':False]
['text':' 12 am is 12 midnight, and 12 pm is 12 noon.','line_number':1820,'multiline':False]
['text':' count == 5','line_number':1827,'multiline':False]
['text':' toAppend is NULL if time isn't exactly midnight or noon (as displayed).','line_number':1832,'multiline':False]
['text':' toAppend is bogus if time is midnight or noon, but no localized string exists.','line_number':1833,'multiline':False]
['text':' In either case, fall back to am/pm.','line_number':1834,'multiline':False]
['text':' Reformat with identical arguments except ch, now changed to 'a'.','line_number':1836,'multiline':False]
['text':' TODO: Maybe fetch the DayperiodRules during initialization (instead of at the first','line_number':1848,'multiline':False]
['text':' loading of an instance) if a relevant pattern character (b or B) is used.','line_number':1849,'multiline':False]
['text':' Data doesn't conform to spec, therefore loading failed.','line_number':1852,'multiline':False]
['text':' Data doesn't exist for the locale we're looking for.','line_number':1856,'multiline':False]
['text':' Falling back to am/pm.','line_number':1857,'multiline':False]
['text':' Get current display time.','line_number':1863,'multiline':False]
['text':' Determine day period.','line_number':1874,'multiline':False]
['text':' Rule set exists, therefore periodType can't be UNKNOWN.','line_number':1884,'multiline':False]
['text':' Get localized string.','line_number':1885,'multiline':False]
['text':' Note: "midnight" can be ambiguous as to whether it refers to beginning of day or end of day.','line_number':1890,'multiline':False]
['text':' For ICU 57 output of "midnight" is temporarily suppressed.','line_number':1891,'multiline':False]
['text':' i.e. short','line_number':1898,'multiline':False]
['text':' count == 5','line_number':1901,'multiline':False]
['text':' Fallback schedule:','line_number':1906,'multiline':False]
['text':' Midnight/Noon -> General Periods -> AM/PM.','line_number':1907,'multiline':False]
['text':' Midnight/Noon -> General Periods.','line_number':1909,'multiline':False]
['text':' i.e. short','line_number':1917,'multiline':False]
['text':' count == 5','line_number':1920,'multiline':False]
['text':' General Periods -> AM/PM.','line_number':1925,'multiline':False]
['text':' all of the other pattern symbols can be formatted as simple numbers with','line_number':1939,'multiline':False]
['text':' appropriate zero padding','line_number':1940,'multiline':False]
['text':' if first field, check to see whether we need to and are able to titlecase it','line_number':1946,'multiline':False]
['text':' titlecase = FALSE;','line_number':1960,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':1974,'multiline':False]
['text':' We successfully set the default number format. Now delete the overrides','line_number':1981,'multiline':False]
['text':' (can't fail).','line_number':1982,'multiline':False]
['text':' We must ensure fSharedNumberFormatters is allocated.','line_number':1996,'multiline':False]
['text':' if the pattern character is unrecognized, signal an error and bail out','line_number':2011,'multiline':False]
['text':' Set the number formatter in the table','line_number':2019,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':2035,'multiline':False]
['text':' 3rd arg is there to speed up processing','line_number':2047,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':2051,'multiline':False]
['text':'*
 * Return true if the given format character, occuring count
 * times, represents a numeric field.
 ','line_number':2053,'multiline':True]
['text':' not at any field','line_number':2064,'multiline':False]
['text':' not at any field','line_number':2070,'multiline':False]
['text':' not after any field','line_number':2081,'multiline':False]
['text':' not after any field','line_number':2087,'multiline':False]
['text':' Hold the day period until everything else is parsed, because we need','line_number':2106,'multiline':False]
['text':' the hour to interpret time correctly.','line_number':2107,'multiline':False]
['text':' For parsing abutting numeric fields. 'abutPat' is the','line_number':2116,'multiline':False]
['text':' offset into 'pattern' of the first of 2 or more abutting','line_number':2117,'multiline':False]
['text':' numeric fields.  'abutStart' is the offset into 'text'','line_number':2118,'multiline':False]
['text':' where parsing the fields begins. 'abutPass' starts off as 0','line_number':2119,'multiline':False]
['text':' and increments each time we try to parse the fields.','line_number':2120,'multiline':False]
['text':' If >=0, we are in a run of abutting numeric fields','line_number':2121,'multiline':False]
['text':' Different calendar type','line_number':2131,'multiline':False]
['text':' We use the time/zone from the input calendar, but','line_number':2132,'multiline':False]
['text':' do not use the input calendar for field calculation.','line_number':2133,'multiline':False]
['text':' this will delete numericLeapMonthFormatter','line_number':2154,'multiline':False]
['text':' Handle alphabetic field characters.','line_number':2161,'multiline':False]
['text':' Count the length of this field specifier','line_number':2165,'multiline':False]
['text':' Determine if there is an abutting numeric field.','line_number':2175,'multiline':False]
['text':' Record the start of a set of abutting numeric fields.','line_number':2176,'multiline':False]
['text':' End of any abutting fields','line_number':2184,'multiline':False]
['text':' Handle fields within a run of abutting numeric fields.  Take','line_number':2187,'multiline':False]
['text':' the pattern "HHmmss" as an example. We will try to parse','line_number':2188,'multiline':False]
['text':' 2/2/2 characters of the input text, then if that fails,','line_number':2189,'multiline':False]
['text':' 1/2/2.  We only adjust the width of the leftmost field; the','line_number':2190,'multiline':False]
['text':' others remain fixed.  This allows "123456" => 12:34:56, but','line_number':2191,'multiline':False]
['text':' "12345" => 1:23:45.  Likewise, for the pattern "yyyyMMdd" we','line_number':2192,'multiline':False]
['text':' try 4/2/2, 3/2/2, 2/2/2, and finally 1/2/2.','line_number':2193,'multiline':False]
['text':' If we are at the start of a run of abutting fields, then','line_number':2195,'multiline':False]
['text':' shorten this field in each pass.  If we can't shorten','line_number':2196,'multiline':False]
['text':' this field any more, then the parse of this set of','line_number':2197,'multiline':False]
['text':' abutting numeric fields has failed.','line_number':2198,'multiline':False]
['text':' If the parse fails anywhere in the run, back up to the','line_number':2210,'multiline':False]
['text':' start of the run and retry.','line_number':2211,'multiline':False]
['text':' Handle non-numeric fields and non-abutting numeric','line_number':2219,'multiline':False]
['text':' fields.','line_number':2220,'multiline':False]
['text':' pattern char 'l' (SMALL LETTER L) just gets ignored','line_number':2221,'multiline':False]
['text':' era not present, in special cases allow this to continue','line_number':2226,'multiline':False]
['text':' from the position where the era was expected','line_number':2227,'multiline':False]
['text':' move to next pattern character','line_number':2231,'multiline':False]
['text':' check for whitespace','line_number':2234,'multiline':False]
['text':' Advance over run in pattern','line_number':2237,'multiline':False]
['text':' Handle literal pattern characters.  These are any','line_number':2253,'multiline':False]
['text':' quoted characters and non-alphabetic unquoted','line_number':2254,'multiline':False]
['text':' characters.','line_number':2255,'multiline':False]
['text':' End of any abutting fields','line_number':2258,'multiline':False]
['text':' Special hack for trailing "." after non-numeric field.','line_number':2267,'multiline':False]
['text':' only do if the last field is not numeric','line_number':2269,'multiline':False]
['text':' skip the extra "."','line_number':2271,'multiline':False]
['text':' If dayPeriod is set, use it in conjunction with hour-of-day to determine am/pm.','line_number':2275,'multiline':False]
['text':' If hour is not set, set time to the midpoint of current day period, overwriting','line_number':2281,'multiline':False]
['text':' minutes if it's set.','line_number':2282,'multiline':False]
['text':' If we can't get midPoint we do nothing.','line_number':2285,'multiline':False]
['text':' Truncate midPoint toward zero to get the hour.','line_number':2287,'multiline':False]
['text':' Any leftover means it was a half-hour.','line_number':2288,'multiline':False]
['text':' No need to set am/pm because hour-of-day is set last therefore takes precedence.','line_number':2292,'multiline':False]
['text':' Hour is parsed in 24-hour format.','line_number':2299,'multiline':False]
['text':' Hour is parsed in 12-hour format.','line_number':2301,'multiline':False]
['text':' cal.get() turns 12 to 0 for 12-hour time; change 0 to 12','line_number':2303,'multiline':False]
['text':' so 0 unambiguously means a 24-hour time from above.','line_number':2304,'multiline':False]
['text':' If hour-of-day is 0 or 13 thru 23 then input time in unambiguously in 24-hour format.','line_number':2310,'multiline':False]
['text':' Make hour-of-day take precedence over (hour + am/pm) by setting it again.','line_number':2312,'multiline':False]
['text':' We have a 12-hour time and need to choose between am and pm.','line_number':2315,'multiline':False]
['text':' Behave as if dayPeriod spanned 6 hours each way from its center point.','line_number':2316,'multiline':False]
['text':' This will parse correctly for consistent time + period (e.g. 10 at night) as','line_number':2317,'multiline':False]
['text':' well as provide a reasonable recovery for inconsistent time + period (e.g.','line_number':2318,'multiline':False]
['text':' 9 in the afternoon).','line_number':2319,'multiline':False]
['text':' Assume current time is in the AM.','line_number':2321,'multiline':False]
['text':' - Change 12 back to 0 for easier handling of 12am.','line_number':2322,'multiline':False]
['text':' - Append minutes as fractional hours because e.g. 8:15 and 8:45 could be parsed','line_number':2323,'multiline':False]
['text':' into different half-days if center of dayPeriod is at 14:30.','line_number':2324,'multiline':False]
['text':' - cal.get(MINUTE) will return 0 if MINUTE is unset, which works.','line_number':2325,'multiline':False]
['text':' Assume current time is in the AM.','line_number':2333,'multiline':False]
['text':' Assumption holds; set time as such.','line_number':2335,'multiline':False]
['text':' At this point the fields of Calendar have been set.  Calendar','line_number':2345,'multiline':False]
['text':' will fill in default values for missing fields when the time','line_number':2346,'multiline':False]
['text':' is computed.','line_number':2347,'multiline':False]
['text':' This part is a problem:  When we call parsedDate.after, we compute the time.','line_number':2351,'multiline':False]
['text':' Take the date April 3 2004 at 2:30 am.  When this is first set up, the year','line_number':2352,'multiline':False]
['text':' will be wrong if we're parsing a 2-digit year pattern.  It will be 1904.','line_number':2353,'multiline':False]
['text':' April 3 1904 is a Sunday (unlike 2004) so it is the DST onset day.  2:30 am','line_number':2354,'multiline':False]
['text':' is therefore an "impossible" time, since the time goes from 1:59 to 3:00 am','line_number':2355,'multiline':False]
['text':' on that day.  It is therefore parsed out to fields as 3:30 am.  Then we','line_number':2356,'multiline':False]
['text':' add 100 years, and get April 3 2004 at 3:30 am.  Note that April 3 2004 is','line_number':2357,'multiline':False]
['text':' a Saturday, so it can have a 2:30 am -- and it should. [LIU]','line_number':2358,'multiline':False]
['text':'
        UDate parsedDate = calendar.getTime();
        if( ambiguousYear[0] && !parsedDate.after(fDefaultCenturyStart) ) {
            calendar.add(Calendar.YEAR, 100);
            parsedDate = calendar.getTime();
        }
    ','line_number':2359,'multiline':True]
['text':' Because of the above condition, save off the fields in case we need to readjust.','line_number':2366,'multiline':False]
['text':' The procedure we use here is not particularly efficient, but there is no other','line_number':2367,'multiline':False]
['text':' way to do this given the API restrictions present in Calendar.  We minimize','line_number':2368,'multiline':False]
['text':' inefficiency by only performing this computation when it might apply, that is,','line_number':2369,'multiline':False]
['text':' when the two-digit year is equal to the start year, and thus might fall at the','line_number':2370,'multiline':False]
['text':' front or the back of the default century.  This only works because we adjust','line_number':2371,'multiline':False]
['text':' the year correctly to start with in other cases -- see subParse().','line_number':2372,'multiline':False]
['text':' If this is true then the two-digit year == the default start year','line_number':2373,'multiline':False]
['text':' We need a copy of the fields, and we need to avoid triggering a call to','line_number':2375,'multiline':False]
['text':' complete(), which will recalculate the fields.  Since we can't access','line_number':2376,'multiline':False]
['text':' the fields[] array in Calendar, we clone the entire object.  This will','line_number':2377,'multiline':False]
['text':' stop working if Calendar.clone() is ever rewritten to call complete().','line_number':2378,'multiline':False]
['text':' Check for failed cloning.','line_number':2382,'multiline':False]
['text':' {sfb} check internalGetDefaultCenturyStart','line_number':2388,'multiline':False]
['text':' We can't use add here because that does a complete() first.','line_number':2390,'multiline':False]
['text':' Check for failed cloning.','line_number':2398,'multiline':False]
['text':' Get local millis','line_number':2413,'multiline':False]
['text':' Make sure parsed time zone type (Standard or Daylight)','line_number':2418,'multiline':False]
['text':' matches the rule used by the parsed time zone.','line_number':2419,'multiline':False]
['text':' No good way to resolve ambiguous time at transition,','line_number':2430,'multiline':False]
['text':' but following code work in most case.','line_number':2431,'multiline':False]
['text':' Now, compare the results with parsed type, either standard or daylight saving time','line_number':2435,'multiline':False]
['text':' Override DST_OFFSET = 0 in the result calendar','line_number':2439,'multiline':False]
['text':' tztype == TZTYPE_DST','line_number':2442,'multiline':False]
['text':' We use the nearest daylight saving time rule.','line_number':2446,'multiline':False]
['text':' Search for DST rule before or on the time','line_number':2452,'multiline':False]
['text':' Search for DST rule after the time','line_number':2465,'multiline':False]
['text':' final fallback','line_number':2495,'multiline':False]
['text':' Set the parsed result if local calendar is used','line_number':2506,'multiline':False]
['text':' instead of the input calendar','line_number':2507,'multiline':False]
['text':' If any Calendar calls failed, we pretend that we','line_number':2520,'multiline':False]
['text':' couldn't parse the string, when in reality this isn't quite accurate--','line_number':2521,'multiline':False]
['text':' we did parse it; the Calendar calls just failed.','line_number':2522,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':2529,'multiline':False]
['text':' There may be multiple strings in the data[] array which begin with','line_number':2546,'multiline':False]
['text':' the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).','line_number':2547,'multiline':False]
['text':' We keep track of the longest match, and return that.  Note that this','line_number':2548,'multiline':False]
['text':' unfortunately requires us to test all array elements.','line_number':2549,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':2592,'multiline':False]
['text':' scan pattern looking for contiguous literal characters','line_number':2605,'multiline':False]
['text':' Match a quote literal ('') inside OR outside of quotes','line_number':2614,'multiline':False]
['text':' at this point, literal contains the literal text','line_number':2626,'multiline':False]
['text':' and i is the index of the next non-literal pattern character.','line_number':2627,'multiline':False]
['text':' trim leading, trailing whitespace from','line_number':2632,'multiline':False]
['text':' the literal text','line_number':2633,'multiline':False]
['text':' ignore any leading whitespace in the text','line_number':2636,'multiline':False]
['text':' TODO: should we require internal spaces','line_number':2663,'multiline':False]
['text':' in lenient mode? (There won't be any','line_number':2664,'multiline':False]
['text':' leading or trailing spaces)','line_number':2665,'multiline':False]
['text':' didn't find matching whitespace:','line_number':2667,'multiline':False]
['text':' an error in strict mode','line_number':2668,'multiline':False]
['text':' In strict mode, this run of whitespace','line_number':2672,'multiline':False]
['text':' may have been at the end.','line_number':2673,'multiline':False]
['text':' Ran out of text, or found a non-matching character:','line_number':2679,'multiline':False]
['text':' OK in lenient mode, an error in strict mode.','line_number':2680,'multiline':False]
['text':' Lenient mode and the literal input text begins with a "." and','line_number':2684,'multiline':False]
['text':' we are after a non-numeric field: We skip the "."','line_number':2685,'multiline':False]
['text':' Do not update p.','line_number':2687,'multiline':False]
['text':' if it is actual whitespace and we're whitespace lenient it's OK','line_number':2689,'multiline':False]
['text':' Lenient mode and it's just whitespace we skip it','line_number':2693,'multiline':False]
['text':' Do not update p.','line_number':2695,'multiline':False]
['text':' hack around oldleniency being a bit of a catch-all bucket and we're just adding support specifically for paritial matches','line_number':2698,'multiline':False]
['text':' At this point if we're in strict mode we have a complete match.','line_number':2709,'multiline':False]
['text':' If we're in lenient mode we may have a partial match, or no','line_number':2710,'multiline':False]
['text':' match at all.','line_number':2711,'multiline':False]
['text':' no match. Pretend it matched a run of whitespace','line_number':2713,'multiline':False]
['text':' and ignorables in the text.','line_number':2714,'multiline':False]
['text':' if we get here, we've got a complete match.','line_number':2730,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':2737,'multiline':False]
['text':' There may be multiple strings in the data[] array which begin with','line_number':2752,'multiline':False]
['text':' the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).','line_number':2753,'multiline':False]
['text':' We keep track of the longest match, and return that.  Note that this','line_number':2754,'multiline':False]
['text':' unfortunately requires us to test all array elements.','line_number':2755,'multiline':False]
['text':' Adjustment for Hebrew Calendar month Adar II','line_number':2783,'multiline':False]
['text':' only get here for cyclic year names, which match 1-based years 1-60','line_number':2788,'multiline':False]
['text':' default case option ','line_number':2813,'multiline':True]
['text':' normal match ','line_number':2818,'multiline':True]
['text':' match without trailing dot ','line_number':2820,'multiline':True]
['text':'----------------------------------------------------------------------','line_number':2827,'multiline':False]
['text':'*
 * Private member function that converts the parsed date strings into
 * timeFields. Returns -start (for ParsePosition) if failed.
 ','line_number':2835,'multiline':True]
['text':'fprintf(stderr, "%s:%d - [%c]  st=%d \n", __FILE__, __LINE__, (char) ch, start);','line_number':2856,'multiline':False]
['text':' UCAL_FIELD_COUNT if irrelevant','line_number':2867,'multiline':False]
['text':' If there are any spaces here, skip over them.  If we hit the end','line_number':2875,'multiline':False]
['text':' of the string, then fail.','line_number':2876,'multiline':False]
['text':'||','line_number':2882,'multiline':True]
['text':' We handle a few special cases here where we need to parse','line_number':2889,'multiline':False]
['text':' a number value.  We handle further, more generic cases below.  We need','line_number':2890,'multiline':False]
['text':' to handle some of them here because some fields require extra processing on','line_number':2891,'multiline':False]
['text':' the parsed value.','line_number':2892,'multiline':False]
['text':' k','line_number':2893,'multiline':False]
['text':' H','line_number':2894,'multiline':False]
['text':' h','line_number':2895,'multiline':False]
['text':' K','line_number':2896,'multiline':False]
['text':' e','line_number':2897,'multiline':False]
['text':' c','line_number':2898,'multiline':False]
['text':' M','line_number':2899,'multiline':False]
['text':' L','line_number':2900,'multiline':False]
['text':' Q','line_number':2901,'multiline':False]
['text':' q','line_number':2902,'multiline':False]
['text':' y','line_number':2903,'multiline':False]
['text':' Y','line_number':2904,'multiline':False]
['text':' U (falls back to numeric)','line_number':2905,'multiline':False]
['text':' G','line_number':2906,'multiline':False]
['text':' S','line_number':2907,'multiline':False]
['text':' It would be good to unify this with the obeyCount logic below,','line_number':2910,'multiline':False]
['text':' but that's going to be difficult.','line_number':2911,'multiline':False]
['text':' suffix processing','line_number':2950,'multiline':False]
['text':' Check the range of the value','line_number':2962,'multiline':False]
['text':' Make sure that we got a number if','line_number':2973,'multiline':False]
['text':' we want one, and didn't get one','line_number':2974,'multiline':False]
['text':' if we don't want one.','line_number':2975,'multiline':False]
['text':' special range check for hours:','line_number':2981,'multiline':False]
['text':' fall through to gotNumber check','line_number':2986,'multiline':False]
['text':' these must be a number','line_number':2991,'multiline':False]
['text':' we check the rest of the fields below.','line_number':2999,'multiline':False]
['text':' check return position, if it equals -start, then matchString error','line_number':3020,'multiline':False]
['text':' special case the return code so we don't necessarily fail out until we','line_number':3021,'multiline':False]
['text':' verify no year information also','line_number':3022,'multiline':False]
['text':' If there are 3 or more YEAR pattern characters, this indicates','line_number':3029,'multiline':False]
['text':' that the year value is to be treated literally, without any','line_number':3030,'multiline':False]
['text':' two-digit year adjustments (e.g., from "01" to 2001).  Otherwise','line_number':3031,'multiline':False]
['text':' we made adjustments to place the 2-digit year in the proper','line_number':3032,'multiline':False]
['text':' century, for parsed strings from "00" to "99".  Any other string','line_number':3033,'multiline':False]
['text':' is treated literally:  "2250", "-1", "1", "002".','line_number':3034,'multiline':False]
['text':' only adjust year for patterns less than 3.','line_number':3041,'multiline':False]
['text':' Assume for example that the defaultCenturyStart is 6/18/1903.','line_number':3043,'multiline':False]
['text':' This means that two-digit years will be forced into the range','line_number':3044,'multiline':False]
['text':' 6/18/1903 to 6/17/2003.  As a result, years 00, 01, and 02','line_number':3045,'multiline':False]
['text':' correspond to 2000, 2001, and 2002.  Years 04, 05, etc. correspond','line_number':3046,'multiline':False]
['text':' to 1904, 1905, etc.  If the year is 03, then it is 2003 if the','line_number':3047,'multiline':False]
['text':' other fields specify a date before 6/18, or 1903 if they specify a','line_number':3048,'multiline':False]
['text':' date afterwards.  As a result, 03 is an ambiguous year.  All other','line_number':3049,'multiline':False]
['text':' two-digit years are unambiguous.','line_number':3050,'multiline':False]
['text':' check if this formatter even has a pivot year','line_number':3051,'multiline':False]
['text':' Delayed checking for adjustment of Hebrew month numbers in non-leap years.','line_number':3061,'multiline':False]
['text':' Comment is the same as for UDAT_Year_FIELDs - look above','line_number':3074,'multiline':False]
['text':' i.e., M or MM.','line_number':3105,'multiline':False]
['text':' When parsing month numbers from the Hebrew Calendar, we might need to adjust the month depending on whether','line_number':3107,'multiline':False]
['text':' or not it was a leap year.  We may or may not yet know what year it is, so might have to delay checking until','line_number':3108,'multiline':False]
['text':' the year is parsed.','line_number':3109,'multiline':False]
['text':' Don't want to parse the month if it is a string','line_number':3123,'multiline':False]
['text':' while pattern uses numeric style: M/MM, L/LL','line_number':3124,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3125,'multiline':False]
['text':' count >= 3 // i.e., MMM/MMMM, LLL/LLLL','line_number':3130,'multiline':False]
['text':' Want to be able to parse both short and long forms.','line_number':3131,'multiline':False]
['text':' Try count == 4 first:','line_number':3132,'multiline':False]
['text':' try MMMM','line_number':3147,'multiline':False]
['text':' try MMM','line_number':3153,'multiline':False]
['text':' try LLLL','line_number':3157,'multiline':False]
['text':' try LLL','line_number':3163,'multiline':False]
['text':' currently we do not try to parse MMMMM/LLLLL: #8860','line_number':3166,'multiline':False]
['text':' else we allowing parsing as number, below','line_number':3168,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3173,'multiline':False]
['text':' fall through to set field','line_number':3177,'multiline':False]
['text':' Fractional seconds left-justify','line_number':3184,'multiline':False]
['text':' i.e., e or ee','line_number':3203,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3205,'multiline':False]
['text':' else for eee-eeeee fall through to handling of EEE-EEEEE','line_number':3209,'multiline':False]
['text':' fall through, do not break here','line_number':3210,'multiline':False]
['text':' Want to be able to parse both short and long forms.','line_number':3214,'multiline':False]
['text':' Try count == 4 (EEEE) wide first:','line_number':3215,'multiline':False]
['text':' EEEE wide failed, now try EEE abbreviated','line_number':3222,'multiline':False]
['text':' EEE abbreviated failed, now try EEEEEE short','line_number':3228,'multiline':False]
['text':' EEEEEE short failed, now try EEEEE narrow','line_number':3234,'multiline':False]
['text':' else we allowing parsing as number, below','line_number':3242,'multiline':False]
['text':' c or cc','line_number':3248,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3250,'multiline':False]
['text':' Want to be able to parse both short and long forms.','line_number':3254,'multiline':False]
['text':' Try count == 4 (cccc) first:','line_number':3255,'multiline':False]
['text':' else we allowing parsing as number, below','line_number':3274,'multiline':False]
['text':' optionally try both wide/abbrev and narrow forms','line_number':3280,'multiline':False]
['text':' try wide/abbrev','line_number':3282,'multiline':False]
['text':' try narrow','line_number':3288,'multiline':False]
['text':' no matches for given options','line_number':3294,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3299,'multiline':False]
['text':' fall through to set field','line_number':3303,'multiline':False]
['text':' i.e., Q or QQ.','line_number':3310,'multiline':False]
['text':' Don't want to parse the month if it is a string','line_number':3312,'multiline':False]
['text':' while pattern uses numeric style: Q or QQ.','line_number':3313,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3314,'multiline':False]
['text':' count >= 3 // i.e., QQQ or QQQQ','line_number':3318,'multiline':False]
['text':' Want to be able to parse both short and long forms.','line_number':3319,'multiline':False]
['text':' Try count == 4 first:','line_number':3320,'multiline':False]
['text':' else we allowing parsing as number, below','line_number':3335,'multiline':False]
['text':' i.e., q or qq.','line_number':3342,'multiline':False]
['text':' Don't want to parse the month if it is a string','line_number':3344,'multiline':False]
['text':' while pattern uses numeric style: q or q.','line_number':3345,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3346,'multiline':False]
['text':' count >= 3 // i.e., qqq or qqqq','line_number':3350,'multiline':False]
['text':' Want to be able to parse both short and long forms.','line_number':3351,'multiline':False]
['text':' Try count == 4 first:','line_number':3352,'multiline':False]
['text':' else we allowing parsing as number, below','line_number':3367,'multiline':False]
['text':' 'z'','line_number':3373,'multiline':False]
['text':' 'Z'','line_number':3383,'multiline':False]
['text':' 'v'','line_number':3394,'multiline':False]
['text':' 'V'','line_number':3404,'multiline':False]
['text':' 'O'','line_number':3428,'multiline':False]
['text':' 'X'','line_number':3438,'multiline':False]
['text':' 'x'','line_number':3465,'multiline':False]
['text':' currently no pattern character is defined for UDAT_TIME_SEPARATOR_FIELD','line_number':3492,'multiline':False]
['text':' so we should not get here. Leave support in for future definition.','line_number':3493,'multiline':False]
['text':' Try matching a time separator.','line_number':3499,'multiline':False]
['text':' Add the default, if different from the locale.','line_number':3504,'multiline':False]
['text':' If lenient, add also the alternate, if different from the locale.','line_number':3509,'multiline':False]
['text':' => nothing to set ','line_number':3514,'multiline':True]
['text':' Only match the first two strings from the day period strings array.','line_number':3529,'multiline':False]
['text':' count == 4, but allow other counts','line_number':3542,'multiline':False]
['text':' Handle "generic" fields','line_number':3582,'multiline':False]
['text':' this is now handled below, outside the switch block','line_number':3583,'multiline':False]
['text':' Handle "generic" fields:','line_number':3586,'multiline':False]
['text':' switch default case now handled here (outside switch block) to allow','line_number':3587,'multiline':False]
['text':' parsing of some string fields as digits for lenient case','line_number':3588,'multiline':False]
['text':' Don't need suffix processing here (as in number processing at the beginning of the function);','line_number':3605,'multiline':False]
['text':' the new fields being handled as numeric values (month, weekdays, quarters) should not have suffixes.','line_number':3606,'multiline':False]
['text':' Check the range of the value','line_number':3609,'multiline':False]
['text':' For the following, need to repeat some of the "if (gotNumber)" code above:','line_number':3616,'multiline':False]
['text':' UDAT_[STANDALONE_]MONTH_FIELD, UDAT_DOW_LOCAL_FIELD, UDAT_STANDALONE_DAY_FIELD,','line_number':3617,'multiline':False]
['text':' UDAT_[STANDALONE_]QUARTER_FIELD','line_number':3618,'multiline':False]
['text':' See notes under UDAT_MONTH_FIELD case above','line_number':3621,'multiline':False]
['text':'*
 * Parse an integer using fNumberFormat.  This method is semantically
 * const, but actually may modify fNumberFormat.
 ','line_number':3661,'multiline':True]
['text':'*
 * Parse an integer using fNumberFormat up to maxDigits.
 ','line_number':3673,'multiline':True]
['text':' adjust the result to fit into','line_number':3695,'multiline':False]
['text':' the maxDigits and move the position back','line_number':3696,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3711,'multiline':False]
['text':' run through the pattern and convert any pattern symbols from the version','line_number':3719,'multiline':False]
['text':' in "from" to the corresponding character in "to".  This code takes','line_number':3720,'multiline':False]
['text':' quoted strings into account (it doesn't try to translate them), and it signals','line_number':3721,'multiline':False]
['text':' an error if a particular "pattern character" doesn't appear in "from".','line_number':3722,'multiline':False]
['text':' Depending on the values of "from" and "to" this can convert from generic','line_number':3723,'multiline':False]
['text':' to localized patterns or localized to generic.','line_number':3724,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3757,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3766,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3778,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3787,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3798,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3806,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3815,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3823,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3829,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3837,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3845,'multiline':False]
['text':' we need a new century (possibly)','line_number':3861,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3865,'multiline':False]
['text':' override the DateFormat implementation in order to','line_number':3868,'multiline':False]
['text':' lazily initialize fCapitalizationBrkIter','line_number':3869,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3890,'multiline':False]
['text':' the larger the level, the smaller the field unit.','line_number':3913,'multiline':False]
['text':' last item','line_number':3932,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3941,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3948,'multiline':False]
['text':' local variables','line_number':3953,'multiline':False]
['text':' check that we are still in range','line_number':3959,'multiline':False]
['text':' out of range, don't advance location in text','line_number':3964,'multiline':False]
['text':' get the suffix','line_number':3968,'multiline':False]
['text':' check for suffix','line_number':3979,'multiline':False]
['text':' check suffix will be encountered in the pattern','line_number':3984,'multiline':False]
['text':' check if a suffix will be encountered in the text','line_number':3987,'multiline':False]
['text':' check if a suffix was encountered in the text','line_number':3990,'multiline':False]
['text':' check for suffix match','line_number':3993,'multiline':False]
['text':' should not get here','line_number':4001,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4005,'multiline':False]
['text':' We may have a pattern like: \u200F \u0020','line_number':4016,'multiline':False]
['text':'        and input text like: \u200F \u0020','line_number':4017,'multiline':False]
['text':' Note that U+200F and U+0020 are Pattern_White_Space but only','line_number':4018,'multiline':False]
['text':' U+0020 is UWhiteSpace.  So we have to first do a direct','line_number':4019,'multiline':False]
['text':' match of the run of Pattern_White_Space in the pattern,','line_number':4020,'multiline':False]
['text':' then match any extra characters.','line_number':4021,'multiline':False]
['text':' Advance over run in pattern','line_number':4038,'multiline':False]
['text':' Advance over run in input text','line_number':4041,'multiline':False]
['text':' Must see at least one white space char in input,','line_number':4042,'multiline':False]
['text':' unless we've already matched some characters literally.','line_number':4043,'multiline':False]
['text':' If we skip UWhiteSpace in the input text, we need to skip it in the pattern.','line_number':4050,'multiline':False]
['text':' Otherwise, the previous lines may have skipped over text (such as U+00A0) that','line_number':4051,'multiline':False]
['text':' is also in the affix.','line_number':4052,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4067,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4075,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4089,'multiline':False]
['text':' Lazy TimeZoneFormat instantiation, semantically const.','line_number':4091,'multiline':False]
['text':' 0x6D == 'm'','line_number':4124,'multiline':False]
['text':' 0x73 == 's'','line_number':4127,'multiline':False]
['text':' #if !UCONFIG_NO_FORMATTING ','line_number':4136,'multiline':True]
['text':'eof','line_number':4138,'multiline':False]
