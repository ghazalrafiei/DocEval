['text':'
*******************************************************************************
* Copyright (C) 1997-2015, International Business Machines Corporation and    *
* others. All Rights Reserved.                                                *
*******************************************************************************
','line_number':1,'multiline':True]
['text':' TODO: Travis Keep: Copied from numfmt.cpp','line_number':27,'multiline':False]
['text':' TODO: Travis Keep: Copied from numfmt.cpp','line_number':32,'multiline':False]
['text':' TODO: Travis Keep: This function was copied from format.cpp','line_number':35,'multiline':False]
['text':' we are not using line number','line_number':40,'multiline':False]
['text':' for pre-context','line_number':42,'multiline':False]
['text':' subtract 1 so that we have room for null','line_number':44,'multiline':True]
['text':'null terminate the buffer','line_number':47,'multiline':False]
['text':'for post-context','line_number':50,'multiline':False]
['text':'null terminate the buffer','line_number':55,'multiline':False]
['text':' Clear error struct','line_number':145,'multiline':False]
['text':' TODO: Travis Keep: This won't always work.','line_number':149,'multiline':False]
['text':' Part 0 is the positive pattern.  Part 1, if present, is the negative','line_number':157,'multiline':False]
['text':' pattern.','line_number':158,'multiline':False]
['text':' The subpart ranges from 0 to 4: 0=pattern proper, 1=prefix,','line_number':160,'multiline':False]
['text':' 2=suffix, 3=prefix in quote, 4=suffix in quote.  Subpart 0 is','line_number':161,'multiline':False]
['text':' between the prefix and suffix, and consists of pattern','line_number':162,'multiline':False]
['text':' characters.  In the prefix and suffix, percent, perMill, and','line_number':163,'multiline':False]
['text':' currency symbols are recognized and translated.','line_number':164,'multiline':False]
['text':' It's important that we don't change any fields of this object','line_number':167,'multiline':False]
['text':' prematurely.  We set the following variables for the multiplier,','line_number':168,'multiline':False]
['text':' grouping, etc., and then only change the actual object fields if','line_number':169,'multiline':False]
['text':' everything parses correctly.  This also lets us register','line_number':170,'multiline':False]
['text':' the data from part 0 and ignore the part 1, except for the','line_number':171,'multiline':False]
['text':' prefix and suffix.','line_number':172,'multiline':False]
['text':' The affix is either the prefix or the suffix.','line_number':187,'multiline':False]
['text':' Todo: account for surrogate pairs','line_number':195,'multiline':False]
['text':' Pattern proper subpart (between prefix & suffix)','line_number':198,'multiline':False]
['text':' Process the digits, decimal, and grouping characters.  We','line_number':199,'multiline':False]
['text':' record five pieces of information.  We expect the digits','line_number':200,'multiline':False]
['text':' to occur in the pattern ####00.00####, and we record the','line_number':201,'multiline':False]
['text':' number of left digits, zero (central) digits, and right','line_number':202,'multiline':False]
['text':' digits.  The position of the last grouping character is','line_number':203,'multiline':False]
['text':' recorded (should be somewhere within the first two blocks','line_number':204,'multiline':False]
['text':' of characters), as is the position of the decimal point,','line_number':205,'multiline':False]
['text':' if any (should be in the zero digits).  If there is no','line_number':206,'multiline':False]
['text':' decimal point, then there should be no right digits.','line_number':207,'multiline':False]
['text':' Unexpected '0'','line_number':221,'multiline':False]
['text':' Grouping separator after decimal','line_number':244,'multiline':False]
['text':' Multiple decimal separators','line_number':255,'multiline':False]
['text':' Intentionally incorporate the digitRightCount,','line_number':261,'multiline':False]
['text':' even though it is illegal for this to be > 0','line_number':262,'multiline':False]
['text':' at this point.  We check pattern syntax below.','line_number':263,'multiline':False]
['text':' Multiple exponential symbols','line_number':269,'multiline':False]
['text':' Grouping separator in exponential pattern','line_number':276,'multiline':False]
['text':' Check for positive prefix','line_number':283,'multiline':False]
['text':' Use lookahead to parse out the exponential part of the','line_number':289,'multiline':False]
['text':' pattern, then jump into suffix subpart.','line_number':290,'multiline':False]
['text':' 1. Require at least one mantissa pattern digit','line_number':298,'multiline':False]
['text':' 2. Disallow "#+ @" in mantissa','line_number':299,'multiline':False]
['text':' 3. Require at least one exponent pattern digit','line_number':300,'multiline':False]
['text':' Malformed exponential pattern','line_number':305,'multiline':False]
['text':' Transition to suffix subpart','line_number':312,'multiline':False]
['text':' suffix subpart','line_number':313,'multiline':False]
['text':' Prefix subpart','line_number':319,'multiline':False]
['text':' Suffix subpart','line_number':320,'multiline':False]
['text':' Process the prefix / suffix characters','line_number':321,'multiline':False]
['text':' Process unquoted characters seen in prefix or suffix','line_number':322,'multiline':False]
['text':' subpart.','line_number':323,'multiline':False]
['text':' Several syntax characters implicitly begins the','line_number':325,'multiline':False]
['text':' next subpart if we are in the prefix; otherwise','line_number':326,'multiline':False]
['text':' they are illegal if unquoted.','line_number':327,'multiline':False]
['text':' prefix subpart','line_number':333,'multiline':False]
['text':' pattern proper subpart','line_number':334,'multiline':False]
['text':' Reprocess this character','line_number':335,'multiline':False]
['text':' Encode currency','line_number':343,'multiline':False]
['text':' Use lookahead to determine if the currency sign is','line_number':344,'multiline':False]
['text':' doubled or not.','line_number':345,'multiline':False]
['text':' Skip over the doubled character','line_number':349,'multiline':False]
['text':' Skip over the doubled character','line_number':353,'multiline':False]
['text':' Fall through to append(ch)','line_number':361,'multiline':False]
['text':' A quote outside quotes indicates either the opening','line_number':363,'multiline':False]
['text':' quote or two quotes, which is a quote literal.  That is,','line_number':364,'multiline':False]
['text':' we have the first quote in 'do' or o''clock.','line_number':365,'multiline':False]
['text':' Encode quote','line_number':369,'multiline':False]
['text':' Fall through to append(ch)','line_number':370,'multiline':False]
['text':' open quote','line_number':372,'multiline':False]
['text':' Don't allow separators in the prefix, and don't allow','line_number':376,'multiline':False]
['text':' separators in the second pattern (part == 1).','line_number':377,'multiline':False]
['text':' Unexpected separator','line_number':379,'multiline':False]
['text':' Go to next part','line_number':386,'multiline':False]
['text':' Next handle characters which are appended directly.','line_number':390,'multiline':False]
['text':' Too many percent/perMill characters','line_number':392,'multiline':False]
['text':' Encode percent/perMill','line_number':398,'multiline':False]
['text':' Use unlocalized pattern char','line_number':399,'multiline':False]
['text':' Next handle characters which are appended directly.','line_number':404,'multiline':False]
['text':' Too many percent/perMill characters','line_number':406,'multiline':False]
['text':' Encode percent/perMill','line_number':412,'multiline':False]
['text':' Use unlocalized pattern char','line_number':413,'multiline':False]
['text':' Multiple pad specifiers','line_number':418,'multiline':False]
['text':' Nothing after padEscape','line_number':419,'multiline':False]
['text':' Encode minus','line_number':431,'multiline':False]
['text':' Encode plus','line_number':436,'multiline':False]
['text':' Unquoted, non-special characters fall through to here, as','line_number':441,'multiline':False]
['text':' well as other code which needs to append something to the','line_number':442,'multiline':False]
['text':' affix.','line_number':443,'multiline':False]
['text':' Prefix subpart, in quote','line_number':447,'multiline':False]
['text':' Suffix subpart, in quote','line_number':448,'multiline':False]
['text':' A quote within quotes indicates either the closing','line_number':449,'multiline':False]
['text':' quote or two quotes, which is a quote literal.  That is,','line_number':450,'multiline':False]
['text':' we have the second quote in 'do' or 'don''t'.','line_number':451,'multiline':False]
['text':' Encode quote','line_number':455,'multiline':False]
['text':' Fall through to append(ch)','line_number':456,'multiline':False]
['text':' close quote','line_number':458,'multiline':False]
['text':' Handle patterns with no '0' pattern character.  These patterns
         * are legal, but must be recodified to make sense.  "##.###" ->
         * "#0.###".  ".###" -> ".0##".
         *
         * We allow patterns of the form "####" to produce a zeroDigitCount
         * of zero (got that?); although this seems like it might make it
         * possible for format() to produce empty strings, format() checks
         * for this condition and outputs a zero digit in this situation.
         * Having a zeroDigitCount of zero yields a minimum integer digits
         * of zero, which allows proper round-trip patterns.  We don't want
         * "#" to become "#0" when toPattern() is called (even though that's
         * what it really is, semantically).
         ','line_number':476,'multiline':True]
['text':' Handle "###.###" and "###." and ".###"','line_number':491,'multiline':False]
['text':' Handle ".###"','line_number':494,'multiline':False]
['text':' Do syntax checking on the digits, decimal points, and quotes.','line_number':500,'multiline':False]
['text':' subpart > 2 == unmatched quote','line_number':509,'multiline':False]
['text':' Make sure pad is at legal position before or after affix.','line_number':516,'multiline':False]
['text':' Illegal pad position','line_number':527,'multiline':False]
['text':' The effectiveDecimalPos is the position the decimal is at or','line_number':549,'multiline':False]
['text':' would be at if there is no decimal.  Note that if','line_number':550,'multiline':False]
['text':' decimalPos<0, then digitTotalCount == digitLeftCount +','line_number':551,'multiline':False]
['text':' zeroDigitCount.','line_number':552,'multiline':False]
['text':' To compute the format width, first set up sub0Limit -','line_number':579,'multiline':False]
['text':' sub0Start.  Add in prefix/suffix length later.','line_number':580,'multiline':False]
['text':' fFormatWidth = prefix.length() + suffix.length() +','line_number':582,'multiline':False]
['text':'    sub0Limit - sub0Start;','line_number':583,'multiline':False]
['text':' If there was no negative pattern, or if the negative pattern is','line_number':627,'multiline':False]
['text':' identical to the positive pattern, then prepend the minus sign to the','line_number':628,'multiline':False]
['text':' positive pattern to form the negative pattern.','line_number':629,'multiline':False]
['text':' TODO: Deprecate/Remove out.fNegSuffixPattern and 3 other fields.','line_number':639,'multiline':False]
['text':' !UCONFIG_NO_FORMATTING ','line_number':652,'multiline':True]
