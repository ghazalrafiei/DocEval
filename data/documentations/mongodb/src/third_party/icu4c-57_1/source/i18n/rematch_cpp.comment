['text':'
**************************************************************************
*   Copyright (C) 2002-2016 International Business Machines Corporation
*   and others. All rights reserved.
**************************************************************************
','line_number':1,'multiline':True]
['text':'','line_number':7,'multiline':False]
['text':'  file:  rematch.cpp','line_number':8,'multiline':False]
['text':'','line_number':9,'multiline':False]
['text':'         Contains the implementation of class RegexMatcher,','line_number':10,'multiline':False]
['text':'         which is one of the main API classes for the ICU regular expression package.','line_number':11,'multiline':False]
['text':'','line_number':12,'multiline':False]
['text':' #include <malloc.h>        // Needed for heapcheck testing','line_number':35,'multiline':False]
['text':' Default limit for the size of the back track stack, to avoid system','line_number':40,'multiline':False]
['text':'    failures causedby heap exhaustion.  Units are in 32 bit words, not bytes.','line_number':41,'multiline':False]
['text':' This value puts ICU's limits higher than most other regexp implementations,','line_number':42,'multiline':False]
['text':'    which use recursion rather than the heap, and take more storage per','line_number':43,'multiline':False]
['text':'    backtrack point.','line_number':44,'multiline':False]
['text':'','line_number':45,'multiline':False]
['text':' Time limit counter constant.','line_number':48,'multiline':False]
['text':'   Time limits for expression evaluation are in terms of quanta of work by','line_number':49,'multiline':False]
['text':'   the engine, each of which is 10,000 state saves.','line_number':50,'multiline':False]
['text':'   This constant determines that state saves per tick number.','line_number':51,'multiline':False]
['text':' Test for any of the Unicode line terminating characters.','line_number':55,'multiline':False]
['text':'-----------------------------------------------------------------------------','line_number':63,'multiline':False]
['text':'','line_number':64,'multiline':False]
['text':'   Constructor and Destructor','line_number':65,'multiline':False]
['text':'','line_number':66,'multiline':False]
['text':'-----------------------------------------------------------------------------','line_number':67,'multiline':False]
['text':'','line_number':181,'multiline':False]
['text':'   init()   common initialization for use by all constructors.','line_number':182,'multiline':False]
['text':'            Initialize all fields, get the object into a consistent state.','line_number':183,'multiline':False]
['text':'            This must be done even when the initial status shows an error,','line_number':184,'multiline':False]
['text':'            so that the object is initialized sufficiently well for the destructor','line_number':185,'multiline':False]
['text':'            to run safely.','line_number':186,'multiline':False]
['text':'','line_number':187,'multiline':False]
['text':'','line_number':232,'multiline':False]
['text':'  init2()   Common initialization for use by RegexMatcher constructors, part 2.','line_number':233,'multiline':False]
['text':'            This handles the common setup to be done after the Pattern is available.','line_number':234,'multiline':False]
['text':'','line_number':235,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':270,'multiline':False]
['text':'','line_number':271,'multiline':False]
['text':'    appendReplacement','line_number':272,'multiline':False]
['text':'','line_number':273,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':274,'multiline':False]
['text':'','line_number':295,'multiline':False]
['text':'    appendReplacement, UText mode','line_number':296,'multiline':False]
['text':'','line_number':297,'multiline':False]
['text':' Copy input string from the end of previous match to start of current match','line_number':313,'multiline':False]
['text':' scan the replacement text, looking for substitutions ($n) and \escapes.','line_number':340,'multiline':False]
['text':'  TODO:  optimize this loop by efficiently scanning for '$' or '\',','line_number':341,'multiline':False]
['text':'         move entire ranges not containing substitutions.','line_number':342,'multiline':False]
['text':' Backslash Escape.  Copy the following char out without further checks.','line_number':346,'multiline':False]
['text':'                    Note:  Surrogate pairs don't need any special handling','line_number':347,'multiline':False]
['text':'                           The second half wont be a '$' or a '\', and','line_number':348,'multiline':False]
['text':'                           will move to the dest normally on the next','line_number':349,'multiline':False]
['text':'                           loop iteration.','line_number':350,'multiline':False]
['text':'U','line_number':356,'multiline':True]
['text':'u','line_number':356,'multiline':True]
['text':' We have a \udddd or \Udddddddd escape sequence.','line_number':357,'multiline':False]
['text':' TODO:  Report errors for mal-formed \u escapes?','line_number':373,'multiline':False]
['text':'        As this is, the original sequence is output, which may be OK.','line_number':374,'multiline':False]
['text':' Plain backslash escape.  Just put out the escaped character.','line_number':383,'multiline':False]
['text':' Normal char, not a $.  Copy it out without further checks.','line_number':397,'multiline':False]
['text':' We've got a $.  Pick up a capture group name or number if one follows.','line_number':410,'multiline':False]
['text':' Consume digits so long as the resulting group number <= the number of','line_number':411,'multiline':False]
['text':' number of capture groups in the pattern.','line_number':412,'multiline':False]
['text':' Scan for a Named Capture Group, ${name}.','line_number':418,'multiline':False]
['text':' A..Z','line_number':425,'multiline':False]
['text':' a..z','line_number':426,'multiline':False]
['text':' 0..9','line_number':427,'multiline':False]
['text':' Character was something other than a name char or a closing '}'','line_number':435,'multiline':False]
['text':' $n    Scan for a capture group number','line_number':441,'multiline':False]
['text':' Don't consume the next digit if it makes the capture group number too big.','line_number':453,'multiline':False]
['text':' $ not followed by capture group name or number.','line_number':464,'multiline':False]
['text':' End of $ capture group handling','line_number':471,'multiline':False]
['text':' End of per-character loop through the replacement string.','line_number':472,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':479,'multiline':False]
['text':'','line_number':480,'multiline':False]
['text':'    appendTail     Intended to be used in conjunction with appendReplacement()','line_number':481,'multiline':False]
['text':'                   To the destination string, append everything following','line_number':482,'multiline':False]
['text':'                   the last match position from the input string.','line_number':483,'multiline':False]
['text':'','line_number':484,'multiline':False]
['text':'                   Note:  Match ranges do not affect appendTail or appendReplacement','line_number':485,'multiline':False]
['text':'','line_number':486,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':487,'multiline':False]
['text':'','line_number':501,'multiline':False]
['text':'   appendTail, UText mode','line_number':502,'multiline':False]
['text':'','line_number':503,'multiline':False]
['text':' buffer overflow','line_number':524,'multiline':False]
['text':' unterminated','line_number':531,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':543,'multiline':False]
['text':'','line_number':544,'multiline':False]
['text':'   end','line_number':545,'multiline':False]
['text':'','line_number':546,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':547,'multiline':False]
['text':' Get the position within the stack frame of the variables for','line_number':572,'multiline':False]
['text':'    this capture group.','line_number':573,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':587,'multiline':False]
['text':'','line_number':588,'multiline':False]
['text':'   findProgressInterrupt  This function is called once for each advance in the target','line_number':589,'multiline':False]
['text':'                          string from the find() function, and calls the user progress callback','line_number':590,'multiline':False]
['text':'                          function if there is one installed.','line_number':591,'multiline':False]
['text':'','line_number':592,'multiline':False]
['text':'         Return:  TRUE if the find operation is to be terminated.','line_number':593,'multiline':False]
['text':'                  FALSE if the find operation is to continue running.','line_number':594,'multiline':False]
['text':'','line_number':595,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':596,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':605,'multiline':False]
['text':'','line_number':606,'multiline':False]
['text':'   find()','line_number':607,'multiline':False]
['text':'','line_number':608,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':609,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':619,'multiline':False]
['text':'','line_number':620,'multiline':False]
['text':'   find()','line_number':621,'multiline':False]
['text':'','line_number':622,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':623,'multiline':False]
['text':' Start at the position of the last match end.  (Will be zero if the','line_number':625,'multiline':False]
['text':'   matcher has been reset.)','line_number':626,'multiline':False]
['text':'','line_number':627,'multiline':False]
['text':' Save the position of any previous successful match.','line_number':646,'multiline':False]
['text':' Previous match had zero length.  Move start position up one position','line_number':650,'multiline':False]
['text':'  to avoid sending find() into a loop on zero-length matches.','line_number':651,'multiline':False]
['text':' A previous find() failed to match.  Don't try again.','line_number':663,'multiline':False]
['text':'   (without this test, a pattern with a zero-length match','line_number':664,'multiline':False]
['text':'    could match again at the end of an input string.)','line_number':665,'multiline':False]
['text':' Compute the position in the input string beyond which a match can not begin, because','line_number':672,'multiline':False]
['text':'   the minimum length match would extend past the end of the input.','line_number':673,'multiline':False]
['text':'   Note:  some patterns that cannot match anything will have fMinMatchLength==Max Int.','line_number':674,'multiline':False]
['text':'          Be aware of possible overflows if making changes here.','line_number':675,'multiline':False]
['text':' We don't know exactly how long the minimum match length is in native characters.','line_number':685,'multiline':False]
['text':' Treat anything > 0 as 1.','line_number':686,'multiline':False]
['text':' No optimization was found.','line_number':695,'multiline':False]
['text':'  Try a match at each input position.','line_number':696,'multiline':False]
['text':' Note that it's perfectly OK for a pattern to have a zero-length','line_number':712,'multiline':False]
['text':'   match at the end of a string, so we must make sure that the loop','line_number':713,'multiline':False]
['text':'   runs with startPos == testStartLimit the last time through.','line_number':714,'multiline':False]
['text':' Matches are only possible at the start of the input string','line_number':721,'multiline':False]
['text':'   (pattern begins with ^ or \A)','line_number':722,'multiline':False]
['text':' Match may start on any char from a pre-computed set.','line_number':736,'multiline':False]
['text':' c will be -1 (U_SENTINEL) at end of text, in which case we','line_number':743,'multiline':False]
['text':' skip this next block (so we don't have a negative array index)','line_number':744,'multiline':False]
['text':' and handle end of text in the following block.','line_number':745,'multiline':False]
['text':' Match starts on exactly one char.','line_number':771,'multiline':False]
['text':' Note that it's perfectly OK for a pattern to have a zero-length','line_number':839,'multiline':False]
['text':'   match at the end of a string, so we must make sure that the loop','line_number':840,'multiline':False]
['text':'   runs with startPos == testStartLimit the last time through.','line_number':841,'multiline':False]
['text':' Note that it's perfectly OK for a pattern to have a zero-length','line_number':868,'multiline':False]
['text':'   match at the end of a string, so we must make sure that the loop','line_number':869,'multiline':False]
['text':'   runs with startPos == testStartLimit the last time through.','line_number':870,'multiline':False]
['text':' Note:  Reset() is specified by Java Matcher documentation.','line_number':895,'multiline':False]
['text':'        This will reset the region to be the full input length.','line_number':896,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':912,'multiline':False]
['text':'','line_number':913,'multiline':False]
['text':'   findUsingChunk() -- like find(), but with the advance knowledge that the','line_number':914,'multiline':False]
['text':'                       entire string is available in the UText's chunk buffer.','line_number':915,'multiline':False]
['text':'','line_number':916,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':917,'multiline':False]
['text':' Start at the position of the last match end.  (Will be zero if the','line_number':919,'multiline':False]
['text':'   matcher has been reset.','line_number':920,'multiline':False]
['text':'','line_number':921,'multiline':False]
['text':' Save the position of any previous successful match.','line_number':931,'multiline':False]
['text':' Previous match had zero length.  Move start position up one position','line_number':935,'multiline':False]
['text':'  to avoid sending find() into a loop on zero-length matches.','line_number':936,'multiline':False]
['text':' A previous find() failed to match.  Don't try again.','line_number':946,'multiline':False]
['text':'   (without this test, a pattern with a zero-length match','line_number':947,'multiline':False]
['text':'    could match again at the end of an input string.)','line_number':948,'multiline':False]
['text':' Compute the position in the input string beyond which a match can not begin, because','line_number':955,'multiline':False]
['text':'   the minimum length match would extend past the end of the input.','line_number':956,'multiline':False]
['text':'   Note:  some patterns that cannot match anything will have fMinMatchLength==Max Int.','line_number':957,'multiline':False]
['text':'          Be aware of possible overflows if making changes here.','line_number':958,'multiline':False]
['text':'   Note:  a match can begin at inputBuf + testLen; it is an inclusive limit.','line_number':959,'multiline':False]
['text':' No optimization was found.','line_number':972,'multiline':False]
['text':'  Try a match at each input position.','line_number':973,'multiline':False]
['text':' Note that it's perfectly OK for a pattern to have a zero-length','line_number':987,'multiline':False]
['text':'   match at the end of a string, so we must make sure that the loop','line_number':988,'multiline':False]
['text':'   runs with startPos == testLen the last time through.','line_number':989,'multiline':False]
['text':' Matches are only possible at the start of the input string','line_number':996,'multiline':False]
['text':'   (pattern begins with ^ or \A)','line_number':997,'multiline':False]
['text':' Match may start on any char from a pre-computed set.','line_number':1011,'multiline':False]
['text':' like c = inputBuf[startPos++];','line_number':1015,'multiline':False]
['text':' Match starts on exactly one char.','line_number':1040,'multiline':False]
['text':' like c = inputBuf[startPos++];','line_number':1045,'multiline':False]
['text':' Note that it's perfectly OK for a pattern to have a zero-length','line_number':1098,'multiline':False]
['text':'   match at the end of a string, so we must make sure that the loop','line_number':1099,'multiline':False]
['text':'   runs with startPos == testLen the last time through.','line_number':1100,'multiline':False]
['text':' Note that it's perfectly OK for a pattern to have a zero-length','line_number':1125,'multiline':False]
['text':'   match at the end of a string, so we must make sure that the loop','line_number':1126,'multiline':False]
['text':'   runs with startPos == testLen the last time through.','line_number':1127,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1144,'multiline':False]
['text':'','line_number':1145,'multiline':False]
['text':'  group()','line_number':1146,'multiline':False]
['text':'','line_number':1147,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1148,'multiline':False]
['text':'  Return immutable shallow clone','line_number':1153,'multiline':False]
['text':'  Return immutable shallow clone','line_number':1158,'multiline':False]
['text':' A capture group wasn't part of the match','line_number':1189,'multiline':False]
['text':' Get the group length using a utext_extract preflight.','line_number':1209,'multiline':False]
['text':'    UText is actually pretty efficient at this when underlying encoding is UTF-16.','line_number':1210,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1229,'multiline':False]
['text':'','line_number':1230,'multiline':False]
['text':'  appendGroup() -- currently internal only, appends a group to a UText rather','line_number':1231,'multiline':False]
['text':'                   than replacing its contents','line_number':1232,'multiline':False]
['text':'','line_number':1233,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1234,'multiline':False]
['text':' A capture group wasn't part of the match','line_number':1268,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1300,'multiline':False]
['text':'','line_number':1301,'multiline':False]
['text':'  groupCount()','line_number':1302,'multiline':False]
['text':'','line_number':1303,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1304,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1309,'multiline':False]
['text':'','line_number':1310,'multiline':False]
['text':'  hasAnchoringBounds()','line_number':1311,'multiline':False]
['text':'','line_number':1312,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1313,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1319,'multiline':False]
['text':'','line_number':1320,'multiline':False]
['text':'  hasTransparentBounds()','line_number':1321,'multiline':False]
['text':'','line_number':1322,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1323,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1330,'multiline':False]
['text':'','line_number':1331,'multiline':False]
['text':'  hitEnd()','line_number':1332,'multiline':False]
['text':'','line_number':1333,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1334,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1340,'multiline':False]
['text':'','line_number':1341,'multiline':False]
['text':'  input()','line_number':1342,'multiline':False]
['text':'','line_number':1343,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1344,'multiline':False]
['text':' overflow, length status','line_number':1353,'multiline':False]
['text':' unterminated warning','line_number':1358,'multiline':False]
['text':' pointer assignment, rather than operator=','line_number':1361,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1367,'multiline':False]
['text':'','line_number':1368,'multiline':False]
['text':'  inputText()','line_number':1369,'multiline':False]
['text':'','line_number':1370,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1371,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1377,'multiline':False]
['text':'','line_number':1378,'multiline':False]
['text':'  getInput() -- like inputText(), but makes a clone or copies into another UText','line_number':1379,'multiline':False]
['text':'','line_number':1380,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1381,'multiline':False]
['text':' buffer overflow error','line_number':1400,'multiline':False]
['text':' not terminated warning','line_number':1408,'multiline':False]
['text':'  In the following test, we're really only interested in whether the UText should switch','line_number':1425,'multiline':False]
['text':'  between heap and stack allocation.  If length hasn't changed, we won't, so the chunkContents','line_number':1426,'multiline':False]
['text':'  will still point to the correct data.','line_number':1427,'multiline':False]
['text':' Update to the latest length.','line_number':1431,'multiline':False]
['text':' For example, (utext_nativeLength(ut) != ut->nativeIndexingLimit).','line_number':1432,'multiline':False]
['text':' Update the chunk description.','line_number':1435,'multiline':False]
['text':' The buffer may have switched between stack- and heap-based.','line_number':1436,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1447,'multiline':False]
['text':'','line_number':1448,'multiline':False]
['text':'  lookingAt()','line_number':1449,'multiline':False]
['text':'','line_number':1450,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1451,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1518,'multiline':False]
['text':'','line_number':1519,'multiline':False]
['text':'  matches()','line_number':1520,'multiline':False]
['text':'','line_number':1521,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1522,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1590,'multiline':False]
['text':'','line_number':1591,'multiline':False]
['text':'    pattern','line_number':1592,'multiline':False]
['text':'','line_number':1593,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1594,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1601,'multiline':False]
['text':'','line_number':1602,'multiline':False]
['text':'    region','line_number':1603,'multiline':False]
['text':'','line_number':1604,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1605,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1653,'multiline':False]
['text':'','line_number':1654,'multiline':False]
['text':'    regionEnd','line_number':1655,'multiline':False]
['text':'','line_number':1656,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1657,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1666,'multiline':False]
['text':'','line_number':1667,'multiline':False]
['text':'    regionStart','line_number':1668,'multiline':False]
['text':'','line_number':1669,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1670,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1680,'multiline':False]
['text':'','line_number':1681,'multiline':False]
['text':'    replaceAll','line_number':1682,'multiline':False]
['text':'','line_number':1683,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1684,'multiline':False]
['text':'','line_number':1705,'multiline':False]
['text':'    replaceAll, UText mode','line_number':1706,'multiline':False]
['text':'','line_number':1707,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1741,'multiline':False]
['text':'','line_number':1742,'multiline':False]
['text':'    replaceFirst','line_number':1743,'multiline':False]
['text':'','line_number':1744,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1745,'multiline':False]
['text':'','line_number':1762,'multiline':False]
['text':'    replaceFirst, UText mode','line_number':1763,'multiline':False]
['text':'','line_number':1764,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1795,'multiline':False]
['text':'','line_number':1796,'multiline':False]
['text':'     requireEnd','line_number':1797,'multiline':False]
['text':'','line_number':1798,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1799,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1805,'multiline':False]
['text':'','line_number':1806,'multiline':False]
['text':'     reset','line_number':1807,'multiline':False]
['text':'','line_number':1808,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1809,'multiline':False]
['text':'resetStack(); // more expensive than it looks...','line_number':1835,'multiline':False]
['text':'  Do the following for any UnicodeString.','line_number':1853,'multiline':False]
['text':'  This is for compatibility for those clients who modify the input string "live" during regex operations.','line_number':1854,'multiline':False]
['text':'RegexMatcher &RegexMatcher::reset(const UChar *) {
    fDeferredStatus = U_INTERNAL_PROGRAM_ERROR;
    return *this;
}','line_number':1892,'multiline':True]
['text':' Reset also resets the region to be the entire string.','line_number':1901,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1912,'multiline':False]
['text':'','line_number':1913,'multiline':False]
['text':'    refresh','line_number':1914,'multiline':False]
['text':'','line_number':1915,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1916,'multiline':False]
['text':'  Shallow read-only clone of the new UText into the existing input UText','line_number':1930,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1950,'multiline':False]
['text':'','line_number':1951,'multiline':False]
['text':'    setTrace','line_number':1952,'multiline':False]
['text':'','line_number':1953,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1954,'multiline':False]
['text':'*
  *  UText, replace entire contents of the destination UText with a substring of the source UText.
  *
  *     @param src    The source UText
  *     @param dest   The destination UText. Must be writable.
  *                   May be NULL, in which case a new UText will be allocated.
  *     @param start  Start index of source substring.
  *     @param limit  Limit index of source substring.
  *     @param status An error code.
  ','line_number':1961,'multiline':True]
['text':' Leave space for terminating Nul.','line_number':1990,'multiline':False]
['text':' Caller did not provide a prexisting UText.','line_number':2001,'multiline':False]
['text':' Open a new one, and have it adopt the text buffer storage.','line_number':2002,'multiline':False]
['text':'---------------------------------------------------------------------','line_number':2022,'multiline':False]
['text':'','line_number':2023,'multiline':False]
['text':'   split','line_number':2024,'multiline':False]
['text':'','line_number':2025,'multiline':False]
['text':'---------------------------------------------------------------------','line_number':2026,'multiline':False]
['text':'','line_number':2059,'multiline':False]
['text':'   split, UText mode','line_number':2060,'multiline':False]
['text':'','line_number':2061,'multiline':False]
['text':'','line_number':2067,'multiline':False]
['text':' Check arguements for validity','line_number':2068,'multiline':False]
['text':'','line_number':2069,'multiline':False]
['text':'','line_number':2079,'multiline':False]
['text':' Reset for the input text','line_number':2080,'multiline':False]
['text':'','line_number':2081,'multiline':False]
['text':'','line_number':2088,'multiline':False]
['text':' Loop through the input text, searching for the delimiter pattern','line_number':2089,'multiline':False]
['text':'','line_number':2090,'multiline':False]
['text':' There is one or zero output string left.','line_number':2095,'multiline':False]
['text':' Fill the last output string with whatever is left from the input, then exit the loop.','line_number':2096,'multiline':False]
['text':'  ( i will be == destCapacity if we filled the output array while processing','line_number':2097,'multiline':False]
['text':'    capture groups of the delimiter expression, in which case we will discard the','line_number':2098,'multiline':False]
['text':'    last capture group saved in favor of the unprocessed remainder of the','line_number':2099,'multiline':False]
['text':'    input string.)','line_number':2100,'multiline':False]
['text':' We found another delimiter.  Move everything from where we started looking','line_number':2141,'multiline':False]
['text':'  up until the start of the delimiter into the next output string.','line_number':2142,'multiline':False]
['text':' If the delimiter pattern has capturing parentheses, the captured','line_number':2177,'multiline':False]
['text':'  text goes out into the next n destination strings.','line_number':2178,'multiline':False]
['text':' Never fill the last available output string with capture group text.','line_number':2182,'multiline':False]
['text':' It will filled with the last field, the remainder of the','line_number':2183,'multiline':False]
['text':'  unsplit input text.','line_number':2184,'multiline':False]
['text':' The delimiter was at the end of the string.  We're done, but first','line_number':2193,'multiline':False]
['text':' we output one last empty string, for the empty field following','line_number':2194,'multiline':False]
['text':'   the delimiter at the end of input.','line_number':2195,'multiline':False]
['text':' We ran off the end of the input while looking for the next delimiter.','line_number':2211,'multiline':False]
['text':' All the remaining text goes into the current output string.','line_number':2212,'multiline':False]
['text':' end of for loop','line_number':2251,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2256,'multiline':False]
['text':'','line_number':2257,'multiline':False]
['text':'     start','line_number':2258,'multiline':False]
['text':'','line_number':2259,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2260,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2269,'multiline':False]
['text':'','line_number':2270,'multiline':False]
['text':'     start(int32_t group, UErrorCode &status)','line_number':2271,'multiline':False]
['text':'','line_number':2272,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2273,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2309,'multiline':False]
['text':'','line_number':2310,'multiline':False]
['text':'     useAnchoringBounds','line_number':2311,'multiline':False]
['text':'','line_number':2312,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2313,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2322,'multiline':False]
['text':'','line_number':2323,'multiline':False]
['text':'     useTransparentBounds','line_number':2324,'multiline':False]
['text':'','line_number':2325,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2326,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2334,'multiline':False]
['text':'','line_number':2335,'multiline':False]
['text':'     setTimeLimit','line_number':2336,'multiline':False]
['text':'','line_number':2337,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2338,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2355,'multiline':False]
['text':'','line_number':2356,'multiline':False]
['text':'     getTimeLimit','line_number':2357,'multiline':False]
['text':'','line_number':2358,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2359,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2365,'multiline':False]
['text':'','line_number':2366,'multiline':False]
['text':'     setStackLimit','line_number':2367,'multiline':False]
['text':'','line_number':2368,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2369,'multiline':False]
['text':' Reset the matcher.  This is needed here in case there is a current match','line_number':2383,'multiline':False]
['text':'    whose final stack frame (containing the match results, pointed to by fFrame)','line_number':2384,'multiline':False]
['text':'    would be lost by resizing to a smaller stack size.','line_number':2385,'multiline':False]
['text':' Unlimited stack expansion','line_number':2389,'multiline':False]
['text':' Change the units of the limit  from bytes to ints, and bump the size up','line_number':2392,'multiline':False]
['text':'   to be big enough to hold at least one stack frame for the pattern,','line_number':2393,'multiline':False]
['text':'   if it isn't there already.','line_number':2394,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2405,'multiline':False]
['text':'','line_number':2406,'multiline':False]
['text':'     getStackLimit','line_number':2407,'multiline':False]
['text':'','line_number':2408,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2409,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2415,'multiline':False]
['text':'','line_number':2416,'multiline':False]
['text':'     setMatchCallback','line_number':2417,'multiline':False]
['text':'','line_number':2418,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2419,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2431,'multiline':False]
['text':'','line_number':2432,'multiline':False]
['text':'     getMatchCallback','line_number':2433,'multiline':False]
['text':'','line_number':2434,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2435,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2447,'multiline':False]
['text':'','line_number':2448,'multiline':False]
['text':'     setMatchCallback','line_number':2449,'multiline':False]
['text':'','line_number':2450,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2451,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2463,'multiline':False]
['text':'','line_number':2464,'multiline':False]
['text':'     getMatchCallback','line_number':2465,'multiline':False]
['text':'','line_number':2466,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2467,'multiline':False]
['text':'================================================================================','line_number':2479,'multiline':False]
['text':'','line_number':2480,'multiline':False]
['text':'    Code following this point in this file is the internal','line_number':2481,'multiline':False]
['text':'    Match Engine Implementation.','line_number':2482,'multiline':False]
['text':'','line_number':2483,'multiline':False]
['text':'================================================================================','line_number':2484,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2487,'multiline':False]
['text':'','line_number':2488,'multiline':False]
['text':'   resetStack','line_number':2489,'multiline':False]
['text':'           Discard any previous contents of the state save stack, and initialize a','line_number':2490,'multiline':False]
['text':'           new stack frame to all -1.  The -1s are needed for capture group limits,','line_number':2491,'multiline':False]
['text':'           where they indicate that a group has not yet matched anything.','line_number':2492,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2493,'multiline':False]
['text':' Discard any previous contents of the state save stack, and initialize a','line_number':2495,'multiline':False]
['text':'  new stack frame with all -1 data.  The -1s are needed for capture group limits,','line_number':2496,'multiline':False]
['text':'  where they indicate that a group has not yet matched anything.','line_number':2497,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2514,'multiline':False]
['text':'','line_number':2515,'multiline':False]
['text':'   isWordBoundary','line_number':2516,'multiline':False]
['text':'                     in perl, "xab..cd..", \b is true at positions 0,3,5,7','line_number':2517,'multiline':False]
['text':'                     For us,','line_number':2518,'multiline':False]
['text':'                       If the current char is a combining mark,','line_number':2519,'multiline':False]
['text':'                          \b is FALSE.','line_number':2520,'multiline':False]
['text':'                       Else Scan backwards to the first non-combining char.','line_number':2521,'multiline':False]
['text':'                            We are at a boundary if the this char and the original chars are','line_number':2522,'multiline':False]
['text':'                               opposite in membership in \w set','line_number':2523,'multiline':False]
['text':'','line_number':2524,'multiline':False]
['text':'          parameters:   pos   - the current position in the input buffer','line_number':2525,'multiline':False]
['text':'','line_number':2526,'multiline':False]
['text':'              TODO:  double-check edge cases at region boundaries.','line_number':2527,'multiline':False]
['text':'','line_number':2528,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2529,'multiline':False]
['text':' Determine whether char c at current position is a member of the word set of chars.','line_number':2537,'multiline':False]
['text':' If we're off the end of the string, behave as though we're not at a word char.','line_number':2538,'multiline':False]
['text':' Current char is a combining one.  Not a boundary.','line_number':2542,'multiline':False]
['text':' Back up until we come to a non-combining char, determine whether','line_number':2548,'multiline':False]
['text':'  that char is a word char.','line_number':2549,'multiline':False]
['text':' Determine whether char c at current position is a member of the word set of chars.','line_number':2575,'multiline':False]
['text':' If we're off the end of the string, behave as though we're not at a word char.','line_number':2576,'multiline':False]
['text':' Current char is a combining one.  Not a boundary.','line_number':2580,'multiline':False]
['text':' Back up until we come to a non-combining char, determine whether','line_number':2586,'multiline':False]
['text':'  that char is a word char.','line_number':2587,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2605,'multiline':False]
['text':'','line_number':2606,'multiline':False]
['text':'   isUWordBoundary','line_number':2607,'multiline':False]
['text':'','line_number':2608,'multiline':False]
['text':'         Test for a word boundary using RBBI word break.','line_number':2609,'multiline':False]
['text':'','line_number':2610,'multiline':False]
['text':'          parameters:   pos   - the current position in the input buffer','line_number':2611,'multiline':False]
['text':'','line_number':2612,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2613,'multiline':False]
['text':' If we haven't yet created a break iterator for this matcher, do it now.','line_number':2618,'multiline':False]
['text':' With Unicode word rules, only positions within the interior of "real"','line_number':2630,'multiline':False]
['text':'    words are not boundaries.  All non-word chars stand by themselves,','line_number':2631,'multiline':False]
['text':'    with word boundaries on both sides.','line_number':2632,'multiline':False]
['text':' !!!: Would like a better way to do this!','line_number':2635,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2645,'multiline':False]
['text':'','line_number':2646,'multiline':False]
['text':'   IncrementTime     This function is called once each TIMER_INITIAL_VALUE state','line_number':2647,'multiline':False]
['text':'                     saves. Increment the "time" counter, and call the','line_number':2648,'multiline':False]
['text':'                     user callback function if there is one installed.','line_number':2649,'multiline':False]
['text':'','line_number':2650,'multiline':False]
['text':'                     If the match operation needs to be aborted, either for a time-out','line_number':2651,'multiline':False]
['text':'                     or because the user callback asked for it, just set an error status.','line_number':2652,'multiline':False]
['text':'                     The engine will pick that up and stop in its outer loop.','line_number':2653,'multiline':False]
['text':'','line_number':2654,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2655,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2670,'multiline':False]
['text':'','line_number':2671,'multiline':False]
['text':'   StateSave','line_number':2672,'multiline':False]
['text':'       Make a new stack frame, initialized as a copy of the current stack frame.','line_number':2673,'multiline':False]
['text':'       Set the pattern index in the original stack frame from the operand value','line_number':2674,'multiline':False]
['text':'       in the opcode.  Execution of the engine continues with the state in','line_number':2675,'multiline':False]
['text':'       the newly created stack frame','line_number':2676,'multiline':False]
['text':'','line_number':2677,'multiline':False]
['text':'       Note that reserveBlock() may grow the stack, resulting in the','line_number':2678,'multiline':False]
['text':'       whole thing being relocated in memory.','line_number':2679,'multiline':False]
['text':'','line_number':2680,'multiline':False]
['text':'    Parameters:','line_number':2681,'multiline':False]
['text':'       fp           The top frame pointer when called.  At return, a new','line_number':2682,'multiline':False]
['text':'                    fame will be present','line_number':2683,'multiline':False]
['text':'       savePatIdx   An index into the compiled pattern.  Goes into the original','line_number':2684,'multiline':False]
['text':'                    (not new) frame.  If execution ever back-tracks out of the','line_number':2685,'multiline':False]
['text':'                    new frame, this will be where we continue from in the pattern.','line_number':2686,'multiline':False]
['text':'    Return','line_number':2687,'multiline':False]
['text':'                    The new frame pointer.','line_number':2688,'multiline':False]
['text':'','line_number':2689,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2690,'multiline':False]
['text':' push storage for a new frame.','line_number':2695,'multiline':False]
['text':' Failure on attempted stack expansion.','line_number':2698,'multiline':False]
['text':'   Stack function set some other error code, change it to a more','line_number':2699,'multiline':False]
['text':'   specific one for regular expressions.','line_number':2700,'multiline':False]
['text':' We need to return a writable stack frame, so just return the','line_number':2702,'multiline':False]
['text':'    previous frame.  The match operation will stop quickly','line_number':2703,'multiline':False]
['text':'    because of the error status, after which the frame will never','line_number':2704,'multiline':False]
['text':'    be looked at again.','line_number':2705,'multiline':False]
['text':' in case of realloc of stack.','line_number':2708,'multiline':False]
['text':' New stack frame = copy of old top frame.','line_number':2710,'multiline':False]
['text':' Re-initializes fTickCounter','line_number':2722,'multiline':False]
['text':' REGEX_DEBUG','line_number':2738,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2741,'multiline':False]
['text':'','line_number':2742,'multiline':False]
['text':'   MatchAt      This is the actual matching engine.','line_number':2743,'multiline':False]
['text':'','line_number':2744,'multiline':False]
['text':'                  startIdx:    begin matching a this index.','line_number':2745,'multiline':False]
['text':'                  toEnd:       if true, match must extend to end of the input region','line_number':2746,'multiline':False]
['text':'','line_number':2747,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2748,'multiline':False]
['text':' True if the we have a match.','line_number':2750,'multiline':False]
['text':' used after greedy single-character matches for searching backwards','line_number':2752,'multiline':False]
['text':' Operation from the compiled pattern, split into','line_number':2754,'multiline':False]
['text':'    the opcode','line_number':2755,'multiline':False]
['text':'    and the operand value.','line_number':2756,'multiline':False]
['text':'  Cache frequently referenced items from the compiled pattern','line_number':2770,'multiline':False]
['text':'','line_number':2771,'multiline':False]
['text':' Zero out the pattern's static data','line_number':2787,'multiline':False]
['text':'','line_number':2793,'multiline':False]
['text':'  Main loop for interpreting the compiled pattern.','line_number':2794,'multiline':False]
['text':'  One iteration of the loop per pattern operation performed.','line_number':2795,'multiline':False]
['text':'','line_number':2796,'multiline':False]
['text':' Force a backtrack.  In some circumstances, the pattern compiler','line_number':2819,'multiline':False]
['text':'   will notice that the pattern can't possibly match anything, and will','line_number':2820,'multiline':False]
['text':'   emit one of these at that point.','line_number':2821,'multiline':False]
['text':' Test input against a literal string.','line_number':2843,'multiline':False]
['text':' Strings require two slots in the compiled pattern, one for the','line_number':2844,'multiline':False]
['text':'   offset to the string text, and one for the length.','line_number':2845,'multiline':False]
['text':' Fetch the second operand','line_number':2848,'multiline':False]
['text':' The match loop will exit via this path on a successful match,','line_number':2890,'multiline':False]
['text':'   when we reach the end of the pattern.','line_number':2891,'multiline':False]
['text':' The pattern matched, but not to the end of input.  Try some more.','line_number':2893,'multiline':False]
['text':' Start and End Capture stack frame variables are laid out out like this:','line_number':2900,'multiline':False]
['text':'  fp->fExtra[opValue]  - The start of a completed capture group','line_number':2901,'multiline':False]
['text':'             opValue+1 - The end   of a completed capture group','line_number':2902,'multiline':False]
['text':'             opValue+2 - the start of a capture group whose end','line_number':2903,'multiline':False]
['text':'                          has not yet been reached (and might not ever be).','line_number':2904,'multiline':False]
['text':' Start pos for this group must be set.','line_number':2913,'multiline':False]
['text':' Tentative start becomes real.','line_number':2914,'multiline':False]
['text':' End position','line_number':2915,'multiline':False]
['text':'  $, test for End of line','line_number':2920,'multiline':False]
['text':'     or for position before new line at end of input','line_number':2921,'multiline':False]
['text':' We really are at the end of input.  Success.','line_number':2924,'multiline':False]
['text':' If we are positioned just before a new-line that is located at the','line_number':2932,'multiline':False]
['text':'   end of input, succeed.','line_number':2933,'multiline':False]
['text':' If not in the middle of a CR/LF sequence','line_number':2937,'multiline':False]
['text':' At new-line at end of input. Success','line_number':2939,'multiline':False]
['text':' At CR/LF at end of input.  Success','line_number':2951,'multiline':False]
['text':'  $, test for End of Line, in UNIX_LINES mode.','line_number':2960,'multiline':False]
['text':' Off the end of input.  Success.','line_number':2962,'multiline':False]
['text':' Either at the last character of input, or off the end.','line_number':2969,'multiline':False]
['text':' Not at end of input.  Back-track out.','line_number':2977,'multiline':False]
['text':'  $, test for End of line in multi-line mode','line_number':2982,'multiline':False]
['text':' We really are at the end of input.  Success.','line_number':2985,'multiline':False]
['text':' If we are positioned just before a new-line, succeed.','line_number':2990,'multiline':False]
['text':' It makes no difference where the new-line is within the input.','line_number':2991,'multiline':False]
['text':' At a line end, except for the odd chance of  being in the middle of a CR/LF sequence','line_number':2995,'multiline':False]
['text':'  In multi-line mode, hitting a new-line just before the end of input does not','line_number':2996,'multiline':False]
['text':'   set the hitEnd or requireEnd flags','line_number':2997,'multiline':False]
['text':' not at a new line.  Fail.','line_number':3002,'multiline':False]
['text':'  $, test for End of line in multi-line and UNIX_LINES mode','line_number':3008,'multiline':False]
['text':' We really are at the end of input.  Success.','line_number':3011,'multiline':False]
['text':' Java set requireEnd in this case, even though','line_number':3013,'multiline':False]
['text':'   adding a new-line would not lose the match.','line_number':3014,'multiline':False]
['text':' If we are not positioned just before a new-line, the test fails; backtrack out.','line_number':3016,'multiline':False]
['text':' It makes no difference where the new-line is within the input.','line_number':3017,'multiline':False]
['text':'  ^, test for start of line','line_number':3026,'multiline':False]
['text':'  ^, test for start of line in mulit-line mode','line_number':3033,'multiline':False]
['text':' We are at the start input.  Success.','line_number':3036,'multiline':False]
['text':' Check whether character just before the current pos is a new-line','line_number':3039,'multiline':False]
['text':'   unless we are at the end of input','line_number':3040,'multiline':False]
['text':'  It's a new-line.  ^ is true.  Success.','line_number':3044,'multiline':False]
['text':'  TODO:  what should be done with positions between a CR and LF?','line_number':3045,'multiline':False]
['text':' Not at the start of a line.  Fail.','line_number':3048,'multiline':False]
['text':'  ^, test for start of line in mulit-line + Unix-line mode','line_number':3054,'multiline':False]
['text':' We are at the start input.  Success.','line_number':3058,'multiline':False]
['text':' Check whether character just before the current pos is a new-line','line_number':3061,'multiline':False]
['text':' Not at the start of a line.  Back-track out.','line_number':3066,'multiline':False]
['text':' Test for word boundaries','line_number':3072,'multiline':False]
['text':' flip sense for \B','line_number':3075,'multiline':False]
['text':' Test for word boundaries, Unicode-style','line_number':3083,'multiline':False]
['text':' flip sense for \B','line_number':3086,'multiline':False]
['text':' Test for decimal digit','line_number':3094,'multiline':False]
['text':' TODO:  make a unicode set for this.  Will be faster.','line_number':3105,'multiline':False]
['text':' flip sense for \D','line_number':3107,'multiline':False]
['text':' Test for position at end of previous match','line_number':3117,'multiline':False]
['text':' Test for \h, horizontal white space.','line_number':3124,'multiline':False]
['text':' SPACE_SEPARATOR || TAB','line_number':3134,'multiline':False]
['text':' flip sense for \H','line_number':3135,'multiline':False]
['text':' Test for \R, any line break sequence.','line_number':3145,'multiline':False]
['text':' \v, any single line ending character.','line_number':3166,'multiline':False]
['text':' flip sense for \V','line_number':3176,'multiline':False]
['text':'  Match a Grapheme, as defined by Unicode TR 29.','line_number':3187,'multiline':False]
['text':'  Differs slightly from Perl, which consumes combining marks independently','line_number':3188,'multiline':False]
['text':'    of context.','line_number':3189,'multiline':False]
['text':' Fail if at end of input','line_number':3192,'multiline':False]
['text':' Examine (and consume) the current char.','line_number':3201,'multiline':False]
['text':'   Dispatch into a little state machine, based on the char.','line_number':3202,'multiline':False]
['text':' Combining characters are consumed here','line_number':3250,'multiline':False]
['text':' Most control chars stand alone (don't combine with combining chars),','line_number':3265,'multiline':False]
['text':'   except for that CR/LF sequence is a single grapheme cluster.','line_number':3266,'multiline':False]
['text':' Test for end of Input','line_number':3282,'multiline':False]
['text':' Test input character against one of the predefined sets','line_number':3295,'multiline':False]
['text':'    (Word Characters, for example)','line_number':3296,'multiline':False]
['text':' The high bit of the op value is a flag for the match polarity.','line_number':3297,'multiline':False]
['text':'    0:   success if input char is in set.','line_number':3298,'multiline':False]
['text':'    1:   success if input char is not in set.','line_number':3299,'multiline':False]
['text':' the character wasn't in the set.','line_number':3326,'multiline':False]
['text':' Test input character for NOT being a member of  one of','line_number':3335,'multiline':False]
['text':'    the predefined sets (Word Characters, for example)','line_number':3336,'multiline':False]
['text':' the character wasn't in the set.','line_number':3361,'multiline':False]
['text':' There is input left.  Pick up one char and test it for set membership.','line_number':3375,'multiline':False]
['text':' The character is in the set.  A Match.','line_number':3387,'multiline':False]
['text':' the character wasn't in the set.','line_number':3393,'multiline':False]
['text':' . matches anything, but stops at end-of-line.','line_number':3401,'multiline':False]
['text':' At end of input.  Match failed.  Backtrack out.','line_number':3403,'multiline':False]
['text':' There is input left.  Advance over one char, unless we've hit end-of-line','line_number':3411,'multiline':False]
['text':' End of line in normal mode.   . does not match.','line_number':3414,'multiline':False]
['text':' ., in dot-matches-all (including new lines) mode','line_number':3425,'multiline':False]
['text':' At end of input.  Match failed.  Backtrack out.','line_number':3427,'multiline':False]
['text':' There is input left.  Advance over one char, except if we are','line_number':3435,'multiline':False]
['text':'   at a cr/lf, advance over both of them.','line_number':3436,'multiline':False]
['text':' In the case of a CR/LF, we need to advance over both.','line_number':3441,'multiline':False]
['text':' '.' operator, matches all, but stops at end-of-line.','line_number':3454,'multiline':False]
['text':'   UNIX_LINES mode, so 0x0a is the only recognized line ending.','line_number':3455,'multiline':False]
['text':' At end of input.  Match failed.  Backtrack out.','line_number':3457,'multiline':False]
['text':' There is input left.  Advance over one char, unless we've hit end-of-line','line_number':3465,'multiline':False]
['text':' End of line in normal mode.   '.' does not match the \n','line_number':3468,'multiline':False]
['text':' State save to loc following current','line_number':3487,'multiline':False]
['text':' Then JMP.','line_number':3488,'multiline':False]
['text':' This opcode is used with (x)+, when x can match a zero length string.','line_number':3492,'multiline':False]
['text':' Same as JMP_SAV, except conditional on the match having made forward progress.','line_number':3493,'multiline':False]
['text':' Destination of the JMP must be a URX_STO_INP_LOC, from which we get the','line_number':3494,'multiline':False]
['text':'   data address of the input position at the start of the loop.','line_number':3495,'multiline':False]
['text':' The match did make progress.  Repeat the loop.','line_number':3505,'multiline':False]
['text':' State save to loc following current','line_number':3506,'multiline':False]
['text':' If the input position did not advance, we do nothing here,','line_number':3510,'multiline':False]
['text':'   execution will fall out of the loop.','line_number':3511,'multiline':False]
['text':'  Set the loop counter variable to zero','line_number':3518,'multiline':False]
['text':' Pick up the three extra operands that CTR_INIT has, and','line_number':3520,'multiline':False]
['text':'    skip the pattern location counter past','line_number':3521,'multiline':False]
['text':'  For loop breaking.','line_number':3535,'multiline':False]
['text':' Loop has no hard upper bound.','line_number':3557,'multiline':False]
['text':' Check that it is progressing through the input, break if it is not.','line_number':3558,'multiline':False]
['text':' Loop back.','line_number':3568,'multiline':False]
['text':' Initialize a non-greedy loop','line_number':3574,'multiline':False]
['text':'  Set the loop counter variable to zero','line_number':3576,'multiline':False]
['text':' Pick up the three extra operands that CTR_INIT_NG has, and','line_number':3578,'multiline':False]
['text':'    skip the pattern location counter past','line_number':3579,'multiline':False]
['text':'  Save initial input index for loop breaking.','line_number':3589,'multiline':False]
['text':' Continue with stuff after repeated block','line_number':3596,'multiline':False]
['text':' Non-greedy {min, max} loops','line_number':3603,'multiline':False]
['text':' The loop has matched the maximum permitted number of times.','line_number':3613,'multiline':False]
['text':'   Break out of here with no action.  Matching will','line_number':3614,'multiline':False]
['text':'   continue with the following pattern.','line_number':3615,'multiline':False]
['text':' We haven't met the minimum number of matches yet.','line_number':3621,'multiline':False]
['text':'   Loop back for another one.','line_number':3622,'multiline':False]
['text':' Loop back.','line_number':3623,'multiline':False]
['text':' We do have the minimum number of matches.','line_number':3625,'multiline':False]
['text':' If there is no upper bound on the loop iterations, check that the input index','line_number':3627,'multiline':False]
['text':' is progressing, and stop the loop if it is not.','line_number':3628,'multiline':False]
['text':' Loop Continuation: we will fall into the pattern following the loop','line_number':3637,'multiline':False]
['text':'   (non-greedy, don't execute loop body first), but first do','line_number':3638,'multiline':False]
['text':'   a state save to the top of the loop, so that a match failure','line_number':3639,'multiline':False]
['text':'   in the following pattern will try another iteration of the loop.','line_number':3640,'multiline':False]
['text':' This capture group has not participated in the match thus far,','line_number':3676,'multiline':False]
['text':' FAIL, no match.','line_number':3677,'multiline':False]
['text':'   Note: if the capture group match was of an empty string the backref','line_number':3683,'multiline':False]
['text':'         match succeeds.  Verified by testing:  Perl matches succeed','line_number':3684,'multiline':False]
['text':'         in this case, so we do too.','line_number':3685,'multiline':False]
['text':' This capture group has not participated in the match thus far,','line_number':3723,'multiline':False]
['text':' FAIL, no match.','line_number':3724,'multiline':False]
['text':'   Note: if the capture group match was of an empty string the backref','line_number':3732,'multiline':False]
['text':'         match succeeds.  Verified by testing:  Perl matches succeed','line_number':3733,'multiline':False]
['text':'         in this case, so we do too.','line_number':3734,'multiline':False]
['text':' We otained a match by consuming part of a string obtained from','line_number':3756,'multiline':False]
['text':' case-folding a single code point of the input text.','line_number':3757,'multiline':False]
['text':' This does not count as an overall match.','line_number':3758,'multiline':False]
['text':' JMP','line_number':3787,'multiline':False]
['text':' FAIL, no progress in loop.','line_number':3789,'multiline':False]
['text':' Entering a lookahead block.','line_number':3796,'multiline':False]
['text':' Save Stack Ptr, Input Pos.','line_number':3797,'multiline':False]
['text':' Set the match region change for','line_number':3801,'multiline':False]
['text':'   transparent bounds.','line_number':3802,'multiline':False]
['text':' Leaving a look-ahead block.','line_number':3808,'multiline':False]
['text':'  restore Stack Ptr, Input Pos to positions they had on entry to block.','line_number':3809,'multiline':False]
['text':' Copy the current top frame back to the new (cut back) top frame.','line_number':3815,'multiline':False]
['text':'   This makes the capture groups from within the look-ahead','line_number':3816,'multiline':False]
['text':'   expression available.','line_number':3817,'multiline':False]
['text':' Restore the active region bounds in the input string; they may have','line_number':3828,'multiline':False]
['text':'    been changed because of transparent bounds on a Region.','line_number':3829,'multiline':False]
['text':' Case insensitive one char.  The char from the pattern is already case folded.','line_number':3836,'multiline':False]
['text':' Input text is not, but case folding the input can not reduce two or more code','line_number':3837,'multiline':False]
['text':' points to one.','line_number':3838,'multiline':False]
['text':' Case-insensitive test input against a literal string.','line_number':3856,'multiline':False]
['text':' Strings require two slots in the compiled pattern, one for the','line_number':3857,'multiline':False]
['text':'   offset to the string text, and one for the length.','line_number':3858,'multiline':False]
['text':'   The compiled string has already been case folded.','line_number':3859,'multiline':False]
['text':' Length of the string from the pattern.','line_number':3869,'multiline':False]
['text':' Entering a look-behind block.','line_number':3906,'multiline':False]
['text':' Save Stack Ptr, Input Pos.','line_number':3907,'multiline':False]
['text':'   TODO:  implement transparent bounds.  Ticket #6067','line_number':3908,'multiline':False]
['text':' Init the variable containing the start index for attempted matches.','line_number':3912,'multiline':False]
['text':' Save input string length, then reset to pin any matches to end at','line_number':3914,'multiline':False]
['text':'   the current position.','line_number':3915,'multiline':False]
['text':' Positive Look-Behind, at top of loop checking for matches of LB expression','line_number':3924,'multiline':False]
['text':'    at all possible input starting positions.','line_number':3925,'multiline':False]
['text':' Fetch the min and max possible match lengths.  They are the operands','line_number':3927,'multiline':False]
['text':'   of this op in the pattern.','line_number':3928,'multiline':False]
['text':' utf-8 fix to maximum match length. The pattern compiler assumes utf-16.','line_number':3932,'multiline':False]
['text':' The max length need not be exact; it just needs to be >= actual maximum.','line_number':3933,'multiline':False]
['text':' Fetch (from data) the last input index where a match was attempted.','line_number':3939,'multiline':False]
['text':' First time through loop.','line_number':3943,'multiline':False]
['text':' move index to a code point boudary, if it's not on one already.','line_number':3946,'multiline':False]
['text':' 2nd through nth time through the loop.','line_number':3951,'multiline':False]
['text':' Back up start position for match by one.','line_number':3952,'multiline':False]
['text':' We have tried all potential match starting points without','line_number':3963,'multiline':False]
['text':'  getting a match.  Backtrack out, and out of the','line_number':3964,'multiline':False]
['text':'   Look Behind altogether.','line_number':3965,'multiline':False]
['text':'    Save state to this URX_LB_CONT op, so failure to match will repeat the loop.','line_number':3974,'multiline':False]
['text':'      (successful match will fall off the end of the loop.)','line_number':3975,'multiline':False]
['text':' End of a look-behind block, after a successful match.','line_number':3982,'multiline':False]
['text':'  The look-behind expression matched, but the match did not','line_number':3986,'multiline':False]
['text':'    extend all the way to the point that we are looking behind from.','line_number':3987,'multiline':False]
['text':'  FAIL out of here, which will take us back to the LB_CONT, which','line_number':3988,'multiline':False]
['text':'     will retry the match starting at another position or fail','line_number':3989,'multiline':False]
['text':'     the look-behind altogether, whichever is appropriate.','line_number':3990,'multiline':False]
['text':' Look-behind match is good.  Restore the orignal input string length,','line_number':3995,'multiline':False]
['text':'   which had been truncated to pin the end of the lookbehind match to the','line_number':3996,'multiline':False]
['text':'   position being looked-behind.','line_number':3997,'multiline':False]
['text':' Negative Look-Behind, at top of loop checking for matches of LB expression','line_number':4008,'multiline':False]
['text':'    at all possible input starting positions.','line_number':4009,'multiline':False]
['text':' Fetch the extra parameters of this op.','line_number':4011,'multiline':False]
['text':' utf-8 fix to maximum match length. The pattern compiler assumes utf-16.','line_number':4015,'multiline':False]
['text':' The max length need not be exact; it just needs to be >= actual maximum.','line_number':4016,'multiline':False]
['text':' Fetch (from data) the last input index where a match was attempted.','line_number':4025,'multiline':False]
['text':' First time through loop.','line_number':4029,'multiline':False]
['text':' move index to a code point boudary, if it's not on one already.','line_number':4032,'multiline':False]
['text':' 2nd through nth time through the loop.','line_number':4037,'multiline':False]
['text':' Back up start position for match by one.','line_number':4038,'multiline':False]
['text':' We have tried all potential match starting points without','line_number':4049,'multiline':False]
['text':'  getting a match, which means that the negative lookbehind as','line_number':4050,'multiline':False]
['text':'  a whole has succeeded.  Jump forward to the continue location','line_number':4051,'multiline':False]
['text':'    Save state to this URX_LB_CONT op, so failure to match will repeat the loop.','line_number':4060,'multiline':False]
['text':'      (successful match will cause a FAIL out of the loop altogether.)','line_number':4061,'multiline':False]
['text':' End of a negative look-behind block, after a successful match.','line_number':4068,'multiline':False]
['text':'  The look-behind expression matched, but the match did not','line_number':4072,'multiline':False]
['text':'    extend all the way to the point that we are looking behind from.','line_number':4073,'multiline':False]
['text':'  FAIL out of here, which will take us back to the LB_CONT, which','line_number':4074,'multiline':False]
['text':'     will retry the match starting at another position or succeed','line_number':4075,'multiline':False]
['text':'     the look-behind altogether, whichever is appropriate.','line_number':4076,'multiline':False]
['text':' Look-behind expression matched, which means look-behind test as','line_number':4081,'multiline':False]
['text':'   a whole Fails','line_number':4082,'multiline':False]
['text':'   Restore the orignal input string length, which had been truncated','line_number':4084,'multiline':False]
['text':'   inorder to pin the end of the lookbehind match','line_number':4085,'multiline':False]
['text':'   to the position being looked-behind.','line_number':4086,'multiline':False]
['text':' Restore original stack position, discarding any state saved','line_number':4092,'multiline':False]
['text':'   by the successful pattern match.','line_number':4093,'multiline':False]
['text':'  FAIL, which will take control back to someplace','line_number':4099,'multiline':False]
['text':'  prior to entering the look-behind test.','line_number':4100,'multiline':False]
['text':' Loop Initialization for the optimized implementation of','line_number':4107,'multiline':False]
['text':'     [some character set]*','line_number':4108,'multiline':False]
['text':'   This op scans through all matching input.','line_number':4109,'multiline':False]
['text':'   The following LOOP_C op emulates stack unwinding if the following pattern fails.','line_number':4110,'multiline':False]
['text':' Loop through input, until either the input is exhausted or','line_number':4116,'multiline':False]
['text':'   we reach a character that is not a member of the set.','line_number':4117,'multiline':False]
['text':' If there were no matching characters, skip over the loop altogether.','line_number':4138,'multiline':False]
['text':'   The loop doesn't run at all, a * op always succeeds.','line_number':4139,'multiline':False]
['text':' skip the URX_LOOP_C op.','line_number':4141,'multiline':False]
['text':' Peek ahead in the compiled pattern, to the URX_LOOP_C that','line_number':4145,'multiline':False]
['text':'   must follow.  It's operand is the stack location','line_number':4146,'multiline':False]
['text':'   that holds the starting input index for the match of this [set]*','line_number':4147,'multiline':False]
['text':' Save State to the URX_LOOP_C op that follows this one,','line_number':4155,'multiline':False]
['text':'   so that match failures in the following code will return to there.','line_number':4156,'multiline':False]
['text':'   Then bump the pattern idx so the LOOP_C is skipped on the way out of here.','line_number':4157,'multiline':False]
['text':' Loop Initialization for the optimized implementation of .*','line_number':4165,'multiline':False]
['text':'   This op scans through all remaining input.','line_number':4166,'multiline':False]
['text':'   The following LOOP_C op emulates stack unwinding if the following pattern fails.','line_number':4167,'multiline':False]
['text':' Loop through input until the input is exhausted (we reach an end-of-line)','line_number':4169,'multiline':False]
['text':' In DOTALL mode, we can just go straight to the end of the input.','line_number':4170,'multiline':False]
['text':' Dot-matches-All mode.  Jump straight to the end of the string.','line_number':4173,'multiline':False]
['text':' NOT DOT ALL mode.  Line endings do not match '.'','line_number':4177,'multiline':False]
['text':' Scan forward until a line ending or end of input.','line_number':4178,'multiline':False]
['text':' Fast filter of non-new-line-s','line_number':4187,'multiline':False]
['text':'  0x0a is newline in both modes.','line_number':4188,'multiline':False]
['text':' IF not UNIX_LINES mode','line_number':4189,'multiline':False]
['text':'  char is a line ending.  Exit the scanning loop.','line_number':4191,'multiline':False]
['text':' If there were no matching characters, skip over the loop altogether.','line_number':4199,'multiline':False]
['text':'   The loop doesn't run at all, a * op always succeeds.','line_number':4200,'multiline':False]
['text':' skip the URX_LOOP_C op.','line_number':4202,'multiline':False]
['text':' Peek ahead in the compiled pattern, to the URX_LOOP_C that','line_number':4206,'multiline':False]
['text':'   must follow.  It's operand is the stack location','line_number':4207,'multiline':False]
['text':'   that holds the starting input index for the match of this .*','line_number':4208,'multiline':False]
['text':' Save State to the URX_LOOP_C op that follows this one,','line_number':4216,'multiline':False]
['text':'   so that match failures in the following code will return to there.','line_number':4217,'multiline':False]
['text':'   Then bump the pattern idx so the LOOP_C is skipped on the way out of here.','line_number':4218,'multiline':False]
['text':' We've backed up the input idx to the point that the loop started.','line_number':4231,'multiline':False]
['text':' The loop is done.  Leave here without saving state.','line_number':4232,'multiline':False]
['text':'  Subsequent failures won't come back here.','line_number':4233,'multiline':False]
['text':' Set up for the next iteration of the loop, with input index','line_number':4236,'multiline':False]
['text':'   backed up by one from the last time through,','line_number':4237,'multiline':False]
['text':'   and a state save to this instruction in case the following code fails again.','line_number':4238,'multiline':False]
['text':'   (We're going backwards because this loop emulates stack unwinding, not','line_number':4239,'multiline':False]
['text':'    the initial scan forward.)','line_number':4240,'multiline':False]
['text':' .*, stepping back over CRLF pair.','line_number':4252,'multiline':False]
['text':' Trouble.  The compiled pattern contains an entry with an','line_number':4265,'multiline':False]
['text':'           unrecognized type tag.','line_number':4266,'multiline':False]
['text':' The active stack frame when the engine stopped.','line_number':4294,'multiline':False]
['text':'   Contains the capture group results that we need to','line_number':4295,'multiline':False]
['text':'    access later.','line_number':4296,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':4301,'multiline':False]
['text':'','line_number':4302,'multiline':False]
['text':'   MatchChunkAt   This is the actual matching engine. Like MatchAt, but with the','line_number':4303,'multiline':False]
['text':'                  assumption that the entire string is available in the UText's','line_number':4304,'multiline':False]
['text':'                  chunk buffer. For now, that means we can use int32_t indexes,','line_number':4305,'multiline':False]
['text':'                  except for anything that needs to be saved (like group starts','line_number':4306,'multiline':False]
['text':'                  and ends).','line_number':4307,'multiline':False]
['text':'','line_number':4308,'multiline':False]
['text':'                  startIdx:    begin matching a this index.','line_number':4309,'multiline':False]
['text':'                  toEnd:       if true, match must extend to end of the input region','line_number':4310,'multiline':False]
['text':'','line_number':4311,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':4312,'multiline':False]
['text':' True if the we have a match.','line_number':4314,'multiline':False]
['text':' used after greedy single-character matches for searching backwards','line_number':4316,'multiline':False]
['text':' Operation from the compiled pattern, split into','line_number':4318,'multiline':False]
['text':'    the opcode','line_number':4319,'multiline':False]
['text':'    and the operand value.','line_number':4320,'multiline':False]
['text':'  Cache frequently referenced items from the compiled pattern','line_number':4334,'multiline':False]
['text':'','line_number':4335,'multiline':False]
['text':' Zero out the pattern's static data','line_number':4353,'multiline':False]
['text':'','line_number':4359,'multiline':False]
['text':'  Main loop for interpreting the compiled pattern.','line_number':4360,'multiline':False]
['text':'  One iteration of the loop per pattern operation performed.','line_number':4361,'multiline':False]
['text':'','line_number':4362,'multiline':False]
['text':' Force a backtrack.  In some circumstances, the pattern compiler','line_number':4385,'multiline':False]
['text':'   will notice that the pattern can't possibly match anything, and will','line_number':4386,'multiline':False]
['text':'   emit one of these at that point.','line_number':4387,'multiline':False]
['text':' Test input against a literal string.','line_number':4408,'multiline':False]
['text':' Strings require two slots in the compiled pattern, one for the','line_number':4409,'multiline':False]
['text':'   offset to the string text, and one for the length.','line_number':4410,'multiline':False]
['text':' Fetch the second operand','line_number':4414,'multiline':False]
['text':' The match loop will exit via this path on a successful match,','line_number':4453,'multiline':False]
['text':'   when we reach the end of the pattern.','line_number':4454,'multiline':False]
['text':' The pattern matched, but not to the end of input.  Try some more.','line_number':4456,'multiline':False]
['text':' Start and End Capture stack frame variables are laid out out like this:','line_number':4463,'multiline':False]
['text':'  fp->fExtra[opValue]  - The start of a completed capture group','line_number':4464,'multiline':False]
['text':'             opValue+1 - The end   of a completed capture group','line_number':4465,'multiline':False]
['text':'             opValue+2 - the start of a capture group whose end','line_number':4466,'multiline':False]
['text':'                          has not yet been reached (and might not ever be).','line_number':4467,'multiline':False]
['text':' Start pos for this group must be set.','line_number':4476,'multiline':False]
['text':' Tentative start becomes real.','line_number':4477,'multiline':False]
['text':' End position','line_number':4478,'multiline':False]
['text':'  $, test for End of line','line_number':4483,'multiline':False]
['text':'     or for position before new line at end of input','line_number':4484,'multiline':False]
['text':' We are no where near the end of input.  Fail.','line_number':4486,'multiline':False]
['text':'   This is the common case.  Keep it first.','line_number':4487,'multiline':False]
['text':' We really are at the end of input.  Success.','line_number':4492,'multiline':False]
['text':' If we are positioned just before a new-line that is located at the','line_number':4498,'multiline':False]
['text':'   end of input, succeed.','line_number':4499,'multiline':False]
['text':' At new-line at end of input. Success','line_number':4506,'multiline':False]
['text':' At CR/LF at end of input.  Success','line_number':4516,'multiline':False]
['text':'  $, test for End of Line, in UNIX_LINES mode.','line_number':4524,'multiline':False]
['text':' Either at the last character of input, or off the end.','line_number':4526,'multiline':False]
['text':' At last char of input.  Success if it's a new line.','line_number':4528,'multiline':False]
['text':' Off the end of input.  Success.','line_number':4535,'multiline':False]
['text':' Not at end of input.  Back-track out.','line_number':4542,'multiline':False]
['text':'  $, test for End of line in multi-line mode','line_number':4547,'multiline':False]
['text':' We really are at the end of input.  Success.','line_number':4550,'multiline':False]
['text':' If we are positioned just before a new-line, succeed.','line_number':4555,'multiline':False]
['text':' It makes no difference where the new-line is within the input.','line_number':4556,'multiline':False]
['text':' At a line end, except for the odd chance of  being in the middle of a CR/LF sequence','line_number':4559,'multiline':False]
['text':'  In multi-line mode, hitting a new-line just before the end of input does not','line_number':4560,'multiline':False]
['text':'   set the hitEnd or requireEnd flags','line_number':4561,'multiline':False]
['text':' not at a new line.  Fail.','line_number':4566,'multiline':False]
['text':'  $, test for End of line in multi-line and UNIX_LINES mode','line_number':4572,'multiline':False]
['text':' We really are at the end of input.  Success.','line_number':4575,'multiline':False]
['text':' Java set requireEnd in this case, even though','line_number':4577,'multiline':False]
['text':'   adding a new-line would not lose the match.','line_number':4578,'multiline':False]
['text':' If we are not positioned just before a new-line, the test fails; backtrack out.','line_number':4580,'multiline':False]
['text':' It makes no difference where the new-line is within the input.','line_number':4581,'multiline':False]
['text':'  ^, test for start of line','line_number':4589,'multiline':False]
['text':'  ^, test for start of line in mulit-line mode','line_number':4596,'multiline':False]
['text':' We are at the start input.  Success.','line_number':4599,'multiline':False]
['text':' Check whether character just before the current pos is a new-line','line_number':4602,'multiline':False]
['text':'   unless we are at the end of input','line_number':4603,'multiline':False]
['text':'  It's a new-line.  ^ is true.  Success.','line_number':4607,'multiline':False]
['text':'  TODO:  what should be done with positions between a CR and LF?','line_number':4608,'multiline':False]
['text':' Not at the start of a line.  Fail.','line_number':4611,'multiline':False]
['text':'  ^, test for start of line in mulit-line + Unix-line mode','line_number':4617,'multiline':False]
['text':' We are at the start input.  Success.','line_number':4621,'multiline':False]
['text':' Check whether character just before the current pos is a new-line','line_number':4624,'multiline':False]
['text':' Not at the start of a line.  Back-track out.','line_number':4628,'multiline':False]
['text':' Test for word boundaries','line_number':4634,'multiline':False]
['text':' flip sense for \B','line_number':4637,'multiline':False]
['text':' Test for word boundaries, Unicode-style','line_number':4645,'multiline':False]
['text':' flip sense for \B','line_number':4648,'multiline':False]
['text':' Test for decimal digit','line_number':4656,'multiline':False]
['text':' TODO:  make a unicode set for this.  Will be faster.','line_number':4666,'multiline':False]
['text':' flip sense for \D','line_number':4668,'multiline':False]
['text':' Test for position at end of previous match','line_number':4676,'multiline':False]
['text':' Test for \h, horizontal white space.','line_number':4683,'multiline':False]
['text':' SPACE_SEPARATOR || TAB','line_number':4693,'multiline':False]
['text':' flip sense for \H','line_number':4694,'multiline':False]
['text':' Test for \R, any line break sequence.','line_number':4702,'multiline':False]
['text':' Check for CR/LF sequence. Consume both together when found.','line_number':4713,'multiline':False]
['text':' Any single code point line ending.','line_number':4727,'multiline':False]
['text':' flip sense for \V','line_number':4737,'multiline':False]
['text':'  Match a Grapheme, as defined by Unicode TR 29.','line_number':4747,'multiline':False]
['text':'  Differs slightly from Perl, which consumes combining marks independently','line_number':4748,'multiline':False]
['text':'    of context.','line_number':4749,'multiline':False]
['text':' Fail if at end of input','line_number':4752,'multiline':False]
['text':' Examine (and consume) the current char.','line_number':4759,'multiline':False]
['text':'   Dispatch into a little state machine, based on the char.','line_number':4760,'multiline':False]
['text':' Combining characters are consumed here','line_number':4801,'multiline':False]
['text':' Most control chars stand alone (don't combine with combining chars),','line_number':4815,'multiline':False]
['text':'   except for that CR/LF sequence is a single grapheme cluster.','line_number':4816,'multiline':False]
['text':' Test for end of Input','line_number':4831,'multiline':False]
['text':' Test input character against one of the predefined sets','line_number':4844,'multiline':False]
['text':'    (Word Characters, for example)','line_number':4845,'multiline':False]
['text':' The high bit of the op value is a flag for the match polarity.','line_number':4846,'multiline':False]
['text':'    0:   success if input char is in set.','line_number':4847,'multiline':False]
['text':'    1:   success if input char is not in set.','line_number':4848,'multiline':False]
['text':' Test input character for NOT being a member of  one of','line_number':4881,'multiline':False]
['text':'    the predefined sets (Word Characters, for example)','line_number':4882,'multiline':False]
['text':' There is input left.  Pick up one char and test it for set membership.','line_number':4919,'multiline':False]
['text':' The character is in the set.  A Match.','line_number':4925,'multiline':False]
['text':' The character is in the set.  A Match.','line_number':4931,'multiline':False]
['text':' the character wasn't in the set.','line_number':4936,'multiline':False]
['text':' . matches anything, but stops at end-of-line.','line_number':4944,'multiline':False]
['text':' At end of input.  Match failed.  Backtrack out.','line_number':4946,'multiline':False]
['text':' There is input left.  Advance over one char, unless we've hit end-of-line','line_number':4952,'multiline':False]
['text':' End of line in normal mode.   . does not match.','line_number':4956,'multiline':False]
['text':' . in dot-matches-all (including new lines) mode','line_number':4966,'multiline':False]
['text':' At end of input.  Match failed.  Backtrack out.','line_number':4968,'multiline':False]
['text':' There is input left.  Advance over one char, except if we are','line_number':4974,'multiline':False]
['text':'   at a cr/lf, advance over both of them.','line_number':4975,'multiline':False]
['text':' In the case of a CR/LF, we need to advance over both.','line_number':4979,'multiline':False]
['text':' '.' operator, matches all, but stops at end-of-line.','line_number':4990,'multiline':False]
['text':'   UNIX_LINES mode, so 0x0a is the only recognized line ending.','line_number':4991,'multiline':False]
['text':' At end of input.  Match failed.  Backtrack out.','line_number':4993,'multiline':False]
['text':' There is input left.  Advance over one char, unless we've hit end-of-line','line_number':4999,'multiline':False]
['text':' End of line in normal mode.   '.' does not match the \n','line_number':5003,'multiline':False]
['text':' State save to loc following current','line_number':5020,'multiline':False]
['text':' Then JMP.','line_number':5021,'multiline':False]
['text':' This opcode is used with (x)+, when x can match a zero length string.','line_number':5025,'multiline':False]
['text':' Same as JMP_SAV, except conditional on the match having made forward progress.','line_number':5026,'multiline':False]
['text':' Destination of the JMP must be a URX_STO_INP_LOC, from which we get the','line_number':5027,'multiline':False]
['text':'   data address of the input position at the start of the loop.','line_number':5028,'multiline':False]
['text':' The match did make progress.  Repeat the loop.','line_number':5038,'multiline':False]
['text':' State save to loc following current','line_number':5039,'multiline':False]
['text':' If the input position did not advance, we do nothing here,','line_number':5043,'multiline':False]
['text':'   execution will fall out of the loop.','line_number':5044,'multiline':False]
['text':'  Set the loop counter variable to zero','line_number':5051,'multiline':False]
['text':' Pick up the three extra operands that CTR_INIT has, and','line_number':5053,'multiline':False]
['text':'    skip the pattern location counter past','line_number':5054,'multiline':False]
['text':'  For loop breaking.','line_number':5068,'multiline':False]
['text':' Loop has no hard upper bound.','line_number':5090,'multiline':False]
['text':' Check that it is progressing through the input, break if it is not.','line_number':5091,'multiline':False]
['text':' Loop back.','line_number':5101,'multiline':False]
['text':' Initialize a non-greedy loop','line_number':5107,'multiline':False]
['text':'  Set the loop counter variable to zero','line_number':5109,'multiline':False]
['text':' Pick up the three extra operands that CTR_INIT_NG has, and','line_number':5111,'multiline':False]
['text':'    skip the pattern location counter past','line_number':5112,'multiline':False]
['text':'  Save initial input index for loop breaking.','line_number':5122,'multiline':False]
['text':' Continue with stuff after repeated block','line_number':5129,'multiline':False]
['text':' Non-greedy {min, max} loops','line_number':5136,'multiline':False]
['text':' The loop has matched the maximum permitted number of times.','line_number':5146,'multiline':False]
['text':'   Break out of here with no action.  Matching will','line_number':5147,'multiline':False]
['text':'   continue with the following pattern.','line_number':5148,'multiline':False]
['text':' We haven't met the minimum number of matches yet.','line_number':5154,'multiline':False]
['text':'   Loop back for another one.','line_number':5155,'multiline':False]
['text':' Loop back.','line_number':5156,'multiline':False]
['text':' We do have the minimum number of matches.','line_number':5158,'multiline':False]
['text':' If there is no upper bound on the loop iterations, check that the input index','line_number':5160,'multiline':False]
['text':' is progressing, and stop the loop if it is not.','line_number':5161,'multiline':False]
['text':' Loop Continuation: we will fall into the pattern following the loop','line_number':5170,'multiline':False]
['text':'   (non-greedy, don't execute loop body first), but first do','line_number':5171,'multiline':False]
['text':'   a state save to the top of the loop, so that a match failure','line_number':5172,'multiline':False]
['text':'   in the following pattern will try another iteration of the loop.','line_number':5173,'multiline':False]
['text':' This capture group has not participated in the match thus far,','line_number':5210,'multiline':False]
['text':' FAIL, no match.','line_number':5211,'multiline':False]
['text':' Capture group ended with an unpaired lead surrogate.','line_number':5228,'multiline':False]
['text':' Back reference is not permitted to match lead only of a surrogatge pair.','line_number':5229,'multiline':False]
['text':' This capture group has not participated in the match thus far,','line_number':5247,'multiline':False]
['text':' FAIL, no match.','line_number':5248,'multiline':False]
['text':'   Note: if the capture group match was of an empty string the backref','line_number':5254,'multiline':False]
['text':'         match succeeds.  Verified by testing:  Perl matches succeed','line_number':5255,'multiline':False]
['text':'         in this case, so we do too.','line_number':5256,'multiline':False]
['text':' We otained a match by consuming part of a string obtained from','line_number':5278,'multiline':False]
['text':' case-folding a single code point of the input text.','line_number':5279,'multiline':False]
['text':' This does not count as an overall match.','line_number':5280,'multiline':False]
['text':' JMP','line_number':5308,'multiline':False]
['text':' FAIL, no progress in loop.','line_number':5310,'multiline':False]
['text':' Entering a lookahead block.','line_number':5317,'multiline':False]
['text':' Save Stack Ptr, Input Pos.','line_number':5318,'multiline':False]
['text':' Set the match region change for','line_number':5322,'multiline':False]
['text':'   transparent bounds.','line_number':5323,'multiline':False]
['text':' Leaving a look-ahead block.','line_number':5329,'multiline':False]
['text':'  restore Stack Ptr, Input Pos to positions they had on entry to block.','line_number':5330,'multiline':False]
['text':' Copy the current top frame back to the new (cut back) top frame.','line_number':5336,'multiline':False]
['text':'   This makes the capture groups from within the look-ahead','line_number':5337,'multiline':False]
['text':'   expression available.','line_number':5338,'multiline':False]
['text':' Restore the active region bounds in the input string; they may have','line_number':5349,'multiline':False]
['text':'    been changed because of transparent bounds on a Region.','line_number':5350,'multiline':False]
['text':' Case-insensitive test input against a literal string.','line_number':5370,'multiline':False]
['text':' Strings require two slots in the compiled pattern, one for the','line_number':5371,'multiline':False]
['text':'   offset to the string text, and one for the length.','line_number':5372,'multiline':False]
['text':'   The compiled string has already been case folded.','line_number':5373,'multiline':False]
['text':' Length of the string from the pattern.','line_number':5382,'multiline':False]
['text':' Entering a look-behind block.','line_number':5414,'multiline':False]
['text':' Save Stack Ptr, Input Pos.','line_number':5415,'multiline':False]
['text':'   TODO:  implement transparent bounds.  Ticket #6067','line_number':5416,'multiline':False]
['text':' Init the variable containing the start index for attempted matches.','line_number':5420,'multiline':False]
['text':' Save input string length, then reset to pin any matches to end at','line_number':5422,'multiline':False]
['text':'   the current position.','line_number':5423,'multiline':False]
['text':' Positive Look-Behind, at top of loop checking for matches of LB expression','line_number':5432,'multiline':False]
['text':'    at all possible input starting positions.','line_number':5433,'multiline':False]
['text':' Fetch the min and max possible match lengths.  They are the operands','line_number':5435,'multiline':False]
['text':'   of this op in the pattern.','line_number':5436,'multiline':False]
['text':' Fetch (from data) the last input index where a match was attempted.','line_number':5442,'multiline':False]
['text':' First time through loop.','line_number':5446,'multiline':False]
['text':' 2nd through nth time through the loop.','line_number':5452,'multiline':False]
['text':' Back up start position for match by one.','line_number':5453,'multiline':False]
['text':' We have tried all potential match starting points without','line_number':5462,'multiline':False]
['text':'  getting a match.  Backtrack out, and out of the','line_number':5463,'multiline':False]
['text':'   Look Behind altogether.','line_number':5464,'multiline':False]
['text':'    Save state to this URX_LB_CONT op, so failure to match will repeat the loop.','line_number':5473,'multiline':False]
['text':'      (successful match will fall off the end of the loop.)','line_number':5474,'multiline':False]
['text':' End of a look-behind block, after a successful match.','line_number':5481,'multiline':False]
['text':'  The look-behind expression matched, but the match did not','line_number':5485,'multiline':False]
['text':'    extend all the way to the point that we are looking behind from.','line_number':5486,'multiline':False]
['text':'  FAIL out of here, which will take us back to the LB_CONT, which','line_number':5487,'multiline':False]
['text':'     will retry the match starting at another position or fail','line_number':5488,'multiline':False]
['text':'     the look-behind altogether, whichever is appropriate.','line_number':5489,'multiline':False]
['text':' Look-behind match is good.  Restore the orignal input string length,','line_number':5494,'multiline':False]
['text':'   which had been truncated to pin the end of the lookbehind match to the','line_number':5495,'multiline':False]
['text':'   position being looked-behind.','line_number':5496,'multiline':False]
['text':' Negative Look-Behind, at top of loop checking for matches of LB expression','line_number':5507,'multiline':False]
['text':'    at all possible input starting positions.','line_number':5508,'multiline':False]
['text':' Fetch the extra parameters of this op.','line_number':5510,'multiline':False]
['text':' Fetch (from data) the last input index where a match was attempted.','line_number':5519,'multiline':False]
['text':' First time through loop.','line_number':5523,'multiline':False]
['text':' 2nd through nth time through the loop.','line_number':5529,'multiline':False]
['text':' Back up start position for match by one.','line_number':5530,'multiline':False]
['text':' Because U16_BACK is unsafe starting at 0.','line_number':5532,'multiline':False]
['text':' We have tried all potential match starting points without','line_number':5539,'multiline':False]
['text':'  getting a match, which means that the negative lookbehind as','line_number':5540,'multiline':False]
['text':'  a whole has succeeded.  Jump forward to the continue location','line_number':5541,'multiline':False]
['text':'    Save state to this URX_LB_CONT op, so failure to match will repeat the loop.','line_number':5550,'multiline':False]
['text':'      (successful match will cause a FAIL out of the loop altogether.)','line_number':5551,'multiline':False]
['text':' End of a negative look-behind block, after a successful match.','line_number':5558,'multiline':False]
['text':'  The look-behind expression matched, but the match did not','line_number':5562,'multiline':False]
['text':'    extend all the way to the point that we are looking behind from.','line_number':5563,'multiline':False]
['text':'  FAIL out of here, which will take us back to the LB_CONT, which','line_number':5564,'multiline':False]
['text':'     will retry the match starting at another position or succeed','line_number':5565,'multiline':False]
['text':'     the look-behind altogether, whichever is appropriate.','line_number':5566,'multiline':False]
['text':' Look-behind expression matched, which means look-behind test as','line_number':5571,'multiline':False]
['text':'   a whole Fails','line_number':5572,'multiline':False]
['text':'   Restore the orignal input string length, which had been truncated','line_number':5574,'multiline':False]
['text':'   inorder to pin the end of the lookbehind match','line_number':5575,'multiline':False]
['text':'   to the position being looked-behind.','line_number':5576,'multiline':False]
['text':' Restore original stack position, discarding any state saved','line_number':5582,'multiline':False]
['text':'   by the successful pattern match.','line_number':5583,'multiline':False]
['text':'  FAIL, which will take control back to someplace','line_number':5589,'multiline':False]
['text':'  prior to entering the look-behind test.','line_number':5590,'multiline':False]
['text':' Loop Initialization for the optimized implementation of','line_number':5597,'multiline':False]
['text':'     [some character set]*','line_number':5598,'multiline':False]
['text':'   This op scans through all matching input.','line_number':5599,'multiline':False]
['text':'   The following LOOP_C op emulates stack unwinding if the following pattern fails.','line_number':5600,'multiline':False]
['text':' Loop through input, until either the input is exhausted or','line_number':5606,'multiline':False]
['text':'   we reach a character that is not a member of the set.','line_number':5607,'multiline':False]
['text':' If there were no matching characters, skip over the loop altogether.','line_number':5629,'multiline':False]
['text':'   The loop doesn't run at all, a * op always succeeds.','line_number':5630,'multiline':False]
['text':' skip the URX_LOOP_C op.','line_number':5632,'multiline':False]
['text':' Peek ahead in the compiled pattern, to the URX_LOOP_C that','line_number':5636,'multiline':False]
['text':'   must follow.  It's operand is the stack location','line_number':5637,'multiline':False]
['text':'   that holds the starting input index for the match of this [set]*','line_number':5638,'multiline':False]
['text':' Save State to the URX_LOOP_C op that follows this one,','line_number':5646,'multiline':False]
['text':'   so that match failures in the following code will return to there.','line_number':5647,'multiline':False]
['text':'   Then bump the pattern idx so the LOOP_C is skipped on the way out of here.','line_number':5648,'multiline':False]
['text':' Loop Initialization for the optimized implementation of .*','line_number':5656,'multiline':False]
['text':'   This op scans through all remaining input.','line_number':5657,'multiline':False]
['text':'   The following LOOP_C op emulates stack unwinding if the following pattern fails.','line_number':5658,'multiline':False]
['text':' Loop through input until the input is exhausted (we reach an end-of-line)','line_number':5660,'multiline':False]
['text':' In DOTALL mode, we can just go straight to the end of the input.','line_number':5661,'multiline':False]
['text':' Dot-matches-All mode.  Jump straight to the end of the string.','line_number':5664,'multiline':False]
['text':' NOT DOT ALL mode.  Line endings do not match '.'','line_number':5668,'multiline':False]
['text':' Scan forward until a line ending or end of input.','line_number':5669,'multiline':False]
['text':' c = inputBuf[ix++]','line_number':5677,'multiline':False]
['text':' Fast filter of non-new-line-s','line_number':5678,'multiline':False]
['text':'  0x0a is newline in both modes.','line_number':5679,'multiline':False]
['text':' IF not UNIX_LINES mode','line_number':5680,'multiline':False]
['text':'  char is a line ending.  Put the input pos back to the','line_number':5682,'multiline':False]
['text':'    line ending char, and exit the scanning loop.','line_number':5683,'multiline':False]
['text':' If there were no matching characters, skip over the loop altogether.','line_number':5691,'multiline':False]
['text':'   The loop doesn't run at all, a * op always succeeds.','line_number':5692,'multiline':False]
['text':' skip the URX_LOOP_C op.','line_number':5694,'multiline':False]
['text':' Peek ahead in the compiled pattern, to the URX_LOOP_C that','line_number':5698,'multiline':False]
['text':'   must follow.  It's operand is the stack location','line_number':5699,'multiline':False]
['text':'   that holds the starting input index for the match of this .*','line_number':5700,'multiline':False]
['text':' Save State to the URX_LOOP_C op that follows this one,','line_number':5708,'multiline':False]
['text':'   so that match failures in the following code will return to there.','line_number':5709,'multiline':False]
['text':'   Then bump the pattern idx so the LOOP_C is skipped on the way out of here.','line_number':5710,'multiline':False]
['text':' We've backed up the input idx to the point that the loop started.','line_number':5723,'multiline':False]
['text':' The loop is done.  Leave here without saving state.','line_number':5724,'multiline':False]
['text':'  Subsequent failures won't come back here.','line_number':5725,'multiline':False]
['text':' Set up for the next iteration of the loop, with input index','line_number':5728,'multiline':False]
['text':'   backed up by one from the last time through,','line_number':5729,'multiline':False]
['text':'   and a state save to this instruction in case the following code fails again.','line_number':5730,'multiline':False]
['text':'   (We're going backwards because this loop emulates stack unwinding, not','line_number':5731,'multiline':False]
['text':'    the initial scan forward.)','line_number':5732,'multiline':False]
['text':' !!!: should this 0 be one of f*Limit?','line_number':5735,'multiline':False]
['text':' .*, stepping back over CRLF pair.','line_number':5742,'multiline':False]
['text':' Trouble.  The compiled pattern contains an entry with an','line_number':5755,'multiline':False]
['text':'           unrecognized type tag.','line_number':5756,'multiline':False]
['text':' The active stack frame when the engine stopped.','line_number':5784,'multiline':False]
['text':'   Contains the capture group results that we need to','line_number':5785,'multiline':False]
['text':'    access later.','line_number':5786,'multiline':False]
['text':' !UCONFIG_NO_REGULAR_EXPRESSIONS','line_number':5796,'multiline':False]
