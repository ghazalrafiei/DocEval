['text':'
*******************************************************************************
* Copyright (C) 1997-2013, International Business Machines Corporation and    *
* others. All Rights Reserved.                                                *
*******************************************************************************
*
* File CHOICFMT.CPP
*
* Modification History:
*
*   Date        Name        Description
*   02/19/97    aliu        Converted from java.
*   03/20/97    helena      Finished first cut of implementation and got rid 
*                           of nextDouble/previousDouble and replaced with
*                           boolean array.
*   4/10/97     aliu        Clean up.  Modified to work on AIX.
*   06/04/97    helena      Fixed applyPattern(), toPattern() and not to include 
*                           wchar.h.
*   07/09/97    helena      Made ParsePosition into a class.
*   08/06/97    nos         removed overloaded constructor, fixed 'format(array)'
*   07/22/98    stephen     JDK 1.2 Sync - removed UBool array (doubleFlags)
*   02/22/99    stephen     Removed character literals for EBCDIC safety
********************************************************************************
','line_number':1,'multiline':True]
['text':' *****************************************************************************','line_number':41,'multiline':False]
['text':' class ChoiceFormat','line_number':42,'multiline':False]
['text':' *****************************************************************************','line_number':43,'multiline':False]
['text':' Special characters used by ChoiceFormat.  There are two characters','line_number':49,'multiline':False]
['text':' used interchangeably to indicate <=.  Either is parsed, but only','line_number':50,'multiline':False]
['text':' LESS_EQUAL is generated by toPattern().','line_number':51,'multiline':False]
['text':''','line_number':52,'multiline':True]
['text':'<','line_number':53,'multiline':True]
['text':'#','line_number':54,'multiline':True]
['text':'|','line_number':56,'multiline':True]
['text':'-','line_number':57,'multiline':True]
['text':'{','line_number':59,'multiline':True]
['text':'}','line_number':60,'multiline':True]
['text':'static const UChar gPositiveInfinity[] = {INFINITY, 0};','line_number':67,'multiline':False]
['text':'static const UChar gNegativeInfinity[] = {MINUS, INFINITY, 0};','line_number':68,'multiline':False]
['text':' -------------------------------------','line_number':72,'multiline':False]
['text':' Creates a ChoiceFormat instance based on the pattern.','line_number':73,'multiline':False]
['text':' -------------------------------------','line_number':83,'multiline':False]
['text':' Creates a ChoiceFormat instance with the limit array and ','line_number':84,'multiline':False]
['text':' format strings for each limit.','line_number':85,'multiline':False]
['text':' -------------------------------------','line_number':96,'multiline':False]
['text':' -------------------------------------','line_number':108,'multiline':False]
['text':' copy constructor','line_number':109,'multiline':False]
['text':' -------------------------------------','line_number':118,'multiline':False]
['text':' Private constructor that creates a ','line_number':119,'multiline':False]
['text':' ChoiceFormat instance based on the ','line_number':120,'multiline':False]
['text':' pattern and populates UParseError','line_number':121,'multiline':False]
['text':' -------------------------------------','line_number':131,'multiline':False]
['text':' -------------------------------------','line_number':142,'multiline':False]
['text':' copy constructor','line_number':143,'multiline':False]
['text':' -------------------------------------','line_number':156,'multiline':False]
['text':' -------------------------------------','line_number':162,'multiline':False]
['text':'*
 * Convert a double value to a string without the overhead of NumberFormat.
 ','line_number':164,'multiline':True]
['text':' Buffer to contain the digits and any extra formatting stuff. ','line_number':171,'multiline':True]
['text':' Find and convert the decimal point.
       Using setlocale on some machines will cause sprintf to use a comma for certain locales.
    ','line_number':178,'multiline':True]
['text':' We reached something that looks like a decimal point.
        In case someone used setlocale(), which changes the decimal point. ','line_number':185,'multiline':True]
['text':' Search for the exponent ','line_number':190,'multiline':True]
['text':' Verify the exponent sign ','line_number':196,'multiline':True]
['text':' Remove leading zeros. You will see this on Windows machines. ','line_number':200,'multiline':True]
['text':' Shift the exponent without zeros. ','line_number':206,'multiline':True]
['text':' NULL terminate','line_number':210,'multiline':False]
['text':' invariant codepage ','line_number':215,'multiline':True]
['text':' -------------------------------------','line_number':219,'multiline':False]
['text':' calls the overloaded applyPattern method.','line_number':220,'multiline':False]
['text':' -------------------------------------','line_number':230,'multiline':False]
['text':' Applies the pattern to this ChoiceFormat instance.','line_number':231,'multiline':False]
['text':' -------------------------------------','line_number':241,'multiline':False]
['text':' Returns the input pattern string.','line_number':242,'multiline':False]
['text':' -------------------------------------','line_number':250,'multiline':False]
['text':' Sets the limit and format arrays. ','line_number':251,'multiline':False]
['text':' -------------------------------------','line_number':261,'multiline':False]
['text':' Sets the limit and format arrays. ','line_number':262,'multiline':False]
['text':' Reconstruct the original input pattern.','line_number':286,'multiline':False]
['text':' Modified version of the pre-ICU 4.8 toPattern() implementation.','line_number':287,'multiline':False]
['text':' Append formats[i], using quotes if there are special','line_number':307,'multiline':False]
['text':' characters.  Single quotes themselves must be escaped in','line_number':308,'multiline':False]
['text':' either case.','line_number':309,'multiline':False]
['text':' Double each top-level apostrophe.','line_number':316,'multiline':False]
['text':' Surround each pipe symbol with apostrophes for quoting.','line_number':319,'multiline':False]
['text':' If the next character is an apostrophe, then that will be doubled,','line_number':320,'multiline':False]
['text':' and although the parser will see the apostrophe pairs beginning','line_number':321,'multiline':False]
['text':' and ending one character earlier than our doubling, the result','line_number':322,'multiline':False]
['text':' is as desired.','line_number':323,'multiline':False]
['text':'   | -> '|'','line_number':324,'multiline':False]
['text':'   |' -> '|'''','line_number':325,'multiline':False]
['text':'   |'' -> '|''''' etc.','line_number':326,'multiline':False]
['text':' Skip the append(c) at the end of the loop body.','line_number':328,'multiline':False]
['text':' Apply the reconstructed pattern.','line_number':337,'multiline':False]
['text':' -------------------------------------','line_number':341,'multiline':False]
['text':' Gets the limit array.','line_number':342,'multiline':False]
['text':' -------------------------------------','line_number':351,'multiline':False]
['text':' Gets the closures array.','line_number':352,'multiline':False]
['text':' -------------------------------------','line_number':361,'multiline':False]
['text':' Gets the format array.','line_number':362,'multiline':False]
['text':' -------------------------------------','line_number':371,'multiline':False]
['text':' Formats an int64 number, it's actually formatted as','line_number':372,'multiline':False]
['text':' a double.  The returned format string may differ','line_number':373,'multiline':False]
['text':' from the input number because of this.','line_number':374,'multiline':False]
['text':' -------------------------------------','line_number':384,'multiline':False]
['text':' Formats an int32_t number, it's actually formatted as','line_number':385,'multiline':False]
['text':' a double.','line_number':386,'multiline':False]
['text':' -------------------------------------','line_number':396,'multiline':False]
['text':' Formats a double number.','line_number':397,'multiline':False]
['text':'pos','line_number':402,'multiline':True]
['text':' No pattern was applied, or it failed.','line_number':405,'multiline':False]
['text':' Get the appropriate sub-message.','line_number':408,'multiline':False]
['text':' JDK compatibility mode: Remove SKIP_SYNTAX.','line_number':418,'multiline':False]
['text':' Iterate over (ARG_INT|DOUBLE, ARG_SELECTOR, message) tuples','line_number':426,'multiline':False]
['text':' until ARG_LIMIT or end of choice-only pattern.','line_number':427,'multiline':False]
['text':' Ignore the first number and selector and start the loop on the first message.','line_number':428,'multiline':False]
['text':' Skip but remember the current sub-message.','line_number':431,'multiline':False]
['text':' Reached the end of the choice-only pattern.','line_number':435,'multiline':False]
['text':' Return with the last sub-message.','line_number':436,'multiline':False]
['text':' Reached the end of the ChoiceFormat style.','line_number':442,'multiline':False]
['text':' Return with the last sub-message.','line_number':443,'multiline':False]
['text':' part is an ARG_INT or ARG_DOUBLE','line_number':446,'multiline':False]
['text':' Fetch the ARG_SELECTOR character.','line_number':449,'multiline':False]
['text':' The number is in the interval between the previous boundary and the current one.','line_number':453,'multiline':False]
['text':' Return with the sub-message between them.','line_number':454,'multiline':False]
['text':' The !(a>b) and !(a>=b) comparisons are equivalent to','line_number':455,'multiline':False]
['text':' (a<=b) and (a<b) except they "catch" NaN.','line_number':456,'multiline':False]
['text':' -------------------------------------','line_number':463,'multiline':False]
['text':' Formats an array of objects. Checks if the data type of the objects','line_number':464,'multiline':False]
['text':' to get the right value for formatting.  ','line_number':465,'multiline':False]
['text':' -------------------------------------','line_number':493,'multiline':False]
['text':' find the best number (defined as the one with the longest parse)','line_number':507,'multiline':False]
['text':' skip the numeric part and ignore the ARG_SELECTOR','line_number':515,'multiline':False]
['text':' mismatch','line_number':551,'multiline':False]
['text':' SKIP_SYNTAX','line_number':557,'multiline':False]
['text':' -------------------------------------','line_number':562,'multiline':False]
['text':' #if !UCONFIG_NO_FORMATTING ','line_number':573,'multiline':True]
['text':'eof','line_number':575,'multiline':False]
