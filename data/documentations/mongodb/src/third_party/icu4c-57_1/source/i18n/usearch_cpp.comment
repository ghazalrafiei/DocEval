['text':'
**********************************************************************
*   Copyright (C) 2001-2015 IBM and others. All rights reserved.
**********************************************************************
*   Date        Name        Description
*  07/02/2001   synwee      Creation.
**********************************************************************
','line_number':1,'multiline':True]
['text':' don't use Boyer-Moore','line_number':27,'multiline':False]
['text':' (and if we decide to turn this on again there are several new TODOs that will need to be addressed)','line_number':28,'multiline':False]
['text':' internal definition ---------------------------------------------------','line_number':31,'multiline':False]
['text':' internal methods -------------------------------------------------','line_number':39,'multiline':False]
['text':'*
* Fast collation element iterator setOffset.
* This function does not check for bounds.
* @param coleiter collation element iterator
* @param offset to set
','line_number':41,'multiline':True]
['text':' Note: Not "fast" any more after the 2013 collation rewrite.','line_number':51,'multiline':False]
['text':' We do not want to expose more internals than necessary.','line_number':52,'multiline':False]
['text':'*
* Getting the mask for collation strength
* @param strength collation strength
* @return collation element mask
','line_number':57,'multiline':True]
['text':'*
* @param ce 32-bit collation element
* @return hash code
','line_number':77,'multiline':True]
['text':'*
* Initializing the fcd tables.
* Internal method, status assumed to be a success.
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
','line_number':104,'multiline':True]
['text':'*
* Gets the fcd value for a character at the argument index.
* This method takes into accounts of the supplementary characters.
* @param str UTF16 string where character for fcd retrieval resides
* @param offset position of the character whose fcd is to be retrieved, to be
*               overwritten with the next character position, taking
*               surrogate characters into consideration.
* @param strlength length of the argument string
* @return fcd value
','line_number':119,'multiline':True]
['text':'*
* Getting the modified collation elements taking into account the collation
* attributes
* @param strsrch string search data
* @param sourcece
* @return the modified collation element
','line_number':139,'multiline':True]
['text':' note for tertiary we can't use the collator->tertiaryMask, that','line_number':149,'multiline':False]
['text':' is a preprocessed mask that takes into account case options. since','line_number':150,'multiline':False]
['text':' we are only concerned with exact matches, we don't need that.','line_number':151,'multiline':False]
['text':' alternate handling here, since only the 16 most significant digits','line_number':155,'multiline':False]
['text':' is only used, we can safely do a compare without masking','line_number':156,'multiline':False]
['text':' if the ce is a variable, we mask and get only the primary values','line_number':157,'multiline':False]
['text':' no shifting to quartenary is required since all primary values','line_number':158,'multiline':False]
['text':' less than variabletop will need to be masked off anyway.','line_number':159,'multiline':False]
['text':'*
* Allocate a memory and returns NULL if it failed.
* Internal method, status assumed to be a success.
* @param size to allocate
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
* @return newly allocated array, NULL otherwise
','line_number':175,'multiline':True]
['text':'*
* Adds a uint32_t value to a destination array.
* Creates a new array if we run out of space. The caller will have to
* manually deallocate the newly allocated array.
* Internal method, status assumed to be success, caller has to check status
* before calling this method. destination not to be NULL and has at least
* size destinationlength.
* @param destination target array
* @param offset destination offset to add value
* @param destinationlength target array size, return value for the new size
* @param value to be added
* @param increments incremental size expected
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
* @return new destination array, destination if there was no new allocation
','line_number':193,'multiline':True]
['text':'*
* Adds a uint64_t value to a destination array.
* Creates a new array if we run out of space. The caller will have to
* manually deallocate the newly allocated array.
* Internal method, status assumed to be success, caller has to check status
* before calling this method. destination not to be NULL and has at least
* size destinationlength.
* @param destination target array
* @param offset destination offset to add value
* @param destinationlength target array size, return value for the new size
* @param value to be added
* @param increments incremental size expected
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
* @return new destination array, destination if there was no new allocation
','line_number':233,'multiline':True]
['text':'*
* Initializing the ce table for a pattern.
* Stores non-ignorable collation keys.
* Table size will be estimated by the size of the pattern text. Table
* expansion will be perform as we go along. Adding 1 to ensure that the table
* size definitely increases.
* Internal method, status assumed to be a success.
* @param strsrch string search data
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
* @return total number of expansions
','line_number':277,'multiline':True]
['text':' status will be checked in ucol_next(..) later and if it is an','line_number':302,'multiline':False]
['text':' error UCOL_NULLORDER the result of ucol_next(..) and 0 will be','line_number':303,'multiline':False]
['text':' returned.','line_number':304,'multiline':False]
['text':'*
* Initializing the pce table for a pattern.
* Stores non-ignorable collation keys.
* Table size will be estimated by the size of the pattern text. Table
* expansion will be perform as we go along. Adding 1 to ensure that the table
* size definitely increases.
* Internal method, status assumed to be a success.
* @param strsrch string search data
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
* @return total number of expansions
','line_number':349,'multiline':True]
['text':' status will be checked in ucol_next(..) later and if it is an','line_number':374,'multiline':False]
['text':' error UCOL_NULLORDER the result of ucol_next(..) and 0 will be','line_number':375,'multiline':False]
['text':' returned.','line_number':376,'multiline':False]
['text':' ** Should processed CEs be signed or unsigned?','line_number':395,'multiline':False]
['text':' ** (the rest of the code in this file seems to play fast-and-loose with','line_number':396,'multiline':False]
['text':' **  whether a CE is signed or unsigned. For example, look at routine above this one.)','line_number':397,'multiline':False]
['text':'result += (uint16_t)(ucol_getMaxExpansion(coleiter, ce) - 1);','line_number':416,'multiline':False]
['text':'*
* Initializes the pattern struct.
* Internal method, status assumed to be success.
* @param strsrch UStringSearch data storage
* @param status output error if any, caller to check status before calling
*               method, status assumed to be success when passed in.
* @return expansionsize the total expansion size of the pattern
','line_number':426,'multiline':True]
['text':' Since the strength is primary, accents are ignored in the pattern.','line_number':443,'multiline':False]
['text':' ** HACK **','line_number':456,'multiline':False]
['text':' since intializePattern is an internal method status is a success.','line_number':465,'multiline':False]
['text':'*
* Initializing shift tables, with the default values.
* If a corresponding default value is 0, the shift table is not set.
* @param shift table for forwards shift
* @param backshift table for backwards shift
* @param cetable table containing pattern ce
* @param cesize size of the pattern ces
* @param expansionsize total size of the expansions
* @param defaultforward the default forward value
* @param defaultbackward the default backward value
','line_number':469,'multiline':True]
['text':' estimate the value to shift. to do that we estimate the smallest','line_number':487,'multiline':False]
['text':' number of characters to give the relevant ces, ie approximately','line_number':488,'multiline':False]
['text':' the number of ces minus their expansion, since expansions can come','line_number':489,'multiline':False]
['text':' from a character.','line_number':490,'multiline':False]
['text':' down to the last index','line_number':495,'multiline':False]
['text':' number of ces from right of array to the count','line_number':497,'multiline':False]
['text':' for ignorables we just shift by one. see test examples.','line_number':502,'multiline':False]
['text':' the original value count does not seem to work','line_number':509,'multiline':False]
['text':'*
* Building of the pattern collation element list and the boyer moore strsrch
* table.
* The canonical match will only be performed after the default match fails.
* For both cases we need to remember the size of the composed and decomposed
* versions of the string. Since the Boyer-Moore shift calculations shifts by
* a number of characters in the text and tries to match the pattern from that
* offset, the shift value can not be too large in case we miss some
* characters. To choose a right shift size, we estimate the NFC form of the
* and use its size as a shift guide. The NFC form should be the small
* possible representation of the pattern. Anyways, we'll err on the smaller
* shift size. Hence the calculation for minlength.
* Canonical match will be performed slightly differently. We'll split the
* pattern into 3 parts, the prefix accents (PA), the middle string bounded by
* the first and last base character (MS), the ending accents (EA). Matches
* will be done on MS first, and only when we match MS then some processing
* will be required for the prefix and end accents in order to determine if
* they match PA and EA. Hence the default shift values
* for the canonical match will take the size of either end's accent into
* consideration. Forwards search will take the end accents into consideration
* for the default shift values and the backwards search will take the prefix
* accents into consideration.
* If pattern has no non-ignorable ce, we return a illegal argument error.
* Internal method, status assumed to be success.
* @param strsrch UStringSearch data storage
* @param status  for output errors if it occurs, status is assumed to be a
*                success when it is passed in.
','line_number':517,'multiline':True]
['text':'*
* Check to make sure that the match length is at the end of the character by
* using the breakiterator.
* @param strsrch string search data
* @param start target text start offset
* @param end target text end offset
','line_number':564,'multiline':True]
['text':'start','line_number':572,'multiline':True]
['text':'int32_t matchstart = *start;','line_number':579,'multiline':False]
['text':' Check the start of the matched text to make sure it doesn't have any accents
         * before it.  This code may not be necessary and so it is commented out ','line_number':585,'multiline':True]
['text':'if (!ubrk_isBoundary(breakiterator, matchstart) && !ubrk_isBoundary(breakiterator, matchstart-1)) {
            *start = ubrk_preceding(breakiterator, matchstart);
        }','line_number':587,'multiline':True]
['text':'*
* Determine whether the target text in UStringSearch bounded by the offset
* start and end is one or more whole units of text as
* determined by the breakiterator in UStringSearch.
* @param strsrch string search data
* @param start target text start offset
* @param end target text end offset
','line_number':594,'multiline':True]
['text':'TODO: Add here.','line_number':608,'multiline':False]
['text':' out-of-range indexes are never boundary positions','line_number':613,'multiline':False]
['text':' otherwise, we can use following() on the position before the','line_number':618,'multiline':False]
['text':' specified one and return true of the position we get back is the','line_number':619,'multiline':False]
['text':' one the user specified','line_number':620,'multiline':False]
['text':' iterates the individual ces','line_number':626,'multiline':False]
['text':' extra collation elements at the end of the match','line_number':650,'multiline':False]
['text':'*
* Getting the next base character offset if current offset is an accent,
* or the current offset if the current character contains a base character.
* accents the following base character will be returned
* @param text string
* @param textoffset current offset
* @param textlength length of text string
* @return the next base character or the current offset
*         if the current character is contains a base character.
','line_number':660,'multiline':True]
['text':'*
* Gets the next base character offset depending on the string search pattern
* data
* @param strsrch string search data
* @param textoffset current offset, one offset away from the last character
*                   to search for.
* @return start index of the next base character or the current offset
*         if the current character is contains a base character.
','line_number':691,'multiline':True]
['text':'*
* Shifting the collation element iterator position forward to prepare for
* a following match. If the last character is a unsafe character, we'll only
* shift by 1 to capture contractions, normalization etc.
* Internal method, status assumed to be success.
* @param text strsrch string search data
* @param textoffset start text position to do search
* @param ce the text ce which failed the match.
* @param patternceindex index of the ce within the pattern ce buffer which
*        failed the match
* @return final offset
','line_number':717,'multiline':True]
['text':' this is to adjust for characters in the middle of the','line_number':738,'multiline':False]
['text':' substring for matching that failed.','line_number':739,'multiline':False]
['text':' check for unsafe characters','line_number':751,'multiline':False]
['text':' * if it is the start or middle of a contraction: to be done after','line_number':752,'multiline':False]
['text':'   a initial match is found','line_number':753,'multiline':False]
['text':' * thai or lao base consonant character: similar to contraction','line_number':754,'multiline':False]
['text':' * high surrogate character: similar to contraction','line_number':755,'multiline':False]
['text':' * next character is a accent: shift to the next base character','line_number':756,'multiline':False]
['text':' #if BOYER_MOORE','line_number':759,'multiline':False]
['text':'*
* sets match not found
* @param strsrch string search data
','line_number':761,'multiline':True]
['text':' this method resets the match result regardless of the error status.','line_number':768,'multiline':False]
['text':'*
* Gets the offset to the next safe point in text.
* ie. not the middle of a contraction, swappable characters or supplementary
* characters.
* @param collator collation sata
* @param text string to work with
* @param textoffset offset in string
* @param textlength length of text string
* @return offset to the next safe character
','line_number':780,'multiline':True]
['text':' first contraction character','line_number':796,'multiline':False]
['text':'*
* This checks for accents in the potential match started with a .
* composite character.
* This is really painful... we have to check that composite character do not
* have any extra accents. We have to normalize the potential match and find
* the immediate decomposed character before the match.
* The first composite character would have been taken care of by the fcd
* checks in checkForwardExactMatch.
* This is the slow path after the fcd of the first character and
* the last character has been checked by checkForwardExactMatch and we
* determine that the potential match has extra non-ignorable preceding
* ces.
* E.g. looking for \u0301 acute in \u01FA A ring above and acute,
* checkExtraMatchAccent should fail since there is a middle ring in \u01FA
* Note here that accents checking are slow and cautioned in the API docs.
* Internal method, status assumed to be a success, caller should check status
* before calling this method
* @param strsrch string search data
* @param start index of the potential unfriendly composite character
* @param end index of the potential unfriendly composite character
* @param status output error status if any.
* @return TRUE if there is non-ignorable accents before at the beginning
*              of the match, FALSE otherwise.
','line_number':803,'multiline':True]
['text':' we are only concerned with the first composite character','line_number':840,'multiline':False]
['text':' if allocation failed, status will be set to','line_number':858,'multiline':False]
['text':' U_MEMORY_ALLOCATION_ERROR and unorm_normalize internally','line_number':859,'multiline':False]
['text':' checks for it.','line_number':860,'multiline':False]
['text':'*
* Used by exact matches, checks if there are accents before the match.
* This is really painful... we have to check that composite characters at
* the start of the matches have to not have any extra accents.
* We check the FCD of the character first, if it starts with an accent and
* the first pattern ce does not match the first ce of the character, we bail.
* Otherwise we try normalizing the first composite
* character and find the immediate decomposed character before the match to
* see if it is an non-ignorable accent.
* Now normalizing the first composite character is enough because we ensure
* that when the match is passed in here with extra beginning ces, the
* first or last ce that match has to occur within the first character.
* E.g. looking for \u0301 acute in \u01FA A ring above and acute,
* checkExtraMatchAccent should fail since there is a middle ring in \u01FA
* Note here that accents checking are slow and cautioned in the API docs.
* @param strsrch string search data
* @param start offset
* @param end offset
* @return TRUE if there are accents on either side of the match,
*         FALSE otherwise
','line_number':897,'multiline':True]
['text':' we have been iterating forwards previously','line_number':925,'multiline':False]
['text':' within normalization buffer, discontiguous handled here','line_number':944,'multiline':False]
['text':' within text','line_number':948,'multiline':False]
['text':' original code','line_number':950,'multiline':False]
['text':' accent = (getFCD(strsrch->search->text, &temp,','line_number':951,'multiline':False]
['text':'                  strsrch->search->textLength)','line_number':952,'multiline':False]
['text':'            >> SECOND_LAST_BYTE_SHIFT_);','line_number':953,'multiline':False]
['text':' however this code does not work well with VC7 .net in release mode.','line_number':954,'multiline':False]
['text':' maybe the inlines for getFCD combined with shifting has bugs in','line_number':955,'multiline':False]
['text':' VC7. anyways this is a work around.','line_number':956,'multiline':False]
['text':'*
* Used by exact matches, checks if there are accents bounding the match.
* Note this is the initial boundary check. If the potential match
* starts or ends with composite characters, the accents in those
* characters will be determined later.
* Not doing backwards iteration here, since discontiguos contraction for
* backwards collation element iterator, use up too many characters.
* E.g. looking for \u030A ring in \u01FA A ring above and acute,
* should fail since there is a acute at the end of \u01FA
* Note here that accents checking are slow and cautioned in the API docs.
* @param strsrch string search data
* @param start offset of match
* @param end end offset of the match
* @return TRUE if there are accents on either side of the match,
*         FALSE otherwise
','line_number':983,'multiline':True]
['text':' Thai can give an ignorable here.','line_number':1023,'multiline':False]
['text':' #if BOYER_MOORE','line_number':1051,'multiline':False]
['text':'*
* Checks if the offset runs out of the text string
* @param offset
* @param textlength of the text string
* @return TRUE if offset is out of bounds, FALSE otherwise
','line_number':1053,'multiline':True]
['text':'*
* Checks for identical match
* @param strsrch string search data
* @param start offset of possible match
* @param end offset of possible match
* @return TRUE if identical match is found
','line_number':1065,'multiline':True]
['text':' Note: We could use Normalizer::compare() or similar, but for short strings','line_number':1080,'multiline':False]
['text':' which may not be in FCD it might be faster to just NFD them.','line_number':1081,'multiline':False]
['text':' return FALSE if NFD failed','line_number':1088,'multiline':False]
['text':'*
* Checks to see if the match is repeated
* @param strsrch string search data
* @param start new match start index
* @param end new match end index
* @return TRUE if the the match is repeated, FALSE otherwise
','line_number':1093,'multiline':True]
['text':'*
* Gets the collation element iterator's current offset.
* @param coleiter collation element iterator
* @param forwards flag TRUE if we are moving in th forwards direction
* @return current offset
','line_number':1127,'multiline':True]
['text':' intricacies of the the backwards collation element iterator','line_number':1138,'multiline':False]
['text':'*
* Checks match for contraction.
* If the match ends with a partial contraction we fail.
* If the match starts too far off (because of backwards iteration) we try to
* chip off the extra characters depending on whether a breakiterator has
* been used.
* Internal method, error assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param start offset of potential match, to be modified if necessary
* @param end offset of potential match, to be modified if necessary
* @param status output error status if any
* @return TRUE if match passes the contraction test, FALSE otherwise
','line_number':1145,'multiline':True]
['text':' This part checks if either ends of the match contains potential','line_number':1170,'multiline':False]
['text':' contraction. If so we'll have to iterate through them','line_number':1171,'multiline':False]
['text':' The start contraction needs to be checked since ucol_previous dumps','line_number':1172,'multiline':False]
['text':' all characters till the first safe character into the buffer.','line_number':1173,'multiline':False]
['text':' *start + 1 is used to test for the unsafe characters instead of *start','line_number':1174,'multiline':False]
['text':' because ucol_prev takes all unsafe characters till the first safe','line_number':1175,'multiline':False]
['text':' character ie *start. so by testing *start + 1, we can estimate if','line_number':1176,'multiline':False]
['text':' excess prefix characters has been included in the potential search','line_number':1177,'multiline':False]
['text':' results.','line_number':1178,'multiline':False]
['text':' getting rid of the redundant ce, caused by setOffset.','line_number':1186,'multiline':False]
['text':' since backward contraction/expansion may have extra ces if we','line_number':1187,'multiline':False]
['text':' are in the normalization buffer, hasAccentsBeforeMatch would','line_number':1188,'multiline':False]
['text':' have taken care of it.','line_number':1189,'multiline':False]
['text':' E.g. the character \u01FA will have an expansion of 3, but if','line_number':1190,'multiline':False]
['text':' we are only looking for acute and ring \u030A and \u0301, we'll','line_number':1191,'multiline':False]
['text':' have to skip the first ce in the expansion buffer.','line_number':1192,'multiline':False]
['text':'*
* Checks and sets the match information if found.
* Checks
* <ul>
* <li> the potential match does not repeat the previous match
* <li> boundaries are correct
* <li> exact matches has no extra accents
* <li> identical matchesb
* <li> potential match does not end in the middle of a contraction
* <\ul>
* Otherwise the offset will be shifted to the next character.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param textoffset offset in the collation element text. the returned value
*        will be the truncated end offset of the match or the new start
*        search offset.
* @param status output error status if any
* @return TRUE if the match is valid, FALSE otherwise
','line_number':1227,'multiline':True]
['text':' this totally matches, however we need to check if it is repeating','line_number':1258,'multiline':False]
['text':'Add breakiterator boundary check for primary strength search.','line_number':1270,'multiline':False]
['text':' totally match, we will get rid of the ending ignorables.','line_number':1275,'multiline':False]
['text':'*
* Getting the previous base character offset, or the current offset if the
* current character is a base character
* @param text string
* @param textoffset one offset after the current character
* @return the offset of the next character after the base character or the first
*         composed character with accents
','line_number':1281,'multiline':True]
['text':'*
* Getting the indexes of the accents that are not blocked in the argument
* accent array
* @param accents array of accents in nfd terminated by a 0.
* @param accentsindex array of indexes of the accents that are not blocked
','line_number':1313,'multiline':True]
['text':'*
* Appends 3 UChar arrays to a destination array.
* Creates a new array if we run out of space. The caller will have to
* manually deallocate the newly allocated array.
* Internal method, status assumed to be success, caller has to check status
* before calling this method. destination not to be NULL and has at least
* size destinationlength.
* @param destination target array
* @param destinationlength target array size, returning the appended length
* @param source1 null-terminated first array
* @param source2 second array
* @param source2length length of seond array
* @param source3 null-terminated third array
* @param status error status if any
* @return new destination array, destination if there was no new allocation
','line_number':1341,'multiline':True]
['text':' if error allocating memory, status will be','line_number':1374,'multiline':False]
['text':' U_MEMORY_ALLOCATION_ERROR','line_number':1375,'multiline':False]
['text':'*
* Running through a collation element iterator to see if the contents matches
* pattern in string search data
* @param strsrch string search data
* @param coleiter collation element iterator
* @return TRUE if a match if found, FALSE otherwise
','line_number':1396,'multiline':True]
['text':'*
* Rearranges the front accents to try matching.
* Prefix accents in the text will be grouped according to their combining
* class and the groups will be mixed and matched to try find the perfect
* match with the pattern.
* So for instance looking for "\u0301" in "\u030A\u0301\u0325"
* step 1: split "\u030A\u0301" into 6 other type of potential accent substrings
*         "\u030A", "\u0301", "\u0325", "\u030A\u0301", "\u030A\u0325",
*         "\u0301\u0325".
* step 2: check if any of the generated substrings matches the pattern.
* Internal method, status is assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search match
* @param start first offset of the accents to start searching
* @param end start of the last accent set
* @param status output error status if any
* @return USEARCH_DONE if a match is not found, otherwise return the starting
*         offset of the match. Note this start includes all preceding accents.
','line_number':1424,'multiline':True]
['text':' die... failed at a base character','line_number':1454,'multiline':False]
['text':' normalizing the offensive string','line_number':1462,'multiline':False]
['text':' copy the base characters','line_number':1477,'multiline':False]
['text':' forming all possible canonical rearrangement by dropping','line_number':1481,'multiline':False]
['text':' sets of accents','line_number':1482,'multiline':False]
['text':' if status is a failure, ucol_setText does nothing.','line_number':1500,'multiline':False]
['text':' run the collator iterator through this match','line_number':1501,'multiline':False]
['text':'*
* Gets the offset to the safe point in text before textoffset.
* ie. not the middle of a contraction, swappable characters or supplementary
* characters.
* @param collator collation sata
* @param text string to work with
* @param textoffset offset in string
* @param textlength length of text string
* @return offset to the previous safe character
','line_number':1516,'multiline':True]
['text':' first contraction character','line_number':1531,'multiline':False]
['text':' the first contraction character is consider unsafe here','line_number':1536,'multiline':False]
['text':'*
* Cleaning up after we passed the safe zone
* @param strsrch string search data
* @param safetext safe text array
* @param safebuffer safe text buffer
* @param coleiter collation element iterator for safe text
','line_number':1542,'multiline':True]
['text':'*
* Take the rearranged end accents and tries matching. If match failed at
* a seperate preceding set of accents (seperated from the rearranged on by
* at least a base character) then we rearrange the preceding accents and
* tries matching again.
* We allow skipping of the ends of the accent set if the ces do not match.
* However if the failure is found before the accent set, it fails.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param textoffset of the start of the rearranged accent
* @param status output error status if any
* @return USEARCH_DONE if a match is not found, otherwise return the starting
*         offset of the match. Note this start includes all preceding accents.
','line_number':1559,'multiline':True]
['text':' if status is a failure, ucol_setText does nothing','line_number':1603,'multiline':False]
['text':' status checked in loop below','line_number':1605,'multiline':False]
['text':' indication flag for position in safe zone','line_number':1610,'multiline':False]
['text':' check if we have passed the safe buffer','line_number':1621,'multiline':False]
['text':' status checked at the start of the loop','line_number':1630,'multiline':False]
['text':' do the beginning stuff','line_number':1636,'multiline':False]
['text':' alas... no hope. failed at rearranged accent set','line_number':1639,'multiline':False]
['text':' try rearranging the front accents','line_number':1649,'multiline':False]
['text':' if status is a failure, ucol_setOffset does nothing','line_number':1653,'multiline':False]
['text':' set offset here','line_number':1666,'multiline':False]
['text':' sets the text iterator here with the correct expansion and offset','line_number':1669,'multiline':False]
['text':'*
* Trying out the substring and sees if it can be a canonical match.
* This will try normalizing the end accents and arranging them into canonical
* equivalents and check their corresponding ces with the pattern ce.
* Suffix accents in the text will be grouped according to their combining
* class and the groups will be mixed and matched to try find the perfect
* match with the pattern.
* So for instance looking for "\u0301" in "\u030A\u0301\u0325"
* step 1: split "\u030A\u0301" into 6 other type of potential accent substrings
*         "\u030A", "\u0301", "\u0325", "\u030A\u0301", "\u030A\u0325",
*         "\u0301\u0325".
* step 2: check if any of the generated substrings matches the pattern.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param textoffset end offset in the collation element text that ends with
*                   the accents to be rearranged
* @param status error status if any
* @return TRUE if the match is valid, FALSE otherwise
','line_number':1687,'multiline':True]
['text':' offset to the last base character in substring to search','line_number':1734,'multiline':False]
['text':' normalizing the offensive string','line_number':1736,'multiline':False]
['text':' status checked in loop below','line_number':1739,'multiline':False]
['text':' 2 power n - 1 plus the full set of accents','line_number':1744,'multiline':False]
['text':' copy the base characters','line_number':1748,'multiline':False]
['text':' forming all possible canonical rearrangement by dropping','line_number':1752,'multiline':False]
['text':' sets of accents','line_number':1753,'multiline':False]
['text':' match found','line_number':1766,'multiline':False]
['text':'*
* Gets the previous base character offset depending on the string search
* pattern data
* @param strsrch string search data
* @param textoffset current offset, current character
* @return the offset of the next character after this base character or itself
*         if it is a composed character with accents
','line_number':1773,'multiline':True]
['text':'*
* Checks match for contraction.
* If the match ends with a partial contraction we fail.
* If the match starts too far off (because of backwards iteration) we try to
* chip off the extra characters
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param start offset of potential match, to be modified if necessary
* @param end offset of potential match, to be modified if necessary
* @param status output error status if any
* @return TRUE if match passes the contraction test, FALSE otherwise
','line_number':1796,'multiline':True]
['text':' This part checks if either ends of the match contains potential','line_number':1820,'multiline':False]
['text':' contraction. If so we'll have to iterate through them','line_number':1821,'multiline':False]
['text':' getting rid of the redundant ce, caused by setOffset.','line_number':1829,'multiline':False]
['text':' since backward contraction/expansion may have extra ces if we','line_number':1830,'multiline':False]
['text':' are in the normalization buffer, hasAccentsBeforeMatch would','line_number':1831,'multiline':False]
['text':' have taken care of it.','line_number':1832,'multiline':False]
['text':' E.g. the character \u01FA will have an expansion of 3, but if','line_number':1833,'multiline':False]
['text':' we are only looking for acute and ring \u030A and \u0301, we'll','line_number':1834,'multiline':False]
['text':' have to skip the first ce in the expansion buffer.','line_number':1835,'multiline':False]
['text':' status checked below, note that if status is a failure','line_number':1853,'multiline':False]
['text':' ucol_next returns UCOL_NULLORDER','line_number':1854,'multiline':False]
['text':' accents may have extra starting ces, this occurs when a','line_number':1864,'multiline':False]
['text':' pure accent pattern is matched without rearrangement','line_number':1865,'multiline':False]
['text':' text \u0325\u0300 and looking for \u0300','line_number':1866,'multiline':False]
['text':'*
* Checks and sets the match information if found.
* Checks
* <ul>
* <li> the potential match does not repeat the previous match
* <li> boundaries are correct
* <li> potential match does not end in the middle of a contraction
* <li> identical matches
* <\ul>
* Otherwise the offset will be shifted to the next character.
* Internal method, status assumed to be success, caller has to check the
* status before calling this method.
* @param strsrch string search data
* @param textoffset offset in the collation element text. the returned value
*        will be the truncated end offset of the match or the new start
*        search offset.
* @param status output error status if any
* @return TRUE if the match is valid, FALSE otherwise
','line_number':1888,'multiline':True]
['text':' to ensure that the start and ends are not composite characters','line_number':1912,'multiline':False]
['text':' if we have a canonical accent match','line_number':1914,'multiline':False]
['text':' this totally matches, however we need to check if it is repeating','line_number':1934,'multiline':False]
['text':'*
* Shifting the collation element iterator position forward to prepare for
* a preceding match. If the first character is a unsafe character, we'll only
* shift by 1 to capture contractions, normalization etc.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param text strsrch string search data
* @param textoffset start text position to do search
* @param ce the text ce which failed the match.
* @param patternceindex index of the ce within the pattern ce buffer which
*        failed the match
* @return final offset
','line_number':1949,'multiline':True]
['text':' this is to adjust for characters in the middle of the substring','line_number':1980,'multiline':False]
['text':' for matching that failed.','line_number':1981,'multiline':False]
['text':'*
* Checks match for contraction.
* If the match starts with a partial contraction we fail.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param start offset of potential match, to be modified if necessary
* @param end offset of potential match, to be modified if necessary
* @param status output error status if any
* @return TRUE if match passes the contraction test, FALSE otherwise
','line_number':1996,'multiline':True]
['text':' This part checks if either if the start of the match contains potential','line_number':2017,'multiline':False]
['text':' contraction. If so we'll have to iterate through them','line_number':2018,'multiline':False]
['text':' Since we used ucol_next while previously looking for the potential','line_number':2019,'multiline':False]
['text':' match, this guarantees that our end will not be a partial contraction,','line_number':2020,'multiline':False]
['text':' or a partial supplementary character.','line_number':2021,'multiline':False]
['text':' getting rid of the redundant ce','line_number':2027,'multiline':False]
['text':' since forward contraction/expansion may have extra ces','line_number':2028,'multiline':False]
['text':' if we are in the normalization buffer, hasAccentsBeforeMatch','line_number':2029,'multiline':False]
['text':' would have taken care of it.','line_number':2030,'multiline':False]
['text':' E.g. the character \u01FA will have an expansion of 3, but if','line_number':2031,'multiline':False]
['text':' we are only looking for A ring A\u030A, we'll have to skip the','line_number':2032,'multiline':False]
['text':' last ce in the expansion buffer','line_number':2033,'multiline':False]
['text':' status checked below, note that if status is a failure','line_number':2050,'multiline':False]
['text':' ucol_previous returns UCOL_NULLORDER','line_number':2051,'multiline':False]
['text':'*
* Checks and sets the match information if found.
* Checks
* <ul>
* <li> the current match does not repeat the last match
* <li> boundaries are correct
* <li> exact matches has no extra accents
* <li> identical matches
* <\ul>
* Otherwise the offset will be shifted to the preceding character.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param collator
* @param coleiter collation element iterator
* @param text string
* @param textoffset offset in the collation element text. the returned value
*        will be the truncated start offset of the match or the new start
*        search offset.
* @param status output error status if any
* @return TRUE if the match is valid, FALSE otherwise
','line_number':2071,'multiline':True]
['text':' to ensure that the start and ends are not composite characters','line_number':2098,'multiline':False]
['text':' this totally matches, however we need to check if it is repeating','line_number':2105,'multiline':False]
['text':' the old match','line_number':2106,'multiline':False]
['text':'Add breakiterator boundary check for primary strength search.','line_number':2118,'multiline':False]
['text':'*
* Rearranges the end accents to try matching.
* Suffix accents in the text will be grouped according to their combining
* class and the groups will be mixed and matched to try find the perfect
* match with the pattern.
* So for instance looking for "\u0301" in "\u030A\u0301\u0325"
* step 1: split "\u030A\u0301" into 6 other type of potential accent substrings
*         "\u030A", "\u0301", "\u0325", "\u030A\u0301", "\u030A\u0325",
*         "\u0301\u0325".
* step 2: check if any of the generated substrings matches the pattern.
* Internal method, status assumed to be success, user has to check status
* before calling this method.
* @param strsrch string search match
* @param start offset of the first base character
* @param end start of the last accent set
* @param status only error status if any
* @return USEARCH_DONE if a match is not found, otherwise return the ending
*         offset of the match. Note this start includes all following accents.
','line_number':2128,'multiline':True]
['text':' die... failed at a base character','line_number':2159,'multiline':False]
['text':' normalizing the offensive string','line_number':2167,'multiline':False]
['text':' copy the base characters','line_number':2179,'multiline':False]
['text':' forming all possible canonical rearrangement by dropping','line_number':2183,'multiline':False]
['text':' sets of accents','line_number':2184,'multiline':False]
['text':' run the collator iterator through this match','line_number':2202,'multiline':False]
['text':' if status is a failure ucol_setText does nothing','line_number':2203,'multiline':False]
['text':'*
* Take the rearranged start accents and tries matching. If match failed at
* a seperate following set of accents (seperated from the rearranged on by
* at least a base character) then we rearrange the preceding accents and
* tries matching again.
* We allow skipping of the ends of the accent set if the ces do not match.
* However if the failure is found before the accent set, it fails.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param textoffset of the ends of the rearranged accent
* @param status output error status if any
* @return USEARCH_DONE if a match is not found, otherwise return the ending
*         offset of the match. Note this start includes all following accents.
','line_number':2219,'multiline':True]
['text':' if status is a failure, ucol_setText does nothing','line_number':2266,'multiline':False]
['text':' status checked in loop below','line_number':2268,'multiline':False]
['text':' safe zone indication flag for position','line_number':2273,'multiline':False]
['text':' check if we have passed the safe buffer','line_number':2285,'multiline':False]
['text':' status checked at the start of the loop','line_number':2294,'multiline':False]
['text':' do the beginning stuff','line_number':2300,'multiline':False]
['text':' alas... no hope. failed at rearranged accent set','line_number':2303,'multiline':False]
['text':' try rearranging the end accents','line_number':2313,'multiline':False]
['text':' if status is a failure, ucol_setOffset does nothing','line_number':2317,'multiline':False]
['text':' set offset here','line_number':2330,'multiline':False]
['text':' sets the text iterator here with the correct expansion and offset','line_number':2333,'multiline':False]
['text':'*
* Trying out the substring and sees if it can be a canonical match.
* This will try normalizing the starting accents and arranging them into
* canonical equivalents and check their corresponding ces with the pattern ce.
* Prefix accents in the text will be grouped according to their combining
* class and the groups will be mixed and matched to try find the perfect
* match with the pattern.
* So for instance looking for "\u0301" in "\u030A\u0301\u0325"
* step 1: split "\u030A\u0301" into 6 other type of potential accent substrings
*         "\u030A", "\u0301", "\u0325", "\u030A\u0301", "\u030A\u0325",
*         "\u0301\u0325".
* step 2: check if any of the generated substrings matches the pattern.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param textoffset start offset in the collation element text that starts
*                   with the accents to be rearranged
* @param status output error status if any
* @return TRUE if the match is valid, FALSE otherwise
','line_number':2350,'multiline':True]
['text':' offset to the last base character in substring to search','line_number':2397,'multiline':False]
['text':' normalizing the offensive string','line_number':2399,'multiline':False]
['text':' status checked in loop','line_number':2402,'multiline':False]
['text':' 2 power n - 1 plus the full set of accents','line_number':2407,'multiline':False]
['text':' copy the base characters','line_number':2411,'multiline':False]
['text':' forming all possible canonical rearrangement by dropping','line_number':2415,'multiline':False]
['text':' sets of accents','line_number':2416,'multiline':False]
['text':' match found','line_number':2429,'multiline':False]
['text':'*
* Checks match for contraction.
* If the match starts with a partial contraction we fail.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param start offset of potential match, to be modified if necessary
* @param end offset of potential match, to be modified if necessary
* @param status only error status if any
* @return TRUE if match passes the contraction test, FALSE otherwise
','line_number':2436,'multiline':True]
['text':' This part checks if either if the start of the match contains potential','line_number':2457,'multiline':False]
['text':' contraction. If so we'll have to iterate through them','line_number':2458,'multiline':False]
['text':' Since we used ucol_next while previously looking for the potential','line_number':2459,'multiline':False]
['text':' match, this guarantees that our end will not be a partial contraction,','line_number':2460,'multiline':False]
['text':' or a partial supplementary character.','line_number':2461,'multiline':False]
['text':' getting rid of the redundant ce','line_number':2467,'multiline':False]
['text':' since forward contraction/expansion may have extra ces','line_number':2468,'multiline':False]
['text':' if we are in the normalization buffer, hasAccentsBeforeMatch','line_number':2469,'multiline':False]
['text':' would have taken care of it.','line_number':2470,'multiline':False]
['text':' E.g. the character \u01FA will have an expansion of 3, but if','line_number':2471,'multiline':False]
['text':' we are only looking for A ring A\u030A, we'll have to skip the','line_number':2472,'multiline':False]
['text':' last ce in the expansion buffer','line_number':2473,'multiline':False]
['text':' status checked below, note that if status is a failure','line_number':2490,'multiline':False]
['text':' ucol_previous returns UCOL_NULLORDER','line_number':2491,'multiline':False]
['text':' accents may have extra starting ces, this occurs when a','line_number':2502,'multiline':False]
['text':' pure accent pattern is matched without rearrangement','line_number':2503,'multiline':False]
['text':'*
* Checks and sets the match information if found.
* Checks
* <ul>
* <li> the potential match does not repeat the previous match
* <li> boundaries are correct
* <li> potential match does not end in the middle of a contraction
* <li> identical matches
* <\ul>
* Otherwise the offset will be shifted to the next character.
* Internal method, status assumed to be success, caller has to check status
* before calling this method.
* @param strsrch string search data
* @param textoffset offset in the collation element text. the returned value
*        will be the truncated start offset of the match or the new start
*        search offset.
* @param status only error status if any
* @return TRUE if the match is valid, FALSE otherwise
','line_number':2526,'multiline':True]
['text':' to ensure that the start and ends are not composite characters','line_number':2550,'multiline':False]
['text':' if we have a canonical accent match','line_number':2552,'multiline':False]
['text':' this totally matches, however we need to check if it is repeating','line_number':2573,'multiline':False]
['text':' #if BOYER_MOORE','line_number':2587,'multiline':False]
['text':' constructors and destructor -------------------------------------------','line_number':2589,'multiline':False]
['text':' ucol_open internally checks for status','line_number':2609,'multiline':False]
['text':' pattern, text checks are done in usearch_openFromCollator','line_number':2611,'multiline':False]
['text':' string search does not really work when numeric collation is turned on','line_number':2654,'multiline':False]
['text':' set and get methods --------------------------------------------------','line_number':2802,'multiline':False]
['text':' if status is a failure, ucol_getAttribute returns UCOL_DEFAULT','line_number':3039,'multiline':False]
['text':' if status is a failure, ucol_getVariableTop returns 0','line_number':3043,'multiline':False]
['text':' initialize() _after_ setting the iterators for the new collator.','line_number':3051,'multiline':False]
['text':' **** are these calls needed?','line_number':3055,'multiline':False]
['text':' **** we call uprv_init_pce in initializePatternPCETable','line_number':3056,'multiline':False]
['text':' **** and the CEIBuffer constructor...','line_number':3057,'multiline':False]
['text':' miscellanous methods --------------------------------------------------','line_number':3108,'multiline':False]
['text':' position checked in usearch_setOffset','line_number':3129,'multiline':False]
['text':' position checked in usearch_setOffset','line_number':3157,'multiline':False]
['text':'*
* If a direction switch is required, we'll count the number of ces till the
* beginning of the collation element iterator and iterate forwards that
* number of times. This is so that we get to the correct point within the
* string to continue the search in. Imagine when we are in the middle of the
* normalization buffer when the change in direction is request. arrrgghh....
* After searching the offset within the collation element iterator will be
* shifted to the start of the match. If a match is not found, the offset would
* have been set to the end of the text string in the collation element
* iterator.
* Okay, here's my take on normalization buffer. The only time when there can
* be 2 matches within the same normalization is when the pattern is consists
* of all accents. But since the offset returned is from the text string, we
* should not confuse the caller by returning the second match within the
* same normalization buffer. If we do, the 2 results will have the same match
* offsets, and that'll be confusing. I'll return the next match that doesn't
* fall within the same normalization buffer. Note this does not affect the
* results of matches spanning the text and the normalization buffer.
* The position to start searching is taken from the collation element
* iterator. Callers of this API would have to set the offset in the collation
* element iterator before using this method.
','line_number':3166,'multiline':True]
['text':' note offset is either equivalent to the start of the previous match','line_number':3192,'multiline':False]
['text':' or is set by the user','line_number':3193,'multiline':False]
['text':' not enough characters to match','line_number':3205,'multiline':False]
['text':' not enough characters to match','line_number':3214,'multiline':False]
['text':' switching direction.','line_number':3221,'multiline':False]
['text':' if matchedIndex == USEARCH_DONE, it means that either a','line_number':3222,'multiline':False]
['text':' setOffset has been called or that previous ran off the text','line_number':3223,'multiline':False]
['text':' string. the iterator would have been set to offset 0 if a','line_number':3224,'multiline':False]
['text':' match is not found.','line_number':3225,'multiline':False]
['text':' there's no need to set the collation element iterator','line_number':3228,'multiline':False]
['text':' the next call to next will set the offset.','line_number':3229,'multiline':False]
['text':' moves by codepoints','line_number':3239,'multiline':False]
['text':' status checked below','line_number':3245,'multiline':False]
['text':' if matchlength is 0 we are at the start of the iteration','line_number':3252,'multiline':False]
['text':' for boundary check purposes. this will ensure that the','line_number':3262,'multiline':False]
['text':' next match will not preceed the current offset','line_number':3263,'multiline':False]
['text':' note search->matchedIndex will always be set to something','line_number':3264,'multiline':False]
['text':' in the code','line_number':3265,'multiline':False]
['text':' can't use exact here since extra accents are allowed.','line_number':3270,'multiline':False]
['text':' switching direction.','line_number':3314,'multiline':False]
['text':' if matchedIndex == USEARCH_DONE, it means that either a','line_number':3315,'multiline':False]
['text':' setOffset has been called or that next ran off the text','line_number':3316,'multiline':False]
['text':' string. the iterator would have been set to offset textLength if','line_number':3317,'multiline':False]
['text':' a match is not found.','line_number':3318,'multiline':False]
['text':' not enough characters to match','line_number':3331,'multiline':False]
['text':' Could check pattern length, but the','line_number':3336,'multiline':False]
['text':' linear search will do the right thing','line_number':3337,'multiline':False]
['text':' status checked below','line_number':3351,'multiline':False]
['text':' move by codepoints','line_number':3353,'multiline':False]
['text':' status checked below','line_number':3356,'multiline':False]
['text':' can't use exact here since extra accents are allowed.','line_number':3362,'multiline':False]
['text':' status checked below','line_number':3364,'multiline':False]
['text':' status checked below','line_number':3368,'multiline':False]
['text':'
    reset is setting the attributes that are already in
    string search, hence all attributes in the collator should
    be retrieved without any problems
    ','line_number':3386,'multiline':True]
['text':' **** hack to deal w/ how processed CEs encode quaternary ****','line_number':3398,'multiline':False]
['text':' if status is a failure, ucol_getAttribute returns UCOL_DEFAULT','line_number':3412,'multiline':False]
['text':' if status is a failure, ucol_getVariableTop returns 0','line_number':3420,'multiline':False]
['text':'','line_number':3442,'multiline':False]
['text':'  CEI  Collation Element + source text index.','line_number':3443,'multiline':False]
['text':'       These structs are kept in the circular buffer.','line_number':3444,'multiline':False]
['text':'','line_number':3445,'multiline':False]
['text':'','line_number':3455,'multiline':False]
['text':'  CEIBuffer   A circular buffer of CEs-with-index from the text being searched.','line_number':3456,'multiline':False]
['text':'','line_number':3457,'multiline':False]
['text':' Some typical max values to make buffer size more reasonable for asymmetric search.','line_number':3460,'multiline':False]
['text':' #8694 is for a better long-term solution to allocation of this buffer.','line_number':3461,'multiline':False]
['text':' No check for surrogates, we might allocate slightly more buffer than necessary.','line_number':3496,'multiline':False]
['text':' TODO: add a reset or init function so that allocated','line_number':3516,'multiline':False]
['text':'       buffers can be retained & reused.','line_number':3517,'multiline':False]
['text':' Get the CE with the specified index.','line_number':3526,'multiline':False]
['text':'   Index must be in the range','line_number':3527,'multiline':False]
['text':'          n-history_size < index < n+1','line_number':3528,'multiline':False]
['text':'   where n is the largest index to have been fetched by some previous call to this function.','line_number':3529,'multiline':False]
['text':'   The CE value will be UCOL__PROCESSED_NULLORDER at end of input.','line_number':3530,'multiline':False]
['text':'','line_number':3531,'multiline':False]
['text':' The request was for an entry already in our buffer.','line_number':3536,'multiline':False]
['text':'  Just return it.','line_number':3537,'multiline':False]
['text':' Caller is requesting a new, never accessed before, CE.','line_number':3541,'multiline':False]
['text':'   Verify that it is the next one in sequence, which is all','line_number':3542,'multiline':False]
['text':'   that is allowed.','line_number':3543,'multiline':False]
['text':' Manage the circular CE buffer indexing','line_number':3550,'multiline':False]
['text':' The buffer is full, knock out the lowest-indexed entry.','line_number':3554,'multiline':False]
['text':' Get the CE with the specified index.','line_number':3565,'multiline':False]
['text':'   Index must be in the range','line_number':3566,'multiline':False]
['text':'          n-history_size < index < n+1','line_number':3567,'multiline':False]
['text':'   where n is the largest index to have been fetched by some previous call to this function.','line_number':3568,'multiline':False]
['text':'   The CE value will be UCOL__PROCESSED_NULLORDER at end of input.','line_number':3569,'multiline':False]
['text':'','line_number':3570,'multiline':False]
['text':' The request was for an entry already in our buffer.','line_number':3575,'multiline':False]
['text':'  Just return it.','line_number':3576,'multiline':False]
['text':' Caller is requesting a new, never accessed before, CE.','line_number':3580,'multiline':False]
['text':'   Verify that it is the next one in sequence, which is all','line_number':3581,'multiline':False]
['text':'   that is allowed.','line_number':3582,'multiline':False]
['text':' Manage the circular CE buffer indexing','line_number':3589,'multiline':False]
['text':' The buffer is full, knock out the lowest-indexed entry.','line_number':3593,'multiline':False]
['text':' #define USEARCH_DEBUG','line_number':3609,'multiline':False]
['text':'
 * Find the next break boundary after startIndex. If the UStringSearch object
 * has an external break iterator, use that. Otherwise use the internal character
 * break iterator.
 ','line_number':3616,'multiline':True]
['text':' If we are on a control character, stop without looking for combining marks.','line_number':3637,'multiline':False]
['text':'    Control characters do not combine.','line_number':3638,'multiline':False]
['text':' The initial character was not a control, and can thus accept trailing','line_number':3644,'multiline':False]
['text':'   combining characters.  Advance over however many of them there are.','line_number':3645,'multiline':False]
['text':' **** or should we use the original code? ****','line_number':3672,'multiline':False]
['text':'
 * Returns TRUE if index is on a break boundary. If the UStringSearch
 * has an external break iterator, test using that, otherwise test
 * using the internal character break iterator.
 ','line_number':3678,'multiline':True]
['text':' If the character at the current index is not a GRAPHEME_EXTEND','line_number':3695,'multiline':False]
['text':'    then we can not be within a combining sequence.','line_number':3696,'multiline':False]
['text':' We are at a combining mark.  If the preceding character is anything','line_number':3704,'multiline':False]
['text':'   except a CONTROL, CR or LF, we are in a combining sequence.','line_number':3705,'multiline':False]
['text':' **** or use the original code? ****','line_number':3719,'multiline':False]
['text':' out-of-range indexes are never boundary positions','line_number':3734,'multiline':False]
['text':' TODO: #if BOYER_MOORE, need 32-bit version of compareCE64s','line_number':3809,'multiline':False]
['text':' namespace','line_number':3832,'multiline':False]
['text':' TODO:  reject search patterns beginning with a combining char.','line_number':3844,'multiline':False]
['text':' Input parameter sanity check.','line_number':3856,'multiline':False]
['text':'  TODO:  should input indicies clip to the text length','line_number':3857,'multiline':False]
['text':'         in the same way that UText does.','line_number':3858,'multiline':False]
['text':' Outer loop moves over match starting positions in the','line_number':3887,'multiline':False]
['text':'      target CE space.','line_number':3888,'multiline':False]
['text':' Here we see the target as a sequence of collation elements, resulting from the following:','line_number':3889,'multiline':False]
['text':' 1. Target characters were decomposed, and (if appropriate) other compressions and expansions are applied','line_number':3890,'multiline':False]
['text':'    (for example, digraphs such as IJ may be broken into two characters).','line_number':3891,'multiline':False]
['text':' 2. An int64_t CE weight is determined for each resulting unit (high 16 bits are primary strength, next','line_number':3892,'multiline':False]
['text':'    16 bits are secondary, next 16 (the high 16 bits of the low 32-bit half) are tertiary. Any of these','line_number':3893,'multiline':False]
['text':'    fields that are for strengths below that of the collator are set to 0. If this makes the int64_t','line_number':3894,'multiline':False]
['text':'    CE weight 0 (as for a combining diacritic with secondary weight when the collator strentgh is primary),','line_number':3895,'multiline':False]
['text':'    then the CE is deleted, so the following code sees only CEs that are relevant.','line_number':3896,'multiline':False]
['text':' For each CE, the lowIndex and highIndex correspond to where this CE begins and ends in the original text.','line_number':3897,'multiline':False]
['text':' If lowIndex==highIndex, either the CE resulted from an expansion/decomposition of one of the original text','line_number':3898,'multiline':False]
['text':' characters, or the CE marks the limit of the target text (in which case the CE weight is UCOL_PROCESSED_NULLORDER).','line_number':3899,'multiline':False]
['text':'','line_number':3900,'multiline':False]
['text':'  Inner loop checks for a match beginning at each','line_number':3904,'multiline':False]
['text':'  position from the outer loop.','line_number':3905,'multiline':False]
['text':' For targetIx > 0, this ceb.get gets a CE that is as far back in the ring buffer','line_number':3908,'multiline':False]
['text':' (compared to the last CE fetched for the previous targetIx value) as we need to go','line_number':3909,'multiline':False]
['text':' for this targetIx value, so if it is non-NULL then other ceb.get calls should be OK.','line_number':3910,'multiline':False]
['text':'  Compare CE from target string with CE from the pattern.','line_number':3921,'multiline':False]
['text':'    Note that the target CE will be UCOL_PROCESSED_NULLORDER if we reach the end of input,','line_number':3922,'multiline':False]
['text':'    which will fail the compare, below.','line_number':3923,'multiline':False]
['text':' redo with same patCE, next targCE','line_number':3930,'multiline':False]
['text':' ceMatch == U_CE_SKIP_PATN','line_number':3933,'multiline':False]
['text':' redo with same targCE, next patCE','line_number':3934,'multiline':False]
['text':' this is now the offset in target CE space to end of the match so far','line_number':3939,'multiline':False]
['text':' No match at this targetIx.  Try again at the next.','line_number':3942,'multiline':False]
['text':' No match at all, we have run off the end of the target text.','line_number':3947,'multiline':False]
['text':' We have found a match in CE space.','line_number':3952,'multiline':False]
['text':' Now determine the bounds in string index space.','line_number':3953,'multiline':False]
['text':'  There still is a chance of match failure if the CE range not correspond to','line_number':3954,'multiline':False]
['text':'     an acceptable character range.','line_number':3955,'multiline':False]
['text':'','line_number':3956,'multiline':False]
['text':' Look at the CE following the match.  If it is UCOL_NULLORDER the match','line_number':3962,'multiline':False]
['text':'   extended to the end of input, and the match is good.','line_number':3963,'multiline':False]
['text':' Look at the high and low indices of the CE following the match. If','line_number':3965,'multiline':False]
['text':' they are the same it means one of two things:','line_number':3966,'multiline':False]
['text':'    1. The match extended to the last CE from the target text, which is OK, or','line_number':3967,'multiline':False]
['text':'    2. The last CE that was part of the match is in an expansion that extends','line_number':3968,'multiline':False]
['text':'       to the first CE after the match. In this case, we reject the match.','line_number':3969,'multiline':False]
['text':' If we are at the end of the target too, match succeeds','line_number':3981,'multiline':False]
['text':' As long as the next CE has primary weight of 0,','line_number':3985,'multiline':False]
['text':' it is part of the last target element matched by the pattern;','line_number':3986,'multiline':False]
['text':' make sure it can be part of a match with the last patCE','line_number':3987,'multiline':False]
['text':' If lowIndex == highIndex, this target CE is part of an expansion of the last matched','line_number':3994,'multiline':False]
['text':' target element, but it has non-zero primary weight => match fails','line_number':3995,'multiline':False]
['text':' Else the target CE is not part of an expansion of the last matched element, match succeeds','line_number':3999,'multiline':False]
['text':' Check for the start of the match being within a combining sequence.','line_number':4007,'multiline':False]
['text':'   This can happen if the pattern itself begins with a combining char, and','line_number':4008,'multiline':False]
['text':'   the match found combining marks in the target text that were attached','line_number':4009,'multiline':False]
['text':'    to something else.','line_number':4010,'multiline':False]
['text':'   This type of match should be rejected for not completely consuming a','line_number':4011,'multiline':False]
['text':'   combining sequence.','line_number':4012,'multiline':False]
['text':' Check for the start of the match being within an Collation Element Expansion,','line_number':4017,'multiline':False]
['text':'   meaning that the first char of the match is only partially matched.','line_number':4018,'multiline':False]
['text':'   With exapnsions, the first CE will report the index of the source','line_number':4019,'multiline':False]
['text':'   character, and all subsequent (expansions) CEs will report the source index of the','line_number':4020,'multiline':False]
['text':'    _following_ character.','line_number':4021,'multiline':False]
['text':' Allow matches to end in the middle of a grapheme cluster if the following','line_number':4027,'multiline':False]
['text':' conditions are met; this is needed to make prefix search work properly in','line_number':4028,'multiline':False]
['text':' Indic, see #11750','line_number':4029,'multiline':False]
['text':' * the default breakIter is being used','line_number':4030,'multiline':False]
['text':' * the next collation element after this combining sequence','line_number':4031,'multiline':False]
['text':'   - has non-zero primary weight','line_number':4032,'multiline':False]
['text':'   - corresponds to a separate character following the one at end of the current match','line_number':4033,'multiline':False]
['text':'   (the second of these conditions, and perhaps both, may be redundant given the','line_number':4034,'multiline':False]
['text':'   subsequent check for normalization boundary; however they are likely much faster','line_number':4035,'multiline':False]
['text':'   tests in any case)','line_number':4036,'multiline':False]
['text':' * the match limit is a normalization boundary','line_number':4037,'multiline':False]
['text':' If those conditions are met, then:','line_number':4047,'multiline':False]
['text':' * do NOT advance the candidate match limit (mLimit) to a break boundary; however','line_number':4048,'multiline':False]
['text':'   the match limit may be backed off to a previous break boundary. This handles','line_number':4049,'multiline':False]
['text':'   cases in which mLimit includes target characters that are ignorable with current','line_number':4050,'multiline':False]
['text':'   settings (such as space) and which extend beyond the pattern match.','line_number':4051,'multiline':False]
['text':' * do NOT require that end of the combining sequence not extend beyond the match in CE space','line_number':4052,'multiline':False]
['text':' * do NOT require that match limit be on a breakIter boundary','line_number':4053,'multiline':False]
['text':'  Advance the match end position to the first acceptable match boundary.','line_number':4055,'multiline':False]
['text':'    This advances the index over any combining charcters.','line_number':4056,'multiline':False]
['text':' When the last CE's low index is same with its high index, the CE is likely','line_number':4059,'multiline':False]
['text':' a part of expansion. In this case, the index is located just after the','line_number':4060,'multiline':False]
['text':' character corresponding to the CEs compared above. If the index is right','line_number':4061,'multiline':False]
['text':' at the break boundary, move the position to the next boundary will result','line_number':4062,'multiline':False]
['text':' incorrect match length when there are ignorable characters exist between','line_number':4063,'multiline':False]
['text':' the position and the next character produces CE(s). See ticket#8482.','line_number':4064,'multiline':False]
['text':' Note that we can have nba < maxLimit && nba >= minLImit, in which','line_number':4069,'multiline':False]
['text':' case we want to set mLimit to nba regardless of allowMidclusterMatch','line_number':4070,'multiline':False]
['text':' (i.e. we back off mLimit to the previous breakIterator boundary).','line_number':4071,'multiline':False]
['text':' If advancing to the end of a combining sequence in character indexing space','line_number':4085,'multiline':False]
['text':'   advanced us beyond the end of the match in CE space, reject this match.','line_number':4086,'multiline':False]
['text':' All Done.  Store back the match bounds to the caller.','line_number':4116,'multiline':False]
['text':'','line_number':4117,'multiline':False]
['text':' TODO:  reject search patterns beginning with a combining char.','line_number':4144,'multiline':False]
['text':' Input parameter sanity check.','line_number':4156,'multiline':False]
['text':'  TODO:  should input indicies clip to the text length','line_number':4157,'multiline':False]
['text':'         in the same way that UText does.','line_number':4158,'multiline':False]
['text':'
     * Pre-load the buffer with the CE's for the grapheme
     * after our starting position so that we're sure that
     * we can look at the CE following the match when we
     * check the match boundaries.
     *
     * This will also pre-fetch the first CE that we'll
     * consider for the match.
     ','line_number':4174,'multiline':True]
['text':' Outer loop moves over match starting positions in the','line_number':4211,'multiline':False]
['text':'      target CE space.','line_number':4212,'multiline':False]
['text':' Here, targetIx values increase toward the beginning of the base text (i.e. we get the text CEs in reverse order).','line_number':4213,'multiline':False]
['text':' But  patIx is 0 at the beginning of the pattern and increases toward the end.','line_number':4214,'multiline':False]
['text':' So this loop performs a comparison starting with the end of pattern, and prcessd toward the beginning of the pattern','line_number':4215,'multiline':False]
['text':' and the beginning of the base text.','line_number':4216,'multiline':False]
['text':' For targetIx > limitIx, this ceb.getPrevious gets a CE that is as far back in the ring buffer','line_number':4220,'multiline':False]
['text':' (compared to the last CE fetched for the previous targetIx value) as we need to go','line_number':4221,'multiline':False]
['text':' for this targetIx value, so if it is non-NULL then other ceb.getPrevious calls should be OK.','line_number':4222,'multiline':False]
['text':'  Inner loop checks for a match beginning at each','line_number':4229,'multiline':False]
['text':'  position from the outer loop.','line_number':4230,'multiline':False]
['text':'  Compare CE from target string with CE from the pattern.','line_number':4236,'multiline':False]
['text':'    Note that the target CE will be UCOL_NULLORDER if we reach the end of input,','line_number':4237,'multiline':False]
['text':'    which will fail the compare, below.','line_number':4238,'multiline':False]
['text':' redo with same patCE, next targCE','line_number':4245,'multiline':False]
['text':' ceMatch == U_CE_SKIP_PATN','line_number':4248,'multiline':False]
['text':' redo with same targCE, next patCE','line_number':4249,'multiline':False]
['text':' No match at this targetIx.  Try again at the next.','line_number':4256,'multiline':False]
['text':' No match at all, we have run off the end of the target text.','line_number':4261,'multiline':False]
['text':' We have found a match in CE space.','line_number':4266,'multiline':False]
['text':' Now determine the bounds in string index space.','line_number':4267,'multiline':False]
['text':'  There still is a chance of match failure if the CE range not correspond to','line_number':4268,'multiline':False]
['text':'     an acceptable character range.','line_number':4269,'multiline':False]
['text':'','line_number':4270,'multiline':False]
['text':' Check for the start of the match being within a combining sequence.','line_number':4274,'multiline':False]
['text':'   This can happen if the pattern itself begins with a combining char, and','line_number':4275,'multiline':False]
['text':'   the match found combining marks in the target text that were attached','line_number':4276,'multiline':False]
['text':'    to something else.','line_number':4277,'multiline':False]
['text':'   This type of match should be rejected for not completely consuming a','line_number':4278,'multiline':False]
['text':'   combining sequence.','line_number':4279,'multiline':False]
['text':' Look at the high index of the first CE in the match. If it's the same as the','line_number':4284,'multiline':False]
['text':' low index, the first CE in the match is in the middle of an expansion.','line_number':4285,'multiline':False]
['text':' Look at the CE following the match.  If it is UCOL_NULLORDER the match','line_number':4294,'multiline':False]
['text':'   extended to the end of input, and the match is good.','line_number':4295,'multiline':False]
['text':' Look at the high and low indices of the CE following the match. If','line_number':4297,'multiline':False]
['text':' they are the same it means one of two things:','line_number':4298,'multiline':False]
['text':'    1. The match extended to the last CE from the target text, which is OK, or','line_number':4299,'multiline':False]
['text':'    2. The last CE that was part of the match is in an expansion that extends','line_number':4300,'multiline':False]
['text':'       to the first CE after the match. In this case, we reject the match.','line_number':4301,'multiline':False]
['text':' Allow matches to end in the middle of a grapheme cluster if the following','line_number':4310,'multiline':False]
['text':' conditions are met; this is needed to make prefix search work properly in','line_number':4311,'multiline':False]
['text':' Indic, see #11750','line_number':4312,'multiline':False]
['text':' * the default breakIter is being used','line_number':4313,'multiline':False]
['text':' * the next collation element after this combining sequence','line_number':4314,'multiline':False]
['text':'   - has non-zero primary weight','line_number':4315,'multiline':False]
['text':'   - corresponds to a separate character following the one at end of the current match','line_number':4316,'multiline':False]
['text':'   (the second of these conditions, and perhaps both, may be redundant given the','line_number':4317,'multiline':False]
['text':'   subsequent check for normalization boundary; however they are likely much faster','line_number':4318,'multiline':False]
['text':'   tests in any case)','line_number':4319,'multiline':False]
['text':' * the match limit is a normalization boundary','line_number':4320,'multiline':False]
['text':' If those conditions are met, then:','line_number':4330,'multiline':False]
['text':' * do NOT advance the candidate match limit (mLimit) to a break boundary; however','line_number':4331,'multiline':False]
['text':'   the match limit may be backed off to a previous break boundary. This handles','line_number':4332,'multiline':False]
['text':'   cases in which mLimit includes target characters that are ignorable with current','line_number':4333,'multiline':False]
['text':'   settings (such as space) and which extend beyond the pattern match.','line_number':4334,'multiline':False]
['text':' * do NOT require that end of the combining sequence not extend beyond the match in CE space','line_number':4335,'multiline':False]
['text':' * do NOT require that match limit be on a breakIter boundary','line_number':4336,'multiline':False]
['text':'  Advance the match end position to the first acceptable match boundary.','line_number':4338,'multiline':False]
['text':'    This advances the index over any combining characters.','line_number':4339,'multiline':False]
['text':' Note that we can have nba < maxLimit && nba >= minLImit, in which','line_number':4342,'multiline':False]
['text':' case we want to set mLimit to nba regardless of allowMidclusterMatch','line_number':4343,'multiline':False]
['text':' (i.e. we back off mLimit to the previous breakIterator boundary).','line_number':4344,'multiline':False]
['text':' If advancing to the end of a combining sequence in character indexing space','line_number':4351,'multiline':False]
['text':'   advanced us beyond the end of the match in CE space, reject this match.','line_number':4352,'multiline':False]
['text':' Make sure the end of the match is on a break boundary','line_number':4357,'multiline':False]
['text':' No non-ignorable CEs after this point.','line_number':4364,'multiline':False]
['text':' The maximum position is detected by boundary after','line_number':4365,'multiline':False]
['text':' the last non-ignorable CE. Combining sequence','line_number':4366,'multiline':False]
['text':' across the start index will be truncated.','line_number':4367,'multiline':False]
['text':' All Done.  Store back the match bounds to the caller.','line_number':4399,'multiline':False]
['text':'','line_number':4400,'multiline':False]
['text':' internal use methods declared in usrchimp.h -----------------------------','line_number':4417,'multiline':False]
['text':' status used in setting coleiter offset, since offset is checked in','line_number':4433,'multiline':False]
['text':' shiftForward before setting the coleiter offset, status never','line_number':4434,'multiline':False]
['text':' a failure','line_number':4435,'multiline':False]
['text':' finding the last pattern ce match, imagine composite characters','line_number':4448,'multiline':False]
['text':' for example: search for pattern A in text \u00C0','line_number':4449,'multiline':False]
['text':' we'll have to skip \u0300 the grave first before we get to A','line_number':4450,'multiline':False]
['text':' this is for the text \u0315\u0300 that requires','line_number':4458,'multiline':False]
['text':' normalization and pattern \u0300, where \u0315 is ignorable','line_number':4459,'multiline':False]
['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4465,'multiline':False]
['text':' the first ce can be a contraction','line_number':4467,'multiline':False]
['text':'targetce = lastce;','line_number':4477,'multiline':False]
['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4492,'multiline':False]
['text':' status checked at loop.','line_number':4504,'multiline':False]
['text':' status checked in ucol_setOffset','line_number':4510,'multiline':False]
['text':' finding the last pattern ce match, imagine composite characters','line_number':4564,'multiline':False]
['text':' for example: search for pattern A in text \u00C0','line_number':4565,'multiline':False]
['text':' we'll have to skip \u0300 the grave first before we get to A','line_number':4566,'multiline':False]
['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4576,'multiline':False]
['text':' the first ce can be a contraction','line_number':4578,'multiline':False]
['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4600,'multiline':False]
['text':' initializing the rearranged accent array','line_number':4604,'multiline':False]
['text':' status checked at loop','line_number':4620,'multiline':False]
['text':' shifting it check for setting offset','line_number':4661,'multiline':False]
['text':' if setOffset is called previously or there was no previous match, we','line_number':4662,'multiline':False]
['text':' leave the offset as it is.','line_number':4663,'multiline':False]
['text':' if status is a failure, ucol_setOffset does nothing','line_number':4678,'multiline':False]
['text':' finding the first pattern ce match, imagine composite','line_number':4682,'multiline':False]
['text':' characters. for example: search for pattern \u0300 in text','line_number':4683,'multiline':False]
['text':' \u00C0, we'll have to skip A first before we get to','line_number':4684,'multiline':False]
['text':' \u0300 the grave accent','line_number':4685,'multiline':False]
['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4698,'multiline':False]
['text':' checking for accents in composite character','line_number':4704,'multiline':False]
['text':'targetce = firstce;','line_number':4710,'multiline':False]
['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4724,'multiline':False]
['text':' move the start position at the end of possible match','line_number':4756,'multiline':False]
['text':' at the end of the text','line_number':4765,'multiline':False]
['text':' shifting it check for setting offset','line_number':4809,'multiline':False]
['text':' if setOffset is called previously or there was no previous match, we','line_number':4810,'multiline':False]
['text':' leave the offset as it is.','line_number':4811,'multiline':False]
['text':' finding the first pattern ce match, imagine composite','line_number':4830,'multiline':False]
['text':' characters. for example: search for pattern \u0300 in text','line_number':4831,'multiline':False]
['text':' \u00C0, we'll have to skip A first before we get to','line_number':4832,'multiline':False]
['text':' \u0300 the grave accent','line_number':4833,'multiline':False]
['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4844,'multiline':False]
['text':' the first ce can be a contraction','line_number':4846,'multiline':False]
['text':' checking for accents in composite character','line_number':4851,'multiline':False]
['text':' TODO: #if BOYER_MOORE, replace with code using 32-bit version of compareCE64s','line_number':4870,'multiline':False]
['text':' initializing the rearranged accent array','line_number':4875,'multiline':False]
['text':' move the start position at the end of possible match','line_number':4909,'multiline':False]
['text':' at the end of the text','line_number':4918,'multiline':False]
['text':' #if !UCONFIG_NO_COLLATION ','line_number':4946,'multiline':True]
