['text':'
*******************************************************************************
* Copyright (C) 2010-2014, International Business Machines
* Corporation and others.  All Rights Reserved.
*******************************************************************************
* collationiterator.cpp
*
* created on: 2010oct27
* created by: Markus W. Scherer
','line_number':1,'multiline':True]
['text':' for 'typeid' to work','line_number':12,'multiline':False]
['text':' State of combining marks skipped in discontiguous contraction.','line_number':54,'multiline':False]
['text':' We create a state object on first use and keep it around deactivated between uses.','line_number':55,'multiline':False]
['text':' Born active but empty.','line_number':58,'multiline':False]
['text':' The newBuffer is reset by setFirstSkipped().','line_number':63,'multiline':False]
['text':' Requires hasNext().','line_number':70,'multiline':False]
['text':' Accounts for one more input code point read beyond the end of the marks buffer.','line_number':77,'multiline':False]
['text':' Goes backward through the skipped-marks buffer.','line_number':83,'multiline':False]
['text':' Returns the number of code points read beyond the skipped marks','line_number':84,'multiline':False]
['text':' that need to be backtracked through normal input.','line_number':85,'multiline':False]
['text':' Not back far enough to re-enter the oldBuffer.','line_number':91,'multiline':False]
['text':' Back out all beyond-oldBuffer code points and re-enter the buffer.','line_number':95,'multiline':False]
['text':' Go backwards from inside the oldBuffer.','line_number':100,'multiline':False]
['text':' Replaces the characters we consumed with the newly skipped ones.','line_number':117,'multiline':False]
['text':' Note: UnicodeString.replace() pins pos to at most length().','line_number':119,'multiline':False]
['text':' Combining marks skipped in previous discontiguous-contraction matching.','line_number':128,'multiline':False]
['text':' After that discontiguous contraction was completed, we start reading them from here.','line_number':129,'multiline':False]
['text':' Combining marks newly skipped in current discontiguous-contraction matching.','line_number':131,'multiline':False]
['text':' These might have been read from the normal text or from the oldBuffer.','line_number':132,'multiline':False]
['text':' Reading index in oldBuffer,','line_number':134,'multiline':False]
['text':' or counter for how many code points have been read beyond oldBuffer (pos-oldBuffer.length()).','line_number':135,'multiline':False]
['text':' newBuffer.length() at the time of the last matching character.','line_number':137,'multiline':False]
['text':' When a partial match fails, we back out skipped and partial-matching input characters.','line_number':138,'multiline':False]
['text':' We save the trie state before we attempt to match a character,','line_number':140,'multiline':False]
['text':' so that we can skip it and try the next one.','line_number':141,'multiline':False]
['text':' Subclasses: Call this method and then add more specific checks.','line_number':171,'multiline':False]
['text':' Compare the iterator state but not the collation data (trie & data fields):','line_number':172,'multiline':False]
['text':' Assume that the caller compares the data.','line_number':173,'multiline':False]
['text':' Ignore skipped since that should be unused between calls to nextCE().','line_number':174,'multiline':False]
['text':' (It only stays around to avoid another memory allocation.)','line_number':175,'multiline':False]
['text':' No need to loop for each expansion CE.','line_number':198,'multiline':False]
['text':'ce32','line_number':231,'multiline':True]
['text':' Undo ceBuffer.incLength().','line_number':239,'multiline':False]
['text':' Default if no suffix match.','line_number':305,'multiline':False]
['text':' Backward contractions are handled by previousCEUnsafe().','line_number':307,'multiline':False]
['text':' c has contractions but they were not found.','line_number':308,'multiline':False]
['text':' Some portion of nextCE32FromContraction() pulled out here as an ASCII fast path,','line_number':314,'multiline':False]
['text':' avoiding the function call and the nextSkippedCodePoint() overhead.','line_number':315,'multiline':False]
['text':' No more text.','line_number':318,'multiline':False]
['text':' All contraction suffixes start with characters with lccc!=0','line_number':323,'multiline':False]
['text':' but the next code point has lccc==0.','line_number':324,'multiline':False]
['text':' No more text.','line_number':332,'multiline':False]
['text':' All contraction suffixes start with characters with lccc!=0','line_number':337,'multiline':False]
['text':' but the next code point has lccc==0.','line_number':338,'multiline':False]
['text':' CEs from a discontiguous contraction plus the skipped combining marks','line_number':346,'multiline':False]
['text':' have been appended already.','line_number':347,'multiline':False]
['text':' Fetch the non-numeric-collation CE32 and continue.','line_number':357,'multiline':False]
['text':' Handle NUL-termination. (Not needed in Java.)','line_number':364,'multiline':False]
['text':' Fetch the normal ce32 for U+0000 and continue.','line_number':368,'multiline':False]
['text':' None of the Jamo CE32s are isSpecialCE32().','line_number':380,'multiline':False]
['text':' Avoid recursive function calls and per-Jamo tests.','line_number':381,'multiline':False]
['text':' We should not need to compute each Jamo code point.','line_number':392,'multiline':False]
['text':' In particular, there should be no offset or implicit ce32.','line_number':393,'multiline':False]
['text':' offset 39 = 19 + 21 - 1:','line_number':397,'multiline':False]
['text':' 19 = JAMO_L_COUNT','line_number':398,'multiline':False]
['text':' 21 = JAMO_T_COUNT','line_number':399,'multiline':False]
['text':' -1 = omit t==0','line_number':400,'multiline':False]
['text':' Backward iteration should never see lead surrogate code _unit_ data.','line_number':407,'multiline':False]
['text':' unassigned-implicit','line_number':414,'multiline':False]
['text':' fall back to the base data','line_number':417,'multiline':False]
['text':' c is an unpaired surrogate.','line_number':422,'multiline':False]
['text':' Default if no prefix match.','line_number':449,'multiline':False]
['text':' Number of code points read before the original code point.','line_number':451,'multiline':False]
['text':' c: next code point after the original one','line_number':491,'multiline':False]
['text':' Number of code points read beyond the original code point.','line_number':493,'multiline':False]
['text':' Needed for discontiguous contraction matching.','line_number':494,'multiline':False]
['text':' Number of code points read since the last match (initially only c).','line_number':496,'multiline':False]
['text':' Normally we only need a contiguous match,','line_number':498,'multiline':False]
['text':' and therefore need not remember the suffixes state from before a mismatch for retrying.','line_number':499,'multiline':False]
['text':' If we are already processing skipped combining marks, then we do track the state.','line_number':500,'multiline':False]
['text':' No match for c, or partial match (USTRINGTRIE_NO_VALUE) and no further text.','line_number':514,'multiline':False]
['text':' Back up if necessary, and try a discontiguous contraction.','line_number':515,'multiline':False]
['text':' Discontiguous contraction matching extends an existing match.','line_number':517,'multiline':False]
['text':' If there is no match yet, then there is nothing to do.','line_number':518,'multiline':False]
['text':' The last character of at least one suffix has lccc!=0,','line_number':521,'multiline':False]
['text':' allowing for discontiguous contractions.','line_number':522,'multiline':False]
['text':' UCA S2.1.1 only processes non-starters immediately following','line_number':523,'multiline':False]
['text':' "a match in the table" (sinceMatch=1).','line_number':524,'multiline':False]
['text':' Return to the state after the last match.','line_number':526,'multiline':False]
['text':' (Return to sinceMatch=0 and re-fetch the first partially-matched character.)','line_number':527,'multiline':False]
['text':' Continue after partial match (USTRINGTRIE_NO_VALUE) for c.','line_number':540,'multiline':False]
['text':' It does not have a result value, therefore it is not itself "a match in the table".','line_number':541,'multiline':False]
['text':' If a partially-matched c has ccc!=0 then','line_number':542,'multiline':False]
['text':' it might be skipped in discontiguous contraction.','line_number':543,'multiline':False]
['text':' UCA section 3.3.2 Contractions:','line_number':561,'multiline':False]
['text':' Contractions that end with non-starter characters','line_number':562,'multiline':False]
['text':' are known as discontiguous contractions.','line_number':563,'multiline':False]
['text':' ... discontiguous contractions must be detected in input text','line_number':564,'multiline':False]
['text':' whenever the final sequence of non-starter characters could be rearranged','line_number':565,'multiline':False]
['text':' so as to make a contiguous matching sequence that is canonically equivalent.','line_number':566,'multiline':False]
['text':' UCA: http://www.unicode.org/reports/tr10/#S2.1','line_number':568,'multiline':False]
['text':' S2.1 Find the longest initial substring S at each point that has a match in the table.','line_number':569,'multiline':False]
['text':' S2.1.1 If there are any non-starters following S, process each non-starter C.','line_number':570,'multiline':False]
['text':' S2.1.2 If C is not blocked from S, find if S + C has a match in the table.','line_number':571,'multiline':False]
['text':'     Note: A non-starter in a string is called blocked','line_number':572,'multiline':False]
['text':'     if there is another non-starter of the same canonical combining class or zero','line_number':573,'multiline':False]
['text':'     between it and the last character of canonical combining class 0.','line_number':574,'multiline':False]
['text':' S2.1.3 If there is a match, replace S by S + C, and remove C.','line_number':575,'multiline':False]
['text':' First: Is a discontiguous contraction even possible?','line_number':577,'multiline':False]
['text':' The caller checked this already, as a shortcut.','line_number':579,'multiline':False]
['text':' No further text.','line_number':582,'multiline':False]
['text':' The next code point after c is a starter (S2.1.1 "process each non-starter").','line_number':590,'multiline':False]
['text':' We have read and matched (lookAhead-2) code points,','line_number':595,'multiline':False]
['text':' read non-matching c and peeked ahead at nextCp.','line_number':596,'multiline':False]
['text':' Return to the state before the mismatch and continue matching with nextCp.','line_number':597,'multiline':False]
['text':' Replay the partial match so far.','line_number':608,'multiline':False]
['text':' Skip c (which did not match) and nextCp (which we will try now).','line_number':614,'multiline':False]
['text':' Reset to the trie state before the failed match of c.','line_number':619,'multiline':False]
['text':' Number of code points read since the last match (at this point: c and nextCp).','line_number':624,'multiline':False]
['text':' "If C is not blocked from S, find if S + C has a match in the table." (S2.1.2)','line_number':629,'multiline':False]
['text':' "If there is a match, replace S by S + C, and remove C." (S2.1.3)','line_number':631,'multiline':False]
['text':' Keep prevCC unchanged.','line_number':632,'multiline':False]
['text':' No match for "S + C", skip C.','line_number':639,'multiline':False]
['text':' The next code point after c is a starter (S2.1.1 "process each non-starter").','line_number':648,'multiline':False]
['text':' We did get a match after skipping one or more combining marks,','line_number':656,'multiline':False]
['text':' and we are not in a recursive discontiguous contraction.','line_number':657,'multiline':False]
['text':' Append CEs from the contraction ce32','line_number':658,'multiline':False]
['text':' and then from the combining marks that we skipped before the match.','line_number':659,'multiline':False]
['text':' Fetch CE32s for skipped combining marks from the normal data, with fallback,','line_number':663,'multiline':False]
['text':' rather than from the CollationData where we found the contraction.','line_number':664,'multiline':False]
['text':' Note: A nested discontiguous-contraction match','line_number':674,'multiline':False]
['text':' replaces consumed combining marks with newly skipped ones','line_number':675,'multiline':False]
['text':' and resets the reading position to the beginning.','line_number':676,'multiline':False]
['text':' Signal to the caller that the result is in the ceBuffer.','line_number':679,'multiline':False]
['text':' Collect digits.','line_number':686,'multiline':False]
['text':' Reverse the digit string.','line_number':720,'multiline':False]
['text':' Skip leading zeros.','line_number':732,'multiline':False]
['text':' Write a sequence of CEs for at most 254 digits at a time.','line_number':734,'multiline':False]
['text':' Note: We use primary byte values 2..255: digits are not compressible.','line_number':747,'multiline':False]
['text':' Very dense encoding for small numbers.','line_number':749,'multiline':False]
['text':' Primary weight second byte values:','line_number':754,'multiline':False]
['text':'     74 byte values   2.. 75 for small numbers in two-byte primary weights.','line_number':755,'multiline':False]
['text':'     40 byte values  76..115 for medium numbers in three-byte primary weights.','line_number':756,'multiline':False]
['text':'     16 byte values 116..131 for large numbers in four-byte primary weights.','line_number':757,'multiline':False]
['text':'    124 byte values 132..255 for very large numbers with 4..127 digit pairs.','line_number':758,'multiline':False]
['text':' Two-byte primary for 0..73, good for day & month numbers etc.','line_number':762,'multiline':False]
['text':' Three-byte primary for 74..10233=74+40*254-1, good for year numbers and more.','line_number':771,'multiline':False]
['text':' Four-byte primary for 10234..1042489=10234+16*254*254-1.','line_number':781,'multiline':False]
['text':' original value > 1042489','line_number':790,'multiline':False]
['text':' The second primary byte value 132..255 indicates the number of digit pairs (4..127),','line_number':794,'multiline':False]
['text':' then we generate primary bytes with those pairs.','line_number':795,'multiline':False]
['text':' Omit trailing 00 pairs.','line_number':796,'multiline':False]
['text':' Decrement the value for the last pair.','line_number':797,'multiline':False]
['text':' Set the exponent. 4 pairs->132, 5 pairs->133, ..., 127 pairs->255.','line_number':799,'multiline':False]
['text':' Find the length without trailing 00 pairs.','line_number':802,'multiline':False]
['text':' Read the first pair.','line_number':806,'multiline':False]
['text':' Only "half a pair" if we have an odd number of digits.','line_number':810,'multiline':False]
['text':' Add the pairs of digits between pos and length.','line_number':818,'multiline':False]
['text':' Every three pairs/bytes we need to store a 4-byte-primary CE','line_number':822,'multiline':False]
['text':' and start with a new CE with the '0' primary lead byte.','line_number':823,'multiline':False]
['text':' Return the previous buffered CE.','line_number':842,'multiline':False]
['text':' Simple, safe-backwards iteration:','line_number':852,'multiline':False]
['text':' Get a CE going backwards, handle prefixes but no contractions.','line_number':853,'multiline':False]
['text':' For an expansion, the offset of each non-initial CE is the limit offset,','line_number':869,'multiline':False]
['text':' consistent with forward iteration.','line_number':870,'multiline':False]
['text':' We just move through the input counting safe and unsafe code points','line_number':883,'multiline':False]
['text':' without collecting the unsafe-backward substring into a buffer and','line_number':884,'multiline':False]
['text':' switching to it.','line_number':885,'multiline':False]
['text':' This is to keep the logic simple. Otherwise we would have to handle','line_number':886,'multiline':False]
['text':' prefix matching going before the backward buffer, switching','line_number':887,'multiline':False]
['text':' to iteration and back, etc.','line_number':888,'multiline':False]
['text':' In the most important case of iterating over a normal string,','line_number':889,'multiline':False]
['text':' reading from the string itself is already maximally fast.','line_number':890,'multiline':False]
['text':' The only drawback there is that after getting the CEs we always','line_number':891,'multiline':False]
['text':' skip backward to the safe character rather than switching out','line_number':892,'multiline':False]
['text':' of a backwardBuffer.','line_number':893,'multiline':False]
['text':' But this should not be the common case for previousCE(),','line_number':894,'multiline':False]
['text':' and correctness and maintainability are more important than','line_number':895,'multiline':False]
['text':' complex optimizations.','line_number':896,'multiline':False]
['text':' Find the first safe character before c.','line_number':897,'multiline':False]
['text':' Set the forward iteration limit.','line_number':905,'multiline':False]
['text':' Note: This counts code points.','line_number':906,'multiline':False]
['text':' We cannot enforce a limit in the middle of a surrogate pair or similar.','line_number':907,'multiline':False]
['text':' Reset the forward iterator.','line_number':909,'multiline':False]
['text':' Go forward and collect the CEs.','line_number':912,'multiline':False]
['text':' nextCE() normally reads one code point.','line_number':915,'multiline':False]
['text':' Contraction matching and digit specials read more and check numCpFwd.','line_number':916,'multiline':False]
['text':' Append one or more CEs to the ceBuffer.','line_number':918,'multiline':False]
['text':' No need to loop for getting each expansion CE from nextCE().','line_number':921,'multiline':False]
['text':' However, we need to write an offset for each CE.','line_number':923,'multiline':False]
['text':' This is for CollationElementIterator::getOffset() to return','line_number':924,'multiline':False]
['text':' intermediate offsets from the unsafe-backwards segment.','line_number':925,'multiline':False]
['text':' For an expansion, the offset of each non-initial CE is the limit offset,','line_number':928,'multiline':False]
['text':' consistent with forward iteration.','line_number':929,'multiline':False]
['text':' End offset corresponding to just after the unsafe-backwards segment.','line_number':936,'multiline':False]
['text':' Reset the forward iteration limit','line_number':938,'multiline':False]
['text':' and move backward to before the segment for which we fetched CEs.','line_number':939,'multiline':False]
['text':' Use the collected CEs and return the last one.','line_number':942,'multiline':False]
['text':' Avoid cesIndex > ceBuffer.length when that gets decremented.','line_number':943,'multiline':False]
['text':' !UCONFIG_NO_COLLATION','line_number':953,'multiline':False]
