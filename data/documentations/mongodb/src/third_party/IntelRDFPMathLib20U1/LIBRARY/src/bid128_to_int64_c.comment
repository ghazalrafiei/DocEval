['text':'*****************************************************************************
  Copyright (c) 2007-2011, Intel Corp.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    * Neither the name of Intel Corporation nor the names of its contributors 
      may be used to endorse or promote products derived from this software 
      without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  THE POSSIBILITY OF SUCH DAMAGE.
*****************************************************************************','line_number':1,'multiline':True]
['text':'****************************************************************************
 *  BID128_to_int64_rnint
 ***************************************************************************','line_number':33,'multiline':True]
['text':' unbiased exponent','line_number':43,'multiline':False]
['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':44,'multiline':False]
['text':' C* represents up to 34 decimal digits ~ 113 bits','line_number':50,'multiline':False]
['text':' unpack x','line_number':54,'multiline':False]
['text':' 0 for positive, MASK_SIGN for negative','line_number':55,'multiline':False]
['text':' biased and shifted left 49 bit positions','line_number':56,'multiline':False]
['text':' check for NaN or Infinity','line_number':60,'multiline':False]
['text':' x is special','line_number':62,'multiline':False]
['text':' x is NAN','line_number':63,'multiline':False]
['text':' x is SNAN','line_number':64,'multiline':False]
['text':' set invalid flag','line_number':65,'multiline':False]
['text':' return Integer Indefinite','line_number':67,'multiline':False]
['text':' x is QNaN','line_number':69,'multiline':False]
['text':' set invalid flag','line_number':70,'multiline':False]
['text':' return Integer Indefinite','line_number':72,'multiline':False]
['text':' x is not a NaN, so it must be infinity','line_number':76,'multiline':False]
['text':' x is +inf','line_number':77,'multiline':False]
['text':' set invalid flag','line_number':78,'multiline':False]
['text':' return Integer Indefinite','line_number':80,'multiline':False]
['text':' x is -inf','line_number':82,'multiline':False]
['text':' set invalid flag','line_number':83,'multiline':False]
['text':' return Integer Indefinite','line_number':85,'multiline':False]
['text':' check for non-canonical values (after the check for special values)','line_number':91,'multiline':False]
['text':' x is 0','line_number':99,'multiline':False]
['text':' x is not special and is not zero','line_number':102,'multiline':False]
['text':' q = nr. of decimal digits in x','line_number':104,'multiline':False]
['text':'  determine first the nr. of bits in x','line_number':105,'multiline':False]
['text':' x >= 2^53','line_number':107,'multiline':False]
['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':108,'multiline':False]
['text':' exact conversion','line_number':109,'multiline':False]
['text':' if x < 2^53','line_number':112,'multiline':False]
['text':' exact conversion','line_number':113,'multiline':False]
['text':' C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])','line_number':117,'multiline':False]
['text':' exact conversion','line_number':118,'multiline':False]
['text':' x >= 10^19 ~= 2^63.11... (cannot fit in BID_SINT64)','line_number':131,'multiline':False]
['text':' set invalid flag','line_number':132,'multiline':False]
['text':' return Integer Indefinite','line_number':134,'multiline':False]
['text':' x = c(0)c(1)...c(18).c(19)...c(q-1)','line_number':137,'multiline':False]
['text':' in this case 2^63.11... ~= 10^19 <= x < 10^20 ~= 2^66.43...','line_number':138,'multiline':False]
['text':' so x rounded to an integer may or may not fit in a signed 64-bit int','line_number':139,'multiline':False]
['text':' the cases that do not fit are identified here; the ones that fit','line_number':140,'multiline':False]
['text':' fall through and will be handled with other cases further,','line_number':141,'multiline':False]
['text':' under '1 <= q + exp <= 19'','line_number':142,'multiline':False]
['text':' if n < 0 and q + exp = 19','line_number':143,'multiline':False]
['text':' if n < -2^63 - 1/2 then n is too large','line_number':144,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) > 2^63+1/2','line_number':145,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 > 5*(2^64+1), 1<=q<=34','line_number':146,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 > 0x50000000000000005, 1<=q<=34','line_number':147,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 => ','line_number':150,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':151,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':154,'multiline':False]
['text':' if 21 <= q <= 34','line_number':155,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':156,'multiline':False]
['text':' set invalid flag','line_number':159,'multiline':False]
['text':' return Integer Indefinite','line_number':161,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':165,'multiline':False]
['text':' to '1 <= q + exp <= 19'','line_number':166,'multiline':False]
['text':' if n > 0 and q + exp = 19','line_number':167,'multiline':False]
['text':' if n >= 2^63 - 1/2 then n is too large','line_number':168,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63-1/2','line_number':169,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 5*(2^64-1), 1<=q<=34','line_number':170,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 0x4fffffffffffffffb, 1<=q<=34','line_number':171,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 =>','line_number':174,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':175,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':178,'multiline':False]
['text':' if 21 <= q <= 34','line_number':179,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':180,'multiline':False]
['text':' set invalid flag ','line_number':183,'multiline':False]
['text':' return Integer Indefinite ','line_number':185,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':189,'multiline':False]
['text':' to '1 <= q + exp <= 19' ','line_number':190,'multiline':False]
['text':' n is not too large to be converted to int64: -2^63-1/2 <= n < 2^63-1/2','line_number':193,'multiline':False]
['text':' Note: some of the cases tested for above fall through to this point','line_number':194,'multiline':False]
['text':' Restore C1 which may have been modified above','line_number':195,'multiline':False]
['text':' n = +/-0.0...c(0)c(1)...c(q-1)','line_number':198,'multiline':False]
['text':' return 0','line_number':199,'multiline':False]
['text':' n = +/-0.c(0)c(1)...c(q-1)','line_number':202,'multiline':False]
['text':' if 0.c(0)c(1)...c(q-1) <= 0.5 <=> c(0)c(1)...c(q-1) <= 5 * 10^(q-1)','line_number':203,'multiline':False]
['text':'   res = 0','line_number':204,'multiline':False]
['text':' else','line_number':205,'multiline':False]
['text':'   res = +/-1','line_number':206,'multiline':False]
['text':' 0 <= ind <= 18','line_number':208,'multiline':False]
['text':' return 0','line_number':210,'multiline':False]
['text':' n < 0','line_number':211,'multiline':False]
['text':' return -1','line_number':212,'multiline':False]
['text':' n > 0','line_number':213,'multiline':False]
['text':' return +1','line_number':214,'multiline':False]
['text':' 19 <= ind <= 33','line_number':216,'multiline':False]
['text':' return 0','line_number':220,'multiline':False]
['text':' n < 0','line_number':221,'multiline':False]
['text':' return -1','line_number':222,'multiline':False]
['text':' n > 0','line_number':223,'multiline':False]
['text':' return +1','line_number':224,'multiline':False]
['text':' if (1 <= q + exp <= 19, 1 <= q <= 34, -33 <= exp <= 18)','line_number':227,'multiline':False]
['text':' -2^63-1/2 <= x <= -1 or 1 <= x < 2^63-1/2 so x can be rounded','line_number':228,'multiline':False]
['text':' to nearest to a 64-bit signed integer','line_number':229,'multiline':False]
['text':' 2 <= q <= 34, -33 <= exp <= -1, 1 <= q + exp <= 19','line_number':230,'multiline':False]
['text':' 1 <= ind <= 33; ind is a synonym for 'x'','line_number':231,'multiline':False]
['text':' chop off ind digits from the lower part of C1','line_number':232,'multiline':False]
['text':' C1 = C1 + 1/2 * 10^ind where the result C1 fits in 127 bits','line_number':233,'multiline':False]
['text':' calculate C* and f*','line_number':243,'multiline':False]
['text':' C* is actually floor(C*) in this case','line_number':244,'multiline':False]
['text':' C* and f* need shifting and masking, as shown by','line_number':245,'multiline':False]
['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':246,'multiline':False]
['text':' 1 <= x <= 33','line_number':247,'multiline':False]
['text':' kx = 10^(-x) = bid_ten2mk128[ind - 1]','line_number':248,'multiline':False]
['text':' C* = (C1 + 1/2 * 10^x) * 10^(-x)','line_number':249,'multiline':False]
['text':' the approximation of 10^(-x) was rounded up to 118 bits','line_number':250,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':252,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':259,'multiline':False]
['text':' the top Ex bits of 10^(-x) are T* = bid_ten2mk128trunc[ind], e.g.','line_number':267,'multiline':False]
['text':' if x=1, T*=bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':268,'multiline':False]
['text':' if (0 < f* < 10^(-x)) then the result is a midpoint','line_number':269,'multiline':False]
['text':'   if floor(C*) is even then C* = floor(C*) - logical right','line_number':270,'multiline':False]
['text':'       shift; C* has p decimal digits, correct by Prop. 1)','line_number':271,'multiline':False]
['text':'   else if floor(C*) is odd C* = floor(C*)-1 (logical right','line_number':272,'multiline':False]
['text':'       shift; C* has p decimal digits, correct by Pr. 1)','line_number':273,'multiline':False]
['text':' else','line_number':274,'multiline':False]
['text':'   C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':275,'multiline':False]
['text':'       correct by Property 1)','line_number':276,'multiline':False]
['text':' n = C* * 10^(e+x)','line_number':277,'multiline':False]
['text':' shift right C* by Ex-128 = bid_shiftright128[ind]','line_number':279,'multiline':False]
['text':' 0 <= shift <= 102','line_number':280,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':281,'multiline':False]
['text':' redundant, it will be 0! Cstar.w[1] = (Cstar.w[1] >> shift);','line_number':284,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':285,'multiline':False]
['text':' 2 <= shift - 64 <= 38','line_number':286,'multiline':False]
['text':' if the result was a midpoint it was rounded away from zero, so','line_number':288,'multiline':False]
['text':' it will need a correction','line_number':289,'multiline':False]
['text':' check for midpoints','line_number':290,'multiline':False]
['text':' the result is a midpoint; round to nearest','line_number':296,'multiline':False]
['text':' Cstar.w[0] is odd; MP in [EVEN, ODD]','line_number':297,'multiline':False]
['text':' if floor(C*) is odd C = floor(C*) - 1; the result >= 1','line_number':298,'multiline':False]
['text':' Cstar.w[0] is now even','line_number':299,'multiline':False]
['text':' else MP in [ODD, EVEN]','line_number':300,'multiline':False]
['text':' 1 <= q <= 19','line_number':307,'multiline':False]
['text':' res = +/-C (exact)','line_number':308,'multiline':False]
['text':' if (exp>0) => 1 <= exp <= 18, 1 <= q < 18, 2 <= q + exp <= 19','line_number':313,'multiline':False]
['text':' res = +/-C * 10^exp (exact) where this fits in 64-bit integer','line_number':314,'multiline':False]
['text':'****************************************************************************
 *  BID128_to_int64_xrnint
 ***************************************************************************','line_number':326,'multiline':True]
['text':' unbiased exponent','line_number':336,'multiline':False]
['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':337,'multiline':False]
['text':' C* represents up to 34 decimal digits ~ 113 bits','line_number':343,'multiline':False]
['text':' unpack x','line_number':347,'multiline':False]
['text':' 0 for positive, MASK_SIGN for negative','line_number':348,'multiline':False]
['text':' biased and shifted left 49 bit positions','line_number':349,'multiline':False]
['text':' check for NaN or Infinity','line_number':353,'multiline':False]
['text':' x is special','line_number':355,'multiline':False]
['text':' x is NAN','line_number':356,'multiline':False]
['text':' x is SNAN','line_number':357,'multiline':False]
['text':' set invalid flag','line_number':358,'multiline':False]
['text':' return Integer Indefinite','line_number':360,'multiline':False]
['text':' x is QNaN','line_number':362,'multiline':False]
['text':' set invalid flag','line_number':363,'multiline':False]
['text':' return Integer Indefinite','line_number':365,'multiline':False]
['text':' x is not a NaN, so it must be infinity','line_number':369,'multiline':False]
['text':' x is +inf','line_number':370,'multiline':False]
['text':' set invalid flag','line_number':371,'multiline':False]
['text':' return Integer Indefinite','line_number':373,'multiline':False]
['text':' x is -inf','line_number':375,'multiline':False]
['text':' set invalid flag','line_number':376,'multiline':False]
['text':' return Integer Indefinite','line_number':378,'multiline':False]
['text':' check for non-canonical values (after the check for special values)','line_number':384,'multiline':False]
['text':' x is 0','line_number':392,'multiline':False]
['text':' x is not special and is not zero','line_number':395,'multiline':False]
['text':' q = nr. of decimal digits in x','line_number':397,'multiline':False]
['text':'  determine first the nr. of bits in x','line_number':398,'multiline':False]
['text':' x >= 2^53','line_number':400,'multiline':False]
['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':401,'multiline':False]
['text':' exact conversion','line_number':402,'multiline':False]
['text':' if x < 2^53','line_number':405,'multiline':False]
['text':' exact conversion','line_number':406,'multiline':False]
['text':' C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])','line_number':410,'multiline':False]
['text':' exact conversion','line_number':411,'multiline':False]
['text':' x >= 10^19 ~= 2^63.11... (cannot fit in BID_SINT64)','line_number':424,'multiline':False]
['text':' set invalid flag','line_number':425,'multiline':False]
['text':' return Integer Indefinite','line_number':427,'multiline':False]
['text':' x = c(0)c(1)...c(18).c(19)...c(q-1)','line_number':430,'multiline':False]
['text':' in this case 2^63.11... ~= 10^19 <= x < 10^20 ~= 2^66.43...','line_number':431,'multiline':False]
['text':' so x rounded to an integer may or may not fit in a signed 64-bit int','line_number':432,'multiline':False]
['text':' the cases that do not fit are identified here; the ones that fit','line_number':433,'multiline':False]
['text':' fall through and will be handled with other cases further,','line_number':434,'multiline':False]
['text':' under '1 <= q + exp <= 19'','line_number':435,'multiline':False]
['text':' if n < 0 and q + exp = 19','line_number':436,'multiline':False]
['text':' if n < -2^63 - 1/2 then n is too large','line_number':437,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) > 2^63+1/2','line_number':438,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 > 5*(2^64+1), 1<=q<=34','line_number':439,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 > 0x50000000000000005, 1<=q<=34','line_number':440,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 => ','line_number':443,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':444,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':447,'multiline':False]
['text':' if 21 <= q <= 34','line_number':448,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':449,'multiline':False]
['text':' set invalid flag','line_number':452,'multiline':False]
['text':' return Integer Indefinite','line_number':454,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':458,'multiline':False]
['text':' to '1 <= q + exp <= 19'','line_number':459,'multiline':False]
['text':' if n > 0 and q + exp = 19','line_number':460,'multiline':False]
['text':' if n >= 2^63 - 1/2 then n is too large','line_number':461,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63-1/2','line_number':462,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 5*(2^64-1), 1<=q<=34','line_number':463,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 0x4fffffffffffffffb, 1<=q<=34','line_number':464,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 =>','line_number':467,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':468,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':471,'multiline':False]
['text':' if 21 <= q <= 34','line_number':472,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':473,'multiline':False]
['text':' set invalid flag ','line_number':476,'multiline':False]
['text':' return Integer Indefinite ','line_number':478,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':482,'multiline':False]
['text':' to '1 <= q + exp <= 19' ','line_number':483,'multiline':False]
['text':' n is not too large to be converted to int64: -2^63-1/2 <= n < 2^63-1/2','line_number':486,'multiline':False]
['text':' Note: some of the cases tested for above fall through to this point','line_number':487,'multiline':False]
['text':' Restore C1 which may have been modified above','line_number':488,'multiline':False]
['text':' n = +/-0.0...c(0)c(1)...c(q-1)','line_number':491,'multiline':False]
['text':' set inexact flag','line_number':492,'multiline':False]
['text':' return 0','line_number':494,'multiline':False]
['text':' n = +/-0.c(0)c(1)...c(q-1)','line_number':497,'multiline':False]
['text':' if 0.c(0)c(1)...c(q-1) <= 0.5 <=> c(0)c(1)...c(q-1) <= 5 * 10^(q-1)','line_number':498,'multiline':False]
['text':'   res = 0','line_number':499,'multiline':False]
['text':' else','line_number':500,'multiline':False]
['text':'   res = +/-1','line_number':501,'multiline':False]
['text':' 0 <= ind <= 18','line_number':503,'multiline':False]
['text':' return 0','line_number':505,'multiline':False]
['text':' n < 0','line_number':506,'multiline':False]
['text':' return -1','line_number':507,'multiline':False]
['text':' n > 0','line_number':508,'multiline':False]
['text':' return +1','line_number':509,'multiline':False]
['text':' 19 <= ind <= 33','line_number':511,'multiline':False]
['text':' return 0','line_number':515,'multiline':False]
['text':' n < 0','line_number':516,'multiline':False]
['text':' return -1','line_number':517,'multiline':False]
['text':' n > 0','line_number':518,'multiline':False]
['text':' return +1','line_number':519,'multiline':False]
['text':' set inexact flag','line_number':522,'multiline':False]
['text':' if (1 <= q + exp <= 19, 1 <= q <= 34, -33 <= exp <= 18)','line_number':524,'multiline':False]
['text':' -2^63-1/2 <= x <= -1 or 1 <= x < 2^63-1/2 so x can be rounded','line_number':525,'multiline':False]
['text':' to nearest to a 64-bit signed integer','line_number':526,'multiline':False]
['text':' 2 <= q <= 34, -33 <= exp <= -1, 1 <= q + exp <= 19','line_number':527,'multiline':False]
['text':' 1 <= ind <= 33; ind is a synonym for 'x'','line_number':528,'multiline':False]
['text':' chop off ind digits from the lower part of C1','line_number':529,'multiline':False]
['text':' C1 = C1 + 1/2 * 10^ind where the result C1 fits in 127 bits','line_number':530,'multiline':False]
['text':' calculate C* and f*','line_number':540,'multiline':False]
['text':' C* is actually floor(C*) in this case','line_number':541,'multiline':False]
['text':' C* and f* need shifting and masking, as shown by','line_number':542,'multiline':False]
['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':543,'multiline':False]
['text':' 1 <= x <= 33','line_number':544,'multiline':False]
['text':' kx = 10^(-x) = bid_ten2mk128[ind - 1]','line_number':545,'multiline':False]
['text':' C* = (C1 + 1/2 * 10^x) * 10^(-x)','line_number':546,'multiline':False]
['text':' the approximation of 10^(-x) was rounded up to 118 bits','line_number':547,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':549,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':556,'multiline':False]
['text':' the top Ex bits of 10^(-x) are T* = bid_ten2mk128trunc[ind], e.g.','line_number':564,'multiline':False]
['text':' if x=1, T*=bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':565,'multiline':False]
['text':' if (0 < f* < 10^(-x)) then the result is a midpoint','line_number':566,'multiline':False]
['text':'   if floor(C*) is even then C* = floor(C*) - logical right','line_number':567,'multiline':False]
['text':'       shift; C* has p decimal digits, correct by Prop. 1)','line_number':568,'multiline':False]
['text':'   else if floor(C*) is odd C* = floor(C*)-1 (logical right','line_number':569,'multiline':False]
['text':'       shift; C* has p decimal digits, correct by Pr. 1)','line_number':570,'multiline':False]
['text':' else','line_number':571,'multiline':False]
['text':'   C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':572,'multiline':False]
['text':'       correct by Property 1)','line_number':573,'multiline':False]
['text':' n = C* * 10^(e+x)','line_number':574,'multiline':False]
['text':' shift right C* by Ex-128 = bid_shiftright128[ind]','line_number':576,'multiline':False]
['text':' 0 <= shift <= 102','line_number':577,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':578,'multiline':False]
['text':' redundant, it will be 0! Cstar.w[1] = (Cstar.w[1] >> shift);','line_number':581,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':582,'multiline':False]
['text':' 2 <= shift - 64 <= 38','line_number':583,'multiline':False]
['text':' determine inexactness of the rounding of C*','line_number':585,'multiline':False]
['text':' if (0 < f* - 1/2 < 10^(-x)) then','line_number':586,'multiline':False]
['text':'   the result is exact','line_number':587,'multiline':False]
['text':' else // if (f* - 1/2 > T*) then','line_number':588,'multiline':False]
['text':'   the result is inexact','line_number':589,'multiline':False]
['text':' f* > 1/2 and the result may be exact','line_number':594,'multiline':False]
['text':' f* - 1/2','line_number':595,'multiline':False]
['text':' set the inexact flag','line_number':599,'multiline':False]
['text':' else the result is exact','line_number':601,'multiline':False]
['text':' the result is inexact; f2* <= 1/2','line_number':602,'multiline':False]
['text':' set the inexact flag','line_number':603,'multiline':False]
['text':' if 3 <= ind <= 21','line_number':606,'multiline':False]
['text':' f2* > 1/2 and the result may be exact','line_number':611,'multiline':False]
['text':' Calculate f2* - 1/2','line_number':612,'multiline':False]
['text':' set the inexact flag','line_number':621,'multiline':False]
['text':' else the result is exact','line_number':623,'multiline':False]
['text':' the result is inexact; f2* <= 1/2','line_number':624,'multiline':False]
['text':' set the inexact flag','line_number':625,'multiline':False]
['text':' if 22 <= ind <= 33','line_number':628,'multiline':False]
['text':' f2* > 1/2 and the result may be exact','line_number':632,'multiline':False]
['text':' Calculate f2* - 1/2','line_number':633,'multiline':False]
['text':' set the inexact flag','line_number':639,'multiline':False]
['text':' else the result is exact','line_number':641,'multiline':False]
['text':' the result is inexact; f2* <= 1/2','line_number':642,'multiline':False]
['text':' set the inexact flag','line_number':643,'multiline':False]
['text':' if the result was a midpoint it was rounded away from zero, so','line_number':648,'multiline':False]
['text':' it will need a correction','line_number':649,'multiline':False]
['text':' check for midpoints','line_number':650,'multiline':False]
['text':' the result is a midpoint; round to nearest','line_number':656,'multiline':False]
['text':' Cstar.w[0] is odd; MP in [EVEN, ODD]','line_number':657,'multiline':False]
['text':' if floor(C*) is odd C = floor(C*) - 1; the result >= 1','line_number':658,'multiline':False]
['text':' Cstar.w[0] is now even','line_number':659,'multiline':False]
['text':' else MP in [ODD, EVEN]','line_number':660,'multiline':False]
['text':' 1 <= q <= 19','line_number':667,'multiline':False]
['text':' res = +/-C (exact)','line_number':668,'multiline':False]
['text':' if (exp>0) => 1 <= exp <= 18, 1 <= q < 18, 2 <= q + exp <= 19','line_number':673,'multiline':False]
['text':' res = +/-C * 10^exp (exact) where this fits in 64-bit integer','line_number':674,'multiline':False]
['text':'****************************************************************************
 *  BID128_to_int64_floor
 ***************************************************************************','line_number':686,'multiline':True]
['text':' unbiased exponent','line_number':696,'multiline':False]
['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':697,'multiline':False]
['text':' C* represents up to 34 decimal digits ~ 113 bits','line_number':702,'multiline':False]
['text':' unpack x','line_number':706,'multiline':False]
['text':' 0 for positive, MASK_SIGN for negative','line_number':707,'multiline':False]
['text':' biased and shifted left 49 bit positions','line_number':708,'multiline':False]
['text':' check for NaN or Infinity','line_number':712,'multiline':False]
['text':' x is special','line_number':714,'multiline':False]
['text':' x is NAN','line_number':715,'multiline':False]
['text':' x is SNAN','line_number':716,'multiline':False]
['text':' set invalid flag','line_number':717,'multiline':False]
['text':' return Integer Indefinite','line_number':719,'multiline':False]
['text':' x is QNaN','line_number':721,'multiline':False]
['text':' set invalid flag','line_number':722,'multiline':False]
['text':' return Integer Indefinite','line_number':724,'multiline':False]
['text':' x is not a NaN, so it must be infinity','line_number':728,'multiline':False]
['text':' x is +inf','line_number':729,'multiline':False]
['text':' set invalid flag','line_number':730,'multiline':False]
['text':' return Integer Indefinite','line_number':732,'multiline':False]
['text':' x is -inf','line_number':734,'multiline':False]
['text':' set invalid flag','line_number':735,'multiline':False]
['text':' return Integer Indefinite','line_number':737,'multiline':False]
['text':' check for non-canonical values (after the check for special values)','line_number':743,'multiline':False]
['text':' x is 0','line_number':751,'multiline':False]
['text':' x is not special and is not zero','line_number':754,'multiline':False]
['text':' q = nr. of decimal digits in x','line_number':756,'multiline':False]
['text':'  determine first the nr. of bits in x','line_number':757,'multiline':False]
['text':' x >= 2^53','line_number':759,'multiline':False]
['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':760,'multiline':False]
['text':' exact conversion','line_number':761,'multiline':False]
['text':' if x < 2^53','line_number':764,'multiline':False]
['text':' exact conversion','line_number':765,'multiline':False]
['text':' C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])','line_number':769,'multiline':False]
['text':' exact conversion','line_number':770,'multiline':False]
['text':' x >= 10^19 ~= 2^63.11... (cannot fit in BID_SINT64)','line_number':784,'multiline':False]
['text':' set invalid flag','line_number':785,'multiline':False]
['text':' return Integer Indefinite','line_number':787,'multiline':False]
['text':' x = c(0)c(1)...c(18).c(19)...c(q-1)','line_number':790,'multiline':False]
['text':' in this case 2^63.11... ~= 10^19 <= x < 10^20 ~= 2^66.43...','line_number':791,'multiline':False]
['text':' so x rounded to an integer may or may not fit in a signed 64-bit int','line_number':792,'multiline':False]
['text':' the cases that do not fit are identified here; the ones that fit','line_number':793,'multiline':False]
['text':' fall through and will be handled with other cases further,','line_number':794,'multiline':False]
['text':' under '1 <= q + exp <= 19'','line_number':795,'multiline':False]
['text':' if n < 0 and q + exp = 19','line_number':796,'multiline':False]
['text':' if n < -2^63 then n is too large','line_number':797,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) > 2^63','line_number':798,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 > 10*2^63, 1<=q<=34','line_number':799,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 > 0x50000000000000000, 1<=q<=34','line_number':800,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 => ','line_number':803,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':804,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':807,'multiline':False]
['text':' if 21 <= q <= 34','line_number':808,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':809,'multiline':False]
['text':' set invalid flag','line_number':812,'multiline':False]
['text':' return Integer Indefinite','line_number':814,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':818,'multiline':False]
['text':' to '1 <= q + exp <= 19'','line_number':819,'multiline':False]
['text':' if n > 0 and q + exp = 19','line_number':820,'multiline':False]
['text':' if n >= 2^63 then n is too large','line_number':821,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63','line_number':822,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 5*2^64, 1<=q<=34','line_number':823,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 0x50000000000000000, 1<=q<=34','line_number':824,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 =>','line_number':827,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':828,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':831,'multiline':False]
['text':' if 21 <= q <= 34','line_number':832,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':833,'multiline':False]
['text':' set invalid flag ','line_number':836,'multiline':False]
['text':' return Integer Indefinite ','line_number':838,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':842,'multiline':False]
['text':' to '1 <= q + exp <= 19' ','line_number':843,'multiline':False]
['text':' n is not too large to be converted to int64: -2^63-1 < n < 2^63','line_number':846,'multiline':False]
['text':' Note: some of the cases tested for above fall through to this point','line_number':847,'multiline':False]
['text':' Restore C1 which may have been modified above','line_number':848,'multiline':False]
['text':' n = +/-0.[0...0]c(0)c(1)...c(q-1)','line_number':851,'multiline':False]
['text':' return -1 or 0','line_number':852,'multiline':False]
['text':' if (1 <= q + exp <= 19, 1 <= q <= 34, -33 <= exp <= 18)','line_number':858,'multiline':False]
['text':' -2^63 <= x <= -1 or 1 <= x < 2^63 so x can be rounded','line_number':859,'multiline':False]
['text':' toward zero to a 64-bit signed integer','line_number':860,'multiline':False]
['text':' 2 <= q <= 34, -33 <= exp <= -1, 1 <= q + exp <= 19','line_number':861,'multiline':False]
['text':' 1 <= ind <= 33; ind is a synonym for 'x'','line_number':862,'multiline':False]
['text':' chop off ind digits from the lower part of C1','line_number':863,'multiline':False]
['text':' C1 fits in 127 bits','line_number':864,'multiline':False]
['text':' calculate C* and f*','line_number':865,'multiline':False]
['text':' C* is actually floor(C*) in this case','line_number':866,'multiline':False]
['text':' C* and f* need shifting and masking, as shown by','line_number':867,'multiline':False]
['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':868,'multiline':False]
['text':' 1 <= x <= 33','line_number':869,'multiline':False]
['text':' kx = 10^(-x) = bid_ten2mk128[ind - 1]','line_number':870,'multiline':False]
['text':' C* = C1 * 10^(-x)','line_number':871,'multiline':False]
['text':' the approximation of 10^(-x) was rounded up to 118 bits','line_number':872,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':874,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':881,'multiline':False]
['text':' the top Ex bits of 10^(-x) are T* = bid_ten2mk128trunc[ind], e.g.','line_number':889,'multiline':False]
['text':' if x=1, T*=bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':890,'multiline':False]
['text':' C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':891,'multiline':False]
['text':'     correct by Property 1)','line_number':892,'multiline':False]
['text':' n = C* * 10^(e+x)','line_number':893,'multiline':False]
['text':' shift right C* by Ex-128 = bid_shiftright128[ind]','line_number':895,'multiline':False]
['text':' 0 <= shift <= 102','line_number':896,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':897,'multiline':False]
['text':' redundant, it will be 0! Cstar.w[1] = (Cstar.w[1] >> shift);','line_number':900,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':901,'multiline':False]
['text':' 2 <= shift - 64 <= 38','line_number':902,'multiline':False]
['text':' if the result is negative and inexact, need to add 1 to it','line_number':904,'multiline':False]
['text':' determine inexactness of the rounding of C*','line_number':906,'multiline':False]
['text':' if (0 < f* < 10^(-x)) then','line_number':907,'multiline':False]
['text':'   the result is exact','line_number':908,'multiline':False]
['text':' else // if (f* > T*) then','line_number':909,'multiline':False]
['text':'   the result is inexact','line_number':910,'multiline':False]
['text':' positive and inexact','line_number':915,'multiline':False]
['text':' else the result is exact','line_number':920,'multiline':False]
['text':' if 3 <= ind <= 21','line_number':921,'multiline':False]
['text':' positive and inexact','line_number':925,'multiline':False]
['text':' else the result is exact','line_number':930,'multiline':False]
['text':' if 22 <= ind <= 33','line_number':931,'multiline':False]
['text':' positive and inexact','line_number':936,'multiline':False]
['text':' else the result is exact','line_number':941,'multiline':False]
['text':' 1 <= q <= 19','line_number':949,'multiline':False]
['text':' res = +/-C (exact)','line_number':950,'multiline':False]
['text':' if (exp>0) => 1 <= exp <= 18, 1 <= q < 18, 2 <= q + exp <= 19','line_number':955,'multiline':False]
['text':' res = +/-C * 10^exp (exact) where this fits in 64-bit integer','line_number':956,'multiline':False]
['text':'****************************************************************************
 *  BID128_to_int64_xfloor
 ***************************************************************************','line_number':968,'multiline':True]
['text':' unbiased exponent','line_number':978,'multiline':False]
['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':979,'multiline':False]
['text':' C* represents up to 34 decimal digits ~ 113 bits','line_number':984,'multiline':False]
['text':' unpack x','line_number':988,'multiline':False]
['text':' 0 for positive, MASK_SIGN for negative','line_number':989,'multiline':False]
['text':' biased and shifted left 49 bit positions','line_number':990,'multiline':False]
['text':' check for NaN or Infinity','line_number':994,'multiline':False]
['text':' x is special','line_number':996,'multiline':False]
['text':' x is NAN','line_number':997,'multiline':False]
['text':' x is SNAN','line_number':998,'multiline':False]
['text':' set invalid flag','line_number':999,'multiline':False]
['text':' return Integer Indefinite','line_number':1001,'multiline':False]
['text':' x is QNaN','line_number':1003,'multiline':False]
['text':' set invalid flag','line_number':1004,'multiline':False]
['text':' return Integer Indefinite','line_number':1006,'multiline':False]
['text':' x is not a NaN, so it must be infinity','line_number':1010,'multiline':False]
['text':' x is +inf','line_number':1011,'multiline':False]
['text':' set invalid flag','line_number':1012,'multiline':False]
['text':' return Integer Indefinite','line_number':1014,'multiline':False]
['text':' x is -inf','line_number':1016,'multiline':False]
['text':' set invalid flag','line_number':1017,'multiline':False]
['text':' return Integer Indefinite','line_number':1019,'multiline':False]
['text':' check for non-canonical values (after the check for special values)','line_number':1025,'multiline':False]
['text':' x is 0','line_number':1033,'multiline':False]
['text':' x is not special and is not zero','line_number':1036,'multiline':False]
['text':' q = nr. of decimal digits in x','line_number':1038,'multiline':False]
['text':'  determine first the nr. of bits in x','line_number':1039,'multiline':False]
['text':' x >= 2^53','line_number':1041,'multiline':False]
['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':1042,'multiline':False]
['text':' exact conversion','line_number':1043,'multiline':False]
['text':' if x < 2^53','line_number':1046,'multiline':False]
['text':' exact conversion','line_number':1047,'multiline':False]
['text':' C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])','line_number':1051,'multiline':False]
['text':' exact conversion','line_number':1052,'multiline':False]
['text':' x >= 10^19 ~= 2^63.11... (cannot fit in BID_SINT64)','line_number':1065,'multiline':False]
['text':' set invalid flag','line_number':1066,'multiline':False]
['text':' return Integer Indefinite','line_number':1068,'multiline':False]
['text':' x = c(0)c(1)...c(18).c(19)...c(q-1)','line_number':1071,'multiline':False]
['text':' in this case 2^63.11... ~= 10^19 <= x < 10^20 ~= 2^66.43...','line_number':1072,'multiline':False]
['text':' so x rounded to an integer may or may not fit in a signed 64-bit int','line_number':1073,'multiline':False]
['text':' the cases that do not fit are identified here; the ones that fit','line_number':1074,'multiline':False]
['text':' fall through and will be handled with other cases further,','line_number':1075,'multiline':False]
['text':' under '1 <= q + exp <= 19'','line_number':1076,'multiline':False]
['text':' if n < 0 and q + exp = 19','line_number':1077,'multiline':False]
['text':' if n < -2^63 then n is too large','line_number':1078,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) > 2^63','line_number':1079,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 > 10*2^63, 1<=q<=34','line_number':1080,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 > 0x50000000000000000, 1<=q<=34','line_number':1081,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 => ','line_number':1084,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':1085,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':1088,'multiline':False]
['text':' if 21 <= q <= 34','line_number':1089,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':1090,'multiline':False]
['text':' set invalid flag','line_number':1093,'multiline':False]
['text':' return Integer Indefinite','line_number':1095,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':1099,'multiline':False]
['text':' to '1 <= q + exp <= 19'','line_number':1100,'multiline':False]
['text':' if n > 0 and q + exp = 19','line_number':1101,'multiline':False]
['text':' if n >= 2^63 then n is too large','line_number':1102,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63','line_number':1103,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 5*2^64, 1<=q<=34','line_number':1104,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 0x50000000000000000, 1<=q<=34','line_number':1105,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 =>','line_number':1108,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':1109,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':1112,'multiline':False]
['text':' if 21 <= q <= 34','line_number':1113,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':1114,'multiline':False]
['text':' set invalid flag ','line_number':1117,'multiline':False]
['text':' return Integer Indefinite ','line_number':1119,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':1123,'multiline':False]
['text':' to '1 <= q + exp <= 19' ','line_number':1124,'multiline':False]
['text':' n is not too large to be converted to int64: -2^63-1 < n < 2^63','line_number':1127,'multiline':False]
['text':' Note: some of the cases tested for above fall through to this point','line_number':1128,'multiline':False]
['text':' Restore C1 which may have been modified above','line_number':1129,'multiline':False]
['text':' n = +/-0.[0...0]c(0)c(1)...c(q-1)','line_number':1132,'multiline':False]
['text':' set inexact flag','line_number':1133,'multiline':False]
['text':' return -1 or 0','line_number':1135,'multiline':False]
['text':' if (1 <= q + exp <= 19, 1 <= q <= 34, -33 <= exp <= 18)','line_number':1141,'multiline':False]
['text':' -2^63 <= x <= -1 or 1 <= x < 2^63 so x can be rounded','line_number':1142,'multiline':False]
['text':' toward zero to a 64-bit signed integer','line_number':1143,'multiline':False]
['text':' 2 <= q <= 34, -33 <= exp <= -1, 1 <= q + exp <= 19','line_number':1144,'multiline':False]
['text':' 1 <= ind <= 33; ind is a synonym for 'x'','line_number':1145,'multiline':False]
['text':' chop off ind digits from the lower part of C1','line_number':1146,'multiline':False]
['text':' C1 fits in 127 bits','line_number':1147,'multiline':False]
['text':' calculate C* and f*','line_number':1148,'multiline':False]
['text':' C* is actually floor(C*) in this case','line_number':1149,'multiline':False]
['text':' C* and f* need shifting and masking, as shown by','line_number':1150,'multiline':False]
['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':1151,'multiline':False]
['text':' 1 <= x <= 33','line_number':1152,'multiline':False]
['text':' kx = 10^(-x) = bid_ten2mk128[ind - 1]','line_number':1153,'multiline':False]
['text':' C* = C1 * 10^(-x)','line_number':1154,'multiline':False]
['text':' the approximation of 10^(-x) was rounded up to 118 bits','line_number':1155,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':1157,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':1164,'multiline':False]
['text':' the top Ex bits of 10^(-x) are T* = bid_ten2mk128trunc[ind], e.g.','line_number':1172,'multiline':False]
['text':' if x=1, T*=bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':1173,'multiline':False]
['text':' C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':1174,'multiline':False]
['text':'     correct by Property 1)','line_number':1175,'multiline':False]
['text':' n = C* * 10^(e+x)','line_number':1176,'multiline':False]
['text':' shift right C* by Ex-128 = bid_shiftright128[ind]','line_number':1178,'multiline':False]
['text':' 0 <= shift <= 102','line_number':1179,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':1180,'multiline':False]
['text':' redundant, it will be 0! Cstar.w[1] = (Cstar.w[1] >> shift);','line_number':1183,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':1184,'multiline':False]
['text':' 2 <= shift - 64 <= 38','line_number':1185,'multiline':False]
['text':' if the result is negative and inexact, need to add 1 to it','line_number':1187,'multiline':False]
['text':' determine inexactness of the rounding of C*','line_number':1189,'multiline':False]
['text':' if (0 < f* < 10^(-x)) then','line_number':1190,'multiline':False]
['text':'   the result is exact','line_number':1191,'multiline':False]
['text':' else // if (f* > T*) then','line_number':1192,'multiline':False]
['text':'   the result is inexact','line_number':1193,'multiline':False]
['text':' positive and inexact','line_number':1198,'multiline':False]
['text':' set the inexact flag','line_number':1203,'multiline':False]
['text':' else the result is exact','line_number':1205,'multiline':False]
['text':' if 3 <= ind <= 21','line_number':1206,'multiline':False]
['text':' positive and inexact','line_number':1210,'multiline':False]
['text':' set the inexact flag','line_number':1215,'multiline':False]
['text':' else the result is exact','line_number':1217,'multiline':False]
['text':' if 22 <= ind <= 33','line_number':1218,'multiline':False]
['text':' positive and inexact','line_number':1223,'multiline':False]
['text':' set the inexact flag','line_number':1228,'multiline':False]
['text':' else the result is exact','line_number':1230,'multiline':False]
['text':' 1 <= q <= 19','line_number':1238,'multiline':False]
['text':' res = +/-C (exact)','line_number':1239,'multiline':False]
['text':' if (exp>0) => 1 <= exp <= 18, 1 <= q < 18, 2 <= q + exp <= 19','line_number':1244,'multiline':False]
['text':' res = +/-C * 10^exp (exact) where this fits in 64-bit integer','line_number':1245,'multiline':False]
['text':'****************************************************************************
 *  BID128_to_int64_ceil
 ***************************************************************************','line_number':1257,'multiline':True]
['text':' unbiased exponent','line_number':1267,'multiline':False]
['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':1268,'multiline':False]
['text':' C* represents up to 34 decimal digits ~ 113 bits','line_number':1273,'multiline':False]
['text':' unpack x','line_number':1277,'multiline':False]
['text':' 0 for positive, MASK_SIGN for negative','line_number':1278,'multiline':False]
['text':' biased and shifted left 49 bit positions','line_number':1279,'multiline':False]
['text':' check for NaN or Infinity','line_number':1283,'multiline':False]
['text':' x is special','line_number':1285,'multiline':False]
['text':' x is NAN','line_number':1286,'multiline':False]
['text':' x is SNAN','line_number':1287,'multiline':False]
['text':' set invalid flag','line_number':1288,'multiline':False]
['text':' return Integer Indefinite','line_number':1290,'multiline':False]
['text':' x is QNaN','line_number':1292,'multiline':False]
['text':' set invalid flag','line_number':1293,'multiline':False]
['text':' return Integer Indefinite','line_number':1295,'multiline':False]
['text':' x is not a NaN, so it must be infinity','line_number':1299,'multiline':False]
['text':' x is +inf','line_number':1300,'multiline':False]
['text':' set invalid flag','line_number':1301,'multiline':False]
['text':' return Integer Indefinite','line_number':1303,'multiline':False]
['text':' x is -inf','line_number':1305,'multiline':False]
['text':' set invalid flag','line_number':1306,'multiline':False]
['text':' return Integer Indefinite','line_number':1308,'multiline':False]
['text':' check for non-canonical values (after the check for special values)','line_number':1314,'multiline':False]
['text':' x is 0','line_number':1322,'multiline':False]
['text':' x is not special and is not zero','line_number':1325,'multiline':False]
['text':' q = nr. of decimal digits in x','line_number':1327,'multiline':False]
['text':'  determine first the nr. of bits in x','line_number':1328,'multiline':False]
['text':' x >= 2^53','line_number':1330,'multiline':False]
['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':1331,'multiline':False]
['text':' exact conversion','line_number':1332,'multiline':False]
['text':' if x < 2^53','line_number':1335,'multiline':False]
['text':' exact conversion','line_number':1336,'multiline':False]
['text':' C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])','line_number':1340,'multiline':False]
['text':' exact conversion','line_number':1341,'multiline':False]
['text':' x >= 10^19 ~= 2^63.11... (cannot fit in BID_SINT64)','line_number':1354,'multiline':False]
['text':' set invalid flag','line_number':1355,'multiline':False]
['text':' return Integer Indefinite','line_number':1357,'multiline':False]
['text':' x = c(0)c(1)...c(18).c(19)...c(q-1)','line_number':1360,'multiline':False]
['text':' in this case 2^63.11... ~= 10^19 <= x < 10^20 ~= 2^66.43...','line_number':1361,'multiline':False]
['text':' so x rounded to an integer may or may not fit in a signed 64-bit int','line_number':1362,'multiline':False]
['text':' the cases that do not fit are identified here; the ones that fit','line_number':1363,'multiline':False]
['text':' fall through and will be handled with other cases further,','line_number':1364,'multiline':False]
['text':' under '1 <= q + exp <= 19'','line_number':1365,'multiline':False]
['text':' if n < 0 and q + exp = 19','line_number':1366,'multiline':False]
['text':' if n <= -2^63 - 1 then n is too large','line_number':1367,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63+1','line_number':1368,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 > 5*(2^64+2), 1<=q<=34','line_number':1369,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 > 0x5000000000000000a, 1<=q<=34','line_number':1370,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 => ','line_number':1373,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':1374,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':1377,'multiline':False]
['text':' if 21 <= q <= 34','line_number':1378,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':1379,'multiline':False]
['text':' set invalid flag','line_number':1382,'multiline':False]
['text':' return Integer Indefinite','line_number':1384,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':1388,'multiline':False]
['text':' to '1 <= q + exp <= 19'','line_number':1389,'multiline':False]
['text':' if n > 0 and q + exp = 19','line_number':1390,'multiline':False]
['text':' if n > 2^63 - 1 then n is too large','line_number':1391,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) > 2^63 - 1','line_number':1392,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 > 10*(2^63-1), 1<=q<=34','line_number':1393,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 > 0x4fffffffffffffff6, 1<=q<=34','line_number':1394,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 =>','line_number':1397,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':1398,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':1401,'multiline':False]
['text':' if 21 <= q <= 34','line_number':1402,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':1403,'multiline':False]
['text':' set invalid flag ','line_number':1406,'multiline':False]
['text':' return Integer Indefinite ','line_number':1408,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':1412,'multiline':False]
['text':' to '1 <= q + exp <= 19' ','line_number':1413,'multiline':False]
['text':' n is not too large to be converted to int64: -2^63-1 < n <= 2^63 - 1','line_number':1416,'multiline':False]
['text':' Note: some of the cases tested for above fall through to this point','line_number':1417,'multiline':False]
['text':' Restore C1 which may have been modified above','line_number':1418,'multiline':False]
['text':' n = +/-0.[0...0]c(0)c(1)...c(q-1)','line_number':1421,'multiline':False]
['text':' return 0 or 1','line_number':1422,'multiline':False]
['text':' if (1 <= q + exp <= 19, 1 <= q <= 34, -33 <= exp <= 18)','line_number':1428,'multiline':False]
['text':' -2^63-1 < x <= -1 or 1 <= x <= 2^63 - 1 so x can be rounded','line_number':1429,'multiline':False]
['text':' up to a 64-bit signed integer','line_number':1430,'multiline':False]
['text':' 2 <= q <= 34, -33 <= exp <= -1, 1 <= q + exp <= 19','line_number':1431,'multiline':False]
['text':' 1 <= ind <= 33; ind is a synonym for 'x'','line_number':1432,'multiline':False]
['text':' chop off ind digits from the lower part of C1','line_number':1433,'multiline':False]
['text':' C1 fits in 127 bits','line_number':1434,'multiline':False]
['text':' calculate C* and f*','line_number':1435,'multiline':False]
['text':' C* is actually floor(C*) in this case','line_number':1436,'multiline':False]
['text':' C* and f* need shifting and masking, as shown by','line_number':1437,'multiline':False]
['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':1438,'multiline':False]
['text':' 1 <= x <= 33','line_number':1439,'multiline':False]
['text':' kx = 10^(-x) = bid_ten2mk128[ind - 1]','line_number':1440,'multiline':False]
['text':' C* = C1 * 10^(-x)','line_number':1441,'multiline':False]
['text':' the approximation of 10^(-x) was rounded up to 118 bits','line_number':1442,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':1444,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':1451,'multiline':False]
['text':' the top Ex bits of 10^(-x) are T* = bid_ten2mk128trunc[ind], e.g.','line_number':1459,'multiline':False]
['text':' if x=1, T*=bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':1460,'multiline':False]
['text':' C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':1461,'multiline':False]
['text':'     correct by Property 1)','line_number':1462,'multiline':False]
['text':' n = C* * 10^(e+x)','line_number':1463,'multiline':False]
['text':' shift right C* by Ex-128 = bid_shiftright128[ind]','line_number':1465,'multiline':False]
['text':' 0 <= shift <= 102','line_number':1466,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':1467,'multiline':False]
['text':' redundant, it will be 0! Cstar.w[1] = (Cstar.w[1] >> shift);','line_number':1470,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':1471,'multiline':False]
['text':' 2 <= shift - 64 <= 38','line_number':1472,'multiline':False]
['text':' if the result is positive and inexact, need to add 1 to it','line_number':1474,'multiline':False]
['text':' determine inexactness of the rounding of C*','line_number':1476,'multiline':False]
['text':' if (0 < f* < 10^(-x)) then','line_number':1477,'multiline':False]
['text':'   the result is exact','line_number':1478,'multiline':False]
['text':' else // if (f* > T*) then','line_number':1479,'multiline':False]
['text':'   the result is inexact','line_number':1480,'multiline':False]
['text':' positive and inexact','line_number':1485,'multiline':False]
['text':' else the result is exact','line_number':1490,'multiline':False]
['text':' if 3 <= ind <= 21','line_number':1491,'multiline':False]
['text':' positive and inexact','line_number':1495,'multiline':False]
['text':' else the result is exact','line_number':1500,'multiline':False]
['text':' if 22 <= ind <= 33','line_number':1501,'multiline':False]
['text':' positive and inexact','line_number':1506,'multiline':False]
['text':' else the result is exact','line_number':1511,'multiline':False]
['text':' 1 <= q <= 19','line_number':1518,'multiline':False]
['text':' res = +/-C (exact)','line_number':1519,'multiline':False]
['text':' if (exp>0) => 1 <= exp <= 18, 1 <= q < 18, 2 <= q + exp <= 19','line_number':1524,'multiline':False]
['text':' res = +/-C * 10^exp (exact) where this fits in 64-bit integer','line_number':1525,'multiline':False]
['text':'****************************************************************************
 *  BID128_to_int64_xceil
 ***************************************************************************','line_number':1537,'multiline':True]
['text':' unbiased exponent','line_number':1547,'multiline':False]
['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':1548,'multiline':False]
['text':' C* represents up to 34 decimal digits ~ 113 bits','line_number':1553,'multiline':False]
['text':' unpack x','line_number':1557,'multiline':False]
['text':' 0 for positive, MASK_SIGN for negative','line_number':1558,'multiline':False]
['text':' biased and shifted left 49 bit positions','line_number':1559,'multiline':False]
['text':' check for NaN or Infinity','line_number':1563,'multiline':False]
['text':' x is special','line_number':1565,'multiline':False]
['text':' x is NAN','line_number':1566,'multiline':False]
['text':' x is SNAN','line_number':1567,'multiline':False]
['text':' set invalid flag','line_number':1568,'multiline':False]
['text':' return Integer Indefinite','line_number':1570,'multiline':False]
['text':' x is QNaN','line_number':1572,'multiline':False]
['text':' set invalid flag','line_number':1573,'multiline':False]
['text':' return Integer Indefinite','line_number':1575,'multiline':False]
['text':' x is not a NaN, so it must be infinity','line_number':1579,'multiline':False]
['text':' x is +inf','line_number':1580,'multiline':False]
['text':' set invalid flag','line_number':1581,'multiline':False]
['text':' return Integer Indefinite','line_number':1583,'multiline':False]
['text':' x is -inf','line_number':1585,'multiline':False]
['text':' set invalid flag','line_number':1586,'multiline':False]
['text':' return Integer Indefinite','line_number':1588,'multiline':False]
['text':' check for non-canonical values (after the check for special values)','line_number':1594,'multiline':False]
['text':' x is 0','line_number':1602,'multiline':False]
['text':' x is not special and is not zero','line_number':1605,'multiline':False]
['text':' q = nr. of decimal digits in x','line_number':1607,'multiline':False]
['text':'  determine first the nr. of bits in x','line_number':1608,'multiline':False]
['text':' x >= 2^53','line_number':1610,'multiline':False]
['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':1611,'multiline':False]
['text':' exact conversion','line_number':1612,'multiline':False]
['text':' if x < 2^53','line_number':1615,'multiline':False]
['text':' exact conversion','line_number':1616,'multiline':False]
['text':' C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])','line_number':1620,'multiline':False]
['text':' exact conversion','line_number':1621,'multiline':False]
['text':' x >= 10^19 ~= 2^63.11... (cannot fit in BID_SINT64)','line_number':1634,'multiline':False]
['text':' set invalid flag','line_number':1635,'multiline':False]
['text':' return Integer Indefinite','line_number':1637,'multiline':False]
['text':' x = c(0)c(1)...c(18).c(19)...c(q-1)','line_number':1640,'multiline':False]
['text':' in this case 2^63.11... ~= 10^19 <= x < 10^20 ~= 2^66.43...','line_number':1641,'multiline':False]
['text':' so x rounded to an integer may or may not fit in a signed 64-bit int','line_number':1642,'multiline':False]
['text':' the cases that do not fit are identified here; the ones that fit','line_number':1643,'multiline':False]
['text':' fall through and will be handled with other cases further,','line_number':1644,'multiline':False]
['text':' under '1 <= q + exp <= 19'','line_number':1645,'multiline':False]
['text':' if n < 0 and q + exp = 19','line_number':1646,'multiline':False]
['text':' if n <= -2^63 - 1 then n is too large','line_number':1647,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63+1','line_number':1648,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 > 5*(2^64+2), 1<=q<=34','line_number':1649,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 > 0x5000000000000000a, 1<=q<=34','line_number':1650,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 => ','line_number':1653,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':1654,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':1657,'multiline':False]
['text':' if 21 <= q <= 34','line_number':1658,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':1659,'multiline':False]
['text':' set invalid flag','line_number':1662,'multiline':False]
['text':' return Integer Indefinite','line_number':1664,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':1668,'multiline':False]
['text':' to '1 <= q + exp <= 19'','line_number':1669,'multiline':False]
['text':' if n > 0 and q + exp = 19','line_number':1670,'multiline':False]
['text':' if n > 2^63 - 1 then n is too large','line_number':1671,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) > 2^63 - 1','line_number':1672,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 > 10*(2^63-1), 1<=q<=34','line_number':1673,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 > 0x4fffffffffffffff6, 1<=q<=34','line_number':1674,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 =>','line_number':1677,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':1678,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':1681,'multiline':False]
['text':' if 21 <= q <= 34','line_number':1682,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':1683,'multiline':False]
['text':' set invalid flag ','line_number':1686,'multiline':False]
['text':' return Integer Indefinite ','line_number':1688,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':1692,'multiline':False]
['text':' to '1 <= q + exp <= 19' ','line_number':1693,'multiline':False]
['text':' n is not too large to be converted to int64: -2^63-1 < n <= 2^63 - 1','line_number':1696,'multiline':False]
['text':' Note: some of the cases tested for above fall through to this point','line_number':1697,'multiline':False]
['text':' Restore C1 which may have been modified above','line_number':1698,'multiline':False]
['text':' n = +/-0.[0...0]c(0)c(1)...c(q-1)','line_number':1701,'multiline':False]
['text':' set inexact flag','line_number':1702,'multiline':False]
['text':' return 0 or 1','line_number':1704,'multiline':False]
['text':' if (1 <= q + exp <= 19, 1 <= q <= 34, -33 <= exp <= 18)','line_number':1710,'multiline':False]
['text':' -2^63-1 < x <= -1 or 1 <= x <= 2^63 - 1 so x can be rounded','line_number':1711,'multiline':False]
['text':' up to a 64-bit signed integer','line_number':1712,'multiline':False]
['text':' 2 <= q <= 34, -33 <= exp <= -1, 1 <= q + exp <= 19','line_number':1713,'multiline':False]
['text':' 1 <= ind <= 33; ind is a synonym for 'x'','line_number':1714,'multiline':False]
['text':' chop off ind digits from the lower part of C1','line_number':1715,'multiline':False]
['text':' C1 fits in 127 bits','line_number':1716,'multiline':False]
['text':' calculate C* and f*','line_number':1717,'multiline':False]
['text':' C* is actually floor(C*) in this case','line_number':1718,'multiline':False]
['text':' C* and f* need shifting and masking, as shown by','line_number':1719,'multiline':False]
['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':1720,'multiline':False]
['text':' 1 <= x <= 33','line_number':1721,'multiline':False]
['text':' kx = 10^(-x) = bid_ten2mk128[ind - 1]','line_number':1722,'multiline':False]
['text':' C* = C1 * 10^(-x)','line_number':1723,'multiline':False]
['text':' the approximation of 10^(-x) was rounded up to 118 bits','line_number':1724,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':1726,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':1733,'multiline':False]
['text':' the top Ex bits of 10^(-x) are T* = bid_ten2mk128trunc[ind], e.g.','line_number':1741,'multiline':False]
['text':' if x=1, T*=bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':1742,'multiline':False]
['text':' C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':1743,'multiline':False]
['text':'     correct by Property 1)','line_number':1744,'multiline':False]
['text':' n = C* * 10^(e+x)','line_number':1745,'multiline':False]
['text':' shift right C* by Ex-128 = bid_shiftright128[ind]','line_number':1747,'multiline':False]
['text':' 0 <= shift <= 102','line_number':1748,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':1749,'multiline':False]
['text':' redundant, it will be 0! Cstar.w[1] = (Cstar.w[1] >> shift);','line_number':1752,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':1753,'multiline':False]
['text':' 2 <= shift - 64 <= 38','line_number':1754,'multiline':False]
['text':' if the result is positive and inexact, need to add 1 to it','line_number':1756,'multiline':False]
['text':' determine inexactness of the rounding of C*','line_number':1758,'multiline':False]
['text':' if (0 < f* < 10^(-x)) then','line_number':1759,'multiline':False]
['text':'   the result is exact','line_number':1760,'multiline':False]
['text':' else // if (f* > T*) then','line_number':1761,'multiline':False]
['text':'   the result is inexact','line_number':1762,'multiline':False]
['text':' positive and inexact','line_number':1767,'multiline':False]
['text':' set the inexact flag','line_number':1772,'multiline':False]
['text':' else the result is exact','line_number':1774,'multiline':False]
['text':' if 3 <= ind <= 21','line_number':1775,'multiline':False]
['text':' positive and inexact','line_number':1779,'multiline':False]
['text':' set the inexact flag','line_number':1784,'multiline':False]
['text':' else the result is exact','line_number':1786,'multiline':False]
['text':' if 22 <= ind <= 33','line_number':1787,'multiline':False]
['text':' positive and inexact','line_number':1792,'multiline':False]
['text':' set the inexact flag','line_number':1797,'multiline':False]
['text':' else the result is exact','line_number':1799,'multiline':False]
['text':' 1 <= q <= 19','line_number':1807,'multiline':False]
['text':' res = +/-C (exact)','line_number':1808,'multiline':False]
['text':' if (exp>0) => 1 <= exp <= 18, 1 <= q < 18, 2 <= q + exp <= 19','line_number':1813,'multiline':False]
['text':' res = +/-C * 10^exp (exact) where this fits in 64-bit integer','line_number':1814,'multiline':False]
['text':'****************************************************************************
 *  BID128_to_int64_int
 ***************************************************************************','line_number':1826,'multiline':True]
['text':' unbiased exponent','line_number':1836,'multiline':False]
['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':1837,'multiline':False]
['text':' C* represents up to 34 decimal digits ~ 113 bits','line_number':1842,'multiline':False]
['text':' unpack x','line_number':1845,'multiline':False]
['text':' 0 for positive, MASK_SIGN for negative','line_number':1846,'multiline':False]
['text':' biased and shifted left 49 bit positions','line_number':1847,'multiline':False]
['text':' check for NaN or Infinity','line_number':1851,'multiline':False]
['text':' x is special','line_number':1853,'multiline':False]
['text':' x is NAN','line_number':1854,'multiline':False]
['text':' x is SNAN','line_number':1855,'multiline':False]
['text':' set invalid flag','line_number':1856,'multiline':False]
['text':' return Integer Indefinite','line_number':1858,'multiline':False]
['text':' x is QNaN','line_number':1860,'multiline':False]
['text':' set invalid flag','line_number':1861,'multiline':False]
['text':' return Integer Indefinite','line_number':1863,'multiline':False]
['text':' x is not a NaN, so it must be infinity','line_number':1867,'multiline':False]
['text':' x is +inf','line_number':1868,'multiline':False]
['text':' set invalid flag','line_number':1869,'multiline':False]
['text':' return Integer Indefinite','line_number':1871,'multiline':False]
['text':' x is -inf','line_number':1873,'multiline':False]
['text':' set invalid flag','line_number':1874,'multiline':False]
['text':' return Integer Indefinite','line_number':1876,'multiline':False]
['text':' check for non-canonical values (after the check for special values)','line_number':1882,'multiline':False]
['text':' x is 0','line_number':1890,'multiline':False]
['text':' x is not special and is not zero','line_number':1893,'multiline':False]
['text':' q = nr. of decimal digits in x','line_number':1895,'multiline':False]
['text':'  determine first the nr. of bits in x','line_number':1896,'multiline':False]
['text':' x >= 2^53','line_number':1898,'multiline':False]
['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':1899,'multiline':False]
['text':' exact conversion','line_number':1900,'multiline':False]
['text':' if x < 2^53','line_number':1903,'multiline':False]
['text':' exact conversion','line_number':1904,'multiline':False]
['text':' C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])','line_number':1908,'multiline':False]
['text':' exact conversion','line_number':1909,'multiline':False]
['text':' x >= 10^19 ~= 2^63.11... (cannot fit in BID_SINT64)','line_number':1922,'multiline':False]
['text':' set invalid flag','line_number':1923,'multiline':False]
['text':' return Integer Indefinite','line_number':1925,'multiline':False]
['text':' x = c(0)c(1)...c(18).c(19)...c(q-1)','line_number':1928,'multiline':False]
['text':' in this case 2^63.11... ~= 10^19 <= x < 10^20 ~= 2^66.43...','line_number':1929,'multiline':False]
['text':' so x rounded to an integer may or may not fit in a signed 64-bit int','line_number':1930,'multiline':False]
['text':' the cases that do not fit are identified here; the ones that fit','line_number':1931,'multiline':False]
['text':' fall through and will be handled with other cases further,','line_number':1932,'multiline':False]
['text':' under '1 <= q + exp <= 19'','line_number':1933,'multiline':False]
['text':' if n < 0 and q + exp = 19','line_number':1934,'multiline':False]
['text':' if n <= -2^63 - 1 then n is too large','line_number':1935,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63+1','line_number':1936,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 >= 5*(2^64+2), 1<=q<=34','line_number':1937,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 >= 0x5000000000000000a, 1<=q<=34','line_number':1938,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 => ','line_number':1941,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':1942,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':1945,'multiline':False]
['text':' if 21 <= q <= 34','line_number':1946,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':1947,'multiline':False]
['text':' set invalid flag','line_number':1950,'multiline':False]
['text':' return Integer Indefinite','line_number':1952,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':1956,'multiline':False]
['text':' to '1 <= q + exp <= 19'','line_number':1957,'multiline':False]
['text':' if n > 0 and q + exp = 19','line_number':1958,'multiline':False]
['text':' if n >= 2^63 then n is too large','line_number':1959,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63','line_number':1960,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 5*2^64, 1<=q<=34','line_number':1961,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 0x50000000000000000, 1<=q<=34','line_number':1962,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 =>','line_number':1965,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':1966,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':1969,'multiline':False]
['text':' if 21 <= q <= 34','line_number':1970,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':1971,'multiline':False]
['text':' set invalid flag ','line_number':1974,'multiline':False]
['text':' return Integer Indefinite ','line_number':1976,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':1980,'multiline':False]
['text':' to '1 <= q + exp <= 19' ','line_number':1981,'multiline':False]
['text':' n is not too large to be converted to int64: -2^63-1 < n < 2^63','line_number':1984,'multiline':False]
['text':' Note: some of the cases tested for above fall through to this point','line_number':1985,'multiline':False]
['text':' Restore C1 which may have been modified above','line_number':1986,'multiline':False]
['text':' n = +/-0.[0...0]c(0)c(1)...c(q-1)','line_number':1989,'multiline':False]
['text':' return 0','line_number':1990,'multiline':False]
['text':' if (1 <= q + exp <= 19, 1 <= q <= 34, -33 <= exp <= 18)','line_number':1993,'multiline':False]
['text':' -2^63-1 < x <= -1 or 1 <= x < 2^63 so x can be rounded','line_number':1994,'multiline':False]
['text':' toward zero to a 64-bit signed integer','line_number':1995,'multiline':False]
['text':' 2 <= q <= 34, -33 <= exp <= -1, 1 <= q + exp <= 19','line_number':1996,'multiline':False]
['text':' 1 <= ind <= 33; ind is a synonym for 'x'','line_number':1997,'multiline':False]
['text':' chop off ind digits from the lower part of C1','line_number':1998,'multiline':False]
['text':' C1 fits in 127 bits','line_number':1999,'multiline':False]
['text':' calculate C* and f*','line_number':2000,'multiline':False]
['text':' C* is actually floor(C*) in this case','line_number':2001,'multiline':False]
['text':' C* and f* need shifting and masking, as shown by','line_number':2002,'multiline':False]
['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':2003,'multiline':False]
['text':' 1 <= x <= 33','line_number':2004,'multiline':False]
['text':' kx = 10^(-x) = bid_ten2mk128[ind - 1]','line_number':2005,'multiline':False]
['text':' C* = C1 * 10^(-x)','line_number':2006,'multiline':False]
['text':' the approximation of 10^(-x) was rounded up to 118 bits','line_number':2007,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':2009,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':2012,'multiline':False]
['text':' the top Ex bits of 10^(-x) are T* = bid_ten2mk128trunc[ind], e.g.','line_number':2016,'multiline':False]
['text':' if x=1, T*=bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':2017,'multiline':False]
['text':' C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':2018,'multiline':False]
['text':'     correct by Property 1)','line_number':2019,'multiline':False]
['text':' n = C* * 10^(e+x)','line_number':2020,'multiline':False]
['text':' shift right C* by Ex-128 = bid_shiftright128[ind]','line_number':2022,'multiline':False]
['text':' 0 <= shift <= 102','line_number':2023,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':2024,'multiline':False]
['text':' redundant, it will be 0! Cstar.w[1] = (Cstar.w[1] >> shift);','line_number':2027,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':2028,'multiline':False]
['text':' 2 <= shift - 64 <= 38','line_number':2029,'multiline':False]
['text':' 1 <= q <= 19','line_number':2036,'multiline':False]
['text':' res = +/-C (exact)','line_number':2037,'multiline':False]
['text':' if (exp>0) => 1 <= exp <= 18, 1 <= q < 18, 2 <= q + exp <= 19','line_number':2042,'multiline':False]
['text':' res = +/-C * 10^exp (exact) where this fits in 64-bit integer','line_number':2043,'multiline':False]
['text':'****************************************************************************
 *  BID128_to_xint64_xint
 ***************************************************************************','line_number':2055,'multiline':True]
['text':' unbiased exponent','line_number':2065,'multiline':False]
['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':2066,'multiline':False]
['text':' C* represents up to 34 decimal digits ~ 113 bits','line_number':2071,'multiline':False]
['text':' unpack x','line_number':2075,'multiline':False]
['text':' 0 for positive, MASK_SIGN for negative','line_number':2076,'multiline':False]
['text':' biased and shifted left 49 bit positions','line_number':2077,'multiline':False]
['text':' check for NaN or Infinity','line_number':2081,'multiline':False]
['text':' x is special','line_number':2083,'multiline':False]
['text':' x is NAN','line_number':2084,'multiline':False]
['text':' x is SNAN','line_number':2085,'multiline':False]
['text':' set invalid flag','line_number':2086,'multiline':False]
['text':' return Integer Indefinite','line_number':2088,'multiline':False]
['text':' x is QNaN','line_number':2090,'multiline':False]
['text':' set invalid flag','line_number':2091,'multiline':False]
['text':' return Integer Indefinite','line_number':2093,'multiline':False]
['text':' x is not a NaN, so it must be infinity','line_number':2097,'multiline':False]
['text':' x is +inf','line_number':2098,'multiline':False]
['text':' set invalid flag','line_number':2099,'multiline':False]
['text':' return Integer Indefinite','line_number':2101,'multiline':False]
['text':' x is -inf','line_number':2103,'multiline':False]
['text':' set invalid flag','line_number':2104,'multiline':False]
['text':' return Integer Indefinite','line_number':2106,'multiline':False]
['text':' check for non-canonical values (after the check for special values)','line_number':2112,'multiline':False]
['text':' x is 0','line_number':2120,'multiline':False]
['text':' x is not special and is not zero','line_number':2123,'multiline':False]
['text':' q = nr. of decimal digits in x','line_number':2125,'multiline':False]
['text':'  determine first the nr. of bits in x','line_number':2126,'multiline':False]
['text':' x >= 2^53','line_number':2128,'multiline':False]
['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':2129,'multiline':False]
['text':' exact conversion','line_number':2130,'multiline':False]
['text':' if x < 2^53','line_number':2133,'multiline':False]
['text':' exact conversion','line_number':2134,'multiline':False]
['text':' C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])','line_number':2138,'multiline':False]
['text':' exact conversion','line_number':2139,'multiline':False]
['text':' x >= 10^19 ~= 2^63.11... (cannot fit in BID_SINT64)','line_number':2152,'multiline':False]
['text':' set invalid flag','line_number':2153,'multiline':False]
['text':' return Integer Indefinite','line_number':2155,'multiline':False]
['text':' x = c(0)c(1)...c(18).c(19)...c(q-1)','line_number':2158,'multiline':False]
['text':' in this case 2^63.11... ~= 10^19 <= x < 10^20 ~= 2^66.43...','line_number':2159,'multiline':False]
['text':' so x rounded to an integer may or may not fit in a signed 64-bit int','line_number':2160,'multiline':False]
['text':' the cases that do not fit are identified here; the ones that fit','line_number':2161,'multiline':False]
['text':' fall through and will be handled with other cases further,','line_number':2162,'multiline':False]
['text':' under '1 <= q + exp <= 19'','line_number':2163,'multiline':False]
['text':' if n < 0 and q + exp = 19','line_number':2164,'multiline':False]
['text':' if n <= -2^63 - 1 then n is too large','line_number':2165,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63+1','line_number':2166,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 >= 5*(2^64+2), 1<=q<=34','line_number':2167,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 >= 0x5000000000000000a, 1<=q<=34','line_number':2168,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 => ','line_number':2171,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':2172,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':2175,'multiline':False]
['text':' if 21 <= q <= 34','line_number':2176,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':2177,'multiline':False]
['text':' set invalid flag','line_number':2180,'multiline':False]
['text':' return Integer Indefinite','line_number':2182,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':2186,'multiline':False]
['text':' to '1 <= q + exp <= 19'','line_number':2187,'multiline':False]
['text':' if n > 0 and q + exp = 19','line_number':2188,'multiline':False]
['text':' if n >= 2^63 then n is too large','line_number':2189,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63','line_number':2190,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 5*2^64, 1<=q<=34','line_number':2191,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 0x50000000000000000, 1<=q<=34','line_number':2192,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 =>','line_number':2195,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':2196,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':2199,'multiline':False]
['text':' if 21 <= q <= 34','line_number':2200,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':2201,'multiline':False]
['text':' set invalid flag ','line_number':2204,'multiline':False]
['text':' return Integer Indefinite ','line_number':2206,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':2210,'multiline':False]
['text':' to '1 <= q + exp <= 19' ','line_number':2211,'multiline':False]
['text':' n is not too large to be converted to int64: -2^63-1 < n < 2^63','line_number':2214,'multiline':False]
['text':' Note: some of the cases tested for above fall through to this point','line_number':2215,'multiline':False]
['text':' Restore C1 which may have been modified above','line_number':2216,'multiline':False]
['text':' n = +/-0.[0...0]c(0)c(1)...c(q-1)','line_number':2219,'multiline':False]
['text':' set inexact flag','line_number':2220,'multiline':False]
['text':' return 0','line_number':2222,'multiline':False]
['text':' if (1 <= q + exp <= 19, 1 <= q <= 34, -33 <= exp <= 18)','line_number':2225,'multiline':False]
['text':' -2^63-1 < x <= -1 or 1 <= x < 2^63 so x can be rounded','line_number':2226,'multiline':False]
['text':' toward zero to a 64-bit signed integer','line_number':2227,'multiline':False]
['text':' 2 <= q <= 34, -33 <= exp <= -1, 1 <= q + exp <= 19','line_number':2228,'multiline':False]
['text':' 1 <= ind <= 33; ind is a synonym for 'x'','line_number':2229,'multiline':False]
['text':' chop off ind digits from the lower part of C1','line_number':2230,'multiline':False]
['text':' C1 fits in 127 bits','line_number':2231,'multiline':False]
['text':' calculate C* and f*','line_number':2232,'multiline':False]
['text':' C* is actually floor(C*) in this case','line_number':2233,'multiline':False]
['text':' C* and f* need shifting and masking, as shown by','line_number':2234,'multiline':False]
['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':2235,'multiline':False]
['text':' 1 <= x <= 33','line_number':2236,'multiline':False]
['text':' kx = 10^(-x) = bid_ten2mk128[ind - 1]','line_number':2237,'multiline':False]
['text':' C* = C1 * 10^(-x)','line_number':2238,'multiline':False]
['text':' the approximation of 10^(-x) was rounded up to 118 bits','line_number':2239,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':2241,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':2248,'multiline':False]
['text':' the top Ex bits of 10^(-x) are T* = bid_ten2mk128trunc[ind], e.g.','line_number':2256,'multiline':False]
['text':' if x=1, T*=bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':2257,'multiline':False]
['text':' C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':2258,'multiline':False]
['text':'     correct by Property 1)','line_number':2259,'multiline':False]
['text':' n = C* * 10^(e+x)','line_number':2260,'multiline':False]
['text':' shift right C* by Ex-128 = bid_shiftright128[ind]','line_number':2262,'multiline':False]
['text':' 0 <= shift <= 102','line_number':2263,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':2264,'multiline':False]
['text':' redundant, it will be 0! Cstar.w[1] = (Cstar.w[1] >> shift);','line_number':2267,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':2268,'multiline':False]
['text':' 2 <= shift - 64 <= 38','line_number':2269,'multiline':False]
['text':' determine inexactness of the rounding of C*','line_number':2271,'multiline':False]
['text':' if (0 < f* < 10^(-x)) then','line_number':2272,'multiline':False]
['text':'   the result is exact','line_number':2273,'multiline':False]
['text':' else // if (f* > T*) then','line_number':2274,'multiline':False]
['text':'   the result is inexact','line_number':2275,'multiline':False]
['text':' set the inexact flag','line_number':2280,'multiline':False]
['text':' else the result is exact','line_number':2282,'multiline':False]
['text':' if 3 <= ind <= 21','line_number':2283,'multiline':False]
['text':' set the inexact flag','line_number':2287,'multiline':False]
['text':' if 22 <= ind <= 33','line_number':2290,'multiline':False]
['text':' set the inexact flag','line_number':2295,'multiline':False]
['text':' 1 <= q <= 19','line_number':2305,'multiline':False]
['text':' res = +/-C (exact)','line_number':2306,'multiline':False]
['text':' if (exp>0) => 1 <= exp <= 18, 1 <= q < 18, 2 <= q + exp <= 19','line_number':2311,'multiline':False]
['text':' res = +/-C * 10^exp (exact) where this fits in 64-bit integer','line_number':2312,'multiline':False]
['text':'****************************************************************************
 *  BID128_to_int64_rninta
 ***************************************************************************','line_number':2324,'multiline':True]
['text':' unbiased exponent','line_number':2334,'multiline':False]
['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':2335,'multiline':False]
['text':' C* represents up to 34 decimal digits ~ 113 bits','line_number':2341,'multiline':False]
['text':' unpack x','line_number':2344,'multiline':False]
['text':' 0 for positive, MASK_SIGN for negative','line_number':2345,'multiline':False]
['text':' biased and shifted left 49 bit positions','line_number':2346,'multiline':False]
['text':' check for NaN or Infinity','line_number':2350,'multiline':False]
['text':' x is special','line_number':2352,'multiline':False]
['text':' x is NAN','line_number':2353,'multiline':False]
['text':' x is SNAN','line_number':2354,'multiline':False]
['text':' set invalid flag','line_number':2355,'multiline':False]
['text':' return Integer Indefinite','line_number':2357,'multiline':False]
['text':' x is QNaN','line_number':2359,'multiline':False]
['text':' set invalid flag','line_number':2360,'multiline':False]
['text':' return Integer Indefinite','line_number':2362,'multiline':False]
['text':' x is not a NaN, so it must be infinity','line_number':2366,'multiline':False]
['text':' x is +inf','line_number':2367,'multiline':False]
['text':' set invalid flag','line_number':2368,'multiline':False]
['text':' return Integer Indefinite','line_number':2370,'multiline':False]
['text':' x is -inf','line_number':2372,'multiline':False]
['text':' set invalid flag','line_number':2373,'multiline':False]
['text':' return Integer Indefinite','line_number':2375,'multiline':False]
['text':' check for non-canonical values (after the check for special values)','line_number':2381,'multiline':False]
['text':' x is 0','line_number':2389,'multiline':False]
['text':' x is not special and is not zero','line_number':2392,'multiline':False]
['text':' q = nr. of decimal digits in x','line_number':2394,'multiline':False]
['text':'  determine first the nr. of bits in x','line_number':2395,'multiline':False]
['text':' x >= 2^53','line_number':2397,'multiline':False]
['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':2398,'multiline':False]
['text':' exact conversion','line_number':2399,'multiline':False]
['text':' if x < 2^53','line_number':2402,'multiline':False]
['text':' exact conversion','line_number':2403,'multiline':False]
['text':' C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])','line_number':2407,'multiline':False]
['text':' exact conversion','line_number':2408,'multiline':False]
['text':' x >= 10^19 ~= 2^63.11... (cannot fit in BID_SINT64)','line_number':2421,'multiline':False]
['text':' set invalid flag','line_number':2422,'multiline':False]
['text':' return Integer Indefinite','line_number':2424,'multiline':False]
['text':' x = c(0)c(1)...c(18).c(19)...c(q-1)','line_number':2427,'multiline':False]
['text':' in this case 2^63.11... ~= 10^19 <= x < 10^20 ~= 2^66.43...','line_number':2428,'multiline':False]
['text':' so x rounded to an integer may or may not fit in a signed 64-bit int','line_number':2429,'multiline':False]
['text':' the cases that do not fit are identified here; the ones that fit','line_number':2430,'multiline':False]
['text':' fall through and will be handled with other cases further,','line_number':2431,'multiline':False]
['text':' under '1 <= q + exp <= 19'','line_number':2432,'multiline':False]
['text':' if n < 0 and q + exp = 19','line_number':2433,'multiline':False]
['text':' if n <= -2^63 - 1/2 then n is too large','line_number':2434,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63+1/2','line_number':2435,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 >= 5*(2^64+1), 1<=q<=34','line_number':2436,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 >= 0x50000000000000005, 1<=q<=34','line_number':2437,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 => ','line_number':2440,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':2441,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':2444,'multiline':False]
['text':' if 21 <= q <= 34','line_number':2445,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':2446,'multiline':False]
['text':' set invalid flag','line_number':2449,'multiline':False]
['text':' return Integer Indefinite','line_number':2451,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':2455,'multiline':False]
['text':' to '1 <= q + exp <= 19'','line_number':2456,'multiline':False]
['text':' if n > 0 and q + exp = 19','line_number':2457,'multiline':False]
['text':' if n >= 2^63 - 1/2 then n is too large','line_number':2458,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63-1/2','line_number':2459,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 5*(2^64-1), 1<=q<=34','line_number':2460,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 0x4fffffffffffffffb, 1<=q<=34','line_number':2461,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 =>','line_number':2464,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':2465,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':2468,'multiline':False]
['text':' if 21 <= q <= 34','line_number':2469,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':2470,'multiline':False]
['text':' set invalid flag ','line_number':2473,'multiline':False]
['text':' return Integer Indefinite ','line_number':2475,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':2479,'multiline':False]
['text':' to '1 <= q + exp <= 19' ','line_number':2480,'multiline':False]
['text':' n is not too large to be converted to int64: -2^63-1/2 <= n < 2^63-1/2','line_number':2483,'multiline':False]
['text':' Note: some of the cases tested for above fall through to this point','line_number':2484,'multiline':False]
['text':' Restore C1 which may have been modified above','line_number':2485,'multiline':False]
['text':' n = +/-0.0...c(0)c(1)...c(q-1)','line_number':2488,'multiline':False]
['text':' return 0','line_number':2489,'multiline':False]
['text':' n = +/-0.c(0)c(1)...c(q-1)','line_number':2492,'multiline':False]
['text':' if 0.c(0)c(1)...c(q-1) < 0.5 <=> c(0)c(1)...c(q-1) < 5 * 10^(q-1)','line_number':2493,'multiline':False]
['text':'   res = 0','line_number':2494,'multiline':False]
['text':' else','line_number':2495,'multiline':False]
['text':'   res = +/-1','line_number':2496,'multiline':False]
['text':' 0 <= ind <= 18','line_number':2498,'multiline':False]
['text':' return 0','line_number':2500,'multiline':False]
['text':' n < 0','line_number':2501,'multiline':False]
['text':' return -1','line_number':2502,'multiline':False]
['text':' n > 0','line_number':2503,'multiline':False]
['text':' return +1','line_number':2504,'multiline':False]
['text':' 19 <= ind <= 33','line_number':2506,'multiline':False]
['text':' return 0','line_number':2510,'multiline':False]
['text':' n < 0','line_number':2511,'multiline':False]
['text':' return -1','line_number':2512,'multiline':False]
['text':' n > 0','line_number':2513,'multiline':False]
['text':' return +1','line_number':2514,'multiline':False]
['text':' if (1 <= q + exp <= 19, 1 <= q <= 34, -33 <= exp <= 18)','line_number':2517,'multiline':False]
['text':' -2^63-1/2 <= x <= -1 or 1 <= x < 2^63-1/2 so x can be rounded','line_number':2518,'multiline':False]
['text':' to nearest to a 64-bit signed integer','line_number':2519,'multiline':False]
['text':' 2 <= q <= 34, -33 <= exp <= -1, 1 <= q + exp <= 19','line_number':2520,'multiline':False]
['text':' 1 <= ind <= 33; ind is a synonym for 'x'','line_number':2521,'multiline':False]
['text':' chop off ind digits from the lower part of C1','line_number':2522,'multiline':False]
['text':' C1 = C1 + 1/2 * 10^ind where the result C1 fits in 127 bits','line_number':2523,'multiline':False]
['text':' calculate C* and f*','line_number':2533,'multiline':False]
['text':' C* is actually floor(C*) in this case','line_number':2534,'multiline':False]
['text':' C* and f* need shifting and masking, as shown by','line_number':2535,'multiline':False]
['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':2536,'multiline':False]
['text':' 1 <= x <= 33','line_number':2537,'multiline':False]
['text':' kx = 10^(-x) = bid_ten2mk128[ind - 1]','line_number':2538,'multiline':False]
['text':' C* = (C1 + 1/2 * 10^x) * 10^(-x)','line_number':2539,'multiline':False]
['text':' the approximation of 10^(-x) was rounded up to 118 bits','line_number':2540,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':2542,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':2545,'multiline':False]
['text':' the top Ex bits of 10^(-x) are T* = bid_ten2mk128trunc[ind], e.g.','line_number':2549,'multiline':False]
['text':' if x=1, T*=bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':2550,'multiline':False]
['text':' if (0 < f* < 10^(-x)) then the result is a midpoint','line_number':2551,'multiline':False]
['text':'   if floor(C*) is even then C* = floor(C*) - logical right','line_number':2552,'multiline':False]
['text':'       shift; C* has p decimal digits, correct by Prop. 1)','line_number':2553,'multiline':False]
['text':'   else if floor(C*) is odd C* = floor(C*)-1 (logical right','line_number':2554,'multiline':False]
['text':'       shift; C* has p decimal digits, correct by Pr. 1)','line_number':2555,'multiline':False]
['text':' else','line_number':2556,'multiline':False]
['text':'   C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':2557,'multiline':False]
['text':'       correct by Property 1)','line_number':2558,'multiline':False]
['text':' n = C* * 10^(e+x)','line_number':2559,'multiline':False]
['text':' shift right C* by Ex-128 = bid_shiftright128[ind]','line_number':2561,'multiline':False]
['text':' 0 <= shift <= 102','line_number':2562,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':2563,'multiline':False]
['text':' redundant, it will be 0! Cstar.w[1] = (Cstar.w[1] >> shift);','line_number':2566,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':2567,'multiline':False]
['text':' 2 <= shift - 64 <= 38','line_number':2568,'multiline':False]
['text':' if the result was a midpoint it was rounded away from zero','line_number':2571,'multiline':False]
['text':' 1 <= q <= 19','line_number':2577,'multiline':False]
['text':' res = +/-C (exact)','line_number':2578,'multiline':False]
['text':' if (exp>0) => 1 <= exp <= 18, 1 <= q < 18, 2 <= q + exp <= 19','line_number':2583,'multiline':False]
['text':' res = +/-C * 10^exp (exact) where this fits in 64-bit integer','line_number':2584,'multiline':False]
['text':'****************************************************************************
 *  BID128_to_int64_xrninta
 ***************************************************************************','line_number':2596,'multiline':True]
['text':' unbiased exponent','line_number':2606,'multiline':False]
['text':' Note: C1.w[1], C1.w[0] represent x_signif_hi, x_signif_lo (all are BID_UINT64)','line_number':2607,'multiline':False]
['text':' C* represents up to 34 decimal digits ~ 113 bits','line_number':2613,'multiline':False]
['text':' unpack x','line_number':2617,'multiline':False]
['text':' 0 for positive, MASK_SIGN for negative','line_number':2618,'multiline':False]
['text':' biased and shifted left 49 bit positions','line_number':2619,'multiline':False]
['text':' check for NaN or Infinity','line_number':2623,'multiline':False]
['text':' x is special','line_number':2625,'multiline':False]
['text':' x is NAN','line_number':2626,'multiline':False]
['text':' x is SNAN','line_number':2627,'multiline':False]
['text':' set invalid flag','line_number':2628,'multiline':False]
['text':' return Integer Indefinite','line_number':2630,'multiline':False]
['text':' x is QNaN','line_number':2632,'multiline':False]
['text':' set invalid flag','line_number':2633,'multiline':False]
['text':' return Integer Indefinite','line_number':2635,'multiline':False]
['text':' x is not a NaN, so it must be infinity','line_number':2639,'multiline':False]
['text':' x is +inf','line_number':2640,'multiline':False]
['text':' set invalid flag','line_number':2641,'multiline':False]
['text':' return Integer Indefinite','line_number':2643,'multiline':False]
['text':' x is -inf','line_number':2645,'multiline':False]
['text':' set invalid flag','line_number':2646,'multiline':False]
['text':' return Integer Indefinite','line_number':2648,'multiline':False]
['text':' check for non-canonical values (after the check for special values)','line_number':2654,'multiline':False]
['text':' x is 0','line_number':2662,'multiline':False]
['text':' x is not special and is not zero','line_number':2665,'multiline':False]
['text':' q = nr. of decimal digits in x','line_number':2667,'multiline':False]
['text':'  determine first the nr. of bits in x','line_number':2668,'multiline':False]
['text':' x >= 2^53','line_number':2670,'multiline':False]
['text':' split the 64-bit value in two 32-bit halves to avoid rounding errors','line_number':2671,'multiline':False]
['text':' exact conversion','line_number':2672,'multiline':False]
['text':' if x < 2^53','line_number':2675,'multiline':False]
['text':' exact conversion','line_number':2676,'multiline':False]
['text':' C1.w[1] != 0 => nr. bits = 64 + nr_bits (C1.w[1])','line_number':2680,'multiline':False]
['text':' exact conversion','line_number':2681,'multiline':False]
['text':' x >= 10^19 ~= 2^63.11... (cannot fit in BID_SINT64)','line_number':2694,'multiline':False]
['text':' set invalid flag','line_number':2695,'multiline':False]
['text':' return Integer Indefinite','line_number':2697,'multiline':False]
['text':' x = c(0)c(1)...c(18).c(19)...c(q-1)','line_number':2700,'multiline':False]
['text':' in this case 2^63.11... ~= 10^19 <= x < 10^20 ~= 2^66.43...','line_number':2701,'multiline':False]
['text':' so x rounded to an integer may or may not fit in a signed 64-bit int','line_number':2702,'multiline':False]
['text':' the cases that do not fit are identified here; the ones that fit','line_number':2703,'multiline':False]
['text':' fall through and will be handled with other cases further,','line_number':2704,'multiline':False]
['text':' under '1 <= q + exp <= 19'','line_number':2705,'multiline':False]
['text':' if n < 0 and q + exp = 19','line_number':2706,'multiline':False]
['text':' if n <= -2^63 - 1/2 then n is too large','line_number':2707,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63+1/2','line_number':2708,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 >= 5*(2^64+1), 1<=q<=34','line_number':2709,'multiline':False]
['text':' <=> 0.c(0)c(1)...c(q-1) * 10^20 >= 0x50000000000000005, 1<=q<=34','line_number':2710,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 => ','line_number':2713,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':2714,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':2717,'multiline':False]
['text':' if 21 <= q <= 34','line_number':2718,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':2719,'multiline':False]
['text':' set invalid flag','line_number':2722,'multiline':False]
['text':' return Integer Indefinite','line_number':2724,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':2728,'multiline':False]
['text':' to '1 <= q + exp <= 19'','line_number':2729,'multiline':False]
['text':' if n > 0 and q + exp = 19','line_number':2730,'multiline':False]
['text':' if n >= 2^63 - 1/2 then n is too large','line_number':2731,'multiline':False]
['text':' too large if c(0)c(1)...c(18).c(19)...c(q-1) >= 2^63-1/2','line_number':2732,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 5*(2^64-1), 1<=q<=34','line_number':2733,'multiline':False]
['text':' <=> if 0.c(0)c(1)...c(q-1) * 10^20 >= 0x4fffffffffffffffb, 1<=q<=34','line_number':2734,'multiline':False]
['text':' 1 <= q <= 19 => 1 <= 20-q <= 19 =>','line_number':2737,'multiline':False]
['text':' 10^(20-q) is 64-bit, and so is C1','line_number':2738,'multiline':False]
['text':' C1 * 10^0 = C1','line_number':2741,'multiline':False]
['text':' if 21 <= q <= 34','line_number':2742,'multiline':False]
['text':' max 47-bit x 67-bit','line_number':2743,'multiline':False]
['text':' set invalid flag ','line_number':2746,'multiline':False]
['text':' return Integer Indefinite ','line_number':2748,'multiline':False]
['text':' else cases that can be rounded to a 64-bit int fall through','line_number':2752,'multiline':False]
['text':' to '1 <= q + exp <= 19' ','line_number':2753,'multiline':False]
['text':' n is not too large to be converted to int64: -2^63-1/2 <= n < 2^63-1/2','line_number':2756,'multiline':False]
['text':' Note: some of the cases tested for above fall through to this point','line_number':2757,'multiline':False]
['text':' Restore C1 which may have been modified above','line_number':2758,'multiline':False]
['text':' n = +/-0.0...c(0)c(1)...c(q-1)','line_number':2761,'multiline':False]
['text':' set inexact flag','line_number':2762,'multiline':False]
['text':' return 0','line_number':2764,'multiline':False]
['text':' n = +/-0.c(0)c(1)...c(q-1)','line_number':2767,'multiline':False]
['text':' if 0.c(0)c(1)...c(q-1) < 0.5 <=> c(0)c(1)...c(q-1) < 5 * 10^(q-1)','line_number':2768,'multiline':False]
['text':'   res = 0','line_number':2769,'multiline':False]
['text':' else','line_number':2770,'multiline':False]
['text':'   res = +/-1','line_number':2771,'multiline':False]
['text':' 0 <= ind <= 18','line_number':2773,'multiline':False]
['text':' return 0','line_number':2775,'multiline':False]
['text':' n < 0','line_number':2776,'multiline':False]
['text':' return -1','line_number':2777,'multiline':False]
['text':' n > 0','line_number':2778,'multiline':False]
['text':' return +1','line_number':2779,'multiline':False]
['text':' 19 <= ind <= 33','line_number':2781,'multiline':False]
['text':' return 0','line_number':2785,'multiline':False]
['text':' n < 0','line_number':2786,'multiline':False]
['text':' return -1','line_number':2787,'multiline':False]
['text':' n > 0','line_number':2788,'multiline':False]
['text':' return +1','line_number':2789,'multiline':False]
['text':' set inexact flag','line_number':2792,'multiline':False]
['text':' if (1 <= q + exp <= 19, 1 <= q <= 34, -33 <= exp <= 18)','line_number':2794,'multiline':False]
['text':' -2^63-1/2 <= x <= -1 or 1 <= x < 2^63-1/2 so x can be rounded','line_number':2795,'multiline':False]
['text':' to nearest to a 64-bit signed integer','line_number':2796,'multiline':False]
['text':' 2 <= q <= 34, -33 <= exp <= -1, 1 <= q + exp <= 19','line_number':2797,'multiline':False]
['text':' 1 <= ind <= 33; ind is a synonym for 'x'','line_number':2798,'multiline':False]
['text':' chop off ind digits from the lower part of C1','line_number':2799,'multiline':False]
['text':' C1 = C1 + 1/2 * 10^ind where the result C1 fits in 127 bits','line_number':2800,'multiline':False]
['text':' calculate C* and f*','line_number':2810,'multiline':False]
['text':' C* is actually floor(C*) in this case','line_number':2811,'multiline':False]
['text':' C* and f* need shifting and masking, as shown by','line_number':2812,'multiline':False]
['text':' bid_shiftright128[] and bid_maskhigh128[]','line_number':2813,'multiline':False]
['text':' 1 <= x <= 33','line_number':2814,'multiline':False]
['text':' kx = 10^(-x) = bid_ten2mk128[ind - 1]','line_number':2815,'multiline':False]
['text':' C* = (C1 + 1/2 * 10^x) * 10^(-x)','line_number':2816,'multiline':False]
['text':' the approximation of 10^(-x) was rounded up to 118 bits','line_number':2817,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':2819,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':2826,'multiline':False]
['text':' the top Ex bits of 10^(-x) are T* = bid_ten2mk128trunc[ind], e.g.','line_number':2834,'multiline':False]
['text':' if x=1, T*=bid_ten2mk128trunc[0]=0x19999999999999999999999999999999','line_number':2835,'multiline':False]
['text':' if (0 < f* < 10^(-x)) then the result is a midpoint','line_number':2836,'multiline':False]
['text':'   if floor(C*) is even then C* = floor(C*) - logical right','line_number':2837,'multiline':False]
['text':'       shift; C* has p decimal digits, correct by Prop. 1)','line_number':2838,'multiline':False]
['text':'   else if floor(C*) is odd C* = floor(C*)-1 (logical right','line_number':2839,'multiline':False]
['text':'       shift; C* has p decimal digits, correct by Pr. 1)','line_number':2840,'multiline':False]
['text':' else','line_number':2841,'multiline':False]
['text':'   C* = floor(C*) (logical right shift; C has p decimal digits,','line_number':2842,'multiline':False]
['text':'       correct by Property 1)','line_number':2843,'multiline':False]
['text':' n = C* * 10^(e+x)','line_number':2844,'multiline':False]
['text':' shift right C* by Ex-128 = bid_shiftright128[ind]','line_number':2846,'multiline':False]
['text':' 0 <= shift <= 102','line_number':2847,'multiline':False]
['text':' 0 <= ind - 1 <= 21','line_number':2848,'multiline':False]
['text':' redundant, it will be 0! Cstar.w[1] = (Cstar.w[1] >> shift);','line_number':2851,'multiline':False]
['text':' 22 <= ind - 1 <= 33','line_number':2852,'multiline':False]
['text':' 2 <= shift - 64 <= 38','line_number':2853,'multiline':False]
['text':' determine inexactness of the rounding of C*','line_number':2855,'multiline':False]
['text':' if (0 < f* - 1/2 < 10^(-x)) then','line_number':2856,'multiline':False]
['text':'   the result is exact','line_number':2857,'multiline':False]
['text':' else // if (f* - 1/2 > T*) then','line_number':2858,'multiline':False]
['text':'   the result is inexact','line_number':2859,'multiline':False]
['text':' f* > 1/2 and the result may be exact','line_number':2864,'multiline':False]
['text':' f* - 1/2','line_number':2865,'multiline':False]
['text':' set the inexact flag','line_number':2869,'multiline':False]
['text':' else the result is exact','line_number':2871,'multiline':False]
['text':' the result is inexact; f2* <= 1/2','line_number':2872,'multiline':False]
['text':' set the inexact flag','line_number':2873,'multiline':False]
['text':' if 3 <= ind <= 21','line_number':2876,'multiline':False]
['text':' f2* > 1/2 and the result may be exact','line_number':2881,'multiline':False]
['text':' Calculate f2* - 1/2','line_number':2882,'multiline':False]
['text':' set the inexact flag','line_number':2891,'multiline':False]
['text':' else the result is exact','line_number':2893,'multiline':False]
['text':' the result is inexact; f2* <= 1/2','line_number':2894,'multiline':False]
['text':' set the inexact flag','line_number':2895,'multiline':False]
['text':' if 22 <= ind <= 33','line_number':2898,'multiline':False]
['text':' f2* > 1/2 and the result may be exact','line_number':2902,'multiline':False]
['text':' Calculate f2* - 1/2','line_number':2903,'multiline':False]
['text':' set the inexact flag','line_number':2909,'multiline':False]
['text':' else the result is exact','line_number':2911,'multiline':False]
['text':' the result is inexact; f2* <= 1/2','line_number':2912,'multiline':False]
['text':' set the inexact flag','line_number':2913,'multiline':False]
['text':' if the result was a midpoint it was rounded away from zero','line_number':2918,'multiline':False]
['text':' 1 <= q <= 19','line_number':2924,'multiline':False]
['text':' res = +/-C (exact)','line_number':2925,'multiline':False]
['text':' if (exp>0) => 1 <= exp <= 18, 1 <= q < 18, 2 <= q + exp <= 19','line_number':2930,'multiline':False]
['text':' res = +/-C * 10^exp (exact) where this fits in 64-bit integer','line_number':2931,'multiline':False]
