['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':' Check (num_vertices_ > 0) to avoid invalid reference to vertices[0].','line_number':52,'multiline':False]
['text':' mongodb: void* casts to silence a -Wclass-memaccess warning.','line_number':54,'multiline':False]
['text':' All vertices must be unit length.','line_number':74,'multiline':False]
['text':' Adjacent vertices must not be identical or antipodal.','line_number':86,'multiline':False]
['text':' mongodb: void* casts to silence a -Wclass-memaccess warning.','line_number':105,'multiline':False]
['text':' The centroid (multiplied by length) is a vector toward the midpoint','line_number':125,'multiline':False]
['text':' of the edge, whose length is twice the sin of half the angle between','line_number':126,'multiline':False]
['text':' the two vertices.  Defining theta to be this angle, we have:','line_number':127,'multiline':False]
['text':' Length == 2*cos(theta)','line_number':128,'multiline':False]
['text':' Length == 2*sin(theta)','line_number':129,'multiline':False]
['text':' Otherwise edge is undefined, and result is NaN.','line_number':132,'multiline':False]
['text':' Length == 2*sin(theta)','line_number':133,'multiline':False]
['text':' We intentionally let the (fraction >= 1) case fall through, since','line_number':140,'multiline':False]
['text':' we need to handle it in the loop below in any case because of','line_number':141,'multiline':False]
['text':' possible roundoff errors.','line_number':142,'multiline':False]
['text':' This interpolates with respect to arc length rather than','line_number':155,'multiline':False]
['text':' straight-line distance, and produces a unit-length result.','line_number':156,'multiline':False]
['text':' It is possible that (result == vertex(i)) due to rounding errors.','line_number':159,'multiline':False]
['text':' The ratio can be greater than 1.0 due to rounding errors or because the','line_number':187,'multiline':False]
['text':' point is not exactly on the polyline.','line_number':188,'multiline':False]
['text':' If there is only one vertex, it is always closest to any given point.','line_number':196,'multiline':False]
['text':' Initial value larger than any possible distance on the unit sphere.','line_number':201,'multiline':False]
['text':' Find the line segment in the polyline that is closest to the point given.','line_number':205,'multiline':False]
['text':' Compute the point on the segment found that is closest to the point given.','line_number':216,'multiline':False]
['text':' If the closest point C is an interior vertex of the polyline, let B and D','line_number':233,'multiline':False]
['text':' be the previous and next vertices.  The given point P is on the right of','line_number':234,'multiline':False]
['text':' the polyline (locally) if B, P, D are ordered CCW around vertex C.','line_number':235,'multiline':False]
['text':' Polyline vertices are not on the RHS.','line_number':239,'multiline':False]
['text':' Otherwise, the closest point C is incident to exactly one polyline edge.','line_number':244,'multiline':False]
['text':' We test the point P against that edge.','line_number':245,'multiline':False]
['text':' TODO(user) look into S2EdgeIndex to make this near linear in performance.','line_number':261,'multiline':False]
['text':' We only need to check whether the cell contains vertex 0 for correctness,','line_number':293,'multiline':False]
['text':' but these tests are cheap compared to edge crossings so we might as well','line_number':294,'multiline':False]
['text':' check all the vertices.','line_number':295,'multiline':False]
['text':' There is a proper crossing, or two vertices were the same.','line_number':308,'multiline':False]
['text':' sufficient','line_number':317,'multiline':False]
['text':' Given a polyline, a tolerance distance, and a start index, this function','line_number':345,'multiline':False]
['text':' returns the maximal end index such that the line segment between these two','line_number':346,'multiline':False]
['text':' vertices passes within "tolerance" of all interior vertices, in order.','line_number':347,'multiline':False]
['text':' The basic idea is to keep track of the "pie wedge" of angles from the','line_number':353,'multiline':False]
['text':' starting vertex such that a ray from the starting vertex at that angle','line_number':354,'multiline':False]
['text':' will pass through the discs of radius "tolerance" centered around all','line_number':355,'multiline':False]
['text':' vertices processed so far.','line_number':356,'multiline':False]
['text':' First we define a "coordinate frame" for the tangent and normal spaces','line_number':358,'multiline':False]
['text':' at the starting vertex.  Essentially this means picking three','line_number':359,'multiline':False]
['text':' orthonormal vectors X,Y,Z such that X and Y span the tangent plane at','line_number':360,'multiline':False]
['text':' the starting vertex, and Z is "up".  We use the coordinate frame to','line_number':361,'multiline':False]
['text':' define a mapping from 3D direction vectors to a one-dimensional "ray','line_number':362,'multiline':False]
['text':' angle" in the range (-Pi, Pi].  The angle of a direction vector is','line_number':363,'multiline':False]
['text':' computed by transforming it into the X,Y,Z basis, and then calculating','line_number':364,'multiline':False]
['text':' atan2(y,x).  This mapping allows us to represent a wedge of angles as a','line_number':365,'multiline':False]
['text':' 1D interval.  Since the interval wraps around, we represent it as an','line_number':366,'multiline':False]
['text':' S1Interval, i.e. an interval on the unit circle.','line_number':367,'multiline':False]
['text':' As we go along, we keep track of the current wedge of angles and the','line_number':372,'multiline':False]
['text':' distance to the last vertex (which must be non-decreasing).','line_number':373,'multiline':False]
['text':' We don't allow simplification to create edges longer than 90 degrees,','line_number':381,'multiline':False]
['text':' to avoid numeric instability as lengths approach 180 degrees.  (We do','line_number':382,'multiline':False]
['text':' need to allow for original edges longer than 90 degrees, though.)','line_number':383,'multiline':False]
['text':' Vertices must be in increasing order along the ray, except for the','line_number':386,'multiline':False]
['text':' initial disc around the origin.','line_number':387,'multiline':False]
['text':' Points that are within the tolerance distance of the origin do not','line_number':391,'multiline':False]
['text':' constrain the ray direction, so we can ignore them.','line_number':392,'multiline':False]
['text':' If the current wedge of angles does not contain the angle to this','line_number':395,'multiline':False]
['text':' vertex, then stop right now.  Note that the wedge of possible ray','line_number':396,'multiline':False]
['text':' angles is not necessarily empty yet, but we can't continue unless we','line_number':397,'multiline':False]
['text':' are willing to backtrack to the last vertex that was contained within','line_number':398,'multiline':False]
['text':' the wedge (since we don't create new vertices).  This would be more','line_number':399,'multiline':False]
['text':' complicated and also make the worst-case running time more than linear.','line_number':400,'multiline':False]
['text':' To determine how this vertex constrains the possible ray angles,','line_number':405,'multiline':False]
['text':' consider the triangle ABC where A is the origin, B is the candidate','line_number':406,'multiline':False]
['text':' vertex, and C is one of the two tangent points between A and the','line_number':407,'multiline':False]
['text':' spherical cap of radius "tolerance" centered at B.  Then from the','line_number':408,'multiline':False]
['text':' spherical law of sines, sin(a)/sin(A) = sin(c)/sin(C), where "a" and','line_number':409,'multiline':False]
['text':' "c" are the lengths of the edges opposite A and C.  In our case C is a','line_number':410,'multiline':False]
['text':' 90 degree angle, therefore A = asin(sin(a) / sin(c)).  Angle A is the','line_number':411,'multiline':False]
['text':' half-angle of the allowable wedge.','line_number':412,'multiline':False]
['text':' We break out of the loop when we reach a vertex index that can't be','line_number':419,'multiline':False]
['text':' included in the line segment, so back up by one vertex.','line_number':420,'multiline':False]
['text':' Don't create duplicate adjacent vertices.','line_number':434,'multiline':False]
['text':' Return the first i > "index" such that the ith vertex of "pline" is not at','line_number':453,'multiline':False]
['text':' the same point as the "index"th vertex.  Returns pline.num_vertices() if','line_number':454,'multiline':False]
['text':' there is no such value of i.','line_number':455,'multiline':False]
['text':' This struct represents a search state in the NearlyCoversPolyline algorithm','line_number':464,'multiline':False]
['text':' below.  See the description of the algorithm for details.','line_number':465,'multiline':False]
['text':' namespace','line_number':474,'multiline':False]
['text':' This operator is needed for storing SearchStates in a set.  The ordering','line_number':479,'multiline':False]
['text':' chosen has no special meaning.','line_number':480,'multiline':False]
['text':' namespace std','line_number':489,'multiline':False]
['text':' NOTE: This algorithm is described assuming that adjacent vertices in a','line_number':493,'multiline':False]
['text':' polyline are never at the same point.  That is, the ith and i+1th vertices','line_number':494,'multiline':False]
['text':' of a polyline are never at the same point in space.  The implementation','line_number':495,'multiline':False]
['text':' does not make this assumption.','line_number':496,'multiline':False]
['text':' DEFINITIONS:','line_number':498,'multiline':False]
['text':'   - edge "i" of a polyline is the edge from the ith to i+1th vertex.','line_number':499,'multiline':False]
['text':'   - covered_j is a polyline consisting of edges 0 through j of "covered."','line_number':500,'multiline':False]
['text':'   - this_i is a polyline consisting of edges 0 through i of this polyline.','line_number':501,'multiline':False]
['text':'','line_number':502,'multiline':False]
['text':' A search state is represented as an (int, int, bool) tuple, (i, j,','line_number':503,'multiline':False]
['text':' i_in_progress).  Using the "drive a car" analogy from the header comment, a','line_number':504,'multiline':False]
['text':' search state signifies that you can drive one car along "covered" from its','line_number':505,'multiline':False]
['text':' first vertex through a point on its jth edge, and another car along this','line_number':506,'multiline':False]
['text':' polyline from some point on or before its ith edge to a to a point on its','line_number':507,'multiline':False]
['text':' ith edge, such that no car ever goes backward, and the cars are always','line_number':508,'multiline':False]
['text':' within "max_error" of each other.  If i_in_progress is true, it means that','line_number':509,'multiline':False]
['text':' you can definitely drive along "covered" through the jth vertex (beginning','line_number':510,'multiline':False]
['text':' of the jth edge). Otherwise, you can definitely drive along "covered"','line_number':511,'multiline':False]
['text':' through the point on the jth edge of "covered" closest to the ith vertex of','line_number':512,'multiline':False]
['text':' this polyline.','line_number':513,'multiline':False]
['text':'','line_number':514,'multiline':False]
['text':' The algorithm begins by finding all edges of this polyline that are within','line_number':515,'multiline':False]
['text':' "max_error" of the first vertex of "covered," and adding search states','line_number':516,'multiline':False]
['text':' representing all of these possible starting states to the stack of','line_number':517,'multiline':False]
['text':' "pending" states.','line_number':518,'multiline':False]
['text':'','line_number':519,'multiline':False]
['text':' The algorithm proceeds by popping the next pending state,','line_number':520,'multiline':False]
['text':' (i,j,i_in_progress), off of the stack.  First it checks to see if that','line_number':521,'multiline':False]
['text':' state represents finding a valid covering of "covered" and returns true if','line_number':522,'multiline':False]
['text':' so.  Next, if the state represents reaching the end of this polyline','line_number':523,'multiline':False]
['text':' without finding a successful covering, the algorithm moves on to the next','line_number':524,'multiline':False]
['text':' state in the stack.  Otherwise, if state (i+1,j,false) is valid, it is','line_number':525,'multiline':False]
['text':' added to the stack of pending states.  Same for state (i,j+1,true).','line_number':526,'multiline':False]
['text':'','line_number':527,'multiline':False]
['text':' We need the stack because when "i" and "j" can both be incremented,','line_number':528,'multiline':False]
['text':' sometimes only one choice leads to a solution.  We use a set to keep track','line_number':529,'multiline':False]
['text':' of visited states to avoid duplicating work.  With the set, the worst-case','line_number':530,'multiline':False]
['text':' number of states examined is O(n+m) where n = this->num_vertices() and m =','line_number':531,'multiline':False]
['text':' covered.num_vertices().  Without it, the amount of work could be as high as','line_number':532,'multiline':False]
['text':' O((n*m)^2).  Using set, the running time is O((n*m) log (n*m)).','line_number':533,'multiline':False]
['text':'','line_number':534,'multiline':False]
['text':' TODO(user): Benchmark this, and see if the set is worth it.','line_number':535,'multiline':False]
['text':' Find all possible starting states.','line_number':539,'multiline':False]
