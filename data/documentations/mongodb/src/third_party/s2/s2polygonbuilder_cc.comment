['text':' Copyright 2006 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':' If xor_edges is true, we look for an existing edge in the opposite','line_number':76,'multiline':False]
['text':' direction.  We either delete that edge or insert a new one.','line_number':77,'multiline':False]
['text':' Vertex indices need to be in the range [0, 2*num_vertices()-1].','line_number':96,'multiline':False]
['text':' Note that there may be more than one copy of an edge if we are not XORing','line_number':108,'multiline':False]
['text':' them, so a VertexSet is a multiset.','line_number':109,'multiline':False]
['text':' For orthonormal matrices, Inverse() == Transpose().','line_number':130,'multiline':False]
['text':' We start at the given edge and assemble a loop taking left turns','line_number':172,'multiline':False]
['text':' whenever possible.  We stop the loop as soon as we encounter any','line_number':173,'multiline':False]
['text':' vertex that we have seen before *except* for the first vertex (v0).','line_number':174,'multiline':False]
['text':' This ensures that only CCW loops are constructed when possible.','line_number':175,'multiline':False]
['text':' The path so far.','line_number':177,'multiline':False]
['text':' Maps a vertex to its index in "path".','line_number':178,'multiline':False]
['text':' Note that "v0" and "v1" become invalid if "path" is modified.','line_number':183,'multiline':False]
['text':' We prefer the leftmost outgoing edge, ignoring any reverse edges.','line_number':192,'multiline':False]
['text':' We've hit a dead end.  Remove this edge and backtrack.','line_number':199,'multiline':False]
['text':' This is the first time we've visited this vertex.','line_number':205,'multiline':False]
['text':' We've completed a loop.  Throw away any initial vertices that','line_number':208,'multiline':False]
['text':' are not part of the loop.','line_number':209,'multiline':False]
['text':' In the case of undirected edges, we may have assembled a clockwise','line_number':212,'multiline':False]
['text':' loop while trying to assemble a CCW loop.  To fix this, we assemble','line_number':213,'multiline':False]
['text':' a new loop starting with an arbitrary edge in the reverse direction.','line_number':214,'multiline':False]
['text':' This is guaranteed to assemble a loop that is interior to the previous','line_number':215,'multiline':False]
['text':' one and will therefore eventually terminate.','line_number':216,'multiline':False]
['text':' We've constructed a loop that crosses itself, which can only','line_number':220,'multiline':False]
['text':' happen if there is bad input data.  Throw away the whole loop.','line_number':221,'multiline':False]
['text':' XXX for debugging','line_number':229,'multiline':False]
['text':' A PointIndex is a cheap spatial index to help us find mergeable','line_number':239,'multiline':False]
['text':' vertices.  Given a set of points, it can efficiently find all of the','line_number':240,'multiline':False]
['text':' points within a given search radius of an arbitrary query location.','line_number':241,'multiline':False]
['text':' It is essentially just a hash map from cell ids at a given fixed level to','line_number':242,'multiline':False]
['text':' the set of points contained by that cell id.','line_number':243,'multiline':False]
['text':'','line_number':244,'multiline':False]
['text':' This class is not suitable for general use because it only supports','line_number':245,'multiline':False]
['text':' fixed-radius queries and has various special-purpose operations to avoid','line_number':246,'multiline':False]
['text':' the need for additional data structures.','line_number':247,'multiline':False]
['text':' Allocated here for efficiency.','line_number':256,'multiline':False]
['text':' We compute an S2CellId level such that the vertex neighbors at that','line_number':262,'multiline':False]
['text':' level of any point A are a covering for spherical cap (i.e. "disc")','line_number':263,'multiline':False]
['text':' of the given search radius centered at A.  This requires that the','line_number':264,'multiline':False]
['text':' minimum cell width at that level must be twice the search radius.','line_number':265,'multiline':False]
['text':' We insert a sentinel so that we don't need to test for map_.end().','line_number':268,'multiline':False]
['text':' Return the set the points whose distance to "axis" is less than','line_number':293,'multiline':False]
['text':' vertex_radius_.','line_number':294,'multiline':False]
['text':' Return a point whose distance from the edge (v0,v1) is less than','line_number':308,'multiline':False]
['text':' vertex_radius_, and which is not equal to v0 or v1.  The current','line_number':309,'multiline':False]
['text':' implementation returns the closest such point.','line_number':310,'multiline':False]
['text':'','line_number':311,'multiline':False]
['text':' Strategy: we compute a very cheap covering by approximating the edge as','line_number':312,'multiline':False]
['text':' two spherical caps, one around each endpoint, and then computing a','line_number':313,'multiline':False]
['text':' 4-cell covering of each one.  We could improve the quality of the','line_number':314,'multiline':False]
['text':' covering by using some intermediate points along the edge as well.','line_number':315,'multiline':False]
['text':' Sort the cell ids so that we can skip duplicates in the loop below.','line_number':323,'multiline':False]
['text':' Skip duplicates.','line_number':328,'multiline':False]
['text':' The overall strategy is to start from each vertex and grow a maximal','line_number':351,'multiline':False]
['text':' cluster of mergeable vertices.  In graph theoretic terms, we find the','line_number':352,'multiline':False]
['text':' connected components of the undirected graph whose edges connect pairs of','line_number':353,'multiline':False]
['text':' vertices that are separated by at most vertex_merge_radius().','line_number':354,'multiline':False]
['text':'','line_number':355,'multiline':False]
['text':' We then choose a single representative vertex for each cluster, and','line_number':356,'multiline':False]
['text':' update "merge_map" appropriately.  We choose an arbitrary existing','line_number':357,'multiline':False]
['text':' vertex rather than computing the centroid of all the vertices to avoid','line_number':358,'multiline':False]
['text':' creating new vertex pairs that need to be merged.  (We guarantee that all','line_number':359,'multiline':False]
['text':' vertex pairs are separated by at least the merge radius in the output.)','line_number':360,'multiline':False]
['text':' First, we build the set of all the distinct vertices in the input.','line_number':362,'multiline':False]
['text':' We need to include the source and destination of every edge.','line_number':363,'multiline':False]
['text':' Build a spatial index containing all the distinct vertices.','line_number':372,'multiline':False]
['text':' Next, we loop through all the vertices and attempt to grow a maximial','line_number':378,'multiline':False]
['text':' mergeable group starting from each vertex.','line_number':379,'multiline':False]
['text':' Skip any vertices that have already been merged with another vertex.','line_number':383,'multiline':False]
['text':' Grow a maximal mergeable component starting from "vstart", the','line_number':386,'multiline':False]
['text':' canonical representative of the mergeable group.','line_number':387,'multiline':False]
['text':' Do this before entering the loop below.','line_number':391,'multiline':False]
['text':' Erase from the index any vertices that will be merged.  This','line_number':395,'multiline':False]
['text':' ensures that we won't try to merge the same vertex twice.','line_number':396,'multiline':False]
['text':' We need to copy the set of edges affected by the move, since','line_number':409,'multiline':False]
['text':' edges_ could be reallocated when we start modifying it.','line_number':410,'multiline':False]
['text':' We only need to modify one copy of each undirected edge.','line_number':419,'multiline':False]
['text':' Now erase all the old edges, and add all the new edges.  This will','line_number':427,'multiline':False]
['text':' automatically take care of any XORing that needs to be done, because','line_number':428,'multiline':False]
['text':' EraseEdge also erases the sibling of undirected edges.','line_number':429,'multiline':False]
['text':' We keep a stack of unprocessed edges.  Initially all edges are','line_number':443,'multiline':False]
['text':' pushed onto the stack.','line_number':444,'multiline':False]
['text':' We only need to modify one copy of each undirected edge.','line_number':451,'multiline':False]
['text':' For each edge, we check whether there are any nearby vertices that should','line_number':458,'multiline':False]
['text':' be spliced into it.  If there are, we choose one such vertex, split','line_number':459,'multiline':False]
['text':' the edge into two pieces, and iterate on each piece.','line_number':460,'multiline':False]
['text':' Do this before pushing new edges.','line_number':464,'multiline':False]
['text':' If we are xoring, edges may be erased before we get to them.','line_number':466,'multiline':False]
['text':' We repeatedly choose an edge and attempt to assemble a loop','line_number':494,'multiline':False]
['text':' starting from that edge.  (This is always possible unless the','line_number':495,'multiline':False]
['text':' input includes extra edges that are not part of any loop.)  To','line_number':496,'multiline':False]
['text':' maintain a consistent scanning order over edges_ between','line_number':497,'multiline':False]
['text':' different machine architectures (e.g. 'clovertown' vs. 'opteron'),','line_number':498,'multiline':False]
['text':' we follow the order they were added to the builder.','line_number':499,'multiline':False]
['text':' NOTE(user): If we have such two S2Points a, b that:','line_number':508,'multiline':False]
['text':'','line_number':509,'multiline':False]
['text':'   a.x = b.x, a.y = b.y and','line_number':510,'multiline':False]
['text':'   -- a.z = b.z if CPU is Intel','line_number':511,'multiline':False]
['text':'   -- a.z <> b.z if CPU is AMD','line_number':512,'multiline':False]
['text':'','line_number':513,'multiline':False]
['text':' then the order of points picked up as v1 on the following line','line_number':514,'multiline':False]
['text':' can be inconsistent between different machine architectures.','line_number':515,'multiline':False]
['text':'','line_number':516,'multiline':False]
['text':' As of b/3088321 and of cl/17847332, it's not clear if such','line_number':517,'multiline':False]
['text':' input really exists in our input and probably it's O.K. not to','line_number':518,'multiline':False]
['text':' address it in favor of the speed.','line_number':519,'multiline':False]
['text':' If edges are undirected, then all loops are already CCW.  Otherwise we','line_number':535,'multiline':False]
['text':' need to make sure the loops are normalized.','line_number':536,'multiline':False]
