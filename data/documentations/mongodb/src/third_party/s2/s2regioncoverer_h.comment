['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':'#include "base/scoped_ptr.h"','line_number':19,'multiline':False]
['text':' An S2RegionCoverer is a class that allows arbitrary regions to be','line_number':25,'multiline':False]
['text':' approximated as unions of cells (S2CellUnion).  This is useful for','line_number':26,'multiline':False]
['text':' implementing various sorts of search and precomputation operations.','line_number':27,'multiline':False]
['text':'','line_number':28,'multiline':False]
['text':' Typical usage:','line_number':29,'multiline':False]
['text':'','line_number':30,'multiline':False]
['text':' S2RegionCoverer coverer;','line_number':31,'multiline':False]
['text':' coverer.set_max_cells(5);','line_number':32,'multiline':False]
['text':' S2Cap cap = S2Cap::FromAxisAngle(...);','line_number':33,'multiline':False]
['text':' vector<S2CellId> covering;','line_number':34,'multiline':False]
['text':' coverer.GetCovering(cap, &covering);','line_number':35,'multiline':False]
['text':'','line_number':36,'multiline':False]
['text':' This yields a vector of at most 5 cells that is guaranteed to cover the','line_number':37,'multiline':False]
['text':' given cap (a disc-shaped region on the sphere).','line_number':38,'multiline':False]
['text':'','line_number':39,'multiline':False]
['text':' The approximation algorithm is not optimal but does a pretty good job in','line_number':40,'multiline':False]
['text':' practice.  The output does not always use the maximum number of cells','line_number':41,'multiline':False]
['text':' allowed, both because this would not always yield a better approximation,','line_number':42,'multiline':False]
['text':' and because max_cells() is a limit on how much work is done exploring the','line_number':43,'multiline':False]
['text':' possible covering as well as a limit on the final output size.','line_number':44,'multiline':False]
['text':'','line_number':45,'multiline':False]
['text':' One can also generate interior coverings, which are sets of cells which','line_number':46,'multiline':False]
['text':' are entirely contained within a region.  Interior coverings can be','line_number':47,'multiline':False]
['text':' empty, even for non-empty regions, if there are no cells that satisfy','line_number':48,'multiline':False]
['text':' the provided constraints and are contained by the region.  Note that for','line_number':49,'multiline':False]
['text':' performance reasons, it is wise to specify a max_level when computing','line_number':50,'multiline':False]
['text':' interior coverings - otherwise for regions with small or zero area, the','line_number':51,'multiline':False]
['text':' algorithm may spend a lot of time subdividing cells all the way to leaf','line_number':52,'multiline':False]
['text':' level to try to find contained cells.','line_number':53,'multiline':False]
['text':' By default, the covering uses at most 8 cells at any level.  This gives','line_number':56,'multiline':False]
['text':' a reasonable tradeoff between the number of cells used and the accuracy','line_number':57,'multiline':False]
['text':' of the approximation (see table below).','line_number':58,'multiline':False]
['text':' Set the minimum and maximum cell level to be used.  The default is to use','line_number':64,'multiline':False]
['text':' all cell levels.  Requires: max_level() >= min_level().','line_number':65,'multiline':False]
['text':'','line_number':66,'multiline':False]
['text':' To find the cell level corresponding to a given physical distance, use','line_number':67,'multiline':False]
['text':' the S2Cell metrics defined in s2.h.  For example, to find the cell','line_number':68,'multiline':False]
['text':' level that corresponds to an average edge length of 10km, use:','line_number':69,'multiline':False]
['text':'','line_number':70,'multiline':False]
['text':'     int level = S2::kAvgEdge.GetClosestLevel(','line_number':71,'multiline':False]
['text':'                 geostore::S2Earth::KmToRadians(length_km));','line_number':72,'multiline':False]
['text':'','line_number':73,'multiline':False]
['text':' Note: min_level() takes priority over max_cells(), i.e. cells below the','line_number':74,'multiline':False]
['text':' given level will never be used even if this causes a large number of','line_number':75,'multiline':False]
['text':' cells to be returned.','line_number':76,'multiline':False]
['text':' If specified, then only cells where (level - min_level) is a multiple of','line_number':82,'multiline':False]
['text':' "level_mod" will be used (default 1).  This effectively allows the','line_number':83,'multiline':False]
['text':' branching factor of the S2CellId hierarchy to be increased.  Currently','line_number':84,'multiline':False]
['text':' the only parameter values allowed are 1, 2, or 3, corresponding to','line_number':85,'multiline':False]
['text':' branching factors of 4, 16, and 64 respectively.','line_number':86,'multiline':False]
['text':' Sets the maximum desired number of cells in the approximation (defaults','line_number':90,'multiline':False]
['text':' to kDefaultMaxCells).  Note the following:','line_number':91,'multiline':False]
['text':'','line_number':92,'multiline':False]
['text':'  - For any setting of max_cells(), up to 6 cells may be returned if that','line_number':93,'multiline':False]
['text':'    is the minimum number of cells required (e.g. if the region intersects','line_number':94,'multiline':False]
['text':'    all six face cells).  Up to 3 cells may be returned even for very tiny','line_number':95,'multiline':False]
['text':'    convex regions if they happen to be located at the intersection of','line_number':96,'multiline':False]
['text':'    three cube faces.','line_number':97,'multiline':False]
['text':'','line_number':98,'multiline':False]
['text':'  - For any setting of max_cells(), an arbitrary number of cells may be','line_number':99,'multiline':False]
['text':'    returned if min_level() is too high for the region being approximated.','line_number':100,'multiline':False]
['text':'','line_number':101,'multiline':False]
['text':'  - If max_cells() is less than 4, the area of the covering may be','line_number':102,'multiline':False]
['text':'    arbitrarily large compared to the area of the original region even if','line_number':103,'multiline':False]
['text':'    the region is convex (e.g. an S2Cap or S2LatLngRect).','line_number':104,'multiline':False]
['text':'','line_number':105,'multiline':False]
['text':' Accuracy is measured by dividing the area of the covering by the area of','line_number':106,'multiline':False]
['text':' the original region.  The following table shows the median and worst case','line_number':107,'multiline':False]
['text':' values for this area ratio on a test case consisting of 100,000 spherical','line_number':108,'multiline':False]
['text':' caps of random size (generated using s2regioncoverer_unittest):','line_number':109,'multiline':False]
['text':'','line_number':110,'multiline':False]
['text':'   max_cells:        3      4     5     6     8    12    20   100   1000','line_number':111,'multiline':False]
['text':'   median ratio:  5.33   3.32  2.73  2.34  1.98  1.66  1.42  1.11   1.01','line_number':112,'multiline':False]
['text':'   worst case:  215518  14.41  9.72  5.26  3.91  2.75  1.92  1.20   1.02','line_number':113,'multiline':False]
['text':' Return a vector of cell ids that covers (GetCovering) or is contained','line_number':117,'multiline':False]
['text':' within (GetInteriorCovering) the given region and satisfies the various','line_number':118,'multiline':False]
['text':' restrictions specified above.','line_number':119,'multiline':False]
['text':' Return a normalized cell union that covers (GetCellUnion) or is contained','line_number':123,'multiline':False]
['text':' within (GetInteriorCellUnion) the given region and satisfies the','line_number':124,'multiline':False]
['text':' restrictions *EXCEPT* for min_level() and level_mod().  These criteria','line_number':125,'multiline':False]
['text':' cannot be satisfied using a cell union because cell unions are','line_number':126,'multiline':False]
['text':' automatically normalized by replacing four child cells with their parent','line_number':127,'multiline':False]
['text':' whenever possible.  (Note that the list of cell ids passed to the cell','line_number':128,'multiline':False]
['text':' union constructor does in fact satisfy all the given restrictions.)','line_number':129,'multiline':False]
['text':' Given a connected region and a starting point, return a set of cells at','line_number':133,'multiline':False]
['text':' the given level that cover the region.','line_number':134,'multiline':False]
['text':' Cell should not be expanded further.','line_number':141,'multiline':False]
['text':' Number of children that intersect the region.','line_number':142,'multiline':False]
['text':' Actual size may be 0, 4, 16, or 64 elements.','line_number':145,'multiline':False]
['text':' If the cell intersects the given region, return a new candidate with no','line_number':149,'multiline':False]
['text':' children, otherwise return NULL.  Also marks the candidate as "terminal"','line_number':150,'multiline':False]
['text':' if it should not be expanded further.','line_number':151,'multiline':False]
['text':' Return the log base 2 of the maximum number of children of a candidate.','line_number':154,'multiline':False]
['text':' Free the memory associated with a candidate.','line_number':157,'multiline':False]
['text':' Process a candidate by either adding it to the result_ vector or','line_number':160,'multiline':False]
['text':' expanding its children and inserting it into the priority queue.','line_number':161,'multiline':False]
['text':' Passing an argument of NULL does nothing.','line_number':162,'multiline':False]
['text':' Populate the children of "candidate" by expanding the given number of','line_number':165,'multiline':False]
['text':' levels from the given cell.  Returns the number of children that were','line_number':166,'multiline':False]
['text':' marked "terminal".','line_number':167,'multiline':False]
['text':' Computes a set of initial candidates that cover the given region.','line_number':170,'multiline':False]
['text':' Generates a covering and stores it in result_.','line_number':173,'multiline':False]
['text':' Given a region and a starting cell, return the set of all the','line_number':176,'multiline':False]
['text':' edge-connected cells at the same level that intersect "region".','line_number':177,'multiline':False]
['text':' The output cells are returned in arbitrary order.','line_number':178,'multiline':False]
['text':' We save a temporary copy of the pointer passed to GetCovering() in order','line_number':187,'multiline':False]
['text':' to avoid passing this parameter around internally.  It is only used (and','line_number':188,'multiline':False]
['text':' only valid) for the duration of a single GetCovering() call.','line_number':189,'multiline':False]
['text':' A temporary variable used by GetCovering() that holds the cell ids that','line_number':192,'multiline':False]
['text':' have been added to the covering so far.','line_number':193,'multiline':False]
['text':' We keep the candidates in a priority queue.  We specify a vector to hold','line_number':196,'multiline':False]
['text':' the queue entries since for some reason priority_queue<> uses a deque by','line_number':197,'multiline':False]
['text':' default.','line_number':198,'multiline':False]
['text':' True if we're computing an interior covering.','line_number':205,'multiline':False]
['text':' Counter of number of candidates created, for performance evaluation.','line_number':208,'multiline':False]
['text':' UTIL_GEOMETRY_S2REGION_COVERER_H_','line_number':214,'multiline':False]
