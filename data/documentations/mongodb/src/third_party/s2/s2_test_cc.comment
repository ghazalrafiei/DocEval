['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':' Check consistency with respect to swapping axes.','line_number':33,'multiline':False]
['text':' Check consistency with respect to reversing axis directions.','line_number':39,'multiline':False]
['text':' Check that the two tables are inverses of each other.','line_number':45,'multiline':False]
['text':' Check boundary conditions.','line_number':53,'multiline':False]
['text':' Check that UVtoST and STtoUV are inverses.','line_number':62,'multiline':False]
['text':' Check that each face appears exactly once.','line_number':70,'multiline':False]
['text':' Check that each face has a right-handed coordinate system.','line_number':80,'multiline':False]
['text':' Check that the Hilbert curves on each face combine to form a','line_number':86,'multiline':False]
['text':' continuous curve over the entire cube.','line_number':87,'multiline':False]
['text':' The Hilbert curve on each face starts at (-1,-1) and terminates','line_number':89,'multiline':False]
['text':' at either (1,-1) (if axes not swapped) or (-1,1) (if swapped).','line_number':90,'multiline':False]
['text':' Check that GetUNorm and GetVNorm compute right-handed normals for','line_number':98,'multiline':False]
['text':' an edge in the increasing U or V direction.','line_number':99,'multiline':False]
['text':' Check that axes are consistent with FaceUVtoXYZ.','line_number':113,'multiline':False]
['text':' Make sure that Area() has good *relative* accuracy even for','line_number':145,'multiline':False]
['text':' very small areas.','line_number':146,'multiline':False]
['text':' Make sure that it can handle degenerate triangles.','line_number':153,'multiline':False]
['text':' TODO: The following test is not exact in optimized mode because the','line_number':157,'multiline':False]
['text':' compiler chooses to mix 64-bit and 80-bit intermediate results.','line_number':158,'multiline':False]
['text':' The actual displacement can be as much as 1.2e-15 due to roundoff.','line_number':169,'multiline':False]
['text':' This yields a maximum triangle area of about 0.7e-30.','line_number':170,'multiline':False]
['text':' This check only passes if GirardArea() uses RobustCrossProd().','line_number':174,'multiline':False]
['text':' Try a very long and skinny triangle.','line_number':178,'multiline':False]
['text':' Mathematica.','line_number':180,'multiline':False]
['text':' Triangles with near-180 degree edges that sum to a quarter-sphere.','line_number':183,'multiline':False]
['text':' Four other triangles that sum to a quarter-sphere.','line_number':192,'multiline':False]
['text':' Compute the area of a hemisphere using four triangles with one near-180','line_number':200,'multiline':False]
['text':' degree edge and one near-degenerate edge.  This test fails in optimized','line_number':201,'multiline':False]
['text':' mode unless GirardArea uses RobustCrossProd(), because the compiler','line_number':202,'multiline':False]
['text':' doesn't compute all the inlined CrossProd() calls with the same level of','line_number':203,'multiline':False]
['text':' accuracy (some intermediate values are spilled to 64-bit temporaries).','line_number':204,'multiline':False]
['text':' Test TrueCentroid() with very small triangles.  This test assumes that','line_number':220,'multiline':False]
['text':' the triangle is small enough so that it is nearly planar.','line_number':221,'multiline':False]
['text':' The centroid of a planar triangle is at the intersection of its','line_number':231,'multiline':False]
['text':' medians, which is two-thirds of the way along each median.','line_number':232,'multiline':False]
['text':' The following points happen to be *exactly collinear* along a line that it','line_number':239,'multiline':False]
['text':' approximate tangent to the surface of the unit sphere.  In fact, C is the','line_number':240,'multiline':False]
['text':' exact midpoint of the line segment AB.  All of these points are close','line_number':241,'multiline':False]
['text':' enough to unit length to satisfy S2::IsUnitLength().','line_number':242,'multiline':False]
['text':' The points "x1" and "x2" are exactly proportional, i.e. they both lie','line_number':251,'multiline':False]
['text':' on a common line through the origin.  Both points are considered to be','line_number':252,'multiline':False]
['text':' normalized, and in fact they both satisfy (x == x.Normalize()).','line_number':253,'multiline':False]
['text':' Therefore the triangle (x1, x2, -x1) consists of three distinct points','line_number':254,'multiline':False]
['text':' that all lie on a common line through the origin.','line_number':255,'multiline':False]
['text':' Here are two more points that are distinct, exactly proportional, and','line_number':264,'multiline':False]
['text':' that satisfy (x == x.Normalize()).','line_number':265,'multiline':False]
['text':' The following two points demonstrate that Normalize() is not idempotent,','line_number':273,'multiline':False]
['text':' i.e. y0.Normalize() != y0.Normalize().Normalize().  Both points satisfy','line_number':274,'multiline':False]
['text':' S2::IsNormalized(), though, and the two points are exactly proportional.','line_number':275,'multiline':False]
['text':' Given 3 points A, B, C that are exactly coplanar with the origin and where','line_number':286,'multiline':False]
['text':' A < B < C in lexicographic order, verify that ABC is counterclockwise (if','line_number':287,'multiline':False]
['text':' expected == 1) or clockwise (if expected == -1) using S2::ExpensiveCCW().','line_number':288,'multiline':False]
['text':'','line_number':289,'multiline':False]
['text':' This method is intended specifically for checking the cases where','line_number':290,'multiline':False]
['text':' symbolic perturbations are needed to break ties.','line_number':291,'multiline':False]
['text':' Use ASSERT rather than EXPECT to suppress spurious error messages.','line_number':298,'multiline':False]
['text':' The purpose of this test is simply to get code coverage of','line_number':308,'multiline':False]
['text':' SymbolicallyPerturbedCCW().  Let M_1, M_2, ... be the sequence of','line_number':309,'multiline':False]
['text':' submatrices whose determinant sign is tested by that function.  Then the','line_number':310,'multiline':False]
['text':' i-th test below is a 3x3 matrix M (with rows A, B, C) such that:','line_number':311,'multiline':False]
['text':'','line_number':312,'multiline':False]
['text':'    det(M) = 0','line_number':313,'multiline':False]
['text':'    det(M_j) = 0 for j < i','line_number':314,'multiline':False]
['text':'    det(M_i) != 0','line_number':315,'multiline':False]
['text':'    A < B < C in lexicographic order.','line_number':316,'multiline':False]
['text':'','line_number':317,'multiline':False]
['text':' I checked that reversing the sign of any of the "return" statements in','line_number':318,'multiline':False]
['text':' SymbolicallyPerturbedCCW() will cause this test to fail.','line_number':319,'multiline':False]
['text':' det(M_1) = b0*c1 - b1*c0','line_number':321,'multiline':False]
['text':' det(M_2) = b2*c0 - b0*c2','line_number':324,'multiline':False]
['text':' det(M_3) = b1*c2 - b2*c1','line_number':327,'multiline':False]
['text':' From this point onward, B or C must be zero, or B is proportional to C.','line_number':329,'multiline':False]
['text':' det(M_4) = c0*a1 - c1*a0','line_number':331,'multiline':False]
['text':' det(M_5) = c0','line_number':334,'multiline':False]
['text':' det(M_6) = -c1','line_number':337,'multiline':False]
['text':' det(M_7) = c2*a0 - c0*a2','line_number':340,'multiline':False]
['text':' det(M_8) = c2','line_number':343,'multiline':False]
['text':' From this point onward, C must be zero.','line_number':345,'multiline':False]
['text':' det(M_9) = a0*b1 - a1*b0','line_number':347,'multiline':False]
['text':' det(M_10) = -b0','line_number':350,'multiline':False]
['text':' det(M_11) = b1','line_number':353,'multiline':False]
['text':' det(M_12) = a0','line_number':356,'multiline':False]
['text':' det(M_13) = 1','line_number':359,'multiline':False]
['text':' This test repeatedly constructs some number of points that are on or nearly','line_number':363,'multiline':False]
['text':' on a given great circle.  Then it chooses one of these points as the','line_number':364,'multiline':False]
['text':' "origin" and sorts the other points in CCW order around it.  Of course,','line_number':365,'multiline':False]
['text':' since the origin is on the same great circle as the points being sorted,','line_number':366,'multiline':False]
['text':' nearly all of these tests are degenerate.  It then does various consistency','line_number':367,'multiline':False]
['text':' checks to verify that the points are indeed sorted in CCW order.','line_number':368,'multiline':False]
['text':'','line_number':369,'multiline':False]
['text':' It is easier to think about what this test is doing if you imagine that the','line_number':370,'multiline':False]
['text':' points are in general position rather than on a great circle.','line_number':371,'multiline':False]
['text':' The following method is used to sort a collection of points in CCW order','line_number':374,'multiline':False]
['text':' around a given origin.  It returns true if A comes before B in the CCW','line_number':375,'multiline':False]
['text':' ordering (starting at an arbitrary fixed direction).','line_number':376,'multiline':False]
['text':' OrderedCCW() acts like "<=", so we need to invert the comparison.','line_number':383,'multiline':False]
['text':' Given a set of points with no duplicates, first remove "origin" from','line_number':391,'multiline':False]
['text':' "points" (if it exists) and then sort the remaining points in CCW order','line_number':392,'multiline':False]
['text':' around "origin" putting the result in "sorted".','line_number':393,'multiline':False]
['text':' Make a copy of the points with "origin" removed.','line_number':396,'multiline':False]
['text':' Sort the points CCW around the origin starting at (*sorted)[0].','line_number':400,'multiline':False]
['text':' Given a set of points sorted circularly CCW around "origin", and the','line_number':405,'multiline':False]
['text':' index "start" of a point A, count the number of CCW triangles OAB over','line_number':406,'multiline':False]
['text':' all sorted points B not equal to A.  Also check that the results of the','line_number':407,'multiline':False]
['text':' CCW tests are consistent with the hypothesis that the points are sorted.','line_number':408,'multiline':False]
['text':' Since the points are sorted around the origin, we expect to see a','line_number':419,'multiline':False]
['text':' (possibly empty) sequence of CCW triangles followed by a (possibly','line_number':420,'multiline':False]
['text':' empty) sequence of CW triangles.','line_number':421,'multiline':False]
['text':' Test exhaustively whether the points in "sorted" are sorted circularly','line_number':428,'multiline':False]
['text':' CCW around "origin".','line_number':429,'multiline':False]
['text':' Each iteration we increase the start index by 1, therefore the number','line_number':436,'multiline':False]
['text':' of CCW triangles should decrease by at most 1.','line_number':437,'multiline':False]
['text':' We have tested all triangles of the form OAB.  Exactly half of these','line_number':442,'multiline':False]
['text':' should be CCW.','line_number':443,'multiline':False]
['text':' Add two points A1 and A2 that are slightly offset from A along the','line_number':451,'multiline':False]
['text':' tangent toward B, and such that A, A1, and A2 are exactly collinear','line_number':452,'multiline':False]
['text':' (i.e. even with infinite-precision arithmetic).','line_number':453,'multiline':False]
['text':' Add zero or more (but usually one) point that is likely to trigger','line_number':469,'multiline':False]
['text':' RobustCCW() degeneracies among the given points.','line_number':470,'multiline':False]
['text':' Add a random point (not uniformly distributed) along the great','line_number':478,'multiline':False]
['text':' circle AB.','line_number':479,'multiline':False]
['text':' Perturb one coordinate by the minimum amount possible.','line_number':484,'multiline':False]
['text':' Perturb one coordinate by up to 1e-15.','line_number':489,'multiline':False]
['text':' Scale a point just enough so that it is different while still being','line_number':494,'multiline':False]
['text':' considered normalized.','line_number':495,'multiline':False]
['text':' Add the intersection point of AB with X=0, Y=0, or Z=0.','line_number':500,'multiline':False]
['text':' Add two closely spaced points along the tangent at A to the great','line_number':510,'multiline':False]
['text':' circle through AB.','line_number':511,'multiline':False]
['text':' Add two closely spaced points along the tangent at A to the great','line_number':515,'multiline':False]
['text':' circle through A and the X-axis.','line_number':516,'multiline':False]
['text':' Add the negative of a point.','line_number':520,'multiline':False]
['text':' Sort the points around the given origin, and then do some consistency','line_number':526,'multiline':False]
['text':' checks to verify that they are actually sorted.','line_number':527,'multiline':False]
['text':' Construct approximately "n" points near the great circle through A and B,','line_number':535,'multiline':False]
['text':' then sort them and test whether they are sorted.','line_number':536,'multiline':False]
['text':' Remove any (0, 0, 0) points that were accidentically created, then sort','line_number':546,'multiline':False]
['text':' the points and remove duplicates.','line_number':547,'multiline':False]
['text':' The run time of this test is *cubic* in the parameter below.','line_number':563,'multiline':False]
['text':' This test is randomized, so it is beneficial to run it several times.','line_number':566,'multiline':False]
['text':' The most difficult great circles are the ones in the X-Y, Y-Z, and X-Z','line_number':568,'multiline':False]
['text':' planes, for two reasons.  First, when one or more coordinates are close','line_number':569,'multiline':False]
['text':' to zero then the perturbations can be much smaller, since floating','line_number':570,'multiline':False]
['text':' point numbers are spaced much more closely together near zero.  (This','line_number':571,'multiline':False]
['text':' tests the handling of things like underflow.)  The second reason is','line_number':572,'multiline':False]
['text':' that most of the cases of SymbolicallyPerturbedCCW() can only be','line_number':573,'multiline':False]
['text':' reached when one or more input point coordinates are zero.','line_number':574,'multiline':False]
['text':' This tests a great circle where at least some points have X, Y, and Z','line_number':579,'multiline':False]
['text':' coordinates with exactly the same mantissa.  One useful property of','line_number':580,'multiline':False]
['text':' such points is that when they are scaled (e.g. multiplying by 1+eps),','line_number':581,'multiline':False]
['text':' all such points are exactly collinear with the origin.','line_number':582,'multiline':False]
['text':' Note: obviously, I could have defined a bundle of metrics like this in the','line_number':588,'multiline':False]
['text':' S2 class itself rather than just for testing.  However, it's not clear that','line_number':589,'multiline':False]
['text':' this is useful other than for testing purposes, and I find','line_number':590,'multiline':False]
['text':' S2::kMinWidth.GetMaxLevel(width) to be slightly more readable than','line_number':591,'multiline':False]
['text':' than S2::kWidth.min().GetMaxLevel(width).  Also, there is no fundamental','line_number':592,'multiline':False]
['text':' reason that we need to analyze the minimum, maximum, and average values of','line_number':593,'multiline':False]
['text':' every metric; it would be perfectly reasonable to just define one of these.','line_number':594,'multiline':False]
['text':' First, check that min <= avg <= max for each metric.','line_number':629,'multiline':False]
['text':' Check that the maximum aspect ratio of an individual cell is consistent','line_number':636,'multiline':False]
['text':' with the global minimums and maximums.','line_number':637,'multiline':False]
['text':' Check various conditions that are provable mathematically.','line_number':643,'multiline':False]
['text':' GetMinLevelForLength() and friends have built-in assertions, we just need','line_number':653,'multiline':False]
['text':' to call these functions to test them.','line_number':654,'multiline':False]
['text':'','line_number':655,'multiline':False]
['text':' We don't actually check that the metrics are correct here, e.g. that','line_number':656,'multiline':False]
['text':' GetMinWidth(10) is a lower bound on the width of cells at level 10.','line_number':657,'multiline':False]
['text':' It is easier to check these properties in s2cell_unittest, since','line_number':658,'multiline':False]
['text':' S2Cell has methods to compute the cell vertices, etc.','line_number':659,'multiline':False]
['text':' Check boundary cases (exactly equal to a threshold value).','line_number':665,'multiline':False]
['text':' Also check non-boundary cases.','line_number':672,'multiline':False]
['text':' Same thing for area.','line_number':678,'multiline':False]
['text':' All points in a tiny cap to test avalanche property of hash','line_number':717,'multiline':False]
['text':' function (the cap would be of radius 1mm on Earth (4*10^9/2^35).','line_number':718,'multiline':False]
['text':' A real collision is extremely unlikely.','line_number':724,'multiline':False]
['text':' Allow a few for the hash.','line_number':726,'multiline':False]
