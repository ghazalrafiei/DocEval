['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':' An S2Polygon is an S2Region object that represents a polygon.  A polygon','line_number':24,'multiline':False]
['text':' consists of zero or more loops representing "shells" and "holes".  All','line_number':25,'multiline':False]
['text':' loops should be oriented CCW, i.e. the shell or hole is on the left side of','line_number':26,'multiline':False]
['text':' the loop.  Loops may be specified in any order.  A point is defined to be','line_number':27,'multiline':False]
['text':' inside the polygon if it is contained by an odd number of loops.','line_number':28,'multiline':False]
['text':'','line_number':29,'multiline':False]
['text':' Polygons have the following restrictions:','line_number':30,'multiline':False]
['text':'','line_number':31,'multiline':False]
['text':'  - Loops may not cross, i.e. the boundary of a loop may not intersect','line_number':32,'multiline':False]
['text':'    both the interior and exterior of any other loop.','line_number':33,'multiline':False]
['text':'','line_number':34,'multiline':False]
['text':'  - Loops may not share edges, i.e. if a loop contains an edge AB, then','line_number':35,'multiline':False]
['text':'    no other loop may contain AB or BA.','line_number':36,'multiline':False]
['text':'','line_number':37,'multiline':False]
['text':'  - No loop may cover more than half the area of the sphere.  This ensures','line_number':38,'multiline':False]
['text':'    that no loop properly contains the complement of any other loop, even','line_number':39,'multiline':False]
['text':'    if the loops are from different polygons.  (Loops that represent exact','line_number':40,'multiline':False]
['text':'    hemispheres are allowed.)','line_number':41,'multiline':False]
['text':'','line_number':42,'multiline':False]
['text':' Loops may share vertices, however no vertex may appear twice in a single','line_number':43,'multiline':False]
['text':' loop (see s2loop.h).','line_number':44,'multiline':False]
['text':' Creates an empty polygon that should be initialized by calling Init() or','line_number':47,'multiline':False]
['text':' Decode().','line_number':48,'multiline':False]
['text':' Convenience constructor that calls Init() with the given loops.  Takes','line_number':51,'multiline':False]
['text':' ownership of the loops and clears the given vector.','line_number':52,'multiline':False]
['text':' Convenience constructor that creates a polygon with a single loop','line_number':55,'multiline':False]
['text':' corresponding to the given cell.','line_number':56,'multiline':False]
['text':' Initialize a polygon by taking ownership of the given loops and clearing','line_number':59,'multiline':False]
['text':' the given vector.  This method figures out the loop nesting hierarchy and','line_number':60,'multiline':False]
['text':' then reorders the loops by following a preorder traversal.  This implies','line_number':61,'multiline':False]
['text':' that each loop is immediately followed by its descendants in the nesting','line_number':62,'multiline':False]
['text':' hierarchy.  (See also GetParent and GetLastDescendant.)','line_number':63,'multiline':False]
['text':' Release ownership of the loops of this polygon, and appends them to','line_number':66,'multiline':False]
['text':' "loops" if non-NULL.  Resets the polygon to be empty.','line_number':67,'multiline':False]
['text':' Makes a deep copy of the given source polygon.  Requires that the','line_number':70,'multiline':False]
['text':' destination polygon is empty.','line_number':71,'multiline':False]
['text':' Destroys the polygon and frees its loops.','line_number':74,'multiline':False]
['text':' Return true if the given loops form a valid polygon.  Assumes that','line_number':77,'multiline':False]
['text':' all of the given loops have already been validated.','line_number':78,'multiline':False]
['text':' Output errors to "err" if it's not NULL.','line_number':79,'multiline':False]
['text':' Return true if this is a valid polygon.  Note that in debug mode,','line_number':82,'multiline':False]
['text':' validity is checked at polygon creation time, so IsValid() should always','line_number':83,'multiline':False]
['text':' return true.','line_number':84,'multiline':False]
['text':' If err is not NULL, output errors to it.','line_number':85,'multiline':False]
['text':' DEPRECATED.','line_number':88,'multiline':False]
['text':' Total number of vertices in all loops.','line_number':93,'multiline':False]
['text':' Return the index of the parent of loop k, or -1 if it has no parent.','line_number':98,'multiline':False]
['text':' Return the index of the last loop that is contained within loop k.','line_number':101,'multiline':False]
['text':' Returns num_loops() - 1 if k < 0.  Note that loops are indexed according','line_number':102,'multiline':False]
['text':' to a preorder traversal of the nesting hierarchy, so the immediate','line_number':103,'multiline':False]
['text':' children of loop k can be found by iterating over loops','line_number':104,'multiline':False]
['text':' (k+1)..GetLastDescendant(k) and selecting those whose depth is equal to','line_number':105,'multiline':False]
['text':' (loop(k)->depth() + 1).','line_number':106,'multiline':False]
['text':' Return the area of the polygon interior, i.e. the region on the left side','line_number':109,'multiline':False]
['text':' of an odd number of loops.  The return value is between 0 and 4*Pi.','line_number':110,'multiline':False]
['text':' Return the true centroid of the polygon multiplied by the area of the','line_number':113,'multiline':False]
['text':' polygon (see s2.h for details on centroids).  The result is not unit','line_number':114,'multiline':False]
['text':' length, so you may want to normalize it.  Also note that in general, the','line_number':115,'multiline':False]
['text':' centroid may not be contained by the polygon.','line_number':116,'multiline':False]
['text':'','line_number':117,'multiline':False]
['text':' We prescale by the polygon area for two reasons: (1) it is cheaper to','line_number':118,'multiline':False]
['text':' compute this way, and (2) it makes it easier to compute the centroid of','line_number':119,'multiline':False]
['text':' more complicated shapes (by splitting them into disjoint regions and','line_number':120,'multiline':False]
['text':' adding their centroids).','line_number':121,'multiline':False]
['text':' Return true if this polygon contains the given other polygon, i.e.','line_number':124,'multiline':False]
['text':' if polygon A contains all points contained by polygon B.','line_number':125,'multiline':False]
['text':' Returns true if this polgyon (A) approximately contains the given other','line_number':128,'multiline':False]
['text':' polygon (B). This is true if it is possible to move the vertices of B','line_number':129,'multiline':False]
['text':' no further than "vertex_merge_radius" such that A contains the modified B.','line_number':130,'multiline':False]
['text':'','line_number':131,'multiline':False]
['text':' For example, the empty polygon will contain any polygon whose maximum','line_number':132,'multiline':False]
['text':' width is no more than vertex_merge_radius.','line_number':133,'multiline':False]
['text':' Return true if this polygon intersects the given other polygon, i.e.','line_number':136,'multiline':False]
['text':' if there is a point that is contained by both polygons.','line_number':137,'multiline':False]
['text':' Initialize this polygon to the intersection, union, or difference','line_number':140,'multiline':False]
['text':' (A - B) of the given two polygons.  The "vertex_merge_radius" determines','line_number':141,'multiline':False]
['text':' how close two vertices must be to be merged together and how close a','line_number':142,'multiline':False]
['text':' vertex must be to an edge in order to be spliced into it (see','line_number':143,'multiline':False]
['text':' S2PolygonBuilder for details).  By default, the merge radius is just','line_number':144,'multiline':False]
['text':' large enough to compensate for errors that occur when computing','line_number':145,'multiline':False]
['text':' intersection points between edges (S2EdgeUtil::kIntersectionTolerance).','line_number':146,'multiline':False]
['text':'','line_number':147,'multiline':False]
['text':' If you are going to convert the resulting polygon to a lower-precision','line_number':148,'multiline':False]
['text':' format, it is necessary to increase the merge radius in order to get a','line_number':149,'multiline':False]
['text':' valid result after rounding (i.e. no duplicate vertices, etc).  For','line_number':150,'multiline':False]
['text':' example, if you are going to convert them to geostore::PolygonProto','line_number':151,'multiline':False]
['text':' format, then S1Angle::E7(1) is a good value for "vertex_merge_radius".','line_number':152,'multiline':False]
['text':' Initializes this polygon to a polygon that contains fewer vertices and is','line_number':163,'multiline':False]
['text':' within tolerance of the polygon a, with some caveats.','line_number':164,'multiline':False]
['text':'','line_number':165,'multiline':False]
['text':' - If there is a very small island in the original polygon, it may','line_number':166,'multiline':False]
['text':'   disappear completely.  Thus some parts of the original polygon','line_number':167,'multiline':False]
['text':'   may not be close to the simplified polygon.  Those parts are small,','line_number':168,'multiline':False]
['text':'   though, and arguably don't need to be kept.','line_number':169,'multiline':False]
['text':' - However, if there are dense islands, they may all disappear, instead','line_number':170,'multiline':False]
['text':'   of replacing them by a big simplified island.','line_number':171,'multiline':False]
['text':' - For small tolerances (compared to the polygon size), it may happen that','line_number':172,'multiline':False]
['text':'   the simplified polygon has more vertices than the original, if the','line_number':173,'multiline':False]
['text':'   first step of the simplification creates too many self-intersections.','line_number':174,'multiline':False]
['text':'   One can construct irrealistic cases where that happens to an extreme','line_number':175,'multiline':False]
['text':'   degree.','line_number':176,'multiline':False]
['text':' Intersect this polygon with the polyline "in" and append the resulting','line_number':179,'multiline':False]
['text':' zero or more polylines to "out" (which must be empty).  The polylines','line_number':180,'multiline':False]
['text':' are appended in the order they would be encountered by traversing "in"','line_number':181,'multiline':False]
['text':' from beginning to end.  Note that the output may include polylines with','line_number':182,'multiline':False]
['text':' only one vertex, but there will not be any zero-vertex polylines.','line_number':183,'multiline':False]
['text':'','line_number':184,'multiline':False]
['text':' This is equivalent to calling IntersectWithPolylineSloppy() with the','line_number':185,'multiline':False]
['text':' "vertex_merge_radius" set to S2EdgeUtil::kIntersectionTolerance.','line_number':186,'multiline':False]
['text':' Similar to IntersectWithPolyline(), except that vertices will be','line_number':190,'multiline':False]
['text':' dropped as necessary to ensure that all adjacent vertices in the','line_number':191,'multiline':False]
['text':' sequence obtained by concatenating the output polylines will be','line_number':192,'multiline':False]
['text':' farther than "vertex_merge_radius" apart.  Note that this can change','line_number':193,'multiline':False]
['text':' the number of output polylines and/or yield single-vertex polylines.','line_number':194,'multiline':False]
['text':' Same as IntersectWithPolyline, but subtracts this polygon from','line_number':199,'multiline':False]
['text':' the given polyline.','line_number':200,'multiline':False]
['text':' Same as IntersectWithPolylineSloppy, but subtracts this polygon','line_number':204,'multiline':False]
['text':' from the given polyline.','line_number':205,'multiline':False]
['text':' Return a polygon which is the union of the given polygons.','line_number':210,'multiline':False]
['text':' Clears the vector and deletes the polygons!','line_number':211,'multiline':False]
['text':' Initialize this polygon to the outline of the given cell union.','line_number':216,'multiline':False]
['text':' In principle this polygon should exactly contain the cell union and','line_number':217,'multiline':False]
['text':' this polygon's inverse should not intersect the cell union, but rounding','line_number':218,'multiline':False]
['text':' issues may cause this not to be the case.','line_number':219,'multiline':False]
['text':' Does not work correctly if the union covers more than half the sphere.','line_number':220,'multiline':False]
['text':' Return true if every loop of this polygon shares at most one vertex with','line_number':223,'multiline':False]
['text':' its parent loop.  Every polygon has a unique normalized form.  Normalized','line_number':224,'multiline':False]
['text':' polygons are useful for testing since it is easy to compare whether two','line_number':225,'multiline':False]
['text':' polygons represent the same region.','line_number':226,'multiline':False]
['text':' Output errors into "err" if it's not NULL.','line_number':227,'multiline':False]
['text':' Return true if two polygons have the same boundary.  More precisely, this','line_number':230,'multiline':False]
['text':' method requires that both polygons have loops with the same cyclic vertex','line_number':231,'multiline':False]
['text':' order and the same nesting hierarchy.','line_number':232,'multiline':False]
['text':' Return true if two polygons have the same boundary except for vertex','line_number':235,'multiline':False]
['text':' perturbations.  Both polygons must have loops with the same cyclic vertex','line_number':236,'multiline':False]
['text':' order and the same nesting hierarchy, but the vertex locations are','line_number':237,'multiline':False]
['text':' allowed to differ by up to "max_error".','line_number':238,'multiline':False]
['text':' Return true if two polygons have boundaries that are within "max_error"','line_number':241,'multiline':False]
['text':' of each other along their entire lengths.  More precisely, there must be','line_number':242,'multiline':False]
['text':' a bijection between the two sets of loops such that for each pair of','line_number':243,'multiline':False]
['text':' loops, "a_loop->BoundaryNear(b_loop)" is true.','line_number':244,'multiline':False]
['text':' If the point is not contained by the polygon returns a point on the','line_number':247,'multiline':False]
['text':' polygon closest to the given point. Otherwise returns the point itself.','line_number':248,'multiline':False]
['text':' The polygon must not be empty.','line_number':249,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////','line_number':252,'multiline':False]
['text':' S2Region interface (see s2region.h for details):','line_number':253,'multiline':False]
['text':' GetRectBound() guarantees that it will return exact bounds. GetCapBound()','line_number':255,'multiline':False]
['text':' does not.','line_number':256,'multiline':False]
['text':' Cap surrounding rect bound.','line_number':258,'multiline':False]
['text':' The point 'p' does not need to be normalized.','line_number':265,'multiline':False]
['text':' Internal constructor that does *not* take ownership of its argument.','line_number':273,'multiline':False]
['text':' A map from each loop to its immediate children with respect to nesting.','line_number':276,'multiline':False]
['text':' This map is built during initialization of multi-loop polygons to','line_number':277,'multiline':False]
['text':' determine which are shells and which are holes, and then discarded.','line_number':278,'multiline':False]
['text':' Internal implementation of the Decode and DecodeWithinScope methods above.','line_number':281,'multiline':False]
['text':' The within_scope parameter specifies whether to call DecodeWithinScope','line_number':282,'multiline':False]
['text':' on the loops.','line_number':283,'multiline':False]
['text':' Internal implementation of intersect/subtract polyline functions above.','line_number':286,'multiline':False]
['text':' Cache for num_vertices().','line_number':308,'multiline':False]
['text':' UTIL_GEOMETRY_S2POLYGON_H_','line_number':314,'multiline':False]
