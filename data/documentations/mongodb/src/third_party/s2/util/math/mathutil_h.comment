['text':' Copyright 2001 and onwards Google Inc.','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' This class is intended to contain a collection of useful (static)','line_number':3,'multiline':False]
['text':' mathematical functions, properly coded (by consulting numerical','line_number':4,'multiline':False]
['text':' recipes or another authoritative source first).','line_number':5,'multiline':False]
['text':' Returns the sign of x:','line_number':23,'multiline':False]
['text':'   -1 if x < 0,','line_number':24,'multiline':False]
['text':'   +1 if x > 0,','line_number':25,'multiline':False]
['text':'    0 if x = 0.','line_number':26,'multiline':False]
['text':' Consider instead using MathUtil::Sign below for readability','line_number':27,'multiline':False]
['text':' and floating-point correctness.','line_number':28,'multiline':False]
['text':' HACK ALERT','line_number':33,'multiline':False]
['text':' So here's the deal: There's a ton of junk defined in mathlimits.h that should be moved into','line_number':34,'multiline':False]
['text':' mathlimits.cc.  But the only thing that uses mathlimits.cc/h is this, mathutil.cc/h.','line_number':35,'multiline':False]
['text':' So I moved a class definition into this .h file before the stuff that references it and stuck','line_number':36,'multiline':False]
['text':' mathutil.cc into mathlimits.cc.  Voila!','line_number':37,'multiline':False]
['text':' Useful integer and floating point limits and type traits.','line_number':40,'multiline':False]
['text':' This is just for the documentation;','line_number':41,'multiline':False]
['text':' real members are defined in our specializations below.','line_number':42,'multiline':False]
['text':' Type name.','line_number':44,'multiline':False]
['text':' Unsigned version of the Type with the same byte size.','line_number':46,'multiline':False]
['text':' Same as Type for floating point and unsigned types.','line_number':47,'multiline':False]
['text':' If the type supports negative values.','line_number':49,'multiline':False]
['text':' If the type supports only integer values.','line_number':51,'multiline':False]
['text':' Magnitude-wise smallest representable positive value.','line_number':53,'multiline':False]
['text':' Magnitude-wise largest representable positive value.','line_number':55,'multiline':False]
['text':' Smallest representable value.','line_number':57,'multiline':False]
['text':' Largest representable value.','line_number':59,'multiline':False]
['text':' Magnitude-wise smallest representable negative value.','line_number':61,'multiline':False]
['text':' Present only if kIsSigned.','line_number':62,'multiline':False]
['text':' Magnitude-wise largest representable negative value.','line_number':64,'multiline':False]
['text':' Present only if kIsSigned.','line_number':65,'multiline':False]
['text':' Smallest integer x such that 10^x is representable.','line_number':67,'multiline':False]
['text':' Largest integer x such that 10^x is representable.','line_number':69,'multiline':False]
['text':' Smallest positive value such that Type(1) + kEpsilon != Type(1)','line_number':71,'multiline':False]
['text':' Typical rounding error that is enough to cover','line_number':73,'multiline':False]
['text':' a few simple floating-point operations.','line_number':74,'multiline':False]
['text':' Slightly larger than kEpsilon to account for a few rounding errors.','line_number':75,'multiline':False]
['text':' Is zero if kIsInteger.','line_number':76,'multiline':False]
['text':' Number of decimal digits of mantissa precision.','line_number':78,'multiline':False]
['text':' Present only if !kIsInteger.','line_number':79,'multiline':False]
['text':' Not a number, i.e. result of 0/0.','line_number':81,'multiline':False]
['text':' Present only if !kIsInteger.','line_number':82,'multiline':False]
['text':' Positive infinity, i.e. result of 1/0.','line_number':84,'multiline':False]
['text':' Present only if !kIsInteger.','line_number':85,'multiline':False]
['text':' Negative infinity, i.e. result of -1/0.','line_number':87,'multiline':False]
['text':' Present only if !kIsInteger.','line_number':88,'multiline':False]
['text':' NOTE: Special floating point values behave','line_number':91,'multiline':False]
['text':' in a special (but mathematically-logical) way','line_number':92,'multiline':False]
['text':' in terms of (in)equalty comparison and mathematical operations','line_number':93,'multiline':False]
['text':' -- see out unittest for examples.','line_number':94,'multiline':False]
['text':' Special floating point value testers.','line_number':96,'multiline':False]
['text':' Present in integer types for convenience.','line_number':97,'multiline':False]
['text':' END HACK ALERT','line_number':104,'multiline':False]
['text':'UTIL_MATH_MATHLIMITS_H','line_number':105,'multiline':False]
['text':' ========================================================================= //','line_number':106,'multiline':False]
['text':' Disable error about fabs causing truncation of value because','line_number':108,'multiline':False]
['text':' it takes a double instead of a long double (Clang 3.5)','line_number':109,'multiline':False]
['text':' See SERVER-15183','line_number':110,'multiline':False]
['text':' Return type of RealRootsForQuadratic (below).  The enum values are','line_number':117,'multiline':False]
['text':' chosen to be sensible if converted to bool or int, and should not be','line_number':118,'multiline':False]
['text':' changed lightly.','line_number':119,'multiline':False]
['text':' Returns the QuadraticRootType of the equation a * x^2 + b * x + c = 0.','line_number':122,'multiline':False]
['text':' Normal cases are kNoRealRoots, in which case *r1 and *r2 are not','line_number':123,'multiline':False]
['text':' changed; and kTwoRealRoots, in which case the root(s) are placed in','line_number':124,'multiline':False]
['text':' *r1 and *r2, order not specified.  The kAmbiguous return value','line_number':125,'multiline':False]
['text':' indicates that the disciminant is zero, within floating-point error','line_number':126,'multiline':False]
['text':' (i.e. that changing an input by epsilon<double> would change the sign','line_number':127,'multiline':False]
['text':' of the discriminant). The resulting roots are equal, as if the','line_number':128,'multiline':False]
['text':' discriminant were exactly zero.','line_number':129,'multiline':False]
['text':'','line_number':130,'multiline':False]
['text':' A special case occurs when a==0; see DegenerateQuadraticRoots().','line_number':131,'multiline':False]
['text':' See also QuadraticIsAmbiguous() and RealQuadraticRoots().','line_number':132,'multiline':False]
['text':' Returns the discriminant of the quadratic equation a * x^2 + b * x + c = 0.','line_number':139,'multiline':False]
['text':' Returns true if the discriminant is zero within floating-point error,','line_number':146,'multiline':False]
['text':' in the sense that changing one of the coefficients by epsilon (e.g. a','line_number':147,'multiline':False]
['text':' -> a + a*epsilon) could change the sign of the discriminant. [When the','line_number':148,'multiline':False]
['text':' discriminant is exactly 0 the quadratic is (2*a*x + b)^2 = 0 and the','line_number':149,'multiline':False]
['text':' root is - b / (2*a).]','line_number':150,'multiline':False]
['text':' Discriminants below kTolerance in absolute value are considered zero','line_number':156,'multiline':False]
['text':' because changing the final bit of one of the inputs can change the','line_number':157,'multiline':False]
['text':' sign of the discriminant.','line_number':158,'multiline':False]
['text':' Returns in *r1 and *r2 the roots of a "normal" quadratic equation','line_number':163,'multiline':False]
['text':' whose discriminant (b*b - 4*a*c) is known and positive.  Preconditions','line_number':164,'multiline':False]
['text':' (will DCHECK and return false if not satisfied): a != 0, discriminant > 0.','line_number':165,'multiline':False]
['text':' A case that should have been excluded by the caller.','line_number':173,'multiline':False]
['text':' The discriminant is positive so there are two distinct roots.','line_number':178,'multiline':False]
['text':' According to Numerical Recipes (p. 184), it would be a mistake to','line_number':179,'multiline':False]
['text':' solve for the roots using','line_number':180,'multiline':False]
['text':'','line_number':181,'multiline':False]
['text':'     r1 = 2c / (-b + sqrt(b^2 - 4ac)),','line_number':182,'multiline':False]
['text':'     r2 = 2c / (-b - sqrt(b^2 - 4ac)).','line_number':183,'multiline':False]
['text':'','line_number':184,'multiline':False]
['text':' If a*c is small, then one of the roots above will involve the','line_number':185,'multiline':False]
['text':' subtraction of b from a very nearly equal quantity (the discriminant),','line_number':186,'multiline':False]
['text':' producing a very inaccurate root.  Avoid the risk of cancellation with','line_number':187,'multiline':False]
['text':' the following rearrangement.  (Note we don't use sgn(b) because we','line_number':188,'multiline':False]
['text':' need sgn(0) = +1 or -1.)','line_number':189,'multiline':False]
['text':' If a is very small this produces +/- HUGE_VAL.','line_number':192,'multiline':False]
['text':' q cannot be too small.','line_number':193,'multiline':False]
['text':' Returns the root of the degenerate quadratic equation b * x + c = 0,','line_number':197,'multiline':False]
['text':' following the interface of RealRootsForQuadratic. To be consistent','line_number':198,'multiline':False]
['text':' with that function as a->0, the degenerate quadratic is considered to','line_number':199,'multiline':False]
['text':' have two real roots, one of which is +/- HUGE_VAL and one of which is','line_number':200,'multiline':False]
['text':' -c / b.  If both a and b are 0, so the equation is c = 0, the response','line_number':201,'multiline':False]
['text':' is kNoRealRoots if c != 0 or kAmbiguous if c == 0 (since the','line_number':202,'multiline':False]
['text':' discriminant is zero).','line_number':203,'multiline':False]
['text':' Solves for the real roots of x^3+ax^2+bx+c=0, returns true iff','line_number':209,'multiline':False]
['text':' all three are real, in which case the roots are stored (in any','line_number':210,'multiline':False]
['text':' order) in r1, r2, r3; otherwise, exactly one real root exists and','line_number':211,'multiline':False]
['text':' it is stored in r1.','line_number':212,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':221,'multiline':False]
['text':' Sigmoid','line_number':222,'multiline':False]
['text':'   A sigmoid function is a differentiably s curve that ranges between','line_number':223,'multiline':False]
['text':'   0 and 1:','line_number':224,'multiline':False]
['text':'   f(x) = 1/(1+e^(-lambda x))','line_number':225,'multiline':False]
['text':' --------------------------------------------------------------------','line_number':226,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':231,'multiline':False]
['text':' InverseSigmoid','line_number':232,'multiline':False]
['text':'   Inverts Sigmoid such that InverseSigmoid(Sigmoid(x)) == x for all x','line_number':233,'multiline':False]
['text':'   Note that all inputs must be in (-1, 1)','line_number':234,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':235,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':240,'multiline':False]
['text':' Sigmoid2','line_number':241,'multiline':False]
['text':'   A nicer way of specifying a sigmoid. A sigmoid is a smooth s curve','line_number':242,'multiline':False]
['text':'   that ranges from 0 to 1. We describe a sigmoid  with three values:','line_number':243,'multiline':False]
['text':'','line_number':244,'multiline':False]
['text':'   start: the x value at which f(x) = tolerance','line_number':245,'multiline':False]
['text':'   finish: the x value at which f(x) = 1-tolerance','line_number':246,'multiline':False]
['text':'','line_number':247,'multiline':False]
['text':' So if we was a smoothly transitioning function from, say, x=1 to','line_number':248,'multiline':False]
['text':' x=10 with the property that anything outside the domain [1, 10]','line_number':249,'multiline':False]
['text':' will still be within 10% of either f(1) or f(10) then we set: start','line_number':250,'multiline':False]
['text':' = 1 finish = 10 tolerance = 0.1','line_number':251,'multiline':False]
['text':' --------------------------------------------------------------------','line_number':252,'multiline':False]
['text':' Returns the greatest common divisor of two unsigned integers x and y','line_number':262,'multiline':False]
['text':' Returns the greatest common divisor of two unsigned integers x and y,','line_number':272,'multiline':False]
['text':' and assigns a, and b such that a*x + b*y = gcd(x, y).','line_number':273,'multiline':False]
['text':' Returns the least common multiple of two unsigned integers.  Returns zero','line_number':277,'multiline':False]
['text':' if either is zero.','line_number':278,'multiline':False]
['text':' Converts a non-zero double value representing an odds into its','line_number':289,'multiline':False]
['text':' probability value.','line_number':290,'multiline':False]
['text':' Converts a probability with range [0-1.0) into its odds value.','line_number':296,'multiline':False]
['text':' --------------------------------------------------------------------','line_number':303,'multiline':False]
['text':' ShardsToRead','line_number':304,'multiline':False]
['text':'   Resharding helper.  Suppose we have N input shards and M output','line_number':305,'multiline':False]
['text':'   shards sharded by modulo of the same hash function.  If we want','line_number':306,'multiline':False]
['text':'   to write a subset of the output shards, which input shards should','line_number':307,'multiline':False]
['text':'   we read?','line_number':308,'multiline':False]
['text':'','line_number':309,'multiline':False]
['text':' Inputs:','line_number':310,'multiline':False]
['text':'   shards_to_write gives the desired subset of the M output shards.','line_number':311,'multiline':False]
['text':'   shards_to_read gives the number N of the input shards.','line_number':312,'multiline':False]
['text':' Outputs:','line_number':313,'multiline':False]
['text':'   shards_to_read gives the subset of the N input shards to read.','line_number':314,'multiline':False]
['text':' --------------------------------------------------------------------','line_number':315,'multiline':False]
['text':' --------------------------------------------------------------------','line_number':319,'multiline':False]
['text':' FastIntRound, FastInt64Round','line_number':320,'multiline':False]
['text':'   Fast routines for converting floating-point numbers to integers.','line_number':321,'multiline':False]
['text':'','line_number':322,'multiline':False]
['text':'   These routines are approximately 6 times faster than the default','line_number':323,'multiline':False]
['text':'   implementation of IntRound() on Intel processors (12 times faster on','line_number':324,'multiline':False]
['text':'   the Pentium 3).  They are also more than 5 times faster than simply','line_number':325,'multiline':False]
['text':'   casting a "double" to an "int" using static_cast<int>.  This is','line_number':326,'multiline':False]
['text':'   because casts are defined to truncate towards zero, which on Intel','line_number':327,'multiline':False]
['text':'   processors requires changing the rounding mode and flushing the','line_number':328,'multiline':False]
['text':'   floating-point pipeline (unless programs are compiled specifically','line_number':329,'multiline':False]
['text':'   for the Pentium 4, which has a new instruction to avoid this).','line_number':330,'multiline':False]
['text':'','line_number':331,'multiline':False]
['text':'   Numbers that are halfway between two integers follow the deafult','line_number':332,'multiline':False]
['text':'   rounding mode, which rounds towards the closest even number in case','line_number':333,'multiline':False]
['text':'   of ties.  So for example, FastIntRound(0.5) == 0, but','line_number':334,'multiline':False]
['text':'   FastIntRound(1.5) == 2. These functions should only be used with','line_number':335,'multiline':False]
['text':'   applications that don't care about which way such half-integers are','line_number':336,'multiline':False]
['text':'   rounded.','line_number':337,'multiline':False]
['text':'','line_number':338,'multiline':False]
['text':'   There are template specializations of Round() which call these','line_number':339,'multiline':False]
['text':'   functions (for "int" and "int64" only), but it's safer to call them','line_number':340,'multiline':False]
['text':'   directly.','line_number':341,'multiline':False]
['text':'','line_number':342,'multiline':False]
['text':'   This functions are equivalent to rint() and llrint().','line_number':343,'multiline':False]
['text':' --------------------------------------------------------------------','line_number':344,'multiline':False]
['text':' This function is not templatized because gcc doesn't seem to be able','line_number':347,'multiline':False]
['text':' to deal with inline assembly code in templatized functions, and there','line_number':348,'multiline':False]
['text':' is no advantage to passing an argument type of "float" on Intel','line_number':349,'multiline':False]
['text':' architectures anyway.','line_number':350,'multiline':False]
['text':' SSE2.','line_number':354,'multiline':False]
['text':' Output operand is a register','line_number':358,'multiline':False]
['text':' Input operand is an xmm register','line_number':359,'multiline':False]
['text':' FPU stack.  Adapted from /usr/include/bits/mathinline.h.','line_number':362,'multiline':False]
['text':' Output operand is a memory location','line_number':366,'multiline':False]
['text':' Input operand is top of FP stack','line_number':367,'multiline':False]
['text':' Clobbers (pops) top of FP stack','line_number':368,'multiline':False]
['text':' if defined __x86_64__ || ...','line_number':370,'multiline':False]
['text':' if defined __GNUC__ && ...','line_number':373,'multiline':False]
['text':' SSE2.','line_number':379,'multiline':False]
['text':' Output operand is a register','line_number':383,'multiline':False]
['text':' Input operand is an xmm register','line_number':384,'multiline':False]
['text':' There is no CVTSD2SI in i386 to produce a 64 bit int, even with SSE2.','line_number':387,'multiline':False]
['text':' FPU stack.  Adapted from /usr/include/bits/mathinline.h.','line_number':388,'multiline':False]
['text':' Output operand is a memory location','line_number':392,'multiline':False]
['text':' Input operand is top of FP stack','line_number':393,'multiline':False]
['text':' Clobbers (pops) top of FP stack','line_number':394,'multiline':False]
['text':' if defined __i386__','line_number':396,'multiline':False]
['text':' if defined __GNUC__ && ...','line_number':399,'multiline':False]
['text':' Return Not a Number.','line_number':402,'multiline':False]
['text':' Consider instead using MathLimits<double>::kNaN directly.','line_number':403,'multiline':False]
['text':' the sine cardinal function','line_number':406,'multiline':False]
['text':' Returns an approximation An for the n-th element of the harmonic','line_number':412,'multiline':False]
['text':' serices Hn = 1 + ... + 1/n.  Sets error e such that |An-Hn| < e.','line_number':413,'multiline':False]
['text':' Returns Stirling's Approximation for log(n!) which has an error','line_number':416,'multiline':False]
['text':' of at worst 1/(1260*n^5).','line_number':417,'multiline':False]
['text':' Returns the log of the binomial coefficient C(n, k), known in the','line_number':420,'multiline':False]
['text':' vernacular as "N choose K".  Why log?  Because the integer number','line_number':421,'multiline':False]
['text':' for non-trivial N and K would overflow.','line_number':422,'multiline':False]
['text':' Note that if k > 15, this uses Stirling's approximation of log(n!).','line_number':423,'multiline':False]
['text':' The relative error is about 1/(1260*k^5) (which is 7.6e-10 when k=16).','line_number':424,'multiline':False]
['text':' Rounds "f" to the nearest float which has its last "bits" bits of','line_number':427,'multiline':False]
['text':' the mantissa set to zero.  This rounding will introduce a','line_number':428,'multiline':False]
['text':' fractional error of at most 2^(bits - 24).  Useful for values','line_number':429,'multiline':False]
['text':' stored in compressed files, when super-accurate numbers aren't','line_number':430,'multiline':False]
['text':' needed and the random-looking low-order bits foil compressors.','line_number':431,'multiline':False]
['text':' This routine should be really fast when inlined with "bits" set','line_number':432,'multiline':False]
['text':' to a constant.','line_number':433,'multiline':False]
['text':' Precondition: 1 <= bits <= 23, f != NaN','line_number':434,'multiline':False]
['text':' Set low-order "bits" bits to zero.','line_number':438,'multiline':False]
['text':' Round mantissa up if we need to.  Note that we do round-to-even,','line_number':441,'multiline':False]
['text':' a.k.a. round-up-if-odd.','line_number':442,'multiline':False]
['text':' NOTE: overflow does a really nice thing here - if all the','line_number':447,'multiline':False]
['text':' rest of the mantissa bits are 1, the carry carries over into','line_number':448,'multiline':False]
['text':' the exponent and increments it by 1, which is exactly what we','line_number':449,'multiline':False]
['text':' want.  It even gets to +/-INF properly.','line_number':450,'multiline':False]
['text':' Same, but for doubles.  1 <= bits <= 52, error at most 2^(bits - 53).','line_number':454,'multiline':False]
['text':' Largest of two values.','line_number':466,'multiline':False]
['text':' Works correctly for special floating point values.','line_number':467,'multiline':False]
['text':' Note: 0.0 and -0.0 are not differentiated by Max (Max(0.0, -0.0) is -0.0),','line_number':468,'multiline':False]
['text':' which should be OK because, although they (can) have different','line_number':469,'multiline':False]
['text':' bit representation, they are observably the same when examined','line_number':470,'multiline':False]
['text':' with arithmetic and (in)equality operators.','line_number':471,'multiline':False]
['text':' Smallest of two values','line_number':477,'multiline':False]
['text':' Works correctly for special floating point values.','line_number':478,'multiline':False]
['text':' Note: 0.0 and -0.0 are not differentiated by Min (Min(-0.0, 0.0) is 0.0),','line_number':479,'multiline':False]
['text':' which should be OK: see the comment for Max above.','line_number':480,'multiline':False]
['text':' Absolute value of x','line_number':486,'multiline':False]
['text':' Works correctly for unsigned types and','line_number':487,'multiline':False]
['text':' for special floating point values.','line_number':488,'multiline':False]
['text':' Note: 0.0 and -0.0 are not differentiated by Abs (Abs(0.0) is -0.0),','line_number':489,'multiline':False]
['text':' which should be OK: see the comment for Max above.','line_number':490,'multiline':False]
['text':' The sign of x','line_number':496,'multiline':False]
['text':' (works for unsigned types and special floating point values as well):','line_number':497,'multiline':False]
['text':'   -1 if x < 0,','line_number':498,'multiline':False]
['text':'   +1 if x > 0,','line_number':499,'multiline':False]
['text':'    0 if x = 0.','line_number':500,'multiline':False]
['text':'  nan if x is nan.','line_number':501,'multiline':False]
['text':' Returns the square of x','line_number':507,'multiline':False]
['text':' Absolute value of the difference between two numbers.','line_number':513,'multiline':False]
['text':' Works correctly for signed types and special floating point values.','line_number':514,'multiline':False]
['text':' CAVEAT: Floating point computation instability for x86 CPUs','line_number':520,'multiline':False]
['text':' can frequently stem from the difference of when floating point values','line_number':521,'multiline':False]
['text':' are transferred from registers to memory and back,','line_number':522,'multiline':False]
['text':' which can depend simply on the level of optimization.','line_number':523,'multiline':False]
['text':' The reason is that the registers use a higher-precision representation.','line_number':524,'multiline':False]
['text':' Hence, instead of relying on approximate floating point equality below','line_number':525,'multiline':False]
['text':' it might be better to reorganize the code with volatile modifiers','line_number':526,'multiline':False]
['text':' for the floating point variables so as to control when','line_number':527,'multiline':False]
['text':' the loss of precision occurs.','line_number':528,'multiline':False]
['text':' If two (usually floating point) numbers are within a certain','line_number':530,'multiline':False]
['text':' absolute margin of error.','line_number':531,'multiline':False]
['text':' NOTE: this "misbehaves" is one is trying to capture provisons for errors','line_number':532,'multiline':False]
['text':' that are relative, i.e. larger if the numbers involved are larger.','line_number':533,'multiline':False]
['text':' Consider using WithinFraction or WithinFractionOrMargin below.','line_number':534,'multiline':False]
['text':'','line_number':535,'multiline':False]
['text':' This and other Within* NearBy* functions below','line_number':536,'multiline':False]
['text':' work correctly for signed types and special floating point values.','line_number':537,'multiline':False]
['text':' this is a little faster than x <= y + margin  &&  x >= y - margin','line_number':541,'multiline':False]
['text':' If two (usually floating point) numbers are within a certain','line_number':545,'multiline':False]
['text':' fraction of their magnitude.','line_number':546,'multiline':False]
['text':' CAVEAT: Although this works well if computation errors are relative','line_number':547,'multiline':False]
['text':' both for large magnitude numbers > 1 and for small magnitude numbers < 1,','line_number':548,'multiline':False]
['text':' zero is never within a fraction of any','line_number':549,'multiline':False]
['text':' non-zero finite number (fraction is required to be < 1).','line_number':550,'multiline':False]
['text':' If two (usually floating point) numbers are within a certain','line_number':554,'multiline':False]
['text':' fraction of their magnitude or within a certain absolute margin of error.','line_number':555,'multiline':False]
['text':' This is the same as the following but faster:','line_number':556,'multiline':False]
['text':'   WithinFraction(x, y, fraction)  ||  WithinMargin(x, y, margin)','line_number':557,'multiline':False]
['text':' E.g. WithinFraction(0.0, 1e-10, 1e-5) is false but','line_number':558,'multiline':False]
['text':'      WithinFractionOrMargin(0.0, 1e-10, 1e-5, 1e-5) is true.','line_number':559,'multiline':False]
['text':' NearBy* functions below are geared as replacements for CHECK_EQ()','line_number':564,'multiline':False]
['text':' over floating-point numbers.','line_number':565,'multiline':False]
['text':' Same as WithinMargin(x, y, MathLimits<T>::kStdError)','line_number':567,'multiline':False]
['text':' Works as == for integer types.','line_number':568,'multiline':False]
['text':' Same as WithinFraction(x, y, MathLimits<T>::kStdError)','line_number':574,'multiline':False]
['text':' Works as == for integer types.','line_number':575,'multiline':False]
['text':' Same as WithinFractionOrMargin(x, y, MathLimits<T>::kStdError,','line_number':581,'multiline':False]
['text':'                                      MathLimits<T>::kStdError)','line_number':582,'multiline':False]
['text':' Works as == for integer types.','line_number':583,'multiline':False]
['text':' Tests whether two values are close enough to each other to be considered','line_number':590,'multiline':False]
['text':' equal. This function is intended to be used mainly as a replacement for','line_number':591,'multiline':False]
['text':' equality tests of floating point values in CHECK()s, and as a replacement','line_number':592,'multiline':False]
['text':' for equality comparison against golden files. It is the same as == for','line_number':593,'multiline':False]
['text':' integer types. The purpose of AlmostEquals() is to avoid false positive','line_number':594,'multiline':False]
['text':' error reports in unit tests and regression tests due to minute differences','line_number':595,'multiline':False]
['text':' in floating point arithmetic (for example, due to a different compiler).','line_number':596,'multiline':False]
['text':'','line_number':597,'multiline':False]
['text':' We cannot use simple equality to compare floating point values','line_number':598,'multiline':False]
['text':' because floating point expressions often accumulate inaccuracies, and','line_number':599,'multiline':False]
['text':' new compilers may introduce further variations in the values.','line_number':600,'multiline':False]
['text':'','line_number':601,'multiline':False]
['text':' Two values x and y are considered "almost equals" if:','line_number':602,'multiline':False]
['text':' (a) Both values are very close to zero: x and y are in the range','line_number':603,'multiline':False]
['text':'     [-standard_error, standard_error]','line_number':604,'multiline':False]
['text':'     Normal calculations producing these values are likely to be dealing','line_number':605,'multiline':False]
['text':'     with meaningless residual values.','line_number':606,'multiline':False]
['text':' -or-','line_number':607,'multiline':False]
['text':' (b) The difference between the values is small:','line_number':608,'multiline':False]
['text':'     abs(x - y) <= standard_error','line_number':609,'multiline':False]
['text':' -or-','line_number':610,'multiline':False]
['text':' (c) The values are finite and the relative difference between them is','line_number':611,'multiline':False]
['text':'     small:','line_number':612,'multiline':False]
['text':'     abs (x - y) <= standard_error * max(abs(x), abs(y))','line_number':613,'multiline':False]
['text':' -or-','line_number':614,'multiline':False]
['text':' (d) The values are both positive infinity or both negative infinity.','line_number':615,'multiline':False]
['text':'','line_number':616,'multiline':False]
['text':' Cases (b) and (c) are the same as MathUtils::NearByFractionOrMargin(x, y),','line_number':617,'multiline':False]
['text':' for finite values of x and y.','line_number':618,'multiline':False]
['text':'','line_number':619,'multiline':False]
['text':' standard_error is the corresponding MathLimits<T>::kStdError constant.','line_number':620,'multiline':False]
['text':' It is equivalent to 5 bits of mantissa error. See','line_number':621,'multiline':False]
['text':' google3/util/math/mathlimits.cc.','line_number':622,'multiline':False]
['text':'','line_number':623,'multiline':False]
['text':' Caveat:','line_number':624,'multiline':False]
['text':' AlmostEquals() is not appropriate for checking long sequences of','line_number':625,'multiline':False]
['text':' operations where errors may cascade (like extended sums or matrix','line_number':626,'multiline':False]
['text':' computations), or where significant cancellation may occur','line_number':627,'multiline':False]
['text':' (e.g., the expression (x+y)-x, where x is much larger than y).','line_number':628,'multiline':False]
['text':' Both cases may produce errors in excess of standard_error.','line_number':629,'multiline':False]
['text':' In any case, you should not test the results of calculations which have','line_number':630,'multiline':False]
['text':' not been vetted for possible cancellation errors and the like.','line_number':631,'multiline':False]
['text':' Covers +inf and -inf, and is a shortcut for finite values.','line_number':634,'multiline':False]
['text':' Returns the clamped value to be between low and high inclusively.','line_number':646,'multiline':False]
['text':' Clamps value to be between min and max inclusively.','line_number':652,'multiline':False]
['text':' not just "0 <= fraction" to fool the compiler for unsigned types','line_number':661,'multiline':False]
['text':' Template specialization will convert the if() condition to a constant,','line_number':664,'multiline':False]
['text':' which will cause the compiler to generate code for either the "if" part','line_number':665,'multiline':False]
['text':' or the "then" part.  In this way we avoid a compiler warning','line_number':666,'multiline':False]
['text':' about a potential integer overflow in crosstool v12 (gcc 4.3.1).','line_number':667,'multiline':False]
['text':' IsFinite checks are to make kPosInf and kNegInf not within fraction','line_number':671,'multiline':False]
['text':' not just "0 <= fraction" to fool the compiler for unsigned types','line_number':680,'multiline':False]
['text':' Template specialization will convert the if() condition to a constant,','line_number':683,'multiline':False]
['text':' which will cause the compiler to generate code for either the "if" part','line_number':684,'multiline':False]
['text':' or the "then" part.  In this way we avoid a compiler warning','line_number':685,'multiline':False]
['text':' about a potential integer overflow in crosstool v12 (gcc 4.3.1).','line_number':686,'multiline':False]
['text':' IsFinite checks are to make kPosInf and kNegInf not within fraction','line_number':690,'multiline':False]
['text':' UTIL_MATH_MATHUTIL_H__','line_number':698,'multiline':False]
