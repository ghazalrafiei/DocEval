['text':' Copyright 2009 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':' Define storage for constants.','line_number':20,'multiline':False]
['text':' To simplify the overflow/underflow logic, we limit the exponent and','line_number':29,'multiline':False]
['text':' precision range so that (2 * bn_exp_) does not overflow an "int".  We take','line_number':30,'multiline':False]
['text':' advantage of this, for example, by only checking for overflow/underflow','line_number':31,'multiline':False]
['text':' *after* multiplying two numbers.','line_number':32,'multiline':False]
['text':' We define a few simple extensions to the BIGNUM interface.  In some cases','line_number':38,'multiline':False]
['text':' these depend on BIGNUM internal fields, so they might require tweaking if','line_number':39,'multiline':False]
['text':' the BIGNUM implementation changes significantly.','line_number':40,'multiline':False]
['text':' Set a BIGNUM to the given unsigned 64-bit value.','line_number':42,'multiline':False]
['text':' Return the absolute value of a BIGNUM as a 64-bit unsigned integer.','line_number':54,'multiline':False]
['text':' Requires that BIGNUM fits into 64 bits.','line_number':55,'multiline':False]
['text':' Count the number of low-order zero bits in the given BIGNUM (ignoring its','line_number':69,'multiline':False]
['text':' sign).  Returns 0 if the argument is zero.','line_number':70,'multiline':False]
['text':' The following code is much simpler than messing about with bit masks,','line_number':95,'multiline':False]
['text':' has the advantage of handling denormalized numbers and zero correctly,','line_number':96,'multiline':False]
['text':' and is actually quite efficient (at least compared to the rest of this','line_number':97,'multiline':False]
['text':' code).  "f" is a fraction in the range [0.5, 1), so if we shift it left','line_number':98,'multiline':False]
['text':' by the number of mantissa bits in a double (53, including the leading','line_number':99,'multiline':False]
['text':' "1") then the result is always an integer.','line_number':100,'multiline':False]
['text':' Note that this works even for INT_MIN because the parameter type for','line_number':113,'multiline':False]
['text':' BN_set_word() is unsigned.','line_number':114,'multiline':False]
['text':' If the mantissa has too many bits, we need to round it.','line_number':173,'multiline':False]
['text':' We rely on ldexp() to handle overflow and underflow.  (It will return a','line_number':190,'multiline':False]
['text':' signed zero or infinity if the result is too small or too large.)','line_number':191,'multiline':False]
['text':' The "kRoundTiesToEven" mode requires at least 2 bits of precision','line_number':196,'multiline':False]
['text':' (otherwise both adjacent representable values may be odd).','line_number':197,'multiline':False]
['text':' The following test also catches zero, infinity, and NaN.','line_number':201,'multiline':False]
['text':' Round by removing the appropriate number of bits from the mantissa.  Note','line_number':205,'multiline':False]
['text':' that if the value is rounded up to a power of 2, the high-order bit','line_number':206,'multiline':False]
['text':' position may increase, but in that case Canonicalize() will remove at','line_number':207,'multiline':False]
['text':' least one zero bit and so the output will still have prec() <= max_prec.','line_number':208,'multiline':False]
['text':' If the exponent is already large enough, or the value is zero, infinity,','line_number':216,'multiline':False]
['text':' or NaN, then there is nothing to do.','line_number':217,'multiline':False]
['text':' Convert rounding up/down to toward/away from zero, so that we don't need','line_number':222,'multiline':False]
['text':' to consider the sign of the number from this point onward.','line_number':223,'multiline':False]
['text':' Rounding consists of right-shifting the mantissa by "shift", and then','line_number':230,'multiline':False]
['text':' possibly incrementing the result (depending on the rounding mode, the','line_number':231,'multiline':False]
['text':' bits that were discarded, and sometimes the lowest kept bit).  The','line_number':232,'multiline':False]
['text':' following code figures out whether we need to increment.','line_number':233,'multiline':False]
['text':' Never increment.','line_number':237,'multiline':False]
['text':' Increment if the highest discarded bit is 1.','line_number':239,'multiline':False]
['text':' Increment unless all discarded bits are zero.','line_number':243,'multiline':False]
['text':' Let "w/xyz" denote a mantissa where "w" is the lowest kept bit and','line_number':248,'multiline':False]
['text':' "xyz" are the discarded bits.  Then using regexp notation:','line_number':249,'multiline':False]
['text':'    ./0.*       ->    Don't increment (fraction < 1/2)','line_number':250,'multiline':False]
['text':'    0/10*       ->    Don't increment (fraction = 1/2, kept part even)','line_number':251,'multiline':False]
['text':'    1/10*       ->    Increment (fraction = 1/2, kept part odd)','line_number':252,'multiline':False]
['text':'    ./1.*1.*    ->    Increment (fraction > 1/2)','line_number':253,'multiline':False]
['text':' The simplest bound is','line_number':271,'multiline':False]
['text':'','line_number':272,'multiline':False]
['text':'    d <= 1 + ceil(prec * log10(2))','line_number':273,'multiline':False]
['text':'','line_number':274,'multiline':False]
['text':' The following bound is tighter by 0.5 digits on average, but requires','line_number':275,'multiline':False]
['text':' the exponent to be known as well:','line_number':276,'multiline':False]
['text':'','line_number':277,'multiline':False]
['text':'    d <= ceil(exp * log10(2)) - floor((exp - prec) * log10(2))','line_number':278,'multiline':False]
['text':'','line_number':279,'multiline':False]
['text':' Since either of these bounds can be too large by 0, 1, or 2 digits, we','line_number':280,'multiline':False]
['text':' stick with the simpler first bound.','line_number':281,'multiline':False]
['text':' Numbers are always formatted with at least this many significant digits.','line_number':285,'multiline':False]
['text':' This prevents small integers from being formatted in exponential notation','line_number':286,'multiline':False]
['text':' (e.g. 1024 formatted as 1e+03), and also avoids the confusion of having','line_number':287,'multiline':False]
['text':' supposedly "high precision" numbers formatted with just 1 or 2 digits','line_number':288,'multiline':False]
['text':' (e.g. 1/512 == 0.001953125 formatted as 0.002).','line_number':289,'multiline':False]
['text':' We use the standard '%g' formatting rules.  If the exponent is less than','line_number':310,'multiline':False]
['text':' -4 or greater than or equal to the requested precision (i.e., max_digits)','line_number':311,'multiline':False]
['text':' then we use exponential notation.','line_number':312,'multiline':False]
['text':'','line_number':313,'multiline':False]
['text':' But since "exp10" is the base-10 exponent corresponding to a mantissa in','line_number':314,'multiline':False]
['text':' the range [0.1, 1), whereas the '%g' rules assume a mantissa in the range','line_number':315,'multiline':False]
['text':' [1.0, 10), we need to adjust these parameters by 1.','line_number':316,'multiline':False]
['text':' Use exponential format.','line_number':318,'multiline':False]
['text':' Use fixed format.  We split this into two cases depending on whether','line_number':328,'multiline':False]
['text':' the integer portion is non-zero or not.','line_number':329,'multiline':False]
['text':' Increment an unsigned integer represented as a string of ASCII digits.','line_number':352,'multiline':False]
['text':' Convert the value to the form (bn * (10 ** bn_exp10)) where "bn" is a','line_number':364,'multiline':False]
['text':' positive integer (BIGNUM).','line_number':365,'multiline':False]
['text':' The easy case: bn = bn_ * (2 ** bn_exp_)), bn_exp10 = 0.','line_number':369,'multiline':False]
['text':' Set bn = bn_ * (5 ** -bn_exp_) and bn_exp10 = bn_exp_.  This is','line_number':373,'multiline':False]
['text':' equivalent to the original value of (bn_ * (2 ** bn_exp_)).','line_number':374,'multiline':False]
['text':' Now convert "bn" to a decimal string.','line_number':385,'multiline':False]
['text':' Check whether we have too many digits and round if necessary.','line_number':389,'multiline':False]
['text':' Standard "printf" formatting rounds ties to an even number.  This means','line_number':395,'multiline':False]
['text':' that we round up (away from zero) if highest discarded digit is '5' or','line_number':396,'multiline':False]
['text':' more, unless all other discarded digits are zero in which case we round','line_number':397,'multiline':False]
['text':' up only if the lowest kept digit is odd.','line_number':398,'multiline':False]
['text':' This can increase the number of digits by 1, but in that case at','line_number':402,'multiline':False]
['text':' least one trailing zero will be stripped off below.','line_number':403,'multiline':False]
['text':' Adjust the base-10 exponent to reflect the digits we have removed.','line_number':406,'multiline':False]
['text':' Now strip any trailing zeros.','line_number':411,'multiline':False]
['text':' Finally, we adjust the base-10 exponent so that the mantissa is a','line_number':421,'multiline':False]
['text':' fraction in the range [0.1, 1) rather than an integer.','line_number':422,'multiline':False]
['text':' Handle zero, infinity, and NaN according to IEEE 754-2008.','line_number':456,'multiline':False]
['text':' Adding two infinities with opposite sign yields NaN.','line_number':460,'multiline':False]
['text':' Adding two zeros with the same sign preserves the sign.','line_number':467,'multiline':False]
['text':' Adding two zeros of opposite sign produces +0.','line_number':469,'multiline':False]
['text':' Swap the numbers if necessary so that "a" has the larger bn_exp_.','line_number':475,'multiline':False]
['text':' Shift "a" if necessary so that both values have the same bn_exp_.','line_number':480,'multiline':False]
['text':' The only field of "a" used below is bn_.','line_number':484,'multiline':False]
['text':' Note that the BIGNUM documentation is out of date -- all methods now','line_number':491,'multiline':False]
['text':' allow the result to be the same as any input argument, so it is okay if','line_number':492,'multiline':False]
['text':' (a == &r) due to the shift above.','line_number':493,'multiline':False]
['text':' The magnitude of "b" was larger.','line_number':498,'multiline':False]
['text':' They were equal, or the magnitude of "a" was larger.','line_number':502,'multiline':False]
['text':' Underflow/overflow occurs if exp() is not in [kMinExp, kMaxExp].','line_number':513,'multiline':False]
['text':' We also convert a zero mantissa to signed zero.','line_number':514,'multiline':False]
['text':' Remove any low-order zero bits from the mantissa.','line_number':521,'multiline':False]
['text':' If the mantissa has too many bits, we replace it by NaN to indicate','line_number':529,'multiline':False]
['text':' that an inexact calculation has occurred.','line_number':530,'multiline':False]
['text':' Handle zero, infinity, and NaN according to IEEE 754-2008.','line_number':539,'multiline':False]
['text':' Infinity times zero yields NaN.','line_number':543,'multiline':False]
['text':' NaN is not equal to anything, not even itself.','line_number':565,'multiline':False]
['text':' Since Canonicalize() strips low-order zero bits, all other cases','line_number':568,'multiline':False]
['text':' (including non-normal values) require bn_exp_ to be equal.','line_number':569,'multiline':False]
['text':' Positive and negative zero are equal.','line_number':572,'multiline':False]
['text':' Otherwise, the signs and mantissas must match.  Note that non-normal','line_number':575,'multiline':False]
['text':' values such as infinity have a mantissa of zero.','line_number':576,'multiline':False]
['text':' Handle the zero/infinity cases (NaN has already been done).','line_number':588,'multiline':False]
['text':' If the high-order bit positions differ, we are done.','line_number':591,'multiline':False]
['text':' Otherwise shift one of the two values so that they both have the same','line_number':594,'multiline':False]
['text':' bn_exp_ and then compare the mantissas.','line_number':595,'multiline':False]
['text':' NaN is unordered compared to everything, including itself.','line_number':601,'multiline':False]
['text':' Positive and negative zero are equal.','line_number':603,'multiline':False]
['text':' Otherwise, anything negative is less than anything positive.','line_number':605,'multiline':False]
['text':' Now we just compare absolute values.','line_number':607,'multiline':False]
['text':' If one argument is NaN, return the other argument.','line_number':616,'multiline':False]
['text':' Not required by IEEE 754, but we prefer +0 over -0.','line_number':619,'multiline':False]
['text':' If one argument is NaN, return the other argument.','line_number':627,'multiline':False]
['text':' Not required by IEEE 754, but we prefer -0 over +0.','line_number':630,'multiline':False]
['text':' This formulation has the correct behavior for NaNs.','line_number':638,'multiline':False]
['text':' If the unsigned value has more than 63 bits it is always clamped.','line_number':673,'multiline':False]
['text':' If a == 0, exp should be zero.  If a.is_inf() or a.is_nan(), exp is not','line_number':705,'multiline':False]
['text':' defined but the glibc implementation returns zero.','line_number':706,'multiline':False]
['text':' To prevent integer overflow, we first clamp "exp" so that','line_number':717,'multiline':False]
['text':' (kMinExp - 1) <= (a_exp + exp) <= (kMaxExp + 1).','line_number':718,'multiline':False]
['text':' Now modify the exponent and check for overflow/underflow.','line_number':723,'multiline':False]
['text':' a.exp() assumes the significand is in the range [0.5, 1).','line_number':734,'multiline':False]
['text':' Even if a < 0.','line_number':740,'multiline':False]
['text':' exp() assumes the significand is in the range [0.5,1).','line_number':742,'multiline':False]
