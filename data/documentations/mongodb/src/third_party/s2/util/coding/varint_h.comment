['text':' Copyright 2001 and onwards Google Inc.','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' Raw support for varint encoding.  Higher level interfaces are','line_number':3,'multiline':False]
['text':' provided by Encoder/Decoder/IOBuffer.  Clients should typically use','line_number':4,'multiline':False]
['text':' those interfaces, unless speed is paramount.','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':' If decoding speed is very important, consider using PrefixVarint instead.','line_number':7,'multiline':False]
['text':' It has the same compression ratio, but generally faster decoding.','line_number':8,'multiline':False]
['text':'','line_number':9,'multiline':False]
['text':' Provided routines:','line_number':10,'multiline':False]
['text':'      vi_parse32_unchecked','line_number':11,'multiline':False]
['text':'      vi_parse64_unchecked','line_number':12,'multiline':False]
['text':'      vi_encode32_unchecked','line_number':13,'multiline':False]
['text':'      vi_encode64_unchecked','line_number':14,'multiline':False]
['text':' Just a namespace, not a real class','line_number':24,'multiline':False]
['text':' Maximum lengths of varint encoding of uint32 and uint64','line_number':27,'multiline':False]
['text':' = 5;','line_number':28,'multiline':False]
['text':' = 10;','line_number':29,'multiline':False]
['text':' REQUIRES   "ptr" points to a buffer of length at least kMaxXX','line_number':31,'multiline':False]
['text':' EFFECTS    Scan next varint from "ptr" and store in OUTPUT.','line_number':32,'multiline':False]
['text':'            Returns pointer just past last read byte.  Returns','line_number':33,'multiline':False]
['text':'            NULL if a valid varint value was not found.','line_number':34,'multiline':False]
['text':' A fully inlined version of Parse32: useful in the most time critical','line_number':38,'multiline':False]
['text':' routines, but its code size is large','line_number':39,'multiline':False]
['text':' REQUIRES   "ptr" points just past the last byte of a varint-encoded value.','line_number':42,'multiline':False]
['text':' REQUIRES   A second varint must be encoded just before the one we parse,','line_number':43,'multiline':False]
['text':'            OR "base" must point to the first byte of the one we parse.','line_number':44,'multiline':False]
['text':' REQUIRES   Bytes [base, ptr-1] are readable','line_number':45,'multiline':False]
['text':'','line_number':46,'multiline':False]
['text':' EFFECTS    Scan backwards from "ptr" and store in OUTPUT. Stop at the last','line_number':47,'multiline':False]
['text':'            byte of the previous varint, OR at "base", whichever one comes','line_number':48,'multiline':False]
['text':'            first. Returns pointer to the first byte of the decoded varint','line_number':49,'multiline':False]
['text':'            NULL if a valid varint value was not found.','line_number':50,'multiline':False]
['text':' Attempts to parse a varint32 from a prefix of the bytes in [ptr,limit-1].','line_number':56,'multiline':False]
['text':' Never reads a character at or beyond limit.  If a valid/terminated varint32','line_number':57,'multiline':False]
['text':' was found in the range, stores it in *OUTPUT and returns a pointer just','line_number':58,'multiline':False]
['text':' past the last byte of the varint32. Else returns NULL.  On success,','line_number':59,'multiline':False]
['text':' "result <= limit".','line_number':60,'multiline':False]
['text':' REQUIRES   "ptr" points to the first byte of a varint-encoded value.','line_number':66,'multiline':False]
['text':' EFFECTS     Scans until the end of the varint and returns a pointer just','line_number':67,'multiline':False]
['text':'             past the last byte. Returns NULL if "ptr" does not point to','line_number':68,'multiline':False]
['text':'             a valid varint value.','line_number':69,'multiline':False]
['text':' REQUIRES   "ptr" points just past the last byte of a varint-encoded value.','line_number':73,'multiline':False]
['text':' REQUIRES   A second varint must be encoded just before the one we parse,','line_number':74,'multiline':False]
['text':'            OR "base" must point to the first byte of the one we parse.','line_number':75,'multiline':False]
['text':' REQUIRES   Bytes [base, ptr-1] are readable','line_number':76,'multiline':False]
['text':'','line_number':77,'multiline':False]
['text':' EFFECTS    Scan backwards from "ptr" and stop at the last byte of the','line_number':78,'multiline':False]
['text':'            previous varint, OR at "base", whichever one comes first.','line_number':79,'multiline':False]
['text':'            Returns pointer to the first byte of the skipped varint or','line_number':80,'multiline':False]
['text':'            NULL if a valid varint value was not found.','line_number':81,'multiline':False]
['text':' REQUIRES   "ptr" points to a buffer of length sufficient to hold "v".','line_number':85,'multiline':False]
['text':' EFFECTS    Encodes "v" into "ptr" and returns a pointer to the','line_number':86,'multiline':False]
['text':'            byte just past the last encoded byte.','line_number':87,'multiline':False]
['text':' A fully inlined version of Encode32: useful in the most time critical','line_number':91,'multiline':False]
['text':' routines, but its code size is large','line_number':92,'multiline':False]
['text':' EFFECTS    Returns the encoding length of the specified value.','line_number':95,'multiline':False]
['text':' EFFECTS    Appends the varint representation of "value" to "*s".','line_number':101,'multiline':False]
['text':' EFFECTS    Encodes a pair of values to "*s".  The encoding','line_number':105,'multiline':False]
['text':'            is done by weaving together 4 bit groups of','line_number':106,'multiline':False]
['text':'            each number into a single 64 bit value, and then','line_number':107,'multiline':False]
['text':'            encoding this value as a Varint64 value.  This means','line_number':108,'multiline':False]
['text':'            that if both a and b are small, both values can be','line_number':109,'multiline':False]
['text':'            encoded in a single byte.','line_number':110,'multiline':False]
['text':' Decode and sum up a sequence of deltas until the sum >= goal.','line_number':114,'multiline':False]
['text':' It is significantly faster than calling ParseXXInline in a loop.','line_number':115,'multiline':False]
['text':' NOTE(user): The code does NO error checking, it assumes all the','line_number':116,'multiline':False]
['text':' deltas are valid and the sum of deltas will never exceed kint64max. The','line_number':117,'multiline':False]
['text':' code works for both 32bits and 64bits varint, and on 64 bits machines,','line_number':118,'multiline':False]
['text':' the 64 bits version is almost always faster. Thus we only have a 64 bits','line_number':119,'multiline':False]
['text':' interface here. The interface is slightly different from the other','line_number':120,'multiline':False]
['text':' functions in that it requires *signed* integers.','line_number':121,'multiline':False]
['text':' REQUIRES   "ptr" points to the first byte of a varint-encoded delta.','line_number':122,'multiline':False]
['text':'            The sum of deltas >= goal (the code does NO boundary check).','line_number':123,'multiline':False]
['text':'            goal is positive and fit into a signed int64.','line_number':124,'multiline':False]
['text':' EFFECTS    Returns a pointer just past last read byte.','line_number':125,'multiline':False]
['text':'            "out" stores the actual sum.','line_number':126,'multiline':False]
['text':' Mapping from rightmost bit set to the number of bytes required','line_number':147,'multiline':False]
['text':'**** Implementation details; clients should ignore ****','line_number':151,'multiline':True]
['text':' Fast path','line_number':155,'multiline':False]
['text':' Already checked in inlined prelude','line_number':159,'multiline':False]
['text':' Value is too long to be a varint32','line_number':164,'multiline':False]
['text':' Fast path for inlining','line_number':171,'multiline':False]
['text':' Fast path for inlining','line_number':183,'multiline':False]
['text':' value is too long to be a varint32','line_number':201,'multiline':False]
['text':' Fast path','line_number':207,'multiline':False]
['text':' Value is too long to be a varint32','line_number':221,'multiline':False]
['text':' value is too long to be a varint32','line_number':239,'multiline':False]
['text':' Slow version with bounds checks','line_number':251,'multiline':False]
['text':' Value is too long to be a varint32','line_number':265,'multiline':False]
['text':' value is too long to be a varint64','line_number':296,'multiline':False]
['text':' Fast path','line_number':302,'multiline':False]
['text':' Value is too long to be a varint64','line_number':330,'multiline':False]
['text':' Fast path','line_number':342,'multiline':False]
['text':' value is too long to be a varint64','line_number':355,'multiline':False]
['text':' Special case for small values','line_number':365,'multiline':False]
['text':' Find the rightmost bit set, and index into a small table','line_number':376,'multiline':False]
['text':' "ro" for the input spec means the input can come from either a','line_number':378,'multiline':False]
['text':' register ("r") or offsetable memory ("o").','line_number':379,'multiline':False]
['text':'','line_number':380,'multiline':False]
['text':' If "n == 0", the "bsr" instruction sets the "Z" flag, so we','line_number':381,'multiline':False]
['text':' conditionally move "-1" into the result.','line_number':382,'multiline':False]
['text':'','line_number':383,'multiline':False]
['text':' Note: the cmovz was introduced on PIII's, and may not work on','line_number':384,'multiline':False]
['text':' older machines.','line_number':385,'multiline':False]
['text':' Output spec, early clobber','line_number':390,'multiline':False]
['text':' Input spec','line_number':391,'multiline':False]
['text':' Clobbers condition-codes','line_number':392,'multiline':False]
['text':'
    The following version is about 1.5X the code size, but is faster than
    the loop below.

  if (v < (1u << 14)) {
    if (v < (1u << 7)) {
      return 1;
    } else {
      return 2;
    }
  } else {
    if (v < (1u << 28)) {
      if (v < (1u << 21)) {
        return 3;
      } else {
        return 4;
      }
    } else {
      return 5;
    }
  }
  ','line_number':399,'multiline':True]
['text':' Each byte of output stores 7 bits of "v" until "v" becomes zero','line_number':422,'multiline':False]
['text':' Inline the fast-path for single-character output, but fall back to the .cc','line_number':433,'multiline':False]
['text':' file for the full version. The size<capacity check is so the compiler can','line_number':434,'multiline':False]
['text':' optimize out the string resize code.','line_number':435,'multiline':False]
['text':' Inline the fast-path for single-character output, but fall back to the .cc','line_number':444,'multiline':False]
['text':' file for the full version. The size<capacity check is so the compiler can','line_number':445,'multiline':False]
['text':' optimize out the string resize code.','line_number':446,'multiline':False]
['text':' Operate on characters as unsigneds','line_number':455,'multiline':False]
['text':' Make decoding faster by eliminating unpredictable branching.','line_number':491,'multiline':False]
['text':' sign extend one byte of data','line_number':493,'multiline':False]
['text':' (value >> 7) is either -1(continuation byte) or 0 (stop byte)','line_number':496,'multiline':False]
['text':' Loop if we haven't reached goal (sum < 0) or we haven't finished','line_number':498,'multiline':False]
['text':' parsing current delta (value < 0). We write it in the form of','line_number':499,'multiline':False]
['text':' (a | b) < 0 as opposed to (a < 0 || b < 0) as the former one is','line_number':500,'multiline':False]
['text':' usually as fast as a test for (a < 0).','line_number':501,'multiline':False]
['text':' _VARINT_H ','line_number':508,'multiline':True]
