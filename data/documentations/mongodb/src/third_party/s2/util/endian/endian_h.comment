['text':' Copyright 2005 Google, Inc','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' Utility functions that depend on bytesex. We define htonll and ntohll,','line_number':3,'multiline':False]
['text':' as well as "Google" versions of all the standards: ghtonl, ghtons, and','line_number':4,'multiline':False]
['text':' so on. These functions do exactly the same as their standard variants,','line_number':5,'multiline':False]
['text':' but don't require including the dangerous netinet/in.h.','line_number':6,'multiline':False]
['text':' Adapted from /usr/include/byteswap.h.','line_number':18,'multiline':False]
['text':' bswap_64','line_number':31,'multiline':False]
['text':' Definitions for ntohl etc. that don't require us to include','line_number':36,'multiline':False]
['text':' netinet/in.h. We wrap bswap_32 and bswap_16 in functions rather','line_number':37,'multiline':False]
['text':' than just #defining them because in debug mode, gcc doesn't','line_number':38,'multiline':False]
['text':' correctly handle the (rather involved) definitions of bswap_32.','line_number':39,'multiline':False]
['text':' gcc guarantees that inline functions are as fast as macros, so','line_number':40,'multiline':False]
['text':' this isn't a performance hit.','line_number':41,'multiline':False]
['text':' These definitions are a lot simpler on big-endian machines','line_number':48,'multiline':False]
['text':' bytesex','line_number':55,'multiline':False]
['text':' Convert to little-endian storage, opposite of network format.','line_number':57,'multiline':False]
['text':' Convert x from host to little endian: x = LittleEndian.FromHost(x);','line_number':58,'multiline':False]
['text':' convert x from little endian to host: x = LittleEndian.ToHost(x);','line_number':59,'multiline':False]
['text':'','line_number':60,'multiline':False]
['text':'  Store values into unaligned memory converting to little endian order:','line_number':61,'multiline':False]
['text':'    LittleEndian.Store16(p, x);','line_number':62,'multiline':False]
['text':'','line_number':63,'multiline':False]
['text':'  Load unaligned values stored in little endian coverting to host order:','line_number':64,'multiline':False]
['text':'    x = LittleEndian.Load16(p);','line_number':65,'multiline':False]
['text':' Conversion functions.','line_number':68,'multiline':False]
['text':' ENDIAN ','line_number':95,'multiline':True]
['text':' Functions to do unaligned loads and stores in little-endian order.','line_number':97,'multiline':False]
['text':' Build a uint64 from 1-8 bytes.','line_number':118,'multiline':False]
['text':' 8 * len least significant bits are loaded from the memory with','line_number':119,'multiline':False]
['text':' LittleEndian order. The 64 - 8 * len most significant bits are','line_number':120,'multiline':False]
['text':' set all to 0.','line_number':121,'multiline':False]
['text':' In latex-friendly words, this function returns:','line_number':122,'multiline':False]
['text':'     $\sum_{i=0}^{len-1} p[i] 256^{i}$, where p[i] is unsigned.','line_number':123,'multiline':False]
['text':'','line_number':124,'multiline':False]
['text':' This function is equivalent with:','line_number':125,'multiline':False]
['text':' uint64 val = 0;','line_number':126,'multiline':False]
['text':' memcpy(&val, p, len);','line_number':127,'multiline':False]
['text':' return ToHost64(val);','line_number':128,'multiline':False]
['text':' TODO(user): write a small benchmark and benchmark the speed','line_number':129,'multiline':False]
['text':' of a memcpy based approach.','line_number':130,'multiline':False]
['text':'','line_number':131,'multiline':False]
['text':' For speed reasons this function does not work for len == 0.','line_number':132,'multiline':False]
['text':' The caller needs to guarantee that 1 <= len <= 8.','line_number':133,'multiline':False]
['text':' (--len >= 0) is about 10 % faster than (len--) in some benchmarks.','line_number':142,'multiline':False]
['text':' No ToHost64(...) needed. The bytes are accessed in little-endian manner','line_number':144,'multiline':False]
['text':' on every architecture.','line_number':145,'multiline':False]
['text':' Build a uint128 from 1-16 bytes.','line_number':165,'multiline':False]
['text':' 8 * len least significant bits are loaded from the memory with','line_number':166,'multiline':False]
['text':' LittleEndian order. The 128 - 8 * len most significant bits are','line_number':167,'multiline':False]
['text':' set all to 0.','line_number':168,'multiline':False]
['text':' This one is safe to take as it's an extension','line_number':181,'multiline':False]
['text':' #define htonll(x) ghtonll(x)     // XXX Conflicts on OS X Yosemite','line_number':182,'multiline':False]
['text':' ntoh* and hton* are the same thing for any size and bytesex,','line_number':184,'multiline':False]
['text':' since the function is an involution, i.e., its own inverse.','line_number':185,'multiline':False]
['text':' #define ntohll(x) htonll(x)      // XXX Conflicts on OS X Yosemite','line_number':189,'multiline':False]
['text':' UTIL_ENDIAN_ENDIAN_H_','line_number':191,'multiline':False]
