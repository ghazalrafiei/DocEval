['text':' Copyright 2006 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':' A chain represents either a polyline or a loop, depending','line_number':24,'multiline':False]
['text':' on whether "closed" is true.','line_number':25,'multiline':False]
['text':' +1 = undirected, -1 = directed, 0 = either one','line_number':32,'multiline':False]
['text':' +1 = XOR, -1 = don't XOR, 0 = either one','line_number':35,'multiline':False]
['text':' Can edges be split for this test case?','line_number':38,'multiline':False]
['text':' Min and max vertex merge radius for this test case in degrees.','line_number':41,'multiline':False]
['text':' Minimum angle in degrees between any two edges *after* vertex merging.','line_number':44,'multiline':False]
['text':' Each test case consists of a set of input loops and polylines.','line_number':47,'multiline':False]
['text':' The expected set of output loops, directed appropriately.','line_number':50,'multiline':False]
['text':' The expected number of unused edges.','line_number':53,'multiline':False]
['text':' 0: No loops.','line_number':57,'multiline':False]
['text':' 1: One loop with some extra edges.','line_number':62,'multiline':False]
['text':' 2: One loop that has an edge removed by XORing, plus lots of extra edges.','line_number':69,'multiline':False]
['text':' XOR','line_number':70,'multiline':False]
['text':' 3: Three loops (two shells and one hole) that combine into one.','line_number':81,'multiline':False]
['text':' XOR','line_number':82,'multiline':False]
['text':' 4: A big CCW triangle contained 3 CW triangular holes.  The whole thing','line_number':88,'multiline':False]
['text':' looks like a pyramid of nine small triangles (with two extra edges).','line_number':89,'multiline':False]
['text':' Directed edges required for unique result.','line_number':90,'multiline':False]
['text':' 5: A square divided into four subsquares.  In this case we want','line_number':104,'multiline':False]
['text':' to extract the four loops rather than taking their union.','line_number':105,'multiline':False]
['text':' There are four extra edges as well.','line_number':106,'multiline':False]
['text':' Don't XOR','line_number':107,'multiline':False]
['text':' 6: Five nested loops that touch at a point.','line_number':119,'multiline':False]
['text':' 7: Four diamonds nested within each other touching at two points.','line_number':132,'multiline':False]
['text':' Directed edges required for unique result.','line_number':133,'multiline':False]
['text':' 8: Seven diamonds nested within each other touching at one','line_number':143,'multiline':False]
['text':' point between each nested pair.','line_number':144,'multiline':False]
['text':' 9: A triangle and a self-intersecting bowtie.','line_number':161,'multiline':False]
['text':' 10: Two triangles that intersect each other.','line_number':168,'multiline':False]
['text':' 11: Four squares that combine to make a big square.  The nominal edges of','line_number':174,'multiline':False]
['text':' the square are at +/-8.5 degrees in latitude and longitude.  All vertices','line_number':175,'multiline':False]
['text':' except the center vertex are perturbed by up to 0.5 degrees in latitude','line_number':176,'multiline':False]
['text':' and/or longitude.  The various copies of the center vertex are misaligned','line_number':177,'multiline':False]
['text':' by more than this (i.e. they are structured as a tree where adjacent','line_number':178,'multiline':False]
['text':' vertices are separated by at most 1 degree in latitude and/or longitude)','line_number':179,'multiline':False]
['text':' so that the clustering algorithm needs more than one iteration to find','line_number':180,'multiline':False]
['text':' them all.  Note that the merged position of this vertex doesn't matter','line_number':181,'multiline':False]
['text':' because it is XORed away in the output.  However, it's important that','line_number':182,'multiline':False]
['text':' all edge pairs that need to be XORed are separated by no more than','line_number':183,'multiline':False]
['text':' 'min_merge' below.','line_number':184,'multiline':False]
['text':' XOR, min_merge > sqrt(2), max_merge < 6.','line_number':186,'multiline':False]
['text':' Perturb the point "x" randomly within a radius of max_perturb.','line_number':208,'multiline':False]
['text':' Parse the vertices and transform them into the given frame.','line_number':218,'multiline':False]
['text':' Adds an edge from "v0" to "v1", possibly splitting it recursively up to','line_number':229,'multiline':False]
['text':' "max_splits" times, and perturbing each vertex up to a distance of','line_number':230,'multiline':False]
['text':' "max_perturb".  No edge shorter than "min_edge" will be created due to','line_number':231,'multiline':False]
['text':' splitting.','line_number':232,'multiline':False]
['text':' Choose an interpolation parameter such that the length of each','line_number':236,'multiline':False]
['text':' piece is at least min_edge.','line_number':237,'multiline':False]
['text':' Now add the two sub-edges recursively.','line_number':241,'multiline':False]
['text':' Transform the given edge chain to the frame (x,y,z), optionally split','line_number':254,'multiline':False]
['text':' each edge into pieces and/or perturb the vertices up to the given','line_number':255,'multiline':False]
['text':' radius, and add them to the builder.','line_number':256,'multiline':False]
['text':' Return true if "loop" matches any of the given candidates.  The type','line_number':269,'multiline':False]
['text':' of matching depends on whether any edge splitting was done.','line_number':270,'multiline':False]
['text':' The two loops should match except for vertex perturbations.','line_number':274,'multiline':False]
['text':' The two loops may have different numbers of vertices.','line_number':277,'multiline':False]
['text':' Dump any loops from "actual" that are not present in "expected".','line_number':289,'multiline':False]
['text':' Return true if the actual number of unused edges is inconsistent','line_number':309,'multiline':False]
['text':' with the expected number of unused edges.','line_number':310,'multiline':False]
['text':'','line_number':311,'multiline':False]
['text':' If there are no splits, the number of unused edges should match exactly.','line_number':312,'multiline':False]
['text':' Otherwise, both values should be zero or both should be non-zero.','line_number':313,'multiline':False]
['text':' Print the unused edges, transformed back into their original','line_number':324,'multiline':False]
['text':' latitude-longitude space in degrees.','line_number':325,'multiline':False]
['text':' Returns a fraction between 0 and 1 where small values are more','line_number':345,'multiline':False]
['text':' likely.  In particular it often returns exactly 0, and often','line_number':346,'multiline':False]
['text':' returns a fraction whose logarithm is uniformly distributed','line_number':347,'multiline':False]
['text':' over some interval.','line_number':348,'multiline':False]
['text':' Each test has a minimum and a maximum merge radius.  The merge','line_number':371,'multiline':False]
['text':' radius must be at least the given minimum to ensure that all expected','line_number':372,'multiline':False]
['text':' merging will take place, and it must be at most the given maximum to','line_number':373,'multiline':False]
['text':' ensure that no unexpected merging takes place.','line_number':374,'multiline':False]
['text':'','line_number':375,'multiline':False]
['text':' If the minimum and maximum values are different, we have some latitude','line_number':376,'multiline':False]
['text':' to perturb the vertices as long as the merge radius is adjusted','line_number':377,'multiline':False]
['text':' appropriately.  If "p" is the maximum perturbation radius, "m" and','line_number':378,'multiline':False]
['text':' "M" are the min/max merge radii, and "v" is the vertex merge radius','line_number':379,'multiline':False]
['text':' for this test, we require that','line_number':380,'multiline':False]
['text':'','line_number':381,'multiline':False]
['text':'       v >= m + 2*p    and    v <= M - 2*p .','line_number':382,'multiline':False]
['text':'','line_number':383,'multiline':False]
['text':' This implies that we can choose "v" in the range [m,M], and then choose','line_number':384,'multiline':False]
['text':'','line_number':385,'multiline':False]
['text':'       p <= 0.5 * min(v - m, M - v) .','line_number':386,'multiline':False]
['text':'','line_number':387,'multiline':False]
['text':' Things get more complicated when we turn on edge splicing.  Since the','line_number':388,'multiline':False]
['text':' min/max merge radii apply to vertices, we need to adjust them to ensure','line_number':389,'multiline':False]
['text':' that vertices are not accidentally spliced into nearby edges.  Recall','line_number':390,'multiline':False]
['text':' that the edge splice radius is defined as (e = v * f) where "f" is the','line_number':391,'multiline':False]
['text':' edge splice fraction.  Letting "a" be the minimum angle between two','line_number':392,'multiline':False]
['text':' edges at a vertex, we need to ensure that','line_number':393,'multiline':False]
['text':'','line_number':394,'multiline':False]
['text':'     e <= M * sin(a) - 2*p .','line_number':395,'multiline':False]
['text':'','line_number':396,'multiline':False]
['text':' The right-hand side is a lower bound on the distance from a vertex to a','line_number':397,'multiline':False]
['text':' non-incident edge.  (To simplify things, we ignore this case and fold','line_number':398,'multiline':False]
['text':' it into the case below.)','line_number':399,'multiline':False]
['text':'','line_number':400,'multiline':False]
['text':' If we also split edges by introducing new vertices, things get even','line_number':401,'multiline':False]
['text':' more complicated.  First, the vertex merge radius "v" must be chosen','line_number':402,'multiline':False]
['text':' such that','line_number':403,'multiline':False]
['text':'','line_number':404,'multiline':False]
['text':'      e >= m + 2*p    and  v <= M * sin(a) - 2*p .','line_number':405,'multiline':False]
['text':'','line_number':406,'multiline':False]
['text':' Note that the right-hand inequality now applies to "v" rather than "e",','line_number':407,'multiline':False]
['text':' since a new vertex can be introduced anywhere along a split edge.','line_number':408,'multiline':False]
['text':'','line_number':409,'multiline':False]
['text':' Finally, we need to ensure that the new edges created by splitting an','line_number':410,'multiline':False]
['text':' edge are not too short, otherwise unbounded vertex merging and/or edge','line_number':411,'multiline':False]
['text':' splicing can occur.  Letting "g" be the minimum distance (gap) between','line_number':412,'multiline':False]
['text':' vertices along a split edge, we require that','line_number':413,'multiline':False]
['text':'','line_number':414,'multiline':False]
['text':'      2 * sin(a/2) * (g - m) - 2*p >= v','line_number':415,'multiline':False]
['text':'','line_number':416,'multiline':False]
['text':' which is satisfied whenever','line_number':417,'multiline':False]
['text':'','line_number':418,'multiline':False]
['text':'      g >= m + (v + 2*p) / sin(a)','line_number':419,'multiline':False]
['text':'','line_number':420,'multiline':False]
['text':' This inequality is derived by considering two edges of length "g"','line_number':421,'multiline':False]
['text':' meeting at an angle "a", where both vertices are perturbed by distance','line_number':422,'multiline':False]
['text':' "p" toward each other, and the shared vertex is perturbed by the','line_number':423,'multiline':False]
['text':' minimum merge radius "m" along one of the two edges.','line_number':424,'multiline':False]
['text':' Half of the time we allow edges to be split into smaller pieces','line_number':430,'multiline':False]
['text':' (up to 5 levels, i.e. up to 32 pieces).','line_number':431,'multiline':False]
['text':' We choosen randomly among two different values for the edge fraction,','line_number':435,'multiline':False]
['text':' just to exercise that code.','line_number':436,'multiline':False]
['text':' Turn off edge splicing completely.','line_number':443,'multiline':False]
['text':' Splice edges.  These bounds also assume that edges may be split','line_number':449,'multiline':False]
['text':' (see detailed comments above).','line_number':450,'multiline':False]
['text':'','line_number':451,'multiline':False]
['text':' If edges are actually split, need to bump up the minimum merge radius','line_number':452,'multiline':False]
['text':' to ensure that split edges in opposite directions are unified.','line_number':453,'multiline':False]
['text':' Otherwise there will be tiny degenerate loops created.','line_number':454,'multiline':False]
['text':' We can perturb by any amount up to the maximum, but choosing a','line_number':465,'multiline':False]
['text':' lower maximum decreases the error bounds when checking the output.','line_number':466,'multiline':False]
['text':' This is the minimum length of a split edge to prevent unexpected','line_number':469,'multiline':False]
['text':' merging and/or splicing (the "g" value mentioned above).','line_number':470,'multiline':False]
['text':' On each iteration we randomly rotate the test case around the sphere.','line_number':478,'multiline':False]
['text':' This causes the S2PolygonBuilder to choose different first edges when','line_number':479,'multiline':False]
['text':' trying to build loops.','line_number':480,'multiline':False]
['text':' We assume that the vertex locations in the expected output polygon','line_number':505,'multiline':False]
['text':' are separated from the corresponding vertex locations in the input','line_number':506,'multiline':False]
['text':' edges by at most half of the minimum merge radius.  Essentially','line_number':507,'multiline':False]
['text':' this means that the expected output vertices should be near the','line_number':508,'multiline':False]
['text':' centroid of the various input vertices.','line_number':509,'multiline':False]
['text':'','line_number':510,'multiline':False]
['text':' If any edges were split, we need to allow a bit more error due to','line_number':511,'multiline':False]
['text':' inaccuracies in the interpolated positions.  Similarly, if any vertices','line_number':512,'multiline':False]
['text':' were perturbed, we need to bump up the error to allow for numerical','line_number':513,'multiline':False]
['text':' errors in the actual perturbation.','line_number':514,'multiline':False]
['text':' Note the single "|" below so that we print both sets of loops.','line_number':518,'multiline':False]
['text':' We found a problem.  Print out the relevant parameters.','line_number':526,'multiline':False]
['text':' namespace','line_number':555,'multiline':False]
