['text':' Copyright 2008 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' Various Google-specific macros.','line_number':3,'multiline':False]
['text':'','line_number':4,'multiline':False]
['text':' This code is compiled directly on many platforms, including client','line_number':5,'multiline':False]
['text':' platforms like Windows, Mac, and embedded systems.  Before making','line_number':6,'multiline':False]
['text':' any changes here, make sure that you're not breaking any platforms.','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':' For OS_WINDOWS','line_number':13,'multiline':False]
['text':' For size_t','line_number':15,'multiline':False]
['text':' We use our own  local  version of type traits while we're waiting','line_number':17,'multiline':False]
['text':' for TR1 type traits to be standardized. Define some macros so that','line_number':18,'multiline':False]
['text':' most google3 code doesn't have to work with type traits directly.','line_number':19,'multiline':False]
['text':' The swigged version of an abstract class must be concrete if any methods','line_number':22,'multiline':False]
['text':' return objects of the abstract type. We keep it abstract in C++ and','line_number':23,'multiline':False]
['text':' concrete for swig.','line_number':24,'multiline':False]
['text':' The COMPILE_ASSERT macro can be used to verify that a compile time','line_number':29,'multiline':False]
['text':' expression is true. For example, you could use it to verify the','line_number':30,'multiline':False]
['text':' size of a static array:','line_number':31,'multiline':False]
['text':'','line_number':32,'multiline':False]
['text':'   COMPILE_ASSERT(ARRAYSIZE(content_type_names) == CONTENT_NUM_TYPES,','line_number':33,'multiline':False]
['text':'                  content_type_names_incorrect_size);','line_number':34,'multiline':False]
['text':'','line_number':35,'multiline':False]
['text':' or to make sure a struct is smaller than a certain size:','line_number':36,'multiline':False]
['text':'','line_number':37,'multiline':False]
['text':'   COMPILE_ASSERT(sizeof(foo) < 128, foo_too_large);','line_number':38,'multiline':False]
['text':'','line_number':39,'multiline':False]
['text':' The second argument to the macro is the name of the variable. If','line_number':40,'multiline':False]
['text':' the expression is false, most compilers will issue a warning/error','line_number':41,'multiline':False]
['text':' containing the name of the variable.','line_number':42,'multiline':False]
['text':' Implementation details of COMPILE_ASSERT:','line_number':51,'multiline':False]
['text':'','line_number':52,'multiline':False]
['text':' - COMPILE_ASSERT works by defining an array type that has -1','line_number':53,'multiline':False]
['text':'   elements (and thus is invalid) when the expression is false.','line_number':54,'multiline':False]
['text':'','line_number':55,'multiline':False]
['text':' - The simpler definition','line_number':56,'multiline':False]
['text':'','line_number':57,'multiline':False]
['text':'     #define COMPILE_ASSERT(expr, msg) typedef char msg[(expr) ? 1 : -1]','line_number':58,'multiline':False]
['text':'','line_number':59,'multiline':False]
['text':'   does not work, as gcc supports variable-length arrays whose sizes','line_number':60,'multiline':False]
['text':'   are determined at run-time (this is gcc's extension and not part','line_number':61,'multiline':False]
['text':'   of the C++ standard).  As a result, gcc fails to reject the','line_number':62,'multiline':False]
['text':'   following code with the simple definition:','line_number':63,'multiline':False]
['text':'','line_number':64,'multiline':False]
['text':'     int foo;','line_number':65,'multiline':False]
['text':'     COMPILE_ASSERT(foo, msg); // not supposed to compile as foo is','line_number':66,'multiline':False]
['text':'                               // not a compile-time constant.','line_number':67,'multiline':False]
['text':'','line_number':68,'multiline':False]
['text':' - By using the type CompileAssert<(bool(expr))>, we ensures that','line_number':69,'multiline':False]
['text':'   expr is a compile-time constant.  (Template arguments must be','line_number':70,'multiline':False]
['text':'   determined at compile-time.)','line_number':71,'multiline':False]
['text':'','line_number':72,'multiline':False]
['text':' - The outter parentheses in CompileAssert<(bool(expr))> are necessary','line_number':73,'multiline':False]
['text':'   to work around a bug in gcc 3.4.4 and 4.0.1.  If we had written','line_number':74,'multiline':False]
['text':'','line_number':75,'multiline':False]
['text':'     CompileAssert<bool(expr)>','line_number':76,'multiline':False]
['text':'','line_number':77,'multiline':False]
['text':'   instead, these compilers will refuse to compile','line_number':78,'multiline':False]
['text':'','line_number':79,'multiline':False]
['text':'     COMPILE_ASSERT(5 > 0, some_message);','line_number':80,'multiline':False]
['text':'','line_number':81,'multiline':False]
['text':'   (They seem to think the ">" in "5 > 0" marks the end of the','line_number':82,'multiline':False]
['text':'   template argument list.)','line_number':83,'multiline':False]
['text':'','line_number':84,'multiline':False]
['text':' - The array size is (bool(expr) ? 1 : -1), instead of simply','line_number':85,'multiline':False]
['text':'','line_number':86,'multiline':False]
['text':'     ((expr) ? 1 : -1).','line_number':87,'multiline':False]
['text':'','line_number':88,'multiline':False]
['text':'   This is to avoid running into a bug in MS VC 7.1, which','line_number':89,'multiline':False]
['text':'   causes ((0.0) ? 1 : -1) to incorrectly evaluate to 1.','line_number':90,'multiline':False]
['text':' A macro to disallow the copy constructor and operator= functions','line_number':93,'multiline':False]
['text':' This should be used in the private: declarations for a class','line_number':94,'multiline':False]
['text':'','line_number':95,'multiline':False]
['text':' For disallowing only assign or copy, write the code directly, but declare','line_number':96,'multiline':False]
['text':' the intend in a comment, for example:','line_number':97,'multiline':False]
['text':' void operator=(const TypeName&);  // DISALLOW_ASSIGN','line_number':98,'multiline':False]
['text':' Note, that most uses of DISALLOW_ASSIGN and DISALLOW_COPY are broken','line_number':99,'multiline':False]
['text':' semantically, one should either use disallow both or neither. Try to','line_number':100,'multiline':False]
['text':' avoid these in new code.','line_number':101,'multiline':False]
['text':' An older, politically incorrect name for the above.','line_number':106,'multiline':False]
['text':' Prefer DISALLOW_COPY_AND_ASSIGN for new code.','line_number':107,'multiline':False]
['text':' A macro to disallow all the implicit constructors, namely the','line_number':110,'multiline':False]
['text':' default constructor, copy constructor and operator= functions.','line_number':111,'multiline':False]
['text':'','line_number':112,'multiline':False]
['text':' This should be used in the private: declarations for a class','line_number':113,'multiline':False]
['text':' that wants to prevent anyone from instantiating it. This is','line_number':114,'multiline':False]
['text':' especially useful for classes containing only static methods.','line_number':115,'multiline':False]
['text':' The arraysize(arr) macro returns the # of elements in an array arr.','line_number':120,'multiline':False]
['text':' The expression is a compile-time constant, and therefore can be','line_number':121,'multiline':False]
['text':' used in defining new arrays, for example.  If you use arraysize on','line_number':122,'multiline':False]
['text':' a pointer by mistake, you will get a compile-time error.','line_number':123,'multiline':False]
['text':'','line_number':124,'multiline':False]
['text':' One caveat is that arraysize() doesn't accept any array of an','line_number':125,'multiline':False]
['text':' anonymous type or a type defined inside a function.  In these rare','line_number':126,'multiline':False]
['text':' cases, you have to use the unsafe ARRAYSIZE() macro below.  This is','line_number':127,'multiline':False]
['text':' due to a limitation in C++'s template system.  The limitation might','line_number':128,'multiline':False]
['text':' eventually be removed, but it hasn't happened yet.','line_number':129,'multiline':False]
['text':' This template function declaration is used in defining arraysize.','line_number':131,'multiline':False]
['text':' Note that the function doesn't need an implementation, as we only','line_number':132,'multiline':False]
['text':' use its type.','line_number':133,'multiline':False]
['text':' That gcc wants both of these prototypes seems mysterious. VC, for','line_number':137,'multiline':False]
['text':' its part, can't decide which to use (another mystery). Matching of','line_number':138,'multiline':False]
['text':' template overloads: the final frontier.','line_number':139,'multiline':False]
['text':' ARRAYSIZE performs essentially the same calculation as arraysize,','line_number':147,'multiline':False]
['text':' but can be used on anonymous types or types defined inside','line_number':148,'multiline':False]
['text':' functions.  It's less safe than arraysize as it accepts some','line_number':149,'multiline':False]
['text':' (although not all) pointers.  Therefore, you should use arraysize','line_number':150,'multiline':False]
['text':' whenever possible.','line_number':151,'multiline':False]
['text':'','line_number':152,'multiline':False]
['text':' The expression ARRAYSIZE(a) is a compile-time constant of type','line_number':153,'multiline':False]
['text':' size_t.','line_number':154,'multiline':False]
['text':'','line_number':155,'multiline':False]
['text':' ARRAYSIZE catches a few type errors.  If you see a compiler error','line_number':156,'multiline':False]
['text':'','line_number':157,'multiline':False]
['text':'   "warning: division by zero in ..."','line_number':158,'multiline':False]
['text':'','line_number':159,'multiline':False]
['text':' when using ARRAYSIZE, you are (wrongfully) giving it a pointer.','line_number':160,'multiline':False]
['text':' You should only use ARRAYSIZE on statically allocated arrays.','line_number':161,'multiline':False]
['text':'','line_number':162,'multiline':False]
['text':' The following comments are on the implementation details, and can','line_number':163,'multiline':False]
['text':' be ignored by the users.','line_number':164,'multiline':False]
['text':'','line_number':165,'multiline':False]
['text':' ARRAYSIZE(arr) works by inspecting sizeof(arr) (the # of bytes in','line_number':166,'multiline':False]
['text':' the array) and sizeof(*(arr)) (the # of bytes in one array','line_number':167,'multiline':False]
['text':' element).  If the former is divisible by the latter, perhaps arr is','line_number':168,'multiline':False]
['text':' indeed an array, in which case the division result is the # of','line_number':169,'multiline':False]
['text':' elements in the array.  Otherwise, arr cannot possibly be an array,','line_number':170,'multiline':False]
['text':' and we generate a compiler error to prevent the code from','line_number':171,'multiline':False]
['text':' compiling.','line_number':172,'multiline':False]
['text':'','line_number':173,'multiline':False]
['text':' Since the size of bool is implementation-defined, we need to cast','line_number':174,'multiline':False]
['text':' !(sizeof(a) & sizeof(*(a))) to size_t in order to ensure the final','line_number':175,'multiline':False]
['text':' result has type size_t.','line_number':176,'multiline':False]
['text':'','line_number':177,'multiline':False]
['text':' This macro is not perfect as it wrongfully accepts certain','line_number':178,'multiline':False]
['text':' pointers, namely where the pointer size is divisible by the pointee','line_number':179,'multiline':False]
['text':' size.  Since all our code has to go through a 32-bit compiler,','line_number':180,'multiline':False]
['text':' where a pointer is 4 bytes, this means all pointers to a type whose','line_number':181,'multiline':False]
['text':' size is 3 or greater than 4 will be (righteously) rejected.','line_number':182,'multiline':False]
['text':'','line_number':183,'multiline':False]
['text':' Kudos to Jorg Brown for this simple and elegant implementation.','line_number':184,'multiline':False]
['text':'','line_number':185,'multiline':False]
['text':' - wan 2005-11-16','line_number':186,'multiline':False]
['text':'','line_number':187,'multiline':False]
['text':' Starting with Visual C++ 2005, WinNT.h includes ARRAYSIZE.','line_number':188,'multiline':False]
['text':' A macro to turn a symbol into a string','line_number':197,'multiline':False]
['text':' One of the type traits, is_pod, makes it possible to query whether','line_number':202,'multiline':False]
['text':' a type is a POD type. It is impossible for type_traits.h to get','line_number':203,'multiline':False]
['text':' this right without compiler support, so it fails conservatively. It','line_number':204,'multiline':False]
['text':' knows that fundamental types and pointers are PODs, but it can't','line_number':205,'multiline':False]
['text':' tell whether user classes are PODs. The DECLARE_POD macro is used','line_number':206,'multiline':False]
['text':' to inform the type traits library that a user class is a POD.','line_number':207,'multiline':False]
['text':'','line_number':208,'multiline':False]
['text':' Implementation note: the typedef at the end is just to make it legal','line_number':209,'multiline':False]
['text':' to put a semicolon after DECLARE_POD(foo).','line_number':210,'multiline':False]
['text':'','line_number':211,'multiline':False]
['text':' The only reason this matters is that a few parts of the google3','line_number':212,'multiline':False]
['text':' code base either require their template arguments to be PODs','line_number':213,'multiline':False]
['text':' (e.g. compact_vector) or are able to use a more efficient code path','line_number':214,'multiline':False]
['text':' when their template arguments are PODs (e.g. sparse_hash_map). You','line_number':215,'multiline':False]
['text':' should use DECLARE_POD if you have written a class that you intend','line_number':216,'multiline':False]
['text':' to use with one of those components, and if you know that your','line_number':217,'multiline':False]
['text':' class satisfies all of the conditions to be a POD type.','line_number':218,'multiline':False]
['text':'','line_number':219,'multiline':False]
['text':' So what's a POD?  The C++ standard (clause 9 paragraph 4) gives a','line_number':220,'multiline':False]
['text':' full definition, but a good rule of thumb is that a struct is a POD','line_number':221,'multiline':False]
['text':' ("plain old data") if it doesn't use any of the features that make','line_number':222,'multiline':False]
['text':' C++ different from C.  A POD struct can't have constructors,','line_number':223,'multiline':False]
['text':' destructors, assignment operators, base classes, private or','line_number':224,'multiline':False]
['text':' protected members, or virtual functions, and all of its member','line_number':225,'multiline':False]
['text':' variables must themselves be PODs.','line_number':226,'multiline':False]
['text':' We once needed a different technique to assert that a nested class','line_number':234,'multiline':False]
['text':' is a POD. This is no longer necessary, and DECLARE_NESTED_POD is','line_number':235,'multiline':False]
['text':' just a synonym for DECLARE_POD. We continue to provide','line_number':236,'multiline':False]
['text':' DECLARE_NESTED_POD only so we don't have to change client','line_number':237,'multiline':False]
['text':' code. Regardless of whether you use DECLARE_POD or','line_number':238,'multiline':False]
['text':' DECLARE_NESTED_POD: use it after the outer class. Using it within a','line_number':239,'multiline':False]
['text':' class definition will give a compiler error.','line_number':240,'multiline':False]
['text':' Declare that TemplateName<T> is a POD whenever T is','line_number':243,'multiline':False]
['text':' Macro that does nothing if TypeName is a POD, and gives a compiler','line_number':250,'multiline':False]
['text':' error if TypeName is a non-POD.  You should put a descriptive','line_number':251,'multiline':False]
['text':' comment right next to the macro call so that people can tell what','line_number':252,'multiline':False]
['text':' the compiler error is about.','line_number':253,'multiline':False]
['text':'','line_number':254,'multiline':False]
['text':' Implementation note: this works by taking the size of a type that's','line_number':255,'multiline':False]
['text':' complete when TypeName is a POD and incomplete otherwise.','line_number':256,'multiline':False]
['text':' BASE_MACROS_H_','line_number':265,'multiline':False]
