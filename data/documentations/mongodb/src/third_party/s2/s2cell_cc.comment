['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':' Since S2Cells are copied by value, the following assertion is a reminder','line_number':12,'multiline':False]
['text':' not to add fields unnecessarily.  An S2Cell currently consists of 43 data','line_number':13,'multiline':False]
['text':' bytes, one vtable pointer, plus alignment overhead.  This works out to 48','line_number':14,'multiline':False]
['text':' bytes on 32 bit architectures and 56 bytes on 64 bit architectures.','line_number':15,'multiline':False]
['text':'','line_number':16,'multiline':False]
['text':' The expression below rounds up (43 + sizeof(void*)) to the nearest','line_number':17,'multiline':False]
['text':' multiple of sizeof(void*).','line_number':18,'multiline':False]
['text':' Vertices are returned in the order SW, SE, NE, NW.','line_number':26,'multiline':False]
['text':' South','line_number':32,'multiline':False]
['text':' East','line_number':33,'multiline':False]
['text':' North','line_number':34,'multiline':False]
['text':' West','line_number':35,'multiline':False]
['text':' Compress int to a byte.','line_number':43,'multiline':False]
['text':' Depends on level_.','line_number':45,'multiline':False]
['text':' This function is equivalent to just iterating over the child cell ids','line_number':55,'multiline':False]
['text':' and calling the S2Cell constructor, but it is about 2.5 times faster.','line_number':56,'multiline':False]
['text':' Compute the cell midpoint in uv-space.','line_number':60,'multiline':False]
['text':' Create four children with the appropriate bounds.','line_number':63,'multiline':False]
['text':' We want to split the cell in half in "u" and "v".  To decide which','line_number':71,'multiline':False]
['text':' side to set equal to the midpoint value, we look at cell's (i,j)','line_number':72,'multiline':False]
['text':' position within its parent.  The index for "i" is in bit 1 of ij.','line_number':73,'multiline':False]
['text':' All cells at the first two levels have the same area.','line_number':94,'multiline':False]
['text':' First, compute the approximate area of the cell when projected','line_number':97,'multiline':False]
['text':' perpendicular to its normal.  The cross product of its diagonals gives','line_number':98,'multiline':False]
['text':' the normal, and the length of the normal is twice the projected area.','line_number':99,'multiline':False]
['text':' Now, compensate for the curvature of the cell surface by pretending','line_number':103,'multiline':False]
['text':' that the cell is shaped like a spherical cap.  The ratio of the','line_number':104,'multiline':False]
['text':' area of a spherical cap to the area of its projected disc turns out','line_number':105,'multiline':False]
['text':' to be 2 / (1 + sqrt(1 - r*r)) where "r" is the radius of the disc.','line_number':106,'multiline':False]
['text':' For example, when r=0 the ratio is 1, and when r=1 the ratio is 2.','line_number':107,'multiline':False]
['text':' Here we set Pi*r*r == flat_area to find the equivalent disc.','line_number':108,'multiline':False]
['text':' Use the cell center in (u,v)-space as the cap axis.  This vector is','line_number':125,'multiline':False]
['text':' very close to GetCenter() and faster to compute.  Neither one of these','line_number':126,'multiline':False]
['text':' vectors yields the bounding cap with minimal surface area, but they','line_number':127,'multiline':False]
['text':' are both pretty close.','line_number':128,'multiline':False]
['text':'','line_number':129,'multiline':False]
['text':' It's possible to show that the two vertices that are furthest from','line_number':130,'multiline':False]
['text':' the (u,v)-origin never determine the maximum cap size (this is a','line_number':131,'multiline':False]
['text':' possible future optimization).','line_number':132,'multiline':False]
['text':' Except for cells at level 0, the latitude and longitude extremes are','line_number':155,'multiline':False]
['text':' attained at the vertices.  Furthermore, the latitude range is','line_number':156,'multiline':False]
['text':' determined by one pair of diagonally opposite vertices and the','line_number':157,'multiline':False]
['text':' longitude range is determined by the other pair.','line_number':158,'multiline':False]
['text':'','line_number':159,'multiline':False]
['text':' We first determine which corner (i,j) of the cell has the largest','line_number':160,'multiline':False]
['text':' absolute latitude.  To maximize latitude, we want to find the point in','line_number':161,'multiline':False]
['text':' the cell that has the largest absolute z-coordinate and the smallest','line_number':162,'multiline':False]
['text':' absolute x- and y-coordinates.  To do this we look at each coordinate','line_number':163,'multiline':False]
['text':' (u and v), and determine whether we want to minimize or maximize that','line_number':164,'multiline':False]
['text':' coordinate based on the axis direction and the cell's (u,v) quadrant.','line_number':165,'multiline':False]
['text':' We grow the bounds slightly to make sure that the bounding rectangle','line_number':171,'multiline':False]
['text':' also contains the normalized versions of the vertices.  Note that the','line_number':172,'multiline':False]
['text':' maximum result magnitude is Pi, with a floating-point exponent of 1.','line_number':173,'multiline':False]
['text':' Therefore adding or subtracting 2**-51 will always change the result.','line_number':174,'multiline':False]
['text':' The 4 cells around the equator extend to +/-45 degrees latitude at the','line_number':187,'multiline':False]
['text':' midpoints of their top and bottom edges.  The two cells covering the','line_number':188,'multiline':False]
['text':' poles extend down to +/-35.26 degrees at their vertices.','line_number':189,'multiline':False]
['text':' 35.26 degrees','line_number':190,'multiline':False]
['text':' The face centers are the +X, +Y, +Z, -X, -Y, -Z axes in that order.','line_number':192,'multiline':False]
['text':' We can't just call XYZtoFaceUV, because for points that lie on the','line_number':219,'multiline':False]
['text':' boundary between two faces (i.e. u or v is +1/-1) we need to return','line_number':220,'multiline':False]
['text':' true for both adjacent cells.','line_number':221,'multiline':False]
