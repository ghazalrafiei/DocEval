['text':' Copyright 2008 and onwards Google Inc.  All rights reserved.','line_number':1,'multiline':False]
['text':' pi; an arbitrary number','line_number':15,'multiline':False]
['text':' more of pi','line_number':16,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':18,'multiline':False]
['text':' Hash32StringWithSeed()','line_number':19,'multiline':False]
['text':' Hash64StringWithSeed()','line_number':20,'multiline':False]
['text':' Hash32NumWithSeed()','line_number':21,'multiline':False]
['text':' Hash64NumWithSeed()','line_number':22,'multiline':False]
['text':'   These are Bob Jenkins' hash functions, one for 32 bit numbers','line_number':23,'multiline':False]
['text':'   and one for 64 bit numbers.  Each takes a string as input and','line_number':24,'multiline':False]
['text':'   a start seed.  Hashing the same string with two different seeds','line_number':25,'multiline':False]
['text':'   should give two independent hash values.','line_number':26,'multiline':False]
['text':'      The *Num*() functions just do a single mix, in order to','line_number':27,'multiline':False]
['text':'   convert the given number into something *random*.','line_number':28,'multiline':False]
['text':'','line_number':29,'multiline':False]
['text':' Note that these methods may return any value for the given size, while','line_number':30,'multiline':False]
['text':' the corresponding HashToXX() methods avoids certain reserved values.','line_number':31,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':32,'multiline':False]
['text':' These slow down a lot if inlined, so do not inline them  --Sanjay','line_number':34,'multiline':False]
['text':'extern uint32 Hash32StringWithSeed(const char *s, uint32 len, uint32 c);','line_number':35,'multiline':False]
['text':' Once again, not included, but copied from:','line_number':36,'multiline':False]
['text':' http://szl.googlecode.com/svn-history/r40/trunk/src/utilities/hashutils.cc','line_number':37,'multiline':False]
['text':' This is an Apache license...make sure this is ok','line_number':38,'multiline':False]
['text':' Indices into kPrimes32','line_number':45,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':62,'multiline':False]
['text':' HashTo32()','line_number':63,'multiline':False]
['text':' HashTo16()','line_number':64,'multiline':False]
['text':' HashTo8()','line_number':65,'multiline':False]
['text':'    These functions take various types of input (through operator','line_number':66,'multiline':False]
['text':'    overloading) and return 32, 16, and 8 bit quantities, respectively.','line_number':67,'multiline':False]
['text':'    The basic rule of our hashing is: always mix().  Thus, even for','line_number':68,'multiline':False]
['text':'    char outputs we cast to a uint32 and mix with two arbitrary numbers.','line_number':69,'multiline':False]
['text':'       As indicated in basictypes.h, there are a few illegal hash','line_number':70,'multiline':False]
['text':'    values to watch out for.','line_number':71,'multiline':False]
['text':'','line_number':72,'multiline':False]
['text':' Note that these methods avoid returning certain reserved values, while','line_number':73,'multiline':False]
['text':' the corresponding HashXXStringWithSeed() methdos may return any value.','line_number':74,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':75,'multiline':False]
['text':' This macro defines the HashTo32, To16, and To8 versions all in one go.','line_number':77,'multiline':False]
['text':' It takes the argument list and a command that hashes your number.','line_number':78,'multiline':False]
['text':' (For 16 and 8, we just mod retval before returning it.)  Example:','line_number':79,'multiline':False]
['text':'    HASH_TO((char c), Hash32NumWithSeed(c, MIX32_1))','line_number':80,'multiline':False]
['text':' evaluates to','line_number':81,'multiline':False]
['text':'    uint32 retval;','line_number':82,'multiline':False]
['text':'    retval = Hash32NumWithSeed(c, MIX32_1);','line_number':83,'multiline':False]
['text':'    return retval == kIllegalHash32 ? retval-1 : retval;','line_number':84,'multiline':False]
['text':'','line_number':85,'multiline':False]
['text':' the golden ratio; an arbitrary value','line_number':88,'multiline':False]
['text':' more of the golden ratio','line_number':94,'multiline':False]
['text':' take upper 16 bits ','line_number':105,'multiline':True]
['text':' take upper 8 bits ','line_number':109,'multiline':True]
['text':' This defines:','line_number':113,'multiline':False]
['text':' HashToXX(char *s, int slen);','line_number':114,'multiline':False]
['text':' HashToXX(char c);','line_number':115,'multiline':False]
['text':' etc','line_number':116,'multiline':False]
['text':' clean up the macro space','line_number':132,'multiline':False]
['text':' NOTE(user): we have to implement our own interator because','line_number':135,'multiline':False]
['text':' insert_iterator<set<string> > does not instantiate without','line_number':136,'multiline':False]
['text':' errors, perhaps since string != std::string.','line_number':137,'multiline':False]
['text':' This is not a fully functional iterator, but is','line_number':138,'multiline':False]
['text':' sufficient for SplitStringToIteratorUsing().','line_number':139,'multiline':False]
['text':' Used to populate a hash_map out of pairs of consecutive strings in','line_number':155,'multiline':False]
['text':' SplitStringToIterator{Using|AllowEmpty}().','line_number':156,'multiline':False]
['text':' anonymous namespace','line_number':183,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':185,'multiline':False]
['text':' SplitStringIntoNPiecesAllowEmpty()','line_number':186,'multiline':False]
['text':' SplitStringToIteratorAllowEmpty()','line_number':187,'multiline':False]
['text':'    Split a string using a character delimiter. Append the components','line_number':188,'multiline':False]
['text':'    to 'result'.  If there are consecutive delimiters, this function','line_number':189,'multiline':False]
['text':'    will return corresponding empty strings. The string is split into','line_number':190,'multiline':False]
['text':'    at most the specified number of pieces greedily. This means that the','line_number':191,'multiline':False]
['text':'    last piece may possibly be split further. To split into as many pieces','line_number':192,'multiline':False]
['text':'    as possible, specify 0 as the number of pieces.','line_number':193,'multiline':False]
['text':'','line_number':194,'multiline':False]
['text':'    If "full" is the empty string, yields an empty string as the only value.','line_number':195,'multiline':False]
['text':'','line_number':196,'multiline':False]
['text':'    If "pieces" is negative for some reason, it returns the whole string','line_number':197,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':198,'multiline':False]
['text':'#define back_insert_iterator Platform::Collections::BackInsertIterator','line_number':222,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':233,'multiline':False]
['text':' SplitStringAllowEmpty','line_number':234,'multiline':False]
['text':' SplitStringToHashsetAllowEmpty','line_number':235,'multiline':False]
['text':' SplitStringToSetAllowEmpty','line_number':236,'multiline':False]
['text':' SplitStringToHashmapAllowEmpty','line_number':237,'multiline':False]
['text':'    Split a string using a character delimiter. Append the components','line_number':238,'multiline':False]
['text':'    to 'result'.  If there are consecutive delimiters, this function','line_number':239,'multiline':False]
['text':'    will return corresponding empty strings.','line_number':240,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':241,'multiline':False]
['text':' If we know how much to allocate for a vector of strings, we can','line_number':266,'multiline':False]
['text':' allocate the vector<string> only once and directly to the right size.','line_number':267,'multiline':False]
['text':' This saves in between 33-66 % of memory space needed for the result,','line_number':268,'multiline':False]
['text':' and runs faster in the microbenchmarks.','line_number':269,'multiline':False]
['text':'','line_number':270,'multiline':False]
['text':' The reserve is only implemented for the single character delim.','line_number':271,'multiline':False]
['text':'','line_number':272,'multiline':False]
['text':' The implementation for counting is cut-and-pasted from','line_number':273,'multiline':False]
['text':' SplitStringToIteratorUsing. I could have written my own counting iterator,','line_number':274,'multiline':False]
['text':' and use the existing template function, but probably this is more clear','line_number':275,'multiline':False]
['text':' and more sure to get optimized to reasonable code.','line_number':276,'multiline':False]
['text':' Optimize the common case where delim is a single character.','line_number':280,'multiline':False]
['text':' This could be optimized with hasless(v,1) trick.','line_number':285,'multiline':False]
['text':' Skip to the next occurence of the delimiter.','line_number':289,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':298,'multiline':False]
['text':' SplitStringUsing()','line_number':299,'multiline':False]
['text':' SplitStringToHashsetUsing()','line_number':300,'multiline':False]
['text':' SplitStringToSetUsing()','line_number':301,'multiline':False]
['text':' SplitStringToHashmapUsing()','line_number':302,'multiline':False]
['text':'    Split a string using a character delimiter. Append the components','line_number':303,'multiline':False]
['text':'    to 'result'.','line_number':304,'multiline':False]
['text':'','line_number':305,'multiline':False]
['text':' Note: For multi-character delimiters, this routine will split on *ANY* of','line_number':306,'multiline':False]
['text':' the characters in the string, not the entire string as a single delimiter.','line_number':307,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':308,'multiline':False]
['text':' Optimize the common case where delim is a single character.','line_number':314,'multiline':False]
['text':' Skip to the next occurence of the delimiter.','line_number':325,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':372,'multiline':False]
['text':' SplitOneIntToken()','line_number':373,'multiline':False]
['text':' SplitOneInt32Token()','line_number':374,'multiline':False]
['text':' SplitOneUint32Token()','line_number':375,'multiline':False]
['text':' SplitOneInt64Token()','line_number':376,'multiline':False]
['text':' SplitOneUint64Token()','line_number':377,'multiline':False]
['text':' SplitOneDoubleToken()','line_number':378,'multiline':False]
['text':' SplitOneFloatToken()','line_number':379,'multiline':False]
['text':' SplitOneDecimalIntToken()','line_number':380,'multiline':False]
['text':' SplitOneDecimalInt32Token()','line_number':381,'multiline':False]
['text':' SplitOneDecimalUint32Token()','line_number':382,'multiline':False]
['text':' SplitOneDecimalInt64Token()','line_number':383,'multiline':False]
['text':' SplitOneDecimalUint64Token()','line_number':384,'multiline':False]
['text':' SplitOneHexUint32Token()','line_number':385,'multiline':False]
['text':' SplitOneHexUint64Token()','line_number':386,'multiline':False]
['text':'   Mainly a stringified wrapper around strtol/strtoul/strtod','line_number':387,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':388,'multiline':False]
['text':' Curried functions for the macro below','line_number':389,'multiline':False]
['text':' Parse int ','line_number':419,'multiline':True]
['text':' number not present at start of string ','line_number':423,'multiline':True]
['text':' Garbage characters after int ','line_number':425,'multiline':True]
['text':' Advance past token ','line_number':426,'multiline':True]
['text':' has no strtof()','line_number':440,'multiline':False]
['text':' Note: does an implicit cast to float.','line_number':441,'multiline':False]
