['text':'','line_number':1,'multiline':False]
['text':' Copyright (C) 1999-2005 Google, Inc.','line_number':2,'multiline':False]
['text':'','line_number':3,'multiline':False]
['text':' for DBL_DIG and FLT_DIG','line_number':9,'multiline':False]
['text':' for HUGE_VAL','line_number':10,'multiline':False]
['text':' for FastTimeToBuffer()','line_number':15,'multiline':False]
['text':' windows.h defines this to something silly','line_number':45,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':50,'multiline':False]
['text':' FpToString()','line_number':51,'multiline':False]
['text':' FloatToString()','line_number':52,'multiline':False]
['text':' IntToString()','line_number':53,'multiline':False]
['text':'    Convert various types to their string representation.  These','line_number':54,'multiline':False]
['text':'    all do the obvious, trivial thing.','line_number':55,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':56,'multiline':False]
['text':' Default arguments','line_number':88,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':98,'multiline':False]
['text':' FastIntToBuffer()','line_number':99,'multiline':False]
['text':' FastInt64ToBuffer()','line_number':100,'multiline':False]
['text':' FastHexToBuffer()','line_number':101,'multiline':False]
['text':' FastHex64ToBuffer()','line_number':102,'multiline':False]
['text':' FastHex32ToBuffer()','line_number':103,'multiline':False]
['text':' FastTimeToBuffer()','line_number':104,'multiline':False]
['text':'    These are intended for speed.  FastHexToBuffer() assumes the','line_number':105,'multiline':False]
['text':'    integer is non-negative.  FastHexToBuffer() puts output in','line_number':106,'multiline':False]
['text':'    hex rather than decimal.  FastTimeToBuffer() puts the output','line_number':107,'multiline':False]
['text':'    into RFC822 format.  If time is 0, uses the current time.','line_number':108,'multiline':False]
['text':'','line_number':109,'multiline':False]
['text':'    FastHex64ToBuffer() puts a 64-bit unsigned value in hex-format,','line_number':110,'multiline':False]
['text':'    padded to exactly 16 bytes (plus one byte for '\0')','line_number':111,'multiline':False]
['text':'','line_number':112,'multiline':False]
['text':'    FastHex32ToBuffer() puts a 32-bit unsigned value in hex-format,','line_number':113,'multiline':False]
['text':'    padded to exactly 8 bytes (plus one byte for '\0')','line_number':114,'multiline':False]
['text':'','line_number':115,'multiline':False]
['text':'       All functions take the output buffer as an arg.  FastInt()','line_number':116,'multiline':False]
['text':'    uses at most 22 bytes, FastTime() uses exactly 30 bytes.','line_number':117,'multiline':False]
['text':'    They all return a pointer to the beginning of the output,','line_number':118,'multiline':False]
['text':'    which may not be the beginning of the input buffer.  (Though','line_number':119,'multiline':False]
['text':'    for FastTimeToBuffer(), we guarantee that it is.)','line_number':120,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':121,'multiline':False]
['text':' Sigh, also not actually defined here, copied from:','line_number':128,'multiline':False]
['text':' https://github.com/splitfeed/android-market-api-php/blob/master/proto/protoc-gen-php/strutil.cc','line_number':129,'multiline':False]
['text':' The idea of this implementation is to trim the number of divides to as few','line_number':157,'multiline':False]
['text':' as possible by using multiplication and subtraction rather than mod (%),','line_number':158,'multiline':False]
['text':' and by outputting two digits at a time rather than one.','line_number':159,'multiline':False]
['text':' The huge-number case is first, in the hopes that the compiler will output','line_number':160,'multiline':False]
['text':' that case in one branch-free block of code, and only output conditional','line_number':161,'multiline':False]
['text':' branches into it from below.','line_number':162,'multiline':False]
['text':' >= 1,000,000,000','line_number':163,'multiline':False]
['text':' 100,000,000','line_number':164,'multiline':False]
['text':' 100,000,000','line_number':170,'multiline':False]
['text':' 1,000,000','line_number':172,'multiline':False]
['text':' 1,000,000','line_number':178,'multiline':False]
['text':' 10,000','line_number':180,'multiline':False]
['text':' 10,000','line_number':186,'multiline':False]
['text':' 10,000','line_number':212,'multiline':False]
['text':' 1,000,000','line_number':218,'multiline':False]
['text':'    10,000','line_number':220,'multiline':False]
['text':' 100,000,000','line_number':224,'multiline':False]
['text':'   1,000,000','line_number':226,'multiline':False]
['text':' we already know that u < 1,000,000,000','line_number':230,'multiline':False]
['text':' 100,000,000','line_number':231,'multiline':False]
['text':' 10,000,000','line_number':246,'multiline':False]
['text':' 10,000,000','line_number':252,'multiline':False]
['text':' 100,000','line_number':253,'multiline':False]
['text':' 100,000','line_number':258,'multiline':False]
['text':' 1,000','line_number':259,'multiline':False]
['text':' 1,000','line_number':264,'multiline':False]
['text':' Offset into buffer where FastInt32ToBuffer places the end of string','line_number':286,'multiline':False]
['text':' null character.  Also used by FastInt32ToBufferLeft','line_number':287,'multiline':False]
['text':' This used to call out to FastInt32ToBufferLeft but that wasn't defined.','line_number':290,'multiline':False]
['text':' Copied from http://gears.googlecode.com/svn-history/r395/trunk/gears/base/common/string16.cc','line_number':291,'multiline':False]
['text':' We could collapse the positive and negative sections, but that','line_number':293,'multiline':False]
['text':' would be slightly slower for positive numbers...','line_number':294,'multiline':False]
['text':' 12 bytes is enough to store -2**32, -4294967296.','line_number':295,'multiline':False]
['text':' On different platforms, % and / have different behaviors for','line_number':305,'multiline':False]
['text':' negative numbers, so we need to jump through hoops to make sure','line_number':306,'multiline':False]
['text':' we don't divide negative numbers.','line_number':307,'multiline':False]
['text':' Make sure we aren't at MIN_INT, in which case we can't say i = -i','line_number':314,'multiline':False]
['text':' Undo what we did a moment ago','line_number':318,'multiline':False]
['text':' mod by 16','line_number':337,'multiline':False]
['text':' divide by 16','line_number':338,'multiline':False]
['text':' Error message must fit in 30-char buffer.','line_number':376,'multiline':False]
['text':' strftime format: "%a, %d %b %Y %H:%M:%S GMT",','line_number':382,'multiline':False]
['text':' but strftime does locale stuff which we do not want','line_number':383,'multiline':False]
['text':' plus strftime takes > 10x the time of hard code','line_number':384,'multiline':False]
['text':' Write out the buffer.','line_number':415,'multiline':False]
['text':' includes ending NUL','line_number':440,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':447,'multiline':False]
['text':' ParseLeadingUInt64Value','line_number':448,'multiline':False]
['text':' ParseLeadingInt64Value','line_number':449,'multiline':False]
['text':' ParseLeadingHex64Value','line_number':450,'multiline':False]
['text':'    A simple parser for long long values. Returns the parsed value if a','line_number':451,'multiline':False]
['text':'    valid integer is found; else returns deflt','line_number':452,'multiline':False]
['text':'    UInt64 and Int64 cannot handle decimal numbers with leading 0s.','line_number':453,'multiline':False]
['text':' --------------------------------------------------------------------','line_number':454,'multiline':False]
['text':' ----------------------------------------------------------------------','line_number':473,'multiline':False]
['text':' ParseLeadingDec64Value','line_number':474,'multiline':False]
['text':' ParseLeadingUDec64Value','line_number':475,'multiline':False]
['text':'    A simple parser for [u]int64 values. Returns the parsed value','line_number':476,'multiline':False]
['text':'    if a valid value is found; else returns deflt','line_number':477,'multiline':False]
['text':'    The string passed in is treated as *10 based*.','line_number':478,'multiline':False]
['text':'    This can handle strings with leading 0s.','line_number':479,'multiline':False]
['text':' --------------------------------------------------------------------','line_number':480,'multiline':False]
['text':' parsing error','line_number':501,'multiline':False]
