['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':' for HASH_NAMESPACE_DECLARATION_START','line_number':19,'multiline':False]
['text':' An S2CellId is a 64-bit unsigned integer that uniquely identifies a','line_number':25,'multiline':False]
['text':' cell in the S2 cell decomposition.  It has the following format:','line_number':26,'multiline':False]
['text':'','line_number':27,'multiline':False]
['text':'   id = [face][face_pos]','line_number':28,'multiline':False]
['text':'','line_number':29,'multiline':False]
['text':'   face:     a 3-bit number (range 0..5) encoding the cube face.','line_number':30,'multiline':False]
['text':'','line_number':31,'multiline':False]
['text':'   face_pos: a 61-bit number encoding the position of the center of this','line_number':32,'multiline':False]
['text':'             cell along the Hilbert curve over this face (see the Wiki','line_number':33,'multiline':False]
['text':'             pages for details).','line_number':34,'multiline':False]
['text':'','line_number':35,'multiline':False]
['text':' Sequentially increasing cell ids follow a continuous space-filling curve','line_number':36,'multiline':False]
['text':' over the entire sphere.  They have the following properties:','line_number':37,'multiline':False]
['text':'','line_number':38,'multiline':False]
['text':'  - The id of a cell at level k consists of a 3-bit face number followed','line_number':39,'multiline':False]
['text':'    by k bit pairs that recursively select one of the four children of','line_number':40,'multiline':False]
['text':'    each cell.  The next bit is always 1, and all other bits are 0.','line_number':41,'multiline':False]
['text':'    Therefore, the level of a cell is determined by the position of its','line_number':42,'multiline':False]
['text':'    lowest-numbered bit that is turned on (for a cell at level k, this','line_number':43,'multiline':False]
['text':'    position is 2 * (kMaxLevel - k).)','line_number':44,'multiline':False]
['text':'','line_number':45,'multiline':False]
['text':'  - The id of a parent cell is at the midpoint of the range of ids spanned','line_number':46,'multiline':False]
['text':'    by its children (or by its descendants at any level).','line_number':47,'multiline':False]
['text':'','line_number':48,'multiline':False]
['text':' Leaf cells are often used to represent points on the unit sphere, and','line_number':49,'multiline':False]
['text':' this class provides methods for converting directly between these two','line_number':50,'multiline':False]
['text':' representations.  For cells that represent 2D regions rather than','line_number':51,'multiline':False]
['text':' discrete point, it is better to use the S2Cell class.','line_number':52,'multiline':False]
['text':'','line_number':53,'multiline':False]
['text':' This class is intended to be copied by value as desired.  It uses','line_number':54,'multiline':False]
['text':' the default copy constructor and assignment operator.','line_number':55,'multiline':False]
['text':' Although only 60 bits are needed to represent the index of a leaf','line_number':58,'multiline':False]
['text':' cell, we need an extra bit in order to represent the position of','line_number':59,'multiline':False]
['text':' the center of the leaf cell along the Hilbert curve.','line_number':60,'multiline':False]
['text':' = 3;','line_number':61,'multiline':False]
['text':' = 6;','line_number':62,'multiline':False]
['text':' = S2::kMaxCellLevel;  // Valid levels: 0..kMaxLevel','line_number':63,'multiline':False]
['text':' = 2 * kMaxLevel + 1;','line_number':64,'multiline':False]
['text':' = 1 << kMaxLevel;','line_number':65,'multiline':False]
['text':' The default constructor returns an invalid cell id.','line_number':69,'multiline':False]
['text':' Returns an invalid cell id guaranteed to be larger than any','line_number':73,'multiline':False]
['text':' valid cell id.  Useful for creating indexes.','line_number':74,'multiline':False]
['text':' Return a cell given its face (range 0..5), 61-bit Hilbert curve position','line_number':77,'multiline':False]
['text':' within that face, and level (range 0..kMaxLevel).  The given position','line_number':78,'multiline':False]
['text':' will be modified to correspond to the Hilbert curve position at the','line_number':79,'multiline':False]
['text':' center of the returned cell.  This is a static function rather than a','line_number':80,'multiline':False]
['text':' constructor in order to give names to the arguments.','line_number':81,'multiline':False]
['text':' Return the leaf cell containing the given point (a direction','line_number':84,'multiline':False]
['text':' vector, not necessarily unit length).','line_number':85,'multiline':False]
['text':' Return the leaf cell containing the given normalized S2LatLng.','line_number':88,'multiline':False]
['text':' Return the direction vector corresponding to the center of the given','line_number':91,'multiline':False]
['text':' cell.  The vector returned by ToPointRaw is not necessarily unit length.','line_number':92,'multiline':False]
['text':' Return the center of the cell in (s,t) coordinates (see s2.h).','line_number':96,'multiline':False]
['text':' Return the center of the cell in (u,v) coordinates (see s2.h).  Note that','line_number':99,'multiline':False]
['text':' the center of the cell is defined as the point at which it is recursively','line_number':100,'multiline':False]
['text':' subdivided into four children; in general, it is not at the midpoint of','line_number':101,'multiline':False]
['text':' the (u,v) rectangle covered by the cell.','line_number':102,'multiline':False]
['text':' Return the S2LatLng corresponding to the center of the given cell.','line_number':105,'multiline':False]
['text':' The 64-bit unique identifier for this cell.','line_number':108,'multiline':False]
['text':' Return true if id() represents a valid cell.','line_number':111,'multiline':False]
['text':' Which cube face this cell belongs to, in the range 0..5.','line_number':114,'multiline':False]
['text':' The position of the cell center along the Hilbert curve over this face,','line_number':117,'multiline':False]
['text':' in the range 0..(2**kPosBits-1).','line_number':118,'multiline':False]
['text':' Return the subdivision level of the cell (range 0..kMaxLevel).','line_number':121,'multiline':False]
['text':' Return the edge length of this cell in (i,j)-space.','line_number':124,'multiline':False]
['text':' Return the edge length of this cell in (s,t)-space.','line_number':127,'multiline':False]
['text':' Like the above, but return the size of cells at the given level.','line_number':130,'multiline':False]
['text':' Return true if this is a leaf cell (more efficient than checking','line_number':134,'multiline':False]
['text':' whether level() == kMaxLevel).','line_number':135,'multiline':False]
['text':' Return true if this is a top-level face cell (more efficient than','line_number':138,'multiline':False]
['text':' checking whether level() == 0).','line_number':139,'multiline':False]
['text':' Return the child position (0..3) of this cell's ancestor at the given','line_number':142,'multiline':False]
['text':' level, relative to its parent.  The argument should be in the range','line_number':143,'multiline':False]
['text':' 1..kMaxLevel.  For example, child_position(1) returns the position of','line_number':144,'multiline':False]
['text':' this cell's level-1 ancestor within its top-level face cell.','line_number':145,'multiline':False]
['text':' Methods that return the range of cell ids that are contained','line_number':148,'multiline':False]
['text':' within this cell (including itself).  The range is *inclusive*','line_number':149,'multiline':False]
['text':' (i.e. test using >= and <=) and the return values of both','line_number':150,'multiline':False]
['text':' methods are valid leaf cell ids.','line_number':151,'multiline':False]
['text':'','line_number':152,'multiline':False]
['text':' These methods should not be used for iteration.  If you want to','line_number':153,'multiline':False]
['text':' iterate through all the leaf cells, call child_begin(kMaxLevel) and','line_number':154,'multiline':False]
['text':' child_end(kMaxLevel) instead.','line_number':155,'multiline':False]
['text':'','line_number':156,'multiline':False]
['text':' It would in fact be error-prone to define a range_end() method,','line_number':157,'multiline':False]
['text':' because (range_max().id() + 1) is not always a valid cell id, and the','line_number':158,'multiline':False]
['text':' iterator would need to be tested using "<" rather that the usual "!=".','line_number':159,'multiline':False]
['text':' Return true if the given cell is contained within this one.','line_number':163,'multiline':False]
['text':' Return true if the given cell intersects this one.','line_number':166,'multiline':False]
['text':' Return the cell at the previous level or at the given level (which must','line_number':169,'multiline':False]
['text':' be less than or equal to the current level).','line_number':170,'multiline':False]
['text':' Return the immediate child of this cell at the given traversal order','line_number':174,'multiline':False]
['text':' position (in the range 0 to 3).  This cell must not be a leaf cell.','line_number':175,'multiline':False]
['text':' Iterator-style methods for traversing the immediate children of a cell or','line_number':178,'multiline':False]
['text':' all of the children at a given level (greater than or equal to the current','line_number':179,'multiline':False]
['text':' level).  Note that the end value is exclusive, just like standard STL','line_number':180,'multiline':False]
['text':' iterators, and may not even be a valid cell id.  You should iterate using','line_number':181,'multiline':False]
['text':' code like this:','line_number':182,'multiline':False]
['text':'','line_number':183,'multiline':False]
['text':'   for(S2CellId c = id.child_begin(); c != id.child_end(); c = c.next())','line_number':184,'multiline':False]
['text':'     ...','line_number':185,'multiline':False]
['text':'','line_number':186,'multiline':False]
['text':' The convention for advancing the iterator is "c = c.next()" rather','line_number':187,'multiline':False]
['text':' than "++c" to avoid possible confusion with incrementing the','line_number':188,'multiline':False]
['text':' underlying 64-bit cell id.','line_number':189,'multiline':False]
['text':' Return the next/previous cell at the same level along the Hilbert curve.','line_number':195,'multiline':False]
['text':' Works correctly when advancing from one face to the next, but','line_number':196,'multiline':False]
['text':' does *not* wrap around from the last face to the first or vice versa.','line_number':197,'multiline':False]
['text':' This method advances or retreats the indicated number of steps along the','line_number':201,'multiline':False]
['text':' Hilbert curve at the current level, and returns the new position.  The','line_number':202,'multiline':False]
['text':' position is never advanced past End() or before Begin().','line_number':203,'multiline':False]
['text':' Like next() and prev(), but these methods wrap around from the last face','line_number':206,'multiline':False]
['text':' to the first and vice versa.  They should *not* be used for iteration in','line_number':207,'multiline':False]
['text':' conjunction with child_begin(), child_end(), Begin(), or End().  The','line_number':208,'multiline':False]
['text':' input must be a valid cell id.','line_number':209,'multiline':False]
['text':' This method advances or retreats the indicated number of steps along the','line_number':213,'multiline':False]
['text':' Hilbert curve at the current level, and returns the new position.  The','line_number':214,'multiline':False]
['text':' position wraps between the first and last faces as necessary.  The input','line_number':215,'multiline':False]
['text':' must be a valid cell id.','line_number':216,'multiline':False]
['text':' Iterator-style methods for traversing all the cells along the Hilbert','line_number':219,'multiline':False]
['text':' curve at a given level (across all 6 faces of the cube).  Note that the','line_number':220,'multiline':False]
['text':' end value is exclusive (just like standard STL iterators), and is not a','line_number':221,'multiline':False]
['text':' valid cell id.','line_number':222,'multiline':False]
['text':' Methods to encode and decode cell ids to compact text strings suitable','line_number':226,'multiline':False]
['text':' for display or indexing.  Cells at lower levels (i.e. larger cells) are','line_number':227,'multiline':False]
['text':' encoded into fewer characters.  The maximum token length is 16.','line_number':228,'multiline':False]
['text':'','line_number':229,'multiline':False]
['text':' ToToken() returns a string by value for convenience; the compiler','line_number':230,'multiline':False]
['text':' does this without intermediate copying in most cases.','line_number':231,'multiline':False]
['text':'','line_number':232,'multiline':False]
['text':' These methods guarantee that FromToken(ToToken(x)) == x even when','line_number':233,'multiline':False]
['text':' "x" is an invalid cell id.  All tokens are alphanumeric strings.','line_number':234,'multiline':False]
['text':' FromToken() returns S2CellId::None() for malformed inputs.','line_number':235,'multiline':False]
['text':' Creates a debug human readable string. Used for << and available for direct','line_number':239,'multiline':False]
['text':' usage as well.','line_number':240,'multiline':False]
['text':' Return the four cells that are adjacent across the cell's four edges.','line_number':246,'multiline':False]
['text':' Neighbors are returned in the order defined by S2Cell::GetEdge.  All','line_number':247,'multiline':False]
['text':' neighbors are guaranteed to be distinct.','line_number':248,'multiline':False]
['text':' Return the neighbors of closest vertex to this cell at the given level,','line_number':251,'multiline':False]
['text':' by appending them to "output".  Normally there are four neighbors, but','line_number':252,'multiline':False]
['text':' the closest vertex may only have three neighbors if it is one of the 8','line_number':253,'multiline':False]
['text':' cube vertices.','line_number':254,'multiline':False]
['text':'','line_number':255,'multiline':False]
['text':' Requires: level < this->level(), so that we can determine which vertex is','line_number':256,'multiline':False]
['text':' closest (in particular, level == kMaxLevel is not allowed).','line_number':257,'multiline':False]
['text':' Append all neighbors of this cell at the given level to "output".  Two','line_number':260,'multiline':False]
['text':' cells X and Y are neighbors if their boundaries intersect but their','line_number':261,'multiline':False]
['text':' interiors do not.  In particular, two cells that intersect at a single','line_number':262,'multiline':False]
['text':' point are neighbors.','line_number':263,'multiline':False]
['text':'','line_number':264,'multiline':False]
['text':' Requires: nbr_level >= this->level().  Note that for cells adjacent to a','line_number':265,'multiline':False]
['text':' face vertex, the same neighbor may be appended more than once.','line_number':266,'multiline':False]
['text':'///////////////////////////////////////////////////////////////////','line_number':269,'multiline':False]
['text':' Low-level methods.','line_number':270,'multiline':False]
['text':' Return a leaf cell given its cube face (range 0..5) and','line_number':272,'multiline':False]
['text':' i- and j-coordinates (see s2.h).','line_number':273,'multiline':False]
['text':' Return the (face, i, j) coordinates for the leaf cell corresponding to','line_number':276,'multiline':False]
['text':' this cell id.  Since cells are represented by the Hilbert curve position','line_number':277,'multiline':False]
['text':' at the center of the cell, the returned (i,j) for non-leaf cells will be','line_number':278,'multiline':False]
['text':' a leaf cell adjacent to the cell center.  If "orientation" is non-NULL,','line_number':279,'multiline':False]
['text':' also return the Hilbert curve orientation for the current cell.','line_number':280,'multiline':False]
['text':' Return the lowest-numbered bit that is on for this cell id, which is','line_number':283,'multiline':False]
['text':' equal to (uint64(1) << (2 * (kMaxLevel - level))).  So for example,','line_number':284,'multiline':False]
['text':' a.lsb() <= b.lsb() if and only if a.level() >= b.level(), but the','line_number':285,'multiline':False]
['text':' first test is more efficient.','line_number':286,'multiline':False]
['text':' Return the lowest-numbered bit that is on for cells at the given level.','line_number':292,'multiline':False]
['text':' This is the offset required to wrap around from the beginning of the','line_number':298,'multiline':False]
['text':' Hilbert curve to the end or vice versa; see next_wrap() and prev_wrap().','line_number':299,'multiline':False]
['text':' = uint64(kNumFaces) << kPosBits;','line_number':300,'multiline':False]
['text':' Return the i- or j-index of the leaf cell containing the given','line_number':302,'multiline':False]
['text':' s- or t-value.  Values are clamped appropriately.','line_number':303,'multiline':False]
['text':' Return the (face, si, ti) coordinates of the center of the cell.  Note','line_number':306,'multiline':False]
['text':' that although (si,ti) coordinates span the range [0,2**31] in general,','line_number':307,'multiline':False]
['text':' the cell center coordinates are always in the range [1,2**31-1] and','line_number':308,'multiline':False]
['text':' therefore can be represented using a signed 32-bit integer.','line_number':309,'multiline':False]
['text':' Given (i, j) coordinates that may be out of bounds, normalize them by','line_number':312,'multiline':False]
['text':' returning the corresponding neighbor cell on an adjacent face.','line_number':313,'multiline':False]
['text':' Inline helper function that calls FromFaceIJ if "same_face" is true,','line_number':316,'multiline':False]
['text':' or FromFaceIJWrap if "same_face" is false.','line_number':317,'multiline':False]
['text':' Necessary so that structures containing S2CellId's can be PACKED.','line_number':321,'multiline':False]
['text':' Floating-point multiplication is much faster than division.','line_number':373,'multiline':False]
['text':' To change the level, we need to move the least-significant bit two','line_number':434,'multiline':False]
['text':' positions downward.  We do this by subtracting (4 * new_lsb) and adding','line_number':435,'multiline':False]
['text':' new_lsb.  Then to advance to the given child cell, we add','line_number':436,'multiline':False]
['text':' (2 * position * new_lsb).','line_number':437,'multiline':False]
['text':' UTIL_GEOMETRY_S2CELLID_H_','line_number':510,'multiline':False]
