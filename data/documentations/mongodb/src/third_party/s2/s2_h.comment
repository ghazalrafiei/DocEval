['text':' Copyright 2005 Google Inc. All Rights Reserved.','line_number':1,'multiline':False]
['text':' To have template struct hash<T> defined','line_number':21,'multiline':False]
['text':' for HASH_NAMESPACE_DECLARATION_START','line_number':25,'multiline':False]
['text':' An S2Point represents a point on the unit sphere as a 3D vector.  Usually','line_number':30,'multiline':False]
['text':' points are normalized to be unit length, but some methods do not require','line_number':31,'multiline':False]
['text':' this.  See util/math/vector3-inl.h for the methods available.  Among other','line_number':32,'multiline':False]
['text':' things, there are overloaded operators that make it convenient to write','line_number':33,'multiline':False]
['text':' arithmetic expressions (e.g. (1-x)*p1 + x*p2).','line_number':34,'multiline':False]
['text':' The S2 class is simply a namespace for constants and static utility','line_number':46,'multiline':False]
['text':' functions related to spherical geometry, such as area calculations and edge','line_number':47,'multiline':False]
['text':' intersection tests.  The name "S2" is derived from the mathematical symbol','line_number':48,'multiline':False]
['text':' for the two-dimensional unit sphere (note that the "2" refers to the','line_number':49,'multiline':False]
['text':' dimension of the surface, not the space it is embedded in).','line_number':50,'multiline':False]
['text':'','line_number':51,'multiline':False]
['text':' This class also defines a framework for decomposing the unit sphere into a','line_number':52,'multiline':False]
['text':' hierarchy of "cells".  Each cell is a quadrilateral bounded by four','line_number':53,'multiline':False]
['text':' geodesics.  The top level of the hierarchy is obtained by projecting the','line_number':54,'multiline':False]
['text':' six faces of a cube onto the unit sphere, and lower levels are obtained by','line_number':55,'multiline':False]
['text':' subdividing each cell into four children recursively.','line_number':56,'multiline':False]
['text':'','line_number':57,'multiline':False]
['text':' This class specifies the details of how the cube faces are projected onto','line_number':58,'multiline':False]
['text':' the unit sphere.  This includes getting the face ordering and orientation','line_number':59,'multiline':False]
['text':' correct so that sequentially increasing cell ids follow a continuous','line_number':60,'multiline':False]
['text':' space-filling curve over the entire sphere, and defining the','line_number':61,'multiline':False]
['text':' transformation from cell-space to cube-space in order to make the cells','line_number':62,'multiline':False]
['text':' more uniform in size.','line_number':63,'multiline':False]
['text':'','line_number':64,'multiline':False]
['text':' This file also contains documentation of the various coordinate systems','line_number':65,'multiline':False]
['text':' and conventions used.','line_number':66,'multiline':False]
['text':'','line_number':67,'multiline':False]
['text':' This class is not thread-safe for loops and objects that use loops.','line_number':68,'multiline':False]
['text':'','line_number':69,'multiline':False]
['text':' Return a unique "origin" on the sphere for operations that need a fixed','line_number':73,'multiline':False]
['text':' reference point.  In particular, this is the "point at infinity" used for','line_number':74,'multiline':False]
['text':' point-in-polygon testing (by counting the number of edge crossings).','line_number':75,'multiline':False]
['text':'','line_number':76,'multiline':False]
['text':' It should *not* be a point that is commonly used in edge tests in order','line_number':77,'multiline':False]
['text':' to avoid triggering code to handle degenerate cases.  (This rules out the','line_number':78,'multiline':False]
['text':' north and south poles.)  It should also not be on the boundary of any','line_number':79,'multiline':False]
['text':' low-level S2Cell for the same reason.','line_number':80,'multiline':False]
['text':' Return true if the given point is approximately unit length','line_number':83,'multiline':False]
['text':' (this is mainly useful for assertions).','line_number':84,'multiline':False]
['text':' Return a unit-length vector that is orthogonal to "a".  Satisfies','line_number':87,'multiline':False]
['text':' Ortho(-a) = -Ortho(a) for all a.','line_number':88,'multiline':False]
['text':' Given a point "z" on the unit sphere, extend this into a right-handed','line_number':91,'multiline':False]
['text':' coordinate frame of unit-length column vectors m = (x,y,z).  Note that','line_number':92,'multiline':False]
['text':' the vectors (x,y) are an orthonormal frame for the tangent space at "z",','line_number':93,'multiline':False]
['text':' while "z" itself is an orthonormal frame for the normal space at "z".','line_number':94,'multiline':False]
['text':' Given an orthonormal basis "m" of column vectors and a point "p", return','line_number':97,'multiline':False]
['text':' the coordinates of "p" with respect to the basis "m".  The resulting','line_number':98,'multiline':False]
['text':' point "q" satisfies the identity (m * q == p).','line_number':99,'multiline':False]
['text':' Given an orthonormal basis "m" of column vectors and a point "q" with','line_number':102,'multiline':False]
['text':' respect to that basis, return the equivalent point "p" with respect to','line_number':103,'multiline':False]
['text':' the standard axis-aligned basis.  The result satisfies (p == m * q).','line_number':104,'multiline':False]
['text':' the coordinates of "p" with respect to the basis "m".  The resulting','line_number':107,'multiline':False]
['text':' point "r" satisfies the identity (m * r == p).','line_number':108,'multiline':False]
['text':' Return true if two points are within the given distance of each other','line_number':110,'multiline':False]
['text':' (this is mainly useful for testing).','line_number':111,'multiline':False]
['text':' Return a vector "c" that is orthogonal to the given unit-length vectors','line_number':115,'multiline':False]
['text':' "a" and "b".  This function is similar to a.CrossProd(b) except that it','line_number':116,'multiline':False]
['text':' does a better job of ensuring orthogonality when "a" is nearly parallel','line_number':117,'multiline':False]
['text':' to "b", and it returns a non-zero result even when a == b or a == -b.','line_number':118,'multiline':False]
['text':'','line_number':119,'multiline':False]
['text':' It satisfies the following properties (RCP == RobustCrossProd):','line_number':120,'multiline':False]
['text':'','line_number':121,'multiline':False]
['text':'   (1) RCP(a,b) != 0 for all a, b','line_number':122,'multiline':False]
['text':'   (2) RCP(b,a) == -RCP(a,b) unless a == b or a == -b','line_number':123,'multiline':False]
['text':'   (3) RCP(-a,b) == -RCP(a,b) unless a == b or a == -b','line_number':124,'multiline':False]
['text':'   (4) RCP(a,-b) == -RCP(a,b) unless a == b or a == -b','line_number':125,'multiline':False]
['text':' Return true if the points A, B, C are strictly counterclockwise.  Return','line_number':128,'multiline':False]
['text':' false if the points are clockwise or collinear (i.e. if they are all','line_number':129,'multiline':False]
['text':' contained on some great circle).','line_number':130,'multiline':False]
['text':'','line_number':131,'multiline':False]
['text':' Due to numerical errors, situations may arise that are mathematically','line_number':132,'multiline':False]
['text':' impossible, e.g. ABC may be considered strictly CCW while BCA is not.','line_number':133,'multiline':False]
['text':' However, the implementation guarantees the following:','line_number':134,'multiline':False]
['text':'','line_number':135,'multiline':False]
['text':'   If SimpleCCW(a,b,c), then !SimpleCCW(c,b,a) for all a,b,c.','line_number':136,'multiline':False]
['text':' Returns +1 if the points A, B, C are counterclockwise, -1 if the points','line_number':139,'multiline':False]
['text':' are clockwise, and 0 if any two points are the same.  This function is','line_number':140,'multiline':False]
['text':' essentially like taking the sign of the determinant of ABC, except that','line_number':141,'multiline':False]
['text':' it has additional logic to make sure that the above properties hold even','line_number':142,'multiline':False]
['text':' when the three points are coplanar, and to deal with the limitations of','line_number':143,'multiline':False]
['text':' floating-point arithmetic.','line_number':144,'multiline':False]
['text':'','line_number':145,'multiline':False]
['text':' RobustCCW satisfies the following conditions:','line_number':146,'multiline':False]
['text':'','line_number':147,'multiline':False]
['text':'  (1) RobustCCW(a,b,c) == 0 if and only if a == b, b == c, or c == a','line_number':148,'multiline':False]
['text':'  (2) RobustCCW(b,c,a) == RobustCCW(a,b,c) for all a,b,c','line_number':149,'multiline':False]
['text':'  (3) RobustCCW(c,b,a) == -RobustCCW(a,b,c) for all a,b,c','line_number':150,'multiline':False]
['text':'','line_number':151,'multiline':False]
['text':' In other words:','line_number':152,'multiline':False]
['text':'','line_number':153,'multiline':False]
['text':'  (1) The result is zero if and only if two points are the same.','line_number':154,'multiline':False]
['text':'  (2) Rotating the order of the arguments does not affect the result.','line_number':155,'multiline':False]
['text':'  (3) Exchanging any two arguments inverts the result.','line_number':156,'multiline':False]
['text':'','line_number':157,'multiline':False]
['text':' On the other hand, note that it is not true in general that','line_number':158,'multiline':False]
['text':' RobustCCW(-a,b,c) == -RobustCCW(a,b,c), or any similar identities','line_number':159,'multiline':False]
['text':' involving antipodal points.','line_number':160,'multiline':False]
['text':' A more efficient version of RobustCCW that allows the precomputed','line_number':163,'multiline':False]
['text':' cross-product of A and B to be specified.  (Unlike the 3 argument','line_number':164,'multiline':False]
['text':' version this method is also inlined.)','line_number':165,'multiline':False]
['text':' This version of RobustCCW returns +1 if the points are definitely CCW,','line_number':169,'multiline':False]
['text':' -1 if they are definitely CW, and 0 if two points are identical or the','line_number':170,'multiline':False]
['text':' result is uncertain.  Uncertain certain cases can be resolved, if','line_number':171,'multiline':False]
['text':' desired, by calling ExpensiveCCW.','line_number':172,'multiline':False]
['text':'','line_number':173,'multiline':False]
['text':' The purpose of this method is to allow additional cheap tests to be done,','line_number':174,'multiline':False]
['text':' where possible, in order to avoid calling ExpensiveCCW unnecessarily.','line_number':175,'multiline':False]
['text':' This function is invoked by RobustCCW() if the sign of the determinant is','line_number':179,'multiline':False]
['text':' uncertain.  It always returns a non-zero result unless two of the input','line_number':180,'multiline':False]
['text':' points are the same.  It uses a combination of multiple-precision','line_number':181,'multiline':False]
['text':' arithmetic and symbolic perturbations to ensure that its results are','line_number':182,'multiline':False]
['text':' always self-consistent (cf. Simulation of Simplicity, Edelsbrunner and','line_number':183,'multiline':False]
['text':' Muecke).  The basic idea is to assign an infinitesmal symbolic','line_number':184,'multiline':False]
['text':' perturbation to every possible S2Point such that no three S2Points are','line_number':185,'multiline':False]
['text':' collinear and no four S2Points are coplanar.  These perturbations are so','line_number':186,'multiline':False]
['text':' small that they do not affect the sign of any determinant that was','line_number':187,'multiline':False]
['text':' non-zero before the perturbations.','line_number':188,'multiline':False]
['text':'','line_number':189,'multiline':False]
['text':' Unlike RobustCCW(), this method does not require the input points to be','line_number':190,'multiline':False]
['text':' normalized.','line_number':191,'multiline':False]
['text':' Given 4 points on the unit sphere, return true if the edges OA, OB, and','line_number':195,'multiline':False]
['text':' OC are encountered in that order while sweeping CCW around the point O.','line_number':196,'multiline':False]
['text':' You can think of this as testing whether A <= B <= C with respect to the','line_number':197,'multiline':False]
['text':' CCW ordering around O that starts at A, or equivalently, whether B is','line_number':198,'multiline':False]
['text':' contained in the range of angles (inclusive) that starts at A and extends','line_number':199,'multiline':False]
['text':' CCW to C.  Properties:','line_number':200,'multiline':False]
['text':'','line_number':201,'multiline':False]
['text':'  (1) If OrderedCCW(a,b,c,o) && OrderedCCW(b,a,c,o), then a == b','line_number':202,'multiline':False]
['text':'  (2) If OrderedCCW(a,b,c,o) && OrderedCCW(a,c,b,o), then b == c','line_number':203,'multiline':False]
['text':'  (3) If OrderedCCW(a,b,c,o) && OrderedCCW(c,b,a,o), then a == b == c','line_number':204,'multiline':False]
['text':'  (4) If a == b or b == c, then OrderedCCW(a,b,c,o) is true','line_number':205,'multiline':False]
['text':'  (5) Otherwise if a == c, then OrderedCCW(a,b,c,o) is false','line_number':206,'multiline':False]
['text':' Return the interior angle at the vertex B in the triangle ABC.  The','line_number':210,'multiline':False]
['text':' return value is always in the range [0, Pi].  The points do not need to','line_number':211,'multiline':False]
['text':' be normalized.  Ensures that Angle(a,b,c) == Angle(c,b,a) for all a,b,c.','line_number':212,'multiline':False]
['text':'','line_number':213,'multiline':False]
['text':' The angle is undefined if A or C is diametrically opposite from B, and','line_number':214,'multiline':False]
['text':' becomes numerically unstable as the length of edge AB or BC approaches','line_number':215,'multiline':False]
['text':' 180 degrees.','line_number':216,'multiline':False]
['text':' Return the exterior angle at the vertex B in the triangle ABC.  The','line_number':219,'multiline':False]
['text':' return value is positive if ABC is counterclockwise and negative','line_number':220,'multiline':False]
['text':' otherwise.  If you imagine an ant walking from A to B to C, this is the','line_number':221,'multiline':False]
['text':' angle that the ant turns at vertex B (positive = left, negative = right).','line_number':222,'multiline':False]
['text':' Ensures that TurnAngle(a,b,c) == -TurnAngle(c,b,a) for all a,b,c.','line_number':223,'multiline':False]
['text':' Return the area of triangle ABC.  The method used is about twice as','line_number':226,'multiline':False]
['text':' expensive as Girard's formula, but it is numerically stable for both','line_number':227,'multiline':False]
['text':' large and very small triangles.  All points should be unit length.','line_number':228,'multiline':False]
['text':' The area is always positive.','line_number':229,'multiline':False]
['text':'','line_number':230,'multiline':False]
['text':' The triangle area is undefined if it contains two antipodal points, and','line_number':231,'multiline':False]
['text':' becomes numerically unstable as the length of any edge approaches 180','line_number':232,'multiline':False]
['text':' degrees.','line_number':233,'multiline':False]
['text':' Return the area of the triangle computed using Girard's formula.  All','line_number':236,'multiline':False]
['text':' points should be unit length.  This is slightly faster than the Area()','line_number':237,'multiline':False]
['text':' method above but is not accurate for very small triangles.','line_number':238,'multiline':False]
['text':' Like Area(), but returns a positive value for counterclockwise triangles','line_number':242,'multiline':False]
['text':' and a negative value otherwise.','line_number':243,'multiline':False]
['text':' About centroids:','line_number':247,'multiline':False]
['text':' ----------------','line_number':248,'multiline':False]
['text':'','line_number':249,'multiline':False]
['text':' There are several notions of the "centroid" of a triangle.  First, there','line_number':250,'multiline':False]
['text':'  // is the planar centroid, which is simply the centroid of the ordinary','line_number':251,'multiline':False]
['text':' (non-spherical) triangle defined by the three vertices.  Second, there is','line_number':252,'multiline':False]
['text':' the surface centroid, which is defined as the intersection of the three','line_number':253,'multiline':False]
['text':' medians of the spherical triangle.  It is possible to show that this','line_number':254,'multiline':False]
['text':' point is simply the planar centroid projected to the surface of the','line_number':255,'multiline':False]
['text':' sphere.  Finally, there is the true centroid (mass centroid), which is','line_number':256,'multiline':False]
['text':' defined as the area integral over the spherical triangle of (x,y,z)','line_number':257,'multiline':False]
['text':' divided by the triangle area.  This is the point that the triangle would','line_number':258,'multiline':False]
['text':' rotate around if it was spinning in empty space.','line_number':259,'multiline':False]
['text':'','line_number':260,'multiline':False]
['text':' The best centroid for most purposes is the true centroid.  Unlike the','line_number':261,'multiline':False]
['text':' planar and surface centroids, the true centroid behaves linearly as','line_number':262,'multiline':False]
['text':' regions are added or subtracted.  That is, if you split a triangle into','line_number':263,'multiline':False]
['text':' pieces and compute the average of their centroids (weighted by triangle','line_number':264,'multiline':False]
['text':' area), the result equals the centroid of the original triangle.  This is','line_number':265,'multiline':False]
['text':' not true of the other centroids.','line_number':266,'multiline':False]
['text':'','line_number':267,'multiline':False]
['text':' Also note that the surface centroid may be nowhere near the intuitive','line_number':268,'multiline':False]
['text':' "center" of a spherical triangle.  For example, consider the triangle','line_number':269,'multiline':False]
['text':' with vertices A=(1,eps,0), B=(0,0,1), C=(-1,eps,0) (a quarter-sphere).','line_number':270,'multiline':False]
['text':' The surface centroid of this triangle is at S=(0, 2*eps, 1), which is','line_number':271,'multiline':False]
['text':' within a distance of 2*eps of the vertex B.  Note that the median from A','line_number':272,'multiline':False]
['text':' (the segment connecting A to the midpoint of BC) passes through S, since','line_number':273,'multiline':False]
['text':' this is the shortest path connecting the two endpoints.  On the other','line_number':274,'multiline':False]
['text':' hand, the true centroid is at M=(0, 0.5, 0.5), which when projected onto','line_number':275,'multiline':False]
['text':' the surface is a much more reasonable interpretation of the "center" of','line_number':276,'multiline':False]
['text':' this triangle.','line_number':277,'multiline':False]
['text':' Return the centroid of the planar triangle ABC.  This can be normalized','line_number':279,'multiline':False]
['text':' to unit length to obtain the "surface centroid" of the corresponding','line_number':280,'multiline':False]
['text':' spherical triangle, i.e. the intersection of the three medians.  However,','line_number':281,'multiline':False]
['text':' note that for large spherical triangles the surface centroid may be','line_number':282,'multiline':False]
['text':' nowhere near the intuitive "center" (see example above).','line_number':283,'multiline':False]
['text':' Returns the true centroid of the spherical triangle ABC multiplied by the','line_number':287,'multiline':False]
['text':' signed area of spherical triangle ABC.  The reasons for multiplying by','line_number':288,'multiline':False]
['text':' the signed area are (1) this is the quantity that needs to be summed to','line_number':289,'multiline':False]
['text':' compute the centroid of a union or difference of triangles, and (2) it's','line_number':290,'multiline':False]
['text':' actually easier to calculate this way.','line_number':291,'multiline':False]
['text':'//////////////////////// S2Cell Decomposition /////////////////////////','line_number':295,'multiline':False]
['text':'','line_number':296,'multiline':False]
['text':' The following methods define the cube-to-sphere projection used by','line_number':297,'multiline':False]
['text':' the S2Cell decomposition.','line_number':298,'multiline':False]
['text':'','line_number':299,'multiline':False]
['text':' In the process of converting a latitude-longitude pair to a 64-bit cell','line_number':300,'multiline':False]
['text':' id, the following coordinate systems are used:','line_number':301,'multiline':False]
['text':'','line_number':302,'multiline':False]
['text':'  (id)','line_number':303,'multiline':False]
['text':'    An S2CellId is a 64-bit encoding of a face and a Hilbert curve position','line_number':304,'multiline':False]
['text':'    on that face.  The Hilbert curve position implicitly encodes both the','line_number':305,'multiline':False]
['text':'    position of a cell and its subdivision level (see s2cellid.h).','line_number':306,'multiline':False]
['text':'','line_number':307,'multiline':False]
['text':'  (face, i, j)','line_number':308,'multiline':False]
['text':'    Leaf-cell coordinates.  "i" and "j" are integers in the range','line_number':309,'multiline':False]
['text':'    [0,(2**30)-1] that identify a particular leaf cell on the given face.','line_number':310,'multiline':False]
['text':'    The (i, j) coordinate system is right-handed on each face, and the','line_number':311,'multiline':False]
['text':'    faces are oriented such that Hilbert curves connect continuously from','line_number':312,'multiline':False]
['text':'    one face to the next.','line_number':313,'multiline':False]
['text':'','line_number':314,'multiline':False]
['text':'  (face, s, t)','line_number':315,'multiline':False]
['text':'    Cell-space coordinates.  "s" and "t" are real numbers in the range','line_number':316,'multiline':False]
['text':'    [0,1] that identify a point on the given face.  For example, the point','line_number':317,'multiline':False]
['text':'    (s, t) = (0.5, 0.5) corresponds to the center of the top-level face','line_number':318,'multiline':False]
['text':'    cell.  This point is also a vertex of exactly four cells at each','line_number':319,'multiline':False]
['text':'    subdivision level greater than zero.','line_number':320,'multiline':False]
['text':'','line_number':321,'multiline':False]
['text':'  (face, si, ti)','line_number':322,'multiline':False]
['text':'    Discrete cell-space coordinates.  These are obtained by multiplying','line_number':323,'multiline':False]
['text':'    "s" and "t" by 2**31 and rounding to the nearest unsigned integer.','line_number':324,'multiline':False]
['text':'    Discrete coordinates lie in the range [0,2**31].  This coordinate','line_number':325,'multiline':False]
['text':'    system can represent the edge and center positions of all cells with','line_number':326,'multiline':False]
['text':'    no loss of precision (including non-leaf cells).','line_number':327,'multiline':False]
['text':'','line_number':328,'multiline':False]
['text':'  (face, u, v)','line_number':329,'multiline':False]
['text':'    Cube-space coordinates.  To make the cells at each level more uniform','line_number':330,'multiline':False]
['text':'    in size after they are projected onto the sphere, we apply apply a','line_number':331,'multiline':False]
['text':'    nonlinear transformation of the form u=f(s), v=f(t).  The (u, v)','line_number':332,'multiline':False]
['text':'    coordinates after this transformation give the actual coordinates on','line_number':333,'multiline':False]
['text':'    the cube face (modulo some 90 degree rotations) before it is projected','line_number':334,'multiline':False]
['text':'    onto the unit sphere.','line_number':335,'multiline':False]
['text':'','line_number':336,'multiline':False]
['text':'  (x, y, z)','line_number':337,'multiline':False]
['text':'    Direction vector (S2Point).  Direction vectors are not necessarily unit','line_number':338,'multiline':False]
['text':'    length, and are often chosen to be points on the biunit cube','line_number':339,'multiline':False]
['text':'    [-1,+1]x[-1,+1]x[-1,+1].  They can be be normalized to obtain the','line_number':340,'multiline':False]
['text':'    corresponding point on the unit sphere.','line_number':341,'multiline':False]
['text':'','line_number':342,'multiline':False]
['text':'  (lat, lng)','line_number':343,'multiline':False]
['text':'    Latitude and longitude (S2LatLng).  Latitudes must be between -90 and','line_number':344,'multiline':False]
['text':'    90 degrees inclusive, and longitudes must be between -180 and 180','line_number':345,'multiline':False]
['text':'    degrees inclusive.','line_number':346,'multiline':False]
['text':'','line_number':347,'multiline':False]
['text':' Note that the (i, j), (s, t), (si, ti), and (u, v) coordinate systems are','line_number':348,'multiline':False]
['text':' right-handed on all six faces.','line_number':349,'multiline':False]
['text':' Convert an s or t value  to the corresponding u or v value.  This is','line_number':351,'multiline':False]
['text':' a non-linear transformation from [-1,1] to [-1,1] that attempts to','line_number':352,'multiline':False]
['text':' make the cell sizes more uniform.','line_number':353,'multiline':False]
['text':' The inverse of the STtoUV transformation.  Note that it is not always','line_number':356,'multiline':False]
['text':' true that UVtoST(STtoUV(x)) == x due to numerical errors.','line_number':357,'multiline':False]
['text':' Convert (face, u, v) coordinates to a direction vector (not','line_number':360,'multiline':False]
['text':' necessarily unit length).','line_number':361,'multiline':False]
['text':' If the dot product of p with the given face normal is positive,','line_number':364,'multiline':False]
['text':' set the corresponding u and v values (which may lie outside the range','line_number':365,'multiline':False]
['text':' [-1,1]) and return true.  Otherwise return false.','line_number':366,'multiline':False]
['text':' Convert a direction vector (not necessarily unit length) to','line_number':370,'multiline':False]
['text':' (face, u, v) coordinates.','line_number':371,'multiline':False]
['text':' Return the right-handed normal (not necessarily unit length) for an','line_number':374,'multiline':False]
['text':' edge in the direction of the positive v-axis at the given u-value on','line_number':375,'multiline':False]
['text':' the given face.  (This vector is perpendicular to the plane through','line_number':376,'multiline':False]
['text':' the sphere origin that contains the given edge.)','line_number':377,'multiline':False]
['text':' Return the right-handed normal (not necessarily unit length) for an','line_number':380,'multiline':False]
['text':' edge in the direction of the positive u-axis at the given v-value on','line_number':381,'multiline':False]
['text':' the given face.','line_number':382,'multiline':False]
['text':' Return the unit-length normal, u-axis, or v-axis for the given face.','line_number':385,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////','line_number':390,'multiline':False]
['text':' The canonical Hilbert traversal order looks like an inverted 'U':','line_number':391,'multiline':False]
['text':' the subcells are visited in the order (0,0), (0,1), (1,1), (1,0).','line_number':392,'multiline':False]
['text':' The following tables encode the traversal order for various','line_number':393,'multiline':False]
['text':' orientations of the Hilbert curve (axes swapped and/or directions','line_number':394,'multiline':False]
['text':' of the axes reversed).','line_number':395,'multiline':False]
['text':' Together these flags define a cell orientation.  If 'kSwapMask'','line_number':397,'multiline':False]
['text':' is true, then canonical traversal order is flipped around the','line_number':398,'multiline':False]
['text':' diagonal (i.e. i and j are swapped with each other).  If','line_number':399,'multiline':False]
['text':' 'kInvertMask' is true, then the traversal order is rotated by 180','line_number':400,'multiline':False]
['text':' degrees (i.e. the bits of i and j are inverted, or equivalently,','line_number':401,'multiline':False]
['text':' the axis directions are reversed).','line_number':402,'multiline':False]
['text':' This is the number of levels needed to specify a leaf cell. This','line_number':406,'multiline':False]
['text':' constant is defined here so that the S2::Metric class can be','line_number':407,'multiline':False]
['text':' implemented without including s2cellid.h.','line_number':408,'multiline':False]
['text':' kIJtoPos[orientation][ij] -> pos','line_number':411,'multiline':False]
['text':'','line_number':412,'multiline':False]
['text':' Given a cell orientation and the (i,j)-index of a subcell (0=(0,0),','line_number':413,'multiline':False]
['text':' 1=(0,1), 2=(1,0), 3=(1,1)), return the order in which this subcell is','line_number':414,'multiline':False]
['text':' visited by the Hilbert curve (a position in the range [0..3]).','line_number':415,'multiline':False]
['text':' kPosToIJ[orientation][pos] -> ij','line_number':418,'multiline':False]
['text':'','line_number':419,'multiline':False]
['text':' Return the (i,j) index of the subcell at the given position 'pos' in the','line_number':420,'multiline':False]
['text':' Hilbert curve traversal order with the given orientation.  This is the','line_number':421,'multiline':False]
['text':' inverse of the previous table:','line_number':422,'multiline':False]
['text':'','line_number':423,'multiline':False]
['text':'   kPosToIJ[r][kIJtoPos[r][ij]] == ij','line_number':424,'multiline':False]
['text':' kPosToOrientation[pos] -> orientation_modifier','line_number':427,'multiline':False]
['text':'','line_number':428,'multiline':False]
['text':' Return a modifier indicating how the orientation of the child subcell','line_number':429,'multiline':False]
['text':' with the given traversal position [0..3] is related to the orientation','line_number':430,'multiline':False]
['text':' of the parent cell.  The modifier should be XOR-ed with the parent','line_number':431,'multiline':False]
['text':' orientation to obtain the curve orientation in the child.','line_number':432,'multiline':False]
['text':'//////////////////////// S2Cell Metrics //////////////////////////////','line_number':435,'multiline':False]
['text':'','line_number':436,'multiline':False]
['text':' The following are various constants that describe the shapes and sizes of','line_number':437,'multiline':False]
['text':' cells.  They are useful for deciding which cell level to use in order to','line_number':438,'multiline':False]
['text':' satisfy a given condition (e.g. that cell vertices must be no further','line_number':439,'multiline':False]
['text':' than "x" apart).  All of the raw constants are differential quantities;','line_number':440,'multiline':False]
['text':' you can use the GetValue(level) method to compute the corresponding length','line_number':441,'multiline':False]
['text':' or area on the unit sphere for cells at a given level.  The minimum and','line_number':442,'multiline':False]
['text':' maximum bounds are valid for cells at all levels, but they may be','line_number':443,'multiline':False]
['text':' somewhat conservative for very large cells (e.g. face cells).','line_number':444,'multiline':False]
['text':' Defines a cell metric of the given dimension (1 == length, 2 == area).','line_number':446,'multiline':False]
['text':' The "deriv" value of a metric is a derivative, and must be multiplied by','line_number':451,'multiline':False]
['text':' a length or area in (s,t)-space to get a useful value.','line_number':452,'multiline':False]
['text':' Return the value of a metric for cells at the given level. The value is','line_number':455,'multiline':False]
['text':' either a length or an area on the unit sphere, depending on the','line_number':456,'multiline':False]
['text':' particular metric.','line_number':457,'multiline':False]
['text':' Return the level at which the metric has approximately the given','line_number':460,'multiline':False]
['text':' value.  For example, S2::kAvgEdge.GetClosestLevel(0.1) returns the','line_number':461,'multiline':False]
['text':' level at which the average cell edge length is approximately 0.1.','line_number':462,'multiline':False]
['text':' The return value is always a valid level.','line_number':463,'multiline':False]
['text':' Return the minimum level such that the metric is at most the given','line_number':466,'multiline':False]
['text':' value, or S2CellId::kMaxLevel if there is no such level.  For example,','line_number':467,'multiline':False]
['text':' S2::kMaxDiag.GetMinLevel(0.1) returns the minimum level such that all','line_number':468,'multiline':False]
['text':' cell diagonal lengths are 0.1 or smaller.  The return value is always a','line_number':469,'multiline':False]
['text':' valid level.','line_number':470,'multiline':False]
['text':' Return the maximum level such that the metric is at least the given','line_number':473,'multiline':False]
['text':' value, or zero if there is no such level.  For example,','line_number':474,'multiline':False]
['text':' S2::kMinWidth.GetMaxLevel(0.1) returns the maximum level such that all','line_number':475,'multiline':False]
['text':' cells have a minimum width of 0.1 or larger.  The return value is','line_number':476,'multiline':False]
['text':' always a valid level.','line_number':477,'multiline':False]
['text':' Each cell is bounded by four planes passing through its four edges and','line_number':487,'multiline':False]
['text':' the center of the sphere.  These metrics relate to the angle between each','line_number':488,'multiline':False]
['text':' pair of opposite bounding planes, or equivalently, between the planes','line_number':489,'multiline':False]
['text':' corresponding to two different s-values or two different t-values.  For','line_number':490,'multiline':False]
['text':' example, the maximum angle between opposite bounding planes for a cell at','line_number':491,'multiline':False]
['text':' level k is kMaxAngleSpan.GetValue(k), and the average angle span for all','line_number':492,'multiline':False]
['text':' cells at level k is approximately kAvgAngleSpan.GetValue(k).','line_number':493,'multiline':False]
['text':' The width of geometric figure is defined as the distance between two','line_number':498,'multiline':False]
['text':' parallel bounding lines in a given direction.  For cells, the minimum','line_number':499,'multiline':False]
['text':' width is always attained between two opposite edges, and the maximum','line_number':500,'multiline':False]
['text':' width is attained between two opposite vertices.  However, for our','line_number':501,'multiline':False]
['text':' purposes we redefine the width of a cell as the perpendicular distance','line_number':502,'multiline':False]
['text':' between a pair of opposite edges.  A cell therefore has two widths, one','line_number':503,'multiline':False]
['text':' in each direction.  The minimum width according to this definition agrees','line_number':504,'multiline':False]
['text':' with the classic geometric one, but the maximum width is different.  (The','line_number':505,'multiline':False]
['text':' maximum geometric width corresponds to kMaxDiag defined below.)','line_number':506,'multiline':False]
['text':'','line_number':507,'multiline':False]
['text':' For a cell at level k, the distance between opposite edges is at least','line_number':508,'multiline':False]
['text':' kMinWidth.GetValue(k) and at most kMaxWidth.GetValue(k).  The average','line_number':509,'multiline':False]
['text':' width in both directions for all cells at level k is approximately','line_number':510,'multiline':False]
['text':' kAvgWidth.GetValue(k).','line_number':511,'multiline':False]
['text':'','line_number':512,'multiline':False]
['text':' The width is useful for bounding the minimum or maximum distance from a','line_number':513,'multiline':False]
['text':' point on one edge of a cell to the closest point on the opposite edge.','line_number':514,'multiline':False]
['text':' For example, this is useful when "growing" regions by a fixed distance.','line_number':515,'multiline':False]
['text':' The minimum edge length of any cell at level k is at least','line_number':520,'multiline':False]
['text':' kMinEdge.GetValue(k), and the maximum is at most kMaxEdge.GetValue(k).','line_number':521,'multiline':False]
['text':' The average edge length is approximately kAvgEdge.GetValue(k).','line_number':522,'multiline':False]
['text':'','line_number':523,'multiline':False]
['text':' The edge length metrics can also be used to bound the minimum, maximum,','line_number':524,'multiline':False]
['text':' or average distance from the center of one cell to the center of one of','line_number':525,'multiline':False]
['text':' its edge neighbors.  In particular, it can be used to bound the distance','line_number':526,'multiline':False]
['text':' between adjacent cell centers along the space-filling Hilbert curve for','line_number':527,'multiline':False]
['text':' cells at any given level.','line_number':528,'multiline':False]
['text':' The minimum diagonal length of any cell at level k is at least','line_number':533,'multiline':False]
['text':' kMinDiag.GetValue(k), and the maximum is at most kMaxDiag.GetValue(k).','line_number':534,'multiline':False]
['text':' The average diagonal length is approximately kAvgDiag.GetValue(k).','line_number':535,'multiline':False]
['text':'','line_number':536,'multiline':False]
['text':' The maximum diagonal also happens to be the maximum diameter of any cell,','line_number':537,'multiline':False]
['text':' and also the maximum geometric width (see the discussion above).  So for','line_number':538,'multiline':False]
['text':' example, the distance from an arbitrary point to the closest cell center','line_number':539,'multiline':False]
['text':' at a given level is at most half the maximum diagonal length.','line_number':540,'multiline':False]
['text':' The minimum area of any cell at level k is at least kMinArea.GetValue(k),','line_number':545,'multiline':False]
['text':' and the maximum is at most kMaxArea.GetValue(k).  The average area of all','line_number':546,'multiline':False]
['text':' cells at level k is exactly kAvgArea.GetValue(k).','line_number':547,'multiline':False]
['text':' This is the maximum edge aspect ratio over all cells at any level, where','line_number':552,'multiline':False]
['text':' the edge aspect ratio of a cell is defined as the ratio of its longest','line_number':553,'multiline':False]
['text':' edge length to its shortest edge length.','line_number':554,'multiline':False]
['text':' This is the maximum diagonal aspect ratio over all cells at any level,','line_number':557,'multiline':False]
['text':' where the diagonal aspect ratio of a cell is defined as the ratio of its','line_number':558,'multiline':False]
['text':' longest diagonal length to its shortest diagonal length.','line_number':559,'multiline':False]
['text':' Given a *valid* face for the given point p (meaning that dot product','line_number':563,'multiline':False]
['text':' of p with the face normal is positive), return the corresponding','line_number':564,'multiline':False]
['text':' u and v values (which may lie outside the range [-1,1]).','line_number':565,'multiline':False]
['text':' The value below is the maximum error in computing the determinant','line_number':569,'multiline':False]
['text':' a.CrossProd(b).DotProd(c).  To derive this, observe that computing the','line_number':570,'multiline':False]
['text':' determinant in this way requires 14 multiplications and additions.  Since','line_number':571,'multiline':False]
['text':' all three points are normalized, none of the intermediate results in this','line_number':572,'multiline':False]
['text':' calculation exceed 1.0 in magnitude.  The maximum rounding error for an','line_number':573,'multiline':False]
['text':' operation whose result magnitude does not exceed 1.0 (before rounding) is','line_number':574,'multiline':False]
['text':' 2**-54 (i.e., half of the difference between 1.0 and the next','line_number':575,'multiline':False]
['text':' representable value below 1.0).  Therefore, the total error in computing','line_number':576,'multiline':False]
['text':' the determinant does not exceed 14 * (2**-54).','line_number':577,'multiline':False]
['text':'','line_number':578,'multiline':False]
['text':' The C++ standard requires to initialize kMaxDetError outside of','line_number':579,'multiline':False]
['text':' the class definition, even though GCC doesn't enforce it.','line_number':580,'multiline':False]
['text':' Contains only static methods.','line_number':583,'multiline':False]
['text':' Uncomment the following line for testing purposes only.  It greatly','line_number':586,'multiline':False]
['text':' increases the number of degenerate cases that need to be handled using','line_number':587,'multiline':False]
['text':' ExpensiveCCW().','line_number':588,'multiline':False]
['text':' #define S2_TEST_DEGENERACIES','line_number':589,'multiline':False]
['text':' This makes polygon operations much slower.','line_number':593,'multiline':False]
['text':' Double-check borderline cases in debug mode.','line_number':606,'multiline':False]
['text':' We have implemented three different projections from cell-space (s,t) to','line_number':623,'multiline':False]
['text':' cube-space (u,v): linear, quadratic, and tangent.  They have the following','line_number':624,'multiline':False]
['text':' tradeoffs:','line_number':625,'multiline':False]
['text':'','line_number':626,'multiline':False]
['text':'   Linear - This is the fastest transformation, but also produces the least','line_number':627,'multiline':False]
['text':'   uniform cell sizes.  Cell areas vary by a factor of about 5.2, with the','line_number':628,'multiline':False]
['text':'   largest cells at the center of each face and the smallest cells in','line_number':629,'multiline':False]
['text':'   the corners.','line_number':630,'multiline':False]
['text':'','line_number':631,'multiline':False]
['text':'   Tangent - Transforming the coordinates via atan() makes the cell sizes','line_number':632,'multiline':False]
['text':'   more uniform.  The areas vary by a maximum ratio of 1.4 as opposed to a','line_number':633,'multiline':False]
['text':'   maximum ratio of 5.2.  However, each call to atan() is about as expensive','line_number':634,'multiline':False]
['text':'   as all of the other calculations combined when converting from points to','line_number':635,'multiline':False]
['text':'   cell ids, i.e. it reduces performance by a factor of 3.','line_number':636,'multiline':False]
['text':'','line_number':637,'multiline':False]
['text':'   Quadratic - This is an approximation of the tangent projection that','line_number':638,'multiline':False]
['text':'   is much faster and produces cells that are almost as uniform in size.','line_number':639,'multiline':False]
['text':'   It is about 3 times faster than the tangent projection for converting','line_number':640,'multiline':False]
['text':'   cell ids to points or vice versa.  Cell areas vary by a maximum ratio of','line_number':641,'multiline':False]
['text':'   about 2.1.','line_number':642,'multiline':False]
['text':'','line_number':643,'multiline':False]
['text':' Here is a table comparing the cell uniformity using each projection.  "Area','line_number':644,'multiline':False]
['text':' ratio" is the maximum ratio over all subdivision levels of the largest cell','line_number':645,'multiline':False]
['text':' area to the smallest cell area at that level, "edge ratio" is the maximum','line_number':646,'multiline':False]
['text':' ratio of the longest edge of any cell to the shortest edge of any cell at','line_number':647,'multiline':False]
['text':' the same level, and "diag ratio" is the ratio of the longest diagonal of','line_number':648,'multiline':False]
['text':' any cell to the shortest diagonal of any cell at the same level.  "ToPoint"','line_number':649,'multiline':False]
['text':' and "FromPoint" are the times in microseconds required to convert cell ids','line_number':650,'multiline':False]
['text':' to and from points (unit vectors) respectively.  "ToPointRaw" is the time','line_number':651,'multiline':False]
['text':' to convert to a non-unit-length vector, which is all that is needed for','line_number':652,'multiline':False]
['text':' some purposes.','line_number':653,'multiline':False]
['text':'','line_number':654,'multiline':False]
['text':'               Area    Edge    Diag   ToPointRaw  ToPoint  FromPoint','line_number':655,'multiline':False]
['text':'              Ratio   Ratio   Ratio             (microseconds)','line_number':656,'multiline':False]
['text':' -------------------------------------------------------------------','line_number':657,'multiline':False]
['text':' Linear:      5.200   2.117   2.959      0.020     0.087     0.085','line_number':658,'multiline':False]
['text':' Tangent:     1.414   1.414   1.704      0.237     0.299     0.258','line_number':659,'multiline':False]
['text':' Quadratic:   2.082   1.802   1.932      0.033     0.096     0.108','line_number':660,'multiline':False]
['text':'','line_number':661,'multiline':False]
['text':' The worst-case cell aspect ratios are about the same with all three','line_number':662,'multiline':False]
['text':' projections.  The maximum ratio of the longest edge to the shortest edge','line_number':663,'multiline':False]
['text':' within the same cell is about 1.4 and the maximum ratio of the diagonals','line_number':664,'multiline':False]
['text':' within the same cell is about 1.7.','line_number':665,'multiline':False]
['text':'','line_number':666,'multiline':False]
['text':' This data was produced using s2cell_unittest and s2cellid_unittest.','line_number':667,'multiline':False]
['text':' Unfortunately, tan(M_PI_4) is slightly less than 1.0.  This isn't due to','line_number':688,'multiline':False]
['text':' a flaw in the implementation of tan(), it's because the derivative of','line_number':689,'multiline':False]
['text':' tan(x) at x=pi/4 is 2, and it happens that the two adjacent floating','line_number':690,'multiline':False]
['text':' point numbers on either side of the infinite-precision value of pi/4 have','line_number':691,'multiline':False]
['text':' tangents that are slightly below and slightly above 1.0 when rounded to','line_number':692,'multiline':False]
['text':' the nearest double-precision result.','line_number':693,'multiline':False]
['text':' This code is equivalent to computing a floating-point "level"','line_number':816,'multiline':False]
['text':' value and rounding up.  frexp() returns a fraction in the','line_number':817,'multiline':False]
['text':' range [0.5,1) and the corresponding exponent.','line_number':818,'multiline':False]
['text':' This code is equivalent to computing a floating-point "level"','line_number':831,'multiline':False]
['text':' value and rounding down.','line_number':832,'multiline':False]
['text':' UTIL_GEOMETRY_S2_H_','line_number':846,'multiline':False]
