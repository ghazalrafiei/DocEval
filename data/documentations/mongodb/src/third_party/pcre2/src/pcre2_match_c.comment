['text':'************************************************
*      Perl-Compatible Regular Expressions       *
************************************************','line_number':1,'multiline':True]
['text':' PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
     Original API code Copyright (c) 1997-2012 University of Cambridge
          New API code Copyright (c) 2015-2022 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
','line_number':5,'multiline':True]
['text':' These defines enable debugging code ','line_number':46,'multiline':True]
['text':' #define DEBUG_FRAMES_DISPLAY ','line_number':48,'multiline':True]
['text':' #define DEBUG_SHOW_OPS ','line_number':49,'multiline':True]
['text':' #define DEBUG_SHOW_RMATCH ','line_number':50,'multiline':True]
['text':' These defines identify the name of the block containing "static"
information, and fields within it. ','line_number':56,'multiline':True]
['text':' Block containing newline information ','line_number':59,'multiline':True]
['text':' Field containing processed string start ','line_number':60,'multiline':True]
['text':' Field containing processed string end ','line_number':61,'multiline':True]
['text':' Bigger than max group number ','line_number':65,'multiline':True]
['text':' Masks for identifying the public options that are permitted at match time. ','line_number':67,'multiline':True]
['text':' Non-error returns from and within the match() function. Error returns are
externally defined PCRE2_ERROR_xxx codes, which are all negative. ','line_number':79,'multiline':True]
['text':' Special internal returns used in the match() function. Make them
sufficiently negative to avoid the external error codes. ','line_number':85,'multiline':True]
['text':' The next 5 must be kept together and in sequence so that a test that checks
for any one of them can use a range. ','line_number':90,'multiline':True]
['text':' Group frame type values. Zero means the frame is not a group frame. The
lower 16 bits are used for data (e.g. the capture number). Group frames are
used for most groups so that information about the start is easily available at
the end without having to scan back through intermediate frames (backtrack
points). ','line_number':100,'multiline':True]
['text':' Masks for the identity and data parts of the group frame type. ','line_number':111,'multiline':True]
['text':' Repetition types ','line_number':116,'multiline':True]
['text':' Min and max values for the common repeats; a maximum of UINT32_MAX =>
infinity. ','line_number':120,'multiline':True]
['text':' * and *? ','line_number':124,'multiline':True]
['text':' + and +? ','line_number':125,'multiline':True]
['text':' ? and ?? ','line_number':126,'multiline':True]
['text':' dummy placefillers for OP_CR[MIN]RANGE ','line_number':127,'multiline':True]
['text':' OP_CRPOS{STAR, PLUS, QUERY} ','line_number':128,'multiline':True]
['text':' * and *? ','line_number':131,'multiline':True]
['text':' + and +? ','line_number':132,'multiline':True]
['text':' ? and ?? ','line_number':133,'multiline':True]
['text':' dummy placefillers for OP_CR[MIN]RANGE ','line_number':134,'multiline':True]
['text':' OP_CRPOS{STAR, PLUS, QUERY} ','line_number':135,'multiline':True]
['text':' Repetition types - must include OP_CRPOSRANGE (not needed above) ','line_number':137,'multiline':True]
['text':' * and *? ','line_number':140,'multiline':True]
['text':' + and +? ','line_number':141,'multiline':True]
['text':' ? and ?? ','line_number':142,'multiline':True]
['text':' OP_CRRANGE and OP_CRMINRANGE ','line_number':143,'multiline':True]
['text':' OP_CRPOSSTAR, OP_CRPOSPLUS ','line_number':144,'multiline':True]
['text':' OP_CRPOSQUERY, OP_CRPOSRANGE ','line_number':145,'multiline':True]
['text':' Numbers for RMATCH calls at backtracking points. When these lists are
changed, the code at RETURN_SWITCH below must be updated in sync.  ','line_number':147,'multiline':True]
['text':' Define short names for general fields in the current backtrack frame, which
is always pointed to by the F variable. Occasional references to fields in
other frames are written out explicitly. There are also some fields in the
current frame whose names start with "temp" that are used for short-term,
localised backtracking memory. These are #defined with Lxxx names at the point
of use and undefined afterwards. ','line_number':166,'multiline':True]
['text':'************************************************
*      Display current frames and contents       *
************************************************','line_number':192,'multiline':True]
['text':' This debugging function displays the current set of frames and their
contents. It is not called automatically from anywhere, the intention being
that calls can be inserted where necessary when debugging frame-related
problems.

Arguments:
  f           the file to write to
  F           the current top frame
  P           a previous frame of interest
  frame_size  the frame size
  mb          points to the match block
  s           identification text

Returns:    nothing
','line_number':196,'multiline':True]
['text':'************************************************
*                Process a callout               *
************************************************','line_number':248,'multiline':True]
['text':' This function is called for all callouts, whether "standalone" or at the
start of a conditional group. Feptr will be pointing to either OP_CALLOUT or
OP_CALLOUT_STR. A callout block is allocated in pcre2_match() and initialized
with fixed values.

Arguments:
  F          points to the current backtracking frame
  mb         points to the match block
  lengthptr  where to return the length of the callout item

Returns:     the return from the callout
             or 0 if no callout function exists
','line_number':252,'multiline':True]
['text':' No callout function provided ','line_number':277,'multiline':True]
['text':' The original matching code (pre 10.30) worked directly with the ovector
passed by the user, and this was passed to callouts. Now that the working
ovector is in the backtracking frame, it no longer needs to reserve space for
the overall match offsets (which would waste space in the frame). For backward
compatibility, however, we pass capture_top and offset_vector to the callout as
if for the extended ovector, and we ensure that the first two slots are unset
by preserving and restoring their current contents. Picky compilers complain if
references such as Fovector[-2] are use directly, so we set up a separate
pointer. ','line_number':279,'multiline':True]
['text':' The cb->version, cb->subject, cb->subject_length, and cb->start_match fields
are set externally. The first 3 never change; the last is updated for each
bumpalong. ','line_number':291,'multiline':True]
['text':' Numerical callout ','line_number':304,'multiline':True]
['text':' String callout ','line_number':311,'multiline':True]
['text':'************************************************
*          Match a back-reference                *
************************************************','line_number':332,'multiline':True]
['text':' This function is called only when it is known that the offset lies within
the offsets that have so far been used in the match. Note that in caseless
UTF-8 mode, the number of subject bytes matched may be different to the number
of reference bytes. (In theory this could also happen in UTF-16 mode, but it
seems unlikely.)

Arguments:
  offset      index into the offset vector
  caseless    TRUE if caseless
  F           the current backtracking frame pointer
  mb          points to match block
  lengthptr   pointer for returning the length matched

Returns:      = 0 sucessful match; number of code units matched is set
              < 0 no match
              > 0 partial match
','line_number':336,'multiline':True]
['text':' Deal with an unset group. The default is no match, but there is an option to
match an empty string. ','line_number':363,'multiline':True]
['text':' Match ','line_number':371,'multiline':True]
['text':' No match ','line_number':373,'multiline':True]
['text':' Separate the caseless and UTF cases for speed. ','line_number':376,'multiline':True]
['text':' Match characters up to the end of the reference. NOTE: the number of
    code units matched may differ, because in UTF-8 there are some characters
    whose upper and lower case codes have different numbers of bytes. For
    example, U+023A (2 bytes in UTF-8) is the upper case version of U+2C65 (3
    bytes in UTF-8); a sequence of 3 of the former uses 6 bytes, as does a
    sequence of two of the latter. It is important, therefore, to check the
    length along the reference, not along the subject (earlier code did this
    wrong). UCP without uses Unicode properties but without UTF encoding. ','line_number':391,'multiline':True]
['text':' Partial match ','line_number':404,'multiline':True]
['text':' No match ','line_number':423,'multiline':True]
['text':' Not in UTF or UCP mode ','line_number':432,'multiline':True]
['text':' Partial match ','line_number':437,'multiline':True]
['text':' No match ','line_number':441,'multiline':True]
['text':' In the caseful case, we can just compare the code units, whether or not we
are in UTF and/or UCP mode. When partial matching, we have to do this unit by
unit. ','line_number':448,'multiline':True]
['text':' Partial match ','line_number':458,'multiline':True]
['text':' No match ','line_number':459,'multiline':True]
['text':' Not partial matching ','line_number':463,'multiline':True]
['text':' Partial ','line_number':467,'multiline':True]
['text':' No match ','line_number':468,'multiline':True]
['text':' Match ','line_number':474,'multiline':True]
['text':'*****************************************************************************
*******************************************************************************
                   "Recursion" in the match() function

The original match() function was highly recursive, but this proved to be the
source of a number of problems over the years, mostly because of the relatively
small system stacks that are commonly found. As new features were added to
patterns, various kludges were invented to reduce the amount of stack used,
making the code hard to understand in places.

A version did exist that used individual frames on the heap instead of calling
match() recursively, but this ran substantially slower. The current version is
a refactoring that uses a vector of frames to remember backtracking points.
This runs no slower, and possibly even a bit faster than the original recursive
implementation. An initial vector of size START_FRAMES_SIZE (enough for maybe
50 frames) is allocated on the system stack. If this is not big enough, the
heap is used for a larger vector.

*******************************************************************************
*****************************************************************************','line_number':479,'multiline':True]
['text':'************************************************
*       Macros for the match() function          *
************************************************','line_number':503,'multiline':True]
['text':' These macros pack up tests that are used for partial matching several times
in the code. The second one is used when we already know we are past the end of
the subject. We set the "hit end" flag if the pointer is at the end of the
subject and either (a) the pointer is past the earliest inspected character
(i.e. something has been matched, even if not part of the actual matched
string), or (b) the pattern contains a lookbehind. These are the conditions for
which adding more characters may allow the current match to continue.

For hard partial matching, we immediately return a partial match. Otherwise,
carrying on means that a complete match on the current subject will be sought.
A partial match is returned only if no complete match can be found. ','line_number':507,'multiline':True]
['text':' These macros are used to implement backtracking. They simulate a recursive
call to the match() function by means of a local vector of frames which
remember the backtracking points. ','line_number':534,'multiline':True]
['text':'************************************************
*         Match from current position            *
************************************************','line_number':554,'multiline':True]
['text':' This function is called to run one match attempt at a single starting point
in the subject.

Performance note: It might be tempting to extract commonly used fields from the
mb structure (e.g. end_subject) into individual variables to improve
performance. Tests using gcc on a SPARC disproved this; in the first case, it
made performance worse.

Arguments:
   start_eptr   starting character in subject
   start_ecode  starting position in compiled code
   ovector      pointer to the final output vector
   oveccount    number of pairs in ovector
   top_bracket  number of capturing parentheses in the pattern
   frame_size   size of each backtracking frame
   mb           pointer to "static" variables block

Returns:        MATCH_MATCH if matched            )  these values are >= 0
                MATCH_NOMATCH if failed to match  )
                negative MATCH_xxx value for PRUNE, SKIP, etc
                negative PCRE2_ERROR_xxx value if aborted by an error condition
                (e.g. stopped by repeated call or depth limit)
','line_number':558,'multiline':True]
['text':' Frame-handling variables ','line_number':587,'multiline':True]
['text':' Current frame pointer ','line_number':589,'multiline':True]
['text':' Temporary frame pointers ','line_number':590,'multiline':True]
['text':' For passing back a frame with captures ','line_number':592,'multiline':True]
['text':' Amount to copy when creating a new frame ','line_number':593,'multiline':True]
['text':' Local variables that do not need to be preserved over calls to RRMATCH(). ','line_number':595,'multiline':True]
['text':' Temp pointer to start of group ','line_number':597,'multiline':True]
['text':' Used for group offsets ','line_number':598,'multiline':True]
['text':' Used for various length calculations ','line_number':599,'multiline':True]
['text':' Return from functions & backtracking "recursions" ','line_number':601,'multiline':True]
['text':' Type of character property ','line_number':603,'multiline':True]
['text':' Used for local loops ','line_number':606,'multiline':True]
['text':' Character values ','line_number':607,'multiline':True]
['text':' Used for group and other numbers ','line_number':608,'multiline':True]
['text':' Type of repetition (0 to avoid compiler warning) ','line_number':609,'multiline':True]
['text':' Specifies type for new group frames ','line_number':610,'multiline':True]
['text':' Used in conditional groups ','line_number':612,'multiline':True]
['text':' Used in "word" tests ','line_number':613,'multiline':True]
['text':' Used in "word" tests ','line_number':614,'multiline':True]
['text':' UTF and UCP flags ','line_number':616,'multiline':True]
['text':' Required for convenience even when no Unicode support ','line_number':622,'multiline':True]
['text':' This is the length of the last part of a backtracking frame that must be
copied when a new frame is created. ','line_number':625,'multiline':True]
['text':' Set up the first current frame at the start of the vector, and initialize
fields that are not reset for new frames. ','line_number':630,'multiline':True]
['text':' "Recursion" depth ','line_number':634,'multiline':True]
['text':' Number of most recent capture ','line_number':635,'multiline':True]
['text':' Not pattern recursing. ','line_number':636,'multiline':True]
['text':' Current data pointer and start match ','line_number':637,'multiline':True]
['text':' Most recent mark ','line_number':638,'multiline':True]
['text':' End of captures within the frame ','line_number':639,'multiline':True]
['text':' Saved frame of most recent group ','line_number':640,'multiline':True]
['text':' Not a start of group frame ','line_number':641,'multiline':True]
['text':' Start processing with this frame ','line_number':642,'multiline':True]
['text':' Come back here when we want to create a new frame for remembering a
backtracking point. ','line_number':644,'multiline':True]
['text':' Set up a new backtracking frame. If the vector is full, get a new one
on the heap, doubling the size, but constrained by the heap limit. ','line_number':649,'multiline':True]
['text':' Copy those fields that must be copied into the new frame, increase the
"recursion" depth (i.e. the new frame's index) and then make the new frame
current. ','line_number':710,'multiline':True]
['text':' Carry on processing with a new frame. ','line_number':721,'multiline':True]
['text':' Starting code pointer ','line_number':725,'multiline':True]
['text':' Default is go back one frame ','line_number':726,'multiline':True]
['text':' If this is a special type of group frame, remember its offset for quick
access at the end of the group. If this is a recursion, set a new current
recursion value. ','line_number':728,'multiline':True]
['text':' ========================================================================= ','line_number':741,'multiline':True]
['text':' This is the main processing loop. First check that we haven't recorded too
many backtracks (search tree is too large), or that we haven't exceeded the
recursive depth limit (used too many backtracking frames). If not, process the
opcodes. ','line_number':742,'multiline':True]
['text':' Cast needed for 16-bit and 32-bit modes ','line_number':756,'multiline':True]
['text':' ===================================================================== ','line_number':759,'multiline':True]
['text':' Before OP_ACCEPT there may be any number of OP_CLOSE opcodes, to close
    any currently open capturing brackets. Unlike reaching the end of a group,
    where we know the starting frame is at the top of the chained frames, in
    this case we have to search back for the relevant frame in case other types
    of group that use chained frames have intervened. Multiple OP_CLOSEs always
    come innermost first, which matches the chain order. We can ignore this in
    a recursion, because captures are not passed out of recursions. ','line_number':760,'multiline':True]
['text':' ===================================================================== ','line_number':791,'multiline':True]
['text':' Real or forced end of the pattern, assertion, or recursion. In an
    assertion ACCEPT, update the last used pointer and remember the current
    frame so that the captures and mark can be fished out of it. ','line_number':792,'multiline':True]
['text':' If recursing, we have to find the most recent recursion. ','line_number':801,'multiline':True]
['text':' Handle end of a recursion. ','line_number':806,'multiline':True]
['text':' N is now the frame of the recursion; the previous frame is at the
      OP_RECURSE position. Go back there, copying the current subject position
      and mark, and the start_match position (\K might have changed it), and
      then move on past the OP_RECURSE. ','line_number':820,'multiline':True]
['text':' Not a recursion. Fail for an empty string match if either PCRE2_NOTEMPTY
    is set, or if PCRE2_NOTEMPTY_ATSTART is set and we have matched at the
    start of the subject. In both cases, backtracking will then try other
    alternatives, if any. ','line_number':833,'multiline':True]
['text':' Also fail if PCRE2_ENDANCHORED is set and the end of the match is not
    the end of the subject. After (*ACCEPT) we fail the entire match (at this
    position) but backtrack on reaching the end of the pattern. ','line_number':844,'multiline':True]
['text':' We have a successful match of the whole pattern. Record the result and
    then do a direct return from the function. If there is space in the offset
    vector, set any pairs that follow the highest-numbered captured string but
    are less than the number of capturing groups in the pattern to PCRE2_UNSET.
    It is documented that this happens. "Gaps" are set to PCRE2_UNSET
    dynamically. It is only those at the end that need setting here. ','line_number':855,'multiline':True]
['text':' Record where we ended ','line_number':862,'multiline':True]
['text':' and how many extracts were taken ','line_number':863,'multiline':True]
['text':' and the last success mark ','line_number':864,'multiline':True]
['text':' Set i to the smaller of the sizes of the external and frame ovectors. ','line_number':870,'multiline':True]
['text':' Note: NOT RRETURN ','line_number':875,'multiline':True]
['text':'===================================================================== ','line_number':878,'multiline':True]
['text':' Match any single character type except newline; have to take care with
    CRLF newlines and partial matching. ','line_number':879,'multiline':True]
['text':' Fall through ','line_number':893,'multiline':True]
['text':' Match any single character whatsoever. ','line_number':895,'multiline':True]
['text':' DO NOT merge the Feptr++ here; it must ','line_number':898,'multiline':True]
['text':' not be updated before SCHECK_PARTIAL. ','line_number':899,'multiline':True]
['text':' ===================================================================== ','line_number':911,'multiline':True]
['text':' Match a single code unit, even in UTF mode. This opcode really does
    match any code unit, even newline. (It really should be called ANYCODEUNIT,
    of course - the byte name is from pre-16 bit days.) ','line_number':912,'multiline':True]
['text':' DO NOT merge the Feptr++ here; it must ','line_number':917,'multiline':True]
['text':' not be updated before SCHECK_PARTIAL. ','line_number':918,'multiline':True]
['text':' ===================================================================== ','line_number':927,'multiline':True]
['text':' Match a single character, casefully ','line_number':928,'multiline':True]
['text':' Not SCHECK_PARTIAL() ','line_number':939,'multiline':True]
['text':' Not UTF mode ','line_number':950,'multiline':True]
['text':' This one can use SCHECK_PARTIAL() ','line_number':954,'multiline':True]
['text':' ===================================================================== ','line_number':963,'multiline':True]
['text':' Match a single character, caselessly. If we are at the end of the
    subject, give up immediately. We get here only when the pattern character
    has at most one other case. Characters with more than two cases are coded
    as OP_PROP with the pseudo-property PT_CLIST. ','line_number':964,'multiline':True]
['text':' If the pattern character's value is < 128, we know that its other case
      (if any) is also < 128 (and therefore only one code unit long in all
      code-unit widths), so we can use the fast lookup table. We checked above
      that there is at least one character left in the subject. ','line_number':983,'multiline':True]
['text':' Otherwise we must pick up the subject character and use Unicode
      property support to test its other case. Note that we cannot use the
      value of "Flength" to check for sufficient bytes left, because the other
      case of the character may have more or fewer code units. ','line_number':996,'multiline':True]
['text':' If UCP is set without UTF we must do the same as above, but with one
    character per code unit. ','line_number':1010,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':1030,'multiline':True]
['text':' Not UTF or UCP mode; use the table for characters < 256. ','line_number':1032,'multiline':True]
['text':' ===================================================================== ','line_number':1042,'multiline':True]
['text':' Match not a single character. ','line_number':1043,'multiline':True]
['text':' Caseful match ','line_number':1062,'multiline':True]
['text':' If caseless ','line_number':1064,'multiline':True]
['text':' UCP without UTF is as above, but with one character per code unit. ','line_number':1074,'multiline':True]
['text':' Caseful match ','line_number':1085,'multiline':True]
['text':' If caseless ','line_number':1087,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':1098,'multiline':True]
['text':' Neither UTF nor UCP is set ','line_number':1100,'multiline':True]
['text':' ===================================================================== ','line_number':1112,'multiline':True]
['text':' Match a single character repeatedly. ','line_number':1113,'multiline':True]
['text':' Common code for all repeated single-character matches. We first check
    for the minimum number of characters. If the minimum equals the maximum, we
    are done. Otherwise, if minimizing, check the rest of the pattern for a
    match; if there isn't one, advance up to the maximum, one character at a
    time.

    If maximizing, advance up to the maximum number of matching characters,
    until Feptr is past the end of the maximum run. If possessive, we are
    then done (no backing up). Otherwise, match at this position; anything
    other than no match is immediately returned. For nomatch, back up one
    character, unless we are matching \R and the last thing matched was
    \r\n, in which case, back up two code units until we reach the first
    optional character position.

    The various UTF/non-UTF and caseful/caseless cases are handled separately,
    for speed. ','line_number':1194,'multiline':True]
['text':' Handle multi-code-unit character matching, caseful and caseless. ','line_number':1220,'multiline':True]
['text':' Caseless ','line_number':1226,'multiline':True]
['text':' Control never gets here ','line_number':1267,'multiline':True]
['text':' Maximize ','line_number':1270,'multiline':True]
['text':' After \C in UTF mode, Lstart_eptr might be in the middle of a
          Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
          go too far. ','line_number':1289,'multiline':True]
['text':' End of repeated wide character handling ','line_number':1302,'multiline':True]
['text':' Length of UTF character is 1. Put it into the preserved variable and
      fall through to the non-UTF code. ','line_number':1305,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':1311,'multiline':True]
['text':' When not in UTF mode, load a single-code-unit character. Then proceed as
    above, using Unicode casing if either UTF or UCP is set. ','line_number':1313,'multiline':True]
['text':' Caseless comparison ','line_number':1318,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':1326,'multiline':True]
['text':' Lc will be < 128 in UTF-8 mode. ','line_number':1327,'multiline':True]
['text':' 16-bit & 32-bit ','line_number':1329,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':1333,'multiline':True]
['text':' PCRE2_CODE_UNIT_WIDTH == 8 ','line_number':1335,'multiline':True]
['text':' Faster than PCRE2_UCHAR ','line_number':1339,'multiline':True]
['text':' Faster than PCRE2_UCHAR ','line_number':1355,'multiline':True]
['text':' Control never gets here ','line_number':1368,'multiline':True]
['text':' Maximize ','line_number':1371,'multiline':True]
['text':' Faster than PCRE2_UCHAR ','line_number':1376,'multiline':True]
['text':' Caseful comparisons (includes all multi-byte characters) ','line_number':1396,'multiline':True]
['text':' Control never gets here ','line_number':1426,'multiline':True]
['text':' Maximize ','line_number':1428,'multiline':True]
['text':' ===================================================================== ','line_number':1463,'multiline':True]
['text':' Match a negated single one-byte character repeatedly. This is almost a
    repeat of the code for a repeated single character, but I haven't found a
    nice way of commoning these up that doesn't require a test of the
    positive/negative option for each character match. Maybe that wouldn't add
    very much to the time taken, but character matching *is* what this is all
    about... ','line_number':1464,'multiline':True]
['text':' Common code for all repeated single-character non-matches. ','line_number':1548,'multiline':True]
['text':' The code is duplicated for the caseless and caseful cases, for speed,
    since matching characters is likely to be quite common. First, ensure the
    minimum number of matches are present. If Lmin = Lmax, we are done.
    Otherwise, if minimizing, keep trying the rest of the expression and
    advancing one matching character if failing, up to the maximum.
    Alternatively, if maximizing, find the maximum number of characters and
    work backwards. ','line_number':1553,'multiline':True]
['text':' Caseless ','line_number':1561,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':1567,'multiline':True]
['text':' Other case from table ','line_number':1569,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':1587,'multiline':True]
['text':' Not UTF mode ','line_number':1589,'multiline':True]
['text':' Finished for exact count ','line_number':1603,'multiline':True]
['text':'SUPPORT_UNICODE ','line_number':1626,'multiline':True]
['text':' Not UTF mode ','line_number':1628,'multiline':True]
['text':' Control never gets here ','line_number':1644,'multiline':True]
['text':' Maximize case ','line_number':1647,'multiline':True]
['text':' After \C in UTF mode, Lstart_eptr might be in the middle of a
          Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
          go too far. ','line_number':1670,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':1684,'multiline':True]
['text':' Not UTF mode ','line_number':1686,'multiline':True]
['text':' Caseful comparisons ','line_number':1709,'multiline':True]
['text':' Not UTF mode ','line_number':1730,'multiline':True]
['text':' Not UTF mode ','line_number':1767,'multiline':True]
['text':' Control never gets here ','line_number':1782,'multiline':True]
['text':' Maximize case ','line_number':1785,'multiline':True]
['text':' After \C in UTF mode, Lstart_eptr might be in the middle of a
          Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
          go too far. ','line_number':1808,'multiline':True]
['text':' Not UTF mode ','line_number':1823,'multiline':True]
['text':' ===================================================================== ','line_number':1854,'multiline':True]
['text':' Match a bit-mapped character class, possibly repeatedly. These opcodes
    are used when all the characters in the class have values in the range
    0-255, and either the matching is caseful, or the characters are in the
    range 0-127 when UTF processing is enabled. The only difference between
    OP_CLASS and OP_NCLASS occurs when a data character outside the range is
    encountered. ','line_number':1855,'multiline':True]
['text':' Save for matching ','line_number':1871,'multiline':True]
['text':' Advance past the item ','line_number':1872,'multiline':True]
['text':' Look past the end of the item to see if there is repeat information
      following. Then obey similar code to character type repeats. ','line_number':1874,'multiline':True]
['text':' Max 0 => infinity ','line_number':1899,'multiline':True]
['text':' No repeat follows ','line_number':1904,'multiline':True]
['text':' First, ensure the minimum number of matches are present. ','line_number':1909,'multiline':True]
['text':' Not UTF mode ','line_number':1932,'multiline':True]
['text':' If Lmax == Lmin we are done. Continue with main loop. ','line_number':1953,'multiline':True]
['text':' If minimizing, keep testing the rest of the expression and advancing
      the pointer while it matches the class. ','line_number':1957,'multiline':True]
['text':' Not UTF mode ','line_number':1986,'multiline':True]
['text':' Control never gets here ','line_number':2009,'multiline':True]
['text':' If maximizing, find the longest possible run, then work backwards. ','line_number':2012,'multiline':True]
['text':' No backtracking ','line_number':2039,'multiline':True]
['text':' After \C in UTF mode, Lstart_eptr might be in the middle of a
          Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
          go too far. ','line_number':2041,'multiline':True]
['text':' Tried at original position ','line_number':2049,'multiline':True]
['text':' Not UTF mode ','line_number':2055,'multiline':True]
['text':' No backtracking ','line_number':2076,'multiline':True]
['text':' Control never gets here ','line_number':2089,'multiline':True]
['text':' ===================================================================== ','line_number':2098,'multiline':True]
['text':' Match an extended character class. In the 8-bit library, this opcode is
    encountered only when UTF-8 mode mode is supported. In the 16-bit and
    32-bit libraries, codepoints greater than 255 may be encountered even when
    UTF is not supported. ','line_number':2099,'multiline':True]
['text':' Save for matching ','line_number':2112,'multiline':True]
['text':' Advance past the item ','line_number':2113,'multiline':True]
['text':' Max 0 => infinity ','line_number':2137,'multiline':True]
['text':' No repeat follows ','line_number':2142,'multiline':True]
['text':' First, ensure the minimum number of matches are present. ','line_number':2147,'multiline':True]
['text':' If Lmax == Lmin we can just continue with the main loop. ','line_number':2160,'multiline':True]
['text':' If minimizing, keep testing the rest of the expression and advancing
      the pointer while it matches the class. ','line_number':2164,'multiline':True]
['text':' Control never gets here ','line_number':2182,'multiline':True]
['text':' If maximizing, find the longest possible run, then work backwards. ','line_number':2185,'multiline':True]
['text':' No backtracking ','line_number':2207,'multiline':True]
['text':' After \C in UTF mode, Lstart_eptr might be in the middle of a
        Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
        go too far. ','line_number':2209,'multiline':True]
['text':' Tried at original position ','line_number':2217,'multiline':True]
['text':' Control never gets here ','line_number':2225,'multiline':True]
['text':' SUPPORT_WIDE_CHARS: end of XCLASS ','line_number':2227,'multiline':True]
['text':' ===================================================================== ','line_number':2235,'multiline':True]
['text':' Match various character types when PCRE2_UCP is not set. These opcodes
    are not generated when PCRE2_UCP is set - instead appropriate property
    tests are compiled. ','line_number':2236,'multiline':True]
['text':' Not EBCDIC ','line_number':2340,'multiline':True]
['text':' Byte and multibyte cases ','line_number':2356,'multiline':True]
['text':' Byte and multibyte cases ','line_number':2371,'multiline':True]
['text':' ===================================================================== ','line_number':2410,'multiline':True]
['text':' Check the next character by Unicode property. We will get here only
    if the support is in the binary; otherwise a compile-time error occurs. ','line_number':2411,'multiline':True]
['text':' These are specials ','line_number':2463,'multiline':True]
['text':' Perl space used to exclude VT, but from Perl 5.18 it is included,
        which means that Perl space and POSIX space are now identical. PCRE
        was changed at release 8.34. ','line_number':2471,'multiline':True]
['text':' Perl space ','line_number':2475,'multiline':True]
['text':' POSIX space ','line_number':2476,'multiline':True]
['text':' This should never occur ','line_number':2529,'multiline':True]
['text':' ===================================================================== ','line_number':2540,'multiline':True]
['text':' Match an extended Unicode sequence. We will get here only if the support
    is in the binary; otherwise a compile-time error occurs. ','line_number':2541,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':2560,'multiline':True]
['text':' ===================================================================== ','line_number':2563,'multiline':True]
['text':' Match a single character type repeatedly. Note that the property type
    does not need to be in a stack frame as it is not used within an RMATCH()
    loop. ','line_number':2564,'multiline':True]
['text':' Common code for all repeated character type matches. ','line_number':2626,'multiline':True]
['text':' Code for the character type ','line_number':2629,'multiline':True]
['text':' First, ensure the minimum number of matches are present. Use inline
    code for maximizing the speed, and do the type test once at the start
    (i.e. keep it out of the loops). As there are no calls to RMATCH in the
    loops, we can use an ordinary variable for "notmatch". The code for UTF
    mode is separated out for tidiness, except for Unicode property tests. ','line_number':2640,'multiline':True]
['text':' Property tests in all modes ','line_number':2649,'multiline':True]
['text':' Perl space used to exclude VT, but from Perl 5.18 it is included,
          which means that Perl space and POSIX space are now identical. PCRE
          was changed at release 8.34. ','line_number':2762,'multiline':True]
['text':' Perl space ','line_number':2766,'multiline':True]
['text':' POSIX space ','line_number':2767,'multiline':True]
['text':' This should not occur ','line_number':2884,'multiline':True]
['text':' Match extended Unicode sequences. We will get here only if the
      support is in the binary; otherwise a compile-time error occurs. ','line_number':2891,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':2913,'multiline':True]
['text':' Handle all other cases in UTF mode ','line_number':2915,'multiline':True]
['text':' Not EBCDIC ','line_number':2987,'multiline':True]
['text':' No need to skip more code units - we know it has only one. ','line_number':3089,'multiline':True]
['text':' No need to skip more code units - we know it has only one. ','line_number':3123,'multiline':True]
['text':' No need to skip more code units - we know it has only one. ','line_number':3157,'multiline':True]
['text':' End switch(Lctype) ','line_number':3163,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':3166,'multiline':True]
['text':' Code for the non-UTF case for minimum matching of operators other
      than OP_PROP and OP_NOTPROP. ','line_number':3168,'multiline':True]
['text':' This OP_ANYBYTE case will never be reached because \C gets turned
        into OP_ALLANY in non-UTF mode. Cut out the code so that coverage
        reports don't complain about it's never being used. ','line_number':3204,'multiline':True]
['text':'        case OP_ANYBYTE:
*        if (Feptr > mb->end_subject - Lmin)
*          {
*          SCHECK_PARTIAL();
*          RRETURN(MATCH_NOMATCH);
*          }
*        Feptr += Lmin;
*        break;
','line_number':3208,'multiline':True]
['text':' If Lmin = Lmax we are done. Continue with the main loop. ','line_number':3418,'multiline':True]
['text':' If minimizing, we have to test the rest of the pattern before each
    subsequent match. This means we cannot use a local "notmatch" variable as
    in the other cases. As all 4 temporary 32-bit values in the frame are
    already in use, just test the type each time. ','line_number':3422,'multiline':True]
['text':' Control never gets here ','line_number':3448,'multiline':True]
['text':' Control never gets here ','line_number':3469,'multiline':True]
['text':' Control never gets here ','line_number':3486,'multiline':True]
['text':' Control never gets here ','line_number':3503,'multiline':True]
['text':' Control never gets here ','line_number':3520,'multiline':True]
['text':' Control never gets here ','line_number':3542,'multiline':True]
['text':' Control never gets here ','line_number':3561,'multiline':True]
['text':' Perl space used to exclude VT, but from Perl 5.18 it is included,
          which means that Perl space and POSIX space are now identical. PCRE
          was changed at release 8.34. ','line_number':3563,'multiline':True]
['text':' Perl space ','line_number':3567,'multiline':True]
['text':' POSIX space ','line_number':3568,'multiline':True]
['text':' Control never gets here ','line_number':3593,'multiline':True]
['text':' Control never gets here ','line_number':3614,'multiline':True]
['text':' Control never gets here ','line_number':3644,'multiline':True]
['text':' Control never gets here ','line_number':3663,'multiline':True]
['text':' Control never gets here ','line_number':3680,'multiline':True]
['text':' Control never gets here ','line_number':3702,'multiline':True]
['text':' This should never occur ','line_number':3704,'multiline':True]
['text':' Match extended Unicode sequences. We will get here only if the
      support is in the binary; otherwise a compile-time error occurs. ','line_number':3710,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':3735,'multiline':True]
['text':' UTF mode for non-property testing character types. ','line_number':3737,'multiline':True]
['text':' This is the non-NL case ','line_number':3756,'multiline':True]
['text':' Take care with CRLF partial ','line_number':3757,'multiline':True]
['text':' Not EBCDIC ','line_number':3790,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':3865,'multiline':True]
['text':' Not UTF mode ','line_number':3867,'multiline':True]
['text':' This is the non-NL case ','line_number':3884,'multiline':True]
['text':' Take care with CRLF partial ','line_number':3885,'multiline':True]
['text':' Control never gets here ','line_number':4008,'multiline':True]
['text':' If maximizing, it is worth using inline code for speed, doing the type
    test once at the start (i.e. keep it out of the loops). Once again,
    "notmatch" can be an ordinary local variable because the loops do not call
    RMATCH. ','line_number':4011,'multiline':True]
['text':' Remember where we started ','line_number':4018,'multiline':True]
['text':' Perl space used to exclude VT, but from Perl 5.18 it is included,
          which means that Perl space and POSIX space are now identical. PCRE
          was changed at release 8.34. ','line_number':4144,'multiline':True]
['text':' Perl space ','line_number':4148,'multiline':True]
['text':' POSIX space ','line_number':4149,'multiline':True]
['text':' Break the loop ','line_number':4163,'multiline':True]
['text':' Break the loop ','line_number':4168,'multiline':True]
['text':' Feptr is now past the end of the maximum run ','line_number':4276,'multiline':True]
['text':' No backtracking ','line_number':4278,'multiline':True]
['text':' After \C in UTF mode, Lstart_eptr might be in the middle of a
        Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't
        go too far. ','line_number':4280,'multiline':True]
['text':' Match extended Unicode grapheme clusters. We will get here only if the
      support is in the binary; otherwise a compile-time error occurs. ','line_number':4294,'multiline':True]
['text':' Feptr is now past the end of the maximum run ','line_number':4315,'multiline':True]
['text':' No backtracking ','line_number':4317,'multiline':True]
['text':' We use <= Lstart_eptr rather than == Lstart_eptr to detect the start
        of the run while backtracking because the use of \C in UTF mode can
        cause BACKCHAR to move back past Lstart_eptr. This is just palliative;
        the use of \C in UTF mode is fraught with danger. ','line_number':4319,'multiline':True]
['text':' At start of char run ','line_number':4329,'multiline':True]
['text':' Backtracking over an extended grapheme cluster involves inspecting
          the previous two characters (if present) to see if a break is
          permitted between them. ','line_number':4333,'multiline':True]
['text':' At start of char run ','line_number':4347,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':4363,'multiline':True]
['text':' Take care with CRLF partial ','line_number':4379,'multiline':True]
['text':' Unlimited UTF-8 repeat ','line_number':4409,'multiline':True]
['text':' The "byte" (i.e. "code unit") case is the same as non-UTF ','line_number':4414,'multiline':True]
['text':' Not EBCDIC ','line_number':4448,'multiline':True]
['text':' No backtracking ','line_number':4594,'multiline':True]
['text':' After \C in UTF mode, Lstart_eptr might be in the middle of a
        Unicode character. Use <= Lstart_eptr to ensure backtracking doesn't go
        too far. ','line_number':4596,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':4613,'multiline':True]
['text':' Not UTF mode ','line_number':4615,'multiline':True]
['text':' Take care with CRLF partial ','line_number':4628,'multiline':True]
['text':' No backtracking ','line_number':4851,'multiline':True]
['text':' End of repeat character type processing ','line_number':4864,'multiline':True]
['text':' ===================================================================== ','line_number':4873,'multiline':True]
['text':' Match a back reference, possibly repeatedly. Look past the end of the
    item to see if there is repeat information following. The OP_REF and
    OP_REFI opcodes are used for a reference to a numbered group or to a
    non-duplicated named group. For a duplicated named group, OP_DNREF and
    OP_DNREFI are used. In this case we must scan the list of groups to which
    the name refers, and use the first one that is set. ','line_number':4874,'multiline':True]
['text':' Set up for repetition, or handle the non-repeated case. The maximum and
    minimum must be in the heap frame, but as they are short-term values, we
    use temporary fields. ','line_number':4910,'multiline':True]
['text':' Max 0 => infinity ','line_number':4934,'multiline':True]
['text':' No repeat follows ','line_number':4938,'multiline':True]
['text':' Partial match ','line_number':4943,'multiline':True]
['text':' With the main loop ','line_number':4949,'multiline':True]
['text':' Handle repeated back references. If a set group has length zero, just
    continue with the main loop, because it matches however many times. For an
    unset reference, if the minimum is zero, we can also just continue. We can
    also continue if PCRE2_MATCH_UNSET_BACKREF is set, because this makes unset
    group behave as a zero-length group. For any other unset cases, carrying
    on will result in NOMATCH. ','line_number':4952,'multiline':True]
['text':' Group is not set ','line_number':4963,'multiline':True]
['text':' First, ensure the minimum number of matches are present. ','line_number':4969,'multiline':True]
['text':' Partial match ','line_number':4977,'multiline':True]
['text':' If min = max, we are done. They are not both allowed to be zero. ','line_number':4984,'multiline':True]
['text':' If minimizing, keep trying and advancing the pointer. ','line_number':4988,'multiline':True]
['text':' Partial match ','line_number':5001,'multiline':True]
['text':' Control never gets here ','line_number':5007,'multiline':True]
['text':' If maximizing, find the longest string and work backwards, as long as
    the matched lengths for each iteration are the same. ','line_number':5010,'multiline':True]
['text':' Starting position ','line_number':5016,'multiline':True]
['text':' Can't use CHECK_PARTIAL because we don't want to update Feptr in
          the soft partial matching case. ','line_number':5025,'multiline':True]
['text':' If the length matched for each repetition is the same as the length of
      the captured group, we can easily work backwards. This is the normal
      case. However, in caseless UTF-8 mode there are pairs of case-equivalent
      characters whose lengths (in terms of code units) differ. However, this
      is very rare, so we handle it by re-matching fewer and fewer times. ','line_number':5041,'multiline':True]
['text':' The rare case of non-matching lengths. Re-scan the repetition for each
      iteration. We know that match_ref() will succeed every time. ','line_number':5057,'multiline':True]
['text':' Failed after minimal repetition ','line_number':5067,'multiline':True]
['text':' Control never gets here ','line_number':5081,'multiline':True]
['text':' ========================================================================= ','line_number':5091,'multiline':True]
['text':'           Opcodes for the start of various parenthesized items            ','line_number':5092,'multiline':True]
['text':' ========================================================================= ','line_number':5093,'multiline':True]
['text':' In all cases, if the result of RMATCH() is MATCH_THEN, check whether the
    (*THEN) is within the current branch by comparing the address of OP_THEN
    that is passed back with the end of the branch. If (*THEN) is within the
    current branch, and the branch is one of two or more alternatives (it
    either starts or ends with OP_ALT), we have reached the limit of THEN's
    action, so convert the return code to NOMATCH, which will cause normal
    backtracking to happen from now on. Otherwise, THEN is passed back to an
    outer alternative. This implements Perl's treatment of parenthesized
    groups, where a group not containing | does not affect the current
    alternative, that is, (X) is NOT the same as (X|(*F)). ','line_number':5095,'multiline':True]
['text':' ===================================================================== ','line_number':5107,'multiline':True]
['text':' BRAZERO, BRAMINZERO and SKIPZERO occur just before a non-possessive
    bracket group, indicating that it may occur zero times. It may repeat
    infinitely, or not at all - i.e. it could be ()* or ()? or even (){0} in
    the pattern. Brackets with fixed upper repeat limits are compiled as a
    number of copies, with the optional ones preceded by BRAZERO or BRAMINZERO.
    Possessive groups with possible zero repeats are preceded by BRAPOSZERO. ','line_number':5108,'multiline':True]
['text':' ===================================================================== ','line_number':5142,'multiline':True]
['text':' Handle possessive brackets with an unlimited repeat. The end of these
    brackets will always be OP_KETRPOS, which returns MATCH_KETRPOS without
    going further in the pattern. ','line_number':5143,'multiline':True]
['text':' Zero repeat is allowed ','line_number':5154,'multiline':True]
['text':' Zero repeat not allowed ','line_number':5162,'multiline':True]
['text':' Remembered frame type ','line_number':5165,'multiline':True]
['text':' Zero repeat not allowed ','line_number':5170,'multiline':True]
['text':' Remembered frame type ','line_number':5174,'multiline':True]
['text':' Never matched ','line_number':5177,'multiline':True]
['text':' Start of this group ','line_number':5178,'multiline':True]
['text':' Position at group start ','line_number':5182,'multiline':True]
['text':' Matched at least once ','line_number':5187,'multiline':True]
['text':' Empty match; skip to end ','line_number':5188,'multiline':True]
['text':' See comment above about handling THEN. ','line_number':5198,'multiline':True]
['text':' Success if matched something or zero repeat allowed ','line_number':5213,'multiline':True]
['text':' ===================================================================== ','line_number':5230,'multiline':True]
['text':' Handle non-capturing brackets that cannot match an empty string. When we
    get to the final alternative within the brackets, as long as there are no
    THEN's in the pattern, we can optimize by not recording a new backtracking
    point. (Ideally we should test for a THEN within this group, but we don't
    have that information.) Don't do this if we are at the very top level,
    however, because that would make handling assertions and once-only brackets
    messier when there is nothing to go back to. ','line_number':5231,'multiline':True]
['text':' Set for all that use GROUPLOOP ','line_number':5239,'multiline':True]
['text':' Used only in OP_BRA handling ','line_number':5240,'multiline':True]
['text':' This is never the final branch. We do not need to test for MATCH_THEN
      here because this code is not used when there is a THEN in the pattern. ','line_number':5254,'multiline':True]
['text':' Hit the start of the final branch. Continue at this level. ','line_number':5262,'multiline':True]
['text':' ===================================================================== ','line_number':5270,'multiline':True]
['text':' Handle a capturing bracket, other than those that are possessive with an
    unlimited repeat. ','line_number':5271,'multiline':True]
['text':' ===================================================================== ','line_number':5280,'multiline':True]
['text':' Atomic groups and non-capturing brackets that can match an empty string
    must record a backtracking point and also set up a chained frame. ','line_number':5281,'multiline':True]
['text':' Control never reaches here. ','line_number':5305,'multiline':True]
['text':' ===================================================================== ','line_number':5310,'multiline':True]
['text':' Recursion either matches the current regex, or some subexpression. The
    offset data is the offset to the starting bracket from the start of the
    whole pattern. (This is so that it works from duplicated subpatterns.) ','line_number':5311,'multiline':True]
['text':' If we are already in a recursion, check for repeating the same one
    without advancing the subject pointer. This should catch convoluted mutual
    recursions. (Some simple cases are caught at compile time.) ','line_number':5322,'multiline':True]
['text':' Now run the recursion, branch by branch. ','line_number':5342,'multiline':True]
['text':' Handle backtracking verbs, which are defined in a range that can
      easily be tested for. PCRE does not allow THEN, SKIP, PRUNE or COMMIT to
      escape beyond a recursion; they cause a NOMATCH for the entire recursion.

      When one of these verbs triggers, the current recursion group number is
      recorded. If it matches the recursion we are processing, the verb
      happened within the recursion and we must deal with it. Otherwise it must
      have happened after the recursion completed, and so has to be passed
      back. See comment above about handling THEN. ','line_number':5355,'multiline':True]
['text':' Note that carrying on after (*ACCEPT) in a recursion is handled in the
      OP_ACCEPT code. Nothing needs to be done here. ','line_number':5374,'multiline':True]
['text':' Control never reaches here. ','line_number':5381,'multiline':True]
['text':' ===================================================================== ','line_number':5387,'multiline':True]
['text':' Positive assertions are like other groups except that PCRE doesn't allow
    the effect of (*THEN) to escape beyond an assertion; it is therefore
    treated as NOMATCH. (*ACCEPT) is treated as successful assertion, with its
    captures and mark retained. Any other return is an error. ','line_number':5388,'multiline':True]
['text':' ===================================================================== ','line_number':5425,'multiline':True]
['text':' Handle negative assertions. Loop for each non-matching branch as for
    positive assertions. ','line_number':5426,'multiline':True]
['text':' Assertion matched, therefore it fails. ','line_number':5441,'multiline':True]
['text':' Branch failed, try next if present. ','line_number':5445,'multiline':True]
['text':' Assertion forced to fail, therefore continue. ','line_number':5451,'multiline':True]
['text':' Pass back any other return ','line_number':5457,'multiline':True]
['text':' None of the branches have matched or there was a backtrack to (*COMMIT),
    (*SKIP), (*PRUNE), or (*THEN) in the last branch. This is success for a
    negative assertion, so carry on. ','line_number':5462,'multiline':True]
['text':' ===================================================================== ','line_number':5473,'multiline':True]
['text':' The callout item calls an external function, if one is provided, passing
    details of the match so far. This is mainly for debugging, though the
    function is able to force a failure. ','line_number':5474,'multiline':True]
['text':' ===================================================================== ','line_number':5487,'multiline':True]
['text':' Conditional group: compilation checked that there are no more than two
    branches. If the condition is false, skipping the first branch takes us
    past the end of the item if there is only one branch, but that's exactly
    what we want. ','line_number':5488,'multiline':True]
['text':' The variable Flength will be added to Fecode when the condition is
    false, to get to the second branch. Setting it to the offset to the ALT or
    KET, then incrementing Fecode achieves this effect. However, if the second
    branch is non-existent, we must point to the KET so that the end of the
    group is correctly processed. We now have Fecode pointing to the condition
    or callout. ','line_number':5496,'multiline':True]
['text':' Offset to the second branch ','line_number':5503,'multiline':True]
['text':' From this opcode ','line_number':5505,'multiline':True]
['text':' Because of the way auto-callout works during compile, a callout item is
    inserted between OP_COND and an assertion condition. Such a callout can
    also be inserted manually. ','line_number':5507,'multiline':True]
['text':' Advance Fecode past the callout, so it now points to the condition. We
      must adjust Flength so that the value of Fecode+Flength is unchanged. ','line_number':5517,'multiline':True]
['text':' Test the various possible conditions ','line_number':5524,'multiline':True]
['text':' Group recursion test ','line_number':5529,'multiline':True]
['text':' Duplicate named group recursion test ','line_number':5537,'multiline':True]
['text':' Numbered group used test ','line_number':5552,'multiline':True]
['text':' Doubled ref number ','line_number':5553,'multiline':True]
['text':' Duplicate named group used test ','line_number':5557,'multiline':True]
['text':' The assertion (?!) becomes OP_FAIL ','line_number':5572,'multiline':True]
['text':' The condition is an assertion. Run code similar to the assertion code
      above. ','line_number':5579,'multiline':True]
['text':' Save captures ','line_number':5596,'multiline':True]
['text':' Fall through ','line_number':5602,'multiline':True]
['text':' In the case of a match, the captures have already been put into
          the current frame. ','line_number':5603,'multiline':True]
['text':' TRUE for positive assertion ','line_number':5607,'multiline':True]
['text':' PCRE doesn't allow the effect of (*THEN) to escape beyond an
          assertion; it is therefore always treated as NOMATCH. ','line_number':5610,'multiline':True]
['text':' Try next branch ','line_number':5616,'multiline':True]
['text':' TRUE for negative assertion ','line_number':5617,'multiline':True]
['text':' These force no match without checking other branches. ','line_number':5620,'multiline':True]
['text':' Out of the branch loop ','line_number':5631,'multiline':True]
['text':' If the condition is true, find the end of the assertion so that
      advancing past it gets us to the start of the first branch. ','line_number':5634,'multiline':True]
['text':' End of assertion condition ','line_number':5641,'multiline':True]
['text':' Choose branch according to the condition. ','line_number':5647,'multiline':True]
['text':' If the opcode is OP_SCOND it means we are at a repeated conditional
    group that might match an empty string. We must therefore descend a level
    so that the start is remembered for checking. For OP_COND we can just
    continue at this level. ','line_number':5651,'multiline':True]
['text':' ========================================================================= ','line_number':5666,'multiline':True]
['text':'                  End of start of parenthesis opcodes                      ','line_number':5667,'multiline':True]
['text':' ========================================================================= ','line_number':5668,'multiline':True]
['text':' ===================================================================== ','line_number':5671,'multiline':True]
['text':' Move the subject pointer back. This occurs only at the start of each
    branch of a lookbehind assertion. If we are too close to the start to move
    back, fail. When working with UTF-8 we move back a number of characters,
    not bytes. ','line_number':5672,'multiline':True]
['text':' No UTF-8 support, or not in UTF-8 mode: count is code unit count ','line_number':5692,'multiline':True]
['text':' Save the earliest consulted character, then skip to next opcode ','line_number':5699,'multiline':True]
['text':' ===================================================================== ','line_number':5706,'multiline':True]
['text':' An alternation is the end of a branch; scan along to find the end of the
    bracketed group. ','line_number':5707,'multiline':True]
['text':' ===================================================================== ','line_number':5715,'multiline':True]
['text':' The end of a parenthesized group. For all but OP_BRA and OP_COND, the
    starting frame was added to the chained frames in order to remember the
    starting subject position for the group. ','line_number':5716,'multiline':True]
['text':' Point N to the frame at the start of the most recent group.
    Remember the subject pointer at the start of the group. ','line_number':5727,'multiline':True]
['text':' If we are at the end of an assertion that is a condition, return a
      match, discarding any intermediate backtracking points. Copy back the
      mark setting and the captures into the frame before N so that they are
      set on return. Doing this for all assertions, both positive and negative,
      seems to match what Perl does. ','line_number':5742,'multiline':True]
['text':' Indicates starting frame not recorded ','line_number':5758,'multiline':True]
['text':' The group was not a conditional assertion. ','line_number':5760,'multiline':True]
['text':' No need to do anything for these ','line_number':5764,'multiline':True]
['text':' Non-atomic positive assertions are like OP_BRA, except that the
      subject pointer must be put back to where it was at the start of the
      assertion. ','line_number':5769,'multiline':True]
['text':' Atomic positive assertions are like OP_ONCE, except that in addition
      the subject pointer must be put back to where it was at the start of the
      assertion. ','line_number':5779,'multiline':True]
['text':' Fall through ','line_number':5787,'multiline':True]
['text':' For an atomic group, discard internal backtracking points. We must
      also ensure that any remaining branches within the top-level of the group
      are not tried. Do this by adjusting the code pointer within the backtrack
      frame so that it points to the final branch. ','line_number':5789,'multiline':True]
['text':' A matching negative assertion returns MATCH, which is turned into
      NOMATCH at the assertion level. ','line_number':5804,'multiline':True]
['text':' At the end of a script run, apply the script-checking rules. This code
      will never by exercised if Unicode support it not compiled, because in
      that environment script runs cause an error at compile time. ','line_number':5811,'multiline':True]
['text':' Whole-pattern recursion is coded as a recurse into group 0, so it
      won't be picked up here. Instead, we catch it when the OP_END is reached.
      Other recursion is handled here. ','line_number':5819,'multiline':True]
['text':' Handle a recursively called group. We reinstate the previous set of
      captures and then carry on after the recursion call. ','line_number':5829,'multiline':True]
['text':' With next opcode ','line_number':5841,'multiline':True]
['text':' Deal with actual capturing. ','line_number':5844,'multiline':True]
['text':' End actions relating to the starting opcode ','line_number':5852,'multiline':True]
['text':' OP_KETRPOS is a possessive repeating ket. Remember the current position,
    and return the MATCH_KETRPOS. This makes it possible to do the repeats one
    at a time from the outer level. This must precede the empty string test -
    in this case that test is done at the outer level. ','line_number':5854,'multiline':True]
['text':' Handle the different kinds of closing brackets. A non-repeating ket
    needs no special action, just continuing at this level. This also happens
    for the repeating kets if the group matched no characters, in order to
    forcibly break infinite loops. Otherwise, the repeating kets try the rest
    of the pattern or restart from the preceding bracket, in the appropriate
    order. ','line_number':5867,'multiline':True]
['text':' End of ket processing ','line_number':5881,'multiline':True]
['text':' Repeat the maximum number of times (KETRMAX) ','line_number':5884,'multiline':True]
['text':' Carry on at this level for a non-repeating ket, or after matching an
    empty string, or after repeating for a maximum number of times. ','line_number':5890,'multiline':True]
['text':' ===================================================================== ','line_number':5897,'multiline':True]
['text':' Start and end of line assertions, not multiline mode. ','line_number':5898,'multiline':True]
['text':' Start of line, unless PCRE2_NOTBOL is set. ','line_number':5900,'multiline':True]
['text':' Unconditional start of subject ','line_number':5906,'multiline':True]
['text':' When PCRE2_NOTEOL is unset, assert before the subject end, or a
    terminating newline unless PCRE2_DOLLAR_ENDONLY is set. ','line_number':5911,'multiline':True]
['text':' Fall through ','line_number':5918,'multiline':True]
['text':' Unconditional end of subject assertion (\z) ','line_number':5919,'multiline':True]
['text':' End of subject or ending \n assertion (\Z) ','line_number':5931,'multiline':True]
['text':' Either at end of string or \n before end. ','line_number':5950,'multiline':True]
['text':' ===================================================================== ','line_number':5961,'multiline':True]
['text':' Start and end of line assertions, multiline mode. ','line_number':5962,'multiline':True]
['text':' Start of subject unless notbol, or after any newline except for one at
    the very end, unless PCRE2_ALT_CIRCUMFLEX is set. ','line_number':5964,'multiline':True]
['text':' Assert before any newline, or before end of subject unless noteol is
    set. ','line_number':5978,'multiline':True]
['text':' ===================================================================== ','line_number':6007,'multiline':True]
['text':' Start of match assertion ','line_number':6008,'multiline':True]
['text':' ===================================================================== ','line_number':6016,'multiline':True]
['text':' Reset the start of match point ','line_number':6017,'multiline':True]
['text':' ===================================================================== ','line_number':6025,'multiline':True]
['text':' Word boundary assertions. Find out if the previous and current
    characters are "word" characters. It takes a bit more work in UTF mode.
    Characters > 255 are assumed to be "non-word" characters when PCRE2_UCP is
    not set. When it is set, use Unicode properties if available, even when not
    in UTF mode. Remember the earliest and latest consulted characters. ','line_number':6026,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':6044,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':6057,'multiline':True]
['text':' Get status of next character ','line_number':6061,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':6078,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':6091,'multiline':True]
['text':' Now see if the situation is what we want ','line_number':6095,'multiline':True]
['text':' ===================================================================== ','line_number':6103,'multiline':True]
['text':' Backtracking (*VERB)s, with and without arguments. Note that if the
    pattern is successfully matched, we do not come back from RMATCH. ','line_number':6104,'multiline':True]
['text':' A return of MATCH_SKIP_ARG means that matching failed at SKIP with an
    argument, and we must check whether that argument matches this MARK's
    argument. It is passed back in mb->verb_skip_ptr. If it does match, we
    return MATCH_SKIP with mb->verb_skip_ptr now pointing to the subject
    position that corresponds to this mark. Otherwise, pass back the return
    code unaltered. ','line_number':6111,'multiline':True]
['text':' Pass back current position ','line_number':6121,'multiline':True]
['text':' Record the current recursing group number in mb->verb_current_recurse
    when a backtracking return such as MATCH_COMMIT is given. This enables the
    recurse processing to catch verbs from within the recursion. ','line_number':6129,'multiline':True]
['text':' Pass back current position ','line_number':6162,'multiline':True]
['text':' Note that, for Perl compatibility, SKIP with an argument does NOT set
    nomatch_mark. When a pattern match ends with a SKIP_ARG for which there was
    not a matching mark, we have to re-run the match, ignoring the SKIP_ARG
    that failed and any that precede it (either they also failed, or were not
    triggered). To do this, we maintain a count of executed SKIP_ARGs. If a
    SKIP_ARG gets to top level, the match is re-run with mb->ignore_skip_arg
    set to the count of the one that failed. ','line_number':6166,'multiline':True]
['text':' Pass back the current skip name and return the special MATCH_SKIP_ARG
    return code. This will either be caught by a matching MARK, or get to the
    top, where it causes a rematch with mb->ignore_skip_arg set to the value of
    mb->skip_arg_count. ','line_number':6184,'multiline':True]
['text':' For THEN (and THEN_ARG) we pass back the address of the opcode, so that
    the branch in which it occurs can be determined. ','line_number':6193,'multiline':True]
['text':' ===================================================================== ','line_number':6212,'multiline':True]
['text':' There's been some horrible disaster. Arrival here can only mean there is
    something seriously wrong in the code above or the OP_xxx definitions. ','line_number':6213,'multiline':True]
['text':' Do not insert any code in here without much thought; it is assumed
  that "continue" in the code above comes out to here to repeat the main
  loop. ','line_number':6220,'multiline':True]
['text':' End of main loop ','line_number':6224,'multiline':True]
['text':' Control never reaches here ','line_number':6225,'multiline':True]
['text':' ========================================================================= ','line_number':6228,'multiline':True]
['text':' The RRETURN() macro jumps here. The number that is saved in Freturn_id
indicates which label we actually want to return to. The value in Frdepth is
the index number of the frame in the vector. The return value has been placed
in rrc. ','line_number':6229,'multiline':True]
['text':' Exit from the top level ','line_number':6238,'multiline':True]
['text':' Backtrack ','line_number':6239,'multiline':True]
['text':' Note for callouts ','line_number':6240,'multiline':True]
['text':'************************************************
*           Match a Regular Expression           *
************************************************','line_number':6272,'multiline':True]
['text':' This function applies a compiled pattern to a subject string and picks out
portions of the string if it matches. Two elements in the vector are set for
each substring: the offsets to the start and end of the substring.

Arguments:
  code            points to the compiled expression
  subject         points to the subject string
  length          length of subject string (may contain binary zeros)
  start_offset    where to start in the subject string
  options         option bits
  match_data      points to a match_data block
  mcontext        points a PCRE2 context

Returns:          > 0 => success; value is the number of ovector pairs filled
                  = 0 => success, but ovector is not big enough
                  = -1 => failed to match (PCRE2_ERROR_NOMATCH)
                  = -2 => partial match (PCRE2_ERROR_PARTIAL)
                  < -2 => some kind of unexpected problem
','line_number':6276,'multiline':True]
['text':' This flag is needed even when Unicode is not supported for convenience
(it is used by the IS_NEWLINE macro). ','line_number':6334,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':6346,'multiline':True]
['text':' We need to have mb as a pointer to a match block, because the IS_NEWLINE
macro is used below, and it expects NLBLOCK to be defined as a pointer. ','line_number':6350,'multiline':True]
['text':' Allocate an initial vector of backtracking frames on the stack. If this
proves to be too small, it is replaced by a larger one on the heap. To get a
vector of the size required that is aligned for pointers, allocate it as a
vector of pointers. ','line_number':6357,'multiline':True]
['text':' Recognize NULL, length 0 as an empty string. ','line_number':6366,'multiline':True]
['text':' Plausibility checks ','line_number':6370,'multiline':True]
['text':' Check that the first field in the block is the magic number. ','line_number':6387,'multiline':True]
['text':' Check the code unit width. ','line_number':6391,'multiline':True]
['text':' PCRE2_NOTEMPTY and PCRE2_NOTEMPTY_ATSTART are match-time flags in the
options variable for this function. Users of PCRE2 who are not calling the
function directly would like to have a way of setting these flags, in the same
way that they can set pcre2_compile() flags like PCRE2_NO_AUTOPOSSESS with
constructions like (*NO_AUTOPOSSESS). To enable this, (*NOTEMPTY) and
(*NOTEMPTY_ATSTART) set bits in the pattern's "flag" function which we now
transfer to the options for this function. The bits are guaranteed to be
adjacent, but do not have the same values. This bit of Boolean trickery assumes
that the match-time bits are not more significant than the flag bits. If by
accident this is not the case, a compile-time division by zero error will
occur. ','line_number':6396,'multiline':True]
['text':' If the pattern was successfully studied with JIT support, we will run the
JIT executable instead of the rest of this function. Most options must be set
at compile time for the JIT code to be usable. ','line_number':6414,'multiline':True]
['text':' Initialize UTF/UCP parameters. ','line_number':6423,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':6429,'multiline':True]
['text':' Convert the partial matching flags into an integer. ','line_number':6431,'multiline':True]
['text':' Partial matching and PCRE2_ENDANCHORED are currently not allowed at the same
time. ','line_number':6436,'multiline':True]
['text':' It is an error to set an offset limit without setting the flag at compile
time. ','line_number':6443,'multiline':True]
['text':' If the match data block was previously used with PCRE2_COPY_MATCHED_SUBJECT,
free the memory that was obtained. Set the field to NULL for no match cases. ','line_number':6450,'multiline':True]
['text':' Zero the error offset in case the first code unit is invalid UTF. ','line_number':6461,'multiline':True]
['text':' ============================= JIT matching ============================== ','line_number':6466,'multiline':True]
['text':' Prepare for JIT matching. Check a UTF string for validity unless no check is
requested or invalid UTF can be handled. We check only the portion of the
subject that might be be inspected during matching - from the offset minus the
maximum lookbehind to the given length. This saves time when a small part of a
large subject is being matched by the use of a starting offset. Note that the
maximum lookbehind is a number of characters, not code units. ','line_number':6468,'multiline':True]
['text':' For 8-bit and 16-bit UTF, check that the first code unit is a valid
    character start. ','line_number':6485,'multiline':True]
['text':' Isolated 0x80 byte ','line_number':6493,'multiline':True]
['text':' Isolated low surrogate ','line_number':6495,'multiline':True]
['text':' WIDTH != 32 ','line_number':6498,'multiline':True]
['text':' Move back by the maximum lookbehind, just in case it happens at the very
    start of matching. ','line_number':6500,'multiline':True]
['text':' 16-bit ','line_number':6510,'multiline':True]
['text':' PCRE2_CODE_UNIT_WIDTH != 32 ','line_number':6515,'multiline':True]
['text':' In the 32-bit library, one code unit equals one character. However,
    we cannot just subtract the lookbehind and then compare pointers, because
    a very large lookbehind could create an invalid pointer. ','line_number':6517,'multiline':True]
['text':' PCRE2_CODE_UNIT_WIDTH != 32 ','line_number':6525,'multiline':True]
['text':' Validate the relevant portion of the subject. Adjust the offset of an
    invalid code point to be an absolute offset in the whole string. ','line_number':6527,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':6539,'multiline':True]
['text':' If JIT returns BADOPTION, which means that the selected complete or
  partial matching mode was not compiled, fall through to the interpreter. ','line_number':6541,'multiline':True]
['text':' SUPPORT_JIT ','line_number':6560,'multiline':True]
['text':' ========================= End of JIT matching ========================== ','line_number':6562,'multiline':True]
['text':' Proceed with non-JIT matching. The default is to allow lookbehinds to the
start of the subject. A UTF check when there is a non-zero offset may change
this. ','line_number':6565,'multiline':True]
['text':' If a UTF subject string was not checked for validity in the JIT code above,
check it here, and handle support for invalid UTF strings. The check above
happens only when invalid UTF is not supported and PCRE2_NO_CHECK_UTF is unset.
If we get here in those circumstances, it means the subject string is valid,
but for some reason JIT matching was not successful. There is no need to check
the subject again.

We check only the portion of the subject that might be be inspected during
matching - from the offset minus the maximum lookbehind to the given length.
This saves time when a small part of a large subject is being matched by the
use of a starting offset. Note that the maximum lookbehind is a number of
characters, not code units.

Note also that support for invalid UTF forces a check, overriding the setting
of PCRE2_NO_CHECK_UTF. ','line_number':6571,'multiline':True]
['text':' For 8-bit and 16-bit UTF, check that the first code unit is a valid
  character start. If we are handling invalid UTF, just skip over such code
  units. Otherwise, give an appropriate error. ','line_number':6598,'multiline':True]
['text':' Isolated 0x80 byte ','line_number':6615,'multiline':True]
['text':' Isolated low surrogate ','line_number':6617,'multiline':True]
['text':' WIDTH != 32 ','line_number':6620,'multiline':True]
['text':' The mb->check_subject field points to the start of UTF checking;
  lookbehinds can go back no further than this. ','line_number':6622,'multiline':True]
['text':' Move back by the maximum lookbehind, just in case it happens at the very
  start of matching, but don't do this if we skipped bad 8-bit or 16-bit code
  units above. ','line_number':6627,'multiline':True]
['text':' 16-bit ','line_number':6641,'multiline':True]
['text':' PCRE2_CODE_UNIT_WIDTH != 32 ','line_number':6647,'multiline':True]
['text':' In the 32-bit library, one code unit equals one character. However,
  we cannot just subtract the lookbehind and then compare pointers, because
  a very large lookbehind could create an invalid pointer. ','line_number':6649,'multiline':True]
['text':' PCRE2_CODE_UNIT_WIDTH != 32 ','line_number':6657,'multiline':True]
['text':' Validate the relevant portion of the subject. There's a loop in case we
  encounter bad UTF in the characters preceding start_match which we are
  scanning because of a lookbehind. ','line_number':6659,'multiline':True]
['text':' Valid UTF string ','line_number':6668,'multiline':True]
['text':' Invalid UTF string. Adjust the offset to be an absolute offset in the
    whole string. If we are handling invalid UTF strings, set end_subject to
    stop before the bad code unit, and set the options to "not end of line".
    Otherwise return the error. ','line_number':6670,'multiline':True]
['text':' If the end precedes start_match, it means there is invalid UTF in the
    extra code units we reversed over because of a lookbehind. Advance past the
    first bad code unit, and then skip invalid character starting code units in
    8-bit and 16-bit modes, and try again with the original end point. ','line_number':6679,'multiline':True]
['text':' Otherwise, set the not end of line option, and do the match. ','line_number':6694,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':6703,'multiline':True]
['text':' A NULL match context means "use a default context", but we take the memory
control functions from the pattern. ','line_number':6705,'multiline':True]
['text':' Initialize and set up the fixed fields in the callout block, with a pointer
in the match block. ','line_number':6721,'multiline':True]
['text':' Fill in the remaining fields in the match block, except for moptions, which
gets set later. ','line_number':6730,'multiline':True]
['text':' Pattern options ','line_number':6742,'multiline':True]
['text':' In case never set ','line_number':6744,'multiline':True]
['text':' The name table is needed for finding all the numbers associated with a
given name, for condition testing. The code follows the name table. ','line_number':6746,'multiline':True]
['text':' Process the \R and newline settings. ','line_number':6754,'multiline':True]
['text':' The backtracking frames have fixed data at the front, and a PCRE2_SIZE
vector at the end, whose size depends on the number of capturing parentheses in
the pattern. It is not used at all if there are no capturing parentheses.

  frame_size             is the total size of each frame
  mb->frame_vector_size  is the total usable size of the vector (rounded down
                           to a whole number of frames)

The last of these is changed within the match() function if the frame vector
has to be expanded. We therefore put it into the match block so that it is
correct when calling match() more than once for non-anchored patterns.

We must also pad frame_size for alignment to ensure subsequent frames are as
aligned as heapframe. Whilst ovector is word-aligned due to being a PCRE2_SIZE
array, that does not guarantee it is suitably aligned for pointers, as some
architectures have pointers that are larger than a size_t. ','line_number':6792,'multiline':True]
['text':' Limits set in the pattern override the match context only if they are
smaller. ','line_number':6813,'multiline':True]
['text':' If a pattern has very many capturing parentheses, the frame size may be very
large. Ensure that there are at least 10 available frames by getting an initial
vector on the heap if necessary, except when the heap limit prevents this. Get
fewer if possible. (The heap limit is in kibibytes.) ','line_number':6825,'multiline':True]
['text':' Initial frame vector on the stack ','line_number':6832,'multiline':True]
['text':' Write to the ovector within the first frame to mark every capture unset and
to avoid uninitialized memory read errors when it is copied to a new frame. ','line_number':6851,'multiline':True]
['text':' Pointers to the individual character tables ','line_number':6857,'multiline':True]
['text':' Set up the first code unit to match, if available. If there's no first code
unit there may be a bitmap of possible first characters. ','line_number':6863,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':6879,'multiline':True]
['text':' There may also be a "last known required character" set. ','line_number':6886,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':6901,'multiline':True]
['text':' ==========================================================================','line_number':6906,'multiline':True]
['text':' Loop for handling unanchored repeated matching attempts; for anchored regexs
the loop runs just once. ','line_number':6908,'multiline':True]
['text':' ----------------- Start of match optimizations ---------------- ','line_number':6927,'multiline':True]
['text':' There are some optimizations that avoid running the match if a known
  starting point is not found, or if a known later code unit is not present.
  However, there is an option (settable at compile time) that disables these,
  for testing and for ensuring that all callouts do actually occur. ','line_number':6929,'multiline':True]
['text':' If firstline is TRUE, the start of the match is constrained to the first
    line of a multiline string. That is, the match must be before or at the
    first newline following the start of matching. Temporarily adjust
    end_subject so that we stop the scans for a first code unit at a newline.
    If the match fails at the newline, later code breaks the loop. ','line_number':6936,'multiline':True]
['text':' Anchored: check the first code unit if one is recorded. This may seem
    pointless but it can help in detecting a no match case without scanning for
    the required code unit. ','line_number':6960,'multiline':True]
['text':' Not anchored. Advance to a unique first code unit if there is one. ','line_number':6989,'multiline':True]
['text':' Caseless ','line_number':6995,'multiline':True]
['text':' In 16-bit and 32_bit modes we have to do our own search, so can
          look for both cases at once. ','line_number':6997,'multiline':True]
['text':' In 8-bit mode, the use of memchr() gives a big speed up, even
          though we have to call it twice in order to find the earliest
          occurrence of the code unit in either of its cases. Caching is used
          to remember the positions of previously found code units. This can
          make a huge difference when the strings are very long and only one
          case is actually present. ','line_number':7007,'multiline':True]
['text':' If we haven't got a previously found position for first_cu, or if
          the current starting position is later, we need to do a search. If
          the code unit is not found, set it to the end. ','line_number':7018,'multiline':True]
['text':' If the start is before a previously found position, use the
          previous position, or NULL if a previous search failed. ','line_number':7029,'multiline':True]
['text':' Do the same thing for the other case. ','line_number':7035,'multiline':True]
['text':' Set the start to the end of the subject if neither case was found.
          Otherwise, use the earlier found point. ','line_number':7047,'multiline':True]
['text':' 8-bit handling ','line_number':7055,'multiline':True]
['text':' The caseful case is much simpler. ','line_number':7058,'multiline':True]
['text':' If we can't find the required first code unit, having reached the
        true end of the subject, break the bumpalong loop, to force a match
        failure, except when doing partial matching, when we let the next cycle
        run at the end of the subject. To see why, consider the pattern
        /(?<=abc)def/, which partially matches "abc", even though the string
        does not contain the starting character "d". If we have not reached the
        true end of the subject (PCRE2_FIRSTLINE caused end_subject to be
        temporarily modified) we also let the cycle run, because the matching
        string is legitimately allowed to start with the first code unit of a
        newline. ','line_number':7072,'multiline':True]
['text':' If there's no first code unit, advance to just after a linebreak for a
      multiline match if required. ','line_number':7090,'multiline':True]
['text':' If we have just passed a CR and the newline option is ANY or
          ANYCRLF, and we are now at a LF, advance the match position by one
          more code unit. ','line_number':7111,'multiline':True]
['text':' If there's no first code unit or a requirement for a multiline line
      start, advance to a non-unique first code unit if any have been
      identified. The bitmap contains only 256 bits. When code units are 16 or
      32 bits wide, all code units greater than 254 set the 255 bit. ','line_number':7123,'multiline':True]
['text':' See comment above in first_cu checking about the next few lines. ','line_number':7140,'multiline':True]
['text':' End first code unit handling ','line_number':7148,'multiline':True]
['text':' Restore fudged end_subject ','line_number':7150,'multiline':True]
['text':' The following two optimizations must be disabled for partial matching. ','line_number':7154,'multiline':True]
['text':' The minimum matching length is a lower bound; no string of that length
      may actually match the pattern. Although the value is, strictly, in
      characters, we treat it as code units to avoid spending too much time in
      this optimization. ','line_number':7160,'multiline':True]
['text':' If req_cu is set, we know that that code unit must appear in the
      subject for the (non-partial) match to succeed. If the first code unit is
      set, req_cu must be later in the subject; otherwise the test starts at
      the match point. This optimization can save a huge amount of backtracking
      in patterns with nested unlimited repeats that aren't going to match.
      Writing separate code for caseful/caseless versions makes it go faster,
      as does using an autoincrement and backing off on a match. As in the case
      of the first code unit, using memchr() in the 8-bit library gives a big
      speed up. Unlike the first_cu check above, we do not need to call
      memchr() twice in the caseless case because we only need to check for the
      presence of the character in either case, not find the first occurrence.

      The search can be skipped if the code unit was found later than the
      current starting point in a previous iteration of the bumpalong loop.

      HOWEVER: when the subject string is very, very long, searching to its end
      can take a long time, and give bad performance on quite ordinary
      anchored patterns. This showed up when somebody was matching something
      like /^\d+C/ on a 32-megabyte string... so we don't do this when the
      string is sufficiently long, but it's worth searching a lot more for
      unanchored patterns. ','line_number':7171,'multiline':True]
['text':' Caseless ','line_number':7201,'multiline':True]
['text':' 8-bit code units ','line_number':7209,'multiline':True]
['text':' PCRE2_CODE_UNIT_WIDTH != 8 ','line_number':7217,'multiline':True]
['text':' The caseful case ','line_number':7220,'multiline':True]
['text':' 8-bit code units ','line_number':7230,'multiline':True]
['text':' If we can't find the required code unit, break the bumpalong loop,
          forcing a match failure. ','line_number':7236,'multiline':True]
['text':' If we have found the required code unit, save the point where we
          found it, so that we don't search again next time round the bumpalong
          loop if the start hasn't yet passed this code unit. ','line_number':7245,'multiline':True]
['text':' ------------ End of start of match optimizations ------------ ','line_number':7255,'multiline':True]
['text':' Give no match if we have passed the bumpalong limit. ','line_number':7257,'multiline':True]
['text':' OK, we can now run the match. If "hitend" is set afterwards, remember the
  first starting point for which a partial match was found. ','line_number':7265,'multiline':True]
['text':' If MATCH_SKIP_ARG reaches this level it means that a MARK that matched
    the SKIP's arg was not found. In this circumstance, Perl ignores the SKIP
    entirely. The only way we can do that is to re-do the match at the same
    point, with a flag to force SKIP with an argument to be ignored. Just
    treating this case as NOMATCH does not work because it does not check other
    alternatives in patterns such as A(*SKIP:A)B|AC when the subject is AC. ','line_number':7293,'multiline':True]
['text':' SKIP passes back the next starting point explicitly, but if it is no
    greater than the match we have just done, treat it as NOMATCH. ','line_number':7305,'multiline':True]
['text':' Fall through ','line_number':7314,'multiline':True]
['text':' NOMATCH and PRUNE advance by one character. THEN at this level acts
    exactly like PRUNE. Unset ignore SKIP-with-argument. ','line_number':7316,'multiline':True]
['text':' COMMIT disables the bumpalong, but otherwise behaves as NOMATCH. ','line_number':7331,'multiline':True]
['text':' Any other return is either a match, or some kind of error. ','line_number':7337,'multiline':True]
['text':' Control reaches here for the various types of "no match at this point"
  result. Reset the code to MATCH_NOMATCH for subsequent checking. ','line_number':7343,'multiline':True]
['text':' If PCRE2_FIRSTLINE is set, the match must happen before or at the first
  newline in the subject (though it may continue over the newline). Therefore,
  if we have just failed to match, starting at a newline, do not continue. ','line_number':7348,'multiline':True]
['text':' Advance to new matching position ','line_number':7354,'multiline':True]
['text':' Break the loop if the pattern is anchored or if we have passed the end of
  the subject. ','line_number':7358,'multiline':True]
['text':' If we have just passed a CR and we are now at a LF, and the pattern does
  not contain any explicit matches for \r or \n, and the newline option is CRLF
  or ANY or ANYCRLF, advance the match position by one more code unit. In
  normal matching start_match will aways be greater than the first position at
  this stage, but a failed *SKIP can cause a return at the same point, which is
  why the first test exists. ','line_number':7363,'multiline':True]
['text':' Reset for start of next match attempt ','line_number':7380,'multiline':True]
['text':' End of for(;;) "bumpalong" loop ','line_number':7381,'multiline':True]
['text':' ==========================================================================','line_number':7383,'multiline':True]
['text':' When we reach here, one of the following stopping conditions is true:

(1) The match succeeded, either completely, or partially;

(2) The pattern is anchored or the match was failed after (*COMMIT);

(3) We are past the end of the subject or the bumpalong limit;

(4) PCRE2_FIRSTLINE is set and we have failed to match at a newline, because
    this option requests that a match occur at or before the first newline in
    the subject.

(5) Some kind of error occurred.

','line_number':7385,'multiline':True]
['text':' If end_subject != true_end_subject, it means we are handling invalid UTF,
and have just processed a non-terminal fragment. If this resulted in no match
or a partial match we must carry on to the next fragment (a partial match is
returned to the caller only at the very end of the subject). A loop is used to
avoid trying to match against empty fragments; if the pattern can match an
empty string it would have done so already. ','line_number':7403,'multiline':True]
['text':' Advance past the first bad code unit, and then skip invalid character
    starting code units in 8-bit and 16-bit modes. ','line_number':7416,'multiline':True]
['text':' If we have hit the end of the subject, there isn't another non-empty
    fragment, so give up. ','line_number':7426,'multiline':True]
['text':' In case it was partial ','line_number':7431,'multiline':True]
['text':' Check the rest of the subject ','line_number':7435,'multiline':True]
['text':' The rest of the subject is valid UTF. ','line_number':7441,'multiline':True]
['text':' A subsequent UTF error has been found; if the next fragment is
    non-empty, set up to process it. Otherwise, let the loop advance. ','line_number':7450,'multiline':True]
['text':' SUPPORT_UNICODE ','line_number':7464,'multiline':True]
['text':' Release an enlarged frame vector that is on the heap. ','line_number':7466,'multiline':True]
['text':' Fill in fields that are always returned in the match data. ','line_number':7471,'multiline':True]
['text':' Handle a fully successful match. Set the return code to the number of
captured strings, or 0 if there were too many to fit into the ovector, and then
set the remaining returned values before returning. Make a copy of the subject
string if requested. ','line_number':7477,'multiline':True]
['text':' Control gets here if there has been a partial match, an error, or if the
overall match attempt has failed at all permitted starting positions. Any mark
data is in the nomatch_mark field. ','line_number':7503,'multiline':True]
['text':' For anything other than nomatch or partial match, just return the code. ','line_number':7509,'multiline':True]
['text':' Handle a partial match. If a "soft" partial match was requested, searching
for a complete match will have continued, and the value of rc at this point
will be MATCH_NOMATCH. For a "hard" partial match, it will already be
PCRE2_ERROR_PARTIAL. ','line_number':7513,'multiline':True]
['text':' Else this is the classic nomatch case. ','line_number':7529,'multiline':True]
['text':' End of pcre2_match.c ','line_number':7536,'multiline':True]
