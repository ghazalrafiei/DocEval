['text':'
 *    Stack-less Just-In-Time compiler
 *
 *    Copyright Zoltan Herczeg (hzmester@freemail.hu). All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *   1. Redistributions of source code must retain the above copyright notice, this list of
 *      conditions and the following disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above copyright notice, this list
 *      of conditions and the following disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ','line_number':1,'multiline':True]
['text':'
   ------------------------------------------------------------------------
    Stack-Less JIT compiler for multiple architectures (x86, ARM, PowerPC)
   ------------------------------------------------------------------------

   Short description
    Advantages:
      - The execution can be continued from any LIR instruction. In other
        words, it is possible to jump to any label from anywhere, even from
        a code fragment, which is compiled later, if both compiled code
        shares the same context. See sljit_emit_enter for more details
      - Supports self modifying code: target of (conditional) jump and call
        instructions and some constant values can be dynamically modified
        during runtime
        - although it is not suggested to do it frequently
        - can be used for inline caching: save an important value once
          in the instruction stream
        - since this feature limits the optimization possibilities, a
          special flag must be passed at compile time when these
          instructions are emitted
      - A fixed stack space can be allocated for local variables
      - The compiler is thread-safe
      - The compiler is highly configurable through preprocessor macros.
        You can disable unneeded features (multithreading in single
        threaded applications), and you can use your own system functions
        (including memory allocators). See sljitConfig.h
    Disadvantages:
      - No automatic register allocation, and temporary results are
        not stored on the stack. (hence the name comes)
    In practice:
      - This approach is very effective for interpreters
        - One of the saved registers typically points to a stack interface
        - It can jump to any exception handler anytime (even if it belongs
          to another function)
        - Hot paths can be modified during runtime reflecting the changes
          of the fastest execution path of the dynamic language
        - SLJIT supports complex memory addressing modes
        - mainly position and context independent code (except some cases)

    For valgrind users:
      - pass --smc-check=all argument to valgrind, since JIT is a "self-modifying code"
','line_number':30,'multiline':True]
['text':' SLJIT_HAVE_CONFIG_PRE ','line_number':75,'multiline':True]
['text':' The following header file defines useful macros for fine tuning
sljit based code generators. They are listed in the beginning
of sljitConfigInternal.h ','line_number':79,'multiline':True]
['text':' SLJIT_HAVE_CONFIG_POST ','line_number':87,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':93,'multiline':True]
['text':'  Error codes                                                          ','line_number':94,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':95,'multiline':True]
['text':' Indicates no error. ','line_number':97,'multiline':True]
['text':' After the call of sljit_generate_code(), the error code of the compiler
   is set to this value to avoid future sljit calls (in debug mode at least).
   The complier should be freed after sljit_generate_code(). ','line_number':99,'multiline':True]
['text':' Cannot allocate non executable memory. ','line_number':103,'multiline':True]
['text':' Cannot allocate executable memory.
   Only for sljit_generate_code() ','line_number':105,'multiline':True]
['text':' Return value for SLJIT_CONFIG_UNSUPPORTED placeholder architecture. ','line_number':108,'multiline':True]
['text':' An ivalid argument is passed to any SLJIT function. ','line_number':110,'multiline':True]
['text':' Dynamic code modification is not enabled. ','line_number':112,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':115,'multiline':True]
['text':'  Registers                                                            ','line_number':116,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':117,'multiline':True]
['text':'
  Scratch (R) registers: registers whose may not preserve their values
  across function calls.

  Saved (S) registers: registers whose preserve their values across
  function calls.

  The scratch and saved register sets are overlap. The last scratch register
  is the first saved register, the one before the last is the second saved
  register, and so on.

  If an architecture provides two scratch and three saved registers,
  its scratch and saved register sets are the following:

     R0   |        |   R0 is always a scratch register
     R1   |        |   R1 is always a scratch register
    [R2]  |   S2   |   R2 and S2 represent the same physical register
    [R3]  |   S1   |   R3 and S1 represent the same physical register
    [R4]  |   S0   |   R4 and S0 represent the same physical register

  Note: SLJIT_NUMBER_OF_SCRATCH_REGISTERS would be 2 and
        SLJIT_NUMBER_OF_SAVED_REGISTERS would be 3 for this architecture.

  Note: On all supported architectures SLJIT_NUMBER_OF_REGISTERS >= 12
        and SLJIT_NUMBER_OF_SAVED_REGISTERS >= 6. However, 6 registers
        are virtual on x86-32. See below.

  The purpose of this definition is convenience: saved registers can
  be used as extra scratch registers. For example four registers can
  be specified as scratch registers and the fifth one as saved register
  on the CPU above and any user code which requires four scratch
  registers can run unmodified. The SLJIT compiler automatically saves
  the content of the two extra scratch register on the stack. Scratch
  registers can also be preserved by saving their value on the stack
  but this needs to be done manually.

  Note: To emphasize that registers assigned to R2-R4 are saved
        registers, they are enclosed by square brackets.

  Note: sljit_emit_enter and sljit_set_context defines whether a register
        is S or R register. E.g: when 3 scratches and 1 saved is mapped
        by sljit_emit_enter, the allowed register set will be: R0-R2 and
        S0. Although S2 is mapped to the same position as R2, it does not
        available in the current configuration. Furthermore the S1 register
        is not available at all.
','line_number':119,'multiline':True]
['text':' Scratch registers. ','line_number':166,'multiline':True]
['text':' Note: on x86-32, R3 - R6 (same as S3 - S6) are emulated (they
   are allocated on the stack). These registers are called virtual
   and cannot be used for memory addressing (cannot be part of
   any SLJIT_MEM1, SLJIT_MEM2 construct). There is no such
   limitation on other CPUs. See sljit_get_register_index(). ','line_number':170,'multiline':True]
['text':' All R registers provided by the architecture can be accessed by SLJIT_R(i)
   The i parameter must be >= 0 and < SLJIT_NUMBER_OF_REGISTERS. ','line_number':182,'multiline':True]
['text':' Saved registers. ','line_number':186,'multiline':True]
['text':' Note: on x86-32, S3 - S6 (same as R3 - R6) are emulated (they
   are allocated on the stack). These registers are called virtual
   and cannot be used for memory addressing (cannot be part of
   any SLJIT_MEM1, SLJIT_MEM2 construct). There is no such
   limitation on other CPUs. See sljit_get_register_index(). ','line_number':190,'multiline':True]
['text':' All S registers provided by the architecture can be accessed by SLJIT_S(i)
   The i parameter must be >= 0 and < SLJIT_NUMBER_OF_SAVED_REGISTERS. ','line_number':202,'multiline':True]
['text':' Registers >= SLJIT_FIRST_SAVED_REG are saved registers. ','line_number':206,'multiline':True]
['text':' The SLJIT_SP provides direct access to the linear stack space allocated by
   sljit_emit_enter. It can only be used in the following form: SLJIT_MEM1(SLJIT_SP).
   The immediate offset is extended by the relative stack offset automatically.
   The sljit_get_local_base can be used to obtain the absolute offset. ','line_number':209,'multiline':True]
['text':' Return with machine word. ','line_number':215,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':219,'multiline':True]
['text':'  Floating point registers                                             ','line_number':220,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':221,'multiline':True]
['text':' Each floating point register can store a 32 or a 64 bit precision
   value. The FR and FS register sets are overlap in the same way as R
   and S register sets. See above. ','line_number':223,'multiline':True]
['text':' Floating point scratch registers. ','line_number':227,'multiline':True]
['text':' All FR registers provided by the architecture can be accessed by SLJIT_FR(i)
   The i parameter must be >= 0 and < SLJIT_NUMBER_OF_FLOAT_REGISTERS. ','line_number':234,'multiline':True]
['text':' Floating point saved registers. ','line_number':238,'multiline':True]
['text':' All S registers provided by the architecture can be accessed by SLJIT_FS(i)
   The i parameter must be >= 0 and < SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS. ','line_number':245,'multiline':True]
['text':' Float registers >= SLJIT_FIRST_SAVED_FLOAT_REG are saved registers. ','line_number':249,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':252,'multiline':True]
['text':'  Argument type definitions                                            ','line_number':253,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':254,'multiline':True]
['text':' The following argument type definitions are used by sljit_emit_enter,
   sljit_set_context, sljit_emit_call, and sljit_emit_icall functions.

   As for sljit_emit_call and sljit_emit_icall, the first integer argument
   must be placed into SLJIT_R0, the second one into SLJIT_R1, and so on.
   Similarly the first floating point argument must be placed into SLJIT_FR0,
   the second one into SLJIT_FR1, and so on.

   As for sljit_emit_enter, the integer arguments can be stored in scratch
   or saved registers. The first integer argument without _R postfix is
   stored in SLJIT_S0, the next one in SLJIT_S1, and so on. The integer
   arguments with _R postfix are placed into scratch registers. The index
   of the scratch register is the count of the previous integer arguments
   starting from SLJIT_R0. The floating point arguments are always placed
   into SLJIT_FR0, SLJIT_FR1, and so on.

   Note: if a function is called by sljit_emit_call/sljit_emit_icall and
         an argument is stored in a scratch register by sljit_emit_enter,
         that argument uses the same scratch register index for both
         integer and floating point arguments.

   Example function definition:
     sljit_f32 SLJIT_FUNC example_c_callback(void *arg_a,
         sljit_f64 arg_b, sljit_u32 arg_c, sljit_f32 arg_d);

   Argument type definition:
     SLJIT_ARG_RETURN(SLJIT_ARG_TYPE_F32)
        | SLJIT_ARG_VALUE(SLJIT_ARG_TYPE_P, 1) | SLJIT_ARG_VALUE(SLJIT_ARG_TYPE_F64, 2)
        | SLJIT_ARG_VALUE(SLJIT_ARG_TYPE_32, 3) | SLJIT_ARG_VALUE(SLJIT_ARG_TYPE_F32, 4)

   Short form of argument type definition:
     SLJIT_ARGS4(32, P, F64, 32, F32)

   Argument passing:
     arg_a must be placed in SLJIT_R0
     arg_c must be placed in SLJIT_R1
     arg_b must be placed in SLJIT_FR0
     arg_d must be placed in SLJIT_FR1

   Examples for argument processing by sljit_emit_enter:
     SLJIT_ARGS4(VOID, P, 32_R, F32, W)
     Arguments are placed into: SLJIT_S0, SLJIT_R1, SLJIT_FR0, SLJIT_S1

     SLJIT_ARGS4(VOID, W, W_R, W, W_R)
     Arguments are placed into: SLJIT_S0, SLJIT_R1, SLJIT_S1, SLJIT_R3

     SLJIT_ARGS4(VOID, F64, W, F32, W_R)
     Arguments are placed into: SLJIT_FR0, SLJIT_S0, SLJIT_FR1, SLJIT_R1

     Note: it is recommended to pass the scratch arguments first
     followed by the saved arguments:

       SLJIT_ARGS4(VOID, W_R, W_R, W, W)
       Arguments are placed into: SLJIT_R0, SLJIT_R1, SLJIT_S0, SLJIT_S1
','line_number':256,'multiline':True]
['text':' The following flag is only allowed for the integer arguments of
   sljit_emit_enter. When the flag is set, the integer argument is
   stored in a scratch register instead of a saved register. ','line_number':312,'multiline':True]
['text':' Void result, can only be used by SLJIT_ARG_RETURN. ','line_number':317,'multiline':True]
['text':' Machine word sized integer argument or result. ','line_number':319,'multiline':True]
['text':' 32 bit integer argument or result. ','line_number':322,'multiline':True]
['text':' Pointer sized integer argument or result. ','line_number':325,'multiline':True]
['text':' 64 bit floating point argument or result. ','line_number':328,'multiline':True]
['text':' 32 bit floating point argument or result. ','line_number':330,'multiline':True]
['text':' Simplified argument list definitions.

   The following definition:
       SLJIT_ARG_RETURN(SLJIT_ARG_TYPE_W) | SLJIT_ARG_VALUE(SLJIT_ARG_TYPE_F32, 1)

   can be shortened to:
       SLJIT_ARGS1(W, F32)
','line_number':337,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':363,'multiline':True]
['text':'  Main structures and functions                                        ','line_number':364,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':365,'multiline':True]
['text':'
	The following structures are private, and can be changed in the
	future. Keeping them here allows code inlining.
','line_number':367,'multiline':True]
['text':' Must be aligned to sljit_sw. ','line_number':375,'multiline':True]
['text':' The maximum size difference. ','line_number':382,'multiline':True]
['text':' Used scratch registers. ','line_number':426,'multiline':True]
['text':' Used saved registers. ','line_number':428,'multiline':True]
['text':' Used float scratch registers. ','line_number':430,'multiline':True]
['text':' Used float saved registers. ','line_number':432,'multiline':True]
['text':' Local stack size. ','line_number':434,'multiline':True]
['text':' Code size. ','line_number':436,'multiline':True]
['text':' Relative offset of the executable mapping from the writable mapping. ','line_number':438,'multiline':True]
['text':' Executable size for statistical purposes. ','line_number':440,'multiline':True]
['text':' Constant pool handling. ','line_number':458,'multiline':True]
['text':' Other members. ','line_number':463,'multiline':True]
['text':' Contains pointer, "ldr pc, [...]" pairs. ','line_number':464,'multiline':True]
['text':' Temporary fields. ','line_number':469,'multiline':True]
['text':' SLJIT_CONFIG_ARM_V5 || SLJIT_CONFIG_ARM_V7 ','line_number':471,'multiline':True]
['text':' Need to allocate register save area to make calls. ','line_number':498,'multiline':True]
['text':' Flags specified by the last arithmetic instruction.
	   It contains the type of the variable flag. ','line_number':508,'multiline':True]
['text':' Return value type set by entry functions. ','line_number':511,'multiline':True]
['text':' Local size passed to entry functions. ','line_number':513,'multiline':True]
['text':' Trust arguments when the API function is called. ','line_number':520,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':525,'multiline':True]
['text':'  Main functions                                                       ','line_number':526,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':527,'multiline':True]
['text':' Creates an sljit compiler. The allocator_data is required by some
   custom memory managers. This pointer is passed to SLJIT_MALLOC
   and SLJIT_FREE macros. Most allocators (including the default
   one) ignores this value, and it is recommended to pass NULL
   as a dummy value for allocator_data. The exec_allocator_data
   has the same purpose but this one is passed to SLJIT_MALLOC_EXEC /
   SLJIT_MALLOC_FREE functions.

   Returns NULL if failed. ','line_number':529,'multiline':True]
['text':' Frees everything except the compiled machine code. ','line_number':540,'multiline':True]
['text':' Returns the current error code. If an error is occurred, future sljit
   calls which uses the same compiler argument returns early with the same
   error code. Thus there is no need for checking the error after every
   call, it is enough to do it before the code is compiled. Removing
   these checks increases the performance of the compiling process. ','line_number':543,'multiline':True]
['text':' Sets the compiler error code to SLJIT_ERR_ALLOC_FAILED except
   if an error was detected before. After the error code is set
   the compiler behaves as if the allocation failure happened
   during an sljit function call. This can greatly simplify error
   checking, since only the compiler status needs to be checked
   after the compilation. ','line_number':550,'multiline':True]
['text':'
   Allocate a small amount of memory. The size must be <= 64 bytes on 32 bit,
   and <= 128 bytes on 64 bit architectures. The memory area is owned by the
   compiler, and freed by sljit_free_compiler. The returned pointer is
   sizeof(sljit_sw) aligned. Excellent for allocating small blocks during
   the compiling, and no need to worry about freeing them. The size is
   enough to contain at most 16 pointers. If the size is outside of the range,
   the function will return with NULL. However, this return value does not
   indicate that there is no more memory (does not set the current error code
   of the compiler to out-of-memory status).
','line_number':558,'multiline':True]
['text':' Passing NULL disables verbose. ','line_number':572,'multiline':True]
['text':'
   Create executable code from the sljit instruction stream. This is the final step
   of the code generation so no more instructions can be added after this call.
','line_number':576,'multiline':True]
['text':' Free executable code. ','line_number':583,'multiline':True]
['text':'
   When the protected executable allocator is used the JIT code is mapped
   twice. The first mapping has read/write and the second mapping has read/exec
   permissions. This function returns with the relative offset of the executable
   mapping using the writable mapping as the base after the machine code is
   successfully generated. The returned value is always 0 for the normal executable
   allocator, since it uses only one mapping with read/write/exec permissions.
   Dynamic code modifications requires this value.

   Before a successful code generation, this function returns with 0.
','line_number':587,'multiline':True]
['text':'
   The executable memory consumption of the generated code can be retrieved by
   this function. The returned value can be used for statistical purposes.

   Before a successful code generation, this function returns with 0.
','line_number':600,'multiline':True]
['text':' Returns with non-zero if the feature or limitation type passed as its
   argument is present on the current CPU.

   Some features (e.g. floating point operations) require hardware (CPU)
   support while others (e.g. move with update) are emulated if not available.
   However even if a feature is emulated, specialized code paths can be faster
   than the emulation. Some limitations are emulated as well so their general
   case is supported but it has extra performance costs. ','line_number':608,'multiline':True]
['text':' [Not emulated] Floating-point support is available. ','line_number':617,'multiline':True]
['text':' [Limitation] Some registers are virtual registers. ','line_number':619,'multiline':True]
['text':' [Emulated] Has zero register (setting a memory location to zero is efficient). ','line_number':621,'multiline':True]
['text':' [Emulated] Count leading zero is supported. ','line_number':623,'multiline':True]
['text':' [Emulated] Conditional move is supported. ','line_number':625,'multiline':True]
['text':' [Emulated] Conditional move is supported. ','line_number':627,'multiline':True]
['text':' [Not emulated] SSE2 support is available on x86. ','line_number':631,'multiline':True]
['text':' Instruction generation. Returns with any error code. If there is no
   error, they return with SLJIT_SUCCESS. ','line_number':637,'multiline':True]
['text':'
   The executable code is a function from the viewpoint of the C
   language. The function calls must obey to the ABI (Application
   Binary Interface) of the platform, which specify the purpose of
   machine registers and stack handling among other things. The
   sljit_emit_enter function emits the necessary instructions for
   setting up a new context for the executable code and moves function
   arguments to the saved registers. Furthermore the options argument
   can be used to pass configuration options to the compiler. The
   available options are listed before sljit_emit_enter.

   The function argument list is the combination of SLJIT_ARGx
   (SLJIT_DEF_ARG1) macros. Currently maximum 4 arguments are
   supported. The first integer argument is loaded into SLJIT_S0,
   the second one is loaded into SLJIT_S1, and so on. Similarly,
   the first floating point argument is loaded into SLJIT_FR0,
   the second one is loaded into SLJIT_FR1, and so on. Furthermore
   the register set used by the function must be declared as well.
   The number of scratch and saved registers used by the function
   must be passed to sljit_emit_enter. Only R registers between R0
   and "scratches" argument can be used later. E.g. if "scratches"
   is set to 2, the scratch register set will be limited to SLJIT_R0
    and SLJIT_R1. The S registers and the floating point registers
   ("fscratches" and "fsaveds") are specified in a similar manner.
   The sljit_emit_enter is also capable of allocating a stack space
   for local variables. The "local_size" argument contains the size
   in bytes of this local area and its staring address is stored
   in SLJIT_SP. The memory area between SLJIT_SP (inclusive) and
   SLJIT_SP + local_size (exclusive) can be modified freely until
   the function returns. The stack space is not initialized.

   Note: the following conditions must met:
         0 <= scratches <= SLJIT_NUMBER_OF_REGISTERS
         0 <= saveds <= SLJIT_NUMBER_OF_SAVED_REGISTERS
         scratches + saveds <= SLJIT_NUMBER_OF_REGISTERS
         0 <= fscratches <= SLJIT_NUMBER_OF_FLOAT_REGISTERS
         0 <= fsaveds <= SLJIT_NUMBER_OF_SAVED_FLOAT_REGISTERS
         fscratches + fsaveds <= SLJIT_NUMBER_OF_FLOAT_REGISTERS

   Note: the compiler can use saved registers as scratch registers,
         but the opposite is not supported

   Note: every call of sljit_emit_enter and sljit_set_context
         overwrites the previous context.
','line_number':640,'multiline':True]
['text':' The compiled function uses cdecl calling
 * convention instead of SLJIT_FUNC. ','line_number':686,'multiline':True]
['text':' The local_size must be >= 0 and <= SLJIT_MAX_LOCAL_SIZE. ','line_number':690,'multiline':True]
['text':' The machine code has a context (which contains the local stack space size,
   number of used registers, etc.) which initialized by sljit_emit_enter. Several
   functions (such as sljit_emit_return) requres this context to be able to generate
   the appropriate code. However, some code fragments (like inline cache) may have
   no normal entry point so their context is unknown for the compiler. Their context
   can be provided to the compiler by the sljit_set_context function.

   Note: every call of sljit_emit_enter and sljit_set_context overwrites
         the previous context. ','line_number':697,'multiline':True]
['text':' Return from machine code. The sljit_emit_return_void function does not return with
   any value. The sljit_emit_return function returns with a single value which stores
   the result of a data move instruction. The instruction is specified by the op
   argument, and must be between SLJIT_MOV and SLJIT_MOV_P (see sljit_emit_op1). ','line_number':711,'multiline':True]
['text':' Generating entry and exit points for fast call functions (see SLJIT_FAST_CALL).
   Both sljit_emit_fast_enter and SLJIT_FAST_RETURN operations preserve the
   values of all registers and stack frame. The return address is stored in the
   dst argument of sljit_emit_fast_enter, and this return address can be passed
   to SLJIT_FAST_RETURN to continue the execution after the fast call.

   Fast calls are cheap operations (usually only a single call instruction is
   emitted) but they do not preserve any registers. However the callee function
   can freely use / update any registers and stack values which can be
   efficiently exploited by various optimizations. Registers can be saved
   manually by the callee function if needed.

   Although returning to different address by SLJIT_FAST_RETURN is possible,
   this address usually cannot be predicted by the return address predictor of
   modern CPUs which may reduce performance. Furthermore certain security
   enhancement technologies such as Intel Control-flow Enforcement Technology
   (CET) may disallow returning to a different address.

   Flags: - (does not modify flags). ','line_number':721,'multiline':True]
['text':'
   Source and destination operands for arithmetical instructions
    imm              - a simple immediate value (cannot be used as a destination)
    reg              - any of the registers (immediate argument must be 0)
    [imm]            - absolute immediate memory address
    [reg+imm]        - indirect memory address
    [reg+(reg<<imm)] - indirect indexed memory address (shift must be between 0 and 3)
                       useful for (byte, half, int, sljit_sw) array access
                       (fully supported by both x86 and ARM architectures, and cheap operation on others)
','line_number':743,'multiline':True]
['text':'
   IMPORTANT NOTE: memory access MUST be naturally aligned unless
                   SLJIT_UNALIGNED macro is defined and its value is 1.

     length | alignment
   ---------+-----------
     byte   | 1 byte (any physical_address is accepted)
     half   | 2 byte (physical_address & 0x1 == 0)
     int    | 4 byte (physical_address & 0x3 == 0)
     word   | 4 byte if SLJIT_32BIT_ARCHITECTURE is defined and its value is 1
            | 8 byte if SLJIT_64BIT_ARCHITECTURE is defined and its value is 1
    pointer | size of sljit_p type (4 byte on 32 bit machines, 4 or 8 byte
            | on 64 bit machines)

   Note:   Different architectures have different addressing limitations.
           A single instruction is enough for the following addressing
           modes. Other adrressing modes are emulated by instruction
           sequences. This information could help to improve those code
           generators which focuses only a few architectures.

   x86:    [reg+imm], -2^32+1 <= imm <= 2^32-1 (full address space on x86-32)
           [reg+(reg<<imm)] is supported
           [imm], -2^32+1 <= imm <= 2^32-1 is supported
           Write-back is not supported
   arm:    [reg+imm], -4095 <= imm <= 4095 or -255 <= imm <= 255 for signed
                bytes, any halfs or floating point values)
           [reg+(reg<<imm)] is supported
           Write-back is supported
   arm-t2: [reg+imm], -255 <= imm <= 4095
           [reg+(reg<<imm)] is supported
           Write back is supported only for [reg+imm], where -255 <= imm <= 255
   arm64:  [reg+imm], -256 <= imm <= 255, 0 <= aligned imm <= 4095 * alignment
           [reg+(reg<<imm)] is supported
           Write back is supported only for [reg+imm], where -256 <= imm <= 255
   ppc:    [reg+imm], -65536 <= imm <= 65535. 64 bit loads/stores and 32 bit
                signed load on 64 bit requires immediates divisible by 4.
                [reg+imm] is not supported for signed 8 bit values.
           [reg+reg] is supported
           Write-back is supported except for one instruction: 32 bit signed
                load with [reg+imm] addressing mode on 64 bit.
   mips:   [reg+imm], -65536 <= imm <= 65535
   sparc:  [reg+imm], -4096 <= imm <= 4095
           [reg+reg] is supported
   s390x:  [reg+imm], -2^19 <= imm < 2^19
           [reg+reg] is supported
           Write-back is not supported
','line_number':754,'multiline':True]
['text':' Macros for specifying operand types. ','line_number':802,'multiline':True]
['text':' Sets 32 bit operation mode on 64 bit CPUs. This option is ignored on
   32 bit CPUs. When this option is set for an arithmetic operation, only
   the lower 32 bit of the input registers are used, and the CPU status
   flags are set according to the 32 bit result. Although the higher 32 bit
   of the input and the result registers are not defined by SLJIT, it might
   be defined by the CPU architecture (e.g. MIPS). To satisfy these CPU
   requirements all source registers must be the result of those operations
   where this option was also set. Memory loads read 32 bit values rather
   than 64 bit ones. In other words 32 bit and 64 bit operations cannot be
   mixed. The only exception is SLJIT_MOV32 whose source register can hold
   any 32 or 64 bit value, and it is converted to a 32 bit compatible format
   first. This conversion is free (no instructions are emitted) on most CPUs.
   A 32 bit value can also be converted to a 64 bit value by SLJIT_MOV_S32
   (sign extension) or SLJIT_MOV_U32 (zero extension).

   As for floating-point operations, this option sets 32 bit single
   precision mode. Similar to the integer operations, all register arguments
   must be the result of those operations where this option was also set.

   Note: memory addressing always uses 64 bit values on 64 bit systems so
         the result of a 32 bit operation must not be used with SLJIT_MEMx
         macros.

   This option is part of the instruction name, so there is no need to
   manually set it. E.g:

     SLJIT_ADD32 == (SLJIT_ADD | SLJIT_32) ','line_number':809,'multiline':True]
['text':' Many CPUs (x86, ARM, PPC) have status flags which can be set according
   to the result of an operation. Other CPUs (MIPS) do not have status
   flags, and results must be stored in registers. To cover both architecture
   types efficiently only two flags are defined by SLJIT:

    * Zero (equal) flag: it is set if the result is zero
    * Variable flag: its value is defined by the last arithmetic operation

   SLJIT instructions can set any or both of these flags. The value of
   these flags is undefined if the instruction does not specify their value.
   The description of each instruction contains the list of allowed flag
   types.

   Example: SLJIT_ADD can set the Z, OVERFLOW, CARRY flags hence

     sljit_op2(..., SLJIT_ADD, ...)
       Both the zero and variable flags are undefined so they can
       have any value after the operation is completed.

     sljit_op2(..., SLJIT_ADD | SLJIT_SET_Z, ...)
       Sets the zero flag if the result is zero, clears it otherwise.
       The variable flag is undefined.

     sljit_op2(..., SLJIT_ADD | SLJIT_SET_OVERFLOW, ...)
       Sets the variable flag if an integer overflow occurs, clears
       it otherwise. The zero flag is undefined.

     sljit_op2(..., SLJIT_ADD | SLJIT_SET_Z | SLJIT_SET_CARRY, ...)
       Sets the zero flag if the result is zero, clears it otherwise.
       Sets the variable flag if unsigned overflow (carry) occurs,
       clears it otherwise.

   If an instruction (e.g. SLJIT_MOV) does not modify flags the flags are
   unchanged.

   Using these flags can reduce the number of emitted instructions. E.g. a
   fast loop can be implemented by decreasing a counter register and set the
   zero flag to jump back if the counter register has not reached zero.

   Motivation: although CPUs can set a large number of flags, usually their
   values are ignored or only one of them is used. Emulating a large number
   of flags on systems without flag register is complicated so SLJIT
   instructions must specify the flag they want to use and only that flag
   will be emulated. The last arithmetic instruction can be repeated if
   multiple flags need to be checked.
','line_number':838,'multiline':True]
['text':' Set Zero status flag. ','line_number':885,'multiline':True]
['text':' Set the variable status flag if condition is true.
   See comparison types. ','line_number':887,'multiline':True]
['text':' Notes:
     - you cannot postpone conditional jump instructions except if noted that
       the instruction does not set flags (See: SLJIT_KEEP_FLAGS).
     - flag combinations: '|' means 'logical or'. ','line_number':891,'multiline':True]
['text':' Starting index of opcodes for sljit_emit_op0. ','line_number':896,'multiline':True]
['text':' Flags: - (does not modify flags)
   Note: breakpoint instruction is not supported by all architectures (e.g. ppc)
         It falls back to SLJIT_NOP in those cases. ','line_number':899,'multiline':True]
['text':' Flags: - (does not modify flags)
   Note: may or may not cause an extra cycle wait
         it can even decrease the runtime in a few cases. ','line_number':903,'multiline':True]
['text':' Flags: - (may destroy flags)
   Unsigned multiplication of SLJIT_R0 and SLJIT_R1.
   Result is placed into SLJIT_R1:SLJIT_R0 (high:low) word ','line_number':907,'multiline':True]
['text':' Flags: - (may destroy flags)
   Signed multiplication of SLJIT_R0 and SLJIT_R1.
   Result is placed into SLJIT_R1:SLJIT_R0 (high:low) word ','line_number':911,'multiline':True]
['text':' Flags: - (may destroy flags)
   Unsigned divide of the value in SLJIT_R0 by the value in SLJIT_R1.
   The result is placed into SLJIT_R0 and the remainder into SLJIT_R1.
   Note: if SLJIT_R1 is 0, the behaviour is undefined. ','line_number':915,'multiline':True]
['text':' Flags: - (may destroy flags)
   Signed divide of the value in SLJIT_R0 by the value in SLJIT_R1.
   The result is placed into SLJIT_R0 and the remainder into SLJIT_R1.
   Note: if SLJIT_R1 is 0, the behaviour is undefined.
   Note: if SLJIT_R1 is -1 and SLJIT_R0 is integer min (0x800..00),
         the behaviour is undefined. ','line_number':921,'multiline':True]
['text':' Flags: - (may destroy flags)
   Unsigned divide of the value in SLJIT_R0 by the value in SLJIT_R1.
   The result is placed into SLJIT_R0. SLJIT_R1 preserves its value.
   Note: if SLJIT_R1 is 0, the behaviour is undefined. ','line_number':929,'multiline':True]
['text':' Flags: - (may destroy flags)
   Signed divide of the value in SLJIT_R0 by the value in SLJIT_R1.
   The result is placed into SLJIT_R0. SLJIT_R1 preserves its value.
   Note: if SLJIT_R1 is 0, the behaviour is undefined.
   Note: if SLJIT_R1 is -1 and SLJIT_R0 is integer min (0x800..00),
         the behaviour is undefined. ','line_number':935,'multiline':True]
['text':' Flags: - (does not modify flags)
   ENDBR32 instruction for x86-32 and ENDBR64 instruction for x86-64
   when Intel Control-flow Enforcement Technology (CET) is enabled.
   No instruction for other architectures.  ','line_number':943,'multiline':True]
['text':' Flags: - (may destroy flags)
   Skip stack frames before return.  ','line_number':948,'multiline':True]
['text':' Starting index of opcodes for sljit_emit_op1. ','line_number':954,'multiline':True]
['text':' The MOV instruction transfers data from source to destination.

   MOV instruction suffixes:

   U8  - unsigned 8 bit data transfer
   S8  - signed 8 bit data transfer
   U16 - unsigned 16 bit data transfer
   S16 - signed 16 bit data transfer
   U32 - unsigned int (32 bit) data transfer
   S32 - signed int (32 bit) data transfer
   P   - pointer (sljit_p) data transfer
','line_number':957,'multiline':True]
['text':' Flags: - (does not modify flags) ','line_number':970,'multiline':True]
['text':' Flags: - (does not modify flags) ','line_number':972,'multiline':True]
['text':' Flags: - (does not modify flags) ','line_number':975,'multiline':True]
['text':' Flags: - (does not modify flags) ','line_number':978,'multiline':True]
['text':' Flags: - (does not modify flags) ','line_number':981,'multiline':True]
['text':' Flags: - (does not modify flags)
   Note: no SLJIT_MOV32_U32 form, since it is the same as SLJIT_MOV32 ','line_number':984,'multiline':True]
['text':' Flags: - (does not modify flags)
   Note: no SLJIT_MOV32_S32 form, since it is the same as SLJIT_MOV32 ','line_number':987,'multiline':True]
['text':' Flags: - (does not modify flags) ','line_number':990,'multiline':True]
['text':' Flags: - (does not modify flags)
   Note: load a pointer sized data, useful on x32 (a 32 bit mode on x86-64
         where all x64 features are available, e.g. 16 register) or similar
         compiling modes ','line_number':992,'multiline':True]
['text':' Flags: Z
   Note: immediate source argument is not supported ','line_number':997,'multiline':True]
['text':' Count leading zeroes
   Flags: - (may destroy flags)
   Note: immediate source argument is not supported ','line_number':1001,'multiline':True]
['text':' Starting index of opcodes for sljit_emit_op2. ','line_number':1011,'multiline':True]
['text':' Flags: Z | OVERFLOW | CARRY ','line_number':1014,'multiline':True]
['text':' Flags: CARRY ','line_number':1017,'multiline':True]
['text':' Flags: Z | LESS | GREATER_EQUAL | GREATER | LESS_EQUAL
          SIG_LESS | SIG_GREATER_EQUAL | SIG_GREATER
          SIG_LESS_EQUAL | CARRY ','line_number':1020,'multiline':True]
['text':' Flags: CARRY ','line_number':1025,'multiline':True]
['text':' Note: integer mul
   Flags: OVERFLOW ','line_number':1028,'multiline':True]
['text':' Flags: Z ','line_number':1032,'multiline':True]
['text':' Flags: Z ','line_number':1035,'multiline':True]
['text':' Flags: Z ','line_number':1038,'multiline':True]
['text':' Flags: Z
   Let bit_length be the length of the shift operation: 32 or 64.
   If src2 is immediate, src2w is masked by (bit_length - 1).
   Otherwise, if the content of src2 is outside the range from 0
   to bit_length - 1, the result is undefined. ','line_number':1041,'multiline':True]
['text':' Flags: Z
   Let bit_length be the length of the shift operation: 32 or 64.
   If src2 is immediate, src2w is masked by (bit_length - 1).
   Otherwise, if the content of src2 is outside the range from 0
   to bit_length - 1, the result is undefined. ','line_number':1048,'multiline':True]
['text':' Flags: Z
   Let bit_length be the length of the shift operation: 32 or 64.
   If src2 is immediate, src2w is masked by (bit_length - 1).
   Otherwise, if the content of src2 is outside the range from 0
   to bit_length - 1, the result is undefined. ','line_number':1055,'multiline':True]
['text':' The sljit_emit_op2u function is the same as sljit_emit_op2 except the result is discarded. ','line_number':1068,'multiline':True]
['text':' Starting index of opcodes for sljit_emit_op2. ','line_number':1074,'multiline':True]
['text':' Note: src cannot be an immedate value
   Flags: - (does not modify flags) ','line_number':1077,'multiline':True]
['text':' Skip stack frames before fast return.
   Note: src cannot be an immedate value
   Flags: may destroy flags. ','line_number':1080,'multiline':True]
['text':' Prefetch value into the level 1 data cache
   Note: if the target CPU does not support data prefetch,
         no instructions are emitted.
   Note: this instruction never fails, even if the memory address is invalid.
   Flags: - (does not modify flags) ','line_number':1084,'multiline':True]
['text':' Prefetch value into the level 2 data cache
   Note: same as SLJIT_PREFETCH_L1 if the target CPU
         does not support this instruction form.
   Note: this instruction never fails, even if the memory address is invalid.
   Flags: - (does not modify flags) ','line_number':1090,'multiline':True]
['text':' Prefetch value into the level 3 data cache
   Note: same as SLJIT_PREFETCH_L2 if the target CPU
         does not support this instruction form.
   Note: this instruction never fails, even if the memory address is invalid.
   Flags: - (does not modify flags) ','line_number':1096,'multiline':True]
['text':' Prefetch a value which is only used once (and can be discarded afterwards)
   Note: same as SLJIT_PREFETCH_L1 if the target CPU
         does not support this instruction form.
   Note: this instruction never fails, even if the memory address is invalid.
   Flags: - (does not modify flags) ','line_number':1102,'multiline':True]
['text':' Starting index of opcodes for sljit_emit_fop1. ','line_number':1112,'multiline':True]
['text':' Flags: - (does not modify flags) ','line_number':1115,'multiline':True]
['text':' Convert opcodes: CONV[DST_TYPE].FROM[SRC_TYPE]
   SRC/DST TYPE can be: D - double, S - single, W - signed word, I - signed int
   Rounding mode when the destination is W or I: round towards zero. ','line_number':1118,'multiline':True]
['text':' Flags: - (may destroy flags) ','line_number':1121,'multiline':True]
['text':' Flags: - (may destroy flags) ','line_number':1124,'multiline':True]
['text':' Flags: - (may destroy flags) ','line_number':1127,'multiline':True]
['text':' Flags: - (may destroy flags) ','line_number':1130,'multiline':True]
['text':' Flags: - (may destroy flags) ','line_number':1133,'multiline':True]
['text':' Note: dst is the left and src is the right operand for SLJIT_CMPD.
   Flags: EQUAL_F | LESS_F | GREATER_EQUAL_F | GREATER_F | LESS_EQUAL_F ','line_number':1136,'multiline':True]
['text':' Flags: - (may destroy flags) ','line_number':1140,'multiline':True]
['text':' Flags: - (may destroy flags) ','line_number':1143,'multiline':True]
['text':' Starting index of opcodes for sljit_emit_fop2. ','line_number':1151,'multiline':True]
['text':' Flags: - (may destroy flags) ','line_number':1154,'multiline':True]
['text':' Flags: - (may destroy flags) ','line_number':1157,'multiline':True]
['text':' Flags: - (may destroy flags) ','line_number':1160,'multiline':True]
['text':' Flags: - (may destroy flags) ','line_number':1163,'multiline':True]
['text':' Label and jump instructions. ','line_number':1172,'multiline':True]
['text':' Invert (negate) conditional type: xor (^) with 0x1 ','line_number':1176,'multiline':True]
['text':' Integer comparison types. ','line_number':1178,'multiline':True]
['text':' Unlike other flags, sljit_emit_jump may destroy this flag. ','line_number':1205,'multiline':True]
['text':' Floating point comparison types. ','line_number':1210,'multiline':True]
['text':' Unconditional jump types. ','line_number':1236,'multiline':True]
['text':' Fast calling method. See sljit_emit_fast_enter / SLJIT_FAST_RETURN. ','line_number':1238,'multiline':True]
['text':' Called function must be declared with the SLJIT_FUNC attribute. ','line_number':1240,'multiline':True]
['text':' Called function must be declared with cdecl attribute.
	   This is the default attribute for C functions. ','line_number':1242,'multiline':True]
['text':' The target can be changed during runtime (see: sljit_set_jump_addr). ','line_number':1246,'multiline':True]
['text':' When this flag is passed, the execution of the current function ends and
   the called function returns to the caller of the current function. The
   stack usage is reduced before the call, but it is not necessarily reduced
   to zero. In the latter case the compiler needs to allocate space for some
   arguments and the return register must be kept as well.

   This feature is highly experimental and not supported on SPARC platform
   at the moment. ','line_number':1248,'multiline':True]
['text':' Emit a jump instruction. The destination is not set, only the type of the jump.
    type must be between SLJIT_EQUAL and SLJIT_FAST_CALL
    type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP

   Flags: does not modify flags. ','line_number':1258,'multiline':True]
['text':' Emit a C compiler (ABI) compatible function call.
    type must be SLJIT_CALL or SLJIT_CALL_CDECL
    type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP and SLJIT_CALL_RETURN
    arg_types is the combination of SLJIT_RET / SLJIT_ARGx (SLJIT_DEF_RET / SLJIT_DEF_ARGx) macros

   Flags: destroy all flags. ','line_number':1265,'multiline':True]
['text':' Basic arithmetic comparison. In most architectures it is implemented as
   an compare operation followed by a sljit_emit_jump. However some
   architectures (i.e: ARM64 or MIPS) may employ special optimizations here.
   It is suggested to use this comparison form when appropriate.
    type must be between SLJIT_EQUAL and SLJIT_I_SIG_LESS_EQUAL
    type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP

   Flags: may destroy flags. ','line_number':1273,'multiline':True]
['text':' Basic floating point comparison. In most architectures it is implemented as
   an SLJIT_FCMP operation (setting appropriate flags) followed by a
   sljit_emit_jump. However some architectures (i.e: MIPS) may employ
   special optimizations here. It is suggested to use this comparison form
   when appropriate.
    type must be between SLJIT_EQUAL_F64 and SLJIT_ORDERED_F32
    type can be combined (or'ed) with SLJIT_REWRITABLE_JUMP
   Flags: destroy flags.
   Note: if either operand is NaN, the behaviour is undefined for
         types up to SLJIT_S_LESS_EQUAL. ','line_number':1285,'multiline':True]
['text':' Set the destination of the jump to this label. ','line_number':1299,'multiline':True]
['text':' Set the destination address of the jump to this label. ','line_number':1301,'multiline':True]
['text':' Emit an indirect jump or fast call.
   Direct form: set src to SLJIT_IMM() and srcw to the address
   Indirect form: any other valid addressing mode
    type must be between SLJIT_JUMP and SLJIT_FAST_CALL

   Flags: does not modify flags. ','line_number':1304,'multiline':True]
['text':' Emit a C compiler (ABI) compatible function call.
   Direct form: set src to SLJIT_IMM() and srcw to the address
   Indirect form: any other valid addressing mode
    type must be SLJIT_CALL or SLJIT_CALL_CDECL
    type can be combined (or'ed) with SLJIT_CALL_RETURN
    arg_types is the combination of SLJIT_RET / SLJIT_ARGx (SLJIT_DEF_RET / SLJIT_DEF_ARGx) macros

   Flags: destroy all flags. ','line_number':1312,'multiline':True]
['text':' Perform the operation using the conditional flags as the second argument.
   Type must always be between SLJIT_EQUAL and SLJIT_ORDERED_F64. The value
   represented by the type is 1, if the condition represented by the type
   is fulfilled, and 0 otherwise.

   If op == SLJIT_MOV, SLJIT_MOV32:
     Set dst to the value represented by the type (0 or 1).
     Flags: - (does not modify flags)
   If op == SLJIT_OR, op == SLJIT_AND, op == SLJIT_XOR
     Performs the binary operation using dst as the first, and the value
     represented by type as the second argument. Result is written into dst.
     Flags: Z (may destroy flags) ','line_number':1322,'multiline':True]
['text':' Emit a conditional mov instruction which moves source to destination,
   if the condition is satisfied. Unlike other arithmetic operations this
   instruction does not support memory access.

   type must be between SLJIT_EQUAL and SLJIT_ORDERED_F64
   dst_reg must be a valid register and it can be combined
      with SLJIT_32 to perform a 32 bit arithmetic operation
   src must be register or immediate (SLJIT_IMM)

   Flags: - (does not modify flags) ','line_number':1338,'multiline':True]
['text':' The following flags are used by sljit_emit_mem() and sljit_emit_fmem(). ','line_number':1352,'multiline':True]
['text':' When SLJIT_MEM_SUPP is passed, no instructions are emitted.
   Instead the function returns with SLJIT_SUCCESS if the instruction
   form is supported and SLJIT_ERR_UNSUPPORTED otherwise. This flag
   allows runtime checking of available instruction forms. ','line_number':1354,'multiline':True]
['text':' Memory load operation. This is the default. ','line_number':1359,'multiline':True]
['text':' Memory store operation. ','line_number':1361,'multiline':True]
['text':' Base register is updated before the memory access. ','line_number':1363,'multiline':True]
['text':' Base register is updated after the memory access. ','line_number':1365,'multiline':True]
['text':' Emit a single memory load or store with update instruction. When the
   requested instruction form is not supported by the CPU, it returns
   with SLJIT_ERR_UNSUPPORTED instead of emulating the instruction. This
   allows specializing tight loops based on the supported instruction
   forms (see SLJIT_MEM_SUPP flag).

   type must be between SLJIT_MOV and SLJIT_MOV_P and can be
     combined with SLJIT_MEM_* flags. Either SLJIT_MEM_PRE
     or SLJIT_MEM_POST must be specified.
   reg is the source or destination register, and must be
     different from the base register of the mem operand
   mem must be a SLJIT_MEM1() or SLJIT_MEM2() operand

   Flags: - (does not modify flags) ','line_number':1368,'multiline':True]
['text':' Same as sljit_emit_mem except the followings:

   type must be SLJIT_MOV_F64 or SLJIT_MOV_F32 and can be
     combined with SLJIT_MEM_* flags. Either SLJIT_MEM_PRE
     or SLJIT_MEM_POST must be specified.
   freg is the source or destination floating point register ','line_number':1386,'multiline':True]
['text':' Copies the base address of SLJIT_SP + offset to dst. The offset can be
   anything to negate the effect of relative addressing. For example if an
   array of sljit_sw values is stored on the stack from offset 0x40, and R0
   contains the offset of an array item plus 0x120, this item can be
   overwritten by two SLJIT instructions:

   sljit_get_local_base(compiler, SLJIT_R1, 0, 0x40 - 0x120);
   sljit_emit_op1(compiler, SLJIT_MOV, SLJIT_MEM2(SLJIT_R1, SLJIT_R0), 0, SLJIT_IMM, 0x5);

   Flags: - (may destroy flags) ','line_number':1397,'multiline':True]
['text':' Store a value that can be changed runtime (see: sljit_get_const_addr / sljit_set_const)
   Flags: - (does not modify flags) ','line_number':1409,'multiline':True]
['text':' Store the value of a label (see: sljit_set_put_label)
   Flags: - (does not modify flags) ','line_number':1413,'multiline':True]
['text':' Set the value stored by put_label to this label. ','line_number':1417,'multiline':True]
['text':' After the code generation the address for label, jump and const instructions
   are computed. Since these structures are freed by sljit_free_compiler, the
   addresses must be preserved by the user program elsewere. ','line_number':1420,'multiline':True]
['text':' Only the address and executable offset are required to perform dynamic
   code modifications. See sljit_get_executable_offset function. ','line_number':1427,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':1432,'multiline':True]
['text':'  Miscellaneous utility functions                                      ','line_number':1433,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':1434,'multiline':True]
['text':' Get the human readable name of the platform. Can be useful on platforms
   like ARM, where ARM and Thumb2 functions can be mixed, and
   it is useful to know the type of the code generator. ','line_number':1439,'multiline':True]
['text':' Portable helper function to get an offset of a member. ','line_number':1444,'multiline':True]
['text':' The sljit_stack structure and its manipulation functions provides
   an implementation for a top-down stack. The stack top is stored
   in the end field of the sljit_stack structure and the stack goes
   down to the min_start field, so the memory region reserved for
   this stack is between min_start (inclusive) and end (exclusive)
   fields. However the application can only use the region between
   start (inclusive) and end (exclusive) fields. The sljit_stack_resize
   function can be used to extend this region up to min_start.

   This feature uses the "address space reserve" feature of modern
   operating systems. Instead of allocating a large memory block
   applications can allocate a small memory region and extend it
   later without moving the content of the memory area. Therefore
   after a successful resize by sljit_stack_resize all pointers into
   this region are still valid.

   Note:
     this structure may not be supported by all operating systems.
     end and max_limit fields are aligned to PAGE_SIZE bytes (usually
         4 Kbyte or more).
     stack should grow in larger steps, e.g. 4Kbyte, 16Kbyte or more. ','line_number':1449,'multiline':True]
['text':' User data, anything can be stored here.
	   Initialized to the same value as the end field. ','line_number':1472,'multiline':True]
['text':' These members are read only. ','line_number':1475,'multiline':True]
['text':' End address of the stack ','line_number':1476,'multiline':True]
['text':' Current start address of the stack. ','line_number':1478,'multiline':True]
['text':' Lowest start address of the stack. ','line_number':1480,'multiline':True]
['text':' Allocates a new stack. Returns NULL if unsuccessful.
   Note: see sljit_create_compiler for the explanation of allocator_data. ','line_number':1484,'multiline':True]
['text':' Can be used to increase (extend) or decrease (shrink) the stack
   memory area. Returns with new_start if successful and NULL otherwise.
   It always fails if new_start is less than min_start or greater or equal
   than end fields. The fields of the stack are not changed if the returned
   value is NULL (the current memory content is never lost). ','line_number':1489,'multiline':True]
['text':' (defined SLJIT_UTIL_STACK && SLJIT_UTIL_STACK) ','line_number':1496,'multiline':True]
['text':' Get the entry address of a given function (signed, unsigned result). ','line_number':1500,'multiline':True]
['text':' !(defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL) ','line_number':1504,'multiline':True]
['text':' All JIT related code should be placed in the same context (library, binary, etc.). ','line_number':1506,'multiline':True]
['text':' Get the entry address of a given function (signed, unsigned result). ','line_number':1508,'multiline':True]
['text':' For powerpc64, the function pointers point to a context descriptor. ','line_number':1512,'multiline':True]
['text':' Fill the context arguments using the addr and the function.
   If func_ptr is NULL, it will not be set to the address of context
   If addr is NULL, the function address also comes from the func pointer. ','line_number':1519,'multiline':True]
['text':' !(defined SLJIT_INDIRECT_CALL && SLJIT_INDIRECT_CALL) ','line_number':1524,'multiline':True]
['text':' Free unused executable memory. The allocator keeps some free memory
   around to reduce the number of OS executable memory allocations.
   This improves performance since these calls are costly. However
   it is sometimes desired to free all unused memory regions, e.g.
   before the application terminates. ','line_number':1527,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':1535,'multiline':True]
['text':'  CPU specific functions                                               ','line_number':1536,'multiline':True]
['text':' --------------------------------------------------------------------- ','line_number':1537,'multiline':True]
['text':' The following function is a helper function for sljit_emit_op_custom.
   It returns with the real machine register index ( >=0 ) of any SLJIT_R,
   SLJIT_S and SLJIT_SP registers.

   Note: it returns with -1 for virtual registers (only on x86-32). ','line_number':1539,'multiline':True]
['text':' The following function is a helper function for sljit_emit_op_custom.
   It returns with the real machine register index of any SLJIT_FLOAT register.

   Note: the index is always an even number on ARM (except ARM-64), MIPS, and SPARC. ','line_number':1547,'multiline':True]
['text':' Any instruction can be inserted into the instruction stream by
   sljit_emit_op_custom. It has a similar purpose as inline assembly.
   The size parameter must match to the instruction size of the target
   architecture:

         x86: 0 < size <= 15. The instruction argument can be byte aligned.
      Thumb2: if size == 2, the instruction argument must be 2 byte aligned.
              if size == 4, the instruction argument must be 4 byte aligned.
   Otherwise: size must be 4 and instruction argument must be 4 byte aligned. ','line_number':1554,'multiline':True]
['text':' Flags were set by a 32 bit operation. ','line_number':1567,'multiline':True]
['text':' Flags were set by an ADD or ADDC operations. ','line_number':1570,'multiline':True]
['text':' Flags were set by a SUB, SUBC, or NEG operation. ','line_number':1572,'multiline':True]
['text':' Flags were set by sljit_emit_op2u with SLJIT_SUB opcode.
   Must be combined with SLJIT_CURRENT_FLAGS_SUB. ','line_number':1575,'multiline':True]
['text':' Define the currently available CPU status flags. It is usually used after
   an sljit_emit_label or sljit_emit_op_custom operations to define which CPU
   status flags are available.

   The current_flags must be a valid combination of SLJIT_SET_* and
   SLJIT_CURRENT_FLAGS_* constants. ','line_number':1579,'multiline':True]
['text':' extern "C" ','line_number':1590,'multiline':True]
['text':' SLJIT_LIR_H_ ','line_number':1593,'multiline':True]
