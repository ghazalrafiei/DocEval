['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' JSMSG_*','line_number':30,'multiline':False]
['text':' js::FunctionFlags','line_number':36,'multiline':False]
['text':' HandlerArgs = ','line_number':100,'multiline':True]
['text':' no handlerArgs ','line_number':109,'multiline':True]
['text':' Entries must be sorted by pcOffset for binary search to work.','line_number':146,'multiline':False]
['text':' See BaselineScript::retAddrEntryFromPCOffset.','line_number':147,'multiline':False]
['text':' Similarly, entries must be sorted by return offset and this offset must be','line_number':151,'multiline':False]
['text':' unique. See BaselineScript::retAddrEntryFromReturnOffset.','line_number':152,'multiline':False]
['text':' When code coverage is enabled, we have to create the ScriptCounts if they','line_number':218,'multiline':False]
['text':' do not exist.','line_number':219,'multiline':False]
['text':' Suppress GC during compilation.','line_number':226,'multiline':False]
['text':' If profiler instrumentation is enabled, toggle instrumentation on.','line_number':284,'multiline':False]
['text':' Initialize the tracelogger instrumentation.','line_number':291,'multiline':False]
['text':' Compute native resume addresses for the script's resume offsets.','line_number':297,'multiline':False]
['text':' Always register a native => bytecode mapping entry, since profiler can be','line_number':304,'multiline':False]
['text':' turned on with baseline jitcode on stack, and baseline jitcode cannot be','line_number':305,'multiline':False]
['text':' invalidated.','line_number':306,'multiline':False]
['text':' Generate profiling string.','line_number':313,'multiline':False]
['text':' Mark the jitcode as having a bytecode map.','line_number':330,'multiline':False]
['text':' On most platforms we use a dedicated bytecode PC register to avoid many','line_number':347,'multiline':False]
['text':' dependent loads and stores for sequences of simple bytecode ops. This','line_number':348,'multiline':False]
['text':' register must be saved/restored around VM and IC calls.','line_number':349,'multiline':False]
['text':'','line_number':350,'multiline':False]
['text':' On 32-bit x86 we don't have enough registers for this (because R0-R2 require','line_number':351,'multiline':False]
['text':' 6 registers) so there we always store the pc on the frame.','line_number':352,'multiline':False]
['text':' Load the opcode and operand, then left shift to discard the opcode.','line_number':395,'multiline':False]
['text':' Note: the Value might be unaligned but as above we rely on all our','line_number':402,'multiline':False]
['text':' platforms having appropriate support for unaligned accesses (except for','line_number':403,'multiline':False]
['text':' floating point instructions on ARM).','line_number':404,'multiline':False]
['text':' Initialize all locals to |undefined|. Lexical bindings are temporal','line_number':441,'multiline':False]
['text':' dead zoned in bytecode.','line_number':442,'multiline':False]
['text':' Use R0 to minimize code size. If the number of locals to push is <','line_number':449,'multiline':False]
['text':' LOOP_UNROLL_FACTOR, then the initialization pushes are emitted directly','line_number':450,'multiline':False]
['text':' and inline.  Otherwise, they're emitted in a partially unrolled loop.','line_number':451,'multiline':False]
['text':' Handle any extra pushes left over by the optional unrolled loop below.','line_number':457,'multiline':False]
['text':' Partially unrolled loop of pushes.','line_number':462,'multiline':False]
['text':' Emit unrolled loop with 4 pushes per iteration.','line_number':468,'multiline':False]
['text':' Push |undefined| for all locals.','line_number':481,'multiline':False]
['text':' On input:','line_number':500,'multiline':False]
['text':'  R2.scratchReg() contains object being written to.','line_number':501,'multiline':False]
['text':'  Called with the baseline stack synced, except for R0 which is preserved.','line_number':502,'multiline':False]
['text':'  All other registers are usable as scratch.','line_number':503,'multiline':False]
['text':' This calls:','line_number':504,'multiline':False]
['text':'    void PostWriteBarrier(JSRuntime* rt, JSObject* obj);','line_number':505,'multiline':False]
['text':' On ARM, save the link register before calling.  It contains the return','line_number':523,'multiline':False]
['text':' address.  The |masm.ret()| later will pop this into |pc| to return.','line_number':524,'multiline':False]
['text':' Scan the a cache IR stub's fields and create an allocation site for any that','line_number':545,'multiline':False]
['text':' refer to the catch-all unknown allocation site. This will be the case for','line_number':546,'multiline':False]
['text':' stubs created when running in the interpreter. This happens on transition to','line_number':547,'multiline':False]
['text':' baseline.','line_number':548,'multiline':False]
['text':' This is an optimization and safe to skip if we hit OOM or per-zone','line_number':589,'multiline':False]
['text':' limit.','line_number':590,'multiline':False]
['text':' Emit a call to an IC stored in JitScript. Calls to this must match the','line_number':599,'multiline':False]
['text':' ICEntry order in JitScript: first the non-op IC entries for |this| and','line_number':600,'multiline':False]
['text':' formal arguments, then the for-op IC entries for JOF_IC ops.','line_number':601,'multiline':False]
['text':' We don't use every ICEntry and we can skip unreachable ops, so we have','line_number':606,'multiline':False]
['text':' to loop until we find an ICEntry for the current pc.','line_number':607,'multiline':False]
['text':' Load stub pointer into ICStubReg.','line_number':623,'multiline':False]
['text':' If this is an IC for a bytecode op where Ion may inline scripts, we need to','line_number':649,'multiline':False]
['text':' record the return offset for Ion bailouts.','line_number':650,'multiline':False]
['text':' dest = FramePointer + BaselineFrame::FramePointerOffset - StackPointer.','line_number':672,'multiline':False]
['text':' Ensure everything is synced.','line_number':686,'multiline':False]
['text':' scratch1 = FramePointer + BaselineFrame::FramePointerOffset - StackPointer.','line_number':707,'multiline':False]
['text':' Store the frame size without VMFunction arguments in debug builds.','line_number':713,'multiline':False]
['text':' Push frame descriptor based on the full frame size.','line_number':718,'multiline':False]
['text':' Assert prepareVMCall() has been called.','line_number':733,'multiline':False]
['text':' Assert all arguments were pushed.','line_number':743,'multiline':False]
['text':' Perform the call.','line_number':762,'multiline':False]
['text':' Pop arguments from framePushed.','line_number':766,'multiline':False]
['text':' Subtract the size of script->nslots() first.','line_number':786,'multiline':False]
['text':' Use a toggled jump to call FrameIsDebuggeeCheck only if the debugger is','line_number':833,'multiline':False]
['text':' enabled.','line_number':834,'multiline':False]
['text':'','line_number':835,'multiline':False]
['text':' TODO(bug 1522394): consider having a cx->realm->isDebuggee guard before the','line_number':836,'multiline':False]
['text':' call. Consider moving the callWithABI out-of-line.','line_number':837,'multiline':False]
['text':' If the main instruction is not a jump target, then we emit the','line_number':863,'multiline':False]
['text':' corresponding code coverage counter.','line_number':864,'multiline':False]
['text':' reg = reg - script->nslots() * sizeof(Value)','line_number':892,'multiline':False]
['text':' Load the index in |scratch|.','line_number':1002,'multiline':False]
['text':' Load the GCCellPtr.','line_number':1005,'multiline':False]
['text':' Clear the tag bits.','line_number':1012,'multiline':False]
['text':' Use xorPtr with a 32-bit immediate because it's more efficient than','line_number':1015,'multiline':False]
['text':' andPtr on 64-bit.','line_number':1016,'multiline':False]
['text':' No-op because GCCellPtr tag bits are zero for objects.','line_number':1024,'multiline':False]
['text':' Use xorPtr with a 32-bit immediate because it's more efficient than','line_number':1029,'multiline':False]
['text':' andPtr on 64-bit.','line_number':1030,'multiline':False]
['text':' Use xorPtr with a 32-bit immediate because it's more efficient than','line_number':1036,'multiline':False]
['text':' andPtr on 64-bit.','line_number':1037,'multiline':False]
['text':' Assert low bits are not set.','line_number':1045,'multiline':False]
['text':' Load pointer to BaselineFrame in R0.','line_number':1117,'multiline':False]
['text':' If cx->inlinedICScript contains an inlined ICScript (passed from','line_number':1150,'multiline':False]
['text':' the caller), take that ICScript and store it in the frame, then','line_number':1151,'multiline':False]
['text':' overwrite cx->inlinedICScript with nullptr.','line_number':1152,'multiline':False]
['text':' Otherwise, store this script's default ICSCript in the frame.','line_number':1162,'multiline':False]
['text':' If we have a dedicated PC register we use it as scratch1 to avoid a','line_number':1174,'multiline':False]
['text':' register move below.','line_number':1175,'multiline':False]
['text':' Initialize interpreterScript.','line_number':1183,'multiline':False]
['text':' CalleeToken_Function or CalleeToken_FunctionConstructing.','line_number':1189,'multiline':False]
['text':' CalleeToken_Script.','line_number':1199,'multiline':False]
['text':' Initialize icScript and interpreterICEntry','line_number':1206,'multiline':False]
['text':' Initialize interpreter pc.','line_number':1215,'multiline':False]
['text':' For function scripts use the code emitted by initFunctionEnv. For other','line_number':1243,'multiline':False]
['text':' scripts this is a no-op.','line_number':1244,'multiline':False]
['text':' Call into the VM to create the proper environment objects.','line_number':1263,'multiline':False]
['text':' Use a custom RetAddrEntry::Kind so DebugModeOSR can distinguish this call','line_number':1292,'multiline':False]
['text':' from other callVMs that might happen at this pc.','line_number':1293,'multiline':False]
['text':' Record native code offset for OSR from Baseline Interpreter into Baseline','line_number':1309,'multiline':False]
['text':' JIT code. This is right before the warm-up check in the Baseline JIT code,','line_number':1310,'multiline':False]
['text':' to make sure we can immediately enter Ion if the script is warm enough or','line_number':1311,'multiline':False]
['text':' if --ion-eager is used.','line_number':1312,'multiline':False]
['text':' Emit no warm-up counter increments if Ion is not enabled or if the script','line_number':1324,'multiline':False]
['text':' will never be Ion-compileable.','line_number':1325,'multiline':False]
['text':' Load the ICScript* in scriptReg.','line_number':1333,'multiline':False]
['text':' Bump warm-up counter.','line_number':1336,'multiline':False]
['text':' Consider trial inlining.','line_number':1343,'multiline':False]
['text':' Note: unlike other warmup thresholds, where we try to enter a','line_number':1344,'multiline':False]
['text':' higher tier whenever we are higher than a given warmup count,','line_number':1345,'multiline':False]
['text':' trial inlining triggers once when reaching the threshold.','line_number':1346,'multiline':False]
['text':' Reload registers potentially clobbered by the call.','line_number':1359,'multiline':False]
['text':' If this is a loop where we can't OSR (for example because it's inside a','line_number':1366,'multiline':False]
['text':' catch or finally block), increment the warmup counter but don't attempt','line_number':1367,'multiline':False]
['text':' OSR (Ion/Warp only compiles the try block).','line_number':1368,'multiline':False]
['text':' Don't trigger Warp compilations from trial-inlined scripts.','line_number':1381,'multiline':False]
['text':' Load the IonScript* in scriptReg. We can load this from the ICScript*','line_number':1385,'multiline':False]
['text':' because it must be an outer ICScript embedded in the JitScript.','line_number':1386,'multiline':False]
['text':' Do nothing if Ion is already compiling this script off-thread or if Ion has','line_number':1391,'multiline':False]
['text':' been disabled for this script.','line_number':1392,'multiline':False]
['text':' Try to compile and/or finish a compilation.','line_number':1398,'multiline':False]
['text':' Try to OSR into Ion.','line_number':1400,'multiline':False]
['text':' The return register holds the IonOsrTempData*. Perform OSR if it's not','line_number':1415,'multiline':False]
['text':' nullptr.','line_number':1416,'multiline':False]
['text':' Success! Switch from Baseline JIT code to Ion JIT code.','line_number':1422,'multiline':False]
['text':' At this point, stack looks like:','line_number':1424,'multiline':False]
['text':'','line_number':1425,'multiline':False]
['text':'  +-> [...Calling-Frame...]','line_number':1426,'multiline':False]
['text':'  |   [...Actual-Args/ThisV/ArgCount/Callee...]','line_number':1427,'multiline':False]
['text':'  |   [Descriptor]','line_number':1428,'multiline':False]
['text':'  |   [Return-Addr]','line_number':1429,'multiline':False]
['text':'  +---[Saved-FramePtr]','line_number':1430,'multiline':False]
['text':'      [...Baseline-Frame...]','line_number':1431,'multiline':False]
['text':' Restore the stack pointer so that the return address is on top of','line_number':1433,'multiline':False]
['text':' the stack.','line_number':1434,'multiline':False]
['text':' Get a scratch register that's not osrDataReg or OsrFrameReg.','line_number':1438,'multiline':False]
['text':' If profiler instrumentation is on, ensure that lastProfilingFrame is','line_number':1446,'multiline':False]
['text':' the frame currently being OSR-ed','line_number':1447,'multiline':False]
['text':' It may be the case that we entered the baseline frame with','line_number':1458,'multiline':False]
['text':' profiling turned off on, then in a call within a loop (i.e. a','line_number':1459,'multiline':False]
['text':' callee frame), turn on profiling, then return to this frame,','line_number':1460,'multiline':False]
['text':' and then OSR with profiling turned on.  In this case, allow for','line_number':1461,'multiline':False]
['text':' lastProfilingFrame to be null.','line_number':1462,'multiline':False]
['text':' Jump into Ion.','line_number':1471,'multiline':False]
['text':' Load the JitScript* in scriptReg.','line_number':1495,'multiline':False]
['text':' Bump warm-up counter.','line_number':1499,'multiline':False]
['text':' If the script is warm enough for Baseline compilation, call into the VM to','line_number':1505,'multiline':False]
['text':' compile it.','line_number':1506,'multiline':False]
['text':' If the function returned nullptr we either skipped compilation or were','line_number':1523,'multiline':False]
['text':' unable to compile the script. Continue running in the interpreter.','line_number':1524,'multiline':False]
['text':' Success! Switch from interpreter to JIT code by jumping to the','line_number':1527,'multiline':False]
['text':' corresponding code in the BaselineScript.','line_number':1528,'multiline':False]
['text':'','line_number':1529,'multiline':False]
['text':' This works because BaselineCompiler uses the same frame layout (stack is','line_number':1530,'multiline':False]
['text':' synced at OSR points) and BaselineCompileFromBaselineInterpreter has','line_number':1531,'multiline':False]
['text':' already cleared the RUNNING_IN_INTERPRETER flag for us.','line_number':1532,'multiline':False]
['text':' See BaselineFrame::prepareForBaselineInterpreterToJitOSR.','line_number':1533,'multiline':False]
['text':' Emit patchable call to debug trap handler.','line_number':1549,'multiline':False]
['text':' Add a RetAddrEntry for the return offset -> pc mapping.','line_number':1564,'multiline':False]
['text':' Script start.','line_number':1586,'multiline':False]
['text':' Engine start.','line_number':1595,'multiline':False]
['text':' force = ','line_number':1596,'multiline':True]
['text':' force = ','line_number':1627,'multiline':True]
['text':' force = ','line_number':1628,'multiline':True]
['text':' force = ','line_number':1654,'multiline':True]
['text':' Store stack position to lastProfilingFrame variable, guarded by a toggled','line_number':1667,'multiline':False]
['text':' jump. Starts off initially disabled.','line_number':1668,'multiline':False]
['text':' Store the start offset in the appropriate location.','line_number':1674,'multiline':False]
['text':' Store previous frame to lastProfilingFrame variable, guarded by a toggled','line_number':1681,'multiline':False]
['text':' jump. Starts off initially disabled.','line_number':1682,'multiline':False]
['text':' Store the start offset in the appropriate location.','line_number':1688,'multiline':False]
['text':' DupAt takes a value on the stack and re-pushes it on top.  It's like','line_number':1731,'multiline':False]
['text':' GetLocal but it addresses from the top of the stack instead of from the','line_number':1732,'multiline':False]
['text':' stack frame.','line_number':1733,'multiline':False]
['text':' Keep top stack value in R0, sync the rest so that we can use R1. We use','line_number':1751,'multiline':False]
['text':' separate registers because every register can be used by at most one','line_number':1752,'multiline':False]
['text':' StackValue.','line_number':1753,'multiline':False]
['text':' inc/dec ops use Dup followed by Inc/Dec. Push R0 last to avoid a move.','line_number':1757,'multiline':False]
['text':' Keep top stack values in R0 and R1.','line_number':1777,'multiline':False]
['text':' Pick takes a value on the stack and moves it to the top.','line_number':1789,'multiline':False]
['text':' For instance, pick 2:','line_number':1790,'multiline':False]
['text':'     before: A B C D E','line_number':1791,'multiline':False]
['text':'     after : A B D E C','line_number':1792,'multiline':False]
['text':' First, move value at -(amount + 1) into R0.','line_number':1794,'multiline':False]
['text':' Move the other values down.','line_number':1798,'multiline':False]
['text':' Push R0.','line_number':1807,'multiline':False]
['text':' First, move the value to move up into R0.','line_number':1815,'multiline':False]
['text':' Move the other values down.','line_number':1820,'multiline':False]
['text':' Replace value on top of the stack with R0.','line_number':1832,'multiline':False]
['text':' Pick takes the top of the stack value and moves it under the nth value.','line_number':1841,'multiline':False]
['text':' For instance, unpick 2:','line_number':1842,'multiline':False]
['text':'     before: A B C D E','line_number':1843,'multiline':False]
['text':'     after : A B E C D','line_number':1844,'multiline':False]
['text':' First, move value at -1 into R0.','line_number':1846,'multiline':False]
['text':' Move the other values up.','line_number':1852,'multiline':False]
['text':' Store R0 under the nth value.','line_number':1861,'multiline':False]
['text':' Move the top value into R0.','line_number':1872,'multiline':False]
['text':' Overwrite the nth stack value with R0 but first save the old value in R1.','line_number':1875,'multiline':False]
['text':' Now for each slot x in [n-1, 1] do the following:','line_number':1879,'multiline':False]
['text':'','line_number':1880,'multiline':False]
['text':' * Store the value in slot x in R0.','line_number':1881,'multiline':False]
['text':' * Store the value in the previous slot (now in R1) in slot x.','line_number':1882,'multiline':False]
['text':' * Move R0 to R1.','line_number':1883,'multiline':False]
['text':' Assert the operand > 0 so the branchSub32 below doesn't "underflow" to','line_number':1886,'multiline':False]
['text':' negative values.','line_number':1887,'multiline':False]
['text':' Overwrite stack slot x with slot x + 1, saving the old value in R1.','line_number':1900,'multiline':False]
['text':' Finally, replace the value on top of the stack (slot 0) with R1. This is','line_number':1907,'multiline':False]
['text':' the value that used to be in slot 1.','line_number':1908,'multiline':False]
['text':' We have to add the current pc's jump offset to the current pc. We can use','line_number':1926,'multiline':False]
['text':' R0 and R1 as scratch because we jump to the "next op" label so these','line_number':1927,'multiline':False]
['text':' registers aren't in use at this point.','line_number':1928,'multiline':False]
['text':' Keep top stack value in R0.','line_number':2071,'multiline':False]
['text':' IC will leave a BooleanValue in R0, just need to branch on it.','line_number':2078,'multiline':False]
['text':' And and Or leave the original value on the stack.','line_number':2097,'multiline':False]
['text':' Coalesce leaves the original value on the stack.','line_number':2121,'multiline':False]
['text':' fall through','line_number':2133,'multiline':False]
['text':' Keep top stack value in R0.','line_number':2141,'multiline':False]
['text':' If this ever changes, change what JSOp::GImplicitThis does too.','line_number':2187,'multiline':False]
['text':' reinit = ','line_number':2238,'multiline':True]
['text':' Load |this| in R0, return value in R1.','line_number':2273,'multiline':False]
['text':' Store |this| in the return value slot.','line_number':2296,'multiline':False]
['text':' Load |thisv| in R0. Skip the call if it's already an object.','line_number':2311,'multiline':False]
['text':' In strict mode code, |this| is left alone.','line_number':2331,'multiline':False]
['text':' Box and push return value.','line_number':2557,'multiline':False]
['text':' Box and push return value.','line_number':2574,'multiline':False]
['text':' Box and push return value.','line_number':2594,'multiline':False]
['text':' Keep pushed newTarget in R0.','line_number':2602,'multiline':False]
['text':' Box and push return value.','line_number':2619,'multiline':False]
['text':' Keep top JSStack value in R0 and R2','line_number':2707,'multiline':False]
['text':' Call IC','line_number':2710,'multiline':False]
['text':' Mark R0 as pushed stack value.','line_number':2715,'multiline':False]
['text':' Keep top stack value in R0.','line_number':2722,'multiline':False]
['text':' Call IC','line_number':2725,'multiline':False]
['text':' Mark R0 as pushed stack value.','line_number':2730,'multiline':False]
['text':' CODEGEN','line_number':2787,'multiline':False]
['text':' Keep top JSStack value in R0 and R1.','line_number':2789,'multiline':False]
['text':' Call IC.','line_number':2792,'multiline':False]
['text':' Mark R0 as pushed stack value.','line_number':2797,'multiline':False]
['text':' branchIfTrue ','line_number':2817,'multiline':True]
['text':' Pop the switch value if the case matches.','line_number':2819,'multiline':False]
['text':' Pop value into R0, keep the object on the stack.','line_number':2864,'multiline':False]
['text':' Load object in R2.','line_number':2867,'multiline':False]
['text':' Load index in R1.','line_number':2871,'multiline':False]
['text':' Store the Value. No pre-barrier because this is an initialization.','line_number':2875,'multiline':False]
['text':' Bump initialized length.','line_number':2879,'multiline':False]
['text':' Mark elements as NON_PACKED if we stored the hole value.','line_number':2884,'multiline':False]
['text':' Post-barrier.','line_number':2887,'multiline':False]
['text':' Pop value into R0, keep the object on the stack.','line_number':2903,'multiline':False]
['text':' Load object in R2.','line_number':2907,'multiline':False]
['text':' Store the Value. No pre-barrier because this is an initialization.','line_number':2916,'multiline':False]
['text':' Bump initialized length.','line_number':2920,'multiline':False]
['text':' Mark elements as NON_PACKED if we stored the hole value. We know this','line_number':2924,'multiline':False]
['text':' statically except when debugger instrumentation is enabled because that','line_number':2925,'multiline':False]
['text':' forces a stack-sync (which discards constants and known types) for each op.','line_number':2926,'multiline':False]
['text':' Post-barrier.','line_number':2941,'multiline':False]
['text':' Store RHS in the scratch slot.','line_number':2985,'multiline':False]
['text':' Keep object and index in R0 and R1.','line_number':2989,'multiline':False]
['text':' Push the object to store the result of the IC.','line_number':2992,'multiline':False]
['text':' Keep RHS on the stack.','line_number':2996,'multiline':False]
['text':' Call IC.','line_number':2999,'multiline':False]
['text':' Pop the rhs, so that the object is on the top of the stack.','line_number':3004,'multiline':False]
['text':' Keep values on the stack for the decompiler.','line_number':3021,'multiline':False]
['text':' Load lhs in R0, rhs in R1.','line_number':3043,'multiline':False]
['text':' Call IC.','line_number':3048,'multiline':False]
['text':' Leave the object on the stack.','line_number':3053,'multiline':False]
['text':' Keep top two stack values in R0 and R1.','line_number':3070,'multiline':False]
['text':' Call IC.','line_number':3073,'multiline':False]
['text':' Mark R0 as pushed stack value.','line_number':3078,'multiline':False]
['text':' Store obj in the scratch slot.','line_number':3085,'multiline':False]
['text':' Keep receiver and index in R0 and R1.','line_number':3089,'multiline':False]
['text':' Keep obj on the stack.','line_number':3092,'multiline':False]
['text':' Store RHS in the scratch slot.','line_number':3106,'multiline':False]
['text':' Keep object and index in R0 and R1.','line_number':3110,'multiline':False]
['text':' Keep RHS on the stack.','line_number':3113,'multiline':False]
['text':' Call IC.','line_number':3116,'multiline':False]
['text':' Incoming stack is |receiver, propval, obj, rval|. We need to shuffle','line_number':3131,'multiline':False]
['text':' stack to leave rval when operation is complete.','line_number':3132,'multiline':False]
['text':' Pop rval into R0, then load receiver into R1 and replace with rval.','line_number':3134,'multiline':False]
['text':' receiver','line_number':3142,'multiline':False]
['text':' rval','line_number':3143,'multiline':False]
['text':' propval','line_number':3145,'multiline':False]
['text':' obj','line_number':3147,'multiline':False]
['text':' strict = ','line_number':3161,'multiline':True]
['text':' strict = ','line_number':3166,'multiline':True]
['text':' Keep values on the stack for the decompiler.','line_number':3171,'multiline':False]
['text':' strict = ','line_number':3200,'multiline':True]
['text':' strict = ','line_number':3205,'multiline':True]
['text':' Keep key and val on the stack.','line_number':3234,'multiline':False]
['text':' These names are non-configurable on the global and cannot be shadowed.','line_number':3251,'multiline':False]
['text':' Interpreter doesn't optimize simple GETGNAMEs.','line_number':3270,'multiline':False]
['text':' Call IC.','line_number':3287,'multiline':False]
['text':' Mark R0 as pushed stack value.','line_number':3292,'multiline':False]
['text':' Interpreter doesn't optimize simple BINDGNAMEs.','line_number':3318,'multiline':False]
['text':' Keep lhs in R0, rhs in R1.','line_number':3350,'multiline':False]
['text':' Keep RHS on the stack.','line_number':3353,'multiline':False]
['text':' Call IC.','line_number':3357,'multiline':False]
['text':' Incoming stack is |receiver, obj, rval|. We need to shuffle stack to','line_number':3392,'multiline':False]
['text':' leave rval when operation is complete.','line_number':3393,'multiline':False]
['text':' Pop rval into R0, then load receiver into R1 and replace with rval.','line_number':3395,'multiline':False]
['text':' rval','line_number':3403,'multiline':False]
['text':' receiver','line_number':3405,'multiline':False]
['text':' obj','line_number':3407,'multiline':False]
['text':' strict = ','line_number':3421,'multiline':True]
['text':' strict = ','line_number':3426,'multiline':True]
['text':' Keep object in R0.','line_number':3431,'multiline':False]
['text':' Call IC.','line_number':3434,'multiline':False]
['text':' Mark R0 as pushed stack value.','line_number':3439,'multiline':False]
['text':' Receiver -> R1, Object -> R0','line_number':3451,'multiline':False]
['text':' Keep value on the stack for the decompiler.','line_number':3466,'multiline':False]
['text':' strict = ','line_number':3494,'multiline':True]
['text':' strict = ','line_number':3499,'multiline':True]
['text':' For a JOF_ENVCOORD op load the number of hops from the bytecode and skip this','line_number':3545,'multiline':False]
['text':' number of environment objects.','line_number':3546,'multiline':False]
['text':' Load the right environment object.','line_number':3577,'multiline':False]
['text':' Load the slot index.','line_number':3581,'multiline':False]
['text':' Load the Value from a fixed or dynamic slot.','line_number':3586,'multiline':False]
['text':' See EnvironmentObject::nonExtensibleIsFixedSlot.','line_number':3587,'multiline':False]
['text':' Use an offset to subtract the number of fixed slots.','line_number':3600,'multiline':False]
['text':' Load the right environment object.','line_number':3611,'multiline':False]
['text':' Keep rvalue in R0.','line_number':3643,'multiline':False]
['text':' Only R0 is live at this point.','line_number':3654,'multiline':False]
['text':' Scope coordinate object is already in R2.scratchReg().','line_number':3655,'multiline':False]
['text':' Won't clobber R0','line_number':3662,'multiline':False]
['text':' Load the right environment object.','line_number':3682,'multiline':False]
['text':' Load the slot index.','line_number':3686,'multiline':False]
['text':' Store the RHS Value in R2.','line_number':3691,'multiline':False]
['text':' Load a pointer to the fixed or dynamic slot into scratch2. We want to call','line_number':3694,'multiline':False]
['text':' guardedCallPreBarrierAnyZone once to avoid code bloat.','line_number':3695,'multiline':False]
['text':' See EnvironmentObject::nonExtensibleIsFixedSlot.','line_number':3697,'multiline':False]
['text':' Use an offset to subtract the number of fixed slots.','line_number':3711,'multiline':False]
['text':' Pre-barrier and store.','line_number':3718,'multiline':False]
['text':' Post barrier.','line_number':3723,'multiline':False]
['text':' Post barrier code expects the object in R2.','line_number':3729,'multiline':False]
['text':' Call IC.','line_number':3743,'multiline':False]
['text':' Mark R0 as pushed stack value.','line_number':3748,'multiline':False]
['text':' If we have a BindGName without a non-syntactic scope, we pass the global','line_number':3755,'multiline':False]
['text':' lexical environment to the IC instead of the frame's environment.','line_number':3756,'multiline':False]
['text':' Call IC.','line_number':3781,'multiline':False]
['text':' Mark R0 as pushed stack value.','line_number':3786,'multiline':False]
['text':' Imports are initialized by this point except in rare circumstances, so','line_number':3842,'multiline':False]
['text':' don't emit a check unless we have to.','line_number':3843,'multiline':False]
['text':' Keep values on the stack for the decompiler.','line_number':3921,'multiline':False]
['text':' Load index and value in R0 and R1, but keep values on the stack for the','line_number':3966,'multiline':False]
['text':' decompiler.','line_number':3967,'multiline':False]
['text':' Keep the object and rhs on the stack.','line_number':4012,'multiline':False]
['text':' Load object in R0, index in R1.','line_number':4015,'multiline':False]
['text':' Call IC.','line_number':4019,'multiline':False]
['text':' Pop the rhs','line_number':4024,'multiline':False]
['text':' Increment index','line_number':4027,'multiline':False]
['text':' Locals are stored in memory at a negative offset from the frame pointer. We','line_number':4047,'multiline':False]
['text':' negate the index first to effectively subtract it.','line_number':4048,'multiline':False]
['text':' Ensure no other StackValue refers to the old value, for instance i + (i =','line_number':4066,'multiline':False]
['text':' 3). This also allows us to use R0 as scratch below.','line_number':4067,'multiline':False]
['text':' Fast path: the script does not use |arguments| or formals don't','line_number':4091,'multiline':False]
['text':' alias the arguments object.','line_number':4092,'multiline':False]
['text':' See the comment in emit_SetLocal.','line_number':4097,'multiline':False]
['text':' Sync so that we can use R0.','line_number':4105,'multiline':False]
['text':' Load the arguments object data vector.','line_number':4108,'multiline':False]
['text':' Load/store the argument.','line_number':4113,'multiline':False]
['text':' Reload the arguments object.','line_number':4126,'multiline':False]
['text':' Load the index.','line_number':4147,'multiline':False]
['text':' If the frame has no arguments object, this must be an unaliased access.','line_number':4151,'multiline':False]
['text':' If it's an unmapped arguments object, this is an unaliased access.','line_number':4158,'multiline':False]
['text':' Load the arguments object data vector.','line_number':4165,'multiline':False]
['text':' Load/store the argument.','line_number':4169,'multiline':False]
['text':' Reload the arguments object.','line_number':4180,'multiline':False]
['text':' if (isConstructing()) push(argv[Max(numActualArgs, numFormalArgs)])','line_number':4231,'multiline':False]
['text':' If argvLen < nformals, set argvlen := nformals.','line_number':4242,'multiline':False]
['text':' else push(undefined)','line_number':4251,'multiline':False]
['text':' Arrow functions store their |new.target| value in an','line_number':4270,'multiline':False]
['text':' extended slot.','line_number':4271,'multiline':False]
['text':' Case 1: eval.','line_number':4294,'multiline':False]
['text':' Case 2: arrow function.','line_number':4307,'multiline':False]
['text':' Case 3: non-arrow function.','line_number':4315,'multiline':False]
['text':' Call IC','line_number':4395,'multiline':False]
['text':' Update FrameInfo.','line_number':4400,'multiline':False]
['text':' The IC expects argc in R0.','line_number':4411,'multiline':False]
['text':' Pop the arguments. We have to reload pc/argc because the IC clobbers them.','line_number':4417,'multiline':False]
['text':' The return value is in R0 so we can't use that.','line_number':4418,'multiline':False]
['text':' Call IC','line_number':4436,'multiline':False]
['text':' Update FrameInfo.','line_number':4441,'multiline':False]
['text':' Keep value to throw in R0.','line_number':4602,'multiline':False]
['text':' JSOp::Finally has a def count of 2, but these values are already on the','line_number':4619,'multiline':False]
['text':' stack (they're pushed by JSOp::Gosub). Update the compiler's stack state.','line_number':4620,'multiline':False]
['text':' To match the interpreter, emit an interrupt check at the start of the','line_number':4623,'multiline':False]
['text':' finally block.','line_number':4624,'multiline':False]
['text':' Jump to the finally block.','line_number':4630,'multiline':False]
['text':' Load JSScript::immutableScriptData() into |script|.','line_number':4652,'multiline':False]
['text':' Load the resume pcOffset in |resumeIndex|.','line_number':4657,'multiline':False]
['text':' Add resume offset to PC, jump to it.','line_number':4665,'multiline':False]
['text':' branchIfTrue = ','line_number':4699,'multiline':True]
['text':' R0 is |true|. We need to throw R1.','line_number':4701,'multiline':False]
['text':' R0 is |false|. R1 contains the resumeIndex to jump to.','line_number':4712,'multiline':False]
['text':' The JIT calls either ifDebuggee or (if present) ifNotDebuggee, because it','line_number':4726,'multiline':False]
['text':' knows statically whether we're compiling with debug instrumentation.','line_number':4727,'multiline':False]
['text':' The interpreter emits both ifDebuggee and (if present) ifNotDebuggee','line_number':4744,'multiline':False]
['text':' paths, with a toggled jump followed by a branch on the frame's DEBUGGEE','line_number':4745,'multiline':False]
['text':' flag.','line_number':4746,'multiline':False]
['text':' Call a stub to push the block on the block chain.','line_number':4778,'multiline':False]
['text':' Pop "with" object to R0.','line_number':4903,'multiline':False]
['text':' Call a stub to push the object onto the environment chain.','line_number':4906,'multiline':False]
['text':' Call a stub to pop the with object from the environment chain.','line_number':4922,'multiline':False]
['text':' Move return value into the frame's rval slot.','line_number':4964,'multiline':False]
['text':' Load BaselineFrame pointer in R0.','line_number':4968,'multiline':False]
['text':' Only emit the jump if this JSOp::RetRval is not the last instruction.','line_number':4997,'multiline':False]
['text':' Not needed for last instruction, because last instruction flows','line_number':4998,'multiline':False]
['text':' into return label.','line_number':4999,'multiline':False]
['text':' Return the value in the return value slot, if any.','line_number':5036,'multiline':False]
['text':' Keep top stack value in R0.','line_number':5194,'multiline':False]
['text':' Inline path for string.','line_number':5197,'multiline':False]
['text':' Call ToStringSlow which doesn't handle string inputs.','line_number':5205,'multiline':False]
['text':' Jump to the 'default' pc if not int32 (tableswitch is only used when','line_number':5236,'multiline':False]
['text':' all cases are int32).','line_number':5237,'multiline':False]
['text':' Subtract 'low'. Bounds check.','line_number':5241,'multiline':False]
['text':' Jump to the 'default' pc if not int32 (tableswitch is only used when','line_number':5253,'multiline':False]
['text':' all cases are int32).','line_number':5254,'multiline':False]
['text':' Jump to default if val > high.','line_number':5263,'multiline':False]
['text':' Jump to default if val < low.','line_number':5266,'multiline':False]
['text':' index := val - low.','line_number':5270,'multiline':False]
['text':' Jump to resumeEntries[firstResumeIndex + key].','line_number':5284,'multiline':False]
['text':' Note: BytecodeEmitter::allocateResumeIndex static_asserts','line_number':5286,'multiline':False]
['text':' |firstResumeIndex * sizeof(uintptr_t)| fits in int32_t.','line_number':5287,'multiline':False]
['text':' Load the op's firstResumeIndex in scratch1.','line_number':5301,'multiline':False]
['text':' Call a stub to convert R0 from double to int32 if needed.','line_number':5316,'multiline':False]
['text':' Note: this stub may clobber scratch1.','line_number':5317,'multiline':False]
['text':' Load the index in the jump table in |key|, or branch to default pc if not','line_number':5320,'multiline':False]
['text':' int32 or out-of-range.','line_number':5321,'multiline':False]
['text':' Jump to the target pc.','line_number':5324,'multiline':False]
['text':' Pop iterator value.','line_number':5377,'multiline':False]
['text':' Pop the iterator object to close in R0.','line_number':5380,'multiline':False]
['text':' Store to the frame's return value slot.','line_number':5417,'multiline':False]
['text':' Load the right environment object.','line_number':5461,'multiline':False]
['text':' Unbox callee.','line_number':5476,'multiline':False]
['text':' Load [[HomeObject]]','line_number':5479,'multiline':False]
['text':' Load prototype from [[HomeObject]]','line_number':5490,'multiline':False]
['text':' We won't encounter a lazy proto, because the prototype is guaranteed to','line_number':5494,'multiline':False]
['text':' either be a JSFunction or a PlainObject, and only proxy objects can have a','line_number':5495,'multiline':False]
['text':' lazy proto.','line_number':5496,'multiline':False]
['text':' Throw an error if |proto| is null.','line_number':5508,'multiline':False]
['text':' Box prototype and return','line_number':5516,'multiline':False]
['text':' Unbox callee.','line_number':5533,'multiline':False]
['text':' Load prototype of callee','line_number':5544,'multiline':False]
['text':' We won't encounter a lazy proto, because |callee| is guaranteed to be a','line_number':5548,'multiline':False]
['text':' JSFunction and only proxy objects can have a lazy proto.','line_number':5549,'multiline':False]
['text':' Box prototype and return','line_number':5561,'multiline':False]
['text':' Mark R0 as pushed stack value.','line_number':5601,'multiline':False]
['text':' Load the generator object in R2, but leave the return value on the','line_number':5630,'multiline':False]
['text':' expression stack.','line_number':5631,'multiline':False]
['text':' Generator and return value are one and the same.','line_number':5634,'multiline':False]
['text':' If the expression stack is empty, we can inline the Yield. Note that this','line_number':5644,'multiline':False]
['text':' branch is never taken for the interpreter because it doesn't know static','line_number':5645,'multiline':False]
['text':' stack depths.','line_number':5646,'multiline':False]
['text':' Three values are pushed onto the stack when resuming the generator,','line_number':5697,'multiline':False]
['text':' replacing the one slot that holds the return value.','line_number':5698,'multiline':False]
['text':' Note that we can't use emitDebugInstrumentation here because the frame's','line_number':5732,'multiline':False]
['text':' DEBUGGEE flag hasn't been initialized yet.','line_number':5733,'multiline':False]
['text':' If the current Realm is not a debuggee we're done.','line_number':5735,'multiline':False]
['text':' Store generator in R0.','line_number':5780,'multiline':False]
['text':' Resume in either the BaselineScript (if present) or Baseline Interpreter.','line_number':5813,'multiline':False]
['text':' Initialize the icScript slot in the baseline frame.','line_number':5818,'multiline':False]
['text':' Initialize interpreter frame fields.','line_number':5842,'multiline':False]
['text':' Initialize pc and jump to it.','line_number':5849,'multiline':False]
['text':' Load generator object.','line_number':5867,'multiline':False]
['text':' Load callee.','line_number':5871,'multiline':False]
['text':' Save a pointer to the JSOp::Resume operand stack Values.','line_number':5876,'multiline':False]
['text':' Branch to |interpret| to resume the generator in the C++ interpreter if the','line_number':5880,'multiline':False]
['text':' script does not have a JitScript.','line_number':5881,'multiline':False]
['text':' TODO (bug 1565788): add Baseline Interpreter support.','line_number':5889,'multiline':False]
['text':' Push |undefined| for all formals.','line_number':5900,'multiline':False]
['text':' If JitStackValueAlignment == 1, then we were already correctly aligned on','line_number':5907,'multiline':False]
['text':' entry, as guaranteed by the assertStackAlignment at the entry to this','line_number':5908,'multiline':False]
['text':' function.','line_number':5909,'multiline':False]
['text':' Compute alignment adjustment.','line_number':5915,'multiline':False]
['text':' Some code, like BaselineFrame::trace, will inspect the whole range of','line_number':5918,'multiline':False]
['text':' the stack frame. In order to ensure that garbage data left behind from','line_number':5919,'multiline':False]
['text':' previous activations doesn't confuse other machinery, we zero out the','line_number':5920,'multiline':False]
['text':' alignment bytes.','line_number':5921,'multiline':False]
['text':' Since we know prior to the stack alignment that the stack was 8 byte','line_number':5925,'multiline':False]
['text':' aligned, and JitStackAlignment is 8 or 16 bytes, if we are doing an','line_number':5926,'multiline':False]
['text':' alignment then we -must- have aligned by subtracting 8 bytes from','line_number':5927,'multiline':False]
['text':' the stack pointer.','line_number':5928,'multiline':False]
['text':'','line_number':5929,'multiline':False]
['text':' So we can freely store a valid double here.','line_number':5930,'multiline':False]
['text':' Push |undefined| for |this|.','line_number':5943,'multiline':False]
['text':' Update BaselineFrame frameSize field and create the frame descriptor.','line_number':5946,'multiline':False]
['text':' actual argc','line_number':5956,'multiline':False]
['text':' constructing = ','line_number':5957,'multiline':True]
['text':' frame descriptor','line_number':5958,'multiline':False]
['text':' PushCalleeToken bumped framePushed. Reset it.','line_number':5960,'multiline':False]
['text':' Push a fake return address on the stack. We will resume here when the','line_number':5966,'multiline':False]
['text':' generator returns.','line_number':5967,'multiline':False]
['text':' Record the return address so the return offset -> pc mapping works.','line_number':5975,'multiline':False]
['text':' If profiler instrumentation is on, update lastProfilingFrame on','line_number':5987,'multiline':False]
['text':' current JitActivation','line_number':5988,'multiline':False]
['text':' Construct BaselineFrame.','line_number':6003,'multiline':False]
['text':' Store flags and env chain.','line_number':6009,'multiline':False]
['text':' Store the arguments object if there is one.','line_number':6016,'multiline':False]
['text':' Push locals and expression slots if needed.','line_number':6026,'multiline':False]
['text':' Push arg, generator, resumeKind stack Values, in that order.','line_number':6056,'multiline':False]
['text':' Load script in scratch1.','line_number':6063,'multiline':False]
['text':' Load resume index in scratch2 and mark generator as running.','line_number':6068,'multiline':False]
['text':' Call into the VM to resume the generator in the C++ interpreter if there's','line_number':6079,'multiline':False]
['text':' no JitScript.','line_number':6080,'multiline':False]
['text':' When we call into a function which may end up in Warp/Ion,','line_number':6097,'multiline':False]
['text':' we need to account for the possibility that BaselineFrameReg','line_number':6098,'multiline':False]
['text':' is clobbered. So we recompute it based on the frame descriptor.','line_number':6099,'multiline':False]
['text':' Load the frame descriptor into R2.','line_number':6101,'multiline':False]
['text':' Compute Frame Size.','line_number':6103,'multiline':False]
['text':' Add to stack pointer.','line_number':6105,'multiline':False]
['text':' This magic constant corresponds to the callee token and','line_number':6108,'multiline':False]
['text':' actualArgc pushed before the frame descriptor was pushed.','line_number':6109,'multiline':False]
['text':' Restore Stack pointer','line_number':6113,'multiline':False]
['text':' After the generator returns, we restore the stack pointer, switch back to','line_number':6117,'multiline':False]
['text':' the current realm, push the return value, and we're done.','line_number':6118,'multiline':False]
['text':' Load resumeKind in R1, generator in R0.','line_number':6132,'multiline':False]
['text':' If resumeKind is 'next' we don't have to do anything.','line_number':6142,'multiline':False]
['text':' resumeKind','line_number':6150,'multiline':False]
['text':' arg','line_number':6153,'multiline':False]
['text':' genObj','line_number':6156,'multiline':False]
['text':' frame','line_number':6159,'multiline':False]
['text':' Load icIndex in scratch1.','line_number':6229,'multiline':False]
['text':' Compute ICEntry* and store to frame->interpreterICEntry.','line_number':6232,'multiline':False]
['text':' Leave the heritage value on the stack.','line_number':6246,'multiline':False]
['text':' Load HomeObject in R0.','line_number':6258,'multiline':False]
['text':' Load function off stack','line_number':6261,'multiline':False]
['text':' Set HOMEOBJECT_SLOT','line_number':6265,'multiline':False]
['text':' Built-in objects are constants for a given global.','line_number':6282,'multiline':False]
['text':' Leave the proto value on the stack for the decompiler','line_number':6312,'multiline':False]
['text':' Note: this is like the interpreter implementation, but optimized a bit by','line_number':6355,'multiline':False]
['text':' calling GetModuleObjectForScript at compile-time.','line_number':6356,'multiline':False]
['text':' Put specifier value in R0.','line_number':6394,'multiline':False]
['text':' Caller is responsible for checking script->hasForceInterpreterOp().','line_number':6413,'multiline':False]
['text':' Push link register from generateEnterJIT()'s BLR.','line_number':6426,'multiline':False]
['text':' Initialize BaselineFrame. Also handles env chain pre-initialization (in','line_number':6436,'multiline':False]
['text':' case GC gets run during stack check). For global and eval scripts, the env','line_number':6437,'multiline':False]
['text':' chain is in R1. For function scripts, the env chain is in the callee.','line_number':6438,'multiline':False]
['text':' When compiling with Debugger instrumentation, set the debuggeeness of','line_number':6441,'multiline':False]
['text':' the frame before any operation that can call into the VM.','line_number':6442,'multiline':False]
['text':' Initialize the env chain before any operation that may call into the VM and','line_number':6447,'multiline':False]
['text':' trigger a GC.','line_number':6448,'multiline':False]
['text':' Check for overrecursion before initializing locals.','line_number':6453,'multiline':False]
['text':' Ion prologue bailouts will enter here in the Baseline Interpreter.','line_number':6466,'multiline':False]
['text':' Skip unreachable ops.','line_number':6530,'multiline':False]
['text':' Test if last instructions and stop emitting in that case.','line_number':6532,'multiline':False]
['text':' Fully sync the stack if there are incoming jumps.','line_number':6543,'multiline':False]
['text':' Also fully sync the stack if the debugger is enabled.','line_number':6548,'multiline':False]
['text':' At the beginning of any op, at most the top 2 stack-values are','line_number':6551,'multiline':False]
['text':' unsynced.','line_number':6552,'multiline':False]
['text':' If the script has a resume offset for this pc we need to keep track of','line_number':6560,'multiline':False]
['text':' the native code offset.','line_number':6561,'multiline':False]
['text':' Emit traps for breakpoints and step mode.','line_number':6572,'multiline':False]
['text':' Test if last instructions and stop emitting in that case.','line_number':6592,'multiline':False]
['text':' Register holding the bytecode pc during dispatch. This exists so the debug','line_number':6617,'multiline':False]
['text':' trap handler can reload the pc into this register when it's done.','line_number':6618,'multiline':False]
['text':' Entry point for interpreting a bytecode op. No registers are live except','line_number':6626,'multiline':False]
['text':' for InterpreterPCReg.','line_number':6627,'multiline':False]
['text':' Emit a patchable call for debugger breakpoints/stepping.','line_number':6630,'multiline':False]
['text':' Load pc, bytecode op.','line_number':6637,'multiline':False]
['text':' Jump to table[op].','line_number':6641,'multiline':False]
['text':' At the end of each op, emit code to bump the pc and jump to the','line_number':6651,'multiline':False]
['text':' next op (this is also known as a threaded interpreter).','line_number':6652,'multiline':False]
['text':' Nothing to do.','line_number':6657,'multiline':False]
['text':' Bump frame->interpreterICEntry if needed.','line_number':6662,'multiline':False]
['text':' Bump bytecode PC.','line_number':6667,'multiline':False]
['text':' Load the opcode, jump to table[op].','line_number':6682,'multiline':False]
['text':' Emit code for each bytecode op.','line_number':6693,'multiline':False]
['text':' External entry point to start interpreting bytecode ops. This is used for','line_number':6710,'multiline':False]
['text':' things like exception handling and OSR. DebugModeOSR patches JIT frames to','line_number':6711,'multiline':False]
['text':' return here from the DebugTrapHandler.','line_number':6712,'multiline':False]
['text':' Second external entry point: this skips the debug trap for the first op','line_number':6718,'multiline':False]
['text':' and is used by OSR.','line_number':6719,'multiline':False]
['text':' External entry point for Ion prologue bailouts.','line_number':6724,'multiline':False]
['text':' Emit debug trap handler code (target of patchable call instructions). This','line_number':6729,'multiline':False]
['text':' is just a tail call to the debug trap handler trampoline code.','line_number':6730,'multiline':False]
['text':' Emit the table.','line_number':6743,'multiline':False]
['text':' Register BaselineInterpreter code with the profiler's JitCode table.','line_number':6832,'multiline':False]
['text':' Patch loads now that we know the tableswitch base address.','line_number':6847,'multiline':False]
['text':' The interpreter calls this for every script when debugging, so check if','line_number':6902,'multiline':False]
['text':' the script has any breakpoints or is in step mode before calling into','line_number':6903,'multiline':False]
['text':' C++.','line_number':6904,'multiline':False]
['text':' Update frame's bytecode pc because the debugger depends on it.','line_number':6917,'multiline':False]
['text':' Load the return address in scratch1.','line_number':6924,'multiline':False]
['text':' Load BaselineFrame pointer in scratch2.','line_number':6927,'multiline':False]
['text':' Enter a stub frame and call the HandleDebugTrap VM function. Ensure','line_number':6930,'multiline':False]
['text':' the stub frame has a nullptr ICStub pointer, since this pointer is marked','line_number':6931,'multiline':False]
['text':' during GC.','line_number':6932,'multiline':False]
['text':' We have to reload the bytecode pc register.','line_number':6947,'multiline':False]
['text':' namespace jit','line_number':6970,'multiline':False]
['text':' namespace js','line_number':6971,'multiline':False]
