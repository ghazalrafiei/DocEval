['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' Shift operand should be constant or, unless BMI2 is available, in register','line_number':49,'multiline':False]
['text':' ecx. x86 can't shift a non-ecx register.','line_number':50,'multiline':False]
['text':' Shift operand should be constant or, unless BMI2 is available, in register','line_number':82,'multiline':False]
['text':' ecx. x86 can't shift a non-ecx register.','line_number':83,'multiline':False]
['text':' The operands are int64, but we only care about the lower 32 bits of','line_number':91,'multiline':False]
['text':' the RHS. On 32-bit, the code below will load that part in ecx and','line_number':92,'multiline':False]
['text':' will discard the upper half.','line_number':93,'multiline':False]
['text':' Without AVX, we'll need to use the x86 encodings where one of the','line_number':139,'multiline':False]
['text':' inputs must be the same location as the output.','line_number':140,'multiline':False]
['text':' Note: If we need a negative zero check, lhs is used twice.','line_number':184,'multiline':False]
['text':' Division instructions are slow. Division by constant denominators can be','line_number':203,'multiline':False]
['text':' rewritten to use other instructions.','line_number':204,'multiline':False]
['text':' Division by powers of two can be done by shifting, and division by','line_number':208,'multiline':False]
['text':' other numbers can be done by a reciprocal multiplication technique.','line_number':209,'multiline':False]
['text':' When truncated with maybe a non-zero remainder, we have to round the','line_number':214,'multiline':False]
['text':' result toward 0. This requires an extra register to round up/down','line_number':215,'multiline':False]
['text':' whether the left-hand-side is signed.','line_number':216,'multiline':False]
['text':' Numerator is unsigned, so does not need adjusting.','line_number':219,'multiline':False]
['text':' Numerator might be signed, and needs adjusting, and an extra lhs copy','line_number':222,'multiline':False]
['text':' is needed to round the result of the integer division towards zero.','line_number':223,'multiline':False]
['text':' For simplicity, require a register if we're going to emit a bounds-check','line_number':332,'multiline':False]
['text':' branch, so that we don't have special cases for constants. This should','line_number':333,'multiline':False]
['text':' only happen in rare constant-folding cases since asm.js sets the minimum','line_number':334,'multiline':False]
['text':' heap size based when accessed via constant.','line_number':335,'multiline':False]
['text':' For simplicity, require a register if we're going to emit a bounds-check','line_number':360,'multiline':False]
['text':' branch, so that we don't have special cases for constants. This should','line_number':361,'multiline':False]
['text':' only happen in rare constant-folding cases since asm.js sets the minimum','line_number':362,'multiline':False]
['text':' heap size based when accessed via constant.','line_number':363,'multiline':False]
['text':' See comment for LIRGeneratorX86::useByteOpRegister.','line_number':380,'multiline':False]
['text':' For now, don't allow constant values. The immediate operand affects','line_number':391,'multiline':False]
['text':' instruction layout which affects patching.','line_number':392,'multiline':False]
['text':' Without BMI2, x86 can only shift by ecx.','line_number':483,'multiline':False]
['text':' Shift operand should be in register ecx, unless BMI2 is available.','line_number':502,'multiline':False]
['text':' x86 can't shift a non-ecx register.','line_number':503,'multiline':False]
['text':' Shift operand should be in register ecx, unless BMI2 is available.','line_number':512,'multiline':False]
['text':' x86 can't shift a non-ecx register.','line_number':513,'multiline':False]
['text':' Shift operand should be in register ecx, unless BMI2 is available.','line_number':523,'multiline':False]
['text':' x86 can't shift a non-ecx register.','line_number':524,'multiline':False]
['text':' If the target is a floating register then we need a temp at the','line_number':582,'multiline':False]
['text':' lower level; that temp must be eax.','line_number':583,'multiline':False]
['text':'','line_number':584,'multiline':False]
['text':' Otherwise the target (if used) is an integer register, which','line_number':585,'multiline':False]
['text':' must be eax.  If the target is not used the machine code will','line_number':586,'multiline':False]
['text':' still clobber eax, so just pretend it's used.','line_number':587,'multiline':False]
['text':'','line_number':588,'multiline':False]
['text':' oldval must be in a register.','line_number':589,'multiline':False]
['text':'','line_number':590,'multiline':False]
['text':' newval must be in a register.  If the source is a byte array','line_number':591,'multiline':False]
['text':' then newval must be a register that has a byte size: on x86','line_number':592,'multiline':False]
['text':' this must be ebx, ecx, or edx (eax is taken for the output).','line_number':593,'multiline':False]
['text':'','line_number':594,'multiline':False]
['text':' Bug #1077036 describes some further optimization opportunities.','line_number':595,'multiline':False]
['text':' The underlying instruction is XCHG, which can operate on any','line_number':637,'multiline':False]
['text':' register.','line_number':638,'multiline':False]
['text':'','line_number':639,'multiline':False]
['text':' If the target is a floating register (for Uint32) then we need','line_number':640,'multiline':False]
['text':' a temp into which to exchange.','line_number':641,'multiline':False]
['text':'','line_number':642,'multiline':False]
['text':' If the source is a byte array then we need a register that has','line_number':643,'multiline':False]
['text':' a byte size; in this case -- on x86 only -- pin the output to','line_number':644,'multiline':False]
['text':' an appropriate register and use that as a temp in the back-end.','line_number':645,'multiline':False]
['text':' Case 1: the result of the operation is not used.','line_number':676,'multiline':False]
['text':'','line_number':677,'multiline':False]
['text':' We'll emit a single instruction: LOCK ADD, LOCK SUB, LOCK AND,','line_number':678,'multiline':False]
['text':' LOCK OR, or LOCK XOR.  We can do this even for the Uint32 case.','line_number':679,'multiline':False]
['text':' Case 2: the result of the operation is used.','line_number':697,'multiline':False]
['text':'','line_number':698,'multiline':False]
['text':' For ADD and SUB we'll use XADD:','line_number':699,'multiline':False]
['text':'','line_number':700,'multiline':False]
['text':'    movl       src, output','line_number':701,'multiline':False]
['text':'    lock xaddl output, mem','line_number':702,'multiline':False]
['text':'','line_number':703,'multiline':False]
['text':' For the 8-bit variants XADD needs a byte register for the output.','line_number':704,'multiline':False]
['text':'','line_number':705,'multiline':False]
['text':' For AND/OR/XOR we need to use a CMPXCHG loop:','line_number':706,'multiline':False]
['text':'','line_number':707,'multiline':False]
['text':'    movl          *mem, eax','line_number':708,'multiline':False]
['text':' L: mov           eax, temp','line_number':709,'multiline':False]
['text':'    andl          src, temp','line_number':710,'multiline':False]
['text':'    lock cmpxchg  temp, mem  ; reads eax also','line_number':711,'multiline':False]
['text':'    jnz           L','line_number':712,'multiline':False]
['text':'    ; result in eax','line_number':713,'multiline':False]
['text':'','line_number':714,'multiline':False]
['text':' Note the placement of L, cmpxchg will update eax with *mem if','line_number':715,'multiline':False]
['text':' *mem does not have the expected value, so reloading it at the','line_number':716,'multiline':False]
['text':' top of the loop would be redundant.','line_number':717,'multiline':False]
['text':'','line_number':718,'multiline':False]
['text':' If the array is not a uint32 array then:','line_number':719,'multiline':False]
['text':'  - eax should be the output (one result of the cmpxchg)','line_number':720,'multiline':False]
['text':'  - there is a temp, which must have a byte register if','line_number':721,'multiline':False]
['text':'    the array has 1-byte elements elements','line_number':722,'multiline':False]
['text':'','line_number':723,'multiline':False]
['text':' If the array is a uint32 array then:','line_number':724,'multiline':False]
['text':'  - eax is the first temp','line_number':725,'multiline':False]
['text':'  - we also need a second temp','line_number':726,'multiline':False]
['text':'','line_number':727,'multiline':False]
['text':' There are optimization opportunities:','line_number':728,'multiline':False]
['text':'  - better register allocation in the x86 8-bit case, Bug #1077036.','line_number':729,'multiline':False]
['text':' As lowerForFPU, but we want rhs to be in a FP register too.','line_number':796,'multiline':False]
['text':' These lowerings are really x86-shared but some Masm APIs are not yet','line_number':809,'multiline':False]
['text':' available on x86.','line_number':810,'multiline':False]
['text':' Ternary and binary operators require the dest register to be the same as','line_number':812,'multiline':False]
['text':' their first input register, leading to a pattern of useRegisterAtStart +','line_number':813,'multiline':False]
['text':' defineReuseInput.','line_number':814,'multiline':False]
['text':' Enforcing lhs == output avoids one setup move.  We would like to also','line_number':823,'multiline':False]
['text':' enforce merging the control with the temp (with usRegisterAtStart(control)','line_number':824,'multiline':False]
['text':' and tempCopy()), but the register allocator ignores those constraints','line_number':825,'multiline':False]
['text':' at present.','line_number':826,'multiline':False]
['text':' Note MWasmBinarySimd128::foldsTo has already specialized operations that','line_number':847,'multiline':False]
['text':' have a constant operand, so this takes care of more general cases of','line_number':848,'multiline':False]
['text':' reordering, see ReorderCommutative.','line_number':849,'multiline':False]
['text':' Swap operands and change operation if necessary, these are all x86/x64','line_number':854,'multiline':False]
['text':' dependent transformations.  Except where noted, this is about avoiding','line_number':855,'multiline':False]
['text':' unnecessary moves and fixups in the code generator macros.','line_number':856,'multiline':False]
['text':' Code generation requires the operands to be reversed.','line_number':860,'multiline':False]
['text':' Code generation requires the operations to be reversed (the rhs is the','line_number':918,'multiline':False]
['text':' output register).','line_number':919,'multiline':False]
['text':' Allocate temp registers','line_number':932,'multiline':False]
['text':' For binary ops, the Masm API always is usually (rhs, lhsDest) and requires','line_number':954,'multiline':False]
['text':' AtStart+ReuseInput for the lhs.','line_number':955,'multiline':False]
['text':'','line_number':956,'multiline':False]
['text':' For a few ops, the API is actually (rhsDest, lhs) and the rules are the','line_number':957,'multiline':False]
['text':' same but the reversed.  We swapped operands above; they will be swapped','line_number':958,'multiline':False]
['text':' again in the code generator to emit the right code.','line_number':959,'multiline':False]
['text':' Optimization when control vector is a mask with all 0 or all 1 per lane.','line_number':976,'multiline':False]
['text':' On x86, there is no bitselect, blend operations will be a win,','line_number':977,'multiline':False]
['text':' e.g. via PBLENDVB or PBLENDW.','line_number':978,'multiline':False]
['text':' The order follows MacroAssembler.h, generally','line_number':996,'multiline':False]
['text':' Operations implemented by a single native instruction where it is','line_number':998,'multiline':False]
['text':' plausible that the rhs (after commutation if available) could be a','line_number':999,'multiline':False]
['text':' constant.','line_number':1000,'multiline':False]
['text':'','line_number':1001,'multiline':False]
['text':' Swizzle is not here because it was handled earlier in the pipeline.','line_number':1002,'multiline':False]
['text':'','line_number':1003,'multiline':False]
['text':' Integer compares >= and < are not here because they are not supported in','line_number':1004,'multiline':False]
['text':' the hardware.','line_number':1005,'multiline':False]
['text':'','line_number':1006,'multiline':False]
['text':' Floating compares are not here because our patching machinery can't','line_number':1007,'multiline':False]
['text':' handle them yet.','line_number':1008,'multiline':False]
['text':'','line_number':1009,'multiline':False]
['text':' Floating-point min and max (including pmin and pmax) are not here because','line_number':1010,'multiline':False]
['text':' they are not straightforward to implement.','line_number':1011,'multiline':False]
['text':' Always beneficial to reuse the lhs register here, see discussion in','line_number':1092,'multiline':False]
['text':' visitWasmBinarySimd128() and also code in specializeForConstantRhs().','line_number':1093,'multiline':False]
['text':' Check if possible to apply sign replication optimization.','line_number':1142,'multiline':False]
['text':' For some ops the input shall be reused.','line_number':1143,'multiline':False]
['text':' Almost always beneficial, and never detrimental, to reuse the input if','line_number':1167,'multiline':False]
['text':' possible.','line_number':1168,'multiline':False]
['text':' Reusing the input if possible is never detrimental.','line_number':1194,'multiline':False]
['text':' All permute operators currently favor reusing the input register so','line_number':1219,'multiline':False]
['text':' we're not currently exercising code paths below that do not reuse.','line_number':1220,'multiline':False]
['text':' Those paths have been exercised in the past however and are believed','line_number':1221,'multiline':False]
['text':' to be correct.','line_number':1222,'multiline':False]
['text':' The Masm API is (rhs, lhsDest) and requires AtStart+ReuseInput for the lhs.','line_number':1296,'multiline':False]
['text':' For type reasons, the rhs will never be the same as the lhs and is','line_number':1297,'multiline':False]
['text':' therefore a plain Use.','line_number':1298,'multiline':False]
['text':' 64-bit integer splats.','line_number':1320,'multiline':False]
['text':' Load-and-(sign|zero)extend.','line_number':1321,'multiline':False]
['text':' Floating-point splats.','line_number':1329,'multiline':False]
['text':' Ideally we save a move on SSE systems by reusing the input register,','line_number':1330,'multiline':False]
['text':' but since the input and output register types differ, we can't.','line_number':1331,'multiline':False]
['text':' 32-bit integer splats.','line_number':1338,'multiline':False]
['text':' Prefer src != dest to avoid an unconditional src->temp move.','line_number':1363,'multiline':False]
['text':' Prefer src == dest to avoid an unconditional src->dest move.','line_number':1383,'multiline':False]
['text':' Prefer src == dest to avoid an unconditional src->dest move.','line_number':1392,'multiline':False]
['text':' Prefer src == dest to exert the lowest register pressure on the','line_number':1421,'multiline':False]
['text':' surrounding code.','line_number':1422,'multiline':False]
['text':' Only specific ops generating int32.','line_number':1494,'multiline':False]
['text':' If never used then defer (it will be removed).','line_number':1501,'multiline':False]
['text':' We require an MTest consumer.','line_number':1506,'multiline':False]
['text':' Defer only if there's only one use.','line_number':1511,'multiline':False]
['text':' ENABLE_WASM_SIMD','line_number':1516,'multiline':False]
['text':' Reductions (any_true, all_true, bitmask, extract_lane) uniformly prefer','line_number':1525,'multiline':False]
['text':' useRegisterAtStart:','line_number':1526,'multiline':False]
['text':'','line_number':1527,'multiline':False]
['text':' - In most cases, the input type differs from the output type, so there's no','line_number':1528,'multiline':False]
['text':'   conflict and it doesn't really matter.','line_number':1529,'multiline':False]
['text':'','line_number':1530,'multiline':False]
['text':' - For extract_lane(0) on F32x4 and F64x2, input == output results in zero','line_number':1531,'multiline':False]
['text':'   code being generated.','line_number':1532,'multiline':False]
['text':'','line_number':1533,'multiline':False]
['text':' - For extract_lane(k > 0) on F32x4 and F64x2, allowing the input register','line_number':1534,'multiline':False]
['text':'   to be targeted lowers register pressure if it's the last use of the','line_number':1535,'multiline':False]
['text':'   input.','line_number':1536,'multiline':False]
['text':' Ideally we would reuse the input register for floating extract_lane if','line_number':1543,'multiline':False]
['text':' the lane is zero, but constraints in the register allocator require the','line_number':1544,'multiline':False]
['text':' input and output register types to be the same.','line_number':1545,'multiline':False]
