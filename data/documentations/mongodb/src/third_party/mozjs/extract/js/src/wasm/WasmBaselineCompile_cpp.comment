['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 *
 * Copyright 2016 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ','line_number':1,'multiline':True]
['text':'
 * [SMDOC] WebAssembly baseline compiler (RabaldrMonkey)
 *
 * General assumptions for 32-bit vs 64-bit code:
 *
 * - A 32-bit register can be extended in-place to a 64-bit register on 64-bit
 *   systems.
 *
 * - Code that knows that Register64 has a '.reg' member on 64-bit systems and
 *   '.high' and '.low' members on 32-bit systems, or knows the implications
 *   thereof, is #ifdef JS_PUNBOX64.  All other code is #if(n)?def JS_64BIT.
 *
 *
 * Coding standards:
 *
 * - In "small" code generating functions (eg emitMultiplyF64, emitQuotientI32,
 *   and surrounding functions; most functions fall into this class) where the
 *   meaning is obvious:
 *
 *   Old school:
 *   - if there is a single source + destination register, it is called 'r'
 *   - if there is one source and a different destination, they are called 'rs'
 *     and 'rd'
 *   - if there is one source + destination register and another source register
 *     they are called 'r' and 'rs'
 *   - if there are two source registers and a destination register they are
 *     called 'rs0', 'rs1', and 'rd'.
 *
 *   The new thing:
 *   - what is called 'r' in the old-school naming scheme is increasingly called
 *     'rsd' in source+dest cases.
 *
 * - Generic temp registers are named /temp[0-9]?/ not /tmp[0-9]?/.
 *
 * - Registers can be named non-generically for their function ('rp' for the
 *   'pointer' register and 'rv' for the 'value' register are typical) and those
 *   names may or may not have an 'r' prefix.
 *
 * - "Larger" code generating functions make their own rules.
 *
 *
 * General status notes:
 *
 * "FIXME" indicates a known or suspected bug.  Always has a bug#.
 *
 * "TODO" indicates an opportunity for a general improvement, with an additional
 * tag to indicate the area of improvement.  Usually has a bug#.
 *
 * There are lots of machine dependencies here but they are pretty well isolated
 * to a segment of the compiler.  Many dependencies will eventually be factored
 * into the MacroAssembler layer and shared with other code generators.
 *
 *
 * High-value compiler performance improvements:
 *
 * - (Bug 1316802) The specific-register allocator (the needI32(r), needI64(r)
 *   etc methods) can avoid syncing the value stack if the specific register is
 *   in use but there is a free register to shuffle the specific register into.
 *   (This will also improve the generated code.)  The sync happens often enough
 *   here to show up in profiles, because it is triggered by integer multiply
 *   and divide.
 *
 *
 * High-value code generation improvements:
 *
 * - (Bug 1316804) brTable pessimizes by always dispatching to code that pops
 *   the stack and then jumps to the code for the target case.  If no cleanup is
 *   needed we could just branch conditionally to the target; if the same amount
 *   of cleanup is needed for all cases then the cleanup can be done before the
 *   dispatch.  Both are highly likely.
 *
 * - (Bug 1316806) Register management around calls: At the moment we sync the
 *   value stack unconditionally (this is simple) but there are probably many
 *   common cases where we could instead save/restore live caller-saves
 *   registers and perform parallel assignment into argument registers.  This
 *   may be important if we keep some locals in registers.
 *
 * - (Bug 1316808) Allocate some locals to registers on machines where there are
 *   enough registers.  This is probably hard to do well in a one-pass compiler
 *   but it might be that just keeping register arguments and the first few
 *   locals in registers is a viable strategy; another (more general) strategy
 *   is caching locals in registers in straight-line code.  Such caching could
 *   also track constant values in registers, if that is deemed valuable.  A
 *   combination of techniques may be desirable: parameters and the first few
 *   locals could be cached on entry to the function but not statically assigned
 *   to registers throughout.
 *
 *   (On a large corpus of code it should be possible to compute, for every
 *   signature comprising the types of parameters and locals, and using a static
 *   weight for loops, a list in priority order of which parameters and locals
 *   that should be assigned to registers.  Or something like that.  Wasm makes
 *   this simple.  Static assignments are desirable because they are not flushed
 *   to memory by the pre-block sync() call.)
 ','line_number':19,'multiline':True]
['text':' js::Scalar::Type','line_number':146,'multiline':False]
['text':' Two flags, useABI and interModule, control how calls are made.','line_number':179,'multiline':False]
['text':'','line_number':180,'multiline':False]
['text':' UseABI::Wasm implies that the Tls/Heap/Global registers are nonvolatile,','line_number':181,'multiline':False]
['text':' except when InterModule::True is also set, when they are volatile.','line_number':182,'multiline':False]
['text':'','line_number':183,'multiline':False]
['text':' UseABI::Builtin implies that the Tls/Heap/Global registers are volatile.','line_number':184,'multiline':False]
['text':' In this case, we require InterModule::False.  The calling convention','line_number':185,'multiline':False]
['text':' is otherwise like UseABI::Wasm.','line_number':186,'multiline':False]
['text':'','line_number':187,'multiline':False]
['text':' UseABI::System implies that the Tls/Heap/Global registers are volatile.','line_number':188,'multiline':False]
['text':' Additionally, the parameter passing mechanism may be slightly different from','line_number':189,'multiline':False]
['text':' the UseABI::Wasm convention.','line_number':190,'multiline':False]
['text':'','line_number':191,'multiline':False]
['text':' When the Tls/Heap/Global registers are not volatile, the baseline compiler','line_number':192,'multiline':False]
['text':' will restore the Tls register from its save slot before the call, since the','line_number':193,'multiline':False]
['text':' baseline compiler uses the Tls register for other things.','line_number':194,'multiline':False]
['text':'','line_number':195,'multiline':False]
['text':' When those registers are volatile, the baseline compiler will reload them','line_number':196,'multiline':False]
['text':' after the call (it will restore the Tls register from the save slot and load','line_number':197,'multiline':False]
['text':' the other two from the Tls data).','line_number':198,'multiline':False]
['text':' Note, the float scratch regs cannot be registers that are used for parameter','line_number':224,'multiline':False]
['text':' passing in any ABI we use.  Argregs tend to be low-numbered; register 30','line_number':225,'multiline':False]
['text':' should be safe.','line_number':226,'multiline':False]
['text':' The selection of EBX here steps gingerly around: the need for EDX','line_number':245,'multiline':False]
['text':' to be allocatable for multiply/divide; ECX to be allocatable for','line_number':246,'multiline':False]
['text':' shift/rotate; EAX (= ReturnReg) to be allocatable as the result','line_number':247,'multiline':False]
['text':' register; EBX not being one of the WasmTableCall registers; and','line_number':248,'multiline':False]
['text':' needing a temp register for load/store that has a single-byte','line_number':249,'multiline':False]
['text':' persona.','line_number':250,'multiline':False]
['text':'','line_number':251,'multiline':False]
['text':' The compiler assumes that RabaldrScratchI32 has a single-byte','line_number':252,'multiline':False]
['text':' persona.  Code for 8-byte atomic operations assumes that','line_number':253,'multiline':False]
['text':' RabaldrScratchI32 is in fact ebx.','line_number':254,'multiline':False]
['text':' We use our own scratch register, because the macro assembler uses','line_number':263,'multiline':False]
['text':' the regular scratch register(s) pretty liberally.  We could','line_number':264,'multiline':False]
['text':' work around that in several cases but the mess does not seem','line_number':265,'multiline':False]
['text':' worth it yet.  CallTempReg2 seems safe.','line_number':266,'multiline':False]
['text':' The strongly typed register wrappers are especially useful to distinguish','line_number':323,'multiline':False]
['text':' float registers from double registers, but they also clearly distinguish','line_number':324,'multiline':False]
['text':' 32-bit registers from 64-bit register pairs on 32-bit systems.','line_number':325,'multiline':False]
['text':' RegRef is for GC-pointers, for non GC-pointers use RegPtr','line_number':347,'multiline':False]
['text':' RegPtr is for non GC-pointers, for GC-pointers use RegRef','line_number':358,'multiline':False]
['text':' The compiler is written so that this is never needed: any() is','line_number':491,'multiline':False]
['text':' called on arbitrary registers for asm.js but asm.js does not have','line_number':492,'multiline':False]
['text':' 64-bit ints.  For wasm, any() is called on arbitrary registers','line_number':493,'multiline':False]
['text':' only on 64-bit platforms.','line_number':494,'multiline':False]
['text':' Work around GCC 5 analysis/warning bug.','line_number':502,'multiline':False]
['text':' Platform-specific registers.','line_number':507,'multiline':False]
['text':'','line_number':508,'multiline':False]
['text':' All platforms must define struct SpecificRegs.  All 32-bit platforms must','line_number':509,'multiline':False]
['text':' have an abiReturnRegI64 member in that struct.','line_number':510,'multiline':False]
['text':' Spill all spillable registers.','line_number':570,'multiline':False]
['text':'','line_number':571,'multiline':False]
['text':' TODO / OPTIMIZE (Bug 1316802): It's possible to do better here by','line_number':572,'multiline':False]
['text':' spilling only enough registers to satisfy current needs.','line_number':573,'multiline':False]
['text':' Register allocator.','line_number':579,'multiline':False]
['text':' Notes on float register allocation.','line_number':582,'multiline':False]
['text':'','line_number':583,'multiline':False]
['text':' The general rule in SpiderMonkey is that float registers can alias double','line_number':584,'multiline':False]
['text':' registers, but there are predicates to handle exceptions to that rule:','line_number':585,'multiline':False]
['text':' hasUnaliasedDouble() and hasMultiAlias().  The way aliasing actually','line_number':586,'multiline':False]
['text':' works is platform dependent and exposed through the aliased(n, &r)','line_number':587,'multiline':False]
['text':' predicate, etc.','line_number':588,'multiline':False]
['text':'','line_number':589,'multiline':False]
['text':'  - hasUnaliasedDouble(): on ARM VFPv3-D32 there are double registers that','line_number':590,'multiline':False]
['text':'    cannot be treated as float.','line_number':591,'multiline':False]
['text':'  - hasMultiAlias(): on ARM and MIPS a double register aliases two float','line_number':592,'multiline':False]
['text':'    registers.','line_number':593,'multiline':False]
['text':'','line_number':594,'multiline':False]
['text':' On some platforms (x86, x64, ARM64) but not all (ARM)','line_number':595,'multiline':False]
['text':' ScratchFloat32Register is the same as ScratchDoubleRegister.','line_number':596,'multiline':False]
['text':'','line_number':597,'multiline':False]
['text':' It's a basic invariant of the AllocatableRegisterSet that it deals','line_number':598,'multiline':False]
['text':' properly with aliasing of registers: if s0 or s1 are allocated then d0 is','line_number':599,'multiline':False]
['text':' not allocatable; if s0 and s1 are freed individually then d0 becomes','line_number':600,'multiline':False]
['text':' allocatable.','line_number':601,'multiline':False]
['text':' The registers available after removing ScratchReg, HeapReg, etc.','line_number':607,'multiline':False]
['text':' r12 is normally the ScratchRegister and r13 is always the stack pointer,','line_number':672,'multiline':False]
['text':' so the highest possible pair has r10 as the even-numbered register.','line_number':673,'multiline':False]
['text':' Allocate any private scratch registers.','line_number':742,'multiline':False]
['text':' TODO / OPTIMIZE (Bug 1316802): Do not sync everything on allocation','line_number':822,'multiline':False]
['text':' failure, only as much as we need.','line_number':823,'multiline':False]
['text':' Use when you need a register for a short time but explicitly want to avoid','line_number':881,'multiline':False]
['text':' a full sync().','line_number':882,'multiline':False]
['text':' Scratch register abstractions.','line_number':1018,'multiline':False]
['text':'','line_number':1019,'multiline':False]
['text':' We define our own scratch registers when the platform doesn't provide what we','line_number':1020,'multiline':False]
['text':' need.  A notable use case is that we will need a private scratch register','line_number':1021,'multiline':False]
['text':' when the platform masm uses its scratch register very frequently (eg, ARM).','line_number':1022,'multiline':False]
['text':' ScratchEBX is a mnemonic device: For some atomic ops we really need EBX,','line_number':1115,'multiline':False]
['text':' no other register will do.  And we would normally have to allocate that','line_number':1116,'multiline':False]
['text':' register using ScratchI32 since normally the scratch register is EBX.','line_number':1117,'multiline':False]
['text':' But the whole point of ScratchI32 is to hide that relationship.  By using','line_number':1118,'multiline':False]
['text':' the ScratchEBX alias, we document that at that point we require the','line_number':1119,'multiline':False]
['text':' scratch register to be EBX.','line_number':1120,'multiline':False]
['text':' ScratchI8 is a mnemonic device: For some ops we need a register with a','line_number':1123,'multiline':False]
['text':' byte subregister.','line_number':1124,'multiline':False]
['text':' The stack frame.','line_number':1128,'multiline':False]
['text':'','line_number':1129,'multiline':False]
['text':' The stack frame has four parts ("below" means at lower addresses):','line_number':1130,'multiline':False]
['text':'','line_number':1131,'multiline':False]
['text':'  - the Frame element;','line_number':1132,'multiline':False]
['text':'  - the Local area, including the DebugFrame element and possibly a spilled','line_number':1133,'multiline':False]
['text':'    pointer to stack results, if any; allocated below the header with various','line_number':1134,'multiline':False]
['text':'    forms of alignment;','line_number':1135,'multiline':False]
['text':'  - the Dynamic area, comprising the temporary storage the compiler uses for','line_number':1136,'multiline':False]
['text':'    register spilling, allocated below the Local area;','line_number':1137,'multiline':False]
['text':'  - the Arguments area, comprising memory allocated for outgoing calls,','line_number':1138,'multiline':False]
['text':'    allocated below the Dynamic area.','line_number':1139,'multiline':False]
['text':'','line_number':1140,'multiline':False]
['text':'                +==============================+','line_number':1141,'multiline':False]
['text':'                |    Incoming stack arg        |','line_number':1142,'multiline':False]
['text':'                |    ...                       |','line_number':1143,'multiline':False]
['text':' -------------  +==============================+','line_number':1144,'multiline':False]
['text':'                |    Frame (fixed size)        |','line_number':1145,'multiline':False]
['text':' -------------  +==============================+ <-------------------- FP','line_number':1146,'multiline':False]
['text':'         ^      |    DebugFrame (optional)     |    ^  ^             ^^','line_number':1147,'multiline':False]
['text':'   localSize    |    Register arg local        |    |  |             ||','line_number':1148,'multiline':False]
['text':'         |      |    ...                       |    |  |     framePushed','line_number':1149,'multiline':False]
['text':'         |      |    Register stack result ptr?|    |  |             ||','line_number':1150,'multiline':False]
['text':'         |      |    Non-arg local             |    |  |             ||','line_number':1151,'multiline':False]
['text':'         |      |    ...                       |    |  |             ||','line_number':1152,'multiline':False]
['text':'         |      |    (padding)                 |    |  |             ||','line_number':1153,'multiline':False]
['text':'         |      |    Tls pointer               |    |  |             ||','line_number':1154,'multiline':False]
['text':'         |      +------------------------------+    |  |             ||','line_number':1155,'multiline':False]
['text':'         v      |    (padding)                 |    |  v             ||','line_number':1156,'multiline':False]
['text':' -------------  +==============================+ currentStackHeight  ||','line_number':1157,'multiline':False]
['text':'         ^      |    Dynamic (variable size)   |    |                ||','line_number':1158,'multiline':False]
['text':'  dynamicSize   |    ...                       |    |                ||','line_number':1159,'multiline':False]
['text':'         v      |    ...                       |    v                ||','line_number':1160,'multiline':False]
['text':' -------------  |    (free space, sometimes)   | ---------           v|','line_number':1161,'multiline':False]
['text':'                +==============================+ <----- SP not-during calls','line_number':1162,'multiline':False]
['text':'                |    Arguments (sometimes)     |                      |','line_number':1163,'multiline':False]
['text':'                |    ...                       |                      v','line_number':1164,'multiline':False]
['text':'                +==============================+ <----- SP during calls','line_number':1165,'multiline':False]
['text':'','line_number':1166,'multiline':False]
['text':' The Frame is addressed off the stack pointer.  masm.framePushed() is always','line_number':1167,'multiline':False]
['text':' correct, and masm.getStackPointer() + masm.framePushed() always addresses the','line_number':1168,'multiline':False]
['text':' Frame, with the DebugFrame optionally below it.','line_number':1169,'multiline':False]
['text':'','line_number':1170,'multiline':False]
['text':' The Local area (including the DebugFrame and, if needed, the spilled value of','line_number':1171,'multiline':False]
['text':' the stack results area pointer) is laid out by BaseLocalIter and is allocated','line_number':1172,'multiline':False]
['text':' and deallocated by standard prologue and epilogue functions that manipulate','line_number':1173,'multiline':False]
['text':' the stack pointer, but it is accessed via BaseStackFrame.','line_number':1174,'multiline':False]
['text':'','line_number':1175,'multiline':False]
['text':' The Dynamic area is maintained by and accessed via BaseStackFrame.  On some','line_number':1176,'multiline':False]
['text':' systems (such as ARM64), the Dynamic memory may be allocated in chunks','line_number':1177,'multiline':False]
['text':' because the SP needs a specific alignment, and in this case there will','line_number':1178,'multiline':False]
['text':' normally be some free space directly above the SP.  The stack height does not','line_number':1179,'multiline':False]
['text':' include the free space, it reflects the logically used space only.','line_number':1180,'multiline':False]
['text':'','line_number':1181,'multiline':False]
['text':' The Dynamic area is where space for stack results is allocated when calling','line_number':1182,'multiline':False]
['text':' functions that return results on the stack.  If a function has stack results,','line_number':1183,'multiline':False]
['text':' a pointer to the low address of the stack result area is passed as an','line_number':1184,'multiline':False]
['text':' additional argument, according to the usual ABI.  See','line_number':1185,'multiline':False]
['text':' ABIResultIter::HasStackResults.','line_number':1186,'multiline':False]
['text':'','line_number':1187,'multiline':False]
['text':' The Arguments area is allocated and deallocated via BaseStackFrame (see','line_number':1188,'multiline':False]
['text':' comments later) but is accessed directly off the stack pointer.','line_number':1189,'multiline':False]
['text':' BaseLocalIter iterates over a vector of types of locals and provides offsets','line_number':1191,'multiline':False]
['text':' from the Frame address for those locals, and associated data.','line_number':1192,'multiline':False]
['text':'','line_number':1193,'multiline':False]
['text':' The implementation of BaseLocalIter is the property of the BaseStackFrame.','line_number':1194,'multiline':False]
['text':' But it is also exposed for eg the debugger to use.','line_number':1195,'multiline':False]
['text':' Locals grow down so capture base address.','line_number':1216,'multiline':False]
['text':' The pointer to stack results is handled like any other argument:','line_number':1228,'multiline':False]
['text':' either addressed in place if it is passed on the stack, or we spill','line_number':1229,'multiline':False]
['text':' it in the frame if it's in a register.','line_number':1230,'multiline':False]
['text':' Advance past the synthetic stack result pointer argument and fall','line_number':1253,'multiline':False]
['text':' through to the next case.','line_number':1254,'multiline':False]
['text':' TODO/AnyRef-boxing: With boxed immediates and strings, the','line_number':1273,'multiline':False]
['text':' debugger must be made aware that AnyRef != Pointer.','line_number':1274,'multiline':False]
['text':' Abstraction of the height of the stack frame, to avoid type confusion.','line_number':1297,'multiline':False]
['text':' Abstraction for where multi-value results go on the machine stack.','line_number':1315,'multiline':False]
['text':' Abstraction of the baseline compiler's stack frame (except for the Frame /','line_number':1342,'multiline':False]
['text':' DebugFrame parts).  See comments above for more.  Remember, "below" on the','line_number':1343,'multiline':False]
['text':' stack means at lower addresses.','line_number':1344,'multiline':False]
['text':'','line_number':1345,'multiline':False]
['text':' The abstraction is split into two parts: BaseStackFrameAllocator is','line_number':1346,'multiline':False]
['text':' responsible for allocating and deallocating space on the stack and for','line_number':1347,'multiline':False]
['text':' performing computations that are affected by how the allocation is performed;','line_number':1348,'multiline':False]
['text':' BaseStackFrame then provides a pleasant interface for stack frame management.','line_number':1349,'multiline':False]
['text':' On platforms that require the stack pointer to be aligned on a boundary','line_number':1355,'multiline':False]
['text':' greater than the typical stack item (eg, ARM64 requires 16-byte alignment','line_number':1356,'multiline':False]
['text':' but items are 8 bytes), allocate stack memory in chunks, and use a','line_number':1357,'multiline':False]
['text':' separate stack height variable to track the effective stack pointer','line_number':1358,'multiline':False]
['text':' within the allocated area.  Effectively, there's a variable amount of','line_number':1359,'multiline':False]
['text':' free space directly above the stack pointer.  See diagram above.','line_number':1360,'multiline':False]
['text':' The following must be true in order for the stack height to be','line_number':1362,'multiline':False]
['text':' predictable at control flow joins:','line_number':1363,'multiline':False]
['text':'','line_number':1364,'multiline':False]
['text':' - The Local area is always aligned according to WasmStackAlignment, ie,','line_number':1365,'multiline':False]
['text':'   masm.framePushed() % WasmStackAlignment is zero after allocating','line_number':1366,'multiline':False]
['text':'   locals.','line_number':1367,'multiline':False]
['text':'','line_number':1368,'multiline':False]
['text':' - ChunkSize is always a multiple of WasmStackAlignment.','line_number':1369,'multiline':False]
['text':'','line_number':1370,'multiline':False]
['text':' - Pushing and popping are always in units of ChunkSize (hence preserving','line_number':1371,'multiline':False]
['text':'   alignment).','line_number':1372,'multiline':False]
['text':'','line_number':1373,'multiline':False]
['text':' - The free space on the stack (masm.framePushed() - currentStackHeight_)','line_number':1374,'multiline':False]
['text':'   is a predictable (nonnegative) amount.','line_number':1375,'multiline':False]
['text':' As an optimization, we pre-allocate some space on the stack, the size of','line_number':1377,'multiline':False]
['text':' this allocation is InitialChunk and it must be a multiple of ChunkSize.','line_number':1378,'multiline':False]
['text':' It is allocated as part of the function prologue and deallocated as part','line_number':1379,'multiline':False]
['text':' of the epilogue, along with the locals.','line_number':1380,'multiline':False]
['text':'','line_number':1381,'multiline':False]
['text':' If ChunkSize is too large then we risk overflowing the stack on simple','line_number':1382,'multiline':False]
['text':' recursions with few live values where stack overflow should not be a','line_number':1383,'multiline':False]
['text':' risk; if it is too small we spend too much time adjusting the stack','line_number':1384,'multiline':False]
['text':' pointer.','line_number':1385,'multiline':False]
['text':'','line_number':1386,'multiline':False]
['text':' Good values for ChunkSize are the subject of future empirical analysis;','line_number':1387,'multiline':False]
['text':' eight words is just an educated guess.','line_number':1388,'multiline':False]
['text':' The current logical height of the frame is','line_number':1393,'multiline':False]
['text':'   currentStackHeight_ = localSize_ + dynamicSize','line_number':1394,'multiline':False]
['text':' where dynamicSize is not accounted for explicitly and localSize_ also','line_number':1395,'multiline':False]
['text':' includes size for the DebugFrame.','line_number':1396,'multiline':False]
['text':'','line_number':1397,'multiline':False]
['text':' The allocated size of the frame, provided by masm.framePushed(), is usually','line_number':1398,'multiline':False]
['text':' larger than currentStackHeight_, notably at the beginning of execution when','line_number':1399,'multiline':False]
['text':' we've allocated InitialChunk extra space.','line_number':1400,'multiline':False]
['text':' Size of the Local area in bytes (stable after BaseCompiler::init() has','line_number':1405,'multiline':False]
['text':' called BaseStackFrame::setupLocals(), which in turn calls','line_number':1406,'multiline':False]
['text':' BaseStackFrameAllocator::setLocalSize()), always rounded to the proper','line_number':1407,'multiline':False]
['text':' stack alignment.  The Local area is then allocated in beginFunction(),','line_number':1408,'multiline':False]
['text':' following the allocation of the Header.  See onFixedStackAllocated()','line_number':1409,'multiline':False]
['text':' below.','line_number':1410,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':1415,'multiline':False]
['text':'','line_number':1416,'multiline':False]
['text':' Initialization','line_number':1417,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////','line_number':1428,'multiline':False]
['text':'','line_number':1429,'multiline':False]
['text':' The Local area - the static part of the frame.','line_number':1430,'multiline':False]
['text':' Record the size of the Local area, once it is known.','line_number':1432,'multiline':False]
['text':' Record the current stack height, after it has become stable in','line_number':1441,'multiline':False]
['text':' beginFunction().  See also BaseStackFrame::onFixedStackAllocated().','line_number':1442,'multiline':False]
['text':' The fixed amount of memory, in bytes, allocated on the stack below the','line_number':1452,'multiline':False]
['text':' Header for purposes such as locals and other fixed values.  Includes all','line_number':1453,'multiline':False]
['text':' necessary alignment, and on ARM64 also the initial chunk for the working','line_number':1454,'multiline':False]
['text':' stack memory.','line_number':1455,'multiline':False]
['text':' The allocated frame size is frequently larger than the logical stack','line_number':1467,'multiline':False]
['text':' height; we round up to a chunk boundary, and special case the initial','line_number':1468,'multiline':False]
['text':' chunk.','line_number':1469,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////','line_number':1480,'multiline':False]
['text':'','line_number':1481,'multiline':False]
['text':' The Dynamic area - the dynamic part of the frame, for spilling and saving','line_number':1482,'multiline':False]
['text':' intermediate values.','line_number':1483,'multiline':False]
['text':' Offset off of sp_ for the slot at stack area location `offset`.','line_number':1485,'multiline':False]
['text':' Sometimes, popChunkyBytes() is used to pop a larger area, as when we drop','line_number':1515,'multiline':False]
['text':' values consumed by a call, and we may need to drop several chunks.  But','line_number':1516,'multiline':False]
['text':' never drop the initial chunk.  Crucially, the amount we drop is always an','line_number':1517,'multiline':False]
['text':' integral number of chunks.','line_number':1518,'multiline':False]
['text':' For a given stack height, return the appropriate size of the allocated','line_number':1551,'multiline':False]
['text':' frame.','line_number':1552,'multiline':False]
['text':' A more complicated adjustment is needed.','line_number':1556,'multiline':False]
['text':' The allocated frame size equals the stack height.','line_number':1559,'multiline':False]
['text':' The current height of the stack area, not necessarily zero-based, in a','line_number':1565,'multiline':False]
['text':' type-safe way.','line_number':1566,'multiline':False]
['text':' Set the frame height to a previously recorded value.','line_number':1570,'multiline':False]
['text':' The current height of the dynamic part of the stack area (ie, the backing','line_number':1582,'multiline':False]
['text':' store for the evaluation stack), zero-based.','line_number':1583,'multiline':False]
['text':' Before branching to an outer control label, pop the execution stack to','line_number':1587,'multiline':False]
['text':' the level expected by that region, but do not update masm.framePushed()','line_number':1588,'multiline':False]
['text':' as that will happen as compilation leaves the block.','line_number':1589,'multiline':False]
['text':'','line_number':1590,'multiline':False]
['text':' Note these operate directly on the stack pointer register.','line_number':1591,'multiline':False]
['text':' Given that there are |stackParamSize| bytes on the dynamic stack','line_number':1609,'multiline':False]
['text':' corresponding to the stack results, return the stack height once these','line_number':1610,'multiline':False]
['text':' parameters are popped.','line_number':1611,'multiline':False]
['text':' For most of WebAssembly, adjacent instructions have fallthrough control','line_number':1617,'multiline':False]
['text':' flow between them, which allows us to simply thread the current stack','line_number':1618,'multiline':False]
['text':' height through the compiler.  There are two exceptions to this rule: when','line_number':1619,'multiline':False]
['text':' leaving a block via dead code, and when entering the "else" arm of an "if".','line_number':1620,'multiline':False]
['text':' In these cases, the stack height is the block entry height, plus any stack','line_number':1621,'multiline':False]
['text':' values (results in the block exit case, parameters in the else entry case).','line_number':1622,'multiline':False]
['text':' Return offset of stack result.','line_number':1630,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////','line_number':1641,'multiline':False]
['text':'','line_number':1642,'multiline':False]
['text':' The Argument area - for outgoing calls.','line_number':1643,'multiline':False]
['text':'','line_number':1644,'multiline':False]
['text':' We abstract these operations as an optimization: we can merge the freeing','line_number':1645,'multiline':False]
['text':' of the argument area and dropping values off the stack after a call.  But','line_number':1646,'multiline':False]
['text':' they always amount to manipulating the real stack pointer by some amount.','line_number':1647,'multiline':False]
['text':'','line_number':1648,'multiline':False]
['text':' Note that we do not update currentStackHeight_ for this; the frame does','line_number':1649,'multiline':False]
['text':' not know about outgoing arguments.  But we do update framePushed(), so we','line_number':1650,'multiline':False]
['text':' can still index into the frame below the outgoing arguments area.','line_number':1651,'multiline':False]
['text':' This is always equivalent to a masm.reserveStack() call.','line_number':1653,'multiline':False]
['text':' This frees the argument area allocated by allocArgArea(), and `argSize`','line_number':1661,'multiline':False]
['text':' must be equal to the `argSize` argument to allocArgArea().  In addition','line_number':1662,'multiline':False]
['text':' we drop some values from the frame, corresponding to the values that were','line_number':1663,'multiline':False]
['text':' consumed by the call.','line_number':1664,'multiline':False]
['text':' Freeing the outgoing arguments and freeing the consumed values have','line_number':1668,'multiline':False]
['text':' different semantics here, which is why the operation is split.','line_number':1669,'multiline':False]
['text':' The largest observed value of masm.framePushed(), ie, the size of the','line_number':1685,'multiline':False]
['text':' stack frame.  Read this for its true value only when code generation is','line_number':1686,'multiline':False]
['text':' finished.','line_number':1687,'multiline':False]
['text':' Patch point where we check for stack overflow.','line_number':1690,'multiline':False]
['text':' Low byte offset of pointer to stack results, if any.','line_number':1693,'multiline':False]
['text':' The offset of TLS pointer.','line_number':1696,'multiline':False]
['text':' Low byte offset of local area for true locals (not parameters).','line_number':1699,'multiline':False]
['text':' High byte offset + 1 of local area for true locals.','line_number':1702,'multiline':False]
['text':' The stack pointer, cached for brevity.','line_number':1705,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':1719,'multiline':False]
['text':'','line_number':1720,'multiline':False]
['text':' Stack management and overflow checking','line_number':1721,'multiline':False]
['text':' This must be called once beginFunction has allocated space for the Header','line_number':1723,'multiline':False]
['text':' (the Frame and DebugFrame) and the Local area, and will record the current','line_number':1724,'multiline':False]
['text':' frame size for internal use by the stack abstractions.','line_number':1725,'multiline':False]
['text':' We won't know until after we've generated code how big the frame will be','line_number':1732,'multiline':False]
['text':' (we may need arbitrary spill slots and outgoing param slots) so emit a','line_number':1733,'multiline':False]
['text':' patchable add that is patched in endFunction().','line_number':1734,'multiline':False]
['text':'','line_number':1735,'multiline':False]
['text':' Note the platform scratch register may be used by branchPtr(), so','line_number':1736,'multiline':False]
['text':' generally tmp must be something else.','line_number':1737,'multiline':False]
['text':' Very large frames are implausible, probably an attack.','line_number':1754,'multiline':False]
['text':' 512KiB should be enough, considering how Rabaldr uses the stack and','line_number':1757,'multiline':False]
['text':' what the standard limits are:','line_number':1758,'multiline':False]
['text':'','line_number':1759,'multiline':False]
['text':' - 1,000 parameters','line_number':1760,'multiline':False]
['text':' - 50,000 locals','line_number':1761,'multiline':False]
['text':' - 10,000 values on the eval stack (not an official limit)','line_number':1762,'multiline':False]
['text':'','line_number':1763,'multiline':False]
['text':' At sizeof(int64) bytes per slot this works out to about 480KiB.','line_number':1764,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':1768,'multiline':False]
['text':'','line_number':1769,'multiline':False]
['text':' Local area','line_number':1770,'multiline':False]
['text':' Type of the value.','line_number':1773,'multiline':False]
['text':' Byte offset from Frame "into" the locals, ie positive for true locals','line_number':1776,'multiline':False]
['text':' and negative for incoming args that read directly from the arg area.','line_number':1777,'multiline':False]
['text':' It assumes the stack is growing down and that locals are on the stack','line_number':1778,'multiline':False]
['text':' at lower addresses than Frame, and is the offset from Frame of the','line_number':1779,'multiline':False]
['text':' lowest-addressed byte of the local.','line_number':1780,'multiline':False]
['text':' Profiling shows that the number of parameters and locals frequently','line_number':1788,'multiline':False]
['text':' touches or exceeds 8.  So 16 seems like a reasonable starting point.','line_number':1789,'multiline':False]
['text':' Initialize `localInfo` based on the types of `locals` and `args`.','line_number':1792,'multiline':False]
['text':' Reserve an additional stack slot for the TLS pointer.','line_number':1818,'multiline':False]
['text':' Offset off of sp_ for `local`.','line_number':1904,'multiline':False]
['text':' Offset off of frame pointer for `stack argument`.','line_number':1910,'multiline':False]
['text':' The incoming stack result area pointer is for stack results of the function','line_number':1916,'multiline':False]
['text':' being compiled.','line_number':1917,'multiline':False]
['text':' If we get here, that means the pointer to the stack results area was','line_number':1926,'multiline':False]
['text':' passed in as a register, and therefore it will be spilled below the','line_number':1927,'multiline':False]
['text':' frame, so the offset is a positive height.','line_number':1928,'multiline':False]
['text':' An outgoing stack result area pointer is for stack results of callees of','line_number':1944,'multiline':False]
['text':' the function being compiled.','line_number':1945,'multiline':False]
['text':' Offset off of sp_ for a local with offset `offset` from Frame.','line_number':1957,'multiline':False]
['text':'/////////////////////////////////////////////////////////////////////////','line_number':1961,'multiline':False]
['text':'','line_number':1962,'multiline':False]
['text':' Dynamic area','line_number':1963,'multiline':False]
['text':' Pushes the register `r` to the stack. This pushes the full 64-bit width on','line_number':1973,'multiline':False]
['text':' 64-bit systems, and 32-bits otherwise.','line_number':1974,'multiline':False]
['text':' Pops the stack into the register `r`. This pops the full 64-bit width on','line_number':2030,'multiline':False]
['text':' 64-bit systems, and 32-bits otherwise.','line_number':2031,'multiline':False]
['text':' |srcHeight| and |destHeight| are stack heights *including* |bytes|.','line_number':2146,'multiline':False]
['text':' Unlike the overload that operates on raw heights, |srcHeight| and','line_number':2169,'multiline':False]
['text':' |destHeight| are stack heights *not including* |bytes|.','line_number':2170,'multiline':False]
['text':' |srcHeight| and |destHeight| are stack heights *including* |bytes|.','line_number':2183,'multiline':False]
['text':' Copy results from the top of the current stack frame to an area of memory,','line_number':2204,'multiline':False]
['text':' and pop the stack accordingly.  `dest` is the address of the low byte of','line_number':2205,'multiline':False]
['text':' that memory.','line_number':2206,'multiline':False]
['text':' Do not store 4 bytes if StackSizeOfFloat == 8.  It's probably OK to do','line_number':2272,'multiline':False]
['text':' so, but it costs little to store something predictable.','line_number':2273,'multiline':False]
['text':' The adjustments to 'low' by the size of the item being stored compensates','line_number':2315,'multiline':False]
['text':' for the fact that locals offsets are the offsets from Frame to the bytes','line_number':2316,'multiline':False]
['text':' directly "above" the locals in the locals area.  See comment at Local.','line_number':2317,'multiline':False]
['text':' On 64-bit systems we may have 32-bit alignment for the local area as it','line_number':2319,'multiline':False]
['text':' may be preceded by parameters and prologue/debug data.','line_number':2320,'multiline':False]
['text':' An UNROLL_LIMIT of 16 is chosen so that we only need an 8-bit signed','line_number':2331,'multiline':False]
['text':' immediate to represent the offset in the store instructions in the loop','line_number':2332,'multiline':False]
['text':' on x64.','line_number':2333,'multiline':False]
['text':' With only one word to initialize, just store an immediate zero.','line_number':2340,'multiline':False]
['text':' For other cases, it's best to have a zero in a register.','line_number':2347,'multiline':False]
['text':'','line_number':2348,'multiline':False]
['text':' One can do more here with SIMD registers (store 16 bytes at a time) or','line_number':2349,'multiline':False]
['text':' with instructions like STRD on ARM (store 8 bytes at a time), but that's','line_number':2350,'multiline':False]
['text':' for another day.','line_number':2351,'multiline':False]
['text':' For the general case we want to have a loop body of UNROLL_LIMIT stores','line_number':2356,'multiline':False]
['text':' and then a tail of less than UNROLL_LIMIT stores.  When initWords is less','line_number':2357,'multiline':False]
['text':' than 2*UNROLL_LIMIT the loop trip count is at most 1 and there is no','line_number':2358,'multiline':False]
['text':' benefit to having the pointer calculations and the compare-and-branch.','line_number':2359,'multiline':False]
['text':' So we completely unroll when we have initWords < 2 * UNROLL_LIMIT.  (In','line_number':2360,'multiline':False]
['text':' this case we'll end up using 32-bit offsets on x64 for up to half of the','line_number':2361,'multiline':False]
['text':' stores, though.)','line_number':2362,'multiline':False]
['text':' Fully-unrolled case.','line_number':2364,'multiline':False]
['text':' Unrolled loop with a tail. Stores will use negative offsets. That's OK','line_number':2374,'multiline':False]
['text':' for x86 and ARM, at least.','line_number':2375,'multiline':False]
['text':' Compute pointer to the highest-addressed slot on the frame.','line_number':2377,'multiline':False]
['text':' Compute pointer to the lowest-addressed slot on the frame that will be','line_number':2381,'multiline':False]
['text':' initialized by the loop body.','line_number':2382,'multiline':False]
['text':' The loop body.  Eventually we'll have p == lim and exit the loop.','line_number':2387,'multiline':False]
['text':' The tail.','line_number':2396,'multiline':False]
['text':' Value stack: stack elements','line_number':2406,'multiline':False]
['text':' The Mem opcodes are all clustered at the beginning to','line_number':2414,'multiline':False]
['text':' allow for a quick test within sync().','line_number':2415,'multiline':False]
['text':' 32-bit integer stack value ("offs")','line_number':2416,'multiline':False]
['text':' 64-bit integer stack value ("offs")','line_number':2417,'multiline':False]
['text':' 32-bit floating stack value ("offs")','line_number':2418,'multiline':False]
['text':' 64-bit floating stack value ("offs")','line_number':2419,'multiline':False]
['text':' 128-bit vector stack value ("offs")','line_number':2421,'multiline':False]
['text':' reftype (pointer wide) stack value ("offs")','line_number':2423,'multiline':False]
['text':' The Local opcodes follow the Mem opcodes for a similar','line_number':2425,'multiline':False]
['text':' quick test within hasLocal().','line_number':2426,'multiline':False]
['text':' Local int32 var ("slot")','line_number':2427,'multiline':False]
['text':' Local int64 var ("slot")','line_number':2428,'multiline':False]
['text':' Local float32 var ("slot")','line_number':2429,'multiline':False]
['text':' Local double var ("slot")','line_number':2430,'multiline':False]
['text':' Local v128 var ("slot")','line_number':2432,'multiline':False]
['text':' Local reftype (pointer wide) var ("slot")','line_number':2434,'multiline':False]
['text':' 32-bit integer register ("i32reg")','line_number':2436,'multiline':False]
['text':' 64-bit integer register ("i64reg")','line_number':2437,'multiline':False]
['text':' 32-bit floating register ("f32reg")','line_number':2438,'multiline':False]
['text':' 64-bit floating register ("f64reg")','line_number':2439,'multiline':False]
['text':' 128-bit vector register ("v128reg")','line_number':2441,'multiline':False]
['text':' reftype (pointer wide) register ("refReg")','line_number':2443,'multiline':False]
['text':' 32-bit integer constant ("i32val")','line_number':2445,'multiline':False]
['text':' 64-bit integer constant ("i64val")','line_number':2446,'multiline':False]
['text':' 32-bit floating constant ("f32val")','line_number':2447,'multiline':False]
['text':' 64-bit floating constant ("f64val")','line_number':2448,'multiline':False]
['text':' 128-bit vector constant ("v128val")','line_number':2450,'multiline':False]
['text':' reftype (pointer wide) constant ("refval")','line_number':2452,'multiline':False]
['text':' For these two, use an out-param instead of simply returning, to','line_number':2588,'multiline':False]
['text':' use the normal stack and not the x87 FP stack (which has effect on','line_number':2589,'multiline':False]
['text':' NaNs with the signaling bit set).','line_number':2590,'multiline':False]
['text':' For SIMD, do the same as for floats since we're using float registers to','line_number':2602,'multiline':False]
['text':' hold vectors; this is just conservative.','line_number':2603,'multiline':False]
['text':' MachineStackTracker, used for stack-slot pointerness tracking.','line_number':2622,'multiline':False]
['text':' Simulates the machine's stack, with one bool per word.  Index zero in','line_number':2625,'multiline':False]
['text':' this vector corresponds to the highest address in the machine stack.  The','line_number':2626,'multiline':False]
['text':' last entry corresponds to what SP currently points at.  This all assumes','line_number':2627,'multiline':False]
['text':' a grow-down stack.','line_number':2628,'multiline':False]
['text':'','line_number':2629,'multiline':False]
['text':' numPtrs_ contains the number of "true" values in vec_, and is therefore','line_number':2630,'multiline':False]
['text':' redundant.  But it serves as a constant-time way to detect the common','line_number':2631,'multiline':False]
['text':' case where vec_ holds no "true" values.','line_number':2632,'multiline':False]
['text':' Clone this MachineStackTracker, writing the result at |dst|.','line_number':2649,'multiline':False]
['text':' Notionally push |n| non-pointers on the stack.','line_number':2659,'multiline':False]
['text':' Mark the stack slot |offsetFromSP| up from the bottom as holding a','line_number':2664,'multiline':False]
['text':' pointer.','line_number':2665,'multiline':False]
['text':' offsetFromSP == 0 denotes the most recently pushed item, == 1 the','line_number':2667,'multiline':False]
['text':' second most recently pushed item, etc.','line_number':2668,'multiline':False]
['text':' Query the pointerness of the slot |offsetFromSP| up from the bottom.','line_number':2676,'multiline':False]
['text':' Return the number of words tracked by this MachineStackTracker.','line_number':2684,'multiline':False]
['text':' Return the number of pointer-typed words tracked by this','line_number':2687,'multiline':False]
['text':' MachineStackTracker.','line_number':2688,'multiline':False]
['text':' Discard all contents, but (per mozilla::Vector::clear semantics) don't','line_number':2694,'multiline':False]
['text':' free or reallocate any dynamic storage associated with |vec_|.','line_number':2695,'multiline':False]
['text':' StackMapGenerator, which carries all state needed to create stackmaps.','line_number':2702,'multiline':False]
['text':' --- These are constant for the life of the function's compilation ---','line_number':2708,'multiline':False]
['text':' For generating stackmaps, we'll need to know the offsets of registers','line_number':2710,'multiline':False]
['text':' as saved by the trap exit stub.','line_number':2711,'multiline':False]
['text':' Completed stackmaps are added here','line_number':2715,'multiline':False]
['text':' So as to be able to get current offset when creating stackmaps','line_number':2718,'multiline':False]
['text':' --- These are constant once we've completed beginFunction() ---','line_number':2722,'multiline':False]
['text':' The number of words of arguments passed to this function in memory.','line_number':2724,'multiline':False]
['text':' tracks machine stack pointerness','line_number':2727,'multiline':False]
['text':' This holds masm.framePushed at entry to the function's body.  It is a','line_number':2729,'multiline':False]
['text':' Maybe because createStackMap needs to know whether or not we're still','line_number':2730,'multiline':False]
['text':' in the prologue.  It makes a Nothing-to-Some transition just once per','line_number':2731,'multiline':False]
['text':' function.','line_number':2732,'multiline':False]
['text':' --- These can change at any point ---','line_number':2735,'multiline':False]
['text':' This holds masm.framePushed at it would be be for a function call','line_number':2737,'multiline':False]
['text':' instruction, but excluding the stack area used to pass arguments in','line_number':2738,'multiline':False]
['text':' memory.  That is, for an upcoming function call, this will hold','line_number':2739,'multiline':False]
['text':'','line_number':2740,'multiline':False]
['text':'   masm.framePushed() at the call instruction -','line_number':2741,'multiline':False]
['text':'      StackArgAreaSizeUnaligned(argumentTypes)','line_number':2742,'multiline':False]
['text':'','line_number':2743,'multiline':False]
['text':' This value denotes the lowest-addressed stack word covered by the current','line_number':2744,'multiline':False]
['text':' function's stackmap.  Words below this point form the highest-addressed','line_number':2745,'multiline':False]
['text':' area of the callee's stackmap.  Note that all alignment padding above the','line_number':2746,'multiline':False]
['text':' arguments-in-memory themselves belongs to the caller's stackmap, which','line_number':2747,'multiline':False]
['text':' is why this is defined in terms of StackArgAreaSizeUnaligned() rather than','line_number':2748,'multiline':False]
['text':' StackArgAreaSizeAligned().','line_number':2749,'multiline':False]
['text':'','line_number':2750,'multiline':False]
['text':' When not inside a function call setup/teardown sequence, it is Nothing.','line_number':2751,'multiline':False]
['text':' It can make Nothing-to/from-Some transitions arbitrarily as we progress','line_number':2752,'multiline':False]
['text':' through the function body.','line_number':2753,'multiline':False]
['text':' The number of memory-resident, ref-typed entries on the containing','line_number':2756,'multiline':False]
['text':' BaseCompiler::stk_.','line_number':2757,'multiline':False]
['text':' This is a copy of machineStackTracker that is used only within individual','line_number':2760,'multiline':False]
['text':' calls to createStackMap. It is here only to avoid possible heap allocation','line_number':2761,'multiline':False]
['text':' costs resulting from making it local to createStackMap().','line_number':2762,'multiline':False]
['text':' At the beginning of a function, we may have live roots in registers (as','line_number':2775,'multiline':False]
['text':' arguments) at the point where we perform a stack overflow check.  This','line_number':2776,'multiline':False]
['text':' method generates the "extra" stackmap entries to describe that, in the','line_number':2777,'multiline':False]
['text':' case that the check fails and we wind up calling into the wasm exit','line_number':2778,'multiline':False]
['text':' stub, as generated by GenerateTrapExit().','line_number':2779,'multiline':False]
['text':'','line_number':2780,'multiline':False]
['text':' The resulting map must correspond precisely with the stack layout','line_number':2781,'multiline':False]
['text':' created for the integer registers as saved by (code generated by)','line_number':2782,'multiline':False]
['text':' GenerateTrapExit().  To do that we use trapExitLayout_ and','line_number':2783,'multiline':False]
['text':' trapExitLayoutNumWords_, which together comprise a description of the','line_number':2784,'multiline':False]
['text':' layout and are created by GenerateTrapExitMachineState().','line_number':2785,'multiline':False]
['text':' Creates a stackmap associated with the instruction denoted by','line_number':2792,'multiline':False]
['text':' |assemblerOffset|, incorporating pointers from the current operand','line_number':2793,'multiline':False]
['text':' stack |stk|, incorporating possible extra pointers in |extra| at the','line_number':2794,'multiline':False]
['text':' lower addressed end, and possibly with the associated frame having a','line_number':2795,'multiline':False]
['text':' DebugFrame as indicated by |debugFrame|.','line_number':2796,'multiline':False]
['text':' An important optimization.  If there are obviously no pointers, as','line_number':2804,'multiline':False]
['text':' we expect in the majority of cases, exit quickly.','line_number':2805,'multiline':False]
['text':' We can skip creating the map if there are no |true| elements in','line_number':2807,'multiline':False]
['text':' |extras|.','line_number':2808,'multiline':False]
['text':' In the debug case, create the stackmap regardless, and cross-check','line_number':2821,'multiline':False]
['text':' the pointer-counting below.  We expect the final map to have','line_number':2822,'multiline':False]
['text':' |countedPointers| in total.  This doesn't include those in the','line_number':2823,'multiline':False]
['text':' DebugFrame, but they do not appear in the map's bitmap.  Note that','line_number':2824,'multiline':False]
['text':' |countedPointers| is debug-only from this point onwards.','line_number':2825,'multiline':False]
['text':' Start with the frame-setup map, and add operand-stack information to','line_number':2831,'multiline':False]
['text':' that.  augmentedMst holds live data only within individual calls to','line_number':2832,'multiline':False]
['text':' createStackMap.','line_number':2833,'multiline':False]
['text':' At this point, augmentedMst only contains entries covering the','line_number':2839,'multiline':False]
['text':' incoming argument area (if any) and for the area allocated by this','line_number':2840,'multiline':False]
['text':' function's prologue.  We now need to calculate how far the machine's','line_number':2841,'multiline':False]
['text':' stack pointer is below where it was at the start of the body.  But we','line_number':2842,'multiline':False]
['text':' must take care not to include any words pushed as arguments to an','line_number':2843,'multiline':False]
['text':' upcoming function call, since those words "belong" to the stackmap of','line_number':2844,'multiline':False]
['text':' the callee, not to the stackmap of this function.  Note however that','line_number':2845,'multiline':False]
['text':' any alignment padding pushed prior to pushing the args *does* belong to','line_number':2846,'multiline':False]
['text':' this function.','line_number':2847,'multiline':False]
['text':'','line_number':2848,'multiline':False]
['text':' That padding is taken into account at the point where','line_number':2849,'multiline':False]
['text':' framePushedExcludingOutboundCallArgs is set, viz, in startCallArgs(),','line_number':2850,'multiline':False]
['text':' and comprises two components:','line_number':2851,'multiline':False]
['text':'','line_number':2852,'multiline':False]
['text':' * call->frameAlignAdjustment','line_number':2853,'multiline':False]
['text':' * the padding applied to the stack arg area itself.  That is:','line_number':2854,'multiline':False]
['text':'   StackArgAreaSize(argTys) - StackArgAreaSizeUnpadded(argTys)','line_number':2855,'multiline':False]
['text':' Still in the prologue.  framePushedExcludingArgs remains Nothing.','line_number':2858,'multiline':False]
['text':' In the body.','line_number':2861,'multiline':False]
['text':' In the body, and we've potentially pushed some args onto the stack.','line_number':2864,'multiline':False]
['text':' We must ignore them when sizing the stackmap.','line_number':2865,'multiline':False]
['text':' In the body, but not with call args on the stack.  The stackmap','line_number':2873,'multiline':False]
['text':' must be sized so as to extend all the way "down" to','line_number':2874,'multiline':False]
['text':' masm_.framePushed().','line_number':2875,'multiline':False]
['text':' Scan the operand stack, marking pointers in the just-added new','line_number':2889,'multiline':False]
['text':' section.','line_number':2890,'multiline':False]
['text':' We don't track roots in registers, per rationale below, so if this','line_number':2896,'multiline':False]
['text':' doesn't hold, something is seriously wrong, and we're likely to get a','line_number':2897,'multiline':False]
['text':' GC-related crash.','line_number':2898,'multiline':False]
['text':' Take the opportunity to check everything we reasonably can about','line_number':2904,'multiline':False]
['text':' operand stack elements.','line_number':2905,'multiline':False]
['text':' All of these have uninteresting type.','line_number':2919,'multiline':False]
['text':' These also have uninteresting type.  Check that they live in the','line_number':2928,'multiline':False]
['text':' section of stack set up by beginFunction().  The unguarded use of','line_number':2929,'multiline':False]
['text':' |value()| here is safe due to the assertion above this loop.','line_number':2930,'multiline':False]
['text':' These also have uninteresting type, but more to the point: all','line_number':2940,'multiline':False]
['text':' registers holding live values should have been flushed to the','line_number':2941,'multiline':False]
['text':' machine stack immediately prior to the instruction to which this','line_number':2942,'multiline':False]
['text':' stackmap pertains.  So these can't happen.','line_number':2943,'multiline':False]
['text':' This is the only case we care about.  We'll handle it after the','line_number':2946,'multiline':False]
['text':' switch.','line_number':2947,'multiline':False]
['text':' We need the stackmap to mention this pointer, but it should','line_number':2950,'multiline':False]
['text':' already be in the machineStackTracker section created by','line_number':2951,'multiline':False]
['text':' beginFunction().','line_number':2952,'multiline':False]
['text':' This can currently only be a null pointer.','line_number':2956,'multiline':False]
['text':' This can't happen, per rationale above.','line_number':2960,'multiline':False]
['text':' v.offs() holds masm.framePushed() at the point immediately after it','line_number':2966,'multiline':False]
['text':' was pushed on the stack.  Since it's still on the stack,','line_number':2967,'multiline':False]
['text':' masm.framePushed() can't be less.','line_number':2968,'multiline':False]
['text':' Create the final StackMap.  The initial map is zeroed out, so there's','line_number':2975,'multiline':False]
['text':' no need to write zero bits in it.','line_number':2976,'multiline':False]
['text':' First the exit stub extra words, if any.','line_number':2986,'multiline':False]
['text':' Followed by the "main" part of the map.','line_number':2995,'multiline':False]
['text':' Record in the map, how far down from the highest address the Frame* is.','line_number':3004,'multiline':False]
['text':' Take the opportunity to check that we haven't marked any part of the','line_number':3005,'multiline':False]
['text':' Frame itself as a pointer.','line_number':3006,'multiline':False]
['text':' Note the presence of a DebugFrame, if any.','line_number':3016,'multiline':False]
['text':' Add the completed map to the running collection thereof.','line_number':3021,'multiline':False]
['text':' Crosscheck the map pointer counting.','line_number':3029,'multiline':False]
['text':' The baseline compiler proper.','line_number':3063,'multiline':False]
['text':' Bit set used for simple bounds check elimination.  Capping this at 64','line_number':3087,'multiline':False]
['text':' locals makes sense; even 32 locals would probably be OK in practice.','line_number':3088,'multiline':False]
['text':'','line_number':3089,'multiline':False]
['text':' For more information about BCE, see the block comment above','line_number':3090,'multiline':False]
['text':' popMemory32Access(), below.','line_number':3091,'multiline':False]
['text':' Information stored in the control node for generating exception handling','line_number':3095,'multiline':False]
['text':' landing pads.','line_number':3096,'multiline':False]
['text':' Index for the associated exception.','line_number':3099,'multiline':False]
['text':' The entry label for the handler.','line_number':3100,'multiline':False]
['text':' Control node, representing labels and stack heights at join points.','line_number':3110,'multiline':False]
['text':' The "exit" label','line_number':3113,'multiline':False]
['text':' Used for the "else" branch of if-then-else','line_number':3114,'multiline':False]
['text':' and to allow delegate to jump to catches.','line_number':3115,'multiline':False]
['text':' From BaseStackFrame','line_number':3116,'multiline':False]
['text':' Value stack height','line_number':3117,'multiline':False]
['text':' Bounds check info flowing into the item','line_number':3118,'multiline':False]
['text':' Bounds check info flowing out of the item','line_number':3119,'multiline':False]
['text':' deadCode_ was set on entry to the region','line_number':3120,'multiline':False]
['text':' deadCode_ was set on exit from "then"','line_number':3121,'multiline':False]
['text':' For tracking try branch code ranges.','line_number':3122,'multiline':False]
['text':' Used for try-catch handlers.','line_number':3123,'multiline':False]
['text':' The baseline compiler tracks values on a stack of its own -- it','line_number':3145,'multiline':False]
['text':' needs to scan that stack for spilling -- and thus has no need','line_number':3146,'multiline':False]
['text':' for the values maintained by the iterator.','line_number':3147,'multiline':False]
['text':' The baseline compiler uses the iterator's control stack, attaching','line_number':3151,'multiline':False]
['text':' its own control information.','line_number':3152,'multiline':False]
['text':' The baseline compiler will use OOL code more sparingly than','line_number':3158,'multiline':False]
['text':' Baldr since our code is not high performance and frills like','line_number':3159,'multiline':False]
['text':' code density and branch prediction friendliness will be less','line_number':3160,'multiline':False]
['text':' important.','line_number':3161,'multiline':False]
['text':' The generate() method must be careful about register use','line_number':3186,'multiline':False]
['text':' because it will be invoked when there is a register','line_number':3187,'multiline':False]
['text':' assignment in the BaseCompiler that does not correspond','line_number':3188,'multiline':False]
['text':' to the available registers when the generated OOL code is','line_number':3189,'multiline':False]
['text':' executed.  The register allocator *must not* be called.','line_number':3190,'multiline':False]
['text':'','line_number':3191,'multiline':False]
['text':' The best strategy is for the creator of the OOL object to','line_number':3192,'multiline':False]
['text':' allocate all temps that the OOL code will need.','line_number':3193,'multiline':False]
['text':'','line_number':3194,'multiline':False]
['text':' Input, output, and temp registers are embedded in the OOL','line_number':3195,'multiline':False]
['text':' object and are known to the code generator.','line_number':3196,'multiline':False]
['text':'','line_number':3197,'multiline':False]
['text':' Scratch registers are available to use in OOL code.','line_number':3198,'multiline':False]
['text':'','line_number':3199,'multiline':False]
['text':' All other registers must be explicitly saved and restored','line_number':3200,'multiline':False]
['text':' by the OOL code before being used.','line_number':3201,'multiline':False]
['text':' If `omitAlignmentCheck` is true then we need check neither the','line_number':3214,'multiline':False]
['text':' pointer nor the offset.  Otherwise, if `onlyPointerAlignment` is true','line_number':3215,'multiline':False]
['text':' then we need check only the pointer.  Otherwise, check the sum of','line_number':3216,'multiline':False]
['text':' pointer and offset.','line_number':3217,'multiline':False]
['text':' Types of parameters and locals','line_number':3230,'multiline':False]
['text':' Flag indicating we should decode & discard the opcode','line_number':3231,'multiline':False]
['text':' Locals that have been bounds checked and not updated since','line_number':3233,'multiline':False]
['text':' Latent operation for branch (seen next)','line_number':3238,'multiline':False]
['text':' Operand type, if latentOp_ is true','line_number':3239,'multiline':False]
['text':' Comparison operator, if latentOp_ == Compare, int types','line_number':3241,'multiline':False]
['text':' Comparison operator, if latentOp_ == Compare, float','line_number':3243,'multiline':False]
['text':' types','line_number':3244,'multiline':False]
['text':' No '_' suffix - too tedious...','line_number':3247,'multiline':False]
['text':' Ditto','line_number':3248,'multiline':False]
['text':' On specific platforms we sometimes need to use specific registers.','line_number':3256,'multiline':False]
['text':' There are more members scattered throughout.','line_number':3260,'multiline':False]
['text':' Used by some of the ScratchRegister implementations.','line_number':3287,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':3294,'multiline':False]
['text':'','line_number':3295,'multiline':False]
['text':' Out of line code management.','line_number':3296,'multiline':False]
['text':' Utility.','line_number':3315,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':3322,'multiline':False]
['text':'','line_number':3323,'multiline':False]
['text':' High-level register management.','line_number':3324,'multiline':False]
['text':' TODO / OPTIMIZE: need2xI32() can be optimized along with needI32()','line_number':3429,'multiline':False]
['text':' to avoid sync(). (Bug 1316802)','line_number':3430,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////////','line_number':3529,'multiline':False]
['text':'','line_number':3530,'multiline':False]
['text':' Block parameters and results.','line_number':3531,'multiline':False]
['text':'','line_number':3532,'multiline':False]
['text':' Blocks may have multiple parameters and multiple results.  Blocks can also','line_number':3533,'multiline':False]
['text':' be the target of branches: the entry for loops, and the exit for','line_number':3534,'multiline':False]
['text':' non-loops.','line_number':3535,'multiline':False]
['text':'','line_number':3536,'multiline':False]
['text':' Passing multiple values to a non-branch target (i.e., the entry of a','line_number':3537,'multiline':False]
['text':' "block") falls out naturally: any items on the value stack can flow','line_number':3538,'multiline':False]
['text':' directly from one block to another.','line_number':3539,'multiline':False]
['text':'','line_number':3540,'multiline':False]
['text':' However, for branch targets, we need to allocate well-known locations for','line_number':3541,'multiline':False]
['text':' the branch values.  The approach taken in the baseline compiler is to','line_number':3542,'multiline':False]
['text':' allocate registers to the top N values (currently N=1), and then stack','line_number':3543,'multiline':False]
['text':' locations for the rest.','line_number':3544,'multiline':False]
['text':'','line_number':3545,'multiline':False]
['text':' Register results are visited first; when we see a stack result we're','line_number':3556,'multiline':False]
['text':' done.','line_number':3557,'multiline':False]
['text':' Register results are visited first; when we see a stack result we're','line_number':3619,'multiline':False]
['text':' done.','line_number':3620,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':3722,'multiline':False]
['text':'','line_number':3723,'multiline':False]
['text':' Value stack and spilling.','line_number':3724,'multiline':False]
['text':'','line_number':3725,'multiline':False]
['text':' The value stack facilitates some on-the-fly register allocation','line_number':3726,'multiline':False]
['text':' and immediate-constant use.  It tracks constants, latent','line_number':3727,'multiline':False]
['text':' references to locals, register contents, and values on the CPU','line_number':3728,'multiline':False]
['text':' stack.','line_number':3729,'multiline':False]
['text':'','line_number':3730,'multiline':False]
['text':' The stack can be flushed to memory using sync().  This is handy','line_number':3731,'multiline':False]
['text':' to avoid problems with control flow and messy register usage','line_number':3732,'multiline':False]
['text':' patterns.','line_number':3733,'multiline':False]
['text':' This is the value stack actually used during compilation.  It is a','line_number':3735,'multiline':False]
['text':' StkVector rather than a StkVector& since constantly dereferencing a','line_number':3736,'multiline':False]
['text':' StkVector& adds about 0.5% or more to the compiler's dynamic instruction','line_number':3737,'multiline':False]
['text':' count.','line_number':3738,'multiline':False]
['text':' Max number of pushes onto the value stack for any opcode or emitter that','line_number':3741,'multiline':False]
['text':' does not push a variable, unbounded amount (anything with multiple','line_number':3742,'multiline':False]
['text':' results).  This includes also intermediate pushes such as values pushed as','line_number':3743,'multiline':False]
['text':' parameters for builtin calls.','line_number':3744,'multiline':False]
['text':'','line_number':3745,'multiline':False]
['text':' This limit is set quite high on purpose, so as to avoid brittleness.  The','line_number':3746,'multiline':False]
['text':' true max value is likely no more than four or five.','line_number':3747,'multiline':False]
['text':' BaselineCompileFunctions() "lends" us the StkVector to use in this','line_number':3751,'multiline':False]
['text':' BaseCompiler object, and that is installed in |stk_| in our constructor.','line_number':3752,'multiline':False]
['text':' This is so as to avoid having to malloc/free the vector's contents at','line_number':3753,'multiline':False]
['text':' each creation/destruction of a BaseCompiler object.  It does however mean','line_number':3754,'multiline':False]
['text':' that we need to hold on to a reference to BaselineCompileFunctions()'s','line_number':3755,'multiline':False]
['text':' vector, so we can swap (give) its contents back when this BaseCompiler','line_number':3756,'multiline':False]
['text':' object is destroyed.  This significantly reduces the heap turnover of the','line_number':3757,'multiline':False]
['text':' baseline compiler.  See bug 1532592.','line_number':3758,'multiline':False]
['text':' None of the single-arg Stk constructors create a Stk::MemRef, so','line_number':3775,'multiline':False]
['text':' there's no need to increment stackMapGenerator_.memRefsOnStk here.','line_number':3776,'multiline':False]
['text':' Duplicate the reference at the specified depth and load it into a register.','line_number':4042,'multiline':False]
['text':' Flush all local and register value stack elements to memory.','line_number':4049,'multiline':False]
['text':'','line_number':4050,'multiline':False]
['text':' TODO / OPTIMIZE: As this is fairly expensive and causes worse','line_number':4051,'multiline':False]
['text':' code to be emitted subsequently, it is useful to avoid calling','line_number':4052,'multiline':False]
['text':' it.  (Bug 1316802)','line_number':4053,'multiline':False]
['text':'','line_number':4054,'multiline':False]
['text':' Some optimization has been done already.  Remaining','line_number':4055,'multiline':False]
['text':' opportunities:','line_number':4056,'multiline':False]
['text':'','line_number':4057,'multiline':False]
['text':'  - It would be interesting to see if we can specialize it','line_number':4058,'multiline':False]
['text':'    before calls with particularly simple signatures, or where','line_number':4059,'multiline':False]
['text':'    we can do parallel assignment of register arguments, or','line_number':4060,'multiline':False]
['text':'    similar.  See notes in emitCall().','line_number':4061,'multiline':False]
['text':'','line_number':4062,'multiline':False]
['text':'  - Operations that need specific registers: multiply, quotient,','line_number':4063,'multiline':False]
['text':'    remainder, will tend to sync because the registers we need','line_number':4064,'multiline':False]
['text':'    will tend to be allocated.  We may be able to avoid that by','line_number':4065,'multiline':False]
['text':'    prioritizing registers differently (takeLast instead of','line_number':4066,'multiline':False]
['text':'    takeFirst) but we may also be able to allocate an unused','line_number':4067,'multiline':False]
['text':'    register on demand to free up one we need, thus avoiding the','line_number':4068,'multiline':False]
['text':'    sync.  That type of fix would go into needI32().','line_number':4069,'multiline':False]
['text':' Memory opcodes are first in the enum, single check against MemLast is','line_number':4076,'multiline':False]
['text':' fine.','line_number':4077,'multiline':False]
['text':' Various methods for creating a stackmap.  Stackmaps are indexed by the','line_number':4203,'multiline':False]
['text':' lowest address of the instruction immediately *after* the instruction of','line_number':4204,'multiline':False]
['text':' interest.  In practice that means either: the return point of a call, the','line_number':4205,'multiline':False]
['text':' instruction immediately after a trap instruction (the "resume"','line_number':4206,'multiline':False]
['text':' instruction), or the instruction immediately following a no-op (when','line_number':4207,'multiline':False]
['text':' debugging is enabled).','line_number':4208,'multiline':False]
['text':' Create a vanilla stackmap.','line_number':4210,'multiline':False]
['text':' Create a stackmap as vanilla, but for a custom assembler offset.','line_number':4216,'multiline':False]
['text':' The most general stackmap construction.','line_number':4223,'multiline':False]
['text':' This is an optimization used to avoid calling sync() for','line_number':4233,'multiline':False]
['text':' setLocal(): if the local does not exist unresolved on the stack','line_number':4234,'multiline':False]
['text':' then we can skip the sync.','line_number':4235,'multiline':False]
['text':' Memory opcodes are first in the enum, single check against MemLast is','line_number':4239,'multiline':False]
['text':' fine.','line_number':4240,'multiline':False]
['text':' Local opcodes follow memory opcodes in the enum, single check against','line_number':4246,'multiline':False]
['text':' LocalLast is sufficient.','line_number':4247,'multiline':False]
['text':' TODO / OPTIMIZE: Improve this?  (Bug 1316817)','line_number':4257,'multiline':False]
['text':' Push the register r onto the stack.','line_number':4261,'multiline':False]
['text':' Push the value onto the stack.  PushI32 can also take uint32_t, and PushI64','line_number':4335,'multiline':False]
['text':' can take uint64_t; the semantics are the same.  Appropriate sign extension','line_number':4336,'multiline':False]
['text':' for a 32-bit value on a 64-bit architecture happens when the value is','line_number':4337,'multiline':False]
['text':' popped, see the definition of moveImm32 below.','line_number':4338,'multiline':False]
['text':' Push the local slot onto the stack.  The slot will not be read','line_number':4354,'multiline':False]
['text':' here; it will be read when it is consumed, or when a side','line_number':4355,'multiline':False]
['text':' effect to the slot forces its value to be saved.','line_number':4356,'multiline':False]
['text':' Call only from other popI32() variants.','line_number':4519,'multiline':False]
['text':' v must be the stack top.  May pop the CPU stack.','line_number':4520,'multiline':False]
['text':' Call only from other popV128() variants.','line_number':4570,'multiline':False]
['text':' v must be the stack top.  May pop the CPU stack.','line_number':4571,'multiline':False]
['text':' Call only from other popI64() variants.','line_number':4621,'multiline':False]
['text':' v must be the stack top.  May pop the CPU stack.','line_number':4622,'multiline':False]
['text':' Note, the stack top can be in one half of "specific" on 32-bit','line_number':4661,'multiline':False]
['text':' systems.  We can optimize, but for simplicity, if the register','line_number':4662,'multiline':False]
['text':' does not match exactly, then just force the stack top to memory','line_number':4663,'multiline':False]
['text':' and then read it back in.','line_number':4664,'multiline':False]
['text':' Call only from other popRef() variants.','line_number':4681,'multiline':False]
['text':' v must be the stack top.  May pop the CPU stack.','line_number':4682,'multiline':False]
['text':' Call only from other popPtr() variants.','line_number':4737,'multiline':False]
['text':' v must be the stack top.  May pop the CPU stack.','line_number':4738,'multiline':False]
['text':' Call only from other popF64() variants.','line_number':4764,'multiline':False]
['text':' v must be the stack top.  May pop the CPU stack.','line_number':4765,'multiline':False]
['text':' Call only from other popF32() variants.','line_number':4814,'multiline':False]
['text':' v must be the stack top.  May pop the CPU stack.','line_number':4815,'multiline':False]
['text':' TODO / OPTIMIZE (Bug 1316818): At the moment we use the Wasm','line_number':4953,'multiline':False]
['text':' inter-procedure ABI for block returns, which allocates ReturnReg as the','line_number':4954,'multiline':False]
['text':' single block result register.  It is possible other choices would lead to','line_number':4955,'multiline':False]
['text':' better register allocation, as ReturnReg is often first in the register set','line_number':4956,'multiline':False]
['text':' and will be heavily wanted by the register allocator that uses takeFirst().','line_number':4957,'multiline':False]
['text':'','line_number':4958,'multiline':False]
['text':' Obvious options:','line_number':4959,'multiline':False]
['text':'  - pick a register at the back of the register set','line_number':4960,'multiline':False]
['text':'  - pick a random register per block (different blocks have','line_number':4961,'multiline':False]
['text':'    different join regs)','line_number':4962,'multiline':False]
['text':' Pop register results.  Note that in the single-value case, popping to a','line_number':4965,'multiline':False]
['text':' register may cause a sync(); for multi-value we sync'd already.','line_number':4966,'multiline':False]
['text':' TODO / OPTIMIZE: We sync here to avoid solving the general parallel','line_number':4970,'multiline':False]
['text':' move problem in popStackResults.  However we could avoid syncing the','line_number':4971,'multiline':False]
['text':' values that are going to registers anyway, if they are already in','line_number':4972,'multiline':False]
['text':' registers.','line_number':4973,'multiline':False]
['text':' The iterator should be advanced beyond register results, and register','line_number':5007,'multiline':False]
['text':' results should be popped already from the value stack.','line_number':5008,'multiline':False]
['text':' At this point, only stack arguments are remaining.  Iterate through them','line_number':5011,'multiline':False]
['text':' to measure how much stack space they will take up.','line_number':5012,'multiline':False]
['text':' Calculate the space needed to store stack results, in bytes.','line_number':5017,'multiline':False]
['text':' Compute the stack height including the stack results.  Note that it's','line_number':5021,'multiline':False]
['text':' possible that this call expands the stack, for example if some of the','line_number':5022,'multiline':False]
['text':' results are supplied by constants and so are not already on the machine','line_number':5023,'multiline':False]
['text':' stack.','line_number':5024,'multiline':False]
['text':' Find a free GPR to use when shuffling stack values.  If none is','line_number':5027,'multiline':False]
['text':' available, push ReturnReg and restore it after we're done.','line_number':5028,'multiline':False]
['text':' The sequence of Stk values is in the same order on the machine stack as','line_number':5032,'multiline':False]
['text':' the result locations, but there is a complication: constant values are','line_number':5033,'multiline':False]
['text':' not actually pushed on the machine stack.  (At this point registers and','line_number':5034,'multiline':False]
['text':' locals have been spilled already.)  So, moving the Stk values into place','line_number':5035,'multiline':False]
['text':' isn't simply a shuffle-down or shuffle-up operation.  There is a part of','line_number':5036,'multiline':False]
['text':' the Stk sequence that shuffles toward the FP, a part that's already in','line_number':5037,'multiline':False]
['text':' place, and a part that shuffles toward the SP.  After shuffling, we have','line_number':5038,'multiline':False]
['text':' to materialize the constants.','line_number':5039,'multiline':False]
['text':' Shuffle mem values toward the frame pointer, copying deepest values','line_number':5041,'multiline':False]
['text':' first.  Stop when we run out of results, get to a register result, or','line_number':5042,'multiline':False]
['text':' find a Stk value that is closer to the FP than the result.','line_number':5043,'multiline':False]
['text':' Reset iterator and skip register results.','line_number':5063,'multiline':False]
['text':' Revisit top stack values, shuffling mem values toward the stack pointer,','line_number':5070,'multiline':False]
['text':' copying shallowest values first.','line_number':5071,'multiline':False]
['text':' Reset iterator and skip register results, which are already popped off','line_number':5088,'multiline':False]
['text':' the value stack.','line_number':5089,'multiline':False]
['text':' Materialize constants and pop the remaining items from the value stack.','line_number':5096,'multiline':False]
['text':' Update bookkeeping as we pop the Stk entry.','line_number':5123,'multiline':False]
['text':' This will pop the stack if needed.','line_number':5135,'multiline':False]
['text':' Because popStackResults might clobber the stack, it leaves the stack','line_number':5148,'multiline':False]
['text':' pointer already in the right place for the continuation, whether the','line_number':5149,'multiline':False]
['text':' continuation is a jump or fallthrough.','line_number':5150,'multiline':False]
['text':' We get here if there are no stack results.  For a fallthrough, the stack','line_number':5154,'multiline':False]
['text':' is already at the right height.  For a jump, we may need to pop the stack','line_number':5155,'multiline':False]
['text':' pointer if the continuation's stack height is lower than the current','line_number':5156,'multiline':False]
['text':' stack height.','line_number':5157,'multiline':False]
['text':' This function is similar to popBlockResults, but additionally handles the','line_number':5164,'multiline':False]
['text':' implicit exception pointer that is pushed to the value stack on entry to','line_number':5165,'multiline':False]
['text':' a catch handler by dropping it appropriately.','line_number':5166,'multiline':False]
['text':' Since popStackResults clobbers the stack, we only need to free the','line_number':5173,'multiline':False]
['text':' exception off of the value stack.','line_number':5174,'multiline':False]
['text':' If there are no stack results, we have to adjust the stack by','line_number':5177,'multiline':False]
['text':' dropping the exception reference that's now on the stack.','line_number':5178,'multiline':False]
['text':' Reserve extra space on the stack for all the values we'll push.','line_number':5201,'multiline':False]
['text':' Multi-value push is not accounted for by the pre-sizing of the stack in','line_number':5202,'multiline':False]
['text':' the decoding loop.','line_number':5203,'multiline':False]
['text':'','line_number':5204,'multiline':False]
['text':' Also make sure we leave headroom for other pushes that will occur after','line_number':5205,'multiline':False]
['text':' pushing results, just to be safe.','line_number':5206,'multiline':False]
['text':' We need to push the results in reverse order, so first iterate through','line_number':5212,'multiline':False]
['text':' all results to determine the locations of stack result types.','line_number':5213,'multiline':False]
['text':' A combination of popBlockResults + pushBlockResults, used when entering a','line_number':5268,'multiline':False]
['text':' block with a control-flow join (loops) or split (if) to shuffle the','line_number':5269,'multiline':False]
['text':' fallthrough block parameters into the locations expected by the','line_number':5270,'multiline':False]
['text':' continuation.','line_number':5271,'multiline':False]
['text':' This function should only be called when entering a block with a','line_number':5273,'multiline':False]
['text':' control-flow join at the entry, where there are no live temporaries in','line_number':5274,'multiline':False]
['text':' the current block.','line_number':5275,'multiline':False]
['text':' A combination of popBlockResults + pushBlockResults, used before branches','line_number':5282,'multiline':False]
['text':' where we don't know the target (br_if / br_table).  If and when the branch','line_number':5283,'multiline':False]
['text':' is taken, the stack results will be shuffled down into place.  For br_if','line_number':5284,'multiline':False]
['text':' that has fallthrough, the parameters for the untaken branch flow through to','line_number':5285,'multiline':False]
['text':' the continuation.','line_number':5286,'multiline':False]
['text':' There may be temporary values that need spilling; delay computation of','line_number':5292,'multiline':False]
['text':' the stack results base until after the popRegisterResults(), which spills','line_number':5293,'multiline':False]
['text':' if needed.','line_number':5294,'multiline':False]
['text':' Conditional branches with fallthrough are preceded by a topBranchParams, so','line_number':5308,'multiline':False]
['text':' we know that there are no stack results that need to be materialized.  In','line_number':5309,'multiline':False]
['text':' that case, we can just shuffle the whole block down before popping the','line_number':5310,'multiline':False]
['text':' stack.','line_number':5311,'multiline':False]
['text':' Find a free GPR to use when shuffling stack values.  If none','line_number':5332,'multiline':False]
['text':' is available, push ReturnReg and restore it after we're done.','line_number':5333,'multiline':False]
['text':' Return the amount of execution stack consumed by the top numval','line_number':5345,'multiline':False]
['text':' values on the value stack.','line_number':5346,'multiline':False]
['text':' Peek at the stack, for calls.','line_number':5426,'multiline':False]
['text':' Check that we're not leaking registers by comparing the','line_number':5433,'multiline':False]
['text':' state of the stack + available registers with the set of','line_number':5434,'multiline':False]
['text':' all available registers.','line_number':5435,'multiline':False]
['text':' Call this between opcodes.','line_number':5437,'multiline':False]
['text':' Nonlocal control flow can pass values in stack locations in a way that','line_number':5470,'multiline':False]
['text':' isn't accounted for by the value stack.  In dead code, which occurs','line_number':5471,'multiline':False]
['text':' after unconditional non-local control flow, there is no invariant to','line_number':5472,'multiline':False]
['text':' assert.','line_number':5473,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':5509,'multiline':False]
['text':'','line_number':5510,'multiline':False]
['text':' Control stack','line_number':5511,'multiline':False]
['text':' Make sure the constructor was run properly','line_number':5514,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':5533,'multiline':False]
['text':'','line_number':5534,'multiline':False]
['text':' Labels','line_number':5535,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////','line_number':5542,'multiline':False]
['text':'','line_number':5543,'multiline':False]
['text':' Function prologue and epilogue.','line_number':5544,'multiline':False]
['text':' Make a start on the stackmap for this function.  Inspect the args so','line_number':5553,'multiline':False]
['text':' as to determine which of them are both in-memory and pointer-typed, and','line_number':5554,'multiline':False]
['text':' add entries to machineStackTracker as appropriate.','line_number':5555,'multiline':False]
['text':' Identify GC-managed pointers passed on the stack.','line_number':5568,'multiline':False]
['text':' GenerateFunctionPrologue pushes exactly one wasm::Frame's worth of','line_number':5587,'multiline':False]
['text':' stuff, and none of the values are GC pointers.  Hence:','line_number':5588,'multiline':False]
['text':' Initialize DebugFrame fields before the stack overflow trap so that','line_number':5594,'multiline':False]
['text':' we have the invariant that all observable Frames in a debugEnabled','line_number':5595,'multiline':False]
['text':' Module have valid DebugFrames.','line_number':5596,'multiline':False]
['text':' No need to initialize cachedReturnJSValue_ or any ref-typed spilled','line_number':5614,'multiline':False]
['text':' register results, as they are traced if and only if a corresponding','line_number':5615,'multiline':False]
['text':' flag (hasCachedReturnJSValue or hasSpilledRefRegisterResult) is set.','line_number':5616,'multiline':False]
['text':' Generate a stack-overflow check and its associated stackmap.','line_number':5619,'multiline':False]
['text':' Locals are stack allocated.  Mark ref-typed ones in the stackmap','line_number':5641,'multiline':False]
['text':' accordingly.','line_number':5642,'multiline':False]
['text':' Locals that are stack arguments were already added to the stackmap','line_number':5644,'multiline':False]
['text':' before pushing the frame.','line_number':5645,'multiline':False]
['text':' Copy arguments from registers to stack.','line_number':5654,'multiline':False]
['text':' If there are stack results and the pointer to stack results','line_number':5657,'multiline':False]
['text':' was passed in a register, store it to the stack.','line_number':5658,'multiline':False]
['text':' If we're in a debug frame, copy the stack result pointer arg','line_number':5662,'multiline':False]
['text':' to a well-known place.','line_number':5663,'multiline':False]
['text':' We should have just visited this local in the preceding loop.','line_number':5691,'multiline':False]
['text':' Tell Instance::traceFrame that we have a pointer to trace.','line_number':5777,'multiline':False]
['text':' Always branch to returnLabel_.','line_number':5844,'multiline':False]
['text':' Patch the add in the prologue so that it checks against the correct','line_number':5847,'multiline':False]
['text':' frame size. Flush the constant pool in case it needs to be patched.','line_number':5848,'multiline':False]
['text':' Precondition for patching.','line_number':5851,'multiline':False]
['text':' Store and reload the return value from DebugFrame::return so that','line_number':5865,'multiline':False]
['text':' it can be clobbered, and/or modified by the debug trap.','line_number':5866,'multiline':False]
['text':' To satisy Tls extent invariant we need to reload WasmTlsReg because','line_number':5879,'multiline':False]
['text':' baseline can clobber it.','line_number':5880,'multiline':False]
['text':' FIXME - profiling code missing.  No bug for this.','line_number':5885,'multiline':False]
['text':' Note the end of the inline code and start of the OOL code.','line_number':5887,'multiline':False]
['text':' gen->perfSpewer().noteEndInlineCode(masm);','line_number':5888,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////','line_number':5908,'multiline':False]
['text':'','line_number':5909,'multiline':False]
['text':' Calls.','line_number':5910,'multiline':False]
['text':' Call-outs need to use the appropriate system ABI.','line_number':5942,'multiline':False]
['text':' Use masm.framePushed() because the value we want here does not depend','line_number':5956,'multiline':False]
['text':' on the height of the frame's stack area, but the actual size of the','line_number':5957,'multiline':False]
['text':' allocated frame.','line_number':5958,'multiline':False]
['text':' On x86 there are no pinned registers, so don't waste time','line_number':5976,'multiline':False]
['text':' reloading the Tls.','line_number':5977,'multiline':False]
['text':' Record the masm.framePushed() value at this point, before we push args','line_number':5990,'multiline':False]
['text':' for the call, but including the alignment space placed above the args.','line_number':5991,'multiline':False]
['text':' This defines the lower limit of the stackmap that will be created for','line_number':5992,'multiline':False]
['text':' this call.','line_number':5993,'multiline':False]
['text':' However much we've pushed so far','line_number':5997,'multiline':False]
['text':' Extra space we'll push to get the frame aligned','line_number':5999,'multiline':False]
['text':' Extra space we'll push to get the outbound arg area 16-aligned','line_number':6001,'multiline':False]
['text':' TODO / OPTIMIZE (Bug 1316821): Note passArg is used only in one place.','line_number':6014,'multiline':False]
['text':' (Or it was, until Luke wandered through, but that can be fixed again.)','line_number':6015,'multiline':False]
['text':' I'm not saying we should manually inline it, but we could hoist the','line_number':6016,'multiline':False]
['text':' dispatch into the caller and have type-specific implementations of','line_number':6017,'multiline':False]
['text':' passArg: passArgI32(), etc.  Then those might be inlined, at least in PGO','line_number':6018,'multiline':False]
['text':' builds.','line_number':6019,'multiline':False]
['text':'','line_number':6020,'multiline':False]
['text':' The bulk of the work here (60%) is in the next() call, though.','line_number':6021,'multiline':False]
['text':'','line_number':6022,'multiline':False]
['text':' Notably, since next() is so expensive, StackArgAreaSizeUnaligned()','line_number':6023,'multiline':False]
['text':' becomes expensive too.','line_number':6024,'multiline':False]
['text':'','line_number':6025,'multiline':False]
['text':' Somehow there could be a trick here where the sequence of argument types','line_number':6026,'multiline':False]
['text':' (read from the input stream) leads to a cached entry for','line_number':6027,'multiline':False]
['text':' StackArgAreaSizeUnaligned() and for how to pass arguments...','line_number':6028,'multiline':False]
['text':'','line_number':6029,'multiline':False]
['text':' But at least we could reduce the cost of StackArgAreaSizeUnaligned() by','line_number':6030,'multiline':False]
['text':' first reading the argument types into a (reusable) vector, then we have','line_number':6031,'multiline':False]
['text':' the outgoing size at low cost, and then we can pass args based on the','line_number':6032,'multiline':False]
['text':' info we read.','line_number':6033,'multiline':False]
['text':' Precondition: sync()','line_number':6199,'multiline':False]
['text':' Precondition: sync()','line_number':6215,'multiline':False]
['text':' Builtin method calls assume the TLS register has been set.','line_number':6230,'multiline':False]
['text':' pushResults currently bypasses special case code in captureReturnedFxx()','line_number':6241,'multiline':False]
['text':' that converts GPR results to FPR results for systemABI+softFP.  If we','line_number':6242,'multiline':False]
['text':' ever start using that combination for calls we need more code.  This','line_number':6243,'multiline':False]
['text':' assert is stronger than we need - we only care about results in return','line_number':6244,'multiline':False]
['text':' registers - but that's OK.','line_number':6245,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////','line_number':6251,'multiline':False]
['text':'','line_number':6252,'multiline':False]
['text':' Sundry low-level code generators.','line_number':6253,'multiline':False]
['text':' The compiler depends on moveImm32() clearing the high bits of a 64-bit','line_number':6255,'multiline':False]
['text':' register on 64-bit systems except MIPS64 where high bits are sign extended','line_number':6256,'multiline':False]
['text':' from lower bits, see doc block "64-bit GPRs carrying 32-bit values" in','line_number':6257,'multiline':False]
['text':' MacroAssembler.h.','line_number':6258,'multiline':False]
['text':' Flush constant pools to ensure that the table is never interrupted by','line_number':6274,'multiline':False]
['text':' constant pool entries.','line_number':6275,'multiline':False]
['text':' Prevent nop sequences to appear in the jump table.','line_number':6279,'multiline':False]
['text':' Flush constant pools: offset must reflect the distance from the MOV','line_number':6306,'multiline':False]
['text':' to the start of the table; as the address of the MOV is given by the','line_number':6307,'multiline':False]
['text':' label, nothing must come between the bind() and the ma_mov().','line_number':6308,'multiline':False]
['text':' number of instructions in scope = ','line_number':6310,'multiline':True]
['text':' Compute the offset from the ma_mov instruction to the jump table.','line_number':6314,'multiline':False]
['text':' Read PC+8','line_number':6319,'multiline':False]
['text':' ARM scratch register is required by ma_sub.','line_number':6322,'multiline':False]
['text':' Compute the absolute table base pointer into `scratch`, offset by 8','line_number':6325,'multiline':False]
['text':' to account for the fact that ma_mov read PC+8.','line_number':6326,'multiline':False]
['text':' Jump indirect via table element.','line_number':6329,'multiline':False]
['text':' number of instructions in scope = ','line_number':6344,'multiline':True]
['text':' The caller must set up the following situation.','line_number':6476,'multiline':False]
['text':' The caller must set up the following situation.','line_number':6520,'multiline':False]
['text':' RABALDR_INT_DIV_I64_CALLOUT','line_number':6557,'multiline':False]
['text':' RABALDR_FLOAT_TO_I64_CALLOUT','line_number':6704,'multiline':False]
['text':' RABALDR_I64_TO_FLOAT_CALLOUT','line_number':6734,'multiline':False]
['text':' TODO / OPTIMIZE (Bug 1316822): This is pretty branchy, we should be','line_number':6743,'multiline':False]
['text':' able to do better.','line_number':6744,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////','line_number':6767,'multiline':False]
['text':'','line_number':6768,'multiline':False]
['text':' Global variable access.','line_number':6769,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////','line_number':6782,'multiline':False]
['text':'','line_number':6783,'multiline':False]
['text':' Heap access.','line_number':6784,'multiline':False]
['text':' The local becomes safe even if the offset is beyond the guard limit.','line_number':6800,'multiline':False]
['text':' Fold offset if necessary for further computations.','line_number':6817,'multiline':False]
['text':' Alignment check if required.','line_number':6830,'multiline':False]
['text':' We only care about the low pointer bits here.','line_number':6834,'multiline':False]
['text':' Ensure no tls if we don't need it.','line_number':6842,'multiline':False]
['text':' We have HeapReg and no bounds checking and need load neither','line_number':6845,'multiline':False]
['text':' memoryBase nor boundsCheckLimit from tls.','line_number':6846,'multiline':False]
['text':' We have HeapReg on ARM and don't need to load the memoryBase from tls.','line_number':6850,'multiline':False]
['text':' Bounds check if required.','line_number':6854,'multiline':False]
['text':' If the bounds check uses the full 64 bits of the bounds check limit,','line_number':6859,'multiline':False]
['text':' then the index must be zero-extended to 64 bits before checking and','line_number':6860,'multiline':False]
['text':' wrapped back to 32-bits after Spectre masking.  (And it's important','line_number':6861,'multiline':False]
['text':' that the value we end up with has flowed through the Spectre mask.)','line_number':6862,'multiline':False]
['text':'','line_number':6863,'multiline':False]
['text':' If the memory's max size is known to be smaller than 64K pages exactly,','line_number':6864,'multiline':False]
['text':' we can use a 32-bit check and avoid extension and wrapping.','line_number':6865,'multiline':False]
['text':' Note, ptr and ptr64 are the same register.','line_number':6868,'multiline':False]
['text':' In principle there may be non-zero bits in the upper bits of the','line_number':6871,'multiline':False]
['text':' register; clear them.','line_number':6872,'multiline':False]
['text':' The canonical value is zero-extended (see comment block "64-bit GPRs','line_number':6874,'multiline':False]
['text':' carrying 32-bit values" in MacroAssembler.h); we already have that.','line_number':6875,'multiline':False]
['text':' Any Spectre mitigation will appear to update the ptr64 register.','line_number':6881,'multiline':False]
['text':' Restore the value to the canonical form for a 32-bit value in a','line_number':6886,'multiline':False]
['text':' 64-bit register and/or the appropriate form for further use in the','line_number':6887,'multiline':False]
['text':' indexing instruction.','line_number':6888,'multiline':False]
['text':' The canonical value is zero-extended; we already have that.','line_number':6890,'multiline':False]
['text':' Some consumers depend on the address not retaining tls, as tls may be the','line_number':6920,'multiline':False]
['text':' scratch register.','line_number':6921,'multiline':False]
['text':' x86 requires Tls for memory base','line_number':6975,'multiline':False]
['text':' ptr and dest may be the same iff dest is I32.','line_number':6982,'multiline':False]
['text':' This may destroy ptr even if ptr and dest are not the same.','line_number':6983,'multiline':False]
['text':' For 8 bit loads, this will generate movsbl or movzbl, so','line_number':7005,'multiline':False]
['text':' there's no constraint on what the output register may be.','line_number':7006,'multiline':False]
['text':' ptr and src must not be the same register.','line_number':7063,'multiline':False]
['text':' This may destroy ptr and src.','line_number':7064,'multiline':False]
['text':' Emit the store','line_number':7069,'multiline':False]
['text':' Allocate all temp registers if 'allocate' is not specified.','line_number':7154,'multiline':False]
['text':' The temp, if used, must be a byte register.','line_number':7182,'multiline':False]
['text':' On x86, V is Address.  On other platforms, it is Register64.','line_number':7208,'multiline':False]
['text':' T is BaseIndex or Address.','line_number':7209,'multiline':False]
['text':' The replacement value must have a byte persona.','line_number':7233,'multiline':False]
['text':' The output register must have a byte persona.','line_number':7271,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':7295,'multiline':False]
['text':'','line_number':7296,'multiline':False]
['text':' Generally speaking, ABOVE this point there should be no','line_number':7297,'multiline':False]
['text':' value stack manipulation (calls to popI32 etc).','line_number':7298,'multiline':False]
['text':'','line_number':7299,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':7300,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':7302,'multiline':False]
['text':'','line_number':7303,'multiline':False]
['text':' Platform-specific popping and register targeting.','line_number':7304,'multiline':False]
['text':'','line_number':7305,'multiline':False]
['text':' These fall into two groups, popping methods for simple needs, and RAII','line_number':7306,'multiline':False]
['text':' wrappers for more complex behavior.','line_number':7307,'multiline':False]
['text':' The simple popping methods pop values into targeted registers; the caller','line_number':7309,'multiline':False]
['text':' can free registers using standard functions.  These are always called','line_number':7310,'multiline':False]
['text':' popXForY where X says something about types and Y something about the','line_number':7311,'multiline':False]
['text':' operation being targeted.','line_number':7312,'multiline':False]
['text':' r0 must be eax, and edx will be clobbered.','line_number':7316,'multiline':False]
['text':' r0 must be rax, and rdx will be clobbered.','line_number':7329,'multiline':False]
['text':' As for x64, though edx is part of r0.','line_number':7335,'multiline':False]
['text':' r0 must be rax, and rdx will be clobbered.','line_number':7357,'multiline':False]
['text':' r1 must be ecx for a variable shift, unless BMI2 is available.','line_number':7369,'multiline':False]
['text':' A limitation in the x86 masm requires ecx here','line_number':7383,'multiline':False]
['text':' r1 must be ecx for a variable shift.','line_number':7397,'multiline':False]
['text':' r1 must be rcx for a variable shift, unless BMI2 is available.','line_number':7402,'multiline':False]
['text':' No masking is necessary on 64-bit platforms, and on arm32 the masm','line_number':7408,'multiline':False]
['text':' implementation masks.','line_number':7409,'multiline':False]
['text':' r1 must be ecx for a variable rotate.','line_number':7416,'multiline':False]
['text':' r1 must be ecx for a variable rotate.','line_number':7425,'multiline':False]
['text':' r0 must be edx:eax for cdq','line_number':7435,'multiline':False]
['text':' r0 must be edx:eax for cdq','line_number':7446,'multiline':False]
['text':' Low on top, high underneath','line_number':7448,'multiline':False]
['text':' The RAII wrappers are used because we sometimes have to free partial','line_number':7455,'multiline':False]
['text':' registers, as when part of a register is the scratch register that has','line_number':7456,'multiline':False]
['text':' been temporarily used, or not free a register at all, as when the','line_number':7457,'multiline':False]
['text':' register is the same as the destination register (but only on some','line_number':7458,'multiline':False]
['text':' platforms, not on all).  These are called PopX{32,64}Regs where X is the','line_number':7459,'multiline':False]
['text':' operation being targeted.','line_number':7460,'multiline':False]
['text':' Utility struct that holds the BaseCompiler and the destination, and frees','line_number':7462,'multiline':False]
['text':' the destination if it has not been extracted.','line_number':7463,'multiline':False]
['text':' Take and clear the Rd - use this when pushing Rd.','line_number':7488,'multiline':False]
['text':' For cmpxchg, the expected value and the result are both in eax.','line_number':7508,'multiline':False]
['text':' For cmpxchg, the expected value and the result are both in rax.','line_number':7580,'multiline':False]
['text':' For cmpxchg8b, the expected value and the result are both in','line_number':7589,'multiline':False]
['text':' edx:eax, and the replacement value is in ecx:ebx.  But we can't','line_number':7590,'multiline':False]
['text':' allocate ebx here, so instead we allocate a temp to hold the low','line_number':7591,'multiline':False]
['text':' word of 'new'.','line_number':7592,'multiline':False]
['text':' The replacement value and the result must both be odd/even pairs.','line_number':7604,'multiline':False]
['text':' The result is in edx:eax, and we need ecx:ebx as a temp.  But we','line_number':7654,'multiline':False]
['text':' can't reserve ebx yet, so we'll accept it as an argument to the','line_number':7655,'multiline':False]
['text':' operation (below).','line_number':7656,'multiline':False]
['text':' ARM, MIPS32','line_number':7683,'multiline':False]
['text':' JS_64BIT','line_number':7690,'multiline':False]
['text':' We use xadd, so source and destination are the same.  Using','line_number':7705,'multiline':False]
['text':' eax here is overconstraining, but for byte operations on x86','line_number':7706,'multiline':False]
['text':' we do need something with a byte register.','line_number':7707,'multiline':False]
['text':' We use a cmpxchg loop.  The output must be eax; the input','line_number':7715,'multiline':False]
['text':' must be in a separate register since it may be used several','line_number':7716,'multiline':False]
['text':' times.','line_number':7717,'multiline':False]
['text':' Single-byte is a special case handled very locally with','line_number':7725,'multiline':False]
['text':' ScratchReg, see atomicRMW32 above.','line_number':7726,'multiline':False]
['text':' We use xaddq, so input and output must be the same register.','line_number':7795,'multiline':False]
['text':' We use a cmpxchgq loop, so the output must be rax.','line_number':7799,'multiline':False]
['text':' We'll use cmpxchg8b, so rv must be in ecx:ebx, and rd must be','line_number':7813,'multiline':False]
['text':' edx:eax.  But we can't reserve ebx here because we need it later, so','line_number':7814,'multiline':False]
['text':' use a separate temp and set up ebx when we perform the operation.','line_number':7815,'multiline':False]
['text':' We use a ldrex/strexd loop so the temp and the output must be','line_number':7830,'multiline':False]
['text':' odd/even pairs.','line_number':7831,'multiline':False]
['text':' The xchg instruction reuses rv as rd.','line_number':7884,'multiline':False]
['text':' We'll use cmpxchg8b, so rv must be in ecx:ebx, and rd must be','line_number':7942,'multiline':False]
['text':' edx:eax.  But we can't reserve ebx here because we need it later, so','line_number':7943,'multiline':False]
['text':' use a separate temp and set up ebx when we perform the operation.','line_number':7944,'multiline':False]
['text':' Both rv and rd must be odd/even pairs.','line_number':7956,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':7991,'multiline':False]
['text':'','line_number':7992,'multiline':False]
['text':' Generally speaking, BELOW this point there should be no','line_number':7993,'multiline':False]
['text':' platform dependencies.  We make very occasional exceptions','line_number':7994,'multiline':False]
['text':' when it doesn't become messy and further abstraction is','line_number':7995,'multiline':False]
['text':' not desirable.','line_number':7996,'multiline':False]
['text':'','line_number':7997,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':7998,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':8000,'multiline':False]
['text':'','line_number':8001,'multiline':False]
['text':' Sundry wrappers.','line_number':8002,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':8088,'multiline':False]
['text':'','line_number':8089,'multiline':False]
['text':' Sundry helpers.','line_number':8090,'multiline':False]
['text':' Abstracted helper for throwing, used for throw, rethrow, and rethrowing','line_number':8106,'multiline':False]
['text':' at the end of a series of catch blocks (if none matched the exception).','line_number':8107,'multiline':False]
['text':' ThrowException invokes a trap, and the rest is dead code.','line_number':8111,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':8121,'multiline':False]
['text':'','line_number':8122,'multiline':False]
['text':' Object support.','line_number':8123,'multiline':False]
['text':' This emits a GC pre-write barrier.  The pre-barrier is needed when we','line_number':8125,'multiline':False]
['text':' replace a member field with a new value, and the previous field value','line_number':8126,'multiline':False]
['text':' might have no other referents, and incremental GC is ongoing. The field','line_number':8127,'multiline':False]
['text':' might belong to an object or be a stack slot or a register or a heap','line_number':8128,'multiline':False]
['text':' allocated value.','line_number':8129,'multiline':False]
['text':'','line_number':8130,'multiline':False]
['text':' let obj = { field: previousValue };','line_number':8131,'multiline':False]
['text':' obj.field = newValue; // previousValue must be marked with a pre-barrier.','line_number':8132,'multiline':False]
['text':'','line_number':8133,'multiline':False]
['text':' The `valueAddr` is the address of the location that we are about to','line_number':8134,'multiline':False]
['text':' update.  This function preserves that register.','line_number':8135,'multiline':False]
['text':' The prebarrier stub assumes the PseudoStackPointer is set up.  It is OK','line_number':8146,'multiline':False]
['text':' to just move the sp to x28 here because x28 is not being used by the','line_number':8147,'multiline':False]
['text':' baseline compiler and need not be saved or restored.','line_number':8148,'multiline':False]
['text':' The prebarrier call preserves all volatile registers','line_number':8152,'multiline':False]
['text':' This frees the register `valueAddr`.','line_number':8158,'multiline':False]
['text':' The `valueAddr` is a raw pointer to the cell within some GC object or','line_number':8163,'multiline':False]
['text':' TLS area, and we guarantee that the GC will not run while the','line_number':8164,'multiline':False]
['text':' postbarrier call is active, so push a uintptr_t value.','line_number':8165,'multiline':False]
['text':' Emits a store to a JS object pointer at the address valueAddr, which is','line_number':8170,'multiline':False]
['text':' inside the GC cell `object`. Preserves `object` and `value`.','line_number':8171,'multiline':False]
['text':' TODO/AnyRef-boxing: With boxed immediates and strings, the write','line_number':8174,'multiline':False]
['text':' barrier is going to have to be more complicated.','line_number':8175,'multiline':False]
['text':' Preserves valueAddr','line_number':8178,'multiline':False]
['text':' Consumes valueAddr','line_number':8193,'multiline':False]
['text':' Consume all other operands as they may have been clobbered by the post','line_number':8198,'multiline':False]
['text':' barrier call','line_number':8199,'multiline':False]
['text':'//////////////////////////////////////////////////////////','line_number':8209,'multiline':False]
['text':'','line_number':8210,'multiline':False]
['text':' Machinery for optimized conditional branches.','line_number':8211,'multiline':False]
['text':'','line_number':8212,'multiline':False]
['text':' To disable this optimization it is enough always to return false from','line_number':8213,'multiline':False]
['text':' sniffConditionalControl{Cmp,Eqz}.','line_number':8214,'multiline':False]
['text':' The target of the branch, never NULL','line_number':8240,'multiline':False]
['text':' The stack base above which to place','line_number':8241,'multiline':False]
['text':' stack-spilled block results, if','line_number':8242,'multiline':False]
['text':' hasBlockResults().','line_number':8243,'multiline':False]
['text':' If true, invert the sense of the branch','line_number':8244,'multiline':False]
['text':' The result propagated along the edges','line_number':8245,'multiline':False]
['text':' Emit a conditional branch that optionally and optimally cleans up the CPU','line_number':8321,'multiline':False]
['text':' stack before we branch.','line_number':8322,'multiline':False]
['text':'','line_number':8323,'multiline':False]
['text':' Cond is either Assembler::Condition or Assembler::DoubleCondition.','line_number':8324,'multiline':False]
['text':'','line_number':8325,'multiline':False]
['text':' Lhs is RegI32, RegI64, or RegF32, RegF64, or RegRef.','line_number':8326,'multiline':False]
['text':'','line_number':8327,'multiline':False]
['text':' Rhs is either the same as Lhs, or an immediate expression compatible with','line_number':8328,'multiline':False]
['text':' Lhs "when applicable".','line_number':8329,'multiline':False]
['text':' Shuffle stack args.','line_number':8344,'multiline':False]
['text':' sniffConditionalControl{Cmp,Eqz} may modify the latentWhatever_ state in','line_number':8358,'multiline':False]
['text':' the BaseCompiler so that a subsequent conditional branch can be compiled','line_number':8359,'multiline':False]
['text':' optimally.  emitBranchSetup() and emitBranchPerform() will consume that','line_number':8360,'multiline':False]
['text':' state.  If the latter methods are not called because deadCode_ is true','line_number':8361,'multiline':False]
['text':' then the compiler MUST instead call resetLatentOp() to reset the state.','line_number':8362,'multiline':False]
['text':'////////////////////////////////////////////////////////////////////','line_number':8371,'multiline':False]
['text':' Used for common setup for catch and catch_all.','line_number':8379,'multiline':False]
['text':' Helper function used to generate landing pad code for the special','line_number':8382,'multiline':False]
['text':' case in which `delegate` jumps to a function's body block.','line_number':8383,'multiline':False]
['text':' After the arguments to the call, there is a callee pushed onto value','line_number':8401,'multiline':False]
['text':' stack.  This is only the case for callIndirect.  To get the arguments to','line_number':8402,'multiline':False]
['text':' the call, emitCallArgs has to reach one element deeper into the value','line_number':8403,'multiline':False]
['text':' stack, to skip the callee.','line_number':8404,'multiline':False]
['text':' No callee on the stack.','line_number':8407,'multiline':False]
['text':' TODO: We want these to be inlined for sure; do we need an `inline` somewhere?','line_number':8658,'multiline':False]
['text':' Specialize narrowing reuse.  Consumers may assume that rs.reg==rd on 64-bit','line_number':8725,'multiline':False]
['text':' platforms, or rs.low==rd on 32-bit platforms.','line_number':8726,'multiline':False]
['text':' Note order of arguments must be the same as for the reader.','line_number':8915,'multiline':False]
['text':' Currently common to PopcntI32 and PopcntI64','line_number':8969,'multiline':False]
['text':' Convert signaling NaN to quiet NaNs.','line_number':9138,'multiline':False]
['text':'','line_number':9139,'multiline':False]
['text':' TODO / OPTIMIZE (bug 1316824): see comment in MinF32.','line_number':9140,'multiline':False]
['text':' Convert signaling NaN to quiet NaNs.','line_number':9153,'multiline':False]
['text':'','line_number':9154,'multiline':False]
['text':' TODO / OPTIMIZE (bug 1316824): see comment in MinF32.','line_number':9155,'multiline':False]
['text':' Convert signaling NaN to quiet NaNs.','line_number':9206,'multiline':False]
['text':'','line_number':9207,'multiline':False]
['text':' TODO / OPTIMIZE (bug 1316824): Don't do this if one of the operands','line_number':9208,'multiline':False]
['text':' is known to be a constant.','line_number':9209,'multiline':False]
['text':' Convert signaling NaN to quiet NaNs.','line_number':9222,'multiline':False]
['text':'','line_number':9223,'multiline':False]
['text':' TODO / OPTIMIZE (bug 1316824): see comment in MinF32.','line_number':9224,'multiline':False]
['text':' RABALDR_INT_DIV_I64_CALLOUT','line_number':9580,'multiline':False]
['text':' RABALDR_FLOAT_TO_I64_CALLOUT','line_number':9682,'multiline':False]
['text':' RABALDR_I64_TO_FLOAT_CALLOUT','line_number':9739,'multiline':False]
['text':' On x86, latent i64 binary comparisons use too many registers: the','line_number':9748,'multiline':False]
['text':' reserved join register and the lhs and rhs operands require six, but we','line_number':9749,'multiline':False]
['text':' only have five.','line_number':9750,'multiline':False]
['text':' No optimization for pointer compares yet.','line_number':9756,'multiline':False]
['text':' Avoid allocating operands to latentOp_ to result registers.','line_number':9794,'multiline':False]
['text':' Set up fields so that emitBranchPerform() need not switch on latentOp_.','line_number':9799,'multiline':False]
['text':' For blocks and loops and ifs:','line_number':9929,'multiline':False]
['text':'','line_number':9930,'multiline':False]
['text':'  - Sync the value stack before going into the block in order to simplify exit','line_number':9931,'multiline':False]
['text':'    from the block: all exits from the block can assume that there are no','line_number':9932,'multiline':False]
['text':'    live registers except the one carrying the exit value.','line_number':9933,'multiline':False]
['text':'  - The block can accumulate a number of dead values on the stacks, so when','line_number':9934,'multiline':False]
['text':'    branching out of the block or falling out at the end be sure to','line_number':9935,'multiline':False]
['text':'    pop the appropriate stacks back to where they were on entry, while','line_number':9936,'multiline':False]
['text':'    preserving the exit value.','line_number':9937,'multiline':False]
['text':'  - A continue branch in a loop is much like an exit branch, but the branch','line_number':9938,'multiline':False]
['text':'    value must not be preserved.','line_number':9939,'multiline':False]
['text':'  - The exit value is always in a designated join register (type dependent).','line_number':9940,'multiline':False]
['text':' Simplifies branching out from block','line_number':9949,'multiline':False]
['text':' Block does not fall through; reset stack.','line_number':9961,'multiline':False]
['text':' If the block label is used, we have a control join, so we need to shuffle','line_number':9965,'multiline':False]
['text':' fallthrough values into place.  Otherwise if it's not a control join, we','line_number':9966,'multiline':False]
['text':' can leave the value stack alone.','line_number':9967,'multiline':False]
['text':' Bind after cleanup: branches out will have popped the stack.','line_number':9975,'multiline':False]
['text':' Simplifies branching out from block','line_number':9999,'multiline':False]
['text':' Loop entry is a control join, so shuffle the entry parameters into the','line_number':10006,'multiline':False]
['text':' well-known locations.','line_number':10007,'multiline':False]
['text':' The interrupt check barfs if there are live registers.','line_number':10013,'multiline':False]
['text':' The bodies of the "then" and "else" arms can be arbitrary sequences','line_number':10023,'multiline':False]
['text':' of expressions, they push control and increment the nesting and can','line_number':10024,'multiline':False]
['text':' even be targeted by jumps.  A branch to the "if" block branches to','line_number':10025,'multiline':False]
['text':' the exit of the if, ie, it's like "break".  Consider:','line_number':10026,'multiline':False]
['text':'','line_number':10027,'multiline':False]
['text':'      (func (result i32)','line_number':10028,'multiline':False]
['text':'       (if (i32.const 1)','line_number':10029,'multiline':False]
['text':'           (begin (br 1) (unreachable))','line_number':10030,'multiline':False]
['text':'           (begin (unreachable)))','line_number':10031,'multiline':False]
['text':'       (i32.const 1))','line_number':10032,'multiline':False]
['text':'','line_number':10033,'multiline':False]
['text':' The branch causes neither of the unreachable expressions to be','line_number':10034,'multiline':False]
['text':' evaluated.','line_number':10035,'multiline':False]
['text':' Because params can flow immediately to results in the case of an empty','line_number':10057,'multiline':False]
['text':' "then" or "else" block, and the result of an if/then is a join in','line_number':10058,'multiline':False]
['text':' general, we shuffle params eagerly to the result allocations.','line_number':10059,'multiline':False]
['text':' The parameters to the "if" logically flow to both the "then" and "else"','line_number':10074,'multiline':False]
['text':' blocks, but the "else" block is empty.  Since we know that the "if"','line_number':10075,'multiline':False]
['text':' type-checks, that means that the "else" parameters are the "else" results,','line_number':10076,'multiline':False]
['text':' and that the "if"'s result type is the same as its parameter type.','line_number':10077,'multiline':False]
['text':' "then" arm does not fall through; reset stack.','line_number':10080,'multiline':False]
['text':' Assume we have a control join, so place results in block result','line_number':10088,'multiline':False]
['text':' allocations.','line_number':10089,'multiline':False]
['text':' See comment in endIfThenElse, below.','line_number':10128,'multiline':False]
['text':' Exit the "then" branch.','line_number':10130,'multiline':False]
['text':' Reset to the "else" branch.','line_number':10152,'multiline':False]
['text':' The expression type is not a reliable guide to what we'll find','line_number':10176,'multiline':False]
['text':' on the stack, we could have (if E (i32.const 1) (unreachable))','line_number':10177,'multiline':False]
['text':' in which case the "else" arm is AnyType but the type of the','line_number':10178,'multiline':False]
['text':' full expression is I32.  So restore whatever's there, not what','line_number':10179,'multiline':False]
['text':' we want to find there.  The "then" arm has the same constraint.','line_number':10180,'multiline':False]
['text':' "then" arm does not fall through; reset stack.','line_number':10183,'multiline':False]
['text':' Assume we have a control join, so place results in block result','line_number':10188,'multiline':False]
['text':' allocations.','line_number':10189,'multiline':False]
['text':' No values were provided by the "then" path, but capture the values','line_number':10205,'multiline':False]
['text':' provided by the "else" path.','line_number':10206,'multiline':False]
['text':' This is emitted here after `doReturn` to avoid being executed in the','line_number':10238,'multiline':False]
['text':' normal return path of a function, and instead only when a `delegate`','line_number':10239,'multiline':False]
['text':' jumps to it.','line_number':10240,'multiline':False]
['text':' The end of a loop isn't a branch target, so we can just leave its','line_number':10255,'multiline':False]
['text':' results on the expression stack to be consumed by the outer block.','line_number':10256,'multiline':False]
['text':' Save any values in the designated join registers, as if the target block','line_number':10299,'multiline':False]
['text':' returned normally.','line_number':10300,'multiline':False]
['text':' The registers holding the join values are free for the remainder of this','line_number':10305,'multiline':False]
['text':' block.','line_number':10306,'multiline':False]
['text':' N.B., `branchParams' gets set to the type of the default branch target.  In','line_number':10382,'multiline':False]
['text':' the presence of subtyping, it could be that the different branch targets','line_number':10383,'multiline':False]
['text':' have different types.  Here we rely on the assumption that the value','line_number':10384,'multiline':False]
['text':' representations (e.g. Stk value types) of all branch target types are the','line_number':10385,'multiline':False]
['text':' same, in the baseline compiler.  Notably, this means that all Ref types','line_number':10386,'multiline':False]
['text':' should be represented the same.','line_number':10387,'multiline':False]
['text':' Don't use param registers for rc','line_number':10397,'multiline':False]
['text':' Table switch value always on top.','line_number':10400,'multiline':False]
['text':' This is the out-of-range stub.  rc is dead here but we don't need it.','line_number':10413,'multiline':False]
['text':' Emit stubs.  rc is dead in all of these but we don't need it.','line_number':10420,'multiline':False]
['text':'','line_number':10421,'multiline':False]
['text':' The labels in the vector are in the TempAllocator and will','line_number':10422,'multiline':False]
['text':' be freed by and by.','line_number':10423,'multiline':False]
['text':'','line_number':10424,'multiline':False]
['text':' TODO / OPTIMIZE (Bug 1316804): Branch directly to the case code if we','line_number':10425,'multiline':False]
['text':' can, don't emit an intermediate stub.','line_number':10426,'multiline':False]
['text':' Emit table.','line_number':10442,'multiline':False]
['text':' Emit indirect jump.  rc is live here.','line_number':10447,'multiline':False]
['text':' Clean up.','line_number':10453,'multiline':False]
['text':' Simplifies jumping out, but it is also necessary so that control','line_number':10469,'multiline':False]
['text':' can re-enter the catch handler without restoring registers.','line_number':10470,'multiline':False]
['text':' Be conservative for BCE due to complex control flow in try blocks.','line_number':10477,'multiline':False]
['text':' Mark the beginning of the try block, the rest is filled in by catch.','line_number':10479,'multiline':False]
['text':' Catch ends the try or last catch, so we finish this like endIfThen.','line_number':10488,'multiline':False]
['text':' If the previous block is a catch, we need to handle the extra exception','line_number':10493,'multiline':False]
['text':' reference on the stack (for rethrow) and thus the stack size is 1 more.','line_number':10494,'multiline':False]
['text':' Try jumps to the end of the try-catch block unless a throw is done.','line_number':10497,'multiline':False]
['text':' Reset to this "catch" branch.','line_number':10508,'multiline':False]
['text':' We use the empty result type here because catch does *not* take the','line_number':10511,'multiline':False]
['text':' try-catch block parameters.','line_number':10512,'multiline':False]
['text':' The end of the previous try/catch jumps to the join point.','line_number':10521,'multiline':False]
['text':' Note end of try block for finding the catch block target. This needs','line_number':10524,'multiline':False]
['text':' to happen after the stack is reset to the correct height.','line_number':10525,'multiline':False]
['text':' Construct info used for the exception landing pad.','line_number':10552,'multiline':False]
['text':' Extract the arguments in the exception package and push them.','line_number':10560,'multiline':False]
['text':' The code in the landing pad guarantees us that the exception reference','line_number':10573,'multiline':False]
['text':' is live in this register.','line_number':10574,'multiline':False]
['text':' This reference is pushed onto the stack because a potential rethrow','line_number':10598,'multiline':False]
['text':' may need to access it. It is always popped at the end of the block.','line_number':10599,'multiline':False]
['text':' The ref values have been pushed into the ArrayObject in a stacklike','line_number':10604,'multiline':False]
['text':' fashion so we need to load them starting from the last element.','line_number':10605,'multiline':False]
['text':' TODO/AnyRef-boxing: With boxed immediates and strings, this may need','line_number':10645,'multiline':False]
['text':' to handle other kinds of values.','line_number':10646,'multiline':False]
['text':' The code in the landing pad guarantees us that the exception reference','line_number':10693,'multiline':False]
['text':' is live in this register.','line_number':10694,'multiline':False]
['text':' This reference is pushed onto the stack because a potential rethrow','line_number':10697,'multiline':False]
['text':' may need to access it. It is always popped at the end of the block.','line_number':10698,'multiline':False]
['text':' Only emit a landing pad if a `delegate` has generated a jump to here.','line_number':10707,'multiline':False]
['text':' We can assume this is live because `delegate` received it from a throw.','line_number':10713,'multiline':False]
['text':' End the try branch like a plain catch block without exception ref handling.','line_number':10737,'multiline':False]
['text':' Create an exception landing pad that immediately branches to the landing','line_number':10756,'multiline':False]
['text':' pad of the delegated try block.','line_number':10757,'multiline':False]
['text':' Where the try branch jumps to, if it's not dead.','line_number':10773,'multiline':False]
['text':' If the previous block is a catch, we must handle the extra exception','line_number':10794,'multiline':False]
['text':' reference on the stack (for rethrow) and thus the stack size is 1 more.','line_number':10795,'multiline':False]
['text':' Assume we have a control join, so place results in block result','line_number':10798,'multiline':False]
['text':' allocations and also handle the implicit exception reference if needed.','line_number':10799,'multiline':False]
['text':' Since we will emit a landing pad after this and jump over it to get to','line_number':10806,'multiline':False]
['text':' the control join, we free these here and re-capture at the join.','line_number':10807,'multiline':False]
['text':' Create landing pad for all catch handlers in this block.','line_number':10820,'multiline':False]
['text':' When used for a catchless try block, this will generate a landing pad','line_number':10821,'multiline':False]
['text':' with no handlers and only the fall-back rethrow.','line_number':10822,'multiline':False]
['text':' The stack height also needs to be set not for a block result, but for the','line_number':10825,'multiline':False]
['text':' entry to the exception handlers. This is reset again below for the join.','line_number':10826,'multiline':False]
['text':' If we are in a catchless try block, then there were no catch blocks to','line_number':10835,'multiline':False]
['text':' mark the end of the try note, so we need to end it here.','line_number':10836,'multiline':False]
['text':' Explicitly restore the tls data in case the throw was across instances.','line_number':10844,'multiline':False]
['text':' Make sure that the exception pointer is saved across the call.','line_number':10852,'multiline':False]
['text':' Prevent conflict with exn register when popping this result.','line_number':10861,'multiline':False]
['text':' Ensure that the exception is materialized before branching.','line_number':10866,'multiline':False]
['text':' `catch_all` must be the last clause and we won't call throwFrom','line_number':10878,'multiline':False]
['text':' below due to the catch_all, so we can free exn here.','line_number':10879,'multiline':False]
['text':' If none of the tag checks succeed and there is no catch_all,','line_number':10885,'multiline':False]
['text':' then we rethrow the exception.','line_number':10886,'multiline':False]
['text':' Reset stack height for join.','line_number':10891,'multiline':False]
['text':' Create join point.','line_number':10894,'multiline':False]
['text':' Measure space we need for all the args to put in the exception.','line_number':10921,'multiline':False]
['text':' Create the new exception object that we will throw.','line_number':10929,'multiline':False]
['text':' Create scratch register, to store the exception package values.','line_number':10937,'multiline':False]
['text':' Keep exn on the stack to preserve it across the call.','line_number':10990,'multiline':False]
['text':' Arguments to the instance call start here.','line_number':10995,'multiline':False]
['text':' The call result is checked by the instance call failure handling,','line_number':11003,'multiline':False]
['text':' so we do not need to use the result here.','line_number':11004,'multiline':False]
['text':' Restore scratch register contents that got clobbered.','line_number':11009,'multiline':False]
['text':' Args are deeper on the stack than the stack result area, if any.','line_number':11096,'multiline':False]
['text':' They're deeper than the callee too, for callIndirect.','line_number':11098,'multiline':False]
['text':' The synthetic stack result area pointer.','line_number':11109,'multiline':False]
['text':' In particular, passing |type| as MIRType::Void or MIRType::Pointer to','line_number':11162,'multiline':False]
['text':' this function is an error.','line_number':11163,'multiline':False]
['text':' This method is the only one in the class that can increase stk_.length() by','line_number':11174,'multiline':False]
['text':' an unbounded amount, so it's the only one that requires an allocation.','line_number':11175,'multiline':False]
['text':' (The general case is handled in emitBody.)','line_number':11176,'multiline':False]
['text':' Measure stack results.','line_number':11181,'multiline':False]
['text':' Reserve space for the stack results.','line_number':11191,'multiline':False]
['text':' Push Stk values onto the value stack, and zero out Ref values.','line_number':11195,'multiline':False]
['text':' After a call, some results may be written to the stack result locations that','line_number':11213,'multiline':False]
['text':' are pushed on the machine stack after any stack args.  If there are stack','line_number':11214,'multiline':False]
['text':' args and stack results, these results need to be shuffled down, as the args','line_number':11215,'multiline':False]
['text':' are "consumed" by the call.','line_number':11216,'multiline':False]
['text':' For now, always sync() at the beginning of the call to easily save live','line_number':11232,'multiline':False]
['text':' values.','line_number':11233,'multiline':False]
['text':'','line_number':11234,'multiline':False]
['text':' TODO / OPTIMIZE (Bug 1316806): We may be able to avoid a full sync(), since','line_number':11235,'multiline':False]
['text':' all we want is to save live registers that won't be saved by the callee or','line_number':11236,'multiline':False]
['text':' that we need for outgoing args - we don't need to sync the locals.  We can','line_number':11237,'multiline':False]
['text':' just push the necessary registers, it'll be like a lightweight sync.','line_number':11238,'multiline':False]
['text':'','line_number':11239,'multiline':False]
['text':' Even some of the pushing may be unnecessary if the registers will be consumed','line_number':11240,'multiline':False]
['text':' by the call, because then what we want is parallel assignment to the argument','line_number':11241,'multiline':False]
['text':' registers or onto the stack for outgoing arguments.  A sync() is just','line_number':11242,'multiline':False]
['text':' simpler.','line_number':11243,'multiline':False]
['text':' Stack: ... arg1 .. argn callee','line_number':11322,'multiline':False]
['text':' RABALDR_INT_DIV_I64_CALLOUT','line_number':11462,'multiline':False]
['text':' RABALDR_I64_TO_FLOAT_CALLOUT','line_number':11498,'multiline':False]
['text':' `Callee` always takes a double, so a float32 input must be converted.','line_number':11501,'multiline':False]
['text':' We may need the value after the call for the ool check.','line_number':11515,'multiline':False]
['text':' If we're saturating, the callout will always produce the final result','line_number':11547,'multiline':False]
['text':' value. Otherwise, the callout value will return 0x8000000000000000','line_number':11548,'multiline':False]
['text':' and we need to produce traps.','line_number':11549,'multiline':False]
['text':' The OOL check just succeeds or fails, it does not generate a value.','line_number':11552,'multiline':False]
['text':' RABALDR_FLOAT_TO_I64_CALLOUT','line_number':11569,'multiline':False]
['text':' Local loads are pushed unresolved, ie, they may be deferred','line_number':11581,'multiline':False]
['text':' until needed, until they may be affected by a store, or until a','line_number':11582,'multiline':False]
['text':' sync.  This is intended to reduce register pressure.','line_number':11583,'multiline':False]
['text':' emitBarrieredStore preserves rv','line_number':11860,'multiline':False]
['text':' Bounds check elimination.','line_number':11883,'multiline':False]
['text':'','line_number':11884,'multiline':False]
['text':' We perform BCE on two kinds of address expressions: on constant heap pointers','line_number':11885,'multiline':False]
['text':' that are known to be in the heap or will be handled by the out-of-bounds trap','line_number':11886,'multiline':False]
['text':' handler; and on local variables that have been checked in dominating code','line_number':11887,'multiline':False]
['text':' without being updated since.','line_number':11888,'multiline':False]
['text':'','line_number':11889,'multiline':False]
['text':' For an access through a constant heap pointer + an offset we can eliminate','line_number':11890,'multiline':False]
['text':' the bounds check if the sum of the address and offset is below the sum of the','line_number':11891,'multiline':False]
['text':' minimum memory length and the offset guard length.','line_number':11892,'multiline':False]
['text':'','line_number':11893,'multiline':False]
['text':' For an access through a local variable + an offset we can eliminate the','line_number':11894,'multiline':False]
['text':' bounds check if the local variable has already been checked and has not been','line_number':11895,'multiline':False]
['text':' updated since, and the offset is less than the guard limit.','line_number':11896,'multiline':False]
['text':'','line_number':11897,'multiline':False]
['text':' To track locals for which we can eliminate checks we use a bit vector','line_number':11898,'multiline':False]
['text':' bceSafe_ that has a bit set for those locals whose bounds have been checked','line_number':11899,'multiline':False]
['text':' and which have not subsequently been set.  Initially this vector is zero.','line_number':11900,'multiline':False]
['text':'','line_number':11901,'multiline':False]
['text':' In straight-line code a bit is set when we perform a bounds check on an','line_number':11902,'multiline':False]
['text':' access via the local and is reset when the variable is updated.','line_number':11903,'multiline':False]
['text':'','line_number':11904,'multiline':False]
['text':' In control flow, the bit vector is manipulated as follows.  Each ControlItem','line_number':11905,'multiline':False]
['text':' has a value bceSafeOnEntry, which is the value of bceSafe_ on entry to the','line_number':11906,'multiline':False]
['text':' item, and a value bceSafeOnExit, which is initially ~0.  On a branch (br,','line_number':11907,'multiline':False]
['text':' brIf, brTable), we always AND the branch target's bceSafeOnExit with the','line_number':11908,'multiline':False]
['text':' value of bceSafe_ at the branch point.  On exiting an item by falling out of','line_number':11909,'multiline':False]
['text':' it, provided we're not in dead code, we AND the current value of bceSafe_','line_number':11910,'multiline':False]
['text':' into the item's bceSafeOnExit.  Additional processing depends on the item','line_number':11911,'multiline':False]
['text':' type:','line_number':11912,'multiline':False]
['text':'','line_number':11913,'multiline':False]
['text':'  - After a block, set bceSafe_ to the block's bceSafeOnExit.','line_number':11914,'multiline':False]
['text':'','line_number':11915,'multiline':False]
['text':'  - On loop entry, after pushing the ControlItem, set bceSafe_ to zero; the','line_number':11916,'multiline':False]
['text':'    back edges would otherwise require us to iterate to a fixedpoint.','line_number':11917,'multiline':False]
['text':'','line_number':11918,'multiline':False]
['text':'  - After a loop, the bceSafe_ is left unchanged, because only fallthrough','line_number':11919,'multiline':False]
['text':'    control flow will reach that point and the bceSafe_ value represents the','line_number':11920,'multiline':False]
['text':'    correct state of the fallthrough path.','line_number':11921,'multiline':False]
['text':'','line_number':11922,'multiline':False]
['text':'  - Set bceSafe_ to the ControlItem's bceSafeOnEntry at both the 'then' branch','line_number':11923,'multiline':False]
['text':'    and the 'else' branch.','line_number':11924,'multiline':False]
['text':'','line_number':11925,'multiline':False]
['text':'  - After an if-then-else, set bceSafe_ to the if-then-else's bceSafeOnExit.','line_number':11926,'multiline':False]
['text':'','line_number':11927,'multiline':False]
['text':'  - After an if-then, set bceSafe_ to the if-then's bceSafeOnExit AND'ed with','line_number':11928,'multiline':False]
['text':'    the if-then's bceSafeOnEntry.','line_number':11929,'multiline':False]
['text':'','line_number':11930,'multiline':False]
['text':' Finally, when the debugger allows locals to be mutated we must disable BCE','line_number':11931,'multiline':False]
['text':' for references via a local, by returning immediately from bceCheckLocal if','line_number':11932,'multiline':False]
['text':' compilerEnv_.debugEnabled() is true.','line_number':11933,'multiline':False]
['text':'','line_number':11934,'multiline':False]
['text':'','line_number':11935,'multiline':False]
['text':' Alignment check elimination.','line_number':11936,'multiline':False]
['text':'','line_number':11937,'multiline':False]
['text':' Alignment checks for atomic operations can be omitted if the pointer is a','line_number':11938,'multiline':False]
['text':' constant and the pointer + offset is aligned.  Alignment checking that can't','line_number':11939,'multiline':False]
['text':' be omitted can still be simplified by checking only the pointer if the offset','line_number':11940,'multiline':False]
['text':' is aligned.','line_number':11941,'multiline':False]
['text':'','line_number':11942,'multiline':False]
['text':' (In addition, alignment checking of the pointer can be omitted if the pointer','line_number':11943,'multiline':False]
['text':' has been checked in dominating code, but we don't do that yet.)','line_number':11944,'multiline':False]
['text':' TODO / OPTIMIZE (bug 1329576): There are opportunities to generate better','line_number':11946,'multiline':False]
['text':' code by not moving a constant address with a zero offset into a register.','line_number':11947,'multiline':False]
['text':' Fold the offset into the pointer if we can, as this is always','line_number':11967,'multiline':False]
['text':' beneficial.','line_number':11968,'multiline':False]
['text':' I32 condition on top, then false, then true.','line_number':12235,'multiline':False]
['text':' There may be as many as four Int64 values in registers at a time: two','line_number':12256,'multiline':False]
['text':' for the latent branch operands, and two for the true/false values we','line_number':12257,'multiline':False]
['text':' normally pop before executing the branch.  On x86 this is one value','line_number':12258,'multiline':False]
['text':' too many, so we need to generate more complicated code here, and for','line_number':12259,'multiline':False]
['text':' simplicity's sake we do so even if the branch operands are not Int64.','line_number':12260,'multiline':False]
['text':' However, the resulting control flow diamond is complicated since the','line_number':12261,'multiline':False]
['text':' arms of the diamond will have to stay synchronized with respect to','line_number':12262,'multiline':False]
['text':' their evaluation stack and regalloc state.  To simplify further, we','line_number':12263,'multiline':False]
['text':' use a double branch and a temporary boolean value for now.','line_number':12264,'multiline':False]
['text':' instance ','line_number':12454,'multiline':True]
['text':' Instance function args can now be uninterpreted pointers (eg, for','line_number':12476,'multiline':False]
['text':' the cases PostBarrier and PostBarrierFilter) so we simply treat','line_number':12477,'multiline':False]
['text':' them like the equivalently sized integer.','line_number':12478,'multiline':False]
['text':' Note, many clients of emitInstanceCall currently assume that pushing the','line_number':12496,'multiline':False]
['text':' result here does not destroy ReturnReg.','line_number':12497,'multiline':False]
['text':'','line_number':12498,'multiline':False]
['text':' Furthermore, clients assume that if builtin.retType != MIRType::None, the','line_number':12499,'multiline':False]
['text':' callee will have returned a result and left it in ReturnReg for us to','line_number':12500,'multiline':False]
['text':' find, and that that register will not be destroyed here (or above).','line_number':12501,'multiline':False]
['text':' For the return type only, MIRType::None is used to indicate that the','line_number':12503,'multiline':False]
['text':' call doesn't return a result, that is, returns a C/C++ "void".','line_number':12504,'multiline':False]
['text':' JS_64BIT','line_number':12691,'multiline':False]
['text':' Compute the number of copies of each width we will need to do','line_number':12991,'multiline':False]
['text':' Load all source bytes onto the value stack from low to high using the','line_number':13003,'multiline':False]
['text':' widest transfer width we can for the system. We will trap without writing','line_number':13004,'multiline':False]
['text':' anything if any source byte is out-of-bounds.','line_number':13005,'multiline':False]
['text':' Store all source bytes from the value stack to the destination from','line_number':13072,'multiline':False]
['text':' high to low. We will trap without writing anything on the first store','line_number':13073,'multiline':False]
['text':' if any dest byte is out-of-bounds.','line_number':13074,'multiline':False]
['text':' Compute the number of copies of each width we will need to do','line_number':13229,'multiline':False]
['text':' Generate splatted definitions for wider fills as needed','line_number':13243,'multiline':False]
['text':' Store the fill value to the destination from high to low. We will trap','line_number':13251,'multiline':False]
['text':' without writing anything on the first store if any dest byte is','line_number':13252,'multiline':False]
['text':' out-of-bounds.','line_number':13253,'multiline':False]
['text':'isMem','line_number':13339,'multiline':True]
['text':'isMem','line_number':13350,'multiline':True]
['text':' fill(start:u32, val:ref, len:u32, table:u32) -> void','line_number':13357,'multiline':False]
['text':' get(index:u32, table:u32) -> AnyRef','line_number':13366,'multiline':False]
['text':' grow(initValue:anyref, delta:u32, table:u32) -> u32','line_number':13375,'multiline':False]
['text':' set(index:u32, value:ref, table:u32) -> void','line_number':13384,'multiline':False]
['text':' size(table:u32) -> u32','line_number':13393,'multiline':False]
['text':' An array is always an outline typed object','line_number':13409,'multiline':False]
['text':' Easy path if the field is a scalar','line_number':13552,'multiline':False]
['text':' Create temporary for the valueAddr that is not in the prebarrier register','line_number':13559,'multiline':False]
['text':' and can be consumed by the barrier operation','line_number':13560,'multiline':False]
['text':' Save state for after barriered write','line_number':13565,'multiline':False]
['text':' emitBarrieredStore preserves object and value','line_number':13568,'multiline':False]
['text':' Restore state','line_number':13574,'multiline':False]
['text':' Try to use a base index store instruction if the field type fits in a','line_number':13582,'multiline':False]
['text':' shift immediate. If not we shift the index manually and then unshift','line_number':13583,'multiline':False]
['text':' it after the store. We don't use an extra register for this because we','line_number':13584,'multiline':False]
['text':' don't have any to spare on x86.','line_number':13585,'multiline':False]
['text':' Easy path if the field is a scalar','line_number':13602,'multiline':False]
['text':' Create temporaries for valueAddr that is not in the prebarrier register','line_number':13609,'multiline':False]
['text':' and can be consumed by the barrier operation','line_number':13610,'multiline':False]
['text':' Save state for after barriered write','line_number':13615,'multiline':False]
['text':' emitBarrieredStore preserves object and value','line_number':13619,'multiline':False]
['text':' Restore state','line_number':13624,'multiline':False]
['text':' Allocate zeroed storage.  The parameter to StructNew is a rtt value that is','line_number':13647,'multiline':False]
['text':' guaranteed to be at the top of the stack by validation.','line_number':13648,'multiline':False]
['text':'','line_number':13649,'multiline':False]
['text':' Traps on OOM.','line_number':13650,'multiline':False]
['text':' Optimization opportunity: Iterate backward to pop arguments off the','line_number':13655,'multiline':False]
['text':' stack.  This will generate more instructions than we want, since we','line_number':13656,'multiline':False]
['text':' really only need to pop the stack once at the end, not for every element,','line_number':13657,'multiline':False]
['text':' but to do better we need a bit more machinery to load elements off the','line_number':13658,'multiline':False]
['text':' stack into registers.','line_number':13659,'multiline':False]
['text':' Reserve this register early if we will need it so that it is not taken by','line_number':13661,'multiline':False]
['text':' any register used in this function.','line_number':13662,'multiline':False]
['text':' Free the barrier reg after we've allocated all registers','line_number':13668,'multiline':False]
['text':' The struct allocated above is guaranteed to have the exact shape of','line_number':13671,'multiline':False]
['text':' structType, we don't need to branch on whether it's inline or not.','line_number':13672,'multiline':False]
['text':' Optimization opportunity: when the value being stored is a known','line_number':13680,'multiline':False]
['text':' zero/null we need store nothing.  This case may be somewhat common','line_number':13681,'multiline':False]
['text':' because struct.new forces a value to be specified for every field.','line_number':13682,'multiline':False]
['text':' Reserve the barrier reg if we might need it for this store','line_number':13687,'multiline':False]
['text':' Free the barrier reg now that we've loaded the value','line_number':13694,'multiline':False]
['text':' Consumes value. rp, and rdata are preserved','line_number':13699,'multiline':False]
['text':' Allocate zeroed storage.  The parameter to StructNew is a rtt value that is','line_number':13712,'multiline':False]
['text':' guaranteed to be at the top of the stack by validation.','line_number':13713,'multiline':False]
['text':'','line_number':13714,'multiline':False]
['text':' Traps on OOM.','line_number':13715,'multiline':False]
['text':' (rtt) -> ref; the type index is just dropped on the floor','line_number':13717,'multiline':False]
['text':' Check for null','line_number':13741,'multiline':False]
['text':' Acquire the data pointer from the object','line_number':13744,'multiline':False]
['text':' Load the value','line_number':13766,'multiline':False]
['text':' Reserve this register early if we will need it so that it is not taken by','line_number':13792,'multiline':False]
['text':' any register used in this function.','line_number':13793,'multiline':False]
['text':' Free the barrier reg after we've allocated all registers','line_number':13802,'multiline':False]
['text':' Check for null','line_number':13807,'multiline':False]
['text':' Acquire the data pointer from the object.','line_number':13810,'multiline':False]
['text':' We don't have a register to spare at this point on x86, so carefully','line_number':13812,'multiline':False]
['text':' borrow the `rdata` as a scratch pointer during the instruction sequence','line_number':13813,'multiline':False]
['text':' that loads `rdata`.','line_number':13814,'multiline':False]
['text':' Consumes value. rp, and rdata are preserved','line_number':13832,'multiline':False]
['text':' Allocate zeroed storage.  The parameter to ArrayNew is a rtt value and','line_number':13858,'multiline':False]
['text':' length that are guaranteed to be at the top of the stack by validation.','line_number':13859,'multiline':False]
['text':'','line_number':13860,'multiline':False]
['text':' Traps on OOM.','line_number':13861,'multiline':False]
['text':' Reserve this register early if we will need it so that it is not taken by','line_number':13866,'multiline':False]
['text':' any register used in this function.','line_number':13867,'multiline':False]
['text':' Acquire the data pointers from the object','line_number':13875,'multiline':False]
['text':' Acquire the array length and adjust the data pointer to be immediately','line_number':13878,'multiline':False]
['text':' after the array length header','line_number':13879,'multiline':False]
['text':' Free the barrier reg after we've allocated all registers','line_number':13882,'multiline':False]
['text':' Perform an initialization loop using `length` as the loop variable,','line_number':13887,'multiline':False]
['text':' counting down to zero.','line_number':13888,'multiline':False]
['text':' Skip initialization if length = 0','line_number':13891,'multiline':False]
['text':' Move to the next element','line_number':13895,'multiline':False]
['text':' Assign value to array[length]. All registers are preserved','line_number':13898,'multiline':False]
['text':' Loop back if there are still elements to initialize','line_number':13903,'multiline':False]
['text':' Allocate zeroed storage. The parameter to ArrayNew is a rtt value that is','line_number':13916,'multiline':False]
['text':' guaranteed to be at the top of the stack by validation.','line_number':13917,'multiline':False]
['text':'','line_number':13918,'multiline':False]
['text':' Traps on OOM.','line_number':13919,'multiline':False]
['text':' (rtt) -> ref; the type index is dropped on the floor.','line_number':13921,'multiline':False]
['text':' Check for null','line_number':13946,'multiline':False]
['text':' Acquire the data pointer from the object','line_number':13949,'multiline':False]
['text':' Acquire the array length and adjust the data pointer to be immediately','line_number':13952,'multiline':False]
['text':' after the array length header','line_number':13953,'multiline':False]
['text':' Bounds check the index','line_number':13956,'multiline':False]
['text':' Load the value','line_number':13960,'multiline':False]
['text':' Reserve this register early if we will need it so that it is not taken by','line_number':13991,'multiline':False]
['text':' any register used in this function.','line_number':13992,'multiline':False]
['text':' We run out of registers on x86 with this instruction, so stash `value` on','line_number':14001,'multiline':False]
['text':' the stack until it is needed later.','line_number':14002,'multiline':False]
['text':' Check for null','line_number':14005,'multiline':False]
['text':' Acquire the data pointer from the object','line_number':14008,'multiline':False]
['text':' Acquire the array length and adjust the data pointer to be immediately','line_number':14011,'multiline':False]
['text':' after the array length header','line_number':14012,'multiline':False]
['text':' Free the barrier reg after we've allocated all registers','line_number':14015,'multiline':False]
['text':' Bounds check the index','line_number':14020,'multiline':False]
['text':' Pull the value out of the stack now that we need it.','line_number':14024,'multiline':False]
['text':' All registers are preserved. This isn't strictly necessary, as we'll just','line_number':14027,'multiline':False]
['text':' be freeing them all after this is done. But this is needed for repeated','line_number':14028,'multiline':False]
['text':' assignments used in array.new/new_default.','line_number':14029,'multiline':False]
['text':' Check for null','line_number':14055,'multiline':False]
['text':' Acquire the data pointer from the object','line_number':14058,'multiline':False]
['text':' Acquire the length from the array','line_number':14062,'multiline':False]
['text':' rttSub builtin has same signature as rtt.sub instruction, stack is','line_number':14088,'multiline':False]
['text':' guaranteed to be in the right condition due to validation.','line_number':14089,'multiline':False]
['text':' refTest builtin has same signature as ref.test instruction, stack is','line_number':14097,'multiline':False]
['text':' guaranteed to be in the right condition due to validation.','line_number':14098,'multiline':False]
['text':' 1. duplicate and shuffle from [ref, rtt] to [ref, ref, rtt]','line_number':14125,'multiline':False]
['text':' 2. ref.test : [ref, rtt] -> [i32]','line_number':14132,'multiline':False]
['text':' 3. trap if result is zero, leaving [ref] as result','line_number':14137,'multiline':False]
['text':' 1. duplicate and shuffle from [T*, ref, rtt] to [T*, ref, ref, rtt]','line_number':14173,'multiline':False]
['text':' 2. ref.test : [ref, rtt] -> [i32]','line_number':14180,'multiline':False]
['text':' 3. br_if $l : [T*, ref, i32] -> [T*, ref]','line_number':14185,'multiline':False]
['text':' Emitter trampolines used by abstracted SIMD operations.  Naming here follows','line_number':14206,'multiline':False]
['text':' the SIMD spec pretty closely.','line_number':14207,'multiline':False]
['text':' JS_CODEGEN_X86 || JS_CODEGEN_X64','line_number':14503,'multiline':False]
['text':' JS_CODEGEN_ARM64','line_number':14858,'multiline':False]
['text':' This is the same op independent of lanes: it tests for any nonzero bit.','line_number':14970,'multiline':False]
['text':' JS_CODEGEN_ARM64','line_number':15054,'multiline':False]
['text':' Bitselect: rs1: ifTrue, rs2: ifFalse, rs3: control','line_number':15082,'multiline':False]
['text':' On x86, certain register assignments will result in more compact code: we','line_number':15086,'multiline':False]
['text':' want output=rs1 and tmp=rs3.  Attend to this after we see what other','line_number':15087,'multiline':False]
['text':' platforms want/need.','line_number':15088,'multiline':False]
['text':' Distinguished tmp, for now','line_number':15089,'multiline':False]
['text':' We want x & ~y but the available operation is ~x & y, so reverse the','line_number':15103,'multiline':False]
['text':' operands.','line_number':15104,'multiline':False]
['text':' We can implement loadSplat mostly as load + splat because the push of the','line_number':15113,'multiline':False]
['text':' result onto the value stack in loadCommon normally will not generate any','line_number':15114,'multiline':False]
['text':' code, it will leave the value in a register which we will consume.','line_number':15115,'multiline':False]
['text':' We use uint types when we can on the general assumption that unsigned loads','line_number':15126,'multiline':False]
['text':' might be smaller/faster on some platforms, because no sign extension needs','line_number':15127,'multiline':False]
['text':' to be done after the sub-register load.','line_number':15128,'multiline':False]
['text':' LoadZero has the structure of LoadSplat','line_number':15163,'multiline':False]
['text':' Control','line_number':15353,'multiline':False]
['text':' 'false' vector','line_number':15354,'multiline':False]
['text':' 'true' vector','line_number':15355,'multiline':False]
['text':' ENABLE_WASM_SIMD','line_number':15449,'multiline':False]
['text':' Check that the number of ref-typed entries in the operand stack matches','line_number':15551,'multiline':False]
['text':' reality.','line_number':15552,'multiline':False]
['text':' Opcodes that push more than MaxPushesPerOpcode (anything with multiple','line_number':15577,'multiline':False]
['text':' results) will perform additional reservation.','line_number':15578,'multiline':False]
['text':' When compilerEnv_.debugEnabled(), every operator has a breakpoint site','line_number':15584,'multiline':False]
['text':' except Op::End.','line_number':15585,'multiline':False]
['text':' TODO sync only registers that can be clobbered by the exit','line_number':15587,'multiline':False]
['text':' prologue/epilogue or disable these registers for use in','line_number':15588,'multiline':False]
['text':' baseline compiler when compilerEnv_.debugEnabled() is set.','line_number':15589,'multiline':False]
['text':' Going below framePushedAtEntryToBody would imply that we've','line_number':15598,'multiline':False]
['text':' popped off the machine stack, part of the frame created by','line_number':15599,'multiline':False]
['text':' beginFunction().','line_number':15600,'multiline':False]
['text':' At this point we're definitely not generating code for a function call.','line_number':15604,'multiline':False]
['text':' Control opcodes','line_number':15618,'multiline':False]
['text':' Calls','line_number':15681,'multiline':False]
['text':' Locals and globals','line_number':15687,'multiline':False]
['text':' Select','line_number':15703,'multiline':False]
['text':'typed','line_number':15705,'multiline':True]
['text':'typed','line_number':15707,'multiline':True]
['text':' I32','line_number':15709,'multiline':False]
['text':' I64','line_number':15799,'multiline':False]
['text':' F32','line_number':15944,'multiline':False]
['text':' F64','line_number':16020,'multiline':False]
['text':' Comparisons','line_number':16096,'multiline':False]
['text':' Sign extensions','line_number':16194,'multiline':False]
['text':' Memory Related','line_number':16211,'multiline':False]
['text':' "GC" operations','line_number':16248,'multiline':False]
['text':' switch (op.b1)','line_number':16292,'multiline':False]
['text':' SIMD operations','line_number':16298,'multiline':False]
['text':' switch (op.b1)','line_number':16817,'multiline':False]
['text':' ENABLE_WASM_SIMD','line_number':16820,'multiline':False]
['text':' "Miscellaneous" operations','line_number':16822,'multiline':False]
['text':'isData=','line_number':16888,'multiline':True]
['text':'isData=','line_number':16896,'multiline':True]
['text':' switch (op.b1)','line_number':16907,'multiline':False]
['text':' Thread operations','line_number':16911,'multiline':False]
['text':' Though thread ops can be used on nonshared memories, we make them','line_number':16913,'multiline':False]
['text':' unavailable if shared memory has been disabled in the prefs, for','line_number':16914,'multiline':False]
['text':' maximum predictability and safety and consistency with JS.','line_number':16915,'multiline':False]
['text':' asm.js and other private operations','line_number':17106,'multiline':False]
['text':' Our caller, BaselineCompileFunctions, will lend us the vector contents to','line_number':17187,'multiline':False]
['text':' use for the eval stack.  To get hold of those contents, we'll temporarily','line_number':17188,'multiline':False]
['text':' installing an empty one in its place.','line_number':17189,'multiline':False]
['text':' Assuming that previously processed wasm functions are well formed, the','line_number':17193,'multiline':False]
['text':' eval stack should now be empty.  But empty it anyway; any non-emptyness','line_number':17194,'multiline':False]
['text':' at this point will cause chaos.','line_number':17195,'multiline':False]
['text':' We've returned the eval stack vector contents to our caller,','line_number':17201,'multiline':False]
['text':' BaselineCompileFunctions.  We expect the vector we get in return to be','line_number':17202,'multiline':False]
['text':' empty since that's what we swapped for the stack vector in our','line_number':17203,'multiline':False]
['text':' constructor.','line_number':17204,'multiline':False]
['text':' namespace wasm','line_number':17235,'multiline':False]
['text':' namespace js','line_number':17236,'multiline':False]
['text':' Simplifying assumption: require SDIV and UDIV.','line_number':17240,'multiline':False]
['text':'','line_number':17241,'multiline':False]
['text':' I have no good data on ARM populations allowing me to say that','line_number':17242,'multiline':False]
['text':' X% of devices in the market implement SDIV and UDIV.  However,','line_number':17243,'multiline':False]
['text':' they are definitely implemented on the Cortex-A7 and Cortex-A15','line_number':17244,'multiline':False]
['text':' and on all ARMv8 systems.','line_number':17245,'multiline':False]
['text':' The MacroAssembler will sometimes access the jitContext.','line_number':17268,'multiline':False]
['text':' Swap in already-allocated empty vectors to avoid malloc/free.','line_number':17275,'multiline':False]
['text':' Create a description of the stack layout created by GenerateTrapExit().','line_number':17281,'multiline':False]
['text':' The compiler's operand stack.  We reuse it across all functions so as to','line_number':17286,'multiline':False]
['text':' avoid malloc/free.  Presize it to 128 elements in the hope of avoiding','line_number':17287,'multiline':False]
['text':' reallocation later.','line_number':17288,'multiline':False]
['text':' Build the local types vector.','line_number':17297,'multiline':False]
['text':' One-pass baseline compilation.','line_number':17307,'multiline':False]
