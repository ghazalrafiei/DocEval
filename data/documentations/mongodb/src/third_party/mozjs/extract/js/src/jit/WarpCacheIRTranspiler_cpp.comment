['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' js::Scalar::Type','line_number':26,'multiline':False]
['text':' The CacheIR transpiler generates MIR from Baseline CacheIR.','line_number':36,'multiline':False]
['text':' Vector mapping OperandId to corresponding MDefinition.','line_number':43,'multiline':False]
['text':' Array mapping call arguments to OperandId.','line_number':49,'multiline':False]
['text':' Used to assert that there is only one effectful instruction','line_number':63,'multiline':False]
['text':' per stub. And that this instruction has a resume point.','line_number':64,'multiline':False]
['text':' If we have not set a more specific bailout kind, mark this instruction','line_number':72,'multiline':False]
['text':' as transpiled CacheIR. If one of these instructions bails out, we','line_number':73,'multiline':False]
['text':' expect to hit the baseline fallback stub and invalidate the Warp script','line_number':74,'multiline':False]
['text':' in tryAttach.','line_number':75,'multiline':False]
['text':' Bypasses all checks in addEffectful. Only used for testing functions.','line_number':95,'multiline':False]
['text':' CacheIR instructions writing to the IC's result register (the *Result','line_number':109,'multiline':False]
['text':' instructions) must call this to push the result onto the virtual stack.','line_number':110,'multiline':False]
['text':' This must only be called when the caller knows the object is tenured and','line_number':183,'multiline':False]
['text':' not a nursery index.','line_number':184,'multiline':False]
['text':' Returns either MConstant or MNurseryIndex. See WarpObjectField.','line_number':190,'multiline':False]
['text':' Calls are either Native (native function without a JitEntry),','line_number':245,'multiline':False]
['text':' a DOM Native (native function with a JitInfo OpType::Method),','line_number':246,'multiline':False]
['text':' or Scripted (scripted function or native function with a JitEntry).','line_number':247,'multiline':False]
['text':' Effectful instructions should have a resume point. MIonToWasmCall is an','line_number':317,'multiline':False]
['text':' exception: we can attach the resume point to the MInt64ToBigInt instruction','line_number':318,'multiline':False]
['text':' instead.','line_number':319,'multiline':False]
['text':' TODO(post-Warp): realms, guard operands (movable?).','line_number':552,'multiline':False]
['text':' bailOnEquality = ','line_number':748,'multiline':True]
['text':' bailOnEquality = ','line_number':824,'multiline':True]
['text':'isConstructing=','line_number':921,'multiline':True]
['text':'bailOnEquality=','line_number':960,'multiline':True]
['text':' Prefer MToDouble because it gets further optimizations downstream.','line_number':1069,'multiline':False]
['text':' MIRType::Double also implies int32 in Ion.','line_number':1079,'multiline':False]
['text':' ToPropertyKey(-0) is "0", so we can silently convert -0 to 0 here.','line_number':1190,'multiline':False]
['text':' Use a separate instruction for converting the length to Int32, so that we','line_number':1608,'multiline':False]
['text':' can fold the MArrayBufferViewLength instruction with length instructions','line_number':1609,'multiline':False]
['text':' added for bounds checks.','line_number':1610,'multiline':False]
['text':' Use a separate MIR instruction for the index masking. Doing this as','line_number':1656,'multiline':False]
['text':' part of MBoundsCheck would be unsound because bounds checks can be','line_number':1657,'multiline':False]
['text':' optimized or eliminated completely. Consider this:','line_number':1658,'multiline':False]
['text':'','line_number':1659,'multiline':False]
['text':'   for (var i = 0; i < x; i++)','line_number':1660,'multiline':False]
['text':'        res = arr[i];','line_number':1661,'multiline':False]
['text':'','line_number':1662,'multiline':False]
['text':' If we can prove |x < arr.length|, we are able to eliminate the bounds','line_number':1663,'multiline':False]
['text':' check, but we should not get rid of the index masking because the','line_number':1664,'multiline':False]
['text':' |i < x| branch could still be mispredicted.','line_number':1665,'multiline':False]
['text':'','line_number':1666,'multiline':False]
['text':' Using a separate instruction lets us eliminate the bounds check','line_number':1667,'multiline':False]
['text':' without affecting the index masking.','line_number':1668,'multiline':False]
['text':' Get the elements vector.','line_number':1746,'multiline':False]
['text':' Check if id < initLength.','line_number':1753,'multiline':False]
['text':' And check elem[id] is not a hole.','line_number':1756,'multiline':False]
['text':' Get the elements vector.','line_number':1769,'multiline':False]
['text':' Check if id < initLength and elem[id] not a hole.','line_number':1776,'multiline':False]
['text':' Unsigned comparison to catch negative indices.','line_number':1804,'multiline':False]
['text':' TODO(post-Warp): Consider changing MStoreElementHole to match IC code.','line_number':2092,'multiline':False]
['text':' MStoreTypedArrayElementHole does the bounds checking.','line_number':2127,'multiline':False]
['text':' Adjust the length to account for accesses near the end of the dataview.','line_number':2152,'multiline':False]
['text':' To ensure |0 <= offset && offset + byteSize <= length|, first adjust the','line_number':2154,'multiline':False]
['text':' length by subtracting |byteSize - 1| (bailing out if that becomes','line_number':2155,'multiline':False]
['text':' negative).','line_number':2156,'multiline':False]
['text':' Add bounds check and get the DataViewObject's elements.','line_number':2175,'multiline':False]
['text':' Load the element.','line_number':2179,'multiline':False]
['text':' Add bounds check and get the DataViewObject's elements.','line_number':2205,'multiline':False]
['text':' Store the element.','line_number':2209,'multiline':False]
['text':' A previously emitted guard ensures that one side of the comparison','line_number':2639,'multiline':False]
['text':' is null or undefined.','line_number':2640,'multiline':False]
['text':' CodeGenerator uses CompileRealm::addressOfRandomNumberGenerator. Assert it','line_number':2756,'multiline':False]
['text':' matches the RNG pointer stored in the stub field.','line_number':2757,'multiline':False]
['text':' TODO: support pre-tenuring.','line_number':3106,'multiline':False]
['text':' Convert to bool with the '!!' idiom.','line_number':3171,'multiline':False]
['text':' TODO: support pre-tenuring.','line_number':3539,'multiline':False]
['text':' TODO: support pre-tenuring.','line_number':3554,'multiline':False]
['text':' TODO: support pre-tenuring.','line_number':3591,'multiline':False]
['text':' TODO: support pre-tenuring.','line_number':3621,'multiline':False]
['text':' TODO: support pre-tenuring.','line_number':3637,'multiline':False]
['text':' When we transpile a call, we may generate guards for some','line_number':3923,'multiline':False]
['text':' arguments.  To make sure the call instruction depends on those','line_number':3924,'multiline':False]
['text':' guards, when the transpiler creates an operand for an argument, we','line_number':3925,'multiline':False]
['text':' register the OperandId of that argument in argumentIds_. (See','line_number':3926,'multiline':False]
['text':' emitLoadArgumentSlot.) Before generating the call, we update the','line_number':3927,'multiline':False]
['text':' CallInfo to use the appropriate value from operands_.','line_number':3928,'multiline':False]
['text':' Note: The callee is an explicit argument to the call op, and is','line_number':3929,'multiline':False]
['text':' tracked separately.','line_number':3930,'multiline':False]
['text':' Reverse of GetIndexOfArgument.','line_number':3977,'multiline':False]
['text':' Layout:','line_number':3979,'multiline':False]
['text':' NewTarget | Args.. (reversed)      | ThisValue | Callee','line_number':3980,'multiline':False]
['text':' 0         | ArgC .. Arg1 Arg0 (+1) | argc (+1) | argc + 1 (+ 1)','line_number':3981,'multiline':False]
['text':' ^ (if constructing)','line_number':3982,'multiline':False]
['text':' NewTarget (optional)','line_number':3984,'multiline':False]
['text':' Adjust slot index to match non-constructing calls.','line_number':3991,'multiline':False]
['text':' Args..','line_number':3994,'multiline':False]
['text':' ThisValue','line_number':4003,'multiline':False]
['text':' Callee','line_number':4009,'multiline':False]
['text':' If this is a native without a JitEntry, WrappedFunction needs to know the','line_number':4035,'multiline':False]
['text':' target JSFunction.','line_number':4036,'multiline':False]
['text':' TODO: support nursery-allocated natives with WrappedFunction, maybe by','line_number':4037,'multiline':False]
['text':' storing the JSNative in the Baseline stub like flags/nargs.','line_number':4038,'multiline':False]
['text':' CacheIR emits the following for specialized calls:','line_number':4059,'multiline':False]
['text':'     GuardSpecificFunction <callee> <func> ..','line_number':4060,'multiline':False]
['text':'     Call(Native|Scripted)Function <callee> ..','line_number':4061,'multiline':False]
['text':' or:','line_number':4062,'multiline':False]
['text':'     GuardClass <callee> ..','line_number':4063,'multiline':False]
['text':'     GuardFunctionScript <callee> <script> ..','line_number':4064,'multiline':False]
['text':'     CallScriptedFunction <callee> ..','line_number':4065,'multiline':False]
['text':'','line_number':4066,'multiline':False]
['text':' We can use the <func> JSFunction or <script> BaseScript to specialize this','line_number':4067,'multiline':False]
['text':' call.','line_number':4068,'multiline':False]
['text':' nativeFun = ','line_number':4078,'multiline':True]
['text':' If it is possible to use MCall for this call, update callInfo_ to use','line_number':4085,'multiline':False]
['text':' the correct arguments. Otherwise, update the ArgFormat of callInfo_.','line_number':4086,'multiline':False]
['text':' The transpilation will add various guards to the callee.','line_number':4089,'multiline':False]
['text':' We replace the callee referenced by the CallInfo, so that','line_number':4090,'multiline':False]
['text':' the resulting call instruction depends on these guards.','line_number':4091,'multiline':False]
['text':' The transpilation may also add guards to other arguments.','line_number':4094,'multiline':False]
['text':' We replace those arguments in the CallInfo here.','line_number':4095,'multiline':False]
['text':' Note: We already changed the callee to the target','line_number':4106,'multiline':False]
['text':' function instead of the |call| function.','line_number':4107,'multiline':False]
['text':' Special case for fun.call() with no arguments.','line_number':4112,'multiline':False]
['text':' The first argument for |call| is the new this value.','line_number':4116,'multiline':False]
['text':' Shift down all other arguments by removing the first.','line_number':4119,'multiline':False]
['text':' Returns true if we are generating a call to CreateThisFromIon and','line_number':4143,'multiline':False]
['text':' must check its return value.','line_number':4144,'multiline':False]
['text':' Native functions keep the is-constructing MagicValue as |this|.','line_number':4151,'multiline':False]
['text':' If one of the arguments uses spread syntax this can be a loop phi with','line_number':4152,'multiline':False]
['text':' MIRType::Value.','line_number':4153,'multiline':False]
['text':' We have already updated |this| based on MetaTwoByte. We do','line_number':4161,'multiline':False]
['text':' not need to generate a check.','line_number':4162,'multiline':False]
['text':' See the Native case above.','line_number':4171,'multiline':False]
['text':' For DOM calls |this| has a class guard.','line_number':4201,'multiline':False]
['text':' Instead of ignoresReturnValue we use CallInfo::ignoresReturnValue.','line_number':4287,'multiline':False]
['text':' We are transpiling to generate the correct guards. We also','line_number':4330,'multiline':False]
['text':' update the CallInfo to use the correct arguments. Code for the','line_number':4331,'multiline':False]
['text':' inlined function itself will be generated in','line_number':4332,'multiline':False]
['text':' WarpBuilder::buildInlinedCall.','line_number':4333,'multiline':False]
['text':' We call maybeCreateThis to update |this|, but inlined constructors','line_number':4341,'multiline':False]
['text':' never need a VM call. CallIRGenerator::getThisForScripted ensures that','line_number':4342,'multiline':False]
['text':' we don't attach a specialized stub unless we have a template object or','line_number':4343,'multiline':False]
['text':' know that the constructor needs uninitialized this.','line_number':4344,'multiline':False]
['text':' Add any post-function call conversions that are necessary.','line_number':4414,'multiline':False]
['text':' No results to convert.','line_number':4419,'multiline':False]
['text':' JS expects a BigInt from I64 types.','line_number':4423,'multiline':False]
['text':' Make non-movable so we can attach a resume point.','line_number':4426,'multiline':False]
['text':' No spectre.index_masking of i32 results required, as the generated','line_number':4432,'multiline':False]
['text':' stub takes care of that.','line_number':4433,'multiline':False]
['text':' The resume point has to be attached to the post-conversion instruction','line_number':4438,'multiline':False]
['text':' (if present) instead of to the call. This way, if the call triggers an','line_number':4439,'multiline':False]
['text':' invalidation bailout, we will have the BigInt value on the Baseline stack.','line_number':4440,'multiline':False]
['text':' Potential alternative solution: attach the resume point to the call and','line_number':4441,'multiline':False]
['text':' have bailouts turn the Int64 value into a BigInt, maybe with a recover','line_number':4442,'multiline':False]
['text':' instruction.','line_number':4443,'multiline':False]
['text':' An invariant in this code is that any type conversion operation that has','line_number':4450,'multiline':False]
['text':' externally visible effects, such as invoking valueOf on an object argument,','line_number':4451,'multiline':False]
['text':' must bailout so that we don't have to worry about replaying effects during','line_number':4452,'multiline':False]
['text':' argument conversion.','line_number':4453,'multiline':False]
['text':' Transform the JS representation into an AnyRef representation.','line_number':4472,'multiline':False]
['text':' The resulting type is MIRType::RefOrNull.  These cases are all','line_number':4473,'multiline':False]
['text':' effect-free.','line_number':4474,'multiline':False]
['text':' constructing = ','line_number':4518,'multiline':True]
['text':' needsThisCheck = ','line_number':4521,'multiline':True]
['text':' We are transpiling to generate the correct guards. We also update the','line_number':4548,'multiline':False]
['text':' CallInfo to use the correct arguments. Code for the inlined getter','line_number':4549,'multiline':False]
['text':' itself will be generated in WarpBuilder::buildInlinedCall.','line_number':4550,'multiline':False]
['text':' Make sure there's enough room to push the arguments on the stack.','line_number':4555,'multiline':False]
['text':' constructing = ','line_number':4589,'multiline':True]
['text':' ignoresReturnValue = ','line_number':4590,'multiline':True]
['text':' needsThisCheck = ','line_number':4593,'multiline':True]
['text':' We are transpiling to generate the correct guards. We also update the','line_number':4618,'multiline':False]
['text':' CallInfo to use the correct arguments. Code for the inlined setter','line_number':4619,'multiline':False]
['text':' itself will be generated in WarpBuilder::buildInlinedCall.','line_number':4620,'multiline':False]
['text':' Make sure there's enough room to push the arguments on the stack.','line_number':4626,'multiline':False]
['text':' TODO(post-Warp): rename the MetaTwoByte op when IonBuilder is gone.','line_number':4647,'multiline':False]
['text':' TODO: support pre-tenuring.','line_number':4653,'multiline':False]
['text':' Don't assert for recovered instructions when recovering is disabled.','line_number':4677,'multiline':False]
['text':' If we are checking the range of all instructions, then the guards','line_number':4684,'multiline':False]
['text':' inserted by Range Analysis prevent the use of recover instruction. Thus,','line_number':4685,'multiline':False]
['text':' we just disable these checks.','line_number':4686,'multiline':False]
['text':' Create an instruction sequence which implies that the argument of the','line_number':4695,'multiline':False]
['text':' assertRecoveredOnBailout function would be encoded at least in one','line_number':4696,'multiline':False]
['text':' Snapshot.','line_number':4697,'multiline':False]
['text':' This is a no-op because we discard all JIT code when set an allocation','line_number':4719,'multiline':False]
['text':' metadata callback.','line_number':4720,'multiline':False]
['text':' When building MIR from bytecode, for each MDefinition that's an operand to','line_number':4765,'multiline':False]
['text':' a bytecode instruction, we must either add an SSA use or set the','line_number':4766,'multiline':False]
['text':' ImplicitlyUsed flag on that definition. The ImplicitlyUsed flag prevents','line_number':4767,'multiline':False]
['text':' the backend from optimizing-out values that will be used by Baseline after','line_number':4768,'multiline':False]
['text':' a bailout.','line_number':4769,'multiline':False]
['text':'','line_number':4770,'multiline':False]
['text':' WarpBuilder uses WarpPoppedValueUseChecker to assert this invariant in','line_number':4771,'multiline':False]
['text':' debug builds.','line_number':4772,'multiline':False]
['text':'','line_number':4773,'multiline':False]
['text':' This function is responsible for setting the ImplicitlyUsed flag for an','line_number':4774,'multiline':False]
['text':' input when using the transpiler. It looks at the input's most recent use','line_number':4775,'multiline':False]
['text':' and if that's an instruction that was added while transpiling this JSOp','line_number':4776,'multiline':False]
['text':' (based on the MIR instruction id) we don't set the ImplicitlyUsed flag.','line_number':4777,'multiline':False]
['text':' Nothing to do.','line_number':4780,'multiline':False]
['text':' If the most recent use of 'input' is an instruction we just added, there is','line_number':4784,'multiline':False]
['text':' nothing to do.','line_number':4785,'multiline':False]
['text':' The transpiler didn't add a use for 'input'.','line_number':4791,'multiline':False]
