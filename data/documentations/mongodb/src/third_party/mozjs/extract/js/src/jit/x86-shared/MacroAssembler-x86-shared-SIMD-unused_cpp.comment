['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' The following routines are from the old asm.js implementation but are UNUSED','line_number':20,'multiline':False]
['text':' in the wasm implementation currently.  They are preserved here because it's','line_number':21,'multiline':False]
['text':' sad to throw out working code.  They are defined in the header file.','line_number':22,'multiline':False]
['text':'','line_number':23,'multiline':False]
['text':' Before using these, they should minimally be moved to','line_number':24,'multiline':False]
['text':' MacroAssembler-x86-shared-SIMD.cpp, and it would be a wrong move to assume','line_number':25,'multiline':False]
['text':' that they are correct according to the wasm spec.','line_number':26,'multiline':False]
['text':' Does the conversion and jumps to the OOL entry if the result value','line_number':31,'multiline':False]
['text':' is the undefined integer pattern.','line_number':32,'multiline':False]
['text':' TODO (bug 1156228): If we have SSE4.1, we can use PTEST here instead of','line_number':40,'multiline':False]
['text':' the two following instructions.','line_number':41,'multiline':False]
['text':' Classify lane values into 4 disjoint classes:','line_number':72,'multiline':False]
['text':'','line_number':73,'multiline':False]
['text':'   N-lanes:             in <= -1.0','line_number':74,'multiline':False]
['text':'   A-lanes:      -1.0 < in <= 0x0.ffffffp31','line_number':75,'multiline':False]
['text':'   B-lanes: 0x1.0p31 <= in <= 0x0.ffffffp32','line_number':76,'multiline':False]
['text':'   V-lanes: 0x1.0p32 <= in, or isnan(in)','line_number':77,'multiline':False]
['text':'','line_number':78,'multiline':False]
['text':' We need to bail out to throw a RangeError if we see any N-lanes or','line_number':79,'multiline':False]
['text':' V-lanes.','line_number':80,'multiline':False]
['text':'','line_number':81,'multiline':False]
['text':' For A-lanes and B-lanes, we make two float -> int32 conversions:','line_number':82,'multiline':False]
['text':'','line_number':83,'multiline':False]
['text':'   A = cvttps2dq(in)','line_number':84,'multiline':False]
['text':'   B = cvttps2dq(in - 0x1.0p31f)','line_number':85,'multiline':False]
['text':'','line_number':86,'multiline':False]
['text':' Note that the subtraction for the B computation is exact for B-lanes.','line_number':87,'multiline':False]
['text':' There is no rounding, so B is the low 31 bits of the correctly converted','line_number':88,'multiline':False]
['text':' result.','line_number':89,'multiline':False]
['text':'','line_number':90,'multiline':False]
['text':' The cvttps2dq instruction produces 0x80000000 when the input is NaN or','line_number':91,'multiline':False]
['text':' out of range for a signed int32_t. This conveniently provides the missing','line_number':92,'multiline':False]
['text':' high bit for B, so the desired result is A for A-lanes and A|B for','line_number':93,'multiline':False]
['text':' B-lanes.','line_number':94,'multiline':False]
['text':' TODO: If the majority of lanes are A-lanes, it could be faster to compute','line_number':98,'multiline':False]
['text':' A first, use vmovmskps to check for any non-A-lanes and handle them in','line_number':99,'multiline':False]
['text':' ool code. OTOH, we we're wrong about the lane distribution, that would be','line_number':100,'multiline':False]
['text':' slower.','line_number':101,'multiline':False]
['text':' Compute B in |scratch|.','line_number':103,'multiline':False]
['text':' 0x1.0p31f for the benefit of MSVC.','line_number':104,'multiline':False]
['text':' Compute A in |out|. This is the last time we use |in| and the first time','line_number':110,'multiline':False]
['text':' we use |out|, so we can tolerate if they are the same register.','line_number':111,'multiline':False]
['text':' We can identify A-lanes by the sign bits in A: Any A-lanes will be','line_number':114,'multiline':False]
['text':' positive in A, and N, B, and V-lanes will be 0x80000000 in A. Compute a','line_number':115,'multiline':False]
['text':' mask of non-A-lanes into |tempF|.','line_number':116,'multiline':False]
['text':' Clear the A-lanes in B.','line_number':120,'multiline':False]
['text':' Compute the final result: A for A-lanes, A|B for B-lanes.','line_number':123,'multiline':False]
['text':' We still need to filter out the V-lanes. They would show up as 0x80000000','line_number':126,'multiline':False]
['text':' in both A and B. Since we cleared the valid A-lanes in B, the V-lanes are','line_number':127,'multiline':False]
['text':' the remaining negative lanes in B.','line_number':128,'multiline':False]
['text':' Get a lane, don't bother fixing the high bits since we'll mask below.','line_number':186,'multiline':False]
['text':' We need to generate a 0/1 value. We have 0/-1 and possibly dirty high bits.','line_number':195,'multiline':False]
['text':' We know that the input lanes are boolean, so they are either 0 or -1.','line_number':201,'multiline':False]
['text':' The all-true vector has all 128 bits set, no matter the lane geometry.','line_number':202,'multiline':False]
['text':' For SIMD.js','line_number':223,'multiline':False]
['text':' Worst-case fallback for pre-SSSE3 machines. Bounce through memory.','line_number':236,'multiline':False]
['text':' TODO Here and below, arch specific lowering could identify this pattern','line_number':267,'multiline':False]
['text':' and use defineReuseInput to avoid this move (bug 1084404)','line_number':268,'multiline':False]
['text':' Check that lanes come from LHS in majority:','line_number':315,'multiline':False]
['text':' When reading this method, remember that vshufps takes the two first','line_number':319,'multiline':False]
['text':' inputs of the destination operand (right operand) and the two last','line_number':320,'multiline':False]
['text':' inputs of the source operand (left operand).','line_number':321,'multiline':False]
['text':'','line_number':322,'multiline':False]
['text':' Legend for explanations:','line_number':323,'multiline':False]
['text':' - L: LHS','line_number':324,'multiline':False]
['text':' - R: RHS','line_number':325,'multiline':False]
['text':' - T: temporary','line_number':326,'multiline':False]
['text':' If all lanes came from a single vector, we should use swizzle instead.','line_number':330,'multiline':False]
['text':' If all values stay in their lane, this is a blend.','line_number':333,'multiline':False]
['text':' One element of the second, all other elements of the first','line_number':341,'multiline':False]
['text':' register-register vmovss preserves the high lanes.','line_number':345,'multiline':False]
['text':' SSE4.1 vinsertps can handle any single element.','line_number':351,'multiline':False]
['text':' T = (Rw Rw Lz Lz) = vshufps(firstMask, lhs, rhs, rhsCopy)','line_number':381,'multiline':False]
['text':' (Lx Ly Lz Rw) = (Lx Ly Tz Tx) = vshufps(secondMask, T, lhs, out)','line_number':383,'multiline':False]
['text':' T = (Rz Rz Lw Lw) = vshufps(firstMask, lhs, rhs, rhsCopy)','line_number':388,'multiline':False]
['text':' (Lx Ly Rz Lw) = (Lx Ly Tx Tz) = vshufps(secondMask, T, lhs, out)','line_number':390,'multiline':False]
['text':' T = (Ry Ry Lx Lx) = vshufps(firstMask, lhs, rhs, rhsCopy)','line_number':403,'multiline':False]
['text':' (Lx Ry Lz Lw) = (Tz Tx Lz Lw) = vshufps(secondMask, lhs, T, out)','line_number':405,'multiline':False]
['text':' T = (Rx Rx Ly Ly) = vshufps(firstMask, lhs, rhs, rhsCopy)','line_number':410,'multiline':False]
['text':' (Rx Ly Lz Lw) = (Tx Tz Lz Lw) = vshufps(secondMask, lhs, T, out)','line_number':412,'multiline':False]
['text':' Two elements from one vector, two other elements from the other','line_number':426,'multiline':False]
['text':' TODO Here and below, symmetric case would be more handy to avoid a move,','line_number':429,'multiline':False]
['text':' but can't be reached because operands would get swapped (bug 1084404).','line_number':430,'multiline':False]
['text':' No need to make an actual copy, since the operand is already','line_number':448,'multiline':False]
['text':' in a register, and it won't be clobbered by the vmovlhps.','line_number':449,'multiline':False]
['text':' TODO swapped case would be better (bug 1084404)','line_number':464,'multiline':False]
['text':' TODO swapped case would be better (bug 1084404)','line_number':483,'multiline':False]
['text':' In one vshufps','line_number':497,'multiline':False]
['text':' At creation, we should have explicitly swapped in this case.','line_number':504,'multiline':False]
['text':' In two vshufps, for the most generic case:','line_number':507,'multiline':False]
['text':' Emulate vblendvps.','line_number':563,'multiline':False]
['text':' With SSE.4.1 we could use blendvps, however it's awkward since','line_number':564,'multiline':False]
['text':' it requires the mask to be in xmm0.','line_number':565,'multiline':False]
['text':' Ensure temp always contains the temporary result','line_number':592,'multiline':False]
['text':' Emulate vblendvps.','line_number':606,'multiline':False]
['text':' With SSE.4.1 we could use blendvps, however it's awkward since','line_number':607,'multiline':False]
['text':' it requires the mask to be in xmm0.','line_number':608,'multiline':False]
