['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' VIXL imports.','line_number':21,'multiline':False]
['text':' The MacroAssembler uses scratch registers extensively and unexpectedly.','line_number':34,'multiline':False]
['text':' For safety, scratch registers should always be acquired using','line_number':35,'multiline':False]
['text':' vixl::UseScratchRegisterScope.','line_number':36,'multiline':False]
['text':' [SMDOC] AArch64 Stack Pointer and Pseudo Stack Pointer conventions','line_number':102,'multiline':False]
['text':'','line_number':103,'multiline':False]
['text':'                               ================','line_number':104,'multiline':False]
['text':'','line_number':105,'multiline':False]
['text':' Stack pointer (SP), PseudoStackPointer (PSP), and RealStackPointer:','line_number':106,'multiline':False]
['text':'','line_number':107,'multiline':False]
['text':' The ARM64 real SP has a constraint: it must be 16-byte aligned whenever it','line_number':108,'multiline':False]
['text':' is used as the base pointer for a memory access.  (SP+offset need not be','line_number':109,'multiline':False]
['text':' 16-byte aligned, but the SP value itself must be.)  The SP register may','line_number':110,'multiline':False]
['text':' take on unaligned values but may not be used for a memory access while it','line_number':111,'multiline':False]
['text':' is unaligned.','line_number':112,'multiline':False]
['text':'','line_number':113,'multiline':False]
['text':' Stack-alignment checking can be enabled or disabled by a control register;','line_number':114,'multiline':False]
['text':' however that register cannot be modified by user space.  We have to assume','line_number':115,'multiline':False]
['text':' stack alignment checking is enabled, and that does usually appear to be the','line_number':116,'multiline':False]
['text':' case.  See the ARM Architecture Reference Manual, "D1.8.2 SP alignment','line_number':117,'multiline':False]
['text':' checking", for further details.','line_number':118,'multiline':False]
['text':'','line_number':119,'multiline':False]
['text':' A second constraint is forced upon us by the ARM64 ABI.  This requires that','line_number':120,'multiline':False]
['text':' all accesses to the stack must be at or above SP.  Accesses below SP are','line_number':121,'multiline':False]
['text':' strictly forbidden, presumably because the kernel might use that area of','line_number':122,'multiline':False]
['text':' memory for its own purposes -- in particular, signal delivery -- and hence','line_number':123,'multiline':False]
['text':' it may get trashed at any time.','line_number':124,'multiline':False]
['text':'','line_number':125,'multiline':False]
['text':' Note this doesn't mean that accesses to the stack must be based off','line_number':126,'multiline':False]
['text':' register SP.  Only that the effective addresses must be >= SP, regardless','line_number':127,'multiline':False]
['text':' of how the address is formed.','line_number':128,'multiline':False]
['text':'','line_number':129,'multiline':False]
['text':' In order to allow word-wise pushes and pops, some of our ARM64 jits','line_number':130,'multiline':False]
['text':' (JS-Baseline, JS-Ion, and Wasm-Ion, but not Wasm-Baseline or','line_number':131,'multiline':False]
['text':' Wasm-Cranelift) dedicate x28 to be used as a PseudoStackPointer (PSP).','line_number':132,'multiline':False]
['text':' Initially the PSP will have the same value as the SP.  Code can, if it','line_number':133,'multiline':False]
['text':' wants, push a single word by subtracting 8 from the PSP, doing SP := PSP,','line_number':134,'multiline':False]
['text':' then storing the value at PSP+0.  Given other constraints on the alignment','line_number':135,'multiline':False]
['text':' of the SP at function call boundaries, this works out OK, at the cost of','line_number':136,'multiline':False]
['text':' the two extra instructions per push / pop.','line_number':137,'multiline':False]
['text':'','line_number':138,'multiline':False]
['text':' This is all a bit messy, and is probably not robustly adhered to.  However,','line_number':139,'multiline':False]
['text':' the following appear to be the intended, and mostly implemented, current','line_number':140,'multiline':False]
['text':' invariants:','line_number':141,'multiline':False]
['text':'','line_number':142,'multiline':False]
['text':' (1) PSP is "primary", SP is "secondary".  Most stack refs are','line_number':143,'multiline':False]
['text':'     PSP-relative. SP-relative is rare and (obviously) only done when we','line_number':144,'multiline':False]
['text':'     know that SP is aligned.','line_number':145,'multiline':False]
['text':'','line_number':146,'multiline':False]
['text':' (2) At all times, the relationship SP <= PSP is maintained.  The fact that','line_number':147,'multiline':False]
['text':'     SP may validly be less than PSP means that pushes on the stack force','line_number':148,'multiline':False]
['text':'     the two values to become equal, by copying PSP into SP.  However, pops','line_number':149,'multiline':False]
['text':'     behave differently: PSP moves back up and SP stays the same, since that','line_number':150,'multiline':False]
['text':'     doesn't break the SP <= PSP invariant.','line_number':151,'multiline':False]
['text':'','line_number':152,'multiline':False]
['text':' (3) However, immediately before a call instruction, SP and PSP must be the','line_number':153,'multiline':False]
['text':'     same.  To enforce this, PSP is copied into SP by the arm64-specific','line_number':154,'multiline':False]
['text':'     MacroAssembler::call routines.','line_number':155,'multiline':False]
['text':'','line_number':156,'multiline':False]
['text':' (4) Also, after a function has returned, it is expected that SP holds the','line_number':157,'multiline':False]
['text':'     "primary" value.  How exactly this is implemented remains not entirely','line_number':158,'multiline':False]
['text':'     clear and merits further investigation.  The following points are','line_number':159,'multiline':False]
['text':'     believed to be relevant:','line_number':160,'multiline':False]
['text':'','line_number':161,'multiline':False]
['text':'     - For calls to functions observing the system AArch64 ABI, PSP (x28) is','line_number':162,'multiline':False]
['text':'       callee-saved.  That, combined with (3) above, implies SP == PSP','line_number':163,'multiline':False]
['text':'       immediately after the call returns.','line_number':164,'multiline':False]
['text':'','line_number':165,'multiline':False]
['text':'     - JIT-generated routines return using MacroAssemblerCompat::retn, and','line_number':166,'multiline':False]
['text':'       that copies PSP into SP (bizarrely; this would make more sense if it','line_number':167,'multiline':False]
['text':'       copied SP into PSP); but in any case, the point is that they are the','line_number':168,'multiline':False]
['text':'       same at the point that the return instruction executes.','line_number':169,'multiline':False]
['text':'','line_number':170,'multiline':False]
['text':'     - MacroAssembler::callWithABIPost copies PSP into SP after the return','line_number':171,'multiline':False]
['text':'       of a call requiring dynamic alignment.','line_number':172,'multiline':False]
['text':'','line_number':173,'multiline':False]
['text':'     Given the above, it is unclear exactly where in the return sequence it','line_number':174,'multiline':False]
['text':'     is expected that SP == PSP, and also whether it is the callee or caller','line_number':175,'multiline':False]
['text':'     that is expected to enforce it.','line_number':176,'multiline':False]
['text':'','line_number':177,'multiline':False]
['text':' In general it would be nice to be able to move (at some time in the future,','line_number':178,'multiline':False]
['text':' not now) to a world where *every* assignment to PSP or SP is followed','line_number':179,'multiline':False]
['text':' immediately by a copy into the other register.  That would make all','line_number':180,'multiline':False]
['text':' required correctness proofs trivial in the sense that it would require only','line_number':181,'multiline':False]
['text':' local inspection of code immediately following (dominated by) any such','line_number':182,'multiline':False]
['text':' assignment.  For the moment, however, this is a guideline, not a hard','line_number':183,'multiline':False]
['text':' requirement.','line_number':184,'multiline':False]
['text':'','line_number':185,'multiline':False]
['text':'                               ================','line_number':186,'multiline':False]
['text':'','line_number':187,'multiline':False]
['text':' Mechanics of keeping the stack pointers in sync:','line_number':188,'multiline':False]
['text':'','line_number':189,'multiline':False]
['text':' The following two methods require that the masm's SP has been set to the PSP','line_number':190,'multiline':False]
['text':' with MacroAssembler::SetStackPointer64(PseudoStackPointer64), or they will be','line_number':191,'multiline':False]
['text':' no-ops.  The setup is performed manually by the jits after creating the masm.','line_number':192,'multiline':False]
['text':'','line_number':193,'multiline':False]
['text':' * MacroAssembler::syncStackPtr() performs SP := PSP, presumably after PSP has','line_number':194,'multiline':False]
['text':'   been updated, so SP needs to move too.  This is used pretty liberally','line_number':195,'multiline':False]
['text':'   throughout the code base.','line_number':196,'multiline':False]
['text':'','line_number':197,'multiline':False]
['text':' * MacroAssembler::initPseudoStackPtr() performs PSP := SP.  This can be used','line_number':198,'multiline':False]
['text':'   after calls to non-ABI compliant code; it's not used much.','line_number':199,'multiline':False]
['text':'','line_number':200,'multiline':False]
['text':' In the ARM64 assembler there is a function Instruction::IsStackPtrSync() that','line_number':201,'multiline':False]
['text':' recognizes the instruction emitted by syncStackPtr(), and this is used to','line_number':202,'multiline':False]
['text':' skip that instruction a few places, should it be present, in the JS JIT where','line_number':203,'multiline':False]
['text':' code is generated to deal with toggled calls.','line_number':204,'multiline':False]
['text':'','line_number':205,'multiline':False]
['text':' In various places there are calls to MacroAssembler::syncStackPtr() which','line_number':206,'multiline':False]
['text':' appear to be redundant.  Investigation shows that they often are redundant,','line_number':207,'multiline':False]
['text':' but not always.  Finding and removing such redundancies would be quite some','line_number':208,'multiline':False]
['text':' work, so we live for now with the occasional redundant update.  Perusal of','line_number':209,'multiline':False]
['text':' the Cortex-A55 and -A72 optimization guides shows no evidence that such','line_number':210,'multiline':False]
['text':' assignments are any more expensive than assignments between vanilla integer','line_number':211,'multiline':False]
['text':' registers, so the costs of such redundant updates are assumed to be small.','line_number':212,'multiline':False]
['text':'','line_number':213,'multiline':False]
['text':' Invariants on the PSP at function call boundaries:','line_number':214,'multiline':False]
['text':'','line_number':215,'multiline':False]
['text':' It *appears* that the following invariants exist:','line_number':216,'multiline':False]
['text':'','line_number':217,'multiline':False]
['text':' * On entry to JIT code, PSP == SP, ie the stack pointer is transmitted via','line_number':218,'multiline':False]
['text':'   both registers.','line_number':219,'multiline':False]
['text':'','line_number':220,'multiline':False]
['text':' * On entry to C++ code, PSP == SP.  Certainly it appears that all calls','line_number':221,'multiline':False]
['text':'   created by the MacroAssembler::call(..) routines perform 'syncStackPtr'','line_number':222,'multiline':False]
['text':'   immediately before the call, and all ABI calls are routed through the','line_number':223,'multiline':False]
['text':'   MacroAssembler::call layer.','line_number':224,'multiline':False]
['text':'','line_number':225,'multiline':False]
['text':' * The stubs generated by WasmStubs.cpp assume that, on entry, SP is the','line_number':226,'multiline':False]
['text':'   active stack pointer and that PSP is dead.','line_number':227,'multiline':False]
['text':'','line_number':228,'multiline':False]
['text':' * The PSP is non-volatile (callee-saved).  Along a normal return path from','line_number':229,'multiline':False]
['text':'   JIT code, simply having PSP == SP on exit is correct, since the exit SP is','line_number':230,'multiline':False]
['text':'   the same as the entry SP by the JIT ABI.','line_number':231,'multiline':False]
['text':'','line_number':232,'multiline':False]
['text':' * Call-outs to non-JIT C++ code do not need to set up the PSP (it won't be','line_number':233,'multiline':False]
['text':'   used), and will not need to restore the PSP on return because x28 is','line_number':234,'multiline':False]
['text':'   non-volatile in the ARM64 ABI.','line_number':235,'multiline':False]
['text':'','line_number':236,'multiline':False]
['text':'                               ================','line_number':237,'multiline':False]
['text':'','line_number':238,'multiline':False]
['text':' Future cleanups to the SP-vs-PSP machinery:','line_number':239,'multiline':False]
['text':'','line_number':240,'multiline':False]
['text':' Currently we have somewhat unclear invariants, which are not obviously','line_number':241,'multiline':False]
['text':' always enforced, and which may require complex non-local reasoning.','line_number':242,'multiline':False]
['text':' Auditing the code to ensure that the invariants always hold, whilst not','line_number':243,'multiline':False]
['text':' generating duplicate syncs, is close to impossible.  A future rework to','line_number':244,'multiline':False]
['text':' tidy this might be as follows.  (This suggestion pertains the the entire','line_number':245,'multiline':False]
['text':' JIT complex: all of the JS compilers, wasm compilers, stub generators,','line_number':246,'multiline':False]
['text':' regexp compilers, etc).','line_number':247,'multiline':False]
['text':'','line_number':248,'multiline':False]
['text':' Currently we have that, in JIT-generated code, PSP is "primary" and SP is','line_number':249,'multiline':False]
['text':' "secondary", meaning that PSP has the "real" stack pointer value and SP is','line_number':250,'multiline':False]
['text':' updated whenever PSP acquires a lower value, so as to ensure that SP <= PSP.','line_number':251,'multiline':False]
['text':' An exception to this scheme is the stubs code generated by WasmStubs.cpp,','line_number':252,'multiline':False]
['text':' which assumes that SP is "primary" and PSP is dead.','line_number':253,'multiline':False]
['text':'','line_number':254,'multiline':False]
['text':' It might give us an easier incremental path to eventually removing PSP','line_number':255,'multiline':False]
['text':' entirely if we switched to having SP always be the primary.  That is:','line_number':256,'multiline':False]
['text':'','line_number':257,'multiline':False]
['text':' (1) SP is primary, PSP is secondary','line_number':258,'multiline':False]
['text':' (2) After any assignment to SP, it is copied into PSP','line_number':259,'multiline':False]
['text':' (3) All (non-frame-pointer-based) stack accesses are PSP-relative','line_number':260,'multiline':False]
['text':'     (as at present)','line_number':261,'multiline':False]
['text':'','line_number':262,'multiline':False]
['text':' This would have the effect that:','line_number':263,'multiline':False]
['text':'','line_number':264,'multiline':False]
['text':' * It would reinstate the invariant that on all targets, the "real" SP value','line_number':265,'multiline':False]
['text':'   is in the ABI-and-or-hardware-mandated stack pointer register.','line_number':266,'multiline':False]
['text':'','line_number':267,'multiline':False]
['text':' * It would give us a simple story about calls and returns:','line_number':268,'multiline':False]
['text':'   - for calls to non-JIT generated code (viz, C++ etc), we need no extra','line_number':269,'multiline':False]
['text':'     copies, because PSP (x28) is callee-saved','line_number':270,'multiline':False]
['text':'   - for calls to JIT-generated code, we need no extra copies, because of (2)','line_number':271,'multiline':False]
['text':'     above','line_number':272,'multiline':False]
['text':'','line_number':273,'multiline':False]
['text':' * We could incrementally migrate those parts of the code generator where we','line_number':274,'multiline':False]
['text':'   know that SP is 16-aligned, to use SP- rather than PSP-relative accesses','line_number':275,'multiline':False]
['text':'','line_number':276,'multiline':False]
['text':' * The consistent use of (2) would remove the requirement to have to perform','line_number':277,'multiline':False]
['text':'   path-dependent reasoning (for paths in the generated code, not in the','line_number':278,'multiline':False]
['text':'   compiler) when reading/understanding the code.','line_number':279,'multiline':False]
['text':'','line_number':280,'multiline':False]
['text':' * x28 would become free for use by stubs and the baseline compiler without','line_number':281,'multiline':False]
['text':'   having to worry about interoperating with code that expects x28 to hold a','line_number':282,'multiline':False]
['text':'   valid PSP.','line_number':283,'multiline':False]
['text':'','line_number':284,'multiline':False]
['text':' One might ask what mechanical checks we can add to ensure correctness, rather','line_number':285,'multiline':False]
['text':' than having to verify these invariants by hand indefinitely.  Maybe some','line_number':286,'multiline':False]
['text':' combination of:','line_number':287,'multiline':False]
['text':'','line_number':288,'multiline':False]
['text':' * In debug builds, compiling-in assert(SP == PSP) at critical places.  This','line_number':289,'multiline':False]
['text':'   can be done using the existing `assertStackPtrsSynced` function.','line_number':290,'multiline':False]
['text':'','line_number':291,'multiline':False]
['text':' * In debug builds, scanning sections of generated code to ensure no','line_number':292,'multiline':False]
['text':'   SP-relative stack accesses have been created -- for some sections, at','line_number':293,'multiline':False]
['text':'   least every assignment to SP is immediately followed by a copy to x28.','line_number':294,'multiline':False]
['text':'   This would also facilitate detection of duplicate syncs.','line_number':295,'multiline':False]
['text':'','line_number':296,'multiline':False]
['text':'                               ================','line_number':297,'multiline':False]
['text':'','line_number':298,'multiline':False]
['text':' Other investigative notes, for the code base at present:','line_number':299,'multiline':False]
['text':'','line_number':300,'multiline':False]
['text':' * Some disassembly dumps suggest that we sync the stack pointer too often.','line_number':301,'multiline':False]
['text':'   This could be the result of various pieces of code working at cross','line_number':302,'multiline':False]
['text':'   purposes when syncing the stack pointer, or of not paying attention to the','line_number':303,'multiline':False]
['text':'   precise invariants.','line_number':304,'multiline':False]
['text':'','line_number':305,'multiline':False]
['text':' * As documented in RegExpNativeMacroAssembler.cpp, function','line_number':306,'multiline':False]
['text':'   SMRegExpMacroAssembler::createStackFrame:','line_number':307,'multiline':False]
['text':'','line_number':308,'multiline':False]
['text':'   // ARM64 communicates stack address via SP, but uses a pseudo-sp (PSP) for','line_number':309,'multiline':False]
['text':'   // addressing.  The register we use for PSP may however also be used by','line_number':310,'multiline':False]
['text':'   // calling code, and it is nonvolatile, so save it.  Do this as a special','line_number':311,'multiline':False]
['text':'   // case first because the generic save/restore code needs the PSP to be','line_number':312,'multiline':False]
['text':'   // initialized already.','line_number':313,'multiline':False]
['text':'','line_number':314,'multiline':False]
['text':'   and also in function SMRegExpMacroAssembler::exitHandler:','line_number':315,'multiline':False]
['text':'','line_number':316,'multiline':False]
['text':'   // Restore the saved value of the PSP register, this value is whatever the','line_number':317,'multiline':False]
['text':'   // caller had saved in it, not any actual SP value, and it must not be','line_number':318,'multiline':False]
['text':'   // overwritten subsequently.','line_number':319,'multiline':False]
['text':'','line_number':320,'multiline':False]
['text':'   The original source for these comments was a patch for bug 1445907.','line_number':321,'multiline':False]
['text':'','line_number':322,'multiline':False]
['text':' * MacroAssembler-arm64.h has an interesting comment in the retn()','line_number':323,'multiline':False]
['text':'   function:','line_number':324,'multiline':False]
['text':'','line_number':325,'multiline':False]
['text':'   syncStackPtr();  // SP is always used to transmit the stack between calls.','line_number':326,'multiline':False]
['text':'','line_number':327,'multiline':False]
['text':'   Same comment at abiret() in that file, and in MacroAssembler-arm64.cpp,','line_number':328,'multiline':False]
['text':'   at callWithABIPre and callWithABIPost.','line_number':329,'multiline':False]
['text':'','line_number':330,'multiline':False]
['text':' * In Trampoline-arm64.cpp function JitRuntime::generateVMWrapper we find','line_number':331,'multiline':False]
['text':'','line_number':332,'multiline':False]
['text':'   // SP is used to transfer stack across call boundaries.','line_number':333,'multiline':False]
['text':'   masm.initPseudoStackPtr();','line_number':334,'multiline':False]
['text':'','line_number':335,'multiline':False]
['text':'   after the return point of a callWithVMWrapper.  The only reasonable','line_number':336,'multiline':False]
['text':'   conclusion from all those (assuming they are right) is that SP == PSP.','line_number':337,'multiline':False]
['text':'','line_number':338,'multiline':False]
['text':' * Wasm-Baseline does not use the PSP, but as Wasm-Ion code requires SP==PSP','line_number':339,'multiline':False]
['text':'   and tiered code can have Baseline->Ion calls, Baseline will set PSP=SP','line_number':340,'multiline':False]
['text':'   before a call to wasm code.  When the optimized tier is created by','line_number':341,'multiline':False]
['text':'   Cranelift this is not necessary.','line_number':342,'multiline':False]
['text':'','line_number':343,'multiline':False]
['text':'                               ================','line_number':344,'multiline':False]
['text':' StackPointer is intentionally undefined on ARM64 to prevent misuse: using','line_number':346,'multiline':False]
['text':' sp as a base register is only valid if sp % 16 == 0.','line_number':347,'multiline':False]
['text':' Define unsized Registers.','line_number':364,'multiline':False]
['text':' Import VIXL registers into the js::jit namespace.','line_number':375,'multiline':False]
['text':' Import VIXL VRegisters into the js::jit namespace.','line_number':386,'multiline':False]
['text':' Registerd used in RegExpMatcher instruction (do not use JSReturnOperand).','line_number':395,'multiline':False]
['text':' Registerd used in RegExpTester instruction (do not use ReturnReg).','line_number':400,'multiline':False]
['text':' N.B. r8 isn't listed as an aapcs temp register, but we can use it as such','line_number':410,'multiline':False]
['text':' because we never use return-structs.','line_number':411,'multiline':False]
['text':' See comments in wasm::GenerateFunctionPrologue.  The difference between these','line_number':436,'multiline':False]
['text':' is the size of the largest callable prologue on the platform.','line_number':437,'multiline':False]
['text':' Emit the jump table, returning the BufferOffset to the first entry in the','line_number':452,'multiline':False]
['text':' table.','line_number':453,'multiline':False]
['text':' The buffer is about to be linked. Ensure any constant pools or','line_number':522,'multiline':False]
['text':' excess bookkeeping has been flushed to the instruction stream.','line_number':523,'multiline':False]
['text':' Add a jump whose target is unknown until finalization.','line_number':555,'multiline':False]
['text':' The jump may not be patched at runtime.','line_number':556,'multiline':False]
['text':' Raw is going to be the return address.','line_number':574,'multiline':False]
['text':' Overwrite the 4 bytes before the return address, which will end up being','line_number':576,'multiline':False]
['text':' the call instruction.','line_number':577,'multiline':False]
['text':' Toggle a jmp or cmp emitted by toggledJump().','line_number':589,'multiline':False]
['text':' A Jump table entry is 2 instructions, with 8 bytes of raw data','line_number':609,'multiline':False]
['text':' Offset of the patchable target for the given entry.','line_number':620,'multiline':False]
['text':' Structure for fixing up pc-relative loads/jumps when the machine','line_number':637,'multiline':False]
['text':' code gets moved (executable copy, gc, etc.).','line_number':638,'multiline':False]
['text':' List of jumps for which the target is either unknown until finalization,','line_number':648,'multiline':False]
['text':' or cannot be known due to GC. Each entry here requires a unique entry','line_number':649,'multiline':False]
['text':' in the extended jump table, and is patched at finalization.','line_number':650,'multiline':False]
['text':' Final output formatters.','line_number':653,'multiline':False]
['text':' These registers may be volatile or nonvolatile.','line_number':678,'multiline':False]
['text':' This register may be volatile or nonvolatile. Avoid d31 which is the','line_number':684,'multiline':False]
['text':' ScratchDoubleReg_.','line_number':685,'multiline':False]
['text':' These registers may be volatile or nonvolatile.','line_number':689,'multiline':False]
['text':' Note: these three registers are all guaranteed to be different','line_number':690,'multiline':False]
['text':' This register is guaranteed to be clobberable during the prologue and','line_number':695,'multiline':False]
['text':' epilogue of an ABI call which must preserve both ABI argument, return','line_number':696,'multiline':False]
['text':' and non-volatile registers.','line_number':697,'multiline':False]
['text':' TLS pointer argument register for WebAssembly functions. This must not alias','line_number':700,'multiline':False]
['text':' any other register used for passing function arguments or return values.','line_number':701,'multiline':False]
['text':' Preserved by WebAssembly functions.  Must be nonvolatile.','line_number':702,'multiline':False]
['text':' Registers used for wasm table calls. These registers must be disjoint','line_number':705,'multiline':False]
['text':' from the ABI argument registers, WasmTlsReg and each other.','line_number':706,'multiline':False]
['text':' Register used as a scratch along the return path in the fast js -> wasm stub','line_number':712,'multiline':False]
['text':' code.  This must not overlap ReturnReg, JSReturnOperand, or WasmTlsReg.  It','line_number':713,'multiline':False]
['text':' must be a volatile register.','line_number':714,'multiline':False]
['text':' Register used to store a reference to an exception thrown by Wasm to an','line_number':717,'multiline':False]
['text':' exception handling block. Should not overlap with WasmTlsReg.','line_number':718,'multiline':False]
['text':' Get a register in which we plan to put a quantity that will be used as an','line_number':739,'multiline':False]
['text':' integer argument.  This differs from GetIntArgReg in that if we have no more','line_number':740,'multiline':False]
['text':' actual argument registers to use we will fall back on using whatever','line_number':741,'multiline':False]
['text':' CallTempReg* don't overlap the argument registers, and only fail once those','line_number':742,'multiline':False]
['text':' run out too.','line_number':743,'multiline':False]
['text':' Unfortunately, we have to assume things about the point at which','line_number':749,'multiline':False]
['text':' GetIntArgReg returns false, because we need to know how many registers it','line_number':750,'multiline':False]
['text':' can allocate.','line_number':751,'multiline':False]
['text':' Forbids nop filling for testing purposes. Not nestable.','line_number':764,'multiline':False]
['text':' Forbids pool generation during a specified interval. Not nestable.','line_number':774,'multiline':False]
['text':' namespace jit','line_number':784,'multiline':False]
['text':' namespace js','line_number':785,'multiline':False]
['text':' A64_ASSEMBLER_A64_H_','line_number':787,'multiline':False]
