['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' for ::std::pair','line_number':10,'multiline':False]
['text':' js::PlainObject','line_number':24,'multiline':False]
['text':' Stack used by FlagPhiInputsAsImplicitlyUsed. It stores the Phi instruction','line_number':40,'multiline':False]
['text':' pointer and the MUseIterator which should be visited next.','line_number':41,'multiline':False]
['text':' Look for Phi uses with a depth-first search. If any uses are found the stack','line_number':45,'multiline':False]
['text':' of MPhi instructions is returned in the |worklist| argument.','line_number':46,'multiline':False]
['text':' Push a Phi and the next use to iterate over in the worklist.','line_number':49,'multiline':False]
['text':' Used to assert that when we have no uses, we at least visited all the','line_number':56,'multiline':False]
['text':' transitive uses.','line_number':57,'multiline':False]
['text':' Resume iterating over the last phi-use pair added by the next loop.','line_number':67,'multiline':False]
['text':' Keep going down the tree of uses, skipping (continue)','line_number':74,'multiline':False]
['text':' non-observable/unused cases and Phi which are already listed in the','line_number':75,'multiline':False]
['text':' worklist. Stop (return) as soon as one use is found.','line_number':76,'multiline':False]
['text':' Observable operands are similar to potential uses.','line_number':90,'multiline':False]
['text':' The producer is explicitly used by a definition.','line_number':99,'multiline':False]
['text':' The information got cached on the Phi the last time it','line_number':106,'multiline':False]
['text':' got visited, or when flagging operands of implicitly used','line_number':107,'multiline':False]
['text':' instructions.','line_number':108,'multiline':False]
['text':' We are already iterating over the uses of this Phi instruction which','line_number':113,'multiline':False]
['text':' are part of a loop, instead of trying to handle loops, conservatively','line_number':114,'multiline':False]
['text':' mark them as used.','line_number':115,'multiline':False]
['text':' The instruction already got visited and is known to have','line_number':120,'multiline':False]
['text':' no uses. Skip it.','line_number':121,'multiline':False]
['text':' We found another Phi instruction, move the use iterator to','line_number':125,'multiline':False]
['text':' the next use push it to the worklist stack. Then, continue','line_number':126,'multiline':False]
['text':' with a depth search.','line_number':127,'multiline':False]
['text':' When unused, we cannot bubble up this information without iterating','line_number':139,'multiline':False]
['text':' over the rest of the previous Phi instruction consumers.','line_number':140,'multiline':False]
['text':' When removing an edge between 2 blocks, we might remove the ability of','line_number':152,'multiline':False]
['text':' later phases to figure out that the uses of a Phi should be considered as','line_number':153,'multiline':False]
['text':' a use of all its inputs. Thus we need to mark the Phi inputs as being','line_number':154,'multiline':False]
['text':' implicitly used iff the phi has any uses.','line_number':155,'multiline':False]
['text':'','line_number':156,'multiline':False]
['text':'','line_number':157,'multiline':False]
['text':'        +--------------------+         +---------------------+','line_number':158,'multiline':False]
['text':'        |12 MFoo 6           |         |32 MBar 5            |','line_number':159,'multiline':False]
['text':'        |                    |         |                     |','line_number':160,'multiline':False]
['text':'        |   ...              |         |   ...               |','line_number':161,'multiline':False]
['text':'        |                    |         |                     |','line_number':162,'multiline':False]
['text':'        |25 MGoto Block 4    |         |43 MGoto Block 4     |','line_number':163,'multiline':False]
['text':'        +--------------------+         +---------------------+','line_number':164,'multiline':False]
['text':'                   |                              |','line_number':165,'multiline':False]
['text':'             |     |                              |','line_number':166,'multiline':False]
['text':'             |     |                              |','line_number':167,'multiline':False]
['text':'             |     +-----X------------------------+','line_number':168,'multiline':False]
['text':'             |         Edge       |','line_number':169,'multiline':False]
['text':'             |        Removed     |','line_number':170,'multiline':False]
['text':'             |                    |','line_number':171,'multiline':False]
['text':'             |       +------------v-----------+','line_number':172,'multiline':False]
['text':'             |       |50 MPhi 12 32           |','line_number':173,'multiline':False]
['text':'             |       |                        |','line_number':174,'multiline':False]
['text':'             |       |   ...                  |','line_number':175,'multiline':False]
['text':'             |       |                        |','line_number':176,'multiline':False]
['text':'             |       |70 MReturn 50           |','line_number':177,'multiline':False]
['text':'             |       +------------------------+','line_number':178,'multiline':False]
['text':'             |','line_number':179,'multiline':False]
['text':'   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -','line_number':180,'multiline':False]
['text':'             |','line_number':181,'multiline':False]
['text':'             v','line_number':182,'multiline':False]
['text':'','line_number':183,'multiline':False]
['text':'    ^   +--------------------+         +---------------------+','line_number':184,'multiline':False]
['text':'   /!\  |12 MConst opt-out   |         |32 MBar 5            |','line_number':185,'multiline':False]
['text':'  '---' |                    |         |                     |','line_number':186,'multiline':False]
['text':'        |   ...              |         |   ...               |','line_number':187,'multiline':False]
['text':'        |78 MBail            |         |                     |','line_number':188,'multiline':False]
['text':'        |80 MUnreachable     |         |43 MGoto Block 4     |','line_number':189,'multiline':False]
['text':'        +--------------------+         +---------------------+','line_number':190,'multiline':False]
['text':'                                                  |','line_number':191,'multiline':False]
['text':'                                                  |','line_number':192,'multiline':False]
['text':'                                                  |','line_number':193,'multiline':False]
['text':'                                  +---------------+','line_number':194,'multiline':False]
['text':'                                  |','line_number':195,'multiline':False]
['text':'                                  |','line_number':196,'multiline':False]
['text':'                                  |','line_number':197,'multiline':False]
['text':'                     +------------v-----------+','line_number':198,'multiline':False]
['text':'                     |50 MPhi 32              |','line_number':199,'multiline':False]
['text':'                     |                        |','line_number':200,'multiline':False]
['text':'                     |   ...                  |','line_number':201,'multiline':False]
['text':'                     |                        |','line_number':202,'multiline':False]
['text':'                     |70 MReturn 50           |','line_number':203,'multiline':False]
['text':'                     +------------------------+','line_number':204,'multiline':False]
['text':'','line_number':205,'multiline':False]
['text':'','line_number':206,'multiline':False]
['text':' If the inputs of the Phi are not flagged as implicitly used, then','line_number':207,'multiline':False]
['text':' later compilation phase might optimize them out. The problem is that a','line_number':208,'multiline':False]
['text':' bailout will use this value and give it back to baseline, which will then','line_number':209,'multiline':False]
['text':' use the OptimizedOut magic value in a computation.','line_number':210,'multiline':False]
['text':'','line_number':211,'multiline':False]
['text':' Unfortunately, we cannot be too conservative about flagging Phi inputs as','line_number':212,'multiline':False]
['text':' having implicit uses, as this would prevent many optimizations from being','line_number':213,'multiline':False]
['text':' used. Thus, the following code is in charge of flagging Phi instructions','line_number':214,'multiline':False]
['text':' as Unused or Used, and setting ImplicitlyUsed accordingly.','line_number':215,'multiline':False]
['text':' We are looking to mark the Phi inputs which are used across the edge','line_number':226,'multiline':False]
['text':' between the |block| and its successor |succ|.','line_number':227,'multiline':False]
['text':' If the Phi is either Used or Unused, set the ImplicitlyUsed flag','line_number':233,'multiline':False]
['text':' accordingly.','line_number':234,'multiline':False]
['text':' We do not know if the Phi was Used or Unused, iterate over all uses','line_number':242,'multiline':False]
['text':' with a depth-search of uses. Returns the matching stack in the','line_number':243,'multiline':False]
['text':' worklist as soon as one use is found.','line_number':244,'multiline':False]
['text':' One of the Phis is used, set Used flags on all the Phis which are','line_number':253,'multiline':False]
['text':' in the use chain.','line_number':254,'multiline':False]
['text':' Given an iterator pointing to the first removed instruction, mark','line_number':281,'multiline':False]
['text':' the operands of each removed instruction as having implicit uses.','line_number':282,'multiline':False]
['text':' Flag operands of removed instructions as having implicit uses.','line_number':289,'multiline':False]
['text':' Flag observable resume point operands as having implicit uses.','line_number':301,'multiline':False]
['text':' Note: no need to iterate over the caller's of the resume point as','line_number':303,'multiline':False]
['text':' this is the same as the entry resume point.','line_number':304,'multiline':False]
['text':' Flag Phi inputs of the successors as having implicit uses.','line_number':314,'multiline':False]
['text':' Flag observable operands of the entry resume point as having implicit uses.','line_number':332,'multiline':False]
['text':' WarpBuilder sets the alwaysBails flag on blocks that contain an','line_number':358,'multiline':False]
['text':' unconditional bailout. We trim any instructions in those blocks','line_number':359,'multiline':False]
['text':' after the first unconditional bailout, and remove any blocks that','line_number':360,'multiline':False]
['text':' are only reachable through bailing blocks.','line_number':361,'multiline':False]
['text':' Pruning is guided by unconditional bailouts. Wasm does not have bailouts.','line_number':365,'multiline':False]
['text':' The entry block is always reachable.','line_number':381,'multiline':False]
['text':' The OSR entry block is always reachable if it exists.','line_number':386,'multiline':False]
['text':' Iteratively mark all reachable blocks.','line_number':391,'multiline':False]
['text':' If this block always bails, then it does not reach its successors.','line_number':401,'multiline':False]
['text':' There is nothing to prune.','line_number':419,'multiline':False]
['text':' The operands of removed instructions may be needed in baseline','line_number':427,'multiline':False]
['text':' after bailing out.','line_number':428,'multiline':False]
['text':' If we are removing the block entirely, mark the operands of every','line_number':436,'multiline':False]
['text':' instruction as being implicitly used.','line_number':437,'multiline':False]
['text':' If we are only trimming instructions after a bail, only mark operands','line_number':440,'multiline':False]
['text':' of removed instructions.','line_number':441,'multiline':False]
['text':' Remove the blocks in post-order such that consumers are visited before','line_number':447,'multiline':False]
['text':' the predecessors, the only exception being the Phi nodes of loop headers.','line_number':448,'multiline':False]
['text':' As we are going to replace/remove the last instruction, we first have','line_number':462,'multiline':False]
['text':' to remove this block from the predecessor list of its successors.','line_number':463,'multiline':False]
['text':' Our dominators code expects all loop headers to have two predecessors.','line_number':471,'multiline':False]
['text':' If we are removing the normal entry to a loop, but can still reach','line_number':472,'multiline':False]
['text':' the loop header via OSR, we create a fake unreachable predecessor.','line_number':473,'multiline':False]
['text':' Mark the block to avoid removing it as unreachable.','line_number':484,'multiline':False]
['text':' Remove unreachable blocks from the CFG.','line_number':498,'multiline':False]
['text':' Remove unreachable instructions after unconditional bailouts.','line_number':502,'multiline':False]
['text':' Discard all instructions after the first MBail.','line_number':505,'multiline':False]
['text':' Create a simple new block which contains a goto and which split the','line_number':531,'multiline':False]
['text':' edge between block and target.','line_number':532,'multiline':False]
['text':' A critical edge is an edge which is neither its successor's only predecessor','line_number':541,'multiline':False]
['text':' nor its predecessor's only successor. Critical edges must be split to','line_number':542,'multiline':False]
['text':' prevent copy-insertion and code motion from affecting other edges.','line_number':543,'multiline':False]
['text':' Return whether a block simply computes the specified constant value.','line_number':568,'multiline':False]
['text':' Look for values with no uses. This is used to eliminate constant','line_number':571,'multiline':False]
['text':' computing blocks in condition statements, and the phi which used to','line_number':572,'multiline':False]
['text':' consume the constant has already been removed.','line_number':573,'multiline':False]
['text':' Determine whether phiBlock/testBlock simply compute a phi and perform a','line_number':593,'multiline':False]
['text':' test on it.','line_number':594,'multiline':False]
['text':' Change block so that it ends in a goto to the specific target block.','line_number':652,'multiline':False]
['text':' existingPred is an existing predecessor of the block.','line_number':653,'multiline':False]
['text':' Change block so that it ends in a test of the specified value, going to','line_number':669,'multiline':False]
['text':' either ifTrue or ifFalse. existingPred is an existing predecessor of ifTrue','line_number':670,'multiline':False]
['text':' or ifFalse with the same values incoming to ifTrue/ifFalse as block.','line_number':671,'multiline':False]
['text':' existingPred is not required to be a predecessor of ifTrue/ifFalse if block','line_number':672,'multiline':False]
['text':' already ends in a test going to that block on a true/false result.','line_number':673,'multiline':False]
['text':' Optimize the MIR graph to improve the code generated for conditional','line_number':721,'multiline':False]
['text':' operations. A test like 'if (a ? b : c)' normally requires four blocks,','line_number':722,'multiline':False]
['text':' with a phi for the intermediate value. This can be improved to use three','line_number':723,'multiline':False]
['text':' blocks with no phi value, and if either b or c is constant,','line_number':724,'multiline':False]
['text':' e.g. 'if (a ? b : 0)', then the block associated with that constant','line_number':725,'multiline':False]
['text':' can be eliminated.','line_number':726,'multiline':False]
['text':'
   * Look for a diamond pattern:
   *
   *        initialBlock
   *          /     \
   *  trueBranch  falseBranch
   *          \     /
   *          phiBlock
   *             |
   *         testBlock
   *
   * Where phiBlock contains a single phi combining values pushed onto the
   * stack by trueBranch and falseBranch, and testBlock contains a test on
   * that phi. phiBlock and testBlock may be the same block; generated code
   * will use different blocks if the (?:) op is in an inlined function.
   ','line_number':728,'multiline':True]
['text':' Make sure the test block does not have any outgoing loop backedges.','line_number':784,'multiline':False]
['text':' OK, we found the desired pattern, now transform the graph.','line_number':800,'multiline':False]
['text':' Remove the phi from phiBlock.','line_number':802,'multiline':False]
['text':' If either trueBranch or falseBranch just computes a constant for the','line_number':805,'multiline':False]
['text':' test, determine the block that branch will end up jumping to and eliminate','line_number':806,'multiline':False]
['text':' the branch. Otherwise, change the end of the block to a test that jumps','line_number':807,'multiline':False]
['text':' directly to successors of testBlock, rather than to testBlock itself.','line_number':808,'multiline':False]
['text':' Short circuit the initial test to skip any constant branch eliminated','line_number':847,'multiline':False]
['text':' above.','line_number':848,'multiline':False]
['text':' Remove phiBlock, if different from testBlock.','line_number':854,'multiline':False]
['text':' Remove testBlock itself.','line_number':860,'multiline':False]
['text':' If we will pop the top of the stack immediately after resuming,','line_number':921,'multiline':False]
['text':' then don't preserve the top value in the resume point.','line_number':922,'multiline':False]
['text':' Operands to a resume point which are dead at the point of the resume can be','line_number':939,'multiline':False]
['text':' replaced with a magic value. This analysis supports limited detection of','line_number':940,'multiline':False]
['text':' dead operands, pruning those which are defined in the resume point's basic','line_number':941,'multiline':False]
['text':' block and have no uses outside the block or at points later than the resume','line_number':942,'multiline':False]
['text':' point.','line_number':943,'multiline':False]
['text':'','line_number':944,'multiline':False]
['text':' This is intended to ensure that extra resume points within a basic block','line_number':945,'multiline':False]
['text':' will not artificially extend the lifetimes of any SSA values. This could','line_number':946,'multiline':False]
['text':' otherwise occur if the new resume point captured a value which is created','line_number':947,'multiline':False]
['text':' between the old and new resume point and is dead at the new resume point.','line_number':948,'multiline':False]
['text':' If we are compiling try blocks, locals and arguments may be observable','line_number':950,'multiline':False]
['text':' from catch or finally blocks (which Ion does not compile). For now just','line_number':951,'multiline':False]
['text':' disable the pass in this case.','line_number':952,'multiline':False]
['text':' The logic below can get confused on infinite loops.','line_number':970,'multiline':False]
['text':' No benefit to replacing constant operands with other constants.','line_number':984,'multiline':False]
['text':' Scanning uses does not give us sufficient information to tell','line_number':989,'multiline':False]
['text':' where instructions that are involved in box/unbox operations or','line_number':990,'multiline':False]
['text':' parameter passing might be live. Rewriting uses of these terms','line_number':991,'multiline':False]
['text':' in resume points may affect the interpreter's behavior. Rather','line_number':992,'multiline':False]
['text':' than doing a more sophisticated analysis, just ignore these.','line_number':993,'multiline':False]
['text':' Early intermediate values captured by resume points, such as','line_number':998,'multiline':False]
['text':' ArrayState and its allocation, may be legitimately dead in Ion code,','line_number':999,'multiline':False]
['text':' but are still needed if we bail out. They can recover on bailout.','line_number':1000,'multiline':False]
['text':' If the instruction's behavior has been constant folded into a','line_number':1006,'multiline':False]
['text':' separate instruction, we can't determine precisely where the','line_number':1007,'multiline':False]
['text':' instruction becomes dead and can't eliminate its uses.','line_number':1008,'multiline':False]
['text':' Check if this instruction's result is only used within the','line_number':1013,'multiline':False]
['text':' current block, and keep track of its last use in a definition','line_number':1014,'multiline':False]
['text':' (not resume point). This requires the instructions in the block','line_number':1015,'multiline':False]
['text':' to be numbered, ensured by running this immediately after alias','line_number':1016,'multiline':False]
['text':' analysis.','line_number':1017,'multiline':False]
['text':' If the instruction's is captured by one of the resume point, then','line_number':1023,'multiline':False]
['text':' it might be observed indirectly while the frame is live on the','line_number':1024,'multiline':False]
['text':' stack, so it has to be computed.','line_number':1025,'multiline':False]
['text':' Walk the uses a second time, removing any in resume points after','line_number':1045,'multiline':False]
['text':' the last use in a definition.','line_number':1046,'multiline':False]
['text':' Store an optimized out magic value in place of all dead','line_number':1063,'multiline':False]
['text':' resume point operands. Making any such substitution can in','line_number':1064,'multiline':False]
['text':' general alter the interpreter's behavior, even though the','line_number':1065,'multiline':False]
['text':' code is dead, as the interpreter will still execute opcodes','line_number':1066,'multiline':False]
['text':' whose effects cannot be observed. If the magic value value','line_number':1067,'multiline':False]
['text':' were to flow to, say, a dead property access the','line_number':1068,'multiline':False]
['text':' interpreter could throw an exception; we avoid this problem','line_number':1069,'multiline':False]
['text':' by removing dead operands before removing dead code.','line_number':1070,'multiline':False]
['text':' Test whether |def| would be needed if it had no uses.','line_number':1082,'multiline':False]
['text':' Effectful instructions of course cannot be removed.','line_number':1084,'multiline':False]
['text':' Never eliminate guard instructions.','line_number':1089,'multiline':False]
['text':' Required to be preserved, as the type guard related to this instruction','line_number':1094,'multiline':False]
['text':' is part of the semantics of a transformation.','line_number':1095,'multiline':False]
['text':' Control instructions have no uses, but also shouldn't be optimized out','line_number':1100,'multiline':False]
['text':' Used when lowering to generate the corresponding snapshots and aggregate','line_number':1105,'multiline':False]
['text':' the list of recover instructions to be repeated.','line_number':1106,'multiline':False]
['text':' Test whether |def| may be safely discarded, due to being dead or due to being','line_number':1114,'multiline':False]
['text':' located in a basic block which has itself been marked for discarding.','line_number':1115,'multiline':False]
['text':' Instructions are useless if they are unused and have no side effects.','line_number':1120,'multiline':False]
['text':' This pass eliminates useless instructions.','line_number':1121,'multiline':False]
['text':' The graph itself is unchanged.','line_number':1122,'multiline':False]
['text':' Traverse in postorder so that we hit uses before definitions.','line_number':1124,'multiline':False]
['text':' Traverse instruction list backwards for the same reason.','line_number':1125,'multiline':False]
['text':' Remove unused instructions.','line_number':1132,'multiline':False]
['text':' If the phi has uses which are not reflected in SSA, then behavior in the','line_number':1146,'multiline':False]
['text':' interpreter may be affected by removing the phi.','line_number':1147,'multiline':False]
['text':' Check for uses of this phi node outside of other phi nodes.','line_number':1152,'multiline':False]
['text':' Note that, initially, we skip reading resume points, which we','line_number':1153,'multiline':False]
['text':' don't count as actual uses. If the only uses are resume points,','line_number':1154,'multiline':False]
['text':' then the SSA name is never consumed by the program.  However,','line_number':1155,'multiline':False]
['text':' after optimizations have been performed, it's possible that the','line_number':1156,'multiline':False]
['text':' actual uses in the program have been (incorrectly) optimized','line_number':1157,'multiline':False]
['text':' away, so we must be more conservative and consider resume','line_number':1158,'multiline':False]
['text':' points as well.','line_number':1159,'multiline':False]
['text':' Handles cases like:','line_number':1181,'multiline':False]
['text':'    x is phi(a, x) --> a','line_number':1182,'multiline':False]
['text':'    x is phi(a, a) --> a','line_number':1183,'multiline':False]
['text':' Propagate the ImplicitlyUsed flag if |phi| is replaced with another phi.','line_number':1190,'multiline':False]
['text':' Eliminates redundant or unobservable phis from the graph.  A','line_number':1200,'multiline':False]
['text':' redundant phi is something like b = phi(a, a) or b = phi(a, b),','line_number':1201,'multiline':False]
['text':' both of which can be replaced with a.  An unobservable phi is','line_number':1202,'multiline':False]
['text':' one that whose value is never used in the program.','line_number':1203,'multiline':False]
['text':'','line_number':1204,'multiline':False]
['text':' Note that we must be careful not to eliminate phis representing','line_number':1205,'multiline':False]
['text':' values that the interpreter will require later.  When the graph','line_number':1206,'multiline':False]
['text':' is first constructed, we can be more aggressive, because there','line_number':1207,'multiline':False]
['text':' is a greater correspondence between the CFG and the bytecode.','line_number':1208,'multiline':False]
['text':' After optimizations such as GVN have been performed, however,','line_number':1209,'multiline':False]
['text':' the bytecode and CFG may not correspond as closely to one','line_number':1210,'multiline':False]
['text':' another.  In that case, we must be more conservative.  The flag','line_number':1211,'multiline':False]
['text':' |conservativeObservability| is used to indicate that eliminate','line_number':1212,'multiline':False]
['text':' phis is being run after some optimizations have been performed,','line_number':1213,'multiline':False]
['text':' and thus we should use more conservative rules about','line_number':1214,'multiline':False]
['text':' observability.  The particular danger is that we can optimize','line_number':1215,'multiline':False]
['text':' away uses of a phi because we think they are not executable,','line_number':1216,'multiline':False]
['text':' but the foundation for that assumption is false TI information','line_number':1217,'multiline':False]
['text':' that will eventually be invalidated.  Therefore, if','line_number':1218,'multiline':False]
['text':' |conservativeObservability| is set, we will consider any use','line_number':1219,'multiline':False]
['text':' from a resume point to be observable.  Otherwise, we demand a','line_number':1220,'multiline':False]
['text':' use from an actual instruction.','line_number':1221,'multiline':False]
['text':' Add all observable phis to a worklist. We use the "in worklist" bit to','line_number':1225,'multiline':False]
['text':' mean "this phi is live".','line_number':1226,'multiline':False]
['text':' Flag all as unused, only observable phis would be marked as used','line_number':1237,'multiline':False]
['text':' when processed by the work list.','line_number':1238,'multiline':False]
['text':' If the phi is redundant, remove it here.','line_number':1241,'multiline':False]
['text':' Enqueue observable Phis.','line_number':1248,'multiline':False]
['text':' Iteratively mark all phis reachable from live phis.','line_number':1258,'multiline':False]
['text':' The removal of Phis can produce newly redundant phis.','line_number':1268,'multiline':False]
['text':' Add to the worklist the used phis which are impacted.','line_number':1270,'multiline':False]
['text':' Otherwise flag them as used.','line_number':1285,'multiline':False]
['text':' The current phi is/was used, so all its operands are used.','line_number':1289,'multiline':False]
['text':' Sweep dead phis.','line_number':1302,'multiline':False]
['text':' The type analysis algorithm inserts conversions and box/unbox instructions','line_number':1322,'multiline':False]
['text':' to make the IR graph well-typed for future passes.','line_number':1323,'multiline':False]
['text':'','line_number':1324,'multiline':False]
['text':' Phi adjustment: If a phi's inputs are all the same type, the phi is','line_number':1325,'multiline':False]
['text':' specialized to return that type.','line_number':1326,'multiline':False]
['text':'','line_number':1327,'multiline':False]
['text':' Input adjustment: Each input is asked to apply conversion operations to its','line_number':1328,'multiline':False]
['text':' inputs. This may include Box, Unbox, or other instruction-specific type','line_number':1329,'multiline':False]
['text':' conversion operations.','line_number':1330,'multiline':False]
['text':'','line_number':1331,'multiline':False]
['text':' anonymous namespace ','line_number':1382,'multiline':True]
['text':' [SMDOC] OSR Phi Type Specialization','line_number':1385,'multiline':False]
['text':'','line_number':1386,'multiline':False]
['text':' Without special handling for OSR phis, we end up with unspecialized phis','line_number':1387,'multiline':False]
['text':' (MIRType::Value) in the loop (pre)header and other blocks, resulting in','line_number':1388,'multiline':False]
['text':' unnecessary boxing and unboxing in the loop body.','line_number':1389,'multiline':False]
['text':'','line_number':1390,'multiline':False]
['text':' To fix this, phi type specialization needs special code to deal with the','line_number':1391,'multiline':False]
['text':' OSR entry block. Recall that OSR results in the following basic block','line_number':1392,'multiline':False]
['text':' structure:','line_number':1393,'multiline':False]
['text':'','line_number':1394,'multiline':False]
['text':'  +------------------+                 +-----------------+','line_number':1395,'multiline':False]
['text':'  | Code before loop |                 | OSR entry block |','line_number':1396,'multiline':False]
['text':'  +------------------+                 +-----------------+','line_number':1397,'multiline':False]
['text':'          |                                       |','line_number':1398,'multiline':False]
['text':'          |                                       |','line_number':1399,'multiline':False]
['text':'          |           +---------------+           |','line_number':1400,'multiline':False]
['text':'          +---------> | OSR preheader | <---------+','line_number':1401,'multiline':False]
['text':'                      +---------------+','line_number':1402,'multiline':False]
['text':'                              |','line_number':1403,'multiline':False]
['text':'                              V','line_number':1404,'multiline':False]
['text':'                      +---------------+','line_number':1405,'multiline':False]
['text':'                      | Loop header   |<-----+','line_number':1406,'multiline':False]
['text':'                      +---------------+      |','line_number':1407,'multiline':False]
['text':'                              |              |','line_number':1408,'multiline':False]
['text':'                             ...             |','line_number':1409,'multiline':False]
['text':'                              |              |','line_number':1410,'multiline':False]
['text':'                      +---------------+      |','line_number':1411,'multiline':False]
['text':'                      | Loop backedge |------+','line_number':1412,'multiline':False]
['text':'                      +---------------+','line_number':1413,'multiline':False]
['text':'','line_number':1414,'multiline':False]
['text':' OSR phi specialization happens in three steps:','line_number':1415,'multiline':False]
['text':'','line_number':1416,'multiline':False]
['text':' (1) Specialize phis but ignore MOsrValue phi inputs. In other words,','line_number':1417,'multiline':False]
['text':'     pretend the OSR entry block doesn't exist. See guessPhiType.','line_number':1418,'multiline':False]
['text':'','line_number':1419,'multiline':False]
['text':' (2) Once phi specialization is done, look at the types of loop header phis','line_number':1420,'multiline':False]
['text':'     and add these types to the corresponding preheader phis. This way, the','line_number':1421,'multiline':False]
['text':'     types of the preheader phis are based on the code before the loop and','line_number':1422,'multiline':False]
['text':'     the code in the loop body. These are exactly the types we expect for','line_number':1423,'multiline':False]
['text':'     the OSR Values. See the last part of TypeAnalyzer::specializePhis.','line_number':1424,'multiline':False]
['text':'','line_number':1425,'multiline':False]
['text':' (3) For type-specialized preheader phis, add guard/unbox instructions to','line_number':1426,'multiline':False]
['text':'     the OSR entry block to guard the incoming Value indeed has this type.','line_number':1427,'multiline':False]
['text':'     This happens in:','line_number':1428,'multiline':False]
['text':'','line_number':1429,'multiline':False]
['text':'     * TypeAnalyzer::adjustPhiInputs: adds a fallible unbox for values that','line_number':1430,'multiline':False]
['text':'       can be unboxed.','line_number':1431,'multiline':False]
['text':'','line_number':1432,'multiline':False]
['text':'     * TypeAnalyzer::replaceRedundantPhi: adds a type guard for values that','line_number':1433,'multiline':False]
['text':'       can't be unboxed (null/undefined/magic Values).','line_number':1434,'multiline':False]
['text':' Try to specialize this phi based on its non-cyclic inputs.','line_number':1442,'multiline':False]
['text':' Check that different magic constants aren't flowing together. Ignore','line_number':1445,'multiline':False]
['text':' JS_OPTIMIZED_OUT, since an operand could be legitimately optimized','line_number':1446,'multiline':False]
['text':' away.','line_number':1447,'multiline':False]
['text':' The operand is a phi we tried to specialize, but we were','line_number':1473,'multiline':False]
['text':' unable to guess its type. propagateSpecialization will','line_number':1474,'multiline':False]
['text':' propagate the type to this phi when it becomes known.','line_number':1475,'multiline':False]
['text':' See shouldSpecializeOsrPhis comment. This is the first step mentioned','line_number':1480,'multiline':False]
['text':' there.','line_number':1481,'multiline':False]
['text':' If we only saw definitions that can be converted into Float32 before','line_number':1501,'multiline':False]
['text':' and encounter a Float32 value, promote previous values to Float32','line_number':1502,'multiline':False]
['text':' Specialize phis with int32 and double operands as double.','line_number':1506,'multiline':False]
['text':' TODO(post-Warp): simplify float32 handling in this function or (better)','line_number':1516,'multiline':False]
['text':' make the float32 analysis a stand-alone optimization pass instead of','line_number':1517,'multiline':False]
['text':' complicating type analysis. See bug 1655773.','line_number':1518,'multiline':False]
['text':' Verify that this specialization matches any phis depending on it.','line_number':1537,'multiline':False]
['text':' We tried to specialize this phi, but were unable to guess its','line_number':1547,'multiline':False]
['text':' type. Now that we know the type of one of its operands, we can','line_number':1548,'multiline':False]
['text':' specialize it.','line_number':1549,'multiline':False]
['text':' Specialize phis with int32 that can be converted to float and float','line_number':1556,'multiline':False]
['text':' operands as floats.','line_number':1557,'multiline':False]
['text':' Specialize phis with int32 and double operands as double.','line_number':1568,'multiline':False]
['text':' This phi in our use chain can now no longer be specialized.','line_number':1577,'multiline':False]
['text':' If branch pruning removes the path from the entry block to the OSR','line_number':1602,'multiline':False]
['text':' preheader, we may have phis (or chains of phis) with no operands','line_number':1603,'multiline':False]
['text':' other than OsrValues. These phis will still have MIRType::None.','line_number':1604,'multiline':False]
['text':' Since we don't have any information about them, we specialize them','line_number':1605,'multiline':False]
['text':' as MIRType::Value.','line_number':1606,'multiline':False]
['text':' We tried to guess the type but failed because all operands are','line_number':1645,'multiline':False]
['text':' phis we still have to visit. Set the triedToSpecialize flag but','line_number':1646,'multiline':False]
['text':' don't propagate the type to other phis, propagateSpecialization','line_number':1647,'multiline':False]
['text':' will do that once we know the type of one of the operands.','line_number':1648,'multiline':False]
['text':' See shouldSpecializeOsrPhis comment. This is the second step, propagating','line_number':1662,'multiline':False]
['text':' loop header phi types to preheader phis.','line_number':1663,'multiline':False]
['text':' Branch pruning has removed the path from the entry block','line_number':1669,'multiline':False]
['text':' to the preheader. Specialize any phis with no non-osr inputs.','line_number':1670,'multiline':False]
['text':' Already includes everything.','line_number':1681,'multiline':False]
['text':' Edge case: there is no backedge in this loop. This can happen','line_number':1694,'multiline':False]
['text':' if the header is a 'pending' loop header when control flow in','line_number':1695,'multiline':False]
['text':' the loop body is terminated unconditionally, or if a block','line_number':1696,'multiline':False]
['text':' that dominates the backedge unconditionally bails out. In','line_number':1697,'multiline':False]
['text':' this case the header only has the preheader as predecessor','line_number':1698,'multiline':False]
['text':' and we don't need to do anything.','line_number':1699,'multiline':False]
['text':' If we specialized a type that's not Value, there are 3 cases:','line_number':1712,'multiline':False]
['text':' 1. Every input is of that type.','line_number':1713,'multiline':False]
['text':' 2. Every observed input is of that type (i.e., some inputs haven't been','line_number':1714,'multiline':False]
['text':' executed yet).','line_number':1715,'multiline':False]
['text':' 3. Inputs were doubles and int32s, and was specialized to double.','line_number':1716,'multiline':False]
['text':' Convert int32 operands to double.','line_number':1734,'multiline':False]
['text':' See comment below','line_number':1740,'multiline':False]
['text':' If we know this branch will fail to convert to phiType,','line_number':1754,'multiline':False]
['text':' insert a box that'll immediately fail in the fallible unbox','line_number':1755,'multiline':False]
['text':' below.','line_number':1756,'multiline':False]
['text':' Be optimistic and insert unboxes when the operand is a','line_number':1763,'multiline':False]
['text':' value.','line_number':1764,'multiline':False]
['text':' Box every typed input.','line_number':1777,'multiline':False]
['text':' The input is being explicitly unboxed, so sneak past and grab the','line_number':1784,'multiline':False]
['text':' original box. Don't bother optimizing if magic values are involved.','line_number':1785,'multiline':False]
['text':' Definitions such as MPhi have no type policy.','line_number':1809,'multiline':False]
['text':' The instruction pass will insert the box','line_number':1846,'multiline':False]
['text':' See shouldSpecializeOsrPhis comment. This is part of the third step,','line_number':1851,'multiline':False]
['text':' guard the incoming MOsrValue is of this type.','line_number':1852,'multiline':False]
['text':' Instructions are processed in reverse postorder: all uses are defs are','line_number':1867,'multiline':False]
['text':' seen before uses. This ensures that output adjustment (which may rewrite','line_number':1868,'multiline':False]
['text':' inputs of uses) does not conflict with input adjustment.','line_number':1869,'multiline':False]
['text':' We can replace this phi with a constant.','line_number':1880,'multiline':False]
['text':' AdjustInputs can add/remove/mutate instructions before and after the','line_number':1893,'multiline':False]
['text':' current instruction. Only increment the iterator after it is finished.','line_number':1894,'multiline':False]
['text':' clang-format off ','line_number':1909,'multiline':True]
['text':'','line_number':1910,'multiline':False]
['text':' This function tries to emit Float32 specialized operations whenever it's possible.','line_number':1911,'multiline':False]
['text':' MIR nodes are flagged as:','line_number':1912,'multiline':False]
['text':' - Producers, when they can create Float32 that might need to be coerced into a Double.','line_number':1913,'multiline':False]
['text':'   Loads in Float32 arrays and conversions to Float32 are producers.','line_number':1914,'multiline':False]
['text':' - Consumers, when they can have Float32 as inputs and validate a legal use of a Float32.','line_number':1915,'multiline':False]
['text':'   Stores in Float32 arrays and conversions to Float32 are consumers.','line_number':1916,'multiline':False]
['text':' - Float32 commutative, when using the Float32 instruction instead of the Double instruction','line_number':1917,'multiline':False]
['text':'   does not result in a compound loss of precision. This is the case for +, -, /, * with 2','line_number':1918,'multiline':False]
['text':'   operands, for instance. However, an addition with 3 operands is not commutative anymore,','line_number':1919,'multiline':False]
['text':'   so an intermediate coercion is needed.','line_number':1920,'multiline':False]
['text':' Except for phis, all these flags are known after Ion building, so they cannot change during','line_number':1921,'multiline':False]
['text':' the process.','line_number':1922,'multiline':False]
['text':'','line_number':1923,'multiline':False]
['text':' The idea behind the algorithm is easy: whenever we can prove that a commutative operation','line_number':1924,'multiline':False]
['text':' has only producers as inputs and consumers as uses, we can specialize the operation as a','line_number':1925,'multiline':False]
['text':' float32 operation. Otherwise, we have to convert all float32 inputs to doubles. Even','line_number':1926,'multiline':False]
['text':' if a lot of conversions are produced, GVN will take care of eliminating the redundant ones.','line_number':1927,'multiline':False]
['text':'','line_number':1928,'multiline':False]
['text':' Phis have a special status. Phis need to be flagged as producers or consumers as they can','line_number':1929,'multiline':False]
['text':' be inputs or outputs of commutative instructions. Fortunately, producers and consumers','line_number':1930,'multiline':False]
['text':' properties are such that we can deduce the property using all non phis inputs first (which form','line_number':1931,'multiline':False]
['text':' an initial phi graph) and then propagate all properties from one phi to another using a','line_number':1932,'multiline':False]
['text':' fixed point algorithm. The algorithm is ensured to terminate as each iteration has less or as','line_number':1933,'multiline':False]
['text':' many flagged phis as the previous iteration (so the worst steady state case is all phis being','line_number':1934,'multiline':False]
['text':' flagged as false).','line_number':1935,'multiline':False]
['text':'','line_number':1936,'multiline':False]
['text':' In a nutshell, the algorithm applies three passes:','line_number':1937,'multiline':False]
['text':' 1 - Determine which phis are consumers. Each phi gets an initial value by making a global AND on','line_number':1938,'multiline':False]
['text':' all its non-phi inputs. Then each phi propagates its value to other phis. If after propagation,','line_number':1939,'multiline':False]
['text':' the flag value changed, we have to reapply the algorithm on all phi operands, as a phi is a','line_number':1940,'multiline':False]
['text':' consumer if all of its uses are consumers.','line_number':1941,'multiline':False]
['text':' 2 - Determine which phis are producers. It's the same algorithm, except that we have to reapply','line_number':1942,'multiline':False]
['text':' the algorithm on all phi uses, as a phi is a producer if all of its operands are producers.','line_number':1943,'multiline':False]
['text':' 3 - Go through all commutative operations and ensure their inputs are all producers and their','line_number':1944,'multiline':False]
['text':' uses are all consumers.','line_number':1945,'multiline':False]
['text':'','line_number':1946,'multiline':False]
['text':' clang-format on ','line_number':1947,'multiline':True]
['text':' Iterate in postorder so worklist is initialized to RPO.','line_number':1951,'multiline':False]
['text':' unused ','line_number':1981,'multiline':True]
['text':' Propagate invalidated phis','line_number':1996,'multiline':False]
['text':' unused ','line_number':2001,'multiline':True]
['text':' Iterate in reverse postorder so worklist is initialized to PO.','line_number':2014,'multiline':False]
['text':' Propagate invalidated phis','line_number':2059,'multiline':False]
['text':' This call will try to specialize the instruction iff all uses are','line_number':2093,'multiline':False]
['text':' consumers and all inputs are producers.','line_number':2094,'multiline':False]
['text':' Asm.js uses the ahead of time type checks to specialize operations, no need','line_number':2119,'multiline':False]
['text':' to check them again at this point.','line_number':2120,'multiline':False]
['text':' Check ahead of time that there is at least one definition typed as Float32,','line_number':2125,'multiline':False]
['text':' otherwise we don't need this pass.','line_number':2126,'multiline':False]
['text':' Asserts that all Float32 instructions are flowing into Float32 consumers or','line_number':2145,'multiline':False]
['text':' specialized operations','line_number':2146,'multiline':False]
['text':' A utility for code which deletes blocks. Renumber the remaining blocks,','line_number':2202,'multiline':False]
['text':' recompute dominators, and optionally recompute AliasAnalysis dependencies.','line_number':2203,'multiline':False]
['text':' Renumber the blocks and clear out the old dominator info.','line_number':2207,'multiline':False]
['text':' Recompute dominator info.','line_number':2215,'multiline':False]
['text':' If needed, update alias analysis dependencies.','line_number':2220,'multiline':False]
['text':' Remove all blocks not marked with isMarked(). Unmark all remaining blocks.','line_number':2234,'multiline':False]
['text':' Alias analysis dependencies may be invalid after calling this function.','line_number':2235,'multiline':False]
['text':' If all blocks are marked, no blocks need removal. Just clear the','line_number':2239,'multiline':False]
['text':' marks. We'll still need to update the dominator tree below though,','line_number':2240,'multiline':False]
['text':' since we may have removed edges even if we didn't remove any blocks.','line_number':2241,'multiline':False]
['text':' As we are going to remove edges and basic blocks, we have to mark','line_number':2244,'multiline':False]
['text':' instructions which would be needed by baseline if we were to','line_number':2245,'multiline':False]
['text':' bailout.','line_number':2246,'multiline':False]
['text':' Find unmarked blocks and remove them.','line_number':2256,'multiline':False]
['text':' The block is unreachable. Clear out the loop header flag, as','line_number':2266,'multiline':False]
['text':' we're doing the sweep of a mark-and-sweep here, so we no longer','line_number':2267,'multiline':False]
['text':' need to worry about whether an unmarked block is a loop or not.','line_number':2268,'multiline':False]
['text':' Renumber the blocks and update the dominator tree.','line_number':2280,'multiline':False]
['text':'updateAliasAnalysis=','line_number':2281,'multiline':True]
['text':' A Simple, Fast Dominance Algorithm by Cooper et al.','line_number':2284,'multiline':False]
['text':' Modified to support empty intersections for OSR, and in RPO.','line_number':2285,'multiline':False]
['text':' In the original paper, the block ID comparisons are on the postorder index.','line_number':2294,'multiline':False]
['text':' This implementation iterates in RPO, so the comparisons are reversed.','line_number':2295,'multiline':False]
['text':' For this function to be called, the block must have multiple predecessors.','line_number':2297,'multiline':False]
['text':' If a finger is then found to be self-dominating, it must therefore be','line_number':2298,'multiline':False]
['text':' reachable from multiple roots through non-intersecting control flow.','line_number':2299,'multiline':False]
['text':' nullptr is returned in this case, to denote an empty intersection.','line_number':2300,'multiline':False]
['text':' Empty intersection.','line_number':2306,'multiline':False]
['text':' Empty intersection.','line_number':2314,'multiline':False]
['text':' The default start block is a root and therefore only self-dominates.','line_number':2329,'multiline':False]
['text':' Any OSR block is a root and therefore only self-dominates.','line_number':2333,'multiline':False]
['text':' For each block in RPO, intersect all dominators.','line_number':2346,'multiline':False]
['text':' If a node has once been found to have no exclusive dominator,','line_number':2348,'multiline':False]
['text':' it will never have an exclusive dominator, so it may be skipped.','line_number':2349,'multiline':False]
['text':' A block with no predecessors is not reachable from any entry, so','line_number':2354,'multiline':False]
['text':' it self-dominates.','line_number':2355,'multiline':False]
['text':' Find the first common dominator.','line_number':2363,'multiline':False]
['text':' If there is no common dominator, the block self-dominates.','line_number':2372,'multiline':False]
['text':' Assert that all blocks have dominator information.','line_number':2388,'multiline':False]
['text':' Traversing through the graph in post-order means that every non-phi use','line_number':2403,'multiline':False]
['text':' of a definition is visited before the def itself. Since a def','line_number':2404,'multiline':False]
['text':' dominates its uses, by the time we reach a particular','line_number':2405,'multiline':False]
['text':' block, we have processed all of its dominated children, so','line_number':2406,'multiline':False]
['text':' block->numDominated() is accurate.','line_number':2407,'multiline':False]
['text':' Dominance is defined such that blocks always dominate themselves.','line_number':2412,'multiline':False]
['text':' If the block only self-dominates, it has no definite parent.','line_number':2415,'multiline':False]
['text':' Add it to the worklist as a root for pre-order traversal.','line_number':2416,'multiline':False]
['text':' This includes all roots. Order does not matter.','line_number':2417,'multiline':False]
['text':' If compiling with OSR, many blocks will self-dominate.','line_number':2433,'multiline':False]
['text':' Without OSR, there is only one root block which dominates all.','line_number':2434,'multiline':False]
['text':' Now, iterate through the dominator tree in pre-order and annotate every','line_number':2439,'multiline':False]
['text':' block with its index in the traversal.','line_number':2440,'multiline':False]
['text':' Build a mapping such that given a basic block, whose successor has one or','line_number':2457,'multiline':False]
['text':' more phis, we can find our specific input to that phi. To make this fast','line_number':2458,'multiline':False]
['text':' mapping work we rely on a specific property of our structured control','line_number':2459,'multiline':False]
['text':' flow graph: For a block with phis, its predecessors each have only one','line_number':2460,'multiline':False]
['text':' successor with phis. Consider each case:','line_number':2461,'multiline':False]
['text':'   * Blocks with less than two predecessors cannot have phis.','line_number':2462,'multiline':False]
['text':'   * Breaks. A break always has exactly one successor, and the break','line_number':2463,'multiline':False]
['text':'             catch block has exactly one predecessor for each break, as','line_number':2464,'multiline':False]
['text':'             well as a final predecessor for the actual loop exit.','line_number':2465,'multiline':False]
['text':'   * Continues. A continue always has exactly one successor, and the','line_number':2466,'multiline':False]
['text':'             continue catch block has exactly one predecessor for each','line_number':2467,'multiline':False]
['text':'             continue, as well as a final predecessor for the actual','line_number':2468,'multiline':False]
['text':'             loop continuation. The continue itself has exactly one','line_number':2469,'multiline':False]
['text':'             successor.','line_number':2470,'multiline':False]
['text':'   * An if. Each branch as exactly one predecessor.','line_number':2471,'multiline':False]
['text':'   * A switch. Each branch has exactly one predecessor.','line_number':2472,'multiline':False]
['text':'   * Loop tail. A new block is always created for the exit, and if a','line_number':2473,'multiline':False]
['text':'             break statement is present, the exit block will forward','line_number':2474,'multiline':False]
['text':'             directly to the break block.','line_number':2475,'multiline':False]
['text':' Assert on the above.','line_number':2482,'multiline':False]
['text':' Assuming B = succ(A), verify A = pred(B).','line_number':2506,'multiline':False]
['text':' Assuming B = pred(A), verify A = succ(B).','line_number':2516,'multiline':False]
['text':' If you have issues with the usesBalance assertions, then define the macro','line_number':2525,'multiline':False]
['text':' _DEBUG_CHECK_OPERANDS_USES_BALANCE to spew information on the error output.','line_number':2526,'multiline':False]
['text':' This output can then be processed with the following awk script to filter and','line_number':2527,'multiline':False]
['text':' highlight which checks are missing or if there is an unexpected operand /','line_number':2528,'multiline':False]
['text':' use.','line_number':2529,'multiline':False]
['text':'','line_number':2530,'multiline':False]
['text':' define _DEBUG_CHECK_OPERANDS_USES_BALANCE 1','line_number':2531,'multiline':False]
['text':'

$ ./js 2>stderr.log
$ gawk '
    /^==Check/ { context = ""; state = $2; }
    /^[a-z]/ { context = context "\n\t" $0; }
    /^==End/ {
      if (state == "Operand") {
        list[context] = list[context] - 1;
      } else if (state == "Use") {
        list[context] = list[context] + 1;
      }
    }
    END {
      for (ctx in list) {
        if (list[ctx] > 0) {
          print "Missing operand check", ctx, "\n"
        }
        if (list[ctx] < 0) {
          print "Missing use check", ctx, "\n"
        }
      };
    }'  < stderr.log

','line_number':2532,'multiline':True]
['text':' To properly encode entry resume points, we have to ensure that all the','line_number':2594,'multiline':False]
['text':' operands of the entry resume point are located before the safeInsertTop','line_number':2595,'multiline':False]
['text':' location.','line_number':2596,'multiline':False]
['text':' DEBUG','line_number':2622,'multiline':False]
['text':' Assert successor and predecessor list coherency.','line_number':2645,'multiline':False]
['text':' We cannot yet assert that is there is no instruction then this is','line_number':2678,'multiline':False]
['text':' the entry resume point because we are still storing resume points','line_number':2679,'multiline':False]
['text':' in the InlinePropertyTable.','line_number':2680,'multiline':False]
['text':' Assert that use chains are valid for this instruction.','line_number':2704,'multiline':False]
['text':' The control instruction is not visited by the MDefinitionIterator.','line_number':2725,'multiline':False]
['text':' In case issues, see the _DEBUG_CHECK_OPERANDS_USES_BALANCE macro above.','line_number':2741,'multiline':False]
['text':' Check that every block is visited after all its predecessors (except','line_number':2750,'multiline':False]
['text':' backedges).','line_number':2751,'multiline':False]
['text':' Check dominators.','line_number':2774,'multiline':False]
['text':' see CodeGeneratorShared::encodeAllocation','line_number':2840,'multiline':False]
['text':' DEBUG','line_number':2899,'multiline':False]
['text':' Checks the basic GraphCoherency but also other conditions that','line_number':2903,'multiline':False]
['text':' do not hold immediately (such as the fact that critical edges','line_number':2904,'multiline':False]
['text':' are split)','line_number':2905,'multiline':False]
['text':' No critical edges:','line_number':2925,'multiline':False]
['text':' Fixup block.','line_number':2934,'multiline':False]
['text':' Verify that phi operands dominate the corresponding CFG predecessor','line_number':2966,'multiline':False]
['text':' edges.','line_number':2967,'multiline':False]
['text':' Verify that instructions are dominated by their operands.','line_number':2978,'multiline':False]
['text':' If the operand is an instruction in the same block, check','line_number':2988,'multiline':False]
['text':' that it comes first.','line_number':2989,'multiline':False]
['text':' Verify that the block resume points are dominated by their operands.','line_number':3006,'multiline':False]
['text':' Compute a hash for bounds checks which ignores constant offsets in the index.','line_number':3028,'multiline':False]
['text':' Since we are traversing the dominator tree in pre-order, when we','line_number':3039,'multiline':False]
['text':' are looking at the |index|-th block, the next numDominated() blocks','line_number':3040,'multiline':False]
['text':' we traverse are precisely the set of blocks that are dominated.','line_number':3041,'multiline':False]
['text':'','line_number':3042,'multiline':False]
['text':' So, this value is visible in all blocks if:','line_number':3043,'multiline':False]
['text':' index <= index + ins->block->numDominated()','line_number':3044,'multiline':False]
['text':' and becomes invalid after that.','line_number':3045,'multiline':False]
['text':' We didn't find a dominating bounds check.','line_number':3049,'multiline':False]
['text':' TruncateAfterBailouts is considered as infinite space because the','line_number':3073,'multiline':False]
['text':' LinearSum will effectively remove the bailout check.','line_number':3074,'multiline':False]
['text':' Extract a linear sum from ins, if possible (otherwise giving the','line_number':3091,'multiline':False]
['text':' sum 'ins + 0').','line_number':3092,'multiline':False]
['text':' Unwrap Int32ToIntPtr. This instruction only changes the representation','line_number':3100,'multiline':False]
['text':' (int32_t to intptr_t) without affecting the value.','line_number':3101,'multiline':False]
['text':' Only allow math which are in the same space.','line_number':3124,'multiline':False]
['text':' Extract linear sums of each operand.','line_number':3139,'multiline':False]
['text':' LinearSum only considers a single term operand, if both sides have','line_number':3143,'multiline':False]
['text':' terms, then ignore extracted linear sums.','line_number':3144,'multiline':False]
['text':' Check if this is of the form <SUM> + n or n + <SUM>.','line_number':3149,'multiline':False]
['text':' Check if this is of the form <SUM> - n.','line_number':3162,'multiline':False]
['text':' Ignore any of the form n - <SUM>.','line_number':3174,'multiline':False]
['text':' Extract a linear inequality holding when a boolean test goes in the','line_number':3178,'multiline':False]
['text':' specified direction, of the form 'lhs + lhsN <= rhs' (or >=).','line_number':3179,'multiline':False]
['text':' TODO: optimize Compare_UInt32','line_number':3192,'multiline':False]
['text':' Normalize operations to use <= or >=.','line_number':3212,'multiline':False]
['text':' x < y ==> x + 1 <= y ','line_number':3218,'multiline':True]
['text':' x > y ==> x - 1 >= y ','line_number':3228,'multiline':True]
['text':' Replace all uses of the bounds check with the actual index.','line_number':3248,'multiline':False]
['text':' This is (a) necessary, because we can coalesce two different','line_number':3249,'multiline':False]
['text':' bounds checks and would otherwise use the wrong index and','line_number':3250,'multiline':False]
['text':' (b) helps register allocation. Note that this is safe since','line_number':3251,'multiline':False]
['text':' no other pass after bounds check elimination moves instructions.','line_number':3252,'multiline':False]
['text':' We didn't find a dominating bounds check.','line_number':3270,'multiline':False]
['text':' We found two bounds checks with the same hash number, but we still have','line_number':3274,'multiline':False]
['text':' to make sure the lengths and index terms are equal.','line_number':3275,'multiline':False]
['text':' Both terms should be nullptr or the same definition.','line_number':3283,'multiline':False]
['text':' This bounds check is redundant.','line_number':3288,'multiline':False]
['text':' Normalize the ranges according to the constant offsets in the two indexes.','line_number':3291,'multiline':False]
['text':' Update the dominating check to cover both ranges, denormalizing the','line_number':3300,'multiline':False]
['text':' result per the constant offset in the index.','line_number':3301,'multiline':False]
['text':' Eliminate checks which are redundant given each other or other instructions.','line_number':3315,'multiline':False]
['text':'','line_number':3316,'multiline':False]
['text':' A bounds check is considered redundant if it's dominated by another bounds','line_number':3317,'multiline':False]
['text':' check with the same length and the indexes differ by only a constant amount.','line_number':3318,'multiline':False]
['text':' In this case we eliminate the redundant bounds check and update the other one','line_number':3319,'multiline':False]
['text':' to cover the ranges of both checks.','line_number':3320,'multiline':False]
['text':'','line_number':3321,'multiline':False]
['text':' Bounds checks are added to a hash map and since the hash function ignores','line_number':3322,'multiline':False]
['text':' differences in constant offset, this offers a fast way to find redundant','line_number':3323,'multiline':False]
['text':' checks.','line_number':3324,'multiline':False]
['text':' Stack for pre-order CFG traversal.','line_number':3328,'multiline':False]
['text':' The index of the current block in the CFG traversal.','line_number':3331,'multiline':False]
['text':' Add all self-dominating blocks to the worklist.','line_number':3334,'multiline':False]
['text':' This includes all roots. Order does not matter.','line_number':3335,'multiline':False]
['text':' Starting from each self-dominating block, traverse the CFG in pre-order.','line_number':3347,'multiline':False]
['text':' Add all immediate dominators to the front of the worklist.','line_number':3351,'multiline':False]
['text':' Constants are kept alive by other pointers, for instance','line_number':3461,'multiline':False]
['text':' ImmGCPtr in JIT code.','line_number':3462,'multiline':False]
['text':' StoreElementHole has an explicit object operand. If GVN','line_number':3470,'multiline':False]
['text':' is disabled, we can get different unbox instructions with','line_number':3471,'multiline':False]
['text':' the same object as input, so we check for that case.','line_number':3472,'multiline':False]
['text':' See StoreElementHole case above.','line_number':3480,'multiline':False]
['text':' = 1 ','line_number':3533,'multiline':True]
['text':' Mark all the blocks that are in the loop with the given header.','line_number':3691,'multiline':False]
['text':' Returns the number of blocks marked. Set *canOsr to true if the loop is','line_number':3692,'multiline':False]
['text':' reachable from both the normal entry and the OSR entry.','line_number':3693,'multiline':False]
['text':' The blocks are in RPO; start at the loop backedge, which marks the bottom','line_number':3705,'multiline':False]
['text':' of the loop, and walk up until we get to the header. Loops may be','line_number':3706,'multiline':False]
['text':' discontiguous, so we trace predecessors to determine which blocks are','line_number':3707,'multiline':False]
['text':' actually part of the loop. The backedge is always part of the loop, and','line_number':3708,'multiline':False]
['text':' so are its predecessors, transitively, up to the loop header or an OSR','line_number':3709,'multiline':False]
['text':' entry.','line_number':3710,'multiline':False]
['text':' If we've reached the loop header, we're done.','line_number':3719,'multiline':False]
['text':' A block not marked by the time we reach it is not in the loop.','line_number':3723,'multiline':False]
['text':' This block is in the loop; trace to its predecessors.','line_number':3728,'multiline':False]
['text':' Blocks dominated by the OSR entry are not part of the loop','line_number':3735,'multiline':False]
['text':' (unless they aren't reachable from the normal entry).','line_number':3736,'multiline':False]
['text':' A nested loop may not exit back to the enclosing loop at its','line_number':3749,'multiline':False]
['text':' bottom. If we just marked its header, then the whole nested loop','line_number':3750,'multiline':False]
['text':' is part of the enclosing loop.','line_number':3751,'multiline':False]
['text':' Mark its backedge so that we add all of its blocks to the','line_number':3755,'multiline':False]
['text':' outer loop as we walk upwards.','line_number':3756,'multiline':False]
['text':' If the nested loop is not contiguous, we may have already','line_number':3760,'multiline':False]
['text':' passed its backedge. If this happens, back up.','line_number':3761,'multiline':False]
['text':' If there's no path connecting the header to the backedge, then this isn't','line_number':3771,'multiline':False]
['text':' actually a loop. This can happen when the code starts with a loop but GVN','line_number':3772,'multiline':False]
['text':' folds some branches away.','line_number':3773,'multiline':False]
['text':' Unmark all the blocks that are in the loop with the given header.','line_number':3782,'multiline':False]
['text':' This pass folds MLoadFixedSlot, MLoadDynamicSlot, MLoadElement instructions','line_number':3806,'multiline':False]
['text':' followed by MUnbox into a single instruction. For LoadElement this allows','line_number':3807,'multiline':False]
['text':' us to fuse the hole check with the type check for the unbox.','line_number':3808,'multiline':False]
['text':' We're only interested in loads producing a Value.','line_number':3821,'multiline':False]
['text':' Ensure there's a single def-use (ignoring resume points) and it's an','line_number':3832,'multiline':False]
['text':' unbox.','line_number':3833,'multiline':False]
['text':' For now require the load and unbox to be in the same block. This isn't','line_number':3842,'multiline':False]
['text':' strictly necessary but it's the common case and could prevent bailouts','line_number':3843,'multiline':False]
['text':' when moving the unbox before a loop.','line_number':3844,'multiline':False]
['text':' If this is a LoadElement that needs a hole check, we only support','line_number':3852,'multiline':False]
['text':' folding it with a fallible unbox so that we can eliminate the hole','line_number':3853,'multiline':False]
['text':' check.','line_number':3854,'multiline':False]
['text':' Combine the load and unbox into a single MIR instruction.','line_number':3860,'multiline':False]
['text':' Reorder the blocks in the loop starting at the given header to be contiguous.','line_number':3908,'multiline':False]
['text':' If there are any blocks between the loop header and the loop backedge','line_number':3916,'multiline':False]
['text':' that are not part of the loop, prepare to move them to the end. We keep','line_number':3917,'multiline':False]
['text':' them in order, which preserves RPO.','line_number':3918,'multiline':False]
['text':' Visit all the blocks from the loop header to the loop backedge.','line_number':3923,'multiline':False]
['text':' This block is in the loop.','line_number':3934,'multiline':False]
['text':' If we've reached the loop backedge, we're done!','line_number':3937,'multiline':False]
['text':' This block is not in the loop. Move it to the end.','line_number':3942,'multiline':False]
['text':' Reorder the blocks in the graph so that loops are contiguous.','line_number':3955,'multiline':False]
['text':' Visit all loop headers (in any order).','line_number':3957,'multiline':False]
['text':' Mark all blocks that are actually part of the loop.','line_number':3964,'multiline':False]
['text':' If the loop isn't a loop, don't try to optimize it.','line_number':3968,'multiline':False]
['text':' If there's an OSR block entering the loop in the middle, it's tricky,','line_number':3973,'multiline':False]
['text':' so don't try to handle it, for now.','line_number':3974,'multiline':False]
['text':' Move all blocks between header and backedge that aren't marked to','line_number':3980,'multiline':False]
['text':' the end of the loop, making the loop itself contiguous.','line_number':3981,'multiline':False]
