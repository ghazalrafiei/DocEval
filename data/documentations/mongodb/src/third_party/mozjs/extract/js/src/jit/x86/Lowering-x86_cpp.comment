['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' If the box wrapped a double, it needs a new register.','line_number':46,'multiline':False]
['text':' Otherwise, we should not define a new register for the payload portion','line_number':69,'multiline':False]
['text':' of the output, so bypass defineBox().','line_number':70,'multiline':False]
['text':' Note that because we're using BogusTemp(), we do not change the type of','line_number':73,'multiline':False]
['text':' the definition. We also do not define the first output as "TYPE",','line_number':74,'multiline':False]
['text':' because it has no corresponding payload at (vreg + 1). Also note that','line_number':75,'multiline':False]
['text':' although we copy the input's original type for the payload half of the','line_number':76,'multiline':False]
['text':' definition, this is only for clarity. BogusTemp() definitions are','line_number':77,'multiline':False]
['text':' ignored.','line_number':78,'multiline':False]
['text':' An unbox on x86 reads in a type tag (either in memory or a register) and','line_number':88,'multiline':False]
['text':' a payload. Unlike most instructions consuming a box, we ask for the type','line_number':89,'multiline':False]
['text':' second, so that the result can re-use the first input.','line_number':90,'multiline':False]
['text':' Swap the order we use the box pieces so we can re-use the payload register.','line_number':105,'multiline':False]
['text':' Types and payloads form two separate intervals. If the type becomes dead','line_number':122,'multiline':False]
['text':' before the payload, it could be used as a Value without the type being','line_number':123,'multiline':False]
['text':' recoverable. Unbox's purpose is to eagerly kill the definition of a type','line_number':124,'multiline':False]
['text':' tag, so keeping both alive (for the purpose of gcmaps) is unappealing.','line_number':125,'multiline':False]
['text':' Instead, we create a new virtual register.','line_number':126,'multiline':False]
['text':' See special cases in CodeGeneratorX86Shared::visitMulI64.','line_number':200,'multiline':False]
['text':' MulI64 on x86 needs output to be in edx, eax;','line_number':209,'multiline':False]
['text':'useAtStart = ','line_number':211,'multiline':True]
['text':' useI386ByteRegisters = ','line_number':242,'multiline':True]
['text':'useI386ByteRegisters=','line_number':264,'multiline':True]
['text':' Case 1: the result of the operation is not used.','line_number':279,'multiline':False]
['text':'','line_number':280,'multiline':False]
['text':' We can omit allocating the result BigInt.','line_number':281,'multiline':False]
['text':' Case 2: the result of the operation is used.','line_number':292,'multiline':False]
['text':' useI386ByteRegisters = ','line_number':301,'multiline':True]
['text':' If the base is a constant, and it is zero or its offset is zero, then','line_number':340,'multiline':False]
['text':' code generation will fold the values into the access.  Allocate the','line_number':341,'multiline':False]
['text':' pointer to a register only if that can't happen.','line_number':342,'multiline':False]
['text':' For int64 accesses on 32-bit systems we will need to add another offset','line_number':353,'multiline':False]
['text':' of 4 to access the high part of the value; make sure this does not','line_number':354,'multiline':False]
['text':' overflow the value.','line_number':355,'multiline':False]
['text':' "AtStart" register usage does not work for the 64-bit case because we','line_number':402,'multiline':False]
['text':' clobber two registers for the result and may need two registers for a','line_number':403,'multiline':False]
['text':' scaled address; we can't guarantee non-interference.','line_number':404,'multiline':False]
['text':' We use cdq to sign-extend the result and cdq demands these registers.','line_number':411,'multiline':False]
['text':' See comment for LIRGeneratorX86::useByteOpRegister.','line_number':446,'multiline':False]
['text':' For now, don't allow constant values. The immediate operand affects','line_number':455,'multiline':False]
['text':' instruction layout which affects patching.','line_number':456,'multiline':False]
['text':' Register allocation:','line_number':507,'multiline':False]
['text':'','line_number':508,'multiline':False]
['text':' The output may not be used, but eax will be clobbered regardless','line_number':509,'multiline':False]
['text':' so pin the output to eax.','line_number':510,'multiline':False]
['text':'','line_number':511,'multiline':False]
['text':' oldval must be in a register.','line_number':512,'multiline':False]
['text':'','line_number':513,'multiline':False]
['text':' newval must be in a register.  If the source is a byte array','line_number':514,'multiline':False]
['text':' then newval must be a register that has a byte size: this must','line_number':515,'multiline':False]
['text':' be ebx, ecx, or edx (eax is taken).','line_number':516,'multiline':False]
['text':'','line_number':517,'multiline':False]
['text':' Bug #1077036 describes some optimization opportunities.','line_number':518,'multiline':False]
['text':' Case 1: the result of the operation is not used.','line_number':582,'multiline':False]
['text':'','line_number':583,'multiline':False]
['text':' We'll emit a single instruction: LOCK ADD, LOCK SUB, LOCK AND,','line_number':584,'multiline':False]
['text':' LOCK OR, or LOCK XOR.  These can all take an immediate.','line_number':585,'multiline':False]
['text':' Case 2: the result of the operation is used.','line_number':603,'multiline':False]
['text':'','line_number':604,'multiline':False]
['text':' For ADD and SUB we'll use XADD:','line_number':605,'multiline':False]
['text':'','line_number':606,'multiline':False]
['text':'    movl       value, output','line_number':607,'multiline':False]
['text':'    lock xaddl output, mem','line_number':608,'multiline':False]
['text':'','line_number':609,'multiline':False]
['text':' For the 8-bit variants XADD needs a byte register for the','line_number':610,'multiline':False]
['text':' output only, we can still set up with movl; just pin the output','line_number':611,'multiline':False]
['text':' to eax (or ebx / ecx / edx).','line_number':612,'multiline':False]
['text':'','line_number':613,'multiline':False]
['text':' For AND/OR/XOR we need to use a CMPXCHG loop:','line_number':614,'multiline':False]
['text':'','line_number':615,'multiline':False]
['text':'    movl          *mem, eax','line_number':616,'multiline':False]
['text':' L: mov           eax, temp','line_number':617,'multiline':False]
['text':'    andl          value, temp','line_number':618,'multiline':False]
['text':'    lock cmpxchg  temp, mem  ; reads eax also','line_number':619,'multiline':False]
['text':'    jnz           L','line_number':620,'multiline':False]
['text':'    ; result in eax','line_number':621,'multiline':False]
['text':'','line_number':622,'multiline':False]
['text':' Note the placement of L, cmpxchg will update eax with *mem if','line_number':623,'multiline':False]
['text':' *mem does not have the expected value, so reloading it at the','line_number':624,'multiline':False]
['text':' top of the loop would be redundant.','line_number':625,'multiline':False]
['text':'','line_number':626,'multiline':False]
['text':' We want to fix eax as the output.  We also need a temp for','line_number':627,'multiline':False]
['text':' the intermediate value.','line_number':628,'multiline':False]
['text':'','line_number':629,'multiline':False]
['text':' For the 8-bit variants the temp must have a byte register.','line_number':630,'multiline':False]
['text':'','line_number':631,'multiline':False]
['text':' There are optimization opportunities:','line_number':632,'multiline':False]
['text':'  - better 8-bit register allocation and instruction selection, Bug','line_number':633,'multiline':False]
['text':'  #1077036.','line_number':634,'multiline':False]
['text':' Due to lack of registers on x86, we reuse the string register as','line_number':747,'multiline':False]
['text':' temporary. As a result we only need two temporary registers and take a','line_number':748,'multiline':False]
['text':' bugos temporary as fifth argument.','line_number':749,'multiline':False]
['text':' Here we'll end up using cdq which requires input and output in (edx,eax).','line_number':807,'multiline':False]
