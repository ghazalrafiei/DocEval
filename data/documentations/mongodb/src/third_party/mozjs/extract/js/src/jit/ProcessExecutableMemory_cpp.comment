['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' js::jit::FlushICache','line_number':26,'multiline':False]
['text':' Nothing.','line_number':38,'multiline':False]
['text':'
   * Inspiration is V8's OS::Allocate in platform-win32.cc.
   *
   * VirtualAlloc takes 64K chunks out of the virtual address space, so we
   * keep 16b alignment.
   *
   * x86: V8 comments say that keeping addresses in the [64MiB, 1GiB) range
   * tries to avoid system default DLL mapping space. In the end, we get 13
   * bits of randomness in our selection.
   * x64: [2GiB, 4TiB), with 25 bits of randomness.
   ','line_number':57,'multiline':True]
['text':' Just do nothing if unwind handling is disabled.','line_number':91,'multiline':False]
['text':' See the ".xdata records" section of','line_number':97,'multiline':False]
['text':' https://docs.microsoft.com/en-us/cpp/build/arm64-exception-handling','line_number':98,'multiline':False]
['text':' These records can have various fields present or absent depending on the','line_number':99,'multiline':False]
['text':' bits set in the header. Our struct will use one 32-bit slot for unwind codes,','line_number':100,'multiline':False]
['text':' and no slots for epilog scopes.','line_number':101,'multiline':False]
['text':' From documentation for UNWIND_INFO on','line_number':114,'multiline':False]
['text':' http://msdn.microsoft.com/en-us/library/ddssxxy8.aspx','line_number':115,'multiline':False]
['text':' This function must match the function pointer type PEXCEPTION_HANDLER','line_number':134,'multiline':False]
['text':' mentioned in:','line_number':135,'multiline':False]
['text':'   http://msdn.microsoft.com/en-us/library/ssa62fwe.aspx.','line_number':136,'multiline':False]
['text':' This type is rather elusive in documentation; Wine is the best I've found:','line_number':137,'multiline':False]
['text':'   http://source.winehq.org/source/include/winnt.h','line_number':138,'multiline':False]
['text':' For an explanation of the problem being solved here, see','line_number':147,'multiline':False]
['text':' SetJitExceptionFilter in jsfriendapi.h.','line_number':148,'multiline':False]
['text':' Because the .xdata format on ARM64 can only encode sizes up to 1M (much','line_number':157,'multiline':False]
['text':' too small for our JIT code regions), we register a function table callback','line_number':158,'multiline':False]
['text':' to provide RUNTIME_FUNCTIONs at runtime. Windows doesn't seem to care about','line_number':159,'multiline':False]
['text':' the size fields on RUNTIME_FUNCTIONs that are created in this way, so the','line_number':160,'multiline':False]
['text':' same RUNTIME_FUNCTION can work for any address in the region. We'll set up','line_number':161,'multiline':False]
['text':' a generic one now and the callback can just return a pointer to it.','line_number':162,'multiline':False]
['text':' All these fields are specified to be offsets from the base of the','line_number':164,'multiline':False]
['text':' executable code (which is 'p'), even if they have 'Address' in their','line_number':165,'multiline':False]
['text':' names. In particular, exceptionHandler is a ULONG offset which is a','line_number':166,'multiline':False]
['text':' 32-bit integer. Since 'p' can be farther than INT32_MAX away from','line_number':167,'multiline':False]
['text':' sJitExceptionHandler, we must generate a little thunk inside the','line_number':168,'multiline':False]
['text':' record. The record is put on its own page so that we can take away write','line_number':169,'multiline':False]
['text':' access to protect against accidental clobbering.','line_number':170,'multiline':False]
['text':' Use a fake unwind code to make the Windows unwinder do _something_. If the','line_number':183,'multiline':False]
['text':' PC and SP both stay unchanged, we'll fail the unwinder's sanity checks and','line_number':184,'multiline':False]
['text':' it won't call our exception handler.','line_number':185,'multiline':False]
['text':' one 32-bit word gives us up to 4 codes','line_number':186,'multiline':False]
['text':' alloc_s small stack of size 1*16','line_number':188,'multiline':False]
['text':' end','line_number':189,'multiline':False]
['text':' xip0/r16 should be safe to clobber: Windows just used it to call our thunk.','line_number':194,'multiline':False]
['text':' Say `handler` is 0x4444333322221111, then:','line_number':197,'multiline':False]
['text':' mov  xip0, 1111','line_number':198,'multiline':False]
['text':' movk xip0, 2222 lsl #0x10','line_number':199,'multiline':False]
['text':' movk xip0, 3333 lsl #0x20','line_number':200,'multiline':False]
['text':' movk xip0, 4444 lsl #0x30','line_number':201,'multiline':False]
['text':' br xip0','line_number':202,'multiline':False]
['text':' mov imm64, rax','line_number':216,'multiline':False]
['text':' jmp rax','line_number':221,'multiline':False]
['text':' XXX NB: The profiler believes this function is only called from the main','line_number':231,'multiline':False]
['text':' thread. If that ever becomes untrue, the profiler must be updated','line_number':232,'multiline':False]
['text':' immediately.','line_number':233,'multiline':False]
['text':' There's no such thing as RtlUninstallFunctionTableCallback, so there's','line_number':240,'multiline':False]
['text':' nothing to do here.','line_number':241,'multiline':False]
['text':' Try again without randomization.','line_number':263,'multiline':False]
['text':' !XP_WIN && !__wasi__','line_number':342,'multiline':False]
['text':' OpenBSD already has random mmap and the idea that all x64 cpus','line_number':349,'multiline':False]
['text':' have 48-bit address space is not correct. Returning nullptr','line_number':350,'multiline':False]
['text':' allows OpenBSD do to the right thing.','line_number':351,'multiline':False]
['text':' x64 CPUs have a 48-bit address space and on some platforms the OS will','line_number':357,'multiline':False]
['text':' give us access to 47 bits, so to be safe we right shift by 18 to leave','line_number':358,'multiline':False]
['text':' 46 bits.','line_number':359,'multiline':False]
['text':' On 32-bit, right shift by 34 to leave 30 bits, range [0, 1GiB). Then add','line_number':362,'multiline':False]
['text':' 512MiB to get range [512MiB, 1.5GiB), or [0x20000000, 0x60000000). This','line_number':363,'multiline':False]
['text':' is based on V8 comments in platform-posix.cc saying this range is','line_number':364,'multiline':False]
['text':' relatively unpopulated across a variety of kernels.','line_number':365,'multiline':False]
['text':' Ensure page alignment.','line_number':370,'multiline':False]
['text':' Note that randomAddr is just a hint: if the address is not available','line_number':377,'multiline':False]
['text':' mmap will pick a different address.','line_number':378,'multiline':False]
['text':' If we're configured for Valgrind and running on it, use a slacker','line_number':396,'multiline':False]
['text':' scheme that doesn't change execute permissions, since doing so causes','line_number':397,'multiline':False]
['text':' Valgrind a lot of extra overhead re-JITting code that loses and later','line_number':398,'multiline':False]
['text':' regains execute permission.  See bug 1338179.','line_number':399,'multiline':False]
['text':' If we get here, we're configured for Valgrind but not running on','line_number':411,'multiline':False]
['text':' it, so use the standard scheme.','line_number':412,'multiline':False]
['text':' Use mmap with MAP_FIXED and PROT_NONE. Inspired by jemalloc's','line_number':438,'multiline':False]
['text':' pages_decommit.','line_number':439,'multiline':False]
['text':' Per-process executable memory allocator. It reserves a block of memory of','line_number':496,'multiline':False]
['text':' MaxCodeBytesPerProcess bytes, then allocates/deallocates pages from that.','line_number':497,'multiline':False]
['text':'','line_number':498,'multiline':False]
['text':' This has a number of benefits compared to raw mmap/VirtualAlloc:','line_number':499,'multiline':False]
['text':'','line_number':500,'multiline':False]
['text':' * More resillient against certain attacks.','line_number':501,'multiline':False]
['text':'','line_number':502,'multiline':False]
['text':' * Behaves more consistently across platforms: it avoids the 64K granularity','line_number':503,'multiline':False]
['text':'   issues on Windows, for instance.','line_number':504,'multiline':False]
['text':'','line_number':505,'multiline':False]
['text':' * On x64, near jumps can be used for jumps to other JIT pages.','line_number':506,'multiline':False]
['text':'','line_number':507,'multiline':False]
['text':' * On Win64, we have to register the exception handler only once (at process','line_number':508,'multiline':False]
['text':'   startup). This saves some memory and avoids RtlAddFunctionTable profiler','line_number':509,'multiline':False]
['text':'   deadlocks.','line_number':510,'multiline':False]
['text':' Start of the MaxCodeBytesPerProcess memory block or nullptr if','line_number':518,'multiline':False]
['text':' uninitialized. Note that this is NOT guaranteed to be aligned to','line_number':519,'multiline':False]
['text':' ExecutableCodePageSize.','line_number':520,'multiline':False]
['text':' The fields below should only be accessed while we hold the lock.','line_number':523,'multiline':False]
['text':' pagesAllocated_ is an Atomic so that bytesAllocated does not have to','line_number':526,'multiline':False]
['text':' take the lock.','line_number':527,'multiline':False]
['text':' Page where we should try to allocate next.','line_number':530,'multiline':False]
['text':' Take the lock and try to allocate.','line_number':612,'multiline':False]
['text':' Check if we have enough pages available.','line_number':618,'multiline':False]
['text':' Maybe skip a page to make allocations less predictable.','line_number':625,'multiline':False]
['text':' Make sure page + numPages - 1 is a valid index.','line_number':629,'multiline':False]
['text':' Mark the pages as unavailable.','line_number':646,'multiline':False]
['text':' If we allocated a small number of pages, move cursor_ to the','line_number':654,'multiline':False]
['text':' next page. We don't do this for larger allocations to avoid','line_number':655,'multiline':False]
['text':' skipping a large number of small holes.','line_number':656,'multiline':False]
['text':' Commit the pages after releasing the lock.','line_number':669,'multiline':False]
['text':' decommit = ','line_number':671,'multiline':True]
['text':' Decommit before taking the lock.','line_number':694,'multiline':False]
['text':' Move the cursor back so we can reuse pages instead of fragmenting the','line_number':708,'multiline':False]
['text':' whole region.','line_number':709,'multiline':False]
['text':' decommit = ','line_number':724,'multiline':True]
['text':' Initialize instruction cache flushing.','line_number':729,'multiline':False]
['text':' Round down available memory to the closest MB.','line_number':740,'multiline':False]
['text':' Use a 8 MB buffer.','line_number':746,'multiline':False]
['text':' Flush ICache when making code executable, before we modify |size|.','line_number':761,'multiline':False]
['text':' Calculate the start of the page containing this region,','line_number':769,'multiline':False]
['text':' and account for this extra memory within size.','line_number':770,'multiline':False]
['text':' Round size up','line_number':777,'multiline':False]
['text':' On weak memory systems, make sure new code is visible on all cores before','line_number':785,'multiline':False]
['text':' addresses of the code are made public.  Now is the latest moment in time','line_number':786,'multiline':False]
['text':' when we can do that, and we're assuming that every other thread that has','line_number':787,'multiline':False]
['text':' written into the memory that is being reprotected here has synchronized','line_number':788,'multiline':False]
['text':' with this thread in such a way that the memory writes have become visible','line_number':789,'multiline':False]
['text':' and we therefore only need to execute the fence once here.  See bug 1529933','line_number':790,'multiline':False]
['text':' for a longer discussion of why this is both necessary and sufficient.','line_number':791,'multiline':False]
['text':'','line_number':792,'multiline':False]
['text':' We use the C++ fence here -- and not AtomicOperations::fenceSeqCst() --','line_number':793,'multiline':False]
['text':' primarily because ReprotectRegion will be called while we construct our own','line_number':794,'multiline':False]
['text':' jitted atomics.  But the C++ fence is sufficient and correct, too.','line_number':795,'multiline':False]
['text':' __wasi__','line_number':813,'multiline':False]
['text':' RegisterExecutableMemory already set up the runtime function in the','line_number':824,'multiline':False]
['text':' exception-data page preceding the allocation.','line_number':825,'multiline':False]
