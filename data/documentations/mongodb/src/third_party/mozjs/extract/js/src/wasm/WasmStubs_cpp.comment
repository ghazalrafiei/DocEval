['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 *
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ','line_number':1,'multiline':True]
['text':'***************************************************************************','line_number':44,'multiline':True]
['text':' ABIResultIter implementation','line_number':45,'multiline':False]
['text':' If we've gone this far, it means we're actually using the debugging','line_number':193,'multiline':False]
['text':' strings. In this case, we leak them! This is only for debugging, and','line_number':194,'multiline':False]
['text':' doing the right thing is cumbersome (in Ion, it'd mean add a vec of','line_number':195,'multiline':False]
['text':' strings to the IonScript; in wasm, it'd mean add it to the current','line_number':196,'multiline':False]
['text':' Module and serialize it properly).','line_number':197,'multiline':False]
['text':' TODO: We might try to do something meaningful here once SIMD data are','line_number':284,'multiline':False]
['text':' aligned and hence C++-ABI compliant.  For now, just make ourselves visible.','line_number':285,'multiline':False]
['text':' On old ARM hardware, constant pools could be inserted and they need to','line_number':309,'multiline':False]
['text':' be flushed before considering the size of the masm.','line_number':310,'multiline':False]
['text':' Copy parameters out of argv and into the registers/stack-slots specified by','line_number':363,'multiline':False]
['text':' the wasm ABI.','line_number':364,'multiline':False]
['text':'','line_number':365,'multiline':False]
['text':' SetupABIArguments are only used for C++ -> wasm calls through callExport(),','line_number':366,'multiline':False]
['text':' and V128 and Ref types (other than externref) are not currently allowed.','line_number':367,'multiline':False]
['text':' This is only used by the testing invoke path,','line_number':409,'multiline':False]
['text':' wasmLosslessInvoke, and is guarded against in normal JS-API','line_number':410,'multiline':False]
['text':' call paths.','line_number':411,'multiline':False]
['text':' This is only used by the testing invoke path,','line_number':456,'multiline':False]
['text':' wasmLosslessInvoke, and is guarded against in normal JS-API','line_number':457,'multiline':False]
['text':' call paths.','line_number':458,'multiline':False]
['text':' The ARM system ABI also includes d15 & s31 in the non volatile float','line_number':528,'multiline':False]
['text':' registers. Also exclude lr (a.k.a. r14) as we preserve it manually.','line_number':529,'multiline':False]
['text':' Exclude the Link Register (x30) because it is preserved manually.','line_number':537,'multiline':False]
['text':'','line_number':538,'multiline':False]
['text':' Include x16 (scratch) to make a 16-byte aligned amount of integer registers.','line_number':539,'multiline':False]
['text':' Include d31 (scratch) to make a 16-byte aligned amount of floating registers.','line_number':540,'multiline':False]
['text':' tls and argv','line_number':553,'multiline':False]
['text':' Since we're asserting that SP is the currently active stack pointer,','line_number':565,'multiline':False]
['text':' let's also in effect assert that PSP is dead -- by setting it to 1, so as','line_number':566,'multiline':False]
['text':' to cause to cause any attempts to use it to segfault in an easily','line_number':567,'multiline':False]
['text':' identifiable way.','line_number':568,'multiline':False]
['text':' Allocate a pad word so that SP can remain properly aligned.  |op| will be','line_number':577,'multiline':False]
['text':' written at the lower-addressed of the two words pushed here.','line_number':578,'multiline':False]
['text':' Also pop the pad word allocated by WasmPush.','line_number':588,'multiline':False]
['text':' Strings are currently boxed','line_number':613,'multiline':False]
['text':' Unboxing is branchy and contorted because of Spectre mitigations - we don't','line_number':615,'multiline':False]
['text':' have enough scratch registers.  Were it not for the spectre mitigations in','line_number':616,'multiline':False]
['text':' branchTestObjClass, the branch nest below would be restructured significantly','line_number':617,'multiline':False]
['text':' by inverting branches and using fewer registers.','line_number':618,'multiline':False]
['text':' Unbox an anyref in src (clobbering src in the process) and then re-box it as','line_number':620,'multiline':False]
['text':' a Value in *dst.  See the definition of AnyRef for a discussion of pointer','line_number':621,'multiline':False]
['text':' representation.','line_number':622,'multiline':False]
['text':' Not actually the value we're passing, but we've no way of','line_number':628,'multiline':False]
['text':' decoding anything better.','line_number':629,'multiline':False]
['text':' The type test will clear src if the test fails, so store early.','line_number':638,'multiline':False]
['text':' Spectre mitigations: see comment above about efficiency.','line_number':640,'multiline':False]
['text':' Unbox an anyref in src and then re-box it as a Value in dst.','line_number':652,'multiline':False]
['text':' See the definition of AnyRef for a discussion of pointer representation.','line_number':653,'multiline':False]
['text':' Not actually the value we're passing, but we've no way of','line_number':665,'multiline':False]
['text':' decoding anything better.','line_number':666,'multiline':False]
['text':' The type test will clear src if the test fails, so store early.','line_number':675,'multiline':False]
['text':' Spectre mitigations: see comment above about efficiency.','line_number':677,'multiline':False]
['text':' Box the Value in src as an anyref in dest.  src and dest must not overlap.','line_number':689,'multiline':False]
['text':' See the definition of AnyRef for a discussion of pointer representation.','line_number':690,'multiline':False]
['text':' Generate a stub that enters wasm from a C++ caller via the native ABI. The','line_number':712,'multiline':False]
['text':' signature of the entry point is Module::ExportFuncPtr. The exported wasm','line_number':713,'multiline':False]
['text':' function has an ABI derived from its specific signature, so this function','line_number':714,'multiline':False]
['text':' must map from the ABI of ExportFuncPtr to the export's signature's ABI.','line_number':715,'multiline':False]
['text':' Save the return address if it wasn't already saved by the call insn.','line_number':724,'multiline':False]
['text':' WasmPush updates framePushed() unlike pushReturnAddress(), but that's','line_number':730,'multiline':False]
['text':' cancelled by the setFramePushed() below.','line_number':731,'multiline':False]
['text':' Save all caller non-volatile registers before we clobber them here and in','line_number':738,'multiline':False]
['text':' the wasm callee (which does not preserve non-volatile registers).','line_number':739,'multiline':False]
['text':' Put the 'argv' argument into a non-argument/return/TLS register so that','line_number':748,'multiline':False]
['text':' we can use 'argv' while we fill in the arguments for the wasm callee.','line_number':749,'multiline':False]
['text':' Use a second non-argument/return register as temporary scratch.','line_number':750,'multiline':False]
['text':' Read the arguments of wasm::ExportFuncPtr according to the native ABI.','line_number':754,'multiline':False]
['text':' The entry stub's frame is 1 word.','line_number':755,'multiline':False]
['text':' arg 1: ExportArg*','line_number':760,'multiline':False]
['text':' Arg 2: TlsData*','line_number':770,'multiline':False]
['text':' Save 'argv' on the stack so that we can recover it after the call.','line_number':782,'multiline':False]
['text':' Since we're about to dynamically align the stack, reset the frame depth','line_number':785,'multiline':False]
['text':' so we can still assert static stack depth balancing.','line_number':786,'multiline':False]
['text':' Dynamically align the stack since ABIStackAlignment is not necessarily','line_number':793,'multiline':False]
['text':' WasmStackAlignment. Preserve SP so it can be restored after the call.','line_number':794,'multiline':False]
['text':' Reserve stack space for the wasm call.','line_number':803,'multiline':False]
['text':' Copy parameters out of argv and into the wasm ABI registers/stack-slots.','line_number':809,'multiline':False]
['text':' Setup wasm register state. The nullness of the frame pointer is used to','line_number':812,'multiline':False]
['text':' determine whether the call ended in success or failure.','line_number':813,'multiline':False]
['text':' Call into the real function. Note that, due to the throw stub, fp, tls','line_number':820,'multiline':False]
['text':' and pinned registers may be clobbered.','line_number':821,'multiline':False]
['text':' Pop the arguments pushed after the dynamic alignment.','line_number':826,'multiline':False]
['text':' Pop the stack pointer to its value right before dynamic alignment.','line_number':829,'multiline':False]
['text':' Recover the 'argv' pointer which was saved before aligning the stack.','line_number':838,'multiline':False]
['text':' Store the register result, if any, in argv[0].','line_number':843,'multiline':False]
['text':' No spectre.index_masking is required, as the value leaves ReturnReg.','line_number':844,'multiline':False]
['text':' After the ReturnReg is stored into argv[0] but before fp is clobbered by','line_number':847,'multiline':False]
['text':' the PopRegsInMask(NonVolatileRegs) below, set the return value based on','line_number':848,'multiline':False]
['text':' whether fp is null (which is the case for successful returns) or the','line_number':849,'multiline':False]
['text':' FailFP magic value (set by the throw stub);','line_number':850,'multiline':False]
['text':' Restore clobbered non-volatile registers of the caller.','line_number':865,'multiline':False]
['text':' Load instance's TLS from the callee.','line_number':897,'multiline':False]
['text':' ScratchIonEntry := callee => JSFunction*','line_number':901,'multiline':False]
['text':' ScratchIonEntry := callee->getExtendedSlot(WASM_TLSDATA_SLOT)->toPrivate()','line_number':906,'multiline':False]
['text':'                 => TlsData*','line_number':907,'multiline':False]
['text':' Creates a JS fake exit frame for wasm, so the frame iterators just use','line_number':913,'multiline':False]
['text':' JSJit frame iteration.','line_number':914,'multiline':False]
['text':' Helper function for allocating a BigInt and initializing it from an I64','line_number':937,'multiline':False]
['text':' in GenerateJitEntry and GenerateImportInterpExit. The return result is','line_number':938,'multiline':False]
['text':' written to scratch.','line_number':939,'multiline':False]
['text':' We need to avoid clobbering other argument registers and the input.','line_number':951,'multiline':False]
['text':' Needs to use a different call type depending on stub it's used from.','line_number':961,'multiline':False]
['text':' Generate a stub that enters wasm from a jit code caller via the jit ABI.','line_number':981,'multiline':False]
['text':'','line_number':982,'multiline':False]
['text':' ARM64 note: This does not save the PseudoStackPointer so we must be sure to','line_number':983,'multiline':False]
['text':' recompute it on every return path, be it normal return or exception return.','line_number':984,'multiline':False]
['text':' The JIT code we return to assumes it is correct.','line_number':985,'multiline':False]
['text':' The jit caller has set up the following stack layout (sp grows to the','line_number':996,'multiline':False]
['text':' left):','line_number':997,'multiline':False]
['text':' <-- retAddr | descriptor | callee | argc | this | arg1..N','line_number':998,'multiline':False]
['text':' Note the jit caller ensures the stack is aligned *after* the call','line_number':1010,'multiline':False]
['text':' instruction.','line_number':1011,'multiline':False]
['text':' Reserve stack space for wasm ABI arguments, set up like this:','line_number':1015,'multiline':False]
['text':' <-- ABI args | padding','line_number':1016,'multiline':False]
['text':' We do two loops:','line_number':1035,'multiline':False]
['text':' - one loop up-front will make sure that all the Value tags fit the','line_number':1036,'multiline':False]
['text':' expected signature argument types. If at least one inline conversion','line_number':1037,'multiline':False]
['text':' fails, we just jump to the OOL path which will call into C++. Inline','line_number':1038,'multiline':False]
['text':' conversions are ordered in the way we expect them to happen the most.','line_number':1039,'multiline':False]
['text':' - the second loop will unbox the arguments into the right registers.','line_number':1040,'multiline':False]
['text':' For int32 inputs, just skip.','line_number':1053,'multiline':False]
['text':' For double inputs, unbox, truncate and store back.','line_number':1056,'multiline':False]
['text':' For null or undefined, store 0.','line_number':1067,'multiline':False]
['text':' For booleans, store the number value back. Other types (symbol,','line_number':1079,'multiline':False]
['text':' object, strings) go to the C++ call.','line_number':1080,'multiline':False]
['text':' fallthrough:','line_number':1083,'multiline':False]
['text':' For BigInt inputs, just skip. Otherwise go to C++ for other','line_number':1096,'multiline':False]
['text':' types that require creating a new BigInt or erroring.','line_number':1097,'multiline':False]
['text':' Note we can reuse the same code for f32/f64 here, since for the','line_number':1104,'multiline':False]
['text':' case of f32, the conversion of f64 to f32 will happen in the','line_number':1105,'multiline':False]
['text':' second loop.','line_number':1106,'multiline':False]
['text':' For double inputs, just skip.','line_number':1110,'multiline':False]
['text':' For int32 inputs, convert and rebox.','line_number':1113,'multiline':False]
['text':' For undefined (missing argument), store NaN.','line_number':1123,'multiline':False]
['text':' +null is 0.','line_number':1133,'multiline':False]
['text':' For booleans, store the number value back. Other types (symbol,','line_number':1143,'multiline':False]
['text':' object, strings) go to the C++ call.','line_number':1144,'multiline':False]
['text':' fallthrough:','line_number':1147,'multiline':False]
['text':' For object inputs, we handle object and null inline, everything','line_number':1162,'multiline':False]
['text':' else requires an actual box and we go out of line to allocate','line_number':1163,'multiline':False]
['text':' that.','line_number':1164,'multiline':False]
['text':' Guarded against by temporarilyUnsupportedReftypeForEntry()','line_number':1173,'multiline':False]
['text':' Guarded against by hasUnexposableArgOrRet()','line_number':1180,'multiline':False]
['text':' Convert all the expected values to unboxed values on the stack.','line_number':1194,'multiline':False]
['text':' The coercion has provided a BigInt value by this point, which','line_number':1212,'multiline':False]
['text':' we need to convert to an I64 here.','line_number':1213,'multiline':False]
['text':' Setup wasm register state.','line_number':1271,'multiline':False]
['text':' Call into the real function. Note that, due to the throw stub, fp, tls','line_number':1277,'multiline':False]
['text':' and pinned registers may be clobbered.','line_number':1278,'multiline':False]
['text':' If fp is equal to the FailFP magic value (set by the throw stub), then','line_number':1283,'multiline':False]
['text':' report the exception to the JIT caller by jumping into the exception','line_number':1284,'multiline':False]
['text':' stub; otherwise the FP value is still set to the parent ion frame value.','line_number':1285,'multiline':False]
['text':' Pop arguments.','line_number':1289,'multiline':False]
['text':' Store the return value in the JSReturnOperand.','line_number':1295,'multiline':False]
['text':' No spectre.index_masking is required, as the value is boxed.','line_number':1305,'multiline':False]
['text':' Fixup the stack for the exception tail so that we can share it.','line_number':1331,'multiline':False]
['text':' Un-fixup the stack for the benefit of the assertion below.','line_number':1335,'multiline':False]
['text':' For FuncRef and EqRef use the AnyRef path for now, since that','line_number':1347,'multiline':False]
['text':' will work.','line_number':1348,'multiline':False]
['text':' Per comment above, the call may have clobbered the Tls register,','line_number':1350,'multiline':False]
['text':' so reload since unboxing will need it.','line_number':1351,'multiline':False]
['text':' frameSize ','line_number':1352,'multiline':True]
['text':' Copy SP into PSP to enforce return-point invariants (SP == PSP).','line_number':1371,'multiline':False]
['text':' `addToStackPtr` won't sync them because SP is the active pointer here.','line_number':1372,'multiline':False]
['text':' For the same reason, we can't use initPseudoStackPtr to do the sync, so','line_number':1373,'multiline':False]
['text':' we have to do it "by hand".  Omitting this causes many tests to segfault.','line_number':1374,'multiline':False]
['text':' Generate an OOL call to the C++ conversion path.','line_number':1381,'multiline':False]
['text':' Baseline and Ion call C++ runtime via BuiltinThunk with wasm abi, so to','line_number':1386,'multiline':False]
['text':' unify the BuiltinThunk's interface we call it here with wasm abi.','line_number':1387,'multiline':False]
['text':' argument 0: function export index.','line_number':1390,'multiline':False]
['text':' argument 1: tlsData','line_number':1399,'multiline':False]
['text':' argument 2: effective address of start of argv','line_number':1407,'multiline':False]
['text':' No spectre.index_masking is required, as the return value is used as a','line_number':1424,'multiline':False]
['text':' bool.','line_number':1425,'multiline':False]
['text':' Prepare to throw: reload WasmTlsReg from the frame.','line_number':1430,'multiline':False]
['text':' FramePointer isn't volatile, manually preserve it because it will be','line_number':1448,'multiline':False]
['text':' clobbered below.','line_number':1449,'multiline':False]
['text':' Ensure that the FramePointer is actually Ion-volatile. This might','line_number':1453,'multiline':False]
['text':' assert when bug 1426134 lands.','line_number':1454,'multiline':False]
['text':' profiling ','line_number':1456,'multiline':True]
['text':' Note, if code here pushes a reference value into the frame for its own','line_number':1462,'multiline':False]
['text':' purposes (and not just as an argument to the callee) then the frame must be','line_number':1463,'multiline':False]
['text':' traced in TraceJitExitFrame, see the case there for DirectWasmJitCall.  The','line_number':1464,'multiline':False]
['text':' callee will trace values that are pushed as arguments, however.','line_number':1465,'multiline':False]
['text':' Push a special frame descriptor that indicates the frame size so we can','line_number':1467,'multiline':False]
['text':' directly iterate from the current JIT frame without an extra call.','line_number':1468,'multiline':False]
['text':' Move stack arguments to their final locations.','line_number':1476,'multiline':False]
['text':' The address offsets were valid *before* we pushed our frame.','line_number':1548,'multiline':False]
['text':' Load tls; from now on, WasmTlsReg is live.','line_number':1595,'multiline':False]
['text':' Actual call.','line_number':1601,'multiline':False]
['text':' WASM does not always keep PSP in sync with SP.  So reinitialize it as it','line_number':1611,'multiline':False]
['text':' might be clobbered either by WASM or by any C++ calls within.','line_number':1612,'multiline':False]
['text':' Store the return value in the appropriate place.','line_number':1620,'multiline':False]
['text':' The return value is in ReturnReg, which is what Ion expects.','line_number':1631,'multiline':False]
['text':' The return value is in ReturnReg64, which is what Ion expects.','line_number':1640,'multiline':False]
['text':' For FuncRef and EqRef, use the AnyRef path for now, since that','line_number':1655,'multiline':False]
['text':' will work.','line_number':1656,'multiline':False]
['text':' The call to wasm above preserves the WasmTlsReg, we don't need to','line_number':1658,'multiline':False]
['text':' reload it here.','line_number':1659,'multiline':False]
['text':' Free args + frame descriptor.','line_number':1675,'multiline':False]
['text':' If we pushed it, free FramePointer.','line_number':1678,'multiline':False]
['text':' Note, when toValue is true then this may destroy the values in incoming','line_number':1737,'multiline':False]
['text':' argument registers as a result of Spectre mitigation.','line_number':1738,'multiline':False]
['text':' This loop does not root the values that are being constructed in','line_number':1748,'multiline':False]
['text':' for the arguments. Allocations that are generated by code either','line_number':1749,'multiline':False]
['text':' in the loop or called from it should be NoGC allocations.','line_number':1750,'multiline':False]
['text':' This works also for FuncRef because it is distinguishable from','line_number':1783,'multiline':False]
['text':' a boxed AnyRef.','line_number':1784,'multiline':False]
['text':' Preserve the NaN pattern in the input.','line_number':1821,'multiline':False]
['text':' JS::Values can't store Float32, so convert to a Double.','line_number':1833,'multiline':False]
['text':' Preserve the NaN pattern in the input.','line_number':1840,'multiline':False]
['text':' The value should never escape; the call will be stopped later as','line_number':1845,'multiline':False]
['text':' the import is being called.  But we should generate something sane','line_number':1846,'multiline':False]
['text':' here for the boxed case since a debugger or the stack walker may','line_number':1847,'multiline':False]
['text':' observe something.','line_number':1848,'multiline':False]
['text':' This works also for FuncRef because it is distinguishable from a','line_number':1882,'multiline':False]
['text':' boxed AnyRef.','line_number':1883,'multiline':False]
['text':' The value should never escape; the call will be stopped later as','line_number':1899,'multiline':False]
['text':' the import is being called.  But we should generate something','line_number':1900,'multiline':False]
['text':' sane here for the boxed case since a debugger or the stack walker','line_number':1901,'multiline':False]
['text':' may observe something.','line_number':1902,'multiline':False]
['text':' As above.  StackCopy does not know this trick.','line_number':1913,'multiline':False]
['text':' Generate a wrapper function with the standard intra-wasm call ABI which','line_number':1931,'multiline':False]
['text':' simply calls an import. This wrapper function allows any import to be treated','line_number':1932,'multiline':False]
['text':' like a normal wasm function for the purposes of exports and table calls. In','line_number':1933,'multiline':False]
['text':' particular, the wrapper function provides:','line_number':1934,'multiline':False]
['text':'  - a table entry, so JS imports can be put into tables','line_number':1935,'multiline':False]
['text':'  - normal entries, so that, if the import is re-exported, an entry stub can','line_number':1936,'multiline':False]
['text':'    be generated and called without any special cases','line_number':1937,'multiline':False]
['text':' pushed by prologue','line_number':1949,'multiline':False]
['text':' The argument register state is already setup by our caller. We just need','line_number':1957,'multiline':False]
['text':' to be sure not to clobber it before the call.','line_number':1958,'multiline':False]
['text':' Copy our frame's stack arguments to the callee frame's stack argument.','line_number':1961,'multiline':False]
['text':' Call the import exit stub.','line_number':1978,'multiline':False]
['text':' Restore the TLS register and pinned regs, per wasm function ABI.','line_number':1983,'multiline':False]
['text':' Restore cx->realm.','line_number':1988,'multiline':False]
['text':' bytecodeOffset = ','line_number':2012,'multiline':True]
['text':' Generate a stub that is called via the internal ABI derived from the','line_number':2026,'multiline':False]
['text':' signature of the import and calls into an appropriate callImport C++','line_number':2027,'multiline':False]
['text':' function, having boxed all the ABI arguments into a homogeneous Value array.','line_number':2028,'multiline':False]
['text':' Argument types for Instance::callImport_*:','line_number':2036,'multiline':False]
['text':' Instance*','line_number':2037,'multiline':False]
['text':' funcImportIndex','line_number':2038,'multiline':False]
['text':' argc','line_number':2039,'multiline':False]
['text':' argv','line_number':2040,'multiline':False]
['text':' At the point of the call, the stack layout shall be (sp grows to the left):','line_number':2044,'multiline':False]
['text':'  | stack args | padding | argv[] | padding | retaddr | caller stack args |','line_number':2045,'multiline':False]
['text':' The padding between stack args and argv ensures that argv is aligned. The','line_number':2046,'multiline':False]
['text':' padding between argv and retaddr ensures that sp is aligned.','line_number':2047,'multiline':False]
['text':' The abiArgCount includes a stack result pointer argument if needed.','line_number':2050,'multiline':False]
['text':' pushed by prologue','line_number':2055,'multiline':False]
['text':' Fill the argument array.','line_number':2061,'multiline':False]
['text':' The scratch3 reg does not need to be non-volatile, but has to be','line_number':2065,'multiline':False]
['text':' distinct from scratch & scratch2.','line_number':2066,'multiline':False]
['text':' Prepare the arguments for the call to Instance::callImport_*.','line_number':2072,'multiline':False]
['text':' argument 0: Instance*','line_number':2075,'multiline':False]
['text':' argument 1: funcImportIndex','line_number':2086,'multiline':False]
['text':' argument 2: argc','line_number':2095,'multiline':False]
['text':' argument 3: argv','line_number':2105,'multiline':False]
['text':' Make the call, test whether it succeeded, and extract the return value.','line_number':2117,'multiline':False]
['text':' No spectre.index_masking is required, as we know the value comes from','line_number':2138,'multiline':False]
['text':' an i32 load.','line_number':2139,'multiline':False]
['text':' Note, CallImport_Rtt/V128 currently always throws, so we should never','line_number':2152,'multiline':False]
['text':' reach this point.','line_number':2153,'multiline':False]
['text':' The native ABI preserves the TLS, heap and global registers since they','line_number':2192,'multiline':False]
['text':' are non-volatile.','line_number':2193,'multiline':False]
['text':' Generate a stub that is called via the internal ABI derived from the','line_number':2207,'multiline':False]
['text':' signature of the import and calls into a compatible JIT function,','line_number':2208,'multiline':False]
['text':' having boxed all the ABI arguments into the JIT stack frame layout.','line_number':2209,'multiline':False]
['text':' JIT calls use the following stack layout (sp grows to the left):','line_number':2216,'multiline':False]
['text':'   | WasmToJSJitFrameLayout | this | arg1..N | saved Tls |','line_number':2217,'multiline':False]
['text':' Unlike most ABIs, the JIT ABI requires that sp be JitStackAlignment-','line_number':2218,'multiline':False]
['text':' aligned *after* pushing the return address.','line_number':2219,'multiline':False]
['text':' pushed by prologue','line_number':2231,'multiline':False]
['text':' On ARM64 we must align the SP to a 16-byte boundary.','line_number':2236,'multiline':False]
['text':' 1. Descriptor.','line_number':2245,'multiline':False]
['text':' 2. Callee, part 1 -- need the callee register for argument filling, so','line_number':2254,'multiline':False]
['text':' record offset here and set up callee later.','line_number':2255,'multiline':False]
['text':' 3. Argc.','line_number':2259,'multiline':False]
['text':' 4. |this| value.','line_number':2266,'multiline':False]
['text':' 5. Fill the arguments.','line_number':2270,'multiline':False]
['text':' Repeatedly clobbered','line_number':2272,'multiline':False]
['text':' Reused as callee below','line_number':2273,'multiline':False]
['text':' The scratch3 reg does not need to be non-volatile, but has to be','line_number':2274,'multiline':False]
['text':' distinct from scratch & scratch2.','line_number':2275,'multiline':False]
['text':' Preserve Tls because the JIT callee clobbers it.','line_number':2283,'multiline':False]
['text':' 2. Callee, part 2 -- now that the register is free, set up the callee.','line_number':2287,'multiline':False]
['text':' Live until call','line_number':2288,'multiline':False]
['text':' 2.1. Get JSFunction callee.','line_number':2290,'multiline':False]
['text':' 2.2. Save callee.','line_number':2294,'multiline':False]
['text':' 6. Check if we need to rectify arguments.','line_number':2297,'multiline':False]
['text':' 7. If we haven't rectified arguments, load callee executable entry point.','line_number':2304,'multiline':False]
['text':' Conform to JIT ABI.  Note this doesn't update PSP since SP is the active','line_number':2315,'multiline':False]
['text':' pointer.','line_number':2316,'multiline':False]
['text':' Manually resync PSP.  Omitting this causes eg tests/wasm/import-export.js','line_number':2318,'multiline':False]
['text':' to segfault.','line_number':2319,'multiline':False]
['text':' Conform to platform conventions - align the SP.','line_number':2324,'multiline':False]
['text':' Note that there might be a GC thing in the JSReturnOperand now.','line_number':2328,'multiline':False]
['text':' In all the code paths from here:','line_number':2329,'multiline':False]
['text':' - either the value is unboxed because it was a primitive and we don't','line_number':2330,'multiline':False]
['text':'   need to worry about rooting anymore.','line_number':2331,'multiline':False]
['text':' - or the value needs to be rooted, but nothing can cause a GC between','line_number':2332,'multiline':False]
['text':'   here and CoerceInPlace, which roots before coercing to a primitive.','line_number':2333,'multiline':False]
['text':' The JIT callee clobbers all registers, including WasmTlsReg and','line_number':2335,'multiline':False]
['text':' FramePointer, so restore those here. During this sequence of','line_number':2336,'multiline':False]
['text':' instructions, FP can't be trusted by the profiling frame iterator.','line_number':2337,'multiline':False]
['text':' As explained above, the frame was aligned for the JIT ABI such that','line_number':2347,'multiline':False]
['text':'   (sp + sizeof(void*)) % JitStackAlignment == 0','line_number':2348,'multiline':False]
['text':' But now we possibly want to call one of several different C++ functions,','line_number':2349,'multiline':False]
['text':' so subtract the sizeof(void*) so that sp is aligned for an ABI call.','line_number':2350,'multiline':False]
['text':' We've already allocated the extra space for frame alignment.','line_number':2353,'multiline':False]
['text':' No spectre.index_masking required, as the return value does not come','line_number':2381,'multiline':False]
['text':' to us in ReturnReg.','line_number':2382,'multiline':False]
['text':' No fastpath for now, go immediately to ool case','line_number':2388,'multiline':False]
['text':' Unreachable as callImport should not call the stub.','line_number':2393,'multiline':False]
['text':' Call the arguments rectifier.','line_number':2429,'multiline':False]
['text':' Coercion calls use the following stack layout (sp grows to the left):','line_number':2441,'multiline':False]
['text':'   | args | padding | Value argv[1] | padding | exit Frame |','line_number':2442,'multiline':False]
['text':' Store return value into argv[0].','line_number':2450,'multiline':False]
['text':' From this point, it's safe to reuse the scratch register (which','line_number':2454,'multiline':False]
['text':' might be part of the JSReturnOperand).','line_number':2455,'multiline':False]
['text':' The JIT might have clobbered exitFP at this point. Since there's','line_number':2457,'multiline':False]
['text':' going to be a CoerceInPlace call, pretend we're still doing the JIT','line_number':2458,'multiline':False]
['text':' call by restoring our tagged exitFP.','line_number':2459,'multiline':False]
['text':' argument 0: argv','line_number':2462,'multiline':False]
['text':' Call coercion function. Note that right after the call, the value of','line_number':2475,'multiline':False]
['text':' FP is correct because FP is non-volatile in the native ABI.','line_number':2476,'multiline':False]
['text':' NOTE that once there can be more than one result and we can box some of','line_number':2480,'multiline':False]
['text':' the results (as we must for AnyRef), pointer and already-boxed results','line_number':2481,'multiline':False]
['text':' must be rooted while subsequent results are boxed.','line_number':2482,'multiline':False]
['text':' No spectre.index_masking required, as we generate a known-good','line_number':2490,'multiline':False]
['text':' value in a safe way here.','line_number':2491,'multiline':False]
['text':' Maintain the invariant that exitFP is either unset or not set to a','line_number':2529,'multiline':False]
['text':' wasm tagged exitFP, per the jit exit contract.','line_number':2530,'multiline':False]
['text':' pushed by prologue','line_number':2577,'multiline':False]
['text':' Copy out and convert caller arguments, if needed.','line_number':2582,'multiline':False]
['text':' Non hard-fp passes the args values in GPRs.','line_number':2588,'multiline':False]
['text':' No spectre.index_masking is required, as the caller will mask.','line_number':2614,'multiline':False]
['text':' x86 passes the return value on the x87 FP stack.','line_number':2616,'multiline':False]
['text':' Non hard-fp passes the return values in GPRs.','line_number':2627,'multiline':False]
['text':' We assume that traps do not happen while lr is live. This both ensures that','line_number':2659,'multiline':False]
['text':' the size of RegsToPreserve is a multiple of 2 (preserving WasmStackAlignment)','line_number':2660,'multiline':False]
['text':' and gives us a register to clobber in the return path.','line_number':2661,'multiline':False]
['text':' If SIMD is not enabled, it's pointless to save/restore the upper 64','line_number':2669,'multiline':False]
['text':' bits of each vector register.','line_number':2670,'multiline':False]
['text':' It's correct to use FloatRegisters::AllMask even when SIMD is not enabled;','line_number':2674,'multiline':False]
['text':' PushRegsInMask strips out the high lanes of the XMM registers in this case,','line_number':2675,'multiline':False]
['text':' while the singles will be stripped as they are aliased by the larger doubles.','line_number':2676,'multiline':False]
['text':' Generate a MachineState which describes the locations of the GPRs as saved','line_number':2689,'multiline':False]
['text':' by GenerateTrapExit.  FP registers are ignored.  Note that the values','line_number':2690,'multiline':False]
['text':' stored in the MachineState are offsets in words downwards from the top of','line_number':2691,'multiline':False]
['text':' the save area.  That is, a higher value implies a lower address.','line_number':2692,'multiline':False]
['text':' This is the number of words pushed by the initial WasmPush().','line_number':2695,'multiline':False]
['text':' And these correspond to the PushRegsInMask() that immediately follows.','line_number':2699,'multiline':False]
['text':' Generate a stub which calls WasmReportTrap() and can be executed by having','line_number':2708,'multiline':False]
['text':' the signal handler redirect PC from any trapping instruction.','line_number':2709,'multiline':False]
['text':' Traps can only happen at well-defined program points. However, since','line_number':2719,'multiline':False]
['text':' traps may resume and the optimal assumption for the surrounding code is','line_number':2720,'multiline':False]
['text':' that registers are not clobbered, we need to preserve all registers in','line_number':2721,'multiline':False]
['text':' the trap exit. One simplifying assumption is that flags may be clobbered.','line_number':2722,'multiline':False]
['text':' Push a dummy word to use as return address below.','line_number':2723,'multiline':False]
['text':' We know that StackPointer is word-aligned, but not necessarily','line_number':2729,'multiline':False]
['text':' stack-aligned, so we need to align it dynamically.','line_number':2730,'multiline':False]
['text':' WasmHandleTrap returns null if control should transfer to the throw stub.','line_number':2741,'multiline':False]
['text':' Otherwise, the return value is the TrapData::resumePC we must jump to.','line_number':2744,'multiline':False]
['text':' We must restore register state before jumping, which will clobber','line_number':2745,'multiline':False]
['text':' ReturnReg, so store ReturnReg in the above-reserved stack slot which we','line_number':2746,'multiline':False]
['text':' use to jump to via ret.','line_number':2747,'multiline':False]
['text':' Generate a stub that restores the stack pointer to what it was on entry to','line_number':2761,'multiline':False]
['text':' the wasm activation, sets the return register to 'false' and then executes a','line_number':2762,'multiline':False]
['text':' return which will return from this wasm activation to the caller. This stub','line_number':2763,'multiline':False]
['text':' should only be called after the caller has reported an error.','line_number':2764,'multiline':False]
['text':' Conservatively, the stack pointer can be unaligned and we must align it','line_number':2778,'multiline':False]
['text':' dynamically.','line_number':2779,'multiline':False]
['text':' Allocate space for exception or regular resume information.','line_number':2785,'multiline':False]
['text':' WasmHandleThrow unwinds JitActivation::wasmExitFP() and returns the','line_number':2808,'multiline':False]
['text':' address of the return address on the stack this stub should return to.','line_number':2809,'multiline':False]
['text':' Set the FramePointer to a magic value to indicate a return by throw.','line_number':2810,'multiline':False]
['text':'','line_number':2811,'multiline':False]
['text':' If there is a Wasm catch handler present, it will instead return the','line_number':2812,'multiline':False]
['text':' address of the handler to jump to and the FP/SP values to restore.','line_number':2813,'multiline':False]
['text':' The case where a Wasm catch handler was found while unwinding the stack.','line_number':2829,'multiline':False]
['text':' Defer reloading stackPointer until just before the jump, so as to','line_number':2833,'multiline':False]
['text':' protect other live data on the stack.','line_number':2834,'multiline':False]
['text':' When there is a catch handler, HandleThrow passes it the Value needed for','line_number':2836,'multiline':False]
['text':' the handler's argument as well.','line_number':2837,'multiline':False]
['text':' Now it's safe to reload stackPointer.','line_number':2848,'multiline':False]
['text':' This move must come after the SP is reloaded because WasmExceptionReg may','line_number':2851,'multiline':False]
['text':' alias ReturnReg.','line_number':2852,'multiline':False]
['text':' No catch handler was found, so we will just return out.','line_number':2856,'multiline':False]
['text':' Generate a stub that handle toggable enter/leave frame traps or breakpoints.','line_number':2878,'multiline':False]
['text':' The trap records frame pointer (via GenerateExitPrologue) and saves most of','line_number':2879,'multiline':False]
['text':' registers to not affect the code generated by WasmBaselineCompile.','line_number':2880,'multiline':False]
['text':' Save all registers used between baseline compiler operations.','line_number':2889,'multiline':False]
['text':' This method might be called with unaligned stack -- aligning and','line_number':2894,'multiline':False]
['text':' saving old stack pointer at the top.','line_number':2895,'multiline':False]
['text':' On ARM64 however the stack is always aligned.','line_number':2897,'multiline':False]
['text':' Unaligned ABI calls require SP+PSP, but our mode here is SP-only','line_number':2967,'multiline':False]
['text':' Undo the SP+PSP mode','line_number':2991,'multiline':False]
['text':' Swap in already-allocated empty vectors to avoid malloc/free.','line_number':3005,'multiline':False]
['text':' Skip if the function does not have a signature that allows for a JIT','line_number':3027,'multiline':False]
['text':' exit.','line_number':3028,'multiline':False]
