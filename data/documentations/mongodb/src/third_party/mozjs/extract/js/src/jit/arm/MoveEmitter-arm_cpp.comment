['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' Reserve stack for cycle resolution','line_number':26,'multiline':False]
['text':' Otherwise, the stack offset may need to be adjusted.','line_number':60,'multiline':False]
['text':' For now, just pick r12/ip as the eviction point. This is totally random,','line_number':70,'multiline':False]
['text':' and if it ends up being bad, we can use actual heuristics later. r12 is','line_number':71,'multiline':False]
['text':' actually a bad choice. It is the scratch register, which is frequently','line_number':72,'multiline':False]
['text':' used for address computations, such as those found when we attempt to','line_number':73,'multiline':False]
['text':' access values more than 4096 off of the stack pointer. Instead, use lr,','line_number':74,'multiline':False]
['text':' the LinkRegister.','line_number':75,'multiline':False]
['text':' There is some pattern:','line_number':89,'multiline':False]
['text':'   (A -> B)','line_number':90,'multiline':False]
['text':'   (B -> A)','line_number':91,'multiline':False]
['text':'','line_number':92,'multiline':False]
['text':' This case handles (A -> B), which we reach first. We save B, then allow','line_number':93,'multiline':False]
['text':' the original move to continue.','line_number':94,'multiline':False]
['text':' Since it is uncertain if the load will be aligned or not','line_number':103,'multiline':False]
['text':' just fill both of them with the same value.','line_number':104,'multiline':False]
['text':' Since it is uncertain if the load will be aligned or not','line_number':108,'multiline':False]
['text':' just fill both of them with the same value.','line_number':109,'multiline':False]
['text':' Just always store the largest possible size. Currently, this is','line_number':114,'multiline':False]
['text':' a double. When SIMD is added, two doubles will need to be stored.','line_number':115,'multiline':False]
['text':' an non-vfp value','line_number':135,'multiline':False]
['text':' If the destination was spilled, restore it first.','line_number':142,'multiline':False]
['text':' There is some pattern:','line_number':157,'multiline':False]
['text':'   (A -> B)','line_number':158,'multiline':False]
['text':'   (B -> A)','line_number':159,'multiline':False]
['text':'','line_number':160,'multiline':False]
['text':' This case handles (B -> A), which we reach last. We emit a move from the','line_number':161,'multiline':False]
['text':' saved value of B, to A.','line_number':162,'multiline':False]
['text':' Make sure we don't re-clobber the spilled register later.','line_number':212,'multiline':False]
['text':' Register pairs are used to store Double values during calls.','line_number':224,'multiline':False]
['text':' If the destination is the spilled register, make sure we','line_number':231,'multiline':False]
['text':' don't re-clobber its value.','line_number':232,'multiline':False]
['text':' If the source is a register that has been spilled, make sure','line_number':238,'multiline':False]
['text':' to load the source back into that register.','line_number':239,'multiline':False]
['text':' Memory to memory gpr move.','line_number':256,'multiline':False]
['text':' Register pairs are used to store Double values during calls.','line_number':272,'multiline':False]
['text':' Memory to memory move.','line_number':301,'multiline':False]
['text':' Registers are used to store pointers / int32 / float32 values.','line_number':311,'multiline':False]
['text':' Note: We can safely use the MoveOperand's displacement here,','line_number':342,'multiline':False]
['text':' even if the base is SP: MoveEmitter::toOperand adjusts','line_number':343,'multiline':False]
['text':' SP-relative operands by the difference between the current','line_number':344,'multiline':False]
['text':' stack usage and stackAdjust, which emitter.finish() resets to','line_number':345,'multiline':False]
['text':' 0.','line_number':346,'multiline':False]
['text':'','line_number':347,'multiline':False]
['text':' Warning: if the offset isn't within [-255,+255] then this','line_number':348,'multiline':False]
['text':' will assert-fail (or, if non-debug, load the wrong words).','line_number':349,'multiline':False]
['text':' Nothing uses such an offset at the time of this writing.','line_number':350,'multiline':False]
['text':' Memory to memory move.','line_number':354,'multiline':False]
['text':' A fun consequence of aliased registers is you can have multiple','line_number':367,'multiline':False]
['text':' cycles at once, and one can end exactly where another begins.','line_number':368,'multiline':False]
