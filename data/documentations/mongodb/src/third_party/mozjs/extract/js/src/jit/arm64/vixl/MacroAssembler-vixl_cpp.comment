['text':' Copyright 2015, ARM Limited','line_number':1,'multiline':False]
['text':' All rights reserved.','line_number':2,'multiline':False]
['text':'','line_number':3,'multiline':False]
['text':' Redistribution and use in source and binary forms, with or without','line_number':4,'multiline':False]
['text':' modification, are permitted provided that the following conditions are met:','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':'   * Redistributions of source code must retain the above copyright notice,','line_number':7,'multiline':False]
['text':'     this list of conditions and the following disclaimer.','line_number':8,'multiline':False]
['text':'   * Redistributions in binary form must reproduce the above copyright notice,','line_number':9,'multiline':False]
['text':'     this list of conditions and the following disclaimer in the documentation','line_number':10,'multiline':False]
['text':'     and/or other materials provided with the distribution.','line_number':11,'multiline':False]
['text':'   * Neither the name of ARM Limited nor the names of its contributors may be','line_number':12,'multiline':False]
['text':'     used to endorse or promote products derived from this software without','line_number':13,'multiline':False]
['text':'     specific prior written permission.','line_number':14,'multiline':False]
['text':'','line_number':15,'multiline':False]
['text':' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS CONTRIBUTORS "AS IS" AND','line_number':16,'multiline':False]
['text':' ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED','line_number':17,'multiline':False]
['text':' WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE','line_number':18,'multiline':False]
['text':' DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE','line_number':19,'multiline':False]
['text':' FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL','line_number':20,'multiline':False]
['text':' DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR','line_number':21,'multiline':False]
['text':' SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER','line_number':22,'multiline':False]
['text':' CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,','line_number':23,'multiline':False]
['text':' OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE','line_number':24,'multiline':False]
['text':' OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.','line_number':25,'multiline':False]
['text':' The worst case for size is mov 64-bit immediate to sp:','line_number':52,'multiline':False]
['text':'  * up to 4 instructions to materialise the constant','line_number':53,'multiline':False]
['text':'  * 1 instruction to move to sp','line_number':54,'multiline':False]
['text':' Immediates on Aarch64 can be produced using an initial value, and zero to','line_number':57,'multiline':False]
['text':' three move keep operations.','line_number':58,'multiline':False]
['text':'','line_number':59,'multiline':False]
['text':' Initial values can be generated with:','line_number':60,'multiline':False]
['text':'  1. 64-bit move zero (movz).','line_number':61,'multiline':False]
['text':'  2. 32-bit move inverted (movn).','line_number':62,'multiline':False]
['text':'  3. 64-bit move inverted.','line_number':63,'multiline':False]
['text':'  4. 32-bit orr immediate.','line_number':64,'multiline':False]
['text':'  5. 64-bit orr immediate.','line_number':65,'multiline':False]
['text':' Move-keep may then be used to modify each of the 16-bit half words.','line_number':66,'multiline':False]
['text':'','line_number':67,'multiline':False]
['text':' The code below supports all five initial value generators, and','line_number':68,'multiline':False]
['text':' applying move-keep operations to move-zero and move-inverted initial','line_number':69,'multiline':False]
['text':' values.','line_number':70,'multiline':False]
['text':' Try to move the immediate in one instruction, and if that fails, switch to','line_number':72,'multiline':False]
['text':' using multiple instructions.','line_number':73,'multiline':False]
['text':' Generic immediate case. Imm will be represented by','line_number':80,'multiline':False]
['text':'   [imm3, imm2, imm1, imm0], where each imm is 16 bits.','line_number':81,'multiline':False]
['text':' A move-zero or move-inverted is generated for the first non-zero or','line_number':82,'multiline':False]
['text':' non-0xffff immX, and a move-keep for subsequent non-zero immX.','line_number':83,'multiline':False]
['text':' If the number of 0xffff halfwords is greater than the number of 0x0000','line_number':87,'multiline':False]
['text':' halfwords, it's more efficient to use move-inverted.','line_number':88,'multiline':False]
['text':' Mov instructions can't move values into the stack pointer, so set up a','line_number':95,'multiline':False]
['text':' temporary register, if needed.','line_number':96,'multiline':False]
['text':' Iterate through the halfwords. Use movn/movz for the first non-ignored','line_number':104,'multiline':False]
['text':' halfword, and movk for subsequent halfwords.','line_number':105,'multiline':False]
['text':' Construct a wider constant.','line_number':121,'multiline':False]
['text':' Move the temporary if the original destination register was the stack','line_number':130,'multiline':False]
['text':' pointer.','line_number':131,'multiline':False]
['text':' Immediate can be represented in a move zero instruction. Movz can't write','line_number':149,'multiline':False]
['text':' to the stack pointer.','line_number':150,'multiline':False]
['text':' Immediate can be represented in a move negative instruction. Movn can't','line_number':156,'multiline':False]
['text':' write to the stack pointer.','line_number':157,'multiline':False]
['text':' Immediate can be represented in a logical orr instruction.','line_number':163,'multiline':False]
['text':' The worst case for size is logical immediate to sp:','line_number':342,'multiline':False]
['text':'  * up to 4 instructions to materialise the constant','line_number':343,'multiline':False]
['text':'  * 1 instruction to do the operation','line_number':344,'multiline':False]
['text':'  * 1 instruction to move to sp','line_number':345,'multiline':False]
['text':' If the operation is NOT, invert the operation and immediate.','line_number':353,'multiline':False]
['text':' Ignore the top 32 bits of an immediate if we're moving to a W register.','line_number':359,'multiline':False]
['text':' Check that the top 32 bits are consistent.','line_number':361,'multiline':False]
['text':' Special cases for all set or all clear immediates.','line_number':369,'multiline':False]
['text':' Immediate can be encoded in the instruction.','line_number':410,'multiline':False]
['text':' Immediate can't be encoded: synthesize using move immediate.','line_number':413,'multiline':False]
['text':' If the left-hand input is the stack pointer, we can't pre-shift the','line_number':416,'multiline':False]
['text':' immediate, as the encoding won't allow the subsequent post shift.','line_number':417,'multiline':False]
['text':' VIXL can acquire temp registers. Assert that the caller is aware.','line_number':421,'multiline':False]
['text':' If rd is the stack pointer we cannot use it as the destination','line_number':426,'multiline':False]
['text':' register so we use the temp register as an intermediate again.','line_number':427,'multiline':False]
['text':' Add/sub extended supports shift <= 4. We want to support exactly the','line_number':436,'multiline':False]
['text':' same modes here.','line_number':437,'multiline':False]
['text':' VIXL can acquire temp registers. Assert that the caller is aware.','line_number':445,'multiline':False]
['text':' The operand can be encoded in the instruction.','line_number':453,'multiline':False]
['text':' The worst case for size is mov immediate with up to 4 instructions.','line_number':463,'multiline':False]
['text':' Call the macro assembler for generic immediates.','line_number':467,'multiline':False]
['text':' Emit a shift instruction if moving a shifted register. This operation','line_number':470,'multiline':False]
['text':' could also be achieved using an orr instruction (like orn used by Mvn),','line_number':471,'multiline':False]
['text':' but using a shift instruction makes the disassembly clearer.','line_number':472,'multiline':False]
['text':' Emit an extend instruction if moving an extended register. This handles','line_number':475,'multiline':False]
['text':' extend with post-shift operations, too.','line_number':476,'multiline':False]
['text':' Otherwise, emit a register move only if the registers are distinct, or','line_number':480,'multiline':False]
['text':' if they are not X registers.','line_number':481,'multiline':False]
['text':'','line_number':482,'multiline':False]
['text':' Note that mov(w0, w0) is not a no-op because it clears the top word of','line_number':483,'multiline':False]
['text':' x0. A flag is provided (kDiscardForSameWReg) if a move between the same W','line_number':484,'multiline':False]
['text':' registers is not required to clear the top word of the X register. In','line_number':485,'multiline':False]
['text':' this case, the instruction is discarded.','line_number':486,'multiline':False]
['text':'','line_number':487,'multiline':False]
['text':' If the sp is an operand, add #0 is emitted, otherwise, orr #0.','line_number':488,'multiline':False]
['text':' All bytes are either 0x00 or 0xff.','line_number':526,'multiline':False]
['text':' Of the 4 bytes, only one byte is non-zero.','line_number':542,'multiline':False]
['text':' Of the 4 bytes, only one byte is not 0xff.','line_number':550,'multiline':False]
['text':' Immediate is of the form 0x00MMFFFF.','line_number':559,'multiline':False]
['text':' Immediate is of the form 0x0000MMFF.','line_number':565,'multiline':False]
['text':' Immediate is of the form 0xFFMM0000.','line_number':571,'multiline':False]
['text':' Immediate is of the form 0xFFFFMM00.','line_number':576,'multiline':False]
['text':' Top and bottom 16-bits are equal.','line_number':582,'multiline':False]
['text':' Default case.','line_number':588,'multiline':False]
['text':' All bytes are either 0x00 or 0xff.','line_number':599,'multiline':False]
['text':' Top and bottom 32-bits are equal.','line_number':615,'multiline':False]
['text':' Default case.','line_number':621,'multiline':False]
['text':' 8-bit immediate.','line_number':643,'multiline':False]
['text':' 16-bit immediate.','line_number':647,'multiline':False]
['text':' 32-bit immediate.','line_number':650,'multiline':False]
['text':' 64-bit immediate.','line_number':653,'multiline':False]
['text':' When hi == lo, the following generates good code.','line_number':665,'multiline':False]
['text':'','line_number':666,'multiline':False]
['text':' In situations where the constants are complex and hi != lo, the following','line_number':667,'multiline':False]
['text':' can turn into up to 10 instructions: 2*(mov + 3*movk + dup/insert).  To do','line_number':668,'multiline':False]
['text':' any better, we could try to estimate whether splatting the high value and','line_number':669,'multiline':False]
['text':' updating the low value would generate fewer instructions than vice versa','line_number':670,'multiline':False]
['text':' (what we do now).','line_number':671,'multiline':False]
['text':'','line_number':672,'multiline':False]
['text':' (A PC-relative load from memory to the vector register (ADR + LD2) is going','line_number':673,'multiline':False]
['text':' to have fairly high latency but is fairly compact; not clear what the best','line_number':674,'multiline':False]
['text':' tradeoff is.)','line_number':675,'multiline':False]
['text':' The worst case for size is mvn immediate with up to 4 instructions.','line_number':687,'multiline':False]
['text':' Call the macro assembler for generic immediates.','line_number':691,'multiline':False]
['text':' Emit two instructions for the extend case. This differs from Mov, as','line_number':697,'multiline':False]
['text':' the extend and invert can't be achieved in one instruction.','line_number':698,'multiline':False]
['text':' VIXL can acquire temp registers. Assert that the caller is aware.','line_number':701,'multiline':False]
['text':' Otherwise, register and shifted register cases can be handled by the','line_number':708,'multiline':False]
['text':' assembler directly, using orn.','line_number':709,'multiline':False]
['text':' The worst case for size is ccmp immediate:','line_number':750,'multiline':False]
['text':'  * up to 4 instructions to materialise the constant','line_number':751,'multiline':False]
['text':'  * 1 instruction for ccmp','line_number':752,'multiline':False]
['text':' The immediate can be encoded in the instruction, or the operand is an','line_number':757,'multiline':False]
['text':' unshifted register: call the assembler.','line_number':758,'multiline':False]
['text':' The operand isn't directly supported by the instruction: perform the','line_number':762,'multiline':False]
['text':' operation on a temporary register.','line_number':763,'multiline':False]
['text':' The worst case for size is csel immediate:','line_number':779,'multiline':False]
['text':'  * up to 4 instructions to materialise the constant','line_number':780,'multiline':False]
['text':'  * 1 instruction for csel','line_number':781,'multiline':False]
['text':' Immediate argument. Handle special cases of 0, 1 and -1 using zero','line_number':785,'multiline':False]
['text':' register.','line_number':786,'multiline':False]
['text':' Unshifted register argument.','line_number':804,'multiline':False]
['text':' All other arguments.','line_number':807,'multiline':False]
['text':' The worst case for size is:','line_number':870,'multiline':False]
['text':'  * 1 to materialise the constant, using literal pool if necessary','line_number':871,'multiline':False]
['text':'  * 1 instruction for fcmp{e}','line_number':872,'multiline':False]
['text':' Floating point immediates are loaded through the literal pool.','line_number':892,'multiline':False]
['text':' TODO: consider NEON support for load literal.','line_number':912,'multiline':False]
['text':' Floating point immediates are loaded through the literal pool.','line_number':920,'multiline':False]
['text':' TODO: consider NEON support for load literal.','line_number':940,'multiline':False]
['text':' Encode the immediate in a single move instruction, if possible.','line_number':975,'multiline':False]
['text':' The move was successful; nothing to do here.','line_number':977,'multiline':False]
['text':' Pre-shift the immediate to the least-significant bits of the register.','line_number':979,'multiline':False]
['text':' When applied to the stack pointer, the subsequent arithmetic operation','line_number':982,'multiline':False]
['text':' can use the extend form to shift left by a maximum of four bits. Right','line_number':983,'multiline':False]
['text':' shifts are not allowed, so we filter them out later before the new','line_number':984,'multiline':False]
['text':' immediate is tested.','line_number':985,'multiline':False]
['text':' Pre-shift the immediate to the most-significant bits of the register,','line_number':991,'multiline':False]
['text':' inserting set bits in the least-significant bits.','line_number':992,'multiline':False]
['text':' The new immediate has been moved into the destination's low bits:','line_number':997,'multiline':False]
['text':' return a new leftward-shifting operand.','line_number':998,'multiline':False]
['text':' The new immediate has been moved into the destination's high bits:','line_number':1001,'multiline':False]
['text':' return a new rightward-shifting operand.','line_number':1002,'multiline':False]
['text':' We cannot handle pre-indexing or post-indexing.','line_number':1014,'multiline':False]
['text':' Worst case is add/sub immediate:','line_number':1040,'multiline':False]
['text':'  * up to 4 instructions to materialise the constant','line_number':1041,'multiline':False]
['text':'  * 1 instruction for add/sub','line_number':1042,'multiline':False]
['text':' The instruction would be a nop. Avoid generating useless code.','line_number':1047,'multiline':False]
['text':' If the destination or source register is the stack pointer, we can','line_number':1059,'multiline':False]
['text':' only pre-shift the immediate right by values supported in the add/sub','line_number':1060,'multiline':False]
['text':' extend encoding.','line_number':1061,'multiline':False]
['text':' If the destination is SP and flags will be set, we can't pre-shift','line_number':1063,'multiline':False]
['text':' the immediate at all. ','line_number':1064,'multiline':False]
['text':' Worst case is addc/subc immediate:','line_number':1131,'multiline':False]
['text':'  * up to 4 instructions to materialise the constant','line_number':1132,'multiline':False]
['text':'  * 1 instruction for add/sub','line_number':1133,'multiline':False]
['text':' Add/sub with carry (immediate or ROR shifted register.)','line_number':1139,'multiline':False]
['text':' Add/sub with carry (shifted register).','line_number':1145,'multiline':False]
['text':' Add/sub with carry (extended register).','line_number':1156,'multiline':False]
['text':' Add/sub extended supports a shift <= 4. We want to support exactly the','line_number':1158,'multiline':False]
['text':' same modes.','line_number':1159,'multiline':False]
['text':' The addressing mode is directly supported by the instruction.','line_number':1170,'multiline':False]
['text':' Worst case is ldr/str pre/post index:','line_number':1187,'multiline':False]
['text':'  * 1 instruction for ldr/str','line_number':1188,'multiline':False]
['text':'  * up to 4 instructions to materialise the constant','line_number':1189,'multiline':False]
['text':'  * 1 instruction to update the base','line_number':1190,'multiline':False]
['text':' Check if an immediate offset fits in the immediate field of the','line_number':1196,'multiline':False]
['text':' appropriate instruction. If not, emit two instructions to perform','line_number':1197,'multiline':False]
['text':' the operation.','line_number':1198,'multiline':False]
['text':' Immediate offset that can't be encoded using unsigned or unscaled','line_number':1201,'multiline':False]
['text':' addressing modes.','line_number':1202,'multiline':False]
['text':' Post-index beyond unscaled addressing range.','line_number':1210,'multiline':False]
['text':' Pre-index beyond unscaled addressing range.','line_number':1214,'multiline':False]
['text':' Encodable in one load/store instruction.','line_number':1218,'multiline':False]
['text':' TODO(all): Should we support register offset for load-store-pair?','line_number':1237,'multiline':False]
['text':' Worst case is ldp/stp immediate:','line_number':1239,'multiline':False]
['text':'  * 1 instruction for ldp/stp','line_number':1240,'multiline':False]
['text':'  * up to 4 instructions to materialise the constant','line_number':1241,'multiline':False]
['text':'  * 1 instruction to update the base','line_number':1242,'multiline':False]
['text':' Check if the offset fits in the immediate field of the appropriate','line_number':1248,'multiline':False]
['text':' instruction. If not, emit two instructions to perform the operation.','line_number':1249,'multiline':False]
['text':' Encodable in one load/store pair instruction.','line_number':1251,'multiline':False]
['text':' There are no pre- or post-index modes for prfm.','line_number':1275,'multiline':False]
['text':' The access size is implicitly 8 bytes for all prefetch operations.','line_number':1278,'multiline':False]
['text':' Check if an immediate offset fits in the immediate field of the','line_number':1281,'multiline':False]
['text':' appropriate instruction. If not, emit two instructions to perform','line_number':1282,'multiline':False]
['text':' the operation.','line_number':1283,'multiline':False]
['text':' Immediate offset that can't be encoded using unsigned or unscaled','line_number':1286,'multiline':False]
['text':' addressing modes.','line_number':1287,'multiline':False]
['text':' Simple register-offsets are encodable in one instruction.','line_number':1293,'multiline':False]
['text':' Pushing a stack pointer leads to implementation-defined','line_number':1302,'multiline':False]
['text':' behavior, which may be surprising. In particular,','line_number':1303,'multiline':False]
['text':'   str x28, [x28, #-8]!','line_number':1304,'multiline':False]
['text':' pre-decrements the stack pointer, storing the decremented value.','line_number':1305,'multiline':False]
['text':' Additionally, sp is read as xzr in this context, so it cannot be pushed.','line_number':1306,'multiline':False]
['text':' So we must use a scratch register.','line_number':1307,'multiline':False]
['text':' It is not valid to pop into the same register more than once in one','line_number':1338,'multiline':False]
['text':' instruction, not even into the zero register.','line_number':1339,'multiline':False]
['text':' Bump the stack pointer and store two registers at the bottom.','line_number':1359,'multiline':False]
['text':' Load the two registers at the bottom and drop the stack pointer.','line_number':1407,'multiline':False]
['text':' Push up to four registers at a time if possible because if the current','line_number':1420,'multiline':False]
['text':' stack pointer is sp and the register size is 32, registers must be pushed','line_number':1421,'multiline':False]
['text':' in blocks of four in order to maintain the 16-byte alignment for sp.','line_number':1422,'multiline':False]
['text':' Ensure that we don't unintentionally modify scratch or debug registers.','line_number':1444,'multiline':False]
['text':' Worst case for size is 2 stp.','line_number':1445,'multiline':False]
['text':' Pushing the stack pointer has unexpected behavior. See PushStackPointer().','line_number':1452,'multiline':False]
['text':' The JS engine should never push 4 bytes.','line_number':1458,'multiline':False]
['text':' When pushing multiple registers, the store order is chosen such that','line_number':1461,'multiline':False]
['text':' Push(a, b) is equivalent to Push(a) followed by Push(b).','line_number':1462,'multiline':False]
['text':' Skip over 4 * size, then fill in the gap. This allows four W registers','line_number':1478,'multiline':False]
['text':' to be pushed using sp, whilst maintaining 16-byte alignment for sp at','line_number':1479,'multiline':False]
['text':' all times.','line_number':1480,'multiline':False]
['text':' Ensure that we don't unintentionally modify scratch or debug registers.','line_number':1495,'multiline':False]
['text':' Worst case for size is 2 ldp.','line_number':1496,'multiline':False]
['text':' When popping multiple registers, the load order is chosen such that','line_number':1503,'multiline':False]
['text':' Pop(a, b) is equivalent to Pop(a) followed by Pop(b).','line_number':1504,'multiline':False]
['text':' Load the higher addresses first, then load the lower addresses and skip','line_number':1520,'multiline':False]
['text':' the whole block in the second instruction. This allows four W registers','line_number':1521,'multiline':False]
['text':' to be popped using sp, whilst maintaining 16-byte alignment for sp at','line_number':1522,'multiline':False]
['text':' all times.','line_number':1523,'multiline':False]
['text':' If the current stack pointer is sp, then it must be aligned to 16 bytes','line_number':1535,'multiline':False]
['text':' on entry and the total size of the specified registers must also be a','line_number':1536,'multiline':False]
['text':' multiple of 16 bytes.','line_number':1537,'multiline':False]
['text':' Even if the current stack pointer is not the system stack pointer (sp),','line_number':1540,'multiline':False]
['text':' the system stack pointer will still be modified in order to comply with','line_number':1541,'multiline':False]
['text':' ABI rules about accessing memory below the system stack pointer.','line_number':1542,'multiline':False]
['text':' If the current stack pointer is sp, then it must be aligned to 16 bytes','line_number':1551,'multiline':False]
['text':' on entry and the total size of the specified registers must also be a','line_number':1552,'multiline':False]
['text':' multiple of 16 bytes.','line_number':1553,'multiline':False]
['text':' Make sure the real stack pointer reflects the claimed stack space.','line_number':1591,'multiline':False]
['text':' We can't use stack memory below the stack pointer, it could be clobbered by','line_number':1592,'multiline':False]
['text':' interupts and signal handlers.','line_number':1593,'multiline':False]
['text':' Ensure that the macro-assembler doesn't use any scratch registers.','line_number':1618,'multiline':False]
['text':' 10 stp will be emitted.','line_number':1619,'multiline':False]
['text':' TODO(all): Should we use GetCalleeSaved and SavedFP.','line_number':1620,'multiline':False]
['text':' This method must not be called unless the current stack pointer is sp.','line_number':1623,'multiline':False]
['text':' Ensure that the macro-assembler doesn't use any scratch registers.','line_number':1643,'multiline':False]
['text':' 10 ldp will be emitted.','line_number':1644,'multiline':False]
['text':' TODO(all): Should we use GetCalleeSaved and SavedFP.','line_number':1645,'multiline':False]
['text':' This method must not be called unless the current stack pointer is sp.','line_number':1648,'multiline':False]
['text':' We do not handle pre-indexing or post-indexing.','line_number':1680,'multiline':False]
['text':' If necessary, pre-compute the base address for the accesses.','line_number':1717,'multiline':False]
['text':' TODO: Several callers rely on this not using scratch registers, so we use','line_number':1742,'multiline':False]
['text':' the assembler directly here. However, this means that large immediate','line_number':1743,'multiline':False]
['text':' values of 'space' cannot be handled.','line_number':1744,'multiline':False]
['text':' The arguments to the trace pseudo instruction need to be contiguous in','line_number':1753,'multiline':False]
['text':' memory, so make sure we don't try to emit a literal pool.','line_number':1754,'multiline':False]
['text':' Refer to simulator-a64.h for a description of the marker and its','line_number':1760,'multiline':False]
['text':' arguments.','line_number':1761,'multiline':False]
['text':' VIXL_ASSERT(SizeOfCodeGeneratedSince(&start) == kTraceParamsOffset);','line_number':1764,'multiline':False]
['text':' VIXL_ASSERT(SizeOfCodeGeneratedSince(&start) == kTraceCommandOffset);','line_number':1767,'multiline':False]
['text':' Emit nothing on real hardware.','line_number':1770,'multiline':False]
['text':' The arguments to the log pseudo instruction need to be contiguous in','line_number':1779,'multiline':False]
['text':' memory, so make sure we don't try to emit a literal pool.','line_number':1780,'multiline':False]
['text':' Refer to simulator-a64.h for a description of the marker and its','line_number':1786,'multiline':False]
['text':' arguments.','line_number':1787,'multiline':False]
['text':' VIXL_ASSERT(SizeOfCodeGeneratedSince(&start) == kLogParamsOffset);','line_number':1790,'multiline':False]
['text':' Emit nothing on real hardware.','line_number':1793,'multiline':False]
['text':' We allow only printable characters in the marker names. Unprintable','line_number':1816,'multiline':False]
['text':' characters are reserved for controlling features of the instrumentation.','line_number':1817,'multiline':False]
['text':' This allows deferred (and optional) initialisation of the scope.','line_number':1861,'multiline':False]
['text':' Make sure that neither sp nor xzr are included the list.','line_number':1907,'multiline':False]
['text':' Make sure that neither sp nor xzr are included the list.','line_number':1922,'multiline':False]
['text':' namespace vixl','line_number':2027,'multiline':False]
