['text':' This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' -*- indent-tabs-mode: nil; js-indent-level: 4 -*- ','line_number':5,'multiline':True]
['text':' Only produce a mangled -> unmangled mapping once, unless there are','line_number':48,'multiline':False]
['text':' multiple unmangled names for the same mangled name.','line_number':49,'multiline':False]
['text':' Returns a table mapping function name to lists of','line_number':67,'multiline':False]
['text':' [annotation-name, annotation-value] pairs:','line_number':68,'multiline':False]
['text':'   { function-name => [ [annotation-name, annotation-value] ] }','line_number':69,'multiline':False]
['text':'','line_number':70,'multiline':False]
['text':' Note that sixgill will only store certain attributes (annotation-names), so','line_number':71,'multiline':False]
['text':' this won't be *all* the attributes in the source, just the ones that sixgill','line_number':72,'multiline':False]
['text':' watches for.','line_number':73,'multiline':False]
['text':' Get just the annotations understood by the hazard analysis.','line_number':91,'multiline':False]
['text':' Scan through a function body, pulling out all annotations and calls and','line_number':104,'multiline':False]
['text':' recording them in callgraph.txt.','line_number':105,'multiline':False]
['text':' Set of all callees that have been output so far, in order to suppress','line_number':118,'multiline':False]
['text':' repeated callgraph edges from being recorded. This uses a Map from','line_number':119,'multiline':False]
['text':' callees to limit sets, because we don't want a limited edge to prevent','line_number':120,'multiline':False]
['text':' an unlimited edge from being recorded later. (So an edge will be skipped','line_number':121,'multiline':False]
['text':' if it exists and is at least as limited as the previously seen edge.)','line_number':122,'multiline':False]
['text':'','line_number':123,'multiline':False]
['text':' Limit sets are implemented as integers interpreted as bitfields.','line_number':124,'multiline':False]
['text':'','line_number':125,'multiline':False]
['text':' The limits (eg LIMIT_CANNOT_GC) are determined by whatever RAII','line_number':133,'multiline':False]
['text':' scopes might be active, which have been computed previously for all','line_number':134,'multiline':False]
['text':' points in the body.','line_number':135,'multiline':False]
['text':' Individual callees may have additional limits. The only such','line_number':139,'multiline':False]
['text':' limit currently is that nsISupports.{AddRef,Release} are assumed','line_number':140,'multiline':False]
['text':' to never GC.','line_number':141,'multiline':False]
['text':' Only output an edge if it loosens a limit.','line_number':148,'multiline':False]
['text':' Fully-resolved field (virtual method) call. Record the','line_number':158,'multiline':False]
['text':' callgraph edges. Do not consider limits, since they are','line_number':159,'multiline':False]
['text':' local to this callsite and we are writing out a global','line_number':160,'multiline':False]
['text':' record here.','line_number':161,'multiline':False]
['text':'','line_number':162,'multiline':False]
['text':' Any field call that does *not* have an R entry must be','line_number':163,'multiline':False]
['text':' assumed to call anything.','line_number':164,'multiline':False]
['text':' GCC generates multiple constructors and destructors ("in-charge" and','line_number':219,'multiline':False]
['text':' "not-in-charge") to handle virtual base classes. They are normally','line_number':220,'multiline':False]
['text':' identical, and it appears that GCC does some magic to alias them to the','line_number':221,'multiline':False]
['text':' same thing. But this aliasing is not visible to the analysis. So we'll','line_number':222,'multiline':False]
['text':' add a dummy call edge from "foo" -> "foo *INTERNAL* ", since only "foo"','line_number':223,'multiline':False]
['text':' will show up as called but only "foo *INTERNAL* " will be emitted in the','line_number':224,'multiline':False]
['text':' case where the constructors are identical.','line_number':225,'multiline':False]
['text':'','line_number':226,'multiline':False]
['text':' This is slightly conservative in the case where they are *not*','line_number':227,'multiline':False]
['text':' identical, but that should be rare enough that we don't care.','line_number':228,'multiline':False]
['text':' Further note: from https://itanium-cxx-abi.github.io/cxx-abi/abi.html the','line_number':237,'multiline':False]
['text':' different kinds of constructors/destructors are:','line_number':238,'multiline':False]
['text':' C1	# complete object constructor','line_number':239,'multiline':False]
['text':' C2	# base object constructor','line_number':240,'multiline':False]
['text':' C3	# complete object allocating constructor','line_number':241,'multiline':False]
['text':' D0	# deleting destructor','line_number':242,'multiline':False]
['text':' D1	# complete object destructor','line_number':243,'multiline':False]
['text':' D2	# base object destructor','line_number':244,'multiline':False]
['text':'','line_number':245,'multiline':False]
['text':' In actual practice, I have observed C4 and D4 xtors generated by gcc','line_number':246,'multiline':False]
['text':' 4.9.3 (but not 4.7.3). The gcc source code says:','line_number':247,'multiline':False]
['text':'','line_number':248,'multiline':False]
['text':'   /* This is the old-style "[unified]" constructor.','line_number':249,'multiline':False]
['text':'      In some cases, we may emit this function and call','line_number':250,'multiline':False]
['text':'      it from the clones in order to share code and save space.  */','line_number':251,'multiline':False]
['text':'','line_number':252,'multiline':False]
['text':' Unfortunately, that "call... from the clones" does not seem to appear in','line_number':253,'multiline':False]
['text':' the CFG we get from GCC. So if we see a C4 constructor or D4 destructor,','line_number':254,'multiline':False]
['text':' inject an edge to it from C1, C2, and C3 (or D1, D2, and D3). (Note that','line_number':255,'multiline':False]
['text':' C3 isn't even used in current GCC, but add the edge anyway just in','line_number':256,'multiline':False]
['text':' case.)','line_number':257,'multiline':False]
['text':'','line_number':258,'multiline':False]
['text':' from gcc/cp/mangle.c:','line_number':259,'multiline':False]
['text':'','line_number':260,'multiline':False]
['text':' <special-name> ::= D0 # deleting (in-charge) destructor','line_number':261,'multiline':False]
['text':'                ::= D1 # complete object (in-charge) destructor','line_number':262,'multiline':False]
['text':'                ::= D2 # base object (not-in-charge) destructor','line_number':263,'multiline':False]
['text':' <special-name> ::= C1   # complete object constructor','line_number':264,'multiline':False]
['text':'                ::= C2   # base object constructor','line_number':265,'multiline':False]
['text':'                ::= C3   # complete object allocating constructor','line_number':266,'multiline':False]
['text':'','line_number':267,'multiline':False]
['text':' Currently, allocating constructors are never used.','line_number':268,'multiline':False]
['text':'','line_number':269,'multiline':False]
['text':' E terminates the method name (and precedes the method parameters).','line_number':271,'multiline':False]
['text':' If eg "C4E" shows up in the mangled name for another reason, this','line_number':272,'multiline':False]
['text':' will create bogus edges in the callgraph. But it will affect little','line_number':273,'multiline':False]
['text':' and is somewhat difficult to avoid, so we will live with it.','line_number':274,'multiline':False]
['text':'','line_number':275,'multiline':False]
['text':' Another possibility! A templatized constructor will contain C4I...E','line_number':276,'multiline':False]
['text':' for template arguments.','line_number':277,'multiline':False]
['text':'','line_number':278,'multiline':False]
['text':' For destructors:','line_number':296,'multiline':False]
['text':'','line_number':297,'multiline':False]
['text':' I've never seen D4Ev() + D4Ev(int32), only one or the other. So','line_number':298,'multiline':False]
['text':' for a D4Ev of any sort, create:','line_number':299,'multiline':False]
['text':'','line_number':300,'multiline':False]
['text':'   D0() -> D1()  # deleting destructor calls complete destructor, then deletes','line_number':301,'multiline':False]
['text':'   D1() -> D2()  # complete destructor calls base destructor, then destroys virtual bases','line_number':302,'multiline':False]
['text':'   D2() -> D4(?) # base destructor might be aliased to unified destructor','line_number':303,'multiline':False]
['text':'                 # use whichever one is defined, in-charge or not.','line_number':304,'multiline':False]
['text':'                 # ('?') means either () or (int32).','line_number':305,'multiline':False]
['text':'','line_number':306,'multiline':False]
['text':' Note that this doesn't actually make sense -- D0 and D1 should be','line_number':307,'multiline':False]
['text':' in-charge, but gcc doesn't seem to give them the in-charge parameter?!','line_number':308,'multiline':False]
['text':'','line_number':309,'multiline':False]
