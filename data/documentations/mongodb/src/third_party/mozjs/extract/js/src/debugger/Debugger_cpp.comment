['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' for MOZ_STACK_CLASS, MOZ_RAII','line_number':9,'multiline':False]
['text':' for DebugOnly','line_number':10,'multiline':False]
['text':' for DoublyLinkedList<>::Iterator','line_number':11,'multiline':False]
['text':' for HashSet<>::Range, HashMapEntry','line_number':12,'multiline':False]
['text':' for Maybe, Nothing, Some','line_number':13,'multiline':False]
['text':' for MakeScopeExit, ScopeExit','line_number':14,'multiline':False]
['text':' for ThreadLocal','line_number':15,'multiline':False]
['text':' for TimeStamp, TimeDuration','line_number':16,'multiline':False]
['text':' for UniquePtr','line_number':17,'multiline':False]
['text':' for AsVariant, AsVariantTemporary','line_number':18,'multiline':False]
['text':' for Vector, Vector<>::ConstRange','line_number':19,'multiline':False]
['text':' for std::find, std::max','line_number':21,'multiline':False]
['text':' for function','line_number':22,'multiline':False]
['text':' for size_t','line_number':23,'multiline':False]
['text':' for uint32_t, uint64_t, int32_t','line_number':24,'multiline':False]
['text':' for strlen, strcmp','line_number':25,'multiline':False]
['text':' for std::move','line_number':26,'multiline':False]
['text':' for CallArgs, CallArgsFromVp','line_number':28,'multiline':False]
['text':' for JS_PUBLIC_API','line_number':29,'multiline':False]
['text':' for NewDenseFullyAllocatedArray','line_number':31,'multiline':False]
['text':' for ResumeMode, DebugAPI','line_number':32,'multiline':False]
['text':' for DebuggerMemory','line_number':33,'multiline':False]
['text':' for DebugScript','line_number':34,'multiline':False]
['text':' for DebuggerEnvironment','line_number':35,'multiline':False]
['text':' for DebuggerFrame','line_number':36,'multiline':False]
['text':' for EnterDebuggeeNoExecute','line_number':37,'multiline':False]
['text':' for DebuggerObject','line_number':38,'multiline':False]
['text':' for DebuggerScript','line_number':39,'multiline':False]
['text':' for DebuggerSource','line_number':40,'multiline':False]
['text':' for CompilationStencil','line_number':41,'multiline':False]
['text':' for ParseGoal, ParseGoal::Script','line_number':42,'multiline':False]
['text':' for UsedNameTracker','line_number':43,'multiline':False]
['text':' for Parser','line_number':44,'multiline':False]
['text':' for JSFreeOp','line_number':45,'multiline':False]
['text':' for IterateScripts','line_number':46,'multiline':False]
['text':' for GCMarker','line_number':47,'multiline':False]
['text':' for GCRuntime, AutoEnterIteration','line_number':48,'multiline':False]
['text':' for DependentAddPtr','line_number':49,'multiline':False]
['text':' for IsMarkedUnbarriered, IsMarked','line_number':50,'multiline':False]
['text':' for RealmsIter, CompartmentsIter','line_number':51,'multiline':False]
['text':' for RootedNativeObject','line_number':52,'multiline':False]
['text':' for Statistics::SliceData','line_number':53,'multiline':False]
['text':' for TraceEdge','line_number':54,'multiline':False]
['text':' for Zone','line_number':55,'multiline':False]
['text':' for ZoneAllocPolicy','line_number':56,'multiline':False]
['text':' for RecompileOnStackBaselineScriptsForDebugMode','line_number':57,'multiline':False]
['text':' for FinishDiscardBaselineScript','line_number':58,'multiline':False]
['text':' for RecompileInfoVector','line_number':59,'multiline':False]
['text':' for JitContext','line_number':60,'multiline':False]
['text':' for JitScript','line_number':61,'multiline':False]
['text':' for InlineFrameIterator','line_number':62,'multiline':False]
['text':' for RematerializedFrame','line_number':63,'multiline':False]
['text':' for ToBoolean, ToUint32','line_number':64,'multiline':False]
['text':' for Builder::Object, Builder','line_number':65,'multiline':False]
['text':' for GetErrorMessage, JSMSG_*','line_number':66,'multiline':False]
['text':' for GarbageCollectionEvent','line_number':67,'multiline':False]
['text':' for ExposeObjectToActiveJS','line_number':68,'multiline':False]
['text':' for AutoDebuggerJobQueueInterruption','line_number':69,'multiline':False]
['text':' for PropertyDescriptor','line_number':70,'multiline':False]
['text':' for SourceOwnership, SourceText','line_number':71,'multiline':False]
['text':' for AutoStableStringChars','line_number':72,'multiline':False]
['text':' for Node, RootList, Edge','line_number':73,'multiline':False]
['text':' for BreadthFirst','line_number':74,'multiline':False]
['text':' for AutoSuppressWarningReporter','line_number':75,'multiline':False]
['text':' for CheckedUnwrapStatic','line_number':76,'multiline':False]
['text':' for DuplicateString, js_strlen','line_number':77,'multiline':False]
['text':' for ArrayObject','line_number':78,'multiline':False]
['text':' for AsyncFunctionGeneratorObject','line_number':79,'multiline':False]
['text':' for AsyncGeneratorObject','line_number':80,'multiline':False]
['text':' for JSDVG_IGNORE_STACK','line_number':81,'multiline':False]
['text':' for CrossCompartmentKey','line_number':82,'multiline':False]
['text':' for IsSyntacticEnvironment','line_number':83,'multiline':False]
['text':' for ReportErrorToGlobal','line_number':84,'multiline':False]
['text':' for AbstractGeneratorObject','line_number':85,'multiline':False]
['text':' for GlobalObject','line_number':86,'multiline':False]
['text':' for Call, ReportIsNotFunction','line_number':87,'multiline':False]
['text':' for CreateIterResultObject','line_number':88,'multiline':False]
['text':' for Atomize, ClassName','line_number':89,'multiline':False]
['text':' for JSContext','line_number':90,'multiline':False]
['text':' for JSFunction','line_number':91,'multiline':False]
['text':' for JSObject, RequireObject,','line_number':92,'multiline':False]
['text':' for DefineDataProperty','line_number':93,'multiline':False]
['text':' for js::PlainObject','line_number':94,'multiline':False]
['text':' for js::PromiseObject','line_number':95,'multiline':False]
['text':' for ProxyObject, JSObject::is','line_number':96,'multiline':False]
['text':' for AutoRealm, Realm','line_number':97,'multiline':False]
['text':' for ReportOutOfMemory, JSRuntime','line_number':98,'multiline':False]
['text':' for SavedFrame','line_number':99,'multiline':False]
['text':' for SavedStacks','line_number':100,'multiline':False]
['text':' for Scope','line_number':101,'multiline':False]
['text':' for JSString, PropertyName','line_number':102,'multiline':False]
['text':' for TraceLoggerForCurrentThread','line_number':103,'multiline':False]
['text':' for CrossCompartmentWrapperObject','line_number':104,'multiline':False]
['text':' for DebugState','line_number':105,'multiline':False]
['text':' for Instance','line_number':106,'multiline':False]
['text':' for WasmInstanceObject','line_number':107,'multiline':False]
['text':' for Realm','line_number':108,'multiline':False]
['text':' for WasmInstanceObjectVector','line_number':109,'multiline':False]
['text':' for DebuggerEnvironment::owner','line_number':112,'multiline':False]
['text':' for DebuggerFrame::hasGeneratorInfo','line_number':113,'multiline':False]
['text':' for DebuggerObject::owner and isInstance.','line_number':114,'multiline':False]
['text':' for DebuggerScript::getReferent','line_number':115,'multiline':False]
['text':' for ZoneCellIter','line_number':116,'multiline':False]
['text':' for MaybeForwarded','line_number':117,'multiline':False]
['text':' for DebuggerWeakMap::trace','line_number':118,'multiline':False]
['text':' for Compartment::wrap','line_number':119,'multiline':False]
['text':' for AutoSuppressProfilerSampling','line_number':120,'multiline':False]
['text':' for AtomToId, ValueToId','line_number':121,'multiline':False]
['text':' for JSContext::check','line_number':122,'multiline':False]
['text':' for JSObject::isCallable, NewTenuredObjectWithGivenProto','line_number':123,'multiline':False]
['text':' for JSScript::isDebuggee, JSScript','line_number':124,'multiline':False]
['text':' for NativeObject::ensureDenseInitializedLength','line_number':125,'multiline':False]
['text':' for GetProperty, HasProperty','line_number':126,'multiline':False]
['text':' for AutoRealm::AutoRealm','line_number':127,'multiline':False]
['text':' for AbstractFramePtr::script','line_number':128,'multiline':False]
['text':' namespace js ','line_number':144,'multiline':True]
['text':'** Utils *****************************************************************','line_number':164,'multiline':True]
['text':' The default value for each argument is |undefined|.','line_number':180,'multiline':False]
['text':' Skip any internal, non-identifier names, like for example ".args".','line_number':197,'multiline':False]
['text':' static ','line_number':241,'multiline':True]
['text':' In some OOM failure cases, we need to destroy the edge to the referent,','line_number':249,'multiline':False]
['text':' to avoid trying to trace it during untimely collections.','line_number':250,'multiline':False]
['text':' The Debugger's hooks may return a value that affects the completion','line_number':256,'multiline':False]
['text':' value of the given frame. For example, a hook may return `{ return: 42 }`','line_number':257,'multiline':False]
['text':' to terminate the frame and return `42` as the final frame result.','line_number':258,'multiline':False]
['text':' To accomplish this, the debugger treats these return values as if','line_number':259,'multiline':False]
['text':' execution of the JS function has been terminated without a pending','line_number':260,'multiline':False]
['text':' exception, but with a special flag. When the error is handled by the','line_number':261,'multiline':False]
['text':' interpreter or JIT, the special flag and the error state will be cleared','line_number':262,'multiline':False]
['text':' and execution will continue from the end of the frame.','line_number':263,'multiline':False]
['text':' The value passed in here is unwrapped and has no guarantees about what','line_number':281,'multiline':False]
['text':' compartment it may be associated with, so we explicitly wrap it into the','line_number':282,'multiline':False]
['text':' debuggee compartment.','line_number':283,'multiline':False]
['text':' If we have a stack from the original throw, use it instead of','line_number':297,'multiline':False]
['text':' associating the throw with the current execution point.','line_number':298,'multiline':False]
['text':'** Breakpoints ***********************************************************','line_number':398,'multiline':True]
['text':'** Debugger hook dispatch ************************************************','line_number':517,'multiline':True]
['text':' The "probably" here is because there could technically be multiple lists','line_number':565,'multiline':False]
['text':' with this type signature and theoretically the debugger could be an entry','line_number':566,'multiline':False]
['text':' in a different one. That is not actually possible however because there','line_number':567,'multiline':False]
['text':' is only one list the debugger could be in.','line_number':568,'multiline':False]
['text':' Breakpoints should hold us alive, so any breakpoints remaining must be set','line_number':578,'multiline':False]
['text':' in dying JSScripts. We should clean them up, but this never asserts. I'm','line_number':579,'multiline':False]
['text':' not sure why.','line_number':580,'multiline':False]
['text':' We don't have to worry about locking here since Debugger is not','line_number':583,'multiline':False]
['text':' background finalized.','line_number':584,'multiline':False]
['text':' static ','line_number':591,'multiline':True]
['text':'** Debugger accessors ******************************************************','line_number':612,'multiline':True]
['text':' Since there is no frame/generator data to associate with this frame, this','line_number':629,'multiline':False]
['text':' will create a new, "terminated" Debugger.Frame object.','line_number':630,'multiline':False]
['text':' If this frame has a generator associated with it, but no on-stack','line_number':659,'multiline':False]
['text':' Debugger.Frame object was found, there should not be a suspended','line_number':660,'multiline':False]
['text':' Debugger.Frame either because otherwise slowPathOnResumeFrame would','line_number':661,'multiline':False]
['text':' have already populated the "frames" map with a Debugger.Frame.','line_number':662,'multiline':False]
['text':' If the frame's generator is closed, there is no way to associate the','line_number':665,'multiline':False]
['text':' generator with the frame successfully because there is no way to','line_number':666,'multiline':False]
['text':' get the generator's callee script, and even if we could, having it','line_number':667,'multiline':False]
['text':' there would in no way affect the behavior of the frame.','line_number':668,'multiline':False]
['text':' If no AbstractGeneratorObject exists yet, we create a Debugger.Frame','line_number':673,'multiline':False]
['text':' below anyway, and Debugger::onNewGenerator() will associate it','line_number':674,'multiline':False]
['text':' with the AbstractGeneratorObject later when we hit JSOp::Generator.','line_number':675,'multiline':False]
['text':' Create and populate the Debugger.Frame object.','line_number':678,'multiline':False]
['text':' To create a Debugger.Frame for a running generator, we'd also need a','line_number':718,'multiline':False]
['text':' FrameIter for its stack frame. We could make this work by searching the','line_number':719,'multiline':False]
['text':' stack for the generator's frame, but for the moment, we only need this','line_number':720,'multiline':False]
['text':' function to handle generators we've found on promises' reaction records,','line_number':721,'multiline':False]
['text':' which should always be suspended.','line_number':722,'multiline':False]
['text':' Do we have an existing Debugger.Frame for this generator?','line_number':725,'multiline':False]
['text':' Create a new Debugger.Frame.','line_number':733,'multiline':False]
['text':' The GC analysis can't determine that the predicate can't GC, so let it know','line_number':754,'multiline':False]
['text':' explicitly.','line_number':755,'multiline':False]
['text':' Callbacks should not create new references to the debugger, so don't','line_number':759,'multiline':False]
['text':' use a barrier. This allows this method to be called during GC.','line_number':760,'multiline':False]
['text':' static ','line_number':768,'multiline':True]
['text':' static ','line_number':774,'multiline':True]
['text':' static ','line_number':780,'multiline':True]
['text':' static ','line_number':786,'multiline':True]
['text':' static ','line_number':792,'multiline':True]
['text':' static ','line_number':797,'multiline':True]
['text':' bool (Debugger*) ','line_number':802,'multiline':True]
['text':' Determine which debuggers will receive this event, and in what order.','line_number':804,'multiline':False]
['text':' Make a copy of the list, since the original is mutable and we will be','line_number':805,'multiline':False]
['text':' calling into arbitrary JS.','line_number':806,'multiline':False]
['text':' bool (Debugger*) ','line_number':819,'multiline':True]
['text':' bool (Debugger*) ','line_number':820,'multiline':True]
['text':' Preserve the debuggee's microtask event queue while we run the hooks, so','line_number':823,'multiline':False]
['text':' the debugger's microtask checkpoints don't run from the debuggee's','line_number':824,'multiline':False]
['text':' microtasks, and vice versa.','line_number':825,'multiline':False]
['text':' Deliver the event to each debugger, checking again to make sure it','line_number':831,'multiline':False]
['text':' should still be delivered.','line_number':832,'multiline':False]
['text':' bool (Debugger*) ','line_number':849,'multiline':True]
['text':' bool (Debugger*) ','line_number':850,'multiline':True]
['text':' dispatchHook may fail due to OOM. This OOM is not handlable at the','line_number':856,'multiline':False]
['text':' callsites of dispatchQuietHook in the engine.','line_number':857,'multiline':False]
['text':' bool (Debugger*) ','line_number':863,'multiline':True]
['text':' bool (Debugger*, ResumeMode&, MutableHandleValue vp) ','line_number':864,'multiline':True]
['text':' A onNewGlobalObject hook does not hold its Debugger live, so its behavior','line_number':883,'multiline':False]
['text':' is nondeterministic. This behavior is not satisfying, but it is at least','line_number':884,'multiline':False]
['text':' documented.','line_number':885,'multiline':False]
['text':' static ','line_number':894,'multiline':True]
['text':' static ','line_number':905,'multiline':True]
['text':' Don't count on this method to be called every time a generator is','line_number':907,'multiline':False]
['text':' resumed! This is called only if the frame's debuggee bit is set,','line_number':908,'multiline':False]
['text':' i.e. the script has breakpoints or the frame is stepping.','line_number':909,'multiline':False]
['text':' If there is an OOM, we mark all of the Debugger.Frame objects terminated','line_number':917,'multiline':False]
['text':' because we want to ensure that none of the frames are in a partially','line_number':918,'multiline':False]
['text':' initialized state where they are in "generatorFrames" but not "frames".','line_number':919,'multiline':False]
['text':' For each debugger, if there is an existing Debugger.Frame object for the','line_number':926,'multiline':False]
['text':' resumed `frame`, update it with the new frame pointer and make sure the','line_number':927,'multiline':False]
['text':' frame is observable.','line_number':928,'multiline':False]
['text':' static ','line_number':952,'multiline':True]
['text':' "onNativeCall" only works consistently in the context of an explicit eval','line_number':956,'multiline':False]
['text':' that has set the "insideDebuggerEvaluationWithOnNativeCallHook" state','line_number':957,'multiline':False]
['text':' on the JSContext, so we fast-path this hook to bail right away if that is','line_number':958,'multiline':False]
['text':' not currently set. If this flag is set to a _different_ debugger, the','line_number':959,'multiline':False]
['text':' standard "isHookCallAllowed" debugger logic will apply and only hooks on','line_number':960,'multiline':False]
['text':' that debugger will be callable.','line_number':961,'multiline':False]
['text':' The onNativeCall hook is fired when self hosted functions are called,','line_number':978,'multiline':False]
['text':' and any other self hosted function or C++ native that is directly called','line_number':979,'multiline':False]
['text':' by the self hosted function is considered to be part of the same','line_number':980,'multiline':False]
['text':' native call.','line_number':981,'multiline':False]
['text':'','line_number':982,'multiline':False]
['text':' We check this only after checking that debuggerList has items in order','line_number':983,'multiline':False]
['text':' to avoid unnecessary calls to cx->currentScript(), which can be expensive','line_number':984,'multiline':False]
['text':' when the top frame is in jitcode.','line_number':985,'multiline':False]
['text':' The value is not in any particular compartment, so it needs to be','line_number':1000,'multiline':False]
['text':' explicitly wrapped into the debuggee compartment.','line_number':1001,'multiline':False]
['text':'
 * RAII class to mark a generator as "running" temporarily while running
 * debugger code.
 *
 * When Debugger::slowPathOnLeaveFrame is called for a frame that is yielding
 * or awaiting, its generator is in the "suspended" state. Letting script
 * observe this state, with the generator on stack yet also reenterable, would
 * be bad, so we mark it running while we fire events.
 ','line_number':1026,'multiline':True]
['text':' Yielding or awaiting.','line_number':1049,'multiline':False]
['text':' Async generators have additionally bookkeeping which must be','line_number':1053,'multiline':False]
['text':' adjusted when switching over to the running state.','line_number':1054,'multiline':False]
['text':' Returning or throwing. The generator is already closed, if','line_number':1061,'multiline':False]
['text':' it was ever exposed at all.','line_number':1062,'multiline':False]
['text':'
 * Handle leaving a frame with debuggers watching. |frameOk| indicates whether
 * the frame is exiting normally or abruptly. Set |cx|'s exception and/or
 * |cx->fp()|'s return value, and return a new success value.
 ','line_number':1079,'multiline':True]
['text':' static ','line_number':1084,'multiline':True]
['text':' These are updated below, but consulted by the cleanup code we register now,','line_number':1091,'multiline':False]
['text':' so declare them here, initialized to quiescent values.','line_number':1092,'multiline':False]
['text':' Clean up all Debugger.Frame instances on exit. On suspending, pass the','line_number':1097,'multiline':False]
['text':' flag that says to leave those frames `.live`. Note that if the completion','line_number':1098,'multiline':False]
['text':' is a suspension but success is false, the generator gets closed, not','line_number':1099,'multiline':False]
['text':' suspended.','line_number':1100,'multiline':False]
['text':' The onPop handler and associated clean up logic should not run multiple','line_number':1108,'multiline':False]
['text':' times on the same frame. If slowPathOnLeaveFrame has already been','line_number':1109,'multiline':False]
['text':' called, the frame will not be present in the Debugger frame maps.','line_number':1110,'multiline':False]
['text':' Preserve the debuggee's microtask event queue while we run the hooks, so','line_number':1126,'multiline':False]
['text':' the debugger's microtask checkpoints don't run from the debuggee's','line_number':1127,'multiline':False]
['text':' microtasks, and vice versa.','line_number':1128,'multiline':False]
['text':' This path can be hit via unwinding the stack due to over-recursion or','line_number':1134,'multiline':False]
['text':' OOM. In those cases, don't fire the frames' onPop handlers, because','line_number':1135,'multiline':False]
['text':' invoking JS will only trigger the same condition. See','line_number':1136,'multiline':False]
['text':' slowPathOnExceptionUnwind.','line_number':1137,'multiline':False]
['text':' For each Debugger.Frame, fire its onPop handler, if any.','line_number':1143,'multiline':False]
['text':' Removing a global from a Debugger's debuggee set kills all of that','line_number':1149,'multiline':False]
['text':' Debugger's D.Fs in that global. This means that one D.F's onPop can','line_number':1150,'multiline':False]
['text':' kill the next D.F. So we have to check whether frameobj is still "on','line_number':1151,'multiline':False]
['text':' the stack".','line_number':1152,'multiline':False]
['text':' Call the onPop handler.','line_number':1160,'multiline':False]
['text':' Mark the generator as running, to prevent reentrance.','line_number':1163,'multiline':False]
['text':'','line_number':1164,'multiline':False]
['text':' At certain points in a generator's lifetime,','line_number':1165,'multiline':False]
['text':' GetGeneratorObjectForFrame can return null even when the','line_number':1166,'multiline':False]
['text':' generator exists, but at those points the generator has not yet','line_number':1167,'multiline':False]
['text':' been exposed to JavaScript, so reentrance isn't possible','line_number':1168,'multiline':False]
['text':' anyway. So there's no harm done if this has no effect in that','line_number':1169,'multiline':False]
['text':' case.','line_number':1170,'multiline':False]
['text':' At this point, we are back in the debuggee compartment, and','line_number':1186,'multiline':False]
['text':' any error has been wrapped up as a completion value.','line_number':1187,'multiline':False]
['text':' Now that we've run all the handlers, extract the final resumption mode. */','line_number':1196,'multiline':False]
['text':' If we are returning the original value used to create the completion, then','line_number':1203,'multiline':False]
['text':' we don't want to treat the resumption value as a Return completion, because','line_number':1204,'multiline':False]
['text':' that would cause us to apply AdjustGeneratorResumptionValue to the','line_number':1205,'multiline':False]
['text':' already-adjusted value that the generator actually returned.','line_number':1206,'multiline':False]
['text':' If this is an exception or termination, we just propagate that along.','line_number':1215,'multiline':False]
['text':' Since we are leaving the frame here, we can convert a forced return','line_number':1219,'multiline':False]
['text':' into a normal return right away.','line_number':1220,'multiline':False]
['text':' static ','line_number':1227,'multiline':True]
['text':' This is called from JSOp::Generator, after default parameter expressions','line_number':1230,'multiline':False]
['text':' are evaluated and well after onEnterFrame, so Debugger.Frame objects for','line_number':1231,'multiline':False]
['text':' `frame` may already have been exposed to debugger code. The','line_number':1232,'multiline':False]
['text':' AbstractGeneratorObject for this generator call, though, has just been','line_number':1233,'multiline':False]
['text':' created. It must be associated with any existing Debugger.Frames.','line_number':1234,'multiline':False]
['text':' Initializing frames with their associated generator is critical to the','line_number':1236,'multiline':False]
['text':' functionality of the debugger, so if there is an OOM, we want to','line_number':1237,'multiline':False]
['text':' cleanly terminate all of the frames.','line_number':1238,'multiline':False]
['text':' This leaves `genObj` and `frameObj` unassociated. It's OK','line_number':1254,'multiline':False]
['text':' because we won't pause again with this generator on the stack:','line_number':1255,'multiline':False]
['text':' the caller will immediately discard `genObj` and unwind `frame`.','line_number':1256,'multiline':False]
['text':' static ','line_number':1276,'multiline':True]
['text':' static ','line_number':1288,'multiline':True]
['text':' Invoking more JS on an over-recursed stack or after OOM is only going','line_number':1291,'multiline':False]
['text':' to result in more of the same error.','line_number':1292,'multiline':False]
['text':' The Debugger API mustn't muck with frames from self-hosted scripts.','line_number':1297,'multiline':False]
['text':' We save and restore the exception once up front to avoid having to do it','line_number':1314,'multiline':False]
['text':' for each 'onExceptionUnwind' hook that has been registered, and we also','line_number':1315,'multiline':False]
['text':' only do it if the debuggerList contains items in order to avoid extra work.','line_number':1316,'multiline':False]
['text':' TODO: Remove Remove this function when all properties/methods returning a','line_number':1338,'multiline':False]
['text':'/      DebuggerEnvironment have been given a C++ interface (bug 1271649).','line_number':1339,'multiline':False]
['text':' DebuggerEnv should only wrap a debug scope chain obtained (transitively)','line_number':1361,'multiline':False]
['text':' from GetDebugEnvironmentFor(Frame|Function).','line_number':1362,'multiline':False]
['text':' Create a new Debugger.Environment for env.','line_number':1369,'multiline':False]
['text':' We handle three sentinel values: missing arguments','line_number':1409,'multiline':False]
['text':' (JS_MISSING_ARGUMENTS), optimized out slots (JS_OPTIMIZED_OUT),','line_number':1410,'multiline':False]
['text':' and uninitialized bindings (JS_UNINITIALIZED_LEXICAL).','line_number':1411,'multiline':False]
['text':'','line_number':1412,'multiline':False]
['text':' Other magic values should not have escaped.','line_number':1413,'multiline':False]
['text':' Create a new Debugger.Object for obj.','line_number':1461,'multiline':False]
['text':'** Debuggee resumption values and debugger error handling ****************','line_number':1589,'multiline':True]
['text':' Only forced returns from a frame need to be validated because forced','line_number':1646,'multiline':False]
['text':' throw values behave just like debuggee `throw` statements. Since','line_number':1647,'multiline':False]
['text':' forced-return is all custom logic within SpiderMonkey itself, we need','line_number':1648,'multiline':False]
['text':' our own custom validation for it to conform with what is expected.','line_number':1649,'multiline':False]
['text':' This replicates the ECMA spec's behavior for [[Construct]] in derived','line_number':1654,'multiline':False]
['text':' class constructors (section 9.2.2 of ECMA262-2020), where returning a','line_number':1655,'multiline':False]
['text':' non-undefined primitive causes an exception tobe thrown.','line_number':1656,'multiline':False]
['text':' Check for forcing return from a generator before the initial yield. This','line_number':1684,'multiline':False]
['text':' is not supported because some engine-internal code assumes a call to a','line_number':1685,'multiline':False]
['text':' generator will return a GeneratorObject; see bug 1477084.','line_number':1686,'multiline':False]
['text':' Last-minute sanity adjustments to resumption.','line_number':1704,'multiline':False]
['text':'','line_number':1705,'multiline':False]
['text':' This is called last, as we leave the debugger. It must happen outside the','line_number':1706,'multiline':False]
['text':' control of the uncaughtExceptionHook, because this code assumes we won't','line_number':1707,'multiline':False]
['text':' change our minds and continue execution--we must not close the generator','line_number':1708,'multiline':False]
['text':' object unless we're really going to force-return.','line_number':1709,'multiline':False]
['text':' Async modules need to be handled separately, as they do not have a callee.','line_number':1720,'multiline':False]
['text':' frame.callee will throw if it is called on a moduleFrame.','line_number':1721,'multiline':False]
['text':' Treat `{return: <value>}` like a `return` statement. Simulate what the','line_number':1727,'multiline':False]
['text':' debuggee would do for an ordinary `return` statement, using a few bytecode','line_number':1728,'multiline':False]
['text':' instructions. It's simpler to do the work manually than to count on that','line_number':1729,'multiline':False]
['text':' bytecode sequence existing in the debuggee, somehow jump to it, and then','line_number':1730,'multiline':False]
['text':' avoid re-entering the debugger from it.','line_number':1731,'multiline':False]
['text':'','line_number':1732,'multiline':False]
['text':' Similarly treat `{throw: <value>}` like a `throw` statement.','line_number':1733,'multiline':False]
['text':'','line_number':1734,'multiline':False]
['text':' Note: Async modules use the same handling as async functions.','line_number':1735,'multiline':False]
['text':' Throw doesn't require any special processing for (async) generators.','line_number':1737,'multiline':False]
['text':' Forcing return from a (possibly async) generator.','line_number':1742,'multiline':False]
['text':' We already went through CheckResumptionValue, which would have replaced','line_number':1746,'multiline':False]
['text':' this invalid resumption value with an error if we were trying to force','line_number':1747,'multiline':False]
['text':' return before the initial yield.','line_number':1748,'multiline':False]
['text':' 1.  `return <value>` creates and returns a new object,','line_number':1751,'multiline':False]
['text':'     `{value: <value>, done: true}`.','line_number':1752,'multiline':False]
['text':'','line_number':1753,'multiline':False]
['text':' For non-async generators, the iterator result object is created in','line_number':1754,'multiline':False]
['text':' bytecode, so we have to simulate that here. For async generators, our','line_number':1755,'multiline':False]
['text':' C++ implementation of AsyncGeneratorResolve will do this. So don't do it','line_number':1756,'multiline':False]
['text':' twice:','line_number':1757,'multiline':False]
['text':' 2.  The generator must be closed.','line_number':1766,'multiline':False]
['text':' Async generators have additionally bookkeeping which must be adjusted','line_number':1769,'multiline':False]
['text':' when switching over to the closed state.','line_number':1770,'multiline':False]
['text':' Throw doesn't require any special processing for async functions when','line_number':1777,'multiline':False]
['text':' the internal generator object is already present.','line_number':1778,'multiline':False]
['text':' 1.  `return <value>` fulfills and returns the async function's promise.','line_number':1786,'multiline':False]
['text':' 2.  The generator must be closed.','line_number':1796,'multiline':False]
['text':' We're before entering the actual function code.','line_number':1799,'multiline':False]
['text':' 1.  `throw <value>` creates a promise rejected with the value *vp.','line_number':1801,'multiline':False]
['text':' 1.  `return <value>` creates a promise resolved with the value *vp.','line_number':1802,'multiline':False]
['text':' 2.  Return normally in both cases.','line_number':1811,'multiline':False]
['text':' Since debugger hooks accumulate into the same final value handle, we','line_number':1835,'multiline':False]
['text':' use that to throw if multiple hooks try to set a resumption value.','line_number':1836,'multiline':False]
['text':' Uncaught exceptions arise from Debugger code, and so we must already be in','line_number':1873,'multiline':False]
['text':' an NX section. This also establishes that we are already within the scope','line_number':1874,'multiline':False]
['text':' of an AutoDebuggerJobQueueInterruption object.','line_number':1875,'multiline':False]
['text':' Uncaught exceptions arise from Debugger code, and so we must already be','line_number':1900,'multiline':False]
['text':' in an NX section.','line_number':1901,'multiline':False]
['text':' We want to report the pending exception, but we want to let the','line_number':1905,'multiline':False]
['text':' embedding handle it however it wants to.  So pretend like we're','line_number':1906,'multiline':False]
['text':' starting a new script execution on our current compartment (which','line_number':1907,'multiline':False]
['text':' is the debugger compartment, so reported errors won't get','line_number':1908,'multiline':False]
['text':' reported to various onerror handlers in debuggees) and as part of','line_number':1909,'multiline':False]
['text':' that "execution" simply throw our exception so the embedding can','line_number':1910,'multiline':False]
['text':' deal.','line_number':1911,'multiline':False]
['text':' Clear the exception, because ReportErrorToGlobal will assert that','line_number':1914,'multiline':False]
['text':' we don't have one.','line_number':1915,'multiline':False]
['text':' And if not, or if PrepareScriptEnvironmentAndInvoke somehow left an','line_number':1920,'multiline':False]
['text':' exception on cx (which it totally shouldn't do), just give up.','line_number':1921,'multiline':False]
['text':'** Debuggee completion values ********************************************','line_number':1926,'multiline':True]
['text':' static ','line_number':1928,'multiline':True]
['text':' static ','line_number':1951,'multiline':True]
['text':' Only Wasm frames get a null pc.','line_number':1954,'multiline':False]
['text':' If this isn't a generator suspension, then that's already handled above.','line_number':1957,'multiline':False]
['text':' A generator is being suspended or returning.','line_number':1962,'multiline':False]
['text':' Since generators are never wasm, we can assume pc is not nullptr, and','line_number':1964,'multiline':False]
['text':' that analyzing bytecode is meaningful.','line_number':1965,'multiline':False]
['text':' If we're leaving successfully at a yield opcode, we're probably','line_number':1968,'multiline':False]
['text':' suspending; the `isClosed()` check detects a debugger forced return from','line_number':1969,'multiline':False]
['text':' an `onStep` handler, which looks almost the same.','line_number':1970,'multiline':False]
['text':'','line_number':1971,'multiline':False]
['text':' GetGeneratorObjectForFrame can return nullptr even when a generator','line_number':1972,'multiline':False]
['text':' object does exist, if the frame is paused between the Generator and','line_number':1973,'multiline':False]
['text':' SetAliasedVar opcodes. But by checking the opcode first we eliminate that','line_number':1974,'multiline':False]
['text':' possibility, so it's fine to call genObj->isClosed().','line_number':1975,'multiline':False]
['text':' Saved stacks are wrapped for direct consumption by debugger code.','line_number':2090,'multiline':False]
['text':' No change to how we'll resume.','line_number':2105,'multiline':False]
['text':' Since this is a new exception, the stack for the old one may not apply.','line_number':2109,'multiline':False]
['text':' If we extend resumption values to specify stacks, we could revisit','line_number':2110,'multiline':False]
['text':' this.','line_number':2111,'multiline':False]
['text':'** Firing debugger hooks *************************************************','line_number':2172,'multiline':True]
['text':' overwritten by successful Call','line_number':2202,'multiline':False]
['text':' Assert that the hook won't be able to re-enter the generator.','line_number':2259,'multiline':False]
['text':' bool (Debugger*) ','line_number':2353,'multiline':True]
['text':' bool (Debugger*) ','line_number':2354,'multiline':True]
['text':' static ','line_number':2355,'multiline':True]
['text':' init may fail due to OOM. This OOM is not handlable at the','line_number':2361,'multiline':False]
['text':' callsites of dispatchQuietHook in the engine.','line_number':2362,'multiline':False]
['text':' bool (Debugger*) ','line_number':2370,'multiline':True]
['text':' bool (Debugger*, ResumeMode&, MutableHandleValue vp) ','line_number':2370,'multiline':True]
['text':' static ','line_number':2371,'multiline':True]
['text':' Maximum length for source URLs that can be remembered.','line_number':2384,'multiline':False]
['text':' Maximum number of source URLs that can be remembered in a realm.','line_number':2387,'multiline':False]
['text':' Sources introduced dynamically are not remembered.','line_number':2393,'multiline':False]
['text':' The source URLs holder never escapes to script, so we can treat it as a','line_number':2422,'multiline':False]
['text':' newborn array for the purpose of adding elements.','line_number':2423,'multiline':False]
['text':' Remember the URLs associated with scripts in non-system realms,','line_number':2429,'multiline':False]
['text':' in case the debugger is attached later.','line_number':2430,'multiline':False]
['text':' static ','line_number':2465,'multiline':True]
['text':' true when iter.hasScript(), false when iter.isWasm()','line_number':2471,'multiline':False]
['text':' valid when isJS == true','line_number':2472,'multiline':False]
['text':' valid when isJS == false','line_number':2473,'multiline':False]
['text':' Build list of breakpoint handlers.','line_number':2491,'multiline':False]
['text':'','line_number':2492,'multiline':False]
['text':' This does not need to be rooted: since the JSScript/WasmInstance is on the','line_number':2493,'multiline':False]
['text':' stack, the Breakpoints will not be GC'd. However, they may be deleted, and','line_number':2494,'multiline':False]
['text':' we check for that case below.','line_number':2495,'multiline':False]
['text':' Preserve the debuggee's microtask event queue while we run the hooks, so','line_number':2507,'multiline':False]
['text':' the debugger's microtask checkpoints don't run from the debuggee's','line_number':2508,'multiline':False]
['text':' microtasks, and vice versa.','line_number':2509,'multiline':False]
['text':' Handlers can clear breakpoints. Check that bp still exists.','line_number':2516,'multiline':False]
['text':' There are two reasons we have to check whether dbg is debugging','line_number':2521,'multiline':False]
['text':' global.','line_number':2522,'multiline':False]
['text':'','line_number':2523,'multiline':False]
['text':' One is just that one breakpoint handler can disable other Debuggers','line_number':2524,'multiline':False]
['text':' or remove debuggees.','line_number':2525,'multiline':False]
['text':'','line_number':2526,'multiline':False]
['text':' The other has to do with non-compile-and-go scripts, which have no','line_number':2527,'multiline':False]
['text':' specific global--until they are executed. Only now do we know which','line_number':2528,'multiline':False]
['text':' global the script is running against.','line_number':2529,'multiline':False]
['text':' Re-wrap the breakpoint's handler for the Debugger's compartment.','line_number':2540,'multiline':False]
['text':' When the handler and the Debugger are in the same compartment (the','line_number':2541,'multiline':False]
['text':' usual case), this actually unwraps it, but there's no requirement','line_number':2542,'multiline':False]
['text':' that they be in the same compartment, so we can't be sure.','line_number':2543,'multiline':False]
['text':' Calling JS code invalidates site. Reload it.','line_number':2562,'multiline':False]
['text':' static ','line_number':2579,'multiline':True]
['text':' We may be stepping over a JSOp::Exception, that pushes the context's','line_number':2583,'multiline':False]
['text':' pending exception for a 'catch' clause to handle. Don't let the onStep','line_number':2584,'multiline':False]
['text':' handlers mess with that (other than by returning a resumption value).','line_number':2585,'multiline':False]
['text':' Build list of Debugger.Frame instances referring to this frame with','line_number':2588,'multiline':False]
['text':' onStep handlers.','line_number':2589,'multiline':False]
['text':' Validate the single-step count on this frame's script, to ensure that','line_number':2597,'multiline':False]
['text':' we're not receiving traps we didn't ask for. Even when frames is','line_number':2598,'multiline':False]
['text':' non-empty (and thus we know this trap was requested), do the check','line_number':2599,'multiline':False]
['text':' anyway, to make sure the count has the correct non-zero value.','line_number':2600,'multiline':False]
['text':'','line_number':2601,'multiline':False]
['text':' The converse --- ensuring that we do receive traps when we should --- can','line_number':2602,'multiline':False]
['text':' be done with unit tests.','line_number':2603,'multiline':False]
['text':' Also count hooks set on suspended generator frames.','line_number':2624,'multiline':False]
['text':' Live Debugger.Frames were already counted in dbg->frames loop.','line_number':2631,'multiline':False]
['text':' A closed generator no longer has a callee so it will not be able to','line_number':2636,'multiline':False]
['text':' compare with the trappingScript.','line_number':2637,'multiline':False]
['text':' If a frame isn't live, but it has an entry in generatorFrames,','line_number':2642,'multiline':False]
['text':' it had better be suspended.','line_number':2643,'multiline':False]
['text':' Preserve the debuggee's microtask event queue while we run the hooks, so','line_number':2664,'multiline':False]
['text':' the debugger's microtask checkpoints don't run from the debuggee's','line_number':2665,'multiline':False]
['text':' microtasks, and vice versa.','line_number':2666,'multiline':False]
['text':' Call onStep for frames that have the handler set.','line_number':2672,'multiline':False]
['text':' onNewGlobalObject is infallible, and thus is only allowed to return','line_number':2718,'multiline':False]
['text':' undefined as a resumption value. If it returns anything else, we throw.','line_number':2719,'multiline':False]
['text':' And if that happens, or if the hook itself throws, we invoke the','line_number':2720,'multiline':False]
['text':' uncaughtExceptionHook so that we never leave an exception pending on the','line_number':2721,'multiline':False]
['text':' cx. This allows JS_NewGlobalObject to avoid handling failures from','line_number':2722,'multiline':False]
['text':' debugger hooks.','line_number':2723,'multiline':False]
['text':' Make a copy of the runtime's onNewGlobalObjectWatchers before running the','line_number':2743,'multiline':False]
['text':' handlers. Since one Debugger's handler can disable another's, the list','line_number':2744,'multiline':False]
['text':' can be mutated while we're walking it.','line_number':2745,'multiline':False]
['text':' Preserve the debuggee's microtask event queue while we run the hooks, so','line_number':2759,'multiline':False]
['text':' the debugger's microtask checkpoints don't run from the debuggee's','line_number':2760,'multiline':False]
['text':' microtasks, and vice versa.','line_number':2761,'multiline':False]
['text':' Like other quiet hooks using dispatchQuietHook, this hook','line_number':2778,'multiline':False]
['text':' silently ignores all errors that propagate out of it and aren't','line_number':2779,'multiline':False]
['text':' already handled by the hook error reporting.','line_number':2780,'multiline':False]
['text':' static ','line_number':2789,'multiline':True]
['text':' static ','line_number':2806,'multiline':True]
['text':' The set of debuggers had better not change while we're iterating,','line_number':2818,'multiline':False]
['text':' such that the vector gets reallocated.','line_number':2819,'multiline':False]
['text':' Use unbarrieredGet() to prevent triggering read barrier while collecting,','line_number':2821,'multiline':False]
['text':' this is safe as long as dbgp does not escape.','line_number':2822,'multiline':False]
['text':' static ','line_number':2834,'multiline':True]
['text':' Root all the Debuggers while we're iterating over them;','line_number':2842,'multiline':False]
['text':' appendAllocationSite calls Compartment::wrap, and thus can GC.','line_number':2843,'multiline':False]
['text':'','line_number':2844,'multiline':False]
['text':' SpiderMonkey protocol is generally for the caller to prove that it has','line_number':2845,'multiline':False]
['text':' rooted the stuff it's asking you to operate on (i.e. by passing a','line_number':2846,'multiline':False]
['text':' Handle), but in this case, we're iterating over a global's list of','line_number':2847,'multiline':False]
['text':' Debuggers, and globals only hold their Debuggers weakly.','line_number':2848,'multiline':False]
['text':' The set of debuggers had better not change while we're iterating,','line_number':2857,'multiline':False]
['text':' such that the vector gets reallocated.','line_number':2858,'multiline':False]
['text':' Like onNewGlobalObject, the Promise hooks are infallible and the comments','line_number':2919,'multiline':False]
['text':' in |Debugger::fireNewGlobalObject| apply here as well.','line_number':2920,'multiline':False]
['text':' static ','line_number':2933,'multiline':True]
['text':' We should be in the right compartment, but for simplicity always enter','line_number':2939,'multiline':False]
['text':' the promise's realm below.','line_number':2940,'multiline':False]
['text':' static ','line_number':2953,'multiline':True]
['text':' static ','line_number':2959,'multiline':True]
['text':'** Debugger code invalidation for observing execution ********************','line_number':2965,'multiline':True]
['text':' AbstractFramePtr can't refer to non-remateralized Ion frames or','line_number':2987,'multiline':False]
['text':' non-debuggee wasm frames, so if iter refers to one such, we know we','line_number':2988,'multiline':False]
['text':' don't match.','line_number':2989,'multiline':False]
['text':' Given a particular AbstractFramePtr F that has become observable, this','line_number':2994,'multiline':False]
['text':' represents the stack frames that need to be bailed out or marked as','line_number':2995,'multiline':False]
['text':' debuggees, and the scripts that need to be recompiled, taking inlining into','line_number':2996,'multiline':False]
['text':' account.','line_number':2997,'multiline':False]
['text':' We never inline across realms, let alone across zones, so','line_number':3006,'multiline':False]
['text':' frames_'s script's zone is the only one of interest.','line_number':3007,'multiline':False]
['text':' Normally, *this represents exactly one script: the one frame_ is','line_number':3018,'multiline':False]
['text':' running.','line_number':3019,'multiline':False]
['text':'','line_number':3020,'multiline':False]
['text':' However, debug-mode OSR uses *this for both invalidating Ion frames,','line_number':3021,'multiline':False]
['text':' and recompiling the Baseline scripts that those Ion frames will bail','line_number':3022,'multiline':False]
['text':' out into. Suppose frame_ is an inline frame, executing a copy of its','line_number':3023,'multiline':False]
['text':' JSScript, S_inner, that has been inlined into the IonScript of some','line_number':3024,'multiline':False]
['text':' other JSScript, S_outer. We must match S_outer, to decide which Ion','line_number':3025,'multiline':False]
['text':' frame to invalidate; and we must match S_inner, to decide which','line_number':3026,'multiline':False]
['text':' Baseline script to recompile.','line_number':3027,'multiline':False]
['text':'','line_number':3028,'multiline':False]
['text':' Note that this does not, by design, invalidate *all* inliners of','line_number':3029,'multiline':False]
['text':' frame_.script(), as only frame_ is made observable, not','line_number':3030,'multiline':False]
['text':' frame_.script().','line_number':3031,'multiline':False]
['text':' AbstractFramePtr can't refer to non-remateralized Ion frames or','line_number':3045,'multiline':False]
['text':' non-debuggee wasm frames, so if iter refers to one such, we know we','line_number':3046,'multiline':False]
['text':' don't match.','line_number':3047,'multiline':False]
['text':'','line_number':3048,'multiline':False]
['text':' We never use this 'has' overload for frame invalidation, only for','line_number':3049,'multiline':False]
['text':' frame debuggee marking; so this overload doesn't need a parallel to','line_number':3050,'multiline':False]
['text':' the just-so inlining logic above.','line_number':3051,'multiline':False]
['text':' AbstractFramePtr can't refer to non-remateralized Ion frames, and','line_number':3071,'multiline':False]
['text':' while a non-rematerialized Ion frame may indeed be running script_,','line_number':3072,'multiline':False]
['text':' we cannot mark them as debuggees until they bail out.','line_number':3073,'multiline':False]
['text':'','line_number':3074,'multiline':False]
['text':' Upon bailing out, any newly constructed Baseline frames that came','line_number':3075,'multiline':False]
['text':' from Ion frames with scripts that are isDebuggee() is marked as','line_number':3076,'multiline':False]
['text':' debuggee. This is correct in that the only other way a frame may be','line_number':3077,'multiline':False]
['text':' marked as debuggee is via Debugger.Frame reflection, which would','line_number':3078,'multiline':False]
['text':' have rematerialized any Ion frames.','line_number':3079,'multiline':False]
['text':'','line_number':3080,'multiline':False]
['text':' Also AbstractFramePtr can't refer to non-debuggee wasm frames, so if','line_number':3081,'multiline':False]
['text':' iter refers to one such, we know we don't match.','line_number':3082,'multiline':False]
['text':' static ','line_number':3088,'multiline':True]
['text':' Debugger.Frame lifetimes are managed by the debug epilogue,','line_number':3115,'multiline':False]
['text':' so in general it's unsafe to unmark a frame if it has a','line_number':3116,'multiline':False]
['text':' Debugger.Frame associated with it.','line_number':3117,'multiline':False]
['text':' See comment in unsetPrevUpToDateUntil.','line_number':3125,'multiline':False]
['text':' Enter the script's realm as AddPendingInvalidation attempts to','line_number':3145,'multiline':False]
['text':' cancel off-thread compilations, whose books are kept on the','line_number':3146,'multiline':False]
['text':' script's realm.','line_number':3147,'multiline':False]
['text':' Iterate through observable scripts, invalidating their Ion scripts and','line_number':3165,'multiline':False]
['text':' appending them to a vector for discarding their baseline scripts later.','line_number':3166,'multiline':False]
['text':' Code below this point must be infallible to ensure the active bit of','line_number':3192,'multiline':False]
['text':' BaselineScripts is in a consistent state.','line_number':3193,'multiline':False]
['text':'','line_number':3194,'multiline':False]
['text':' Mark active baseline scripts in the observable set so that they don't','line_number':3195,'multiline':False]
['text':' get discarded. They will be recompiled.','line_number':3196,'multiline':False]
['text':' Iterate through the scripts again and finish discarding','line_number':3220,'multiline':False]
['text':' BaselineScripts. This must be done as a separate phase as we can only','line_number':3221,'multiline':False]
['text':' discard the BaselineScript on scripts that have no IonScript.','line_number':3222,'multiline':False]
['text':' Iterate through all wasm instances to find ones that need to be updated.','line_number':3231,'multiline':False]
['text':' static ','line_number':3246,'multiline':True]
['text':' static ','line_number':3267,'multiline':True]
['text':' static ','line_number':3278,'multiline':True]
['text':' static ','line_number':3303,'multiline':True]
['text':' static ','line_number':3315,'multiline':True]
['text':' Invalidate scripts first so we can set the needsArgsObj flag on scripts','line_number':3323,'multiline':False]
['text':' before patching frames.','line_number':3324,'multiline':False]
['text':' static ','line_number':3329,'multiline':True]
['text':' static ','line_number':3339,'multiline':True]
['text':' static ','line_number':3351,'multiline':True]
['text':' static ','line_number':3364,'multiline':True]
['text':' static ','line_number':3378,'multiline':True]
['text':' Toggle whether this Debugger's debuggees observe all execution. This is','line_number':3411,'multiline':False]
['text':' called when a hook that observes all execution is set or unset. See','line_number':3412,'multiline':False]
['text':' hookObservesAllExecution.','line_number':3413,'multiline':False]
['text':' It's expensive to eagerly invalidate and recompile a realm,','line_number':3427,'multiline':False]
['text':' so add the realm to the set only if we are observing.','line_number':3428,'multiline':False]
['text':' Invalidate and recompile a realm to add or remove PCCounts','line_number':3459,'multiline':False]
['text':' increments. We have to eagerly invalidate, as otherwise we might have','line_number':3460,'multiline':False]
['text':' dangling pointers to freed PCCounts.','line_number':3461,'multiline':False]
['text':' If any frame on the stack belongs to the debuggee, then we cannot update','line_number':3467,'multiline':False]
['text':' the ScriptCounts, because this would imply to invalidate a Debugger.Frame','line_number':3468,'multiline':False]
['text':' to recompile it with/without ScriptCount support.','line_number':3469,'multiline':False]
['text':' All realms can safely be toggled, and all scripts will be recompiled.','line_number':3482,'multiline':False]
['text':' Thus we can update each realm accordingly.','line_number':3483,'multiline':False]
['text':'** Allocations Tracking **************************************************','line_number':3506,'multiline':True]
['text':' static ','line_number':3508,'multiline':True]
['text':' static ','line_number':3514,'multiline':True]
['text':' Use unbarrieredGet() to prevent triggering read barrier while','line_number':3518,'multiline':False]
['text':' collecting, this is safe as long as dbg does not escape.','line_number':3519,'multiline':False]
['text':' static ','line_number':3529,'multiline':True]
['text':' Precondition: the given global object is being observed by at least one','line_number':3532,'multiline':False]
['text':' Debugger that is tracking allocations.','line_number':3533,'multiline':False]
['text':' static ','line_number':3548,'multiline':True]
['text':' If there are still Debuggers that are observing allocations, we cannot','line_number':3550,'multiline':False]
['text':' remove the metadata callback yet. Recompute the sampling probability','line_number':3551,'multiline':False]
['text':' based on the remaining debuggers' needs.','line_number':3552,'multiline':False]
['text':' Something like the Gecko Profiler could request from the the JS runtime','line_number':3559,'multiline':False]
['text':' to record allocations. If it is recording allocations, then do not','line_number':3560,'multiline':False]
['text':' destroy the allocation metadata builder at this time.','line_number':3561,'multiline':False]
['text':' We don't want to end up in a state where we added allocations','line_number':3569,'multiline':False]
['text':' tracking to some of our debuggees, but failed to do so for','line_number':3570,'multiline':False]
['text':' others. Before attempting to start tracking allocations in *any* of','line_number':3571,'multiline':False]
['text':' our debuggees, ensure that we will be able to track allocations for','line_number':3572,'multiline':False]
['text':' *all* of our debuggees.','line_number':3573,'multiline':False]
['text':' This should always succeed, since we already checked for the','line_number':3586,'multiline':False]
['text':' error case above.','line_number':3587,'multiline':False]
['text':'** Debugger JSObjects ****************************************************','line_number':3604,'multiline':True]
['text':'
 * Ordinarily, WeakMap keys and values are marked because at some point it was
 * discovered that the WeakMap was live; that is, some object containing the
 * WeakMap was marked during mark phase.
 *
 * However, during zone GC, we have to do something about cross-compartment
 * edges in non-GC'd compartments. Since the source may be live, we
 * conservatively assume it is and mark the edge.
 *
 * Each Debugger object keeps five cross-compartment WeakMaps: objects, scripts,
 * lazy scripts, script source objects, and environments. They have the property
 * that all their values are in the same compartment as the Debugger object,
 * but we have to mark the keys and the private pointer in the wrapper object.
 *
 * We must scan all Debugger objects regardless of whether they *currently* have
 * any debuggees in a compartment being GC'd, because the WeakMap entries
 * persist even when debuggees are removed.
 *
 * This happens during the initial mark phase, not iterative marking, because
 * all the edges being reported here are strong references.
 *
 * This method is also used during compacting GC to update cross compartment
 * pointers into zones that are being compacted.
 ','line_number':3622,'multiline':True]
['text':' static ','line_number':3646,'multiline':True]
['text':' static ','line_number':3672,'multiline':True]
['text':' The generatorFrames map is not keyed on the associated JSScript. Get','line_number':3685,'multiline':False]
['text':' the key from the source object and check everything matches.','line_number':3686,'multiline':False]
['text':' See comments in DebugAPI.h. ','line_number':3741,'multiline':True]
['text':' Note that we must loop over all Debuggers here, not just those known to be','line_number':3745,'multiline':False]
['text':' reachable from JavaScript. The existence of hooks set on a Debugger.Frame','line_number':3746,'multiline':False]
['text':' for a live stack frame makes the Debuger.Frame (and hence its Debugger)','line_number':3747,'multiline':False]
['text':' reachable.','line_number':3748,'multiline':False]
['text':' Callback tracers set their own traversal boundaries, but otherwise we're','line_number':3750,'multiline':False]
['text':' only interested in Debugger.Frames participating in the collection.','line_number':3751,'multiline':False]
['text':' Ignore generic tracers.','line_number':3771,'multiline':False]
['text':'','line_number':3772,'multiline':False]
['text':' There are two kinds of generic tracers we need to bar: MovingTracers used','line_number':3773,'multiline':False]
['text':' by compacting GC; and CompartmentCheckTracers.','line_number':3774,'multiline':False]
['text':'','line_number':3775,'multiline':False]
['text':' MovingTracers are used by the compacting GC to update pointers to objects','line_number':3776,'multiline':False]
['text':' that have been moved: the MovingTracer checks each outgoing pointer to see','line_number':3777,'multiline':False]
['text':' if it refers to a forwarding pointer, and if so, updates the pointer stored','line_number':3778,'multiline':False]
['text':' in the object.','line_number':3779,'multiline':False]
['text':'','line_number':3780,'multiline':False]
['text':' Generator objects are background finalized, so the compacting GC assumes it','line_number':3781,'multiline':False]
['text':' can update their pointers in the background as well. Since we treat','line_number':3782,'multiline':False]
['text':' generator objects as having an owning edge to their Debugger.Frame objects,','line_number':3783,'multiline':False]
['text':' a helper thread trying to update a generator object will end up calling','line_number':3784,'multiline':False]
['text':' this function. However, it is verboten to do weak map lookups (e.g., in','line_number':3785,'multiline':False]
['text':' Debugger::generatorFrames) off the main thread, since MovableCellHasher','line_number':3786,'multiline':False]
['text':' must consult the Zone to find the key's unique id.','line_number':3787,'multiline':False]
['text':'','line_number':3788,'multiline':False]
['text':' Fortunately, it's not necessary for compacting GC to worry about that edge','line_number':3789,'multiline':False]
['text':' in the first place: the edge isn't a literal pointer stored on the','line_number':3790,'multiline':False]
['text':' generator object, it's only inferred from the realm's debuggee status and','line_number':3791,'multiline':False]
['text':' its Debuggers' generatorFrames weak maps. Those get relocated when the','line_number':3792,'multiline':False]
['text':' Debugger itself is visited, so compacting GC can just ignore this edge.','line_number':3793,'multiline':False]
['text':'','line_number':3794,'multiline':False]
['text':' CompartmentCheckTracers walk the graph and verify that all','line_number':3795,'multiline':False]
['text':' cross-compartment edges are recorded in the cross-compartment wrapper','line_number':3796,'multiline':False]
['text':' tables. But edges between Debugger.Foo objects and their referents are not','line_number':3797,'multiline':False]
['text':' in the CCW tables, so a CrossCompartmentCheckTracers also calls','line_number':3798,'multiline':False]
['text':' DebugAPI::edgeIsInDebuggerWeakmap to see if a given cross-compartment edge','line_number':3799,'multiline':False]
['text':' is accounted for there. However, edgeIsInDebuggerWeakmap only handles','line_number':3800,'multiline':False]
['text':' debugger -> debuggee edges, so it won't recognize the edge we're','line_number':3801,'multiline':False]
['text':' potentially traversing here, from a generator object to its Debugger.Frame.','line_number':3802,'multiline':False]
['text':'','line_number':3803,'multiline':False]
['text':' But since the purpose of this function is to retrieve such edges, if they','line_number':3804,'multiline':False]
['text':' exist, from the very tables that edgeIsInDebuggerWeakmap would consult,','line_number':3805,'multiline':False]
['text':' we're at no risk of reporting edges that they do not cover. So we can','line_number':3806,'multiline':False]
['text':' safely hide the edges from CompartmentCheckTracers.','line_number':3807,'multiline':False]
['text':'','line_number':3808,'multiline':False]
['text':' We can't quite recognize MovingTracers and CompartmentCheckTracers','line_number':3809,'multiline':False]
['text':' precisely, but they're both generic tracers, so we just show them all the','line_number':3810,'multiline':False]
['text':' door. This means the generator -> Debugger.Frame edge is going to be','line_number':3811,'multiline':False]
['text':' invisible to some traversals. We'll cope with that when it's a problem.','line_number':3812,'multiline':False]
['text':' See comment above.','line_number':3824,'multiline':False]
['text':' static ','line_number':3832,'multiline':True]
['text':'
 * Trace all debugger-owned GC things unconditionally. This is used during
 * compacting GC and in minor GC: the minor GC cannot apply the weak constraints
 * of the full GC because it visits only part of the heap.
 ','line_number':3840,'multiline':True]
['text':' static ','line_number':3853,'multiline':True]
['text':' Mark Debugger.Frame objects. Since the Debugger is reachable, JS could call','line_number':3865,'multiline':False]
['text':' getNewestFrame and then walk the stack, so these are all reachable from JS.','line_number':3866,'multiline':False]
['text':'','line_number':3867,'multiline':False]
['text':' Note that if a Debugger.Frame has hooks set, it must be retained even if','line_number':3868,'multiline':False]
['text':' its Debugger is unreachable, since JS could observe that its hooks did not','line_number':3869,'multiline':False]
['text':' fire. That case is handled by DebugAPI::traceFrames.','line_number':3870,'multiline':False]
['text':'','line_number':3871,'multiline':False]
['text':' (We have weakly-referenced Debugger.Frame objects as well, for suspended','line_number':3872,'multiline':False]
['text':' generator frames; these are traced via generatorFrames just below.)','line_number':3873,'multiline':False]
['text':' static ','line_number':3885,'multiline':True]
['text':' static ','line_number':3892,'multiline':True]
['text':' Debugger.Frames for generator calls bump the JSScript's','line_number':3900,'multiline':False]
['text':' generatorObserverCount, so the JIT will instrument the code to notify','line_number':3901,'multiline':False]
['text':' Debugger when the generator is resumed. When a Debugger.Frame gets GC'd,','line_number':3902,'multiline':False]
['text':' generatorObserverCount needs to be decremented. It's much easier to do','line_number':3903,'multiline':False]
['text':' this when we know that all parties involved - the Debugger.Frame, the','line_number':3904,'multiline':False]
['text':' generator object, and the JSScript - have not yet been finalized.','line_number':3905,'multiline':False]
['text':'','line_number':3906,'multiline':False]
['text':' Since DebugAPI::sweepAll is called after everything is marked, but before','line_number':3907,'multiline':False]
['text':' anything has been finalized, this is the perfect place to drop the count.','line_number':3908,'multiline':False]
['text':' If the DebuggerFrame is being finalized, that means either:','line_number':3914,'multiline':False]
['text':'  1) It is not present in "frames".','line_number':3915,'multiline':False]
['text':'  2) The Debugger itself is also being finalized.','line_number':3916,'multiline':False]
['text':'','line_number':3917,'multiline':False]
['text':' In the first case, passing the frame is not necessary because there','line_number':3918,'multiline':False]
['text':' isn't a frame entry to clear, and in the second case,','line_number':3919,'multiline':False]
['text':' removeDebuggeeGlobal below will iterate and remove the entries','line_number':3920,'multiline':False]
['text':' anyway, so things will be cleaned up properly.','line_number':3921,'multiline':False]
['text':' Detach dying debuggers and debuggees from each other. Since this','line_number':3928,'multiline':False]
['text':' requires access to both objects it must be done before either','line_number':3929,'multiline':False]
['text':' object is finalized.','line_number':3930,'multiline':False]
['text':' Ensure two zones are swept in the same sweep group by adding an edge','line_number':3950,'multiline':False]
['text':' between them in each direction.','line_number':3951,'multiline':False]
['text':' static ','line_number':3955,'multiline':True]
['text':' Ensure that debuggers and their debuggees are finalized in the same group','line_number':3957,'multiline':False]
['text':' by adding edges in both directions for debuggee zones. These are weak','line_number':3958,'multiline':False]
['text':' references that are not in the cross compartment wrapper map.','line_number':3959,'multiline':False]
['text':' Add in edges for delegates, if relevant for the key type.','line_number':3997,'multiline':False]
['text':' addProperty','line_number':4002,'multiline':False]
['text':' delProperty','line_number':4003,'multiline':False]
['text':' enumerate','line_number':4004,'multiline':False]
['text':' newEnumerate','line_number':4005,'multiline':False]
['text':' resolve','line_number':4006,'multiline':False]
['text':' mayResolve','line_number':4007,'multiline':False]
['text':' finalize','line_number':4008,'multiline':False]
['text':' call','line_number':4009,'multiline':False]
['text':' hasInstance','line_number':4010,'multiline':False]
['text':' construct','line_number':4011,'multiline':False]
['text':' trace','line_number':4012,'multiline':False]
['text':' Forbid Debugger.prototype, which is of the Debugger JSClass but isn't','line_number':4034,'multiline':False]
['text':' really a Debugger object. The prototype object is distinguished by','line_number':4035,'multiline':False]
['text':' having a nullptr private value.','line_number':4036,'multiline':False]
['text':' static ','line_number':4103,'multiline':True]
['text':' static ','line_number':4116,'multiline':True]
['text':' static ','line_number':4124,'multiline':True]
['text':' static ','line_number':4162,'multiline':True]
['text':' static ','line_number':4168,'multiline':True]
['text':' We want to maintain the invariant that the hook is always set when the','line_number':4174,'multiline':False]
['text':' Debugger is in the runtime's list, and vice-versa, so if we return early','line_number':4175,'multiline':False]
['text':' and don't adjust the watcher list below, we need to be sure that the','line_number':4176,'multiline':False]
['text':' hook didn't change.','line_number':4177,'multiline':False]
['text':' Add or remove ourselves from the runtime's list of Debuggers that care','line_number':4182,'multiline':False]
['text':' about garbage collection.','line_number':4183,'multiline':False]
['text':' Add or remove ourselves from the runtime's list of Debuggers that care','line_number':4261,'multiline':False]
['text':' about new globals.','line_number':4262,'multiline':False]
['text':'
 * Given a value used to designate a global (there's quite a variety; see the
 * docs), return the actual designee.
 *
 * Note that this does not check whether the designee is marked "invisible to
 * Debugger" or not; different callers need to handle invisible-to-Debugger
 * globals in different ways.
 ','line_number':4352,'multiline':True]
['text':' If it's a Debugger.Object belonging to this debugger, dereference that.','line_number':4370,'multiline':False]
['text':' If we have a cross-compartment wrapper, dereference as far as is secure.','line_number':4379,'multiline':False]
['text':'','line_number':4380,'multiline':False]
['text':' Since we're dealing with globals, we may have a WindowProxy here.  So we','line_number':4381,'multiline':False]
['text':' have to make sure to do a dynamic unwrap, and we want to unwrap the','line_number':4382,'multiline':False]
['text':' WindowProxy too, if we have one.','line_number':4383,'multiline':False]
['text':' stopAtWindowProxy = ','line_number':4384,'multiline':True]
['text':' If that didn't produce a global object, it's an error.','line_number':4390,'multiline':False]
['text':' Only update the realm if there are no Debuggers left, as it's','line_number':4461,'multiline':False]
['text':' expensive to check if no other Debugger has a live script or frame','line_number':4462,'multiline':False]
['text':' hook on any of the current on-stack debuggee frames.','line_number':4463,'multiline':False]
['text':' See note about adding to the observable set in removeDebuggee.','line_number':4484,'multiline':False]
['text':' Obtain the list of debuggees before wrapping each debuggee, as a GC could','line_number':4511,'multiline':False]
['text':' update the debuggees set while we are iterating it.','line_number':4512,'multiline':False]
['text':' Since there may be multiple contexts, use AllFramesIter.','line_number':4545,'multiline':False]
['text':' Ensure that Ion frames are rematerialized. Only rematerialized','line_number':4548,'multiline':False]
['text':' Ion frames may be used as AbstractFramePtrs.','line_number':4549,'multiline':False]
['text':' static ','line_number':4579,'multiline':True]
['text':' Check that the arguments, if any, are cross-compartment wrappers.','line_number':4583,'multiline':False]
['text':' Get Debugger.prototype.','line_number':4596,'multiline':False]
['text':' Make the new Debugger object. Each one has a reference to','line_number':4605,'multiline':False]
['text':' Debugger.{Frame,Object,Script,Memory}.prototype in reserved slots. The','line_number':4606,'multiline':False]
['text':' rest of the reserved slots are for hooks; they default to undefined.','line_number':4607,'multiline':False]
['text':' Construct the underlying C++ object.','line_number':4628,'multiline':False]
['text':' The object owns the released pointer.','line_number':4634,'multiline':False]
['text':' Add the initial debuggees, if any.','line_number':4639,'multiline':False]
['text':' Callers should generally be unable to get a reference to a debugger-','line_number':4658,'multiline':False]
['text':' invisible global in order to pass it to addDebuggee. But this is possible','line_number':4659,'multiline':False]
['text':' with certain testing aides we expose in the shell, so just make addDebuggee','line_number':4660,'multiline':False]
['text':' throw in that case.','line_number':4661,'multiline':False]
['text':' Debugger and debuggee must be in different compartments.','line_number':4669,'multiline':False]
['text':' Check for cycles. If global's realm is reachable from this Debugger','line_number':4676,'multiline':False]
['text':' object's realm by following debuggee-to-debugger links, then adding','line_number':4677,'multiline':False]
['text':' global would create a cycle. (Typically nobody is debugging the','line_number':4678,'multiline':False]
['text':' debugger, in which case we zip through this code without looping.)','line_number':4679,'multiline':False]
['text':' Find all realms containing debuggers debugging realm's global object.','line_number':4691,'multiline':False]
['text':' Add those realms to visited.','line_number':4692,'multiline':False]
['text':' For global to become this js::Debugger's debuggee:','line_number':4705,'multiline':False]
['text':'','line_number':4706,'multiline':False]
['text':' 1. this js::Debugger must be in global->getDebuggers(),','line_number':4707,'multiline':False]
['text':' 2. global must be in this->debuggees,','line_number':4708,'multiline':False]
['text':' 3. the debuggee's zone must be in this->debuggeeZones,','line_number':4709,'multiline':False]
['text':' 4. if we are tracking allocations, the SavedStacksMetadataBuilder must be','line_number':4710,'multiline':False]
['text':'    installed for this realm, and','line_number':4711,'multiline':False]
['text':' 5. Realm::isDebuggee()'s bit must be set.','line_number':4712,'multiline':False]
['text':'','line_number':4713,'multiline':False]
['text':' All five indications must be kept consistent.','line_number':4714,'multiline':False]
['text':' (1)','line_number':4724,'multiline':False]
['text':' (2)','line_number':4732,'multiline':False]
['text':' (3)','line_number':4741,'multiline':False]
['text':' (4)','line_number':4752,'multiline':False]
['text':' (5)','line_number':4764,'multiline':False]
['text':' The caller might have found global by enumerating this->debuggees; if','line_number':4807,'multiline':False]
['text':' so, use HashSet::Enum::removeFront rather than HashSet::remove below,','line_number':4808,'multiline':False]
['text':' to avoid invalidating the live enumerator.','line_number':4809,'multiline':False]
['text':' Clear this global's generators from generatorFrames as well.','line_number':4814,'multiline':False]
['text':'','line_number':4815,'multiline':False]
['text':' This method can be called either from script (dbg.removeDebuggee) or during','line_number':4816,'multiline':False]
['text':' GC sweeping, because the Debugger, debuggee global, or both are being GC'd.','line_number':4817,'multiline':False]
['text':'','line_number':4818,'multiline':False]
['text':' When called from script, it's okay to iterate over generatorFrames and','line_number':4819,'multiline':False]
['text':' touch its keys and values (even when an incremental GC is in progress).','line_number':4820,'multiline':False]
['text':' When called from GC, it's not okay; the keys and values may be dying. But','line_number':4821,'multiline':False]
['text':' in that case, we can actually just skip the loop entirely! If the Debugger','line_number':4822,'multiline':False]
['text':' is going away, it doesn't care about the state of its generatorFrames','line_number':4823,'multiline':False]
['text':' table, and the Debugger.Frame finalizer will fix up the generator observer','line_number':4824,'multiline':False]
['text':' counts.','line_number':4825,'multiline':False]
['text':' The relation must be removed from up to three places:','line_number':4845,'multiline':False]
['text':' globalDebuggersVector and debuggees for sure, and possibly the','line_number':4846,'multiline':False]
['text':' compartment's debuggee set.','line_number':4847,'multiline':False]
['text':'','line_number':4848,'multiline':False]
['text':' The debuggee zone set is recomputed on demand. This avoids refcounting','line_number':4849,'multiline':False]
['text':' and in practice we have relatively few debuggees that tend to all be in','line_number':4850,'multiline':False]
['text':' the same zone. If after recomputing the debuggee zone set, this global's','line_number':4851,'multiline':False]
['text':' zone is not in the set, then we must remove ourselves from the zone's','line_number':4852,'multiline':False]
['text':' vector of observing debuggers.','line_number':4853,'multiline':False]
['text':' Remove all breakpoints for the debuggee.','line_number':4865,'multiline':False]
['text':' If we are tracking allocation sites, we need to remove the object','line_number':4876,'multiline':False]
['text':' metadata callback from this global's realm.','line_number':4877,'multiline':False]
['text':' The context in which we should do our work.','line_number':4899,'multiline':False]
['text':' The debugger for which we conduct queries.','line_number':4902,'multiline':False]
['text':' Require the set of realms to stay fixed while the query is alive.','line_number':4905,'multiline':False]
['text':' A script must be in one of these realms to match the query.','line_number':4910,'multiline':False]
['text':' Indicates whether OOM has occurred while matching.','line_number':4913,'multiline':False]
['text':' Arrange for this query to match only scripts that run in |global|.','line_number':4918,'multiline':False]
['text':' Arrange for this ScriptQuery to match all scripts running in debuggee','line_number':4928,'multiline':False]
['text':' globals.','line_number':4929,'multiline':False]
['text':' Build our realm set from the debugger's set of debuggee globals.','line_number':4932,'multiline':False]
['text':'
 * A class for parsing 'findScripts' query arguments and searching for
 * scripts that match the criteria they represent.
 ','line_number':4944,'multiline':True]
['text':' Construct a ScriptQuery to use matching scripts for |dbg|. ','line_number':4950,'multiline':True]
['text':'
   * Parse the query object |query|, and prepare to match only the scripts
   * it specifies.
   ','line_number':4960,'multiline':True]
['text':' Check for a 'global' property, which limits the results to those','line_number':4965,'multiline':False]
['text':' scripts scoped to a particular global object.','line_number':4966,'multiline':False]
['text':' If the given global isn't a debuggee, just leave the set of','line_number':4981,'multiline':False]
['text':' acceptable globals empty; we'll return no scripts.','line_number':4982,'multiline':False]
['text':' Check for a 'url' property.','line_number':4990,'multiline':False]
['text':' Check for a 'source' property','line_number':5001,'multiline':False]
['text':' The given source must have an owner. Otherwise, it's a','line_number':5019,'multiline':False]
['text':' Debugger.Source.prototype, which would match no scripts, and is','line_number':5020,'multiline':False]
['text':' probably a mistake.','line_number':5021,'multiline':False]
['text':' If it does have an owner, it should match the Debugger we're','line_number':5029,'multiline':False]
['text':' calling findScripts on. It would work fine even if it didn't,','line_number':5030,'multiline':False]
['text':' but mixing Debugger.Sources is probably a sign of confusion.','line_number':5031,'multiline':False]
['text':' Check for a 'displayURL' property.','line_number':5042,'multiline':False]
['text':' Check for a 'line' property.','line_number':5062,'multiline':False]
['text':' Check for an 'innermost' property.','line_number':5091,'multiline':False]
['text':' Technically, we need only check hasLine, but this is clearer.','line_number':5099,'multiline':False]
['text':' Set up this ScriptQuery appropriately for a missing query argument. ','line_number':5111,'multiline':True]
['text':'
   * Search all relevant realms and the stack for scripts matching
   * this query, and append the matching scripts to |scriptVector|.
   ','line_number':5120,'multiline':True]
['text':' Search each realm for debuggee scripts.','line_number':5134,'multiline':False]
['text':' If we are filtering by line number, the lazy BaseScripts were not checked','line_number':5144,'multiline':False]
['text':' yet since they do not implement `GetScriptLineExtent`. Instead we revisit','line_number':5145,'multiline':False]
['text':' each result script and delazify its children and add any matching ones to','line_number':5146,'multiline':False]
['text':' the results list.','line_number':5147,'multiline':False]
['text':' As a performance optimization, we can skip scripts that are definitely','line_number':5154,'multiline':False]
['text':' out-of-bounds for the target line. This was checked before adding to','line_number':5155,'multiline':False]
['text':' the partialMatchVector, but the bound may have improved since then.','line_number':5156,'multiline':False]
['text':' Ignore any delazification placeholder functions. These should not be','line_number':5166,'multiline':False]
['text':' exposed to debugger in any way.','line_number':5167,'multiline':False]
['text':' Delazify script.','line_number':5172,'multiline':False]
['text':' If target line isn't in script, we are done with it.','line_number':5178,'multiline':False]
['text':' Add script to results now that we've completed checks.','line_number':5183,'multiline':False]
['text':' If script was a leaf we are done with it. This is an optional','line_number':5188,'multiline':False]
['text':' optimization to avoid inspecting the `gcthings` list below.','line_number':5189,'multiline':False]
['text':' Now add inner scripts to `partialMatchVector` work list to determine if','line_number':5194,'multiline':False]
['text':' they are matches. Note that out IterateScripts callback ignored them','line_number':5195,'multiline':False]
['text':' already since they did not have a compiled parent at the time.','line_number':5196,'multiline':False]
['text':' If the function doesn't have script, ignore it.','line_number':5208,'multiline':False]
['text':' Add the matching inner script to the back of the results queue','line_number':5216,'multiline':False]
['text':' where it will be processed recursively.','line_number':5217,'multiline':False]
['text':' If this is an 'innermost' query, we want to filter the results again to','line_number':5224,'multiline':False]
['text':' only return the innermost script for each realm. To do this we build a','line_number':5225,'multiline':False]
['text':' hashmap to track innermost and then recreate the `scriptVector` with the','line_number':5226,'multiline':False]
['text':' results that remain in the hashmap.','line_number':5227,'multiline':False]
['text':' Visit each candidate script and find innermost in each realm.','line_number':5234,'multiline':False]
['text':' Is our newly found script deeper than the last one we found?','line_number':5239,'multiline':False]
['text':' This is the first matching script we've encountered for this','line_number':5246,'multiline':False]
['text':' realm, so it is thus the innermost such script.','line_number':5247,'multiline':False]
['text':' Reset the results vector.','line_number':5254,'multiline':False]
['text':' Re-add only the innermost scripts to the results.','line_number':5257,'multiline':False]
['text':' TODO: Until such time that wasm modules are real ES6 modules,','line_number':5266,'multiline':False]
['text':' unconditionally consider all wasm toplevel instance scripts.','line_number':5267,'multiline':False]
['text':' If this is a string, matching scripts have urls equal to it. ','line_number':5289,'multiline':True]
['text':' url as a C string. ','line_number':5292,'multiline':True]
['text':' If this is a string, matching scripts' sources have displayURLs equal to
   * it. ','line_number':5295,'multiline':True]
['text':'
   * If this is a source referent, matching scripts will have sources equal
   * to this instance. Ideally we'd use a Maybe here, but Maybe interacts
   * very badly with Rooted's LIFO invariant.
   ','line_number':5299,'multiline':True]
['text':' True if the query contained a 'line' property. ','line_number':5307,'multiline':True]
['text':' The line matching scripts must cover. ','line_number':5310,'multiline':True]
['text':' As a performance optimization (and to avoid delazifying as many scripts),','line_number':5313,'multiline':False]
['text':' we would like to know the source offset of the target line.','line_number':5314,'multiline':False]
['text':'','line_number':5315,'multiline':False]
['text':' Since we do not have a simple way to compute this precisely, we instead','line_number':5316,'multiline':False]
['text':' track a lower-bound of the offset value. As we collect SourceExtent','line_number':5317,'multiline':False]
['text':' examples with (line,column) <-> sourceStart mappings, we can improve the','line_number':5318,'multiline':False]
['text':' bound. The target line is within the range [sourceOffsetLowerBound, Inf).','line_number':5319,'multiline':False]
['text':'','line_number':5320,'multiline':False]
['text':' NOTE: Using a SourceExtent for updating the bound happens independently of','line_number':5321,'multiline':False]
['text':'       if the script matches the target line or not in the in the end.','line_number':5322,'multiline':False]
['text':' True if the query has an 'innermost' property whose value is true. ','line_number':5325,'multiline':True]
['text':'
   * Accumulate the scripts in an Rooted<BaseScriptVector> instead of creating
   * the JS array as we go, because we mustn't allocate JS objects or GC while
   * we use the CellIter.
   ','line_number':5328,'multiline':True]
['text':'
   * While in the CellIter we may find BaseScripts that need to be compiled
   * before the query can be fully checked. Since we cannot compile while under
   * CellIter we accumulate them here instead.
   *
   * This occurs when matching line numbers since `GetScriptLineExtent` cannot
   * be computed without bytecode existing.
   ','line_number':5335,'multiline':True]
['text':'
   * Like above, but for wasm modules.
   ','line_number':5345,'multiline':True]
['text':'
   * Given that parseQuery or omittedQuery has been called, prepare to match
   * scripts. Set urlCString and displayURLChars as appropriate.
   ','line_number':5350,'multiline':True]
['text':' Compute urlCString and displayURLChars, if a url or displayURL was','line_number':5355,'multiline':False]
['text':' given respectively.','line_number':5356,'multiline':False]
['text':' We trying to find the offset of (target-line, 0) so just ignore any','line_number':5368,'multiline':False]
['text':' extents on target line to keep things simple.','line_number':5369,'multiline':False]
['text':' The extent.sourceStart position is now definitely *before* the target','line_number':5375,'multiline':False]
['text':' line, so update sourceOffsetLowerBound if extent.sourceStart is a tighter','line_number':5376,'multiline':False]
['text':' bound.','line_number':5377,'multiline':False]
['text':' A partial match is a script that starts before the target line, but may or','line_number':5383,'multiline':False]
['text':' may not end before it. If we can prove the script definitely ends before','line_number':5384,'multiline':False]
['text':' the target line, we may return false here.','line_number':5385,'multiline':False]
['text':' Check that start of script is before or on target line.','line_number':5389,'multiline':False]
['text':' Use the implicit (line, column) <-> sourceStart mapping from the','line_number':5394,'multiline':False]
['text':' SourceExtent to update our bounds on possible matches. We call this','line_number':5395,'multiline':False]
['text':' without knowing if the script is a match or not.','line_number':5396,'multiline':False]
['text':' As an optional performance optimization, we rule out any script that ends','line_number':5399,'multiline':False]
['text':' before the lower-bound on where target line exists.','line_number':5400,'multiline':False]
['text':' True if any part of script source is on the target line.','line_number':5404,'multiline':False]
['text':'
   * If |script| matches this query, append it to |scriptVector|. Set |oom| if
   * an out of memory condition occurred.
   ','line_number':5455,'multiline':True]
['text':' Check if line is within script (or any of its inner scripts).','line_number':5481,'multiline':False]
['text':' GetScriptLineExtent is not available on lazy scripts so instead to','line_number':5486,'multiline':False]
['text':' the partial match list for be compiled and reprocessed later. We only','line_number':5487,'multiline':False]
['text':' add scripts that are ready for delazification and they may in turn','line_number':5488,'multiline':False]
['text':' process their inner functions.','line_number':5489,'multiline':False]
['text':' If innermost filter is required, we collect everything that matches the','line_number':5497,'multiline':False]
['text':' line number and filter at the end of `findScripts`.','line_number':5498,'multiline':False]
['text':'
   * If |instanceObject| matches this query, append it to |wasmInstanceVector|.
   * Set |oom| if an out of memory condition occurred.
   ','line_number':5507,'multiline':True]
['text':'
 * A class for searching sources for 'findSources'.
 ','line_number':5576,'multiline':True]
['text':' Search each realm for debuggee scripts.','line_number':5597,'multiline':False]
['text':' TODO: Until such time that wasm modules are real ES6 modules,','line_number':5606,'multiline':False]
['text':' unconditionally consider all wasm toplevel instance scripts.','line_number':5607,'multiline':False]
['text':'
 * A class for parsing 'findObjects' query arguments and searching for objects
 * that match the criteria they represent.
 ','line_number':5699,'multiline':True]
['text':' Construct an ObjectQuery to use matching scripts for |dbg|. ','line_number':5705,'multiline':True]
['text':' The vector that we are accumulating results in. ','line_number':5709,'multiline':True]
['text':' The set of debuggee compartments. ','line_number':5712,'multiline':True]
['text':'
   * Parse the query object |query|, and prepare to match only the objects it
   * specifies.
   ','line_number':5715,'multiline':True]
['text':' Check for the 'class' property','line_number':5720,'multiline':False]
['text':' Set up this ObjectQuery appropriately for a missing query argument. ','line_number':5749,'multiline':True]
['text':'
   * Traverse the heap to find all relevant objects and add them to the
   * provided vector.
   ','line_number':5752,'multiline':True]
['text':' We can't tolerate the GC moving things around while we're','line_number':5770,'multiline':False]
['text':' searching the heap. Check that nothing we do causes a GC.','line_number':5771,'multiline':False]
['text':'
   * |ubi::Node::BreadthFirst| interface.
   ','line_number':5788,'multiline':True]
['text':' Only follow edges within our set of debuggee compartments; we don't','line_number':5801,'multiline':False]
['text':' care about the heap's subgraphs outside of our debuggee compartments,','line_number':5802,'multiline':False]
['text':' so we abandon the referent. Either (1) there is not a path from this','line_number':5803,'multiline':False]
['text':' non-debuggee node back to a node in our debuggee compartments, and we','line_number':5804,'multiline':False]
['text':' don't need to follow edges to or from this node, or (2) there does','line_number':5805,'multiline':False]
['text':' exist some path from this non-debuggee node back to a node in our','line_number':5806,'multiline':False]
['text':' debuggee compartments. However, if that were true, then the incoming','line_number':5807,'multiline':False]
['text':' cross compartment edge back into a debuggee compartment is already','line_number':5808,'multiline':False]
['text':' listed as an edge in the RootList we started traversal with, and','line_number':5809,'multiline':False]
['text':' therefore we don't need to follow edges to or from this non-debuggee','line_number':5810,'multiline':False]
['text':' node.','line_number':5811,'multiline':False]
['text':' If the referent has an associated realm and it's not a debuggee','line_number':5818,'multiline':False]
['text':' realm, skip it. Don't abandonReferent() here like above: realms','line_number':5819,'multiline':False]
['text':' within a compartment can reference each other without going through','line_number':5820,'multiline':False]
['text':' cross-compartment wrappers.','line_number':5821,'multiline':False]
['text':' If the referent is an object and matches our query's restrictions,','line_number':5827,'multiline':False]
['text':' add it to the vector accumulating results. Skip objects that should','line_number':5828,'multiline':False]
['text':' never be exposed to JS, like EnvironmentObjects and internal','line_number':5829,'multiline':False]
['text':' functions.','line_number':5830,'multiline':False]
['text':' The context in which we should do our work. ','line_number':5849,'multiline':True]
['text':' The debugger for which we conduct queries. ','line_number':5852,'multiline':True]
['text':'
   * If this is non-null, matching objects will have a class whose name is
   * this property.
   ','line_number':5855,'multiline':True]
['text':' The className member, as a C string. ','line_number':5861,'multiline':True]
['text':'
   * Given that either omittedQuery or parseQuery has been called, prepare the
   * query for matching objects.
   ','line_number':5864,'multiline':True]
['text':' Accumulate the list of globals before wrapping them, because','line_number':5920,'multiline':False]
['text':' wrapping can GC and collect realms from under us, while iterating.','line_number':5921,'multiline':False]
['text':' We pulled |global| out of nowhere, so it's possible that it was','line_number':5945,'multiline':False]
['text':' marked gray by XPConnect. Since we're now exposing it to JS code,','line_number':5946,'multiline':False]
['text':' we need to mark it black.','line_number':5947,'multiline':False]
['text':' The value is an atom and doesn't need wrapping, but the holder may be','line_number':5987,'multiline':False]
['text':' in another zone and the atom must be marked when we create a','line_number':5988,'multiline':False]
['text':' reference in this zone.','line_number':5989,'multiline':False]
['text':' If we create a D.O referring to a global in an invisible realm,','line_number':6014,'multiline':False]
['text':' then from it we can reach function objects, scripts, environments, etc.,','line_number':6015,'multiline':False]
['text':' none of which we're ever supposed to see.','line_number':6016,'multiline':False]
['text':' foldConstants = ','line_number':6067,'multiline':True]
['text':' syntaxParser = ','line_number':6068,'multiline':True]
['text':' We ran into an error. If it was because we ran out of memory we report','line_number':6070,'multiline':False]
['text':' it in the usual way.','line_number':6071,'multiline':False]
['text':' If it was because we ran out of source, we return false so our caller','line_number':6076,'multiline':False]
['text':' knows to try to collect more [source].','line_number':6077,'multiline':False]
['text':' Skip frames not yet fully initialized during their prologue.','line_number':6379,'multiline':False]
['text':' Skip frame of wasm instances we cannot observe.','line_number':6387,'multiline':False]
['text':' Don't ever observe self-hosted scripts: the Debugger API can break','line_number':6397,'multiline':False]
['text':' self-hosted invariants.','line_number':6398,'multiline':False]
['text':' static ','line_number':6409,'multiline':True]
['text':' Rekey missingScopes to maintain Debugger.Environment identity and','line_number':6414,'multiline':False]
['text':' forward liveScopes to point to the new frame.','line_number':6415,'multiline':False]
['text':' If we hit an OOM anywhere in here, we need to make sure there aren't any','line_number':6418,'multiline':False]
['text':' Debugger.Frame objects left partially-initialized.','line_number':6419,'multiline':False]
['text':' Forward live Debugger.Frame objects.','line_number':6428,'multiline':False]
['text':' An OOM here means that all Debuggers' frame maps still contain','line_number':6431,'multiline':False]
['text':' entries for 'from' and no entries for 'to'. Since the 'from' frame','line_number':6432,'multiline':False]
['text':' will be gone, they are removed by terminateDebuggerFramesOnExit','line_number':6433,'multiline':False]
['text':' above.','line_number':6434,'multiline':False]
['text':' Update frame object's ScriptFrameIter::data pointer.','line_number':6442,'multiline':False]
['text':' Add the frame object with |to| as key.','line_number':6447,'multiline':False]
['text':' Remove the old frame entry after all fallible operations are completed','line_number':6453,'multiline':False]
['text':' so that an OOM will be able to clean up properly.','line_number':6454,'multiline':False]
['text':' All frames successfuly replaced, cancel the rollback.','line_number':6458,'multiline':False]
['text':' static ','line_number':6466,'multiline':True]
['text':' static ','line_number':6474,'multiline':True]
['text':' static ','line_number':6494,'multiline':True]
['text':' If this is an eval frame, then from the debugger's perspective the','line_number':6503,'multiline':False]
['text':' script is about to be destroyed. Remove any breakpoints in it.','line_number':6504,'multiline':False]
['text':' static ','line_number':6512,'multiline':True]
['text':' If we were not passed the frame, either we are destroying a frame early','line_number':6517,'multiline':False]
['text':' on before it was inserted into the "frames" list, or else we are','line_number':6518,'multiline':False]
['text':' terminating a frame from "generatorFrames" and the "frames" entries will','line_number':6519,'multiline':False]
['text':' be cleaned up later on with a second call to this function.','line_number':6520,'multiline':False]
['text':' static ','line_number':6561,'multiline':True]
['text':' static ','line_number':6569,'multiline':True]
['text':' When we return to a bailed-out Ion real frame, we must update all','line_number':6572,'multiline':False]
['text':' Debugger.Frames that refer to its inline frames. However, since we','line_number':6573,'multiline':False]
['text':' can't pop individual inline frames off the stack (we can only pop the','line_number':6574,'multiline':False]
['text':' real frame that contains them all, as a unit), we cannot assume that','line_number':6575,'multiline':False]
['text':' the frame we're dealing with is the top frame. Advance the iterator','line_number':6576,'multiline':False]
['text':' across any inlined frames younger than |to|, the baseline frame','line_number':6577,'multiline':False]
['text':' reconstructed during bailout from the Ion frame corresponding to','line_number':6578,'multiline':False]
['text':' |from|.','line_number':6579,'multiline':False]
['text':' static ','line_number':6587,'multiline':True]
['text':' Ion bailout can fail due to overrecursion. In such cases we cannot','line_number':6590,'multiline':False]
['text':' honor any further Debugger hooks on the frame, and need to ensure that','line_number':6591,'multiline':False]
['text':' its Debugger.Frame entry is cleaned up.','line_number':6592,'multiline':False]
['text':'** JS::dbg::Builder ******************************************************','line_number':6596,'multiline':True]
['text':' We can't use assertSameCompartment here, because that is always keyed to','line_number':6603,'multiline':False]
['text':' some JSContext's current compartment, whereas BuiltThings can be','line_number':6604,'multiline':False]
['text':' constructed and assigned to without respect to any particular context;','line_number':6605,'multiline':False]
['text':' the only constraint is that they should be in their debugger's compartment.','line_number':6606,'multiline':False]
['text':' We should have checked for false Objects before calling this.','line_number':6613,'multiline':False]
['text':' If the allocation failed, this will return a false Object, as the spec','line_number':6656,'multiline':False]
['text':' promises.','line_number':6657,'multiline':False]
['text':'** JS::dbg::AutoEntryMonitor *********************************************','line_number':6661,'multiline':True]
['text':'** Glue ******************************************************************','line_number':6670,'multiline':True]
['text':' We only care about debugger objects, so CheckedUnwrapStatic is OK. ','line_number':6751,'multiline':True]
['text':' Since we know we have a debugger object, CheckedUnwrapStatic is fine. ','line_number':6760,'multiline':True]
['text':' static ','line_number':6777,'multiline':True]
['text':' DEBUG','line_number':6810,'multiline':False]
['text':'** JS::dbg::GarbageCollectionEvent ***************************************','line_number':6812,'multiline':True]
['text':' static ','line_number':6817,'multiline':True]
['text':' There is only one GC reason for the whole cycle, but for legacy','line_number':6828,'multiline':False]
['text':' reasons this data is stored and replicated on each slice. Each','line_number':6829,'multiline':False]
['text':' slice used to have its own GCReason, but now they are all the','line_number':6830,'multiline':False]
['text':' same.','line_number':6831,'multiline':False]
['text':' We had better not GC (and potentially get a dangling Debugger','line_number':6930,'multiline':False]
['text':' pointer) while finding all Debuggers observing a debuggee that','line_number':6931,'multiline':False]
['text':' participated in this GC.','line_number':6932,'multiline':False]
['text':' namespace dbg','line_number':6960,'multiline':False]
['text':' namespace JS','line_number':6961,'multiline':False]
