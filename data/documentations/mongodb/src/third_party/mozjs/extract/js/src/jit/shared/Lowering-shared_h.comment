['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' This file declares the structures that are used for attaching LIR to a','line_number':10,'multiline':False]
['text':' MIRGraph.','line_number':11,'multiline':False]
['text':' Representation of the result of the shuffle analysis.  See','line_number':27,'multiline':False]
['text':' Lowering-shared.cpp for more.','line_number':28,'multiline':False]
['text':' Both inputs, in the original lhs-rhs order','line_number':32,'multiline':False]
['text':' Both inputs, but in rhs-lhs order','line_number':34,'multiline':False]
['text':' Only the lhs input','line_number':36,'multiline':False]
['text':' Only the rhs input','line_number':38,'multiline':False]
['text':' Single operands','line_number':44,'multiline':False]
['text':' Double operands','line_number':45,'multiline':False]
['text':' Abort errors are caught at end of visitInstruction. It is possible for','line_number':85,'multiline':False]
['text':' multiple errors to be detected before the end of visitInstruction. In','line_number':86,'multiline':False]
['text':' this case, we only report the first back to the MIRGenerator.','line_number':87,'multiline':False]
['text':' A backend can decide that an instruction should be emitted at its uses,','line_number':121,'multiline':False]
['text':' rather than at its definition. To communicate this, set the','line_number':122,'multiline':False]
['text':' instruction's virtual register set to 0. When using the instruction,','line_number':123,'multiline':False]
['text':' its virtual register is temporarily reassigned. To know to clear it','line_number':124,'multiline':False]
['text':' after constructing the use information, the worklist bit is temporarily','line_number':125,'multiline':False]
['text':' unset.','line_number':126,'multiline':False]
['text':'','line_number':127,'multiline':False]
['text':' The backend can use the worklist bit to determine whether or not a','line_number':128,'multiline':False]
['text':' definition should be created.','line_number':129,'multiline':False]
['text':' The lowest-level calls to use, those that do not wrap another call to','line_number':132,'multiline':False]
['text':' use(), must prefix grabbing virtual register IDs by these calls.','line_number':133,'multiline':False]
['text':' These all create a use of a virtual register, with an optional','line_number':138,'multiline':False]
['text':' allocation policy.','line_number':139,'multiline':False]
['text':'','line_number':140,'multiline':False]
['text':' Some of these use functions have atStart variants.','line_number':141,'multiline':False]
['text':' - non-atStart variants will tell the register allocator that the input','line_number':142,'multiline':False]
['text':' allocation must be different from any Temp or Definition also needed for','line_number':143,'multiline':False]
['text':' this LInstruction.','line_number':144,'multiline':False]
['text':' - atStart variants relax that restriction and allow the input to be in','line_number':145,'multiline':False]
['text':' the same register as any output Definition (but not Temps) used by the','line_number':146,'multiline':False]
['text':' LInstruction. Note that it doesn't *imply* this will actually happen,','line_number':147,'multiline':False]
['text':' but gives a hint to the register allocator that it can do it.','line_number':148,'multiline':False]
['text':'','line_number':149,'multiline':False]
['text':' TL;DR: Use non-atStart variants only if you need the input value after','line_number':150,'multiline':False]
['text':' writing to any definitions (excluding temps), during code generation of','line_number':151,'multiline':False]
['text':' this LInstruction. Otherwise, use atStart variants, which will lower','line_number':152,'multiline':False]
['text':' register pressure.','line_number':153,'multiline':False]
['text':'','line_number':154,'multiline':False]
['text':' There is an additional constraint.  Consider a MIR node with two','line_number':155,'multiline':False]
['text':' MDefinition* operands, op1 and op2.  If the node reuses the register of op1','line_number':156,'multiline':False]
['text':' for its output then op1 must be used as atStart.  Then, if op1 and op2','line_number':157,'multiline':False]
['text':' represent the same LIR node then op2 must be an atStart use too; otherwise','line_number':158,'multiline':False]
['text':' op2 must be a non-atStart use.  There is however not always a 1-1 mapping','line_number':159,'multiline':False]
['text':' from MDefinition* to LNode*, so to determine whether two MDefinition* map','line_number':160,'multiline':False]
['text':' to the same LNode*, ALWAYS go via the willHaveDifferentLIRNodes()','line_number':161,'multiline':False]
['text':' predicate.  Do not use pointer equality on the MIR nodes.','line_number':162,'multiline':False]
['text':'','line_number':163,'multiline':False]
['text':' Do not add other conditions when using willHaveDifferentLIRNodes().  The','line_number':164,'multiline':False]
['text':' predicate is the source of truth about whether to use atStart or not, no','line_number':165,'multiline':False]
['text':' other conditions may apply in contexts when it is appropriate to use it.','line_number':166,'multiline':False]
['text':' "Any" is architecture dependent, and will include registers and stack','line_number':179,'multiline':False]
['text':' slots on X86, and only registers on ARM.','line_number':180,'multiline':False]
['text':' "Storable" is architecture dependend, and will include registers and','line_number':184,'multiline':False]
['text':' constants on X86 and only registers on ARM.  This is a generic "things','line_number':185,'multiline':False]
['text':' we can expect to write into memory in 1 instruction".','line_number':186,'multiline':False]
['text':' These methods accept either an Int32 or IntPtr value. A constant is used if','line_number':197,'multiline':False]
['text':' the value fits in an int32.','line_number':198,'multiline':False]
['text':' Like useRegisterOrInt32Constant, but uses a constant only if','line_number':202,'multiline':False]
['text':' |int32val * Scalar::byteSize(type) + offsetAdjustment| doesn't overflow','line_number':203,'multiline':False]
['text':' int32.','line_number':204,'multiline':False]
['text':' Adds a box input to an instruction, setting operand |n| to the type and','line_number':216,'multiline':False]
['text':' |n+1| to the payload. Does not modify the operands, instead expecting a','line_number':217,'multiline':False]
['text':' policy to already be set.','line_number':218,'multiline':False]
['text':' Test whether mir1 and mir2 may give rise to different LIR nodes even if','line_number':222,'multiline':False]
['text':' mir1 == mir2; use it to guide the selection of the use directive for one of','line_number':223,'multiline':False]
['text':' the nodes in the context of a reused input.  See comments above about why','line_number':224,'multiline':False]
['text':' it's important to use this predicate and not pointer equality.','line_number':225,'multiline':False]
['text':'','line_number':226,'multiline':False]
['text':' This predicate may be called before or after the application of a use','line_number':227,'multiline':False]
['text':' directive to the first of the nodes, but it is meaningless to call it after','line_number':228,'multiline':False]
['text':' the application of a directive to the second node.','line_number':229,'multiline':False]
['text':' These create temporary register requests.','line_number':232,'multiline':False]
['text':' Note that the fixed register has a GENERAL type,','line_number':244,'multiline':False]
['text':' unless the arg is of FloatRegister type','line_number':245,'multiline':False]
['text':' Returns a box allocation for a Value-typed instruction.','line_number':293,'multiline':False]
['text':' Returns a box allocation. The use is either typed, a Value, or','line_number':298,'multiline':False]
['text':' a constant (if useConstant is true).','line_number':299,'multiline':False]
['text':' Returns an int64 allocation for an Int64-typed instruction.','line_number':306,'multiline':False]
['text':' useAtStart = ','line_number':323,'multiline':True]
['text':' useAtStart = ','line_number':326,'multiline':True]
['text':' useAtStart = ','line_number':329,'multiline':True]
['text':' Rather than defining a new virtual register, sets |ins| to have the same','line_number':332,'multiline':False]
['text':' virtual register as |as|.','line_number':333,'multiline':False]
['text':' If we run out of virtual registers, mark code generation as having','line_number':344,'multiline':False]
['text':' failed and return a dummy vreg. Include a + 1 here for NUNBOX32','line_number':345,'multiline':False]
['text':' platforms that expect Value vregs to be adjacent.','line_number':346,'multiline':False]
['text':' One register containing the payload.','line_number':368,'multiline':False]
['text':' Two registers: one for the type, one for the payload.','line_number':373,'multiline':False]
['text':' One register containing the full Value.','line_number':376,'multiline':False]
['text':' Marks this instruction as fallible, meaning that before it performs','line_number':391,'multiline':False]
['text':' effects (if any), it may check pre-conditions and bailout if they do not','line_number':392,'multiline':False]
['text':' hold. This function informs the register allocator that it will need to','line_number':393,'multiline':False]
['text':' capture appropriate state.','line_number':394,'multiline':False]
['text':' Marks this instruction as needing to call into either the VM or GC. This','line_number':397,'multiline':False]
['text':' function may build a snapshot that captures the result of its own','line_number':398,'multiline':False]
['text':' instruction, and as such, should generally be called after define*().','line_number':399,'multiline':False]
['text':' Marks this instruction as needing a wasm safepoint.','line_number':403,'multiline':False]
['text':' Whether to generate typed reads for element accesses with hole checks.','line_number':419,'multiline':False]
['text':' namespace jit','line_number':423,'multiline':False]
['text':' namespace js','line_number':424,'multiline':False]
['text':' jit_shared_Lowering_shared_h ','line_number':426,'multiline':True]
