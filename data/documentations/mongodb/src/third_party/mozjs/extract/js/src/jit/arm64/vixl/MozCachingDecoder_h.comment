['text':' This enumeration list the different kind of instructions which can be','line_number':16,'multiline':False]
['text':' decoded. These kind correspond to the set of visitor defined by the default','line_number':17,'multiline':False]
['text':' Decoder.','line_number':18,'multiline':False]
['text':' A SinglePageDecodeCache is used to store the decoded kind of all instructions','line_number':26,'multiline':False]
['text':' in an executable page of code. Each time an instruction is decoded, its','line_number':27,'multiline':False]
['text':' decoded kind is recorded in this structure. The previous instruction value is','line_number':28,'multiline':False]
['text':' also recorded in this structure when using a debug build.','line_number':29,'multiline':False]
['text':'','line_number':30,'multiline':False]
['text':' The next time the same offset is visited, the instruction would be decoded','line_number':31,'multiline':False]
['text':' using the previously recorded decode kind. It is also compared against the','line_number':32,'multiline':False]
['text':' previously recorded bits of the instruction to check for potential missing','line_number':33,'multiline':False]
['text':' cache invalidations, in debug builds.','line_number':34,'multiline':False]
['text':'','line_number':35,'multiline':False]
['text':' This structure stores the equivalent of a single page of code to have better','line_number':36,'multiline':False]
['text':' memory locality when using the simulator. As opposed to having a hash-table','line_number':37,'multiline':False]
['text':' for all instructions. However a hash-table is used by the CachingDecoder to','line_number':38,'multiline':False]
['text':' map the prefixes of page addresses to these SinglePageDecodeCaches.','line_number':39,'multiline':False]
['text':' Compute the start address of the page which contains this instruction.','line_number':53,'multiline':False]
['text':' Returns whether the instruction decoded kind is stored in this','line_number':57,'multiline':False]
['text':' SinglePageDecodeCache.','line_number':58,'multiline':False]
['text':' Record the address at which the corresponding code page starts.','line_number':82,'multiline':False]
['text':' Cache what instruction got decoded previously, in order to assert if we see','line_number':85,'multiline':False]
['text':' any stale instructions after.','line_number':86,'multiline':False]
['text':' Cache the decoding of the instruction such that we can skip the decoding','line_number':89,'multiline':False]
['text':' part.','line_number':90,'multiline':False]
['text':' A DecoderVisitor which will record which visitor function should be called','line_number':94,'multiline':False]
['text':' the next time we want to decode the same instruction.','line_number':95,'multiline':False]
['text':' The Caching decoder works by extending the default vixl Decoder class. It','line_number':120,'multiline':False]
['text':' extends it by overloading the Decode function.','line_number':121,'multiline':False]
['text':'','line_number':122,'multiline':False]
['text':' The overloaded Decode function checks whether the instruction given as','line_number':123,'multiline':False]
['text':' argument got decoded before or since it got invalidated. If it was not','line_number':124,'multiline':False]
['text':' previously decoded, the value of the instruction is recorded as well as the','line_number':125,'multiline':False]
['text':' kind of instruction. Otherwise, the value of the instruction is checked','line_number':126,'multiline':False]
['text':' against the previously recorded value and the instruction kind is used to','line_number':127,'multiline':False]
['text':' skip the decoding visitor and resume the execution of instruction.','line_number':128,'multiline':False]
['text':'','line_number':129,'multiline':False]
['text':' The caching decoder stores the equivalent of a page of executable code in a','line_number':130,'multiline':False]
['text':' hash-table. Each SinglePageDecodeCache stores an array of decoded kind as','line_number':131,'multiline':False]
['text':' well as the value of the previously decoded instruction.','line_number':132,'multiline':False]
['text':'','line_number':133,'multiline':False]
['text':' When testing if an instruction was decoded before, we check if the address of','line_number':134,'multiline':False]
['text':' the instruction is contained in the last SinglePageDecodeCache. If it is not,','line_number':135,'multiline':False]
['text':' then the hash-table entry is queried and created if necessary, and the last','line_number':136,'multiline':False]
['text':' SinglePageDecodeCache is updated. Then, the last SinglePageDecodeCache','line_number':137,'multiline':False]
['text':' necessary contains the decoded kind of the instruction given as argument.','line_number':138,'multiline':False]
['text':'','line_number':139,'multiline':False]
['text':' The caching decoder add an extra function for flushing the cache, which is in','line_number':140,'multiline':False]
['text':' charge of clearing the decoded kind of instruction in the range of addresses','line_number':141,'multiline':False]
['text':' given as argument. This is indirectly called by','line_number':142,'multiline':False]
['text':' CPU::EnsureIAndDCacheCoherency.','line_number':143,'multiline':False]
['text':' Record the type of the decoded instruction, to avoid decoding it a second','line_number':164,'multiline':False]
['text':' time the next time we execute it.','line_number':165,'multiline':False]
['text':' Store the mapping of Instruction pointer to the corresponding','line_number':168,'multiline':False]
['text':' SinglePageDecodeCache.','line_number':169,'multiline':False]
['text':' Record the last SinglePageDecodeCache seen, such that we can quickly access','line_number':172,'multiline':False]
['text':' it for the next instruction.','line_number':173,'multiline':False]
['text':' !JS_CACHE_SIMULATOR_ARM64','line_number':178,'multiline':False]
['text':' !VIXL_A64_MOZ_CACHING_DECODER_A64_H_','line_number':179,'multiline':False]
