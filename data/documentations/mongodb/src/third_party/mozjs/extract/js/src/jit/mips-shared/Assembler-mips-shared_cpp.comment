['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' Encode a standard register when it is being used as rd, the rs, and','line_number':21,'multiline':False]
['text':' an extra register(rt). These should never be called with an InvalidReg.','line_number':22,'multiline':False]
['text':' This buffer uses fixed-size chunks so there's no point in reserving','line_number':81,'multiline':False]
['text':' now vs. on-demand.','line_number':82,'multiline':False]
['text':' For now, specialize to the one use case. As long as wasm::Bytes is a','line_number':87,'multiline':False]
['text':' Vector, not a linked-list of chunks, there's not much we can do other','line_number':88,'multiline':False]
['text':' than copy.','line_number':89,'multiline':False]
['text':' Size of the instruction stream, in bytes.','line_number':193,'multiline':False]
['text':' Size of the relocation table, in bytes.','line_number':196,'multiline':False]
['text':' Size of the data table, in bytes.','line_number':205,'multiline':False]
['text':' write a blob of binary into the instruction stream','line_number':210,'multiline':False]
['text':' TODO: Implement a proper halting align.','line_number':226,'multiline':False]
['text':' Logical operations.','line_number':257,'multiline':False]
['text':' Branch and jump instructions','line_number':305,'multiline':False]
['text':' Arithmetic instructions','line_number':404,'multiline':False]
['text':' Shift instructions','line_number':593,'multiline':False]
['text':' Load and store instructions','line_number':735,'multiline':False]
['text':' Move from HI/LO register.','line_number':962,'multiline':False]
['text':' Set on less than.','line_number':973,'multiline':False]
['text':' Conditional move.','line_number':999,'multiline':False]
['text':' Bit twiddling.','line_number':1028,'multiline':False]
['text':' Sign extend','line_number':1118,'multiline':False]
['text':' FP instructions','line_number':1165,'multiline':False]
['text':' FP convert instructions','line_number':1344,'multiline':False]
['text':' FP arithmetic instructions','line_number':1459,'multiline':False]
['text':' FP compare instructions','line_number':1538,'multiline':False]
['text':' FP conditional move.','line_number':1744,'multiline':False]
['text':' If our caller didn't give us an explicit target to bind to','line_number':1859,'multiline':False]
['text':' then we want to bind to the location of the next instruction','line_number':1860,'multiline':False]
['text':' A used label holds a link to branch that uses it.','line_number':1865,'multiline':False]
['text':' Even a 0 offset may be invalid if we're out of memory.','line_number':1868,'multiline':False]
['text':' Second word holds a pointer to the next branch in label's chain.','line_number':1875,'multiline':False]
['text':' The target is not bound but used. Prepend label's branch list','line_number':1891,'multiline':False]
['text':' onto target's.','line_number':1892,'multiline':False]
['text':' Find the head of the use chain for label.','line_number':1896,'multiline':False]
['text':' Second word holds a pointer to the next branch in chain.','line_number':1900,'multiline':False]
['text':' Then patch the head of label's use chain to the tail of','line_number':1905,'multiline':False]
['text':' target's use chain, prepending the entire use chain of target.','line_number':1906,'multiline':False]
['text':' The target is unbound and unused.  We can just take the head of','line_number':1912,'multiline':False]
['text':' the list hanging off of label, and dump that into target.','line_number':1913,'multiline':False]
['text':' This just stomps over memory with 32 bits of raw data. Its purpose is to','line_number':1933,'multiline':False]
['text':' overwrite the call of JITed code with 32 bits worth of an offset. This will','line_number':1934,'multiline':False]
['text':' is only meant to function on code that has been invalidated, so it should','line_number':1935,'multiline':False]
['text':' be totally safe. Since that instruction will never be executed again, a','line_number':1936,'multiline':False]
['text':' ICache flush should not be necessary','line_number':1937,'multiline':False]
['text':' Raw is going to be the return address.','line_number':1939,'multiline':False]
['text':' Overwrite the 4 bytes before the return address, which will','line_number':1941,'multiline':False]
['text':' end up being the call instruction.','line_number':1942,'multiline':False]
['text':' Since there are no pools in MIPS implementation, this should be simple.','line_number':1954,'multiline':False]
['text':' We converted beq to andi, so now we restore it.','line_number':2012,'multiline':False]
['text':' toggledJump is allways used for short jumps.','line_number':2019,'multiline':False]
['text':' Replace "beq $zero, $zero, offset" with "andi $zero, $zero, offset"','line_number':2021,'multiline':False]
