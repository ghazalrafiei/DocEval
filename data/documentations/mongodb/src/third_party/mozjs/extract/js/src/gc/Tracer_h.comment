['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' namespace JS','line_number':18,'multiline':False]
['text':' Internal Tracing API','line_number':22,'multiline':False]
['text':'','line_number':23,'multiline':False]
['text':' Tracing is an abstract visitation of each edge in a JS heap graph.[1] The','line_number':24,'multiline':False]
['text':' most common (and performance sensitive) use of this infrastructure is for GC','line_number':25,'multiline':False]
['text':' "marking" as part of the mark-and-sweep collector; however, this','line_number':26,'multiline':False]
['text':' infrastructure is much more general than that and is used for many other','line_number':27,'multiline':False]
['text':' purposes as well.','line_number':28,'multiline':False]
['text':'','line_number':29,'multiline':False]
['text':' One commonly misunderstood subtlety of the tracing architecture is the role','line_number':30,'multiline':False]
['text':' of graph vertices versus graph edges. Graph vertices are the heap','line_number':31,'multiline':False]
['text':' allocations -- GC things -- that are returned by Allocate. Graph edges are','line_number':32,'multiline':False]
['text':' pointers -- including tagged pointers like Value and jsid -- that link the','line_number':33,'multiline':False]
['text':' allocations into a complex heap. The tracing API deals *only* with edges.','line_number':34,'multiline':False]
['text':' Any action taken on the target of a graph edge is independent of the tracing','line_number':35,'multiline':False]
['text':' itself.','line_number':36,'multiline':False]
['text':'','line_number':37,'multiline':False]
['text':' Another common misunderstanding relates to the role of the JSTracer. The','line_number':38,'multiline':False]
['text':' JSTracer instance determines what tracing does when visiting an edge; it','line_number':39,'multiline':False]
['text':' does not itself participate in the tracing process, other than to be passed','line_number':40,'multiline':False]
['text':' through as opaque data. It works like a closure in that respect.','line_number':41,'multiline':False]
['text':'','line_number':42,'multiline':False]
['text':' Tracing implementations internal to SpiderMonkey should use these interfaces','line_number':43,'multiline':False]
['text':' instead of the public interfaces in js/TracingAPI.h. Unlike the public','line_number':44,'multiline':False]
['text':' tracing methods, these work on internal types and avoid an external call.','line_number':45,'multiline':False]
['text':'','line_number':46,'multiline':False]
['text':' Note that the implementations for these methods are, surprisingly, in','line_number':47,'multiline':False]
['text':' js/src/gc/Marking.cpp. This is so that the compiler can inline as much as','line_number':48,'multiline':False]
['text':' possible in the common, marking pathways. Conceptually, however, they remain','line_number':49,'multiline':False]
['text':' as part of the generic "tracing" architecture, rather than the more specific','line_number':50,'multiline':False]
['text':' marking implementation of tracing.','line_number':51,'multiline':False]
['text':'','line_number':52,'multiline':False]
['text':' 1 - In SpiderMonkey, we call this concept tracing rather than visiting','line_number':53,'multiline':False]
['text':'     because "visiting" is already used by the compiler. Also, it's been','line_number':54,'multiline':False]
['text':'     called "tracing" forever and changing it would be extremely difficult at','line_number':55,'multiline':False]
['text':'     this point.','line_number':56,'multiline':False]
['text':' Our barrier templates are parameterized on the pointer types so that we can','line_number':60,'multiline':False]
['text':' share the definitions with Value and jsid. Thus, we need to strip the','line_number':61,'multiline':False]
['text':' pointer before sending the type to BaseGCType and re-add it on the other','line_number':62,'multiline':False]
['text':' side. As such:','line_number':63,'multiline':False]
['text':' Cast a possibly-derived T** pointer to a base class pointer.','line_number':73,'multiline':False]
['text':' Internal methods to trace edges.','line_number':79,'multiline':False]
['text':' namespace gc','line_number':94,'multiline':False]
['text':' Trace through a strong edge in the live object graph on behalf of','line_number':96,'multiline':False]
['text':' tracing. The effect of tracing the edge depends on the JSTracer being','line_number':97,'multiline':False]
['text':' used. For pointer types, |*thingp| must not be null.','line_number':98,'multiline':False]
['text':'','line_number':99,'multiline':False]
['text':' Note that weak edges are handled separately. GC things with weak edges must','line_number':100,'multiline':False]
['text':' not trace those edges during marking tracing (which would keep the referent','line_number':101,'multiline':False]
['text':' alive) but instead arrange for the edge to be swept by calling','line_number':102,'multiline':False]
['text':' js::gc::IsAboutToBeFinalized or TraceWeakEdge during sweeping.','line_number':103,'multiline':False]
['text':'','line_number':104,'multiline':False]
['text':' GC things that are weakly held in containers can use WeakMap or a container','line_number':105,'multiline':False]
['text':' wrapped in the WeakCache<> template to perform the appropriate sweeping.','line_number':106,'multiline':False]
['text':' Trace through a possibly-null edge in the live object graph on behalf of','line_number':143,'multiline':False]
['text':' tracing.','line_number':144,'multiline':False]
['text':' Trace through a "root" edge. These edges are the initial edges in the object','line_number':175,'multiline':False]
['text':' graph traversal. Root edges are asserted to only be traversed in the initial','line_number':176,'multiline':False]
['text':' phase of a GC.','line_number':177,'multiline':False]
['text':' Idential to TraceRoot, except that this variant will not crash if |*thingp|','line_number':191,'multiline':False]
['text':' is null.','line_number':192,'multiline':False]
['text':' Like TraceEdge, but for edges that do not use one of the automatic barrier','line_number':208,'multiline':False]
['text':' classes and, thus, must be treated specially for moving GC. This method is','line_number':209,'multiline':False]
['text':' separate from TraceEdge to make accidental use of such edges more obvious.','line_number':210,'multiline':False]
['text':' Trace through a weak edge. If *thingp is not marked at the end of marking,','line_number':218,'multiline':False]
['text':' it is replaced by nullptr, and this method will return false to indicate that','line_number':219,'multiline':False]
['text':' the edge no longer exists.','line_number':220,'multiline':False]
['text':' Trace all edges contained in the given array.','line_number':234,'multiline':False]
['text':' Trace all root edges in the given array.','line_number':243,'multiline':False]
['text':' As below but with manual barriers.','line_number':251,'multiline':False]
['text':' Trace an edge that crosses compartment boundaries. If the compartment of the','line_number':256,'multiline':False]
['text':' destination thing is not being GC'd, then the edge will not be traced.','line_number':257,'multiline':False]
['text':' Trace an edge that's guaranteed to be same-zone but may cross a compartment','line_number':265,'multiline':False]
['text':' boundary. This should NOT be used for object => object edges, as those have','line_number':266,'multiline':False]
['text':' to be in the cross-compartment wrapper map.','line_number':267,'multiline':False]
['text':'','line_number':268,'multiline':False]
['text':' WARNING: because this turns off certain compartment checks, you most likely','line_number':269,'multiline':False]
['text':' don't want to use this! If you still think you need this function, talk to a','line_number':270,'multiline':False]
['text':' GC peer first.','line_number':271,'multiline':False]
['text':' Trace a weak map key. For debugger weak maps these may be cross compartment,','line_number':277,'multiline':False]
['text':' but the compartment must always be within the current sweep group.','line_number':278,'multiline':False]
['text':' Permanent atoms and well-known symbols are shared between runtimes and must','line_number':291,'multiline':False]
['text':' use a separate marking path so that we can filter them out of normal heap','line_number':292,'multiline':False]
['text':' tracing.','line_number':293,'multiline':False]
['text':' Trace a root edge that uses the base GC thing type, instead of a more','line_number':297,'multiline':False]
['text':' specific type.','line_number':298,'multiline':False]
['text':' Trace a non-root edge that uses the base GC thing type, instead of a more','line_number':302,'multiline':False]
['text':' specific type.','line_number':303,'multiline':False]
['text':' Trace through a shape or group iteratively during cycle collection to avoid','line_number':311,'multiline':False]
['text':' deep or infinite recursion.','line_number':312,'multiline':False]
['text':'*
 * Trace every value within |compartments| that is wrapped by a
 * cross-compartment wrapper from a compartment that is not an element of
 * |compartments|.
 ','line_number':315,'multiline':True]
['text':' Get information about a GC thing. Used when dumping the heap. ','line_number':322,'multiline':True]
['text':' Overloaded function to call the correct GenericTracer method based on the','line_number':326,'multiline':False]
['text':' argument type.','line_number':327,'multiline':False]
['text':' namespace gc','line_number':370,'multiline':False]
['text':' namespace js','line_number':371,'multiline':False]
['text':' js_Tracer_h ','line_number':373,'multiline':True]
