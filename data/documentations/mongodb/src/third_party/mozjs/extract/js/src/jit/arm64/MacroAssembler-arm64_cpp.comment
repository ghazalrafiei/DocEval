['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' js::jit::JitActivation','line_number':21,'multiline':False]
['text':' placeholder ','line_number':92,'multiline':True]
['text':' Inserting one load instruction.','line_number':98,'multiline':False]
['text':' Every pool entry is 4 bytes.','line_number':99,'multiline':False]
['text':' TODO: Should be const.','line_number':100,'multiline':False]
['text':' Scratch space for generating the load instruction.','line_number':102,'multiline':False]
['text':'','line_number':103,'multiline':False]
['text':' allocLiteralLoadEntry() will use InsertIndexIntoTag() to store a temporary','line_number':104,'multiline':False]
['text':' index to the corresponding PoolEntry in the instruction itself.','line_number':105,'multiline':False]
['text':'','line_number':106,'multiline':False]
['text':' That index will be fixed up later when finishPool()','line_number':107,'multiline':False]
['text':' walks over all marked loads and calls PatchConstantPoolLoad().','line_number':108,'multiline':False]
['text':' Emit the instruction mask in the scratch space.','line_number':111,'multiline':False]
['text':' The offset doesn't matter: it will be fixed up later.','line_number':112,'multiline':False]
['text':' Add the entry to the pool, fix up the LDR imm19 offset,','line_number':116,'multiline':False]
['text':' and add the completed instruction to the buffer.','line_number':117,'multiline':False]
['text':' Inserting one load instruction.','line_number':124,'multiline':False]
['text':' Every pool entry is 4 bytes.','line_number':125,'multiline':False]
['text':' Scratch space for generating the load instruction.','line_number':128,'multiline':False]
['text':'','line_number':129,'multiline':False]
['text':' allocLiteralLoadEntry() will use InsertIndexIntoTag() to store a temporary','line_number':130,'multiline':False]
['text':' index to the corresponding PoolEntry in the instruction itself.','line_number':131,'multiline':False]
['text':'','line_number':132,'multiline':False]
['text':' That index will be fixed up later when finishPool()','line_number':133,'multiline':False]
['text':' walks over all marked loads and calls PatchConstantPoolLoad().','line_number':134,'multiline':False]
['text':' Emit the instruction mask in the scratch space.','line_number':137,'multiline':False]
['text':' The offset doesn't matter: it will be fixed up later.','line_number':138,'multiline':False]
['text':' Add the entry to the pool, fix up the LDR imm19 offset,','line_number':142,'multiline':False]
['text':' and add the completed instruction to the buffer.','line_number':143,'multiline':False]
['text':' Fail rather than silently create wrong code.','line_number':154,'multiline':False]
['text':' Reserve space for exception information.','line_number':157,'multiline':False]
['text':' Call the handler.','line_number':165,'multiline':False]
['text':' Check the `asMasm` calls above didn't mess with the StackPointer identity.','line_number':180,'multiline':False]
['text':' Invalid kind.','line_number':200,'multiline':False]
['text':' No exception handler. Load the error value, load the new stack pointer,','line_number':202,'multiline':False]
['text':' and return from the entry frame.','line_number':203,'multiline':False]
['text':' `retn` does indeed sync the stack pointer, but before doing that it reads','line_number':210,'multiline':False]
['text':' from the stack.  Consequently, if we remove this call to syncStackPointer','line_number':211,'multiline':False]
['text':' then we take on the requirement to prove that the immediately preceding','line_number':212,'multiline':False]
['text':' loadPtr produces a value for PSP which maintains the SP <= PSP invariant.','line_number':213,'multiline':False]
['text':' That's a proof burden we don't want to take on.  In general it would be','line_number':214,'multiline':False]
['text':' good to move (at some time in the future, not now) to a world where','line_number':215,'multiline':False]
['text':' *every* assignment to PSP or SP is followed immediately by a copy into','line_number':216,'multiline':False]
['text':' the other register.  That would make all required correctness proofs','line_number':217,'multiline':False]
['text':' trivial in the sense that it requires only local inspection of code','line_number':218,'multiline':False]
['text':' immediately following (dominated by) any such assignment.','line_number':219,'multiline':False]
['text':' Pop from stack and return.','line_number':221,'multiline':False]
['text':' If we found a catch handler, this must be a baseline frame. Restore state','line_number':223,'multiline':False]
['text':' and jump to the catch block.','line_number':224,'multiline':False]
['text':' If we found a finally block, this must be a baseline frame.','line_number':237,'multiline':False]
['text':' Push two values expected by JSOp::Retsub: BooleanValue(true)','line_number':238,'multiline':False]
['text':' and the exception.','line_number':239,'multiline':False]
['text':' Only used in debug mode. Return BaselineFrame->returnValue() to the caller.','line_number':257,'multiline':False]
['text':' See comment further up beginning "`retn` does indeed sync the stack','line_number':265,'multiline':False]
['text':' pointer".  That comment applies here too.','line_number':266,'multiline':False]
['text':' If profiling is enabled, then update the lastProfilingFrame to refer to','line_number':275,'multiline':False]
['text':' caller frame before returning.','line_number':276,'multiline':False]
['text':' If we are bailing out to baseline to handle an exception, jump to the','line_number':291,'multiline':False]
['text':' bailout tail stub. Load 1 (true) in x0 (ReturnReg) to indicate success.','line_number':292,'multiline':False]
['text':' If we are throwing and the innermost frame was a wasm frame, reset SP and','line_number':301,'multiline':False]
['text':' FP; SP is pointing to the unwound return address to the wasm entry, so','line_number':302,'multiline':False]
['text':' we can just ret().','line_number':303,'multiline':False]
['text':' Found a wasm catch handler, restore state and jump to it.','line_number':313,'multiline':False]
['text':' Note, other payloads are possible, but GDB is known to misinterpret them','line_number':354,'multiline':False]
['text':' sometimes and iloop on the breakpoint instead of stopping properly.','line_number':355,'multiline':False]
['text':' Either `any` is valid or `sixtyfour` is valid.  Return a 32-bit ARMRegister','line_number':359,'multiline':False]
['text':' in the first case and an ARMRegister of the desired size in the latter case.','line_number':360,'multiline':False]
['text':' Assert that `sixtyfour` is invalid and then return an FP register from `any`','line_number':373,'multiline':False]
['text':' of the desired size.','line_number':374,'multiline':False]
['text':' Reg+Reg and Reg+SmallImm addressing is directly encodable in one Load','line_number':405,'multiline':False]
['text':' instruction, hence we expect exactly one instruction to be emitted in the','line_number':406,'multiline':False]
['text':' window.','line_number':407,'multiline':False]
['text':' Splat and widen however require an additional instruction to be emitted','line_number':410,'multiline':False]
['text':' after the load, so allow one more instruction in the window.','line_number':411,'multiline':False]
['text':' The AutoForbidPoolsAndNops asserts if we emit more than the expected','line_number':420,'multiline':False]
['text':' number of instructions and thus ensures that the access metadata is','line_number':421,'multiline':False]
['text':' emitted at the address of the Load.','line_number':422,'multiline':False]
['text':' LDR does the right thing also for access.isZeroExtendSimd128Load()','line_number':453,'multiline':False]
['text':' LDR does the right thing also for access.isZeroExtendSimd128Load()','line_number':489,'multiline':False]
['text':' Return true if `address` can be represented as an immediate (possibly scaled','line_number':507,'multiline':False]
['text':' by the access size) in an LDR/STR type instruction.','line_number':508,'multiline':False]
['text':'','line_number':509,'multiline':False]
['text':' For more about the logic here, see vixl::MacroAssembler::LoadStoreMacro().','line_number':510,'multiline':False]
['text':' The predicates below operate on signed values only.','line_number':512,'multiline':False]
['text':' The access size is always a power of 2, so computing the log amounts to','line_number':517,'multiline':False]
['text':' counting trailing zeroes.','line_number':518,'multiline':False]
['text':' The access will require the constant to be loaded into a temp register.','line_number':528,'multiline':False]
['text':' Do so here, to keep the logic in wasmLoadImpl() tractable wrt emitting','line_number':529,'multiline':False]
['text':' trap information.','line_number':530,'multiline':False]
['text':'','line_number':531,'multiline':False]
['text':' Almost all constant addresses will in practice be handled by a single MOV','line_number':532,'multiline':False]
['text':' so do not worry about additional optimizations here.','line_number':533,'multiline':False]
['text':' Reg+Reg addressing is directly encodable in one Store instruction, hence','line_number':571,'multiline':False]
['text':' the AutoForbidPoolsAndNops will ensure that the access metadata is','line_number':572,'multiline':False]
['text':' emitted at the address of the Store.  The AutoForbidPoolsAndNops will','line_number':573,'multiline':False]
['text':' assert if we emit more than one instruction.','line_number':574,'multiline':False]
['text':' max number of instructions in scope = ','line_number':577,'multiline':True]
['text':' See comments in wasmLoadAbsolute.','line_number':619,'multiline':False]
['text':' Compute -(shift & 7) in all 8-bit lanes','line_number':710,'multiline':False]
['text':' Compute -(shift & 15) in all 16-bit lanes','line_number':732,'multiline':False]
['text':' Compute -(shift & 31) in all 32-bit lanes','line_number':754,'multiline':False]
['text':' Compute -(shift & 63)','line_number':776,'multiline':False]
['text':' TODO: This bumps |sp| every time we reserve using a second register.','line_number':793,'multiline':False]
['text':' It would save some instructions if we had a fixed frame size.','line_number':794,'multiline':False]
['text':'{{{ check_macroassembler_style','line_number':808,'multiline':False]
['text':' ===============================================================','line_number':809,'multiline':False]
['text':' MacroAssembler high-level usage.','line_number':810,'multiline':False]
['text':' ===============================================================','line_number':814,'multiline':False]
['text':' Stack manipulation functions.','line_number':815,'multiline':False]
['text':' Routines for saving/restoring registers on the stack.  The format is:','line_number':817,'multiline':False]
['text':'','line_number':818,'multiline':False]
['text':'   (highest address)','line_number':819,'multiline':False]
['text':'','line_number':820,'multiline':False]
['text':'   integer (X) regs in any order      size: 8 * # int regs','line_number':821,'multiline':False]
['text':'','line_number':822,'multiline':False]
['text':'   if # int regs is odd,','line_number':823,'multiline':False]
['text':'     then an 8 byte alignment hole    size: 0 or 8','line_number':824,'multiline':False]
['text':'','line_number':825,'multiline':False]
['text':'   double (D) regs in any order       size: 8 * # double regs','line_number':826,'multiline':False]
['text':'','line_number':827,'multiline':False]
['text':'   if # double regs is odd,','line_number':828,'multiline':False]
['text':'     then an 8 byte alignment hole    size: 0 or 8','line_number':829,'multiline':False]
['text':'','line_number':830,'multiline':False]
['text':'   vector (Q) regs in any order       size: 16 * # vector regs','line_number':831,'multiline':False]
['text':'','line_number':832,'multiline':False]
['text':'   (lowest address)','line_number':833,'multiline':False]
['text':'','line_number':834,'multiline':False]
['text':' Hence the size of the save area is 0 % 16.  And, provided that the base','line_number':835,'multiline':False]
['text':' (highest) address is 16-aligned, then the vector reg save/restore accesses','line_number':836,'multiline':False]
['text':' will also be 16-aligned, as will pairwise operations for the double regs.','line_number':837,'multiline':False]
['text':'','line_number':838,'multiline':False]
['text':' Implied by this is that the format of the double and vector dump area','line_number':839,'multiline':False]
['text':' corresponds with what FloatRegister::GetPushSizeInBytes computes.','line_number':840,'multiline':False]
['text':' See block comment in MacroAssembler.h for more details.','line_number':841,'multiline':False]
['text':' Generate code to dump the values in `set`, either on the stack if `dest` is','line_number':849,'multiline':False]
['text':' `Nothing` or working backwards from the address denoted by `dest` if it is','line_number':850,'multiline':False]
['text':' `Some`.  These two cases are combined so as to minimise the chance of','line_number':851,'multiline':False]
['text':' mistakenly generating different formats for the same `set`, given that the','line_number':852,'multiline':False]
['text':' `Some` `dest` case is used extremely rarely.','line_number':853,'multiline':False]
['text':' If we're saving to arbitrary memory, check the destination is big enough.','line_number':858,'multiline':False]
['text':' Note the high limit point; we'll check it again later.','line_number':866,'multiline':False]
['text':' Gather up the integer registers in groups of four, and either push each','line_number':870,'multiline':False]
['text':' group as a single transfer so as to minimise the number of stack pointer','line_number':871,'multiline':False]
['text':' changes, or write them individually to memory.  Take care to ensure the','line_number':872,'multiline':False]
['text':' space used remains 16-aligned.','line_number':873,'multiline':False]
['text':' Ensure the stack remains 16-aligned','line_number':885,'multiline':False]
['text':' Now the same for the FP double registers.  Note that because of how','line_number':905,'multiline':False]
['text':' ReduceSetForPush works, an underlying AArch64 SIMD/FP register can either','line_number':906,'multiline':False]
['text':' be present as a double register, or as a V128 register, but not both.','line_number':907,'multiline':False]
['text':' Firstly, round up the registers to be pushed.','line_number':908,'multiline':False]
['text':' We've got an odd number of doubles.  In order to maintain 16-alignment,','line_number':927,'multiline':False]
['text':' push the last register twice.  We'll skip over the duplicate in','line_number':928,'multiline':False]
['text':' PopRegsInMaskIgnore.','line_number':929,'multiline':False]
['text':' And now generate the transfers.','line_number':936,'multiline':False]
['text':' Finally, deal with the SIMD (V128) registers.  This is a bit simpler','line_number':962,'multiline':False]
['text':' as there's no need for special-casing to maintain 16-alignment.','line_number':963,'multiline':False]
['text':' Generate the transfers.','line_number':976,'multiline':False]
['text':' Final overrun check.','line_number':1001,'multiline':False]
['text':' This is a helper function for PopRegsInMaskIgnore below.  It emits the','line_number':1020,'multiline':False]
['text':' loads described by dests[0] and [1] and offsets[0] and [1], generating a','line_number':1021,'multiline':False]
['text':' load-pair if it can.','line_number':1022,'multiline':False]
['text':' Generate the loads ..','line_number':1027,'multiline':False]
['text':' [0] and [1] both present.','line_number':1030,'multiline':False]
['text':' Theoretically we could check for a load-pair with the destinations','line_number':1035,'multiline':False]
['text':' switched, but our callers will never generate that.  Hence there's','line_number':1036,'multiline':False]
['text':' no loss in giving up at this point and generating two loads.','line_number':1037,'multiline':False]
['text':' [0] only.','line_number':1042,'multiline':False]
['text':' [1] only.  Can't happen because callers always fill [0] before [1].','line_number':1047,'multiline':False]
['text':' Neither entry valid.  This can happen.','line_number':1050,'multiline':False]
['text':' .. and flush.','line_number':1054,'multiline':False]
['text':' The offset of the data from the stack pointer.','line_number':1063,'multiline':False]
['text':' The set of FP/SIMD registers we need to restore.','line_number':1066,'multiline':False]
['text':' The set of registers to ignore.  BroadcastToAllSizes() is used to avoid','line_number':1069,'multiline':False]
['text':' any ambiguities arising from (eg) `fpuSet` containing q17 but `ignore`','line_number':1070,'multiline':False]
['text':' containing d17.','line_number':1071,'multiline':False]
['text':' First recover the SIMD (V128) registers.  This is straightforward in that','line_number':1075,'multiline':False]
['text':' we don't need to think about alignment holes.','line_number':1076,'multiline':False]
['text':' These three form a two-entry queue that holds loads that we know we','line_number':1078,'multiline':False]
['text':' need, but which we haven't yet emitted.','line_number':1079,'multiline':False]
['text':' Now recover the FP double registers.  This is more tricky in that we need','line_number':1112,'multiline':False]
['text':' to skip over the lowest-addressed of them if the number of them was odd.','line_number':1113,'multiline':False]
['text':' true but redundant, per loop above: MOZ_RELEASE_ASSERT(reg.isDouble()) ','line_number':1124,'multiline':True]
['text':' And finally recover the integer registers, again skipping an alignment','line_number':1148,'multiline':False]
['text':' hole if it exists.','line_number':1149,'multiline':False]
['text':' ===============================================================','line_number':1240,'multiline':False]
['text':' Simple call functions.','line_number':1241,'multiline':False]
['text':' This sync has been observed (and is expected) to be necessary.','line_number':1244,'multiline':False]
['text':' eg testcase: tests/debug/bug1107525.js','line_number':1245,'multiline':False]
['text':' This sync has been observed (and is expected) to be necessary.','line_number':1252,'multiline':False]
['text':' eg testcase: tests/basic/testBug504520Harder.js','line_number':1253,'multiline':False]
['text':' This sync has been observed (and is expected) to be necessary.','line_number':1260,'multiline':False]
['text':' eg testcase: asm.js/testTimeout5.js','line_number':1261,'multiline':False]
['text':' ip0','line_number':1264,'multiline':False]
['text':' This sync is believed to be necessary, although no case in jit-test/tests','line_number':1275,'multiline':False]
['text':' has been observed to cause SP != PSP here.','line_number':1276,'multiline':False]
['text':' This sync has been observed (and is expected) to be necessary.','line_number':1286,'multiline':False]
['text':' eg testcase: tests/backup-point-bug1315634.js','line_number':1287,'multiline':False]
['text':' This sync has been observed (and is expected) to be necessary.','line_number':1296,'multiline':False]
['text':' eg testcase: arrays/new-array-undefined-undefined-more-args-2.js','line_number':1297,'multiline':False]
['text':' This needs to sync.  Wasm goes through this one for intramodule calls.','line_number':1305,'multiline':False]
['text':'','line_number':1306,'multiline':False]
['text':' In other cases, wasm goes through masm.wasmCallImport(),','line_number':1307,'multiline':False]
['text':' masm.wasmCallBuiltinInstanceMethod, masm.wasmCallIndirect, all of which','line_number':1308,'multiline':False]
['text':' sync.','line_number':1309,'multiline':False]
['text':'','line_number':1310,'multiline':False]
['text':' This sync is believed to be necessary, although no case in jit-test/tests','line_number':1311,'multiline':False]
['text':' has been observed to cause SP != PSP here.','line_number':1312,'multiline':False]
['text':' max number of instructions in scope = ','line_number':1333,'multiline':True]
['text':' At most one nop','line_number':1337,'multiline':False]
['text':' max number of instructions in scope = ','line_number':1371,'multiline':True]
['text':' ===============================================================','line_number':1400,'multiline':False]
['text':' ABI function calls.','line_number':1401,'multiline':False]
['text':' Because wasm operates without the need for dynamic alignment of SP, it is','line_number':1404,'multiline':False]
['text':' implied that this routine should never be called when generating wasm.','line_number':1405,'multiline':False]
['text':' The following won't work for SP -- needs slightly different logic.','line_number':1408,'multiline':False]
['text':' Always save LR -- Baseline ICs assume that LR isn't modified.','line_number':1418,'multiline':False]
['text':' Remember the stack address on entry.  This is reloaded in callWithABIPost','line_number':1421,'multiline':False]
['text':' below.','line_number':1422,'multiline':False]
['text':' Make alignment, including the effective push of the previous sp.','line_number':1425,'multiline':False]
['text':' Store previous sp to the top of the stack, aligned.  This is also','line_number':1430,'multiline':False]
['text':' reloaded in callWithABIPost.','line_number':1431,'multiline':False]
['text':' wasm operates without the need for dynamic alignment of SP.','line_number':1436,'multiline':False]
['text':' ARM64 *really* wants SP to always be 16-aligned, so ensure this now.','line_number':1442,'multiline':False]
['text':' This can happen when we attach out-of-line stubs for rare cases.  For','line_number':1446,'multiline':False]
['text':' example CodeGenerator::visitWasmTruncateToInt32 adds an out-of-line','line_number':1447,'multiline':False]
['text':' chunk.','line_number':1448,'multiline':False]
['text':' Call boundaries communicate stack via SP.','line_number':1466,'multiline':False]
['text':' (jseward, 2021Mar03) This sync may well be redundant, given that all of','line_number':1467,'multiline':False]
['text':' the MacroAssembler::call methods generate a sync before the call.','line_number':1468,'multiline':False]
['text':' Removing it does not cause any failures for all of jit-tests.','line_number':1469,'multiline':False]
['text':' wasm operates without the need for dynamic alignment of SP.','line_number':1475,'multiline':False]
['text':' Call boundaries communicate stack via SP, so we must resync PSP now.','line_number':1478,'multiline':False]
['text':' This then-clause makes more sense if you first read','line_number':1484,'multiline':False]
['text':' setupUnalignedABICall above.','line_number':1485,'multiline':False]
['text':'','line_number':1486,'multiline':False]
['text':' Restore the stack pointer from entry.  The stack pointer will have been','line_number':1487,'multiline':False]
['text':' saved by setupUnalignedABICall.  This is fragile in that it assumes','line_number':1488,'multiline':False]
['text':' that uses of this routine (callWithABIPost) with `dynamicAlignment_ ==','line_number':1489,'multiline':False]
['text':' true` are preceded by matching calls to setupUnalignedABICall.  But','line_number':1490,'multiline':False]
['text':' there's nothing that enforce that mechanically.  If we really want to','line_number':1491,'multiline':False]
['text':' enforce this, we could add a debug-only CallWithABIState enum to the','line_number':1492,'multiline':False]
['text':' MacroAssembler and assert that setupUnalignedABICall updates it before','line_number':1493,'multiline':False]
['text':' we get here, then reset it to its initial state.','line_number':1494,'multiline':False]
['text':' Restore LR.  This restores LR to the value stored by','line_number':1498,'multiline':False]
['text':' setupUnalignedABICall, which should have been called just before','line_number':1499,'multiline':False]
['text':' callWithABIPre.  This is, per the above comment, also fragile.','line_number':1500,'multiline':False]
['text':' SP may be < PSP now.  That is expected from the behaviour of `pop`.  It','line_number':1503,'multiline':False]
['text':' is not clear why the following `syncStackPtr` is necessary, but it is:','line_number':1504,'multiline':False]
['text':' without it, the following test segfaults:','line_number':1505,'multiline':False]
['text':' tests/backup-point-bug1315634.js','line_number':1506,'multiline':False]
['text':' If the ABI's return regs are where ION is expecting them, then','line_number':1510,'multiline':False]
['text':' no other work needs to be done.','line_number':1511,'multiline':False]
['text':' ===============================================================','line_number':1542,'multiline':False]
['text':' Jit Frames.','line_number':1543,'multiline':False]
['text':' ===============================================================','line_number':1566,'multiline':False]
['text':' Move instructions','line_number':1567,'multiline':False]
['text':' ===============================================================','line_number':1612,'multiline':False]
['text':' Branch functions','line_number':1613,'multiline':False]
['text':' Both may be used internally.','line_number':1628,'multiline':False]
['text':' Both may be used internally.','line_number':1656,'multiline':False]
['text':' ========================================================================','line_number':1682,'multiline':False]
['text':' Memory access primitives.','line_number':1683,'multiline':False]
['text':' For known integers and booleans, we can just store the unboxed value if','line_number':1693,'multiline':False]
['text':' the slot has the same type.','line_number':1694,'multiline':False]
['text':' ========================================================================','line_number':1728,'multiline':False]
['text':' wasm support','line_number':1729,'multiline':False]
['text':' max number of instructions in scope = ','line_number':1733,'multiline':True]
['text':' FCVTZU behaves as follows:','line_number':1775,'multiline':False]
['text':'','line_number':1776,'multiline':False]
['text':' on NaN it produces zero','line_number':1777,'multiline':False]
['text':' on too large it produces UINT_MAX (for appropriate type)','line_number':1778,'multiline':False]
['text':' on too small it produces zero','line_number':1779,'multiline':False]
['text':'','line_number':1780,'multiline':False]
['text':' FCVTZS behaves as follows:','line_number':1781,'multiline':False]
['text':'','line_number':1782,'multiline':False]
['text':' on NaN it produces zero','line_number':1783,'multiline':False]
['text':' on too large it produces INT_MAX (for appropriate type)','line_number':1784,'multiline':False]
['text':' on too small it produces INT_MIN (ditto)','line_number':1785,'multiline':False]
['text':' Wasm stubs use the native SP, not the PSP.  Setting up the fake exit','line_number':2055,'multiline':False]
['text':' frame leaves the SP mis-aligned, which is how we want it, but we must do','line_number':2056,'multiline':False]
['text':' that carefully.','line_number':2057,'multiline':False]
['text':' Despite the above assertion, it is possible for control to flow from here','line_number':2070,'multiline':False]
['text':' to the code generated by','line_number':2071,'multiline':False]
['text':' MacroAssemblerCompat::handleFailureWithHandlerTail without any','line_number':2072,'multiline':False]
['text':' intervening assignment to PSP.  But handleFailureWithHandlerTail assumes','line_number':2073,'multiline':False]
['text':' that PSP is the active stack pointer.  Hence the following is necessary','line_number':2074,'multiline':False]
['text':' for safety.  Note we can't use initPseudoStackPtr here as that would','line_number':2075,'multiline':False]
['text':' generate no instructions.','line_number':2076,'multiline':False]
['text':' SP may be unaligned, can't use it for memory op','line_number':2079,'multiline':False]
['text':' ========================================================================','line_number':2084,'multiline':False]
['text':' Convert floating point.','line_number':2085,'multiline':False]
['text':' ========================================================================','line_number':2113,'multiline':False]
['text':' Primitive atomic operations.','line_number':2114,'multiline':False]
['text':' The computed MemOperand must be Reg+0 because the load/store exclusive','line_number':2116,'multiline':False]
['text':' instructions only take a single pointer register.','line_number':2117,'multiline':False]
['text':' This sign extends to targetWidth and leaves any higher bits zero.','line_number':2141,'multiline':False]
['text':' Exclusive-loads zero-extend their values to the full width of the X register.','line_number':2183,'multiline':False]
['text':'','line_number':2184,'multiline':False]
['text':' Note, we've promised to leave the high bits of the 64-bit register clear if','line_number':2185,'multiline':False]
['text':' the targetWidth is 32.','line_number':2186,'multiline':False]
['text':' With this address form, a single native ldxr* will be emitted, and the','line_number':2194,'multiline':False]
['text':' AutoForbidPoolsAndNops ensures that the metadata is emitted at the address','line_number':2195,'multiline':False]
['text':' of the ldxr*.','line_number':2196,'multiline':False]
['text':' max number of instructions in scope = ','line_number':2204,'multiline':True]
['text':' max number of instructions in scope = ','line_number':2219,'multiline':True]
['text':' max number of instructions in scope = ','line_number':2234,'multiline':True]
['text':' max number of instructions in scope = ','line_number':2249,'multiline':True]
['text':' ========================================================================','line_number':2608,'multiline':False]
['text':' JS atomic operations.','line_number':2609,'multiline':False]
['text':' Preserve src for remainder computation','line_number':2731,'multiline':False]
['text':' Compute remainder','line_number':2739,'multiline':False]
['text':' max number of instructions in scope = ','line_number':2746,'multiline':True]
['text':' ========================================================================','line_number':2764,'multiline':False]
['text':' Spectre Mitigations.','line_number':2765,'multiline':False]
['text':' Conditional speculation barrier.','line_number':2768,'multiline':False]
['text':' Convert scalar to signed 32-bit fixed-point, rounding toward zero.','line_number':2798,'multiline':False]
['text':' In the case of overflow, the output is saturated.','line_number':2799,'multiline':False]
['text':' In the case of NaN and -0, the output is zero.','line_number':2800,'multiline':False]
['text':' If the output was zero, worry about special cases.','line_number':2803,'multiline':False]
['text':' Fail on overflow cases.','line_number':2806,'multiline':False]
['text':' If the output was non-zero and wasn't saturated, just return it.','line_number':2810,'multiline':False]
['text':' Handle the case of a zero output:','line_number':2813,'multiline':False]
['text':' 1. The input may have been NaN, requiring a failure.','line_number':2814,'multiline':False]
['text':' 2. The input may have been in (-1,-0], requiring a failure.','line_number':2815,'multiline':False]
['text':' If input is a negative number that truncated to zero, the real','line_number':2819,'multiline':False]
['text':' output should be the non-integer -0.','line_number':2820,'multiline':False]
['text':' The use of "lt" instead of "lo" also catches unordered NaN input.','line_number':2821,'multiline':False]
['text':' Check explicitly for -0, bitwise.','line_number':2825,'multiline':False]
['text':' Convert scalar to signed 32-bit fixed-point, rounding toward zero.','line_number':2840,'multiline':False]
['text':' In the case of overflow, the output is saturated.','line_number':2841,'multiline':False]
['text':' In the case of NaN and -0, the output is zero.','line_number':2842,'multiline':False]
['text':' If the output was zero, worry about special cases.','line_number':2845,'multiline':False]
['text':' Fail on overflow cases.','line_number':2848,'multiline':False]
['text':' If the output was non-zero and wasn't saturated, just return it.','line_number':2852,'multiline':False]
['text':' Handle the case of a zero output:','line_number':2855,'multiline':False]
['text':' 1. The input may have been NaN, requiring a failure.','line_number':2856,'multiline':False]
['text':' 2. The input may have been in (-1,-0], requiring a failure.','line_number':2857,'multiline':False]
['text':' If input is a negative number that truncated to zero, the real','line_number':2861,'multiline':False]
['text':' output should be the non-integer -0.','line_number':2862,'multiline':False]
['text':' The use of "lt" instead of "lo" also catches unordered NaN input.','line_number':2863,'multiline':False]
['text':' Check explicitly for -0, bitwise.','line_number':2867,'multiline':False]
['text':' Branch to a slow path if input < 0.0 due to complicated rounding rules.','line_number':2883,'multiline':False]
['text':' Note that Fcmp with NaN unsets the negative flag.','line_number':2884,'multiline':False]
['text':' Handle the simple case of a positive input, and also -0 and NaN.','line_number':2888,'multiline':False]
['text':' Rounding proceeds with consideration of the fractional part of the input:','line_number':2889,'multiline':False]
['text':' 1. If > 0.5, round to integer with higher absolute value (so, up).','line_number':2890,'multiline':False]
['text':' 2. If < 0.5, round to integer with lower absolute value (so, down).','line_number':2891,'multiline':False]
['text':' 3. If = 0.5, round to +Infinity (so, up).','line_number':2892,'multiline':False]
['text':' Convert to signed 32-bit integer, rounding halfway cases away from zero.','line_number':2894,'multiline':False]
['text':' In the case of overflow, the output is saturated.','line_number':2895,'multiline':False]
['text':' In the case of NaN and -0, the output is zero.','line_number':2896,'multiline':False]
['text':' If the output potentially saturated, fail.','line_number':2898,'multiline':False]
['text':' If the result of the rounding was non-zero, return the output.','line_number':2901,'multiline':False]
['text':' In the case of zero, the input may have been NaN or -0, which must bail.','line_number':2902,'multiline':False]
['text':' If input is NaN, comparisons set the C and V bits of the NZCV flags.','line_number':2905,'multiline':False]
['text':' Move all 32 bits of the input into a scratch register to check for -0.','line_number':2909,'multiline':False]
['text':' Handle the complicated case of a negative input.','line_number':2920,'multiline':False]
['text':' Rounding proceeds with consideration of the fractional part of the input:','line_number':2921,'multiline':False]
['text':' 1. If > 0.5, round to integer with higher absolute value (so, down).','line_number':2922,'multiline':False]
['text':' 2. If < 0.5, round to integer with lower absolute value (so, up).','line_number':2923,'multiline':False]
['text':' 3. If = 0.5, round to +Infinity (so, up).','line_number':2924,'multiline':False]
['text':' Inputs in [-0.5, 0) need 0.5 added; other negative inputs need','line_number':2927,'multiline':False]
['text':' the biggest double less than 0.5.','line_number':2928,'multiline':False]
['text':' Round all values toward -Infinity.','line_number':2937,'multiline':False]
['text':' In the case of overflow, the output is saturated.','line_number':2938,'multiline':False]
['text':' NaN and -0 are already handled by the "positive number" path above.','line_number':2939,'multiline':False]
['text':' If the output potentially saturated, fail.','line_number':2941,'multiline':False]
['text':' If output is zero, then the actual result is -0. Fail.','line_number':2944,'multiline':False]
['text':' Branch to a slow path if input < 0.0 due to complicated rounding rules.','line_number':2958,'multiline':False]
['text':' Note that Fcmp with NaN unsets the negative flag.','line_number':2959,'multiline':False]
['text':' Handle the simple case of a positive input, and also -0 and NaN.','line_number':2963,'multiline':False]
['text':' Rounding proceeds with consideration of the fractional part of the input:','line_number':2964,'multiline':False]
['text':' 1. If > 0.5, round to integer with higher absolute value (so, up).','line_number':2965,'multiline':False]
['text':' 2. If < 0.5, round to integer with lower absolute value (so, down).','line_number':2966,'multiline':False]
['text':' 3. If = 0.5, round to +Infinity (so, up).','line_number':2967,'multiline':False]
['text':' Convert to signed 32-bit integer, rounding halfway cases away from zero.','line_number':2969,'multiline':False]
['text':' In the case of overflow, the output is saturated.','line_number':2970,'multiline':False]
['text':' In the case of NaN and -0, the output is zero.','line_number':2971,'multiline':False]
['text':' If the output potentially saturated, fail.','line_number':2973,'multiline':False]
['text':' If the result of the rounding was non-zero, return the output.','line_number':2976,'multiline':False]
['text':' In the case of zero, the input may have been NaN or -0, which must bail.','line_number':2977,'multiline':False]
['text':' If input is NaN, comparisons set the C and V bits of the NZCV flags.','line_number':2980,'multiline':False]
['text':' Move all 64 bits of the input into a scratch register to check for -0.','line_number':2984,'multiline':False]
['text':' Handle the complicated case of a negative input.','line_number':2995,'multiline':False]
['text':' Rounding proceeds with consideration of the fractional part of the input:','line_number':2996,'multiline':False]
['text':' 1. If > 0.5, round to integer with higher absolute value (so, down).','line_number':2997,'multiline':False]
['text':' 2. If < 0.5, round to integer with lower absolute value (so, up).','line_number':2998,'multiline':False]
['text':' 3. If = 0.5, round to +Infinity (so, up).','line_number':2999,'multiline':False]
['text':' Inputs in [-0.5, 0) need 0.5 added; other negative inputs need','line_number':3002,'multiline':False]
['text':' the biggest double less than 0.5.','line_number':3003,'multiline':False]
['text':' Round all values toward -Infinity.','line_number':3012,'multiline':False]
['text':' In the case of overflow, the output is saturated.','line_number':3013,'multiline':False]
['text':' NaN and -0 are already handled by the "positive number" path above.','line_number':3014,'multiline':False]
['text':' If the output potentially saturated, fail.','line_number':3016,'multiline':False]
['text':' If output is zero, then the actual result is -0. Fail.','line_number':3019,'multiline':False]
['text':' Double with only the sign bit set (= negative zero).','line_number':3068,'multiline':False]
['text':' Float with only the sign bit set (= negative zero).','line_number':3085,'multiline':False]
['text':'}}} check_macroassembler_style','line_number':3098,'multiline':False]
['text':' namespace jit','line_number':3100,'multiline':False]
['text':' namespace js','line_number':3101,'multiline':False]
