['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':'{{{ check_macroassembler_style','line_number':15,'multiline':False]
['text':' ===============================================================','line_number':89,'multiline':False]
['text':' Load instructions','line_number':90,'multiline':False]
['text':' ===============================================================','line_number':98,'multiline':False]
['text':' Logical instructions','line_number':99,'multiline':False]
['text':' ===============================================================','line_number':236,'multiline':False]
['text':' Swap instructions','line_number':237,'multiline':False]
['text':' ===============================================================','line_number':258,'multiline':False]
['text':' Arithmetic functions','line_number':259,'multiline':False]
['text':' LOW32  = LOW(LOW(dest) * LOW(imm));','line_number':416,'multiline':False]
['text':' HIGH32 = LOW(HIGH(dest) * LOW(imm)) [multiply imm into upper bits]','line_number':417,'multiline':False]
['text':'        + LOW(LOW(dest) * HIGH(imm)) [multiply dest into upper bits]','line_number':418,'multiline':False]
['text':'        + HIGH(LOW(dest) * LOW(imm)) [carry]','line_number':419,'multiline':False]
['text':' HIGH(dest) = LOW(HIGH(dest) * LOW(imm));','line_number':424,'multiline':False]
['text':' high:low = LOW(dest) * LOW(imm);','line_number':428,'multiline':False]
['text':' HIGH(dest) += high;','line_number':431,'multiline':False]
['text':' HIGH(dest) += LOW(LOW(dest) * HIGH(imm));','line_number':434,'multiline':False]
['text':' LOW(dest) = low;','line_number':442,'multiline':False]
['text':' LOW32  = LOW(LOW(dest) * LOW(src));                                  (1)','line_number':448,'multiline':False]
['text':' HIGH32 = LOW(HIGH(dest) * LOW(src)) [multiply src into upper bits]   (2)','line_number':449,'multiline':False]
['text':'        + LOW(LOW(dest) * HIGH(src)) [multiply dest into upper bits]  (3)','line_number':450,'multiline':False]
['text':'        + HIGH(LOW(dest) * LOW(src)) [carry]                          (4)','line_number':451,'multiline':False]
['text':' Compute mul64','line_number':455,'multiline':False]
['text':' (2)','line_number':457,'multiline':False]
['text':' (3)','line_number':458,'multiline':False]
['text':' (4) + (1)','line_number':460,'multiline':False]
['text':' LOW32  = LOW(LOW(dest) * LOW(src));                                  (1)','line_number':466,'multiline':False]
['text':' HIGH32 = LOW(HIGH(dest) * LOW(src)) [multiply src into upper bits]   (2)','line_number':467,'multiline':False]
['text':'        + LOW(LOW(dest) * HIGH(src)) [multiply dest into upper bits]  (3)','line_number':468,'multiline':False]
['text':'        + HIGH(LOW(dest) * LOW(src)) [carry]                          (4)','line_number':469,'multiline':False]
['text':' Compute mul64','line_number':474,'multiline':False]
['text':' (2)','line_number':475,'multiline':False]
['text':' (3)','line_number':476,'multiline':False]
['text':' (4) + (1)','line_number':478,'multiline':False]
['text':' ===============================================================','line_number':606,'multiline':False]
['text':' Shift functions','line_number':607,'multiline':False]
['text':' dest.high = dest.high << shift | dest.low << shift - 32 | dest.low >> 32 -','line_number':635,'multiline':False]
['text':' shift Note: one of the two dest.low shift will always yield zero due to','line_number':636,'multiline':False]
['text':' negative shift.','line_number':637,'multiline':False]
['text':' dest.low = dest.low >>> shift | dest.high <<< 32 - shift','line_number':721,'multiline':False]
['text':' if (shift - 32 >= 0)','line_number':722,'multiline':False]
['text':'   dest.low |= dest.high >>> shift - 32','line_number':723,'multiline':False]
['text':' Note: Negative shifts yield a zero as result, except for the signed','line_number':724,'multiline':False]
['text':'       right shift. Therefore we need to test for it and only do it if','line_number':725,'multiline':False]
['text':'       it isn't negative.','line_number':726,'multiline':False]
['text':' dest.low = dest.low >> shift | dest.high >> shift - 32 | dest.high << 32 -','line_number':779,'multiline':False]
['text':' shift Note: one of the two dest.high shifts will always yield zero due to','line_number':780,'multiline':False]
['text':' negative shift.','line_number':781,'multiline':False]
['text':' ===============================================================','line_number':794,'multiline':False]
['text':' Rotate functions','line_number':795,'multiline':False]
['text':' high = high << shift | low >> 32 - shift','line_number':853,'multiline':False]
['text':' low = low << shift | high >> 32 - shift','line_number':854,'multiline':False]
['text':' A 32 - 64 shift is a 0 - 32 shift in the other direction.','line_number':866,'multiline':False]
['text':' high = high >> shift | low << 32 - shift','line_number':939,'multiline':False]
['text':' low = low >> shift | high << 32 - shift','line_number':940,'multiline':False]
['text':' A 32 - 64 shift is a 0 - 32 shift in the other direction.','line_number':952,'multiline':False]
['text':' ===============================================================','line_number':968,'multiline':False]
['text':' Condition functions','line_number':969,'multiline':False]
['text':' ===============================================================','line_number':983,'multiline':False]
['text':' Bit counting functions','line_number':984,'multiline':False]
['text':' knownNotZero = ','line_number':1010,'multiline':True]
['text':' knownNotZero = ','line_number':1014,'multiline':True]
['text':' Equivalent to GCC output of mozilla::CountPopulation32()','line_number':1021,'multiline':False]
['text':' The source and destination can overlap. Therefore make sure we don't','line_number':1047,'multiline':False]
['text':' clobber the source before we have the data.','line_number':1048,'multiline':False]
['text':' ===============================================================','line_number':1061,'multiline':False]
['text':' Branch functions','line_number':1062,'multiline':False]
['text':' Load into scratch.','line_number':1104,'multiline':False]
['text':' Load into scratch.','line_number':1117,'multiline':False]
['text':' Load lhs into scratch2.','line_number':1134,'multiline':False]
['text':' Load lhs into scratch2.','line_number':1154,'multiline':False]
['text':' Force the unordered cases not to jump.','line_number':1413,'multiline':False]
['text':' Force the unordered cases not to jump.','line_number':1453,'multiline':False]
['text':' There are two options for implementing branchTruncateDoubleToInt32:','line_number':1476,'multiline':False]
['text':'','line_number':1477,'multiline':False]
['text':' 1. Convert the floating point value to an integer, if it did not fit, then it','line_number':1478,'multiline':False]
['text':' was clamped to INT_MIN/INT_MAX, and we can test it. NOTE: if the value','line_number':1479,'multiline':False]
['text':' really was supposed to be INT_MAX / INT_MIN then it will be wrong.','line_number':1480,'multiline':False]
['text':'','line_number':1481,'multiline':False]
['text':' 2. Convert the floating point value to an integer, if it did not fit, then it','line_number':1482,'multiline':False]
['text':' set one or two bits in the fpcsr. Check those.','line_number':1483,'multiline':False]
['text':' x86 likes test foo, foo rather than cmp foo, #0.','line_number':1564,'multiline':False]
['text':' Convert the former into the latter.','line_number':1565,'multiline':False]
['text':' When loading from pc, the pc is shifted to the next instruction, we','line_number':2037,'multiline':False]
['text':' add one extra instruction to accomodate for this shifted offset.','line_number':2038,'multiline':False]
['text':' This is never used, but must be present to facilitate linking on arm.','line_number':2078,'multiline':False]
['text':' This is never used, but must be present to facilitate linking on arm.','line_number':2084,'multiline':False]
['text':' ========================================================================','line_number':2161,'multiline':False]
['text':' Memory access primitives.','line_number':2162,'multiline':False]
['text':' On ARMv6 the optional argument (BarrierST, etc) is ignored.','line_number':2191,'multiline':False]
['text':' ===============================================================','line_number':2203,'multiline':False]
['text':' Clamping functions.','line_number':2204,'multiline':False]
['text':' Look at (reg >> 8) if it is 0, then reg shouldn't be clamped if it is','line_number':2207,'multiline':False]
['text':' <0, then we want to clamp to 0, otherwise, we wish to clamp to 255','line_number':2208,'multiline':False]
['text':'}}} check_macroassembler_style','line_number':2253,'multiline':False]
['text':' ===============================================================','line_number':2254,'multiline':False]
['text':' namespace jit','line_number':2260,'multiline':False]
['text':' namespace js','line_number':2261,'multiline':False]
['text':' jit_arm_MacroAssembler_arm_inl_h ','line_number':2263,'multiline':True]
