['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' Return the effective cell color given the current marking state.','line_number':26,'multiline':False]
['text':' This must be kept in sync with ShouldMark in Marking.cpp.','line_number':27,'multiline':False]
['text':' Only objects have delegates, so default to returning nullptr. Note that some','line_number':44,'multiline':False]
['text':' compilation units will only ever use the object version.','line_number':45,'multiline':False]
['text':' Use a helper function to do overload resolution to handle cases like','line_number':55,'multiline':False]
['text':' Heap<ObjectSubclass*>: find everything that is convertible to JSObject* (and','line_number':56,'multiline':False]
['text':' avoid calling barriers).','line_number':57,'multiline':False]
['text':' namespace detail ','line_number':66,'multiline':True]
['text':' namespace gc ','line_number':67,'multiline':True]
['text':' Weakmap entry -> value edges are only visible if the map is traced, which','line_number':69,'multiline':False]
['text':' only happens if the map zone is being collected. If the map and the value','line_number':70,'multiline':False]
['text':' were in different zones, then we could have a case where the map zone is not','line_number':71,'multiline':False]
['text':' collecting but the value zone is, and incorrectly free a value that is','line_number':72,'multiline':False]
['text':' reachable solely through weakmaps.','line_number':73,'multiline':False]
['text':' The object's TraceKind needs to be added to CC graph if this object is','line_number':91,'multiline':False]
['text':' used as a WeakMap key, otherwise the key is considered to be pointed from','line_number':92,'multiline':False]
['text':' somewhere unknown, and results in leaking the subgraph which contains the','line_number':93,'multiline':False]
['text':' key. See the comments in NoteWeakMapsTracer::trace for more details.','line_number':94,'multiline':False]
['text':' Trace a WeakMap entry based on 'markedCell' getting marked, where 'origKey'','line_number':104,'multiline':False]
['text':' is the key in the weakmap. In the absence of delegates, these will be the','line_number':105,'multiline':False]
['text':' same, but when a delegate is marked then origKey will be its wrapper.','line_number':106,'multiline':False]
['text':' `markedCell` is only used for an assertion.','line_number':107,'multiline':False]
['text':' We should only be processing <weakmap,key> pairs where the key exists in','line_number':132,'multiline':False]
['text':' the weakmap. Such pairs are inserted when a weakmap is marked, and are','line_number':133,'multiline':False]
['text':' removed by barriers if the key is removed from the weakmap. Failure here','line_number':134,'multiline':False]
['text':' probably means gcEphemeronEdges is not being properly traced during a minor','line_number':135,'multiline':False]
['text':' GC, or the weakmap keys are not being updated when tenured.','line_number':136,'multiline':False]
['text':' If the entry is live, ensure its key and value are marked. Also make sure','line_number':147,'multiline':False]
['text':' the key is at least as marked as the delegate, so it cannot get discarded','line_number':148,'multiline':False]
['text':' and then recreated by rewrapping the delegate.','line_number':149,'multiline':False]
['text':' The delegate color should propagate to the key, assuming the map is','line_number':160,'multiline':False]
['text':' potentially alive at all (its color doesn't matter).','line_number':161,'multiline':False]
['text':' Don't downgrade the map color from black to gray. This can happen when a','line_number':198,'multiline':False]
['text':' barrier pushes the map object onto the black mark stack when it's','line_number':199,'multiline':False]
['text':' already present on the gray mark stack, which is marked later.','line_number':200,'multiline':False]
['text':' Trace keys only if weakMapAction() says to.','line_number':212,'multiline':False]
['text':' Always trace all values (unless weakMapAction() is Skip).','line_number':220,'multiline':False]
['text':' Add a delegate -> key edge, where the key is marked the color of the','line_number':235,'multiline':False]
['text':' delegate no matter what the weakmap's mark color is. This is implemented','line_number':236,'multiline':False]
['text':' as if it were a regular ephemeron <weakmap, key> -> value edge, where','line_number':237,'multiline':False]
['text':' the value color is the minimum of the two source colors, but in place of','line_number':238,'multiline':False]
['text':' the weakmap we use the constant color Black, which results in the','line_number':239,'multiline':False]
['text':' delegate's color propagating unchanged.','line_number':240,'multiline':False]
['text':' No delegate. Insert just the key -> value edge.','line_number':260,'multiline':False]
['text':' Populate weak keys table when we enter weak marking mode.','line_number':288,'multiline':False]
['text':' Changes in the map's mark color will be handled in this code, but','line_number':296,'multiline':False]
['text':' changes in the key's mark color are handled through the weak keys table.','line_number':297,'multiline':False]
['text':' So we only need to populate the table if the key is less marked than the','line_number':298,'multiline':False]
['text':' map, to catch later updates in the key's mark color.','line_number':299,'multiline':False]
['text':' The final color of the key is not yet known. Record this weakmap and','line_number':302,'multiline':False]
['text':' the lookup key in the list of weak keys. If the key has a delegate,','line_number':303,'multiline':False]
['text':' then the lookup key is the delegate (because marking the key will end','line_number':304,'multiline':False]
['text':' up marking the delegate and thereby mark the entry.)','line_number':305,'multiline':False]
['text':' The nursery is collected at the beginning of an incremental GC. If','line_number':315,'multiline':False]
['text':' the value is in the nursery, we know it was allocated after the GC','line_number':316,'multiline':False]
['text':' started and sometime later was inserted into the map, which should','line_number':317,'multiline':False]
['text':' be a fairly rare case. To avoid needing to sweep through the','line_number':318,'multiline':False]
['text':' ephemeron edge tables on a minor GC, just mark the value','line_number':319,'multiline':False]
['text':' immediately.','line_number':320,'multiline':False]
['text':' Remove all entries whose keys remain unmarked. ','line_number':336,'multiline':True]
['text':' Once we've swept, all remaining edges should stay within the known-live','line_number':344,'multiline':False]
['text':' part of the graph.','line_number':345,'multiline':False]
['text':' memberOf can be nullptr, which means that the map is not part of a JSObject.','line_number':350,'multiline':False]
['text':' For weakmap keys with delegates in a different zone, add a zone edge to','line_number':365,'multiline':False]
['text':' ensure that the delegate zone finishes marking before the key zone.','line_number':366,'multiline':False]
['text':' If the key type doesn't have delegates, then this will always return','line_number':371,'multiline':False]
['text':' nullptr and the optimizer can remove the entire body of this function.','line_number':372,'multiline':False]
['text':' Marking a WeakMap key's delegate will mark the key, so process the','line_number':378,'multiline':False]
['text':' delegate zone no later than the key zone.','line_number':379,'multiline':False]
['text':' namespace js ','line_number':426,'multiline':True]
['text':' gc_WeakMap_inl_h ','line_number':428,'multiline':True]
