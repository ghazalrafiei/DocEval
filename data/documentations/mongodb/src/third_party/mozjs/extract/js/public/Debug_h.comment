['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' Interfaces by which the embedding can interact with the Debugger API.','line_number':7,'multiline':False]
['text':' namespace js','line_number':26,'multiline':False]
['text':' [SMDOC] Debugger builder API','line_number':31,'multiline':False]
['text':'','line_number':32,'multiline':False]
['text':' Helping embedding code build objects for Debugger','line_number':33,'multiline':False]
['text':' -------------------------------------------------','line_number':34,'multiline':False]
['text':'','line_number':35,'multiline':False]
['text':' Some Debugger API features lean on the embedding application to construct','line_number':36,'multiline':False]
['text':' their result values. For example, Debugger.Frame.prototype.scriptEntryReason','line_number':37,'multiline':False]
['text':' calls hooks provided by the embedding to construct values explaining why it','line_number':38,'multiline':False]
['text':' invoked JavaScript; if F is a frame called from a mouse click event handler,','line_number':39,'multiline':False]
['text':' F.scriptEntryReason would return an object of the form:','line_number':40,'multiline':False]
['text':'','line_number':41,'multiline':False]
['text':'   { eventType: "mousedown", event: <object> }','line_number':42,'multiline':False]
['text':'','line_number':43,'multiline':False]
['text':' where <object> is a Debugger.Object whose referent is the event being','line_number':44,'multiline':False]
['text':' dispatched.','line_number':45,'multiline':False]
['text':'','line_number':46,'multiline':False]
['text':' However, Debugger implements a trust boundary. Debuggee code may be','line_number':47,'multiline':False]
['text':' considered untrusted; debugger code needs to be protected from debuggee','line_number':48,'multiline':False]
['text':' getters, setters, proxies, Object.watch watchpoints, and any other feature','line_number':49,'multiline':False]
['text':' that might accidentally cause debugger code to set the debuggee running. The','line_number':50,'multiline':False]
['text':' Debugger API tries to make it easy to write safe debugger code by only','line_number':51,'multiline':False]
['text':' offering access to debuggee objects via Debugger.Object instances, which','line_number':52,'multiline':False]
['text':' ensure that only those operations whose explicit purpose is to invoke','line_number':53,'multiline':False]
['text':' debuggee code do so. But this protective membrane is only helpful if we','line_number':54,'multiline':False]
['text':' interpose Debugger.Object instances in all the necessary spots.','line_number':55,'multiline':False]
['text':'','line_number':56,'multiline':False]
['text':' SpiderMonkey's compartment system also implements a trust boundary. The','line_number':57,'multiline':False]
['text':' debuggee and debugger are always in different compartments. Inter-compartment','line_number':58,'multiline':False]
['text':' work requires carefully tracking which compartment each JSObject or JS::Value','line_number':59,'multiline':False]
['text':' belongs to, and ensuring that is is correctly wrapped for each operation.','line_number':60,'multiline':False]
['text':'','line_number':61,'multiline':False]
['text':' It seems precarious to expect the embedding's hooks to implement these trust','line_number':62,'multiline':False]
['text':' boundaries. Instead, the JS::dbg::Builder API segregates the code which','line_number':63,'multiline':False]
['text':' constructs trusted objects from that which deals with untrusted objects.','line_number':64,'multiline':False]
['text':' Trusted objects have an entirely different C++ type, so code that improperly','line_number':65,'multiline':False]
['text':' mixes trusted and untrusted objects is caught at compile time.','line_number':66,'multiline':False]
['text':'','line_number':67,'multiline':False]
['text':' In the structure shown above, there are two trusted objects, and one','line_number':68,'multiline':False]
['text':' untrusted object:','line_number':69,'multiline':False]
['text':'','line_number':70,'multiline':False]
['text':' - The overall object, with the 'eventType' and 'event' properties, is a','line_number':71,'multiline':False]
['text':'   trusted object. We're going to return it to D.F.p.scriptEntryReason's','line_number':72,'multiline':False]
['text':'   caller, which will handle it directly.','line_number':73,'multiline':False]
['text':'','line_number':74,'multiline':False]
['text':' - The Debugger.Object instance appearing as the value of the 'event' property','line_number':75,'multiline':False]
['text':'   is a trusted object. It belongs to the same Debugger instance as the','line_number':76,'multiline':False]
['text':'   Debugger.Frame instance whose scriptEntryReason accessor was called, and','line_number':77,'multiline':False]
['text':'   presents a safe reflection-oriented API for inspecting its referent, which','line_number':78,'multiline':False]
['text':'   is:','line_number':79,'multiline':False]
['text':'','line_number':80,'multiline':False]
['text':' - The actual event object, an untrusted object, and the referent of the','line_number':81,'multiline':False]
['text':'   Debugger.Object above. (Content can do things like replacing accessors on','line_number':82,'multiline':False]
['text':'   Event.prototype.)','line_number':83,'multiline':False]
['text':'','line_number':84,'multiline':False]
['text':' Using JS::dbg::Builder, all objects and values the embedding deals with','line_number':85,'multiline':False]
['text':' directly are considered untrusted, and are assumed to be debuggee values. The','line_number':86,'multiline':False]
['text':' only way to construct trusted objects is to use Builder's own methods, which','line_number':87,'multiline':False]
['text':' return a separate Object type. The only way to set a property on a trusted','line_number':88,'multiline':False]
['text':' object is through that Object type. The actual trusted object is never','line_number':89,'multiline':False]
['text':' exposed to the embedding.','line_number':90,'multiline':False]
['text':'','line_number':91,'multiline':False]
['text':' So, for example, the embedding might use code like the following to construct','line_number':92,'multiline':False]
['text':' the object shown above, given a Builder passed to it by Debugger:','line_number':93,'multiline':False]
['text':'','line_number':94,'multiline':False]
['text':'    bool','line_number':95,'multiline':False]
['text':'    MyScriptEntryReason::explain(JSContext* cx,','line_number':96,'multiline':False]
['text':'                                 Builder& builder,','line_number':97,'multiline':False]
['text':'                                 Builder::Object& result)','line_number':98,'multiline':False]
['text':'    {','line_number':99,'multiline':False]
['text':'        JSObject* eventObject = ... obtain debuggee event object somehow ...;','line_number':100,'multiline':False]
['text':'        if (!eventObject) {','line_number':101,'multiline':False]
['text':'            return false;','line_number':102,'multiline':False]
['text':'        }','line_number':103,'multiline':False]
['text':'        result = builder.newObject(cx);','line_number':104,'multiline':False]
['text':'        return result &&','line_number':105,'multiline':False]
['text':'               result.defineProperty(cx, "eventType",','line_number':106,'multiline':False]
['text':'                                     SafelyFetchType(eventObject)) &&','line_number':107,'multiline':False]
['text':'               result.defineProperty(cx, "event", eventObject);','line_number':108,'multiline':False]
['text':'    }','line_number':109,'multiline':False]
['text':'','line_number':110,'multiline':False]
['text':'','line_number':111,'multiline':False]
['text':' Object::defineProperty also accepts an Object as the value to store on the','line_number':112,'multiline':False]
['text':' property. By its type, we know that the value is trusted, so we set it','line_number':113,'multiline':False]
['text':' directly as the property's value, without interposing a Debugger.Object','line_number':114,'multiline':False]
['text':' wrapper. This allows the embedding to builted nested structures of trusted','line_number':115,'multiline':False]
['text':' objects.','line_number':116,'multiline':False]
['text':'','line_number':117,'multiline':False]
['text':' The Builder and Builder::Object methods take care of doing whatever','line_number':118,'multiline':False]
['text':' compartment switching and wrapping are necessary to construct the trusted','line_number':119,'multiline':False]
['text':' values in the Debugger's compartment.','line_number':120,'multiline':False]
['text':'','line_number':121,'multiline':False]
['text':' The Object type is self-rooting. Construction, assignment, and destruction','line_number':122,'multiline':False]
['text':' all properly root the referent object.','line_number':123,'multiline':False]
['text':' The Debugger instance whose client we are building a value for. We build','line_number':128,'multiline':False]
['text':' objects in this object's compartment.','line_number':129,'multiline':False]
['text':' debuggerObject's Debugger structure, for convenience.','line_number':132,'multiline':False]
['text':' Check that |thing| is in the same compartment as our debuggerObject. Used','line_number':135,'multiline':False]
['text':' for assertions when constructing BuiltThings. We can overload this as we','line_number':136,'multiline':False]
['text':' add more instantiations of BuiltThing.','line_number':137,'multiline':False]
['text':' A reference to a trusted object or value. At the moment, we only use it','line_number':145,'multiline':False]
['text':' with JSObject*.','line_number':146,'multiline':False]
['text':' The Builder to which this trusted thing belongs.','line_number':152,'multiline':False]
['text':' A rooted reference to our value.','line_number':155,'multiline':False]
['text':' Forward some things from our owner, for convenience.','line_number':164,'multiline':False]
['text':' If we ever instantiate BuiltThing<Value>, this might not suffice.','line_number':178,'multiline':False]
['text':' A reference to a trusted object, possibly null. Instances of Object are','line_number':187,'multiline':False]
['text':' always properly rooted. They can be copied and assigned, as if they were','line_number':188,'multiline':False]
['text':' pointers.','line_number':189,'multiline':False]
['text':' for construction','line_number':191,'multiline':False]
['text':' for unwrapping','line_number':192,'multiline':False]
['text':' This is private, because only Builders can create Objects that','line_number':196,'multiline':False]
['text':' actually point to something (hence the 'friend' declaration).','line_number':197,'multiline':False]
['text':' Our automatically-generated assignment operator can see our base','line_number':208,'multiline':False]
['text':' class's assignment operator, so we don't need to write one out here.','line_number':209,'multiline':False]
['text':' Set the property named |name| on this object to |value|.','line_number':211,'multiline':False]
['text':'','line_number':212,'multiline':False]
['text':' If |value| is a string or primitive, re-wrap it for the debugger's','line_number':213,'multiline':False]
['text':' compartment.','line_number':214,'multiline':False]
['text':'','line_number':215,'multiline':False]
['text':' If |value| is an object, assume it is a debuggee object and make a','line_number':216,'multiline':False]
['text':' Debugger.Object instance referring to it. Set that as the propery's','line_number':217,'multiline':False]
['text':' value.','line_number':218,'multiline':False]
['text':'','line_number':219,'multiline':False]
['text':' If |value| is another trusted object, store it directly as the','line_number':220,'multiline':False]
['text':' property's value.','line_number':221,'multiline':False]
['text':'','line_number':222,'multiline':False]
['text':' On error, report the problem on cx and return false.','line_number':223,'multiline':False]
['text':' Build an empty object for direct use by debugger code, owned by this','line_number':232,'multiline':False]
['text':' Builder. If an error occurs, report it on cx and return a false Object.','line_number':233,'multiline':False]
['text':' Debugger itself instantiates this subclass of Builder, which can unwrap','line_number':240,'multiline':False]
['text':' BuiltThings that belong to it.','line_number':241,'multiline':False]
['text':' Finding the size of blocks allocated with malloc','line_number':256,'multiline':False]
['text':' ------------------------------------------------','line_number':257,'multiline':False]
['text':'','line_number':258,'multiline':False]
['text':' Debugger.Memory wants to be able to report how many bytes items in memory are','line_number':259,'multiline':False]
['text':' consuming. To do this, it needs a function that accepts a pointer to a block,','line_number':260,'multiline':False]
['text':' and returns the number of bytes allocated to that block. SpiderMonkey itself','line_number':261,'multiline':False]
['text':' doesn't know which function is appropriate to use, but the embedding does.','line_number':262,'multiline':False]
['text':' Tell Debuggers in |cx| to use |mallocSizeOf| to find the size of','line_number':264,'multiline':False]
['text':' malloc'd blocks.','line_number':265,'multiline':False]
['text':' Get the MallocSizeOf function that the given context is using to find the','line_number':269,'multiline':False]
['text':' size of malloc'd blocks.','line_number':270,'multiline':False]
['text':' Debugger and Garbage Collection Events','line_number':273,'multiline':False]
['text':' --------------------------------------','line_number':274,'multiline':False]
['text':'','line_number':275,'multiline':False]
['text':' The Debugger wants to report about its debuggees' GC cycles, however entering','line_number':276,'multiline':False]
['text':' JS after a GC is troublesome since SpiderMonkey will often do something like','line_number':277,'multiline':False]
['text':' force a GC and then rely on the nursery being empty. If we call into some','line_number':278,'multiline':False]
['text':' Debugger's hook after the GC, then JS runs and the nursery won't be','line_number':279,'multiline':False]
['text':' empty. Instead, we rely on embedders to call back into SpiderMonkey after a','line_number':280,'multiline':False]
['text':' GC and notify Debuggers to call their onGarbageCollection hook.','line_number':281,'multiline':False]
['text':' Determine whether it's necessary to call FireOnGarbageCollectionHook() after','line_number':283,'multiline':False]
['text':' a GC. This is only required if there are debuggers with an','line_number':284,'multiline':False]
['text':' onGarbageCollection hook observing a global in the set of collected zones.','line_number':285,'multiline':False]
['text':' For each Debugger that observed a debuggee involved in the given GC event,','line_number':288,'multiline':False]
['text':' call its `onGarbageCollection` hook.','line_number':289,'multiline':False]
['text':' Return true if the given value is a Debugger object, false otherwise.','line_number':293,'multiline':False]
['text':' Append each of the debuggee global objects observed by the Debugger object','line_number':296,'multiline':False]
['text':' |dbgObj| to |vector|. Returns true on success, false on failure.','line_number':297,'multiline':False]
['text':' Hooks for reporting where JavaScript execution began.','line_number':301,'multiline':False]
['text':'','line_number':302,'multiline':False]
['text':' Our performance tools would like to be able to label blocks of JavaScript','line_number':303,'multiline':False]
['text':' execution with the function name and source location where execution began:','line_number':304,'multiline':False]
['text':' the event handler, the callback, etc.','line_number':305,'multiline':False]
['text':'','line_number':306,'multiline':False]
['text':' Construct an instance of this class on the stack, providing a JSContext','line_number':307,'multiline':False]
['text':' belonging to the runtime in which execution will occur. Each time we enter','line_number':308,'multiline':False]
['text':' JavaScript --- specifically, each time we push a JavaScript stack frame that','line_number':309,'multiline':False]
['text':' has no older JS frames younger than this AutoEntryMonitor --- we will','line_number':310,'multiline':False]
['text':' call the appropriate |Entry| member function to indicate where we've begun','line_number':311,'multiline':False]
['text':' execution.','line_number':312,'multiline':False]
['text':' SpiderMonkey reports the JavaScript entry points occuring within this','line_number':322,'multiline':False]
['text':' AutoEntryMonitor's scope to the following member functions, which the','line_number':323,'multiline':False]
['text':' embedding is expected to override.','line_number':324,'multiline':False]
['text':'','line_number':325,'multiline':False]
['text':' It is important to note that |asyncCause| is owned by the caller and its','line_number':326,'multiline':False]
['text':' lifetime must outlive the lifetime of the AutoEntryMonitor object. It is','line_number':327,'multiline':False]
['text':' strongly encouraged that |asyncCause| be a string constant or similar','line_number':328,'multiline':False]
['text':' statically allocated string.','line_number':329,'multiline':False]
['text':' We have begun executing |function|. Note that |function| may not be the','line_number':331,'multiline':False]
['text':' actual closure we are running, but only the canonical function object to','line_number':332,'multiline':False]
['text':' which the script refers.','line_number':333,'multiline':False]
['text':' Execution has begun at the entry point of |script|, which is not a','line_number':337,'multiline':False]
['text':' function body. (This is probably being executed by 'eval' or some','line_number':338,'multiline':False]
['text':' JSAPI equivalent.)','line_number':339,'multiline':False]
['text':' Execution of the function or script has ended.','line_number':343,'multiline':False]
['text':' namespace dbg','line_number':347,'multiline':False]
['text':' namespace JS','line_number':348,'multiline':False]
['text':' js_Debug_h ','line_number':350,'multiline':True]
