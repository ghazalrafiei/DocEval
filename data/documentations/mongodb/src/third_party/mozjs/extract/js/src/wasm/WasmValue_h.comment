['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 *
 * Copyright 2021 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ','line_number':1,'multiline':True]
['text':' JSClassOps, ClassSpec','line_number':22,'multiline':False]
['text':' NativeObject','line_number':24,'multiline':False]
['text':' A V128 value.','line_number':30,'multiline':False]
['text':' Little-endian','line_number':33,'multiline':False]
['text':' An AnyRef is a boxed value that can represent any wasm reference type and any','line_number':65,'multiline':False]
['text':' host type that the host system allows to flow into and out of wasm','line_number':66,'multiline':False]
['text':' transparently.  It is a pointer-sized datum that has the same representation','line_number':67,'multiline':False]
['text':' as all its subtypes (funcref, externref, eqref, (ref T), et al) due to the','line_number':68,'multiline':False]
['text':' non-coercive subtyping of the wasm type system.  Its current representation','line_number':69,'multiline':False]
['text':' is a plain JSObject*, and the private JSObject subtype WasmValueBox is used','line_number':70,'multiline':False]
['text':' to box non-object non-null JS values.','line_number':71,'multiline':False]
['text':'','line_number':72,'multiline':False]
['text':' The C++/wasm boundary always uses a 'void*' type to express AnyRef values, to','line_number':73,'multiline':False]
['text':' emphasize the pointer-ness of the value.  The C++ code must transform the','line_number':74,'multiline':False]
['text':' void* into an AnyRef by calling AnyRef::fromCompiledCode(), and transform an','line_number':75,'multiline':False]
['text':' AnyRef into a void* by calling AnyRef::toCompiledCode().  Once in C++, we use','line_number':76,'multiline':False]
['text':' AnyRef everywhere.  A JS Value is transformed into an AnyRef by calling','line_number':77,'multiline':False]
['text':' AnyRef::box(), and the AnyRef is transformed into a JS Value by calling','line_number':78,'multiline':False]
['text':' AnyRef::unbox().','line_number':79,'multiline':False]
['text':'','line_number':80,'multiline':False]
['text':' NOTE that AnyRef values may point to GC'd storage and as such need to be','line_number':81,'multiline':False]
['text':' rooted if they are kept live in boxed form across code that may cause GC!','line_number':82,'multiline':False]
['text':' Use RootedAnyRef / HandleAnyRef / MutableHandleAnyRef where necessary.','line_number':83,'multiline':False]
['text':'','line_number':84,'multiline':False]
['text':' The lowest bits of the pointer value are used for tagging, to allow for some','line_number':85,'multiline':False]
['text':' representation optimizations and to distinguish various types.','line_number':86,'multiline':False]
['text':' For version 0, we simply equate AnyRef and JSObject* (this means that there','line_number':88,'multiline':False]
['text':' are technically no tags at all yet).  We use a simple boxing scheme that','line_number':89,'multiline':False]
['text':' wraps a JS value that is not already JSObject in a distinguishable JSObject','line_number':90,'multiline':False]
['text':' that holds the value, see WasmTypes.cpp for details.  Knowledge of this','line_number':91,'multiline':False]
['text':' mapping is embedded in CodeGenerator.cpp (in WasmBoxValue and','line_number':92,'multiline':False]
['text':' WasmAnyRefFromJSObject) and in WasmStubs.cpp (in functions Box* and Unbox*).','line_number':93,'multiline':False]
['text':' mutable so that tracing may access a JSObject* from a `const Val` or','line_number':96,'multiline':False]
['text':' `const AnyRef`.','line_number':97,'multiline':False]
['text':' An invalid AnyRef cannot arise naturally from wasm and so can be used as','line_number':106,'multiline':False]
['text':' a sentinel value to indicate failure from an AnyRef-returning function.','line_number':107,'multiline':False]
['text':' Given a void* that comes from compiled wasm code, turn it into AnyRef.','line_number':110,'multiline':False]
['text':' Given a JSObject* that comes from JS, turn it into AnyRef.','line_number':113,'multiline':False]
['text':' Generate an AnyRef null pointer.','line_number':116,'multiline':False]
['text':' Tags (to be developed further)','line_number':135,'multiline':False]
['text':' TODO/AnyRef-boxing: With boxed immediates and strings, these will be defined','line_number':144,'multiline':False]
['text':' as MOZ_CRASH or similar so that we can find all locations that need to be','line_number':145,'multiline':False]
['text':' fixed.','line_number':146,'multiline':False]
['text':' Given any JS value, box it as an AnyRef and store it in *result.  Returns','line_number':151,'multiline':False]
['text':' false on OOM.','line_number':152,'multiline':False]
['text':' Given a JS value that requires an object box, box it as an AnyRef and return','line_number':156,'multiline':False]
['text':' it, returning nullptr on OOM.','line_number':157,'multiline':False]
['text':'','line_number':158,'multiline':False]
['text':' Currently the values requiring a box are those other than JSObject* or','line_number':159,'multiline':False]
['text':' nullptr, but in the future more values will be represented without an','line_number':160,'multiline':False]
['text':' allocation.','line_number':161,'multiline':False]
['text':' Given any AnyRef, unbox it as a JS Value.  If it is a reference to a wasm','line_number':164,'multiline':False]
['text':' object it will be reflected as a JSObject* representing some TypedObject','line_number':165,'multiline':False]
['text':' instance.','line_number':166,'multiline':False]
['text':' A FuncRef is a JSFunction* and is hence also an AnyRef, and the remarks above','line_number':184,'multiline':False]
['text':' about AnyRef apply also to FuncRef.  When 'funcref' is used as a value type','line_number':185,'multiline':False]
['text':' in wasm code, the value that is held is "the canonical function value", which','line_number':186,'multiline':False]
['text':' is a function for which IsWasmExportedFunction() is true, and which has the','line_number':187,'multiline':False]
['text':' correct identity wrt reference equality of functions.  Notably, if a function','line_number':188,'multiline':False]
['text':' is imported then its ref.func value compares === in JS to the function that','line_number':189,'multiline':False]
['text':' was passed as an import when the instance was created.','line_number':190,'multiline':False]
['text':'','line_number':191,'multiline':False]
['text':' These rules ensure that casts from funcref to anyref are non-converting','line_number':192,'multiline':False]
['text':' (generate no code), and that no wrapping or unwrapping needs to happen when a','line_number':193,'multiline':False]
['text':' funcref or anyref flows across the JS/wasm boundary, and that functions have','line_number':194,'multiline':False]
['text':' the necessary identity when observed from JS, and in the future, from wasm.','line_number':195,'multiline':False]
['text':'','line_number':196,'multiline':False]
['text':' Functions stored in tables, whether wasm tables or internal tables, can be','line_number':197,'multiline':False]
['text':' stored in a form that optimizes for eg call speed, however.','line_number':198,'multiline':False]
['text':'','line_number':199,'multiline':False]
['text':' Reading a funcref from a funcref table, writing a funcref to a funcref table,','line_number':200,'multiline':False]
['text':' and generating the value for a ref.func instruction are therefore nontrivial','line_number':201,'multiline':False]
['text':' operations that require mapping between the canonical JSFunction and the','line_number':202,'multiline':False]
['text':' optimized table representation.  Once we get an instruction to call a','line_number':203,'multiline':False]
['text':' ref.func directly it too will require such a mapping.','line_number':204,'multiline':False]
['text':' In many cases, a FuncRef is exactly the same as AnyRef and we can use AnyRef','line_number':206,'multiline':False]
['text':' functionality on funcref values.  The FuncRef class exists mostly to add more','line_number':207,'multiline':False]
['text':' checks and to make it clear, when we need to, that we're manipulating funcref','line_number':208,'multiline':False]
['text':' values.  FuncRef does not currently subclass AnyRef because there's been no','line_number':209,'multiline':False]
['text':' need to, but it probably could.','line_number':210,'multiline':False]
['text':' Given a void* that comes from compiled wasm code, turn it into FuncRef.','line_number':221,'multiline':False]
['text':' Given a JSFunction* that comes from JS, turn it into FuncRef.','line_number':224,'multiline':False]
['text':' Given an AnyRef that represents a possibly-null funcref, turn it into a','line_number':227,'multiline':False]
['text':' FuncRef.','line_number':228,'multiline':False]
['text':' Given any FuncRef, unbox it as a JS Value -- always a JSFunction*.','line_number':244,'multiline':False]
['text':' The LitVal class represents a single WebAssembly value of a given value','line_number':248,'multiline':False]
['text':' type, mostly for the purpose of numeric literals and initializers. A LitVal','line_number':249,'multiline':False]
['text':' does not directly map to a JS value since there is not (currently) a precise','line_number':250,'multiline':False]
['text':' representation of i64 values. A LitVal may contain non-canonical NaNs since,','line_number':251,'multiline':False]
['text':' within WebAssembly, floats are not canonicalized. Canonicalization must','line_number':252,'multiline':False]
['text':' happen at the JS boundary.','line_number':253,'multiline':False]
['text':' A Val is a LitVal that can contain (non-null) pointers to GC things. All Vals','line_number':355,'multiline':False]
['text':' must be used with the rooting APIs as they may contain JS objects.','line_number':356,'multiline':False]
['text':' See the comment for `ToWebAssemblyValue` below.','line_number':420,'multiline':False]
['text':' See the comment for `ToJSValue` below.','line_number':423,'multiline':False]
['text':' Check a value against the given reference type.  If the targetType','line_number':439,'multiline':False]
['text':' is RefType::Extern then the test always passes, but the value may be boxed.','line_number':440,'multiline':False]
['text':' If the test passes then the value is stored either in fnval (for','line_number':441,'multiline':False]
['text':' RefType::Func) or in refval (for other types); this split is not strictly','line_number':442,'multiline':False]
['text':' necessary but is convenient for the users of this function.','line_number':443,'multiline':False]
['text':'','line_number':444,'multiline':False]
['text':' This can return false if the type check fails, or if a boxing into AnyRef','line_number':445,'multiline':False]
['text':' throws an OOM.','line_number':446,'multiline':False]
['text':' The same as above for when the target type is 'funcref'.','line_number':452,'multiline':False]
['text':' The same as above for when the target type is 'eqref'.','line_number':456,'multiline':False]
['text':' The level of coercion to apply in `ToWebAssemblyValue` and `ToJSValue`.','line_number':462,'multiline':False]
['text':' The default coercions given by the JS-API specification.','line_number':464,'multiline':False]
['text':' Allow for the coercions given by `Spec` but also use WebAssembly.Global','line_number':466,'multiline':False]
['text':' as a container for lossless conversions. This is only available through','line_number':467,'multiline':False]
['text':' the wasmLosslessInvoke testing function and is used in tests.','line_number':468,'multiline':False]
['text':' Coercion function from a JS value to a WebAssembly value [1].','line_number':472,'multiline':False]
['text':'','line_number':473,'multiline':False]
['text':' This function may fail for any of the following reasons:','line_number':474,'multiline':False]
['text':'  * The input value has an incorrect type for the targetType','line_number':475,'multiline':False]
['text':'  * The targetType is not exposable','line_number':476,'multiline':False]
['text':'  * An OOM ocurred','line_number':477,'multiline':False]
['text':' An error will be set upon failure.','line_number':478,'multiline':False]
['text':'','line_number':479,'multiline':False]
['text':' [1] https://webassembly.github.io/spec/js-api/index.html#towebassemblyvalue','line_number':480,'multiline':False]
['text':' Coercion function from a WebAssembly value to a JS value [1].','line_number':490,'multiline':False]
['text':'','line_number':491,'multiline':False]
['text':' This function will only fail if an OOM ocurred. If the type of WebAssembly','line_number':492,'multiline':False]
['text':' value being coerced is not exposable to JS, then it will be coerced to','line_number':493,'multiline':False]
['text':' 'undefined'. Callers are responsible for guarding against this if this is','line_number':494,'multiline':False]
['text':' not desirable.','line_number':495,'multiline':False]
['text':'','line_number':496,'multiline':False]
['text':' [1] https://webassembly.github.io/spec/js-api/index.html#tojsvalue','line_number':497,'multiline':False]
['text':' namespace wasm','line_number':507,'multiline':False]
['text':' namespace js','line_number':547,'multiline':False]
['text':' wasm_val_h','line_number':549,'multiline':False]
