['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' The value we want to extract is in the low double-word','line_number':57,'multiline':False]
['text':' The value we want to extract is in the low double-word','line_number':69,'multiline':False]
['text':' The value we want to extract is in the low quadword','line_number':86,'multiline':False]
['text':' no-op, although this should not normally happen for type checking','line_number':126,'multiline':False]
['text':' reasons higher up in the stack.','line_number':127,'multiline':False]
['text':' move low dword of value into low dword of output','line_number':129,'multiline':False]
['text':' no-op, although this should not normally happen for type checking','line_number':144,'multiline':False]
['text':' reasons higher up in the stack.','line_number':145,'multiline':False]
['text':' move low qword of value into low qword of output','line_number':147,'multiline':False]
['text':' move low qword of value into high qword of output','line_number':151,'multiline':False]
['text':' Use pshufb instructions to gather the lanes from each source vector.','line_number':188,'multiline':False]
['text':' A negative index creates a zero lane, so the two vectors can be combined.','line_number':189,'multiline':False]
['text':' Register preference: lhs == output.','line_number':191,'multiline':False]
['text':' Set scratch = lanes from rhs.','line_number':193,'multiline':False]
['text':' Set output = lanes from lhs.','line_number':201,'multiline':False]
['text':' Combine.','line_number':208,'multiline':False]
['text':' This is bad, but Ion does not use it.','line_number':229,'multiline':False]
['text':' src := rhs','line_number':230,'multiline':False]
['text':' src := src > lhs (i.e. lhs < rhs)','line_number':236,'multiline':False]
['text':' This is bad, but Ion does not use it.','line_number':247,'multiline':False]
['text':' src := rhs','line_number':248,'multiline':False]
['text':' lhs <= rhs is equivalent to !(rhs < lhs), which we compute here.','line_number':260,'multiline':False]
['text':' This is bad, but Ion does not use it.','line_number':328,'multiline':False]
['text':' src := rhs','line_number':329,'multiline':False]
['text':' src := src > lhs (i.e. lhs < rhs)','line_number':335,'multiline':False]
['text':' This is bad, but Ion does not use it.','line_number':346,'multiline':False]
['text':' src := rhs','line_number':347,'multiline':False]
['text':' lhs <= rhs is equivalent to !(rhs < lhs), which we compute here.','line_number':359,'multiline':False]
['text':' This is bad, but Ion does not use it.','line_number':426,'multiline':False]
['text':' src := rhs','line_number':427,'multiline':False]
['text':' src := src > lhs (i.e. lhs < rhs)','line_number':433,'multiline':False]
['text':' This is bad, but Ion does not use it.','line_number':444,'multiline':False]
['text':' src := rhs','line_number':445,'multiline':False]
['text':' lhs <= rhs is equivalent to !(rhs < lhs), which we compute here.','line_number':457,'multiline':False]
['text':' The pseudo code is for (e.g. > comparison):','line_number':532,'multiline':False]
['text':'  __m128i pcmpgtq_sse2 (__m128i a, __m128i b) {','line_number':533,'multiline':False]
['text':'      __m128i r = _mm_and_si128(_mm_cmpeq_epi32(a, b), _mm_sub_epi64(b,','line_number':534,'multiline':False]
['text':'      a)); r = _mm_or_si128(r, _mm_cmpgt_epi32(a, b)); return','line_number':535,'multiline':False]
['text':'      _mm_shuffle_epi32(r, _MM_SHUFFLE(3,3,1,1));','line_number':536,'multiline':False]
['text':'  }','line_number':537,'multiline':False]
['text':' Credits to https://stackoverflow.com/a/65175746','line_number':538,'multiline':False]
['text':' Move lhs to output if lhs!=output; move rhs out of the way if rhs==output.','line_number':598,'multiline':False]
['text':' This is bad, but Ion does not need this fixup.','line_number':599,'multiline':False]
['text':' We reverse these operations in the -inl.h file so that we don't have to','line_number':625,'multiline':False]
['text':' copy into and out of temporaries after codegen.','line_number':626,'multiline':False]
['text':' Move lhs to output if lhs!=output; move rhs out of the way if rhs==output.','line_number':665,'multiline':False]
['text':' This is bad, but Ion does not need this fixup.','line_number':666,'multiline':False]
['text':' We reverse these operations in the -inl.h file so that we don't have to','line_number':692,'multiline':False]
['text':' copy into and out of temporaries after codegen.','line_number':693,'multiline':False]
['text':' Semantics of wasm max and min.','line_number':725,'multiline':False]
['text':'','line_number':726,'multiline':False]
['text':'  * -0 < 0','line_number':727,'multiline':False]
['text':'  * If one input is NaN then that NaN is the output','line_number':728,'multiline':False]
['text':'  * If both inputs are NaN then the output is selected nondeterministically','line_number':729,'multiline':False]
['text':'  * Any returned NaN is always made quiet','line_number':730,'multiline':False]
['text':'  * The MVP spec 2.2.3 says "No distinction is made between signalling and','line_number':731,'multiline':False]
['text':'    quiet NaNs", suggesting SNaN inputs are allowed and should not fault','line_number':732,'multiline':False]
['text':'','line_number':733,'multiline':False]
['text':' Semantics of maxps/minps/maxpd/minpd:','line_number':734,'multiline':False]
['text':'','line_number':735,'multiline':False]
['text':'  * If the values are both +/-0 the rhs is returned','line_number':736,'multiline':False]
['text':'  * If the rhs is SNaN then the rhs is returned','line_number':737,'multiline':False]
['text':'  * If either value is NaN then the rhs is returned','line_number':738,'multiline':False]
['text':'  * An SNaN operand does not appear to give rise to an exception, at least','line_number':739,'multiline':False]
['text':'    not in the JS shell on Linux, though the Intel spec lists Invalid','line_number':740,'multiline':False]
['text':'    as one of the possible exceptions','line_number':741,'multiline':False]
['text':' Various unaddressed considerations:','line_number':743,'multiline':False]
['text':'','line_number':744,'multiline':False]
['text':' It's pretty insane for this to take an Operand rhs - it really needs to be','line_number':745,'multiline':False]
['text':' a register, given the number of times we access it.','line_number':746,'multiline':False]
['text':'','line_number':747,'multiline':False]
['text':' Constant load can be folded into the ANDPS.  Do we care?  It won't save us','line_number':748,'multiline':False]
['text':' any registers, since output/temp1/temp2/scratch are all live at the same time','line_number':749,'multiline':False]
['text':' after the first instruction of the slow path.','line_number':750,'multiline':False]
['text':'','line_number':751,'multiline':False]
['text':' Can we use blend for the NaN extraction/insertion?  We'd need xmm0 for the','line_number':752,'multiline':False]
['text':' mask, which is no fun.  But it would be lhs UNORD lhs -> mask, blend;','line_number':753,'multiline':False]
['text':' rhs UNORD rhs -> mask; blend.  Better than the mess we have below.  But','line_number':754,'multiline':False]
['text':' we'd still need to setup the QNaN bits, unless we can blend those too','line_number':755,'multiline':False]
['text':' with the lhs UNORD rhs mask?','line_number':756,'multiline':False]
['text':'','line_number':757,'multiline':False]
['text':' If we could determine that both input lanes are NaN then the result of the','line_number':758,'multiline':False]
['text':' fast path should be fine modulo the QNaN bits, but it's not obvious this is','line_number':759,'multiline':False]
['text':' much of an advantage.','line_number':760,'multiline':False]
['text':' clang-format off ','line_number':770,'multiline':True]
['text':' leave my comments alone ','line_number':770,'multiline':True]
['text':' compute','line_number':773,'multiline':False]
['text':'   min lhs, rhs','line_number':774,'multiline':False]
['text':' compute','line_number':775,'multiline':False]
['text':'   min rhs, lhs','line_number':776,'multiline':False]
['text':' fix min(-0, 0) with OR','line_number':777,'multiline':False]
['text':' compute','line_number':779,'multiline':False]
['text':'   max lhs, rhs','line_number':780,'multiline':False]
['text':' compute','line_number':781,'multiline':False]
['text':'   max rhs, lhs','line_number':782,'multiline':False]
['text':' fix max(-0, 0) with AND','line_number':783,'multiline':False]
['text':' compute','line_number':785,'multiline':False]
['text':'   lhs UNORD rhs','line_number':786,'multiline':False]
['text':' check if any unordered','line_number':787,'multiline':False]
['text':'   and exit if not','line_number':788,'multiline':False]
['text':' Slow path.','line_number':790,'multiline':False]
['text':' output has result for non-NaN lanes, garbage in NaN lanes.','line_number':791,'multiline':False]
['text':' temp1 has lhs UNORD rhs.','line_number':792,'multiline':False]
['text':' temp2 is dead.','line_number':793,'multiline':False]
['text':' clear NaN lanes of result','line_number':795,'multiline':False]
['text':'   result now in temp2','line_number':796,'multiline':False]
['text':' setup QNaN bits in NaN lanes','line_number':797,'multiline':False]
['text':'   and OR into result','line_number':798,'multiline':False]
['text':' find NaN lanes','line_number':799,'multiline':False]
['text':'   in lhs','line_number':800,'multiline':False]
['text':'     (and save them for later)','line_number':801,'multiline':False]
['text':'       and extract the NaNs','line_number':802,'multiline':False]
['text':'         and add to the result','line_number':803,'multiline':False]
['text':' find NaN lanes','line_number':804,'multiline':False]
['text':'   in rhs','line_number':805,'multiline':False]
['text':'     except if they were in lhs','line_number':806,'multiline':False]
['text':'       and extract the NaNs','line_number':807,'multiline':False]
['text':'         and add to the result','line_number':808,'multiline':False]
['text':' clang-format on ','line_number':811,'multiline':True]
['text':' Exactly as above.','line_number':814,'multiline':False]
['text':' clang-format off ','line_number':823,'multiline':True]
['text':' leave my comments alone ','line_number':823,'multiline':True]
['text':' compute','line_number':826,'multiline':False]
['text':'   min lhs, rhs','line_number':827,'multiline':False]
['text':' compute','line_number':828,'multiline':False]
['text':'   min rhs, lhs','line_number':829,'multiline':False]
['text':' fix min(-0, 0) with OR','line_number':830,'multiline':False]
['text':' compute','line_number':832,'multiline':False]
['text':'   max lhs, rhs','line_number':833,'multiline':False]
['text':' compute','line_number':834,'multiline':False]
['text':'   max rhs, lhs','line_number':835,'multiline':False]
['text':' fix max(-0, 0) with AND','line_number':836,'multiline':False]
['text':' compute','line_number':838,'multiline':False]
['text':'   lhs UNORD rhs','line_number':839,'multiline':False]
['text':' check if any unordered','line_number':840,'multiline':False]
['text':'   and exit if not','line_number':841,'multiline':False]
['text':' Slow path.','line_number':843,'multiline':False]
['text':' output has result for non-NaN lanes, garbage in NaN lanes.','line_number':844,'multiline':False]
['text':' temp1 has lhs UNORD rhs.','line_number':845,'multiline':False]
['text':' temp2 is dead.','line_number':846,'multiline':False]
['text':' clear NaN lanes of result','line_number':848,'multiline':False]
['text':'   result now in temp2','line_number':849,'multiline':False]
['text':' setup QNaN bits in NaN lanes','line_number':850,'multiline':False]
['text':'   and OR into result','line_number':851,'multiline':False]
['text':' find NaN lanes','line_number':852,'multiline':False]
['text':'   in lhs','line_number':853,'multiline':False]
['text':'     (and save them for later)','line_number':854,'multiline':False]
['text':'       and extract the NaNs','line_number':855,'multiline':False]
['text':'         and add to the result','line_number':856,'multiline':False]
['text':' find NaN lanes','line_number':857,'multiline':False]
['text':'   in rhs','line_number':858,'multiline':False]
['text':'     except if they were in lhs','line_number':859,'multiline':False]
['text':'       and extract the NaNs','line_number':860,'multiline':False]
['text':'         and add to the result','line_number':861,'multiline':False]
['text':' clang-format on ','line_number':864,'multiline':True]
['text':'isMin=','line_number':871,'multiline':True]
['text':'isMin=','line_number':878,'multiline':True]
['text':'isMin=','line_number':885,'multiline':True]
['text':'isMin=','line_number':892,'multiline':True]
['text':' High bytes','line_number':912,'multiline':False]
['text':' Low bytes','line_number':917,'multiline':False]
['text':' Mask off garbage to avoid saturation during packing','line_number':921,'multiline':False]
['text':' Use the doubling trick for low shift counts, otherwise mask off the bits','line_number':942,'multiline':False]
['text':' that are shifted out of the low byte of each word and use word shifts.  The','line_number':943,'multiline':False]
['text':' optimal cutoff remains to be explored.','line_number':944,'multiline':False]
['text':' Invert if negative, shift all, invert back if negative.','line_number':1049,'multiline':False]
['text':' Invert if negative, shift all, invert back if negative.','line_number':1067,'multiline':False]
['text':' Normally the codegen will attempt to enforce these register assignments so','line_number':1078,'multiline':False]
['text':' that the moves are avoided.','line_number':1079,'multiline':False]
['text':' Code sequences for int32x4<->float32x4 culled from v8; commentary added.','line_number':1089,'multiline':False]
['text':' extract low bits','line_number':1095,'multiline':False]
['text':'   into scratch','line_number':1096,'multiline':False]
['text':'     and high bits into dest','line_number':1097,'multiline':False]
['text':' convert low bits','line_number':1098,'multiline':False]
['text':' get high into unsigned range','line_number':1099,'multiline':False]
['text':'   convert','line_number':1100,'multiline':False]
['text':'     and back into signed','line_number':1101,'multiline':False]
['text':' combine high+low: may round','line_number':1102,'multiline':False]
['text':' The cvttps2dq instruction is the workhorse but does not handle NaN or out','line_number':1110,'multiline':False]
['text':' of range values as we need it to.  We want to saturate too-large positive','line_number':1111,'multiline':False]
['text':' values to 7FFFFFFFh and too-large negative values to 80000000h.  NaN and -0','line_number':1112,'multiline':False]
['text':' become 0.','line_number':1113,'multiline':False]
['text':' Convert NaN to 0 by masking away values that compare unordered to itself.','line_number':1115,'multiline':False]
['text':' Compute the complement of each non-NaN lane's sign bit, we'll need this to','line_number':1120,'multiline':False]
['text':' correct the result of cvttps2dq.  All other output bits are garbage.','line_number':1121,'multiline':False]
['text':' Convert.  This will make the output 80000000h if the input is out of range.','line_number':1124,'multiline':False]
['text':' Preserve the computed complemented sign bit if the output was 80000000h.','line_number':1127,'multiline':False]
['text':' The sign bit will be 1 precisely for nonnegative values that overflowed.','line_number':1128,'multiline':False]
['text':' Create a mask with that sign bit.  Now a lane is either FFFFFFFFh if there','line_number':1131,'multiline':False]
['text':' was a positive overflow, otherwise zero.','line_number':1132,'multiline':False]
['text':' Convert overflow lanes to 0x7FFFFFFF.','line_number':1135,'multiline':False]
['text':' The cvttps2dq instruction is the workhorse but does not handle NaN or out','line_number':1144,'multiline':False]
['text':' of range values as we need it to.  We want to saturate too-large positive','line_number':1145,'multiline':False]
['text':' values to FFFFFFFFh and negative values to zero.  NaN and -0 become 0.','line_number':1146,'multiline':False]
['text':' Convert NaN and negative values to zeroes in dest.','line_number':1148,'multiline':False]
['text':' Place the largest positive signed integer in all lanes in scratch.','line_number':1152,'multiline':False]
['text':' We use it to bias the conversion to handle edge cases.','line_number':1153,'multiline':False]
['text':' temp = dest - 7FFFFFFFh (as floating), this brings integers in the unsigned','line_number':1157,'multiline':False]
['text':' range but above the signed range into the signed range; 0 => -7FFFFFFFh.','line_number':1158,'multiline':False]
['text':' scratch = mask of biased values that are greater than 7FFFFFFFh.','line_number':1162,'multiline':False]
['text':' Convert the biased values to integer.  Positive values above 7FFFFFFFh will','line_number':1165,'multiline':False]
['text':' have been converted to 80000000h, all others become the expected integer.','line_number':1166,'multiline':False]
['text':' As lanes of scratch are ~0 where the result overflows, this computes','line_number':1169,'multiline':False]
['text':' 7FFFFFFF in lanes of temp that are 80000000h, and leaves other lanes','line_number':1170,'multiline':False]
['text':' untouched as the biased integer.','line_number':1171,'multiline':False]
['text':' Convert negative biased lanes in temp to zero.  After this, temp will be','line_number':1174,'multiline':False]
['text':' zero where the result should be zero or is less than 80000000h, 7FFFFFFF','line_number':1175,'multiline':False]
['text':' where the result overflows, and will have the converted biased result in','line_number':1176,'multiline':False]
['text':' other lanes (for input values >= 80000000h).','line_number':1177,'multiline':False]
['text':' Convert. Overflow lanes above 7FFFFFFFh will be 80000000h, other lanes will','line_number':1181,'multiline':False]
['text':' be what they should be.','line_number':1182,'multiline':False]
['text':' Add temp to the result.  Overflow lanes with 80000000h becomes FFFFFFFFh,','line_number':1185,'multiline':False]
['text':' biased high-value unsigned lanes become unbiased, everything else is left','line_number':1186,'multiline':False]
['text':' unchanged.','line_number':1187,'multiline':False]
