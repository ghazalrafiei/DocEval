['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' JS::ExpandoAndGeneration','line_number':34,'multiline':False]
['text':' js::jit::GetXrayJitInfo','line_number':35,'multiline':False]
['text':' js::Scalar::Type','line_number':36,'multiline':False]
['text':' js::FunctionFlags','line_number':43,'multiline':False]
['text':' Temporarily add the payload register to currentOpRegs_ so','line_number':95,'multiline':False]
['text':' allocateValueRegister will stay away from it.','line_number':96,'multiline':False]
['text':' Load a value operand directly into a float register. Caller must have','line_number':131,'multiline':False]
['text':' guarded isNumber on the provided val.','line_number':132,'multiline':False]
['text':' If AutoScratchFloatRegister is active, we have to add sizeof(double) to','line_number':136,'multiline':False]
['text':' any stack slot offsets below.','line_number':137,'multiline':False]
['text':' Doubles can't be stored in payload registers, so this must be an int32.','line_number':176,'multiline':False]
['text':' Doubles can't be stored in payload registers, so this must be an int32.','line_number':184,'multiline':False]
['text':' If AutoScratchFloatRegister is active, we have to add sizeof(double) to','line_number':208,'multiline':False]
['text':' any stack slot offsets below.','line_number':209,'multiline':False]
['text':' It's possible the value is still boxed: as an optimization, we unbox','line_number':306,'multiline':False]
['text':' the first time we use a value as object.','line_number':307,'multiline':False]
['text':' The value is on the stack, but boxed. If it's on top of the stack we','line_number':325,'multiline':False]
['text':' unbox it and then remove it from the stack, else we just unbox.','line_number':326,'multiline':False]
['text':' See if any operands are dead so we can reuse their registers. Note that','line_number':437,'multiline':False]
['text':' we skip the input operands, as those are also used by failure paths, and','line_number':438,'multiline':False]
['text':' we currently don't track those uses.','line_number':439,'multiline':False]
['text':' This should only be called when we are no longer using the operands,','line_number':471,'multiline':False]
['text':' as we're discarding everything from the native stack. Set all operand','line_number':472,'multiline':False]
['text':' locations to Uninitialized to catch bugs.','line_number':473,'multiline':False]
['text':' Still no registers available, try to spill unused operands to','line_number':495,'multiline':False]
['text':' the stack.','line_number':496,'multiline':False]
['text':' We got a register, so break out of the loop.','line_number':507,'multiline':False]
['text':' Break out of the loop.','line_number':517,'multiline':False]
['text':' At this point, there must be a free register.','line_number':532,'multiline':False]
['text':' Fixed registers should be allocated first, to ensure they're','line_number':545,'multiline':False]
['text':' still available.','line_number':546,'multiline':False]
['text':' Register may be available only after spilling contents.','line_number':557,'multiline':False]
['text':' The register must be used by some operand. Spill it to the stack.','line_number':568,'multiline':False]
['text':' Possible miscompilation in clang-12 (bug 1689641)','line_number':609,'multiline':False]
['text':' Registers not in availableRegs_ and not used by input operands are','line_number':635,'multiline':False]
['text':' available after being spilled.','line_number':636,'multiline':False]
['text':' If IC inputs alias each other, make sure they are stored in different','line_number':643,'multiline':False]
['text':' locations so we don't have to deal with this complexity in the rest of','line_number':644,'multiline':False]
['text':' the allocator.','line_number':645,'multiline':False]
['text':'','line_number':646,'multiline':False]
['text':' Note that this can happen in IonMonkey with something like |o.foo = o|','line_number':647,'multiline':False]
['text':' or |o[i] = i|.','line_number':648,'multiline':False]
['text':' loc1 and loc2 alias so we spill one of them. If one is a','line_number':665,'multiline':False]
['text':' ValueReg and the other is a PayloadReg, we have to spill the','line_number':666,'multiline':False]
['text':' PayloadReg: spilling the ValueReg instead would leave its type','line_number':667,'multiline':False]
['text':' register unallocated on 32-bit platforms.','line_number':668,'multiline':False]
['text':' Spilled loc1, so nothing else will alias it.','line_number':674,'multiline':False]
['text':' If enough registers are available, use them.','line_number':801,'multiline':False]
['text':' Not enough registers available, spill to the stack.','line_number':820,'multiline':False]
['text':' The payload is on the stack. If it's on top of the stack we can just','line_number':829,'multiline':False]
['text':' pop it, else we emit a load.','line_number':830,'multiline':False]
['text':' The Value is on the stack. If it's on top of the stack we can just','line_number':860,'multiline':False]
['text':' pop it, else we emit a load.','line_number':861,'multiline':False]
['text':' Assert different operands don't have aliasing storage. We depend on this','line_number':878,'multiline':False]
['text':' when spilling registers, for instance.','line_number':879,'multiline':False]
['text':' We have a cycle if a destination register will be used later','line_number':937,'multiline':False]
['text':' as source register. If that happens, just push the current value','line_number':938,'multiline':False]
['text':' on the stack and later get it from there.','line_number':939,'multiline':False]
['text':' We have to restore a Value register.','line_number':948,'multiline':False]
['text':' We have to restore a payload register.','line_number':974,'multiline':False]
['text':' Nothing to do.','line_number':1007,'multiline':False]
['text':' For CCW IC stubs, we can store same-zone but cross-compartment','line_number':1191,'multiline':False]
['text':' shapes. Use TraceSameZoneCrossCompartmentEdge to not assert in the','line_number':1192,'multiline':False]
['text':' GC. Note: CacheIRWriter::writeShapeField asserts we never store','line_number':1193,'multiline':False]
['text':' cross-zone shapes.','line_number':1194,'multiline':False]
['text':' Done.','line_number':1235,'multiline':False]
['text':' +1 for the GCType::Limit terminator.','line_number':1310,'multiline':False]
['text':' Copy the CacheIR code.','line_number':1316,'multiline':False]
['text':' Copy the stub field types.','line_number':1323,'multiline':False]
['text':' Reuse the previous failure path if the current one is the same, to','line_number':1422,'multiline':False]
['text':' avoid emitting duplicate code.','line_number':1423,'multiline':False]
['text':' Doubles and ints are numbers!','line_number':1461,'multiline':False]
['text':' Infallible |emitDouble| emitters can use this implementation to avoid','line_number':1648,'multiline':False]
['text':' generating extra clean-up instructions to restore the scratch float register.','line_number':1649,'multiline':False]
['text':' To select this function simply omit the |Label* fail| parameter for the','line_number':1650,'multiline':False]
['text':' emitter lambda function.','line_number':1651,'multiline':False]
['text':' No-op if the value is already an int32.','line_number':1731,'multiline':False]
['text':' ToPropertyKey(-0.0) is "0", so we can truncate -0.0 to 0 here.','line_number':1734,'multiline':False]
['text':' ToPropertyKey(-0.0) is "0", so we can truncate -0.0 to 0 here.','line_number':1769,'multiline':False]
['text':' Substitute the invalid index with an arbitrary out-of-bounds index.','line_number':1775,'multiline':False]
['text':' No-op if the value is already an int32.','line_number':1813,'multiline':False]
['text':' |output| holds the unboxed int32 value.','line_number':1849,'multiline':False]
['text':' Allocate registers before the failure path to make sure they're registered','line_number':1991,'multiline':False]
['text':' by addFailurePath.','line_number':1992,'multiline':False]
['text':' Guard on the expected object.','line_number':2001,'multiline':False]
['text':' Load obj->elements.','line_number':2176,'multiline':False]
['text':' Make sure there are no dense elements.','line_number':2179,'multiline':False]
['text':' Use indexed value as fast path if possible.','line_number':2216,'multiline':False]
['text':' Reserve stack for holding the result value of the call.','line_number':2223,'multiline':False]
['text':' We cannot use callVM, as callVM expects to be able to clobber all','line_number':2227,'multiline':False]
['text':' operands, however, since this op is not the last in the generated IC, we','line_number':2228,'multiline':False]
['text':' want to be able to reference other live values.','line_number':2229,'multiline':False]
['text':' OOM path, recovered by StringToNumberPure.','line_number':2250,'multiline':False]
['text':'','line_number':2251,'multiline':False]
['text':' Use addToStackPtr instead of freeStack as freeStack tracks stack height','line_number':2252,'multiline':False]
['text':' flow-insensitively, and using it twice would confuse the stack height','line_number':2253,'multiline':False]
['text':' tracking.','line_number':2254,'multiline':False]
['text':' GetIndexFromString returns a negative value on failure.','line_number':2311,'multiline':False]
['text':' We shouldn't encounter a null or lazy proto.','line_number':2326,'multiline':False]
['text':' Determine the expando's Address.','line_number':2392,'multiline':False]
['text':' Private values are stored as doubles, so assert we have a double.','line_number':2399,'multiline':False]
['text':' Load the ExpandoAndGeneration* from the PrivateValue.','line_number':2406,'multiline':False]
['text':' Load expandoAndGeneration->expando into the output Value register.','line_number':2409,'multiline':False]
['text':' Guard length fits in an int32.','line_number':2480,'multiline':False]
['text':' Guard length fits in an int32.','line_number':2500,'multiline':False]
['text':' Float register must be preserved. The BinaryArith ICs use','line_number':2510,'multiline':False]
['text':' the fact that baseline has them available, as well as fixed temps on','line_number':2511,'multiline':False]
['text':' LBinaryCache.','line_number':2512,'multiline':False]
['text':' Result is -0 if exactly one of lhs or rhs is negative.','line_number':2695,'multiline':False]
['text':' Prevent division by 0.','line_number':2718,'multiline':False]
['text':' Prevent -2147483648 / -1.','line_number':2721,'multiline':False]
['text':' Prevent negative 0.','line_number':2727,'multiline':False]
['text':' A remainder implies a double result.','line_number':2738,'multiline':False]
['text':' x % 0 results in NaN','line_number':2757,'multiline':False]
['text':' Prevent -2147483648 % -1.','line_number':2760,'multiline':False]
['text':'','line_number':2761,'multiline':False]
['text':' Traps on x86 and has undefined behavior on ARM32 (when __aeabi_idivmod is','line_number':2762,'multiline':False]
['text':' called).','line_number':2763,'multiline':False]
['text':' Modulo takes the sign of the dividend; we can't return negative zero here.','line_number':2774,'multiline':False]
['text':' Guard against 0 and MIN_INT by checking if low 31-bits are all zero.','line_number':2920,'multiline':False]
['text':' Both of these result in a double.','line_number':2921,'multiline':False]
['text':' Bug 1451976','line_number':3180,'multiline':False]
['text':' Get the JSFunction flags.','line_number':3291,'multiline':False]
['text':' Functions with a SelfHostedLazyScript must be compiled with the slow-path','line_number':3294,'multiline':False]
['text':' before the function length is known. If the length was previously resolved,','line_number':3295,'multiline':False]
['text':' the length property may be shadowed.','line_number':3296,'multiline':False]
['text':' Bounds check, load string char.','line_number':3350,'multiline':False]
['text':' Load obj->elements.','line_number':3437,'multiline':False]
['text':' Bounds check.','line_number':3440,'multiline':False]
['text':' Hole check.','line_number':3444,'multiline':False]
['text':' Load obj->elements.','line_number':3477,'multiline':False]
['text':' Ensure index >= initLength.','line_number':3480,'multiline':False]
['text':' Load obj->elements.','line_number':3503,'multiline':False]
['text':' If length is writable, branch to &success.  All indices are writable.','line_number':3508,'multiline':False]
['text':' Otherwise, ensure index is in bounds.','line_number':3514,'multiline':False]
['text':' failure = ','line_number':3517,'multiline':True]
['text':' If both lhs and rhs are numbers, can't use tag comparison to do inequality','line_number':3536,'multiline':False]
['text':' comparison','line_number':3537,'multiline':False]
['text':' Unwrap the expando before checking its shape.','line_number':3571,'multiline':False]
['text':' The reserved slots on the expando should all be in fixed slots.','line_number':3582,'multiline':False]
['text':'isConstructing =','line_number':3657,'multiline':True]
['text':' Ensure obj is a constructor','line_number':3687,'multiline':False]
['text':' Make sure the index is nonnegative.','line_number':3753,'multiline':False]
['text':' Load obj->elements.','line_number':3756,'multiline':False]
['text':' Guard on the initialized length.','line_number':3759,'multiline':False]
['text':' Load the value.','line_number':3764,'multiline':False]
['text':' Load undefined for the hole.','line_number':3769,'multiline':False]
['text':' Bounds check.','line_number':3787,'multiline':False]
['text':' Load obj->elements.','line_number':3813,'multiline':False]
['text':' Bounds check. Unsigned compare sends negative indices to next IC.','line_number':3816,'multiline':False]
['text':' Hole check.','line_number':3820,'multiline':False]
['text':' Make sure the index is nonnegative.','line_number':3841,'multiline':False]
['text':' Load obj->elements.','line_number':3844,'multiline':False]
['text':' Guard on the initialized length.','line_number':3847,'multiline':False]
['text':' Load value and replace with true.','line_number':3852,'multiline':False]
['text':' Load false for the hole.','line_number':3859,'multiline':False]
['text':' Primitives are never callable.','line_number':3943,'multiline':False]
['text':' Don't negate already positive values.','line_number':4354,'multiline':False]
['text':' neg32 might overflow for INT_MIN.','line_number':4357,'multiline':False]
['text':' knownNotZero = ','line_number':4385,'multiline':True]
['text':' handleNaN = ','line_number':4787,'multiline':True]
['text':' handleNaN = ','line_number':4789,'multiline':True]
['text':' Load obj->elements in scratch.','line_number':4904,'multiline':False]
['text':' Bounds check. Unfortunately we don't have more registers available on','line_number':4907,'multiline':False]
['text':' x86, so use InvalidReg and emit slightly slower code on x86.','line_number':4908,'multiline':False]
['text':' Hole check.','line_number':4913,'multiline':False]
['text':' Perform the store.','line_number':4917,'multiline':False]
['text':' Preceding shape guards ensure the object elements are extensible.','line_number':4928,'multiline':False]
['text':' Preceding shape guards ensure the array length is writable.','line_number':4941,'multiline':False]
['text':' Load obj->elements in scratch.','line_number':4969,'multiline':False]
['text':' We don't have enough registers on x86 so use InvalidReg. This will emit','line_number':4981,'multiline':False]
['text':' slightly less efficient code on x86.','line_number':4982,'multiline':False]
['text':' Bounds check.','line_number':4987,'multiline':False]
['text':' If we're out-of-bounds, only handle the index == initLength case.','line_number':4992,'multiline':False]
['text':' If index < capacity, we can add a dense element inline. If not we','line_number':4996,'multiline':False]
['text':' need to allocate more elements.','line_number':4997,'multiline':False]
['text':' Load the reallocated elements pointer.','line_number':5021,'multiline':False]
['text':' Increment initLength.','line_number':5026,'multiline':False]
['text':' If length is now <= index, increment length too.','line_number':5029,'multiline':False]
['text':' Skip EmitPreBarrier as the memory is uninitialized.','line_number':5036,'multiline':False]
['text':' Fail if index >= initLength.','line_number':5041,'multiline':False]
['text':' Load obj->elements in scratch.','line_number':5069,'multiline':False]
['text':' Fail if length != initLength.','line_number':5080,'multiline':False]
['text':' If scratchLength < capacity, we can add a dense element inline. If not we','line_number':5085,'multiline':False]
['text':' need to allocate more elements.','line_number':5086,'multiline':False]
['text':' Load the reallocated elements pointer.','line_number':5109,'multiline':False]
['text':' Increment initLength and length.','line_number':5114,'multiline':False]
['text':' Store the value.','line_number':5118,'multiline':False]
['text':' Return value is new length.','line_number':5123,'multiline':False]
['text':' Bounds check.','line_number':5185,'multiline':False]
['text':' Load the elements vector.','line_number':5192,'multiline':False]
['text':' We don't have more registers available on x86, so spill |obj|.','line_number':5201,'multiline':False]
['text':' There are too few registers available on x86, so we may need to reuse the','line_number':5269,'multiline':False]
['text':' output's scratch register.','line_number':5270,'multiline':False]
['text':' Bounds check.','line_number':5279,'multiline':False]
['text':' Allocate BigInt if needed. The code after this should be infallible.','line_number':5285,'multiline':False]
['text':' Load the elements vector.','line_number':5301,'multiline':False]
['text':' Load the value.','line_number':5304,'multiline':False]
['text':' We don't have more registers available on x86, so spill |obj| and','line_number':5311,'multiline':False]
['text':' additionally use the output's type register.','line_number':5312,'multiline':False]
['text':' Ensure both offset < length and offset + (byteSize - 1) < length.','line_number':5349,'multiline':False]
['text':' temp := length - (byteSize - 1)','line_number':5354,'multiline':False]
['text':' if temp < 0: fail','line_number':5355,'multiline':False]
['text':' if offset >= temp: fail','line_number':5356,'multiline':False]
['text':' Load the value.','line_number':5390,'multiline':False]
['text':' Swap the bytes in the loaded value.','line_number':5420,'multiline':False]
['text':' Move the value into the output register.','line_number':5453,'multiline':False]
['text':' We need two extra registers. Reuse the obj/littleEndian registers.','line_number':5485,'multiline':False]
['text':' Use a scratch register to avoid running out of the registers.','line_number':5527,'multiline':False]
['text':' On platforms with enough registers, |scratch2| is an extra scratch register','line_number':5570,'multiline':False]
['text':' (pair) used for byte-swapping the value.','line_number':5571,'multiline':False]
['text':' Byte swapping has no effect, so just do the byte store.','line_number':5610,'multiline':False]
['text':' On 32-bit x86, |obj| is already a scratch register so use that. If we need','line_number':5616,'multiline':False]
['text':' a Register64 we also use the littleEndian register and use the stack','line_number':5617,'multiline':False]
['text':' location for the check below.','line_number':5618,'multiline':False]
['text':' Load the value into a gpr register.','line_number':5638,'multiline':False]
['text':' Swap the bytes in the loaded value.','line_number':5669,'multiline':False]
['text':' Store the value.','line_number':5703,'multiline':False]
['text':' Restore registers.','line_number':5727,'multiline':False]
['text':' Fall through to true case.','line_number':6093,'multiline':False]
['text':' signed = ','line_number':6119,'multiline':True]
['text':' signed = ','line_number':6151,'multiline':True]
['text':' Float register must be preserved. The Compare ICs use the fact that','line_number':6167,'multiline':False]
['text':' baseline has them available, as well as fixed temps on LBinaryBoolCache.','line_number':6168,'multiline':False]
['text':' Push the operands in reverse order for JSOp::Le and JSOp::Gt:','line_number':6207,'multiline':False]
['text':' - |left <= right| is implemented as |right >= left|.','line_number':6208,'multiline':False]
['text':' - |left > right| is implemented as |right < left|.','line_number':6209,'multiline':False]
['text':' Float register must be preserved. The Compare ICs use the fact that','line_number':6275,'multiline':False]
['text':' baseline has them available, as well as fixed temps on LBinaryBoolCache.','line_number':6276,'multiline':False]
['text':' Push the operands in reverse order for JSOp::Le and JSOp::Gt:','line_number':6289,'multiline':False]
['text':' - |left <= right| is implemented as |right >= left|.','line_number':6290,'multiline':False]
['text':' - |left > right| is implemented as |right < left|.','line_number':6291,'multiline':False]
['text':' Push the operands in reverse order for JSOp::Le and JSOp::Gt:','line_number':6360,'multiline':False]
['text':' - |left <= right| is implemented as |right >= left|.','line_number':6361,'multiline':False]
['text':' - |left > right| is implemented as |right < left|.','line_number':6362,'multiline':False]
['text':' The static_cast works around an internal compiler error in MSVC.','line_number':6381,'multiline':False]
['text':' The static_cast works around an internal compiler error in MSVC.','line_number':6391,'multiline':False]
['text':' The static_cast works around an internal compiler error in MSVC.','line_number':6401,'multiline':False]
['text':' The static_cast works around an internal compiler error in MSVC.','line_number':6411,'multiline':False]
['text':' The static_cast works around an internal compiler error in MSVC.','line_number':6421,'multiline':False]
['text':' The static_cast works around an internal compiler error in MSVC.','line_number':6432,'multiline':False]
['text':' iter->next = list','line_number':6551,'multiline':False]
['text':' iter->prev = list->prev','line_number':6554,'multiline':False]
['text':' list->prev->next = iter','line_number':6559,'multiline':False]
['text':' list->prev = ni','line_number':6562,'multiline':False]
['text':' Call one of these, depending on maybeIndex:','line_number':6593,'multiline':False]
['text':'','line_number':6594,'multiline':False]
['text':'   void PostWriteBarrier(JSRuntime* rt, JSObject* obj);','line_number':6595,'multiline':False]
['text':'   void PostWriteElementBarrier(JSRuntime* rt, JSObject* obj,','line_number':6596,'multiline':False]
['text':'                                int32_t index);','line_number':6597,'multiline':False]
['text':' We only have to wrap objects, because we are in the same zone.','line_number':6628,'multiline':False]
['text':' We could not get a wrapper for this object.','line_number':6649,'multiline':False]
['text':' We clobbered the output register, so we have to retag.','line_number':6652,'multiline':False]
['text':' The object must be Native.','line_number':6674,'multiline':False]
['text':' idVal will be in vp[0], result will be stored in vp[1].','line_number':6677,'multiline':False]
['text':' idVal will be in vp[0], result will be stored in vp[1].','line_number':6733,'multiline':False]
['text':'
 * Move a constant value into register dest.
 ','line_number':6823,'multiline':True]
['text':'
 * After this is done executing, dest contains the value; either through a
 * constant load or through the load from the stub data.
 *
 * The current policy is that Baseline will use loads from the stub data (to
 * allow IC sharing), where as Ion doesn't share ICs, and so we can safely use
 * constants in the IC.
 ','line_number':6857,'multiline':True]
['text':' LHS is an object. Load its proto.','line_number':6921,'multiline':False]
['text':' Walk the proto chain until we either reach the target object,','line_number':6924,'multiline':False]
['text':' nullptr or LazyProto.','line_number':6925,'multiline':False]
['text':' fallthrough','line_number':6945,'multiline':False]
['text':' The object must be Native.','line_number':6967,'multiline':False]
['text':' All values can be boxed as AnyRef.','line_number':7100,'multiline':False]
['text':' Check that the argument can be converted to the Wasm type in Warp code','line_number':7113,'multiline':False]
['text':' without bailing out.','line_number':7114,'multiline':False]
['text':' Argument must be number, bool, or undefined.','line_number':7120,'multiline':False]
['text':' Argument must be bigint, bool, or string.','line_number':7127,'multiline':False]
['text':' Float register must be preserved. The BinaryArith ICs use','line_number':7218,'multiline':False]
['text':' the fact that baseline has them available, as well as fixed temps on','line_number':7219,'multiline':False]
['text':' LBinaryCache.','line_number':7220,'multiline':False]
['text':' False case','line_number':7261,'multiline':False]
['text':' True case','line_number':7265,'multiline':False]
['text':' Test if it's an object.','line_number':7335,'multiline':False]
['text':' Test if it's a GeneratorObject.','line_number':7339,'multiline':False]
['text':' If the resumeIndex slot holds an int32 value < RESUME_INDEX_RUNNING,','line_number':7344,'multiline':False]
['text':' the generator is suspended.','line_number':7345,'multiline':False]
['text':' This op generates no code. It is consumed by the transpiler.','line_number':7362,'multiline':False]
['text':' nullptr MatchPairs.','line_number':7457,'multiline':False]
['text':' nullptr MatchPairs.','line_number':7481,'multiline':False]
['text':' Use a scratch register to avoid running out of registers.','line_number':7705,'multiline':False]
['text':' Not enough registers on X86.','line_number':7727,'multiline':False]
['text':' AutoCallVM's AutoSaveLiveRegisters aren't accounted for in FailurePath, so','line_number':7735,'multiline':False]
['text':' we can't use both at the same time. This isn't an issue here, because Ion','line_number':7736,'multiline':False]
['text':' doesn't support CallICs. If that ever changes, this code must be updated.','line_number':7737,'multiline':False]
['text':' Bounds check.','line_number':7740,'multiline':False]
['text':' Atomic operations are highly platform-dependent, for example x86/x64 has','line_number':7744,'multiline':False]
['text':' specific requirements on which registers are used; MIPS needs multiple','line_number':7745,'multiline':False]
['text':' additional temporaries. Therefore we're using either an ABI or VM call here','line_number':7746,'multiline':False]
['text':' instead of handling each platform separately.','line_number':7747,'multiline':False]
['text':' Not enough registers on X86.','line_number':7802,'multiline':False]
['text':' Bounds check.','line_number':7810,'multiline':False]
['text':' See comment in emitAtomicsCompareExchange for why we use an ABI call.','line_number':7814,'multiline':False]
['text':' Not enough registers on X86.','line_number':7852,'multiline':False]
['text':' AutoCallVM's AutoSaveLiveRegisters aren't accounted for in FailurePath, so','line_number':7860,'multiline':False]
['text':' we can't use both at the same time. This isn't an issue here, because Ion','line_number':7861,'multiline':False]
['text':' doesn't support CallICs. If that ever changes, this code must be updated.','line_number':7862,'multiline':False]
['text':' Bounds check.','line_number':7865,'multiline':False]
['text':' See comment in emitAtomicsCompareExchange for why we use a VM call.','line_number':7869,'multiline':False]
['text':' AutoCallVM's AutoSaveLiveRegisters aren't accounted for in FailurePath, so','line_number':7994,'multiline':False]
['text':' we can't use both at the same time. This isn't an issue here, because Ion','line_number':7995,'multiline':False]
['text':' doesn't support CallICs. If that ever changes, this code must be updated.','line_number':7996,'multiline':False]
['text':' Bounds check.','line_number':7999,'multiline':False]
['text':' Atomic operations are highly platform-dependent, for example x86/arm32 has','line_number':8003,'multiline':False]
['text':' specific requirements on which registers are used. Therefore we're using a','line_number':8004,'multiline':False]
['text':' VM call here instead of handling each platform separately.','line_number':8005,'multiline':False]
['text':' Load the elements vector.','line_number':8017,'multiline':False]
['text':' Load the value.','line_number':8020,'multiline':False]
['text':' Not enough registers on X86.','line_number':8054,'multiline':False]
['text':' Bounds check.','line_number':8062,'multiline':False]
['text':' Load the elements vector.','line_number':8067,'multiline':False]
['text':' Store the value.','line_number':8070,'multiline':False]
['text':' See comment in emitAtomicsCompareExchange for why we use an ABI call.','line_number':8081,'multiline':False]
['text':' Generates no code.','line_number':8156,'multiline':False]
['text':' NOP when not in IonMonkey','line_number':8167,'multiline':False]
['text':' Remove rest of the frame left on the stack. We remove the return address','line_number':8190,'multiline':False]
['text':' which is implicitly popped when returning.','line_number':8191,'multiline':False]
['text':' Pop arguments from framePushed.','line_number':8194,'multiline':False]
['text':' Baseline does not have any FloatRegisters live when calling an IC stub.','line_number':8227,'multiline':False]
['text':' Ion needs to `prepareVMCall` before it can callVM and it also needs to','line_number':8238,'multiline':False]
['text':' initialize AutoSaveLiveRegisters.','line_number':8239,'multiline':False]
['text':' Will need to use a downcast here as well, in order to pass the','line_number':8241,'multiline':False]
['text':' stub to AutoSaveLiveRegisters','line_number':8242,'multiline':False]
['text':' By convention VMFunctions returning `bool` use an output parameter.','line_number':8295,'multiline':False]
['text':' Definitions for the currently used return types.','line_number':8303,'multiline':False]
['text':' If we're compiling a Baseline IC, FloatReg0 is always available.','line_number':8362,'multiline':False]
