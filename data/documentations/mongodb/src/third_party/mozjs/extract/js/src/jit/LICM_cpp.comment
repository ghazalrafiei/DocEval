['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' There are two constants which control whether a loop is LICM'd or is left','line_number':17,'multiline':False]
['text':' unchanged.  For rationale see comment in jit::LICM() below.','line_number':18,'multiline':False]
['text':'','line_number':19,'multiline':False]
['text':' A bit of quick profiling with the wasm Embenchen suite on x64 shows that','line_number':20,'multiline':False]
['text':' the threshold pair (100,25) has either no effect or gives a small net','line_number':21,'multiline':False]
['text':' reduction in memory traffic, compared to unconstrained LICMing.  Halving','line_number':22,'multiline':False]
['text':' them to (50,12) gives a small overall increase in memory traffic,','line_number':23,'multiline':False]
['text':' suggesting it excludes too many loops from LICM.  Doubling them to (200,50)','line_number':24,'multiline':False]
['text':' gives a win that is even smaller than (100,25), hence (100,25) seems the','line_number':25,'multiline':False]
['text':' best choice.','line_number':26,'multiline':False]
['text':'','line_number':27,'multiline':False]
['text':' If a loop has more than this number of basic blocks in its body, it won't','line_number':28,'multiline':False]
['text':' be LICM'd.','line_number':29,'multiline':False]
['text':' If a loop contains an MTableSwitch instruction that has more than this many','line_number':32,'multiline':False]
['text':' successors, it won't be LICM'd.','line_number':33,'multiline':False]
['text':' Test whether any instruction in the loop possiblyCalls().','line_number':36,'multiline':False]
['text':' Tests whether any instruction in the loop is a table-switch with more than','line_number':66,'multiline':False]
['text':' `LargestAllowedTableSwitch` successors.  If it returns true, it also','line_number':67,'multiline':False]
['text':' returns the actual number of successors of the instruction in question,','line_number':68,'multiline':False]
['text':' although that is used only for statistics/debug printing.','line_number':69,'multiline':False]
['text':'OUT','line_number':71,'multiline':True]
['text':' When a nested loop has no exits back into what would be its parent loop,','line_number':99,'multiline':False]
['text':' MarkLoopBlocks on the parent loop doesn't mark the blocks of the nested','line_number':100,'multiline':False]
['text':' loop, since they technically aren't part of the loop. However, AliasAnalysis','line_number':101,'multiline':False]
['text':' currently does consider such nested loops to be part of their parent','line_number':102,'multiline':False]
['text':' loops. Consequently, we can't use IsInLoop on dependency() values; we must','line_number':103,'multiline':False]
['text':' test whether a dependency() is *before* the loop, even if it is not','line_number':104,'multiline':False]
['text':' technically in the loop.','line_number':105,'multiline':False]
['text':' Test whether the given instruction is inside the loop (and thus not','line_number':110,'multiline':False]
['text':' loop-invariant).','line_number':111,'multiline':False]
['text':' Test whether the given instruction is cheap and not worth hoisting unless','line_number':114,'multiline':False]
['text':' one of its users will be hoisted as well.','line_number':115,'multiline':False]
['text':' Integer constants are usually cheap and aren't worth hoisting on their','line_number':123,'multiline':False]
['text':' own, in general. Floating-point constants typically are worth hoisting,','line_number':124,'multiline':False]
['text':' unless they'll end up being spilled (eg. due to a call).','line_number':125,'multiline':False]
['text':' Test whether the given instruction has any operands defined within the loop.','line_number':133,'multiline':False]
['text':' An instruction is only loop invariant if it and all of its operands can','line_number':135,'multiline':False]
['text':' be safely hoisted into the loop preheader.','line_number':136,'multiline':False]
['text':' Recursively test for loop invariance. Note that the recursion is','line_number':145,'multiline':False]
['text':' bounded because we require RequiresHoistedUse to be set at each','line_number':146,'multiline':False]
['text':' level.','line_number':147,'multiline':False]
['text':' Test whether the given instruction is hoistable, ignoring memory','line_number':158,'multiline':False]
['text':' dependencies.','line_number':159,'multiline':False]
['text':' Test whether the given instruction has a memory dependency inside the loop.','line_number':165,'multiline':False]
['text':' Don't hoist if this instruction depends on a store inside the loop.','line_number':167,'multiline':False]
['text':' Test whether the given instruction is hoistable.','line_number':174,'multiline':False]
['text':' In preparation for hoisting an instruction, hoist any of its operands which','line_number':180,'multiline':False]
['text':' were too cheap to hoist on their own.','line_number':181,'multiline':False]
['text':' If any of our operands were waiting for a user to be hoisted, make a note','line_number':184,'multiline':False]
['text':' to hoist them.','line_number':185,'multiline':False]
['text':' Recursively move the operands. Note that the recursion is bounded','line_number':195,'multiline':False]
['text':' because we require RequiresHoistedUse to be set at each level.','line_number':196,'multiline':False]
['text':' Don't hoist a cheap constant if it doesn't enable us to hoist one of','line_number':227,'multiline':False]
['text':' its uses. We want those instructions as close as possible to their','line_number':228,'multiline':False]
['text':' use, to minimize register pressure.','line_number':229,'multiline':False]
['text':' Hoist operands which were too cheap to hoist on their own.','line_number':238,'multiline':False]
['text':' Move the instruction to the hoistPoint.','line_number':245,'multiline':False]
['text':' This indicates whether the loop contains calls or other things which','line_number':261,'multiline':False]
['text':' clobber most or all floating-point registers. In such loops,','line_number':262,'multiline':False]
['text':' floating-point constants should not be hoisted unless it enables further','line_number':263,'multiline':False]
['text':' hoisting.','line_number':264,'multiline':False]
['text':' Iterate in RPO to visit outer loops before inner loops. We'd hoist the','line_number':290,'multiline':False]
['text':' same things either way, but outer first means we do a little less work.','line_number':291,'multiline':False]
['text':' There are various reasons why we might choose not to LICM a given loop:','line_number':308,'multiline':False]
['text':'','line_number':309,'multiline':False]
['text':' (a) Hoisting out of a loop that has an entry from the OSR block in','line_number':310,'multiline':False]
['text':'     addition to its normal entry is tricky.  In theory we could clone','line_number':311,'multiline':False]
['text':'     the instruction and insert phis.  In practice we don't bother.','line_number':312,'multiline':False]
['text':'','line_number':313,'multiline':False]
['text':' (b) If the loop contains a large number of blocks, we play safe and','line_number':314,'multiline':False]
['text':'     punt, in order to reduce the risk of creating excessive register','line_number':315,'multiline':False]
['text':'     pressure by hoisting lots of values out of the loop.  In a larger','line_number':316,'multiline':False]
['text':'     loop there's more likely to be duplication of invariant expressions','line_number':317,'multiline':False]
['text':'     within the loop body, and that duplication will be GVN'd but only','line_number':318,'multiline':False]
['text':'     within the scope of the loop body, so there's less loss from not','line_number':319,'multiline':False]
['text':'     lifting them out of the loop entirely.','line_number':320,'multiline':False]
['text':'','line_number':321,'multiline':False]
['text':' (c) If the loop contains a multiway switch with many successors, there','line_number':322,'multiline':False]
['text':'     could be paths with low probabilities, from which LICMing will be a','line_number':323,'multiline':False]
['text':'     net loss, especially if a large number of values are hoisted out.','line_number':324,'multiline':False]
['text':'     See bug 1708381 for a spectacular example and bug 1712078 for','line_number':325,'multiline':False]
['text':'     further discussion.','line_number':326,'multiline':False]
['text':'','line_number':327,'multiline':False]
['text':' It's preferable to perform test (c) only if (a) and (b) pass since (c)','line_number':328,'multiline':False]
['text':' is more expensive to determine -- requiring a visit to all the MIR','line_number':329,'multiline':False]
['text':' nodes -- than (a) or (b), which only involve visiting all blocks.','line_number':330,'multiline':False]
