['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' js::AutoCheckRecursionLimit, js::ReportOverRecursed','line_number':28,'multiline':False]
['text':' BaselineStackBuilder may reallocate its buffer if the current one is too','line_number':44,'multiline':False]
['text':' small. To avoid dangling pointers, BufferPointer represents a pointer into','line_number':45,'multiline':False]
['text':' this buffer as a pointer to the header and a fixed offset.','line_number':46,'multiline':False]
['text':' Note: we return a copy instead of a reference, to avoid potential memory','line_number':71,'multiline':False]
['text':' safety hazards when the underlying buffer gets resized.','line_number':72,'multiline':False]
['text':'*
 * BaselineStackBuilder helps abstract the process of rebuilding the C stack on
 * the heap. It takes a bailout iterator and keeps track of the point on the C
 * stack from which the reconstructed frames will be written.
 *
 * It exposes methods to write data into the heap memory storing the
 * reconstructed stack.  It also exposes method to easily calculate addresses.
 * This includes both the virtual address that a particular value will be at
 * when it's eventually copied onto the stack, as well as the current actual
 * address of that value (whether on the heap allocated portion being
 * constructed or the existing stack).
 *
 * The abstraction handles transparent re-allocation of the heap memory when it
 * needs to be enlarged to accommodate new data.  Similarly to the C stack, the
 * data that's written to the reconstructed stack grows from high to low in
 * memory.
 *
 * The lowest region of the allocated memory contains a BaselineBailoutInfo
 * structure that points to the start and end of the written data.
 ','line_number':77,'multiline':True]
['text':' The baseline frames we will reconstruct on the heap are not','line_number':124,'multiline':False]
['text':' rooted, so GC must be suppressed.','line_number':125,'multiline':False]
['text':' Returns true if we're bailing out to a catch or finally block in this frame','line_number':205,'multiline':False]
['text':' Returns true if we're bailing out in place for debug mode','line_number':211,'multiline':False]
['text':' Initialize the new buffer.','line_number':244,'multiline':False]
['text':'','line_number':245,'multiline':False]
['text':'   Before:','line_number':246,'multiline':False]
['text':'','line_number':247,'multiline':False]
['text':'     [ Header | .. | Payload ]','line_number':248,'multiline':False]
['text':'','line_number':249,'multiline':False]
['text':'   After:','line_number':250,'multiline':False]
['text':'','line_number':251,'multiline':False]
['text':'     [ Header | ............... | Payload ]','line_number':252,'multiline':False]
['text':'','line_number':253,'multiline':False]
['text':' Size of Payload is |bufferUsed_|.','line_number':254,'multiline':False]
['text':'','line_number':255,'multiline':False]
['text':' We need to copy from the old buffer and header to the new buffer before','line_number':256,'multiline':False]
['text':' we set header_ (this deletes the old buffer).','line_number':257,'multiline':False]
['text':'','line_number':258,'multiline':False]
['text':' We also need to update |copyStackBottom| and |copyStackTop| because these','line_number':259,'multiline':False]
['text':' fields point to the Payload's start and end, respectively.','line_number':260,'multiline':False]
['text':' enlarge the buffer if need be.','line_number':277,'multiline':False]
['text':' write out element.','line_number':284,'multiline':False]
['text':' Calculate offset from copyStackTop.','line_number':380,'multiline':False]
['text':' heap = ','line_number':382,'multiline':True]
['text':' heap = ','line_number':385,'multiline':True]
['text':' This method should only be called when the builder is in a state where it','line_number':403,'multiline':False]
['text':' is starting to construct the stack frame for the next callee.  This means','line_number':404,'multiline':False]
['text':' that the lowest value on the constructed stack is the return address for','line_number':405,'multiline':False]
['text':' the previous caller frame.','line_number':406,'multiline':False]
['text':'','line_number':407,'multiline':False]
['text':' This method is used to compute the value of the frame pointer (e.g. ebp on','line_number':408,'multiline':False]
['text':' x86) that would have been saved by the baseline jitcode when it was','line_number':409,'multiline':False]
['text':' entered.  In some cases, this value can be bogus since we can ensure that','line_number':410,'multiline':False]
['text':' the caller would have saved it anyway.','line_number':411,'multiline':False]
['text':'','line_number':412,'multiline':False]
['text':' Get the incoming frame.','line_number':414,'multiline':False]
['text':' For IonJS, IonICCall and Entry frames, the "saved" frame pointer','line_number':418,'multiline':False]
['text':' in the baseline frame is meaningless, since Ion saves all registers','line_number':419,'multiline':False]
['text':' before calling other ion frames, and the entry frame saves all','line_number':420,'multiline':False]
['text':' registers too.','line_number':421,'multiline':False]
['text':' If the previous frame is BaselineJS, with no intervening','line_number':427,'multiline':False]
['text':' BaselineStubFrame, then the caller is responsible for recomputing','line_number':428,'multiline':False]
['text':' BaselineFramePointer from the descriptor when returning. This currently','line_number':429,'multiline':False]
['text':' only happens in frames constructed by emit_Resume().','line_number':430,'multiline':False]
['text':' BaselineStub - Baseline calling into Ion.','line_number':435,'multiline':False]
['text':'  PrevFramePtr needs to point to the BaselineStubFrame's saved frame','line_number':436,'multiline':False]
['text':'  pointer.','line_number':437,'multiline':False]
['text':'      STACK_START_ADDR','line_number':438,'multiline':False]
['text':'          + JitFrameLayout::Size()','line_number':439,'multiline':False]
['text':'          + PREV_FRAME_SIZE','line_number':440,'multiline':False]
['text':'          - BaselineStubFrameLayout::reverseOffsetOfSavedFramePtr()','line_number':441,'multiline':False]
['text':' Rectifier - behaviour depends on the frame preceding the rectifier frame,','line_number':449,'multiline':False]
['text':' and whether the arch is x86 or not.  The x86 rectifier frame saves the','line_number':450,'multiline':False]
['text':' frame pointer, so we can calculate it directly.  For other archs, the','line_number':451,'multiline':False]
['text':' previous frame pointer is stored on the stack in the frame that precedes','line_number':452,'multiline':False]
['text':' the rectifier frame.','line_number':453,'multiline':False]
['text':' On X86, the FramePointer is pushed as the first value in the Rectifier','line_number':457,'multiline':False]
['text':' frame.','line_number':458,'multiline':False]
['text':' On X64, ARM, ARM64, and MIPS, the frame pointer save location depends on','line_number':465,'multiline':False]
['text':' the caller of the rectifier frame.','line_number':466,'multiline':False]
['text':' If the frame preceding the rectifier is an IonJS or entry frame,','line_number':474,'multiline':False]
['text':' then once again the frame pointer does not matter.','line_number':475,'multiline':False]
['text':' Otherwise, the frame preceding the rectifier is a BaselineStub frame.','line_number':480,'multiline':False]
['text':'  let X = STACK_START_ADDR + JitFrameLayout::Size() + PREV_FRAME_SIZE','line_number':481,'multiline':False]
['text':'      X + RectifierFrameLayout::Size()','line_number':482,'multiline':False]
['text':'        + ((RectifierFrameLayout*) X)->prevFrameLocalSize()','line_number':483,'multiline':False]
['text':'        - BaselineStubFrameLayout::reverseOffsetOfSavedFramePtr()','line_number':484,'multiline':False]
['text':' If we are catching an exception, we are bailing out to a catch or','line_number':515,'multiline':False]
['text':' finally block and this is the frame where we will resume. Usually the','line_number':516,'multiline':False]
['text':' expression stack should be empty in this case but there can be','line_number':517,'multiline':False]
['text':' iterators on the stack.','line_number':518,'multiline':False]
['text':' Calculate and write the previous frame pointer value.','line_number':534,'multiline':False]
['text':' Record the virtual stack offset at this location.  Later on, if we end up','line_number':535,'multiline':False]
['text':' writing out a BaselineStub frame for the next callee, we'll need to save','line_number':536,'multiline':False]
['text':' the address.','line_number':537,'multiline':False]
['text':' Get the pc. If we are handling an exception, resume at the pc of the','line_number':544,'multiline':False]
['text':' catch or finally block.','line_number':545,'multiline':False]
['text':' Update icScript_ to point to the icScript of nextCallee','line_number':556,'multiline':False]
['text':' Scripts with an IonScript must also have a BaselineScript.','line_number':575,'multiline':False]
['text':' Build the BaselineFrame struct','line_number':582,'multiline':False]
['text':' If we are bailing to a script whose execution is observed, mark the','line_number':592,'multiline':False]
['text':' baseline frame as a debuggee frame. This is to cover the case where we','line_number':593,'multiline':False]
['text':' don't rematerialize the Ion frame via the Debugger.','line_number':594,'multiline':False]
['text':' Get |envChain|.','line_number':599,'multiline':False]
['text':' The env slot has been updated from UndefinedValue. It must be the','line_number':603,'multiline':False]
['text':' complete initial environment.','line_number':604,'multiline':False]
['text':' Set the HAS_INITIAL_ENV flag if needed.','line_number':607,'multiline':False]
['text':' The env slot has been optimized out.','line_number':618,'multiline':False]
['text':' Get it from the function or script.','line_number':619,'multiline':False]
['text':' For global scripts without a non-syntactic env the env','line_number':625,'multiline':False]
['text':' chain is the script's global lexical environment. (We do','line_number':626,'multiline':False]
['text':' not compile scripts with a non-syntactic global scope).','line_number':627,'multiline':False]
['text':' Also note that it's invalid to resume into the prologue in','line_number':628,'multiline':False]
['text':' this case because the prologue expects the env chain in R1','line_number':629,'multiline':False]
['text':' for eval and global scripts.','line_number':630,'multiline':False]
['text':' Write |envChain|.','line_number':637,'multiline':False]
['text':' Get |returnValue| if present.','line_number':642,'multiline':False]
['text':' Don't use the return value (likely a JS_OPTIMIZED_OUT MagicValue) to','line_number':645,'multiline':False]
['text':' not confuse Baseline.','line_number':646,'multiline':False]
['text':' Write |returnValue|.','line_number':653,'multiline':False]
['text':' Get |argsObj| if present.','line_number':658,'multiline':False]
['text':' Note: we do not need to initialize the scratchValue field in BaselineFrame.','line_number':669,'multiline':False]
['text':' Write |flags|.','line_number':671,'multiline':False]
['text':' Write |icScript|.','line_number':674,'multiline':False]
['text':' initArgsObjUnchecked modifies the frame's flags, so call it after setFlags.','line_number':678,'multiline':False]
['text':' Overwrite the pushed args present in the calling frame with','line_number':685,'multiline':False]
['text':' the unpacked |thisv| and argument values.','line_number':686,'multiline':False]
['text':' This is the first (outermost) frame and we don't have an','line_number':704,'multiline':False]
['text':' arguments object aliasing the formals. Due to UCE and phi','line_number':705,'multiline':False]
['text':' elimination, we could store an UndefinedValue() here for','line_number':706,'multiline':False]
['text':' formals we think are unused, but locals may still reference the','line_number':707,'multiline':False]
['text':' original argument slot (MParameter/LArgument) and expect the','line_number':708,'multiline':False]
['text':' original Value. To avoid this problem, store the formals in a','line_number':709,'multiline':False]
['text':' Vector until we are done.','line_number':710,'multiline':False]
['text':' When the arguments object aliases the formal arguments, then','line_number':727,'multiline':False]
['text':' JSOp::SetArg mutates the argument object. In such cases, the','line_number':728,'multiline':False]
['text':' list of arguments reported by the snapshot are only aliases','line_number':729,'multiline':False]
['text':' of argument object slots which are optimized to only store','line_number':730,'multiline':False]
['text':' differences compared to arguments which are on the stack.','line_number':731,'multiline':False]
['text':' The caller side of inlined JSOp::FunCall and accessors must look','line_number':747,'multiline':False]
['text':' like the function wasn't inlined.','line_number':748,'multiline':False]
['text':' Inlining of SpreadCall-like frames not currently supported.','line_number':753,'multiline':False]
['text':' Calculate how many arguments are consumed by the inlined call.','line_number':760,'multiline':False]
['text':' All calls pass |callee| and |this|.','line_number':761,'multiline':False]
['text':' The first argument to an inlined FunCall becomes |this|,','line_number':764,'multiline':False]
['text':' if it exists. The rest are passed normally.','line_number':765,'multiline':False]
['text':' Setters are passed one argument. Getters are passed none.','line_number':769,'multiline':False]
['text':' Calculate how many values are live on the stack across the call,','line_number':775,'multiline':False]
['text':' and push them.','line_number':776,'multiline':False]
['text':' When we inline JSOp::FunCall, we bypass the native and inline the','line_number':790,'multiline':False]
['text':' target directly. When rebuilding the stack, we need to fill in','line_number':791,'multiline':False]
['text':' the right number of slots to make it look like the js_native was','line_number':792,'multiline':False]
['text':' actually called.','line_number':793,'multiline':False]
['text':' We must transform the stack from |target, this, args| to','line_number':795,'multiline':False]
['text':' |js_fun_call, target, this, args|. The value of |js_fun_call|','line_number':796,'multiline':False]
['text':' will never be observed, so we push |undefined| for it, followed','line_number':797,'multiline':False]
['text':' by the remaining arguments.','line_number':798,'multiline':False]
['text':' When we inline FunCall with no arguments, we push an extra','line_number':814,'multiline':False]
['text':' |undefined| value for |this|. That value should not appear','line_number':815,'multiline':False]
['text':' in the rebuilt baseline frame.','line_number':816,'multiline':False]
['text':' Skip |this|.','line_number':822,'multiline':False]
['text':' Save the actual arguments. They are needed to rebuild the callee frame.','line_number':828,'multiline':False]
['text':' The RHS argument to SetProp remains on the stack after the','line_number':837,'multiline':False]
['text':' operation and is observable, so we have to fill it in.','line_number':838,'multiline':False]
['text':' If we are in the middle of propagating an exception from Ion by','line_number':858,'multiline':False]
['text':' bailing to baseline due to debug mode, we might not have all','line_number':859,'multiline':False]
['text':' the stack if we are at the newest frame.','line_number':860,'multiline':False]
['text':'','line_number':861,'multiline':False]
['text':' For instance, if calling |f()| pushed an Ion frame which threw,','line_number':862,'multiline':False]
['text':' the snapshot expects the return value to be pushed, but it's','line_number':863,'multiline':False]
['text':' possible nothing was pushed before we threw. We can't drop','line_number':864,'multiline':False]
['text':' iterators, however, so read them out. They will be closed by','line_number':865,'multiline':False]
['text':' HandleExceptionBaseline.','line_number':866,'multiline':False]
['text':' Write out descriptor and return address for the baseline frame.','line_number':890,'multiline':False]
['text':' The icEntry in question MUST have an inlinable fallback stub.','line_number':891,'multiline':False]
['text':' .               .','line_number':900,'multiline':False]
['text':' |  Descr(BLJS)  |','line_number':901,'multiline':False]
['text':' +---------------+','line_number':902,'multiline':False]
['text':' |  ReturnAddr   |','line_number':903,'multiline':False]
['text':' +===============+','line_number':904,'multiline':False]
['text':' Write out descriptor of BaselineJS frame.','line_number':911,'multiline':False]
['text':' Build baseline stub frame:','line_number':924,'multiline':False]
['text':' +===============+','line_number':925,'multiline':False]
['text':' |    StubPtr    |','line_number':926,'multiline':False]
['text':' +---------------+','line_number':927,'multiline':False]
['text':' |   FramePtr    |','line_number':928,'multiline':False]
['text':' +---------------+','line_number':929,'multiline':False]
['text':' |   Padding?    |','line_number':930,'multiline':False]
['text':' +---------------+','line_number':931,'multiline':False]
['text':' |     ArgA      |','line_number':932,'multiline':False]
['text':' +---------------+','line_number':933,'multiline':False]
['text':' |     ...       |','line_number':934,'multiline':False]
['text':' +---------------+','line_number':935,'multiline':False]
['text':' |     Arg0      |','line_number':936,'multiline':False]
['text':' +---------------+','line_number':937,'multiline':False]
['text':' |     ThisV     |','line_number':938,'multiline':False]
['text':' +---------------+','line_number':939,'multiline':False]
['text':' |  ActualArgC   |','line_number':940,'multiline':False]
['text':' +---------------+','line_number':941,'multiline':False]
['text':' |  CalleeToken  |','line_number':942,'multiline':False]
['text':' +---------------+','line_number':943,'multiline':False]
['text':' | Descr(BLStub) |','line_number':944,'multiline':False]
['text':' +---------------+','line_number':945,'multiline':False]
['text':' |  ReturnAddr   |','line_number':946,'multiline':False]
['text':' +===============+','line_number':947,'multiline':False]
['text':' Write stub pointer.','line_number':953,'multiline':False]
['text':' Write previous frame pointer (saved earlier).','line_number':962,'multiline':False]
['text':' Write out the arguments, copied from the baseline frame. The order','line_number':968,'multiline':False]
['text':' of the arguments is reversed relative to the baseline frame's stack','line_number':969,'multiline':False]
['text':' values.','line_number':970,'multiline':False]
['text':' For accessors, the arguments are not on the stack anymore,','line_number':976,'multiline':False]
['text':' but they are copied in a vector and are written here.','line_number':977,'multiline':False]
['text':' Align the stack based on the number of arguments.','line_number':981,'multiline':False]
['text':' Push arguments.','line_number':988,'multiline':False]
['text':' When calling FunCall with 0 arguments, we push |undefined|','line_number':998,'multiline':False]
['text':' for this. See BaselineCacheIRCompiler::pushFunCallArguments.','line_number':999,'multiline':False]
['text':' Align the stack based on pushing |this| and 0 arguments.','line_number':1002,'multiline':False]
['text':' Push an undefined value for |this|.','line_number':1007,'multiline':False]
['text':' See BaselineCacheIRCompiler::pushFunCallArguments.','line_number':1017,'multiline':False]
['text':' In addition to the formal arguments, we must also push |this|.','line_number':1022,'multiline':False]
['text':' When calling a constructor, we must also push |newTarget|.','line_number':1023,'multiline':False]
['text':' Align the stack based on the number of arguments.','line_number':1026,'multiline':False]
['text':' Copy the arguments and |this| from the BaselineFrame, in reverse order.','line_number':1033,'multiline':False]
['text':' In case these arguments need to be copied on the stack again for a','line_number':1047,'multiline':False]
['text':' rectifier frame, save the framePushed values here for later use.','line_number':1048,'multiline':False]
['text':' Calculate frame size for descriptor.','line_number':1051,'multiline':False]
['text':' Push actual argc','line_number':1058,'multiline':False]
['text':' Push callee token (must be a JS Function)','line_number':1063,'multiline':False]
['text':' Push BaselineStub frame descriptor','line_number':1073,'multiline':False]
['text':' Push return address into ICCall_Scripted stub, immediately after the call.','line_number':1078,'multiline':False]
['text':' Build a rectifier frame if necessary','line_number':1086,'multiline':False]
['text':' Push a reconstructed rectifier frame.','line_number':1097,'multiline':False]
['text':' +===============+','line_number':1098,'multiline':False]
['text':' |   Padding?    |','line_number':1099,'multiline':False]
['text':' +---------------+','line_number':1100,'multiline':False]
['text':' |  UndefinedU   |','line_number':1101,'multiline':False]
['text':' +---------------+','line_number':1102,'multiline':False]
['text':' |     ...       |','line_number':1103,'multiline':False]
['text':' +---------------+','line_number':1104,'multiline':False]
['text':' |  Undefined0   |','line_number':1105,'multiline':False]
['text':' +---------------+','line_number':1106,'multiline':False]
['text':' |     ArgA      |','line_number':1107,'multiline':False]
['text':' +---------------+','line_number':1108,'multiline':False]
['text':' |     ...       |','line_number':1109,'multiline':False]
['text':' +---------------+','line_number':1110,'multiline':False]
['text':' |     Arg0      |','line_number':1111,'multiline':False]
['text':' +---------------+','line_number':1112,'multiline':False]
['text':' |     ThisV     |','line_number':1113,'multiline':False]
['text':' +---------------+','line_number':1114,'multiline':False]
['text':' |  ActualArgC   |','line_number':1115,'multiline':False]
['text':' +---------------+','line_number':1116,'multiline':False]
['text':' |  CalleeToken  |','line_number':1117,'multiline':False]
['text':' +---------------+','line_number':1118,'multiline':False]
['text':' |  Descr(Rect)  |','line_number':1119,'multiline':False]
['text':' +---------------+','line_number':1120,'multiline':False]
['text':' |  ReturnAddr   |','line_number':1121,'multiline':False]
['text':' +===============+','line_number':1122,'multiline':False]
['text':' On x86-only, the frame pointer is saved again in the rectifier frame.','line_number':1129,'multiline':False]
['text':' Follow the same logic as in JitRuntime::generateArgumentsRectifier.','line_number':1134,'multiline':False]
['text':' Align the stack based on the number of arguments.','line_number':1141,'multiline':False]
['text':' Copy new.target, if necessary.','line_number':1149,'multiline':False]
['text':' Push undefined for missing arguments.','line_number':1159,'multiline':False]
['text':' Copy arguments + thisv from BaselineStub frame.','line_number':1166,'multiline':False]
['text':' Calculate frame size for descriptor.','line_number':1176,'multiline':False]
['text':' Push actualArgc','line_number':1182,'multiline':False]
['text':' Push calleeToken again.','line_number':1187,'multiline':False]
['text':' Push rectifier frame descriptor','line_number':1192,'multiline':False]
['text':' Push return address into the ArgumentsRectifier code, immediately after the','line_number':1197,'multiline':False]
['text':' ioncode call.','line_number':1198,'multiline':False]
['text':' Compute the native address (within the Baseline Interpreter) that we will','line_number':1217,'multiline':False]
['text':' resume at and initialize the frame's interpreter fields.','line_number':1218,'multiline':False]
['text':' When propagating an exception for debug mode, set the','line_number':1226,'multiline':False]
['text':' resume pc to the throwing pc, so that Debugger hooks report','line_number':1227,'multiline':False]
['text':' the correct pc offset of the throwing op instead of its','line_number':1228,'multiline':False]
['text':' successor.','line_number':1229,'multiline':False]
['text':' Register bailout with profiler.','line_number':1242,'multiline':False]
['text':' The |envChain| slot must not be optimized out if the currently','line_number':1264,'multiline':False]
['text':' active scope requires any EnvironmentObjects beyond what is','line_number':1265,'multiline':False]
['text':' available at body scope. This checks that scope chain does not','line_number':1266,'multiline':False]
['text':' require any such EnvironmentObjects.','line_number':1267,'multiline':False]
['text':' See also: |CompileInfo::isObservableFrameSlot|','line_number':1268,'multiline':False]
['text':' debugNumValueSlots() is based on the frame size, do some sanity checks.','line_number':1286,'multiline':False]
['text':' For fun.call(this, ...); the reconstructed stack depth will','line_number':1302,'multiline':False]
['text':' include the this. When inlining that is not included.','line_number':1303,'multiline':False]
['text':' So the exprStackSlots will be one less.','line_number':1304,'multiline':False]
['text':' Accessors coming out of ion are inlined via a complete','line_number':1307,'multiline':False]
['text':' lie perpetrated by the compiler internally. Ion just rearranges','line_number':1308,'multiline':False]
['text':' the stack, and pretends that it looked like a call all along.','line_number':1309,'multiline':False]
['text':' This means that the depth is actually one *more* than expected','line_number':1310,'multiline':False]
['text':' by the interpreter, as there is now a JSFunction, |this| and [arg],','line_number':1311,'multiline':False]
['text':' rather than the expected |this| and [arg].','line_number':1312,'multiline':False]
['text':' If the inlined accessor is a getelem operation, the numbers do match,','line_number':1313,'multiline':False]
['text':' but that's just because getelem expects one more item on the stack.','line_number':1314,'multiline':False]
['text':' Note that none of that was pushed, but it's still reflected','line_number':1315,'multiline':False]
['text':' in exprStackSlots.','line_number':1316,'multiline':False]
['text':' This should be a call op of some kind, now.','line_number':1339,'multiline':False]
['text':' Returns the pc to resume execution at in Baseline after a bailout.','line_number':1366,'multiline':False]
['text':' If we are resuming at a LoopHead op, resume at the next op to avoid','line_number':1372,'multiline':False]
['text':' a bailout -> enter Ion -> bailout loop with --ion-eager.','line_number':1373,'multiline':False]
['text':'','line_number':1374,'multiline':False]
['text':' The algorithm below is the "tortoise and the hare" algorithm. See bug','line_number':1375,'multiline':False]
['text':' 994444 for more explanation.','line_number':1376,'multiline':False]
['text':' Return true iff stackSlotIndex is a stack value that's part of an active','line_number':1393,'multiline':False]
['text':' iterator loop instead of a normal expression stack slot.','line_number':1394,'multiline':False]
['text':' If we are propagating an exception for debug mode, we will not resume','line_number':1420,'multiline':False]
['text':' into baseline code, but instead into HandleExceptionBaseline (i.e.,','line_number':1421,'multiline':False]
['text':' never before the prologue).','line_number':1422,'multiline':False]
['text':' Build a baseline stack frame.','line_number':1427,'multiline':False]
['text':' Build a baseline frame:','line_number':1429,'multiline':False]
['text':' +===============+','line_number':1430,'multiline':False]
['text':' | PrevFramePtr  | <-- initFrame()','line_number':1431,'multiline':False]
['text':' +---------------+','line_number':1432,'multiline':False]
['text':' |   Baseline    | <-- buildBaselineFrame()','line_number':1433,'multiline':False]
['text':' |    Frame      |','line_number':1434,'multiline':False]
['text':' +---------------+','line_number':1435,'multiline':False]
['text':' |    Fixed0     | <-- buildFixedSlots()','line_number':1436,'multiline':False]
['text':' +---------------+','line_number':1437,'multiline':False]
['text':' |     ...       |','line_number':1438,'multiline':False]
['text':' +---------------+','line_number':1439,'multiline':False]
['text':' |    FixedF     |','line_number':1440,'multiline':False]
['text':' +---------------+','line_number':1441,'multiline':False]
['text':' |    Stack0     | <-- buildExpressionStack() -or- fixupCallerArgs()','line_number':1442,'multiline':False]
['text':' +---------------+','line_number':1443,'multiline':False]
['text':' |     ...       |','line_number':1444,'multiline':False]
['text':' +---------------+     If we are building the frame in which we will','line_number':1445,'multiline':False]
['text':' |    StackS     | <-- resume, we stop here.','line_number':1446,'multiline':False]
['text':' +---------------+     finishLastFrame() sets up the interpreter fields.','line_number':1447,'multiline':False]
['text':' .               .','line_number':1448,'multiline':False]
['text':' .               .','line_number':1449,'multiline':False]
['text':' .               . <-- If there are additional frames inlined into this','line_number':1450,'multiline':False]
['text':' |  Descr(BLJS)  |     one, we finish this frame. We generate a stub','line_number':1451,'multiline':False]
['text':' +---------------+     frame (and maybe also a rectifier frame) between','line_number':1452,'multiline':False]
['text':' |  ReturnAddr   |     this frame and the inlined frame.','line_number':1453,'multiline':False]
['text':' +===============+     See: prepareForNextFrame()','line_number':1454,'multiline':False]
['text':' If this was the last inline frame, or we are bailing out to a catch or','line_number':1499,'multiline':False]
['text':' finally block in this frame, then unpacking is almost done.','line_number':1500,'multiline':False]
['text':' Otherwise, this is an outer frame for an inlined call or','line_number':1505,'multiline':False]
['text':' accessor. We will be building an inner frame. Before that,','line_number':1506,'multiline':False]
['text':' we must create a stub frame, and potentially a rectifier frame.','line_number':1507,'multiline':False]
['text':' Ion bailout can fail due to overrecursion and OOM. In such cases we','line_number':1523,'multiline':False]
['text':' cannot honor any further Debugger hooks on the frame, and need to','line_number':1524,'multiline':False]
['text':' ensure that its Debugger.Frame entry is cleaned up.','line_number':1525,'multiline':False]
['text':' Always remove the RInstructionResults from the JitActivation, even in','line_number':1531,'multiline':False]
['text':' case of failures as the stack frame is going away after the bailout.','line_number':1532,'multiline':False]
['text':' The caller of the top frame must be one of the following:','line_number':1536,'multiline':False]
['text':'      IonJS - Ion calling into Ion.','line_number':1537,'multiline':False]
['text':'      BaselineStub - Baseline calling into Ion.','line_number':1538,'multiline':False]
['text':'      Entry / WasmToJSJit - Interpreter or other (wasm) calling into Ion.','line_number':1539,'multiline':False]
['text':'      Rectifier - Arguments rectifier calling into Ion.','line_number':1540,'multiline':False]
['text':'      BaselineJS - Resume'd Baseline, then likely OSR'd into Ion.','line_number':1541,'multiline':False]
['text':' All incoming frames are going to look like this:','line_number':1553,'multiline':False]
['text':'','line_number':1554,'multiline':False]
['text':'      +---------------+','line_number':1555,'multiline':False]
['text':'      |     ...       |','line_number':1556,'multiline':False]
['text':'      +---------------+','line_number':1557,'multiline':False]
['text':'      |     Args      |','line_number':1558,'multiline':False]
['text':'      |     ...       |','line_number':1559,'multiline':False]
['text':'      +---------------+','line_number':1560,'multiline':False]
['text':'      |    ThisV      |','line_number':1561,'multiline':False]
['text':'      +---------------+','line_number':1562,'multiline':False]
['text':'      |  ActualArgC   |','line_number':1563,'multiline':False]
['text':'      +---------------+','line_number':1564,'multiline':False]
['text':'      |  CalleeToken  |','line_number':1565,'multiline':False]
['text':'      +---------------+','line_number':1566,'multiline':False]
['text':'      |  Descriptor   |','line_number':1567,'multiline':False]
['text':'      +---------------+','line_number':1568,'multiline':False]
['text':'      |  ReturnAddr   |','line_number':1569,'multiline':False]
['text':'      +---------------+','line_number':1570,'multiline':False]
['text':'      |    |||||      | <---- Overwrite starting here.','line_number':1571,'multiline':False]
['text':'      |    |||||      |','line_number':1572,'multiline':False]
['text':'      |    |||||      |','line_number':1573,'multiline':False]
['text':'      +---------------+','line_number':1574,'multiline':False]
['text':' Under a bailout, there is no need to invalidate the frame after','line_number':1596,'multiline':False]
['text':' evaluating the recover instruction, as the invalidation is only needed in','line_number':1597,'multiline':False]
['text':' cases where the frame is introspected ahead of the bailout.','line_number':1598,'multiline':False]
['text':' Ensure that all value locations are readable from the SnapshotIterator.','line_number':1602,'multiline':False]
['text':' Get the RInstructionResults from the JitActivation if the frame got','line_number':1603,'multiline':False]
['text':' recovered ahead of the bailout.','line_number':1604,'multiline':False]
['text':' Skip recover instructions as they are already recovered by','line_number':1639,'multiline':False]
['text':' |initInstructionResults|.','line_number':1640,'multiline':False]
['text':' TraceLogger doesn't create entries for inlined frames. But we','line_number':1644,'multiline':False]
['text':' see them in Baseline. Here we create the start events of those','line_number':1645,'multiline':False]
['text':' entries. So they correspond to what we will see in Baseline.','line_number':1646,'multiline':False]
['text':' Set the first frame's formals, see the comment in InitFromBailout.','line_number':1670,'multiline':False]
['text':' +1 to skip |this|.','line_number':1671,'multiline':False]
['text':' Do stack check.','line_number':1676,'multiline':False]
['text':' Take the reconstructed baseline stack so it doesn't get freed when builder','line_number':1697,'multiline':False]
['text':' destructs.','line_number':1698,'multiline':False]
['text':' In some cases, the computation of recover instruction can invalidate the','line_number':1709,'multiline':False]
['text':' Ion script before we reach the end of the bailout. Thus, if the outer','line_number':1710,'multiline':False]
['text':' script no longer have any Ion script attached, then we just skip the','line_number':1711,'multiline':False]
['text':' invalidation.','line_number':1712,'multiline':False]
['text':'','line_number':1713,'multiline':False]
['text':' For example, such case can happen if the template object for an unboxed','line_number':1714,'multiline':False]
['text':' objects no longer match the content of its properties (see Bug 1174547)','line_number':1715,'multiline':False]
['text':' We might not have rematerialized a frame if the user never requested a','line_number':1751,'multiline':False]
['text':' Debugger.Frame for it.','line_number':1752,'multiline':False]
['text':' Don't copy over the hasCachedSavedFrame bit. The new BaselineFrame we're','line_number':1776,'multiline':False]
['text':' building has a different AbstractFramePtr, so it won't be found in the','line_number':1777,'multiline':False]
['text':' LiveSavedFrameCache if we look there.','line_number':1778,'multiline':False]
['text':' Propagate the debuggee frame flag. For the case where the Debugger did','line_number':1783,'multiline':False]
['text':' not rematerialize an Ion frame, the baseline frame has its debuggee','line_number':1784,'multiline':False]
['text':' flag set iff its script is considered a debuggee. See the debuggee case','line_number':1785,'multiline':False]
['text':' in InitFromBailout.','line_number':1786,'multiline':False]
['text':' Use UniquePtr to free the bailoutInfo before we return.','line_number':1805,'multiline':False]
['text':' We have to get rid of the rematerialized frame, whether it is','line_number':1814,'multiline':False]
['text':' restored or unwound.','line_number':1815,'multiline':False]
['text':' Ensure the frame has a call object if it needs one.','line_number':1823,'multiline':False]
['text':' Create arguments objects for bailed out frames, to maintain the invariant','line_number':1828,'multiline':False]
['text':' that script->needsArgsObj() implies frame->hasArgsObj().','line_number':1829,'multiline':False]
['text':' Iter currently points at the exit frame.  Get the previous frame','line_number':1837,'multiline':False]
['text':' (which must be a baseline frame), and set it as the last profiling','line_number':1838,'multiline':False]
['text':' frame.','line_number':1839,'multiline':False]
['text':' If the frame doesn't even have a env chain set yet, then it's resuming','line_number':1856,'multiline':False]
['text':' into the the prologue before the env chain is initialized.  Any','line_number':1857,'multiline':False]
['text':' necessary args object will also be initialized there.','line_number':1858,'multiline':False]
['text':' The arguments is a local binding and needsArgsObj does not','line_number':1870,'multiline':False]
['text':' check if it is clobbered. Ensure that the local binding','line_number':1871,'multiline':False]
['text':' restored during bailout before storing the arguments object','line_number':1872,'multiline':False]
['text':' to the slot.','line_number':1873,'multiline':False]
['text':' If we rematerialized Ion frames due to debug mode toggling, copy their','line_number':1898,'multiline':False]
['text':' values into the baseline frame. We need to do this even when debug mode','line_number':1899,'multiline':False]
['text':' is off, as we should respect the mutations made while debug mode was','line_number':1900,'multiline':False]
['text':' on.','line_number':1901,'multiline':False]
['text':' We must attempt to copy all rematerialized frames over,','line_number':1909,'multiline':False]
['text':' even if earlier ones failed, to invoke the proper frame','line_number':1910,'multiline':False]
['text':' cleanup in the Debugger.','line_number':1911,'multiline':False]
['text':' After copying from all the rematerialized frames, remove them from','line_number':1924,'multiline':False]
['text':' the table to keep the table up to date.','line_number':1925,'multiline':False]
['text':' If we are catching an exception, we need to unwind scopes.','line_number':1930,'multiline':False]
['text':' See |SettleOnTryNote|','line_number':1931,'multiline':False]
['text':' Check for interrupts now because we might miss an interrupt check in JIT','line_number':1937,'multiline':False]
['text':' code when resuming in the prologue, after the stack/interrupt check.','line_number':1938,'multiline':False]
['text':' A transpiled guard failed. If this happens often enough, we will','line_number':1958,'multiline':False]
['text':' invalidate and recompile.','line_number':1959,'multiline':False]
['text':' A value of an unexpected type flowed into a phi.','line_number':1965,'multiline':False]
['text':' A conversion inserted by a type policy failed.','line_number':1972,'multiline':False]
['text':' We will invalidate and disable recompilation if this happens too often.','line_number':1973,'multiline':False]
['text':' LICM may cause spurious bailouts by hoisting unreachable','line_number':1978,'multiline':False]
['text':' guards past branches.  To prevent bailout loops, when an','line_number':1979,'multiline':False]
['text':' instruction hoisted by LICM bails out, we update the','line_number':1980,'multiline':False]
['text':' IonScript and resume in baseline. If the guard would have','line_number':1981,'multiline':False]
['text':' been executed anyway, then we will hit the baseline fallback,','line_number':1982,'multiline':False]
['text':' and call noteBaselineFallback. If that does not happen,','line_number':1983,'multiline':False]
['text':' then the next time we reach this point, we will disable LICM','line_number':1984,'multiline':False]
['text':' for this script.','line_number':1985,'multiline':False]
['text':' This bailout is not due to LICM. Treat it like a','line_number':1998,'multiline':False]
['text':' regular TranspiledCacheIR bailout.','line_number':1999,'multiline':False]
['text':' An instruction moved up by instruction reordering bailed out.','line_number':2007,'multiline':False]
['text':' An instruction hoisted or generated by tryHoistBoundsCheck bailed out.','line_number':2013,'multiline':False]
['text':' An eager truncation generated by range analysis bailed out.','line_number':2020,'multiline':False]
['text':' To avoid bailout loops, we set a flag to avoid generating','line_number':2021,'multiline':False]
['text':' eager truncations next time we recompile.','line_number':2022,'multiline':False]
['text':' An unbox that was hoisted to fold with a load bailed out.','line_number':2029,'multiline':False]
['text':' To avoid bailout loops, we set a flag to avoid folding','line_number':2030,'multiline':False]
['text':' loads with unboxes next time we recompile.','line_number':2031,'multiline':False]
['text':' A funapply or spread call had more than JIT_ARGS_LENGTH_MAX arguments.','line_number':2038,'multiline':False]
['text':' We will invalidate and disable recompilation if this happens too often.','line_number':2039,'multiline':False]
['text':' We are bailing out to catch an exception. We will invalidate','line_number':2045,'multiline':False]
['text':' and disable recompilation if this happens too often.','line_number':2046,'multiline':False]
['text':' Do nothing.','line_number':2053,'multiline':False]
['text':' We reached an instruction that had not been executed yet at','line_number':2058,'multiline':False]
['text':' the time we compiled. If this happens often enough, we will','line_number':2059,'multiline':False]
['text':' invalidate and recompile.','line_number':2060,'multiline':False]
['text':' Return false to resume in HandleException with reconstructed','line_number':2070,'multiline':False]
['text':' baseline frame.','line_number':2071,'multiline':False]
['text':' The script has already been invalidated. There is nothing left to do.','line_number':2075,'multiline':False]
['text':' The IonScript should already have been invalidated.','line_number':2093,'multiline':False]
