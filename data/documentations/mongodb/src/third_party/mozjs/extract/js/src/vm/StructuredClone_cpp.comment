['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':'
 * This file implements the structured data algorithms of
 * https://html.spec.whatwg.org/multipage/structured-data.html
 *
 * The spec is in two parts:
 *
 * -   StructuredSerialize examines a JS value and produces a graph of Records.
 * -   StructuredDeserialize walks the Records and produces a new JS value.
 *
 * The differences between our implementation and the spec are minor:
 *
 * -   We call the two phases "write" and "read".
 * -   Our algorithms use an explicit work stack, rather than recursion.
 * -   Serialized data is a flat array of bytes, not a (possibly cyclic) graph
 *     of "Records".
 * -   As a consequence, we handle non-treelike object graphs differently.
 *     We serialize objects that appear in multiple places in the input as
 *     backreferences, using sequential integer indexes.
 *     See `JSStructuredCloneReader::allObjs`, our take on the "memory" map
 *     in the spec's StructuredDeserialize.
 ','line_number':7,'multiline':True]
['text':' JS::GetArrayLength, JS::IsArrayObject','line_number':47,'multiline':False]
['text':' JS::{ArrayBufferHasData,DetachArrayBuffer,IsArrayBufferObject,New{,Mapped}ArrayBufferWithContents,ReleaseMappedArrayBufferContents}','line_number':48,'multiline':False]
['text':' JS_NewDataView, JS_New{{Ui,I}nt{8,16,32},Float{32,64},Uint8Clamped,Big{Ui,I}nt64}ArrayWithBuffer','line_number':50,'multiline':False]
['text':' js::GetErrorMessage, JSMSG_*','line_number':51,'multiline':False]
['text':' JS::GetBuiltinClass','line_number':53,'multiline':False]
['text':' JS::RegExpFlag, JS::RegExpFlags','line_number':54,'multiline':False]
['text':' js::Scalar::Type','line_number':55,'multiline':False]
['text':' JS::IsSharedArrayBufferObject','line_number':56,'multiline':False]
['text':' js::PlainObject','line_number':60,'multiline':False]
['text':' When you make updates here, make sure you consider whether you need to bump','line_number':85,'multiline':False]
['text':' the value of JS_STRUCTURED_CLONE_VERSION in js/public/StructuredClone.h.  You','line_number':86,'multiline':False]
['text':' will likely need to increment the version if anything at all changes in the','line_number':87,'multiline':False]
['text':' serialization format.','line_number':88,'multiline':False]
['text':'','line_number':89,'multiline':False]
['text':' Note that SCTAG_END_OF_KEYS is written into the serialized form and should','line_number':90,'multiline':False]
['text':' have a stable ID, it need not be at the end of the list and should not be','line_number':91,'multiline':False]
['text':' used for sizing data structures.','line_number':92,'multiline':False]
['text':' Structured data types provided by the engine','line_number':95,'multiline':False]
['text':' Old version, for backwards compatibility.','line_number':107,'multiline':False]
['text':' Required for backwards compatibility','line_number':112,'multiline':False]
['text':' Required for backwards compatibility','line_number':113,'multiline':False]
['text':' Old version, for backwards compatibility.','line_number':114,'multiline':False]
['text':' Required for backwards compatibility','line_number':118,'multiline':False]
['text':' Old version, for backwards compatibility.','line_number':119,'multiline':False]
['text':' No new tags before principals.','line_number':122,'multiline':False]
['text':' BigInt64 and BigUint64 are not supported in the v1 format.','line_number':149,'multiline':False]
['text':' Define a separate range of numbers for Transferable-only tags, since','line_number':152,'multiline':False]
['text':' they are not used for persistent clone buffers and therefore do not','line_number':153,'multiline':False]
['text':' require bumping JS_STRUCTURED_CLONE_VERSION.','line_number':154,'multiline':False]
['text':'
 * Format of transfer map:
 *   <SCTAG_TRANSFER_MAP_HEADER, TransferableMapHeader(UNREAD|TRANSFERRED)>
 *   numTransferables (64 bits)
 *   array of:
 *     <SCTAG_TRANSFER_MAP_*, TransferableOwnership>
 *     pointer (64 bits)
 *     extraData (64 bits), eg byte length for ArrayBuffers
 ','line_number':164,'multiline':True]
['text':' Data associated with an SCTAG_TRANSFER_MAP_HEADER that tells whether the','line_number':174,'multiline':False]
['text':' contents have been read out yet or not.','line_number':175,'multiline':False]
['text':' SCOutput provides an interface to write raw data -- eg uint64_ts, doubles,','line_number':304,'multiline':False]
['text':' arrays of bytes -- into a structured clone data output stream. It also knows','line_number':305,'multiline':False]
['text':' how to free any transferable data within that stream.','line_number':306,'multiline':False]
['text':'','line_number':307,'multiline':False]
['text':' Note that it contains a full JSStructuredCloneData object, which holds the','line_number':308,'multiline':False]
['text':' callbacks necessary to read/write/transfer/free the data. For the purpose of','line_number':309,'multiline':False]
['text':' this class, only the freeTransfer callback is relevant; the rest of the','line_number':310,'multiline':False]
['text':' callbacks are used by the higher-level JSStructuredCloneWriter interface.','line_number':311,'multiline':False]
['text':' namespace js','line_number':400,'multiline':False]
['text':' The widest scope that the caller will accept, where','line_number':448,'multiline':False]
['text':' SameProcess is the widest (it can store anything it wants)','line_number':449,'multiline':False]
['text':' and DifferentProcess is the narrowest (it cannot contain pointers and must','line_number':450,'multiline':False]
['text':' be valid cross-process.)','line_number':451,'multiline':False]
['text':' Stack of objects with properties remaining to be read.','line_number':456,'multiline':False]
['text':' Array of all objects read during this deserialization, for resolving','line_number':459,'multiline':False]
['text':' backreferences.','line_number':460,'multiline':False]
['text':'','line_number':461,'multiline':False]
['text':' For backreferences to work correctly, objects must be added to this','line_number':462,'multiline':False]
['text':' array in exactly the order expected by the version of the Writer that','line_number':463,'multiline':False]
['text':' created the serialized data, even across years and format versions. This','line_number':464,'multiline':False]
['text':' is usually no problem, since both algorithms do a single linear pass','line_number':465,'multiline':False]
['text':' over the serialized data. There is one hitch; see readTypedArray.','line_number':466,'multiline':False]
['text':'','line_number':467,'multiline':False]
['text':' The values in this vector are objects, except it can temporarily have','line_number':468,'multiline':False]
['text':' one `undefined` placeholder value (the readTypedArray hack).','line_number':469,'multiline':False]
['text':' The user defined callbacks that will be used for cloning.','line_number':474,'multiline':False]
['text':' Any value passed to JS_ReadStructuredClone.','line_number':477,'multiline':False]
['text':' The user defined callbacks that will be used to signal cloning, in some','line_number':552,'multiline':False]
['text':' cases.','line_number':553,'multiline':False]
['text':' Any value passed to the callbacks.','line_number':556,'multiline':False]
['text':' Vector of objects with properties remaining to be written.','line_number':559,'multiline':False]
['text':'','line_number':560,'multiline':False]
['text':' NB: These can span multiple compartments, so the compartment must be','line_number':561,'multiline':False]
['text':' entered before any manipulation is performed.','line_number':562,'multiline':False]
['text':' counts[i] is the number of entries of objs[i] remaining to be written.','line_number':565,'multiline':False]
['text':' counts.length() == objs.length() and sum(counts) == entries.length().','line_number':566,'multiline':False]
['text':' For JSObject: Property IDs as value','line_number':569,'multiline':False]
['text':' For Map: Key followed by value','line_number':572,'multiline':False]
['text':' For Set: Key','line_number':573,'multiline':False]
['text':' For SavedFrame: parent SavedFrame','line_number':574,'multiline':False]
['text':' The "memory" list described in the HTML5 internal structured cloning','line_number':577,'multiline':False]
['text':' algorithm.  memory is a superset of objs; items are never removed from','line_number':578,'multiline':False]
['text':' Memory until a serialization operation is finished','line_number':579,'multiline':False]
['text':' Set of transferable objects','line_number':591,'multiline':False]
['text':' Get js error message if it's possible and propagate it through callback.','line_number':662,'multiline':False]
['text':' initialize to shut GCC up','line_number':732,'multiline':False]
['text':' Data is packed into an integral number of uint64_t words. Compute the','line_number':794,'multiline':False]
['text':' padding required to finish off the final word.','line_number':795,'multiline':False]
['text':' We want total length mod 8, where total length is nelems * sizeof(T),','line_number':797,'multiline':False]
['text':' but that might overflow. So reduce nelems to nelems mod 8, since we are','line_number':798,'multiline':False]
['text':' going to be doing a mod 8 later anyway.','line_number':799,'multiline':False]
['text':' Fail if nelems is so huge that computing the full size will overflow.','line_number':812,'multiline':False]
['text':' To avoid any way in which uninitialized data could escape, zero the array','line_number':820,'multiline':False]
['text':' if filling it failed.','line_number':821,'multiline':False]
['text':' As it happens, the tag word appears after the data word in the output.','line_number':874,'multiline':False]
['text':' This is because exponents occupy the last 2 bytes of doubles on the','line_number':875,'multiline':False]
['text':' little-endian platforms we care most about.','line_number':876,'multiline':False]
['text':'','line_number':877,'multiline':False]
['text':' For example, TrueValue() is written using writePair(SCTAG_BOOLEAN, 1).','line_number':878,'multiline':False]
['text':' PairToUInt64 produces the number 0xFFFF000200000001.','line_number':879,'multiline':False]
['text':' That is written out as the bytes 01 00 00 00 02 00 FF FF.','line_number':880,'multiline':False]
['text':' Zero-pad to 8 bytes boundary.','line_number':908,'multiline':False]
['text':' zero-pad to 8 bytes boundary','line_number':928,'multiline':False]
['text':' namespace js','line_number':957,'multiline':False]
['text':' If the buffer contains Transferables, free them. Note that custom','line_number':961,'multiline':False]
['text':' Transferables will use the JSStructuredCloneCallbacks::freeTransfer() to','line_number':962,'multiline':False]
['text':' delete their transferables.','line_number':963,'multiline':False]
['text':' DifferentProcess clones cannot contain pointers, so nothing needs to be','line_number':973,'multiline':False]
['text':' released.','line_number':974,'multiline':False]
['text':' Empty buffer','line_number':986,'multiline':False]
['text':' freeTransfer should not GC','line_number':1012,'multiline':False]
['text':' Free any transferable data left lying around in the buffer','line_number':1065,'multiline':False]
['text':' NOTE: The transferables set is tested for non-emptiness at various','line_number':1072,'multiline':False]
['text':'       junctures in structured cloning, so this set must be initialized','line_number':1073,'multiline':False]
['text':'       by this method in all non-error cases.','line_number':1074,'multiline':False]
['text':' Initialize the set for the provided array's length.','line_number':1101,'multiline':False]
['text':' Shared memory cannot be transferred because it is not possible (nor','line_number':1133,'multiline':False]
['text':' desirable) to detach the memory in agents that already hold a','line_number':1134,'multiline':False]
['text':' reference to it.','line_number':1135,'multiline':False]
['text':' External array buffers may be able to be transferred in the future,','line_number':1147,'multiline':False]
['text':' but that is not currently implemented.','line_number':1148,'multiline':False]
['text':' No duplicates allowed','line_number':1173,'multiline':False]
['text':' The length must fit in 31 bits to leave room for a sign bit.','line_number':1220,'multiline':False]
['text':' To avoid making serialization O(n^2), limit stack-checking at 10.','line_number':1234,'multiline':False]
['text':'
 * Write out a typed array. Note that post-v1 structured clone buffers do not
 * perform endianness conversion on stored data, so multibyte typed arrays
 * cannot be deserialized into a different endianness machine. Endianness
 * conversion would prevent sharing ArrayBuffers: if you have Int8Array and
 * Int16Array views of the same ArrayBuffer, should the data bytes be
 * byte-swapped when writing or not? The Int8Array requires them to not be
 * swapped; the Int16Array requires that they are.
 ','line_number':1258,'multiline':True]
['text':' Write out the ArrayBuffer tag and contents','line_number':1285,'multiline':False]
['text':' Write out the ArrayBuffer tag and contents','line_number':1308,'multiline':False]
['text':' We must not transmit SAB pointers (including for WebAssembly.Memory)','line_number':1348,'multiline':False]
['text':' cross-process.  The cloneDataPolicy should have guarded against this;','line_number':1349,'multiline':False]
['text':' since it did not then throw, with a very explicit message.','line_number':1350,'multiline':False]
['text':' We must serialize the length so that the buffer object arrives in the','line_number':1366,'multiline':False]
['text':' receiver with the same length, and not with the length read from the','line_number':1367,'multiline':False]
['text':' rawbuf - that length can be different, and it can change at any time.','line_number':1368,'multiline':False]
['text':'receiving=','line_number':1380,'multiline':True]
['text':' Check the policy here so that we can report a sane error.','line_number':1390,'multiline':False]
['text':' If this changes, might need to change what we write.','line_number':1399,'multiline':False]
['text':' Handle cycles in the object graph.','line_number':1412,'multiline':False]
['text':' We iterate from the last to the first property, so the property names','line_number':1449,'multiline':False]
['text':' are already in reverse order.','line_number':1450,'multiline':False]
['text':' Ignore symbols and non-enumerable properties.','line_number':1454,'multiline':False]
['text':' Add dense element ids in reverse order.','line_number':1467,'multiline':False]
['text':' Objects are written as a "preorder" traversal of the object graph: object','line_number':1484,'multiline':False]
['text':' "headers" (the class tag and any data needed for initial construction) are','line_number':1485,'multiline':False]
['text':' visited first, then the children are recursed through (where children are','line_number':1486,'multiline':False]
['text':' properties, Set or Map entries, etc.). So for example','line_number':1487,'multiline':False]
['text':'','line_number':1488,'multiline':False]
['text':'     obj1 = { key1: { key1.1: val1.1, key1.2: val1.2 }, key2: {} }','line_number':1489,'multiline':False]
['text':'','line_number':1490,'multiline':False]
['text':' would be stored as:','line_number':1491,'multiline':False]
['text':'','line_number':1492,'multiline':False]
['text':'     <Object tag for obj1>','line_number':1493,'multiline':False]
['text':'       <key1 data>','line_number':1494,'multiline':False]
['text':'       <Object tag for key1's value>','line_number':1495,'multiline':False]
['text':'         <key1.1 data>','line_number':1496,'multiline':False]
['text':'         <val1.1 data>','line_number':1497,'multiline':False]
['text':'         <key1.2 data>','line_number':1498,'multiline':False]
['text':'         <val1.2 data>','line_number':1499,'multiline':False]
['text':'       <end-of-children marker for key1's value>','line_number':1500,'multiline':False]
['text':'       <key2 data>','line_number':1501,'multiline':False]
['text':'       <Object tag for key2's value>','line_number':1502,'multiline':False]
['text':'       <end-of-children marker for key2's value>','line_number':1503,'multiline':False]
['text':'     <end-of-children marker for obj1>','line_number':1504,'multiline':False]
['text':'','line_number':1505,'multiline':False]
['text':' This nests nicely (ie, an entire recursive value starts with its tag and','line_number':1506,'multiline':False]
['text':' ends with its end-of-children marker) and so it can be presented indented.','line_number':1507,'multiline':False]
['text':' But see traverseMap below for how this looks different for Maps.','line_number':1508,'multiline':False]
['text':' Get enumerable property ids and put them in reverse order so that they','line_number':1518,'multiline':False]
['text':' will come off the stack in forward order.','line_number':1519,'multiline':False]
['text':' Push obj and count to the stack.','line_number':1537,'multiline':False]
['text':' Write the header for obj.','line_number':1552,'multiline':False]
['text':' Use the same basic setup as for traverseObject, but now keys can themselves','line_number':1566,'multiline':False]
['text':' be complex objects. Keys and values are visited first via startWrite(), then','line_number':1567,'multiline':False]
['text':' the key's children (if any) are handled, then the value's children.','line_number':1568,'multiline':False]
['text':'','line_number':1569,'multiline':False]
['text':'     m = new Map();','line_number':1570,'multiline':False]
['text':'     m.set(key1 = ..., value1 = ...)','line_number':1571,'multiline':False]
['text':'','line_number':1572,'multiline':False]
['text':' where key1 and value2 are both objects would be stored as','line_number':1573,'multiline':False]
['text':'','line_number':1574,'multiline':False]
['text':'     <Map tag>','line_number':1575,'multiline':False]
['text':'     <key1 class tag>','line_number':1576,'multiline':False]
['text':'     <value1 class tag>','line_number':1577,'multiline':False]
['text':'     ...key1 data...','line_number':1578,'multiline':False]
['text':'     <end-of-children marker for key1>','line_number':1579,'multiline':False]
['text':'     ...value1 data...','line_number':1580,'multiline':False]
['text':'     <end-of-children marker for value1>','line_number':1581,'multiline':False]
['text':'     <end-of-children marker for Map>','line_number':1582,'multiline':False]
['text':'','line_number':1583,'multiline':False]
['text':' Notice how the end-of-children marker for key1 is sandwiched between the','line_number':1584,'multiline':False]
['text':' value1 beginning and end.','line_number':1585,'multiline':False]
['text':' If there is no wrapper, the compartment munging is a no-op.','line_number':1589,'multiline':False]
['text':' Push obj and count to the stack.','line_number':1607,'multiline':False]
['text':' Write the header for obj.','line_number':1614,'multiline':False]
['text':' Similar to traverseMap, only there is a single value instead of a key and','line_number':1618,'multiline':False]
['text':' value, and thus no interleaving is possible: a value will be fully emitted','line_number':1619,'multiline':False]
['text':' before the next value is begun.','line_number':1620,'multiline':False]
['text':' If there is no wrapper, the compartment munging is a no-op.','line_number':1624,'multiline':False]
['text':' Push obj and count to the stack.','line_number':1642,'multiline':False]
['text':' Write the header for obj.','line_number':1649,'multiline':False]
['text':' Write the SavedFrame tag and the SavedFrame's principals.','line_number':1670,'multiline':False]
['text':' Write the SavedFrame's reserved slots, except for the parent, which is','line_number':1698,'multiline':False]
['text':' queued on objs for further traversal.','line_number':1699,'multiline':False]
['text':' else fall through','line_number':1881,'multiline':False]
['text':' Emit a placeholder pointer.  We defer stealing the data until later','line_number':1912,'multiline':False]
['text':' (and, if necessary, detaching this object if it's an ArrayBuffer).','line_number':1913,'multiline':False]
['text':' Pointer to ArrayBuffer contents.','line_number':1918,'multiline':False]
['text':' extraData','line_number':1921,'multiline':False]
['text':' Walk along the transferables and the transfer map at the same time,','line_number':1934,'multiline':False]
['text':' grabbing out pointers from the transferables and stuffing them into the','line_number':1935,'multiline':False]
['text':' transfer map.','line_number':1936,'multiline':False]
['text':' The current setup of the array buffer inheritance hierarchy doesn't','line_number':1976,'multiline':False]
['text':' lend itself well to generic manipulation via proxies.','line_number':1977,'multiline':False]
['text':' Write Transferred ArrayBuffers in DifferentProcess scope at','line_number':1994,'multiline':False]
['text':' the end of the clone buffer, and store the offset within the','line_number':1995,'multiline':False]
['text':' buffer to where the ArrayBuffer was written. Note that this','line_number':1996,'multiline':False]
['text':' will invalidate the current position iterator.','line_number':1997,'multiline':False]
['text':' Offset from tag to current end of buffer','line_number':2004,'multiline':False]
['text':' Must refresh the point iterator after its collection has','line_number':2010,'multiline':False]
['text':' been modified.','line_number':2011,'multiline':False]
['text':' out of memory','line_number':2026,'multiline':False]
['text':' Make sure there aren't any more transfer map entries after the expected','line_number':2061,'multiline':False]
['text':' number we read out.','line_number':2062,'multiline':False]
['text':' If obj still has an own property named id, write it out.','line_number':2117,'multiline':False]
['text':' Push a placeholder onto the allObjs list to stand in for the typed array.','line_number':2211,'multiline':False]
['text':' Read the ArrayBuffer object and its contents (but no properties)','line_number':2218,'multiline':False]
['text':' Ensure invalid 64-bit values won't be truncated below.','line_number':2235,'multiline':False]
['text':' Push a placeholder onto the allObjs list to stand in for the DataView.','line_number':2307,'multiline':False]
['text':' Read the ArrayBuffer object and its contents (but no properties).','line_number':2314,'multiline':False]
['text':' Read byteOffset.','line_number':2326,'multiline':False]
['text':' Ensure invalid 64-bit values won't be truncated below.','line_number':2332,'multiline':False]
['text':' V2 stores the length in |data|. The current version stores the','line_number':2357,'multiline':False]
['text':' length separately to allow larger length values.','line_number':2358,'multiline':False]
['text':' The maximum ArrayBuffer size depends on the platform and prefs, and we cast','line_number':2369,'multiline':False]
['text':' to size_t below, so we have to check this here.','line_number':2370,'multiline':False]
['text':' The maximum ArrayBuffer size depends on the platform and prefs, and we cast','line_number':2403,'multiline':False]
['text':' to size_t below, so we have to check this here.','line_number':2404,'multiline':False]
['text':' There's no guarantee that the receiving agent has enabled shared memory','line_number':2418,'multiline':False]
['text':' even if the transmitting agent has done so.  Ideally we'd check at the','line_number':2419,'multiline':False]
['text':' transmission point, but that's tricky, and it will be a very rare problem','line_number':2420,'multiline':False]
['text':' in any case.  Just fail at the receiving end if we can't handle it.','line_number':2421,'multiline':False]
['text':' The new object will have a new reference to the rawbuf.','line_number':2432,'multiline':False]
['text':' `rawbuf` is now owned by `obj`.','line_number':2447,'multiline':False]
['text':'receiving=','line_number':2450,'multiline':True]
['text':' Read the SharedArrayBuffer object.','line_number':2477,'multiline':False]
['text':' Construct the memory.','line_number':2493,'multiline':False]
['text':'
 * Read in the data for a structured clone version 1 ArrayBuffer, performing
 * endianness-conversion while reading.
 ','line_number':2505,'multiline':True]
['text':' We should be past all the transfer map tags.','line_number':2722,'multiline':False]
['text':' readTypedArray adds the array to allObjs.','line_number':2747,'multiline':False]
['text':' V2 stores the length (nelems) in |data| and the arrayType separately.','line_number':2748,'multiline':False]
['text':' readTypedArray adds the array to allObjs.','line_number':2758,'multiline':False]
['text':' The current version stores the array type in |data| and the length','line_number':2759,'multiline':False]
['text':' (nelems) separately to support large TypedArrays.','line_number':2760,'multiline':False]
['text':' readDataView adds the array to allObjs.','line_number':2770,'multiline':False]
['text':' readDataView adds the array to allObjs.','line_number':2776,'multiline':False]
['text':' A v1-format typed array','line_number':2819,'multiline':False]
['text':' readTypedArray adds the array to allObjs','line_number':2820,'multiline':False]
['text':' callbacks->read() might read other objects from the buffer.','line_number':2831,'multiline':False]
['text':' In startWrite we always write the object itself before calling','line_number':2832,'multiline':False]
['text':' the custom function. We should do the same here to keep','line_number':2833,'multiline':False]
['text':' indexing consistent.','line_number':2834,'multiline':False]
['text':' Old structured clone buffer. We must have read it from disk.','line_number':2869,'multiline':False]
['text':' Backward compatibility with old structured clone buffers. Value '0' was','line_number':2873,'multiline':False]
['text':' used for SameProcessSameThread scope.','line_number':2874,'multiline':False]
['text':' Bug 1434308 and bug 1458320 - the scopes stored in old IndexedDB','line_number':2888,'multiline':False]
['text':' clones are incorrect. Treat them as if they were DifferentProcess.','line_number':2889,'multiline':False]
['text':' Transferred ArrayBuffers in a DifferentProcess clone buffer','line_number':2952,'multiline':False]
['text':' are treated as if they weren't Transferred at all. We should','line_number':2953,'multiline':False]
['text':' only see SCTAG_TRANSFER_MAP_STORED_ARRAY_BUFFER.','line_number':2954,'multiline':False]
['text':' On failure, the buffer will still own the data (since its ownership','line_number':3004,'multiline':False]
['text':' will not get set to SCTAG_TMO_UNOWNED), so the data will be freed by','line_number':3005,'multiline':False]
['text':' DiscardTransferables.','line_number':3006,'multiline':False]
['text':' Mark the SCTAG_TRANSFER_MAP_* entry as no longer owned by the input','line_number':3011,'multiline':False]
['text':' buffer.','line_number':3012,'multiline':False]
['text':' Mark the whole transfer map as consumed.','line_number':3021,'multiline':False]
['text':' Read a |mutedErrors| boolean followed by a |source| string.','line_number':3070,'multiline':False]
['text':' The |mutedErrors| boolean is present in all new structured-clone data,','line_number':3071,'multiline':False]
['text':' but in older data it will be absent and only the |source| string will be','line_number':3072,'multiline':False]
['text':' found.','line_number':3073,'multiline':False]
['text':' Backwards compatibility: Handle missing |mutedErrors| boolean,','line_number':3083,'multiline':False]
['text':' this is actually just a |source| string.','line_number':3084,'multiline':False]
['text':' Safe default value.','line_number':3086,'multiline':False]
['text':' Invalid type.','line_number':3088,'multiline':False]
['text':' Don't specify a source ID when reading a cloned saved frame, as these IDs','line_number':3118,'multiline':False]
['text':' are only valid within a specific process.','line_number':3119,'multiline':False]
['text':' Class for counting "children" (actually parent frames) of the SavedFrames on','line_number':3164,'multiline':False]
['text':' the `objs` stack. When a SavedFrame is complete, it should have exactly 1','line_number':3165,'multiline':False]
['text':' parent frame.','line_number':3166,'multiline':False]
['text':'','line_number':3167,'multiline':False]
['text':' This class must be notified after every startRead() call.','line_number':3168,'multiline':False]
['text':'','line_number':3169,'multiline':False]
['text':' If we add other types with restrictions on the number of children, this','line_number':3170,'multiline':False]
['text':' should be expanded to handle those types as well.','line_number':3171,'multiline':False]
['text':'','line_number':3172,'multiline':False]
['text':' startRead() will have pushed any newly seen object onto the `objs` stack.','line_number':3184,'multiline':False]
['text':' If it did not read an object, or if the object it read was a backreference','line_number':3185,'multiline':False]
['text':' to an earlier object, the stack will be unchanged.','line_number':3186,'multiline':False]
['text':' No new object pushed.','line_number':3189,'multiline':False]
['text':' Push a new child counter (initialized to zero) for the new object.','line_number':3193,'multiline':False]
['text':' Not a SavedFrame; do nothing.','line_number':3200,'multiline':False]
['text':' Reading has reached the end of the children for an object. Check whether','line_number':3204,'multiline':False]
['text':' we saw the right number of children.','line_number':3205,'multiline':False]
['text':' While we are reading children, we need to know whether this is the first','line_number':3223,'multiline':False]
['text':' child seen or not, in order to avoid double-initializing in the error','line_number':3224,'multiline':False]
['text':' case.','line_number':3225,'multiline':False]
['text':' We are checking at a point where we have read 0 or more parent frames,','line_number':3227,'multiline':False]
['text':' in which case `obj` may not be on top of the `objs` stack anymore and','line_number':3228,'multiline':False]
['text':' the count on top of the `counts` stack will correspond to the most','line_number':3229,'multiline':False]
['text':' recently read frame, not `obj`. Use the remembered `counts` index from','line_number':3230,'multiline':False]
['text':' when `obj` *was* on top of the stack.','line_number':3231,'multiline':False]
['text':' Perform the whole recursive reading procedure.','line_number':3236,'multiline':False]
['text':' Start out by reading in the main object and pushing it onto the 'objs'','line_number':3250,'multiline':False]
['text':' stack. The data related to this object and its descendants extends from','line_number':3251,'multiline':False]
['text':' here to the SCTAG_END_OF_KEYS at the end of the stream.','line_number':3252,'multiline':False]
['text':' Stop when the stack shows that all objects have been read.','line_number':3257,'multiline':False]
['text':' What happens depends on the top obj on the objs stack.','line_number':3259,'multiline':False]
['text':' Pop the current obj off the stack, since we are done with it and','line_number':3273,'multiline':False]
['text':' its children.','line_number':3274,'multiline':False]
['text':' The input stream contains a sequence of "child" values, whose','line_number':3280,'multiline':False]
['text':' interpretation depends on the type of obj. These values can be','line_number':3281,'multiline':False]
['text':' anything, and startRead() will push onto 'objs' for any non-leaf','line_number':3282,'multiline':False]
['text':' value (i.e., anything that may contain children).','line_number':3283,'multiline':False]
['text':'','line_number':3284,'multiline':False]
['text':' startRead() will allocate the (empty) object, but note that when','line_number':3285,'multiline':False]
['text':' startRead() returns, 'key' is not yet initialized with any of its','line_number':3286,'multiline':False]
['text':' properties. Those will be filled in by returning to the head of this','line_number':3287,'multiline':False]
['text':' loop, processing the first child obj, and continuing until all','line_number':3288,'multiline':False]
['text':' children have been fully created.','line_number':3289,'multiline':False]
['text':'','line_number':3290,'multiline':False]
['text':' Note that this means the ordering in the stream is a little funky for','line_number':3291,'multiline':False]
['text':' things like Map. See the comment above traverseMap() for an example.','line_number':3292,'multiline':False]
['text':' Backwards compatibility: Null formerly indicated the end of','line_number':3300,'multiline':False]
['text':' object properties.','line_number':3301,'multiline':False]
['text':' Set object: the values between obj header (from startRead()) and','line_number':3309,'multiline':False]
['text':' SCTAG_END_OF_KEYS are all interpreted as values to add to the set.','line_number':3310,'multiline':False]
['text':' SavedFrame object: there is one following value, the parent SavedFrame,','line_number':3318,'multiline':False]
['text':' which is either null or another SavedFrame object.','line_number':3319,'multiline':False]
['text':' This is an error (more than one parent given), but it will be','line_number':3334,'multiline':False]
['text':' reported when the SavedFrame is complete so it can be handled along','line_number':3335,'multiline':False]
['text':' with the "no parent given" case.','line_number':3336,'multiline':False]
['text':' Everything else uses a series of key,value,key,value,... Value','line_number':3344,'multiline':False]
['text':' objects.','line_number':3345,'multiline':False]
['text':' For a Map, store those <key,value> pairs in the contained map','line_number':3352,'multiline':False]
['text':' data structure.','line_number':3353,'multiline':False]
['text':' For any other Object, interpret them as plain properties.','line_number':3358,'multiline':False]
['text':' Strings are associated with zones, not compartments,','line_number':3439,'multiline':False]
['text':' so we copy the string by wrapping it.','line_number':3440,'multiline':False]
['text':' V2 stores the length (nelems) in |data| and the arrayType separately.','line_number':3591,'multiline':False]
['text':' The current version stores the array type in |data| and the length','line_number':3601,'multiline':False]
['text':' (nelems) separately to support large TypedArrays.','line_number':3602,'multiline':False]
['text':' startWrite can write everything, thus we should check here','line_number':3638,'multiline':False]
['text':' and report error if the user passes a wrong type.','line_number':3639,'multiline':False]
['text':' We should use startWrite instead of writeTypedArray, because','line_number':3645,'multiline':False]
['text':' typed array is an object, we should add it to the |memory|','line_number':3646,'multiline':False]
['text':' (allObjs) list. Directly calling writeTypedArray won't add it.','line_number':3647,'multiline':False]
