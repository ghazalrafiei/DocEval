['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' This file declares the core data structures for LIR: storage allocations for','line_number':10,'multiline':False]
['text':' inputs and outputs, as well as the interface instructions must conform to.','line_number':11,'multiline':False]
['text':' Represents storage for an operand. For constants, the pointer is tagged','line_number':62,'multiline':False]
['text':' with a single bit, and the untagged pointer is a pointer to a Value.','line_number':63,'multiline':False]
['text':' 3 bits gives us enough for an interesting set of Kinds and also fits','line_number':67,'multiline':False]
['text':' within the alignment bits of pointers to Value, which are always','line_number':68,'multiline':False]
['text':' 8-byte aligned.','line_number':69,'multiline':False]
['text':' MConstant*.','line_number':80,'multiline':False]
['text':' Constant arbitrary index.','line_number':81,'multiline':False]
['text':' Use of a virtual register, with physical allocation policy.','line_number':82,'multiline':False]
['text':' General purpose register.','line_number':83,'multiline':False]
['text':' Floating-point register.','line_number':84,'multiline':False]
['text':' Stack slot.','line_number':85,'multiline':False]
['text':' Stack area.','line_number':86,'multiline':False]
['text':' Argument slot.','line_number':87,'multiline':False]
['text':' The MConstant pointer must have its low bits cleared.','line_number':133,'multiline':False]
['text':' Whether the physical register for this operand may be reused for a def.','line_number':207,'multiline':False]
['text':' The REG field will hold the register code for any Register or','line_number':212,'multiline':False]
['text':' FloatRegister, though not for an AnyRegister.','line_number':213,'multiline':False]
['text':' Virtual registers get the remaining bits.','line_number':219,'multiline':False]
['text':' Input should be in a read-only register or stack slot.','line_number':226,'multiline':False]
['text':' Input must be in a read-only register.','line_number':229,'multiline':False]
['text':' Input must be in a specific, read-only register.','line_number':232,'multiline':False]
['text':' Keep the used virtual register alive, and use whatever allocation is','line_number':235,'multiline':False]
['text':' available. This is similar to ANY but hints to the register allocator','line_number':236,'multiline':False]
['text':' that it is never useful to optimize this site.','line_number':237,'multiline':False]
['text':' Input must be allocated on the stack.  Only used when extracting stack','line_number':240,'multiline':False]
['text':' results from stack result areas.','line_number':241,'multiline':False]
['text':' For snapshot inputs, indicates that the associated instruction will','line_number':244,'multiline':False]
['text':' write this input to its output register before bailing out.','line_number':245,'multiline':False]
['text':' The register allocator may thus allocate that output register, and','line_number':246,'multiline':False]
['text':' does not need to keep the virtual register alive (alternatively,','line_number':247,'multiline':False]
['text':' this may be treated as KEEPALIVE).','line_number':248,'multiline':False]
['text':' Arbitrary constant index.','line_number':375,'multiline':False]
['text':' Stack slots are indices into the stack. The indices are byte indices.','line_number':388,'multiline':False]
['text':' Stack area indicates a contiguous stack allocation meant to receive call','line_number':396,'multiline':False]
['text':' results that don't fit in registers.','line_number':397,'multiline':False]
['text':' Byte index of base of stack area, in the same coordinate space as','line_number':403,'multiline':False]
['text':' LStackSlot::slot().','line_number':404,'multiline':False]
['text':' Size in bytes of the stack area.','line_number':408,'multiline':False]
['text':' Arguments are reverse indices into the stack. The indices are byte indices.','line_number':432,'multiline':False]
['text':' Represents storage for a definition.','line_number':445,'multiline':False]
['text':' Bits containing policy, type, and virtual register.','line_number':447,'multiline':False]
['text':' Before register allocation, this optionally contains a fixed policy.','line_number':450,'multiline':False]
['text':' Register allocation assigns this field to a physical policy if none is','line_number':451,'multiline':False]
['text':' fixed.','line_number':452,'multiline':False]
['text':'','line_number':453,'multiline':False]
['text':' Right now, pre-allocated outputs are limited to the following:','line_number':454,'multiline':False]
['text':'   * Physical argument stack slots.','line_number':455,'multiline':False]
['text':'   * Physical registers.','line_number':456,'multiline':False]
['text':' Note that definitions, by default, are always allocated a register,','line_number':472,'multiline':False]
['text':' unless the policy specifies that an input can be re-used and that input','line_number':473,'multiline':False]
['text':' is a stack slot.','line_number':474,'multiline':False]
['text':' The policy is predetermined by the LAllocation attached to this','line_number':476,'multiline':False]
['text':' definition. The allocation may be:','line_number':477,'multiline':False]
['text':'   * A register, which may not appear as any fixed temporary.','line_number':478,'multiline':False]
['text':'   * A stack slot or argument.','line_number':479,'multiline':False]
['text':'','line_number':480,'multiline':False]
['text':' Register allocation will not modify a fixed allocation.','line_number':481,'multiline':False]
['text':' A random register of an appropriate class will be assigned.','line_number':484,'multiline':False]
['text':' An area on the stack must be assigned.  Used when defining stack results','line_number':487,'multiline':False]
['text':' and stack result areas.','line_number':488,'multiline':False]
['text':' One definition per instruction must re-use the first input','line_number':491,'multiline':False]
['text':' allocation, which (for now) must be a register.','line_number':492,'multiline':False]
['text':' Generic, integer or pointer-width data (GPR).','line_number':497,'multiline':False]
['text':' int32 data (GPR).','line_number':498,'multiline':False]
['text':' Pointer that may be collected as garbage (GPR).','line_number':499,'multiline':False]
['text':' Slots/elements pointer that may be moved by minor GCs (GPR).','line_number':500,'multiline':False]
['text':' 32-bit floating-point value (FPU).','line_number':501,'multiline':False]
['text':' 64-bit floating-point value (FPU).','line_number':502,'multiline':False]
['text':' 128-bit SIMD vector (FPU).','line_number':503,'multiline':False]
['text':' A variable-size stack allocation that may contain objects.','line_number':504,'multiline':False]
['text':' A type virtual register must be followed by a payload virtual','line_number':506,'multiline':False]
['text':' register, as both will be tracked as a single gcthing.','line_number':507,'multiline':False]
['text':' Joined box, for punbox systems. (GPR, gcthing)','line_number':511,'multiline':False]
['text':' MOZ_ASSERT(index != 0);','line_number':580,'multiline':False]
['text':' The stack slot allocator doesn't currently support allocating','line_number':611,'multiline':False]
['text':' 1-byte slots, so for now we lower MIRType::Boolean into INT32.','line_number':612,'multiline':False]
['text':' Forward declarations of LIR types.','line_number':672,'multiline':False]
['text':' The common base class for LPhi and LInstruction.','line_number':683,'multiline':False]
['text':' Bitfields below are all uint32_t to make sure MSVC packs them correctly.','line_number':693,'multiline':False]
['text':' LPhi::numOperands() may not fit in this bitfield, so we only use this','line_number':697,'multiline':False]
['text':' field for LInstruction.','line_number':698,'multiline':False]
['text':' For LInstruction, the first operand is stored at offset','line_number':703,'multiline':False]
['text':' sizeof(LInstruction) + nonPhiOperandsOffset_ * sizeof(uintptr_t).','line_number':704,'multiline':False]
['text':' Hook for opcodes to add extra high level detail about what code will be','line_number':748,'multiline':False]
['text':' emitted for the op.','line_number':749,'multiline':False]
['text':' Returns the number of outputs of this instruction. If an output is','line_number':764,'multiline':False]
['text':' unallocated, it is an LDefinition, defining a virtual register.','line_number':765,'multiline':False]
['text':' Does this call preserve the given register?','line_number':770,'multiline':False]
['text':' By default, it is assumed that all registers are clobbered by a call.','line_number':771,'multiline':False]
['text':' Untyped MIR for this op. Prefer mir() methods in subclasses. ','line_number':782,'multiline':True]
['text':' For an instruction which has a MUST_REUSE_INPUT output, whether that','line_number':788,'multiline':False]
['text':' output register will be restored to its original value when bailing out.','line_number':789,'multiline':False]
['text':' Opcode testing and casts.','line_number':801,'multiline':False]
['text':' Note: GenerateOpcodeFiles.py generates LOpcodesGenerated.h based on this','line_number':809,'multiline':False]
['text':' macro.','line_number':810,'multiline':False]
['text':' This snapshot could be set after a ResumePoint.  It is used to restart','line_number':818,'multiline':False]
['text':' from the resume point pc.','line_number':819,'multiline':False]
['text':' Structure capturing the set of stack slots and registers which are known','line_number':822,'multiline':False]
['text':' to hold either gcthings or Values.','line_number':823,'multiline':False]
['text':' Returns information about temporary registers needed. Each temporary','line_number':867,'multiline':False]
['text':' register is an LDefinition with a fixed or virtual register and','line_number':868,'multiline':False]
['text':' either GENERAL, FLOAT32, or DOUBLE type.','line_number':869,'multiline':False]
['text':' Phi is a pseudo-instruction that emits no code, and is an annotation for the','line_number':918,'multiline':False]
['text':' register allocator. Like its equivalent in MIR, phis are collected at the','line_number':919,'multiline':False]
['text':' top of blocks and are meant to be executed in parallel, choosing the input','line_number':920,'multiline':False]
['text':' corresponding to the predecessor taken in the control flow graph.','line_number':921,'multiline':False]
['text':' nonPhiNumOperands = ','line_number':931,'multiline':True]
['text':' numDefs = ','line_number':932,'multiline':True]
['text':' numTemps = ','line_number':933,'multiline':True]
['text':' Phis don't have temps, so calling numTemps/getTemp is pointless.','line_number':956,'multiline':False]
['text':' The last instruction is a control flow instruction which does not have','line_number':1009,'multiline':False]
['text':' any output.','line_number':1010,'multiline':False]
['text':' Return the label to branch to when branching to this block.','line_number':1015,'multiline':False]
['text':' Test whether this basic block is empty except for a simple goto, and','line_number':1024,'multiline':False]
['text':' which is not forming a loop. No code will be emitted for such blocks.','line_number':1025,'multiline':False]
['text':' Override the methods in LInstruction with more optimized versions','line_number':1044,'multiline':False]
['text':' for when we know the exact instruction type.','line_number':1045,'multiline':False]
['text':' Default accessors, assuming a single input and output, respectively.','line_number':1081,'multiline':False]
['text':' namespace details','line_number':1099,'multiline':False]
['text':' Override the methods in LInstruction with more optimized versions','line_number':1135,'multiline':False]
['text':' for when we know the exact instruction type.','line_number':1136,'multiline':False]
['text':' List of instructions needed to recover the stack frames.','line_number':1211,'multiline':False]
['text':' Outer frames are stored before inner frames.','line_number':1212,'multiline':False]
['text':' Cached offset where this resume point is encoded.','line_number':1215,'multiline':False]
['text':' Fill the instruction vector such as all instructions needed for the','line_number':1221,'multiline':False]
['text':' recovery are pushed before the current instruction.','line_number':1222,'multiline':False]
['text':' Resume point of the inner most function.','line_number':1231,'multiline':False]
['text':' de-virtualize MResumePoint::getOperand calls.','line_number':1277,'multiline':False]
['text':' de-virtualize MResumePoint::getOperand calls.','line_number':1283,'multiline':False]
['text':' An LSnapshot is the reflection of an MResumePoint in LIR. Unlike','line_number':1311,'multiline':False]
['text':' MResumePoints, they cannot be shared, as they are filled in by the register','line_number':1312,'multiline':False]
['text':' allocator in order to capture the precise low-level stack state in between an','line_number':1313,'multiline':False]
['text':' instruction's input and output. During code generation, LSnapshots are','line_number':1314,'multiline':False]
['text':' compressed and saved in the compiled script.','line_number':1315,'multiline':False]
['text':' Flag indicating whether this is a slot in the stack or argument space.','line_number':1371,'multiline':False]
['text':' Byte offset of the slot, as in LStackSlot or LArgument.','line_number':1374,'multiline':False]
['text':' The information in a safepoint describes the registers and gc related','line_number':1402,'multiline':False]
['text':' values that are live at the start of the associated instruction.','line_number':1403,'multiline':False]
['text':' The set of registers which are live at an OOL call made within the','line_number':1405,'multiline':False]
['text':' instruction. This includes any registers for inputs which are not','line_number':1406,'multiline':False]
['text':' use-at-start, any registers for temps, and any registers live after the','line_number':1407,'multiline':False]
['text':' call except outputs of the instruction.','line_number':1408,'multiline':False]
['text':'','line_number':1409,'multiline':False]
['text':' For call instructions, the live regs are empty. Call instructions may','line_number':1410,'multiline':False]
['text':' have register inputs or temporaries, which will *not* be in the live','line_number':1411,'multiline':False]
['text':' registers: if passed to the call, the values passed will be marked via','line_number':1412,'multiline':False]
['text':' MarkJitExitFrame, and no registers can be live after the instruction','line_number':1413,'multiline':False]
['text':' except its outputs.','line_number':1414,'multiline':False]
['text':' The subset of liveRegs which contains gcthing pointers.','line_number':1417,'multiline':False]
['text':' Clobbered regs of the current instruction. This set is never written to','line_number':1421,'multiline':False]
['text':' the safepoint; it's only used by assertions during compilation.','line_number':1422,'multiline':False]
['text':' Offset to a position in the safepoint stream, or','line_number':1426,'multiline':False]
['text':' INVALID_SAFEPOINT_OFFSET.','line_number':1427,'multiline':False]
['text':' Assembler buffer displacement to OSI point's call location.','line_number':1430,'multiline':False]
['text':' List of slots which have gcthing pointers.','line_number':1433,'multiline':False]
['text':' List of registers (in liveRegs) and slots which contain pieces of Values.','line_number':1437,'multiline':False]
['text':' List of slots which have Values.','line_number':1440,'multiline':False]
['text':' The subset of liveRegs which have Values.','line_number':1443,'multiline':False]
['text':' The subset of liveRegs which contains pointers to slots/elements.','line_number':1447,'multiline':False]
['text':' List of slots which have slots/elements pointers.','line_number':1450,'multiline':False]
['text':' Wasm only: with what kind of instruction is this LSafepoint associated?','line_number':1453,'multiline':False]
['text':' true => wasm trap, false => wasm call.','line_number':1454,'multiline':False]
['text':' Wasm only: what is the value of masm.framePushed() that corresponds to','line_number':1457,'multiline':False]
['text':' the lowest-addressed word covered by the StackMap that we will generate','line_number':1458,'multiline':False]
['text':' from this LSafepoint?  This depends on the instruction:','line_number':1459,'multiline':False]
['text':'','line_number':1460,'multiline':False]
['text':' if isWasmTrap_ == true:','line_number':1461,'multiline':False]
['text':'    masm.framePushed() unmodified.  Note that when constructing the','line_number':1462,'multiline':False]
['text':'    StackMap we will add entries below this point to take account of','line_number':1463,'multiline':False]
['text':'    registers dumped on the stack as a result of the trap.','line_number':1464,'multiline':False]
['text':'','line_number':1465,'multiline':False]
['text':' if isWasmTrap_ == false:','line_number':1466,'multiline':False]
['text':'    masm.framePushed() - StackArgAreaSizeUnaligned(arg types for the call),','line_number':1467,'multiline':False]
['text':'    because the map does not include the outgoing args themselves, but','line_number':1468,'multiline':False]
['text':'    it does cover any and all alignment space above them.','line_number':1469,'multiline':False]
['text':' Every register in valueRegs and gcRegs should also be in liveRegs.','line_number':1474,'multiline':False]
['text':' Return true if all GC-managed pointers from `alloc` are recorded in this','line_number':1584,'multiline':False]
['text':' safepoint.','line_number':1585,'multiline':False]
['text':' vregs for nunbox pairs are adjacent, with the type coming first.','line_number':1617,'multiline':False]
['text':' vregs for nunbox pairs are adjacent, with the type coming first.','line_number':1639,'multiline':False]
['text':' Look for some allocation for the specified type vreg, to go with a','line_number':1650,'multiline':False]
['text':' partial nunbox entry for the payload. Note that we don't need to','line_number':1651,'multiline':False]
['text':' look at the value slots in the safepoint, as these aren't used by','line_number':1652,'multiline':False]
['text':' register allocators which add partial nunbox entries.','line_number':1653,'multiline':False]
['text':' JS_PUNBOX64','line_number':1722,'multiline':False]
['text':' In general, pointer arithmetic on code is bad, but in this case,','line_number':1731,'multiline':False]
['text':' getting the return address from a call instruction, stepping over pools','line_number':1732,'multiline':False]
['text':' would be wrong.','line_number':1733,'multiline':False]
['text':' Iterate on the snapshot when iteration over all operands is done.','line_number':1761,'multiline':False]
['text':' constantPool_ is a mozilla::Vector, not a js::Vector, because','line_number':1822,'multiline':False]
['text':' js::Vector<Value> is prohibited as unsafe. This particular Vector of','line_number':1823,'multiline':False]
['text':' Values is safe because it is only used within the scope of an','line_number':1824,'multiline':False]
['text':' AutoSuppressGC (in IonCompile), which inhibits GC.','line_number':1825,'multiline':False]
['text':' Number of stack slots needed for local spills.','line_number':1834,'multiline':False]
['text':' Number of stack slots needed for argument construction for calls.','line_number':1836,'multiline':False]
['text':' Virtual registers are 1-based, not 0-based, so add one as a','line_number':1861,'multiline':False]
['text':' convenience for 0-based arrays.','line_number':1862,'multiline':False]
['text':' Return the localSlotCount() value rounded up so that it satisfies the','line_number':1871,'multiline':False]
['text':' platform stack alignment requirement, and so that it's a multiple of','line_number':1872,'multiline':False]
['text':' the number of slots per Value.','line_number':1873,'multiline':False]
['text':' Round to JitStackAlignment, and implicitly to sizeof(Value) as','line_number':1875,'multiline':False]
['text':' JitStackAlignment is a multiple of sizeof(Value). These alignments','line_number':1876,'multiline':False]
['text':' are needed for spilling SIMD registers properly, and for','line_number':1877,'multiline':False]
['text':' StackOffsetOfPassedArg which rounds argument slots to 8-byte','line_number':1878,'multiline':False]
['text':' boundaries.','line_number':1879,'multiline':False]
['text':' namespace jit','line_number':1925,'multiline':False]
['text':' namespace js','line_number':1926,'multiline':False]
['text':' namespace jit','line_number':1993,'multiline':False]
['text':' namespace js','line_number':1994,'multiline':False]
['text':' jit_LIR_h ','line_number':1996,'multiline':True]
