['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' AArch64 has 32 64-bit integer registers, x0 though x31.','line_number':24,'multiline':False]
['text':'','line_number':25,'multiline':False]
['text':'  x31 (or, more accurately, the integer register with encoding 31, since','line_number':26,'multiline':False]
['text':'  there is no x31 per se) is special and functions as both the stack pointer','line_number':27,'multiline':False]
['text':'  and a zero register.','line_number':28,'multiline':False]
['text':'','line_number':29,'multiline':False]
['text':'  The bottom 32 bits of each of the X registers is accessible as w0 through','line_number':30,'multiline':False]
['text':'  w31. The program counter is not accessible as a register.','line_number':31,'multiline':False]
['text':'','line_number':32,'multiline':False]
['text':' SIMD and scalar floating-point registers share a register bank.','line_number':33,'multiline':False]
['text':'  32 bit float registers are s0 through s31.','line_number':34,'multiline':False]
['text':'  64 bit double registers are d0 through d31.','line_number':35,'multiline':False]
['text':'  128 bit SIMD registers are v0 through v31.','line_number':36,'multiline':False]
['text':'  e.g., s0 is the bottom 32 bits of d0, which is the bottom 64 bits of v0.','line_number':37,'multiline':False]
['text':' AArch64 Calling Convention:','line_number':39,'multiline':False]
['text':'  x0 - x7: arguments and return value','line_number':40,'multiline':False]
['text':'  x8: indirect result (struct) location','line_number':41,'multiline':False]
['text':'  x9 - x15: temporary registers','line_number':42,'multiline':False]
['text':'  x16 - x17: intra-call-use registers (PLT, linker)','line_number':43,'multiline':False]
['text':'  x18: platform specific use (TLS)','line_number':44,'multiline':False]
['text':'  x19 - x28: callee-saved registers','line_number':45,'multiline':False]
['text':'  x29: frame pointer','line_number':46,'multiline':False]
['text':'  x30: link register','line_number':47,'multiline':False]
['text':' AArch64 Calling Convention for Floats:','line_number':49,'multiline':False]
['text':'  d0 - d7: arguments and return value','line_number':50,'multiline':False]
['text':'  d8 - d15: callee-saved registers','line_number':51,'multiline':False]
['text':'   Bits 64:128 are not saved for v8-v15.','line_number':52,'multiline':False]
['text':'  d16 - d31: temporary registers','line_number':53,'multiline':False]
['text':' AArch64 does not have soft float.','line_number':55,'multiline':False]
['text':' MacroAssembler scratch register 1.','line_number':94,'multiline':False]
['text':' MacroAssembler scratch register 2.','line_number':97,'multiline':False]
['text':' Platform-specific use (TLS).','line_number':100,'multiline':False]
['text':' Special: both stack pointer and a zero register.','line_number':131,'multiline':False]
['text':' No named special-function registers.','line_number':173,'multiline':False]
['text':' PseudoStackPointer.','line_number':201,'multiline':False]
['text':' First scratch register.','line_number':202,'multiline':False]
['text':' Second scratch register.','line_number':203,'multiline':False]
['text':' Registers returned from a JS -> JS call.','line_number':208,'multiline':False]
['text':' Registers returned from a JS -> C call.','line_number':211,'multiline':False]
['text':' Smallest integer type that can hold a register bitmask.','line_number':217,'multiline':False]
['text':' 128-bit bitset for FloatRegisters::SetType.','line_number':223,'multiline':False]
['text':' The order (hi, lo) looks best in the debugger.','line_number':226,'multiline':False]
['text':' We must avoid shifting by the word width, which is complex.  Inlining plus','line_number':254,'multiline':False]
['text':' shift-by-constant will remove a lot of code in the normal case.','line_number':255,'multiline':False]
['text':' Scratch register.','line_number':422,'multiline':False]
['text':' Eight bits: (invalid << 7) | (kind << 5) | encoding','line_number':425,'multiline':False]
['text':' clang-format off','line_number':435,'multiline':False]
['text':' clang-format on','line_number':452,'multiline':False]
['text':' Without d31, the scratch register.','line_number':465,'multiline':False]
['text':' s31 is the ScratchFloatReg.','line_number':488,'multiline':False]
['text':' d31 is the ScratchFloatReg.','line_number':515,'multiline':False]
['text':' Content spilled during bailouts.','line_number':525,'multiline':False]
['text':' assert() not available in constexpr function.','line_number':533,'multiline':False]
['text':' assert(c < Total);','line_number':534,'multiline':False]
['text':' assert() not available in constexpr function.','line_number':539,'multiline':False]
['text':' assert(c < Total && ((c >> 5) & 3) < NumTypes);','line_number':540,'multiline':False]
['text':' When our only strategy for far jumps is to encode the offset directly, and','line_number':552,'multiline':False]
['text':' not insert any jump islands during assembly for even further jumps, then the','line_number':553,'multiline':False]
['text':' architecture restricts us to -2^27 .. 2^27-4, to fit into a signed 28-bit','line_number':554,'multiline':False]
['text':' value.  We further reduce this range to allow the far-jump inserting code to','line_number':555,'multiline':False]
['text':' have some breathing room.','line_number':556,'multiline':False]
['text':' Although sp is only usable if 16-byte alignment is kept,','line_number':563,'multiline':False]
['text':' the Pseudo-StackPointer enables use of 8-byte alignment.','line_number':564,'multiline':False]
['text':' These fields only hold valid values: an invalid register is always','line_number':596,'multiline':False]
['text':' represented as a valid encoding and kind with the invalid_ bit set.','line_number':597,'multiline':False]
['text':' 32 encodings','line_number':598,'multiline':False]
['text':' Double, Single, Simd128','line_number':599,'multiline':False]
['text':' assert(uint32_t(encoding) < Codes::TotalPhys);','line_number':607,'multiline':False]
['text':' assert(!invalid_);','line_number':658,'multiline':False]
['text':' This function mostly exists for the ARM backend.  It is to ensure that two','line_number':682,'multiline':False]
['text':' floating point registers' types are equivalent.  e.g. S0 is not equivalent','line_number':683,'multiline':False]
['text':' to D16, since S0 holds a float32, and D16 holds a Double.','line_number':684,'multiline':False]
['text':' Since all floating point registers on x86 and x64 are equivalent, it is','line_number':685,'multiline':False]
['text':' reasonable for this function to do the same.','line_number':686,'multiline':False]
['text':' For N in 0..31, if any of sN, dN or qN is a member of `s`, the','line_number':724,'multiline':False]
['text':' returned set will contain all of sN, dN and qN.','line_number':725,'multiline':False]
['text':' ARM/D32 has double registers that cannot be treated as float32.','line_number':754,'multiline':False]
['text':' Luckily, ARMv8 doesn't have the same misfortune.','line_number':755,'multiline':False]
['text':' ARM prior to ARMv8 also has doubles that alias multiple floats.','line_number':758,'multiline':False]
['text':' Again, ARMv8 is in the clear.','line_number':759,'multiline':False]
['text':' namespace jit','line_number':766,'multiline':False]
['text':' namespace js','line_number':767,'multiline':False]
['text':' jit_arm64_Architecture_arm64_h','line_number':769,'multiline':False]
