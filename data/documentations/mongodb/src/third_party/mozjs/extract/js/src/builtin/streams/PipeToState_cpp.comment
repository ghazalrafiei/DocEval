['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' ReadableStream.prototype.pipeTo state. ','line_number':7,'multiline':True]
['text':' MOZ_ASSERT','line_number':11,'multiline':False]
['text':' mozilla::Maybe, mozilla::Nothing, mozilla::Some','line_number':12,'multiline':False]
['text':' JS_ReportErrorNumberASCII','line_number':14,'multiline':False]
['text':' js::RejectPromiseWithPendingError','line_number':16,'multiline':False]
['text':' js::ReadableStream','line_number':17,'multiline':False]
['text':' js::CreateReadableStreamDefaultReader, js::ForAuthorCodeBool, js::ReadableStreamDefaultReader, js::ReadableStreamReaderGenericRelease','line_number':18,'multiline':False]
['text':' js::WritableStream','line_number':19,'multiline':False]
['text':' js::CreateWritableStreamDefaultWriter, js::WritableStreamDefaultWriter','line_number':20,'multiline':False]
['text':' js::WritableStreamCloseQueuedOrInFlight','line_number':21,'multiline':False]
['text':' js::WritableStreamDefaultWriter{GetDesiredSize,Release,Write}','line_number':22,'multiline':False]
['text':' JS::CallArgsFromVp, JS::CallArgs','line_number':23,'multiline':False]
['text':' JSClass, JSCLASS_HAS_RESERVED_SLOTS','line_number':24,'multiline':False]
['text':' js::GetErrorMessage, JSMSG_*','line_number':25,'multiline':False]
['text':' JS::AddPromiseReactions','line_number':26,'multiline':False]
['text':' JS::Handle, JS::Rooted','line_number':27,'multiline':False]
['text':' JS::{,Int32,Magic,Object}Value, JS::UndefinedHandleValue','line_number':28,'multiline':False]
['text':' JSContext','line_number':29,'multiline':False]
['text':' js::PromiseObject','line_number':30,'multiline':False]
['text':' JSRuntime','line_number':31,'multiline':False]
['text':' js::ExtraValueFromHandler, js::NewHandler{,WithExtraValue}, js::TargetFromHandler','line_number':33,'multiline':False]
['text':' js::UnwrapReaderFromStream, js::UnwrapStreamFromReader','line_number':34,'multiline':False]
['text':' js::UnwrapWriterFromStream','line_number':35,'multiline':False]
['text':' js::UnwrapStreamFromWriter','line_number':36,'multiline':False]
['text':' JSContext::check','line_number':37,'multiline':False]
['text':' js::NewBuiltinClassInstance','line_number':38,'multiline':False]
['text':' js::AutoRealm','line_number':39,'multiline':False]
['text':' Step 1: Perform ! WritableStreamDefaultWriterRelease(writer).','line_number':103,'multiline':False]
['text':' Step 2: Perform ! ReadableStreamReaderGenericRelease(reader).','line_number':110,'multiline':False]
['text':' Step 3: If signal is not undefined, remove abortAlgorithm from signal.','line_number':117,'multiline':False]
['text':' XXX','line_number':118,'multiline':False]
['text':' Step 4: If error was given, reject promise with error.','line_number':123,'multiline':False]
['text':' Step 5: Otherwise, resolve promise with undefined.','line_number':129,'multiline':False]
['text':' Shutdown with an action, steps d-f:','line_number':154,'multiline':False]
['text':'   d. Let p be the result of performing action.','line_number':155,'multiline':False]
['text':'   e. Upon fulfillment of p, finalize, passing along originalError if it was','line_number':156,'multiline':False]
['text':'      given.','line_number':157,'multiline':False]
['text':'   f. Upon rejection of p with reason newError, finalize with newError.','line_number':158,'multiline':False]
['text':' Step d: Let p be the result of performing action.','line_number':162,'multiline':False]
['text':' This corresponds to the action performed by |abortAlgorithm| in','line_number':165,'multiline':False]
['text':' ReadableStreamPipeTo step 14.1.5.','line_number':166,'multiline':False]
['text':' From ReadableStreamPipeTo:','line_number':170,'multiline':False]
['text':' Step 14.1.2: Let actions be an empty ordered set.','line_number':171,'multiline':False]
['text':' Step 14.1.3: If preventAbort is false, append the following action to','line_number':172,'multiline':False]
['text':'              actions:','line_number':173,'multiline':False]
['text':' Step 14.1.3.1: If dest.[[state]] is "writable", return','line_number':174,'multiline':False]
['text':'                ! WritableStreamAbort(dest, error).','line_number':175,'multiline':False]
['text':' Step 14.1.3.2: Otherwise, return a promise resolved with undefined.','line_number':176,'multiline':False]
['text':' Step 14.1.4: If preventCancel is false, append the following action','line_number':177,'multiline':False]
['text':'               action to actions:','line_number':178,'multiline':False]
['text':' Step 14.1.4.1.: If source.[[state]] is "readable", return','line_number':179,'multiline':False]
['text':'                 ! ReadableStreamCancel(source, error).','line_number':180,'multiline':False]
['text':' Step 14.1.4.2: Otherwise, return a promise resolved with undefined.','line_number':181,'multiline':False]
['text':' This corresponds to the action in "shutdown with an action of','line_number':188,'multiline':False]
['text':' ! WritableStreamAbort(dest, source.[[storedError]]) and with','line_number':189,'multiline':False]
['text':' source.[[storedError]]."','line_number':190,'multiline':False]
['text':' This corresponds to two actions:','line_number':206,'multiline':False]
['text':'','line_number':207,'multiline':False]
['text':' * The action in "shutdown with an action of','line_number':208,'multiline':False]
['text':'   ! ReadableStreamCancel(source, dest.[[storedError]]) and with','line_number':209,'multiline':False]
['text':'   dest.[[storedError]]" as used in "Errors must be propagated backward:','line_number':210,'multiline':False]
['text':'   if dest.[[state]] is or becomes 'errored'".','line_number':211,'multiline':False]
['text':' * The action in "shutdown with an action of','line_number':212,'multiline':False]
['text':'   ! ReadableStreamCancel(source, destClosed) and with destClosed" as used','line_number':213,'multiline':False]
['text':'   in "Closing must be propagated backward: if','line_number':214,'multiline':False]
['text':'   ! WritableStreamCloseQueuedOrInFlight(dest) is true or dest.[[state]]','line_number':215,'multiline':False]
['text':'   is 'closed'".','line_number':216,'multiline':False]
['text':'','line_number':217,'multiline':False]
['text':' The different reason-values are passed as |error|.','line_number':218,'multiline':False]
['text':' This corresponds to the action in "shutdown with an action of','line_number':235,'multiline':False]
['text':' ! WritableStreamDefaultWriterCloseWithErrorPropagation(writer)" as done','line_number':236,'multiline':False]
['text':' in "Closing must be propagated forward: if source.[[state]] is or becomes','line_number':237,'multiline':False]
['text':' 'closed'".','line_number':238,'multiline':False]
['text':' just for good measure: we don't depend on this','line_number':243,'multiline':False]
['text':' Step e: Upon fulfillment of p, finalize, passing along originalError if it','line_number':253,'multiline':False]
['text':'         was given.','line_number':254,'multiline':False]
['text':' Step f: Upon rejection of p with reason newError, finalize with newError.','line_number':267,'multiline':False]
['text':' Shutdown with an action: if any of the above requirements ask to shutdown','line_number':314,'multiline':False]
['text':' with an action action, optionally with an error originalError, then:','line_number':315,'multiline':False]
['text':' Step a: If shuttingDown is true, abort these substeps.','line_number':322,'multiline':False]
['text':' Step b: Set shuttingDown to true.','line_number':327,'multiline':False]
['text':' Save the action away for later, potentially asynchronous, use.','line_number':330,'multiline':False]
['text':' Step c: If dest.[[state]] is "writable" and','line_number':333,'multiline':False]
['text':'         ! WritableStreamCloseQueuedOrInFlight(dest) is false,','line_number':334,'multiline':False]
['text':' Step c.i:  If any chunks have been read but not yet written, write them','line_number':340,'multiline':False]
['text':'            to dest.','line_number':341,'multiline':False]
['text':'','line_number':342,'multiline':False]
['text':' Any chunk that has been read, will have been processed and a pending','line_number':343,'multiline':False]
['text':' write for it created by this point.  (A pending read has not been "read".','line_number':344,'multiline':False]
['text':' And any pending read, will not be processed into a pending write because','line_number':345,'multiline':False]
['text':' of the |state->setShuttingDown()| above in concert with the early exit','line_number':346,'multiline':False]
['text':' in this case in |ReadFulfilled|.)','line_number':347,'multiline':False]
['text':' Step c.ii: Wait until every chunk that has been read has been written','line_number':349,'multiline':False]
['text':'            (i.e. the corresponding promises have settled).','line_number':350,'multiline':False]
['text':' If no last write request was ever created, we can fall through and','line_number':370,'multiline':False]
['text':' synchronously perform the remaining steps.','line_number':371,'multiline':False]
['text':' Step d: Let p be the result of performing action.','line_number':374,'multiline':False]
['text':' Step e: Upon fulfillment of p, finalize, passing along originalError if it','line_number':375,'multiline':False]
['text':'         was given.','line_number':376,'multiline':False]
['text':' Step f: Upon rejection of p with reason newError, finalize with newError.','line_number':377,'multiline':False]
['text':' Shutdown: if any of the above requirements or steps ask to shutdown,','line_number':381,'multiline':False]
['text':' optionally with an error error, then:','line_number':382,'multiline':False]
['text':' Step a: If shuttingDown is true, abort these substeps.','line_number':388,'multiline':False]
['text':' Step b: Set shuttingDown to true.','line_number':393,'multiline':False]
['text':' Step c: If dest.[[state]] is "writable" and','line_number':396,'multiline':False]
['text':'         ! WritableStreamCloseQueuedOrInFlight(dest) is false,','line_number':397,'multiline':False]
['text':' Step 1: If any chunks have been read but not yet written, write them to','line_number':403,'multiline':False]
['text':'         dest.','line_number':404,'multiline':False]
['text':'','line_number':405,'multiline':False]
['text':' Any chunk that has been read, will have been processed and a pending','line_number':406,'multiline':False]
['text':' write for it created by this point.  (A pending read has not been "read".','line_number':407,'multiline':False]
['text':' And any pending read, will not be processed into a pending write because','line_number':408,'multiline':False]
['text':' of the |state->setShuttingDown()| above in concert with the early exit','line_number':409,'multiline':False]
['text':' in this case in |ReadFulfilled|.)','line_number':410,'multiline':False]
['text':' Step 2: Wait until every chunk that has been read has been written','line_number':412,'multiline':False]
['text':'         (i.e. the corresponding promises have settled).','line_number':413,'multiline':False]
['text':' If no last write request was ever created, we can fall through and','line_number':432,'multiline':False]
['text':' synchronously perform the remaining steps.','line_number':433,'multiline':False]
['text':' Step d: Finalize, passing along error if it was given.','line_number':436,'multiline':False]
['text':'*
 * Streams spec, 3.4.11. ReadableStreamPipeTo step 14:
 * "a. Errors must be propagated forward: if source.[[state]] is or becomes
 * 'errored', then..."
 ','line_number':440,'multiline':True]
['text':' If |source| becomes errored not during a pending read, it's clear we must','line_number':455,'multiline':False]
['text':' react immediately.','line_number':456,'multiline':False]
['text':'','line_number':457,'multiline':False]
['text':' But what if |source| becomes errored *during* a pending read?  Should this','line_number':458,'multiline':False]
['text':' first error, or the pending-read second error, predominate?  Two semantics','line_number':459,'multiline':False]
['text':' are possible when |source|/|dest| become closed or errored while there's a','line_number':460,'multiline':False]
['text':' pending read:','line_number':461,'multiline':False]
['text':'','line_number':462,'multiline':False]
['text':'   1. Wait until the read fulfills or rejects, then respond to the','line_number':463,'multiline':False]
['text':'      closure/error without regard to the read having fulfilled or rejected.','line_number':464,'multiline':False]
['text':'      (This will simply not react to the read being rejected, or it will','line_number':465,'multiline':False]
['text':'      queue up the read chunk to be written during shutdown.)','line_number':466,'multiline':False]
['text':'   2. React to the closure/error immediately per "Error and close states','line_number':467,'multiline':False]
['text':'      must be propagated".  Then when the read fulfills or rejects later, do','line_number':468,'multiline':False]
['text':'      nothing.','line_number':469,'multiline':False]
['text':'','line_number':470,'multiline':False]
['text':' The spec doesn't clearly require either semantics.  It requires that','line_number':471,'multiline':False]
['text':' *already-read* chunks be written (at least if |dest| didn't become errored','line_number':472,'multiline':False]
['text':' or closed such that no further writes can occur).  But it's silent as to','line_number':473,'multiline':False]
['text':' not-fully-read chunks.  (These semantic differences may only be observable','line_number':474,'multiline':False]
['text':' with very carefully constructed readable/writable streams.)','line_number':475,'multiline':False]
['text':'','line_number':476,'multiline':False]
['text':' It seems best, generally, to react to the temporally-earliest problem that','line_number':477,'multiline':False]
['text':' arises, so we implement option #2.  (Blink, in contrast, currently','line_number':478,'multiline':False]
['text':' implements option #1.)','line_number':479,'multiline':False]
['text':'','line_number':480,'multiline':False]
['text':' All specified reactions to a closure/error invoke either the shutdown, or','line_number':481,'multiline':False]
['text':' shutdown with an action, algorithms.  Those algorithms each abort if either','line_number':482,'multiline':False]
['text':' shutdown algorithm has already been invoked.  So we don't need to do','line_number':483,'multiline':False]
['text':' anything special here to deal with a pending read.','line_number':484,'multiline':False]
['text':' ii. Otherwise (if preventAbort is true), shutdown with','line_number':486,'multiline':False]
['text':'     source.[[storedError]].','line_number':487,'multiline':False]
['text':' i. (If preventAbort is false,) shutdown with an action of','line_number':493,'multiline':False]
['text':'    ! WritableStreamAbort(dest, source.[[storedError]]) and with','line_number':494,'multiline':False]
['text':'    source.[[storedError]].','line_number':495,'multiline':False]
['text':'*
 * Streams spec, 3.4.11. ReadableStreamPipeTo step 14:
 * "b. Errors must be propagated backward: if dest.[[state]] is or becomes
 * 'errored', then..."
 ','line_number':507,'multiline':True]
['text':' As in |OnSourceErrored| above, we must deal with the case of |dest|','line_number':522,'multiline':False]
['text':' erroring before a pending read has fulfilled or rejected.','line_number':523,'multiline':False]
['text':'','line_number':524,'multiline':False]
['text':' As noted there, we handle the *first* error that arises.  And because this','line_number':525,'multiline':False]
['text':' algorithm immediately invokes a shutdown algorithm, and shutting down will','line_number':526,'multiline':False]
['text':' inhibit future shutdown attempts, we don't need to do anything special','line_number':527,'multiline':False]
['text':' *here*, either.','line_number':528,'multiline':False]
['text':' ii. Otherwise (if preventCancel is true), shutdown with','line_number':530,'multiline':False]
['text':'     dest.[[storedError]].','line_number':531,'multiline':False]
['text':' i. If preventCancel is false, shutdown with an action of','line_number':537,'multiline':False]
['text':'    ! ReadableStreamCancel(source, dest.[[storedError]]) and with','line_number':538,'multiline':False]
['text':'    dest.[[storedError]].','line_number':539,'multiline':False]
['text':'*
 * Streams spec, 3.4.11. ReadableStreamPipeTo step 14:
 * "c. Closing must be propagated forward: if source.[[state]] is or becomes
 * 'closed', then..."
 ','line_number':551,'multiline':True]
['text':' It shouldn't be possible for |source| to become closed *during* a pending','line_number':562,'multiline':False]
['text':' read: such spontaneous closure *should* be enqueued for processing *after*','line_number':563,'multiline':False]
['text':' the settling of the pending read.  (Note also that a [[closedPromise]]','line_number':564,'multiline':False]
['text':' resolution in |ReadableStreamClose| occurs only after all pending reads are','line_number':565,'multiline':False]
['text':' resolved.)  So we need not do anything to handle a source closure while a','line_number':566,'multiline':False]
['text':' read is in progress.','line_number':567,'multiline':False]
['text':' ii. Otherwise (if preventClose is true), shutdown.','line_number':569,'multiline':False]
['text':' i. If preventClose is false, shutdown with an action of','line_number':575,'multiline':False]
['text':'    ! WritableStreamDefaultWriterCloseWithErrorPropagation(writer).','line_number':576,'multiline':False]
['text':'*
 * Streams spec, 3.4.11. ReadableStreamPipeTo step 14:
 * "d. Closing must be propagated backward: if
 * ! WritableStreamCloseQueuedOrInFlight(dest) is true or dest.[[state]] is
 * 'closed', then..."
 ','line_number':589,'multiline':True]
['text':' i. Assert: no chunks have been read or written.','line_number':599,'multiline':False]
['text':'','line_number':600,'multiline':False]
['text':' This assertion holds when this function is called by','line_number':601,'multiline':False]
['text':' |SourceOrDestErroredOrClosed|, before any async internal piping operations','line_number':602,'multiline':False]
['text':' happen.','line_number':603,'multiline':False]
['text':'','line_number':604,'multiline':False]
['text':' But it wouldn't hold for streams that can spontaneously close of their own','line_number':605,'multiline':False]
['text':' accord, like say a hypothetical DOM TCP socket.  I think?','line_number':606,'multiline':False]
['text':'','line_number':607,'multiline':False]
['text':' XXX Add this assertion if it really does hold (and is easily performed),','line_number':608,'multiline':False]
['text':'     else report a spec bug.','line_number':609,'multiline':False]
['text':' ii. Let destClosed be a new TypeError.','line_number':611,'multiline':False]
['text':' As in all the |On{Source,Dest}{Closed,Errored}| above, we must consider the','line_number':624,'multiline':False]
['text':' possibility that we're in the middle of a pending read.  |state->writer()|','line_number':625,'multiline':False]
['text':' has a lock on |dest| here, so we know only we can be writing chunks to','line_number':626,'multiline':False]
['text':' |dest| -- but there's no reason why |dest| couldn't become closed of its','line_number':627,'multiline':False]
['text':' own accord here (for example, a socket might become closed on its own), and','line_number':628,'multiline':False]
['text':' such closure may or may not be equivalent to error.','line_number':629,'multiline':False]
['text':'','line_number':630,'multiline':False]
['text':' For the reasons noted in |OnSourceErrored|, we process closure in the','line_number':631,'multiline':False]
['text':' middle of a pending read immediately, without delaying for that read to','line_number':632,'multiline':False]
['text':' fulfill or reject.  We trigger a shutdown operation below, which will','line_number':633,'multiline':False]
['text':' ensure shutdown only occurs once, so we need not do anything special here.','line_number':634,'multiline':False]
['text':' iv. Otherwise (if preventCancel is true), shutdown with destClosed.','line_number':636,'multiline':False]
['text':' iii. If preventCancel is false, shutdown with an action of','line_number':642,'multiline':False]
['text':'      ! ReadableStreamCancel(source, destClosed) and with destClosed.','line_number':643,'multiline':False]
['text':'*
 * Streams spec, 3.4.11. ReadableStreamPipeTo step 14:
 * "Error and close states must be propagated: the following conditions must be
 * applied in order.", as applied at the very start of piping, before any reads
 * from source or writes to dest have been triggered.
 ','line_number':654,'multiline':True]
['text':' a. Errors must be propagated forward: if source.[[state]] is or becomes','line_number':668,'multiline':False]
['text':'    "errored", then','line_number':669,'multiline':False]
['text':' b. Errors must be propagated backward: if dest.[[state]] is or becomes','line_number':674,'multiline':False]
['text':'    "errored", then','line_number':675,'multiline':False]
['text':' c. Closing must be propagated forward: if source.[[state]] is or becomes','line_number':680,'multiline':False]
['text':'    "closed", then','line_number':681,'multiline':False]
['text':' d. Closing must be propagated backward: if','line_number':686,'multiline':False]
['text':'    ! WritableStreamCloseQueuedOrInFlight(dest) is true or dest.[[state]] is','line_number':687,'multiline':False]
['text':'    "closed", then','line_number':688,'multiline':False]
['text':' "Shutdown must stop activity: if shuttingDown becomes true, the user agent','line_number':791,'multiline':False]
['text':' must not initiate further reads from reader, and must only perform writes','line_number':792,'multiline':False]
['text':' of already-read chunks".','line_number':793,'multiline':False]
['text':'','line_number':794,'multiline':False]
['text':' We may reach this point after |On{Source,Dest}{Clos,Error}ed| has responded','line_number':795,'multiline':False]
['text':' to an out-of-band change.  Per the comment in |OnSourceErrored|, we want to','line_number':796,'multiline':False]
['text':' allow the implicated shutdown to proceed, and we don't want to interfere','line_number':797,'multiline':False]
['text':' with or additionally alter its operation.  Particularly, we don't want to','line_number':798,'multiline':False]
['text':' queue up the successfully-read chunk (if there was one, and this isn't just','line_number':799,'multiline':False]
['text':' reporting "done") to be written: it wasn't "already-read" when that','line_number':800,'multiline':False]
['text':' error/closure happened.','line_number':801,'multiline':False]
['text':'','line_number':802,'multiline':False]
['text':' All specified reactions to a closure/error invoke either the shutdown, or','line_number':803,'multiline':False]
['text':' shutdown with an action, algorithms.  Those algorithms each abort if either','line_number':804,'multiline':False]
['text':' shutdown algorithm has already been invoked.  So we check for shutdown here','line_number':805,'multiline':False]
['text':' in case of asynchronous closure/error and abort if shutdown has already','line_number':806,'multiline':False]
['text':' started (and possibly finished).','line_number':807,'multiline':False]
['text':' All chunks have been read from |reader| and written to |writer| (but','line_number':823,'multiline':False]
['text':' not necessarily fulfilled yet, in the latter case).  Proceed as if','line_number':824,'multiline':False]
['text':' |source| is now closed.  (This will asynchronously wait until any','line_number':825,'multiline':False]
['text':' pending writes have fulfilled.)','line_number':826,'multiline':False]
['text':' A chunk was read, and *at the time the read was requested*, |dest| was','line_number':831,'multiline':False]
['text':' ready to accept a write.  (Only one read is processed at a time per','line_number':832,'multiline':False]
['text':' |state->hasPendingRead()|, so this condition remains true now.)  Write the','line_number':833,'multiline':False]
['text':' chunk to |dest|.','line_number':834,'multiline':False]
['text':' Stash away this new last write request.  (The shutdown process will react','line_number':850,'multiline':False]
['text':' to this write request to finish shutdown only once all pending writes are','line_number':851,'multiline':False]
['text':' completed.)','line_number':852,'multiline':False]
['text':' Read another chunk if this write didn't fill up |dest|.','line_number':856,'multiline':False]
['text':'','line_number':857,'multiline':False]
['text':' While we (properly) ignored |state->shuttingDown()| earlier, this call will','line_number':858,'multiline':False]
['text':' *not* initiate a fresh read if |!state->shuttingDown()|.','line_number':859,'multiline':False]
['text':' "Shutdown must stop activity: if shuttingDown becomes true, the user agent','line_number':892,'multiline':False]
['text':' must not initiate further reads from reader..."','line_number':893,'multiline':False]
['text':' "While WritableStreamDefaultWriterGetDesiredSize(writer) is ≤ 0 or is null,','line_number':901,'multiline':False]
['text':' the user agent must not read from reader."','line_number':902,'multiline':False]
['text':' If we're in the middle of erroring or are fully errored, either way the','line_number':908,'multiline':False]
['text':' |dest|-closed reaction queued up in |StartPiping| will do the right','line_number':909,'multiline':False]
['text':' thing, so do nothing here.','line_number':910,'multiline':False]
['text':' If |dest| isn't ready to receive writes yet (i.e. backpressure applies),','line_number':926,'multiline':False]
['text':' resume when it is.','line_number':927,'multiline':False]
['text':' Resume when there's writable capacity.  Don't bother handling rejection:','line_number':939,'multiline':False]
['text':' if this happens, the stream is going to be errored shortly anyway, and','line_number':940,'multiline':False]
['text':' |StartPiping| has us ready to react to that already.','line_number':941,'multiline':False]
['text':'','line_number':942,'multiline':False]
['text':' XXX Double-check the claim that we need not handle rejections and that a','line_number':943,'multiline':False]
['text':'     rejection of [[readyPromise]] *necessarily* is always followed by','line_number':944,'multiline':False]
['text':'     rejection of [[closedPromise]].','line_number':945,'multiline':False]
['text':' |dest| is ready to receive at least one write.  Read one chunk from the','line_number':950,'multiline':False]
['text':' reader now that we're not subject to backpressure.','line_number':951,'multiline':False]
['text':' The specification for ReadableStreamError ensures that rejecting a read or','line_number':969,'multiline':False]
['text':' read-into request is immediately followed by rejecting the reader's','line_number':970,'multiline':False]
['text':' [[closedPromise]].  Therefore, it does not appear *necessary* to handle the','line_number':971,'multiline':False]
['text':' rejected case -- the [[closedPromise]] reaction will do so for us.','line_number':972,'multiline':False]
['text':'','line_number':973,'multiline':False]
['text':' However, this is all very stateful and gnarly, so we implement a rejection','line_number':974,'multiline':False]
['text':' handler that sets a flag to indicate the read was rejected.  Then if the','line_number':975,'multiline':False]
['text':' [[closedPromise]] reaction function is invoked, we can assert that *if*','line_number':976,'multiline':False]
['text':' a read is recorded as pending at that instant, a reject handler would have','line_number':977,'multiline':False]
['text':' been invoked for it.','line_number':978,'multiline':False]
['text':' Once the chunk is read, immediately write it and attempt to read more.','line_number':1000,'multiline':False]
['text':' Don't bother handling a rejection: |source| will be closed/errored, and','line_number':1001,'multiline':False]
['text':' |StartPiping| poised us to react to that already.','line_number':1002,'multiline':False]
['text':' The spec is clear that a write started before an error/stream-closure is','line_number':1008,'multiline':False]
['text':' encountered must be completed before shutdown.  It is *not* clear that a','line_number':1009,'multiline':False]
['text':' read that hasn't yet fulfilled should delay shutdown (or until that read's','line_number':1010,'multiline':False]
['text':' successive write is completed).','line_number':1011,'multiline':False]
['text':'','line_number':1012,'multiline':False]
['text':' It seems easiest to explain, both from a user perspective (no read is ever','line_number':1013,'multiline':False]
['text':' just dropped on the ground) and an implementer perspective (if we *don't*','line_number':1014,'multiline':False]
['text':' delay, then a read could be started, a shutdown could be started, then the','line_number':1015,'multiline':False]
['text':' read could finish but we can't write it which arguably conflicts with the','line_number':1016,'multiline':False]
['text':' requirement that chunks that have been read must be written before shutdown','line_number':1017,'multiline':False]
['text':' completes), to delay.  XXX file a spec issue to require this!','line_number':1018,'multiline':False]
['text':' "Shutdown must stop activity: if shuttingDown becomes true, the user agent','line_number':1042,'multiline':False]
['text':' must not initiate further reads from reader..."','line_number':1043,'multiline':False]
['text':' "Error and close states must be propagated: the following conditions must','line_number':1046,'multiline':False]
['text':' be applied in order."','line_number':1047,'multiline':False]
['text':'','line_number':1048,'multiline':False]
['text':' Before piping has started, we have to check for source/dest being errored','line_number':1049,'multiline':False]
['text':' or closed manually.','line_number':1050,'multiline':False]
['text':' *After* piping has started, add reactions to respond to source/dest','line_number':1060,'multiline':False]
['text':' becoming errored or closed.','line_number':1061,'multiline':False]
['text':'*
 * Stream spec, 4.8.1. ReadableStreamPipeTo ( source, dest,
 *                                            preventClose, preventAbort,
 *                                            preventCancel[, signal] )
 * Step 14.1 abortAlgorithm.
 ','line_number':1108,'multiline':True]
['text':' Step 14.1: Let abortAlgorithm be the following steps:','line_number':1118,'multiline':False]
['text':' Step 14.1.1: Let error be a new "AbortError" DOMException.','line_number':1119,'multiline':False]
['text':' Step 14.1.2: Let actions be an empty ordered set.','line_number':1120,'multiline':False]
['text':' Step 14.1.3: If preventAbort is false, append the following action to','line_number':1121,'multiline':False]
['text':'              actions:','line_number':1122,'multiline':False]
['text':' Step 14.1.3.1: If dest.[[state]] is "writable", return','line_number':1123,'multiline':False]
['text':'                ! WritableStreamAbort(dest, error).','line_number':1124,'multiline':False]
['text':' Step 14.1.3.2: Otherwise, return a promise resolved with undefined.','line_number':1125,'multiline':False]
['text':' Step 14.1.4: If preventCancel is false, append the following action action','line_number':1126,'multiline':False]
['text':'              to actions:','line_number':1127,'multiline':False]
['text':' Step 14.1.4.1: If source.[[state]] is "readable", return','line_number':1128,'multiline':False]
['text':'                ! ReadableStreamCancel(source, error).','line_number':1129,'multiline':False]
['text':' Step 14.1.4.2: Otherwise, return a promise resolved with undefined.','line_number':1130,'multiline':False]
['text':' Step 14.1.5: Shutdown with an action consisting of getting a promise to','line_number':1131,'multiline':False]
['text':'              wait for all of the actions in actions, and with error.','line_number':1132,'multiline':False]
['text':' XXX jwalden','line_number':1133,'multiline':False]
['text':'*
 * Stream spec, 3.4.11. ReadableStreamPipeTo ( source, dest,
 *                                             preventClose, preventAbort,
 *                                             preventCancel, signal )
 * Steps 4-11, 13-14.
 ','line_number':1140,'multiline':True]
['text':' static ','line_number':1146,'multiline':True]
['text':' Step 4. Assert: signal is undefined or signal is an instance of the','line_number':1160,'multiline':False]
['text':'         AbortSignal interface.','line_number':1161,'multiline':False]
['text':' |signal| is double-checked to be an |AbortSignal| further down.','line_number':1164,'multiline':False]
['text':' Step 5: Assert: ! IsReadableStreamLocked(source) is false.','line_number':1168,'multiline':False]
['text':' Step 6: Assert: ! IsWritableStreamLocked(dest) is false.','line_number':1171,'multiline':False]
['text':' Step 7: If ! IsReadableByteStreamController(','line_number':1177,'multiline':False]
['text':'                  source.[[readableStreamController]]) is true, let reader','line_number':1178,'multiline':False]
['text':'         be either ! AcquireReadableStreamBYOBReader(source) or','line_number':1179,'multiline':False]
['text':'         ! AcquireReadableStreamDefaultReader(source), at the user agent’s','line_number':1180,'multiline':False]
['text':'         discretion.','line_number':1181,'multiline':False]
['text':' Step 8: Otherwise, let reader be','line_number':1182,'multiline':False]
['text':'         ! AcquireReadableStreamDefaultReader(source).','line_number':1183,'multiline':False]
['text':' We don't implement byte streams, so we always acquire a default reader.','line_number':1184,'multiline':False]
['text':' Step 9: Let writer be ! AcquireWritableStreamDefaultWriter(dest).','line_number':1196,'multiline':False]
['text':' Step 10: Set source.[[disturbed]] to true.','line_number':1208,'multiline':False]
['text':' Step 11: Let shuttingDown be false.','line_number':1216,'multiline':False]
['text':' Step 12 ("Let promise be a new promise.") was performed by the caller and','line_number':1219,'multiline':False]
['text':' |promise| was its result.','line_number':1220,'multiline':False]
['text':' XXX This used to be step 13 but is now step 14, all the step-comments of','line_number':1222,'multiline':False]
['text':'     the overall algorithm need renumbering.','line_number':1223,'multiline':False]
['text':' Step 13: If signal is not undefined,','line_number':1224,'multiline':False]
['text':' Step 14.2: If signal’s aborted flag is set, perform abortAlgorithm and','line_number':1226,'multiline':False]
['text':'         return promise.','line_number':1227,'multiline':False]
['text':' Sadly, we can't assert |signal| is an |AbortSignal| here because it','line_number':1230,'multiline':False]
['text':' could have become a nuked CCW since it was type-checked.','line_number':1231,'multiline':False]
['text':' Returning |state| here will cause |promise| to be returned by the','line_number':1248,'multiline':False]
['text':' overall algorithm.','line_number':1249,'multiline':False]
['text':' Step 14.3: Add abortAlgorithm to signal.','line_number':1253,'multiline':False]
['text':' XXX jwalden need JSAPI to add an algorithm/steps to an AbortSignal','line_number':1254,'multiline':False]
['text':' Step 14: In parallel, using reader and writer, read all chunks from source','line_number':1261,'multiline':False]
['text':'          and write them to dest.','line_number':1262,'multiline':False]
