['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' [SMDOC] GC Atom Marking','line_number':20,'multiline':False]
['text':'','line_number':21,'multiline':False]
['text':' Things in the atoms zone (which includes atomized strings and other things,','line_number':22,'multiline':False]
['text':' all of which we will refer to as 'atoms' here) may be pointed to freely by','line_number':23,'multiline':False]
['text':' things in other zones. To avoid the need to perform garbage collections of','line_number':24,'multiline':False]
['text':' the entire runtime to collect atoms, we compute a separate atom mark bitmap','line_number':25,'multiline':False]
['text':' for each zone that is always an overapproximation of the atoms that zone is','line_number':26,'multiline':False]
['text':' using. When an atom is not in the mark bitmap for any zone, it can be','line_number':27,'multiline':False]
['text':' destroyed.','line_number':28,'multiline':False]
['text':'','line_number':29,'multiline':False]
['text':' To minimize interference with the rest of the GC, atom marking and sweeping','line_number':30,'multiline':False]
['text':' is done by manipulating the mark bitmaps in the chunks used for the atoms.','line_number':31,'multiline':False]
['text':' When the atoms zone is being collected, the mark bitmaps for the chunk(s)','line_number':32,'multiline':False]
['text':' used by the atoms are updated normally during marking. After marking','line_number':33,'multiline':False]
['text':' finishes, the chunk mark bitmaps are translated to a more efficient atom mark','line_number':34,'multiline':False]
['text':' bitmap (see below) that is stored on the zones which the GC collected','line_number':35,'multiline':False]
['text':' (computeBitmapFromChunkMarkBits). Before sweeping begins, the chunk mark','line_number':36,'multiline':False]
['text':' bitmaps are updated with any atoms that might be referenced by zones which','line_number':37,'multiline':False]
['text':' weren't collected (markAtomsUsedByUncollectedZones). The GC sweeping will','line_number':38,'multiline':False]
['text':' then release all atoms which are not marked by any zone.','line_number':39,'multiline':False]
['text':'','line_number':40,'multiline':False]
['text':' The representation of atom mark bitmaps is as follows:','line_number':41,'multiline':False]
['text':'','line_number':42,'multiline':False]
['text':' Each arena in the atoms zone has an atomBitmapStart() value indicating the','line_number':43,'multiline':False]
['text':' word index into the bitmap of the first thing in the arena. Each arena uses','line_number':44,'multiline':False]
['text':' ArenaBitmapWords of data to store its bitmap, which uses the same','line_number':45,'multiline':False]
['text':' representation as chunk mark bitmaps: one bit is allocated per Cell, with','line_number':46,'multiline':False]
['text':' bits for space between things being unused when things are larger than a','line_number':47,'multiline':False]
['text':' single Cell.','line_number':48,'multiline':False]
['text':' We need to find a range of bits from the atoms bitmap for this arena.','line_number':55,'multiline':False]
['text':' Look for a free range of bits compatible with this arena.','line_number':57,'multiline':False]
['text':' Allocate a range of bits from the end for this arena.','line_number':63,'multiline':False]
['text':' Leak these atom bits if we run out of memory.','line_number':71,'multiline':False]
['text':' Take the bitwise and between the two mark bitmaps to get the best new','line_number':105,'multiline':False]
['text':' overapproximation we can. |bitmap| might include bits that are not in','line_number':106,'multiline':False]
['text':' the zone's mark bitmap, if additional zones were collected by the GC.','line_number':107,'multiline':False]
['text':' Set any bits in the chunk mark bitmaps for atoms which are marked in bitmap.','line_number':111,'multiline':False]
['text':' Make sure that by copying the mark bits for one arena in word sizes we','line_number':114,'multiline':False]
['text':' do not affect the mark bits for other arenas.','line_number':115,'multiline':False]
['text':' Try to compute a simple union of the zone atom bitmaps before updating','line_number':134,'multiline':False]
['text':' the chunk mark bitmaps. If this allocation fails then fall back to','line_number':135,'multiline':False]
['text':' updating the chunk mark bitmaps separately for each zone.','line_number':136,'multiline':False]
['text':' We only need to update the chunk mark bits for zones which were','line_number':140,'multiline':False]
['text':' not collected in the current GC. Atoms which are referenced by','line_number':141,'multiline':False]
['text':' collected zones have already been marked.','line_number':142,'multiline':False]
['text':' DEBUG','line_number':283,'multiline':False]
['text':' namespace gc','line_number':285,'multiline':False]
['text':' DEBUG','line_number':302,'multiline':False]
['text':' namespace js','line_number':304,'multiline':False]
