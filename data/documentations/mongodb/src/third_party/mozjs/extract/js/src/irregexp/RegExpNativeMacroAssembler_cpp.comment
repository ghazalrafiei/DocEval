['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' Copyright 2020 the V8 project authors. All rights reserved.','line_number':7,'multiline':False]
['text':' Use of this source code is governed by a BSD-style license that can be','line_number':8,'multiline':False]
['text':' found in the LICENSE file.','line_number':9,'multiline':False]
['text':' Each capture has a start and an end register','line_number':54,'multiline':False]
['text':' We'll generate the entry code later','line_number':68,'multiline':False]
['text':' and continue from here.','line_number':69,'multiline':False]
['text':' Check for simulating interrupt','line_number':92,'multiline':False]
['text':' Check for an interrupt. We have to restart from the beginning if we','line_number':97,'multiline':False]
['text':' are interrupted, so we only check for urgent interrupts.','line_number':98,'multiline':False]
['text':' bailing out if we have simulating interrupt flag set','line_number':104,'multiline':False]
['text':' Pop code location from backtrack stack and jump to location.','line_number':111,'multiline':False]
['text':' Check if current_position + cp_offset is the input start','line_number':123,'multiline':False]
['text':' Bitwise-and the current character with mask and then check for a','line_number':163,'multiline':False]
['text':' match with c.','line_number':164,'multiline':False]
['text':'is_not =','line_number':183,'multiline':True]
['text':'is_not =','line_number':189,'multiline':True]
['text':' Subtract minus from the current character, then bitwise-and the','line_number':192,'multiline':False]
['text':' result with mask, then check for a match with c.','line_number':193,'multiline':False]
['text':' If the current position matches the position stored on top of the backtrack','line_number':207,'multiline':False]
['text':' stack, pops the backtrack stack and branches to the given label.','line_number':208,'multiline':False]
['text':' Pop.','line_number':213,'multiline':False]
['text':' x is in [from,to] if unsigned(x - from) <= to - from','line_number':220,'multiline':False]
['text':' Claim ownership of the ByteArray from the current HandleScope.','line_number':237,'multiline':False]
['text':' ByteArrays are allocated on the C++ heap and are (eventually)','line_number':238,'multiline':False]
['text':' owned by the RegExpShared.','line_number':239,'multiline':False]
['text':' Transfer ownership of |rawTable| to the |tables_| vector.','line_number':251,'multiline':False]
['text':' Captures are stored as a sequential pair of registers.','line_number':262,'multiline':False]
['text':' Find the length of the back-referenced capture and load the','line_number':263,'multiline':False]
['text':' capture's start index into current_character_.','line_number':264,'multiline':False]
['text':' index of start','line_number':265,'multiline':False]
['text':' index of end','line_number':267,'multiline':False]
['text':' length of capture','line_number':268,'multiline':False]
['text':' Capture registers are either both set or both cleared.','line_number':270,'multiline':False]
['text':' If the capture length is zero, then the capture is either empty or cleared.','line_number':271,'multiline':False]
['text':' Fall through in both cases.','line_number':272,'multiline':False]
['text':' Check that there are sufficient characters left in the input.','line_number':275,'multiline':False]
['text':' If start + len > current, there isn't enough room for a','line_number':277,'multiline':False]
['text':' lookbehind backreference.','line_number':278,'multiline':False]
['text':' current_position_ is the negative offset from the end.','line_number':284,'multiline':False]
['text':' If current + len > 0, there isn't enough room for a backreference.','line_number':285,'multiline':False]
['text':' We call a helper function for case-insensitive non-latin1 strings.','line_number':293,'multiline':False]
['text':' Save volatile regs. temp1_, temp2_, and current_character_','line_number':295,'multiline':False]
['text':' don't need to be saved.  current_position_ needs to be saved','line_number':296,'multiline':False]
['text':' even if it's non-volatile, because we modify it to use as an argument.','line_number':297,'multiline':False]
['text':' Parameters are','line_number':305,'multiline':False]
['text':'   Address captured - Address of captured substring's start.','line_number':306,'multiline':False]
['text':'   Address current - Address of current character position.','line_number':307,'multiline':False]
['text':'   size_t byte_length - length of capture (in bytes)','line_number':308,'multiline':False]
['text':' Compute |captured|','line_number':310,'multiline':False]
['text':' Compute |current|','line_number':313,'multiline':False]
['text':' Offset by length when matching backwards.','line_number':316,'multiline':False]
['text':' On success, advance position by length of capture','line_number':336,'multiline':False]
['text':' We will be modifying current_position_. Save it in case the match fails.','line_number':347,'multiline':False]
['text':' Compute start of capture string','line_number':350,'multiline':False]
['text':' Compute start of match string','line_number':353,'multiline':False]
['text':' Offset by length when matching backwards.','line_number':356,'multiline':False]
['text':' Compute end of match string','line_number':360,'multiline':False]
['text':' Load next character from each string.','line_number':368,'multiline':False]
['text':' Try exact match.','line_number':379,'multiline':False]
['text':' Mismatch. Try case-insensitive match.','line_number':383,'multiline':False]
['text':' Force the capture character to lower case (by setting bit 0x20)','line_number':384,'multiline':False]
['text':' then check to see if it is a letter.','line_number':385,'multiline':False]
['text':' Check if it is in [a,z].','line_number':389,'multiline':False]
['text':' Check for values in range [224,254].','line_number':393,'multiline':False]
['text':' Exclude 247 (U+00F7 DIVISION SIGN).','line_number':394,'multiline':False]
['text':' Capture character is lower case. Convert match character','line_number':399,'multiline':False]
['text':' to lower case and compare.','line_number':400,'multiline':False]
['text':' Fail if characters do not match.','line_number':408,'multiline':False]
['text':' Increment pointers into match and capture strings.','line_number':412,'multiline':False]
['text':' Loop if we have not reached the end of the match string.','line_number':416,'multiline':False]
['text':' If we fail, restore current_position_ and branch.','line_number':420,'multiline':False]
['text':' Drop saved value of current_position_','line_number':427,'multiline':False]
['text':' current_position_ is a pointer. Convert it back to an offset.','line_number':430,'multiline':False]
['text':' Subtract match length if we matched backward','line_number':433,'multiline':False]
['text':' Branch if a back-reference does not match a previous capture.','line_number':441,'multiline':False]
['text':'unicode = ','line_number':445,'multiline':True]
['text':'ignore_case = ','line_number':446,'multiline':True]
['text':'ignore_case = ','line_number':452,'multiline':True]
['text':' Checks whether the given offset from the current position is','line_number':455,'multiline':False]
['text':' inside the input string.','line_number':456,'multiline':False]
['text':' Note: current_position_ is a (negative) byte offset relative to','line_number':459,'multiline':False]
['text':' the end of the input string.','line_number':460,'multiline':False]
['text':'      end + current + offset >= end','line_number':462,'multiline':False]
['text':' <=>        current + offset >= 0','line_number':463,'multiline':False]
['text':' <=>        current          >= -offset','line_number':464,'multiline':False]
['text':' Compute offset position','line_number':469,'multiline':False]
['text':' Compare to start of input.','line_number':473,'multiline':False]
['text':' This function attempts to generate special case code for character classes.','line_number':479,'multiline':False]
['text':' Returns true if a special case is generated.','line_number':480,'multiline':False]
['text':' Otherwise returns false and generates no code.','line_number':481,'multiline':False]
['text':' Note: throughout this function, range checks (c in [min, max])','line_number':486,'multiline':False]
['text':' are implemented by an unsigned (c - min) <= (max - min) check.','line_number':487,'multiline':False]
['text':' Match space-characters','line_number':490,'multiline':False]
['text':' One byte space characters are ' ', '\t'..'\r', and '\u00a0' (NBSP).','line_number':495,'multiline':False]
['text':' Check ' '','line_number':497,'multiline':False]
['text':' Check '\t'..'\r'','line_number':501,'multiline':False]
['text':' Check \u00a0.','line_number':506,'multiline':False]
['text':' The emitted code for generic character classes is good enough.','line_number':514,'multiline':False]
['text':' Match latin1 digits ('0'-'9')','line_number':517,'multiline':False]
['text':' Match anything except latin1 digits ('0'-'9')','line_number':522,'multiline':False]
['text':' Match non-newlines. This excludes '\n' (0x0a), '\r' (0x0d),','line_number':528,'multiline':False]
['text':' U+2028 LINE SEPARATOR, and U+2029 PARAGRAPH SEPARATOR.','line_number':529,'multiline':False]
['text':' See https://tc39.es/ecma262/#prod-LineTerminator','line_number':530,'multiline':False]
['text':' To test for 0x0a and 0x0d efficiently, we XOR the input with 1.','line_number':532,'multiline':False]
['text':' This converts 0x0a to 0x0b, and 0x0d to 0x0c, allowing us to','line_number':533,'multiline':False]
['text':' test for the contiguous range 0x0b..0x0c.','line_number':534,'multiline':False]
['text':' Compare original value to 0x2028 and 0x2029, using the already','line_number':542,'multiline':False]
['text':' computed (current_char ^ 0x01 - 0x0b). I.e., check for','line_number':543,'multiline':False]
['text':' 0x201d (0x2028 - 0x0b) or 0x201e.','line_number':544,'multiline':False]
['text':' \w matches the set of 63 characters defined in Runtime Semantics:','line_number':551,'multiline':False]
['text':' WordCharacters. We use a static lookup table, which is defined in','line_number':552,'multiline':False]
['text':' regexp-macro-assembler.cc.','line_number':553,'multiline':False]
['text':' Note: if both Unicode and IgnoreCase are true, \w matches a','line_number':554,'multiline':False]
['text':' larger set of characters. That case is handled elsewhere.','line_number':555,'multiline':False]
['text':' See 'w' above.','line_number':567,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////','line_number':582,'multiline':False]
['text':' Non-standard classes (with no syntactic shorthand) used internally //','line_number':583,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////','line_number':584,'multiline':False]
['text':' Match any character','line_number':586,'multiline':False]
['text':' Match newlines. The opposite of '.'. See '.' above.','line_number':589,'multiline':False]
['text':' Compare original value to 0x2028 and 0x2029, using the already','line_number':601,'multiline':False]
['text':' computed (current_char ^ 0x01 - 0x0b). I.e., check for','line_number':602,'multiline':False]
['text':' 0x201d (0x2028 - 0x0b) or 0x201e.','line_number':603,'multiline':False]
['text':' No custom implementation','line_number':611,'multiline':False]
['text':' This is a word-for-word identical copy of the V8 code, which is','line_number':643,'multiline':False]
['text':' duplicated in at least nine different places in V8 (one per','line_number':644,'multiline':False]
['text':' supported architecture) with no differences outside of comments and','line_number':645,'multiline':False]
['text':' formatting. It should be hoisted into the superclass. Once that is','line_number':646,'multiline':False]
['text':' done upstream, this version can be deleted.','line_number':647,'multiline':False]
['text':' It's possible to preload a small number of characters when each success','line_number':653,'multiline':False]
['text':' path requires a large number of characters, but not the reverse.','line_number':654,'multiline':False]
['text':' Be sane! (And ensure negation works)','line_number':656,'multiline':False]
['text':' Load the character (or characters) at the specified offset from the','line_number':668,'multiline':False]
['text':' current position. Zero-extend to 32 bits.','line_number':669,'multiline':False]
['text':' Note: The backtrack stack pointer is stored in a register as an','line_number':738,'multiline':False]
['text':' offset from the stack top, not as a bare pointer, so that it is not','line_number':739,'multiline':False]
['text':' corrupted if the backtrack stack grows (and therefore moves).','line_number':740,'multiline':False]
['text':' When matching a regexp that is anchored at the end, this operation','line_number':751,'multiline':False]
['text':' is used to try skipping the beginning of long strings. If the','line_number':752,'multiline':False]
['text':' maximum length of a match is less than the length of the string, we','line_number':753,'multiline':False]
['text':' can skip the initial len - max_len bytes.','line_number':754,'multiline':False]
['text':' On RegExp code entry (where this operation is used), the character before','line_number':761,'multiline':False]
['text':' the current position is expected to be already loaded.','line_number':762,'multiline':False]
['text':' We have advanced the position, so it's safe to read backwards.','line_number':763,'multiline':False]
['text':' Returns true if a regexp match can be restarted (aka the regexp is global).','line_number':773,'multiline':False]
['text':' The return value is not used anywhere, but we implement it to be safe.','line_number':774,'multiline':False]
['text':' Capture registers are initialized to input[-1]','line_number':780,'multiline':False]
['text':' Generate a quick inline test for backtrack stack overflow.','line_number':812,'multiline':False]
['text':' If the test fails, call an OOL handler to try growing the stack.','line_number':813,'multiline':False]
['text':' Exit with an exception if the call failed','line_number':823,'multiline':False]
['text':' This is used to sneak an OOM through the V8 layer.','line_number':830,'multiline':False]
['text':' Finalize code. This is called last, so that we know how many','line_number':835,'multiline':False]
['text':' registers we need.','line_number':836,'multiline':False]
['text':'
 * The stack will have the following structure:
 *  sp-> - FrameData
 *         - inputStart
 *         - backtrack stack base
 *         - matches
 *         - numMatches
 *       - Registers
 *         - Capture positions
 *         - Scratch registers
 *       --- frame alignment ---
 *       - Saved register area
 *       - Return address
 ','line_number':869,'multiline':True]
['text':' ARM64 communicates stack address via SP, but uses a pseudo-sp (PSP) for','line_number':885,'multiline':False]
['text':' addressing.  The register we use for PSP may however also be used by','line_number':886,'multiline':False]
['text':' calling code, and it is nonvolatile, so save it.  Do this as a special','line_number':887,'multiline':False]
['text':' case first because the generic save/restore code needs the PSP to be','line_number':888,'multiline':False]
['text':' initialized already.','line_number':889,'multiline':False]
['text':' Initialize the PSP from the SP.','line_number':894,'multiline':False]
['text':' Push non-volatile registers which might be modified by jitcode.','line_number':898,'multiline':False]
['text':' The pointer to InputOutputData is passed as the first argument.','line_number':906,'multiline':False]
['text':' On x86 we have to load it off the stack into temp0_.','line_number':907,'multiline':False]
['text':' On other platforms it is already in a register.','line_number':908,'multiline':False]
['text':' Start a new stack frame.','line_number':919,'multiline':False]
['text':' Check if we have space on the stack. Use the *NoInterrupt stack limit to','line_number':926,'multiline':False]
['text':' avoid failing repeatedly when the regex code is called from Ion JIT code.','line_number':927,'multiline':False]
['text':' (See bug 1208819)','line_number':928,'multiline':False]
['text':' There is not enough space on the stack. Exit with an exception.','line_number':933,'multiline':False]
['text':' At this point, an uninitialized stack frame has been created,','line_number':941,'multiline':False]
['text':' and the address of the InputOutputData is in temp0_.','line_number':942,'multiline':False]
['text':' Initialize output registers','line_number':949,'multiline':False]
['text':' Bounds-check numMatches.','line_number':956,'multiline':False]
['text':' Load input start pointer.','line_number':964,'multiline':False]
['text':' Load input end pointer','line_number':968,'multiline':False]
['text':' Set up input position to be negative offset from string end.','line_number':972,'multiline':False]
['text':' Store inputStart','line_number':975,'multiline':False]
['text':' Load start index','line_number':978,'multiline':False]
['text':' Initialize current_character_.','line_number':985,'multiline':False]
['text':' Load newline if index is at start, or previous character otherwise.','line_number':986,'multiline':False]
['text':' Initialize captured registers with inputStart - 1','line_number':998,'multiline':False]
['text':' Unroll the loop','line_number':1014,'multiline':False]
['text':' Initialize backtrack stack pointer','line_number':1020,'multiline':False]
['text':' Called when we find a match. May not be generated if we can','line_number':1026,'multiline':False]
['text':' determine ahead of time that a regexp cannot match: for example,','line_number':1027,'multiline':False]
['text':' when compiling /\u1e9e/ for latin-1 inputs.','line_number':1028,'multiline':False]
['text':' Copy captures to the MatchPairs pointed to by the InputOutputData.','line_number':1035,'multiline':False]
['text':' Captures are stored as positions, which are negative byte offsets','line_number':1036,'multiline':False]
['text':' from the end of the string.  We must convert them to actual','line_number':1037,'multiline':False]
['text':' indices.','line_number':1038,'multiline':False]
['text':'','line_number':1039,'multiline':False]
['text':' Index:        [ 0 ][ 1 ][ 2 ][ 3 ][ 4 ][ 5 ][END]','line_number':1040,'multiline':False]
['text':' Pos (1-byte): [-6 ][-5 ][-4 ][-3 ][-2 ][-1 ][ 0 ] // IS = -6','line_number':1041,'multiline':False]
['text':' Pos (2-byte): [-12][-10][-8 ][-6 ][-4 ][-2 ][ 0 ] // IS = -12','line_number':1042,'multiline':False]
['text':'','line_number':1043,'multiline':False]
['text':' To convert a position to an index, we subtract InputStart, and','line_number':1044,'multiline':False]
['text':' divide the result by char_size.','line_number':1045,'multiline':False]
['text':' This falls through to the exit handler.','line_number':1062,'multiline':False]
['text':' Restore registers which were saved on entry','line_number':1074,'multiline':False]
['text':' Now restore the value that was in the PSP register on entry, and return.','line_number':1081,'multiline':False]
['text':' Obtain the correct SP from the PSP.','line_number':1083,'multiline':False]
['text':' Restore the saved value of the PSP register, this value is whatever the','line_number':1086,'multiline':False]
['text':' caller had saved in it, not any actual SP value, and it must not be','line_number':1087,'multiline':False]
['text':' overwritten subsequently.','line_number':1088,'multiline':False]
['text':' Perform a plain Ret(), as abiret() will move SP <- PSP and that is wrong.','line_number':1092,'multiline':False]
['text':' Exit with an error result to signal thrown exception','line_number':1101,'multiline':False]
['text':' Called if the backtrack-stack limit has been hit.','line_number':1120,'multiline':False]
['text':' Load argument','line_number':1123,'multiline':False]
['text':' Save registers before calling C function','line_number':1126,'multiline':False]
['text':' Adjust for the return address on the stack.','line_number':1133,'multiline':False]
['text':' If GrowBacktrackStack returned false, we have failed to grow the','line_number':1148,'multiline':False]
['text':' stack, and must exit with a stack-overflow exception. Do this in','line_number':1149,'multiline':False]
['text':' the caller so that the stack is adjusted by our return instruction.','line_number':1150,'multiline':False]
['text':' Otherwise, store the new backtrack stack base and recompute the new','line_number':1154,'multiline':False]
['text':' top of the stack.','line_number':1155,'multiline':False]
['text':' Resume execution in calling code.','line_number':1164,'multiline':False]
['text':' This is only used by tracing code.','line_number':1169,'multiline':False]
['text':' The return value doesn't matter.','line_number':1170,'multiline':False]
['text':' Compare two strings in `/i` mode (ignoreCase, but not unicode).','line_number':1176,'multiline':False]
['text':'static ','line_number':1177,'multiline':True]
['text':' Non-unicode regexps have weird case-folding rules.','line_number':1190,'multiline':False]
['text':' If we aren't building with ICU, fall back to `/iu` mode. The only','line_number':1194,'multiline':False]
['text':' differences are in corner cases.','line_number':1195,'multiline':False]
['text':' Compare two strings in `/iu` mode (ignoreCase and unicode).','line_number':1208,'multiline':False]
['text':'static ','line_number':1209,'multiline':True]
['text':' Unicode regexps use the common and simple case-folding','line_number':1221,'multiline':False]
['text':' mappings of the Unicode Character Database.','line_number':1222,'multiline':False]
['text':' static ','line_number':1234,'multiline':True]
['text':' namespace internal','line_number':1251,'multiline':False]
['text':' namespace v8','line_number':1252,'multiline':False]
