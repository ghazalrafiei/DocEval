['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' JSJitInfo','line_number':22,'multiline':False]
['text':' useAtStart = ','line_number':47,'multiline':True]
['text':' There should be at least 1 successor. The default case!','line_number':90,'multiline':False]
['text':' If there are no cases, the default case is always taken.','line_number':93,'multiline':False]
['text':' If we don't know the type.','line_number':99,'multiline':False]
['text':' Case indices are numeric, so other types will always go to the default','line_number':106,'multiline':False]
['text':' case.','line_number':107,'multiline':False]
['text':' Return an LTableSwitch, capable of handling either an integer or','line_number':113,'multiline':False]
['text':' floating-point index.','line_number':114,'multiline':False]
['text':'useConstant = ','line_number':303,'multiline':True]
['text':'useAtStart = ','line_number':304,'multiline':True]
['text':' On some 64-bit architectures, we don't support boxing a typed','line_number':313,'multiline':False]
['text':' register in-place without using a scratch register, so the result','line_number':314,'multiline':False]
['text':' register can't be the same as any of the inputs. Fortunately,','line_number':315,'multiline':False]
['text':' those architectures have registers to spare.','line_number':316,'multiline':False]
['text':'useConstant = ','line_number':340,'multiline':True]
['text':' Align the arguments of a call such that the callee would keep the same','line_number':429,'multiline':False]
['text':' alignment as the caller.','line_number':430,'multiline':False]
['text':' Save the maximum number of argument, such that we can have one unique','line_number':438,'multiline':False]
['text':' frame size.','line_number':439,'multiline':False]
['text':' Values take a slow path.','line_number':448,'multiline':False]
['text':' Known types can move constant types and/or payloads.','line_number':453,'multiline':False]
['text':' In case of oom, skip the rest of the allocations.','line_number':469,'multiline':False]
['text':' Call DOM functions.','line_number':480,'multiline':False]
['text':' Call known functions.','line_number':491,'multiline':False]
['text':' Even though this is just a temp reg, use the same API to avoid','line_number':498,'multiline':False]
['text':' register collisions.','line_number':499,'multiline':False]
['text':' Call anything, using the most generic code.','line_number':510,'multiline':False]
['text':' Assert if the return value is already erased.','line_number':522,'multiline':False]
['text':' object register','line_number':530,'multiline':False]
['text':' stack counter register','line_number':531,'multiline':False]
['text':' Bailout is needed in the case of too many values in the arguments array.','line_number':533,'multiline':False]
['text':' Assert if the return value is already erased.','line_number':543,'multiline':False]
['text':' object register','line_number':551,'multiline':False]
['text':' stack counter register','line_number':552,'multiline':False]
['text':' Bailout is needed in the case of too many values in the arguments array.','line_number':554,'multiline':False]
['text':' Assert if the return value is already erased.','line_number':564,'multiline':False]
['text':' object register','line_number':572,'multiline':False]
['text':' stack counter register','line_number':573,'multiline':False]
['text':' Bailout is needed in the case of too many values in the array, or empty','line_number':575,'multiline':False]
['text':' space at the end of the array.','line_number':576,'multiline':False]
['text':' Assert if the return value is already erased.','line_number':589,'multiline':False]
['text':' Bailout is needed in the case of too many values in the array, or empty','line_number':600,'multiline':False]
['text':' space at the end of the array.','line_number':601,'multiline':False]
['text':' String is converted to length of string in the type analysis phase (see','line_number':668,'multiline':False]
['text':' TestPolicy).','line_number':669,'multiline':False]
['text':' Testing a constant.','line_number':672,'multiline':False]
['text':' Objects are truthy, except if it might emulate undefined.','line_number':688,'multiline':False]
['text':' These must be explicitly sniffed out since they are constants and have','line_number':696,'multiline':False]
['text':' no payload.','line_number':697,'multiline':False]
['text':' All symbols are truthy.','line_number':703,'multiline':False]
['text':' Emit LBitAndBranch for cases like |if ((x & y) === 0)|.','line_number':710,'multiline':False]
['text':' Check if the operand for this test is a compare operation. If it is, we','line_number':743,'multiline':False]
['text':' want to emit an LCompare*AndBranch rather than an LTest*AndBranch, to fuse','line_number':744,'multiline':False]
['text':' the compare and jump instructions.','line_number':745,'multiline':False]
['text':' Try to fold the comparison so that we don't have to handle all cases.','line_number':751,'multiline':False]
['text':' Emit LCompare*AndBranch.','line_number':758,'multiline':False]
['text':' Compare and branch null/undefined.','line_number':760,'multiline':False]
['text':' The second operand has known null/undefined type,','line_number':761,'multiline':False]
['text':' so just test the first operand.','line_number':762,'multiline':False]
['text':' Compare and branch Int32, Symbol or Object pointers.','line_number':778,'multiline':False]
['text':' Compare and branch Int64.','line_number':800,'multiline':False]
['text':' Compare and branch doubles.','line_number':808,'multiline':False]
['text':' Compare and branch floats.','line_number':818,'multiline':False]
['text':' Check if the operand for this test is a bitand operation. If it is, we want','line_number':829,'multiline':False]
['text':' to emit an LBitAndAndBranch rather than an LTest*AndBranch.','line_number':830,'multiline':False]
['text':' Check if the operand for this test is an any_true/all_true SIMD operation.','line_number':845,'multiline':False]
['text':' If it is, we want to emit an LWasmReduceAndBranchSimd128 node to avoid','line_number':846,'multiline':False]
['text':' generating an intermediate boolean result.','line_number':847,'multiline':False]
['text':' If the result is never used, we can usefully defer emission to the use','line_number':923,'multiline':False]
['text':' point, since that will never happen.','line_number':924,'multiline':False]
['text':' If the first use isn't of the expected form, the answer is No.','line_number':930,'multiline':False]
['text':' Emission can be deferred to the first use point, but only if there are no','line_number':941,'multiline':False]
['text':' other use points.','line_number':942,'multiline':False]
['text':' Try to fold the comparison so that we don't have to handle all cases.','line_number':951,'multiline':False]
['text':' Move below the emitAtUses call if we ever implement','line_number':958,'multiline':False]
['text':' LCompareSAndBranch. Doing this now wouldn't be wrong, but doesn't','line_number':959,'multiline':False]
['text':' make sense and avoids confusion.','line_number':960,'multiline':False]
['text':' Compare two BigInts.','line_number':969,'multiline':False]
['text':' Compare BigInt with Int32.','line_number':977,'multiline':False]
['text':' Compare BigInt with Double.','line_number':985,'multiline':False]
['text':' Compare BigInt with String.','line_number':994,'multiline':False]
['text':' Sniff out if the output of this compare is used only for a branching.','line_number':1003,'multiline':False]
['text':' If it is, then we will emit an LCompare*AndBranch instruction in place','line_number':1004,'multiline':False]
['text':' of this compare and any test that uses this compare. Thus, we can','line_number':1005,'multiline':False]
['text':' ignore this Compare.','line_number':1006,'multiline':False]
['text':' Compare Null and Undefined.','line_number':1012,'multiline':False]
['text':' Compare Int32, Symbol, Object or Wasm pointers.','line_number':1026,'multiline':False]
['text':' Compare Int64.','line_number':1047,'multiline':False]
['text':' Compare doubles.','line_number':1057,'multiline':False]
['text':' Compare float32.','line_number':1064,'multiline':False]
['text':' Sniff out if the output of this bitand is used only for a branching.','line_number':1195,'multiline':False]
['text':' If it is, then we will emit an LBitAndAndBranch instruction in place','line_number':1196,'multiline':False]
['text':' of this bitand and any test that uses this bitand. Thus, we can','line_number':1197,'multiline':False]
['text':' ignore this BitAnd.','line_number':1198,'multiline':False]
['text':' Input reuse is OK (for now) even on ARM64: floating min/max are fairly','line_number':1381,'multiline':False]
['text':' expensive due to SNaN -> QNaN conversion, and int min/max is for asm.js.','line_number':1382,'multiline':False]
['text':' needed to handle abs(INT32_MIN)','line_number':1409,'multiline':False]
['text':' Restrict this optimization to |base <= 256| to avoid generating too','line_number':1538,'multiline':False]
['text':' many consecutive shift instructions.','line_number':1539,'multiline':False]
['text':' Try to mark an add or sub instruction as able to recover its input when','line_number':1612,'multiline':False]
['text':' bailing out.','line_number':1613,'multiline':False]
['text':' The original operands to an add or sub can't be recovered if they both','line_number':1625,'multiline':False]
['text':' use the same register.','line_number':1626,'multiline':False]
['text':' Add instructions that are on two different values can recover','line_number':1633,'multiline':False]
['text':' the input they clobbered via MUST_REUSE_INPUT. Thus, a copy','line_number':1634,'multiline':False]
['text':' of that input does not need to be kept alive in the snapshot','line_number':1635,'multiline':False]
['text':' for the instruction.','line_number':1636,'multiline':False]
['text':' If our LHS is a constant 0 and we don't have to worry about results that','line_number':1705,'multiline':False]
['text':' can't be represented as an int32, we can optimize to an LNegI.','line_number':1706,'multiline':False]
['text':' If our LHS is a constant 0, we can optimize to an LNegI64.','line_number':1721,'multiline':False]
['text':' If our RHS is a constant -1 and we don't have to worry about results that','line_number':1757,'multiline':False]
['text':' can't be represented as an int32, we can optimize to an LNegI.','line_number':1758,'multiline':False]
['text':' If our RHS is a constant -1, we can optimize to an LNegI64.','line_number':1773,'multiline':False]
['text':' If our RHS is a constant -1.0, we can optimize to an LNegD.','line_number':1788,'multiline':False]
['text':' We apply the same optimizations as for doubles','line_number':1803,'multiline':False]
['text':' Ion does an unaligned ABI call and thus needs a temp register.','line_number':1913,'multiline':False]
['text':' Note: useRegisterAtStart is safe here, the temp is not a FP register.','line_number':1914,'multiline':False]
['text':' Objects might be effectful. Symbols will throw.','line_number':2151,'multiline':False]
['text':' Strings are complicated - we don't handle them yet.','line_number':2152,'multiline':False]
['text':' Objects might be effectful. Symbols will throw.','line_number':2203,'multiline':False]
['text':' Strings are complicated - we don't handle them yet.','line_number':2204,'multiline':False]
['text':' Objects might be effectful. Symbols and BigInts throw. Undefined','line_number':2260,'multiline':False]
['text':' coerces to NaN, not int32.','line_number':2261,'multiline':False]
['text':' Objects might be effectful. Symbols and BigInts throw.','line_number':2310,'multiline':False]
['text':' Strings are complicated - we don't handle them yet.','line_number':2311,'multiline':False]
['text':' May call into JS::ToInt32() on the slow OOL path.','line_number':2343,'multiline':False]
['text':' May call into JS::ToInt32() on the slow OOL path.','line_number':2349,'multiline':False]
['text':' Objects might be effectful. Symbols throw.','line_number':2355,'multiline':False]
['text':' Strings are complicated - we don't handle them yet.','line_number':2356,'multiline':False]
['text':' If the result is only used by instructions that expect a bounds-checked','line_number':2367,'multiline':False]
['text':' index, we must have eliminated or hoisted a bounds check and we can assume','line_number':2368,'multiline':False]
['text':' the index is non-negative. This lets us generate more efficient code.','line_number':2369,'multiline':False]
['text':' In debug builds we verify this non-negative assumption at runtime.','line_number':2370,'multiline':False]
['text':' On 32-bit platforms this is a no-op.','line_number':2396,'multiline':False]
['text':' On 32-bit platforms this is a no-op.','line_number':2413,'multiline':False]
['text':' Input reuse is OK even on ARM64 because this node *must* reuse its input in','line_number':2424,'multiline':False]
['text':' order not to generate any code at all, as is the intent.','line_number':2425,'multiline':False]
['text':' Input reuse is OK even on ARM64 because this node *must* reuse its input in','line_number':2439,'multiline':False]
['text':' order not to generate any code at all, as is the intent.','line_number':2440,'multiline':False]
['text':' An Int64 may be passed here from a BigInt to Int64 conversion.','line_number':2512,'multiline':False]
['text':' Undefined, Null, Number, and Symbol throw.','line_number':2519,'multiline':False]
['text':' Objects may be effectful.','line_number':2520,'multiline':False]
['text':' BigInt operands are eliminated by the type policy.','line_number':2521,'multiline':False]
['text':' May call into JS::ToInt32() on the slow OOL path.','line_number':2559,'multiline':False]
['text':' Float32, symbols, bigint, and objects are not supported.','line_number':2637,'multiline':False]
['text':' Returns true iff |def| is a constant that's either not a GC thing or is not','line_number':2947,'multiline':False]
['text':' allocated in the nursery.','line_number':2948,'multiline':False]
['text':' LPostWriteBarrier assumes that if it has a constant object then that','line_number':2960,'multiline':False]
['text':' object is tenured, and does not need to be tested for being in the','line_number':2961,'multiline':False]
['text':' nursery. Ensure that assumption holds by lowering constant nursery','line_number':2962,'multiline':False]
['text':' objects to a register.','line_number':2963,'multiline':False]
['text':' Currently, only objects and strings can be in the nursery. Other','line_number':3012,'multiline':False]
['text':' instruction types cannot hold nursery pointers.','line_number':3013,'multiline':False]
['text':' LPostWriteElementBarrier assumes that if it has a constant object then that','line_number':3022,'multiline':False]
['text':' object is tenured, and does not need to be tested for being in the','line_number':3023,'multiline':False]
['text':' nursery. Ensure that assumption holds by lowering constant nursery','line_number':3024,'multiline':False]
['text':' objects to a register.','line_number':3025,'multiline':False]
['text':' Currently, only objects, strings, and bigints can be in the nursery.','line_number':3076,'multiline':False]
['text':' Other instruction types cannot hold nursery pointers.','line_number':3077,'multiline':False]
['text':' String is converted to length of string in the type analysis phase (see','line_number':3208,'multiline':False]
['text':' TestPolicy).','line_number':3209,'multiline':False]
['text':' - boolean: x xor 1','line_number':3212,'multiline':False]
['text':' - int32: LCompare(x, 0)','line_number':3213,'multiline':False]
['text':' - double: LCompare(x, 0)','line_number':3214,'multiline':False]
['text':' - null or undefined: true','line_number':3215,'multiline':False]
['text':' - symbol: false','line_number':3216,'multiline':False]
['text':' - bigint: LNotBI(x)','line_number':3217,'multiline':False]
['text':' - object: false if it never emulates undefined, else LNotO(x)','line_number':3218,'multiline':False]
['text':' On x86, spectreBoundsCheck32 can emit better code if it has a scratch','line_number':3402,'multiline':False]
['text':' register and index masking is enabled.','line_number':3403,'multiline':False]
['text':' We will bailout before pushing if the length would overflow INT32_MAX.','line_number':3471,'multiline':False]
['text':' We need a temp register for Uint32Array with known double result.','line_number':3537,'multiline':False]
['text':' We need a temp register for:','line_number':3574,'multiline':False]
['text':' - Uint32Array with known double result,','line_number':3575,'multiline':False]
['text':' - Float32Array,','line_number':3576,'multiline':False]
['text':' - and BigInt64Array and BigUint64Array.','line_number':3577,'multiline':False]
['text':' There are not enough registers on x86.','line_number':3586,'multiline':False]
['text':' We also need a separate 64-bit temp register for:','line_number':3595,'multiline':False]
['text':' - Float64Array','line_number':3596,'multiline':False]
['text':' - and BigInt64Array and BigUint64Array.','line_number':3597,'multiline':False]
['text':' LClampDToUint8 clobbers its input register. Making it available as','line_number':3628,'multiline':False]
['text':' a temp copy describes this behavior to the register allocator.','line_number':3629,'multiline':False]
['text':' For byte arrays, the value has to be in a byte register on x86.','line_number':3704,'multiline':False]
['text':' Optimization opportunity for atomics: on some platforms there','line_number':3713,'multiline':False]
['text':' is a store instruction that incorporates the necessary','line_number':3714,'multiline':False]
['text':' barriers, and we could use that instead of separate barrier and','line_number':3715,'multiline':False]
['text':' store instructions.  See bug #1077027.','line_number':3716,'multiline':False]
['text':' For byte arrays, the value has to be in a byte register on x86.','line_number':3794,'multiline':False]
['text':' Emit an overrecursed check: this is necessary because the cache can','line_number':3911,'multiline':False]
['text':' attach a scripted getter stub that calls this script recursively.','line_number':3912,'multiline':False]
['text':' Emit an overrecursed check: this is necessary because the cache can','line_number':3953,'multiline':False]
['text':' attach a scripted getter stub that calls this script recursively.','line_number':3954,'multiline':False]
['text':' If this is a GetProp, the id is a constant string. Allow passing it as a','line_number':3957,'multiline':False]
['text':' constant to reduce register allocation pressure.','line_number':3958,'multiline':False]
['text':' If this is a SetProp, the id is a constant string. Allow passing it as a','line_number':4375,'multiline':False]
['text':' constant to reduce register allocation pressure.','line_number':4376,'multiline':False]
['text':' Emit an overrecursed check: this is necessary because the cache can','line_number':4381,'multiline':False]
['text':' attach a scripted setter stub that calls this script recursively.','line_number':4382,'multiline':False]
['text':' We need a double temp register for TypedArray or TypedObject stubs.','line_number':4385,'multiline':False]
['text':' Emit an overrecursed check: this is necessary because the cache can','line_number':4506,'multiline':False]
['text':' attach a scripted getter stub that calls this script recursively.','line_number':4507,'multiline':False]
['text':'offs=','line_number':4765,'multiline':True]
['text':'offs=','line_number':4768,'multiline':True]
['text':' Functions that return stack results receive an extra incoming parameter','line_number':4844,'multiline':False]
['text':' with type MIRType::StackResults.  This value is a pointer to fresh','line_number':4845,'multiline':False]
['text':' memory.  Here we treat it as if it were in fact MIRType::Pointer.','line_number':4846,'multiline':False]
['text':' usedAtStart = ','line_number':5002,'multiline':True]
['text':' usedAtStart = ','line_number':5018,'multiline':True]
['text':' Keep using GetTempRegForIntArg, since we want to make sure we','line_number':5071,'multiline':False]
['text':' don't clobber registers we're already using.','line_number':5072,'multiline':False]
['text':' We wish we could assert that ins->domAliasSet() == JSJitInfo::AliasNone,','line_number':5103,'multiline':False]
['text':' but some MGetDOMMembers are for [Pure], not [Constant] properties, whose','line_number':5104,'multiline':False]
['text':' value can in fact change as a result of DOM setters and method calls.','line_number':5105,'multiline':False]
['text':' Constants of special types (undefined, null) should never flow into','line_number':5667,'multiline':False]
['text':' here directly. Operations blindly consuming them require a Box.','line_number':5668,'multiline':False]
['text':' Don't compile the switch-statement below so that we don't have to define','line_number':5726,'multiline':False]
['text':' the platform-specific visit* methods for the none-backend.','line_number':5727,'multiline':False]
['text':' If no safepoint was created, there's no need for an OSI point.','line_number':5768,'multiline':False]
['text':' Note: RangeAnalysis can flag blocks as unreachable, but they are only','line_number':5803,'multiline':False]
['text':' removed iff GVN (including UCE) is enabled.','line_number':5804,'multiline':False]
['text':' If we have a successor with phis, lower the phi input now that we','line_number':5831,'multiline':False]
['text':' are approaching the join point.','line_number':5832,'multiline':False]
['text':' Now emit the last instruction, which is some form of branch.','line_number':5860,'multiline':False]
['text':' Create all blocks and prep all phis beforehand.','line_number':5881,'multiline':False]
['text':' Phi nodes are not lowered because they are only meaningful for the register','line_number':5909,'multiline':False]
['text':' allocator.','line_number':5910,'multiline':False]
['text':' Beta nodes are supposed to be removed before because they are','line_number':5915,'multiline':False]
['text':' only used to carry the range information for Range analysis','line_number':5916,'multiline':False]
['text':' ObjectState nodes are always recovered on bailouts','line_number':5921,'multiline':False]
['text':' ArrayState nodes are always recovered on bailouts','line_number':5926,'multiline':False]
['text':' The instruction needs a temp register:','line_number':5931,'multiline':False]
['text':' - that's not the FramePointer, since wasm is going to use it in the','line_number':5932,'multiline':False]
['text':' function.','line_number':5933,'multiline':False]
['text':' - that's not aliasing an input register.','line_number':5934,'multiline':False]
['text':' Also prevent register allocation from using wasm's FramePointer, in','line_number':5937,'multiline':False]
['text':' non-profiling mode.','line_number':5938,'multiline':False]
['text':' Note that since this is a LIR call instruction, regalloc will prevent','line_number':5943,'multiline':False]
['text':' the use*AtStart below from reusing any of the temporaries.','line_number':5944,'multiline':False]
['text':' Pick off specific cases that we can do with LWasmCompareAndSelect to avoid','line_number':5988,'multiline':False]
['text':' generating a boolean that we then have to test again.','line_number':5989,'multiline':False]
['text':' We don't currently generate any other JSOPs for the comparison, and if','line_number':5995,'multiline':False]
['text':' that changes, we want to know about it.  Hence this assertion.','line_number':5996,'multiline':False]
['text':' Fall through to code that generates a boolean and selects on that.','line_number':6006,'multiline':False]
