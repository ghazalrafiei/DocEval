['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' Ephemeron edges have two source nodes and one target, and mark the target','line_number':51,'multiline':False]
['text':' with the minimum (least-marked) color of the sources. Currently, one of','line_number':52,'multiline':False]
['text':' those sources will always be a WeakMapBase, so this will refer to its color','line_number':53,'multiline':False]
['text':' at the time the edge is traced through. The other source's color will be','line_number':54,'multiline':False]
['text':' given by the current mark color of the GCMarker.','line_number':55,'multiline':False]
['text':'
 * When the mark stack is full, the GC does not call js::TraceChildren to mark
 * the reachable "children" of the thing. Rather the thing is put aside and
 * js::TraceChildren is called later when the mark stack is empty.
 *
 * To implement such delayed marking of the children with minimal overhead for
 * the normal case of sufficient stack, we link arenas into a list using
 * Arena::setNextDelayedMarkingArena(). The head of the list is stored in
 * GCMarker::delayedMarkingList. GCMarker::delayMarkingChildren() adds arenas
 * to the list as necessary while markAllDelayedChildren() pops the arenas from
 * the stack until it is empty.
 ','line_number':69,'multiline':True]
['text':'
   * We use a common mark stack to mark GC things of different types and use
   * the explicit tags to distinguish them when it cannot be deduced from
   * the context of push or pop operation.
   ','line_number':83,'multiline':True]
['text':' The unit for MarkStack::capacity() is mark stack entries.','line_number':143,'multiline':False]
['text':' GCMarker::eagerlyMarkChildren uses unused marking stack as temporary','line_number':164,'multiline':False]
['text':' storage to hold rope pointers.','line_number':165,'multiline':False]
['text':' Fall back to the smaller initial capacity so we don't hold on to excess','line_number':175,'multiline':False]
['text':' memory between GCs.','line_number':176,'multiline':False]
['text':' Grow the stack, ensuring there is space for at least count elements. ','line_number':193,'multiline':True]
['text':' Index of the top of the stack.','line_number':203,'multiline':False]
['text':' The maximum stack capacity to grow to.','line_number':206,'multiline':False]
['text':' Vector containing allocated stack memory. Unused beyond topIndex_.','line_number':209,'multiline':False]
['text':' namespace gc ','line_number':239,'multiline':True]
['text':' Have not yet started marking.','line_number':242,'multiline':False]
['text':' Main marking mode. Weakmap marking will be populating the gcEphemeronEdges','line_number':245,'multiline':False]
['text':' tables but not consulting them. The state will transition to WeakMarking','line_number':246,'multiline':False]
['text':' until it is done, then back to RegularMarking.','line_number':247,'multiline':False]
['text':' Same as RegularMarking except now every marked obj/script is immediately','line_number':250,'multiline':False]
['text':' looked up in the gcEphemeronEdges table to find edges generated by weakmap','line_number':251,'multiline':False]
['text':' keys, and traversing them to their values. Transitions back to','line_number':252,'multiline':False]
['text':' RegularMarking when done.','line_number':253,'multiline':False]
['text':' Same as RegularMarking, but we OOMed (or obeyed a directive in the test','line_number':256,'multiline':False]
['text':' marking queue) and fell back to iterating until the next GC.','line_number':257,'multiline':False]
['text':' If |thing| is unmarked, mark it and then traverse its children.','line_number':275,'multiline':False]
['text':' Traverse a GC thing's children, using a strategy depending on the type.','line_number':279,'multiline':False]
['text':' This can either processing them immediately or push them onto the mark','line_number':280,'multiline':False]
['text':' stack for later.','line_number':281,'multiline':False]
['text':' Calls traverse on target after making additional assertions.','line_number':285,'multiline':False]
['text':' Helper methods that coerce their second argument to the base pointer','line_number':291,'multiline':False]
['text':' type.','line_number':292,'multiline':False]
['text':' We can't check atom marking if the helper thread lock is already held by','line_number':306,'multiline':False]
['text':' the current thread. This allows us to disable the check.','line_number':307,'multiline':False]
['text':'
   * Care must be taken changing the mark color from gray to black. The cycle
   * collector depends on the invariant that there are no black to gray edges
   * in the GC heap. This invariant lets the CC not trace through black
   * objects. If this invariant is violated, the cycle collector may free
   * objects that are still reachable.
   ','line_number':311,'multiline':True]
['text':' Declare which color the main mark stack will be used for. The whole stack','line_number':322,'multiline':False]
['text':' must be empty when this is called.','line_number':323,'multiline':False]
['text':' Do not use linear-time weak marking for the rest of this collection.','line_number':329,'multiline':False]
['text':' Currently, this will only be triggered by an OOM when updating needed data','line_number':330,'multiline':False]
['text':' structures.','line_number':331,'multiline':False]
['text':' 'delegate' is no longer the delegate of 'key'.','line_number':342,'multiline':False]
['text':' 'delegate' is now the delegate of 'key'. Update weakmap marking state.','line_number':345,'multiline':False]
['text':' The mark queue is a testing-only feature for controlling mark ordering and','line_number':350,'multiline':False]
['text':' yield timing.','line_number':351,'multiline':False]
['text':' End this incremental GC slice, if possible','line_number':353,'multiline':False]
['text':' Done with the queue','line_number':354,'multiline':False]
['text':' Continue the GC without ending the slice','line_number':355,'multiline':False]
['text':' Ignore failure to resize the stack and keep using the existing stack.','line_number':367,'multiline':False]
['text':' Mark through edges whose target color depends on the colors of two source','line_number':377,'multiline':False]
['text':' entities (eg a WeakMap and one of its keys), and push the target onto the','line_number':378,'multiline':False]
['text':' mark stack.','line_number':379,'multiline':False]
['text':' Push an object onto the stack for later tracing and assert that it has','line_number':402,'multiline':False]
['text':' already been marked.','line_number':403,'multiline':False]
['text':' Process a marked thing's children by calling T::traceChildren().','line_number':406,'multiline':False]
['text':' Process a marked thing's children recursively using an iterative loop and','line_number':410,'multiline':False]
['text':' manual dispatch, for kinds where this is possible.','line_number':411,'multiline':False]
['text':' Push a marked thing onto the mark stack. Its children will be marked later.','line_number':415,'multiline':False]
['text':' We may not have concrete types yet, so this has to be outside the header.','line_number':428,'multiline':False]
['text':' Mark the given GC thing, but do not trace its children. Return true','line_number':432,'multiline':False]
['text':' if the thing became marked.','line_number':433,'multiline':False]
['text':'
   * List of cells encountered by the pre-write barrier whose children have yet
   * to be marked. These cells have already been marked black. They are "grey"
   * in the GC sense.
   ','line_number':485,'multiline':True]
['text':'
   * The mark stack. Pointers in this stack are "gray" in the GC sense, but may
   * mark the contained items either black or gray (in the CC sense) depending
   * on mainStackColor.
   ','line_number':493,'multiline':True]
['text':'
   * A smaller, auxiliary stack, currently only used to accumulate the rare
   * objects that need to be marked black during gray marking.
   ','line_number':500,'multiline':True]
['text':' The color is only applied to objects and functions. ','line_number':506,'multiline':True]
['text':' Pointer to the top of the stack of arenas we are delaying marking on. ','line_number':513,'multiline':True]
['text':' Whether more work has been added to the delayed marking list. ','line_number':516,'multiline':True]
['text':' The count of marked objects during GC. ','line_number':519,'multiline':True]
['text':' Track the state of marking. ','line_number':522,'multiline':True]
['text':'
   * Whether weakmaps can be marked incrementally.
   *
   * JSGC_INCREMENTAL_WEAKMAP_ENABLED
   * pref: javascript.options.mem.incremental_weakmap
   ','line_number':526,'multiline':True]
['text':' Count of arenas that are currently in the stack. ','line_number':536,'multiline':True]
['text':' Assert that start and stop are called with correct ordering. ','line_number':539,'multiline':True]
['text':'
   * Whether to check that atoms traversed are present in atom marking
   * bitmap.
   ','line_number':542,'multiline':True]
['text':' The test marking queue might want to be marking a particular color. ','line_number':548,'multiline':True]
['text':'
   * If this is true, all marked objects must belong to a compartment being
   * GCed. This is used to look for compartment bugs.
   ','line_number':551,'multiline':True]
['text':'
   * The compartment and zone of the object whose trace hook is currently being
   * called, if any. Used to catch cross-compartment edges traced without use of
   * TraceCrossCompartmentEdge.
   ','line_number':558,'multiline':True]
['text':'
   * List of objects to mark at the beginning of a GC. May also contains string
   * directives to change mark color or wait until different phases of the GC.
   *
   * This is a WeakCache because not everything in this list is guaranteed to
   * end up marked (eg if you insert an object from an already-processed sweep
   * group in the middle of an incremental GC). Also, the mark queue is not
   * used during shutdown GCs. In either case, unmarked objects may need to be
   * discarded.
   ','line_number':566,'multiline':True]
['text':' Position within the test mark queue. ','line_number':578,'multiline':True]
['text':' DEBUG','line_number':580,'multiline':False]
['text':'
 * Temporarily change the mark color while this class is on the stack.
 *
 * During incremental sweeping this also transitions zones in the
 * current sweep group into the Mark or MarkGray state as appropriate.
 ','line_number':585,'multiline':True]
['text':' namespace gc ','line_number':607,'multiline':True]
['text':' namespace js ','line_number':609,'multiline':True]
['text':' gc_GCMarker_h ','line_number':611,'multiline':True]
