['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' shared','line_number':36,'multiline':False]
['text':' All non-table-based bailouts will go here.','line_number':47,'multiline':False]
['text':' Store the frame size, so the handler can recover the IonScript.','line_number':50,'multiline':False]
['text':' Jump to the True block if NonZero.','line_number':80,'multiline':False]
['text':' Jump to the False block if Zero.','line_number':81,'multiline':False]
['text':' Though the assembler doesn't track all frame pushes, at least make sure','line_number':148,'multiline':False]
['text':' the known value makes sense.','line_number':149,'multiline':False]
['text':' ARM64 doesn't use a bailout table.','line_number':153,'multiline':False]
['text':' Though the assembler doesn't track all frame pushes, at least make sure','line_number':168,'multiline':False]
['text':' the known value makes sense.','line_number':169,'multiline':False]
['text':' ARM64 doesn't use a bailout table.','line_number':173,'multiline':False]
['text':' FIXME: Uh, is this a static function? It looks like it is...','line_number':215,'multiline':False]
['text':' FIXME: Uh, is this a static function? It looks like it is...','line_number':221,'multiline':False]
['text':' Let |cond| be an ARM64 condition code that we could reasonably use in a','line_number':251,'multiline':False]
['text':' conditional branch or select following a comparison instruction.  This','line_number':252,'multiline':False]
['text':' function returns the condition to use in the case where we swap the two','line_number':253,'multiline':False]
['text':' operands of the comparison instruction.','line_number':254,'multiline':False]
['text':' EQ and NE map to themselves','line_number':256,'multiline':False]
['text':' Of the remaining 14 cases, 4 other pairings can meaningfully swap:','line_number':257,'multiline':False]
['text':' HS -- LS','line_number':258,'multiline':False]
['text':' LO -- HI','line_number':259,'multiline':False]
['text':' GE -- LE','line_number':260,'multiline':False]
['text':' GT -- LT','line_number':261,'multiline':False]
['text':' Platforms with three-operand arithmetic ops don't need recovery.','line_number':292,'multiline':False]
['text':' Platforms with three-operand arithmetic ops don't need recovery.','line_number':308,'multiline':False]
['text':' Bailout on -0.0.','line_number':333,'multiline':False]
['text':' Go to overflow check.','line_number':345,'multiline':False]
['text':' Avoid overflow check.','line_number':348,'multiline':False]
['text':' Avoid overflow check.','line_number':353,'multiline':False]
['text':' Go to overflow check.','line_number':356,'multiline':False]
['text':' Use shift if cannot overflow and constant is a power of 2','line_number':358,'multiline':False]
['text':' Otherwise, just multiply. We have to check for overflow.','line_number':367,'multiline':False]
['text':' Negative zero was handled above.','line_number':368,'multiline':False]
['text':' Overflow check.','line_number':385,'multiline':False]
['text':' The product of two integer operands is negative zero iff one','line_number':397,'multiline':False]
['text':' operand is zero, and the other is negative. Therefore, the','line_number':398,'multiline':False]
['text':' sum of the two operands will also be negative (specifically,','line_number':399,'multiline':False]
['text':' it will be the non-zero operand). If the result of the','line_number':400,'multiline':False]
['text':' multiplication is 0, we can check the sign of the sum to','line_number':401,'multiline':False]
['text':' determine whether we should bail out.','line_number':402,'multiline':False]
['text':' This code can bailout, so lowering guarantees that the input','line_number':404,'multiline':False]
['text':' operands are not overwritten.','line_number':405,'multiline':False]
['text':' Do the multiplication.','line_number':409,'multiline':False]
['text':' Set Zero flag if destreg is 0.','line_number':412,'multiline':False]
['text':' ccmn is 'conditional compare negative'.','line_number':415,'multiline':False]
['text':' If the Zero flag is set:','line_number':416,'multiline':False]
['text':'    perform a compare negative (compute lhs+rhs and set flags)','line_number':417,'multiline':False]
['text':' else:','line_number':418,'multiline':False]
['text':'    clear flags','line_number':419,'multiline':False]
['text':' Bails out if (lhs * rhs == 0) && (lhs + rhs < 0):','line_number':422,'multiline':False]
['text':' Handle division by zero.','line_number':448,'multiline':False]
['text':' Truncated division by zero is zero: (Infinity|0 = 0).','line_number':457,'multiline':False]
['text':' Handle an integer overflow from (INT32_MIN / -1).','line_number':469,'multiline':False]
['text':' The integer division gives INT32_MIN, but should be -(double)INT32_MIN.','line_number':470,'multiline':False]
['text':' Branch to handle the non-overflow cases.','line_number':474,'multiline':False]
['text':' Handle overflow.','line_number':478,'multiline':False]
['text':' (-INT32_MIN)|0 == INT32_MIN, which is already in lhs.','line_number':482,'multiline':False]
['text':' Handle negative zero: lhs == 0 && rhs < 0.','line_number':492,'multiline':False]
['text':' Perform integer division.','line_number':501,'multiline':False]
['text':' ARM does not automatically calculate the remainder.','line_number':508,'multiline':False]
['text':' The ISR suggests multiplication to determine whether a remainder exists.','line_number':509,'multiline':False]
['text':' 0 divided by a negative number returns a -0 double.','line_number':530,'multiline':False]
['text':' If the remainder is != 0, bailout since this must be a double.','line_number':536,'multiline':False]
['text':' shift right','line_number':542,'multiline':False]
['text':' Adjust the value so that shifting produces a correctly','line_number':546,'multiline':False]
['text':' rounded result when the numerator is negative. See 10-1','line_number':547,'multiline':False]
['text':' "Signed Division by a Known Power of 2" in Henry','line_number':548,'multiline':False]
['text':' S. Warren, Jr.'s Hacker's Delight.','line_number':549,'multiline':False]
['text':' Copy the sign bit of the numerator. (= (2^32 - 1) or 0)','line_number':552,'multiline':False]
['text':' Divide by 2^(32 - shift)','line_number':556,'multiline':False]
['text':' i.e. (= (2^32 - 1) / 2^(32 - shift) or 0)','line_number':557,'multiline':False]
['text':' i.e. (= (2^shift - 1) or 0)','line_number':558,'multiline':False]
['text':' If signed, make any 1 bit below the shifted bits to bubble up, such','line_number':560,'multiline':False]
['text':' that once shifted the value would be rounded towards 0.','line_number':561,'multiline':False]
['text':' INT32_MIN / -1 overflows.','line_number':575,'multiline':False]
['text':' Do not set condition flags.','line_number':586,'multiline':False]
['text':' Copy and set flags.','line_number':591,'multiline':False]
['text':' Unsigned division by 1 can overflow if output is not truncated, as we','line_number':593,'multiline':False]
['text':' do not have an Unsigned type for MIR instructions.','line_number':594,'multiline':False]
['text':' Copy the result.','line_number':597,'multiline':False]
['text':' The absolute value of the denominator isn't a power of 2.','line_number':611,'multiline':False]
['text':' We will first divide by Abs(d), and negate the answer if d is negative.','line_number':615,'multiline':False]
['text':' If desired, this can be avoided by generalizing computeDivisionConstants.','line_number':616,'multiline':False]
['text':' maxLog = ','line_number':618,'multiline':True]
['text':' We first compute (M * n) >> 32, where M = rmc.multiplier.','line_number':620,'multiline':False]
['text':' We actually compute (int32_t(M) * n) instead, without the upper bit.','line_number':625,'multiline':False]
['text':' Thus, (M * n) = (int32_t(M) * n) + n << 32.','line_number':626,'multiline':False]
['text':'','line_number':627,'multiline':False]
['text':' ((int32_t(M) * n) + n << 32) can't overflow, as both operands have','line_number':628,'multiline':False]
['text':' opposite signs because int32_t(M) is negative.','line_number':629,'multiline':False]
['text':' Store (M * n) in output64.','line_number':632,'multiline':False]
['text':' Store (M * n) in output64.','line_number':635,'multiline':False]
['text':' (M * n) >> (32 + shift) is the truncated division answer if n is','line_number':639,'multiline':False]
['text':' non-negative, as proved in the comments of computeDivisionConstants. We','line_number':640,'multiline':False]
['text':' must add 1 later if n is negative to get the right answer in all cases.','line_number':641,'multiline':False]
['text':' We'll subtract -1 instead of adding 1, because (n < 0 ? -1 : 0) can be','line_number':644,'multiline':False]
['text':' computed with just a sign-extending shift of 31 bits.','line_number':645,'multiline':False]
['text':' After this, output32 contains the correct truncated division result.','line_number':651,'multiline':False]
['text':' This is a division op. Multiply the obtained value by d to check if','line_number':657,'multiline':False]
['text':' the correct answer is an integer. This cannot overflow, since |d| > 1.','line_number':658,'multiline':False]
['text':' bailout if (lhs - output * d != 0)','line_number':661,'multiline':False]
['text':' If lhs is zero and the divisor is negative, the answer should have','line_number':665,'multiline':False]
['text':' been -0.','line_number':666,'multiline':False]
['text':' or bailout if (lhs == 0).','line_number':668,'multiline':False]
['text':' ^                  ^','line_number':669,'multiline':False]
['text':' |                  '-- masm.Ccmp(lhs32, lhs32, .., ..)','line_number':670,'multiline':False]
['text':' '-- masm.Ccmp(.., .., vixl::ZFlag, ! bailoutCond)','line_number':671,'multiline':False]
['text':' bailout if (lhs - output * d != 0) or (d < 0 && lhs == 0)','line_number':676,'multiline':False]
['text':' The denominator isn't a power of 2 (see LDivPowTwoI).','line_number':703,'multiline':False]
['text':' maxLog = ','line_number':706,'multiline':True]
['text':' We first compute (M * n) >> 32, where M = rmc.multiplier.','line_number':708,'multiline':False]
['text':' M >= 2^32 and shift == 0 is impossible, as d >= 2 implies that','line_number':712,'multiline':False]
['text':' ((M * n) >> (32 + shift)) >= n > floor(n/d) whenever n >= d,','line_number':713,'multiline':False]
['text':' contradicting the proof of correctness in computeDivisionConstants.','line_number':714,'multiline':False]
['text':' We actually compute (uint32_t(M) * n) instead, without the upper bit.','line_number':718,'multiline':False]
['text':' Thus, (M * n) = (uint32_t(M) * n) + n << 32.','line_number':719,'multiline':False]
['text':'','line_number':720,'multiline':False]
['text':' ((uint32_t(M) * n) + n << 32) can overflow. Hacker's Delight explains a','line_number':721,'multiline':False]
['text':' trick to avoid this overflow case, but we can avoid it by computing the','line_number':722,'multiline':False]
['text':' addition on 64 bits registers.','line_number':723,'multiline':False]
['text':'','line_number':724,'multiline':False]
['text':' Compute ((uint32_t(M) * n) >> 32 + n)','line_number':725,'multiline':False]
['text':' (M * n) >> (32 + shift) is the truncated division answer.','line_number':728,'multiline':False]
['text':' (M * n) >> (32 + shift) is the truncated division answer.','line_number':731,'multiline':False]
['text':' We now have the truncated division value. We are checking whether the','line_number':735,'multiline':False]
['text':' division resulted in an integer, we multiply the obtained value by d and','line_number':736,'multiline':False]
['text':' check the remainder of the division.','line_number':737,'multiline':False]
['text':' bailout if (lhs - output * d != 0)','line_number':741,'multiline':False]
['text':' Prevent divide by zero.','line_number':755,'multiline':False]
['text':' Truncated division by zero yields integer zero.','line_number':764,'multiline':False]
['text':' Non-truncated division by zero produces a non-integer.','line_number':769,'multiline':False]
['text':' Signed division.','line_number':776,'multiline':False]
['text':' Compute the remainder: output = lhs - (output * rhs).','line_number':779,'multiline':False]
['text':' If output == 0 and lhs < 0, then the result should be double -0.0.','line_number':783,'multiline':False]
['text':' Note that this guard handles lhs == INT_MIN and rhs == -1:','line_number':784,'multiline':False]
['text':'   output = INT_MIN - (INT_MIN / -1) * -1','line_number':785,'multiline':False]
['text':'          = INT_MIN - INT_MIN','line_number':786,'multiline':False]
['text':'          = 0','line_number':787,'multiline':False]
['text':' Switch based on sign of the lhs.','line_number':808,'multiline':False]
['text':' Positive numbers are just a bitmask.','line_number':809,'multiline':False]
['text':' Negative numbers need a negate, bitmask, negate.','line_number':819,'multiline':False]
['text':' Since a%b has the same sign as b, and a is negative in this branch,','line_number':824,'multiline':False]
['text':' an answer of 0 means the correct result is actually -0. Bail out.','line_number':825,'multiline':False]
['text':' We wish to compute x % (1<<y) - 1 for a known constant, y.','line_number':854,'multiline':False]
['text':'','line_number':855,'multiline':False]
['text':' 1. Let b = (1<<y) and C = (1<<y)-1, then think of the 32 bit dividend as','line_number':856,'multiline':False]
['text':' a number in base b, namely c_0*1 + c_1*b + c_2*b^2 ... c_n*b^n','line_number':857,'multiline':False]
['text':'','line_number':858,'multiline':False]
['text':' 2. Since both addition and multiplication commute with modulus:','line_number':859,'multiline':False]
['text':'   x % C == (c_0 + c_1*b + ... + c_n*b^n) % C ==','line_number':860,'multiline':False]
['text':'    (c_0 % C) + (c_1%C) * (b % C) + (c_2 % C) * (b^2 % C)...','line_number':861,'multiline':False]
['text':'','line_number':862,'multiline':False]
['text':' 3. Since b == C + 1, b % C == 1, and b^n % C == 1 the whole thing','line_number':863,'multiline':False]
['text':' simplifies to: c_0 + c_1 + c_2 ... c_n % C','line_number':864,'multiline':False]
['text':'','line_number':865,'multiline':False]
['text':' Each c_n can easily be computed by a shift/bitextract, and the modulus','line_number':866,'multiline':False]
['text':' can be maintained by simply subtracting by C whenever the number gets','line_number':867,'multiline':False]
['text':' over C.','line_number':868,'multiline':False]
['text':' Register 'hold' holds -1 if the value was negative, 1 otherwise.','line_number':872,'multiline':False]
['text':' The remain reg holds the remaining bits that have not been processed.','line_number':873,'multiline':False]
['text':' The scratch reg serves as a temporary location to store extracted bits.','line_number':874,'multiline':False]
['text':' The dest reg is the accumulator, becoming final result.','line_number':875,'multiline':False]
['text':'','line_number':876,'multiline':False]
['text':' Move the whole value into the remain.','line_number':877,'multiline':False]
['text':' Zero out the dest.','line_number':879,'multiline':False]
['text':' Set the hold appropriately.','line_number':881,'multiline':False]
['text':' Begin the main loop.','line_number':893,'multiline':False]
['text':' Extract the bottom bits into scratch.','line_number':896,'multiline':False]
['text':' Add those bits to the accumulator.','line_number':898,'multiline':False]
['text':' Do a trial subtraction. This functions as a cmp but remembers the result.','line_number':900,'multiline':False]
['text':' If (sum - C) > 0, store sum - C back into sum, thus performing a modulus.','line_number':902,'multiline':False]
['text':' Get rid of the bits that we extracted before.','line_number':909,'multiline':False]
['text':' If the shift produced zero, finish, otherwise, continue in the loop.','line_number':911,'multiline':False]
['text':' Check the hold to see if we need to negate the result.','line_number':915,'multiline':False]
['text':' If the hold was non-zero, negate the result to match JS expectations.','line_number':919,'multiline':False]
['text':' Bail in case of negative zero hold.','line_number':922,'multiline':False]
['text':' Callers handle division by zero and integer overflow.','line_number':934,'multiline':False]
['text':' result= ','line_number':939,'multiline':True]
['text':' Create and return the result.','line_number':941,'multiline':False]
['text':' Callers handle division by zero and integer overflow.','line_number':949,'multiline':False]
['text':' Signed division.','line_number':955,'multiline':False]
['text':' Compute the remainder: output = dividend - (output * divisor).','line_number':958,'multiline':False]
['text':' result= ','line_number':959,'multiline':True]
['text':' Create and return the result.','line_number':961,'multiline':False]
['text':' x >>> 0 can overflow.','line_number':1010,'multiline':False]
['text':'/ x >>> 0 can overflow.','line_number':1032,'multiline':False]
['text':' Branch if not -Infinity.','line_number':1075,'multiline':False]
['text':' Math.pow(-Infinity, 0.5) == Infinity.','line_number':1084,'multiline':False]
['text':' Math.pow(-0, 0.5) == 0 == Math.pow(0, 0.5).','line_number':1093,'multiline':False]
['text':' Adding 0 converts any -0 to 0.','line_number':1094,'multiline':False]
['text':' Prevent nop and pools sequences to appear in the jump table.','line_number':1137,'multiline':False]
['text':' The entries of the jump table need to be absolute addresses,','line_number':1149,'multiline':False]
['text':' and thus must be patched after codegen is finished.','line_number':1150,'multiline':False]
['text':' Let the lowest table entry be indexed at 0.','line_number':1163,'multiline':False]
['text':' Jump to the default case if input is out of range.','line_number':1168,'multiline':False]
['text':' Because the target code has not yet been generated, we cannot know the','line_number':1172,'multiline':False]
['text':' instruction offsets for use as jump targets. Therefore we construct','line_number':1173,'multiline':False]
['text':' an OutOfLineTableSwitch that winds up holding the jump table.','line_number':1174,'multiline':False]
['text':'','line_number':1175,'multiline':False]
['text':' Because the jump table is generated as part of out-of-line code,','line_number':1176,'multiline':False]
['text':' it is generated after all the regular codegen, so the jump targets','line_number':1177,'multiline':False]
['text':' are guaranteed to exist when generating the jump table.','line_number':1178,'multiline':False]
['text':' Use the index to get the address of the jump target from the table.','line_number':1182,'multiline':False]
['text':' Load the target from the jump table and branch to it.','line_number':1186,'multiline':False]
['text':' knownNotZero = ','line_number':1245,'multiline':True]
['text':' Infallible unbox.','line_number':1350,'multiline':False]
['text':' Assert the types match.','line_number':1355,'multiline':False]
['text':' If the compare set the 0 bit, then the result is definitely false.','line_number':1409,'multiline':False]
['text':' Overflow means one of the operands was NaN, which is also false.','line_number':1412,'multiline':False]
['text':' If the compare set the 0 bit, then the result is definitely false.','line_number':1424,'multiline':False]
['text':' Overflow means one of the operands was NaN, which is also false.','line_number':1427,'multiline':False]
['text':' See ../CodeGenerator.cpp for more information.','line_number':1485,'multiline':False]
['text':'        NZCV','line_number':1506,'multiline':False]
['text':' NAN -> 0011','line_number':1507,'multiline':False]
['text':' ==  -> 0110','line_number':1508,'multiline':False]
['text':' <   -> 1000','line_number':1509,'multiline':False]
['text':' >   -> 0010','line_number':1510,'multiline':False]
['text':' Set output to 1 if input compares equal to 0.0, else 0.','line_number':1515,'multiline':False]
['text':' Comparison with NaN sets V in the NZCV register.','line_number':1519,'multiline':False]
['text':' If the input was NaN, output must now be zero, so it can be incremented.','line_number':1520,'multiline':False]
['text':' The instruction is read: "output = if NoOverflow then output else 0+1".','line_number':1521,'multiline':False]
['text':' Set output to 1 input compares equal to 0.0, else 0.','line_number':1529,'multiline':False]
['text':' Comparison with NaN sets V in the NZCV register.','line_number':1533,'multiline':False]
['text':' If the input was NaN, output must now be zero, so it can be incremented.','line_number':1534,'multiline':False]
['text':' The instruction is read: "output = if NoOverflow then output else 0+1".','line_number':1535,'multiline':False]
['text':' Ensure that there is enough space in the buffer for the OsiPoint patching','line_number':1540,'multiline':False]
['text':' to occur. Otherwise, we could overwrite the invalidation epilogue.','line_number':1541,'multiline':False]
['text':' Push the return address of the point that we bailout out onto the stack.','line_number':1548,'multiline':False]
['text':' Push the Ion script onto the stack (when we determine what that pointer','line_number':1551,'multiline':False]
['text':' is).','line_number':1552,'multiline':False]
['text':' Jump to the invalidator which will replace the current frame.','line_number':1555,'multiline':False]
['text':' Return a default value in case of a bounds-check failure.','line_number':1586,'multiline':False]
['text':' Prevent divide by zero.','line_number':1798,'multiline':False]
['text':' ARM64 UDIV instruction will return 0 when divided by 0.','line_number':1807,'multiline':False]
['text':' No need for extra tests.','line_number':1808,'multiline':False]
['text':' Unsigned division.','line_number':1815,'multiline':False]
['text':' If the remainder is > 0, bailout since this must be a double.','line_number':1818,'multiline':False]
['text':' Compute the remainder: remainder = lhs - (output * rhs).','line_number':1823,'multiline':False]
['text':' Unsigned div can return a value that's not a signed int32.','line_number':1829,'multiline':False]
['text':' If our users aren't expecting that, bail.','line_number':1830,'multiline':False]
['text':' Truncated division by zero yields integer zero.','line_number':1851,'multiline':False]
['text':' Non-truncated division by zero produces a non-integer.','line_number':1856,'multiline':False]
['text':' Unsigned division.','line_number':1862,'multiline':False]
['text':' Compute the remainder: output = lhs - (output * rhs).','line_number':1865,'multiline':False]
['text':' Bail if the output would be negative.','line_number':1869,'multiline':False]
['text':'','line_number':1870,'multiline':False]
['text':' LUMod inputs may be Uint32, so care is taken to ensure the result','line_number':1871,'multiline':False]
['text':' is not unexpectedly signed.','line_number':1872,'multiline':False]
['text':' Ad-hoc strength reduction, cf the x64 code as well as the 32-bit code','line_number':2174,'multiline':False]
['text':' higher up in this file.  Bug 1712298 will lift this code to the MIR','line_number':2175,'multiline':False]
['text':' constant folding pass, or to lowering.','line_number':2176,'multiline':False]
['text':'','line_number':2177,'multiline':False]
['text':' This is for wasm integers only, so no input guards or overflow checking','line_number':2178,'multiline':False]
['text':' are needed.','line_number':2179,'multiline':False]
['text':' Use shift if constant is nonnegative power of 2.','line_number':2199,'multiline':False]
['text':' If we have a constant base ptr, try to add the offset to it, to generate','line_number':2287,'multiline':False]
['text':' better code when the full address is known.  The addition may overflow past','line_number':2288,'multiline':False]
['text':' 32 bits because the front end does nothing special if the base is a large','line_number':2289,'multiline':False]
['text':' constant and base+offset overflows; sidestep this by performing the addition','line_number':2290,'multiline':False]
['text':' anyway, overflowing to 64-bit.','line_number':2291,'multiline':False]
['text':' Set flag.','line_number':2469,'multiline':False]
['text':' Ref types not supported yet; Int64 takes a different path; v128 is not','line_number':2486,'multiline':False]
['text':' worth optimizing.','line_number':2487,'multiline':False]
['text':' Act on flag.','line_number':2491,'multiline':False]
['text':' See above.','line_number':2508,'multiline':False]
['text':' Jump to the True block if NonZero.','line_number':2627,'multiline':False]
['text':' Jump to the False block if Zero.','line_number':2628,'multiline':False]
['text':' Really this is a 64-bit input register and we could use move64To32.','line_number':2647,'multiline':False]
['text':' Generates no code on this platform because the input is assumed to have','line_number':2667,'multiline':False]
['text':' canonical form.','line_number':2668,'multiline':False]
['text':' Generates no code on this platform because the input is assumed to have','line_number':2675,'multiline':False]
['text':' canonical form.','line_number':2676,'multiline':False]
['text':' Handle divide by zero.','line_number':2904,'multiline':False]
['text':' Handle an integer overflow exception from INT64_MIN / -1.','line_number':2912,'multiline':False]
['text':' Handle divide by zero.','line_number':2942,'multiline':False]
['text':' Compare all lanes to zero.','line_number':3992,'multiline':False]
['text':' Forward loading to wasmLoad, and use replaceLane after that.','line_number':4051,'multiline':False]
['text':' replaceLane takes an lhsDest argument.','line_number':4056,'multiline':False]
['text':' Forward storing to wasmStore for the result of extractLane.','line_number':4093,'multiline':False]
