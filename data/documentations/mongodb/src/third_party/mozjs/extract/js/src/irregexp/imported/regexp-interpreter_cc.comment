['text':' Copyright 2011 the V8 project authors. All rights reserved.','line_number':1,'multiline':False]
['text':' Use of this source code is governed by a BSD-style license that can be','line_number':2,'multiline':False]
['text':' found in the LICENSE file.','line_number':3,'multiline':False]
['text':' A simple interpreter for the Irregexp byte code.','line_number':5,'multiline':False]
['text':' For kMaximumStackSize.','line_number':11,'multiline':False]
['text':' V8_INTL_SUPPORT','line_number':16,'multiline':False]
['text':' Use token threaded dispatch iff the compiler supports computed gotos and the','line_number':18,'multiline':False]
['text':' build argument v8_enable_regexp_interpreter_threaded_dispatch was set.','line_number':19,'multiline':False]
['text':' V8_HAS_COMPUTED_GOTO','line_number':23,'multiline':False]
['text':' For Latin1 characters the unicode flag makes no difference.','line_number':48,'multiline':False]
['text':' Convert both characters to lower case.','line_number':53,'multiline':False]
['text':' Not letters in the ASCII range and Latin-1 range.','line_number':57,'multiline':False]
['text':' DEBUG','line_number':83,'multiline':False]
['text':' TODO(jgruber): Rename to Load16AlignedUnsigned.','line_number':90,'multiline':False]
['text':' Helpers to access the packed argument. Takes the 32 bits containing the','line_number':101,'multiline':False]
['text':' current bytecode, where the 8 LSB contain the bytecode and the rest contains','line_number':102,'multiline':False]
['text':' a packed 24-bit argument.','line_number':103,'multiline':False]
['text':' TODO(jgruber): Specify signed-ness in bytecode signature declarations, and','line_number':104,'multiline':False]
['text':' police restrictions during bytecode generation.','line_number':105,'multiline':False]
['text':' A simple abstraction over the backtracking stack used by the interpreter.','line_number':113,'multiline':False]
['text':'','line_number':114,'multiline':False]
['text':' Despite the name 'backtracking' stack, it's actually used as a generic stack','line_number':115,'multiline':False]
['text':' that stores both program counters (= offsets into the bytecode) and generic','line_number':116,'multiline':False]
['text':' integer values.','line_number':117,'multiline':False]
['text':' The 'sp' is the index of the first empty element in the stack.','line_number':138,'multiline':False]
['text':' Semi-arbitrary. Should be large enough for common cases to remain in the','line_number':146,'multiline':False]
['text':' static stack-allocated backing store, but small enough not to waste space.','line_number':147,'multiline':False]
['text':' Registers used during interpreter execution. These consist of output','line_number':157,'multiline':False]
['text':' registers in indices [0, output_register_count[ which will contain matcher','line_number':158,'multiline':False]
['text':' results as a {start,end} index tuple for each capture (where the whole match','line_number':159,'multiline':False]
['text':' counts as implicit capture 0); and internal registers in indices','line_number':160,'multiline':False]
['text':' [output_register_count, total_register_count[.','line_number':161,'multiline':False]
['text':' TODO(jgruber): Use int32_t consistently for registers. Currently, CSA','line_number':171,'multiline':False]
['text':' uses int32_t while runtime uses int.','line_number':172,'multiline':False]
['text':' At least 2 for the match itself.','line_number':174,'multiline':False]
['text':' Initialize the output register region to -1 signifying 'no match'.','line_number':179,'multiline':False]
['text':' Arbitrary.','line_number':193,'multiline':False]
['text':' We abort interpreter execution after the stack overflow is thrown, and thus','line_number':202,'multiline':False]
['text':' allow allocation here despite the outer DisallowGarbageCollectionScope.','line_number':203,'multiline':False]
['text':' Only throws if called from the runtime, otherwise just returns the EXCEPTION','line_number':209,'multiline':False]
['text':' status code.','line_number':210,'multiline':False]
['text':' Runs all pending interrupts and updates unhandlified object references if','line_number':241,'multiline':False]
['text':' necessary.','line_number':242,'multiline':False]
['text':' Direct calls from JavaScript can be interrupted in two ways:','line_number':254,'multiline':False]
['text':' 1. A real stack overflow, in which case we let the caller throw the','line_number':255,'multiline':False]
['text':'    exception.','line_number':256,'multiline':False]
['text':' 2. The stack guard was used to interrupt execution for another purpose,','line_number':257,'multiline':False]
['text':'    forcing the call through the runtime system.','line_number':258,'multiline':False]
['text':' Prepare for possible GC.','line_number':266,'multiline':False]
['text':' If we changed between a LATIN1 and a UC16 string, we need to restart','line_number':285,'multiline':False]
['text':' regexp matching with the appropriate template instantiation of','line_number':286,'multiline':False]
['text':' RawMatch.','line_number':287,'multiline':False]
['text':' Returns true iff 0 <= index < length.','line_number':309,'multiline':False]
['text':' If computed gotos are supported by the compiler, we can get addresses to','line_number':315,'multiline':False]
['text':' labels directly in C/C++. Every bytecode handler has its own label and we','line_number':316,'multiline':False]
['text':' store the addresses in a dispatch table indexed by bytecode. To execute the','line_number':317,'multiline':False]
['text':' next handler we simply jump (goto) directly to its address.','line_number':318,'multiline':False]
['text':' Without computed goto support, we fall back to a simple switch-based','line_number':330,'multiline':False]
['text':' dispatch (A large switch statement inside a loop with a case for every','line_number':331,'multiline':False]
['text':' bytecode).','line_number':332,'multiline':False]
['text':' V8_USE_COMPUTED_GOTO','line_number':333,'multiline':False]
['text':' V8_USE_COMPUTED_GOTO','line_number':340,'multiline':False]
['text':' ADVANCE/SET_PC_FROM_OFFSET are separated from DISPATCH, because ideally some','line_number':342,'multiline':False]
['text':' instructions can be executed between ADVANCE/SET_PC_FROM_OFFSET and DISPATCH.','line_number':343,'multiline':False]
['text':' We want those two macros as far apart as possible, because the goto in','line_number':344,'multiline':False]
['text':' DISPATCH is dependent on a memory load in ADVANCE/SET_PC_FROM_OFFSET. If we','line_number':345,'multiline':False]
['text':' don't hit the cache and have to fetch the next handler address from physical','line_number':346,'multiline':False]
['text':' memory, instructions between ADVANCE/SET_PC_FROM_OFFSET and DISPATCH can','line_number':347,'multiline':False]
['text':' potentially be executed unconditionally, reducing memory stall.','line_number':348,'multiline':False]
['text':' Current position mutations.','line_number':356,'multiline':False]
['text':' DEBUG','line_number':371,'multiline':False]
['text':' We have to make sure that no OOB access to the dispatch table is possible and','line_number':384,'multiline':False]
['text':' all values are valid label addresses.','line_number':385,'multiline':False]
['text':' Otherwise jumps to arbitrary addresses could potentially happen.','line_number':386,'multiline':False]
['text':' This is ensured as follows:','line_number':387,'multiline':False]
['text':' Every index to the dispatch table gets masked using BYTECODE_MASK in','line_number':388,'multiline':False]
['text':' DECODE(). This way we can only get values between 0 (only the least','line_number':389,'multiline':False]
['text':' significant byte of an integer is used) and kRegExpPaddedBytecodeCount - 1','line_number':390,'multiline':False]
['text':' (BYTECODE_MASK is defined to be exactly this value).','line_number':391,'multiline':False]
['text':' All entries from kRegExpBytecodeCount to kRegExpPaddedBytecodeCount have to','line_number':392,'multiline':False]
['text':' be filled with BREAKs (invalid operation).','line_number':393,'multiline':False]
['text':' Fill dispatch table from last defined bytecode up to the next power of two','line_number':395,'multiline':False]
['text':' with BREAK (invalid operation).','line_number':396,'multiline':False]
['text':' TODO(pthier): Find a way to fill up automatically (at compile time)','line_number':397,'multiline':False]
['text':' 59 real bytecodes -> 5 fillers','line_number':398,'multiline':False]
['text':' 1 ','line_number':400,'multiline':True]
['text':' 2 ','line_number':401,'multiline':True]
['text':' 3 ','line_number':402,'multiline':True]
['text':' 4 ','line_number':403,'multiline':True]
['text':' 5 ','line_number':404,'multiline':True]
['text':' Make sure kRegExpPaddedBytecodeCount is actually the closest possible power','line_number':411,'multiline':False]
['text':' of two.','line_number':412,'multiline':False]
['text':' Make sure every bytecode we get by using BYTECODE_MASK is well defined.','line_number':416,'multiline':False]
['text':' V8_USE_COMPUTED_GOTO','line_number':428,'multiline':False]
['text':' V8_USE_COMPUTED_GOTO','line_number':456,'multiline':False]
['text':' The two if-statements below are split up intentionally, as combining','line_number':1003,'multiline':False]
['text':' them seems to result in register allocation behaving quite','line_number':1004,'multiline':False]
['text':' differently and slowing down the resulting code.','line_number':1005,'multiline':False]
['text':' Lint gets confused a lot if we just use !V8_USE_COMPUTED_GOTO or ifndef','line_number':1020,'multiline':False]
['text':' V8_USE_COMPUTED_GOTO here.','line_number':1021,'multiline':False]
['text':' Label we jump to in DISPATCH(). There must be no instructions between the','line_number':1026,'multiline':False]
['text':' end of the switch, this label and the end of the loop.','line_number':1027,'multiline':False]
['text':' V8_USE_COMPUTED_GOTO','line_number':1029,'multiline':False]
['text':' namespace','line_number':1043,'multiline':False]
['text':' static','line_number':1045,'multiline':False]
['text':' Note: Heap allocation *is* allowed in two situations if calling from','line_number':1068,'multiline':False]
['text':' Runtime:','line_number':1069,'multiline':False]
['text':' 1. When creating & throwing a stack overflow exception. The interpreter','line_number':1070,'multiline':False]
['text':'    aborts afterwards, and thus possible-moved objects are never used.','line_number':1071,'multiline':False]
['text':' 2. When handling interrupts. We manually relocate unhandlified references','line_number':1072,'multiline':False]
['text':'    after interrupts have run.','line_number':1073,'multiline':False]
['text':' This method is called through an external reference from RegExpExecInternal','line_number':1098,'multiline':False]
['text':' builtin.','line_number':1099,'multiline':False]
['text':' Returning RETRY will re-enter through runtime, where actual recompilation','line_number':1117,'multiline':False]
['text':' for tier-up takes place.','line_number':1118,'multiline':False]
['text':' !COMPILING_IRREGEXP_FOR_EXTERNAL_EMBEDDER','line_number':1126,'multiline':False]
['text':' namespace internal','line_number':1136,'multiline':False]
['text':' namespace v8','line_number':1137,'multiline':False]
