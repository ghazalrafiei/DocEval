['text':' Copyright 2015, VIXL authors','line_number':1,'multiline':False]
['text':' All rights reserved.','line_number':2,'multiline':False]
['text':'','line_number':3,'multiline':False]
['text':' Redistribution and use in source and binary forms, with or without','line_number':4,'multiline':False]
['text':' modification, are permitted provided that the following conditions are met:','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':'   * Redistributions of source code must retain the above copyright notice,','line_number':7,'multiline':False]
['text':'     this list of conditions and the following disclaimer.','line_number':8,'multiline':False]
['text':'   * Redistributions in binary form must reproduce the above copyright notice,','line_number':9,'multiline':False]
['text':'     this list of conditions and the following disclaimer in the documentation','line_number':10,'multiline':False]
['text':'     and/or other materials provided with the distribution.','line_number':11,'multiline':False]
['text':'   * Neither the name of ARM Limited nor the names of its contributors may be','line_number':12,'multiline':False]
['text':'     used to endorse or promote products derived from this software without','line_number':13,'multiline':False]
['text':'     specific prior written permission.','line_number':14,'multiline':False]
['text':'','line_number':15,'multiline':False]
['text':' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS CONTRIBUTORS "AS IS" AND','line_number':16,'multiline':False]
['text':' ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED','line_number':17,'multiline':False]
['text':' WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE','line_number':18,'multiline':False]
['text':' DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE','line_number':19,'multiline':False]
['text':' FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL','line_number':20,'multiline':False]
['text':' DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR','line_number':21,'multiline':False]
['text':' SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER','line_number':22,'multiline':False]
['text':' CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,','line_number':23,'multiline':False]
['text':' OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE','line_number':24,'multiline':False]
['text':' OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.','line_number':25,'multiline':False]
['text':' Macros for compile-time format checking.','line_number':42,'multiline':False]
['text':' Check number width.','line_number':76,'multiline':False]
['text':' TODO: Refactor these using templates.','line_number':77,'multiline':False]
['text':' Convert to an unsigned integer to avoid implementation-defined behavior.','line_number':108,'multiline':False]
['text':' Convert to an unsigned integer to avoid implementation-defined behavior.','line_number':117,'multiline':False]
['text':' clang-format off','line_number':133,'multiline':False]
['text':' clang-format on','line_number':148,'multiline':False]
['text':' Bit field extraction.','line_number':179,'multiline':False]
['text':' If the highest extracted bit is set, sign extend.','line_number':199,'multiline':False]
['text':' Wrapper class for passing FP16 values through the assembler.','line_number':233,'multiline':False]
['text':' This is purely to aid with type checking/casting.','line_number':234,'multiline':False]
['text':' Floating point representation.','line_number':246,'multiline':False]
['text':' Internal simulation class used solely by the simulator to','line_number':278,'multiline':False]
['text':' provide an abstraction layer for any half-precision arithmetic.','line_number':279,'multiline':False]
['text':' TODO: We should investigate making this constructor explicit.','line_number':282,'multiline':False]
['text':' This is currently difficult to do due to a number of templated','line_number':283,'multiline':False]
['text':' functions in the simulator which rely on returning double values.','line_number':284,'multiline':False]
['text':' NOLINT(runtime/explicit)','line_number':285,'multiline':False]
['text':' NOLINT(runtime/explicit)','line_number':286,'multiline':False]
['text':' This is necessary for conversions peformed in (macro asm) Fmov.','line_number':299,'multiline':False]
['text':' namespace internal','line_number':303,'multiline':False]
['text':' An fpclassify() function for 16-bit half-precision floats.','line_number':362,'multiline':False]
['text':' NaN tests.','line_number':385,'multiline':False]
['text':' Convert the NaN in 'num' to a quiet NaN.','line_number':418,'multiline':False]
['text':' Fused multiply-add.','line_number':441,'multiline':False]
['text':' Split the 64-bit value into an 8-bit array, where b[0] is the least','line_number':503,'multiline':False]
['text':' significant byte, and b[7] is the most significant.','line_number':504,'multiline':False]
['text':' Permutation tables for REV instructions.','line_number':512,'multiline':False]
['text':'  permute_table[0] is used by REV16_x, REV16_w','line_number':513,'multiline':False]
['text':'  permute_table[1] is used by REV32_x, REV_w','line_number':514,'multiline':False]
['text':'  permute_table[2] is used by REV_x','line_number':515,'multiline':False]
['text':' Pointer alignment','line_number':550,'multiline':False]
['text':' TODO: rename/refactor to make it specific to instructions.','line_number':551,'multiline':False]
['text':' NOLINT(runtime/sizeof)','line_number':554,'multiline':False]
['text':' Use C-style casts to get static_cast behaviour for integral types (T), and','line_number':555,'multiline':False]
['text':' reinterpret_cast behaviour for other types.','line_number':556,'multiline':False]
['text':' Increment a pointer until it has the specified alignment. The alignment must','line_number':565,'multiline':False]
['text':' be a power of two.','line_number':566,'multiline':False]
['text':' Use C-style casts to get static_cast behaviour for integral types (T), and','line_number':571,'multiline':False]
['text':' reinterpret_cast behaviour for other types.','line_number':572,'multiline':False]
['text':' Decrement a pointer until it has the specified alignment. The alignment must','line_number':585,'multiline':False]
['text':' be a power of two.','line_number':586,'multiline':False]
['text':' Use C-style casts to get static_cast behaviour for integral types (T), and','line_number':591,'multiline':False]
['text':' reinterpret_cast behaviour for other types.','line_number':592,'multiline':False]
['text':' NOLINT(runtime/references)','line_number':614,'multiline':False]
['text':' NOLINT(runtime/references)','line_number':626,'multiline':False]
['text':' bits: aBbb.bbbc.defg.h000.0000.0000.0000.0000','line_number':642,'multiline':False]
['text':' bit7: a000.0000','line_number':644,'multiline':False]
['text':' bit6: 0b00.0000','line_number':646,'multiline':False]
['text':' bit5_to_0: 00cd.efgh','line_number':648,'multiline':False]
['text':' bits: aBbb.bbbb.bbcd.efgh.0000.0000.0000.0000','line_number':653,'multiline':False]
['text':'       0000.0000.0000.0000.0000.0000.0000.0000','line_number':654,'multiline':False]
['text':' bit7: a000.0000','line_number':656,'multiline':False]
['text':' bit6: 0b00.0000','line_number':658,'multiline':False]
['text':' bit5_to_0: 00cd.efgh','line_number':660,'multiline':False]
['text':'   Imm8: abcdefgh (8 bits)','line_number':666,'multiline':False]
['text':' Single: aBbb.bbbc.defg.h000.0000.0000.0000.0000 (32 bits)','line_number':667,'multiline':False]
['text':' where B is b ^ 1','line_number':668,'multiline':False]
['text':'   Imm8: abcdefgh (8 bits)','line_number':678,'multiline':False]
['text':' Double: aBbb.bbbb.bbcd.efgh.0000.0000.0000.0000','line_number':679,'multiline':False]
['text':'         0000.0000.0000.0000.0000.0000.0000.0000 (64 bits)','line_number':680,'multiline':False]
['text':' where B is b ^ 1','line_number':681,'multiline':False]
['text':' Valid values will have the form:','line_number':690,'multiline':False]
['text':' aBbb.bbbc.defg.h000.0000.0000.0000.0000','line_number':691,'multiline':False]
['text':' bits[19..0] are cleared.','line_number':693,'multiline':False]
['text':' bits[29..25] are all set or all cleared.','line_number':699,'multiline':False]
['text':' bit[30] and bit[29] are opposite.','line_number':704,'multiline':False]
['text':' Valid values will have the form:','line_number':711,'multiline':False]
['text':' aBbb.bbbb.bbcd.efgh.0000.0000.0000.0000','line_number':712,'multiline':False]
['text':' 0000.0000.0000.0000.0000.0000.0000.0000','line_number':713,'multiline':False]
['text':' bits[47..0] are cleared.','line_number':715,'multiline':False]
['text':' bits[61..54] are all set or all cleared.','line_number':719,'multiline':False]
['text':' bit[62] and bit[61] are opposite.','line_number':724,'multiline':False]
['text':' ForEachBitHelper is a functor that will call','line_number':733,'multiline':False]
['text':' bool ForEachBitHelper::execute(ElementType id) const','line_number':734,'multiline':False]
['text':'   and expects a boolean in return whether to continue (if true)','line_number':735,'multiline':False]
['text':'   or stop (if false)','line_number':736,'multiline':False]
['text':' check_set will check if the bits are on (true) or off(false)','line_number':737,'multiline':False]
['text':' For each bit not set in the bitfield call the execute functor','line_number':762,'multiline':False]
['text':' execute.','line_number':763,'multiline':False]
['text':' ForEachBitSetHelper::execute returns true if the iteration through','line_number':764,'multiline':False]
['text':' the bits can continue, otherwise it will stop.','line_number':765,'multiline':False]
['text':' struct ForEachBitSetHelper {','line_number':766,'multiline':False]
['text':'   bool execute(int /*id*/) { return false; }','line_number':767,'multiline':False]
['text':' };','line_number':768,'multiline':False]
['text':' For each bit set in the bitfield call the execute functor','line_number':774,'multiline':False]
['text':' execute.','line_number':775,'multiline':False]
['text':' Unlike uint32_t, Uint32 has a default constructor.','line_number':795,'multiline':False]
['text':' Unlike uint32_t, the shift functions can accept negative shift and','line_number':827,'multiline':False]
['text':' return 0 when the shift is too big.','line_number':828,'multiline':False]
['text':' Unlike uint64_t, Uint64 has a default constructor.','line_number':857,'multiline':False]
['text':' Unlike uint64_t, the shift functions can accept negative shift and','line_number':894,'multiline':False]
['text':' return 0 when the shift is too big.','line_number':895,'multiline':False]
['text':' namespace internal','line_number':979,'multiline':False]
['text':' The default NaN values (for FPCR.DN=1).','line_number':981,'multiline':False]
['text':' Floating-point infinity values.','line_number':986,'multiline':False]
['text':' Floating-point zero values.','line_number':994,'multiline':False]
['text':' AArch64 floating-point specifics. These match IEEE-754.','line_number':998,'multiline':False]
['text':' The first four values are encodable directly by FPCR<RMode>.','line_number':1007,'multiline':False]
['text':' The final rounding modes are only available when explicitly specified by','line_number':1013,'multiline':False]
['text':' the instruction (such as with fcvta). It cannot be set in FPCR.','line_number':1014,'multiline':False]
['text':' Assemble the specified IEEE-754 components into the target type and apply','line_number':1021,'multiline':False]
['text':' appropriate rounding.','line_number':1022,'multiline':False]
['text':'  sign:     0 = positive, 1 = negative','line_number':1023,'multiline':False]
['text':'  exponent: Unbiased IEEE-754 exponent.','line_number':1024,'multiline':False]
['text':'  mantissa: The mantissa of the input. The top bit (which is not encoded for','line_number':1025,'multiline':False]
['text':'            normal IEEE-754 values) must not be omitted. This bit has the','line_number':1026,'multiline':False]
['text':'            value 'pow(2, exponent)'.','line_number':1027,'multiline':False]
['text':'','line_number':1028,'multiline':False]
['text':' The input value is assumed to be a normalized value. That is, the input may','line_number':1029,'multiline':False]
['text':' not be infinity or NaN. If the source value is subnormal, it must be','line_number':1030,'multiline':False]
['text':' normalized before calling this function such that the highest set bit in the','line_number':1031,'multiline':False]
['text':' mantissa has the value 'pow(2, exponent)'.','line_number':1032,'multiline':False]
['text':'','line_number':1033,'multiline':False]
['text':' Callers should use FPRoundToFloat or FPRoundToDouble directly, rather than','line_number':1034,'multiline':False]
['text':' calling a templated FPRound.','line_number':1035,'multiline':False]
['text':' Only FPTieEven and FPRoundOdd rounding modes are implemented.','line_number':1043,'multiline':False]
['text':' Rounding can promote subnormals to normals, and normals to infinities. For','line_number':1046,'multiline':False]
['text':' example, a double with exponent 127 (FLT_MAX_EXP) would appear to be','line_number':1047,'multiline':False]
['text':' encodable as a float, but rounding based on the low-order mantissa bits','line_number':1048,'multiline':False]
['text':' could make it overflow. With ties-to-even rounding, this value would become','line_number':1049,'multiline':False]
['text':' an infinity.','line_number':1050,'multiline':False]
['text':' ---- Rounding Method ----','line_number':1052,'multiline':False]
['text':'','line_number':1053,'multiline':False]
['text':' The exponent is irrelevant in the rounding operation, so we treat the','line_number':1054,'multiline':False]
['text':' lowest-order bit that will fit into the result ('onebit') as having','line_number':1055,'multiline':False]
['text':' the value '1'. Similarly, the highest-order bit that won't fit into','line_number':1056,'multiline':False]
['text':' the result ('halfbit') has the value '0.5'. The 'point' sits between','line_number':1057,'multiline':False]
['text':' 'onebit' and 'halfbit':','line_number':1058,'multiline':False]
['text':'','line_number':1059,'multiline':False]
['text':'            These bits fit into the result.','line_number':1060,'multiline':False]
['text':'               |---------------------|','line_number':1061,'multiline':False]
['text':'  mantissa = 0bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx','line_number':1062,'multiline':False]
['text':'                                     ||','line_number':1063,'multiline':False]
['text':'                                    / |','line_number':1064,'multiline':False]
['text':'                                   /  halfbit','line_number':1065,'multiline':False]
['text':'                               onebit','line_number':1066,'multiline':False]
['text':'','line_number':1067,'multiline':False]
['text':' For subnormal outputs, the range of representable bits is smaller and','line_number':1068,'multiline':False]
['text':' the position of onebit and halfbit depends on the exponent of the','line_number':1069,'multiline':False]
['text':' input, but the method is otherwise similar.','line_number':1070,'multiline':False]
['text':'','line_number':1071,'multiline':False]
['text':'   onebit(frac)','line_number':1072,'multiline':False]
['text':'     |','line_number':1073,'multiline':False]
['text':'     | halfbit(frac)          halfbit(adjusted)','line_number':1074,'multiline':False]
['text':'     | /                      /','line_number':1075,'multiline':False]
['text':'     | |                      |','line_number':1076,'multiline':False]
['text':'  0b00.0 (exact)      -> 0b00.0 (exact)                    -> 0b00','line_number':1077,'multiline':False]
['text':'  0b00.0...           -> 0b00.0...                         -> 0b00','line_number':1078,'multiline':False]
['text':'  0b00.1 (exact)      -> 0b00.0111..111                    -> 0b00','line_number':1079,'multiline':False]
['text':'  0b00.1...           -> 0b00.1...                         -> 0b01','line_number':1080,'multiline':False]
['text':'  0b01.0 (exact)      -> 0b01.0 (exact)                    -> 0b01','line_number':1081,'multiline':False]
['text':'  0b01.0...           -> 0b01.0...                         -> 0b01','line_number':1082,'multiline':False]
['text':'  0b01.1 (exact)      -> 0b01.1 (exact)                    -> 0b10','line_number':1083,'multiline':False]
['text':'  0b01.1...           -> 0b01.1...                         -> 0b10','line_number':1084,'multiline':False]
['text':'  0b10.0 (exact)      -> 0b10.0 (exact)                    -> 0b10','line_number':1085,'multiline':False]
['text':'  0b10.0...           -> 0b10.0...                         -> 0b10','line_number':1086,'multiline':False]
['text':'  0b10.1 (exact)      -> 0b10.0111..111                    -> 0b10','line_number':1087,'multiline':False]
['text':'  0b10.1...           -> 0b10.1...                         -> 0b11','line_number':1088,'multiline':False]
['text':'  0b11.0 (exact)      -> 0b11.0 (exact)                    -> 0b11','line_number':1089,'multiline':False]
['text':'  ...                   /             |                      /   |','line_number':1090,'multiline':False]
['text':'                       /              |                     /    |','line_number':1091,'multiline':False]
['text':'                                                           /     |','line_number':1092,'multiline':False]
['text':' adjusted = frac - (halfbit(mantissa) & ~onebit(frac));   /      |','line_number':1093,'multiline':False]
['text':'','line_number':1094,'multiline':False]
['text':'                   mantissa = (mantissa >> shift) + halfbit(adjusted);','line_number':1095,'multiline':False]
['text':' Bail out early for zero inputs.','line_number':1102,'multiline':False]
['text':' If all bits in the exponent are set, the value is infinite or NaN.','line_number':1107,'multiline':False]
['text':' This is true for all binary IEEE-754 formats.','line_number':1108,'multiline':False]
['text':' Apply the exponent bias to encode it for the result. Doing this early makes','line_number':1112,'multiline':False]
['text':' it easy to detect values that will be infinite or subnormal.','line_number':1113,'multiline':False]
['text':' Overflow: the input is too large for the result type to represent.','line_number':1117,'multiline':False]
['text':' FPTieEven rounding mode handles overflows using infinities.','line_number':1119,'multiline':False]
['text':' FPRoundOdd rounding mode handles overflows using the largest magnitude','line_number':1124,'multiline':False]
['text':' normal number.','line_number':1125,'multiline':False]
['text':' Calculate the shift required to move the top mantissa bit to the proper','line_number':1134,'multiline':False]
['text':' place in the destination type.','line_number':1135,'multiline':False]
['text':' The output will be subnormal (before rounding).','line_number':1140,'multiline':False]
['text':' For subnormal outputs, the shift must be adjusted by the exponent. The +1','line_number':1141,'multiline':False]
['text':' is necessary because the exponent of a subnormal value (encoded as 0) is','line_number':1142,'multiline':False]
['text':' the same as the exponent of the smallest normal value (encoded as 1).','line_number':1143,'multiline':False]
['text':' Handle inputs that would produce a zero output.','line_number':1146,'multiline':False]
['text':'','line_number':1147,'multiline':False]
['text':' Shifts higher than highest_significant_bit+1 will always produce a zero','line_number':1148,'multiline':False]
['text':' result. A shift of exactly highest_significant_bit+1 might produce a','line_number':1149,'multiline':False]
['text':' non-zero result after rounding.','line_number':1150,'multiline':False]
['text':' The result will always be +/-0.0.','line_number':1153,'multiline':False]
['text':' For FPRoundOdd, if the mantissa is too small to represent and','line_number':1158,'multiline':False]
['text':' non-zero return the next "odd" value.','line_number':1159,'multiline':False]
['text':' Properly encode the exponent for a subnormal output.','line_number':1164,'multiline':False]
['text':' Clear the topmost mantissa bit, since this is not encoded in IEEE-754','line_number':1167,'multiline':False]
['text':' normal values.','line_number':1168,'multiline':False]
['text':' The casts below are only well-defined for unsigned integers.','line_number':1172,'multiline':False]
['text':' We have to shift the mantissa to the right. Some precision is lost, so','line_number':1178,'multiline':False]
['text':' we need to apply rounding.','line_number':1179,'multiline':False]
['text':' A very large mantissa can overflow during rounding. If this happens,','line_number':1190,'multiline':False]
['text':' the exponent should be incremented and the mantissa set to 1.0','line_number':1191,'multiline':False]
['text':' (encoded as 0). Applying halfbit_adjusted after assembling the float','line_number':1192,'multiline':False]
['text':' has the nice side-effect that this case is handled for free.','line_number':1193,'multiline':False]
['text':'','line_number':1194,'multiline':False]
['text':' This also handles cases where a very large finite value overflows to','line_number':1195,'multiline':False]
['text':' infinity, or where a very large subnormal value overflows to become','line_number':1196,'multiline':False]
['text':' normal.','line_number':1197,'multiline':False]
['text':' If any bits at position halfbit or below are set, onebit (ie. the','line_number':1201,'multiline':False]
['text':' bottom bit of the resulting mantissa) must be set.','line_number':1202,'multiline':False]
['text':' We have to shift the mantissa to the left (or not at all). The input','line_number':1213,'multiline':False]
['text':' mantissa is exactly representable in the output mantissa, so apply no','line_number':1214,'multiline':False]
['text':' rounding correction.','line_number':1215,'multiline':False]
['text':' See FPRound for a description of this function.','line_number':1223,'multiline':False]
['text':' See FPRound for a description of this function.','line_number':1237,'multiline':False]
['text':' See FPRound for a description of this function.','line_number':1249,'multiline':False]
['text':' namespace vixl','line_number':1281,'multiline':False]
['text':' VIXL_UTILS_H','line_number':1283,'multiline':False]
