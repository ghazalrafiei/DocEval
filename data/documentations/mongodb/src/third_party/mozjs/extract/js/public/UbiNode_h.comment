['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' [SMDOC] ubi::Node (Heap Analysis framework)','line_number':33,'multiline':False]
['text':'','line_number':34,'multiline':False]
['text':' JS::ubi::Node is a pointer-like type designed for internal use by heap','line_number':35,'multiline':False]
['text':' analysis tools. A ubi::Node can refer to:','line_number':36,'multiline':False]
['text':'','line_number':37,'multiline':False]
['text':' - a JS value, like a string, object, or symbol;','line_number':38,'multiline':False]
['text':' - an internal SpiderMonkey structure, like a shape or a scope chain object','line_number':39,'multiline':False]
['text':' - an instance of some embedding-provided type: in Firefox, an XPCOM','line_number':40,'multiline':False]
['text':'   object, or an internal DOM node class instance','line_number':41,'multiline':False]
['text':'','line_number':42,'multiline':False]
['text':' A ubi::Node instance provides metadata about its referent, and can','line_number':43,'multiline':False]
['text':' enumerate its referent's outgoing edges, so you can implement heap analysis','line_number':44,'multiline':False]
['text':' algorithms that walk the graph - finding paths between objects, or','line_number':45,'multiline':False]
['text':' computing heap dominator trees, say - using ubi::Node, while remaining','line_number':46,'multiline':False]
['text':' ignorant of the details of the types you're operating on.','line_number':47,'multiline':False]
['text':'','line_number':48,'multiline':False]
['text':' Of course, when it comes to presenting the results in a developer-facing','line_number':49,'multiline':False]
['text':' tool, you'll need to stop being ignorant of those details, because you have','line_number':50,'multiline':False]
['text':' to discuss the ubi::Nodes' referents with the developer. Here, ubi::Node','line_number':51,'multiline':False]
['text':' can hand you dynamically checked, properly typed pointers to the original','line_number':52,'multiline':False]
['text':' objects via the as<T> method, or generate descriptions of the referent','line_number':53,'multiline':False]
['text':' itself.','line_number':54,'multiline':False]
['text':'','line_number':55,'multiline':False]
['text':' ubi::Node instances are lightweight (two-word) value types. Instances:','line_number':56,'multiline':False]
['text':' - compare equal if and only if they refer to the same object;','line_number':57,'multiline':False]
['text':' - have hash values that respect their equality relation; and','line_number':58,'multiline':False]
['text':' - have serializations that are only equal if the ubi::Nodes are equal.','line_number':59,'multiline':False]
['text':'','line_number':60,'multiline':False]
['text':' A ubi::Node is only valid for as long as its referent is alive; if its','line_number':61,'multiline':False]
['text':' referent goes away, the ubi::Node becomes a dangling pointer. A ubi::Node','line_number':62,'multiline':False]
['text':' that refers to a GC-managed object is not automatically a GC root; if the','line_number':63,'multiline':False]
['text':' GC frees or relocates its referent, the ubi::Node becomes invalid. A','line_number':64,'multiline':False]
['text':' ubi::Node that refers to a reference-counted object does not bump the','line_number':65,'multiline':False]
['text':' reference count.','line_number':66,'multiline':False]
['text':'','line_number':67,'multiline':False]
['text':' ubi::Node values require no supporting data structures, making them','line_number':68,'multiline':False]
['text':' feasible for use in memory-constrained devices --- ideally, the memory','line_number':69,'multiline':False]
['text':' requirements of the algorithm which uses them will be the limiting factor,','line_number':70,'multiline':False]
['text':' not the demands of ubi::Node itself.','line_number':71,'multiline':False]
['text':'','line_number':72,'multiline':False]
['text':' One can construct a ubi::Node value given a pointer to a type that ubi::Node','line_number':73,'multiline':False]
['text':' supports. In the other direction, one can convert a ubi::Node back to a','line_number':74,'multiline':False]
['text':' pointer; these downcasts are checked dynamically. In particular, one can','line_number':75,'multiline':False]
['text':' convert a 'JSContext*' to a ubi::Node, yielding a node with an outgoing edge','line_number':76,'multiline':False]
['text':' for every root registered with the runtime; starting from this, one can walk','line_number':77,'multiline':False]
['text':' the entire heap. (Of course, one could also start traversal at any other kind','line_number':78,'multiline':False]
['text':' of type to which one has a pointer.)','line_number':79,'multiline':False]
['text':'','line_number':80,'multiline':False]
['text':'','line_number':81,'multiline':False]
['text':' Extending ubi::Node To Handle Your Embedding's Types','line_number':82,'multiline':False]
['text':'','line_number':83,'multiline':False]
['text':' To add support for a new ubi::Node referent type R, you must define a','line_number':84,'multiline':False]
['text':' specialization of the ubi::Concrete template, ubi::Concrete<R>, which','line_number':85,'multiline':False]
['text':' inherits from ubi::Base. ubi::Node itself uses the specialization for','line_number':86,'multiline':False]
['text':' compile-time information (i.e. the checked conversions between R * and','line_number':87,'multiline':False]
['text':' ubi::Node), and the inheritance for run-time dispatching.','line_number':88,'multiline':False]
['text':'','line_number':89,'multiline':False]
['text':'','line_number':90,'multiline':False]
['text':' ubi::Node Exposes Implementation Details','line_number':91,'multiline':False]
['text':'','line_number':92,'multiline':False]
['text':' In many cases, a JavaScript developer's view of their data differs','line_number':93,'multiline':False]
['text':' substantially from its actual implementation. For example, while the','line_number':94,'multiline':False]
['text':' ECMAScript specification describes objects as maps from property names to','line_number':95,'multiline':False]
['text':' sets of attributes (like ECMAScript's [[Value]]), in practice many objects','line_number':96,'multiline':False]
['text':' have only a pointer to a shape, shared with other similar objects, and','line_number':97,'multiline':False]
['text':' indexed slots that contain the [[Value]] attributes. As another example, a','line_number':98,'multiline':False]
['text':' string produced by concatenating two other strings may sometimes be','line_number':99,'multiline':False]
['text':' represented by a "rope", a structure that points to the two original','line_number':100,'multiline':False]
['text':' strings.','line_number':101,'multiline':False]
['text':'','line_number':102,'multiline':False]
['text':' We intend to use ubi::Node to write tools that report memory usage, so it's','line_number':103,'multiline':False]
['text':' important that ubi::Node accurately portray how much memory nodes consume.','line_number':104,'multiline':False]
['text':' Thus, for example, when data that apparently belongs to multiple nodes is','line_number':105,'multiline':False]
['text':' in fact shared in a common structure, ubi::Node's graph uses a separate','line_number':106,'multiline':False]
['text':' node for that shared structure, and presents edges to it from the data's','line_number':107,'multiline':False]
['text':' apparent owners. For example, ubi::Node exposes SpiderMonkey objects'','line_number':108,'multiline':False]
['text':' shapes and base shapes, and exposes rope string and substring structure,','line_number':109,'multiline':False]
['text':' because these optimizations become visible when a tool reports how much','line_number':110,'multiline':False]
['text':' memory a structure consumes.','line_number':111,'multiline':False]
['text':'','line_number':112,'multiline':False]
['text':' However, fine granularity is not a goal. When a particular object is the','line_number':113,'multiline':False]
['text':' exclusive owner of a separate block of memory, ubi::Node may present the','line_number':114,'multiline':False]
['text':' object and its block as a single node, and add their sizes together when','line_number':115,'multiline':False]
['text':' reporting the node's size, as there is no meaningful loss of data in this','line_number':116,'multiline':False]
['text':' case. Thus, for example, a ubi::Node referring to a JavaScript object, when','line_number':117,'multiline':False]
['text':' asked for the object's size in bytes, includes the object's slot and','line_number':118,'multiline':False]
['text':' element arrays' sizes in the total. There is no separate ubi::Node value','line_number':119,'multiline':False]
['text':' representing the slot and element arrays, since they are owned exclusively','line_number':120,'multiline':False]
['text':' by the object.','line_number':121,'multiline':False]
['text':'','line_number':122,'multiline':False]
['text':'','line_number':123,'multiline':False]
['text':' Presenting Analysis Results To JavaScript Developers','line_number':124,'multiline':False]
['text':'','line_number':125,'multiline':False]
['text':' If an analysis provides its results in terms of ubi::Node values, a user','line_number':126,'multiline':False]
['text':' interface presenting those results will generally need to clean them up','line_number':127,'multiline':False]
['text':' before they can be understood by JavaScript developers. For example,','line_number':128,'multiline':False]
['text':' JavaScript developers should not need to understand shapes, only JavaScript','line_number':129,'multiline':False]
['text':' objects. Similarly, they should not need to understand the distinction','line_number':130,'multiline':False]
['text':' between DOM nodes and the JavaScript shadow objects that represent them.','line_number':131,'multiline':False]
['text':'','line_number':132,'multiline':False]
['text':'','line_number':133,'multiline':False]
['text':' Rooting Restrictions','line_number':134,'multiline':False]
['text':'','line_number':135,'multiline':False]
['text':' At present there is no way to root ubi::Node instances, so instances can't be','line_number':136,'multiline':False]
['text':' live across any operation that might GC. Analyses using ubi::Node must either','line_number':137,'multiline':False]
['text':' run to completion and convert their results to some other rootable type, or','line_number':138,'multiline':False]
['text':' save their intermediate state in some rooted structure if they must GC before','line_number':139,'multiline':False]
['text':' they complete. (For algorithms like path-finding and dominator tree','line_number':140,'multiline':False]
['text':' computation, we implement the algorithm avoiding any operation that could','line_number':141,'multiline':False]
['text':' cause a GC --- and use AutoCheckCannotGC to verify this.)','line_number':142,'multiline':False]
['text':'','line_number':143,'multiline':False]
['text':' If this restriction prevents us from implementing interesting tools, we may','line_number':144,'multiline':False]
['text':' teach the GC how to root ubi::Nodes, fix up hash tables that use them as','line_number':145,'multiline':False]
['text':' keys, etc.','line_number':146,'multiline':False]
['text':'','line_number':147,'multiline':False]
['text':'','line_number':148,'multiline':False]
['text':' Hostile Graph Structure','line_number':149,'multiline':False]
['text':'','line_number':150,'multiline':False]
['text':' Analyses consuming ubi::Node graphs must be robust when presented with graphs','line_number':151,'multiline':False]
['text':' that are deliberately constructed to exploit their weaknesses. When operating','line_number':152,'multiline':False]
['text':' on live graphs, web content has control over the object graph, and less','line_number':153,'multiline':False]
['text':' direct control over shape and string structure, and analyses should be','line_number':154,'multiline':False]
['text':' prepared to handle extreme cases gracefully. For example, if an analysis were','line_number':155,'multiline':False]
['text':' to use the C++ stack in a depth-first traversal, carefully constructed','line_number':156,'multiline':False]
['text':' content could cause the analysis to overflow the stack.','line_number':157,'multiline':False]
['text':'','line_number':158,'multiline':False]
['text':' When ubi::Nodes refer to nodes deserialized from a heap snapshot, analyses','line_number':159,'multiline':False]
['text':' must be even more careful: since snapshots often come from potentially','line_number':160,'multiline':False]
['text':' compromised e10s content processes, even properties normally guaranteed by','line_number':161,'multiline':False]
['text':' the platform (the proper linking of DOM nodes, for example) might be','line_number':162,'multiline':False]
['text':' corrupted. While it is the deserializer's responsibility to check the basic','line_number':163,'multiline':False]
['text':' structure of the snapshot file, the analyses should be prepared for ubi::Node','line_number':164,'multiline':False]
['text':' graphs constructed from snapshots to be even more bizarre.','line_number':165,'multiline':False]
['text':' namespace js','line_number':169,'multiline':False]
['text':'** ubi::StackFrame *********************************************************','line_number':193,'multiline':True]
['text':' Concrete JS::ubi::StackFrame instances backed by a live SavedFrame object','line_number':195,'multiline':False]
['text':' store their strings as JSAtom*, while deserialized stack frames from offline','line_number':196,'multiline':False]
['text':' heap snapshots store their strings as const char16_t*. In order to provide','line_number':197,'multiline':False]
['text':' zero-cost accessors to these strings in a single interface that works with','line_number':198,'multiline':False]
['text':' both cases, we use this variant type.','line_number':199,'multiline':False]
['text':' Return the length of the given AtomOrTwoByteChars string.','line_number':216,'multiline':False]
['text':' Copy the given AtomOrTwoByteChars string into the destination buffer,','line_number':219,'multiline':False]
['text':' inflating if necessary. Does NOT null terminate. Returns the number of','line_number':220,'multiline':False]
['text':' characters written to destination.','line_number':221,'multiline':False]
['text':' The base class implemented by each ConcreteStackFrame<T> type. Subclasses','line_number':225,'multiline':False]
['text':' must not add data members to this class.','line_number':226,'multiline':False]
['text':' This is a value type that should not have a virtual destructor. Don't add','line_number':238,'multiline':False]
['text':' destructors in subclasses!','line_number':239,'multiline':False]
['text':' Get a unique identifier for this StackFrame. The identifier is not valid','line_number':241,'multiline':False]
['text':' across garbage collections.','line_number':242,'multiline':False]
['text':' Get this frame's parent frame.','line_number':245,'multiline':False]
['text':' Get this frame's line number.','line_number':248,'multiline':False]
['text':' Get this frame's column number.','line_number':251,'multiline':False]
['text':' Get this frame's source name. Never null.','line_number':254,'multiline':False]
['text':' Get a unique per-process ID for this frame's source. Defaults to zero.','line_number':257,'multiline':False]
['text':' Return this frame's function name if named, otherwise the inferred','line_number':260,'multiline':False]
['text':' display name. Can be null.','line_number':261,'multiline':False]
['text':' Returns true if this frame's function is system JavaScript running with','line_number':264,'multiline':False]
['text':' trusted principals, false otherwise.','line_number':265,'multiline':False]
['text':' Return true if this frame's function is a self-hosted JavaScript builtin,','line_number':268,'multiline':False]
['text':' false otherwise.','line_number':269,'multiline':False]
['text':' Construct a SavedFrame stack for the stack starting with this frame and','line_number':272,'multiline':False]
['text':' containing all of its parents. The SavedFrame objects will be placed into','line_number':273,'multiline':False]
['text':' cx's current compartment.','line_number':274,'multiline':False]
['text':'','line_number':275,'multiline':False]
['text':' Note that the process of','line_number':276,'multiline':False]
['text':'','line_number':277,'multiline':False]
['text':'     SavedFrame','line_number':278,'multiline':False]
['text':'         |','line_number':279,'multiline':False]
['text':'         V','line_number':280,'multiline':False]
['text':'     JS::ubi::StackFrame','line_number':281,'multiline':False]
['text':'         |','line_number':282,'multiline':False]
['text':'         V','line_number':283,'multiline':False]
['text':'     offline heap snapshot','line_number':284,'multiline':False]
['text':'         |','line_number':285,'multiline':False]
['text':'         V','line_number':286,'multiline':False]
['text':'     JS::ubi::StackFrame','line_number':287,'multiline':False]
['text':'         |','line_number':288,'multiline':False]
['text':'         V','line_number':289,'multiline':False]
['text':'     SavedFrame','line_number':290,'multiline':False]
['text':'','line_number':291,'multiline':False]
['text':' is lossy because we cannot serialize and deserialize the SavedFrame's','line_number':292,'multiline':False]
['text':' principals in the offline heap snapshot, so JS::ubi::StackFrame','line_number':293,'multiline':False]
['text':' simplifies the principals check into the boolean isSystem() state. This','line_number':294,'multiline':False]
['text':' is fine because we only expose JS::ubi::Stack to devtools and chrome','line_number':295,'multiline':False]
['text':' code, and not to the web platform.','line_number':296,'multiline':False]
['text':' Trace the concrete implementation of JS::ubi::StackFrame.','line_number':300,'multiline':False]
['text':' A traits template with a specialization for each backing type that implements','line_number':304,'multiline':False]
['text':' the ubi::BaseStackFrame interface. Each specialization must be the a subclass','line_number':305,'multiline':False]
['text':' of ubi::BaseStackFrame.','line_number':306,'multiline':False]
['text':' A JS::ubi::StackFrame represents a frame in a recorded stack. It can be','line_number':310,'multiline':False]
['text':' backed either by a live SavedFrame object or by a structure deserialized from','line_number':311,'multiline':False]
['text':' an offline heap snapshot.','line_number':312,'multiline':False]
['text':'','line_number':313,'multiline':False]
['text':' It is a value type that may be memcpy'd hither and thither without worrying','line_number':314,'multiline':False]
['text':' about constructors or destructors, similar to POD types.','line_number':315,'multiline':False]
['text':'','line_number':316,'multiline':False]
['text':' Its lifetime is the same as the lifetime of the graph that is being analyzed','line_number':317,'multiline':False]
['text':' by the JS::ubi::Node that the JS::ubi::StackFrame came from. That is, if the','line_number':318,'multiline':False]
['text':' graph being analyzed is the live heap graph, the JS::ubi::StackFrame is only','line_number':319,'multiline':False]
['text':' valid within the scope of an AutoCheckCannotGC; if the graph being analyzed','line_number':320,'multiline':False]
['text':' is an offline heap snapshot, the JS::ubi::StackFrame is valid as long as the','line_number':321,'multiline':False]
['text':' offline heap snapshot is alive.','line_number':322,'multiline':False]
['text':' Storage in which we allocate BaseStackFrame subclasses.','line_number':324,'multiline':False]
['text':' Constructors accepting SpiderMonkey's generic-pointer-ish types.','line_number':356,'multiline':False]
['text':' Because StackFrame is just a vtable pointer and an instance pointer, we','line_number':380,'multiline':False]
['text':' can memcpy everything around instead of making concrete classes define','line_number':381,'multiline':False]
['text':' virtual constructors. See the comment above Node's copy constructor for','line_number':382,'multiline':False]
['text':' more details; that comment applies here as well.','line_number':383,'multiline':False]
['text':' Copy this StackFrame's source name into the given |destination|','line_number':400,'multiline':False]
['text':' buffer. Copy no more than |length| characters. The result is *not* null','line_number':401,'multiline':False]
['text':' terminated. Returns how many characters were written into the buffer.','line_number':402,'multiline':False]
['text':' Copy this StackFrame's function display name into the given |destination|','line_number':405,'multiline':False]
['text':' buffer. Copy no more than |length| characters. The result is *not* null','line_number':406,'multiline':False]
['text':' terminated. Returns how many characters were written into the buffer.','line_number':407,'multiline':False]
['text':' Get the size of the respective strings. 0 is returned for null strings.','line_number':411,'multiline':False]
['text':' Methods that forward to virtual calls through BaseStackFrame.','line_number':415,'multiline':False]
['text':' The ubi::StackFrame null pointer. Any attempt to operate on a null','line_number':453,'multiline':False]
['text':' ubi::StackFrame crashes.','line_number':454,'multiline':False]
['text':'** ubi::Node
 * ***********************************************************************************','line_number':492,'multiline':True]
['text':' A concrete node specialization can claim its referent is a member of a','line_number':495,'multiline':False]
['text':' particular "coarse type" which is less specific than the actual','line_number':496,'multiline':False]
['text':' implementation type but generally more palatable for web developers. For','line_number':497,'multiline':False]
['text':' example, JitCode can be considered to have a coarse type of "Script". This is','line_number':498,'multiline':False]
['text':' used by some analyses for putting nodes into different buckets. The default,','line_number':499,'multiline':False]
['text':' if a concrete specialization does not provide its own mapping to a CoarseType','line_number':500,'multiline':False]
['text':' variant, is "Other".','line_number':501,'multiline':False]
['text':'','line_number':502,'multiline':False]
['text':' NB: the values associated with a particular enum variant must not change or','line_number':503,'multiline':False]
['text':' be reused for new variants. Doing so will cause inspecting ubi::Nodes backed','line_number':504,'multiline':False]
['text':' by an offline heap snapshot from an older SpiderMonkey/Firefox version to','line_number':505,'multiline':False]
['text':' break. Consider this enum append only.','line_number':506,'multiline':False]
['text':'*
 * Convert a CoarseType enum into a string. The string is statically allocated.
 ','line_number':518,'multiline':True]
['text':' The base class implemented by each ubi::Node referent type. Subclasses must','line_number':539,'multiline':False]
['text':' not add data members to this class.','line_number':540,'multiline':False]
['text':' For performance's sake, we'd prefer to avoid a virtual destructor; and','line_number':544,'multiline':False]
['text':' an empty constructor seems consistent with the 'lightweight value type'','line_number':545,'multiline':False]
['text':' visible behavior we're trying to achieve. But if the destructor isn't','line_number':546,'multiline':False]
['text':' virtual, and a subclass overrides it, the subclass's destructor will be','line_number':547,'multiline':False]
['text':' ignored. Is there a way to make the compiler catch that error?','line_number':548,'multiline':False]
['text':' Space for the actual pointer. Concrete subclasses should define a','line_number':551,'multiline':False]
['text':' properly typed 'get' member function to access this.','line_number':552,'multiline':False]
['text':' Some compilers will indeed place objects of different types at','line_number':559,'multiline':False]
['text':' the same address, so technically, we should include the vtable','line_number':560,'multiline':False]
['text':' in this comparison. But it seems unlikely to cause problems in','line_number':561,'multiline':False]
['text':' practice.','line_number':562,'multiline':False]
['text':' An identifier for this node, guaranteed to be stable and unique for as','line_number':567,'multiline':False]
['text':' long as this ubi::Node's referent is alive and at the same address.','line_number':568,'multiline':False]
['text':'','line_number':569,'multiline':False]
['text':' This is probably suitable for use in serializations, as it is an integral','line_number':570,'multiline':False]
['text':' type. It may also help save memory when constructing HashSets of','line_number':571,'multiline':False]
['text':' ubi::Nodes: since a uint64_t will always be smaller-or-equal-to the size','line_number':572,'multiline':False]
['text':' of a ubi::Node, a HashSet<ubi::Node::Id> may use less space per element','line_number':573,'multiline':False]
['text':' than a HashSet<ubi::Node>.','line_number':574,'multiline':False]
['text':'','line_number':575,'multiline':False]
['text':' (Note that 'unique' only means 'up to equality on ubi::Node'; see the','line_number':576,'multiline':False]
['text':' caveats about multiple objects allocated at the same address for','line_number':577,'multiline':False]
['text':' 'ubi::Node::operator=='.)','line_number':578,'multiline':False]
['text':' Returns true if this node is pointing to something on the live heap, as','line_number':582,'multiline':False]
['text':' opposed to something from a deserialized core dump. Returns false,','line_number':583,'multiline':False]
['text':' otherwise.','line_number':584,'multiline':False]
['text':' Return the coarse-grained type-of-thing that this node represents.','line_number':587,'multiline':False]
['text':' Return a human-readable name for the referent's type. The result should','line_number':590,'multiline':False]
['text':' be statically allocated. (You can use u"strings" for this.)','line_number':591,'multiline':False]
['text':'','line_number':592,'multiline':False]
['text':' This must always return Concrete<T>::concreteTypeName; we use that','line_number':593,'multiline':False]
['text':' pointer as a tag for this particular referent type.','line_number':594,'multiline':False]
['text':' Return the size of this node, in bytes. Include any structures that this','line_number':597,'multiline':False]
['text':' node owns exclusively that are not exposed as their own ubi::Nodes.','line_number':598,'multiline':False]
['text':' |mallocSizeOf| should be a malloc block sizing function; see','line_number':599,'multiline':False]
['text':' |mfbt/MemoryReporting.h|.','line_number':600,'multiline':False]
['text':'','line_number':601,'multiline':False]
['text':' Because we can use |JS::ubi::Node|s backed by a snapshot that was taken','line_number':602,'multiline':False]
['text':' on a 64-bit platform when we are currently on a 32-bit platform, we','line_number':603,'multiline':False]
['text':' cannot rely on |size_t| for node sizes. Instead, |Size| is uint64_t on','line_number':604,'multiline':False]
['text':' all platforms.','line_number':605,'multiline':False]
['text':' Return an EdgeRange that initially contains all the referent's outgoing','line_number':609,'multiline':False]
['text':' edges. The caller takes ownership of the EdgeRange.','line_number':610,'multiline':False]
['text':'','line_number':611,'multiline':False]
['text':' If wantNames is true, compute names for edges. Doing so can be expensive','line_number':612,'multiline':False]
['text':' in time and memory.','line_number':613,'multiline':False]
['text':' Return the Zone to which this node's referent belongs, or nullptr if the','line_number':617,'multiline':False]
['text':' referent is not of a type allocated in SpiderMonkey Zones.','line_number':618,'multiline':False]
['text':' Return the compartment for this node. Some ubi::Node referents are not','line_number':621,'multiline':False]
['text':' associated with Compartments, such as JSStrings (which are associated','line_number':622,'multiline':False]
['text':' with Zones). When the referent is not associated with a compartment,','line_number':623,'multiline':False]
['text':' nullptr is returned.','line_number':624,'multiline':False]
['text':' Return the realm for this node. Some ubi::Node referents are not','line_number':627,'multiline':False]
['text':' associated with Realms, such as JSStrings (which are associated','line_number':628,'multiline':False]
['text':' with Zones) or cross-compartment wrappers (which are associated with','line_number':629,'multiline':False]
['text':' compartments). When the referent is not associated with a realm,','line_number':630,'multiline':False]
['text':' nullptr is returned.','line_number':631,'multiline':False]
['text':' Return whether this node's referent's allocation stack was captured.','line_number':634,'multiline':False]
['text':' Get the stack recorded at the time this node's referent was','line_number':637,'multiline':False]
['text':' allocated. This must only be called when hasAllocationStack() is true.','line_number':638,'multiline':False]
['text':' In some cases, Concrete<T> can return a more descriptive','line_number':645,'multiline':False]
['text':' referent type name than simply `T`. This method returns an','line_number':646,'multiline':False]
['text':' identifier as specific as is efficiently available.','line_number':647,'multiline':False]
['text':' The string returned is borrowed from the ubi::Node's referent.','line_number':648,'multiline':False]
['text':' If nothing more specific than typeName() is available, return nullptr.','line_number':649,'multiline':False]
['text':' Methods for JSObject Referents','line_number':652,'multiline':False]
['text':'','line_number':653,'multiline':False]
['text':' These methods are only semantically valid if the referent is either a','line_number':654,'multiline':False]
['text':' JSObject in the live heap, or represents a previously existing JSObject','line_number':655,'multiline':False]
['text':' from some deserialized heap snapshot.','line_number':656,'multiline':False]
['text':' Return the object's [[Class]]'s name.','line_number':658,'multiline':False]
['text':' Methods for CoarseType::Script referents','line_number':661,'multiline':False]
['text':' Return the script's source's filename if available. If unavailable,','line_number':663,'multiline':False]
['text':' return nullptr.','line_number':664,'multiline':False]
['text':' A traits template with a specialization for each referent type that','line_number':672,'multiline':False]
['text':' ubi::Node supports. The specialization must be the concrete subclass of Base','line_number':673,'multiline':False]
['text':' that represents a pointer to the referent type. It must include these','line_number':674,'multiline':False]
['text':' members:','line_number':675,'multiline':False]
['text':'','line_number':676,'multiline':False]
['text':'    // The specific char16_t array returned by Concrete<T>::typeName().','line_number':677,'multiline':False]
['text':'    static const char16_t concreteTypeName[];','line_number':678,'multiline':False]
['text':'','line_number':679,'multiline':False]
['text':'    // Construct an instance of this concrete class in |storage| referring','line_number':680,'multiline':False]
['text':'    // to |referent|. Implementations typically use a placement 'new'.','line_number':681,'multiline':False]
['text':'    //','line_number':682,'multiline':False]
['text':'    // In some cases, |referent| will contain dynamic type information that','line_number':683,'multiline':False]
['text':'    // identifies it a some more specific subclass of |Referent|. For','line_number':684,'multiline':False]
['text':'    // example, when |Referent| is |JSObject|, then |referent->getClass()|','line_number':685,'multiline':False]
['text':'    // could tell us that it's actually a JSFunction. Similarly, if','line_number':686,'multiline':False]
['text':'    // |Referent| is |nsISupports|, we would like a ubi::Node that knows its','line_number':687,'multiline':False]
['text':'    // final implementation type.','line_number':688,'multiline':False]
['text':'    //','line_number':689,'multiline':False]
['text':'    // So we delegate the actual construction to this specialization, which','line_number':690,'multiline':False]
['text':'    // knows Referent's details.','line_number':691,'multiline':False]
['text':'    static void construct(void* storage, Referent* referent);','line_number':692,'multiline':False]
['text':' A container for a Base instance; all members simply forward to the contained','line_number':696,'multiline':False]
['text':' instance.  This container allows us to pass ubi::Node instances by value.','line_number':697,'multiline':False]
['text':' Storage in which we allocate Base subclasses.','line_number':699,'multiline':False]
['text':' We can construct and assign from rooted forms of pointers.','line_number':728,'multiline':False]
['text':' Constructors accepting SpiderMonkey's other generic-pointer-ish types.','line_number':739,'multiline':False]
['text':' Note that we *do* want an implicit constructor here: JS::Value and','line_number':740,'multiline':False]
['text':' JS::ubi::Node are both essentially tagged references to other sorts of','line_number':741,'multiline':False]
['text':' objects, so letting conversions happen automatically is appropriate.','line_number':742,'multiline':False]
['text':' copy construction and copy assignment just use memcpy, since we know','line_number':746,'multiline':False]
['text':' instances contain nothing but a vtable pointer and a data pointer.','line_number':747,'multiline':False]
['text':'','line_number':748,'multiline':False]
['text':' To be completely correct, concrete classes could provide a virtual','line_number':749,'multiline':False]
['text':' 'construct' member function, which we could invoke on rhs to construct an','line_number':750,'multiline':False]
['text':' instance in our storage. But this is good enough; there's no need to jump','line_number':751,'multiline':False]
['text':' through vtables for copying and assignment that are just going to move','line_number':752,'multiline':False]
['text':' two words around. The compiler knows how to optimize memcpy.','line_number':753,'multiline':False]
['text':' Get the canonical type name for the given type T.','line_number':770,'multiline':False]
['text':' If this node refers to something that can be represented as a JavaScript','line_number':794,'multiline':False]
['text':' value that is safe to expose to JavaScript code, return that value.','line_number':795,'multiline':False]
['text':' Otherwise return UndefinedValue(). JSStrings, JS::Symbols, and some (but','line_number':796,'multiline':False]
['text':' not all!) JSObjects can be exposed.','line_number':797,'multiline':False]
['text':' A hash policy for ubi::Nodes.','line_number':836,'multiline':False]
['text':' This simply uses the stock PointerHasher on the ubi::Node's pointer.','line_number':837,'multiline':False]
['text':' We specialize DefaultHasher below to make this the default.','line_number':838,'multiline':False]
['text':'** Edge and EdgeRange ******************************************************','line_number':857,'multiline':True]
['text':' An outgoing edge to a referent node.','line_number':861,'multiline':False]
['text':' Construct an initialized Edge, taking ownership of |name|.','line_number':866,'multiline':False]
['text':' Move construction and assignment.','line_number':869,'multiline':False]
['text':' This edge's name. This may be nullptr, if Node::edges was called with','line_number':882,'multiline':False]
['text':' false as the wantNames parameter.','line_number':883,'multiline':False]
['text':'','line_number':884,'multiline':False]
['text':' The storage is owned by this Edge, and will be freed when this Edge is','line_number':885,'multiline':False]
['text':' destructed. You may take ownership of the name by `std::move`ing it','line_number':886,'multiline':False]
['text':' out of the edge; it is just a UniquePtr.','line_number':887,'multiline':False]
['text':'','line_number':888,'multiline':False]
['text':' (In real life we'll want a better representation for names, to avoid','line_number':889,'multiline':False]
['text':' creating tons of strings when the names follow a pattern; and we'll need','line_number':890,'multiline':False]
['text':' to think about lifetimes carefully to ensure traversal stays cheap.)','line_number':891,'multiline':False]
['text':' This edge's referent.','line_number':894,'multiline':False]
['text':' EdgeRange is an abstract base class for iterating over a node's outgoing','line_number':898,'multiline':False]
['text':' edges. (This is modeled after js::HashTable<K,V>::Range.)','line_number':899,'multiline':False]
['text':'','line_number':900,'multiline':False]
['text':' Concrete instances of this class need not be as lightweight as Node itself,','line_number':901,'multiline':False]
['text':' since they're usually only instantiated while iterating over a particular','line_number':902,'multiline':False]
['text':' object's edges. For example, a dumb implementation for JS Cells might use','line_number':903,'multiline':False]
['text':' JS::TraceChildren to to get the outgoing edges, and then store them in an','line_number':904,'multiline':False]
['text':' array internal to the EdgeRange.','line_number':905,'multiline':False]
['text':' The current front edge of this range, or nullptr if this range is empty.','line_number':908,'multiline':False]
['text':' True if there are no more edges in this range.','line_number':916,'multiline':False]
['text':' The front edge of this range. This is owned by the EdgeRange, and is','line_number':919,'multiline':False]
['text':' only guaranteed to live until the next call to popFront, or until','line_number':920,'multiline':False]
['text':' the EdgeRange is destructed.','line_number':921,'multiline':False]
['text':' Remove the front edge from this range. This should only be called if','line_number':925,'multiline':False]
['text':' !empty().','line_number':926,'multiline':False]
['text':' An EdgeRange concrete class that holds a pre-existing vector of','line_number':936,'multiline':False]
['text':' Edges. A PreComputedEdgeRange does not take ownership of its','line_number':937,'multiline':False]
['text':' EdgeVector; it is up to the PreComputedEdgeRange's consumer to manage','line_number':938,'multiline':False]
['text':' that lifetime.','line_number':939,'multiline':False]
['text':'** RootList ****************************************************************','line_number':958,'multiline':True]
['text':' RootList is a class that can be pointed to by a |ubi::Node|, creating a','line_number':960,'multiline':False]
['text':' fictional root-of-roots which has edges to every GC root in the JS','line_number':961,'multiline':False]
['text':' runtime. Having a single root |ubi::Node| is useful for algorithms written','line_number':962,'multiline':False]
['text':' with the assumption that there aren't multiple roots (such as computing','line_number':963,'multiline':False]
['text':' dominator trees) and you want a single point of entry. It also ensures that','line_number':964,'multiline':False]
['text':' the roots themselves get visited by |ubi::BreadthFirst| (they would otherwise','line_number':965,'multiline':False]
['text':' only be used as starting points).','line_number':966,'multiline':False]
['text':'','line_number':967,'multiline':False]
['text':' RootList::init itself causes a minor collection, but once the list of roots','line_number':968,'multiline':False]
['text':' has been created, GC must not occur, as the referent ubi::Nodes are not','line_number':969,'multiline':False]
['text':' stable across GC. The init calls emplace on |noGC|'s AutoCheckCannotGC, whose','line_number':970,'multiline':False]
['text':' lifetime must extend at least as long as the RootList itself.','line_number':971,'multiline':False]
['text':'','line_number':972,'multiline':False]
['text':' Example usage:','line_number':973,'multiline':False]
['text':'','line_number':974,'multiline':False]
['text':'    {','line_number':975,'multiline':False]
['text':'        mozilla::Maybe<JS::AutoCheckCannotGC> maybeNoGC;','line_number':976,'multiline':False]
['text':'        JS::ubi::RootList rootList(cx, maybeNoGC);','line_number':977,'multiline':False]
['text':'        if (!rootList.init()) {','line_number':978,'multiline':False]
['text':'            return false;','line_number':979,'multiline':False]
['text':'        }','line_number':980,'multiline':False]
['text':'','line_number':981,'multiline':False]
['text':'        // The AutoCheckCannotGC is guaranteed to exist if init returned true.','line_number':982,'multiline':False]
['text':'        MOZ_ASSERT(maybeNoGC.isSome());','line_number':983,'multiline':False]
['text':'','line_number':984,'multiline':False]
['text':'        JS::ubi::Node root(&rootList);','line_number':985,'multiline':False]
['text':'','line_number':986,'multiline':False]
['text':'        ...','line_number':987,'multiline':False]
['text':'    }','line_number':988,'multiline':False]
['text':' Find all GC roots.','line_number':1000,'multiline':False]
['text':' Find only GC roots in the provided set of |JS::Compartment|s. Note: it's','line_number':1002,'multiline':False]
['text':' important to take a CompartmentSet and not a RealmSet: objects in','line_number':1003,'multiline':False]
['text':' same-compartment realms can reference each other directly, without going','line_number':1004,'multiline':False]
['text':' through CCWs, so if we used a RealmSet here we would miss edges.','line_number':1005,'multiline':False]
['text':' Find only GC roots in the given Debugger object's set of debuggee','line_number':1007,'multiline':False]
['text':' compartments.','line_number':1008,'multiline':False]
['text':' Returns true if the RootList has been initialized successfully, false','line_number':1011,'multiline':False]
['text':' otherwise.','line_number':1012,'multiline':False]
['text':' Explicitly add the given Node as a root in this RootList. If wantNames is','line_number':1015,'multiline':False]
['text':' true, you must pass an edgeName. The RootList does not take ownership of','line_number':1016,'multiline':False]
['text':' edgeName.','line_number':1017,'multiline':False]
['text':'** Concrete classes for ubi::Node referent types ***************************','line_number':1021,'multiline':True]
['text':' A reusable ubi::Concrete specialization base class for types supported by','line_number':1040,'multiline':False]
['text':' JS::TraceChildren.','line_number':1041,'multiline':False]
['text':' For JS::TraceChildren-based types that have 'realm' and 'compartment'','line_number':1054,'multiline':False]
['text':' methods.','line_number':1055,'multiline':False]
['text':' Define specializations for some commonly-used public JSAPI types.','line_number':1066,'multiline':False]
['text':' These can use the generic templates above.','line_number':1067,'multiline':False]
['text':' The JSObject specialization.','line_number':1120,'multiline':False]
['text':' For JSString, we extend the generic template with a 'size' implementation.','line_number':1144,'multiline':False]
['text':' The ubi::Node null pointer. Any attempt to operate on a null ubi::Node','line_number':1163,'multiline':False]
['text':' asserts.','line_number':1164,'multiline':False]
['text':' The |callback| callback is much like the |Concrete<T>::construct| method: a','line_number':1183,'multiline':False]
['text':' call to |callback| should construct an instance of the most appropriate','line_number':1184,'multiline':False]
['text':' JS::ubi::Base subclass for |obj| in |storage|. The callback may assume that','line_number':1185,'multiline':False]
['text':' |obj->getClass()->isDOMClass()|, and that |storage| refers to the','line_number':1186,'multiline':False]
['text':' sizeof(JS::ubi::Base) bytes of space that all ubi::Base implementations','line_number':1187,'multiline':False]
['text':' should require.','line_number':1188,'multiline':False]
['text':' Set |cx|'s runtime hook for constructing ubi::Nodes for DOM classes to','line_number':1190,'multiline':False]
['text':' |callback|.','line_number':1191,'multiline':False]
['text':' namespace ubi','line_number':1196,'multiline':False]
['text':' namespace JS','line_number':1197,'multiline':False]
['text':' Make ubi::Node::HashPolicy the default hash policy for ubi::Node.','line_number':1201,'multiline':False]
['text':' namespace mozilla','line_number':1207,'multiline':False]
['text':' js_UbiNode_h','line_number':1209,'multiline':False]
