['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' See documentation for ScratchTagScope and ScratchTagScopeRelease in','line_number':25,'multiline':False]
['text':' MacroAssembler-x64.h.','line_number':26,'multiline':False]
['text':' MacroAssemblerARM is inheriting form Assembler defined in','line_number':43,'multiline':False]
['text':' Assembler-arm.{h,cpp}','line_number':44,'multiline':False]
['text':' Perform a downcast. Should be removed by Bug 996602.','line_number':47,'multiline':False]
['text':' On ARM, some instructions require a second scratch register. This','line_number':52,'multiline':False]
['text':' register defaults to lr, since it's non-allocatable (as it can be','line_number':53,'multiline':False]
['text':' clobbered by some instructions). Allow the baseline compiler to override','line_number':54,'multiline':False]
['text':' this though, since baseline IC stubs rely on lr holding the return','line_number':55,'multiline':False]
['text':' address.','line_number':56,'multiline':False]
['text':' Higher level tag testing code.','line_number':63,'multiline':False]
['text':' TODO: Can probably remove the Operand versions.','line_number':64,'multiline':False]
['text':' If we are based on StackPointer, pass over the type tag just pushed.','line_number':85,'multiline':False]
['text':' Somewhat direct wrappers for the low-level assembler funcitons','line_number':129,'multiline':False]
['text':' bitops. Attempt to encode a virtual alu instruction using two real','line_number':130,'multiline':False]
['text':' instructions.','line_number':131,'multiline':False]
['text':' To be used with Iter := InstructionIterator or BufferInstructionIterator.','line_number':151,'multiline':False]
['text':' ALU based ops','line_number':156,'multiline':False]
['text':' mov','line_number':157,'multiline':False]
['text':' Shifts (just a move with a shifting op2)','line_number':166,'multiline':False]
['text':' Move not (dest <- ~src)','line_number':180,'multiline':False]
['text':' Negate (dest <- -src) implemented as rsb dest, src, 0','line_number':184,'multiline':False]
['text':' And','line_number':190,'multiline':False]
['text':' Bit clear (dest <- dest & ~imm) or (dest <- src1 & ~src2)','line_number':204,'multiline':False]
['text':' Exclusive or','line_number':208,'multiline':False]
['text':' Or','line_number':222,'multiline':False]
['text':' Arithmetic based ops.','line_number':236,'multiline':False]
['text':' Add with carry:','line_number':237,'multiline':False]
['text':' Add:','line_number':245,'multiline':False]
['text':' Subtract with carry:','line_number':258,'multiline':False]
['text':' Subtract:','line_number':266,'multiline':False]
['text':' Reverse subtract:','line_number':279,'multiline':False]
['text':' Reverse subtract with carry:','line_number':290,'multiline':False]
['text':' Compares/tests.','line_number':298,'multiline':False]
['text':' Compare negative (sets condition codes as src1 + src2 would):','line_number':299,'multiline':False]
['text':' Compare (src - src2):','line_number':305,'multiline':False]
['text':' Test for equality, (src1 ^ src2):','line_number':317,'multiline':False]
['text':' Test (src1 & src2):','line_number':323,'multiline':False]
['text':' Multiplies. For now, there are only two that we care about.','line_number':329,'multiline':False]
['text':' Fast mod, uses scratch registers, and thus needs to be in the assembler','line_number':343,'multiline':False]
['text':' implicitly assumes that we can overwrite dest at the beginning of the','line_number':344,'multiline':False]
['text':' sequence.','line_number':345,'multiline':False]
['text':' Mod - depends on integer divide instructions being supported.','line_number':350,'multiline':False]
['text':' Division - depends on integer divide instructions being supported.','line_number':356,'multiline':False]
['text':' Misc operations','line_number':361,'multiline':False]
['text':' Memory:','line_number':364,'multiline':False]
['text':' Shortcut for when we know we're transferring 32 bits of data.','line_number':365,'multiline':False]
['text':' Specialty for moving N bits of data, where n == 8,16,32,64.','line_number':399,'multiline':False]
['text':' Barriers.','line_number':423,'multiline':False]
['text':' Branches when done from within arm-specific code.','line_number':427,'multiline':False]
['text':' This is almost NEVER necessary, we'll basically never be calling a label','line_number':432,'multiline':False]
['text':' except, possibly in the crazy bailout-table case.','line_number':433,'multiline':False]
['text':' VFP/ALU:','line_number':438,'multiline':False]
['text':' Source is F64, dest is I32:','line_number':475,'multiline':False]
['text':' Source is I32, dest is F64:','line_number':481,'multiline':False]
['text':' Source is F32, dest is I32:','line_number':487,'multiline':False]
['text':' Source is I32, dest is F32:','line_number':493,'multiline':False]
['text':' Transfer (do not coerce) a float into a gpr.','line_number':499,'multiline':False]
['text':' Transfer (do not coerce) a double into a couple of gpr.','line_number':501,'multiline':False]
['text':' Transfer (do not coerce) a gpr into a float','line_number':505,'multiline':False]
['text':' Transfer (do not coerce) a couple of gpr into a double','line_number':507,'multiline':False]
['text':' Float registers can only be loaded/stored in continuous runs when using','line_number':533,'multiline':False]
['text':' vstm/vldm. This function breaks set into continuous runs and loads/stores','line_number':534,'multiline':False]
['text':' them at [rm]. rm will be modified and left in a state logically suitable','line_number':535,'multiline':False]
['text':' for the next load/store. Returns the offset from [dm] for the logical','line_number':536,'multiline':False]
['text':' next load/store.','line_number':537,'multiline':False]
['text':' `outAny` is valid if and only if `out64` == Register64::Invalid().','line_number':551,'multiline':False]
['text':' `valAny` is valid if and only if `val64` == Register64::Invalid().','line_number':556,'multiline':False]
['text':' Implementation for transferMultipleByRuns so we can use different','line_number':562,'multiline':False]
['text':' iterators for forward/backward traversals. The sign argument should be 1','line_number':563,'multiline':False]
['text':' if we traverse forwards, -1 if we traverse backwards.','line_number':564,'multiline':False]
['text':' Build up a new set, which is the sum of all of the single and double','line_number':572,'multiline':False]
['text':' registers. This set can have up to 48 registers in it total','line_number':573,'multiline':False]
['text':' s0-s31 and d16-d31','line_number':574,'multiline':False]
['text':' Perform a downcast. Should be removed by Bug 996602.','line_number':598,'multiline':False]
['text':' Jumps + other functions that should be called from non-arm specific','line_number':606,'multiline':False]
['text':' code. Basically, an x86 front end on top of the ARM code.','line_number':607,'multiline':False]
['text':' Emit a BLX or NOP instruction. ToggleCall can be used to patch this','line_number':683,'multiline':False]
['text':' instruction.','line_number':684,'multiline':False]
['text':' Higher level tag testing code.','line_number':737,'multiline':False]
['text':' Register-based tests.','line_number':753,'multiline':False]
['text':' Unboxing code.','line_number':793,'multiline':False]
['text':' Due to Spectre mitigation logic (see Value.h), if the value is an Object','line_number':844,'multiline':False]
['text':' then this yields the object; otherwise it yields zero (null), as desired.','line_number':845,'multiline':False]
['text':' See comment in MacroAssembler-x64.h.','line_number':860,'multiline':False]
['text':' Boxing code.','line_number':873,'multiline':False]
['text':' Extended unboxing API. If the payload is already in a register, returns','line_number':877,'multiline':False]
['text':' that register. Otherwise, provides a move to the given scratch register,','line_number':878,'multiline':False]
['text':' and returns that.','line_number':879,'multiline':False]
['text':' Treat the value as a boolean, and set condition codes accordingly.','line_number':914,'multiline':False]
['text':' Store the payload.','line_number':968,'multiline':False]
['text':' Store the type.','line_number':975,'multiline':False]
['text':' Encodable as DTRAddr, so only two instructions needed.','line_number':977,'multiline':False]
['text':' Since there are only two scratch registers, the offset must be','line_number':981,'multiline':False]
['text':' applied early using a third instruction to be safe.','line_number':982,'multiline':False]
['text':' Store the type.','line_number':1019,'multiline':False]
['text':' Restore scratch for the payload store.','line_number':1027,'multiline':False]
['text':' Store the payload, marking if necessary.','line_number':1031,'multiline':False]
['text':' Like loadValue but guaranteed to not use LDRD or LDM instructions (these','line_number':1063,'multiline':False]
['text':' don't support unaligned accesses).','line_number':1064,'multiline':False]
['text':'///////////////////////////////////////////////////////////////','line_number':1094,'multiline':False]
['text':' Common interface.','line_number':1095,'multiline':False]
['text':'///////////////////////////////////////////////////////////////','line_number':1096,'multiline':False]
['text':' load16SignExtend uses |ldrsh|, which supports unaligned access.','line_number':1120,'multiline':False]
['text':' load16ZeroExtend uses |ldrh|, which supports unaligned access.','line_number':1129,'multiline':False]
['text':' load32 uses |ldr|, which supports unaligned access.','line_number':1139,'multiline':False]
['text':' load64 calls load32, which supports unaligned accesses.','line_number':1154,'multiline':False]
['text':' Load a float value into a register, then expand it to a double.','line_number':1168,'multiline':False]
['text':' store16 uses |strh|, which supports unaligned access.','line_number':1187,'multiline':False]
['text':' store32 uses |str|, which supports unaligned access.','line_number':1199,'multiline':False]
['text':' store64 calls store32, which supports unaligned access.','line_number':1225,'multiline':False]
['text':' Conditional breakpoint.','line_number':1265,'multiline':False]
['text':' Trigger the simulator's interactive read-eval-print loop.','line_number':1268,'multiline':False]
['text':' The message will be printed at the stopping point.','line_number':1269,'multiline':False]
['text':' (On non-simulator builds, does nothing.)','line_number':1270,'multiline':False]
['text':' Evaluate srcDest = minmax<isMax>{Float32,Double}(srcDest, other).','line_number':1273,'multiline':False]
['text':' Checks for NaN if canBeNaN is true.','line_number':1274,'multiline':False]
['text':' If source is a double, load it into dest. If source is int32, convert it','line_number':1286,'multiline':False]
['text':' to double. Else, branch to failure.','line_number':1287,'multiline':False]
['text':' Check explicitly for r == INT_MIN || r == INT_MAX','line_number':1340,'multiline':False]
['text':' This is the instruction sequence that gcc generated for this','line_number':1341,'multiline':False]
['text':' operation.','line_number':1342,'multiline':False]
['text':' Instrumentation for entering and leaving the profiler.','line_number':1374,'multiline':False]
['text':' namespace jit','line_number':1381,'multiline':False]
['text':' namespace js','line_number':1382,'multiline':False]
['text':' jit_arm_MacroAssembler_arm_h ','line_number':1384,'multiline':True]
