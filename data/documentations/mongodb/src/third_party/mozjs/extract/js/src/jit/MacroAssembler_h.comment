['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' js::Scalar::Type','line_number':38,'multiline':False]
['text':' [SMDOC] MacroAssembler multi-platform overview','line_number':47,'multiline':False]
['text':'','line_number':48,'multiline':False]
['text':' * How to read/write MacroAssembler method declarations:','line_number':49,'multiline':False]
['text':'','line_number':50,'multiline':False]
['text':' The following macros are made to avoid #ifdef around each method declarations','line_number':51,'multiline':False]
['text':' of the Macro Assembler, and they are also used as an hint on the location of','line_number':52,'multiline':False]
['text':' the implementations of each method.  For example, the following declaration','line_number':53,'multiline':False]
['text':'','line_number':54,'multiline':False]
['text':'   void Pop(FloatRegister t) DEFINED_ON(x86_shared, arm);','line_number':55,'multiline':False]
['text':'','line_number':56,'multiline':False]
['text':' suggests the MacroAssembler::Pop(FloatRegister) method is implemented in','line_number':57,'multiline':False]
['text':' x86-shared/MacroAssembler-x86-shared.h, and also in arm/MacroAssembler-arm.h.','line_number':58,'multiline':False]
['text':'','line_number':59,'multiline':False]
['text':' - If there is no annotation, then there is only one generic definition in','line_number':60,'multiline':False]
['text':'   MacroAssembler.cpp.','line_number':61,'multiline':False]
['text':'','line_number':62,'multiline':False]
['text':' - If the declaration is "inline", then the method definition(s) would be in','line_number':63,'multiline':False]
['text':'   the "-inl.h" variant of the same file(s).','line_number':64,'multiline':False]
['text':'','line_number':65,'multiline':False]
['text':' The script check_macroassembler_style.py (which runs on every build) is','line_number':66,'multiline':False]
['text':' used to verify that method definitions match the annotation on the method','line_number':67,'multiline':False]
['text':' declarations.  If there is any difference, then you either forgot to define','line_number':68,'multiline':False]
['text':' the method in one of the macro assembler, or you forgot to update the','line_number':69,'multiline':False]
['text':' annotation of the macro assembler declaration.','line_number':70,'multiline':False]
['text':'','line_number':71,'multiline':False]
['text':' Some convenient short-cuts are used to avoid repeating the same list of','line_number':72,'multiline':False]
['text':' architectures on each method declaration, such as PER_ARCH and','line_number':73,'multiline':False]
['text':' PER_SHARED_ARCH.','line_number':74,'multiline':False]
['text':'','line_number':75,'multiline':False]
['text':' Functions that are architecture-agnostic and are the same for all','line_number':76,'multiline':False]
['text':' architectures, that it's necessary to define inline *in this header* to','line_number':77,'multiline':False]
['text':' avoid used-before-defined warnings/errors that would occur if the','line_number':78,'multiline':False]
['text':' definitions were in MacroAssembler-inl.h, should use the OOL_IN_HEADER','line_number':79,'multiline':False]
['text':' marker at end of the declaration:','line_number':80,'multiline':False]
['text':'','line_number':81,'multiline':False]
['text':'   inline uint32_t framePushed() const OOL_IN_HEADER;','line_number':82,'multiline':False]
['text':'','line_number':83,'multiline':False]
['text':' Such functions should then be defined immediately after MacroAssembler's','line_number':84,'multiline':False]
['text':' definition, for example:','line_number':85,'multiline':False]
['text':'','line_number':86,'multiline':False]
['text':'   //{{{ check_macroassembler_style','line_number':87,'multiline':False]
['text':'   inline uint32_t','line_number':88,'multiline':False]
['text':'   MacroAssembler::framePushed() const','line_number':89,'multiline':False]
['text':'   {','line_number':90,'multiline':False]
['text':'       return framePushed_;','line_number':91,'multiline':False]
['text':'   }','line_number':92,'multiline':False]
['text':'   ////}}} check_macroassembler_style','line_number':93,'multiline':False]
['text':' * How this macro works:','line_number':98,'multiline':False]
['text':'','line_number':99,'multiline':False]
['text':' DEFINED_ON is a macro which check if, for the current architecture, the','line_number':100,'multiline':False]
['text':' method is defined on the macro assembler or not.','line_number':101,'multiline':False]
['text':'','line_number':102,'multiline':False]
['text':' For each architecture, we have a macro named DEFINED_ON_arch.  This macro is','line_number':103,'multiline':False]
['text':' empty if this is not the current architecture.  Otherwise it must be either','line_number':104,'multiline':False]
['text':' set to "define" or "crash" (only used for the none target so far).','line_number':105,'multiline':False]
['text':'','line_number':106,'multiline':False]
['text':' The DEFINED_ON macro maps the list of architecture names given as arguments','line_number':107,'multiline':False]
['text':' to a list of macro names.  For example,','line_number':108,'multiline':False]
['text':'','line_number':109,'multiline':False]
['text':'   DEFINED_ON(arm, x86_shared)','line_number':110,'multiline':False]
['text':'','line_number':111,'multiline':False]
['text':' is expanded to','line_number':112,'multiline':False]
['text':'','line_number':113,'multiline':False]
['text':'   DEFINED_ON_none DEFINED_ON_arm DEFINED_ON_x86_shared','line_number':114,'multiline':False]
['text':'','line_number':115,'multiline':False]
['text':' which are later expanded on ARM, x86, x64 by DEFINED_ON_EXPAND_ARCH_RESULTS','line_number':116,'multiline':False]
['text':' to','line_number':117,'multiline':False]
['text':'','line_number':118,'multiline':False]
['text':'   define','line_number':119,'multiline':False]
['text':'','line_number':120,'multiline':False]
['text':' or if the JIT is disabled or set to no architecture to','line_number':121,'multiline':False]
['text':'','line_number':122,'multiline':False]
['text':'   crash','line_number':123,'multiline':False]
['text':'','line_number':124,'multiline':False]
['text':' or to nothing, if the current architecture is not listed in the list of','line_number':125,'multiline':False]
['text':' arguments of DEFINED_ON.  Note, only one of the DEFINED_ON_arch macro','line_number':126,'multiline':False]
['text':' contributes to the non-empty result, which is the macro of the current','line_number':127,'multiline':False]
['text':' architecture if it is listed in the arguments of DEFINED_ON.','line_number':128,'multiline':False]
['text':'','line_number':129,'multiline':False]
['text':' This result is appended to DEFINED_ON_RESULT_ before expanding the macro,','line_number':130,'multiline':False]
['text':' which results in either no annotation, a MOZ_CRASH(), or a "= delete"','line_number':131,'multiline':False]
['text':' annotation on the method declaration.','line_number':132,'multiline':False]
['text':' Specialize for each architecture.','line_number':144,'multiline':False]
['text':' We need to let the evaluation of MOZ_FOR_EACH terminates.','line_number':187,'multiline':False]
['text':' namespace wasm','line_number':234,'multiline':False]
['text':' Defined in JitFrames.h','line_number':238,'multiline':False]
['text':' Require the callee to use AutoUnsafeCallWithABI.','line_number':247,'multiline':False]
['text':' We pushed an exit frame so this callWithABI can safely GC and walk the','line_number':250,'multiline':False]
['text':' stack.','line_number':251,'multiline':False]
['text':' Don't check this callWithABI uses AutoUnsafeCallWithABI, for instance','line_number':254,'multiline':False]
['text':' because we're calling a simple helper function (like malloc or js_free)','line_number':255,'multiline':False]
['text':' that we can't change and/or that we know won't GC.','line_number':256,'multiline':False]
['text':' This is a global function made to create the DynFn type in a controlled','line_number':260,'multiline':False]
['text':' environment which would check if the function signature has been registered','line_number':261,'multiline':False]
['text':' as an ABI function signature.','line_number':262,'multiline':False]
['text':' Allocation sites may be passed to GC thing allocation methods either via a','line_number':273,'multiline':False]
['text':' register (for baseline compilation) or an enum indicating one of the','line_number':274,'multiline':False]
['text':' catch-all allocation sites (for optimized compilation).','line_number':275,'multiline':False]
['text':' [SMDOC] Code generation invariants (incomplete)','line_number':284,'multiline':False]
['text':'','line_number':285,'multiline':False]
['text':' ## 64-bit GPRs carrying 32-bit values','line_number':286,'multiline':False]
['text':'','line_number':287,'multiline':False]
['text':' At least at the end of every JS or Wasm operation (= SpiderMonkey bytecode or','line_number':288,'multiline':False]
['text':' Wasm bytecode; this is necessarily a little vague), if a 64-bit GPR has a','line_number':289,'multiline':False]
['text':' 32-bit value, then the upper 32 bits of the register may be predictable in','line_number':290,'multiline':False]
['text':' accordance with platform-specific rules, as follows.','line_number':291,'multiline':False]
['text':'','line_number':292,'multiline':False]
['text':' - On x64 and arm64, the upper bits are zero','line_number':293,'multiline':False]
['text':' - On mips64 the upper bits are the sign extension of the lower bits','line_number':294,'multiline':False]
['text':' - (On risc-v we have no rule, having no port yet.  Sign extension is the most','line_number':295,'multiline':False]
['text':'   likely rule, but "unpredictable" is an option.)','line_number':296,'multiline':False]
['text':'','line_number':297,'multiline':False]
['text':' In most cases no extra work needs to be done to maintain the invariant:','line_number':298,'multiline':False]
['text':'','line_number':299,'multiline':False]
['text':' - 32-bit operations on x64 and arm64 zero-extend the result to 64 bits.','line_number':300,'multiline':False]
['text':'   These operations ignore the upper bits of the inputs.','line_number':301,'multiline':False]
['text':' - 32-bit operations on mips64 sign-extend the result to 64 bits (even many','line_number':302,'multiline':False]
['text':'   that are labeled as "unsigned", eg ADDU, though not all, eg LU).','line_number':303,'multiline':False]
['text':'   Additionally, the inputs to many 32-bit operations must be properly','line_number':304,'multiline':False]
['text':'   sign-extended to avoid "unpredictable" behavior, and our simulators check','line_number':305,'multiline':False]
['text':'   that inputs conform.','line_number':306,'multiline':False]
['text':' - (32-bit operations on risc-v sign-extend, much as mips, but appear to','line_number':307,'multiline':False]
['text':'   ignore the upper bits of the inputs.)','line_number':308,'multiline':False]
['text':'','line_number':309,'multiline':False]
['text':' The upshot of these invariants is, among other things, that:','line_number':310,'multiline':False]
['text':'','line_number':311,'multiline':False]
['text':' - No code needs to be generated when a 32-bit value is extended to 64 bits','line_number':312,'multiline':False]
['text':'   or a 64-bit value is wrapped to 32 bits, if the upper bits are known to be','line_number':313,'multiline':False]
['text':'   correct because they resulted from an operation that produced them','line_number':314,'multiline':False]
['text':'   predictably.','line_number':315,'multiline':False]
['text':' - Literal loads must be careful to avoid instructions that might extend the','line_number':316,'multiline':False]
['text':'   literal in the wrong way.','line_number':317,'multiline':False]
['text':' - Code that produces values using intermediate values with non-canonical','line_number':318,'multiline':False]
['text':'   extensions must extend according to platform conventions before being','line_number':319,'multiline':False]
['text':'   "done".','line_number':320,'multiline':False]
['text':'','line_number':321,'multiline':False]
['text':' All optimizations are necessarily platform-specific and should only be used','line_number':322,'multiline':False]
['text':' in platform-specific code.  We may add architectures in the future that do','line_number':323,'multiline':False]
['text':' not follow the patterns of the few architectures we already have.','line_number':324,'multiline':False]
['text':'','line_number':325,'multiline':False]
['text':' Also see MacroAssembler::assertCanonicalInt32().','line_number':326,'multiline':False]
['text':' The public entrypoint for emitting assembly. Note that a MacroAssembler can','line_number':328,'multiline':False]
['text':' use cx->lifoAlloc, so take care not to interleave masm use with other','line_number':329,'multiline':False]
['text':' lifoAlloc use if one will be destroyed before the other.','line_number':330,'multiline':False]
['text':' Labels for handling exceptions and failures.','line_number':337,'multiline':False]
['text':' Constructors are protected. Use one of the derived classes!','line_number':341,'multiline':False]
['text':' This constructor should only be used when there is no JitContext active','line_number':344,'multiline':False]
['text':' (for example when generating string and regexp stubs).','line_number':345,'multiline':False]
['text':' wasm compilation handles its own JitContext-pushing','line_number':348,'multiline':False]
['text':' As an optimization, the MoveResolver is a persistent data structure','line_number':354,'multiline':False]
['text':' shared between visitors in the CodeGenerator. This assertion','line_number':355,'multiline':False]
['text':' checks that state is not leaking from visitor to visitor','line_number':356,'multiline':False]
['text':' via an unresolved addMove().','line_number':357,'multiline':False]
['text':' The value returned by GetMaxOffsetGuardLimit() in WasmTypes.h','line_number':369,'multiline':False]
['text':'{{{ check_macroassembler_decl_style','line_number':378,'multiline':False]
['text':' ===============================================================','line_number':380,'multiline':False]
['text':' MacroAssembler high-level usage.','line_number':381,'multiline':False]
['text':' Flushes the assembly buffer, on platforms that need it.','line_number':383,'multiline':False]
['text':' Add a comment that is visible in the pretty printed assembly code.','line_number':386,'multiline':False]
['text':' ===============================================================','line_number':389,'multiline':False]
['text':' Frame manipulation functions.','line_number':390,'multiline':False]
['text':' Adjust the frame, to account for implicit modification of the stack','line_number':396,'multiline':False]
['text':' pointer, such that callee can remove arguments on the behalf of the','line_number':397,'multiline':False]
['text':' caller.','line_number':398,'multiline':False]
['text':' This field is used to statically (at compilation time) emulate a frame','line_number':402,'multiline':False]
['text':' pointer by keeping track of stack manipulations.','line_number':403,'multiline':False]
['text':'','line_number':404,'multiline':False]
['text':' It is maintained by all stack manipulation functions below.','line_number':405,'multiline':False]
['text':' ===============================================================','line_number':409,'multiline':False]
['text':' Stack manipulation functions -- sets of registers.','line_number':410,'multiline':False]
['text':' Approximately speaking, the following routines must use the same memory','line_number':412,'multiline':False]
['text':' layout.  Any inconsistencies will certainly lead to crashing in generated','line_number':413,'multiline':False]
['text':' code:','line_number':414,'multiline':False]
['text':'','line_number':415,'multiline':False]
['text':'   MacroAssembler::PushRegsInMaskSizeInBytes','line_number':416,'multiline':False]
['text':'   MacroAssembler::PushRegsInMask','line_number':417,'multiline':False]
['text':'   MacroAssembler::storeRegsInMask','line_number':418,'multiline':False]
['text':'   MacroAssembler::PopRegsInMask','line_number':419,'multiline':False]
['text':'   MacroAssembler::PopRegsInMaskIgnore','line_number':420,'multiline':False]
['text':'   FloatRegister::getRegisterDumpOffsetInBytes','line_number':421,'multiline':False]
['text':'   (no class) PushRegisterDump','line_number':422,'multiline':False]
['text':'   (union) RegisterContent','line_number':423,'multiline':False]
['text':'','line_number':424,'multiline':False]
['text':' To be more exact, the invariants are:','line_number':425,'multiline':False]
['text':'','line_number':426,'multiline':False]
['text':' * The save area is conceptually viewed as starting at a highest address','line_number':427,'multiline':False]
['text':'   (really, at "highest address - 1") and working down to some lower','line_number':428,'multiline':False]
['text':'   address.','line_number':429,'multiline':False]
['text':'','line_number':430,'multiline':False]
['text':' * PushRegsInMask, storeRegsInMask and PopRegsInMask{Ignore} must use','line_number':431,'multiline':False]
['text':'   exactly the same memory layout, when starting from the abovementioned','line_number':432,'multiline':False]
['text':'   highest address.','line_number':433,'multiline':False]
['text':'','line_number':434,'multiline':False]
['text':' * PushRegsInMaskSizeInBytes must produce a value which is exactly equal','line_number':435,'multiline':False]
['text':'   to the change in the machine's stack pointer register as a result of','line_number':436,'multiline':False]
['text':'   calling PushRegsInMask or PopRegsInMask{Ignore}.  This value must be at','line_number':437,'multiline':False]
['text':'   least uintptr_t-aligned on the target, and may be more aligned than that.','line_number':438,'multiline':False]
['text':'','line_number':439,'multiline':False]
['text':' * PushRegsInMaskSizeInBytes must produce a value which is greater than or','line_number':440,'multiline':False]
['text':'   equal to the amount of space used by storeRegsInMask.','line_number':441,'multiline':False]
['text':'','line_number':442,'multiline':False]
['text':' * Hence, regardless of whether the save area is created with','line_number':443,'multiline':False]
['text':'   storeRegsInMask or PushRegsInMask, it is guaranteed to fit inside an','line_number':444,'multiline':False]
['text':'   area of size calculated by PushRegsInMaskSizeInBytes.','line_number':445,'multiline':False]
['text':'','line_number':446,'multiline':False]
['text':' * For the `ignore` argument of PopRegsInMaskIgnore, equality checking','line_number':447,'multiline':False]
['text':'   for the floating point/SIMD registers is done on the basis of the','line_number':448,'multiline':False]
['text':'   underlying physical register, regardless of width.  For example, if the','line_number':449,'multiline':False]
['text':'   to-restore set contains v17 (the SIMD register with encoding 17) and','line_number':450,'multiline':False]
['text':'   the ignore set contains d17 (the double register with encoding 17) then','line_number':451,'multiline':False]
['text':'   no part of the physical register with encoding 17 will be restored.','line_number':452,'multiline':False]
['text':'   (This is probably not true on arm32, since that has aliased float32','line_number':453,'multiline':False]
['text':'   registers; but none of our other targets do.)','line_number':454,'multiline':False]
['text':'','line_number':455,'multiline':False]
['text':' * {Push,store}RegsInMask/storeRegsInMask are further constrained as','line_number':456,'multiline':False]
['text':'   follows: when given the argument AllFloatRegisters, the resulting','line_number':457,'multiline':False]
['text':'   memory area must contain exactly all the SIMD/FP registers for the','line_number':458,'multiline':False]
['text':'   target at their widest width (that we care about).  [We have no targets','line_number':459,'multiline':False]
['text':'   where the SIMD registers and FP register sets are disjoint.]  They must','line_number':460,'multiline':False]
['text':'   be packed end-to-end with no holes, with the register with the lowest','line_number':461,'multiline':False]
['text':'   encoding number (0), as returned by FloatRegister::encoding(), at the','line_number':462,'multiline':False]
['text':'   abovementioned highest address, register 1 just below that, etc.','line_number':463,'multiline':False]
['text':'','line_number':464,'multiline':False]
['text':'   Furthermore the sizeof(RegisterContent) must equal the size of a SIMD','line_number':465,'multiline':False]
['text':'   register in the abovementioned array.','line_number':466,'multiline':False]
['text':'','line_number':467,'multiline':False]
['text':'   Furthermore the value returned by','line_number':468,'multiline':False]
['text':'   FloatRegister::getRegisterDumpOffsetInBytes must be a correct index','line_number':469,'multiline':False]
['text':'   into the abovementioned array.  Given the constraints, the only correct','line_number':470,'multiline':False]
['text':'   value is `reg.encoding() * sizeof(RegisterContent)`.','line_number':471,'multiline':False]
['text':' Regarding JitRuntime::generateInvalidator and the first two fields of of','line_number':473,'multiline':False]
['text':' class InvalidationBailoutStack (`fpregs_` and `regs_`).  These form their','line_number':474,'multiline':False]
['text':' own layout-equivalence class.  That is, they must be format-consistent.','line_number':475,'multiline':False]
['text':' But they are not part of the equivalence class that PushRegsInMask et al','line_number':476,'multiline':False]
['text':' belong to. JitRuntime::generateInvalidator may use PushRegsInMask to','line_number':477,'multiline':False]
['text':' generate part of the layout, but that's only a happy coincidence; some','line_number':478,'multiline':False]
['text':' targets roll their own save-code instead.','line_number':479,'multiline':False]
['text':'','line_number':480,'multiline':False]
['text':' Nevertheless, because some targets *do* call PushRegsInMask from','line_number':481,'multiline':False]
['text':' JitRuntime::generateInvalidator, you should check carefully all of the','line_number':482,'multiline':False]
['text':' ::generateInvalidator methods if you change the PushRegsInMask format.','line_number':483,'multiline':False]
['text':' The size of the area used by PushRegsInMask.','line_number':485,'multiline':False]
['text':' Like PushRegsInMask, but instead of pushing the registers, store them to','line_number':493,'multiline':False]
['text':' |dest|. |dest| should point to the end of the reserved space, so the','line_number':494,'multiline':False]
['text':' first register will be stored at |dest.offset - sizeof(register)|.  It is','line_number':495,'multiline':False]
['text':' required that |dest.offset| is at least as large as the value computed by','line_number':496,'multiline':False]
['text':' PushRegsInMaskSizeInBytes for this |set|.  In other words, |dest.base|','line_number':497,'multiline':False]
['text':' must point to either the lowest address in the save area, or some address','line_number':498,'multiline':False]
['text':' below that.','line_number':499,'multiline':False]
['text':' ===============================================================','line_number':508,'multiline':False]
['text':' Stack manipulation functions -- single registers/values.','line_number':509,'multiline':False]
['text':' Move the stack pointer based on the requested amount.','line_number':543,'multiline':False]
['text':' Warning: This method does not update the framePushed() counter.','line_number':547,'multiline':False]
['text':' ===============================================================','line_number':551,'multiline':False]
['text':' Register allocation fields.','line_number':552,'multiline':False]
['text':' Used to track register scopes for debug builds.','line_number':556,'multiline':False]
['text':' Manipulated by the AutoGenericRegisterScope class.','line_number':557,'multiline':False]
['text':' DEBUG','line_number':559,'multiline':False]
['text':' ===============================================================','line_number':562,'multiline':False]
['text':' Simple call functions.','line_number':563,'multiline':False]
['text':' The returned CodeOffset is the assembler offset for the instruction','line_number':565,'multiline':False]
['text':' immediately following the call; that is, for the return point.','line_number':566,'multiline':False]
['text':' Call a target native function, which is neither traceable nor movable.','line_number':572,'multiline':False]
['text':' Call a target JitCode, which must be traceable, and may be movable.','line_number':578,'multiline':False]
['text':' Push the return address and make a call. On platforms where this function','line_number':590,'multiline':False]
['text':' is not defined, push the link register (pushReturnAddress) at the entry','line_number':591,'multiline':False]
['text':' point of the callee.','line_number':592,'multiline':False]
['text':' These do not adjust framePushed().','line_number':596,'multiline':False]
['text':' Useful for dealing with two-valued returns.','line_number':600,'multiline':False]
['text':' ===============================================================','line_number':605,'multiline':False]
['text':' Patchable near/far jumps.','line_number':606,'multiline':False]
['text':' "Far jumps" provide the ability to jump to any uint32_t offset from any','line_number':608,'multiline':False]
['text':' other uint32_t offset without using a constant pool (thus returning a','line_number':609,'multiline':False]
['text':' simple CodeOffset instead of a CodeOffsetJump).','line_number':610,'multiline':False]
['text':' Emit a nop that can be patched to and from a nop and a call with int32','line_number':614,'multiline':False]
['text':' relative displacement.','line_number':615,'multiline':False]
['text':' These methods are like movWithPatch/PatchDataWithValueCheck but allow','line_number':622,'multiline':False]
['text':' using pc-relative addressing on certain platforms (RIP-relative LEA on x64,','line_number':623,'multiline':False]
['text':' ADR instruction on arm64).','line_number':624,'multiline':False]
['text':'','line_number':625,'multiline':False]
['text':' Note: "Near" applies to ARM64 where the target must be within 1 MB (this is','line_number':626,'multiline':False]
['text':' release-asserted).','line_number':627,'multiline':False]
['text':' ===============================================================','line_number':635,'multiline':False]
['text':' [SMDOC] JIT-to-C++ Function Calls (callWithABI)','line_number':636,'multiline':False]
['text':'','line_number':637,'multiline':False]
['text':' callWithABI is used to make a call using the standard C/C++ system ABI.','line_number':638,'multiline':False]
['text':'','line_number':639,'multiline':False]
['text':' callWithABI is a low level interface for making calls, as such every call','line_number':640,'multiline':False]
['text':' made with callWithABI should be organized with 6 steps: spilling live','line_number':641,'multiline':False]
['text':' registers, aligning the stack, listing arguments of the called function,','line_number':642,'multiline':False]
['text':' calling a function pointer, extracting the returned value and restoring','line_number':643,'multiline':False]
['text':' live registers.','line_number':644,'multiline':False]
['text':'','line_number':645,'multiline':False]
['text':' A more detailed example of the six stages:','line_number':646,'multiline':False]
['text':'','line_number':647,'multiline':False]
['text':' 1) Saving of registers that are live. This will vary depending on which','line_number':648,'multiline':False]
['text':'    SpiderMonkey compiler you are working on. Registers that shouldn't be','line_number':649,'multiline':False]
['text':'    restored can be excluded.','line_number':650,'multiline':False]
['text':'','line_number':651,'multiline':False]
['text':'      LiveRegisterSet volatileRegs(...);','line_number':652,'multiline':False]
['text':'      volatileRegs.take(scratch);','line_number':653,'multiline':False]
['text':'      masm.PushRegsInMask(volatileRegs);','line_number':654,'multiline':False]
['text':'','line_number':655,'multiline':False]
['text':' 2) Align the stack to perform the call with the correct stack alignment.','line_number':656,'multiline':False]
['text':'','line_number':657,'multiline':False]
['text':'    When the stack pointer alignment is unknown and cannot be corrected','line_number':658,'multiline':False]
['text':'    when generating the code, setupUnalignedABICall must be used to','line_number':659,'multiline':False]
['text':'    dynamically align the stack pointer to the expectation of the ABI.','line_number':660,'multiline':False]
['text':'    When the stack pointer is known at JIT compilation time, the stack can','line_number':661,'multiline':False]
['text':'    be fixed manually and setupAlignedABICall and setupWasmABICall can be','line_number':662,'multiline':False]
['text':'    used.','line_number':663,'multiline':False]
['text':'','line_number':664,'multiline':False]
['text':'    setupWasmABICall is a special case of setupAlignedABICall as','line_number':665,'multiline':False]
['text':'    SpiderMonkey's WebAssembly implementation mostly follow the system','line_number':666,'multiline':False]
['text':'    ABI, except for float/double arguments, which always use floating','line_number':667,'multiline':False]
['text':'    point registers, even if this is not supported by the system ABI.','line_number':668,'multiline':False]
['text':'','line_number':669,'multiline':False]
['text':'      masm.setupUnalignedABICall(scratch);','line_number':670,'multiline':False]
['text':'','line_number':671,'multiline':False]
['text':' 3) Passing arguments. Arguments are passed left-to-right.','line_number':672,'multiline':False]
['text':'','line_number':673,'multiline':False]
['text':'      masm.passABIArg(scratch);','line_number':674,'multiline':False]
['text':'      masm.passABIArg(FloatOp0, MoveOp::Double);','line_number':675,'multiline':False]
['text':'','line_number':676,'multiline':False]
['text':'    Note how float register arguments are annotated with MoveOp::Double.','line_number':677,'multiline':False]
['text':'','line_number':678,'multiline':False]
['text':'    Concerning stack-relative address, see the note on passABIArg.','line_number':679,'multiline':False]
['text':'','line_number':680,'multiline':False]
['text':' 4) Make the call:','line_number':681,'multiline':False]
['text':'','line_number':682,'multiline':False]
['text':'      using Fn = int32_t (*)(int32_t)','line_number':683,'multiline':False]
['text':'      masm.callWithABI<Fn, Callee>();','line_number':684,'multiline':False]
['text':'','line_number':685,'multiline':False]
['text':'    In the case where the call returns a double, that needs to be','line_number':686,'multiline':False]
['text':'    indicated to the callWithABI like this:','line_number':687,'multiline':False]
['text':'','line_number':688,'multiline':False]
['text':'      using Fn = double (*)(int32_t)','line_number':689,'multiline':False]
['text':'      masm.callWithABI<Fn, Callee>(MoveOp::DOUBLE);','line_number':690,'multiline':False]
['text':'','line_number':691,'multiline':False]
['text':'    There are overloads to allow calls to registers and addresses.','line_number':692,'multiline':False]
['text':'','line_number':693,'multiline':False]
['text':' 5) Take care of the ReturnReg or ReturnDoubleReg','line_number':694,'multiline':False]
['text':'','line_number':695,'multiline':False]
['text':'      masm.mov(ReturnReg, scratch1);','line_number':696,'multiline':False]
['text':'','line_number':697,'multiline':False]
['text':' 6) Restore the potentially clobbered volatile registers','line_number':698,'multiline':False]
['text':'','line_number':699,'multiline':False]
['text':'      masm.PopRegsInMask(volatileRegs);','line_number':700,'multiline':False]
['text':'','line_number':701,'multiline':False]
['text':'    If expecting a returned value, this call should use','line_number':702,'multiline':False]
['text':'    PopRegsInMaskIgnore to filter out the registers which are containing','line_number':703,'multiline':False]
['text':'    the returned value.','line_number':704,'multiline':False]
['text':'','line_number':705,'multiline':False]
['text':' Unless an exit frame is pushed prior to the setupABICall, the callee','line_number':706,'multiline':False]
['text':' should not GC. To ensure this is the case callWithABI is instrumented to','line_number':707,'multiline':False]
['text':' make sure that in the default case callees are annotated with an','line_number':708,'multiline':False]
['text':' AutoUnsafeCallWithABI on the stack.','line_number':709,'multiline':False]
['text':'','line_number':710,'multiline':False]
['text':' A callWithABI can opt out of checking, if for example it is known there','line_number':711,'multiline':False]
['text':' is an exit frame, or the callee is known not to GC.','line_number':712,'multiline':False]
['text':'','line_number':713,'multiline':False]
['text':' If your callee needs to be able to GC, consider using a VMFunction, or','line_number':714,'multiline':False]
['text':' create a fake exit frame, and instrument the TraceJitExitFrame','line_number':715,'multiline':False]
['text':' accordingly.','line_number':716,'multiline':False]
['text':' Setup a call to C/C++ code, given the assumption that the framePushed','line_number':718,'multiline':False]
['text':' accruately define the state of the stack, and that the top of the stack','line_number':719,'multiline':False]
['text':' was properly aligned. Note that this only supports cdecl.','line_number':720,'multiline':False]
['text':' CRASH_ON(arm64)','line_number':721,'multiline':False]
['text':' As setupAlignedABICall, but for WebAssembly native ABI calls, which pass','line_number':723,'multiline':False]
['text':' through a builtin thunk that uses the wasm ABI. All the wasm ABI calls','line_number':724,'multiline':False]
['text':' can be native, since we always know the stack alignment a priori.','line_number':725,'multiline':False]
['text':' CRASH_ON(arm64)','line_number':726,'multiline':False]
['text':' Setup an ABI call for when the alignment is not known. This may need a','line_number':728,'multiline':False]
['text':' scratch register.','line_number':729,'multiline':False]
['text':' Arguments must be assigned to a C/C++ call in order. They are moved','line_number':732,'multiline':False]
['text':' in parallel immediately before performing the call. This process may','line_number':733,'multiline':False]
['text':' temporarily use more stack, in which case esp-relative addresses will be','line_number':734,'multiline':False]
['text':' automatically adjusted. It is extremely important that esp-relative','line_number':735,'multiline':False]
['text':' addresses are computed *after* setupABICall(). Furthermore, no','line_number':736,'multiline':False]
['text':' operations should be emitted while setting arguments.','line_number':737,'multiline':False]
['text':' Reinitialize the variables which have to be cleared before making a call','line_number':760,'multiline':False]
['text':' with callWithABI.','line_number':761,'multiline':False]
['text':' Reinitialize the variables which have to be cleared before making a call','line_number':765,'multiline':False]
['text':' with native abi.','line_number':766,'multiline':False]
['text':' Reserve the stack and resolve the arguments move.','line_number':769,'multiline':False]
['text':' Emits a call to a C/C++ function, resolving all argument moves.','line_number':773,'multiline':False]
['text':' Restore the stack to its state before the setup function call.','line_number':779,'multiline':False]
['text':' Create the signature to be able to decode the arguments of a native','line_number':783,'multiline':False]
['text':' function, when calling a function within the simulator.','line_number':784,'multiline':False]
['text':' Private variables used to handle moves between registers given as','line_number':788,'multiline':False]
['text':' arguments to passABIArg and the list of ABI registers expected for the','line_number':789,'multiline':False]
['text':' signature of the function.','line_number':790,'multiline':False]
['text':' Architecture specific implementation which specify how registers & stack','line_number':793,'multiline':False]
['text':' offsets are used for calling a function.','line_number':794,'multiline':False]
['text':' Flag use to assert that we use ABI function in the right context.','line_number':798,'multiline':False]
['text':' If set by setupUnalignedABICall then callWithABI will pop the stack','line_number':802,'multiline':False]
['text':' register which is on the stack.','line_number':803,'multiline':False]
['text':' The signature is used to accumulate all types of arguments which are used','line_number':807,'multiline':False]
['text':' by the caller. This is used by the simulators to decode the arguments','line_number':808,'multiline':False]
['text':' properly, and cast the function pointer to the right type.','line_number':809,'multiline':False]
['text':' ===============================================================','line_number':814,'multiline':False]
['text':' Jit Frames.','line_number':815,'multiline':False]
['text':'','line_number':816,'multiline':False]
['text':' These functions are used to build the content of the Jit frames.  See','line_number':817,'multiline':False]
['text':' CommonFrameLayout class, and all its derivatives. The content should be','line_number':818,'multiline':False]
['text':' pushed in the opposite order as the fields of the structures, such that','line_number':819,'multiline':False]
['text':' the structures can be used to interpret the content of the stack.','line_number':820,'multiline':False]
['text':' Call the Jit function, and push the return address (or let the callee','line_number':822,'multiline':False]
['text':' push the return address).','line_number':823,'multiline':False]
['text':'','line_number':824,'multiline':False]
['text':' These functions return the offset of the return address, in order to use','line_number':825,'multiline':False]
['text':' the return address to index the safepoints, which are used to list all','line_number':826,'multiline':False]
['text':' live registers.','line_number':827,'multiline':False]
['text':' The frame descriptor is the second field of all Jit frames, pushed before','line_number':834,'multiline':False]
['text':' calling the Jit function.  It is a composite value defined in JitFrames.h','line_number':835,'multiline':False]
['text':' Push the frame descriptor, based on the statically known framePushed.','line_number':839,'multiline':False]
['text':' Push the callee token of a JSFunction which pointer is stored in the','line_number':842,'multiline':False]
['text':' |callee| register. The callee token is packed with a |constructing| flag','line_number':843,'multiline':False]
['text':' which correspond to the fact that the JS function is called with "new" or','line_number':844,'multiline':False]
['text':' not.','line_number':845,'multiline':False]
['text':' Unpack a callee token located at the |token| address, and return the','line_number':848,'multiline':False]
['text':' JSFunction pointer in the |dest| register.','line_number':849,'multiline':False]
['text':' This function emulates a call by pushing an exit frame on the stack,','line_number':852,'multiline':False]
['text':' except that the fake-function is inlined within the body of the caller.','line_number':853,'multiline':False]
['text':'','line_number':854,'multiline':False]
['text':' This function assumes that the current frame is an IonJS frame.','line_number':855,'multiline':False]
['text':'','line_number':856,'multiline':False]
['text':' This function returns the offset of the /fake/ return address, in order to','line_number':857,'multiline':False]
['text':' use the return address to index the safepoints, which are used to list all','line_number':858,'multiline':False]
['text':' live registers.','line_number':859,'multiline':False]
['text':'','line_number':860,'multiline':False]
['text':' This function should be balanced with a call to adjustStack, to pop the','line_number':861,'multiline':False]
['text':' exit frame and emulate the return statement of the inlined function.','line_number':862,'multiline':False]
['text':' This function is used by buildFakeExitFrame to push a fake return address','line_number':866,'multiline':False]
['text':' on the stack. This fake return address should never be used for resuming','line_number':867,'multiline':False]
['text':' any execution, and can even be an invalid pointer into the instruction','line_number':868,'multiline':False]
['text':' stream, as long as it does not alias any other.','line_number':869,'multiline':False]
['text':' ===============================================================','line_number':873,'multiline':False]
['text':' Exit frame footer.','line_number':874,'multiline':False]
['text':'','line_number':875,'multiline':False]
['text':' When calling outside the Jit we push an exit frame. To mark the stack','line_number':876,'multiline':False]
['text':' correctly, we have to push additional information, called the Exit frame','line_number':877,'multiline':False]
['text':' footer, which is used to identify how the stack is marked.','line_number':878,'multiline':False]
['text':'','line_number':879,'multiline':False]
['text':' See JitFrames.h, and MarkJitExitFrame in JitFrames.cpp.','line_number':880,'multiline':False]
['text':' Push stub code and the VMFunctionData pointer.','line_number':882,'multiline':False]
['text':' Push an exit frame token to identify which fake exit frame this footer','line_number':886,'multiline':False]
['text':' corresponds to.','line_number':887,'multiline':False]
['text':' Push an exit frame token for a native call.','line_number':891,'multiline':False]
['text':' Pop ExitFrame footer in addition to the extra frame.','line_number':895,'multiline':False]
['text':' Save the top of the stack into JitActivation::packedExitFP of the','line_number':899,'multiline':False]
['text':' current thread, which should be the location of the latest exit frame.','line_number':900,'multiline':False]
['text':' ===============================================================','line_number':904,'multiline':False]
['text':' Move instructions','line_number':905,'multiline':False]
['text':' move64To32 will clear the high bits of `dest` on 64-bit systems.','line_number':921,'multiline':False]
['text':' Copy a constant, typed-register, or a ValueOperand into a ValueOperand','line_number':933,'multiline':False]
['text':' destination.','line_number':934,'multiline':False]
['text':' ===============================================================','line_number':944,'multiline':False]
['text':' Load instructions','line_number':945,'multiline':False]
['text':' ===============================================================','line_number':952,'multiline':False]
['text':' Logical instructions','line_number':953,'multiline':False]
['text':' ===============================================================','line_number':996,'multiline':False]
['text':' Swap instructions','line_number':997,'multiline':False]
['text':' Swap the two lower bytes and sign extend the result to 32-bit.','line_number':999,'multiline':False]
['text':' Swap the two lower bytes and zero extend the result to 32-bit.','line_number':1002,'multiline':False]
['text':' Swap all four bytes in a 32-bit integer.','line_number':1005,'multiline':False]
['text':' Swap all eight bytes in a 64-bit integer.','line_number':1008,'multiline':False]
['text':' ===============================================================','line_number':1011,'multiline':False]
['text':' Arithmetic functions','line_number':1012,'multiline':False]
['text':' Compute dest=SP-imm where dest is a pointer registers and not SP.  The','line_number':1042,'multiline':False]
['text':' offset returned from sub32FromStackPtrWithPatch() must be passed to','line_number':1043,'multiline':False]
['text':' patchSub32FromStackPtr().','line_number':1044,'multiline':False]
['text':' Perform an integer division, returning the integer part rounded toward','line_number':1100,'multiline':False]
['text':' zero. rhs must not be zero, and the division must not overflow.','line_number':1101,'multiline':False]
['text':'','line_number':1102,'multiline':False]
['text':' On x86_shared, srcDest must be eax and edx will be clobbered.','line_number':1103,'multiline':False]
['text':' On ARM, the chip must have hardware division instructions.','line_number':1104,'multiline':False]
['text':' Perform an integer division, returning the remainder part.','line_number':1108,'multiline':False]
['text':' rhs must not be zero, and the division must not overflow.','line_number':1109,'multiline':False]
['text':'','line_number':1110,'multiline':False]
['text':' On x86_shared, srcDest must be eax and edx will be clobbered.','line_number':1111,'multiline':False]
['text':' On ARM, the chip must have hardware division instructions.','line_number':1112,'multiline':False]
['text':' Perform an integer division, returning the integer part rounded toward','line_number':1116,'multiline':False]
['text':' zero. rhs must not be zero, and the division must not overflow.','line_number':1117,'multiline':False]
['text':'','line_number':1118,'multiline':False]
['text':' This variant preserves registers, and doesn't require hardware division','line_number':1119,'multiline':False]
['text':' instructions on ARM (will call out to a runtime routine).','line_number':1120,'multiline':False]
['text':'','line_number':1121,'multiline':False]
['text':' rhs is preserved, srdDest is clobbered.','line_number':1122,'multiline':False]
['text':' Perform an integer division, returning the integer part rounded toward','line_number':1127,'multiline':False]
['text':' zero. rhs must not be zero, and the division must not overflow.','line_number':1128,'multiline':False]
['text':'','line_number':1129,'multiline':False]
['text':' This variant preserves registers, and doesn't require hardware division','line_number':1130,'multiline':False]
['text':' instructions on ARM (will call out to a runtime routine).','line_number':1131,'multiline':False]
['text':'','line_number':1132,'multiline':False]
['text':' rhs is preserved, srdDest is clobbered.','line_number':1133,'multiline':False]
['text':' Perform an integer division, returning the integer part rounded toward','line_number':1138,'multiline':False]
['text':' zero. rhs must not be zero, and the division must not overflow. The','line_number':1139,'multiline':False]
['text':' remainder is stored into the third argument register here.','line_number':1140,'multiline':False]
['text':'','line_number':1141,'multiline':False]
['text':' This variant preserves registers, and doesn't require hardware division','line_number':1142,'multiline':False]
['text':' instructions on ARM (will call out to a runtime routine).','line_number':1143,'multiline':False]
['text':'','line_number':1144,'multiline':False]
['text':' rhs is preserved, srdDest and remOutput are clobbered.','line_number':1145,'multiline':False]
['text':' Returns a random double in range [0, 1) in |dest|. The |rng| register must','line_number':1207,'multiline':False]
['text':' hold a pointer to a mozilla::non_crypto::XorShift128PlusRNG.','line_number':1208,'multiline':False]
['text':' srcDest = {min,max}{Float32,Double}(srcDest, other)','line_number':1212,'multiline':False]
['text':' For min and max, handle NaN specially if handleNaN is true.','line_number':1213,'multiline':False]
['text':' Compute |pow(base, power)| and store the result in |dest|. If the result','line_number':1232,'multiline':False]
['text':' exceeds the int32 range, jumps to |onOver|.','line_number':1233,'multiline':False]
['text':' |base| and |power| are preserved, the other input registers are clobbered.','line_number':1234,'multiline':False]
['text':' ===============================================================','line_number':1246,'multiline':False]
['text':' Shift functions','line_number':1247,'multiline':False]
['text':' For shift-by-register there may be platform-specific variations, for','line_number':1249,'multiline':False]
['text':' example, x86 will perform the shift mod 32 but ARM will perform the shift','line_number':1250,'multiline':False]
['text':' mod 256.','line_number':1251,'multiline':False]
['text':'','line_number':1252,'multiline':False]
['text':' For shift-by-immediate the platform assembler may restrict the immediate,','line_number':1253,'multiline':False]
['text':' for example, the ARM assembler requires the count for 32-bit shifts to be','line_number':1254,'multiline':False]
['text':' in the range [0,31].','line_number':1255,'multiline':False]
['text':' On x86_shared these have the constraint that shift must be in CL.','line_number':1271,'multiline':False]
['text':' These variants do not have the above constraint, but may emit some extra','line_number':1279,'multiline':False]
['text':' instructions on x86_shared. They also handle shift >= 32 consistently by','line_number':1280,'multiline':False]
['text':' masking with 0x1F (either explicitly or relying on the hardware to do','line_number':1281,'multiline':False]
['text':' that).','line_number':1282,'multiline':False]
['text':' ===============================================================','line_number':1294,'multiline':False]
['text':' Rotation functions','line_number':1295,'multiline':False]
['text':' Note: - on x86 and x64 the count register must be in CL.','line_number':1296,'multiline':False]
['text':'       - on x64 the temp register should be InvalidReg.','line_number':1297,'multiline':False]
['text':' ===============================================================','line_number':1325,'multiline':False]
['text':' Bit counting functions','line_number':1326,'multiline':False]
['text':' knownNotZero may be true only if the src is known not to be zero.','line_number':1328,'multiline':False]
['text':' On x86_shared, temp may be Invalid only if the chip has the POPCNT','line_number':1337,'multiline':False]
['text':' instruction. On ARM, temp may never be Invalid.','line_number':1338,'multiline':False]
['text':' temp may be invalid only if the chip has the POPCNT instruction.','line_number':1342,'multiline':False]
['text':' ===============================================================','line_number':1345,'multiline':False]
['text':' Condition functions','line_number':1346,'multiline':False]
['text':' ===============================================================','line_number':1355,'multiline':False]
['text':' Branch functions','line_number':1356,'multiline':False]
['text':' The supported condition are Equal, NotEqual, LessThan(orEqual),','line_number':1394,'multiline':False]
['text':' GreaterThan(orEqual), Below(orEqual) and Above(orEqual). When a fail label','line_number':1395,'multiline':False]
['text':' is not defined it will fall through to next instruction, else jump to the','line_number':1396,'multiline':False]
['text':' fail label.','line_number':1397,'multiline':False]
['text':' On x86 and x64 NotEqual and Equal conditions are allowed for the branch64','line_number':1402,'multiline':False]
['text':' variants with Address as lhs. On others only the NotEqual condition.','line_number':1403,'multiline':False]
['text':' Compare the value at |lhs| with the value at |rhs|.  The scratch','line_number':1407,'multiline':False]
['text':' register *must not* be the base of |lhs| or |rhs|.','line_number':1408,'multiline':False]
['text':' Given a pointer to a GC Cell, retrieve the StoreBuffer pointer from its','line_number':1450,'multiline':False]
['text':' chunk header, or nullptr if it is in the tenured heap.','line_number':1451,'multiline':False]
['text':' This function compares a Value (lhs) which is having a private pointer','line_number':1464,'multiline':False]
['text':' boxed inside a js::Value, with a raw pointer (rhs).','line_number':1465,'multiline':False]
['text':' Truncate a double/float32 to int32 and when it doesn't fit an int32 it will','line_number':1472,'multiline':False]
['text':' jump to the failure label. This particular variant is allowed to return the','line_number':1473,'multiline':False]
['text':' value module 2**32, which isn't implemented on all architectures. E.g. the','line_number':1474,'multiline':False]
['text':' x64 variants will do this only in the int64_t range.','line_number':1475,'multiline':False]
['text':' Truncate a double/float32 to intptr and when it doesn't fit jump to the','line_number':1483,'multiline':False]
['text':' failure label.','line_number':1484,'multiline':False]
['text':' Truncate a double/float32 to int32 and when it doesn't fit jump to the','line_number':1490,'multiline':False]
['text':' failure label.','line_number':1491,'multiline':False]
['text':' Branches to |label| if |reg| is false. |reg| should be a C++ bool.','line_number':1565,'multiline':False]
['text':' Branches to |label| if |reg| is true. |reg| should be a C++ bool.','line_number':1569,'multiline':False]
['text':' Loads the function length. This handles interpreted, native, and bound','line_number':1599,'multiline':False]
['text':' functions. The caller is responsible for checking that INTERPRETED_LAZY and','line_number':1600,'multiline':False]
['text':' RESOLVED_LENGTH flags are not set.','line_number':1601,'multiline':False]
['text':' Loads the function name. This handles interpreted, native, and bound','line_number':1605,'multiline':False]
['text':' functions.','line_number':1606,'multiline':False]
['text':' For all methods below: spectreRegToZero is a register that will be zeroed','line_number':1617,'multiline':False]
['text':' on speculatively executed code paths (when the branch should be taken but','line_number':1618,'multiline':False]
['text':' branch prediction speculates it isn't). Usually this will be the object','line_number':1619,'multiline':False]
['text':' register but the caller may pass a different register.','line_number':1620,'multiline':False]
['text':' TODO: audit/fix callers to be Spectre safe.','line_number':1660,'multiline':False]
['text':' Perform a type-test on a tag of a Value (32bits boxing), or the tagged','line_number':1690,'multiline':False]
['text':' value (64bits boxing).','line_number':1691,'multiline':False]
['text':' Perform a type-test on a Value, addressed by Address or BaseIndex, or','line_number':1719,'multiline':False]
['text':' loaded into ValueOperand.','line_number':1720,'multiline':False]
['text':' BaseIndex and ValueOperand variants clobber the ScratchReg on x64.','line_number':1721,'multiline':False]
['text':' All Variants clobber the ScratchReg on arm64.','line_number':1722,'multiline':False]
['text':' Clobbers the ScratchReg on x64.','line_number':1791,'multiline':False]
['text':' Checks if given Value is evaluated to true or false in a condition.','line_number':1832,'multiline':False]
['text':' The type of the value should match the type of the method.','line_number':1833,'multiline':False]
['text':' Create an unconditional branch to the address given as argument.','line_number':1848,'multiline':False]
['text':' The fallibleUnbox* methods below combine a Value type check with an unbox.','line_number':1904,'multiline':False]
['text':' Especially on 64-bit platforms this can be implemented more efficiently','line_number':1905,'multiline':False]
['text':' than a separate branch + unbox.','line_number':1906,'multiline':False]
['text':'','line_number':1907,'multiline':False]
['text':' |src| and |dest| can be the same register, but |dest| may hold garbage on','line_number':1908,'multiline':False]
['text':' failure.','line_number':1909,'multiline':False]
['text':' Conditional move for Spectre mitigations.','line_number':1967,'multiline':False]
['text':' Zeroes dest if the condition is true.','line_number':1971,'multiline':False]
['text':' Performs a bounds check and zeroes the index register if out-of-bounds','line_number':1976,'multiline':False]
['text':' (to mitigate Spectre).','line_number':1977,'multiline':False]
['text':' ========================================================================','line_number':1998,'multiline':False]
['text':' Canonicalization primitives.','line_number':1999,'multiline':False]
['text':' ========================================================================','line_number':2007,'multiline':False]
['text':' Memory access primitives.','line_number':2008,'multiline':False]
['text':' ========================================================================','line_number':2045,'multiline':False]
['text':' Wasm SIMD','line_number':2046,'multiline':False]
['text':'','line_number':2047,'multiline':False]
['text':' Naming is "operationSimd128" when operate on the whole vector, otherwise','line_number':2048,'multiline':False]
['text':' it's "operation<Type><Size>x<Lanes>".','line_number':2049,'multiline':False]
['text':'','line_number':2050,'multiline':False]
['text':' For microarchitectural reasons we can in principle get a performance win by','line_number':2051,'multiline':False]
['text':' using int or float specific instructions in the operationSimd128 case when','line_number':2052,'multiline':False]
['text':' we know that subsequent operations on the result are int or float oriented.','line_number':2053,'multiline':False]
['text':' In practice, we don't care about that yet.','line_number':2054,'multiline':False]
['text':'','line_number':2055,'multiline':False]
['text':' The order of operations here follows those in the SIMD overview document,','line_number':2056,'multiline':False]
['text':' https://github.com/WebAssembly/simd/blob/master/proposals/simd/SIMD.md.','line_number':2057,'multiline':False]
['text':'','line_number':2058,'multiline':False]
['text':' Since we must target Intel SSE indefinitely and SSE is one-address or','line_number':2059,'multiline':False]
['text':' two-address, the x86 porting interfaces are nearly all one-address or','line_number':2060,'multiline':False]
['text':' two-address.  Likewise there are two-address ARM64 interfaces to support','line_number':2061,'multiline':False]
['text':' the baseline compiler.  But there are also three-address ARM64 interfaces','line_number':2062,'multiline':False]
['text':' as the ARM64 Ion back-end can use those.  In the future, they may support','line_number':2063,'multiline':False]
['text':' AVX2 or similar for x86.','line_number':2064,'multiline':False]
['text':'','line_number':2065,'multiline':False]
['text':' Conventions for argument order and naming and semantics:','line_number':2066,'multiline':False]
['text':'  - Condition codes come first.','line_number':2067,'multiline':False]
['text':'  - Other immediates (masks, shift counts) come next.','line_number':2068,'multiline':False]
['text':'  - Operands come next:','line_number':2069,'multiline':False]
['text':'    - For a binary two-address operator where the left-hand-side has the','line_number':2070,'multiline':False]
['text':'      same type as the result, one register parameter is normally named','line_number':2071,'multiline':False]
['text':'      `lhsDest` and is both the left-hand side and destination; the other','line_number':2072,'multiline':False]
['text':'      parameter is named `rhs` and is the right-hand side.  `rhs` comes','line_number':2073,'multiline':False]
['text':'      first, `lhsDest` second.  `rhs` and `lhsDest` may be the same register','line_number':2074,'multiline':False]
['text':'      (if rhs is a register).','line_number':2075,'multiline':False]
['text':'    - For a binary three-address operator the order is `lhs`, `rhs`, `dest`,','line_number':2076,'multiline':False]
['text':'      and generally these registers may be the same.','line_number':2077,'multiline':False]
['text':'    - For a unary operator, the input is named `src` and the output is named','line_number':2078,'multiline':False]
['text':'      `dest`.  `src` comes first, `dest` second.  `src` and `dest` may be','line_number':2079,'multiline':False]
['text':'      the same register (if `src` is a register).','line_number':2080,'multiline':False]
['text':'  - Temp registers follow operands and are named `temp` if there's only one,','line_number':2081,'multiline':False]
['text':'    otherwise `temp1`, `temp2`, etc regardless of type.  GPR temps precede','line_number':2082,'multiline':False]
['text':'    FPU temps.  If there are several temps then they must be distinct','line_number':2083,'multiline':False]
['text':'    registers, and they must be distinct from the operand registers unless','line_number':2084,'multiline':False]
['text':'    noted.','line_number':2085,'multiline':False]
['text':' Moves','line_number':2087,'multiline':False]
['text':' Constants','line_number':2092,'multiline':False]
['text':' Splat','line_number':2099,'multiline':False]
['text':' Extract lane as scalar.  Float extraction does not canonicalize the value.','line_number':2125,'multiline':False]
['text':' Replace lane value','line_number':2155,'multiline':False]
['text':' Shuffle - blend and permute with immediate indices, and its many','line_number':2181,'multiline':False]
['text':' specializations.  Lane values other than those mentioned are illegal.','line_number':2182,'multiline':False]
['text':' lane values 0..31','line_number':2184,'multiline':False]
['text':' Lane values must be 0 (select from lhs) or FF (select from rhs).','line_number':2193,'multiline':False]
['text':' The behavior is undefined for lane values that are neither 0 nor FF.','line_number':2194,'multiline':False]
['text':' on x86_shared: it is required that lhs == dest.','line_number':2195,'multiline':False]
['text':' Lane values must be 0 (select from lhs) or FF (select from rhs).','line_number':2200,'multiline':False]
['text':' The behavior is undefined for lane values that are neither 0 nor FF.','line_number':2201,'multiline':False]
['text':' Lane values must be 0 (select from lhs) or FFFF (select from rhs).','line_number':2206,'multiline':False]
['text':' The behavior is undefined for lane values that are neither 0 nor FFFF.','line_number':2207,'multiline':False]
['text':' on x86_shared: it is required that lhs == dest.','line_number':2208,'multiline':False]
['text':' Permute - permute with immediate indices.','line_number':2261,'multiline':False]
['text':' lane values 0..15','line_number':2263,'multiline':False]
['text':' lane values 0..7','line_number':2267,'multiline':False]
['text':' lane values 0..3 [sic].','line_number':2271,'multiline':False]
['text':' lane values 0..3.','line_number':2275,'multiline':False]
['text':' lane values 0..3','line_number':2279,'multiline':False]
['text':' Funnel shift by immediate count:','line_number':2283,'multiline':False]
['text':'   low_16_bytes_of((lhsDest ++ rhs) >> shift*8), shift must be < 32.','line_number':2284,'multiline':False]
['text':' Funnel shift by immediate count:','line_number':2289,'multiline':False]
['text':'   low_16_bytes_of((lhs ++ rhs) >> shift*8), shift must be < 16','line_number':2290,'multiline':False]
['text':' Rotate right by immediate count:','line_number':2295,'multiline':False]
['text':'   low_16_bytes_of((src ++ src) >> shift*8), shift must be < 16','line_number':2296,'multiline':False]
['text':' Shift bytes with immediate count, shifting in zeroes.  Shift count 0..15.','line_number':2300,'multiline':False]
['text':' Swizzle - permute with variable indices.  `rhs` holds the lanes parameter.','line_number':2310,'multiline':False]
['text':' Integer Add','line_number':2318,'multiline':False]
['text':' Integer Subtract','line_number':2356,'multiline':False]
['text':' Integer Multiply','line_number':2394,'multiline':False]
['text':' On x86_shared, it is required lhs == dest','line_number':2414,'multiline':False]
['text':' Note for the extMul opcodes, the NxM designation is for the input lanes;','line_number':2423,'multiline':False]
['text':' the output lanes are twice as wide.','line_number':2424,'multiline':False]
['text':' Integer Negate','line_number':2506,'multiline':False]
['text':' Saturating integer add','line_number':2520,'multiline':False]
['text':' Saturating integer subtract','line_number':2560,'multiline':False]
['text':' Lane-wise integer minimum','line_number':2600,'multiline':False]
['text':' Lane-wise integer maximum','line_number':2656,'multiline':False]
['text':' Lane-wise integer rounding average','line_number':2712,'multiline':False]
['text':' Lane-wise integer absolute value','line_number':2726,'multiline':False]
['text':' Left shift by scalar.  Immediates must have been masked; shifts of zero','line_number':2740,'multiline':False]
['text':' will work but may or may not generate code.','line_number':2741,'multiline':False]
['text':' Right shift by scalar.  Immediates must have been masked; shifts of zero','line_number':2784,'multiline':False]
['text':' will work but may or may not generate code.','line_number':2785,'multiline':False]
['text':' Sign replication operation','line_number':2870,'multiline':False]
['text':' Bitwise and, or, xor, not','line_number':2884,'multiline':False]
['text':' Bitwise AND with compliment: dest = lhs & ~rhs, note only arm64 can do it.','line_number':2916,'multiline':False]
['text':' Bitwise AND with complement: dest = ~lhs & rhs, note this is not what Wasm','line_number':2920,'multiline':False]
['text':' wants but what the x86 hardware offers.  Hence the name.','line_number':2921,'multiline':False]
['text':' Bitwise select','line_number':2926,'multiline':False]
['text':' Population count','line_number':2935,'multiline':False]
['text':' Any lane true, ie, any bit set','line_number':2943,'multiline':False]
['text':' All lanes true','line_number':2948,'multiline':False]
['text':' Bitmask, ie extract and compress high bits of all lanes','line_number':2962,'multiline':False]
['text':' Comparisons (integer and floating-point)','line_number':2988,'multiline':False]
['text':' On x86_shared, limited to !=, ==, <=, >','line_number':2994,'multiline':False]
['text':' On arm64, use any integer comparison condition.','line_number':2998,'multiline':False]
['text':' On x86_shared, limited to !=, ==, <=, >','line_number':3011,'multiline':False]
['text':' On x86_shared, limited to !=, ==, <=, >','line_number':3015,'multiline':False]
['text':' On arm64, use any integer comparison condition.','line_number':3020,'multiline':False]
['text':' On x86_shared, limited to ==, !=, <, <=','line_number':3048,'multiline':False]
['text':' On arm64, use any float-point comparison condition.','line_number':3053,'multiline':False]
['text':' On x86_shared, limited to ==, !=, <, <=','line_number':3062,'multiline':False]
['text':' On arm64, use any float-point comparison condition.','line_number':3067,'multiline':False]
['text':' Load','line_number':3072,'multiline':False]
['text':' Store','line_number':3083,'multiline':False]
['text':' Floating point negation','line_number':3091,'multiline':False]
['text':' Floating point absolute value','line_number':3099,'multiline':False]
['text':' NaN-propagating minimum','line_number':3107,'multiline':False]
['text':' NaN-propagating maximum','line_number':3129,'multiline':False]
['text':' Floating add','line_number':3151,'multiline':False]
['text':' Floating subtract','line_number':3171,'multiline':False]
['text':' Floating division','line_number':3191,'multiline':False]
['text':' Floating Multiply','line_number':3211,'multiline':False]
['text':' Pairwise add','line_number':3231,'multiline':False]
['text':' Floating square root','line_number':3247,'multiline':False]
['text':' Integer to floating point with rounding','line_number':3255,'multiline':False]
['text':' Floating point to integer with saturation','line_number':3271,'multiline':False]
['text':' Floating point narrowing','line_number':3294,'multiline':False]
['text':' Floating point widening','line_number':3299,'multiline':False]
['text':' Integer to integer narrowing','line_number':3304,'multiline':False]
['text':' Integer to integer widening','line_number':3344,'multiline':False]
['text':' Compare-based minimum/maximum','line_number':3382,'multiline':False]
['text':'','line_number':3383,'multiline':False]
['text':' On x86, the signature is (rhsDest, lhs); on arm64 it is (rhs, lhsDest).','line_number':3384,'multiline':False]
['text':'','line_number':3385,'multiline':False]
['text':' The masm preprocessor can't deal with multiple declarations with identical','line_number':3386,'multiline':False]
['text':' signatures even if they are on different platforms, hence the weird','line_number':3387,'multiline':False]
['text':' argument names.','line_number':3388,'multiline':False]
['text':' Widening/pairwise integer dot product','line_number':3418,'multiline':False]
['text':' Floating point rounding','line_number':3429,'multiline':False]
['text':' ========================================================================','line_number':3456,'multiline':False]
['text':' Truncate floating point.','line_number':3457,'multiline':False]
['text':' Undefined behaviour when truncation is outside Int64 range.','line_number':3459,'multiline':False]
['text':' Needs a temp register if SSE3 is not present.','line_number':3460,'multiline':False]
['text':' ========================================================================','line_number':3473,'multiline':False]
['text':' Convert floating point.','line_number':3474,'multiline':False]
['text':' temp required on x86 and x64; must be undefined on mips64.','line_number':3476,'multiline':False]
['text':' temp required when convertUInt64ToDoubleNeedsTemp() returns true.','line_number':3485,'multiline':False]
['text':' ========================================================================','line_number':3494,'multiline':False]
['text':' wasm support','line_number':3495,'multiline':False]
['text':' Returns a pair: the offset of the undefined (trapping) instruction, and','line_number':3505,'multiline':False]
['text':' the number of extra bytes of stack allocated prior to the trap','line_number':3506,'multiline':False]
['text':' instruction proper.','line_number':3507,'multiline':False]
['text':' Emit a bounds check against the wasm heap limit, jumping to 'label' if','line_number':3511,'multiline':False]
['text':' 'cond' holds. If JitOptions.spectreMaskIndex is true, in speculative','line_number':3512,'multiline':False]
['text':' executions 'index' is saturated in-place to 'boundsCheckLimit'.','line_number':3513,'multiline':False]
['text':'','line_number':3514,'multiline':False]
['text':' On 32-bit systems for both wasm and asm.js, and on 64-bit systems for','line_number':3515,'multiline':False]
['text':' asm.js, heap lengths are limited to 2GB.  On 64-bit systems for wasm,','line_number':3516,'multiline':False]
['text':' 32-bit heap lengths are limited to 4GB, and 64-bit heap lengths will be','line_number':3517,'multiline':False]
['text':' limited to something much larger.','line_number':3518,'multiline':False]
['text':' Each wasm load/store instruction appends its own wasm::Trap::OutOfBounds.','line_number':3536,'multiline':False]
['text':' For all the ARM/MIPS wasmLoad and wasmStore functions below, `ptr`','line_number':3546,'multiline':False]
['text':' MUST equal `ptrScratch`, and that register will be updated based on','line_number':3547,'multiline':False]
['text':' conditions listed below (where it is only mentioned as `ptr`).','line_number':3548,'multiline':False]
['text':' `ptr` will be updated if access.offset() != 0 or access.type() ==','line_number':3550,'multiline':False]
['text':' Scalar::Int64.','line_number':3551,'multiline':False]
['text':' These accept general memoryBase + ptr + offset (in `access`); the offset is','line_number':3565,'multiline':False]
['text':' always smaller than the guard region.  They will insert an additional add','line_number':3566,'multiline':False]
['text':' if the offset is nonzero, and of course that add may require a temporary','line_number':3567,'multiline':False]
['text':' register for the offset if the offset is large, and instructions to set it','line_number':3568,'multiline':False]
['text':' up.','line_number':3569,'multiline':False]
['text':' `ptr` will always be updated.','line_number':3579,'multiline':False]
['text':' MIPS: `ptr` will always be updated.','line_number':3585,'multiline':False]
['text':' `ptr` will always be updated.','line_number':3592,'multiline':False]
['text':' MIPS: `ptr` will always be updated.','line_number':3598,'multiline':False]
['text':' `ptr` will always be updated.','line_number':3604,'multiline':False]
['text':' `ptr` will always be updated.','line_number':3610,'multiline':False]
['text':' wasm specific methods, used in both the wasm baseline compiler and ion.','line_number':3616,'multiline':False]
['text':' The truncate-to-int32 methods do not bind the rejoin label; clients must','line_number':3618,'multiline':False]
['text':' do so if oolWasmTruncateCheckF64ToI32() can jump to it.','line_number':3619,'multiline':False]
['text':' The truncate-to-int64 methods will always bind the `oolRejoin` label','line_number':3640,'multiline':False]
['text':' after the last emitted instruction.','line_number':3641,'multiline':False]
['text':' This function takes care of loading the callee's TLS and pinned regs but','line_number':3668,'multiline':False]
['text':' it is the caller's responsibility to save/restore TLS or pinned regs.','line_number':3669,'multiline':False]
['text':' WasmTableCallIndexReg must contain the index of the indirect call.','line_number':3673,'multiline':False]
['text':' This function takes care of loading the pointer to the current instance','line_number':3678,'multiline':False]
['text':' as the implicit first argument. It preserves TLS and pinned registers.','line_number':3679,'multiline':False]
['text':' (TLS & pinned regs are non-volatile registers in the system ABI).','line_number':3680,'multiline':False]
['text':' As enterFakeExitFrame(), but using register conventions appropriate for','line_number':3686,'multiline':False]
['text':' wasm stubs.','line_number':3687,'multiline':False]
['text':' ========================================================================','line_number':3692,'multiline':False]
['text':' Barrier functions.','line_number':3693,'multiline':False]
['text':' ========================================================================','line_number':3699,'multiline':False]
['text':' Clamping functions.','line_number':3700,'multiline':False]
['text':' ========================================================================','line_number':3705,'multiline':False]
['text':' Primitive atomic operations.','line_number':3706,'multiline':False]
['text':'','line_number':3707,'multiline':False]
['text':' If the access is from JS and the eventual destination of the result is a','line_number':3708,'multiline':False]
['text':' js::Value, it's probably best to use the JS-specific versions of these,','line_number':3709,'multiline':False]
['text':' see further below.','line_number':3710,'multiline':False]
['text':'','line_number':3711,'multiline':False]
['text':' Temp registers must be defined unless otherwise noted in the per-function','line_number':3712,'multiline':False]
['text':' constraints.','line_number':3713,'multiline':False]
['text':' 8-bit, 16-bit, and 32-bit wide operations.','line_number':3715,'multiline':False]
['text':'','line_number':3716,'multiline':False]
['text':' The 8-bit and 16-bit operations zero-extend or sign-extend the result to','line_number':3717,'multiline':False]
['text':' 32 bits, according to `type`. On 64-bit systems, the upper 32 bits of the','line_number':3718,'multiline':False]
['text':' result will be zero on some platforms (eg, on x64) and will be the sign','line_number':3719,'multiline':False]
['text':' extension of the lower bits on other platforms (eg, MIPS).','line_number':3720,'multiline':False]
['text':' CompareExchange with memory.  Return the value that was in memory,','line_number':3722,'multiline':False]
['text':' whether we wrote or not.','line_number':3723,'multiline':False]
['text':'','line_number':3724,'multiline':False]
['text':' x86-shared: `output` must be eax.','line_number':3725,'multiline':False]
['text':' MIPS: `valueTemp`, `offsetTemp` and `maskTemp` must be defined for 8-bit','line_number':3726,'multiline':False]
['text':' and 16-bit wide operations.','line_number':3727,'multiline':False]
['text':' x86: `expected` and `output` must be edx:eax; `replacement` is ecx:ebx.','line_number':3751,'multiline':False]
['text':' x64: `output` must be rax.','line_number':3752,'multiline':False]
['text':' ARM: Registers must be distinct; `replacement` and `output` must be','line_number':3753,'multiline':False]
['text':' (even,odd) pairs.','line_number':3754,'multiline':False]
['text':' Exchange with memory.  Return the value initially in memory.','line_number':3766,'multiline':False]
['text':' MIPS: `valueTemp`, `offsetTemp` and `maskTemp` must be defined for 8-bit','line_number':3767,'multiline':False]
['text':' and 16-bit wide operations.','line_number':3768,'multiline':False]
['text':' x86: `value` must be ecx:ebx; `output` must be edx:eax.','line_number':3788,'multiline':False]
['text':' ARM: `value` and `output` must be distinct and (even,odd) pairs.','line_number':3789,'multiline':False]
['text':' ARM64: `value` and `output` must be distinct.','line_number':3790,'multiline':False]
['text':' Read-modify-write with memory.  Return the value in memory before the','line_number':3800,'multiline':False]
['text':' operation.','line_number':3801,'multiline':False]
['text':'','line_number':3802,'multiline':False]
['text':' x86-shared:','line_number':3803,'multiline':False]
['text':'   For 8-bit operations, `value` and `output` must have a byte subregister.','line_number':3804,'multiline':False]
['text':'   For Add and Sub, `temp` must be invalid.','line_number':3805,'multiline':False]
['text':'   For And, Or, and Xor, `output` must be eax and `temp` must have a byte','line_number':3806,'multiline':False]
['text':'   subregister.','line_number':3807,'multiline':False]
['text':'','line_number':3808,'multiline':False]
['text':' ARM: Registers `value` and `output` must differ.','line_number':3809,'multiline':False]
['text':' MIPS: `valueTemp`, `offsetTemp` and `maskTemp` must be defined for 8-bit','line_number':3810,'multiline':False]
['text':' and 16-bit wide operations; `value` and `output` must differ.','line_number':3811,'multiline':False]
['text':' x86:','line_number':3841,'multiline':False]
['text':'   `temp` must be ecx:ebx; `output` must be edx:eax.','line_number':3842,'multiline':False]
['text':' x64:','line_number':3843,'multiline':False]
['text':'   For Add and Sub, `temp` is ignored.','line_number':3844,'multiline':False]
['text':'   For And, Or, and Xor, `output` must be rax.','line_number':3845,'multiline':False]
['text':' ARM:','line_number':3846,'multiline':False]
['text':'   `temp` and `output` must be (even,odd) pairs and distinct from `value`.','line_number':3847,'multiline':False]
['text':' ARM64:','line_number':3848,'multiline':False]
['text':'   Registers `value`, `temp`, and `output` must all differ.','line_number':3849,'multiline':False]
['text':' x64:','line_number':3867,'multiline':False]
['text':'   `value` can be any register.','line_number':3868,'multiline':False]
['text':' ARM:','line_number':3869,'multiline':False]
['text':'   `temp` must be an (even,odd) pair and distinct from `value`.','line_number':3870,'multiline':False]
['text':' ARM64:','line_number':3871,'multiline':False]
['text':'   Registers `value` and `temp` must differ.','line_number':3872,'multiline':False]
['text':' 64-bit atomic load. On 64-bit systems, use regular load with','line_number':3888,'multiline':False]
['text':' Synchronization::Load, not this method.','line_number':3889,'multiline':False]
['text':'','line_number':3890,'multiline':False]
['text':' x86: `temp` must be ecx:ebx; `output` must be edx:eax.','line_number':3891,'multiline':False]
['text':' ARM: `output` must be (even,odd) pair.','line_number':3892,'multiline':False]
['text':' 64-bit atomic store. On 64-bit systems, use regular store with','line_number':3906,'multiline':False]
['text':' Synchronization::Store, not this method.','line_number':3907,'multiline':False]
['text':'','line_number':3908,'multiline':False]
['text':' x86: `value` must be ecx:ebx; `temp` must be edx:eax.','line_number':3909,'multiline':False]
['text':' ARM: `value` and `temp` must be (even,odd) pairs.','line_number':3910,'multiline':False]
['text':' ========================================================================','line_number':3918,'multiline':False]
['text':' Wasm atomic operations.','line_number':3919,'multiline':False]
['text':'','line_number':3920,'multiline':False]
['text':' Constraints, when omitted, are exactly as for the primitive operations','line_number':3921,'multiline':False]
['text':' above.','line_number':3922,'multiline':False]
['text':' Read-modify-write with memory.  Return no value.','line_number':3993,'multiline':False]
['text':'','line_number':3994,'multiline':False]
['text':' MIPS: `valueTemp`, `offsetTemp` and `maskTemp` must be defined for 8-bit','line_number':3995,'multiline':False]
['text':' and 16-bit wide operations.','line_number':3996,'multiline':False]
['text':' 64-bit wide operations.','line_number':4024,'multiline':False]
['text':' 64-bit atomic load.  On 64-bit systems, use regular wasm load with','line_number':4026,'multiline':False]
['text':' Synchronization::Load, not this method.','line_number':4027,'multiline':False]
['text':'','line_number':4028,'multiline':False]
['text':' x86: `temp` must be ecx:ebx; `output` must be edx:eax.','line_number':4029,'multiline':False]
['text':' ARM: `temp` should be invalid; `output` must be (even,odd) pair.','line_number':4030,'multiline':False]
['text':' MIPS32: `temp` should be invalid.','line_number':4031,'multiline':False]
['text':' x86: `expected` must be the same as `output`, and must be edx:eax.','line_number':4041,'multiline':False]
['text':' x86: `replacement` must be ecx:ebx.','line_number':4042,'multiline':False]
['text':' x64: `output` must be rax.','line_number':4043,'multiline':False]
['text':' ARM: Registers must be distinct; `replacement` and `output` must be','line_number':4044,'multiline':False]
['text':' (even,odd) pairs.','line_number':4045,'multiline':False]
['text':' ARM64: The base register in `mem` must not overlap `output`.','line_number':4046,'multiline':False]
['text':' MIPS: Registers must be distinct.','line_number':4047,'multiline':False]
['text':' x86: `value` must be ecx:ebx; `output` must be edx:eax.','line_number':4059,'multiline':False]
['text':' ARM: Registers must be distinct; `value` and `output` must be (even,odd)','line_number':4060,'multiline':False]
['text':' pairs.','line_number':4061,'multiline':False]
['text':' MIPS: Registers must be distinct.','line_number':4062,'multiline':False]
['text':' x86: `output` must be edx:eax, `temp` must be ecx:ebx.','line_number':4072,'multiline':False]
['text':' x64: For And, Or, and Xor `output` must be rax.','line_number':4073,'multiline':False]
['text':' ARM: Registers must be distinct; `temp` and `output` must be (even,odd)','line_number':4074,'multiline':False]
['text':' pairs.','line_number':4075,'multiline':False]
['text':' MIPS: Registers must be distinct.','line_number':4076,'multiline':False]
['text':' MIPS32: `temp` should be invalid.','line_number':4077,'multiline':False]
['text':' Here `value` can be any register.','line_number':4097,'multiline':False]
['text':' ========================================================================','line_number':4107,'multiline':False]
['text':' JS atomic operations.','line_number':4108,'multiline':False]
['text':'','line_number':4109,'multiline':False]
['text':' Here the arrayType must be a type that is valid for JS.  As of 2017 that','line_number':4110,'multiline':False]
['text':' is an 8-bit, 16-bit, or 32-bit integer type.','line_number':4111,'multiline':False]
['text':'','line_number':4112,'multiline':False]
['text':' If arrayType is Scalar::Uint32 then:','line_number':4113,'multiline':False]
['text':'','line_number':4114,'multiline':False]
['text':'   - `output` must be a float register','line_number':4115,'multiline':False]
['text':'   - if the operation takes one temp register then `temp` must be defined','line_number':4116,'multiline':False]
['text':'   - if the operation takes two temp registers then `temp2` must be defined.','line_number':4117,'multiline':False]
['text':'','line_number':4118,'multiline':False]
['text':' Otherwise `output` must be a GPR and `temp`/`temp2` should be InvalidReg.','line_number':4119,'multiline':False]
['text':' (`temp1` must always be valid.)','line_number':4120,'multiline':False]
['text':'','line_number':4121,'multiline':False]
['text':' For additional register constraints, see the primitive 32-bit operations','line_number':4122,'multiline':False]
['text':' and/or wasm operations above.','line_number':4123,'multiline':False]
['text':' ========================================================================','line_number':4226,'multiline':False]
['text':' Spectre Mitigations.','line_number':4227,'multiline':False]
['text':'','line_number':4228,'multiline':False]
['text':' Spectre attacks are side-channel attacks based on cache pollution or','line_number':4229,'multiline':False]
['text':' slow-execution of some instructions. We have multiple spectre mitigations','line_number':4230,'multiline':False]
['text':' possible:','line_number':4231,'multiline':False]
['text':'','line_number':4232,'multiline':False]
['text':'   - Stop speculative executions, with memory barriers. Memory barriers','line_number':4233,'multiline':False]
['text':'     force all branches depending on loads to be resolved, and thus','line_number':4234,'multiline':False]
['text':'     resolve all miss-speculated paths.','line_number':4235,'multiline':False]
['text':'','line_number':4236,'multiline':False]
['text':'   - Use conditional move instructions. Some CPUs have a branch predictor,','line_number':4237,'multiline':False]
['text':'     and not a flag predictor. In such cases, using a conditional move','line_number':4238,'multiline':False]
['text':'     instruction to zero some pointer/index is enough to add a','line_number':4239,'multiline':False]
['text':'     data-dependency which prevents any futher executions until the load is','line_number':4240,'multiline':False]
['text':'     resolved.','line_number':4241,'multiline':False]
['text':' The length must be a power of two. Performs a bounds check and Spectre','line_number':4250,'multiline':False]
['text':' index masking.','line_number':4251,'multiline':False]
['text':'}}} check_macroassembler_decl_style','line_number':4256,'multiline':False]
['text':' Unsafe here means the caller is responsible for Spectre mitigations if','line_number':4258,'multiline':False]
['text':' needed. Prefer branchTestObjClass or one of the other masm helpers!','line_number':4259,'multiline':False]
['text':'*
   * Store the character in |src| to |dest|.
   ','line_number':4312,'multiline':True]
['text':'*
   * Load the character at |src| into |dest|.
   ','line_number':4324,'multiline':True]
['text':'*
   * Load the character at |chars[index + offset]| into |dest|. The optional
   * offset argument is not scaled to the character encoding.
   ','line_number':4336,'multiline':True]
['text':'*
   * Add |index| to |chars| so that |chars| now points at |chars[index]|.
   ','line_number':4343,'multiline':True]
['text':'*
   * Load the BigInt digits from |bigInt| into |digits|.
   ','line_number':4348,'multiline':True]
['text':'*
   * Load the first [u]int64 value from |bigInt| into |dest|.
   ','line_number':4353,'multiline':True]
['text':'*
   * Load the first digit from |bigInt| into |dest|. Handles the case when the
   * BigInt digits length is zero.
   *
   * Note: A BigInt digit is a pointer-sized value.
   ','line_number':4358,'multiline':True]
['text':'*
   * Load the number stored in |bigInt| into |dest|. Handles the case when the
   * BigInt digits length is zero. Jumps to |fail| when the number can't be
   * saved into a single pointer-sized register.
   ','line_number':4366,'multiline':True]
['text':'*
   * Load the number stored in |bigInt| into |dest|. Doesn't handle the case
   * when the BigInt digits length is zero. Jumps to |fail| when the number
   * can't be saved into a single pointer-sized register.
   ','line_number':4373,'multiline':True]
['text':'*
   * Load the absolute number stored in |bigInt| into |dest|. Handles the case
   * when the BigInt digits length is zero. Jumps to |fail| when the number
   * can't be saved into a single pointer-sized register.
   ','line_number':4380,'multiline':True]
['text':'*
   * In-place modifies the BigInt digit to a signed pointer-sized value. Jumps
   * to |fail| when the digit exceeds the representable range.
   ','line_number':4387,'multiline':True]
['text':'*
   * Initialize a BigInt from |val|. Clobbers |val|!
   ','line_number':4393,'multiline':True]
['text':'*
   * Initialize a BigInt from the signed, pointer-sized register |val|.
   * Clobbers |val|!
   ','line_number':4398,'multiline':True]
['text':'*
   * Initialize a BigInt from the pointer-sized register |val|.
   ','line_number':4404,'multiline':True]
['text':'*
   * Copy a BigInt. Jumps to |fail| on allocation failure or when the BigInt
   * digits need to be heap allocated.
   ','line_number':4409,'multiline':True]
['text':'*
   * Compare a BigInt and an Int32 value. Falls through to the false case.
   ','line_number':4416,'multiline':True]
['text':' reshuffle the return registers used for a call result to store into','line_number':4495,'multiline':False]
['text':' dest, using ReturnReg as a scratch register if necessary. This must','line_number':4496,'multiline':False]
['text':' only be called after returning from a call, at a point when the','line_number':4497,'multiline':False]
['text':' return register is not live. XXX would be better to allow wrappers','line_number':4498,'multiline':False]
['text':' to store the return value to different places.','line_number':4499,'multiline':False]
['text':' swap the two registers.','line_number':4502,'multiline':False]
['text':' On arm64, SP may be < PSP now (that's OK).','line_number':4544,'multiline':False]
['text':' eg testcase: tests/auto-regress/bug702915.js','line_number':4545,'multiline':False]
['text':' Like guardedCallPreBarrier, but unlike guardedCallPreBarrier this can be','line_number':4558,'multiline':False]
['text':' called from runtime-wide trampolines because it loads cx->zone (instead of','line_number':4559,'multiline':False]
['text':' baking in the current Zone) if JitContext::realm is nullptr.','line_number':4560,'multiline':False]
['text':' Inline version of js_TypedArray_uint8_clamp_double.','line_number':4659,'multiline':False]
['text':' This function clobbers the input register.','line_number':4660,'multiline':False]
['text':' Inline allocation.','line_number':4680,'multiline':False]
['text':' Compares two strings for equality based on the JSOP.','line_number':4758,'multiline':False]
['text':' This checks for identical pointers, atoms and length and fails for','line_number':4759,'multiline':False]
['text':' everything else.','line_number':4760,'multiline':False]
['text':' Result of the typeof operation. Falls back to slow-path for proxies.','line_number':4764,'multiline':False]
['text':' Implementation of IsCallable. Doesn't handle proxies.','line_number':4768,'multiline':False]
['text':' Generates code used to complete a bailout.','line_number':4796,'multiline':False]
['text':' StackPointer manipulation functions.','line_number':4803,'multiline':False]
['text':' On ARM64, the StackPointer is implemented as two synchronized registers.','line_number':4804,'multiline':False]
['text':' Code shared across platforms must use these functions to be valid.','line_number':4805,'multiline':False]
['text':' StackPointer testing functions.','line_number':4842,'multiline':False]
['text':' On ARM64, sp can function as the zero register depending on context.','line_number':4843,'multiline':False]
['text':' Code shared across platforms must use these functions to be valid.','line_number':4844,'multiline':False]
['text':' Move the stack pointer based on the requested amount.','line_number':4852,'multiline':False]
['text':' !JS_CODEGEN_ARM64','line_number':4854,'multiline':False]
['text':' This class is used to surround call sites throughout the assembler. This','line_number':4864,'multiline':False]
['text':' is used by callWithABI, and callJit functions, except if suffixed by','line_number':4865,'multiline':False]
['text':' NoProfiler.','line_number':4866,'multiline':False]
['text':' Fix up the code pointers to be written for locations where profilerCallSite','line_number':4878,'multiline':False]
['text':' emitted moves of RIP to a register.','line_number':4879,'multiline':False]
['text':' This field is used to manage profiling instrumentation output. If','line_number':4882,'multiline':False]
['text':' provided and enabled, then instrumentation will be emitted around call','line_number':4883,'multiline':False]
['text':' sites.','line_number':4884,'multiline':False]
['text':' Record locations of the call sites.','line_number':4887,'multiline':False]
['text':' Exceptions are currently handled the same way as sequential failures.','line_number':4919,'multiline':False]
['text':'','line_number':4987,'multiline':False]
['text':' Functions for converting values to int.','line_number':4988,'multiline':False]
['text':'','line_number':4989,'multiline':False]
['text':' Strings may be handled by providing labels to jump to when the behavior','line_number':4994,'multiline':False]
['text':' is truncation or clamping. The subroutine, usually an OOL call, is','line_number':4995,'multiline':False]
['text':' passed the unboxed string in |stringReg| and should convert it to a','line_number':4996,'multiline':False]
['text':' double store into |temp|.','line_number':4997,'multiline':False]
['text':' This carries over the MToNumberInt32 operation on the ValueOperand','line_number':5004,'multiline':False]
['text':' input; see comment at the top of this class.','line_number':5005,'multiline':False]
['text':' This carries over the MTruncateToInt32 operation on the ValueOperand','line_number':5017,'multiline':False]
['text':' input; see the comment at the top of this class.','line_number':5018,'multiline':False]
['text':' Truncates, i.e. removes any fractional parts, but doesn't wrap around to','line_number':5034,'multiline':False]
['text':' the int32 range.','line_number':5035,'multiline':False]
['text':' Convenience functions for clamping values to uint8.','line_number':5044,'multiline':False]
['text':' Align the stack pointer based on the number of arguments which are pushed','line_number':5056,'multiline':False]
['text':' on the stack, such that the JitFrameLayout would be correctly aligned on','line_number':5057,'multiline':False]
['text':' the JitStackAlignment.','line_number':5058,'multiline':False]
['text':' See comment block "64-bit GPRs carrying 32-bit values" above.  This asserts','line_number':5068,'multiline':False]
['text':' that the high bits of the register are appropriate for the architecture and','line_number':5069,'multiline':False]
['text':' the value in the low bits.','line_number':5070,'multiline':False]
['text':' StackMacroAssembler checks no GC will happen while it's on the stack.','line_number':5075,'multiline':False]
['text':' WasmMacroAssembler does not contain GC pointers, so it doesn't need the no-GC','line_number':5084,'multiline':False]
['text':' checking StackMacroAssembler has.','line_number':5085,'multiline':False]
['text':' Heap-allocated MacroAssembler used for Ion off-thread code generation.','line_number':5095,'multiline':False]
['text':' GC cancels off-thread compilations.','line_number':5096,'multiline':False]
['text':'{{{ check_macroassembler_style','line_number':5104,'multiline':False]
['text':'}}} check_macroassembler_style','line_number':5121,'multiline':False]
['text':' Note: the op may have been inverted during lowering (to put constants in a','line_number':5144,'multiline':False]
['text':' position where they can be immediates), so it is important to use the','line_number':5145,'multiline':False]
['text':' lir->jsop() instead of the mir->jsop() when it is present.','line_number':5146,'multiline':False]
['text':' Helper for generatePreBarrier.','line_number':5216,'multiline':False]
['text':' This is not an alias because we want to allow class template argument','line_number':5262,'multiline':False]
['text':' deduction.','line_number':5263,'multiline':False]
['text':' namespace jit','line_number':5284,'multiline':False]
['text':' namespace wasm','line_number':5289,'multiline':False]
['text':' namespace js','line_number':5291,'multiline':False]
['text':' jit_MacroAssembler_h ','line_number':5293,'multiline':True]
