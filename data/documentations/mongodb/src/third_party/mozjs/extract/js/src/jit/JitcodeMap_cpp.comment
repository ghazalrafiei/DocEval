['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' for BytecodeLocation','line_number':22,'multiline':False]
['text':' For the first entry pushed (innermost frame), the pcOffset is obtained','line_number':64,'multiline':False]
['text':' from the delta-run encodings.','line_number':65,'multiline':False]
['text':' The region table is stored at the tail of the compacted data,','line_number':118,'multiline':False]
['text':' which means the start of the region table is a pointer to','line_number':119,'multiline':False]
['text':' the _middle_ of the memory space allocated for it.','line_number':120,'multiline':False]
['text':'','line_number':121,'multiline':False]
['text':' When freeing it, obtain the payload start pointer first.','line_number':122,'multiline':False]
['text':' Free the scriptList strs.','line_number':128,'multiline':False]
['text':' Free the script list','line_number':134,'multiline':False]
['text':' TODO: We can't yet normalize Baseline addresses until we unify','line_number':141,'multiline':False]
['text':' BaselineScript's PCMappingEntries with JitcodeGlobalTable.','line_number':142,'multiline':False]
['text':' static ','line_number':215,'multiline':True]
['text':' Both parts of compare cannot be a query.','line_number':218,'multiline':False]
['text':' Ensure no overlaps for non-query lookups.','line_number':221,'multiline':False]
['text':' For two non-query entries, just comapare the start addresses.','line_number':224,'multiline':False]
['text':' query ptr > entry','line_number':238,'multiline':False]
['text':' query ptr < entry','line_number':242,'multiline':False]
['text':' Did not remove current entry; advance prevTower_.','line_number':256,'multiline':False]
['text':' JitcodeGlobalEntries are marked at the end of the mark phase. A read','line_number':291,'multiline':False]
['text':' barrier is not needed. Any JS frames sampled during the sweep phase of','line_number':292,'multiline':False]
['text':' the GC must be on stack, and on-stack frames must already be marked at','line_number':293,'multiline':False]
['text':' the beginning of the sweep phase. It's not possible to assert this here','line_number':294,'multiline':False]
['text':' as we may be off main thread when called from the gecko profiler.','line_number':295,'multiline':False]
['text':' Check startTower','line_number':306,'multiline':False]
['text':' Allocate a new entry and tower.','line_number':337,'multiline':False]
['text':' Suppress profiler sampling while skiplist is being mutated.','line_number':351,'multiline':False]
['text':' Link up entry with forward entries taken from tower.','line_number':354,'multiline':False]
['text':' verifySkiplist(); - disabled for release.','line_number':373,'multiline':False]
['text':' Unlink query entry.','line_number':382,'multiline':False]
['text':' verifySkiplist(); - disabled for release.','line_number':393,'multiline':False]
['text':' Entry has been unlinked.','line_number':395,'multiline':False]
['text':' Validate the resulting tower.','line_number':423,'multiline':False]
['text':' If we got NULL for a given level, then we should have gotten NULL','line_number':427,'multiline':False]
['text':' for the level above as well.','line_number':428,'multiline':False]
['text':' Non-null result at a given level must sort < query.','line_number':436,'multiline':False]
['text':' The entry must have a tower height that accomodates level.','line_number':439,'multiline':False]
['text':' Next entry must have tower height that accomodates level.','line_number':446,'multiline':False]
['text':' Next entry must sort >= query.','line_number':449,'multiline':False]
['text':' DEBUG','line_number':452,'multiline':False]
['text':' If starting with nullptr, use the start tower.','line_number':460,'multiline':False]
['text':' Keep skipping at |level| until we reach an entry < query whose','line_number':468,'multiline':False]
['text':' successor is an entry >= query.','line_number':469,'multiline':False]
['text':' Implementation taken from Hars L. and Pteruska G.,','line_number':481,'multiline':False]
['text':' "Pseudorandom Recursions: Small and fast Pseudorandom number generators for','line_number':482,'multiline':False]
['text':'  embedded applications."','line_number':483,'multiline':False]
['text':' Return 1 + number of lowbit zeros in new randval, capped at MAX_HEIGHT.','line_number':487,'multiline':False]
['text':' DEBUG','line_number':554,'multiline':False]
['text':' JitcodeGlobalTable must keep entries that are in the sampler buffer','line_number':565,'multiline':False]
['text':' alive. This conditionality is akin to holding the entries weakly.','line_number':566,'multiline':False]
['text':'','line_number':567,'multiline':False]
['text':' If this table were marked at the beginning of the mark phase, then','line_number':568,'multiline':False]
['text':' sampling would require a read barrier for sampling in between','line_number':569,'multiline':False]
['text':' incremental GC slices. However, invoking read barriers from the sampler','line_number':570,'multiline':False]
['text':' is wildly unsafe. The sampler may run at any time, including during GC','line_number':571,'multiline':False]
['text':' itself.','line_number':572,'multiline':False]
['text':'','line_number':573,'multiline':False]
['text':' Instead, JitcodeGlobalTable is marked at the beginning of the sweep','line_number':574,'multiline':False]
['text':' phase, along with weak references. The key assumption is the','line_number':575,'multiline':False]
['text':' following. At the beginning of the sweep phase, any JS frames that the','line_number':576,'multiline':False]
['text':' sampler may put in its buffer that are not already there at the','line_number':577,'multiline':False]
['text':' beginning of the mark phase must have already been marked, as either 1)','line_number':578,'multiline':False]
['text':' the frame was on-stack at the beginning of the sweep phase, or 2) the','line_number':579,'multiline':False]
['text':' frame was pushed between incremental sweep slices. Frames of case 1)','line_number':580,'multiline':False]
['text':' are already marked. Frames of case 2) must have been reachable to have','line_number':581,'multiline':False]
['text':' been newly pushed, and thus are already marked.','line_number':582,'multiline':False]
['text':'','line_number':583,'multiline':False]
['text':' The approach above obviates the need for read barriers. The assumption','line_number':584,'multiline':False]
['text':' above is checked in JitcodeGlobalTable::lookupForSampler.','line_number':585,'multiline':False]
['text':' If the profiler is off, rangeStart will be Nothing() and all entries are','line_number':591,'multiline':False]
['text':' considered to be expired.','line_number':592,'multiline':False]
['text':' If an entry is not sampled, reset its buffer position to the invalid','line_number':600,'multiline':False]
['text':' position, and conditionally mark the rest of the entry if its','line_number':601,'multiline':False]
['text':' JitCode is not already marked. This conditional marking ensures','line_number':602,'multiline':False]
['text':' that so long as the JitCode *may* be sampled, we keep any','line_number':603,'multiline':False]
['text':' information that may be handed out to the sampler, like tracked','line_number':604,'multiline':False]
['text':' types used by optimizations and scripts used for pc to line number','line_number':605,'multiline':False]
['text':' mapping, alive as well.','line_number':606,'multiline':False]
['text':' The table is runtime-wide. Not all zones may be participating in','line_number':614,'multiline':False]
['text':' the GC.','line_number':615,'multiline':False]
['text':' static ','line_number':694,'multiline':True]
['text':' static ','line_number':701,'multiline':True]
['text':' static ','line_number':709,'multiline':True]
['text':' static ','line_number':716,'multiline':True]
['text':' static ','line_number':723,'multiline':True]
['text':' 1 and 2-byte formats possible.','line_number':727,'multiline':False]
['text':'  NNNN-BBB0','line_number':729,'multiline':False]
['text':'  NNNN-NNNN BBBB-BB01','line_number':737,'multiline':False]
['text':'  NNNN-NNNN NNNB-BBBB BBBB-B011','line_number':747,'multiline':False]
['text':'  NNNN-NNNN NNNN-NNNN BBBB-BBBB BBBB-B111','line_number':760,'multiline':False]
['text':' Should never get here.','line_number':774,'multiline':False]
['text':' static ','line_number':778,'multiline':True]
['text':' NB:','line_number':781,'multiline':False]
['text':' It's possible to get nativeDeltas with value 0 in two cases:','line_number':782,'multiline':False]
['text':'','line_number':783,'multiline':False]
['text':' 1. The last region's run.  This is because the region table's start','line_number':784,'multiline':False]
['text':' must be 4-byte aligned, and we must insert padding bytes to align the','line_number':785,'multiline':False]
['text':' payload section before emitting the table.','line_number':786,'multiline':False]
['text':'','line_number':787,'multiline':False]
['text':' 2. A zero-offset nativeDelta with a negative pcDelta.','line_number':788,'multiline':False]
['text':'','line_number':789,'multiline':False]
['text':' So if nativeDelta is zero, then pcDelta must be <= 0.','line_number':790,'multiline':False]
['text':'  NNNN-BBB0','line_number':792,'multiline':False]
['text':'  NNNN-NNNN BBBB-BB01','line_number':802,'multiline':False]
['text':'  NNNN-NNNN NNNB-BBBB BBBB-B011','line_number':813,'multiline':False]
['text':' Fix sign if necessary.','line_number':820,'multiline':False]
['text':'  NNNN-NNNN NNNN-NNNN BBBB-BBBB BBBB-B111','line_number':830,'multiline':False]
['text':' fix sign if necessary','line_number':838,'multiline':False]
['text':' static ','line_number':848,'multiline':True]
['text':' We always use the first entry, so runLength starts at 1','line_number':853,'multiline':False]
['text':' If the next run moves to a different inline site, stop the run.','line_number':860,'multiline':False]
['text':' If deltas are too large (very unlikely), stop the run.','line_number':874,'multiline':False]
['text':' If the run has grown to its maximum length, stop the run.','line_number':881,'multiline':False]
['text':' Move to the end of the current buffer.','line_number':929,'multiline':False]
['text':' !JS_JITSPEW','line_number':932,'multiline':False]
['text':' JS_JITSPEW','line_number':935,'multiline':False]
['text':' Write a run, starting at the given NativeToBytecode entry, into the given','line_number':938,'multiline':False]
['text':' buffer writer.','line_number':939,'multiline':False]
['text':' static ','line_number':940,'multiline':True]
['text':' Calculate script depth.','line_number':948,'multiline':False]
['text':' Write the head info.','line_number':955,'multiline':False]
['text':' Write each script/pc pair.','line_number':961,'multiline':False]
['text':' Find the index of the script within the list.','line_number':966,'multiline':False]
['text':' NB: scriptList is guaranteed to contain curTree->script()','line_number':967,'multiline':False]
['text':' Start writing runs.','line_number':989,'multiline':False]
['text':' Skip first entry because it is implicit in the header.  Start at subsequent','line_number':997,'multiline':False]
['text':' entry.','line_number':998,'multiline':False]
['text':' Spew the bytecode in these ranges.','line_number':1019,'multiline':False]
['text':' Skip past script/pc stack','line_number':1052,'multiline':False]
['text':' The start address of the next delta-run entry is counted towards','line_number':1071,'multiline':False]
['text':' the current delta-run entry, because return addresses should','line_number':1072,'multiline':False]
['text':' associate with the bytecode op prior (the call) not the op after.','line_number':1073,'multiline':False]
['text':' Create profiling strings for script, within vector.','line_number':1090,'multiline':False]
['text':' Cleanup allocations on failure.','line_number':1098,'multiline':False]
['text':' Create SizedScriptList','line_number':1115,'multiline':False]
['text':' Keep allocated profiling strings.','line_number':1122,'multiline':False]
['text':' For small region lists, just search linearly.','line_number':1136,'multiline':False]
['text':' See note in binary-search code below about why we use '<=' here','line_number':1143,'multiline':False]
['text':' instead of '<'.  Short explanation: regions are closed at their','line_number':1144,'multiline':False]
['text':' ending addresses, and open at their starting addresses.','line_number':1145,'multiline':False]
['text':' If nothing found, assume it falls within last region.','line_number':1152,'multiline':False]
['text':' For larger ones, binary search the region table.','line_number':1156,'multiline':False]
['text':' A region memory range is closed at its ending address, not starting','line_number':1164,'multiline':False]
['text':' address.  This is because the return address for calls must associate','line_number':1165,'multiline':False]
['text':' with the call's bytecode PC, not the PC of the bytecode operator after','line_number':1166,'multiline':False]
['text':' the call.','line_number':1167,'multiline':False]
['text':'','line_number':1168,'multiline':False]
['text':' So a query is < an entry if the query nativeOffset is <= the start','line_number':1169,'multiline':False]
['text':' address of the entry, and a query is >= an entry if the query','line_number':1170,'multiline':False]
['text':' nativeOffset is > the start address of an entry.','line_number':1171,'multiline':False]
['text':' Target entry is below midEntry.','line_number':1173,'multiline':False]
['text':' if (nativeOffset > midEntry.nativeOffset())','line_number':1175,'multiline':False]
['text':' Target entry is at midEntry or above.','line_number':1176,'multiline':False]
['text':' static ','line_number':1184,'multiline':True]
['text':' Write out runs first.  Keep a vector tracking the positive offsets from','line_number':1206,'multiline':False]
['text':' payload start to the run.','line_number':1207,'multiline':False]
['text':' Calculate the length of the next run.','line_number':1212,'multiline':False]
['text':' Store the offset of the run.','line_number':1219,'multiline':False]
['text':' Encode the run.','line_number':1224,'multiline':False]
['text':' Done encoding regions.  About to start table.  Ensure we are aligned to 4','line_number':1233,'multiline':False]
['text':' bytes since table is composed of uint32_t values.','line_number':1234,'multiline':False]
['text':' Now at start of table.','line_number':1245,'multiline':False]
['text':' The table being written at this point will be accessed directly via','line_number':1248,'multiline':False]
['text':' uint32_t pointers, so all writes below use native endianness.','line_number':1249,'multiline':False]
['text':' Write out numRegions','line_number':1251,'multiline':False]
['text':' Write out region offset table.  The offsets in |runOffsets| are currently','line_number':1255,'multiline':False]
['text':' forward offsets from the beginning of the buffer.  We convert them to','line_number':1256,'multiline':False]
['text':' backwards offsets from the start of the table before writing them into','line_number':1257,'multiline':False]
['text':' their table entries.','line_number':1258,'multiline':False]
['text':' namespace jit','line_number':1275,'multiline':False]
['text':' namespace js','line_number':1276,'multiline':False]
['text':' The iterator iterates in high depth to low depth order. index_ goes up,','line_number':1325,'multiline':False]
['text':' and the depth we need to pass to ProfiledFrameHandle goes down.','line_number':1326,'multiline':False]
