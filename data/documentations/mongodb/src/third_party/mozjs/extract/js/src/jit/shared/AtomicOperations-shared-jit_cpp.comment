['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=4 et sw=4 tw=99:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' js::Scalar::Type','line_number':16,'multiline':False]
['text':' Assigned registers must follow these rules:','line_number':24,'multiline':False]
['text':'','line_number':25,'multiline':False]
['text':'  - if they overlap the argument registers (for arguments we use) then they','line_number':26,'multiline':False]
['text':'','line_number':27,'multiline':False]
['text':'                     M   M   U   U   SSSS  TTTTT','line_number':28,'multiline':False]
['text':'          ====\      MM MM   U   U  S        T      /====','line_number':29,'multiline':False]
['text':'          =====>     M M M   U   U   SSS     T     <=====','line_number':30,'multiline':False]
['text':'          ====/      M   M   U   U      S    T      \====','line_number':31,'multiline':False]
['text':'                     M   M    UUU   SSSS     T','line_number':32,'multiline':False]
['text':'','line_number':33,'multiline':False]
['text':'    require no register movement, even for 64-bit registers.  (If this becomes','line_number':34,'multiline':False]
['text':'    too complex to handle then we need to create an abstraction that uses the','line_number':35,'multiline':False]
['text':'    MoveResolver, see comments on bug 1394420.)','line_number':36,'multiline':False]
['text':'','line_number':37,'multiline':False]
['text':'  - they should be volatile when possible so that we don't have to save and','line_number':38,'multiline':False]
['text':'    restore them.','line_number':39,'multiline':False]
['text':'','line_number':40,'multiline':False]
['text':' Note that the functions we're generating have a very limited number of','line_number':41,'multiline':False]
['text':' signatures, and the register assignments need only work for these signatures.','line_number':42,'multiline':False]
['text':' The signatures are these:','line_number':43,'multiline':False]
['text':'','line_number':44,'multiline':False]
['text':'   ()','line_number':45,'multiline':False]
['text':'   (ptr)','line_number':46,'multiline':False]
['text':'   (ptr, val/val64)','line_number':47,'multiline':False]
['text':'   (ptr, ptr)','line_number':48,'multiline':False]
['text':'   (ptr, val/val64, val/val64)','line_number':49,'multiline':False]
['text':'','line_number':50,'multiline':False]
['text':' It would be nice to avoid saving and restoring all the nonvolatile registers','line_number':51,'multiline':False]
['text':' for all the operations, and instead save and restore only the registers used','line_number':52,'multiline':False]
['text':' by each specific operation, but the amount of protocol needed to accomplish','line_number':53,'multiline':False]
['text':' that probably does not pay for itself.','line_number':54,'multiline':False]
['text':' Selected registers match the argument registers exactly, and none of them','line_number':58,'multiline':False]
['text':' overlap the result register.','line_number':59,'multiline':False]
['text':' Selected registers match the argument registers, except that the Ptr is not','line_number':76,'multiline':False]
['text':' in IntArgReg0 so as not to conflict with the result register.','line_number':77,'multiline':False]
['text':' Assigned registers except temp are disjoint from the argument registers,','line_number':94,'multiline':False]
['text':' since accounting for both 32-bit and 64-bit arguments and constraints on the','line_number':95,'multiline':False]
['text':' result register is much too messy.  The temp is in an argument register since','line_number':96,'multiline':False]
['text':' it won't be used until we've moved all arguments to other registers.','line_number':97,'multiline':False]
['text':'','line_number':98,'multiline':False]
['text':' Save LR because it's the second scratch register.  The first scratch register','line_number':99,'multiline':False]
['text':' is r12 (IP).  The atomics implementation in the MacroAssembler uses both.','line_number':100,'multiline':False]
['text':' There are no argument registers.','line_number':121,'multiline':False]
['text':' 64-bit registers for cmpxchg8b.  ValReg/Val2Reg/Temp are not used in this','line_number':133,'multiline':False]
['text':' case.','line_number':134,'multiline':False]
['text':' AtomicReturnReg64 is unused on x86.','line_number':139,'multiline':False]
['text':' These are useful shorthands and hide the meaningless uint/int distinction.','line_number':145,'multiline':False]
['text':' A "block" is a sequence of bytes that is a reasonable quantum to copy to','line_number':157,'multiline':False]
['text':' amortize call overhead when implementing memcpy and memmove.  A block will','line_number':158,'multiline':False]
['text':' not fit in registers on all platforms and copying it without using','line_number':159,'multiline':False]
['text':' intermediate memory will therefore be sensitive to overlap.','line_number':160,'multiline':False]
['text':'','line_number':161,'multiline':False]
['text':' A "word" is an item that we can copy using only register intermediate storage','line_number':162,'multiline':False]
['text':' on all platforms; words can be individually copied without worrying about','line_number':163,'multiline':False]
['text':' overlap.','line_number':164,'multiline':False]
['text':'','line_number':165,'multiline':False]
['text':' Blocks and words can be aligned or unaligned; specific (generated) copying','line_number':166,'multiline':False]
['text':' functions handle this in platform-specific ways.','line_number':167,'multiline':False]
['text':' Also see SIZEWORD above','line_number':170,'multiline':False]
['text':' Must be a power of 2','line_number':171,'multiline':False]
['text':' The return address is among the nonvolatile registers, if pushed at all.','line_number':251,'multiline':False]
['text':' The return address is pushed separately.','line_number':254,'multiline':False]
['text':' Move data down, ie, iterate toward higher addresses','line_number':364,'multiline':False]
['text':' The other way','line_number':365,'multiline':False]
['text':' The return register edx:eax is a compiler/ABI assumption that is *not*','line_number':435,'multiline':False]
['text':' the same as ReturnReg64, so it's correct not to use that here.','line_number':436,'multiline':False]
['text':' See the definitions of BLOCKSIZE and WORDSIZE earlier.  The "unaligned"','line_number':565,'multiline':False]
['text':' functions perform individual byte copies (and must always be "down" or "up").','line_number':566,'multiline':False]
['text':' The others ignore alignment issues, and thus either depend on unaligned','line_number':567,'multiline':False]
['text':' accesses being OK or not being invoked on unaligned addresses.','line_number':568,'multiline':False]
['text':'','line_number':569,'multiline':False]
['text':' src and dest point to the lower addresses of the respective data areas','line_number':570,'multiline':False]
['text':' irrespective of "up" or "down".','line_number':571,'multiline':False]
['text':' This is not necessarily true but it's the best guess right now.','line_number':642,'multiline':False]
['text':' Set up bulk copying.  The cases are ordered the way they are on the','line_number':653,'multiline':False]
['text':' assumption that if we can achieve aligned copies even with a little','line_number':654,'multiline':False]
['text':' preprocessing then that is better than unaligned copying on a platform','line_number':655,'multiline':False]
['text':' that supports it.','line_number':656,'multiline':False]
['text':' because nbytes >= WORDSIZE','line_number':664,'multiline':False]
['text':' Bulk copy, first larger blocks and then individual words.','line_number':678,'multiline':False]
['text':' Byte copy any remaining tail.','line_number':695,'multiline':False]
['text':' Because nbytes >= WORDSIZE','line_number':715,'multiline':False]
['text':' These will be read and written only by the main thread during startup and','line_number':749,'multiline':False]
['text':' shutdown.','line_number':750,'multiline':False]
['text':' We should only initialize once.','line_number':756,'multiline':False]
['text':' Allocate executable memory.','line_number':862,'multiline':False]
['text':' Zero the padding.','line_number':872,'multiline':False]
['text':' Copy the code into place.','line_number':875,'multiline':False]
['text':' Reprotect the whole region to avoid having separate RW and RX mappings.','line_number':878,'multiline':False]
['text':' Create the function pointers.','line_number':885,'multiline':False]
['text':' Must have been initialized.','line_number':1028,'multiline':False]
['text':' namespace jit','line_number':1036,'multiline':False]
['text':' namespace js','line_number':1037,'multiline':False]
