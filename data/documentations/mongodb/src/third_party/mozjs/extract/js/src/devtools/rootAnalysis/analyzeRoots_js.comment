['text':' This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' -*- indent-tabs-mode: nil; js-indent-level: 4 -*- ','line_number':5,'multiline':True]
['text':' Detect simple |return nullptr;| statements.','line_number':140,'multiline':False]
['text':' If the edge uses the given variable's value, return the earliest point at','line_number':152,'multiline':False]
['text':' which the use is definite. Usually, that means the source of the edge','line_number':153,'multiline':False]
['text':' (anything that reaches that source point will end up using the variable, but','line_number':154,'multiline':False]
['text':' there may be other ways to reach the destination of the edge.)','line_number':155,'multiline':False]
['text':'','line_number':156,'multiline':False]
['text':' Return values are implicitly used at the very last point in the function.','line_number':157,'multiline':False]
['text':' This makes a difference: if an RAII class GCs in its destructor, we need to','line_number':158,'multiline':False]
['text':' start looking at the final point in the function, not one point back from','line_number':159,'multiline':False]
['text':' that, since that would skip over the GCing call.','line_number':160,'multiline':False]
['text':'','line_number':161,'multiline':False]
['text':' Note that this returns true only if the variable's incoming value is used.','line_number':162,'multiline':False]
['text':' So this would return false for 'obj':','line_number':163,'multiline':False]
['text':'','line_number':164,'multiline':False]
['text':'     obj = someFunction();','line_number':165,'multiline':False]
['text':'','line_number':166,'multiline':False]
['text':' but these would return true:','line_number':167,'multiline':False]
['text':'','line_number':168,'multiline':False]
['text':'     obj = someFunction(obj);','line_number':169,'multiline':False]
['text':'     obj->foo = someFunction();','line_number':170,'multiline':False]
['text':'','line_number':171,'multiline':False]
['text':' Last point in function body uses the return value.','line_number':178,'multiline':False]
['text':' Detect `Return := nullptr`.','line_number':185,'multiline':False]
['text':' Detect `lhs := ...variable...`','line_number':189,'multiline':False]
['text':' Detect `...variable... := rhs` but not `variable := rhs`. The latter','line_number':192,'multiline':False]
['text':' overwrites the previous value of `variable` without using it.','line_number':193,'multiline':False]
['text':' If the variable is being constructed, then the incoming','line_number':209,'multiline':False]
['text':' value is not used here; it didn't exist before','line_number':210,'multiline':False]
['text':' construction. (The analysis doesn't get told where','line_number':211,'multiline':False]
['text':' variables are defined, so must infer it from','line_number':212,'multiline':False]
['text':' construction. If the variable does not have a','line_number':213,'multiline':False]
['text':' constructor, its live range may be larger than it really','line_number':214,'multiline':False]
['text':' ought to be if it is defined within a loop body, but','line_number':215,'multiline':False]
['text':' that is conservative.)','line_number':216,'multiline':False]
['text':' Assigning call result to a variable.','line_number':231,'multiline':False]
['text':' This might be calling a method on a base class, in which case exp will','line_number':285,'multiline':False]
['text':' be an unnamed field of the variable instead of the variable itself.','line_number':286,'multiline':False]
['text':' Return whether the edge terminates the live range of a variable's value when','line_number':293,'multiline':False]
['text':' searching in reverse through the CFG, by setting it to some new value.','line_number':294,'multiline':False]
['text':' Examples of killing 'obj's live range:','line_number':295,'multiline':False]
['text':'','line_number':296,'multiline':False]
['text':'     obj = foo;','line_number':297,'multiline':False]
['text':'     obj = foo();','line_number':298,'multiline':False]
['text':'     obj = foo(obj);         // uses previous value but then sets to new value','line_number':299,'multiline':False]
['text':'     SomeClass obj(true, 1); // constructor','line_number':300,'multiline':False]
['text':'','line_number':301,'multiline':False]
['text':' Direct assignments kill their lhs: var = value','line_number':304,'multiline':False]
['text':' Assignments of call results kill their lhs.','line_number':314,'multiline':False]
['text':' Constructor calls kill their 'this' value.','line_number':321,'multiline':False]
['text':' Kludge around incorrect dereference on some constructor calls.','line_number':325,'multiline':False]
['text':' Constructor calls include the text 'Name::Name(' or 'Name<...>::Name('.','line_number':339,'multiline':False]
['text':' Match a UniquePtr move constructor.','line_number':372,'multiline':False]
['text':' Scan forward through the given 'body', starting at 'startpoint', looking for','line_number':380,'multiline':False]
['text':' a call that passes 'variable' to a move constructor that "consumes" it (eg','line_number':381,'multiline':False]
['text':' UniquePtr::UniquePtr(UniquePtr&&)).','line_number':382,'multiline':False]
['text':' edgeKillsVariable will find places where 'variable' is given a','line_number':394,'multiline':False]
['text':' new value. Never observed in practice, since this function is','line_number':395,'multiline':False]
['text':' only called with a temporary resulting from std::move(), which','line_number':396,'multiline':False]
['text':' is used immediately for a call. But just to be robust to future','line_number':397,'multiline':False]
['text':' uses:','line_number':398,'multiline':False]
['text':' Return whether an edge "clears out" a variable's value. A simple example','line_number':406,'multiline':False]
['text':' would be','line_number':407,'multiline':False]
['text':'','line_number':408,'multiline':False]
['text':'     var = nullptr;','line_number':409,'multiline':False]
['text':'','line_number':410,'multiline':False]
['text':' for analyses for which nullptr is a "safe" value (eg GC rooting hazards; you','line_number':411,'multiline':False]
['text':' can't get in trouble by holding a nullptr live across a GC.) A more complex','line_number':412,'multiline':False]
['text':' example is a Maybe<T> that gets reset:','line_number':413,'multiline':False]
['text':'','line_number':414,'multiline':False]
['text':'     Maybe<AutoCheckCannotGC> nogc;','line_number':415,'multiline':False]
['text':'     nogc.emplace(cx);','line_number':416,'multiline':False]
['text':'     nogc.reset();','line_number':417,'multiline':False]
['text':'     gc();             // <-- not a problem; nogc is invalidated by prev line','line_number':418,'multiline':False]
['text':'     nogc.emplace(cx);','line_number':419,'multiline':False]
['text':'     foo(nogc);','line_number':420,'multiline':False]
['text':'','line_number':421,'multiline':False]
['text':' Yet another example is a UniquePtr being passed by value, which means the','line_number':422,'multiline':False]
['text':' receiver takes ownership:','line_number':423,'multiline':False]
['text':'','line_number':424,'multiline':False]
['text':'     UniquePtr<JSObject*> uobj(obj);','line_number':425,'multiline':False]
['text':'     foo(uobj);','line_number':426,'multiline':False]
['text':'     gc();','line_number':427,'multiline':False]
['text':'','line_number':428,'multiline':False]
['text':' Compare to edgeKillsVariable: killing (in backwards direction) means the','line_number':429,'multiline':False]
['text':' variable's value was live and is no longer. Invalidating means it wasn't','line_number':430,'multiline':False]
['text':' actually live after all.','line_number':431,'multiline':False]
['text':'','line_number':432,'multiline':False]
['text':' var = nullptr;','line_number':435,'multiline':False]
['text':' temp = std::move(var)','line_number':455,'multiline':False]
['text':'','line_number':456,'multiline':False]
['text':' If var is a UniquePtr, and we pass it into something that takes','line_number':457,'multiline':False]
['text':' ownership, then it should be considered to be invalid. It really','line_number':458,'multiline':False]
['text':' ought to be invalidated at the point of the function call that calls','line_number':459,'multiline':False]
['text':' the move constructor, but given that we're creating a temporary here','line_number':460,'multiline':False]
['text':' just for the purpose of passing it in, this edge is good enough.','line_number':461,'multiline':False]
['text':' special-case: the initial constructor that doesn't provide a value.','line_number':477,'multiline':False]
['text':' Useful for things like Maybe<T>.','line_number':478,'multiline':False]
['text':' special-case: UniquePtr::reset() and similar.','line_number':487,'multiline':False]
['text':' special-case: passing UniquePtr<T> by value.','line_number':497,'multiline':False]
['text':' Search recursively through predecessors from the use of a variable's value,','line_number':556,'multiline':False]
['text':' returning whether a GC call is reachable (in the reverse direction; this','line_number':557,'multiline':False]
['text':' means that the variable use is reachable from the GC call, and therefore the','line_number':558,'multiline':False]
['text':' variable is live after the GC call), along with some additional information.','line_number':559,'multiline':False]
['text':' What info we want depends on whether the variable turns out to be live','line_number':560,'multiline':False]
['text':' across a GC call. We are looking for both hazards (unrooted variables live','line_number':561,'multiline':False]
['text':' across GC calls) and unnecessary roots (rooted variables that have no GC','line_number':562,'multiline':False]
['text':' calls in their live ranges.)','line_number':563,'multiline':False]
['text':'','line_number':564,'multiline':False]
['text':' If not:','line_number':565,'multiline':False]
['text':'','line_number':566,'multiline':False]
['text':'  - 'minimumUse': the earliest point in each body that uses the variable, for','line_number':567,'multiline':False]
['text':'    reporting on unnecessary roots.','line_number':568,'multiline':False]
['text':'','line_number':569,'multiline':False]
['text':' If so:','line_number':570,'multiline':False]
['text':'','line_number':571,'multiline':False]
['text':'  - 'why': a path from the GC call to a use of the variable after the GC','line_number':572,'multiline':False]
['text':'    call, chained through a 'why' field in the returned edge descriptor','line_number':573,'multiline':False]
['text':'','line_number':574,'multiline':False]
['text':'  - 'gcInfo': a direct pointer to the GC call edge','line_number':575,'multiline':False]
['text':'','line_number':576,'multiline':False]
['text':' Scan through all edges preceding an unrooted variable use, using an','line_number':579,'multiline':False]
['text':' explicit worklist, looking for a GC call. A worklist contains an','line_number':580,'multiline':False]
['text':' incoming edge together with a description of where it or one of its','line_number':581,'multiline':False]
['text':' successors GC'd (if any).','line_number':582,'multiline':False]
['text':' Grab an entry off of the worklist, representing a point within the','line_number':588,'multiline':False]
['text':' CFG identified by <body,ppoint>. If this point has a descendant','line_number':589,'multiline':False]
['text':' later in the CFG that can GC, gcInfo will be set to the information','line_number':590,'multiline':False]
['text':' about that GC call.','line_number':591,'multiline':False]
['text':' Handle the case where there are multiple ways to reach this point','line_number':596,'multiline':False]
['text':' (traversing backwards).','line_number':597,'multiline':False]
['text':' This point already knows how to GC through some other path, so','line_number':604,'multiline':False]
['text':' we have nothing new to learn. (The other path will consider the','line_number':605,'multiline':False]
['text':' predecessors.)','line_number':606,'multiline':False]
['text':' If this worklist's entry doesn't know of any way to GC, then','line_number':610,'multiline':False]
['text':' there's no point in continuing the traversal through it. Perhaps','line_number':611,'multiline':False]
['text':' another edge will be found that *can* GC; otherwise, the first','line_number':612,'multiline':False]
['text':' route to the point will traverse through predecessors.','line_number':613,'multiline':False]
['text':'','line_number':614,'multiline':False]
['text':' Note that this means we may visit a point more than once, if the','line_number':615,'multiline':False]
['text':' first time we visit we don't have a known reachable GC call and','line_number':616,'multiline':False]
['text':' the second time we do.','line_number':617,'multiline':False]
['text':' Check for hitting the entry point of the current body (which may be','line_number':623,'multiline':False]
['text':' the outer function or a loop within it.)','line_number':624,'multiline':False]
['text':' Propagate to outer body parents that enter the loop body.','line_number':627,'multiline':False]
['text':' Also propagate to the *end* of this loop, for the previous','line_number':643,'multiline':False]
['text':' iteration.','line_number':644,'multiline':False]
['text':' The scope of arguments starts at the beginning of the','line_number':648,'multiline':False]
['text':' function','line_number':649,'multiline':False]
['text':' We didn't find a "good" explanation beginning of the live','line_number':652,'multiline':False]
['text':' range, but we do know the variable was live across the GC.','line_number':653,'multiline':False]
['text':' This can happen if the live range started when a variable is','line_number':654,'multiline':False]
['text':' used as a retparam.','line_number':655,'multiline':False]
['text':' Terminate the search through this point; we thought we were','line_number':668,'multiline':False]
['text':' within the live range, but it turns out that the variable','line_number':669,'multiline':False]
['text':' was set to a value that we don't care about.','line_number':670,'multiline':False]
['text':' This is a beginning of the variable's live range. If we can','line_number':683,'multiline':False]
['text':' reach a GC call from here, then we're done -- we have a path','line_number':684,'multiline':False]
['text':' from the beginning of the live range, through the GC call,','line_number':685,'multiline':False]
['text':' to a use after the GC call that proves its live range','line_number':686,'multiline':False]
['text':' extends at least that far.','line_number':687,'multiline':False]
['text':' Otherwise, keep searching through the graph, but truncate','line_number':691,'multiline':False]
['text':' this particular branch of the search at this edge.','line_number':692,'multiline':False]
['text':' The live range starts at least this far back, so we're done','line_number':705,'multiline':False]
['text':' for the same reason as with edge_kills. The only difference','line_number':706,'multiline':False]
['text':' is that a GC on this edge indicates a hazard, whereas if','line_number':707,'multiline':False]
['text':' we're killing a live range in the GC call then it's not live','line_number':708,'multiline':False]
['text':' *across* the call.','line_number':709,'multiline':False]
['text':'','line_number':710,'multiline':False]
['text':' However, we may want to generate a longer usage chain for','line_number':711,'multiline':False]
['text':' the variable than is minimally necessary. For example,','line_number':712,'multiline':False]
['text':' consider:','line_number':713,'multiline':False]
['text':'','line_number':714,'multiline':False]
['text':'   Value v = f();','line_number':715,'multiline':False]
['text':'   if (v.isUndefined())','line_number':716,'multiline':False]
['text':'     return false;','line_number':717,'multiline':False]
['text':'   gc();','line_number':718,'multiline':False]
['text':'   return v;','line_number':719,'multiline':False]
['text':'','line_number':720,'multiline':False]
['text':' The call to .isUndefined() is considered to be a use and','line_number':721,'multiline':False]
['text':' therefore indicates that v must be live at that point. But','line_number':722,'multiline':False]
['text':' it's more helpful to the user to continue the 'why' path to','line_number':723,'multiline':False]
['text':' include the ancestor where the value was generated. So we','line_number':724,'multiline':False]
['text':' will only return here if edge.Kind is Assign; otherwise,','line_number':725,'multiline':False]
['text':' we'll pass a "preGCLive" value up through the worklist to','line_number':726,'multiline':False]
['text':' remember that the variable *is* alive before the GC and so','line_number':727,'multiline':False]
['text':' this function should be returning a true value even if we','line_number':728,'multiline':False]
['text':' don't find an assignment.','line_number':729,'multiline':False]
['text':' Additionally propagate the search into a loop body, starting','line_number':739,'multiline':False]
['text':' with the exit point.','line_number':740,'multiline':False]
['text':' Don't continue to predecessors here without going through','line_number':752,'multiline':False]
['text':' the loop. (The points in this body that enter the loop will','line_number':753,'multiline':False]
['text':' be traversed when we reach the entry point of the loop.)','line_number':754,'multiline':False]
['text':' Propagate the search to the predecessors of this edge.','line_number':758,'multiline':False]
['text':' A variable is live across a GC if (1) it is used by an edge (as in, it','line_number':770,'multiline':False]
['text':' was at least initialized), and (2) it is used after a GC in a successor','line_number':771,'multiline':False]
['text':' edge.','line_number':772,'multiline':False]
['text':' Examples:','line_number':781,'multiline':False]
['text':'','line_number':782,'multiline':False]
['text':'   JSObject* obj = NewObject();','line_number':783,'multiline':False]
['text':'   cangc();','line_number':784,'multiline':False]
['text':'   obj = NewObject();     <-- mentions 'obj' but kills previous value','line_number':785,'multiline':False]
['text':'','line_number':786,'multiline':False]
['text':' This is not a hazard. Contrast this with:','line_number':787,'multiline':False]
['text':'','line_number':788,'multiline':False]
['text':'   JSObject* obj = NewObject();','line_number':789,'multiline':False]
['text':'   cangc();','line_number':790,'multiline':False]
['text':'   obj = LookAt(obj);  <-- uses 'obj' and kills previous value','line_number':791,'multiline':False]
['text':'','line_number':792,'multiline':False]
['text':' This is a hazard; the initial value of obj is live across','line_number':793,'multiline':False]
['text':' cangc(). And a third possibility:','line_number':794,'multiline':False]
['text':'','line_number':795,'multiline':False]
['text':'   JSObject* obj = NewObject();','line_number':796,'multiline':False]
['text':'   obj = CopyObject(obj);','line_number':797,'multiline':False]
['text':'','line_number':798,'multiline':False]
['text':' This is not a hazard, because even though CopyObject can GC, obj','line_number':799,'multiline':False]
['text':' is not live across it. (obj is live before CopyObject, and','line_number':800,'multiline':False]
['text':' probably after, but not across.) There may be a hazard within','line_number':801,'multiline':False]
['text':' CopyObject, of course.','line_number':802,'multiline':False]
['text':'','line_number':803,'multiline':False]
['text':' Ignore uses that are just invalidating the previous value.','line_number':805,'multiline':False]
['text':' An unrooted variable has its address stored in another variable via','line_number':823,'multiline':False]
['text':' assignment, or passed into a function that can GC. If the address is','line_number':824,'multiline':False]
['text':' assigned into some other variable, we can't track it to see if it is held','line_number':825,'multiline':False]
['text':' live across a GC. If it is passed into a function that can GC, then it's','line_number':826,'multiline':False]
['text':' sort of like a Handle to an unrooted location, and the callee could GC','line_number':827,'multiline':False]
['text':' before overwriting it or rooting it.','line_number':828,'multiline':False]
['text':' Read out the brief (non-JSON, semi-human-readable) CFG description for the','line_number':844,'multiline':False]
['text':' given function and store it.','line_number':845,'multiline':False]
['text':' Distribute lines of output to the block they originate from.','line_number':854,'multiline':False]
['text':' If the next point in the trace is in the same block, look for an edge between them.','line_number':918,'multiline':False]
['text':' May be multiple?','line_number':926,'multiline':False]
['text':' Look for any outgoing edge from the chosen point.','line_number':939,'multiline':False]
['text':' Look for the JS_EXPECT_HAZARDS annotation, and output a different','line_number':986,'multiline':False]
['text':' message in that case that won't be counted as a hazard.','line_number':987,'multiline':False]
['text':' Awful special case, hopefully temporary:','line_number':1000,'multiline':False]
['text':'','line_number':1001,'multiline':False]
['text':' The DOM bindings code generator uses "holders" to externally root','line_number':1002,'multiline':False]
['text':' variables. So for example:','line_number':1003,'multiline':False]
['text':'','line_number':1004,'multiline':False]
['text':'       StringObjectRecordOrLong arg0;','line_number':1005,'multiline':False]
['text':'       StringObjectRecordOrLongArgument arg0_holder(arg0);','line_number':1006,'multiline':False]
['text':'       arg0_holder.TrySetToStringObjectRecord(cx, args[0]);','line_number':1007,'multiline':False]
['text':'       GC();','line_number':1008,'multiline':False]
['text':'       self->PassUnion22(cx, arg0);','line_number':1009,'multiline':False]
['text':'','line_number':1010,'multiline':False]
['text':' This appears to be a rooting hazard on arg0, but it is rooted by','line_number':1011,'multiline':False]
['text':' arg0_holder if you set it to any of its union types that requires','line_number':1012,'multiline':False]
['text':' rooting.','line_number':1013,'multiline':False]
['text':'','line_number':1014,'multiline':False]
['text':' Additionally, the holder may be reported as a hazard because it's not','line_number':1015,'multiline':False]
['text':' itself a Rooted or a subclass of AutoRooter; it contains a','line_number':1016,'multiline':False]
['text':' Maybe<RecordRooter<T>> that will get emplaced if rooting is required.','line_number':1017,'multiline':False]
['text':'','line_number':1018,'multiline':False]
['text':' Hopefully these will be simplified at some point (see bug 1517829), but','line_number':1019,'multiline':False]
['text':' for now we special-case functions in the mozilla::dom namespace that','line_number':1020,'multiline':False]
['text':' contain locals with types ending in "Argument". Or','line_number':1021,'multiline':False]
['text':' Maybe<SomethingArgument>. It's a harsh world.','line_number':1022,'multiline':False]
['text':' Ignore the older.','line_number':1033,'multiline':False]
['text':' Ignore the "managed" arg.','line_number':1034,'multiline':False]
['text':' The earliest use of the variable should be its constructor.','line_number':1052,'multiline':False]
['text':' Annotate body with a table of all points within the body that may be in','line_number':1128,'multiline':False]
['text':' a limited scope (eg within the scope of a GC suppression RAII class.)','line_number':1129,'multiline':False]
['text':' body.limits is a plain object indexed by point, with the value being a','line_number':1130,'multiline':False]
['text':' bit set stored in an integer of the limit bits.','line_number':1131,'multiline':False]
