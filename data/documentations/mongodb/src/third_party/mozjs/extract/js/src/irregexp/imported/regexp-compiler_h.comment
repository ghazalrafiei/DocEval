['text':' Copyright 2019 the V8 project authors. All rights reserved.','line_number':1,'multiline':False]
['text':' Use of this source code is governed by a BSD-style license that can be','line_number':2,'multiline':False]
['text':' found in the LICENSE file.','line_number':3,'multiline':False]
['text':' The '2' variant is has inclusive from and exclusive to.','line_number':20,'multiline':False]
['text':' This covers \s as defined in ECMA-262 5.1, 15.10.2.12,','line_number':21,'multiline':False]
['text':' which include WhiteSpace (7.2) or LineTerminator (7.3) values.','line_number':22,'multiline':False]
['text':' More makes code generation slower, less makes V8 benchmark score lower.','line_number':42,'multiline':False]
['text':' In a 3-character pattern you can maximally step forwards 3 characters','line_number':44,'multiline':False]
['text':' at a time, which is not always enough to pay for the extra logic.','line_number':45,'multiline':False]
['text':' namespace regexp_compiler_constants','line_number':48,'multiline':False]
['text':' Both unicode and ignore_case flags are set. We need to use ICU to find','line_number':75,'multiline':False]
['text':' the closure over case equivalents.','line_number':76,'multiline':False]
['text':' Details of a quick mask-compare check that can look ahead in the','line_number':80,'multiline':False]
['text':' input stream.','line_number':81,'multiline':False]
['text':' Merge in the information from another branch of an alternation.','line_number':89,'multiline':False]
['text':' Advance the current position by some amount.','line_number':91,'multiline':False]
['text':' How many characters do we have quick check information from.  This is','line_number':113,'multiline':False]
['text':' the same for all branches of a choice node.','line_number':114,'multiline':False]
['text':' These values are the condensate of the above array after Rationalize().','line_number':117,'multiline':False]
['text':' If set to true, there is no way this quick check can match at all.','line_number':120,'multiline':False]
['text':' E.g., if it requires to be at the start of the input, and isn't.','line_number':121,'multiline':False]
['text':' Improve the speed that we scan for an initial point where a non-anchored','line_number':125,'multiline':False]
['text':' regexp can match by using a Boyer-Moore-like table. This is done by','line_number':126,'multiline':False]
['text':' identifying non-greedy non-capturing loops in the nodes that eat any','line_number':127,'multiline':False]
['text':' character one at a time.  For example in the middle of the regexp','line_number':128,'multiline':False]
['text':' /foo[\s\S]*?bar/ we find such a loop.  There is also such a loop implicitly','line_number':129,'multiline':False]
['text':' inserted at the start of any non-anchored regexp.','line_number':130,'multiline':False]
['text':'','line_number':131,'multiline':False]
['text':' When we have found such a loop we look ahead in the nodes to find the set of','line_number':132,'multiline':False]
['text':' characters that can come at given distances. For example for the regexp','line_number':133,'multiline':False]
['text':' /.?foo/ we know that there are at least 3 characters ahead of us, and the','line_number':134,'multiline':False]
['text':' sets of characters that can occur are [any, [f, o], [o]]. We find a range in','line_number':135,'multiline':False]
['text':' the lookahead info where the set of characters is reasonably constrained. In','line_number':136,'multiline':False]
['text':' our example this is from index 1 to 2 (0 is not constrained). We can now','line_number':137,'multiline':False]
['text':' look 3 characters ahead and if we don't find one of [f, o] (the union of','line_number':138,'multiline':False]
['text':' [f, o] and [o]) then we can skip forwards by the range size (in this case 2).','line_number':139,'multiline':False]
['text':'','line_number':140,'multiline':False]
['text':' For Unicode input strings we do the same, but modulo 128.','line_number':141,'multiline':False]
['text':'','line_number':142,'multiline':False]
['text':' We also look at the first string fed to the regexp and use that to get a hint','line_number':143,'multiline':False]
['text':' of the character frequencies in the inputs. This affects the assessment of','line_number':144,'multiline':False]
['text':' whether the set of characters is 'reasonably constrained'.','line_number':145,'multiline':False]
['text':'','line_number':146,'multiline':False]
['text':' We also have another lookahead mechanism (called quick check in the code),','line_number':147,'multiline':False]
['text':' which uses a wide load of multiple characters followed by a mask and compare','line_number':148,'multiline':False]
['text':' to determine whether a match is possible at this point.','line_number':149,'multiline':False]
['text':' Can also mean both in and out.','line_number':154,'multiline':False]
['text':' Number of set bits in the map.','line_number':182,'multiline':False]
['text':' The \w character class.','line_number':183,'multiline':False]
['text':' This is the value obtained by EatsAtLeast.  If we do not have at least this','line_number':222,'multiline':False]
['text':' many characters left in the sample string then the match is bound to fail.','line_number':223,'multiline':False]
['text':' Therefore it is OK to read a character this far ahead of the current match','line_number':224,'multiline':False]
['text':' point.','line_number':225,'multiline':False]
['text':' 0xff for Latin1, 0xffff for UTF-16.','line_number':228,'multiline':False]
['text':' There are many ways to generate code for a node.  This class encapsulates','line_number':239,'multiline':False]
['text':' the current way we should be generating.  In other words it encapsulates','line_number':240,'multiline':False]
['text':' the current state of the code generator.  The effect of this is that we','line_number':241,'multiline':False]
['text':' generate code for paths that the matcher can take through the regular','line_number':242,'multiline':False]
['text':' expression.  A given node in the regexp can be code-generated several times','line_number':243,'multiline':False]
['text':' as it can be part of several traces.  For example for the regexp:','line_number':244,'multiline':False]
['text':' /foo(bar|ip)baz/ the code to match baz will be generated twice, once as part','line_number':245,'multiline':False]
['text':' of the foo-bar-baz trace and once as part of the foo-ip-baz trace.  The code','line_number':246,'multiline':False]
['text':' to match foo is generated only once (the traces have a common prefix).  The','line_number':247,'multiline':False]
['text':' code to store the capture is deferred and generated (twice) after the places','line_number':248,'multiline':False]
['text':' where baz has been matched.','line_number':249,'multiline':False]
['text':' A value for a property that is either known to be true, know to be false,','line_number':252,'multiline':False]
['text':' or not known.','line_number':253,'multiline':False]
['text':' End the trace.  This involves flushing the deferred actions in the trace','line_number':325,'multiline':False]
['text':' and pushing a backtrack location onto the backtrack stack.  Once this is','line_number':326,'multiline':False]
['text':' done we can start a new trace or go to one that has already been','line_number':327,'multiline':False]
['text':' generated.','line_number':328,'multiline':False]
['text':' A trivial trace is one that has no deferred actions or other state that','line_number':332,'multiline':False]
['text':' affects the assumptions used when generating code.  There is no recorded','line_number':333,'multiline':False]
['text':' backtrack location in a trivial trace, so with a trivial trace we will','line_number':334,'multiline':False]
['text':' generate code that, on a failure to match, gets the backtrack location','line_number':335,'multiline':False]
['text':' from the backtrack stack rather than using a direct jump instruction.  We','line_number':336,'multiline':False]
['text':' always start code generation with a trivial trace and non-trivial traces','line_number':337,'multiline':False]
['text':' are created as we emit code for nodes or add to the list of deferred','line_number':338,'multiline':False]
['text':' actions in the trace.  The location of the code generated for a node using','line_number':339,'multiline':False]
['text':' a trivial trace is recorded in a label in the node so that gotos can be','line_number':340,'multiline':False]
['text':' generated to that code.','line_number':341,'multiline':False]
['text':' Returns true if a deferred position store exists to the specified','line_number':357,'multiline':False]
['text':' register and stores the offset in the out-parameter.  Otherwise','line_number':358,'multiline':False]
['text':' returns false.','line_number':359,'multiline':False]
['text':' These set methods and AdvanceCurrentPositionInTrace should be used only on','line_number':361,'multiline':False]
['text':' new traces - the intention is that traces are immutable after creation.','line_number':362,'multiline':False]
['text':' Analysis performs assertion propagation and computes eats_at_least_ values.','line_number':422,'multiline':False]
['text':' See the comments on AssertionPropagator and EatsAtLeastPropagator for more','line_number':423,'multiline':False]
['text':' details.','line_number':424,'multiline':False]
['text':' Does not measure in percent, but rather per-128 (the table size from the','line_number':441,'multiline':False]
['text':' regexp macro assembler).','line_number':442,'multiline':False]
['text':' Division by zero.','line_number':445,'multiline':False]
['text':' Lookarounds to match lone surrogates for unicode character class matches','line_number':485,'multiline':False]
['text':' are never nested. We can therefore reuse registers.','line_number':486,'multiline':False]
['text':' Preprocessing is the final step of node creation before analysis','line_number':521,'multiline':False]
['text':' and assembly. It includes:','line_number':522,'multiline':False]
['text':' - Wrapping the body of the regexp in capture 0.','line_number':523,'multiline':False]
['text':' - Inserting the implicit .* before/after the regexp if necessary.','line_number':524,'multiline':False]
['text':' - If the input is a one-byte string, filtering out nodes that can't match.','line_number':525,'multiline':False]
['text':' - Fixing up regexp matches that start within a surrogate pair.','line_number':526,'multiline':False]
['text':' If the regexp matching starts within a surrogate pair, step back to the','line_number':530,'multiline':False]
['text':' lead surrogate and start matching from there.','line_number':531,'multiline':False]
['text':' Categorizes character ranges into BMP, non-BMP, lead, and trail surrogates.','line_number':596,'multiline':False]
['text':' We need to check for the following characters: 0x39C 0x3BC 0x178.','line_number':622,'multiline':False]
['text':' TODO(jgruber): Move to CharacterRange.','line_number':623,'multiline':False]
['text':' namespace internal','line_number':626,'multiline':False]
['text':' namespace v8','line_number':627,'multiline':False]
['text':' V8_REGEXP_REGEXP_COMPILER_H_','line_number':629,'multiline':False]
