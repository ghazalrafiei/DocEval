['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':'
 * Token-affiliated data structures except for TokenKind (defined in its own
 * header).
 ','line_number':7,'multiline':True]
['text':' MOZ_ASSERT','line_number':15,'multiline':False]
['text':' uint32_t','line_number':17,'multiline':False]
['text':' TaggedParserAtomIndex, TrivialTaggedParserAtomIndex','line_number':19,'multiline':False]
['text':' js::frontend::TokenKind','line_number':20,'multiline':False]
['text':' JS::RegExpFlags','line_number':21,'multiline':False]
['text':' Offset of the token's first code unit.','line_number':28,'multiline':False]
['text':' Offset of 1 past the token's last code unit.','line_number':29,'multiline':False]
['text':' Return a TokenPos that covers left, right, and anything in between.','line_number':34,'multiline':False]
['text':' The only escapes found in IdentifierName are of the Unicode flavor.','line_number':65,'multiline':False]
['text':' The lexical grammar of JavaScript has a quirk around the '/' character.','line_number':74,'multiline':False]
['text':' As the spec puts it:','line_number':75,'multiline':False]
['text':'','line_number':76,'multiline':False]
['text':' > There are several situations where the identification of lexical input','line_number':77,'multiline':False]
['text':' > elements is sensitive to the syntactic grammar context that is consuming','line_number':78,'multiline':False]
['text':' > the input elements. This requires multiple goal symbols for the lexical','line_number':79,'multiline':False]
['text':' > grammar. [...] The InputElementRegExp goal symbol is used in all','line_number':80,'multiline':False]
['text':' > syntactic grammar contexts where a RegularExpressionLiteral is permitted','line_number':81,'multiline':False]
['text':' > [...]  In all other contexts, InputElementDiv is used as the lexical','line_number':82,'multiline':False]
['text':' > goal symbol.','line_number':83,'multiline':False]
['text':'','line_number':84,'multiline':False]
['text':' https://tc39.github.io/ecma262/#sec-lexical-and-regexp-grammars','line_number':85,'multiline':False]
['text':'','line_number':86,'multiline':False]
['text':' What "sensitive to the syntactic grammar context" means is, the parser has','line_number':87,'multiline':False]
['text':' to tell the TokenStream whether to interpret '/' as division or','line_number':88,'multiline':False]
['text':' RegExp. Because only one or the other (or neither) will be legal at that','line_number':89,'multiline':False]
['text':' point in the program, and only the parser knows which one.','line_number':90,'multiline':False]
['text':'','line_number':91,'multiline':False]
['text':' But there's a problem: the parser often gets a token, puts it back, then','line_number':92,'multiline':False]
['text':' consumes it later; or (equivalently) peeks at a token, leaves it, peeks','line_number':93,'multiline':False]
['text':' again later, then finally consumes it. Of course we don't actually re-scan','line_number':94,'multiline':False]
['text':' the token every time; we cache it in the TokenStream. This leads to the','line_number':95,'multiline':False]
['text':' following rule:','line_number':96,'multiline':False]
['text':'','line_number':97,'multiline':False]
['text':' The parser must not pass SlashIsRegExp when getting/peeking at a token','line_number':98,'multiline':False]
['text':' previously scanned with SlashIsDiv; or vice versa.','line_number':99,'multiline':False]
['text':'','line_number':100,'multiline':False]
['text':' That way, code that asks for a SlashIsRegExp mode will never get a cached','line_number':101,'multiline':False]
['text':' Div token. But this rule is easy to screw up, because tokens are so often','line_number':102,'multiline':False]
['text':' peeked at on Parser.cpp line A and consumed on line B, where |A-B| is','line_number':103,'multiline':False]
['text':' thousands of lines. We therefore enforce it with the frontend's most','line_number':104,'multiline':False]
['text':' annoying assertion (in verifyConsistentModifier), and provide','line_number':105,'multiline':False]
['text':' Modifier::SlashIsInvalid to help avoid tripping it.','line_number':106,'multiline':False]
['text':'','line_number':107,'multiline':False]
['text':' This enum belongs in TokenStream, but C++, so we define it here and','line_number':108,'multiline':False]
['text':' typedef it there.','line_number':109,'multiline':False]
['text':' Parse `/` and `/=` as the division operators. (That is, use','line_number':111,'multiline':False]
['text':' InputElementDiv as the goal symbol.)','line_number':112,'multiline':False]
['text':' Parse `/` as the beginning of a RegExp literal. (That is, use','line_number':115,'multiline':False]
['text':' InputElementRegExp.)','line_number':116,'multiline':False]
['text':' Neither a Div token nor a RegExp token is syntactically valid here. When','line_number':119,'multiline':False]
['text':' the parser calls `getToken(SlashIsInvalid)`, it must be prepared to see','line_number':120,'multiline':False]
['text':' either one (and throw a SyntaxError either way).','line_number':121,'multiline':False]
['text':'','line_number':122,'multiline':False]
['text':' It's OK to use SlashIsInvalid to get a token that was originally scanned','line_number':123,'multiline':False]
['text':' with SlashIsDiv or SlashIsRegExp. The reverse--peeking with','line_number':124,'multiline':False]
['text':' SlashIsInvalid, then getting with another mode--is not OK. If either Div','line_number':125,'multiline':False]
['text':' or RegExp is syntactically valid here, use the appropriate modifier.','line_number':126,'multiline':False]
['text':' WARNING: TokenStreamPosition assumes that the only GC things a Token','line_number':132,'multiline':False]
['text':'          includes are atoms.  DON'T ADD NON-ATOM GC THING POINTERS HERE','line_number':133,'multiline':False]
['text':'          UNLESS YOU ADD ADDITIONAL ROOTING TO THAT CLASS.','line_number':134,'multiline':False]
['text':'* The type of this token. ','line_number':136,'multiline':True]
['text':'* The token's position in the overall script. ','line_number':139,'multiline':True]
['text':'* Numeric literal's value. ','line_number':149,'multiline':True]
['text':'* Does the numeric literal contain a '.'? ','line_number':152,'multiline':True]
['text':'* Regular expression flags; use charBuffer to access source chars. ','line_number':156,'multiline':True]
['text':'* The modifier used to get this token. ','line_number':161,'multiline':True]
['text':' Mutators','line_number':165,'multiline':False]
['text':' Type-safe accessors','line_number':189,'multiline':False]
['text':' namespace frontend','line_number':218,'multiline':False]
['text':' namespace js','line_number':220,'multiline':False]
['text':' frontend_Token_h','line_number':222,'multiline':False]
