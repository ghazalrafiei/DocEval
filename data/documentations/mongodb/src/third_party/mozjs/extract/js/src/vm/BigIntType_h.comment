['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]
['text':' namespace JS','line_number':31,'multiline':False]
['text':' namespace js','line_number':38,'multiline':False]
['text':' The low CellFlagBitsReservedForGC flag bits are reserved.','line_number':47,'multiline':False]
['text':' The number of digits and the flags are stored in the cell header.','line_number':55,'multiline':False]
['text':' The digit storage starts with the least significant digit (little-endian','line_number':59,'multiline':False]
['text':' digit order).  Byte order within a digit is of course native endian.','line_number':60,'multiline':False]
['text':' Offset for direct access from JIT code.','line_number':77,'multiline':False]
['text':' FIXME: Cache these values.','line_number':124,'multiline':False]
['text':' Return true if the BigInt is without loss of precision representable as an','line_number':151,'multiline':False]
['text':' int64 and store the int64 value in the output. Otherwise return false and','line_number':152,'multiline':False]
['text':' leave the value of the output parameter unspecified.','line_number':153,'multiline':False]
['text':' Return true if the BigInt is without loss of precision representable as an','line_number':156,'multiline':False]
['text':' uint64 and store the uint64 value in the output. Otherwise return false and','line_number':157,'multiline':False]
['text':' leave the value of the output parameter unspecified.','line_number':158,'multiline':False]
['text':' Return true if the BigInt is without loss of precision representable as a','line_number':161,'multiline':False]
['text':' JS Number (double) and store the double value in the output. Otherwise','line_number':162,'multiline':False]
['text':' return false and leave the value of the output parameter unspecified.','line_number':163,'multiline':False]
['text':' Type-checking versions of arithmetic operations. These methods','line_number':169,'multiline':False]
['text':' must be called with at least one BigInt operand. Binary','line_number':170,'multiline':False]
['text':' operations will throw a TypeError if one of the operands is not a','line_number':171,'multiline':False]
['text':' BigInt value.','line_number':172,'multiline':False]
['text':' Check a literal for a non-zero character after the radix indicators','line_number':222,'multiline':False]
['text':' have been removed','line_number':223,'multiline':False]
['text':' These methods return Nothing when the non-BigInt operand is NaN','line_number':236,'multiline':False]
['text':' or a string that can't be interpreted as a BigInt.','line_number':237,'multiline':False]
['text':' Debugger-friendly stderr dump.','line_number':248,'multiline':False]
['text':' Limit the size of bigint values to 1 million bits, to prevent excessive','line_number':262,'multiline':False]
['text':' memory usage.  This limit may be raised in the future if needed.  Note','line_number':263,'multiline':False]
['text':' however that there are many parts of the implementation that rely on being','line_number':264,'multiline':False]
['text':' able to count and index bits using a 32-bit signed ints, so until those','line_number':265,'multiline':False]
['text':' sites are fixed, the practical limit is 0x7fffffff bits.','line_number':266,'multiline':False]
['text':' BigInts can be serialized to strings of radix between 2 and 36.  For a','line_number':270,'multiline':False]
['text':' given bigint, radix 2 will take the most characters (one per bit).','line_number':271,'multiline':False]
['text':' Ensure that the max bigint size is small enough so that we can fit the','line_number':272,'multiline':False]
['text':' corresponding character count into a size_t, with space for a possible','line_number':273,'multiline':False]
['text':' sign prefix.','line_number':274,'multiline':False]
['text':' The result of an SymmetricTrim bitwise op has as many digits as the','line_number':319,'multiline':False]
['text':' smaller operand.  A SymmetricFill bitwise op result has as many digits as','line_number':320,'multiline':False]
['text':' the larger operand, with high digits (if any) copied from the larger','line_number':321,'multiline':False]
['text':' operand.  AsymmetricFill is like SymmetricFill, except the result has as','line_number':322,'multiline':False]
['text':' many digits as the first operand; this kind is used for the and-not','line_number':323,'multiline':False]
['text':' operation.','line_number':324,'multiline':False]
['text':' Return `|x| & |y|`.','line_number':331,'multiline':False]
['text':' Return `|x| | |y|`.','line_number':335,'multiline':False]
['text':' Return `|x| & ~|y|`.','line_number':339,'multiline':False]
['text':' Return `|x| ^ |y|`.','line_number':343,'multiline':False]
['text':' Return `(|x| + 1) * (resultNegative ? -1 : +1)`.','line_number':347,'multiline':False]
['text':' Return `(|x| - 1) * (resultNegative ? -1 : +1)`, with the precondition that','line_number':351,'multiline':False]
['text':' |x| != 0.','line_number':352,'multiline':False]
['text':' Return `a + b`, incrementing `*carry` if the addition overflows.','line_number':356,'multiline':False]
['text':' Return `left - right`, incrementing `*borrow` if the addition overflows.','line_number':363,'multiline':False]
['text':' Compute `a * b`, returning the low half of the result and putting the','line_number':370,'multiline':False]
['text':' high half in `*high`.','line_number':371,'multiline':False]
['text':' Divide `(high << DigitBits) + low` by `divisor`, returning the quotient','line_number':374,'multiline':False]
['text':' and storing the remainder in `*remainder`, with the precondition that','line_number':375,'multiline':False]
['text':' `high < divisor` so that the result fits in a Digit.','line_number':376,'multiline':False]
['text':' Return `(|x| + |y|) * (resultNegative ? -1 : +1)`.','line_number':379,'multiline':False]
['text':' Return `(|x| - |y|) * (resultNegative ? -1 : +1)`, with the precondition','line_number':383,'multiline':False]
['text':' that |x| >= |y|.','line_number':384,'multiline':False]
['text':' If `|x| < |y|` return -1; if `|x| == |y|` return 0; otherwise return 1.','line_number':388,'multiline':False]
['text':' To help avoid writing Spectre-unsafe code, we only allow MacroAssembler to','line_number':433,'multiline':False]
['text':' call the methods below.','line_number':434,'multiline':False]
['text':' namespace JS','line_number':457,'multiline':False]
['text':' Parse a BigInt from a string, using the method specified for StringToBigInt.','line_number':466,'multiline':False]
['text':' Used by the BigInt constructor among other places.','line_number':467,'multiline':False]
['text':' Parse a BigInt from an already-validated numeric literal.  Used by the','line_number':471,'multiline':False]
['text':' parser.  Can only fail in out-of-memory situations.','line_number':472,'multiline':False]
['text':' Check an already validated numeric literal for a non-zero value. Used by','line_number':476,'multiline':False]
['text':' the parsers node folder in deferred mode.','line_number':477,'multiline':False]
['text':' namespace js','line_number':484,'multiline':False]
