['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- ','line_number':1,'multiline':True]
['text':' vim: set ts=8 sts=2 et sw=2 tw=80: ','line_number':2,'multiline':True]
['text':' This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':3,'multiline':True]
['text':' __wasi__','line_number':22,'multiline':False]
['text':' Creates a series of atomic bitfields.','line_number':26,'multiline':False]
['text':'','line_number':27,'multiline':False]
['text':' |aBitfields| is the name of the underlying storage for the bitfields.','line_number':28,'multiline':False]
['text':' |aBitFieldsSize| is the size of the underlying storage (8, 16, 32, or 64).','line_number':29,'multiline':False]
['text':'','line_number':30,'multiline':False]
['text':' Bitfields are specified as a triplet of (type, name, size), which mirrors','line_number':31,'multiline':False]
['text':' the way you declare native C++ bitfields (bool mMyField1: 1). Trailing','line_number':32,'multiline':False]
['text':' commas are not supported in the list of bitfields.','line_number':33,'multiline':False]
['text':'','line_number':34,'multiline':False]
['text':' Signed integer types are not supported by this Macro to avoid dealing with','line_number':35,'multiline':False]
['text':' packing/unpacking the sign bit and C++'s general messiness around signed','line_number':36,'multiline':False]
['text':' integer representations not being fully defined.','line_number':37,'multiline':False]
['text':'','line_number':38,'multiline':False]
['text':' You cannot request a single field that's the','line_number':39,'multiline':False]
['text':' size of the the entire bitfield storage. Just use a normal atomic integer!','line_number':40,'multiline':False]
['text':'','line_number':41,'multiline':False]
['text':'','line_number':42,'multiline':False]
['text':' ========================== SEMANTICS AND SAFETY ============================','line_number':43,'multiline':False]
['text':'','line_number':44,'multiline':False]
['text':' All fields are default-initialized to 0.','line_number':45,'multiline':False]
['text':'','line_number':46,'multiline':False]
['text':' In debug builds, storing a value to a bitfield that's larger than its bits','line_number':47,'multiline':False]
['text':' can fit will trigger an assertion. In release builds, the value will just be','line_number':48,'multiline':False]
['text':' masked off.','line_number':49,'multiline':False]
['text':'','line_number':50,'multiline':False]
['text':' If you request anything unsupported by this macro it should result in','line_number':51,'multiline':False]
['text':' a compile-time error (either a static assert or just weird macro errors).','line_number':52,'multiline':False]
['text':' For instance, this macro will statically prevent using more bits than','line_number':53,'multiline':False]
['text':' |aBitFieldsSize|, so specifying the size is just to prevent accidentally','line_number':54,'multiline':False]
['text':' making the storage bigger.','line_number':55,'multiline':False]
['text':'','line_number':56,'multiline':False]
['text':' Each field will get a Load$NAME and Store$Name method which will atomically','line_number':57,'multiline':False]
['text':' load and store the requested value with a Sequentially Consistent memory','line_number':58,'multiline':False]
['text':' order (to be on the safe side). Storing a field requires a compare-exchange,','line_number':59,'multiline':False]
['text':' so a thread may get stalled if there's a lot of contention on the bitfields.','line_number':60,'multiline':False]
['text':'','line_number':61,'multiline':False]
['text':'','line_number':62,'multiline':False]
['text':' ============================== MOTIVATION ==================================','line_number':63,'multiline':False]
['text':'','line_number':64,'multiline':False]
['text':' You might be wondering: why would I need atomic bitfields? Well as it turns','line_number':65,'multiline':False]
['text':' out, bitfields and concurrency mess a lot of people up!','line_number':66,'multiline':False]
['text':'','line_number':67,'multiline':False]
['text':' CPUs don't have operations to write to a handful of bits -- they generally','line_number':68,'multiline':False]
['text':' only have the precision of a byte. So when you use C++'s native bitfields,','line_number':69,'multiline':False]
['text':' the compiler generates code to mask and shift the values in for you. This','line_number':70,'multiline':False]
['text':' means writing to a single field will actually overwrite all the other','line_number':71,'multiline':False]
['text':' bitfields that are packed in with it!','line_number':72,'multiline':False]
['text':'','line_number':73,'multiline':False]
['text':' In single-threaded code this is fine; the old values are loaded and written','line_number':74,'multiline':False]
['text':' back by the compiler's generated code. But in concurrent code, it means','line_number':75,'multiline':False]
['text':' that accessing two different fields can be an unexpected Data Race (which is','line_number':76,'multiline':False]
['text':' Undefined Behavior!).','line_number':77,'multiline':False]
['text':'','line_number':78,'multiline':False]
['text':' By using MOZ_ATOMIC_BITFIELDS, you protect yourself from these Data Races,','line_number':79,'multiline':False]
['text':' and don't have to worry about writes getting lost.','line_number':80,'multiline':False]
['text':'','line_number':81,'multiline':False]
['text':'','line_number':82,'multiline':False]
['text':' ================================ EXAMPLE ===================================','line_number':83,'multiline':False]
['text':'','line_number':84,'multiline':False]
['text':'   #include "mozilla/AtomicBitfields.h"','line_number':85,'multiline':False]
['text':'   #include <stdint.h>','line_number':86,'multiline':False]
['text':'','line_number':87,'multiline':False]
['text':'','line_number':88,'multiline':False]
['text':'   struct MyType {','line_number':89,'multiline':False]
['text':'     MOZ_ATOMIC_BITFIELDS(mAtomicFields, 8, (','line_number':90,'multiline':False]
['text':'      (bool, IsDownloaded, 1),','line_number':91,'multiline':False]
['text':'      (uint32_t, SomeData, 2),','line_number':92,'multiline':False]
['text':'      (uint8_t, OtherData, 5)','line_number':93,'multiline':False]
['text':'     ))','line_number':94,'multiline':False]
['text':'','line_number':95,'multiline':False]
['text':'     int32_t aNormalInteger;','line_number':96,'multiline':False]
['text':'','line_number':97,'multiline':False]
['text':'     explicit MyType(uint32_t aSomeData): aNormalInteger(7) {','line_number':98,'multiline':False]
['text':'       StoreSomeData(aSomeData);','line_number':99,'multiline':False]
['text':'       // Other bitfields were already default initialized to 0/false','line_number':100,'multiline':False]
['text':'     }','line_number':101,'multiline':False]
['text':'   };','line_number':102,'multiline':False]
['text':'','line_number':103,'multiline':False]
['text':'','line_number':104,'multiline':False]
['text':'   int main() {','line_number':105,'multiline':False]
['text':'     MyType val(3);','line_number':106,'multiline':False]
['text':'','line_number':107,'multiline':False]
['text':'     if (!val.LoadIsDownloaded()) {','line_number':108,'multiline':False]
['text':'       val.StoreOtherData(2);','line_number':109,'multiline':False]
['text':'       val.StoreIsDownloaded(true);','line_number':110,'multiline':False]
['text':'     }','line_number':111,'multiline':False]
['text':'   }','line_number':112,'multiline':False]
['text':'','line_number':113,'multiline':False]
['text':'','line_number':114,'multiline':False]
['text':' ============================== GENERATED ===================================','line_number':115,'multiline':False]
['text':'','line_number':116,'multiline':False]
['text':' This macro is a real mess to read because, well, it's a macro. So for the','line_number':117,'multiline':False]
['text':' sake of anyone who has to review or modify its internals, here's a rough','line_number':118,'multiline':False]
['text':' sketch of what the above example would expand to:','line_number':119,'multiline':False]
['text':'','line_number':120,'multiline':False]
['text':'   struct MyType {','line_number':121,'multiline':False]
['text':'     // The actual storage of the bitfields, initialized to 0.','line_number':122,'multiline':False]
['text':'     std::atomic_uint8_t mAtomicFields{0};','line_number':123,'multiline':False]
['text':'','line_number':124,'multiline':False]
['text':'     // How many bits were actually used (in this case, all of them).','line_number':125,'multiline':False]
['text':'     static const size_t mAtomicFields_USED_BITS = 8;','line_number':126,'multiline':False]
['text':'','line_number':127,'multiline':False]
['text':'     // The offset values for each field.','line_number':128,'multiline':False]
['text':'     static const size_t mAtomicFieldsIsDownloaded = 0;','line_number':129,'multiline':False]
['text':'     static const size_t mAtomicFieldsSomeData = 1;','line_number':130,'multiline':False]
['text':'     static const size_t mAtomicFieldsOtherData = 3;','line_number':131,'multiline':False]
['text':'','line_number':132,'multiline':False]
['text':'     // Quick safety guard to prevent capacity overflow.','line_number':133,'multiline':False]
['text':'     static_assert(mAtomicFields_USED_BITS <= 8);','line_number':134,'multiline':False]
['text':'','line_number':135,'multiline':False]
['text':'     // Asserts that fields are reasonable.','line_number':136,'multiline':False]
['text':'     static_assert(8>1, "mAtomicFields: MOZ_ATOMIC_BITFIELDS field too big");','line_number':137,'multiline':False]
['text':'     static_assert(std::is_unsigned<bool>(), "mAtomicFields:','line_number':138,'multiline':False]
['text':'     MOZ_ATOMIC_BITFIELDS doesn't support signed payloads");','line_number':139,'multiline':False]
['text':'     // ...and so on','line_number':140,'multiline':False]
['text':'','line_number':141,'multiline':False]
['text':'     // Load/Store methods for all the fields.','line_number':142,'multiline':False]
['text':'','line_number':143,'multiline':False]
['text':'     bool LoadIsDownloaded() { ... }','line_number':144,'multiline':False]
['text':'     void StoreIsDownloaded(bool aValue) { ... }','line_number':145,'multiline':False]
['text':'','line_number':146,'multiline':False]
['text':'     uint32_t LoadSomeData() { ... }','line_number':147,'multiline':False]
['text':'     void StoreSomeData(uint32_t aValue) { ... }','line_number':148,'multiline':False]
['text':'','line_number':149,'multiline':False]
['text':'     uint8_t LoadOtherData() { ... }','line_number':150,'multiline':False]
['text':'     void StoreOtherData(uint8_t aValue) { ... }','line_number':151,'multiline':False]
['text':'','line_number':152,'multiline':False]
['text':'','line_number':153,'multiline':False]
['text':'     // Remainder of the struct body continues normally.','line_number':154,'multiline':False]
['text':'     int32_t aNormalInteger;','line_number':155,'multiline':False]
['text':'     explicit MyType(uint32_t aSomeData): aNormalInteger(7) {','line_number':156,'multiline':False]
['text':'       StoreSomeData(aSomeData);','line_number':157,'multiline':False]
['text':'       // Other bitfields were already default initialized to 0/false.','line_number':158,'multiline':False]
['text':'     }','line_number':159,'multiline':False]
['text':'   }','line_number':160,'multiline':False]
['text':'','line_number':161,'multiline':False]
['text':' Also if you're wondering why there's so many MOZ_CONCAT's -- it's because','line_number':162,'multiline':False]
['text':' the preprocessor sometimes gets confused if we use ## on certain arguments.','line_number':163,'multiline':False]
['text':' MOZ_CONCAT reliably kept the preprocessor happy, sorry it's so ugly!','line_number':164,'multiline':False]
['text':'','line_number':165,'multiline':False]
['text':'','line_number':166,'multiline':False]
['text':' ==================== FIXMES / FUTURE WORK ==================================','line_number':167,'multiline':False]
['text':'','line_number':168,'multiline':False]
['text':' * It would be nice if LoadField could be IsField for booleans.','line_number':169,'multiline':False]
['text':'','line_number':170,'multiline':False]
['text':' * For the case of setting something to all 1's or 0's, we can use','line_number':171,'multiline':False]
['text':'   |fetch_or| or |fetch_and| instead of |compare_exchange_weak|. Is this','line_number':172,'multiline':False]
['text':'   worth providing? (Possibly for 1-bit boolean fields?)','line_number':173,'multiline':False]
['text':'','line_number':174,'multiline':False]
['text':' * Try harder to hide the atomic/enum/array internals from','line_number':175,'multiline':False]
['text':'   the outer struct?','line_number':176,'multiline':False]
['text':'','line_number':177,'multiline':False]
['text':' Just a helper to unpack the head of the list.','line_number':194,'multiline':False]
['text':' Just a helper to unpack the name and call the real function.','line_number':198,'multiline':False]
['text':' To compute the offset of a field, why sum up all the offsets after it','line_number':202,'multiline':False]
['text':' (inclusive) and subtract that from the total sum itself. We do this to swap','line_number':203,'multiline':False]
['text':' the rolling sum that |MOZ_ROLL_EACH| gets us from descending to ascending.','line_number':204,'multiline':False]
['text':' Just a more clearly named way of unpacking the size.','line_number':211,'multiline':False]
['text':' Just a helper to unpack the tuple and call the real function.','line_number':214,'multiline':False]
['text':' We need to disable this with coverity because it doesn't like checking that','line_number':219,'multiline':False]
['text':' booleans are < 2 (because they always are).','line_number':220,'multiline':False]
['text':' Generates the Load and Store methods for each field.','line_number':229,'multiline':False]
['text':'','line_number':230,'multiline':False]
['text':' Some comments here because inline macro comments are a pain in the neck:','line_number':231,'multiline':False]
['text':'','line_number':232,'multiline':False]
['text':' Most of the locals are forward declared to minimize messy macroified','line_number':233,'multiline':False]
['text':' type declaration. Also a lot of locals are used to try to make things','line_number':234,'multiline':False]
['text':' a little more clear, while also avoiding integer promotion issues.','line_number':235,'multiline':False]
['text':' This is why some locals are literally just copying a value we already have:','line_number':236,'multiline':False]
['text':' to force it to the right size.','line_number':237,'multiline':False]
['text':'','line_number':238,'multiline':False]
['text':' There's an annoying overflow case where a bitfields instance has a field','line_number':239,'multiline':False]
['text':' that is the same size as the bitfields. Rather than trying to handle that,','line_number':240,'multiline':False]
['text':' we just static_assert against it.','line_number':241,'multiline':False]
['text':'','line_number':242,'multiline':False]
['text':'','line_number':243,'multiline':False]
['text':' BITMATH EXPLAINED:','line_number':244,'multiline':False]
['text':'','line_number':245,'multiline':False]
['text':' For |Load$Name|:','line_number':246,'multiline':False]
['text':'','line_number':247,'multiline':False]
['text':'    mask = ((1 << fieldSize) - 1) << offset','line_number':248,'multiline':False]
['text':'','line_number':249,'multiline':False]
['text':' If you subtract 1 from a value with 1 bit set you get all 1's below that bit.','line_number':250,'multiline':False]
['text':' This is perfect for ANDing out |fieldSize| bits. We shift by |offset| to get','line_number':251,'multiline':False]
['text':' it in the right place.','line_number':252,'multiline':False]
['text':'','line_number':253,'multiline':False]
['text':'    value = (aBitfields.load() & mask) >> offset','line_number':254,'multiline':False]
['text':'','line_number':255,'multiline':False]
['text':' This sets every bit we're not interested in to 0. Shifting the result by','line_number':256,'multiline':False]
['text':' |offset| converts the value back to its native format, ready to be cast','line_number':257,'multiline':False]
['text':' up to an integer type.','line_number':258,'multiline':False]
['text':'','line_number':259,'multiline':False]
['text':'','line_number':260,'multiline':False]
['text':' For |Store$Name|:','line_number':261,'multiline':False]
['text':'','line_number':262,'multiline':False]
['text':'    packedValue = (resizedValue << offset) & mask','line_number':263,'multiline':False]
['text':'','line_number':264,'multiline':False]
['text':' This converts a native value to the packed format. If the value is in bounds,','line_number':265,'multiline':False]
['text':' the AND will do nothing. If it's out of bounds (not checked in release),','line_number':266,'multiline':False]
['text':' then it will cause the value to wrap around by modulo 2^aFieldSize, just like','line_number':267,'multiline':False]
['text':' a normal uint.','line_number':268,'multiline':False]
['text':'','line_number':269,'multiline':False]
['text':'    clearedValue = oldValue & ~mask;','line_number':270,'multiline':False]
['text':'','line_number':271,'multiline':False]
['text':' This clears the bits where our field is stored on our bitfield storage by','line_number':272,'multiline':False]
['text':' ANDing it with an inverted (NOTed) mask.','line_number':273,'multiline':False]
['text':'','line_number':274,'multiline':False]
['text':'    newValue = clearedValue | packedValue;','line_number':275,'multiline':False]
['text':'','line_number':276,'multiline':False]
['text':' Once we have |packedValue| and |clearedValue| they just need to be ORed','line_number':277,'multiline':False]
['text':' together to merge the new field value with the old values of all the other','line_number':278,'multiline':False]
['text':' fields.','line_number':279,'multiline':False]
['text':'','line_number':280,'multiline':False]
['text':' This last step is done in a while loop because someone else can modify','line_number':281,'multiline':False]
['text':' the bits before we have a chance to. If we didn't guard against this,','line_number':282,'multiline':False]
['text':' our write would undo the write the other thread did. |compare_exchange_weak|','line_number':283,'multiline':False]
['text':' is specifically designed to handle this. We give it what we expect the','line_number':284,'multiline':False]
['text':' current value to be, and what we want it to be. If someone else modifies','line_number':285,'multiline':False]
['text':' the bitfields before us, then we will reload the value and try again.','line_number':286,'multiline':False]
['text':'','line_number':287,'multiline':False]
['text':' Note that |compare_exchange_weak| writes back the actual value to the','line_number':288,'multiline':False]
['text':' "expected" argument (it's passed by-reference), so we don't need to do','line_number':289,'multiline':False]
['text':' another load in the body of the loop when we fail to write our result.','line_number':290,'multiline':False]
['text':' OK SO THIS IS A GROSS HACK. GCC 10.2 (and below) has a bug[1] where it','line_number':324,'multiline':False]
['text':' doesn't allow a static array to reference itself in its initializer, so we','line_number':325,'multiline':False]
['text':' need to create a hacky way to produce a rolling sum of all the offsets.','line_number':326,'multiline':False]
['text':'','line_number':327,'multiline':False]
['text':' To do this, we make a tweaked version of |MOZ_FOR_EACH| which instead of','line_number':328,'multiline':False]
['text':' passing just one argument to |aMacro| it passes the remaining values of','line_number':329,'multiline':False]
['text':' |aArgs|.','line_number':330,'multiline':False]
['text':'','line_number':331,'multiline':False]
['text':' This allows us to expand an input (a, b, c, d) quadratically to:','line_number':332,'multiline':False]
['text':'','line_number':333,'multiline':False]
['text':' int sum1 = a + b + c + d;','line_number':334,'multiline':False]
['text':' int sum2 = b + c + d;','line_number':335,'multiline':False]
['text':' int sum3 = c + d;','line_number':336,'multiline':False]
['text':' int sum4 = d;','line_number':337,'multiline':False]
['text':'','line_number':338,'multiline':False]
['text':' So all of this is a copy-paste of |MOZ_FOR_EACH| except the definition','line_number':339,'multiline':False]
['text':' of |MOZ_FOR_EACH_HELPER| no longer extracts an argument with |MOZ_ARG_1|.','line_number':340,'multiline':False]
['text':' Also this is restricted to 32 arguments just to reduce footprint a little.','line_number':341,'multiline':False]
['text':'','line_number':342,'multiline':False]
['text':' If the GCC bug is ever fixed, then this hack can be removed, and we can','line_number':343,'multiline':False]
['text':' use the non-quadratic version that was originally written[2]. In case','line_number':344,'multiline':False]
['text':' that link dies, a brief summary of that implementation:','line_number':345,'multiline':False]
['text':'','line_number':346,'multiline':False]
['text':' * Associate each field with an index by creating an `enum class` with','line_number':347,'multiline':False]
['text':'   entries for each field (an existing gecko patten).','line_number':348,'multiline':False]
['text':'','line_number':349,'multiline':False]
['text':' * Calculate offsets with a constexpr static array whose initializer','line_number':350,'multiline':False]
['text':'   self-referentially adds the contents of the previous index to the','line_number':351,'multiline':False]
['text':'   compute the current one.','line_number':352,'multiline':False]
['text':'','line_number':353,'multiline':False]
['text':' * Index into this array with the enum.','line_number':354,'multiline':False]
['text':'','line_number':355,'multiline':False]
['text':' [1] https://gcc.gnu.org/bugzilla/show_bug.cgi?id=97234','line_number':356,'multiline':False]
['text':' [2]: https://phabricator.services.mozilla.com/D91622?id=346499','line_number':357,'multiline':False]
['text':' namespace mozilla','line_number':467,'multiline':False]
['text':' mozilla_AtomicBitfields_h ','line_number':468,'multiline':True]
