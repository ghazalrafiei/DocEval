['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- ','line_number':1,'multiline':True]
['text':' vim: set ts=8 sts=2 et sw=2 tw=80: ','line_number':2,'multiline':True]
['text':' This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':3,'multiline':True]
['text':' It's often unclear if a particular pointer, be it raw (T*) or smart','line_number':10,'multiline':False]
['text':' (RefPtr<T>, nsCOMPtr<T>, etc.) can be null. This leads to missing null','line_number':11,'multiline':False]
['text':' checks (which can cause crashes) and unnecessary null checks (which clutter','line_number':12,'multiline':False]
['text':' the code).','line_number':13,'multiline':False]
['text':'','line_number':14,'multiline':False]
['text':' C++ has a built-in alternative that avoids these problems: references. This','line_number':15,'multiline':False]
['text':' module defines another alternative, NotNull, which can be used in cases','line_number':16,'multiline':False]
['text':' where references are not suitable.','line_number':17,'multiline':False]
['text':'','line_number':18,'multiline':False]
['text':' In the comments below we use the word "handle" to cover all varieties of','line_number':19,'multiline':False]
['text':' pointers and references.','line_number':20,'multiline':False]
['text':'','line_number':21,'multiline':False]
['text':' References','line_number':22,'multiline':False]
['text':' ----------','line_number':23,'multiline':False]
['text':' References are always non-null. (You can do |T& r = *p;| where |p| is null,','line_number':24,'multiline':False]
['text':' but that's undefined behaviour. C++ doesn't provide any built-in, ironclad','line_number':25,'multiline':False]
['text':' guarantee of non-nullness.)','line_number':26,'multiline':False]
['text':'','line_number':27,'multiline':False]
['text':' A reference works well when you need a temporary handle to an existing','line_number':28,'multiline':False]
['text':' single object, e.g. for passing a handle to a function, or as a local handle','line_number':29,'multiline':False]
['text':' within another object. (In Rust parlance, this is a "borrow".)','line_number':30,'multiline':False]
['text':'','line_number':31,'multiline':False]
['text':' A reference is less appropriate in the following cases.','line_number':32,'multiline':False]
['text':'','line_number':33,'multiline':False]
['text':' - As a primary handle to an object. E.g. code such as this is possible but','line_number':34,'multiline':False]
['text':'   strange: |T& t = *new T(); ...; delete &t;|','line_number':35,'multiline':False]
['text':'','line_number':36,'multiline':False]
['text':' - As a handle to an array. It's common for |T*| to refer to either a single','line_number':37,'multiline':False]
['text':'   |T| or an array of |T|, but |T&| cannot refer to an array of |T| because','line_number':38,'multiline':False]
['text':'   you can't index off a reference (at least, not without first converting it','line_number':39,'multiline':False]
['text':'   to a pointer).','line_number':40,'multiline':False]
['text':'','line_number':41,'multiline':False]
['text':' - When the handle identity is meaningful, e.g. if you have a hashtable of','line_number':42,'multiline':False]
['text':'   handles, because you have to use |&| on the reference to convert it to a','line_number':43,'multiline':False]
['text':'   pointer.','line_number':44,'multiline':False]
['text':'','line_number':45,'multiline':False]
['text':' - Some people don't like using non-const references as function parameters,','line_number':46,'multiline':False]
['text':'   because it is not clear at the call site that the argument might be','line_number':47,'multiline':False]
['text':'   modified.','line_number':48,'multiline':False]
['text':'','line_number':49,'multiline':False]
['text':' - When you need "smart" behaviour. E.g. we lack reference equivalents to','line_number':50,'multiline':False]
['text':'   RefPtr and nsCOMPtr.','line_number':51,'multiline':False]
['text':'','line_number':52,'multiline':False]
['text':' - When interfacing with code that uses pointers a lot, sometimes using a','line_number':53,'multiline':False]
['text':'   reference just feels like an odd fit.','line_number':54,'multiline':False]
['text':'','line_number':55,'multiline':False]
['text':' Furthermore, a reference is impossible in the following cases.','line_number':56,'multiline':False]
['text':'','line_number':57,'multiline':False]
['text':' - When the handle is rebound to another object. References don't allow this.','line_number':58,'multiline':False]
['text':'','line_number':59,'multiline':False]
['text':' - When the handle has type |void|. |void&| is not allowed.','line_number':60,'multiline':False]
['text':'','line_number':61,'multiline':False]
['text':' NotNull is an alternative that can be used in any of the above cases except','line_number':62,'multiline':False]
['text':' for the last one, where the handle type is |void|. See below.','line_number':63,'multiline':False]
['text':' namespace detail','line_number':85,'multiline':False]
['text':' NotNull can be used to wrap a "base" pointer (raw or smart) to indicate it','line_number':90,'multiline':False]
['text':' is not null. Some examples:','line_number':91,'multiline':False]
['text':'','line_number':92,'multiline':False]
['text':' - NotNull<char*>','line_number':93,'multiline':False]
['text':' - NotNull<RefPtr<Event>>','line_number':94,'multiline':False]
['text':' - NotNull<nsCOMPtr<Event>>','line_number':95,'multiline':False]
['text':' - NotNull<UniquePtr<Pointee>>','line_number':96,'multiline':False]
['text':'','line_number':97,'multiline':False]
['text':' NotNull has the following notable properties.','line_number':98,'multiline':False]
['text':'','line_number':99,'multiline':False]
['text':' - It has zero space overhead.','line_number':100,'multiline':False]
['text':'','line_number':101,'multiline':False]
['text':' - It must be initialized explicitly. There is no default initialization.','line_number':102,'multiline':False]
['text':'','line_number':103,'multiline':False]
['text':' - It auto-converts to the base pointer type.','line_number':104,'multiline':False]
['text':'','line_number':105,'multiline':False]
['text':' - It does not auto-convert from a base pointer. Implicit conversion from a','line_number':106,'multiline':False]
['text':'   less-constrained type (e.g. T*) to a more-constrained type (e.g.','line_number':107,'multiline':False]
['text':'   NotNull<T*>) is dangerous. Creation and assignment from a base pointer can','line_number':108,'multiline':False]
['text':'   only be done with WrapNotNull() or MakeNotNull<>(), which makes them','line_number':109,'multiline':False]
['text':'   impossible to overlook, both when writing and reading code.','line_number':110,'multiline':False]
['text':'','line_number':111,'multiline':False]
['text':' - When initialized (or assigned) it is checked, and if it is null we abort.','line_number':112,'multiline':False]
['text':'   This guarantees that it cannot be null.','line_number':113,'multiline':False]
['text':'','line_number':114,'multiline':False]
['text':' - |operator bool()| is deleted. This means you cannot check a NotNull in a','line_number':115,'multiline':False]
['text':'   boolean context, which eliminates the possibility of unnecessary null','line_number':116,'multiline':False]
['text':'   checks.','line_number':117,'multiline':False]
['text':'','line_number':118,'multiline':False]
['text':' - It is not movable, but copyable if the base pointer type is copyable. It','line_number':119,'multiline':False]
['text':'   may be used together with MovingNotNull to avoid unnecessary copies or when','line_number':120,'multiline':False]
['text':'   the base pointer type is not copyable (such as UniquePtr<T>).','line_number':121,'multiline':False]
['text':'','line_number':122,'multiline':False]
['text':' This constructor is only used by WrapNotNull() and MakeNotNull<U>().','line_number':136,'multiline':False]
['text':' Disallow default construction.','line_number':146,'multiline':False]
['text':' Construct/assign from another NotNull with a compatible base pointer type.','line_number':149,'multiline':False]
['text':' Disallow null checks, which are unnecessary for this type.','line_number':158,'multiline':False]
['text':' Explicit conversion to a base pointer. Use only to resolve ambiguity or to','line_number':161,'multiline':False]
['text':' get a castable pointer.','line_number':162,'multiline':False]
['text':' Implicit conversion to a base pointer. Preferable to get().','line_number':165,'multiline':False]
['text':' Dereference operators.','line_number':168,'multiline':False]
['text':' NotNull can be copied, but not moved. Moving a NotNull with a smart base','line_number':176,'multiline':False]
['text':' pointer would leave a nullptr NotNull behind. The move operations must not','line_number':177,'multiline':False]
['text':' be explicitly deleted though, since that would cause overload resolution to','line_number':178,'multiline':False]
['text':' fail in situations where a copy is possible.','line_number':179,'multiline':False]
['text':' Specialization for T* to allow adding MOZ_NONNULL_RETURN attributes.','line_number':184,'multiline':False]
['text':' This constructor is only used by WrapNotNull() and MakeNotNull<U>().','line_number':198,'multiline':False]
['text':' Disallow default construction.','line_number':203,'multiline':False]
['text':' Construct/assign from another NotNull with a compatible base pointer type.','line_number':206,'multiline':False]
['text':' Disallow null checks, which are unnecessary for this type.','line_number':220,'multiline':False]
['text':' Explicit conversion to a base pointer. Use only to resolve ambiguity or to','line_number':223,'multiline':False]
['text':' get a castable pointer.','line_number':224,'multiline':False]
['text':' Implicit conversion to a base pointer. Preferable to get().','line_number':227,'multiline':False]
['text':' Dereference operators.','line_number':230,'multiline':False]
['text':' WrapNotNullUnchecked should only be used in situations, where it is','line_number':241,'multiline':False]
['text':' statically known that aBasePtr is non-null, and redundant release assertions','line_number':242,'multiline':False]
['text':' should be avoided. It is only defined for raw base pointers, since it is only','line_number':243,'multiline':False]
['text':' needed for those right now. There is no fundamental reason not to allow','line_number':244,'multiline':False]
['text':' arbitrary base pointers here.','line_number':245,'multiline':False]
['text':' A variant of NotNull that can be used as a return value or parameter type and','line_number':270,'multiline':False]
['text':' moved into both NotNull and non-NotNull targets. This is not possible with','line_number':271,'multiline':False]
['text':' NotNull, as it is not movable. MovingNotNull can therefore not guarantee it','line_number':272,'multiline':False]
['text':' is always non-nullptr, but it can't be dereferenced, and there are debug','line_number':273,'multiline':False]
['text':' assertions that ensure it is only moved once.','line_number':274,'multiline':False]
['text':' This constructor is only used by WrapNotNull() and MakeNotNull<U>().','line_number':285,'multiline':False]
['text':' Extract the pointed-to type from a pointer type (be it raw or smart).','line_number':341,'multiline':False]
['text':' The default implementation uses the dereferencing operator of the pointer','line_number':342,'multiline':False]
['text':' type to find what it's pointing to.','line_number':343,'multiline':False]
['text':' Remove the reference that dereferencing operators may return.','line_number':346,'multiline':False]
['text':' Specializations for raw pointers.','line_number':351,'multiline':False]
['text':' This is especially required because VS 2017 15.6 (March 2018) started','line_number':352,'multiline':False]
['text':' rejecting the above `decltype(*std::declval<Pointer>())` trick for raw','line_number':353,'multiline':False]
['text':' pointers.','line_number':354,'multiline':False]
['text':' See bug 1443367.','line_number':355,'multiline':False]
['text':' namespace detail','line_number':368,'multiline':False]
['text':' Allocate an object with infallible new, and wrap its pointer in NotNull.','line_number':370,'multiline':False]
['text':' |MakeNotNull<Ptr<Ob>>(args...)| will run |new Ob(args...)|','line_number':371,'multiline':False]
['text':' and return NotNull<Ptr<Ob>>.','line_number':372,'multiline':False]
['text':' Compare two NotNulls.','line_number':381,'multiline':False]
['text':' Compare a NotNull to a base pointer.','line_number':391,'multiline':False]
['text':' Compare a base pointer to a NotNull.','line_number':401,'multiline':False]
['text':' Disallow comparing a NotNull to a nullptr.','line_number':411,'multiline':False]
['text':' Disallow comparing a nullptr to a NotNull.','line_number':417,'multiline':False]
['text':' namespace mozilla','line_number':423,'multiline':False]
['text':' mozilla_NotNull_h ','line_number':425,'multiline':True]
