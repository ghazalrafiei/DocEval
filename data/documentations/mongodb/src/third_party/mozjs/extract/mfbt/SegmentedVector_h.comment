['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- ','line_number':1,'multiline':True]
['text':' vim: set ts=8 sts=2 et sw=2 tw=80: ','line_number':2,'multiline':True]
['text':' This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':3,'multiline':True]
['text':' A simple segmented vector class.','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':' This class should be used in preference to mozilla::Vector or nsTArray when','line_number':9,'multiline':False]
['text':' you are simply gathering items in order to later iterate over them.','line_number':10,'multiline':False]
['text':'','line_number':11,'multiline':False]
['text':' - In the case where you don't know the final size in advance, using','line_number':12,'multiline':False]
['text':'   SegmentedVector avoids the need to repeatedly allocate increasingly large','line_number':13,'multiline':False]
['text':'   buffers and copy the data into them.','line_number':14,'multiline':False]
['text':'','line_number':15,'multiline':False]
['text':' - In the case where you know the final size in advance and so can set the','line_number':16,'multiline':False]
['text':'   capacity appropriately, using SegmentedVector still avoids the need for','line_number':17,'multiline':False]
['text':'   large allocations (which can trigger OOMs).','line_number':18,'multiline':False]
['text':' for placement new','line_number':23,'multiline':False]
['text':' IMPL_LIBXUL','line_number':36,'multiline':False]
['text':' |IdealSegmentSize| specifies how big each segment will be in bytes (or as','line_number':40,'multiline':False]
['text':' close as is possible). Use the following guidelines to choose a size.','line_number':41,'multiline':False]
['text':'','line_number':42,'multiline':False]
['text':' - It should be a power-of-two, to avoid slop.','line_number':43,'multiline':False]
['text':'','line_number':44,'multiline':False]
['text':' - It should not be too small, so that segment allocations are infrequent,','line_number':45,'multiline':False]
['text':'   and so that per-segment bookkeeping overhead is low. Typically each','line_number':46,'multiline':False]
['text':'   segment should be able to hold hundreds of elements, at least.','line_number':47,'multiline':False]
['text':'','line_number':48,'multiline':False]
['text':' - It should not be too large, so that OOMs are unlikely when allocating','line_number':49,'multiline':False]
['text':'   segments, and so that not too much space is wasted when the final segment','line_number':50,'multiline':False]
['text':'   is not full.','line_number':51,'multiline':False]
['text':'','line_number':52,'multiline':False]
['text':' The ideal size depends on how the SegmentedVector is used and the size of','line_number':53,'multiline':False]
['text':' |T|, but reasonable sizes include 1024, 4096 (the default), 8192, and 16384.','line_number':54,'multiline':False]
['text':'','line_number':55,'multiline':False]
['text':' Some versions of GCC treat it as a -Wstrict-aliasing violation (ergo a','line_number':67,'multiline':False]
['text':' -Werror compile error) to reinterpret_cast<> |mData| to |T*|, even','line_number':68,'multiline':False]
['text':' through |void*|.  Placing the latter cast in these separate functions','line_number':69,'multiline':False]
['text':' breaks the chain such that affected GCC versions no longer warn/error.','line_number':70,'multiline':False]
['text':' Pre-increment mLength so that the bounds-check in operator[] passes.','line_number':99,'multiline':False]
['text':' See how many we elements we can fit in a segment of IdealSegmentSize. If','line_number':112,'multiline':False]
['text':' IdealSegmentSize is too small, it'll be just one. The +1 is because','line_number':113,'multiline':False]
['text':' kSingleElementSegmentSize already accounts for one element.','line_number':114,'multiline':False]
['text':' The |aIdealSegmentSize| is only for sanity checking. If it's specified, we','line_number':124,'multiline':False]
['text':' check that the actual segment size is as close as possible to it. This','line_number':125,'multiline':False]
['text':' serves as a sanity check for SegmentedVectorCapacity's capacity','line_number':126,'multiline':False]
['text':' computation.','line_number':127,'multiline':False]
['text':' The difference between the actual segment size and the ideal segment','line_number':129,'multiline':False]
['text':' size should be less than the size of a single element... unless the','line_number':130,'multiline':False]
['text':' ideal size was too small, in which case the capacity should be one.','line_number':131,'multiline':False]
['text':' Note that this is O(n) rather than O(1), but the constant factor is very','line_number':145,'multiline':False]
['text':' small because it only has to do one addition per segment.','line_number':146,'multiline':False]
['text':' Returns false if the allocation failed. (If you are using an infallible','line_number':156,'multiline':False]
['text':' allocation policy, use InfallibleAppend() instead.)','line_number':157,'multiline':False]
['text':' You should probably only use this instead of Append() if you are using an','line_number':173,'multiline':False]
['text':' infallible allocation policy. It will crash if the allocation fails.','line_number':174,'multiline':False]
['text':' MOZ_INTERNAL_API','line_number':185,'multiline':False]
['text':' Equivalent to calling |PopLast| |aNumElements| times, but potentially','line_number':219,'multiline':False]
['text':' more efficient.','line_number':220,'multiline':False]
['text':' Pop full segments for as long as we can.  Note that this loop','line_number':226,'multiline':False]
['text':' cleanly handles the case when the initial last segment is not','line_number':227,'multiline':False]
['text':' full and we are popping more elements than said segment contains.','line_number':228,'multiline':False]
['text':' The list is empty.  We're all done.','line_number':232,'multiline':False]
['text':' Check to see if the list contains too many elements.  Handle','line_number':237,'multiline':False]
['text':' that in the epilogue.','line_number':238,'multiline':False]
['text':' Destroying the segment destroys all elements contained therein.','line_number':244,'multiline':False]
['text':' Handle the case where the last segment contains more elements','line_number':256,'multiline':False]
['text':' than we want to pop.','line_number':257,'multiline':False]
['text':' Use this class to iterate over a SegmentedVector, like so:','line_number':267,'multiline':False]
['text':'','line_number':268,'multiline':False]
['text':'  for (auto iter = v.Iter(); !iter.Done(); iter.Next()) {','line_number':269,'multiline':False]
['text':'    MyElem& elem = iter.Get();','line_number':270,'multiline':False]
['text':'    f(elem);','line_number':271,'multiline':False]
['text':'  }','line_number':272,'multiline':False]
['text':'','line_number':273,'multiline':False]
['text':' Note, adding new entries to the SegmentedVector while using iterators','line_number':274,'multiline':False]
['text':' is supported, but removing is not!','line_number':275,'multiline':False]
['text':' If an iterator has entered Done() state, adding more entries to the','line_number':276,'multiline':False]
['text':' vector doesn't affect it.','line_number':277,'multiline':False]
['text':' Measure the memory consumption of the vector excluding |this|. Note that','line_number':329,'multiline':False]
['text':' it only measures the vector itself. If the vector elements contain','line_number':330,'multiline':False]
['text':' pointers to other memory blocks, those blocks must be measured separately','line_number':331,'multiline':False]
['text':' during a subsequent iteration over the vector.','line_number':332,'multiline':False]
['text':' Like sizeOfExcludingThis(), but measures |this| as well.','line_number':337,'multiline':False]
['text':' namespace mozilla','line_number':346,'multiline':False]
['text':' mozilla_SegmentedVector_h ','line_number':348,'multiline':True]
