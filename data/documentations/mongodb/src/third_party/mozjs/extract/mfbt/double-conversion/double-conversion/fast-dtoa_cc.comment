['text':' Copyright 2012 the V8 project authors. All rights reserved.','line_number':1,'multiline':False]
['text':' Redistribution and use in source and binary forms, with or without','line_number':2,'multiline':False]
['text':' modification, are permitted provided that the following conditions are','line_number':3,'multiline':False]
['text':' met:','line_number':4,'multiline':False]
['text':'','line_number':5,'multiline':False]
['text':'     * Redistributions of source code must retain the above copyright','line_number':6,'multiline':False]
['text':'       notice, this list of conditions and the following disclaimer.','line_number':7,'multiline':False]
['text':'     * Redistributions in binary form must reproduce the above','line_number':8,'multiline':False]
['text':'       copyright notice, this list of conditions and the following','line_number':9,'multiline':False]
['text':'       disclaimer in the documentation and/or other materials provided','line_number':10,'multiline':False]
['text':'       with the distribution.','line_number':11,'multiline':False]
['text':'     * Neither the name of Google Inc. nor the names of its','line_number':12,'multiline':False]
['text':'       contributors may be used to endorse or promote products derived','line_number':13,'multiline':False]
['text':'       from this software without specific prior written permission.','line_number':14,'multiline':False]
['text':'','line_number':15,'multiline':False]
['text':' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS','line_number':16,'multiline':False]
['text':' "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT','line_number':17,'multiline':False]
['text':' LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR','line_number':18,'multiline':False]
['text':' A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT','line_number':19,'multiline':False]
['text':' OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,','line_number':20,'multiline':False]
['text':' SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT','line_number':21,'multiline':False]
['text':' LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,','line_number':22,'multiline':False]
['text':' DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY','line_number':23,'multiline':False]
['text':' THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT','line_number':24,'multiline':False]
['text':' (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE','line_number':25,'multiline':False]
['text':' OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.','line_number':26,'multiline':False]
['text':' The minimal and maximal target exponent define the range of w's binary','line_number':36,'multiline':False]
['text':' exponent, where 'w' is the result of multiplying the input by a cached power','line_number':37,'multiline':False]
['text':' of ten.','line_number':38,'multiline':False]
['text':'','line_number':39,'multiline':False]
['text':' A different range might be chosen on a different platform, to optimize digit','line_number':40,'multiline':False]
['text':' generation, but a smaller range requires more powers of ten to be cached.','line_number':41,'multiline':False]
['text':' Adjusts the last digit of the generated number, and screens out generated','line_number':46,'multiline':False]
['text':' solutions that may be inaccurate. A solution may be inaccurate if it is','line_number':47,'multiline':False]
['text':' outside the safe interval, or if we cannot prove that it is closer to the','line_number':48,'multiline':False]
['text':' input than a neighboring representation of the same length.','line_number':49,'multiline':False]
['text':'','line_number':50,'multiline':False]
['text':' Input: * buffer containing the digits of too_high / 10^kappa','line_number':51,'multiline':False]
['text':'        * the buffer's length','line_number':52,'multiline':False]
['text':'        * distance_too_high_w == (too_high - w).f() * unit','line_number':53,'multiline':False]
['text':'        * unsafe_interval == (too_high - too_low).f() * unit','line_number':54,'multiline':False]
['text':'        * rest = (too_high - buffer * 10^kappa).f() * unit','line_number':55,'multiline':False]
['text':'        * ten_kappa = 10^kappa * unit','line_number':56,'multiline':False]
['text':'        * unit = the common multiplier','line_number':57,'multiline':False]
['text':' Output: returns true if the buffer is guaranteed to contain the closest','line_number':58,'multiline':False]
['text':'    representable number to the input.','line_number':59,'multiline':False]
['text':'  Modifies the generated digits in the buffer to approach (round towards) w.','line_number':60,'multiline':False]
['text':' Let w_low  = too_high - big_distance, and','line_number':70,'multiline':False]
['text':'     w_high = too_high - small_distance.','line_number':71,'multiline':False]
['text':' Note: w_low < w < w_high','line_number':72,'multiline':False]
['text':'','line_number':73,'multiline':False]
['text':' The real w (* unit) must lie somewhere inside the interval','line_number':74,'multiline':False]
['text':' ]w_low; w_high[ (often written as "(w_low; w_high)")','line_number':75,'multiline':False]
['text':' Basically the buffer currently contains a number in the unsafe interval','line_number':77,'multiline':False]
['text':' ]too_low; too_high[ with too_low < w < too_high','line_number':78,'multiline':False]
['text':'','line_number':79,'multiline':False]
['text':'  too_high - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -','line_number':80,'multiline':False]
['text':'                     ^v 1 unit            ^      ^                 ^      ^','line_number':81,'multiline':False]
['text':'  boundary_high ---------------------     .      .                 .      .','line_number':82,'multiline':False]
['text':'                     ^v 1 unit            .      .                 .      .','line_number':83,'multiline':False]
['text':'   - - - - - - - - - - - - - - - - - - -  +  - - + - - - - - -     .      .','line_number':84,'multiline':False]
['text':'                                          .      .         ^       .      .','line_number':85,'multiline':False]
['text':'                                          .  big_distance  .       .      .','line_number':86,'multiline':False]
['text':'                                          .      .         .       .    rest','line_number':87,'multiline':False]
['text':'                              small_distance     .         .       .      .','line_number':88,'multiline':False]
['text':'                                          v      .         .       .      .','line_number':89,'multiline':False]
['text':'  w_high - - - - - - - - - - - - - - - - - -     .         .       .      .','line_number':90,'multiline':False]
['text':'                     ^v 1 unit                   .         .       .      .','line_number':91,'multiline':False]
['text':'  w ----------------------------------------     .         .       .      .','line_number':92,'multiline':False]
['text':'                     ^v 1 unit                   v         .       .      .','line_number':93,'multiline':False]
['text':'  w_low  - - - - - - - - - - - - - - - - - - - - -         .       .      .','line_number':94,'multiline':False]
['text':'                                                           .       .      v','line_number':95,'multiline':False]
['text':'  buffer --------------------------------------------------+-------+--------','line_number':96,'multiline':False]
['text':'                                                           .       .','line_number':97,'multiline':False]
['text':'                                                  safe_interval    .','line_number':98,'multiline':False]
['text':'                                                           v       .','line_number':99,'multiline':False]
['text':'   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     .','line_number':100,'multiline':False]
['text':'                     ^v 1 unit                                     .','line_number':101,'multiline':False]
['text':'  boundary_low -------------------------                     unsafe_interval','line_number':102,'multiline':False]
['text':'                     ^v 1 unit                                     v','line_number':103,'multiline':False]
['text':'  too_low  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -','line_number':104,'multiline':False]
['text':'','line_number':105,'multiline':False]
['text':'','line_number':106,'multiline':False]
['text':' Note that the value of buffer could lie anywhere inside the range too_low','line_number':107,'multiline':False]
['text':' to too_high.','line_number':108,'multiline':False]
['text':'','line_number':109,'multiline':False]
['text':' boundary_low, boundary_high and w are approximations of the real boundaries','line_number':110,'multiline':False]
['text':' and v (the input number). They are guaranteed to be precise up to one unit.','line_number':111,'multiline':False]
['text':' In fact the error is guaranteed to be strictly less than one unit.','line_number':112,'multiline':False]
['text':'','line_number':113,'multiline':False]
['text':' Anything that lies outside the unsafe interval is guaranteed not to round','line_number':114,'multiline':False]
['text':' to v when read again.','line_number':115,'multiline':False]
['text':' Anything that lies inside the safe interval is guaranteed to round to v','line_number':116,'multiline':False]
['text':' when read again.','line_number':117,'multiline':False]
['text':' If the number inside the buffer lies inside the unsafe interval but not','line_number':118,'multiline':False]
['text':' inside the safe interval then we simply do not know and bail out (returning','line_number':119,'multiline':False]
['text':' false).','line_number':120,'multiline':False]
['text':'','line_number':121,'multiline':False]
['text':' Similarly we have to take into account the imprecision of 'w' when finding','line_number':122,'multiline':False]
['text':' the closest representation of 'w'. If we have two potential','line_number':123,'multiline':False]
['text':' representations, and one is closer to both w_low and w_high, then we know','line_number':124,'multiline':False]
['text':' it is closer to the actual value v.','line_number':125,'multiline':False]
['text':'','line_number':126,'multiline':False]
['text':' By generating the digits of too_high we got the largest (closest to','line_number':127,'multiline':False]
['text':' too_high) buffer that is still in the unsafe interval. In the case where','line_number':128,'multiline':False]
['text':' w_high < buffer < too_high we try to decrement the buffer.','line_number':129,'multiline':False]
['text':' This way the buffer approaches (rounds towards) w.','line_number':130,'multiline':False]
['text':' There are 3 conditions that stop the decrementation process:','line_number':131,'multiline':False]
['text':'   1) the buffer is already below w_high','line_number':132,'multiline':False]
['text':'   2) decrementing the buffer would make it leave the unsafe interval','line_number':133,'multiline':False]
['text':'   3) decrementing the buffer would yield a number below w_high and farther','line_number':134,'multiline':False]
['text':'      away than the current number. In other words:','line_number':135,'multiline':False]
['text':'              (buffer{-1} < w_high) && w_high - buffer{-1} > buffer - w_high','line_number':136,'multiline':False]
['text':' Instead of using the buffer directly we use its distance to too_high.','line_number':137,'multiline':False]
['text':' Conceptually rest ~= too_high - buffer','line_number':138,'multiline':False]
['text':' We need to do the following tests in this order to avoid over- and','line_number':139,'multiline':False]
['text':' underflows.','line_number':140,'multiline':False]
['text':' Negated condition 1','line_number':142,'multiline':False]
['text':' Negated condition 2','line_number':143,'multiline':False]
['text':' buffer{-1} > w_high','line_number':144,'multiline':False]
['text':' We have approached w+ as much as possible. We now test if approaching w-','line_number':150,'multiline':False]
['text':' would require changing the buffer. If yes, then we have two possible','line_number':151,'multiline':False]
['text':' representations close to w, but we cannot decide which one is closer.','line_number':152,'multiline':False]
['text':' Weeding test.','line_number':160,'multiline':False]
['text':'   The safe interval is [too_low + 2 ulp; too_high - 2 ulp]','line_number':161,'multiline':False]
['text':'   Since too_low = too_high - unsafe_interval this is equivalent to','line_number':162,'multiline':False]
['text':'      [too_high - unsafe_interval + 4 ulp; too_high - 2 ulp]','line_number':163,'multiline':False]
['text':'   Conceptually we have: rest ~= too_high - buffer','line_number':164,'multiline':False]
['text':' Rounds the buffer upwards if the result is closer to v by possibly adding','line_number':169,'multiline':False]
['text':' 1 to the buffer. If the precision of the calculation is not sufficient to','line_number':170,'multiline':False]
['text':' round correctly, return false.','line_number':171,'multiline':False]
['text':' The rounding might shift the whole buffer in which case the kappa is','line_number':172,'multiline':False]
['text':' adjusted. For example "99", kappa = 3 might become "10", kappa = 4.','line_number':173,'multiline':False]
['text':'','line_number':174,'multiline':False]
['text':' If 2*rest > ten_kappa then the buffer needs to be round up.','line_number':175,'multiline':False]
['text':' rest can have an error of +/- 1 unit. This function accounts for the','line_number':176,'multiline':False]
['text':' imprecision and returns false, if the rounding direction cannot be','line_number':177,'multiline':False]
['text':' unambiguously determined.','line_number':178,'multiline':False]
['text':'','line_number':179,'multiline':False]
['text':' Precondition: rest < ten_kappa.','line_number':180,'multiline':False]
['text':' The following tests are done in a specific order to avoid overflows. They','line_number':188,'multiline':False]
['text':' will work correctly with any uint64 values of rest < ten_kappa and unit.','line_number':189,'multiline':False]
['text':'','line_number':190,'multiline':False]
['text':' If the unit is too big, then we don't know which way to round. For example','line_number':191,'multiline':False]
['text':' a unit of 50 means that the real number lies within rest +/- 50. If','line_number':192,'multiline':False]
['text':' 10^kappa == 40 then there is no way to tell which way to round.','line_number':193,'multiline':False]
['text':' Even if unit is just half the size of 10^kappa we are already completely','line_number':195,'multiline':False]
['text':' lost. (And after the previous test we know that the expression will not','line_number':196,'multiline':False]
['text':' over/underflow.)','line_number':197,'multiline':False]
['text':' If 2 * (rest + unit) <= 10^kappa we can safely round down.','line_number':199,'multiline':False]
['text':' If 2 * (rest - unit) >= 10^kappa, then we can safely round up.','line_number':203,'multiline':False]
['text':' Increment the last digit recursively until we find a non '9' digit.','line_number':205,'multiline':False]
['text':' If the first digit is now '0'+ 10 we had a buffer with all '9's. With the','line_number':212,'multiline':False]
['text':' exception of the first digit all digits are now '0'. Simply switch the','line_number':213,'multiline':False]
['text':' first digit to '1' and adjust the kappa. Example: "99" becomes "10" and','line_number':214,'multiline':False]
['text':' the power (the kappa) is increased.','line_number':215,'multiline':False]
['text':' Returns the biggest power of ten that is less than or equal to the given','line_number':225,'multiline':False]
['text':' number. We furthermore receive the maximum number of bits 'number' has.','line_number':226,'multiline':False]
['text':'','line_number':227,'multiline':False]
['text':' Returns power == 10^(exponent_plus_one-1) such that','line_number':228,'multiline':False]
['text':'    power <= number < power * 10.','line_number':229,'multiline':False]
['text':' If number_bits == 0 then 0^(0-1) is returned.','line_number':230,'multiline':False]
['text':' The number of bits must be <= 32.','line_number':231,'multiline':False]
['text':' Precondition: number < (1 << (number_bits + 1)).','line_number':232,'multiline':False]
['text':' Inspired by the method for finding an integer log base 10 from here:','line_number':234,'multiline':False]
['text':' http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10','line_number':235,'multiline':False]
['text':' 1233/4096 is approximately 1/lg(10).','line_number':245,'multiline':False]
['text':' We increment to skip over the first entry in the kPowersOf10 table.','line_number':247,'multiline':False]
['text':' Note: kPowersOf10[i] == 10^(i-1).','line_number':248,'multiline':False]
['text':' We don't have any guarantees that 2^number_bits <= number.','line_number':250,'multiline':False]
['text':' Generates the digits of input number w.','line_number':258,'multiline':False]
['text':' w is a floating-point number (DiyFp), consisting of a significand and an','line_number':259,'multiline':False]
['text':' exponent. Its exponent is bounded by kMinimalTargetExponent and','line_number':260,'multiline':False]
['text':' kMaximalTargetExponent.','line_number':261,'multiline':False]
['text':'       Hence -60 <= w.e() <= -32.','line_number':262,'multiline':False]
['text':'','line_number':263,'multiline':False]
['text':' Returns false if it fails, in which case the generated digits in the buffer','line_number':264,'multiline':False]
['text':' should not be used.','line_number':265,'multiline':False]
['text':' Preconditions:','line_number':266,'multiline':False]
['text':'  * low, w and high are correct up to 1 ulp (unit in the last place). That','line_number':267,'multiline':False]
['text':'    is, their error must be less than a unit of their last digits.','line_number':268,'multiline':False]
['text':'  * low.e() == w.e() == high.e()','line_number':269,'multiline':False]
['text':'  * low < w < high, and taking into account their error: low~ <= high~','line_number':270,'multiline':False]
['text':'  * kMinimalTargetExponent <= w.e() <= kMaximalTargetExponent','line_number':271,'multiline':False]
['text':' Postconditions: returns false if procedure fails.','line_number':272,'multiline':False]
['text':'   otherwise:','line_number':273,'multiline':False]
['text':'     * buffer is not null-terminated, but len contains the number of digits.','line_number':274,'multiline':False]
['text':'     * buffer contains the shortest possible decimal digit-sequence','line_number':275,'multiline':False]
['text':'       such that LOW < buffer * 10^kappa < HIGH, where LOW and HIGH are the','line_number':276,'multiline':False]
['text':'       correct values of low and high (without their error).','line_number':277,'multiline':False]
['text':'     * if more than one decimal representation gives the minimal number of','line_number':278,'multiline':False]
['text':'       decimal digits then the one closest to W (where W is the correct value','line_number':279,'multiline':False]
['text':'       of w) is chosen.','line_number':280,'multiline':False]
['text':' Remark: this procedure takes into account the imprecision of its input','line_number':281,'multiline':False]
['text':'   numbers. If the precision is not enough to guarantee all the postconditions','line_number':282,'multiline':False]
['text':'   then false is returned. This usually happens rarely (~0.5%).','line_number':283,'multiline':False]
['text':'','line_number':284,'multiline':False]
['text':' Say, for the sake of example, that','line_number':285,'multiline':False]
['text':'   w.e() == -48, and w.f() == 0x1234567890abcdef','line_number':286,'multiline':False]
['text':' w's value can be computed by w.f() * 2^w.e()','line_number':287,'multiline':False]
['text':' We can obtain w's integral digits by simply shifting w.f() by -w.e().','line_number':288,'multiline':False]
['text':'  -> w's integral part is 0x1234','line_number':289,'multiline':False]
['text':'  w's fractional part is therefore 0x567890abcdef.','line_number':290,'multiline':False]
['text':' Printing w's integral part is easy (simply print 0x1234 in decimal).','line_number':291,'multiline':False]
['text':' In order to print its fraction we repeatedly multiply the fraction by 10 and','line_number':292,'multiline':False]
['text':' get each digit. Example the first digit after the point would be computed by','line_number':293,'multiline':False]
['text':'   (0x567890abcdef * 10) >> 48. -> 3','line_number':294,'multiline':False]
['text':' The whole thing becomes slightly more complicated because we want to stop','line_number':295,'multiline':False]
['text':' once we have enough digits. That is, once the digits inside the buffer','line_number':296,'multiline':False]
['text':' represent 'w' we can stop. Everything inside the interval low - high','line_number':297,'multiline':False]
['text':' represents w. However we have to pay attention to low, high and w's','line_number':298,'multiline':False]
['text':' imprecision.','line_number':299,'multiline':False]
['text':' low, w and high are imprecise, but by less than one ulp (unit in the last','line_number':309,'multiline':False]
['text':' place).','line_number':310,'multiline':False]
['text':' If we remove (resp. add) 1 ulp from low (resp. high) we are certain that','line_number':311,'multiline':False]
['text':' the new numbers are outside of the interval we want the final','line_number':312,'multiline':False]
['text':' representation to lie in.','line_number':313,'multiline':False]
['text':' Inversely adding (resp. removing) 1 ulp from low (resp. high) would yield','line_number':314,'multiline':False]
['text':' numbers that are certain to lie in the interval. We will use this fact','line_number':315,'multiline':False]
['text':' later on.','line_number':316,'multiline':False]
['text':' We will now start by generating the digits within the uncertain','line_number':317,'multiline':False]
['text':' interval. Later we will weed out representations that lie outside the safe','line_number':318,'multiline':False]
['text':' interval and thus _might_ lie outside the correct interval.','line_number':319,'multiline':False]
['text':' too_low and too_high are guaranteed to lie outside the interval we want the','line_number':323,'multiline':False]
['text':' generated number in.','line_number':324,'multiline':False]
['text':' We now cut the input number into two parts: the integral digits and the','line_number':326,'multiline':False]
['text':' fractionals. We will not write any decimal separator though, but adapt','line_number':327,'multiline':False]
['text':' kappa instead.','line_number':328,'multiline':False]
['text':' Reminder: we are currently computing the digits (stored inside the buffer)','line_number':329,'multiline':False]
['text':' such that:   too_low < buffer * 10^kappa < too_high','line_number':330,'multiline':False]
['text':' We use too_high for the digit_generation and stop as soon as possible.','line_number':331,'multiline':False]
['text':' If we stop early we effectively round down.','line_number':332,'multiline':False]
['text':' Division by one is a shift.','line_number':334,'multiline':False]
['text':' Modulo by one is an and.','line_number':336,'multiline':False]
['text':' Loop invariant: buffer = too_high / 10^kappa  (integer division)','line_number':344,'multiline':False]
['text':' The invariant holds for the first iteration: kappa has been initialized','line_number':345,'multiline':False]
['text':' with the divisor exponent + 1. And the divisor is the biggest power of ten','line_number':346,'multiline':False]
['text':' that is smaller than integrals.','line_number':347,'multiline':False]
['text':' Note that kappa now equals the exponent of the divisor and that the','line_number':355,'multiline':False]
['text':' invariant thus holds again.','line_number':356,'multiline':False]
['text':' Invariant: too_high = buffer * 10^kappa + DiyFp(rest, one.e())','line_number':359,'multiline':False]
['text':' Reminder: unsafe_interval.e() == one.e()','line_number':360,'multiline':False]
['text':' Rounding down (by not emitting the remaining digits) yields a number','line_number':362,'multiline':False]
['text':' that lies within the unsafe interval.','line_number':363,'multiline':False]
['text':' The integrals have been generated. We are at the point of the decimal','line_number':371,'multiline':False]
['text':' separator. In the following loop we simply multiply the remaining digits by','line_number':372,'multiline':False]
['text':' 10 and divide by one. We just need to pay attention to multiply associated','line_number':373,'multiline':False]
['text':' data (like the interval or 'unit'), too.','line_number':374,'multiline':False]
['text':' Note that the multiplication by 10 does not overflow, because w.e >= -60','line_number':375,'multiline':False]
['text':' and thus one.e >= -60.','line_number':376,'multiline':False]
['text':' Integer division by one.','line_number':384,'multiline':False]
['text':' Modulo by one.','line_number':389,'multiline':False]
['text':' Generates (at most) requested_digits digits of input number w.','line_number':400,'multiline':False]
['text':' w is a floating-point number (DiyFp), consisting of a significand and an','line_number':401,'multiline':False]
['text':' exponent. Its exponent is bounded by kMinimalTargetExponent and','line_number':402,'multiline':False]
['text':' kMaximalTargetExponent.','line_number':403,'multiline':False]
['text':'       Hence -60 <= w.e() <= -32.','line_number':404,'multiline':False]
['text':'','line_number':405,'multiline':False]
['text':' Returns false if it fails, in which case the generated digits in the buffer','line_number':406,'multiline':False]
['text':' should not be used.','line_number':407,'multiline':False]
['text':' Preconditions:','line_number':408,'multiline':False]
['text':'  * w is correct up to 1 ulp (unit in the last place). That','line_number':409,'multiline':False]
['text':'    is, its error must be strictly less than a unit of its last digit.','line_number':410,'multiline':False]
['text':'  * kMinimalTargetExponent <= w.e() <= kMaximalTargetExponent','line_number':411,'multiline':False]
['text':'','line_number':412,'multiline':False]
['text':' Postconditions: returns false if procedure fails.','line_number':413,'multiline':False]
['text':'   otherwise:','line_number':414,'multiline':False]
['text':'     * buffer is not null-terminated, but length contains the number of','line_number':415,'multiline':False]
['text':'       digits.','line_number':416,'multiline':False]
['text':'     * the representation in buffer is the most precise representation of','line_number':417,'multiline':False]
['text':'       requested_digits digits.','line_number':418,'multiline':False]
['text':'     * buffer contains at most requested_digits digits of w. If there are less','line_number':419,'multiline':False]
['text':'       than requested_digits digits then some trailing '0's have been removed.','line_number':420,'multiline':False]
['text':'     * kappa is such that','line_number':421,'multiline':False]
['text':'            w = buffer * 10^kappa + eps with |eps| < 10^kappa / 2.','line_number':422,'multiline':False]
['text':'','line_number':423,'multiline':False]
['text':' Remark: This procedure takes into account the imprecision of its input','line_number':424,'multiline':False]
['text':'   numbers. If the precision is not enough to guarantee all the postconditions','line_number':425,'multiline':False]
['text':'   then false is returned. This usually happens rarely, but the failure-rate','line_number':426,'multiline':False]
['text':'   increases with higher requested_digits.','line_number':427,'multiline':False]
['text':' w is assumed to have an error less than 1 unit. Whenever w is scaled we','line_number':436,'multiline':False]
['text':' also scale its error.','line_number':437,'multiline':False]
['text':' We cut the input number into two parts: the integral digits and the','line_number':439,'multiline':False]
['text':' fractional digits. We don't emit any decimal separator, but adapt kappa','line_number':440,'multiline':False]
['text':' instead. Example: instead of writing "1.2" we put "12" into the buffer and','line_number':441,'multiline':False]
['text':' increase kappa by 1.','line_number':442,'multiline':False]
['text':' Division by one is a shift.','line_number':444,'multiline':False]
['text':' Modulo by one is an and.','line_number':446,'multiline':False]
['text':' Loop invariant: buffer = w / 10^kappa  (integer division)','line_number':455,'multiline':False]
['text':' The invariant holds for the first iteration: kappa has been initialized','line_number':456,'multiline':False]
['text':' with the divisor exponent + 1. And the divisor is the biggest power of ten','line_number':457,'multiline':False]
['text':' that is smaller than 'integrals'.','line_number':458,'multiline':False]
['text':' Note that kappa now equals the exponent of the divisor and that the','line_number':467,'multiline':False]
['text':' invariant thus holds again.','line_number':468,'multiline':False]
['text':' The integrals have been generated. We are at the point of the decimal','line_number':481,'multiline':False]
['text':' separator. In the following loop we simply multiply the remaining digits by','line_number':482,'multiline':False]
['text':' 10 and divide by one. We just need to pay attention to multiply associated','line_number':483,'multiline':False]
['text':' data (the 'unit'), too.','line_number':484,'multiline':False]
['text':' Note that the multiplication by 10 does not overflow, because w.e >= -60','line_number':485,'multiline':False]
['text':' and thus one.e >= -60.','line_number':486,'multiline':False]
['text':' Integer division by one.','line_number':493,'multiline':False]
['text':' Modulo by one.','line_number':499,'multiline':False]
['text':' Provides a decimal representation of v.','line_number':508,'multiline':False]
['text':' Returns true if it succeeds, otherwise the result cannot be trusted.','line_number':509,'multiline':False]
['text':' There will be *length digits inside the buffer (not null-terminated).','line_number':510,'multiline':False]
['text':' If the function returns true then','line_number':511,'multiline':False]
['text':'        v == (double) (buffer * 10^decimal_exponent).','line_number':512,'multiline':False]
['text':' The digits in the buffer are the shortest representation possible: no','line_number':513,'multiline':False]
['text':' 0.09999999999999999 instead of 0.1. The shorter representation will even be','line_number':514,'multiline':False]
['text':' chosen even if the longer one would be closer to v.','line_number':515,'multiline':False]
['text':' The last digit will be closest to the actual v. That is, even if several','line_number':516,'multiline':False]
['text':' digits might correctly yield 'v' when read again, the closest will be','line_number':517,'multiline':False]
['text':' computed.','line_number':518,'multiline':False]
['text':' boundary_minus and boundary_plus are the boundaries between v and its','line_number':525,'multiline':False]
['text':' closest floating-point neighbors. Any number strictly between','line_number':526,'multiline':False]
['text':' boundary_minus and boundary_plus will round to v when convert to a double.','line_number':527,'multiline':False]
['text':' Grisu3 will never output representations that lie exactly on a boundary.','line_number':528,'multiline':False]
['text':' Cached power of ten: 10^-k','line_number':538,'multiline':False]
['text':' -k','line_number':539,'multiline':False]
['text':' Note that ten_mk is only an approximation of 10^-k. A DiyFp only contains a','line_number':552,'multiline':False]
['text':' 64 bit significand and ten_mk is thus only precise up to 64 bits.','line_number':553,'multiline':False]
['text':' The DiyFp::Times procedure rounds its result, and ten_mk is approximated','line_number':555,'multiline':False]
['text':' too. The variable scaled_w (as well as scaled_boundary_minus/plus) are now','line_number':556,'multiline':False]
['text':' off by a small amount.','line_number':557,'multiline':False]
['text':' In fact: scaled_w - w*10^k < 1ulp (unit in the last place) of scaled_w.','line_number':558,'multiline':False]
['text':' In other words: let f = scaled_w.f() and e = scaled_w.e(), then','line_number':559,'multiline':False]
['text':'           (f-1) * 2^e < w*10^k < (f+1) * 2^e','line_number':560,'multiline':False]
['text':' In theory it would be possible to avoid some recomputations by computing','line_number':564,'multiline':False]
['text':' the difference between w and boundary_minus/plus (a power of 2) and to','line_number':565,'multiline':False]
['text':' compute scaled_boundary_minus/plus by subtracting/adding from','line_number':566,'multiline':False]
['text':' scaled_w. However the code becomes much less readable and the speed','line_number':567,'multiline':False]
['text':' enhancements are not terriffic.','line_number':568,'multiline':False]
['text':' DigitGen will generate the digits of scaled_w. Therefore we have','line_number':572,'multiline':False]
['text':' v == (double) (scaled_w * 10^-mk).','line_number':573,'multiline':False]
['text':' Set decimal_exponent == -mk and pass it to DigitGen. If scaled_w is not an','line_number':574,'multiline':False]
['text':' integer than it will be updated. For instance if scaled_w == 1.23 then','line_number':575,'multiline':False]
['text':' the buffer will be filled with "123" und the decimal_exponent will be','line_number':576,'multiline':False]
['text':' decreased by 2.','line_number':577,'multiline':False]
['text':' The "counted" version of grisu3 (see above) only generates requested_digits','line_number':586,'multiline':False]
['text':' number of digits. This version does not generate the shortest representation,','line_number':587,'multiline':False]
['text':' and with enough requested digits 0.1 will at some point print as 0.9999999...','line_number':588,'multiline':False]
['text':' Grisu3 is too imprecise for real halfway cases (1.5 will not work) and','line_number':589,'multiline':False]
['text':' therefore the rounding strategy for halfway cases is irrelevant.','line_number':590,'multiline':False]
['text':' Cached power of ten: 10^-k','line_number':597,'multiline':False]
['text':' -k','line_number':598,'multiline':False]
['text':' Note that ten_mk is only an approximation of 10^-k. A DiyFp only contains a','line_number':611,'multiline':False]
['text':' 64 bit significand and ten_mk is thus only precise up to 64 bits.','line_number':612,'multiline':False]
['text':' The DiyFp::Times procedure rounds its result, and ten_mk is approximated','line_number':614,'multiline':False]
['text':' too. The variable scaled_w (as well as scaled_boundary_minus/plus) are now','line_number':615,'multiline':False]
['text':' off by a small amount.','line_number':616,'multiline':False]
['text':' In fact: scaled_w - w*10^k < 1ulp (unit in the last place) of scaled_w.','line_number':617,'multiline':False]
['text':' In other words: let f = scaled_w.f() and e = scaled_w.e(), then','line_number':618,'multiline':False]
['text':'           (f-1) * 2^e < w*10^k < (f+1) * 2^e','line_number':619,'multiline':False]
['text':' We now have (double) (scaled_w * 10^-mk).','line_number':622,'multiline':False]
['text':' DigitGen will generate the first requested_digits digits of scaled_w and','line_number':623,'multiline':False]
['text':' return together with a kappa such that scaled_w ~= buffer * 10^kappa. (It','line_number':624,'multiline':False]
['text':' will not always be exactly the same since DigitGenCounted only produces a','line_number':625,'multiline':False]
['text':' limited number of digits.)','line_number':626,'multiline':False]
['text':' namespace double_conversion','line_number':665,'multiline':False]
