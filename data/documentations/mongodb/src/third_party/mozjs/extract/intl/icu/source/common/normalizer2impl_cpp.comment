['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]
['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]
['text':'
*******************************************************************************
*
*   Copyright (C) 2009-2014, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
*******************************************************************************
*   file name:  normalizer2impl.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2009nov22
*   created by: Markus W. Scherer
','line_number':3,'multiline':True]
['text':' #define UCPTRIE_DEBUG','line_number':19,'multiline':False]
['text':'*
 * UTF-8 lead byte for minNoMaybeCP.
 * Can be lower than the actual lead byte for c.
 * Typically U+0300 for NFC/NFD, U+00A0 for NFKC/NFKD, U+0041 for NFKC_Casefold.
 ','line_number':49,'multiline':True]
['text':' Should not occur because ccc(U+0300)!=0.','line_number':60,'multiline':False]
['text':'*
 * Returns the code point from one single well-formed UTF-8 byte sequence
 * between cpStart and cpLimit.
 *
 * Trie UTF-8 macros do not assemble whole code points (for efficiency).
 * When we do need the code point, we call this function.
 * We should not need it for normalization-inert data (norm16==0).
 * Illegal sequences yield the error value norm16==0 just like real normalization-inert code points.
 ','line_number':65,'multiline':True]
['text':' Similar to U8_NEXT_UNSAFE(s, i, c).','line_number':75,'multiline':False]
['text':' no need for (c&0xf) because the upper bits are truncated after <<12 in the cast to (UChar)','line_number':84,'multiline':False]
['text':' Should not occur.','line_number':89,'multiline':False]
['text':'*
 * Returns the last code point in [start, p[ if it is valid and in U+1000..U+D7FF.
 * Otherwise returns a negative value.
 ','line_number':93,'multiline':True]
['text':'*
 * Returns the offset from the Jamo T base if [src, limit[ starts with a single Jamo T code point.
 * Otherwise returns a negative value.
 ','line_number':112,'multiline':True]
['text':' Jamo T: E1 86 A8..E1 87 82','line_number':117,'multiline':False]
['text':' The first Jamo T is U+11A8 but JAMO_T_BASE is 11A7.','line_number':121,'multiline':False]
['text':' Offset 0 does not correspond to any conjoining Jamo.','line_number':122,'multiline':False]
['text':' The builder makes ASCII map to ASCII.','line_number':143,'multiline':False]
['text':' The delta only changes the last trail byte.','line_number':149,'multiline':False]
['text':' Decode the code point, add the delta, re-encode.','line_number':155,'multiline':False]
['text':' namespace','line_number':167,'multiline':False]
['text':' ReorderingBuffer -------------------------------------------------------- ***','line_number':169,'multiline':False]
['text':' getBuffer() already did str.setToBogus()','line_number':177,'multiline':False]
['text':' getBuffer() already did str.setToBogus()','line_number':186,'multiline':False]
['text':' Set reorderStart after the last code point with cc<=1 if there is one.','line_number':198,'multiline':False]
['text':' ensured by caller','line_number':215,'multiline':False]
['text':' For equal strings, UTF-8 is at least as long as UTF-16, and at most three times as long.','line_number':218,'multiline':False]
['text':' Compare valid strings from between normalization boundaries.','line_number':222,'multiline':False]
['text':' (Invalid sequences are normalization-inert.)','line_number':223,'multiline':False]
['text':' Not at the end of either string yet.','line_number':230,'multiline':False]
['text':' Ok if not a code point boundary.','line_number':273,'multiline':False]
['text':' insert first code point','line_number':282,'multiline':False]
['text':' getBuffer() already did str.setToBogus()','line_number':366,'multiline':False]
['text':' Inserts c somewhere before the last character.','line_number':398,'multiline':False]
['text':' Requires 0<cc<lastCC which implies reorderStart<limit.','line_number':399,'multiline':False]
['text':' insert c at codePointLimit, after the character with prevCC<=cc','line_number':402,'multiline':False]
['text':' Normalizer2Impl --------------------------------------------------------- ***','line_number':414,'multiline':False]
['text':' contains UnicodeSet *','line_number':422,'multiline':False]
['text':' 8-aligned for noNoDelta bit fields','line_number':444,'multiline':False]
['text':'context','line_number':458,'multiline':True]
['text':'errorCode','line_number':482,'multiline':True]
['text':' Add the start code point of each same-value range of the trie.','line_number':483,'multiline':False]
['text':' Range of code points with same-norm16-value algorithmic decompositions.','line_number':491,'multiline':False]
['text':' They might have different non-zero FCD16 values.','line_number':492,'multiline':False]
['text':' add Hangul LV syllables and LV+1 because of skippables ','line_number':505,'multiline':True]
['text':' add Hangul+1 to continue with other properties ','line_number':510,'multiline':True]
['text':' Add the start code point of each same-value range of the canonical iterator data trie.','line_number':515,'multiline':False]
['text':' Currently only used for the SEGMENT_STARTER property.','line_number':517,'multiline':False]
['text':' Make some effort to support NUL-terminated strings reasonably.','line_number':532,'multiline':False]
['text':' Take the part of the fast quick check loop that does not look up','line_number':533,'multiline':False]
['text':' data and check the first part of the string.','line_number':534,'multiline':False]
['text':' After this prefix, determine the string length to simplify the rest','line_number':535,'multiline':False]
['text':' of the code.','line_number':536,'multiline':False]
['text':' Back out the last character for full processing.','line_number':540,'multiline':False]
['text':' Copy this prefix.','line_number':541,'multiline':False]
['text':' Dual functionality:','line_number':582,'multiline':False]
['text':' buffer!=NULL: normalize','line_number':583,'multiline':False]
['text':' buffer==NULL: isNormalized/spanQuickCheckYes','line_number':584,'multiline':False]
['text':' only for quick check','line_number':602,'multiline':False]
['text':' count code units below the minimum or with irrelevant data for the quick check','line_number':607,'multiline':False]
['text':' unpaired lead surrogate: inert','line_number':626,'multiline':False]
['text':' copy these code units all at once','line_number':630,'multiline':False]
['text':' Check one above-minimum, relevant code point.','line_number':645,'multiline':False]
['text':' "no" or cc out of order','line_number':662,'multiline':False]
['text':' Decompose a short piece of text which is likely to contain characters that','line_number':668,'multiline':False]
['text':' fail the quick check loop and/or where the quick check loop's overhead','line_number':669,'multiline':False]
['text':' is unlikely to be amortized.','line_number':670,'multiline':False]
['text':' Called by the compose() and makeFCD() implementations.','line_number':671,'multiline':False]
['text':' get the decomposition and the lead and trail cc's','line_number':703,'multiline':False]
['text':' Maps to an isCompYesAndZeroCC.','line_number':708,'multiline':False]
['text':' c does not decompose','line_number':713,'multiline':False]
['text':' Hangul syllable: decompose algorithmically','line_number':716,'multiline':False]
['text':' c decomposes, get everything from the variable-length extra data','line_number':720,'multiline':False]
['text':' Dual functionality:','line_number':734,'multiline':False]
['text':' sink != nullptr: normalize','line_number':735,'multiline':False]
['text':' sink == nullptr: isNormalized/spanQuickCheckYes','line_number':736,'multiline':False]
['text':' only for quick check','line_number':746,'multiline':False]
['text':' Fast path: Scan over a sequence of characters below the minimum "no" code point,','line_number':750,'multiline':False]
['text':' or with (decompYes && ccc==0) properties.','line_number':751,'multiline':False]
['text':' isMostDecompYesAndZeroCC(norm16) is false, that is, norm16>=minYesNo,','line_number':774,'multiline':False]
['text':' and the current character at [prevSrc..src[ is not a common case with cc=0','line_number':775,'multiline':False]
['text':' (MIN_NORMAL_MAYBE_YES or JAMO_VT).','line_number':776,'multiline':False]
['text':' It could still be a maybeYes with cc=0.','line_number':777,'multiline':False]
['text':' The fast path looped over yes/0 characters before the current one.','line_number':779,'multiline':False]
['text':' Medium-fast path: Quick check.','line_number':789,'multiline':False]
['text':' Does not decompose.','line_number':791,'multiline':False]
['text':' quick check: "no" or cc out of order','line_number':807,'multiline':False]
['text':' Slow path','line_number':810,'multiline':False]
['text':' Decompose up to and including the current character.','line_number':811,'multiline':False]
['text':' onlyContiguous ','line_number':823,'multiline':True]
['text':' Decompose until the next boundary.','line_number':825,'multiline':False]
['text':' onlyContiguous ','line_number':827,'multiline':True]
['text':' guard before buffer.equals()','line_number':833,'multiline':False]
['text':' We already know there was a change if the original character decomposed;','line_number':837,'multiline':False]
['text':' otherwise compare.','line_number':838,'multiline':False]
['text':' Get the decomposition and the lead and trail cc's.','line_number':867,'multiline':False]
['text':' No comp boundaries around this character.','line_number':871,'multiline':False]
['text':' Maps to an isCompYesAndZeroCC.','line_number':885,'multiline':False]
['text':' norm16!=INERT guarantees that [prevSrc, src[ is valid UTF-8.','line_number':895,'multiline':False]
['text':' We do not see invalid UTF-8 here because','line_number':896,'multiline':False]
['text':' its norm16==INERT is normalization-inert,','line_number':897,'multiline':False]
['text':' so it gets copied unchanged in the fast path,','line_number':898,'multiline':False]
['text':' and we stop the slow path where invalid UTF-8 begins.','line_number':899,'multiline':False]
['text':' c >= 0 is the result of an algorithmic mapping.','line_number':900,'multiline':False]
['text':' does not decompose','line_number':906,'multiline':False]
['text':' Hangul syllable: decompose algorithmically','line_number':911,'multiline':False]
['text':' The character decomposes, get everything from the variable-length extra data.','line_number':920,'multiline':False]
['text':' c does not decompose','line_number':950,'multiline':False]
['text':' Maps to an isCompYesAndZeroCC.','line_number':955,'multiline':False]
['text':' The mapping might decompose further.','line_number':960,'multiline':False]
['text':' Hangul syllable: decompose algorithmically','line_number':966,'multiline':False]
['text':' c decomposes, get everything from the variable-length extra data','line_number':970,'multiline':False]
['text':' The capacity of the buffer must be 30=MAPPING_LENGTH_MASK-1','line_number':976,'multiline':False]
['text':' so that a raw mapping fits that consists of one unit ("rm0")','line_number':977,'multiline':False]
['text':' plus all but the first two code units of the normal mapping.','line_number':978,'multiline':False]
['text':' The maximum length of a normal mapping is 31=MAPPING_LENGTH_MASK.','line_number':979,'multiline':False]
['text':' c does not decompose','line_number':984,'multiline':False]
['text':' Hangul syllable: decompose algorithmically','line_number':987,'multiline':False]
['text':' c decomposes, get everything from the variable-length extra data','line_number':997,'multiline':False]
['text':' length of normal mapping','line_number':1000,'multiline':False]
['text':' Read the raw mapping from before the firstUnit and before the optional ccc/lccc word.','line_number':1002,'multiline':False]
['text':' Bit 7=MAPPING_HAS_CCC_LCCC_WORD','line_number':1003,'multiline':False]
['text':' Copy the normal mapping and replace its first two code units with rm0.','line_number':1010,'multiline':False]
['text':' Just merge the strings at the boundary.','line_number':1032,'multiline':False]
['text':' appendZeroCC() needs limit!=NULL','line_number':1051,'multiline':False]
['text':' c decomposes, get everything from the variable-length extra data','line_number':1072,'multiline':False]
['text':' TRUE if leadCC==0 (hasFCDBoundaryBefore())','line_number':1075,'multiline':False]
['text':' Maps to an isCompYesAndZeroCC.','line_number':1097,'multiline':False]
['text':' c decomposes, get everything from the variable-length extra data','line_number':1100,'multiline':False]
['text':' decomp after-boundary: same as hasFCDBoundaryAfter(),','line_number':1103,'multiline':False]
['text':' fcd16<=1 || trailCC==0','line_number':1104,'multiline':False]
['text':' trailCC>1','line_number':1106,'multiline':False]
['text':' trailCC==0','line_number':1109,'multiline':False]
['text':' if(trailCC==1) test leadCC==0, same as checking for before-boundary','line_number':1111,'multiline':False]
['text':' TRUE if leadCC==0 (hasFCDBoundaryBefore())','line_number':1112,'multiline':False]
['text':'
 * Finds the recomposition result for
 * a forward-combining "lead" character,
 * specified with a pointer to its compositions list,
 * and a backward-combining "trail" character.
 *
 * If the lead and trail characters combine, then this function returns
 * the following "compositeAndFwd" value:
 * Bits 21..1  composite character
 * Bit      0  set if the composite is a forward-combining starter
 * otherwise it returns -1.
 *
 * The compositions list has (trail, compositeAndFwd) pair entries,
 * encoded as either pairs or triples of 16-bit units.
 * The last entry has the high bit of its first unit set.
 *
 * The list is sorted by ascending trail characters (there are no duplicates).
 * A linear search is used.
 *
 * See normalizer2impl.h for a more detailed description
 * of the compositions list format.
 ','line_number':1116,'multiline':True]
['text':' trail character is 0..33FF','line_number':1141,'multiline':False]
['text':' result entry may have 2 or 3 units','line_number':1142,'multiline':False]
['text':' trail character is 3400..10FFFF','line_number':1155,'multiline':False]
['text':' result entry has 3 units','line_number':1156,'multiline':False]
['text':'*
  * @param list some character's compositions list
  * @param set recursively receives the composites from these compositions
  ','line_number':1185,'multiline':True]
['text':'
 * Recomposes the buffer text starting at recomposeStartIndex
 * (which is in NFD - decomposed and canonically ordered),
 * and truncates the buffer contents.
 *
 * Note that recomposition never lengthens the text:
 * Any character consists of either one or two code units;
 * a composition may contain at most one more code unit than the original starter,
 * while the combining mark that is removed has at least one code unit.
 ','line_number':1209,'multiline':True]
['text':' Some of the following variables are not used until we have a forward-combining starter','line_number':1234,'multiline':False]
['text':' and are only initialized now to avoid compiler warnings.','line_number':1235,'multiline':False]
['text':' used as indicator for whether we have a forward-combining starter','line_number':1236,'multiline':False]
['text':' this character combines backward and','line_number':1244,'multiline':False]
['text':' we have seen a starter that combines forward and','line_number':1246,'multiline':False]
['text':' the backward-combining character is not blocked','line_number':1248,'multiline':False]
['text':' c is a Jamo V/T, see if we can compose it with the previous character.','line_number':1252,'multiline':False]
['text':' c is a Jamo Vowel, compose with previous Jamo L and following Jamo T.','line_number':1254,'multiline':False]
['text':' The next character was a Jamo T.','line_number':1265,'multiline':False]
['text':' remove the Jamo V/T','line_number':1268,'multiline':False]
['text':'
                 * No "else" for Jamo T:
                 * Since the input is in NFD, there are no Hangul LV syllables that
                 * a Jamo T could combine with.
                 * All Jamo Ts are combined above when handling Jamo Vs.
                 ','line_number':1278,'multiline':True]
['text':' The starter and the combining mark (c) do combine.','line_number':1290,'multiline':False]
['text':' Replace the starter with the composite, remove the combining mark.','line_number':1293,'multiline':False]
['text':' pRemove & p: start & limit of the combining mark','line_number':1294,'multiline':False]
['text':' both are supplementary','line_number':1297,'multiline':False]
['text':' The composite is shorter than the starter,','line_number':1302,'multiline':False]
['text':' move the intermediate characters forward one.','line_number':1303,'multiline':False]
['text':' The composite is longer than the starter,','line_number':1313,'multiline':False]
['text':' move the intermediate characters back one.','line_number':1314,'multiline':False]
['text':' temporarily increment for the loop boundary','line_number':1316,'multiline':False]
['text':' undo the temporary increment','line_number':1323,'multiline':False]
['text':' both are on the BMP','line_number':1325,'multiline':False]
['text':' remove the combining mark by moving the following text over it ','line_number':1329,'multiline':True]
['text':' Keep prevCC because we removed the combining mark.','line_number':1339,'multiline':False]
['text':' Is the composite a starter that combines forward?','line_number':1344,'multiline':False]
['text':' We combined; continue with looking for compositions.','line_number':1352,'multiline':False]
['text':' no combination this time','line_number':1357,'multiline':False]
['text':' If c did not combine, then check if it is a starter.','line_number':1363,'multiline':False]
['text':' Found a new starter.','line_number':1365,'multiline':False]
['text':' It may combine with something, prepare for it.','line_number':1367,'multiline':False]
['text':' FCC: no discontiguous compositions; any intervening character blocks.','line_number':1377,'multiline':False]
['text':' maps an out-of-range 'a' to inert norm16','line_number':1386,'multiline':False]
['text':' a combines forward.','line_number':1391,'multiline':False]
['text':' not b==0!','line_number':1404,'multiline':False]
['text':' 'a' has a compositions list in extraData','line_number':1410,'multiline':False]
['text':' composite 'a' has both mapping & compositions list','line_number':1412,'multiline':False]
['text':' mapping pointer','line_number':1413,'multiline':False]
['text':' +1 to skip the first unit with the mapping length','line_number':1414,'multiline':False]
['text':' + mapping length','line_number':1415,'multiline':False]
['text':' combine(list, b) requires a valid code point b','line_number':1423,'multiline':False]
['text':' Very similar to composeQuickCheck(): Make the same changes in both places if relevant.','line_number':1434,'multiline':False]
['text':' doCompose: normalize','line_number':1435,'multiline':False]
['text':' !doCompose: isNormalized (buffer must be empty and initialized)','line_number':1436,'multiline':False]
['text':' Fast path: Scan over a sequence of characters below the minimum "no or maybe" code point,','line_number':1464,'multiline':False]
['text':' or with (compYes && ccc==0) properties.','line_number':1465,'multiline':False]
['text':' isCompYesAndZeroCC(norm16) is false, that is, norm16>=minNoNo.','line_number':1497,'multiline':False]
['text':' The current character is either a "noNo" (has a mapping)','line_number':1498,'multiline':False]
['text':' or a "maybeYes" (combines backward)','line_number':1499,'multiline':False]
['text':' or a "yesYes" with ccc!=0.','line_number':1500,'multiline':False]
['text':' It is not a Hangul syllable or Jamo L because those have "yes" properties.','line_number':1501,'multiline':False]
['text':' Medium-fast path: Handle cases that do not require full decomposition and recomposition.','line_number':1503,'multiline':False]
['text':' minNoNo <= norm16 < minMaybeYes','line_number':1504,'multiline':False]
['text':' Fast path for mapping a character that is immediately surrounded by boundaries.','line_number':1508,'multiline':False]
['text':' In this case, we need not decompose around the current character.','line_number':1509,'multiline':False]
['text':' Maps to a single isCompYesAndZeroCC character','line_number':1511,'multiline':False]
['text':' which also implies hasCompBoundaryBefore.','line_number':1512,'multiline':False]
['text':' The mapping is comp-normalized which also implies hasCompBoundaryBefore.','line_number':1525,'multiline':False]
['text':' The current character maps to nothing.','line_number':1540,'multiline':False]
['text':' Simply omit it from the output if there is a boundary before _or_ after it.','line_number':1541,'multiline':False]
['text':' The character itself implies no boundaries.','line_number':1542,'multiline':False]
['text':' Other "noNo" type, or need to examine more text around this character:','line_number':1552,'multiline':False]
['text':' Fall through to the slow path.','line_number':1553,'multiline':False]
['text':' The current character is a Jamo Vowel,','line_number':1557,'multiline':False]
['text':' compose with previous Jamo L and following Jamo T.','line_number':1558,'multiline':False]
['text':' The next character is a Jamo T.','line_number':1568,'multiline':False]
['text':' No Jamo T follows, not even via decomposition.','line_number':1571,'multiline':False]
['text':' Replace the Jamo L as well.','line_number':1580,'multiline':False]
['text':' If we see L+V+x where x!=T then we drop to the slow path,','line_number':1590,'multiline':False]
['text':' decompose and recompose.','line_number':1591,'multiline':False]
['text':' This is to deal with NFKC finding normal L and V but a','line_number':1592,'multiline':False]
['text':' compatibility variant of a T.','line_number':1593,'multiline':False]
['text':' We need to either fully compose that combination here','line_number':1594,'multiline':False]
['text':' (which would complicate the code and may not work with strange custom data)','line_number':1595,'multiline':False]
['text':' or use the slow path.','line_number':1596,'multiline':False]
['text':' The current character is a Jamo Trailing consonant,','line_number':1599,'multiline':False]
['text':' compose with previous Hangul LV that does not contain a Jamo T.','line_number':1600,'multiline':False]
['text':' Replace the Hangul LV as well.','line_number':1605,'multiline':False]
['text':' No matching context, or may need to decompose surrounding text first:','line_number':1615,'multiline':False]
['text':' Fall through to the slow path.','line_number':1616,'multiline':False]
['text':' norm16 >= MIN_YES_YES_WITH_CC','line_number':1617,'multiline':False]
['text':' One or more combining marks that do not combine-back:','line_number':1618,'multiline':False]
['text':' Check for canonical order, copy unchanged if ok and','line_number':1619,'multiline':False]
['text':' if followed by a character with a boundary-before.','line_number':1620,'multiline':False]
['text':' cc!=0','line_number':1621,'multiline':False]
['text':' FCC ','line_number':1622,'multiline':True]
['text':' Fails FCD test, need to decompose and contiguously recompose.','line_number':1623,'multiline':False]
['text':' If !onlyContiguous (not FCC), then we ignore the tccc of','line_number':1628,'multiline':False]
['text':' the previous character which passed the quick check "yes && ccc==0" test.','line_number':1629,'multiline':False]
['text':' src is after the last in-order combining mark.','line_number':1655,'multiline':False]
['text':' If there is a boundary here, then we continue with no change.','line_number':1656,'multiline':False]
['text':' Use the slow path. There is no boundary in [prevSrc, src[.','line_number':1663,'multiline':False]
['text':' Slow path: Find the nearest boundaries around the current character,','line_number':1667,'multiline':False]
['text':' decompose and recompose.','line_number':1668,'multiline':False]
['text':' We know there is not a boundary here.','line_number':1680,'multiline':False]
['text':' !stopAtCompBoundary ','line_number':1681,'multiline':True]
['text':' Decompose until the next boundary.','line_number':1683,'multiline':False]
['text':' stopAtCompBoundary ','line_number':1684,'multiline':True]
['text':' guard before buffer.equals()','line_number':1689,'multiline':False]
['text':' Very similar to compose(): Make the same changes in both places if relevant.','line_number':1705,'multiline':False]
['text':' pQCResult==NULL: spanQuickCheckYes','line_number':1706,'multiline':False]
['text':' pQCResult!=NULL: quickCheck (*pQCResult must be UNORM_YES)','line_number':1707,'multiline':False]
['text':' Fast path: Scan over a sequence of characters below the minimum "no or maybe" code point,','line_number':1728,'multiline':False]
['text':' or with (compYes && ccc==0) properties.','line_number':1729,'multiline':False]
['text':' isCompYesAndZeroCC(norm16) is false, that is, norm16>=minNoNo.','line_number':1758,'multiline':False]
['text':' The current character is either a "noNo" (has a mapping)','line_number':1759,'multiline':False]
['text':' or a "maybeYes" (combines backward)','line_number':1760,'multiline':False]
['text':' or a "yesYes" with ccc!=0.','line_number':1761,'multiline':False]
['text':' It is not a Hangul syllable or Jamo L because those have "yes" properties.','line_number':1762,'multiline':False]
['text':' FCC ','line_number':1783,'multiline':True]
['text':' The [prevBoundary..prevSrc[ character','line_number':1785,'multiline':False]
['text':' passed the quick check "yes && ccc==0" test','line_number':1786,'multiline':False]
['text':' but is out of canonical order with the current combining mark.','line_number':1787,'multiline':False]
['text':' If !onlyContiguous (not FCC), then we ignore the tccc of','line_number':1789,'multiline':False]
['text':' the previous character which passed the quick check "yes && ccc==0" test.','line_number':1790,'multiline':False]
['text':' src is after the last in-order combining mark.','line_number':1816,'multiline':False]
['text':' appendZeroCC() needs limit!=NULL','line_number':1859,'multiline':False]
['text':' Fast path: Scan over a sequence of characters below the minimum "no or maybe" code point,','line_number':1876,'multiline':False]
['text':' or with (compYes && ccc==0) properties.','line_number':1877,'multiline':False]
['text':' isCompYesAndZeroCC(norm16) is false, that is, norm16>=minNoNo.','line_number':1898,'multiline':False]
['text':' The current character is either a "noNo" (has a mapping)','line_number':1899,'multiline':False]
['text':' or a "maybeYes" (combines backward)','line_number':1900,'multiline':False]
['text':' or a "yesYes" with ccc!=0.','line_number':1901,'multiline':False]
['text':' It is not a Hangul syllable or Jamo L because those have "yes" properties.','line_number':1902,'multiline':False]
['text':' Medium-fast path: Handle cases that do not require full decomposition and recomposition.','line_number':1904,'multiline':False]
['text':' minNoNo <= norm16 < minMaybeYes','line_number':1905,'multiline':False]
['text':' Fast path for mapping a character that is immediately surrounded by boundaries.','line_number':1909,'multiline':False]
['text':' In this case, we need not decompose around the current character.','line_number':1910,'multiline':False]
['text':' Maps to a single isCompYesAndZeroCC character','line_number':1912,'multiline':False]
['text':' which also implies hasCompBoundaryBefore.','line_number':1913,'multiline':False]
['text':' The mapping is comp-normalized which also implies hasCompBoundaryBefore.','line_number':1926,'multiline':False]
['text':' The current character maps to nothing.','line_number':1944,'multiline':False]
['text':' Simply omit it from the output if there is a boundary before _or_ after it.','line_number':1945,'multiline':False]
['text':' The character itself implies no boundaries.','line_number':1946,'multiline':False]
['text':' Other "noNo" type, or need to examine more text around this character:','line_number':1961,'multiline':False]
['text':' Fall through to the slow path.','line_number':1962,'multiline':False]
['text':' Jamo L: E1 84 80..92','line_number':1964,'multiline':False]
['text':' Jamo V: E1 85 A1..B5','line_number':1965,'multiline':False]
['text':' Jamo T: E1 86 A8..E1 87 82','line_number':1966,'multiline':False]
['text':' The current character is a Jamo Vowel,','line_number':1970,'multiline':False]
['text':' compose with previous Jamo L and following Jamo T.','line_number':1971,'multiline':False]
['text':' The next character is a Jamo T.','line_number':1979,'multiline':False]
['text':' No Jamo T follows, not even via decomposition.','line_number':1982,'multiline':False]
['text':' Replace the Jamo L as well.','line_number':1989,'multiline':False]
['text':' If we see L+V+x where x!=T then we drop to the slow path,','line_number':1999,'multiline':False]
['text':' decompose and recompose.','line_number':2000,'multiline':False]
['text':' This is to deal with NFKC finding normal L and V but a','line_number':2001,'multiline':False]
['text':' compatibility variant of a T.','line_number':2002,'multiline':False]
['text':' We need to either fully compose that combination here','line_number':2003,'multiline':False]
['text':' (which would complicate the code and may not work with strange custom data)','line_number':2004,'multiline':False]
['text':' or use the slow path.','line_number':2005,'multiline':False]
['text':' The current character is a Jamo Trailing consonant,','line_number':2008,'multiline':False]
['text':' compose with previous Hangul LV that does not contain a Jamo T.','line_number':2009,'multiline':False]
['text':' Replace the Hangul LV as well.','line_number':2014,'multiline':False]
['text':' No matching context, or may need to decompose surrounding text first:','line_number':2024,'multiline':False]
['text':' Fall through to the slow path.','line_number':2025,'multiline':False]
['text':' norm16 >= MIN_YES_YES_WITH_CC','line_number':2026,'multiline':False]
['text':' One or more combining marks that do not combine-back:','line_number':2027,'multiline':False]
['text':' Check for canonical order, copy unchanged if ok and','line_number':2028,'multiline':False]
['text':' if followed by a character with a boundary-before.','line_number':2029,'multiline':False]
['text':' cc!=0','line_number':2030,'multiline':False]
['text':' FCC ','line_number':2031,'multiline':True]
['text':' Fails FCD test, need to decompose and contiguously recompose.','line_number':2032,'multiline':False]
['text':' If !onlyContiguous (not FCC), then we ignore the tccc of','line_number':2037,'multiline':False]
['text':' the previous character which passed the quick check "yes && ccc==0" test.','line_number':2038,'multiline':False]
['text':' src is after the last in-order combining mark.','line_number':2065,'multiline':False]
['text':' If there is a boundary here, then we continue with no change.','line_number':2066,'multiline':False]
['text':' Use the slow path. There is no boundary in [prevSrc, src[.','line_number':2073,'multiline':False]
['text':' Slow path: Find the nearest boundaries around the current character,','line_number':2077,'multiline':False]
['text':' decompose and recompose.','line_number':2078,'multiline':False]
['text':' We know there is not a boundary here.','line_number':2090,'multiline':False]
['text':' Decompose until the next boundary.','line_number':2093,'multiline':False]
['text':' guard before buffer.equals()','line_number':2099,'multiline':False]
['text':' Note: normalizer2impl.cpp r30982 (2011-nov-27)','line_number':2217,'multiline':False]
['text':' still had getFCDTrie() which built and cached an FCD trie.','line_number':2218,'multiline':False]
['text':' That provided faster access to FCD data than getFCD16FromNormData()','line_number':2219,'multiline':False]
['text':' but required synchronization and consumed some 10kB of heap memory','line_number':2220,'multiline':False]
['text':' in any process that uses FCD (e.g., via collation).','line_number':2221,'multiline':False]
['text':' minDecompNoCP etc. and smallFCD[] are intended to help with any loss of performance,','line_number':2222,'multiline':False]
['text':' at least for ASCII & CJK.','line_number':2223,'multiline':False]
['text':' Ticket 20907 - The optimizer in MSVC/Visual Studio versions below 16.4 has trouble with this','line_number':2225,'multiline':False]
['text':' function on Windows ARM64. As a work-around, we disable optimizations for this function.','line_number':2226,'multiline':False]
['text':' This work-around could/should be removed once the following versions of Visual Studio are no','line_number':2227,'multiline':False]
['text':' longer supported: All versions of VS2017, and versions of VS2019 below 16.4.','line_number':2228,'multiline':False]
['text':' Gets the FCD value from the regular normalization data.','line_number':2232,'multiline':False]
['text':' combining mark','line_number':2237,'multiline':False]
['text':' isDecompNoAlgorithmic(norm16)','line_number':2242,'multiline':False]
['text':' Maps to an isCompYesAndZeroCC.','line_number':2247,'multiline':False]
['text':' no decomposition or Hangul syllable, all zeros','line_number':2253,'multiline':False]
['text':' c decomposes, get everything from the variable-length extra data','line_number':2256,'multiline':False]
['text':' tccc','line_number':2259,'multiline':False]
['text':' lccc','line_number':2261,'multiline':False]
['text':' Dual functionality:','line_number':2269,'multiline':False]
['text':' buffer!=NULL: normalize','line_number':2270,'multiline':False]
['text':' buffer==NULL: isNormalized/quickCheck/spanQuickCheckYes','line_number':2271,'multiline':False]
['text':' Tracks the last FCD-safe boundary, before lccc=0 or after properly-ordered tccc<=1.','line_number':2276,'multiline':False]
['text':' Similar to the prevBoundary in the compose() implementation.','line_number':2277,'multiline':False]
['text':' We know that the previous character's lccc==0.','line_number':2287,'multiline':False]
['text':' Fetching the fcd16 value was deferred for this below-U+0300 code point.','line_number':2288,'multiline':False]
['text':' Note: In this function we use buffer->appendZeroCC() because we track','line_number':2297,'multiline':False]
['text':' the lead and trail combining classes here, rather than leaving it to','line_number':2298,'multiline':False]
['text':' the ReorderingBuffer.','line_number':2299,'multiline':False]
['text':' The exception is the call to decomposeShort() which uses the buffer','line_number':2300,'multiline':False]
['text':' in the normal way.','line_number':2301,'multiline':False]
['text':' count code units with lccc==0','line_number':2308,'multiline':False]
['text':' copy these code units all at once','line_number':2331,'multiline':False]
['text':' We know that the previous character's lccc==0.','line_number':2340,'multiline':False]
['text':' Fetching the fcd16 value was deferred for this below-minLcccCP code point.','line_number':2342,'multiline':False]
['text':' Need to fetch the previous character's FCD value because','line_number':2356,'multiline':False]
['text':' prevFCD16 was just for the trail surrogate code point.','line_number':2357,'multiline':False]
['text':' Still known to have lccc==0 because its lead surrogate unit had lccc==0.','line_number':2359,'multiline':False]
['text':' The start of the current character (c).','line_number':2365,'multiline':False]
['text':' The current character (c) at [prevSrc..src[ has a non-zero lead combining class.','line_number':2372,'multiline':False]
['text':' Check for proper order, and decompose locally if necessary.','line_number':2373,'multiline':False]
['text':' proper order: prev tccc <= current lccc','line_number':2375,'multiline':False]
['text':' quick check "no"','line_number':2385,'multiline':False]
['text':'
             * Back out the part of the source that we copied or appended
             * already but is now going to be decomposed.
             * prevSrc is set to after what was copied/appended.
             ','line_number':2387,'multiline':True]
['text':'
             * Find the part of the source that needs to be decomposed,
             * up to the next safe boundary.
             ','line_number':2393,'multiline':True]
['text':'
             * The source text does not fulfill the conditions for FCD.
             * Decompose and reorder a limited piece of the text.
             ','line_number':2398,'multiline':True]
['text':' appendZeroCC() needs limit!=NULL','line_number':2439,'multiline':False]
['text':' CanonicalIterator data -------------------------------------------------- ***','line_number':2478,'multiline':False]
['text':' origin is the first character whose decomposition starts with','line_number':2492,'multiline':False]
['text':' the character for which we are setting the value.','line_number':2493,'multiline':False]
['text':' origin is not the first character, or it is U+0000.','line_number':2496,'multiline':False]
['text':' C++ class for friend access to private Normalizer2Impl members.','line_number':2518,'multiline':False]
['text':' UInitOnce instantiation function for CanonIterData','line_number':2526,'multiline':False]
['text':' Call Normalizer2Impl::makeCanonIterDataFromNorm16() for a range of same-norm16 characters.','line_number':2546,'multiline':False]
['text':' Inert, or 2-way mapping (including Hangul syllable).','line_number':2570,'multiline':False]
['text':' We do not write a canonStartSet for any yesNo character.','line_number':2571,'multiline':False]
['text':' Composites from 2-way mappings are added at runtime from the','line_number':2572,'multiline':False]
['text':' starter's compositions list, and the other characters in','line_number':2573,'multiline':False]
['text':' 2-way mappings get CANON_NOT_SEGMENT_STARTER set because they are','line_number':2574,'multiline':False]
['text':' "maybe" characters.','line_number':2575,'multiline':False]
['text':' not a segment starter if it occurs in a decomposition or has cc!=0','line_number':2582,'multiline':False]
['text':' c has a one-way decomposition','line_number':2590,'multiline':False]
['text':' Do not modify the whole-range norm16 value.','line_number':2592,'multiline':False]
['text':' Maps to an isCompYesAndZeroCC.','line_number':2595,'multiline':False]
['text':' No compatibility mappings for the CanonicalIterator.','line_number':2598,'multiline':False]
['text':' c decomposes, get everything from the variable-length extra data','line_number':2602,'multiline':False]
['text':' original c has cc!=0','line_number':2608,'multiline':False]
['text':' Skip empty mappings (no characters in the decomposition).','line_number':2611,'multiline':False]
['text':' skip over the firstUnit','line_number':2613,'multiline':False]
['text':' add c to first code point's start set','line_number':2614,'multiline':False]
['text':' Set CANON_NOT_SEGMENT_STARTER for each remaining code point of a','line_number':2618,'multiline':False]
['text':' one-way mapping. A 2-way mapping is possible here after','line_number':2619,'multiline':False]
['text':' intermediate algorithmic mapping.','line_number':2620,'multiline':False]
['text':' c decomposed to c2 algorithmically; c has cc==0','line_number':2633,'multiline':False]
['text':' Logically const: Synchronized instantiation.','line_number':2644,'multiline':False]
['text':' Normalizer2 data swapping ----------------------------------------------- ***','line_number':2689,'multiline':False]
['text':' udata_swapDataHeader checks the arguments ','line_number':2708,'multiline':True]
['text':' check data format and format version ','line_number':2714,'multiline':True]
['text':' dataFormat="Nrm2" ','line_number':2718,'multiline':True]
['text':' read the first few indexes ','line_number':2755,'multiline':True]
['text':' get the total length of the data ','line_number':2760,'multiline':True]
['text':' copy the data for inaccessible bytes ','line_number':2771,'multiline':True]
['text':' swap the int32_t indexes[] ','line_number':2778,'multiline':True]
['text':' swap the trie ','line_number':2783,'multiline':True]
['text':' swap the uint16_t extraData[] ','line_number':2788,'multiline':True]
['text':' no need to swap the uint8_t smallFCD[] (new in formatVersion 2) ','line_number':2793,'multiline':True]
['text':' !UCONFIG_NO_NORMALIZATION','line_number':2803,'multiline':False]
