['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]
['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]
['text':'
**************************************************************************
*   Copyright (C) 2002-2016 International Business Machines Corporation
*   and others. All rights reserved.
**************************************************************************
','line_number':3,'multiline':True]
['text':'','line_number':9,'multiline':False]
['text':'  file:  rematch.cpp','line_number':10,'multiline':False]
['text':'','line_number':11,'multiline':False]
['text':'         Contains the implementation of class RegexMatcher,','line_number':12,'multiline':False]
['text':'         which is one of the main API classes for the ICU regular expression package.','line_number':13,'multiline':False]
['text':'','line_number':14,'multiline':False]
['text':' #include <malloc.h>        // Needed for heapcheck testing','line_number':37,'multiline':False]
['text':' Default limit for the size of the back track stack, to avoid system','line_number':42,'multiline':False]
['text':'    failures causedby heap exhaustion.  Units are in 32 bit words, not bytes.','line_number':43,'multiline':False]
['text':' This value puts ICU's limits higher than most other regexp implementations,','line_number':44,'multiline':False]
['text':'    which use recursion rather than the heap, and take more storage per','line_number':45,'multiline':False]
['text':'    backtrack point.','line_number':46,'multiline':False]
['text':'','line_number':47,'multiline':False]
['text':' Time limit counter constant.','line_number':50,'multiline':False]
['text':'   Time limits for expression evaluation are in terms of quanta of work by','line_number':51,'multiline':False]
['text':'   the engine, each of which is 10,000 state saves.','line_number':52,'multiline':False]
['text':'   This constant determines that state saves per tick number.','line_number':53,'multiline':False]
['text':' Test for any of the Unicode line terminating characters.','line_number':57,'multiline':False]
['text':'-----------------------------------------------------------------------------','line_number':65,'multiline':False]
['text':'','line_number':66,'multiline':False]
['text':'   Constructor and Destructor','line_number':67,'multiline':False]
['text':'','line_number':68,'multiline':False]
['text':'-----------------------------------------------------------------------------','line_number':69,'multiline':False]
['text':'','line_number':184,'multiline':False]
['text':'   init()   common initialization for use by all constructors.','line_number':185,'multiline':False]
['text':'            Initialize all fields, get the object into a consistent state.','line_number':186,'multiline':False]
['text':'            This must be done even when the initial status shows an error,','line_number':187,'multiline':False]
['text':'            so that the object is initialized sufficiently well for the destructor','line_number':188,'multiline':False]
['text':'            to run safely.','line_number':189,'multiline':False]
['text':'','line_number':190,'multiline':False]
['text':'','line_number':236,'multiline':False]
['text':'  init2()   Common initialization for use by RegexMatcher constructors, part 2.','line_number':237,'multiline':False]
['text':'            This handles the common setup to be done after the Pattern is available.','line_number':238,'multiline':False]
['text':'','line_number':239,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':274,'multiline':False]
['text':'','line_number':275,'multiline':False]
['text':'    appendReplacement','line_number':276,'multiline':False]
['text':'','line_number':277,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':278,'multiline':False]
['text':'','line_number':299,'multiline':False]
['text':'    appendReplacement, UText mode','line_number':300,'multiline':False]
['text':'','line_number':301,'multiline':False]
['text':' Copy input string from the end of previous match to start of current match','line_number':317,'multiline':False]
['text':' scan the replacement text, looking for substitutions ($n) and \escapes.','line_number':344,'multiline':False]
['text':'  TODO:  optimize this loop by efficiently scanning for '$' or '\',','line_number':345,'multiline':False]
['text':'         move entire ranges not containing substitutions.','line_number':346,'multiline':False]
['text':' Backslash Escape.  Copy the following char out without further checks.','line_number':350,'multiline':False]
['text':'                    Note:  Surrogate pairs don't need any special handling','line_number':351,'multiline':False]
['text':'                           The second half wont be a '$' or a '\', and','line_number':352,'multiline':False]
['text':'                           will move to the dest normally on the next','line_number':353,'multiline':False]
['text':'                           loop iteration.','line_number':354,'multiline':False]
['text':'U','line_number':360,'multiline':True]
['text':'u','line_number':360,'multiline':True]
['text':' We have a \udddd or \Udddddddd escape sequence.','line_number':361,'multiline':False]
['text':' TODO:  Report errors for mal-formed \u escapes?','line_number':377,'multiline':False]
['text':'        As this is, the original sequence is output, which may be OK.','line_number':378,'multiline':False]
['text':' Plain backslash escape.  Just put out the escaped character.','line_number':387,'multiline':False]
['text':' Normal char, not a $.  Copy it out without further checks.','line_number':401,'multiline':False]
['text':' We've got a $.  Pick up a capture group name or number if one follows.','line_number':414,'multiline':False]
['text':' Consume digits so long as the resulting group number <= the number of','line_number':415,'multiline':False]
['text':' number of capture groups in the pattern.','line_number':416,'multiline':False]
['text':' Scan for a Named Capture Group, ${name}.','line_number':422,'multiline':False]
['text':' A..Z','line_number':429,'multiline':False]
['text':' a..z','line_number':430,'multiline':False]
['text':' 0..9','line_number':431,'multiline':False]
['text':' Character was something other than a name char or a closing '}'','line_number':439,'multiline':False]
['text':' $n    Scan for a capture group number','line_number':445,'multiline':False]
['text':' Don't consume the next digit if it makes the capture group number too big.','line_number':457,'multiline':False]
['text':' $ not followed by capture group name or number.','line_number':468,'multiline':False]
['text':' End of $ capture group handling','line_number':475,'multiline':False]
['text':' End of per-character loop through the replacement string.','line_number':476,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':483,'multiline':False]
['text':'','line_number':484,'multiline':False]
['text':'    appendTail     Intended to be used in conjunction with appendReplacement()','line_number':485,'multiline':False]
['text':'                   To the destination string, append everything following','line_number':486,'multiline':False]
['text':'                   the last match position from the input string.','line_number':487,'multiline':False]
['text':'','line_number':488,'multiline':False]
['text':'                   Note:  Match ranges do not affect appendTail or appendReplacement','line_number':489,'multiline':False]
['text':'','line_number':490,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':491,'multiline':False]
['text':'','line_number':505,'multiline':False]
['text':'   appendTail, UText mode','line_number':506,'multiline':False]
['text':'','line_number':507,'multiline':False]
['text':' buffer overflow','line_number':528,'multiline':False]
['text':' unterminated','line_number':535,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':547,'multiline':False]
['text':'','line_number':548,'multiline':False]
['text':'   end','line_number':549,'multiline':False]
['text':'','line_number':550,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':551,'multiline':False]
['text':' Get the position within the stack frame of the variables for','line_number':576,'multiline':False]
['text':'    this capture group.','line_number':577,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':591,'multiline':False]
['text':'','line_number':592,'multiline':False]
['text':'   findProgressInterrupt  This function is called once for each advance in the target','line_number':593,'multiline':False]
['text':'                          string from the find() function, and calls the user progress callback','line_number':594,'multiline':False]
['text':'                          function if there is one installed.','line_number':595,'multiline':False]
['text':'','line_number':596,'multiline':False]
['text':'         Return:  TRUE if the find operation is to be terminated.','line_number':597,'multiline':False]
['text':'                  FALSE if the find operation is to continue running.','line_number':598,'multiline':False]
['text':'','line_number':599,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':600,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':609,'multiline':False]
['text':'','line_number':610,'multiline':False]
['text':'   find()','line_number':611,'multiline':False]
['text':'','line_number':612,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':613,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':623,'multiline':False]
['text':'','line_number':624,'multiline':False]
['text':'   find()','line_number':625,'multiline':False]
['text':'','line_number':626,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':627,'multiline':False]
['text':' Start at the position of the last match end.  (Will be zero if the','line_number':629,'multiline':False]
['text':'   matcher has been reset.)','line_number':630,'multiline':False]
['text':'','line_number':631,'multiline':False]
['text':' Save the position of any previous successful match.','line_number':650,'multiline':False]
['text':' Previous match had zero length.  Move start position up one position','line_number':654,'multiline':False]
['text':'  to avoid sending find() into a loop on zero-length matches.','line_number':655,'multiline':False]
['text':' A previous find() failed to match.  Don't try again.','line_number':667,'multiline':False]
['text':'   (without this test, a pattern with a zero-length match','line_number':668,'multiline':False]
['text':'    could match again at the end of an input string.)','line_number':669,'multiline':False]
['text':' Compute the position in the input string beyond which a match can not begin, because','line_number':676,'multiline':False]
['text':'   the minimum length match would extend past the end of the input.','line_number':677,'multiline':False]
['text':'   Note:  some patterns that cannot match anything will have fMinMatchLength==Max Int.','line_number':678,'multiline':False]
['text':'          Be aware of possible overflows if making changes here.','line_number':679,'multiline':False]
['text':' We don't know exactly how long the minimum match length is in native characters.','line_number':689,'multiline':False]
['text':' Treat anything > 0 as 1.','line_number':690,'multiline':False]
['text':' No optimization was found.','line_number':699,'multiline':False]
['text':'  Try a match at each input position.','line_number':700,'multiline':False]
['text':' Note that it's perfectly OK for a pattern to have a zero-length','line_number':716,'multiline':False]
['text':'   match at the end of a string, so we must make sure that the loop','line_number':717,'multiline':False]
['text':'   runs with startPos == testStartLimit the last time through.','line_number':718,'multiline':False]
['text':' Matches are only possible at the start of the input string','line_number':725,'multiline':False]
['text':'   (pattern begins with ^ or \A)','line_number':726,'multiline':False]
['text':' Match may start on any char from a pre-computed set.','line_number':740,'multiline':False]
['text':' c will be -1 (U_SENTINEL) at end of text, in which case we','line_number':747,'multiline':False]
['text':' skip this next block (so we don't have a negative array index)','line_number':748,'multiline':False]
['text':' and handle end of text in the following block.','line_number':749,'multiline':False]
['text':' Match starts on exactly one char.','line_number':775,'multiline':False]
['text':' Note that it's perfectly OK for a pattern to have a zero-length','line_number':843,'multiline':False]
['text':'   match at the end of a string, so we must make sure that the loop','line_number':844,'multiline':False]
['text':'   runs with startPos == testStartLimit the last time through.','line_number':845,'multiline':False]
['text':' Note that it's perfectly OK for a pattern to have a zero-length','line_number':872,'multiline':False]
['text':'   match at the end of a string, so we must make sure that the loop','line_number':873,'multiline':False]
['text':'   runs with startPos == testStartLimit the last time through.','line_number':874,'multiline':False]
['text':' Note:  Reset() is specified by Java Matcher documentation.','line_number':898,'multiline':False]
['text':'        This will reset the region to be the full input length.','line_number':899,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':915,'multiline':False]
['text':'','line_number':916,'multiline':False]
['text':'   findUsingChunk() -- like find(), but with the advance knowledge that the','line_number':917,'multiline':False]
['text':'                       entire string is available in the UText's chunk buffer.','line_number':918,'multiline':False]
['text':'','line_number':919,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':920,'multiline':False]
['text':' Start at the position of the last match end.  (Will be zero if the','line_number':922,'multiline':False]
['text':'   matcher has been reset.','line_number':923,'multiline':False]
['text':'','line_number':924,'multiline':False]
['text':' Save the position of any previous successful match.','line_number':934,'multiline':False]
['text':' Previous match had zero length.  Move start position up one position','line_number':938,'multiline':False]
['text':'  to avoid sending find() into a loop on zero-length matches.','line_number':939,'multiline':False]
['text':' A previous find() failed to match.  Don't try again.','line_number':949,'multiline':False]
['text':'   (without this test, a pattern with a zero-length match','line_number':950,'multiline':False]
['text':'    could match again at the end of an input string.)','line_number':951,'multiline':False]
['text':' Compute the position in the input string beyond which a match can not begin, because','line_number':958,'multiline':False]
['text':'   the minimum length match would extend past the end of the input.','line_number':959,'multiline':False]
['text':'   Note:  some patterns that cannot match anything will have fMinMatchLength==Max Int.','line_number':960,'multiline':False]
['text':'          Be aware of possible overflows if making changes here.','line_number':961,'multiline':False]
['text':'   Note:  a match can begin at inputBuf + testLen; it is an inclusive limit.','line_number':962,'multiline':False]
['text':' No optimization was found.','line_number':975,'multiline':False]
['text':'  Try a match at each input position.','line_number':976,'multiline':False]
['text':' Note that it's perfectly OK for a pattern to have a zero-length','line_number':990,'multiline':False]
['text':'   match at the end of a string, so we must make sure that the loop','line_number':991,'multiline':False]
['text':'   runs with startPos == testLen the last time through.','line_number':992,'multiline':False]
['text':' Matches are only possible at the start of the input string','line_number':999,'multiline':False]
['text':'   (pattern begins with ^ or \A)','line_number':1000,'multiline':False]
['text':' Match may start on any char from a pre-computed set.','line_number':1014,'multiline':False]
['text':' like c = inputBuf[startPos++];','line_number':1018,'multiline':False]
['text':' Match starts on exactly one char.','line_number':1043,'multiline':False]
['text':' like c = inputBuf[startPos++];','line_number':1048,'multiline':False]
['text':' Note that it's perfectly OK for a pattern to have a zero-length','line_number':1101,'multiline':False]
['text':'   match at the end of a string, so we must make sure that the loop','line_number':1102,'multiline':False]
['text':'   runs with startPos == testLen the last time through.','line_number':1103,'multiline':False]
['text':' Note that it's perfectly OK for a pattern to have a zero-length','line_number':1128,'multiline':False]
['text':'   match at the end of a string, so we must make sure that the loop','line_number':1129,'multiline':False]
['text':'   runs with startPos == testLen the last time through.','line_number':1130,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1146,'multiline':False]
['text':'','line_number':1147,'multiline':False]
['text':'  group()','line_number':1148,'multiline':False]
['text':'','line_number':1149,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1150,'multiline':False]
['text':'  Return immutable shallow clone','line_number':1155,'multiline':False]
['text':'  Return immutable shallow clone','line_number':1160,'multiline':False]
['text':' A capture group wasn't part of the match','line_number':1191,'multiline':False]
['text':' Get the group length using a utext_extract preflight.','line_number':1211,'multiline':False]
['text':'    UText is actually pretty efficient at this when underlying encoding is UTF-16.','line_number':1212,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1231,'multiline':False]
['text':'','line_number':1232,'multiline':False]
['text':'  appendGroup() -- currently internal only, appends a group to a UText rather','line_number':1233,'multiline':False]
['text':'                   than replacing its contents','line_number':1234,'multiline':False]
['text':'','line_number':1235,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1236,'multiline':False]
['text':' A capture group wasn't part of the match','line_number':1270,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1302,'multiline':False]
['text':'','line_number':1303,'multiline':False]
['text':'  groupCount()','line_number':1304,'multiline':False]
['text':'','line_number':1305,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1306,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1311,'multiline':False]
['text':'','line_number':1312,'multiline':False]
['text':'  hasAnchoringBounds()','line_number':1313,'multiline':False]
['text':'','line_number':1314,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1315,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1321,'multiline':False]
['text':'','line_number':1322,'multiline':False]
['text':'  hasTransparentBounds()','line_number':1323,'multiline':False]
['text':'','line_number':1324,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1325,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1332,'multiline':False]
['text':'','line_number':1333,'multiline':False]
['text':'  hitEnd()','line_number':1334,'multiline':False]
['text':'','line_number':1335,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1336,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1342,'multiline':False]
['text':'','line_number':1343,'multiline':False]
['text':'  input()','line_number':1344,'multiline':False]
['text':'','line_number':1345,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1346,'multiline':False]
['text':' overflow, length status','line_number':1355,'multiline':False]
['text':' unterminated warning','line_number':1360,'multiline':False]
['text':' pointer assignment, rather than operator=','line_number':1363,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1369,'multiline':False]
['text':'','line_number':1370,'multiline':False]
['text':'  inputText()','line_number':1371,'multiline':False]
['text':'','line_number':1372,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1373,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1379,'multiline':False]
['text':'','line_number':1380,'multiline':False]
['text':'  getInput() -- like inputText(), but makes a clone or copies into another UText','line_number':1381,'multiline':False]
['text':'','line_number':1382,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1383,'multiline':False]
['text':' buffer overflow error','line_number':1402,'multiline':False]
['text':' not terminated warning','line_number':1410,'multiline':False]
['text':'  In the following test, we're really only interested in whether the UText should switch','line_number':1427,'multiline':False]
['text':'  between heap and stack allocation.  If length hasn't changed, we won't, so the chunkContents','line_number':1428,'multiline':False]
['text':'  will still point to the correct data.','line_number':1429,'multiline':False]
['text':' Update to the latest length.','line_number':1433,'multiline':False]
['text':' For example, (utext_nativeLength(ut) != ut->nativeIndexingLimit).','line_number':1434,'multiline':False]
['text':' Update the chunk description.','line_number':1437,'multiline':False]
['text':' The buffer may have switched between stack- and heap-based.','line_number':1438,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1449,'multiline':False]
['text':'','line_number':1450,'multiline':False]
['text':'  lookingAt()','line_number':1451,'multiline':False]
['text':'','line_number':1452,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1453,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1520,'multiline':False]
['text':'','line_number':1521,'multiline':False]
['text':'  matches()','line_number':1522,'multiline':False]
['text':'','line_number':1523,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1524,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1592,'multiline':False]
['text':'','line_number':1593,'multiline':False]
['text':'    pattern','line_number':1594,'multiline':False]
['text':'','line_number':1595,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1596,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1603,'multiline':False]
['text':'','line_number':1604,'multiline':False]
['text':'    region','line_number':1605,'multiline':False]
['text':'','line_number':1606,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1607,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1655,'multiline':False]
['text':'','line_number':1656,'multiline':False]
['text':'    regionEnd','line_number':1657,'multiline':False]
['text':'','line_number':1658,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1659,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1668,'multiline':False]
['text':'','line_number':1669,'multiline':False]
['text':'    regionStart','line_number':1670,'multiline':False]
['text':'','line_number':1671,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1672,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1682,'multiline':False]
['text':'','line_number':1683,'multiline':False]
['text':'    replaceAll','line_number':1684,'multiline':False]
['text':'','line_number':1685,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1686,'multiline':False]
['text':'','line_number':1707,'multiline':False]
['text':'    replaceAll, UText mode','line_number':1708,'multiline':False]
['text':'','line_number':1709,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1743,'multiline':False]
['text':'','line_number':1744,'multiline':False]
['text':'    replaceFirst','line_number':1745,'multiline':False]
['text':'','line_number':1746,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1747,'multiline':False]
['text':'','line_number':1764,'multiline':False]
['text':'    replaceFirst, UText mode','line_number':1765,'multiline':False]
['text':'','line_number':1766,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1797,'multiline':False]
['text':'','line_number':1798,'multiline':False]
['text':'     requireEnd','line_number':1799,'multiline':False]
['text':'','line_number':1800,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1801,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1807,'multiline':False]
['text':'','line_number':1808,'multiline':False]
['text':'     reset','line_number':1809,'multiline':False]
['text':'','line_number':1810,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1811,'multiline':False]
['text':'resetStack(); // more expensive than it looks...','line_number':1837,'multiline':False]
['text':'  Do the following for any UnicodeString.','line_number':1855,'multiline':False]
['text':'  This is for compatibility for those clients who modify the input string "live" during regex operations.','line_number':1856,'multiline':False]
['text':'RegexMatcher &RegexMatcher::reset(const UChar *) {
    fDeferredStatus = U_INTERNAL_PROGRAM_ERROR;
    return *this;
}','line_number':1899,'multiline':True]
['text':' Reset also resets the region to be the entire string.','line_number':1908,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1919,'multiline':False]
['text':'','line_number':1920,'multiline':False]
['text':'    refresh','line_number':1921,'multiline':False]
['text':'','line_number':1922,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1923,'multiline':False]
['text':'  Shallow read-only clone of the new UText into the existing input UText','line_number':1937,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1957,'multiline':False]
['text':'','line_number':1958,'multiline':False]
['text':'    setTrace','line_number':1959,'multiline':False]
['text':'','line_number':1960,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':1961,'multiline':False]
['text':'*
  *  UText, replace entire contents of the destination UText with a substring of the source UText.
  *
  *     @param src    The source UText
  *     @param dest   The destination UText. Must be writable.
  *                   May be NULL, in which case a new UText will be allocated.
  *     @param start  Start index of source substring.
  *     @param limit  Limit index of source substring.
  *     @param status An error code.
  ','line_number':1968,'multiline':True]
['text':' Leave space for terminating Nul.','line_number':1997,'multiline':False]
['text':' Caller did not provide a prexisting UText.','line_number':2008,'multiline':False]
['text':' Open a new one, and have it adopt the text buffer storage.','line_number':2009,'multiline':False]
['text':'---------------------------------------------------------------------','line_number':2029,'multiline':False]
['text':'','line_number':2030,'multiline':False]
['text':'   split','line_number':2031,'multiline':False]
['text':'','line_number':2032,'multiline':False]
['text':'---------------------------------------------------------------------','line_number':2033,'multiline':False]
['text':'','line_number':2066,'multiline':False]
['text':'   split, UText mode','line_number':2067,'multiline':False]
['text':'','line_number':2068,'multiline':False]
['text':'','line_number':2074,'multiline':False]
['text':' Check arguments for validity','line_number':2075,'multiline':False]
['text':'','line_number':2076,'multiline':False]
['text':'','line_number':2086,'multiline':False]
['text':' Reset for the input text','line_number':2087,'multiline':False]
['text':'','line_number':2088,'multiline':False]
['text':'','line_number':2095,'multiline':False]
['text':' Loop through the input text, searching for the delimiter pattern','line_number':2096,'multiline':False]
['text':'','line_number':2097,'multiline':False]
['text':' There is one or zero output string left.','line_number':2102,'multiline':False]
['text':' Fill the last output string with whatever is left from the input, then exit the loop.','line_number':2103,'multiline':False]
['text':'  ( i will be == destCapacity if we filled the output array while processing','line_number':2104,'multiline':False]
['text':'    capture groups of the delimiter expression, in which case we will discard the','line_number':2105,'multiline':False]
['text':'    last capture group saved in favor of the unprocessed remainder of the','line_number':2106,'multiline':False]
['text':'    input string.)','line_number':2107,'multiline':False]
['text':' We found another delimiter.  Move everything from where we started looking','line_number':2148,'multiline':False]
['text':'  up until the start of the delimiter into the next output string.','line_number':2149,'multiline':False]
['text':' If the delimiter pattern has capturing parentheses, the captured','line_number':2184,'multiline':False]
['text':'  text goes out into the next n destination strings.','line_number':2185,'multiline':False]
['text':' Never fill the last available output string with capture group text.','line_number':2189,'multiline':False]
['text':' It will filled with the last field, the remainder of the','line_number':2190,'multiline':False]
['text':'  unsplit input text.','line_number':2191,'multiline':False]
['text':' The delimiter was at the end of the string.  We're done, but first','line_number':2200,'multiline':False]
['text':' we output one last empty string, for the empty field following','line_number':2201,'multiline':False]
['text':'   the delimiter at the end of input.','line_number':2202,'multiline':False]
['text':' We ran off the end of the input while looking for the next delimiter.','line_number':2218,'multiline':False]
['text':' All the remaining text goes into the current output string.','line_number':2219,'multiline':False]
['text':' end of for loop','line_number':2258,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2263,'multiline':False]
['text':'','line_number':2264,'multiline':False]
['text':'     start','line_number':2265,'multiline':False]
['text':'','line_number':2266,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2267,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2276,'multiline':False]
['text':'','line_number':2277,'multiline':False]
['text':'     start(int32_t group, UErrorCode &status)','line_number':2278,'multiline':False]
['text':'','line_number':2279,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2280,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2316,'multiline':False]
['text':'','line_number':2317,'multiline':False]
['text':'     useAnchoringBounds','line_number':2318,'multiline':False]
['text':'','line_number':2319,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2320,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2329,'multiline':False]
['text':'','line_number':2330,'multiline':False]
['text':'     useTransparentBounds','line_number':2331,'multiline':False]
['text':'','line_number':2332,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2333,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2341,'multiline':False]
['text':'','line_number':2342,'multiline':False]
['text':'     setTimeLimit','line_number':2343,'multiline':False]
['text':'','line_number':2344,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2345,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2362,'multiline':False]
['text':'','line_number':2363,'multiline':False]
['text':'     getTimeLimit','line_number':2364,'multiline':False]
['text':'','line_number':2365,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2366,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2372,'multiline':False]
['text':'','line_number':2373,'multiline':False]
['text':'     setStackLimit','line_number':2374,'multiline':False]
['text':'','line_number':2375,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2376,'multiline':False]
['text':' Reset the matcher.  This is needed here in case there is a current match','line_number':2390,'multiline':False]
['text':'    whose final stack frame (containing the match results, pointed to by fFrame)','line_number':2391,'multiline':False]
['text':'    would be lost by resizing to a smaller stack size.','line_number':2392,'multiline':False]
['text':' Unlimited stack expansion','line_number':2396,'multiline':False]
['text':' Change the units of the limit  from bytes to ints, and bump the size up','line_number':2399,'multiline':False]
['text':'   to be big enough to hold at least one stack frame for the pattern,','line_number':2400,'multiline':False]
['text':'   if it isn't there already.','line_number':2401,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2412,'multiline':False]
['text':'','line_number':2413,'multiline':False]
['text':'     getStackLimit','line_number':2414,'multiline':False]
['text':'','line_number':2415,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2416,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2422,'multiline':False]
['text':'','line_number':2423,'multiline':False]
['text':'     setMatchCallback','line_number':2424,'multiline':False]
['text':'','line_number':2425,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2426,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2438,'multiline':False]
['text':'','line_number':2439,'multiline':False]
['text':'     getMatchCallback','line_number':2440,'multiline':False]
['text':'','line_number':2441,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2442,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2454,'multiline':False]
['text':'','line_number':2455,'multiline':False]
['text':'     setMatchCallback','line_number':2456,'multiline':False]
['text':'','line_number':2457,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2458,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2470,'multiline':False]
['text':'','line_number':2471,'multiline':False]
['text':'     getMatchCallback','line_number':2472,'multiline':False]
['text':'','line_number':2473,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2474,'multiline':False]
['text':'================================================================================','line_number':2486,'multiline':False]
['text':'','line_number':2487,'multiline':False]
['text':'    Code following this point in this file is the internal','line_number':2488,'multiline':False]
['text':'    Match Engine Implementation.','line_number':2489,'multiline':False]
['text':'','line_number':2490,'multiline':False]
['text':'================================================================================','line_number':2491,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2494,'multiline':False]
['text':'','line_number':2495,'multiline':False]
['text':'   resetStack','line_number':2496,'multiline':False]
['text':'           Discard any previous contents of the state save stack, and initialize a','line_number':2497,'multiline':False]
['text':'           new stack frame to all -1.  The -1s are needed for capture group limits,','line_number':2498,'multiline':False]
['text':'           where they indicate that a group has not yet matched anything.','line_number':2499,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2500,'multiline':False]
['text':' Discard any previous contents of the state save stack, and initialize a','line_number':2502,'multiline':False]
['text':'  new stack frame with all -1 data.  The -1s are needed for capture group limits,','line_number':2503,'multiline':False]
['text':'  where they indicate that a group has not yet matched anything.','line_number':2504,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2521,'multiline':False]
['text':'','line_number':2522,'multiline':False]
['text':'   isWordBoundary','line_number':2523,'multiline':False]
['text':'                     in perl, "xab..cd..", \b is true at positions 0,3,5,7','line_number':2524,'multiline':False]
['text':'                     For us,','line_number':2525,'multiline':False]
['text':'                       If the current char is a combining mark,','line_number':2526,'multiline':False]
['text':'                          \b is FALSE.','line_number':2527,'multiline':False]
['text':'                       Else Scan backwards to the first non-combining char.','line_number':2528,'multiline':False]
['text':'                            We are at a boundary if the this char and the original chars are','line_number':2529,'multiline':False]
['text':'                               opposite in membership in \w set','line_number':2530,'multiline':False]
['text':'','line_number':2531,'multiline':False]
['text':'          parameters:   pos   - the current position in the input buffer','line_number':2532,'multiline':False]
['text':'','line_number':2533,'multiline':False]
['text':'              TODO:  double-check edge cases at region boundaries.','line_number':2534,'multiline':False]
['text':'','line_number':2535,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2536,'multiline':False]
['text':' Determine whether char c at current position is a member of the word set of chars.','line_number':2544,'multiline':False]
['text':' If we're off the end of the string, behave as though we're not at a word char.','line_number':2545,'multiline':False]
['text':' Current char is a combining one.  Not a boundary.','line_number':2549,'multiline':False]
['text':' Back up until we come to a non-combining char, determine whether','line_number':2555,'multiline':False]
['text':'  that char is a word char.','line_number':2556,'multiline':False]
['text':' Determine whether char c at current position is a member of the word set of chars.','line_number':2582,'multiline':False]
['text':' If we're off the end of the string, behave as though we're not at a word char.','line_number':2583,'multiline':False]
['text':' Current char is a combining one.  Not a boundary.','line_number':2587,'multiline':False]
['text':' Back up until we come to a non-combining char, determine whether','line_number':2593,'multiline':False]
['text':'  that char is a word char.','line_number':2594,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2612,'multiline':False]
['text':'','line_number':2613,'multiline':False]
['text':'   isUWordBoundary','line_number':2614,'multiline':False]
['text':'','line_number':2615,'multiline':False]
['text':'         Test for a word boundary using RBBI word break.','line_number':2616,'multiline':False]
['text':'','line_number':2617,'multiline':False]
['text':'          parameters:   pos   - the current position in the input buffer','line_number':2618,'multiline':False]
['text':'','line_number':2619,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2620,'multiline':False]
['text':' Note: this point will never be reached if break iteration is configured out.','line_number':2625,'multiline':False]
['text':'       Regex patterns that would require this function will fail to compile.','line_number':2626,'multiline':False]
['text':' If we haven't yet created a break iterator for this matcher, do it now.','line_number':2628,'multiline':False]
['text':' Note: zero width boundary tests like \b see through transparent region bounds,','line_number':2637,'multiline':False]
['text':'       which is why fLookLimit is used here, rather than fActiveLimit.','line_number':2638,'multiline':False]
['text':' With Unicode word rules, only positions within the interior of "real"','line_number':2641,'multiline':False]
['text':'    words are not boundaries.  All non-word chars stand by themselves,','line_number':2642,'multiline':False]
['text':'    with word boundaries on both sides.','line_number':2643,'multiline':False]
['text':' Note: this point will never be reached if break iteration is configured out.','line_number':2656,'multiline':False]
['text':'       Regex patterns that would require this function will fail to compile.','line_number':2657,'multiline':False]
['text':' If we haven't yet created a break iterator for this matcher, do it now.','line_number':2659,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2675,'multiline':False]
['text':'','line_number':2676,'multiline':False]
['text':'   IncrementTime     This function is called once each TIMER_INITIAL_VALUE state','line_number':2677,'multiline':False]
['text':'                     saves. Increment the "time" counter, and call the','line_number':2678,'multiline':False]
['text':'                     user callback function if there is one installed.','line_number':2679,'multiline':False]
['text':'','line_number':2680,'multiline':False]
['text':'                     If the match operation needs to be aborted, either for a time-out','line_number':2681,'multiline':False]
['text':'                     or because the user callback asked for it, just set an error status.','line_number':2682,'multiline':False]
['text':'                     The engine will pick that up and stop in its outer loop.','line_number':2683,'multiline':False]
['text':'','line_number':2684,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2685,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2700,'multiline':False]
['text':'','line_number':2701,'multiline':False]
['text':'   StateSave','line_number':2702,'multiline':False]
['text':'       Make a new stack frame, initialized as a copy of the current stack frame.','line_number':2703,'multiline':False]
['text':'       Set the pattern index in the original stack frame from the operand value','line_number':2704,'multiline':False]
['text':'       in the opcode.  Execution of the engine continues with the state in','line_number':2705,'multiline':False]
['text':'       the newly created stack frame','line_number':2706,'multiline':False]
['text':'','line_number':2707,'multiline':False]
['text':'       Note that reserveBlock() may grow the stack, resulting in the','line_number':2708,'multiline':False]
['text':'       whole thing being relocated in memory.','line_number':2709,'multiline':False]
['text':'','line_number':2710,'multiline':False]
['text':'    Parameters:','line_number':2711,'multiline':False]
['text':'       fp           The top frame pointer when called.  At return, a new','line_number':2712,'multiline':False]
['text':'                    fame will be present','line_number':2713,'multiline':False]
['text':'       savePatIdx   An index into the compiled pattern.  Goes into the original','line_number':2714,'multiline':False]
['text':'                    (not new) frame.  If execution ever back-tracks out of the','line_number':2715,'multiline':False]
['text':'                    new frame, this will be where we continue from in the pattern.','line_number':2716,'multiline':False]
['text':'    Return','line_number':2717,'multiline':False]
['text':'                    The new frame pointer.','line_number':2718,'multiline':False]
['text':'','line_number':2719,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2720,'multiline':False]
['text':' push storage for a new frame.','line_number':2725,'multiline':False]
['text':' Failure on attempted stack expansion.','line_number':2728,'multiline':False]
['text':'   Stack function set some other error code, change it to a more','line_number':2729,'multiline':False]
['text':'   specific one for regular expressions.','line_number':2730,'multiline':False]
['text':' We need to return a writable stack frame, so just return the','line_number':2732,'multiline':False]
['text':'    previous frame.  The match operation will stop quickly','line_number':2733,'multiline':False]
['text':'    because of the error status, after which the frame will never','line_number':2734,'multiline':False]
['text':'    be looked at again.','line_number':2735,'multiline':False]
['text':' in case of realloc of stack.','line_number':2738,'multiline':False]
['text':' New stack frame = copy of old top frame.','line_number':2740,'multiline':False]
['text':' Re-initializes fTickCounter','line_number':2752,'multiline':False]
['text':' REGEX_DEBUG','line_number':2768,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2771,'multiline':False]
['text':'','line_number':2772,'multiline':False]
['text':'   MatchAt      This is the actual matching engine.','line_number':2773,'multiline':False]
['text':'','line_number':2774,'multiline':False]
['text':'                  startIdx:    begin matching a this index.','line_number':2775,'multiline':False]
['text':'                  toEnd:       if true, match must extend to end of the input region','line_number':2776,'multiline':False]
['text':'','line_number':2777,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':2778,'multiline':False]
['text':' True if the we have a match.','line_number':2780,'multiline':False]
['text':' used after greedy single-character matches for searching backwards','line_number':2782,'multiline':False]
['text':' Operation from the compiled pattern, split into','line_number':2784,'multiline':False]
['text':'    the opcode','line_number':2785,'multiline':False]
['text':'    and the operand value.','line_number':2786,'multiline':False]
['text':'  Cache frequently referenced items from the compiled pattern','line_number':2800,'multiline':False]
['text':'','line_number':2801,'multiline':False]
['text':' Zero out the pattern's static data','line_number':2817,'multiline':False]
['text':'','line_number':2823,'multiline':False]
['text':'  Main loop for interpreting the compiled pattern.','line_number':2824,'multiline':False]
['text':'  One iteration of the loop per pattern operation performed.','line_number':2825,'multiline':False]
['text':'','line_number':2826,'multiline':False]
['text':' Force a backtrack.  In some circumstances, the pattern compiler','line_number':2849,'multiline':False]
['text':'   will notice that the pattern can't possibly match anything, and will','line_number':2850,'multiline':False]
['text':'   emit one of these at that point.','line_number':2851,'multiline':False]
['text':' Test input against a literal string.','line_number':2873,'multiline':False]
['text':' Strings require two slots in the compiled pattern, one for the','line_number':2874,'multiline':False]
['text':'   offset to the string text, and one for the length.','line_number':2875,'multiline':False]
['text':' Fetch the second operand','line_number':2878,'multiline':False]
['text':' The match loop will exit via this path on a successful match,','line_number':2920,'multiline':False]
['text':'   when we reach the end of the pattern.','line_number':2921,'multiline':False]
['text':' The pattern matched, but not to the end of input.  Try some more.','line_number':2923,'multiline':False]
['text':' Start and End Capture stack frame variables are laid out out like this:','line_number':2930,'multiline':False]
['text':'  fp->fExtra[opValue]  - The start of a completed capture group','line_number':2931,'multiline':False]
['text':'             opValue+1 - The end   of a completed capture group','line_number':2932,'multiline':False]
['text':'             opValue+2 - the start of a capture group whose end','line_number':2933,'multiline':False]
['text':'                          has not yet been reached (and might not ever be).','line_number':2934,'multiline':False]
['text':' Start pos for this group must be set.','line_number':2943,'multiline':False]
['text':' Tentative start becomes real.','line_number':2944,'multiline':False]
['text':' End position','line_number':2945,'multiline':False]
['text':'  $, test for End of line','line_number':2950,'multiline':False]
['text':'     or for position before new line at end of input','line_number':2951,'multiline':False]
['text':' We really are at the end of input.  Success.','line_number':2954,'multiline':False]
['text':' If we are positioned just before a new-line that is located at the','line_number':2962,'multiline':False]
['text':'   end of input, succeed.','line_number':2963,'multiline':False]
['text':' If not in the middle of a CR/LF sequence','line_number':2967,'multiline':False]
['text':' At new-line at end of input. Success','line_number':2969,'multiline':False]
['text':' At CR/LF at end of input.  Success','line_number':2981,'multiline':False]
['text':'  $, test for End of Line, in UNIX_LINES mode.','line_number':2990,'multiline':False]
['text':' Off the end of input.  Success.','line_number':2992,'multiline':False]
['text':' Either at the last character of input, or off the end.','line_number':2999,'multiline':False]
['text':' Not at end of input.  Back-track out.','line_number':3007,'multiline':False]
['text':'  $, test for End of line in multi-line mode','line_number':3012,'multiline':False]
['text':' We really are at the end of input.  Success.','line_number':3015,'multiline':False]
['text':' If we are positioned just before a new-line, succeed.','line_number':3020,'multiline':False]
['text':' It makes no difference where the new-line is within the input.','line_number':3021,'multiline':False]
['text':' At a line end, except for the odd chance of  being in the middle of a CR/LF sequence','line_number':3025,'multiline':False]
['text':'  In multi-line mode, hitting a new-line just before the end of input does not','line_number':3026,'multiline':False]
['text':'   set the hitEnd or requireEnd flags','line_number':3027,'multiline':False]
['text':' not at a new line.  Fail.','line_number':3032,'multiline':False]
['text':'  $, test for End of line in multi-line and UNIX_LINES mode','line_number':3038,'multiline':False]
['text':' We really are at the end of input.  Success.','line_number':3041,'multiline':False]
['text':' Java set requireEnd in this case, even though','line_number':3043,'multiline':False]
['text':'   adding a new-line would not lose the match.','line_number':3044,'multiline':False]
['text':' If we are not positioned just before a new-line, the test fails; backtrack out.','line_number':3046,'multiline':False]
['text':' It makes no difference where the new-line is within the input.','line_number':3047,'multiline':False]
['text':'  ^, test for start of line','line_number':3056,'multiline':False]
['text':'  ^, test for start of line in mulit-line mode','line_number':3063,'multiline':False]
['text':' We are at the start input.  Success.','line_number':3066,'multiline':False]
['text':' Check whether character just before the current pos is a new-line','line_number':3069,'multiline':False]
['text':'   unless we are at the end of input','line_number':3070,'multiline':False]
['text':'  It's a new-line.  ^ is true.  Success.','line_number':3074,'multiline':False]
['text':'  TODO:  what should be done with positions between a CR and LF?','line_number':3075,'multiline':False]
['text':' Not at the start of a line.  Fail.','line_number':3078,'multiline':False]
['text':'  ^, test for start of line in mulit-line + Unix-line mode','line_number':3084,'multiline':False]
['text':' We are at the start input.  Success.','line_number':3088,'multiline':False]
['text':' Check whether character just before the current pos is a new-line','line_number':3091,'multiline':False]
['text':' Not at the start of a line.  Back-track out.','line_number':3096,'multiline':False]
['text':' Test for word boundaries','line_number':3102,'multiline':False]
['text':' flip sense for \B','line_number':3105,'multiline':False]
['text':' Test for word boundaries, Unicode-style','line_number':3113,'multiline':False]
['text':' flip sense for \B','line_number':3116,'multiline':False]
['text':' Test for decimal digit','line_number':3124,'multiline':False]
['text':' TODO:  make a unicode set for this.  Will be faster.','line_number':3135,'multiline':False]
['text':' flip sense for \D','line_number':3137,'multiline':False]
['text':' Test for position at end of previous match','line_number':3147,'multiline':False]
['text':' Test for \h, horizontal white space.','line_number':3154,'multiline':False]
['text':' SPACE_SEPARATOR || TAB','line_number':3164,'multiline':False]
['text':' flip sense for \H','line_number':3165,'multiline':False]
['text':' Test for \R, any line break sequence.','line_number':3175,'multiline':False]
['text':' \v, any single line ending character.','line_number':3196,'multiline':False]
['text':' flip sense for \V','line_number':3206,'multiline':False]
['text':'  Match a Grapheme, as defined by Unicode UAX 29.','line_number':3217,'multiline':False]
['text':' Fail if at end of input','line_number':3219,'multiline':False]
['text':' Test for end of Input','line_number':3234,'multiline':False]
['text':' Test input character against one of the predefined sets','line_number':3247,'multiline':False]
['text':'    (Word Characters, for example)','line_number':3248,'multiline':False]
['text':' The high bit of the op value is a flag for the match polarity.','line_number':3249,'multiline':False]
['text':'    0:   success if input char is in set.','line_number':3250,'multiline':False]
['text':'    1:   success if input char is not in set.','line_number':3251,'multiline':False]
['text':' the character wasn't in the set.','line_number':3278,'multiline':False]
['text':' Test input character for NOT being a member of  one of','line_number':3287,'multiline':False]
['text':'    the predefined sets (Word Characters, for example)','line_number':3288,'multiline':False]
['text':' the character wasn't in the set.','line_number':3313,'multiline':False]
['text':' There is input left.  Pick up one char and test it for set membership.','line_number':3327,'multiline':False]
['text':' The character is in the set.  A Match.','line_number':3339,'multiline':False]
['text':' the character wasn't in the set.','line_number':3345,'multiline':False]
['text':' . matches anything, but stops at end-of-line.','line_number':3353,'multiline':False]
['text':' At end of input.  Match failed.  Backtrack out.','line_number':3355,'multiline':False]
['text':' There is input left.  Advance over one char, unless we've hit end-of-line','line_number':3363,'multiline':False]
['text':' End of line in normal mode.   . does not match.','line_number':3366,'multiline':False]
['text':' ., in dot-matches-all (including new lines) mode','line_number':3377,'multiline':False]
['text':' At end of input.  Match failed.  Backtrack out.','line_number':3379,'multiline':False]
['text':' There is input left.  Advance over one char, except if we are','line_number':3387,'multiline':False]
['text':'   at a cr/lf, advance over both of them.','line_number':3388,'multiline':False]
['text':' In the case of a CR/LF, we need to advance over both.','line_number':3393,'multiline':False]
['text':' '.' operator, matches all, but stops at end-of-line.','line_number':3406,'multiline':False]
['text':'   UNIX_LINES mode, so 0x0a is the only recognized line ending.','line_number':3407,'multiline':False]
['text':' At end of input.  Match failed.  Backtrack out.','line_number':3409,'multiline':False]
['text':' There is input left.  Advance over one char, unless we've hit end-of-line','line_number':3417,'multiline':False]
['text':' End of line in normal mode.   '.' does not match the \n','line_number':3420,'multiline':False]
['text':' State save to loc following current','line_number':3439,'multiline':False]
['text':' Then JMP.','line_number':3440,'multiline':False]
['text':' This opcode is used with (x)+, when x can match a zero length string.','line_number':3444,'multiline':False]
['text':' Same as JMP_SAV, except conditional on the match having made forward progress.','line_number':3445,'multiline':False]
['text':' Destination of the JMP must be a URX_STO_INP_LOC, from which we get the','line_number':3446,'multiline':False]
['text':'   data address of the input position at the start of the loop.','line_number':3447,'multiline':False]
['text':' The match did make progress.  Repeat the loop.','line_number':3457,'multiline':False]
['text':' State save to loc following current','line_number':3458,'multiline':False]
['text':' If the input position did not advance, we do nothing here,','line_number':3462,'multiline':False]
['text':'   execution will fall out of the loop.','line_number':3463,'multiline':False]
['text':'  Set the loop counter variable to zero','line_number':3470,'multiline':False]
['text':' Pick up the three extra operands that CTR_INIT has, and','line_number':3472,'multiline':False]
['text':'    skip the pattern location counter past','line_number':3473,'multiline':False]
['text':'  For loop breaking.','line_number':3487,'multiline':False]
['text':' Loop has no hard upper bound.','line_number':3509,'multiline':False]
['text':' Check that it is progressing through the input, break if it is not.','line_number':3510,'multiline':False]
['text':' Increment time-out counter. (StateSave() does it if count >= minCount)','line_number':3520,'multiline':False]
['text':' Re-initializes fTickCounter','line_number':3523,'multiline':False]
['text':' Loop back.','line_number':3527,'multiline':False]
['text':' Initialize a non-greedy loop','line_number':3533,'multiline':False]
['text':'  Set the loop counter variable to zero','line_number':3535,'multiline':False]
['text':' Pick up the three extra operands that CTR_INIT_NG has, and','line_number':3537,'multiline':False]
['text':'    skip the pattern location counter past','line_number':3538,'multiline':False]
['text':'  Save initial input index for loop breaking.','line_number':3548,'multiline':False]
['text':' Continue with stuff after repeated block','line_number':3555,'multiline':False]
['text':' Non-greedy {min, max} loops','line_number':3562,'multiline':False]
['text':' The loop has matched the maximum permitted number of times.','line_number':3572,'multiline':False]
['text':'   Break out of here with no action.  Matching will','line_number':3573,'multiline':False]
['text':'   continue with the following pattern.','line_number':3574,'multiline':False]
['text':' We haven't met the minimum number of matches yet.','line_number':3580,'multiline':False]
['text':'   Loop back for another one.','line_number':3581,'multiline':False]
['text':' Loop back.','line_number':3582,'multiline':False]
['text':' Increment time-out counter. (StateSave() does it if count >= minCount)','line_number':3583,'multiline':False]
['text':' Re-initializes fTickCounter','line_number':3586,'multiline':False]
['text':' We do have the minimum number of matches.','line_number':3589,'multiline':False]
['text':' If there is no upper bound on the loop iterations, check that the input index','line_number':3591,'multiline':False]
['text':' is progressing, and stop the loop if it is not.','line_number':3592,'multiline':False]
['text':' Loop Continuation: we will fall into the pattern following the loop','line_number':3601,'multiline':False]
['text':'   (non-greedy, don't execute loop body first), but first do','line_number':3602,'multiline':False]
['text':'   a state save to the top of the loop, so that a match failure','line_number':3603,'multiline':False]
['text':'   in the following pattern will try another iteration of the loop.','line_number':3604,'multiline':False]
['text':' This capture group has not participated in the match thus far,','line_number':3640,'multiline':False]
['text':' FAIL, no match.','line_number':3641,'multiline':False]
['text':'   Note: if the capture group match was of an empty string the backref','line_number':3647,'multiline':False]
['text':'         match succeeds.  Verified by testing:  Perl matches succeed','line_number':3648,'multiline':False]
['text':'         in this case, so we do too.','line_number':3649,'multiline':False]
['text':' This capture group has not participated in the match thus far,','line_number':3687,'multiline':False]
['text':' FAIL, no match.','line_number':3688,'multiline':False]
['text':'   Note: if the capture group match was of an empty string the backref','line_number':3696,'multiline':False]
['text':'         match succeeds.  Verified by testing:  Perl matches succeed','line_number':3697,'multiline':False]
['text':'         in this case, so we do too.','line_number':3698,'multiline':False]
['text':' We otained a match by consuming part of a string obtained from','line_number':3720,'multiline':False]
['text':' case-folding a single code point of the input text.','line_number':3721,'multiline':False]
['text':' This does not count as an overall match.','line_number':3722,'multiline':False]
['text':' JMP','line_number':3751,'multiline':False]
['text':' FAIL, no progress in loop.','line_number':3753,'multiline':False]
['text':' Entering a look around block.','line_number':3760,'multiline':False]
['text':' Save Stack Ptr, Input Pos.','line_number':3761,'multiline':False]
['text':' Set the match region change for','line_number':3767,'multiline':False]
['text':'   transparent bounds.','line_number':3768,'multiline':False]
['text':' Leaving a look-ahead block.','line_number':3774,'multiline':False]
['text':'  restore Stack Ptr, Input Pos to positions they had on entry to block.','line_number':3775,'multiline':False]
['text':' Copy the current top frame back to the new (cut back) top frame.','line_number':3781,'multiline':False]
['text':'   This makes the capture groups from within the look-ahead','line_number':3782,'multiline':False]
['text':'   expression available.','line_number':3783,'multiline':False]
['text':' Restore the active region bounds in the input string; they may have','line_number':3794,'multiline':False]
['text':'    been changed because of transparent bounds on a Region.','line_number':3795,'multiline':False]
['text':' Case insensitive one char.  The char from the pattern is already case folded.','line_number':3804,'multiline':False]
['text':' Input text is not, but case folding the input can not reduce two or more code','line_number':3805,'multiline':False]
['text':' points to one.','line_number':3806,'multiline':False]
['text':' Case-insensitive test input against a literal string.','line_number':3824,'multiline':False]
['text':' Strings require two slots in the compiled pattern, one for the','line_number':3825,'multiline':False]
['text':'   offset to the string text, and one for the length.','line_number':3826,'multiline':False]
['text':'   The compiled string has already been case folded.','line_number':3827,'multiline':False]
['text':' Length of the string from the pattern.','line_number':3837,'multiline':False]
['text':' Entering a look-behind block.','line_number':3874,'multiline':False]
['text':' Save Stack Ptr, Input Pos and active input region.','line_number':3875,'multiline':False]
['text':'   TODO:  implement transparent bounds.  Ticket #6067','line_number':3876,'multiline':False]
['text':' Save input string length, then reset to pin any matches to end at','line_number':3880,'multiline':False]
['text':'   the current position.','line_number':3881,'multiline':False]
['text':' Init the variable containing the start index for attempted matches.','line_number':3886,'multiline':False]
['text':' Positive Look-Behind, at top of loop checking for matches of LB expression','line_number':3894,'multiline':False]
['text':'    at all possible input starting positions.','line_number':3895,'multiline':False]
['text':' Fetch the min and max possible match lengths.  They are the operands','line_number':3897,'multiline':False]
['text':'   of this op in the pattern.','line_number':3898,'multiline':False]
['text':' utf-8 fix to maximum match length. The pattern compiler assumes utf-16.','line_number':3902,'multiline':False]
['text':' The max length need not be exact; it just needs to be >= actual maximum.','line_number':3903,'multiline':False]
['text':' Fetch (from data) the last input index where a match was attempted.','line_number':3909,'multiline':False]
['text':' First time through loop.','line_number':3913,'multiline':False]
['text':' move index to a code point boundary, if it's not on one already.','line_number':3916,'multiline':False]
['text':' 2nd through nth time through the loop.','line_number':3921,'multiline':False]
['text':' Back up start position for match by one.','line_number':3922,'multiline':False]
['text':' We have tried all potential match starting points without','line_number':3933,'multiline':False]
['text':'  getting a match.  Backtrack out, and out of the','line_number':3934,'multiline':False]
['text':'   Look Behind altogether.','line_number':3935,'multiline':False]
['text':'    Save state to this URX_LB_CONT op, so failure to match will repeat the loop.','line_number':3944,'multiline':False]
['text':'      (successful match will fall off the end of the loop.)','line_number':3945,'multiline':False]
['text':' End of a look-behind block, after a successful match.','line_number':3952,'multiline':False]
['text':'  The look-behind expression matched, but the match did not','line_number':3956,'multiline':False]
['text':'    extend all the way to the point that we are looking behind from.','line_number':3957,'multiline':False]
['text':'  FAIL out of here, which will take us back to the LB_CONT, which','line_number':3958,'multiline':False]
['text':'     will retry the match starting at another position or fail','line_number':3959,'multiline':False]
['text':'     the look-behind altogether, whichever is appropriate.','line_number':3960,'multiline':False]
['text':' Look-behind match is good.  Restore the orignal input string region,','line_number':3965,'multiline':False]
['text':'   which had been truncated to pin the end of the lookbehind match to the','line_number':3966,'multiline':False]
['text':'   position being looked-behind.','line_number':3967,'multiline':False]
['text':' Negative Look-Behind, at top of loop checking for matches of LB expression','line_number':3978,'multiline':False]
['text':'    at all possible input starting positions.','line_number':3979,'multiline':False]
['text':' Fetch the extra parameters of this op.','line_number':3981,'multiline':False]
['text':' utf-8 fix to maximum match length. The pattern compiler assumes utf-16.','line_number':3985,'multiline':False]
['text':' The max length need not be exact; it just needs to be >= actual maximum.','line_number':3986,'multiline':False]
['text':' Fetch (from data) the last input index where a match was attempted.','line_number':3995,'multiline':False]
['text':' First time through loop.','line_number':3999,'multiline':False]
['text':' move index to a code point boundary, if it's not on one already.','line_number':4002,'multiline':False]
['text':' 2nd through nth time through the loop.','line_number':4007,'multiline':False]
['text':' Back up start position for match by one.','line_number':4008,'multiline':False]
['text':' We have tried all potential match starting points without','line_number':4019,'multiline':False]
['text':'  getting a match, which means that the negative lookbehind as','line_number':4020,'multiline':False]
['text':'  a whole has succeeded.  Jump forward to the continue location','line_number':4021,'multiline':False]
['text':'    Save state to this URX_LB_CONT op, so failure to match will repeat the loop.','line_number':4030,'multiline':False]
['text':'      (successful match will cause a FAIL out of the loop altogether.)','line_number':4031,'multiline':False]
['text':' End of a negative look-behind block, after a successful match.','line_number':4038,'multiline':False]
['text':'  The look-behind expression matched, but the match did not','line_number':4042,'multiline':False]
['text':'    extend all the way to the point that we are looking behind from.','line_number':4043,'multiline':False]
['text':'  FAIL out of here, which will take us back to the LB_CONT, which','line_number':4044,'multiline':False]
['text':'     will retry the match starting at another position or succeed','line_number':4045,'multiline':False]
['text':'     the look-behind altogether, whichever is appropriate.','line_number':4046,'multiline':False]
['text':' Look-behind expression matched, which means look-behind test as','line_number':4051,'multiline':False]
['text':'   a whole Fails','line_number':4052,'multiline':False]
['text':'   Restore the orignal input string length, which had been truncated','line_number':4054,'multiline':False]
['text':'   inorder to pin the end of the lookbehind match','line_number':4055,'multiline':False]
['text':'   to the position being looked-behind.','line_number':4056,'multiline':False]
['text':' Restore original stack position, discarding any state saved','line_number':4062,'multiline':False]
['text':'   by the successful pattern match.','line_number':4063,'multiline':False]
['text':'  FAIL, which will take control back to someplace','line_number':4069,'multiline':False]
['text':'  prior to entering the look-behind test.','line_number':4070,'multiline':False]
['text':' Loop Initialization for the optimized implementation of','line_number':4077,'multiline':False]
['text':'     [some character set]*','line_number':4078,'multiline':False]
['text':'   This op scans through all matching input.','line_number':4079,'multiline':False]
['text':'   The following LOOP_C op emulates stack unwinding if the following pattern fails.','line_number':4080,'multiline':False]
['text':' Loop through input, until either the input is exhausted or','line_number':4086,'multiline':False]
['text':'   we reach a character that is not a member of the set.','line_number':4087,'multiline':False]
['text':' If there were no matching characters, skip over the loop altogether.','line_number':4108,'multiline':False]
['text':'   The loop doesn't run at all, a * op always succeeds.','line_number':4109,'multiline':False]
['text':' skip the URX_LOOP_C op.','line_number':4111,'multiline':False]
['text':' Peek ahead in the compiled pattern, to the URX_LOOP_C that','line_number':4115,'multiline':False]
['text':'   must follow.  It's operand is the stack location','line_number':4116,'multiline':False]
['text':'   that holds the starting input index for the match of this [set]*','line_number':4117,'multiline':False]
['text':' Save State to the URX_LOOP_C op that follows this one,','line_number':4125,'multiline':False]
['text':'   so that match failures in the following code will return to there.','line_number':4126,'multiline':False]
['text':'   Then bump the pattern idx so the LOOP_C is skipped on the way out of here.','line_number':4127,'multiline':False]
['text':' Loop Initialization for the optimized implementation of .*','line_number':4135,'multiline':False]
['text':'   This op scans through all remaining input.','line_number':4136,'multiline':False]
['text':'   The following LOOP_C op emulates stack unwinding if the following pattern fails.','line_number':4137,'multiline':False]
['text':' Loop through input until the input is exhausted (we reach an end-of-line)','line_number':4139,'multiline':False]
['text':' In DOTALL mode, we can just go straight to the end of the input.','line_number':4140,'multiline':False]
['text':' Dot-matches-All mode.  Jump straight to the end of the string.','line_number':4143,'multiline':False]
['text':' NOT DOT ALL mode.  Line endings do not match '.'','line_number':4147,'multiline':False]
['text':' Scan forward until a line ending or end of input.','line_number':4148,'multiline':False]
['text':' Fast filter of non-new-line-s','line_number':4157,'multiline':False]
['text':'  0x0a is newline in both modes.','line_number':4158,'multiline':False]
['text':' IF not UNIX_LINES mode','line_number':4159,'multiline':False]
['text':'  char is a line ending.  Exit the scanning loop.','line_number':4161,'multiline':False]
['text':' If there were no matching characters, skip over the loop altogether.','line_number':4169,'multiline':False]
['text':'   The loop doesn't run at all, a * op always succeeds.','line_number':4170,'multiline':False]
['text':' skip the URX_LOOP_C op.','line_number':4172,'multiline':False]
['text':' Peek ahead in the compiled pattern, to the URX_LOOP_C that','line_number':4176,'multiline':False]
['text':'   must follow.  It's operand is the stack location','line_number':4177,'multiline':False]
['text':'   that holds the starting input index for the match of this .*','line_number':4178,'multiline':False]
['text':' Save State to the URX_LOOP_C op that follows this one,','line_number':4186,'multiline':False]
['text':'   so that match failures in the following code will return to there.','line_number':4187,'multiline':False]
['text':'   Then bump the pattern idx so the LOOP_C is skipped on the way out of here.','line_number':4188,'multiline':False]
['text':' We've backed up the input idx to the point that the loop started.','line_number':4201,'multiline':False]
['text':' The loop is done.  Leave here without saving state.','line_number':4202,'multiline':False]
['text':'  Subsequent failures won't come back here.','line_number':4203,'multiline':False]
['text':' Set up for the next iteration of the loop, with input index','line_number':4206,'multiline':False]
['text':'   backed up by one from the last time through,','line_number':4207,'multiline':False]
['text':'   and a state save to this instruction in case the following code fails again.','line_number':4208,'multiline':False]
['text':'   (We're going backwards because this loop emulates stack unwinding, not','line_number':4209,'multiline':False]
['text':'    the initial scan forward.)','line_number':4210,'multiline':False]
['text':' .*, stepping back over CRLF pair.','line_number':4222,'multiline':False]
['text':' Trouble.  The compiled pattern contains an entry with an','line_number':4235,'multiline':False]
['text':'           unrecognized type tag.','line_number':4236,'multiline':False]
['text':' The active stack frame when the engine stopped.','line_number':4264,'multiline':False]
['text':'   Contains the capture group results that we need to','line_number':4265,'multiline':False]
['text':'    access later.','line_number':4266,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':4271,'multiline':False]
['text':'','line_number':4272,'multiline':False]
['text':'   MatchChunkAt   This is the actual matching engine. Like MatchAt, but with the','line_number':4273,'multiline':False]
['text':'                  assumption that the entire string is available in the UText's','line_number':4274,'multiline':False]
['text':'                  chunk buffer. For now, that means we can use int32_t indexes,','line_number':4275,'multiline':False]
['text':'                  except for anything that needs to be saved (like group starts','line_number':4276,'multiline':False]
['text':'                  and ends).','line_number':4277,'multiline':False]
['text':'','line_number':4278,'multiline':False]
['text':'                  startIdx:    begin matching a this index.','line_number':4279,'multiline':False]
['text':'                  toEnd:       if true, match must extend to end of the input region','line_number':4280,'multiline':False]
['text':'','line_number':4281,'multiline':False]
['text':'--------------------------------------------------------------------------------','line_number':4282,'multiline':False]
['text':' True if the we have a match.','line_number':4284,'multiline':False]
['text':' used after greedy single-character matches for searching backwards','line_number':4286,'multiline':False]
['text':' Operation from the compiled pattern, split into','line_number':4288,'multiline':False]
['text':'    the opcode','line_number':4289,'multiline':False]
['text':'    and the operand value.','line_number':4290,'multiline':False]
['text':'  Cache frequently referenced items from the compiled pattern','line_number':4304,'multiline':False]
['text':'','line_number':4305,'multiline':False]
['text':' Zero out the pattern's static data','line_number':4323,'multiline':False]
['text':'','line_number':4329,'multiline':False]
['text':'  Main loop for interpreting the compiled pattern.','line_number':4330,'multiline':False]
['text':'  One iteration of the loop per pattern operation performed.','line_number':4331,'multiline':False]
['text':'','line_number':4332,'multiline':False]
['text':' Force a backtrack.  In some circumstances, the pattern compiler','line_number':4355,'multiline':False]
['text':'   will notice that the pattern can't possibly match anything, and will','line_number':4356,'multiline':False]
['text':'   emit one of these at that point.','line_number':4357,'multiline':False]
['text':' Test input against a literal string.','line_number':4378,'multiline':False]
['text':' Strings require two slots in the compiled pattern, one for the','line_number':4379,'multiline':False]
['text':'   offset to the string text, and one for the length.','line_number':4380,'multiline':False]
['text':' Fetch the second operand','line_number':4384,'multiline':False]
['text':' The match loop will exit via this path on a successful match,','line_number':4423,'multiline':False]
['text':'   when we reach the end of the pattern.','line_number':4424,'multiline':False]
['text':' The pattern matched, but not to the end of input.  Try some more.','line_number':4426,'multiline':False]
['text':' Start and End Capture stack frame variables are laid out out like this:','line_number':4433,'multiline':False]
['text':'  fp->fExtra[opValue]  - The start of a completed capture group','line_number':4434,'multiline':False]
['text':'             opValue+1 - The end   of a completed capture group','line_number':4435,'multiline':False]
['text':'             opValue+2 - the start of a capture group whose end','line_number':4436,'multiline':False]
['text':'                          has not yet been reached (and might not ever be).','line_number':4437,'multiline':False]
['text':' Start pos for this group must be set.','line_number':4446,'multiline':False]
['text':' Tentative start becomes real.','line_number':4447,'multiline':False]
['text':' End position','line_number':4448,'multiline':False]
['text':'  $, test for End of line','line_number':4453,'multiline':False]
['text':'     or for position before new line at end of input','line_number':4454,'multiline':False]
['text':' We are no where near the end of input.  Fail.','line_number':4456,'multiline':False]
['text':'   This is the common case.  Keep it first.','line_number':4457,'multiline':False]
['text':' We really are at the end of input.  Success.','line_number':4462,'multiline':False]
['text':' If we are positioned just before a new-line that is located at the','line_number':4468,'multiline':False]
['text':'   end of input, succeed.','line_number':4469,'multiline':False]
['text':' At new-line at end of input. Success','line_number':4476,'multiline':False]
['text':' At CR/LF at end of input.  Success','line_number':4486,'multiline':False]
['text':'  $, test for End of Line, in UNIX_LINES mode.','line_number':4494,'multiline':False]
['text':' Either at the last character of input, or off the end.','line_number':4496,'multiline':False]
['text':' At last char of input.  Success if it's a new line.','line_number':4498,'multiline':False]
['text':' Off the end of input.  Success.','line_number':4505,'multiline':False]
['text':' Not at end of input.  Back-track out.','line_number':4512,'multiline':False]
['text':'  $, test for End of line in multi-line mode','line_number':4517,'multiline':False]
['text':' We really are at the end of input.  Success.','line_number':4520,'multiline':False]
['text':' If we are positioned just before a new-line, succeed.','line_number':4525,'multiline':False]
['text':' It makes no difference where the new-line is within the input.','line_number':4526,'multiline':False]
['text':' At a line end, except for the odd chance of  being in the middle of a CR/LF sequence','line_number':4529,'multiline':False]
['text':'  In multi-line mode, hitting a new-line just before the end of input does not','line_number':4530,'multiline':False]
['text':'   set the hitEnd or requireEnd flags','line_number':4531,'multiline':False]
['text':' not at a new line.  Fail.','line_number':4536,'multiline':False]
['text':'  $, test for End of line in multi-line and UNIX_LINES mode','line_number':4542,'multiline':False]
['text':' We really are at the end of input.  Success.','line_number':4545,'multiline':False]
['text':' Java set requireEnd in this case, even though','line_number':4547,'multiline':False]
['text':'   adding a new-line would not lose the match.','line_number':4548,'multiline':False]
['text':' If we are not positioned just before a new-line, the test fails; backtrack out.','line_number':4550,'multiline':False]
['text':' It makes no difference where the new-line is within the input.','line_number':4551,'multiline':False]
['text':'  ^, test for start of line','line_number':4559,'multiline':False]
['text':'  ^, test for start of line in mulit-line mode','line_number':4566,'multiline':False]
['text':' We are at the start input.  Success.','line_number':4569,'multiline':False]
['text':' Check whether character just before the current pos is a new-line','line_number':4572,'multiline':False]
['text':'   unless we are at the end of input','line_number':4573,'multiline':False]
['text':'  It's a new-line.  ^ is true.  Success.','line_number':4577,'multiline':False]
['text':'  TODO:  what should be done with positions between a CR and LF?','line_number':4578,'multiline':False]
['text':' Not at the start of a line.  Fail.','line_number':4581,'multiline':False]
['text':'  ^, test for start of line in mulit-line + Unix-line mode','line_number':4587,'multiline':False]
['text':' We are at the start input.  Success.','line_number':4591,'multiline':False]
['text':' Check whether character just before the current pos is a new-line','line_number':4594,'multiline':False]
['text':' Not at the start of a line.  Back-track out.','line_number':4598,'multiline':False]
['text':' Test for word boundaries','line_number':4604,'multiline':False]
['text':' flip sense for \B','line_number':4607,'multiline':False]
['text':' Test for word boundaries, Unicode-style','line_number':4615,'multiline':False]
['text':' flip sense for \B','line_number':4618,'multiline':False]
['text':' Test for decimal digit','line_number':4626,'multiline':False]
['text':' TODO:  make a unicode set for this.  Will be faster.','line_number':4636,'multiline':False]
['text':' flip sense for \D','line_number':4638,'multiline':False]
['text':' Test for position at end of previous match','line_number':4646,'multiline':False]
['text':' Test for \h, horizontal white space.','line_number':4653,'multiline':False]
['text':' SPACE_SEPARATOR || TAB','line_number':4663,'multiline':False]
['text':' flip sense for \H','line_number':4664,'multiline':False]
['text':' Test for \R, any line break sequence.','line_number':4672,'multiline':False]
['text':' Check for CR/LF sequence. Consume both together when found.','line_number':4683,'multiline':False]
['text':' Any single code point line ending.','line_number':4697,'multiline':False]
['text':' flip sense for \V','line_number':4707,'multiline':False]
['text':'  Match a Grapheme, as defined by Unicode UAX 29.','line_number':4716,'multiline':False]
['text':' Fail if at end of input','line_number':4718,'multiline':False]
['text':' Test for end of Input','line_number':4733,'multiline':False]
['text':' Test input character against one of the predefined sets','line_number':4746,'multiline':False]
['text':'    (Word Characters, for example)','line_number':4747,'multiline':False]
['text':' The high bit of the op value is a flag for the match polarity.','line_number':4748,'multiline':False]
['text':'    0:   success if input char is in set.','line_number':4749,'multiline':False]
['text':'    1:   success if input char is not in set.','line_number':4750,'multiline':False]
['text':' Test input character for NOT being a member of  one of','line_number':4783,'multiline':False]
['text':'    the predefined sets (Word Characters, for example)','line_number':4784,'multiline':False]
['text':' There is input left.  Pick up one char and test it for set membership.','line_number':4821,'multiline':False]
['text':' The character is in the set.  A Match.','line_number':4827,'multiline':False]
['text':' The character is in the set.  A Match.','line_number':4833,'multiline':False]
['text':' the character wasn't in the set.','line_number':4838,'multiline':False]
['text':' . matches anything, but stops at end-of-line.','line_number':4846,'multiline':False]
['text':' At end of input.  Match failed.  Backtrack out.','line_number':4848,'multiline':False]
['text':' There is input left.  Advance over one char, unless we've hit end-of-line','line_number':4854,'multiline':False]
['text':' End of line in normal mode.   . does not match.','line_number':4858,'multiline':False]
['text':' . in dot-matches-all (including new lines) mode','line_number':4868,'multiline':False]
['text':' At end of input.  Match failed.  Backtrack out.','line_number':4870,'multiline':False]
['text':' There is input left.  Advance over one char, except if we are','line_number':4876,'multiline':False]
['text':'   at a cr/lf, advance over both of them.','line_number':4877,'multiline':False]
['text':' In the case of a CR/LF, we need to advance over both.','line_number':4881,'multiline':False]
['text':' '.' operator, matches all, but stops at end-of-line.','line_number':4892,'multiline':False]
['text':'   UNIX_LINES mode, so 0x0a is the only recognized line ending.','line_number':4893,'multiline':False]
['text':' At end of input.  Match failed.  Backtrack out.','line_number':4895,'multiline':False]
['text':' There is input left.  Advance over one char, unless we've hit end-of-line','line_number':4901,'multiline':False]
['text':' End of line in normal mode.   '.' does not match the \n','line_number':4905,'multiline':False]
['text':' State save to loc following current','line_number':4922,'multiline':False]
['text':' Then JMP.','line_number':4923,'multiline':False]
['text':' This opcode is used with (x)+, when x can match a zero length string.','line_number':4927,'multiline':False]
['text':' Same as JMP_SAV, except conditional on the match having made forward progress.','line_number':4928,'multiline':False]
['text':' Destination of the JMP must be a URX_STO_INP_LOC, from which we get the','line_number':4929,'multiline':False]
['text':'   data address of the input position at the start of the loop.','line_number':4930,'multiline':False]
['text':' The match did make progress.  Repeat the loop.','line_number':4940,'multiline':False]
['text':' State save to loc following current','line_number':4941,'multiline':False]
['text':' If the input position did not advance, we do nothing here,','line_number':4945,'multiline':False]
['text':'   execution will fall out of the loop.','line_number':4946,'multiline':False]
['text':'  Set the loop counter variable to zero','line_number':4953,'multiline':False]
['text':' Pick up the three extra operands that CTR_INIT has, and','line_number':4955,'multiline':False]
['text':'    skip the pattern location counter past','line_number':4956,'multiline':False]
['text':'  For loop breaking.','line_number':4970,'multiline':False]
['text':' Loop has no hard upper bound.','line_number':4992,'multiline':False]
['text':' Check that it is progressing through the input, break if it is not.','line_number':4993,'multiline':False]
['text':' Increment time-out counter. (StateSave() does it if count >= minCount)','line_number':5003,'multiline':False]
['text':' Re-initializes fTickCounter','line_number':5006,'multiline':False]
['text':' Loop back.','line_number':5009,'multiline':False]
['text':' Initialize a non-greedy loop','line_number':5015,'multiline':False]
['text':'  Set the loop counter variable to zero','line_number':5017,'multiline':False]
['text':' Pick up the three extra operands that CTR_INIT_NG has, and','line_number':5019,'multiline':False]
['text':'    skip the pattern location counter past','line_number':5020,'multiline':False]
['text':'  Save initial input index for loop breaking.','line_number':5030,'multiline':False]
['text':' Continue with stuff after repeated block','line_number':5037,'multiline':False]
['text':' Non-greedy {min, max} loops','line_number':5044,'multiline':False]
['text':' The loop has matched the maximum permitted number of times.','line_number':5054,'multiline':False]
['text':'   Break out of here with no action.  Matching will','line_number':5055,'multiline':False]
['text':'   continue with the following pattern.','line_number':5056,'multiline':False]
['text':' We haven't met the minimum number of matches yet.','line_number':5062,'multiline':False]
['text':'   Loop back for another one.','line_number':5063,'multiline':False]
['text':' Loop back.','line_number':5064,'multiline':False]
['text':' Re-initializes fTickCounter','line_number':5067,'multiline':False]
['text':' We do have the minimum number of matches.','line_number':5070,'multiline':False]
['text':' If there is no upper bound on the loop iterations, check that the input index','line_number':5072,'multiline':False]
['text':' is progressing, and stop the loop if it is not.','line_number':5073,'multiline':False]
['text':' Loop Continuation: we will fall into the pattern following the loop','line_number':5082,'multiline':False]
['text':'   (non-greedy, don't execute loop body first), but first do','line_number':5083,'multiline':False]
['text':'   a state save to the top of the loop, so that a match failure','line_number':5084,'multiline':False]
['text':'   in the following pattern will try another iteration of the loop.','line_number':5085,'multiline':False]
['text':' This capture group has not participated in the match thus far,','line_number':5122,'multiline':False]
['text':' FAIL, no match.','line_number':5123,'multiline':False]
['text':' Capture group ended with an unpaired lead surrogate.','line_number':5140,'multiline':False]
['text':' Back reference is not permitted to match lead only of a surrogatge pair.','line_number':5141,'multiline':False]
['text':' This capture group has not participated in the match thus far,','line_number':5159,'multiline':False]
['text':' FAIL, no match.','line_number':5160,'multiline':False]
['text':'   Note: if the capture group match was of an empty string the backref','line_number':5166,'multiline':False]
['text':'         match succeeds.  Verified by testing:  Perl matches succeed','line_number':5167,'multiline':False]
['text':'         in this case, so we do too.','line_number':5168,'multiline':False]
['text':' We otained a match by consuming part of a string obtained from','line_number':5190,'multiline':False]
['text':' case-folding a single code point of the input text.','line_number':5191,'multiline':False]
['text':' This does not count as an overall match.','line_number':5192,'multiline':False]
['text':' JMP','line_number':5220,'multiline':False]
['text':' FAIL, no progress in loop.','line_number':5222,'multiline':False]
['text':' Entering a look around block.','line_number':5229,'multiline':False]
['text':' Save Stack Ptr, Input Pos.','line_number':5230,'multiline':False]
['text':' Set the match region change for','line_number':5236,'multiline':False]
['text':'   transparent bounds.','line_number':5237,'multiline':False]
['text':' Leaving a look around block.','line_number':5243,'multiline':False]
['text':'  restore Stack Ptr, Input Pos to positions they had on entry to block.','line_number':5244,'multiline':False]
['text':' Copy the current top frame back to the new (cut back) top frame.','line_number':5250,'multiline':False]
['text':'   This makes the capture groups from within the look-ahead','line_number':5251,'multiline':False]
['text':'   expression available.','line_number':5252,'multiline':False]
['text':' Restore the active region bounds in the input string; they may have','line_number':5263,'multiline':False]
['text':'    been changed because of transparent bounds on a Region.','line_number':5264,'multiline':False]
['text':' Case-insensitive test input against a literal string.','line_number':5286,'multiline':False]
['text':' Strings require two slots in the compiled pattern, one for the','line_number':5287,'multiline':False]
['text':'   offset to the string text, and one for the length.','line_number':5288,'multiline':False]
['text':'   The compiled string has already been case folded.','line_number':5289,'multiline':False]
['text':' Length of the string from the pattern.','line_number':5298,'multiline':False]
['text':' Entering a look-behind block.','line_number':5330,'multiline':False]
['text':' Save Stack Ptr, Input Pos and active input region.','line_number':5331,'multiline':False]
['text':'   TODO:  implement transparent bounds.  Ticket #6067','line_number':5332,'multiline':False]
['text':' Save input string length, then reset to pin any matches to end at','line_number':5336,'multiline':False]
['text':'   the current position.','line_number':5337,'multiline':False]
['text':' Init the variable containing the start index for attempted matches.','line_number':5342,'multiline':False]
['text':' Positive Look-Behind, at top of loop checking for matches of LB expression','line_number':5350,'multiline':False]
['text':'    at all possible input starting positions.','line_number':5351,'multiline':False]
['text':' Fetch the min and max possible match lengths.  They are the operands','line_number':5353,'multiline':False]
['text':'   of this op in the pattern.','line_number':5354,'multiline':False]
['text':' Fetch (from data) the last input index where a match was attempted.','line_number':5360,'multiline':False]
['text':' First time through loop.','line_number':5364,'multiline':False]
['text':' 2nd through nth time through the loop.','line_number':5370,'multiline':False]
['text':' Back up start position for match by one.','line_number':5371,'multiline':False]
['text':' We have tried all potential match starting points without','line_number':5380,'multiline':False]
['text':'  getting a match.  Backtrack out, and out of the','line_number':5381,'multiline':False]
['text':'   Look Behind altogether.','line_number':5382,'multiline':False]
['text':'    Save state to this URX_LB_CONT op, so failure to match will repeat the loop.','line_number':5391,'multiline':False]
['text':'      (successful match will fall off the end of the loop.)','line_number':5392,'multiline':False]
['text':' End of a look-behind block, after a successful match.','line_number':5399,'multiline':False]
['text':'  The look-behind expression matched, but the match did not','line_number':5403,'multiline':False]
['text':'    extend all the way to the point that we are looking behind from.','line_number':5404,'multiline':False]
['text':'  FAIL out of here, which will take us back to the LB_CONT, which','line_number':5405,'multiline':False]
['text':'     will retry the match starting at another position or fail','line_number':5406,'multiline':False]
['text':'     the look-behind altogether, whichever is appropriate.','line_number':5407,'multiline':False]
['text':' Look-behind match is good.  Restore the orignal input string region,','line_number':5412,'multiline':False]
['text':'   which had been truncated to pin the end of the lookbehind match to the','line_number':5413,'multiline':False]
['text':'   position being looked-behind.','line_number':5414,'multiline':False]
['text':' Negative Look-Behind, at top of loop checking for matches of LB expression','line_number':5425,'multiline':False]
['text':'    at all possible input starting positions.','line_number':5426,'multiline':False]
['text':' Fetch the extra parameters of this op.','line_number':5428,'multiline':False]
['text':' Fetch (from data) the last input index where a match was attempted.','line_number':5437,'multiline':False]
['text':' First time through loop.','line_number':5441,'multiline':False]
['text':' 2nd through nth time through the loop.','line_number':5447,'multiline':False]
['text':' Back up start position for match by one.','line_number':5448,'multiline':False]
['text':' Because U16_BACK is unsafe starting at 0.','line_number':5450,'multiline':False]
['text':' We have tried all potential match starting points without','line_number':5457,'multiline':False]
['text':'  getting a match, which means that the negative lookbehind as','line_number':5458,'multiline':False]
['text':'  a whole has succeeded.  Jump forward to the continue location','line_number':5459,'multiline':False]
['text':'    Save state to this URX_LB_CONT op, so failure to match will repeat the loop.','line_number':5468,'multiline':False]
['text':'      (successful match will cause a FAIL out of the loop altogether.)','line_number':5469,'multiline':False]
['text':' End of a negative look-behind block, after a successful match.','line_number':5476,'multiline':False]
['text':'  The look-behind expression matched, but the match did not','line_number':5480,'multiline':False]
['text':'    extend all the way to the point that we are looking behind from.','line_number':5481,'multiline':False]
['text':'  FAIL out of here, which will take us back to the LB_CONT, which','line_number':5482,'multiline':False]
['text':'     will retry the match starting at another position or succeed','line_number':5483,'multiline':False]
['text':'     the look-behind altogether, whichever is appropriate.','line_number':5484,'multiline':False]
['text':' Look-behind expression matched, which means look-behind test as','line_number':5489,'multiline':False]
['text':'   a whole Fails','line_number':5490,'multiline':False]
['text':'   Restore the orignal input string length, which had been truncated','line_number':5492,'multiline':False]
['text':'   inorder to pin the end of the lookbehind match','line_number':5493,'multiline':False]
['text':'   to the position being looked-behind.','line_number':5494,'multiline':False]
['text':' Restore original stack position, discarding any state saved','line_number':5500,'multiline':False]
['text':'   by the successful pattern match.','line_number':5501,'multiline':False]
['text':'  FAIL, which will take control back to someplace','line_number':5507,'multiline':False]
['text':'  prior to entering the look-behind test.','line_number':5508,'multiline':False]
['text':' Loop Initialization for the optimized implementation of','line_number':5515,'multiline':False]
['text':'     [some character set]*','line_number':5516,'multiline':False]
['text':'   This op scans through all matching input.','line_number':5517,'multiline':False]
['text':'   The following LOOP_C op emulates stack unwinding if the following pattern fails.','line_number':5518,'multiline':False]
['text':' Loop through input, until either the input is exhausted or','line_number':5524,'multiline':False]
['text':'   we reach a character that is not a member of the set.','line_number':5525,'multiline':False]
['text':' If there were no matching characters, skip over the loop altogether.','line_number':5547,'multiline':False]
['text':'   The loop doesn't run at all, a * op always succeeds.','line_number':5548,'multiline':False]
['text':' skip the URX_LOOP_C op.','line_number':5550,'multiline':False]
['text':' Peek ahead in the compiled pattern, to the URX_LOOP_C that','line_number':5554,'multiline':False]
['text':'   must follow.  It's operand is the stack location','line_number':5555,'multiline':False]
['text':'   that holds the starting input index for the match of this [set]*','line_number':5556,'multiline':False]
['text':' Save State to the URX_LOOP_C op that follows this one,','line_number':5564,'multiline':False]
['text':'   so that match failures in the following code will return to there.','line_number':5565,'multiline':False]
['text':'   Then bump the pattern idx so the LOOP_C is skipped on the way out of here.','line_number':5566,'multiline':False]
['text':' Loop Initialization for the optimized implementation of .*','line_number':5574,'multiline':False]
['text':'   This op scans through all remaining input.','line_number':5575,'multiline':False]
['text':'   The following LOOP_C op emulates stack unwinding if the following pattern fails.','line_number':5576,'multiline':False]
['text':' Loop through input until the input is exhausted (we reach an end-of-line)','line_number':5578,'multiline':False]
['text':' In DOTALL mode, we can just go straight to the end of the input.','line_number':5579,'multiline':False]
['text':' Dot-matches-All mode.  Jump straight to the end of the string.','line_number':5582,'multiline':False]
['text':' NOT DOT ALL mode.  Line endings do not match '.'','line_number':5586,'multiline':False]
['text':' Scan forward until a line ending or end of input.','line_number':5587,'multiline':False]
['text':' c = inputBuf[ix++]','line_number':5595,'multiline':False]
['text':' Fast filter of non-new-line-s','line_number':5596,'multiline':False]
['text':'  0x0a is newline in both modes.','line_number':5597,'multiline':False]
['text':' IF not UNIX_LINES mode','line_number':5598,'multiline':False]
['text':'  char is a line ending.  Put the input pos back to the','line_number':5600,'multiline':False]
['text':'    line ending char, and exit the scanning loop.','line_number':5601,'multiline':False]
['text':' If there were no matching characters, skip over the loop altogether.','line_number':5609,'multiline':False]
['text':'   The loop doesn't run at all, a * op always succeeds.','line_number':5610,'multiline':False]
['text':' skip the URX_LOOP_C op.','line_number':5612,'multiline':False]
['text':' Peek ahead in the compiled pattern, to the URX_LOOP_C that','line_number':5616,'multiline':False]
['text':'   must follow.  It's operand is the stack location','line_number':5617,'multiline':False]
['text':'   that holds the starting input index for the match of this .*','line_number':5618,'multiline':False]
['text':' Save State to the URX_LOOP_C op that follows this one,','line_number':5626,'multiline':False]
['text':'   so that match failures in the following code will return to there.','line_number':5627,'multiline':False]
['text':'   Then bump the pattern idx so the LOOP_C is skipped on the way out of here.','line_number':5628,'multiline':False]
['text':' We've backed up the input idx to the point that the loop started.','line_number':5641,'multiline':False]
['text':' The loop is done.  Leave here without saving state.','line_number':5642,'multiline':False]
['text':'  Subsequent failures won't come back here.','line_number':5643,'multiline':False]
['text':' Set up for the next iteration of the loop, with input index','line_number':5646,'multiline':False]
['text':'   backed up by one from the last time through,','line_number':5647,'multiline':False]
['text':'   and a state save to this instruction in case the following code fails again.','line_number':5648,'multiline':False]
['text':'   (We're going backwards because this loop emulates stack unwinding, not','line_number':5649,'multiline':False]
['text':'    the initial scan forward.)','line_number':5650,'multiline':False]
['text':' !!!: should this 0 be one of f*Limit?','line_number':5653,'multiline':False]
['text':' .*, stepping back over CRLF pair.','line_number':5660,'multiline':False]
['text':' Trouble.  The compiled pattern contains an entry with an','line_number':5673,'multiline':False]
['text':'           unrecognized type tag.','line_number':5674,'multiline':False]
['text':' The active stack frame when the engine stopped.','line_number':5702,'multiline':False]
['text':'   Contains the capture group results that we need to','line_number':5703,'multiline':False]
['text':'    access later.','line_number':5704,'multiline':False]
['text':' !UCONFIG_NO_REGULAR_EXPRESSIONS','line_number':5714,'multiline':False]
