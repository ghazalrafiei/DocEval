['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]
['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]
['text':'
*******************************************************************************
*
*   Copyright (C) 2005-2016, International Business Machines
*   Corporation and others.  All Rights Reserved.
*
*******************************************************************************
*   file name:  utext.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
*   created on: 2005apr12
*   created by: Markus W. Scherer
','line_number':3,'multiline':True]
['text':' The desired position is outside of the current chunk.','line_number':113,'multiline':False]
['text':' Access the new position.  Assume a forward iteration from here,','line_number':114,'multiline':False]
['text':' which will also be optimimum for a single random access.','line_number':115,'multiline':False]
['text':' Reverse iterations may suffer slightly.','line_number':116,'multiline':False]
['text':' utf-16 indexing.','line_number':119,'multiline':False]
['text':' The convention is that the index must always be on a code point boundary.','line_number':124,'multiline':False]
['text':' Adjust the index position if it is in the middle of a surrogate pair.','line_number':125,'multiline':False]
['text':'','line_number':146,'multiline':False]
['text':'  Fast-path the common case.','line_number':147,'multiline':False]
['text':'     Common means current position is not at the beginning of a chunk','line_number':148,'multiline':False]
['text':'     and the preceding character is not supplementary.','line_number':149,'multiline':False]
['text':'','line_number':150,'multiline':False]
['text':' If at the start of text, simply return 0.','line_number':167,'multiline':False]
['text':' Harder, less common cases.  We are at a chunk boundary, or on a surrogate.','line_number':172,'multiline':False]
['text':'    Keep it simple, use other functions to handle the edges.','line_number':173,'multiline':False]
['text':'','line_number':174,'multiline':False]
['text':'','line_number':182,'multiline':False]
['text':'  utext_current32.  Get the UChar32 at the current position.','line_number':183,'multiline':False]
['text':'                    UText iteration position is always on a code point boundary,','line_number':184,'multiline':False]
['text':'                    never on the trail half of a surrogate pair.','line_number':185,'multiline':False]
['text':'','line_number':186,'multiline':False]
['text':' Current position is just off the end of the chunk.','line_number':191,'multiline':False]
['text':' Off the end of the text.','line_number':193,'multiline':False]
['text':' Normal, non-supplementary case.','line_number':200,'multiline':False]
['text':'','line_number':204,'multiline':False]
['text':'  Possible supplementary char.','line_number':205,'multiline':False]
['text':'','line_number':206,'multiline':False]
['text':' The trail surrogate is in the same chunk.','line_number':210,'multiline':False]
['text':'  The trail surrogate is in a different chunk.','line_number':213,'multiline':False]
['text':'     Because we must maintain the iteration position, we need to switch forward','line_number':214,'multiline':False]
['text':'     into the new chunk, get the trail surrogate, then revert the chunk back to the','line_number':215,'multiline':False]
['text':'     original one.','line_number':216,'multiline':False]
['text':'     An edge case to be careful of:  the entire text may end with an unpaired','line_number':217,'multiline':False]
['text':'        leading surrogate.  The attempt to access the trail will fail, but','line_number':218,'multiline':False]
['text':'        the original position before the unpaired lead still needs to be restored.','line_number':219,'multiline':False]
['text':' reverse iteration flag loads preceding chunk','line_number':225,'multiline':False]
['text':' Fast path the common case.','line_number':245,'multiline':False]
['text':' For surrogates, let current32() deal with the complications','line_number':259,'multiline':False]
['text':'    of supplementaries that may span chunk boundaries.','line_number':260,'multiline':False]
['text':' Normal case, not supplementary.','line_number':280,'multiline':False]
['text':'   (A trail surrogate seen here is just returned as is, as a surrogate value.','line_number':281,'multiline':False]
['text':'    It cannot be part of a pair.)','line_number':282,'multiline':False]
['text':' c is an unpaired lead surrogate at the end of the text.','line_number':288,'multiline':False]
['text':' return it as it is.','line_number':289,'multiline':False]
['text':' c was an unpaired lead surrogate, not at the end of the text.','line_number':295,'multiline':False]
['text':' return it as it is (unpaired).  Iteration position is on the','line_number':296,'multiline':False]
['text':' following character, possibly in the next chunk, where the','line_number':297,'multiline':False]
['text':'  trail surrogate would have been if it had existed.','line_number':298,'multiline':False]
['text':' move iteration position over the trail surrogate.','line_number':303,'multiline':False]
['text':' Normal case, not supplementary.','line_number':320,'multiline':False]
['text':'   (A lead surrogate seen here is just returned as is, as a surrogate value.','line_number':321,'multiline':False]
['text':'    It cannot be part of a pair.)','line_number':322,'multiline':False]
['text':' c is an unpaired trail surrogate at the start of the text.','line_number':328,'multiline':False]
['text':' return it as it is.','line_number':329,'multiline':False]
['text':' c was an unpaired trail surrogate, not at the end of the text.','line_number':336,'multiline':False]
['text':' return it as it is (unpaired).  Iteration position is at c','line_number':337,'multiline':False]
['text':' move iteration position over the lead surrogate.','line_number':342,'multiline':False]
['text':' Desired position is outside of the current chunk.','line_number':353,'multiline':False]
['text':' no chunk available here','line_number':355,'multiline':False]
['text':' Desired position is in chunk, with direct 1:1 native to UTF16 indexing','line_number':359,'multiline':False]
['text':' Desired position is in chunk, with non-UTF16 indexing.','line_number':362,'multiline':False]
['text':' Surrogates.  Many edge cases.  Use other functions that already','line_number':368,'multiline':False]
['text':'              deal with the problems.','line_number':369,'multiline':False]
['text':'','line_number':379,'multiline':False]
['text':'  Return the character preceding the specified index.','line_number':380,'multiline':False]
['text':'  Leave the iteration position at the start of the character that was returned.','line_number':381,'multiline':False]
['text':'','line_number':382,'multiline':False]
['text':' The character preceding cCurr, which is what we will return.','line_number':383,'multiline':False]
['text':' Address the chunk containing the position preceding the incoming index','line_number':385,'multiline':False]
['text':' A tricky edge case:','line_number':386,'multiline':False]
['text':'   We try to test the requested native index against the chunkNativeStart to determine','line_number':387,'multiline':False]
['text':'    whether the character preceding the one at the index is in the current chunk.','line_number':388,'multiline':False]
['text':'    BUT, this test can fail with UTF-8 (or any other multibyte encoding), when the','line_number':389,'multiline':False]
['text':'    requested index is on something other than the first position of the first char.','line_number':390,'multiline':False]
['text':'','line_number':391,'multiline':False]
['text':' Requested native index is outside of the current chunk.','line_number':393,'multiline':False]
['text':' no chunk available here','line_number':395,'multiline':False]
['text':' Direct UTF-16 indexing.','line_number':399,'multiline':False]
['text':' no chunk available here','line_number':404,'multiline':False]
['text':'','line_number':409,'multiline':False]
['text':' Simple case with no surrogates.','line_number':410,'multiline':False]
['text':'','line_number':411,'multiline':False]
['text':' Possible supplementary.  Many edge cases.','line_number':416,'multiline':False]
['text':' Let other functions do the heavy lifting.','line_number':417,'multiline':False]
['text':' Null or invalid arguments don't compare equal to anything.','line_number':440,'multiline':False]
['text':' Different types of text providers.','line_number':445,'multiline':False]
['text':' Different sources (different strings)','line_number':450,'multiline':False]
['text':' Different current position in the string.','line_number':454,'multiline':False]
['text':' Zero out the WRITABLE flag.','line_number':471,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':542,'multiline':False]
['text':'','line_number':543,'multiline':False]
['text':'   UText common functions implementation','line_number':544,'multiline':False]
['text':'','line_number':545,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':546,'multiline':False]
['text':'','line_number':548,'multiline':False]
['text':'  UText.flags bit definitions','line_number':549,'multiline':False]
['text':'','line_number':550,'multiline':False]
['text':'  1 if ICU has allocated this UText struct on the heap.','line_number':552,'multiline':False]
['text':'  0 if caller provided storage for the UText.','line_number':553,'multiline':False]
['text':'  1 if ICU has allocated extra storage as a separate','line_number':555,'multiline':False]
['text':'     heap block.','line_number':556,'multiline':False]
['text':'  0 if there is no separate allocation.  Either no extra','line_number':557,'multiline':False]
['text':'     storage was requested, or it is appended to the end','line_number':558,'multiline':False]
['text':'     of the main UText storage.','line_number':559,'multiline':False]
['text':'  1 if this UText is currently open','line_number':561,'multiline':False]
['text':'  0 if this UText is not open.','line_number':562,'multiline':False]
['text':'','line_number':566,'multiline':False]
['text':'  Extended form of a UText.  The purpose is to aid in computing the total size required','line_number':567,'multiline':False]
['text':'    when a provider asks for a UText to be allocated with extra storage.','line_number':568,'multiline':False]
['text':' We need to heap-allocate storage for the new UText','line_number':584,'multiline':False]
['text':' We have been supplied with an already existing UText.','line_number':602,'multiline':False]
['text':' Verify that it really appears to be a UText.','line_number':603,'multiline':False]
['text':' If the ut is already open and there's a provider supplied close','line_number':608,'multiline':False]
['text':'   function, call it.','line_number':609,'multiline':False]
['text':' If extra space was requested by our caller, check whether','line_number':615,'multiline':False]
['text':'   sufficient already exists, and allocate new if needed.','line_number':616,'multiline':False]
['text':' Need more space.  If there is existing separately allocated space,','line_number':618,'multiline':False]
['text':'   delete it first, then allocate new space.','line_number':619,'multiline':False]
['text':' Initialize all remaining fields of the UText.','line_number':636,'multiline':False]
['text':'','line_number':637,'multiline':False]
['text':' The supplied ut is not an open UText.','line_number':670,'multiline':False]
['text':' Do nothing.','line_number':671,'multiline':False]
['text':' If the provider gave us a close function, call it now.','line_number':675,'multiline':False]
['text':' This will clean up anything allocated specifically by the provider.','line_number':676,'multiline':False]
['text':' If we (the framework) allocated the UText or subsidiary storage,','line_number':682,'multiline':False]
['text':'   delete it.','line_number':683,'multiline':False]
['text':' Zero out function table of the closed UText.  This is a defensive move,','line_number':691,'multiline':False]
['text':'   inteded to cause applications that inadvertantly use a closed','line_number':692,'multiline':False]
['text':'   utext to crash with null pointer errors.','line_number':693,'multiline':False]
['text':' This UText was allocated by UText setup.  We need to free it.','line_number':697,'multiline':False]
['text':' Clear magic, so we can detect if the user messes up and immediately','line_number':698,'multiline':False]
['text':'  tries to reopen another UText using the deleted storage.','line_number':699,'multiline':False]
['text':'','line_number':710,'multiline':False]
['text':' invalidateChunk   Reset a chunk to have no contents, so that the next call','line_number':711,'multiline':False]
['text':'                   to access will cause new data to load.','line_number':712,'multiline':False]
['text':'                   This is needed when copy/move/replace operate directly on the','line_number':713,'multiline':False]
['text':'                   backing text, potentially putting it out of sync with the','line_number':714,'multiline':False]
['text':'                   contents in the chunk.','line_number':715,'multiline':False]
['text':'','line_number':716,'multiline':False]
['text':'','line_number':726,'multiline':False]
['text':' pinIndex        Do range pinning on a native index parameter.','line_number':727,'multiline':False]
['text':'                 64 bit pinning is done in place.','line_number':728,'multiline':False]
['text':'                 32 bit truncated result is returned as a convenience for','line_number':729,'multiline':False]
['text':'                        use in providers that don't need 64 bits.','line_number':730,'multiline':False]
['text':'','line_number':744,'multiline':False]
['text':' Pointer relocation function,','line_number':745,'multiline':False]
['text':'   a utility used by shallow clone.','line_number':746,'multiline':False]
['text':'   Adjust a pointer that refers to something within one UText (the source)','line_number':747,'multiline':False]
['text':'   to refer to the same relative offset within a another UText (the target)','line_number':748,'multiline':False]
['text':'','line_number':749,'multiline':False]
['text':' convert all pointers to (char *) so that byte address arithmetic will work.','line_number':751,'multiline':False]
['text':' target ptr was to something within the src UText's pExtra storage.','line_number':757,'multiline':False]
['text':'   relocate it into the target UText's pExtra region.','line_number':758,'multiline':False]
['text':' target ptr was pointing to somewhere within the source UText itself.','line_number':761,'multiline':False]
['text':'   Move it to the same offset within the target UText.','line_number':762,'multiline':False]
['text':'','line_number':768,'multiline':False]
['text':'  Clone.  This is a generic copy-the-utext-by-value clone function that can be','line_number':769,'multiline':False]
['text':'          used as-is with some utext types, and as a helper by other clones.','line_number':770,'multiline':False]
['text':'','line_number':771,'multiline':False]
['text':'','line_number':779,'multiline':False]
['text':' Use the generic text_setup to allocate storage if required.','line_number':780,'multiline':False]
['text':'','line_number':781,'multiline':False]
['text':'','line_number':787,'multiline':False]
['text':'  flags (how the UText was allocated) and the pointer to the','line_number':788,'multiline':False]
['text':'   extra storage must retain the values in the cloned utext that','line_number':789,'multiline':False]
['text':'   were set up by utext_setup.  Save them separately before','line_number':790,'multiline':False]
['text':'   copying the whole struct.','line_number':791,'multiline':False]
['text':'','line_number':792,'multiline':False]
['text':'','line_number':797,'multiline':False]
['text':'  Copy the whole UText struct by value.','line_number':798,'multiline':False]
['text':'  Any "Extra" storage is copied also.','line_number':799,'multiline':False]
['text':'','line_number':800,'multiline':False]
['text':'','line_number':812,'multiline':False]
['text':' Relocate any pointers in the target that refer to the UText itself','line_number':813,'multiline':False]
['text':'   to point to the cloned copy rather than the original source.','line_number':814,'multiline':False]
['text':'','line_number':815,'multiline':False]
['text':' The newly shallow-cloned UText does _not_ own the underlying storage for the text.','line_number':822,'multiline':False]
['text':' (The source for the clone may or may not have owned the text.)','line_number':823,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':835,'multiline':False]
['text':'','line_number':836,'multiline':False]
['text':'     UText implementation for UTF-8 char * strings (read-only)','line_number':837,'multiline':False]
['text':'     Limitation:  string length must be <= 0x7fffffff in length.','line_number':838,'multiline':False]
['text':'                  (length must for in an int32_t variable)','line_number':839,'multiline':False]
['text':'','line_number':840,'multiline':False]
['text':'         Use of UText data members:','line_number':841,'multiline':False]
['text':'              context    pointer to UTF-8 string','line_number':842,'multiline':False]
['text':'              utext.b    is the input string length (bytes).','line_number':843,'multiline':False]
['text':'              utext.c    Length scanned so far in string','line_number':844,'multiline':False]
['text':'                           (for optimizing finding length of zero terminated strings.)','line_number':845,'multiline':False]
['text':'              utext.p    pointer to the current buffer','line_number':846,'multiline':False]
['text':'              utext.q    pointer to the other buffer.','line_number':847,'multiline':False]
['text':'','line_number':848,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':849,'multiline':False]
['text':' Chunk size.','line_number':851,'multiline':False]
['text':'     Must be less than 85 (256/3), because of byte mapping from UChar indexes to native indexes.','line_number':852,'multiline':False]
['text':'     Worst case is three native bytes to one UChar.  (Supplemenaries are 4 native bytes','line_number':853,'multiline':False]
['text':'     to two UChars.)','line_number':854,'multiline':False]
['text':'     The longest illegal byte sequence treated as a single error (and converted to U+FFFD)','line_number':855,'multiline':False]
['text':'     is a three-byte sequence (truncated four-byte sequence).','line_number':856,'multiline':False]
['text':'','line_number':857,'multiline':False]
['text':'','line_number':860,'multiline':False]
['text':' UTF8Buf  Two of these structs will be set up in the UText's extra allocated space.','line_number':861,'multiline':False]
['text':'          Each contains the UChar chunk buffer, the to and from native maps, and','line_number':862,'multiline':False]
['text':'          header info.','line_number':863,'multiline':False]
['text':'','line_number':864,'multiline':False]
['text':'     because backwards iteration fills the buffers starting at the end and','line_number':865,'multiline':False]
['text':'     working towards the front, the filled part of the buffers may not begin','line_number':866,'multiline':False]
['text':'     at the start of the available storage for the buffers.','line_number':867,'multiline':False]
['text':'','line_number':868,'multiline':False]
['text':'     Buffer size is one bigger than the specified UTF8_TEXT_CHUNK_SIZE to allow for','line_number':869,'multiline':False]
['text':'     the last character added being a supplementary, and thus requiring a surrogate','line_number':870,'multiline':False]
['text':'     pair.  Doing this is simpler than checking for the edge case.','line_number':871,'multiline':False]
['text':'','line_number':872,'multiline':False]
['text':' Native index of first char in UChar buf','line_number':875,'multiline':False]
['text':' Native index following last char in buf.','line_number':876,'multiline':False]
['text':' First filled position in buf.','line_number':877,'multiline':False]
['text':' Limit of filled range in buf.','line_number':878,'multiline':False]
['text':' Limit of native indexing part of buf','line_number':879,'multiline':False]
['text':' Native index corresponding to','line_number':880,'multiline':False]
['text':'   mapToUChars[0].','line_number':881,'multiline':False]
['text':'   Set to bufNativeStart when filling forwards.','line_number':882,'multiline':False]
['text':'   Set to computed value when filling backwards.','line_number':883,'multiline':False]
['text':' The UChar buffer.  Requires one extra position beyond the','line_number':885,'multiline':False]
['text':'   the chunk size, to allow for surrogate at the end.','line_number':886,'multiline':False]
['text':'   Length must be identical to mapToNative array, below,','line_number':887,'multiline':False]
['text':'   because of the way indexing works when the array is','line_number':888,'multiline':False]
['text':'   filled backwards during a reverse iteration.  Thus,','line_number':889,'multiline':False]
['text':'   the additional extra size.','line_number':890,'multiline':False]
['text':' map UChar index in buf to','line_number':891,'multiline':False]
['text':'  native offset from bufNativeStart.','line_number':892,'multiline':False]
['text':'  Requires two extra slots,','line_number':893,'multiline':False]
['text':'    one for a supplementary starting in the last normal position,','line_number':894,'multiline':False]
['text':'    and one for an entry for the buffer limit position.','line_number':895,'multiline':False]
['text':' Map native offset from bufNativeStart to','line_number':896,'multiline':False]
['text':'   corresponding offset in filled part of buf.','line_number':897,'multiline':False]
['text':'','line_number':903,'multiline':False]
['text':'   utf8TextLength','line_number':904,'multiline':False]
['text':'','line_number':905,'multiline':False]
['text':'        Get the length of the string.  If we don't already know it,','line_number':906,'multiline':False]
['text':'              we'll need to scan for the trailing  nul.','line_number':907,'multiline':False]
['text':'','line_number':908,'multiline':False]
['text':' Zero terminated string, and we haven't scanned to the end yet.','line_number':912,'multiline':False]
['text':' Scan it now.','line_number':913,'multiline':False]
['text':' Actual string was bigger (more than 2 gig) than we','line_number':921,'multiline':False]
['text':'   can handle.  Clip it to 2 GB.','line_number':922,'multiline':False]
['text':'','line_number':937,'multiline':False]
['text':'  Apologies to those who are allergic to goto statements.','line_number':938,'multiline':False]
['text':'    Consider each goto to a labelled block to be the equivalent of','line_number':939,'multiline':False]
['text':'         call the named block as if it were a function();','line_number':940,'multiline':False]
['text':'         return;','line_number':941,'multiline':False]
['text':'','line_number':942,'multiline':False]
['text':' Length of original utf-8','line_number':945,'multiline':False]
['text':' Requested index, trimmed to 32 bits.','line_number':946,'multiline':False]
['text':' Strings with 64 bit lengths not supported by this UTF-8 provider.','line_number':951,'multiline':False]
['text':' Pin requested index to the string length.','line_number':955,'multiline':False]
['text':' Zero terminated string, and requested index is beyond','line_number':960,'multiline':False]
['text':'   the region that has already been scanned.','line_number':961,'multiline':False]
['text':'   Scan up to either the end of the string or to the','line_number':962,'multiline':False]
['text':'   requested position, whichever comes first.','line_number':963,'multiline':False]
['text':'  TODO:  support for null terminated string length > 32 bits.','line_number':967,'multiline':False]
['text':' We just found the actual length of the string.','line_number':969,'multiline':False]
['text':'  Trim the requested index back to that.','line_number':970,'multiline':False]
['text':'','line_number':979,'multiline':False]
['text':' Dispatch to the appropriate action for a forward iteration request.','line_number':980,'multiline':False]
['text':'','line_number':981,'multiline':False]
['text':' Check for normal sequential iteration cases first.','line_number':984,'multiline':False]
['text':' Just reached end of string','line_number':986,'multiline':False]
['text':' Don't swap buffers, but do set the','line_number':987,'multiline':False]
['text':'   current buffer position.','line_number':988,'multiline':False]
['text':' End of current buffer.','line_number':992,'multiline':False]
['text':'   check whether other buffer already has what we need.','line_number':993,'multiline':False]
['text':' A random access.  Desired index could be in either or niether buf.','line_number':1001,'multiline':False]
['text':' For optimizing the order of testing, first check for the index','line_number':1002,'multiline':False]
['text':'    being in the other buffer.  This will be the case for uses that','line_number':1003,'multiline':False]
['text':'    move back and forth over a fairly limited range','line_number':1004,'multiline':False]
['text':' the alternate buffer','line_number':1006,'multiline':False]
['text':' Requested index is in the other buffer.','line_number':1008,'multiline':False]
['text':' Requested index is end-of-string.','line_number':1012,'multiline':False]
['text':'   (this is the case of randomly seeking to the end.','line_number':1013,'multiline':False]
['text':'    The case of iterating off the end is handled earlier.)','line_number':1014,'multiline':False]
['text':' Current buffer extends up to the end of the string.','line_number':1016,'multiline':False]
['text':'   Leave it as the current buffer.','line_number':1017,'multiline':False]
['text':' Alternate buffer extends to the end of string.','line_number':1022,'multiline':False]
['text':'   Swap it in as the current buffer.','line_number':1023,'multiline':False]
['text':' Neither existing buffer extends to the end of the string.','line_number':1027,'multiline':False]
['text':' Requested index is in neither buffer.','line_number':1032,'multiline':False]
['text':' Requested index is in this buffer.','line_number':1036,'multiline':False]
['text':' the current buffer','line_number':1037,'multiline':False]
['text':'','line_number':1047,'multiline':False]
['text':' Dispatch to the appropriate action for a','line_number':1048,'multiline':False]
['text':'   Backwards Diretion iteration request.','line_number':1049,'multiline':False]
['text':'','line_number':1050,'multiline':False]
['text':' Check for normal sequential iteration cases first.','line_number':1052,'multiline':False]
['text':' Just reached the start of string','line_number':1054,'multiline':False]
['text':' Don't swap buffers, but do set the','line_number':1055,'multiline':False]
['text':'   current buffer position.','line_number':1056,'multiline':False]
['text':' Start of current buffer.','line_number':1060,'multiline':False]
['text':'   check whether other buffer already has what we need.','line_number':1061,'multiline':False]
['text':' A random access.  Desired index could be in either or niether buf.','line_number':1069,'multiline':False]
['text':' For optimizing the order of testing,','line_number':1070,'multiline':False]
['text':'    Most likely case:  in the other buffer.','line_number':1071,'multiline':False]
['text':'    Second most likely: in neither buffer.','line_number':1072,'multiline':False]
['text':'    Unlikely, but must work:  in the current buffer.','line_number':1073,'multiline':False]
['text':' the alternate buffer','line_number':1074,'multiline':False]
['text':' Requested index is in the other buffer.','line_number':1076,'multiline':False]
['text':' Requested index is start-of-string.','line_number':1079,'multiline':False]
['text':'   (this is the case of randomly seeking to the start.','line_number':1080,'multiline':False]
['text':'    The case of iterating off the start is handled earlier.)','line_number':1081,'multiline':False]
['text':' Alternate buffer contains the data for the start string.','line_number':1084,'multiline':False]
['text':' Make it be the current buffer.','line_number':1085,'multiline':False]
['text':' Request for data before the start of string,','line_number':1088,'multiline':False]
['text':'   neither buffer is usable.','line_number':1089,'multiline':False]
['text':'   set up a zero-length buffer.','line_number':1090,'multiline':False]
['text':' Requested index is in neither buffer.','line_number':1096,'multiline':False]
['text':' Requested index is in this buffer.','line_number':1100,'multiline':False]
['text':'   Set the utf16 buffer index.','line_number':1101,'multiline':False]
['text':' This occurs when the first character in the text is','line_number':1106,'multiline':False]
['text':'   a multi-byte UTF-8 char, and the requested index is to','line_number':1107,'multiline':False]
['text':'   one of the trailing bytes.  Because there is no preceding ,','line_number':1108,'multiline':False]
['text':'   character, this access fails.  We can't pick up on the','line_number':1109,'multiline':False]
['text':'   situation sooner because the requested index is not zero.','line_number':1110,'multiline':False]
['text':'  The alternate buffer (ut->q) has the string data that was requested.','line_number':1119,'multiline':False]
['text':'  Swap the primary and alternate buffers, and set the','line_number':1120,'multiline':False]
['text':'   chunk index into the new primary buffer.','line_number':1121,'multiline':False]
['text':' Index into the (now current) chunk','line_number':1132,'multiline':False]
['text':' Use the map to set the chunk index.  It's more trouble than it's worth','line_number':1133,'multiline':False]
['text':'    to check whether native indexing can be used.','line_number':1134,'multiline':False]
['text':' We got a request for either the start or end of the string,','line_number':1147,'multiline':False]
['text':'  with iteration continuing in the out-of-bounds direction.','line_number':1148,'multiline':False]
['text':' The alternate buffer already contains the data up to the','line_number':1149,'multiline':False]
['text':'  start/end.','line_number':1150,'multiline':False]
['text':' Swap the buffers, then return failure, indicating that we couldn't','line_number':1151,'multiline':False]
['text':'  make things correct for continuing the iteration in the requested','line_number':1152,'multiline':False]
['text':'  direction.  The position & buffer are correct should the','line_number':1153,'multiline':False]
['text':'  user decide to iterate in the opposite direction.','line_number':1154,'multiline':False]
['text':' Index into the (now current) chunk','line_number':1164,'multiline':False]
['text':'  For this function  (swapBuffersAndFail), the requested index','line_number':1165,'multiline':False]
['text':'    will always be at either the start or end of the chunk.','line_number':1166,'multiline':False]
['text':'   The user has done a seek/access past the start or end','line_number':1176,'multiline':False]
['text':'   of the string.  Rather than loading data that is likely','line_number':1177,'multiline':False]
['text':'   to never be used, just set up a zero-length buffer at','line_number':1178,'multiline':False]
['text':'   the position.','line_number':1179,'multiline':False]
['text':' Move the incoming index to a code point boundary.','line_number':1195,'multiline':False]
['text':' Swap the UText buffers.','line_number':1198,'multiline':False]
['text':'  We want to fill what was previously the alternate buffer,','line_number':1199,'multiline':False]
['text':'  and make what was the current buffer be the new alternate.','line_number':1200,'multiline':False]
['text':' Fill the chunk buffer and mapping arrays.','line_number':1220,'multiline':False]
['text':' Special case ASCII range for speed.','line_number':1224,'multiline':False]
['text':'   zero is excluded to simplify bounds checking.','line_number':1225,'multiline':False]
['text':' General case, handle everything.','line_number':1232,'multiline':False]
['text':'  store Native <--> Chunk Map entries for the end of the buffer.','line_number':1262,'multiline':False]
['text':'    There is no actual character here, but the index position is valid.','line_number':1263,'multiline':False]
['text':'  fill in Buffer descriptor','line_number':1267,'multiline':False]
['text':' Set UText chunk to refer to this buffer.','line_number':1277,'multiline':False]
['text':' For zero terminated strings, keep track of the maximum point','line_number':1285,'multiline':False]
['text':'   scanned so far.','line_number':1286,'multiline':False]
['text':' We scanned to the end.','line_number':1290,'multiline':False]
['text':'   Remember the actual length.','line_number':1291,'multiline':False]
['text':' Move the incoming index to a code point boundary.','line_number':1302,'multiline':False]
['text':' Can only do this if the incoming index is somewhere in the interior of the string.','line_number':1303,'multiline':False]
['text':'   If index is at the end, there is no character there to look at.','line_number':1304,'multiline':False]
['text':' Note: this function will only move the index back if it is on a trail byte','line_number':1306,'multiline':False]
['text':'       and there is a preceding lead byte and the sequence from the lead ','line_number':1307,'multiline':False]
['text':'       through this trail could be part of a valid UTF-8 sequence','line_number':1308,'multiline':False]
['text':'       Otherwise the index remains unchanged.','line_number':1309,'multiline':False]
['text':' Swap the UText buffers.','line_number':1313,'multiline':False]
['text':'  We want to fill what was previously the alternate buffer,','line_number':1314,'multiline':False]
['text':'  and make what was the current buffer be the new alternate.','line_number':1315,'multiline':False]
['text':' Note that toUCharsMapStart can be negative. Happens when the remaining','line_number':1324,'multiline':False]
['text':' text from current position to the beginning is less than the buffer size.','line_number':1325,'multiline':False]
['text':' + 1 because mapToUChars must have a slot at the end for the bufNativeLimit entry.','line_number':1326,'multiline':False]
['text':' Start in the overflow region','line_number':1327,'multiline':False]
['text':'   at end of buffer to leave room','line_number':1328,'multiline':False]
['text':'   for a surrogate pair at the','line_number':1329,'multiline':False]
['text':'   buffer start.','line_number':1330,'multiline':False]
['text':' Map to/from Native Indexes, fill in for the position at the end of','line_number':1335,'multiline':False]
['text':'   the buffer.','line_number':1336,'multiline':False]
['text':'','line_number':1337,'multiline':False]
['text':' Fill the chunk buffer','line_number':1341,'multiline':False]
['text':' Work backwards, filling from the end of the buffer towards the front.','line_number':1342,'multiline':False]
['text':'','line_number':1343,'multiline':False]
['text':' Get last byte of the UTF-8 character','line_number':1348,'multiline':False]
['text':' Special case ASCII range for speed.','line_number':1351,'multiline':False]
['text':' General case, handle everything non-ASCII.','line_number':1357,'multiline':False]
['text':' ix of last byte of multi-byte u8 char','line_number':1359,'multiline':False]
['text':' Get the full character from the UTF8 string.','line_number':1361,'multiline':False]
['text':'   use code derived from tbe macros in utf8.h','line_number':1362,'multiline':False]
['text':'   Leaves srcIx pointing at the first byte of the UTF-8 char.','line_number':1363,'multiline':False]
['text':'','line_number':1364,'multiline':False]
['text':' leaves srcIx at first byte of the multi-byte char.','line_number':1366,'multiline':False]
['text':' Store the character in UTF-16 buffer.','line_number':1368,'multiline':False]
['text':' Fill in the map from native indexes to UChars buf index.','line_number':1379,'multiline':False]
['text':' Set native indexing limit to be the current position.','line_number':1385,'multiline':False]
['text':'   We are processing a non-ascii, non-native-indexing char now;','line_number':1386,'multiline':False]
['text':'     the limit will be here if the rest of the chars to be','line_number':1387,'multiline':False]
['text':'     added to this buffer are ascii.','line_number':1388,'multiline':False]
['text':'','line_number':1412,'multiline':False]
['text':'  This is a slightly modified copy of u_strFromUTF8,','line_number':1413,'multiline':False]
['text':'     Inserts a Replacement Char rather than failing on invalid UTF-8','line_number':1414,'multiline':False]
['text':'     Removes unnecessary features.','line_number':1415,'multiline':False]
['text':'','line_number':1416,'multiline':False]
['text':' required.  NUL terminated not supported.','line_number':1422,'multiline':False]
['text':' donot fill the dest buffer just count the UChars needed ','line_number':1454,'multiline':True]
['text':' Terminate the buffer ','line_number':1471,'multiline':True]
['text':' adjust the incoming indexes to land on code point boundaries if needed.','line_number':1501,'multiline':False]
['text':'    adjust by no more than three, because that is the largest number of trail bytes','line_number':1502,'multiline':False]
['text':'    in a well formed UTF8 character.','line_number':1503,'multiline':False]
['text':' Do the actual extract.','line_number':1524,'multiline':False]
['text':'','line_number':1533,'multiline':False]
['text':' utf8TextMapOffsetToNative','line_number':1534,'multiline':False]
['text':'','line_number':1535,'multiline':False]
['text':' Map a chunk (UTF-16) offset to a native index.','line_number':1536,'multiline':False]
['text':'','line_number':1539,'multiline':False]
['text':'','line_number':1547,'multiline':False]
['text':' Map a native index to the corresponding chunk offset','line_number':1548,'multiline':False]
['text':'','line_number':1549,'multiline':False]
['text':' First do a generic shallow clone.  Does everything needed for the UText struct itself.','line_number':1567,'multiline':False]
['text':' For deep clones, make a copy of the string.','line_number':1570,'multiline':False]
['text':'  The copied storage is owned by the newly created clone.','line_number':1571,'multiline':False]
['text':'','line_number':1572,'multiline':False]
['text':' TODO:  There is an isssue with using utext_nativeLength().','line_number':1573,'multiline':False]
['text':'        That function is non-const in cases where the input was NUL terminated','line_number':1574,'multiline':False]
['text':'          and the length has not yet been determined.','line_number':1575,'multiline':False]
['text':'        This function (clone()) is const.','line_number':1576,'multiline':False]
['text':'        There potentially a thread safety issue lurking here.','line_number':1577,'multiline':False]
['text':'','line_number':1578,'multiline':False]
['text':' Most of the work of close is done by the generic UText framework close.','line_number':1596,'multiline':False]
['text':' All that needs to be done here is to delete the UTF8 string if the UText','line_number':1597,'multiline':False]
['text':'  owns it.  This occurs if the UText was created by cloning.','line_number':1598,'multiline':False]
['text':' Reserved alignment padding','line_number':1612,'multiline':False]
['text':' replace','line_number':1617,'multiline':True]
['text':' copy   ','line_number':1618,'multiline':True]
['text':' spare 1','line_number':1622,'multiline':False]
['text':' spare 2','line_number':1623,'multiline':False]
['text':' spare 3','line_number':1624,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':1670,'multiline':False]
['text':'','line_number':1671,'multiline':False]
['text':'     UText implementation wrapper for Replaceable (read/write)','line_number':1672,'multiline':False]
['text':'','line_number':1673,'multiline':False]
['text':'         Use of UText data members:','line_number':1674,'multiline':False]
['text':'            context    pointer to Replaceable.','line_number':1675,'multiline':False]
['text':'            p          pointer to Replaceable if it is owned by the UText.','line_number':1676,'multiline':False]
['text':'','line_number':1677,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':1678,'multiline':False]
['text':' minimum chunk size for this implementation: 3','line_number':1682,'multiline':False]
['text':' to allow for possible trimming for code point boundaries','line_number':1683,'multiline':False]
['text':'
     * Chunk UChars.
     * +1 to simplify filling with surrogate pair at the end.
     ','line_number':1687,'multiline':True]
['text':' First do a generic shallow clone.  Does everything needed for the UText struct itself.','line_number':1699,'multiline':False]
['text':' For deep clones, make a copy of the Replaceable.','line_number':1702,'multiline':False]
['text':'  The copied Replaceable storage is owned by the newly created UText clone.','line_number':1703,'multiline':False]
['text':'  A non-NULL pointer in UText.p is the signal to the close() function to delete','line_number':1704,'multiline':False]
['text':'    it.','line_number':1705,'multiline':False]
['text':'','line_number':1706,'multiline':False]
['text':' with deep clone, the copy is writable, even when the source is not.','line_number':1712,'multiline':False]
['text':' Most of the work of close is done by the generic UText framework close.','line_number':1721,'multiline':False]
['text':' All that needs to be done here is delete the Replaceable if the UText','line_number':1722,'multiline':False]
['text':'  owns it.  This occurs if the UText was created by cloning.','line_number':1723,'multiline':False]
['text':' Full length of the input text (bigger than a chunk)','line_number':1743,'multiline':False]
['text':' clip the requested index to the limits of the text.','line_number':1745,'multiline':False]
['text':'
     * Compute start/limit boundaries around index, for a segment of text
     * to be extracted.
     * To allow for the possibility that our user gave an index to the trailing
     * half of a surrogate pair, we must request one extra preceding UChar when
     * going in the forward direction.  This will ensure that the buffer has the
     * entire code point at the specified index.
     ','line_number':1750,'multiline':True]
['text':' Buffer already contains the requested position.','line_number':1761,'multiline':False]
['text':' Request for end of string, and buffer already extends up to it.','line_number':1766,'multiline':False]
['text':' Can't get the data, but don't change the buffer.','line_number':1767,'multiline':False]
['text':' Going forward, so we want to have the buffer with stuff at and beyond','line_number':1773,'multiline':False]
['text':'   the requested index.  The -1 gets us one code point before the','line_number':1774,'multiline':False]
['text':'   requested index also, to handle the case of the index being on','line_number':1775,'multiline':False]
['text':'   a trail surrogate of a surrogate pair.','line_number':1776,'multiline':False]
['text':' unless buffer ran off end, start is index-1.','line_number':1780,'multiline':False]
['text':' Reverse iteration.  Fill buffer with data preceding the requested index.','line_number':1786,'multiline':False]
['text':' Requested position already in buffer.','line_number':1788,'multiline':False]
['text':' Request for start, buffer already begins at start.','line_number':1793,'multiline':False]
['text':'  No data, but keep the buffer as is.','line_number':1794,'multiline':False]
['text':' Figure out the bounds of the chunk to extract for reverse iteration.','line_number':1799,'multiline':False]
['text':' Need to worry about chunk not splitting surrogate pairs, and while still','line_number':1800,'multiline':False]
['text':' containing the data we need.','line_number':1801,'multiline':False]
['text':' Fix by requesting a chunk that includes an extra UChar at the end.','line_number':1802,'multiline':False]
['text':' If this turns out to be a lead surrogate, we can lop it off and still have','line_number':1803,'multiline':False]
['text':'   the data we wanted.','line_number':1804,'multiline':False]
['text':' Extract the new chunk of text from the Replaceable source.','line_number':1816,'multiline':False]
['text':' UnicodeString with its buffer a writable alias to the chunk buffer','line_number':1818,'multiline':False]
['text':'buffer length','line_number':1819,'multiline':True]
['text':'buffer capacity','line_number':1819,'multiline':True]
['text':' Surrogate pairs from the input text must not span chunk boundaries.','line_number':1826,'multiline':False]
['text':' If end of chunk could be the start of a surrogate, trim it off.','line_number':1827,'multiline':False]
['text':' if the first UChar in the chunk could be the trailing half of a surrogate pair,','line_number':1837,'multiline':False]
['text':' trim it off.','line_number':1838,'multiline':False]
['text':' adjust the index/chunkOffset to a code point boundary','line_number':1846,'multiline':False]
['text':' Use fast indexing for get/setNativeIndex()','line_number':1849,'multiline':False]
['text':' adjust start, limit if they point to trail half of surrogates','line_number':1879,'multiline':False]
['text':' writable alias','line_number':1893,'multiline':False]
['text':' will subtract from new length','line_number':1915,'multiline':False]
['text':' Snap start & limit to code point boundaries.','line_number':1924,'multiline':False]
['text':' Do the actual replace operation using methods of the Replaceable class','line_number':1936,'multiline':False]
['text':' read-only alias','line_number':1937,'multiline':False]
['text':' Is the UText chunk buffer OK?','line_number':1942,'multiline':False]
['text':' this replace operation may have impacted the current chunk.','line_number':1944,'multiline':False]
['text':' invalidate it, which will force a reload on the next access.','line_number':1945,'multiline':False]
['text':' set the iteration position to the end of the newly inserted replacement text.','line_number':1949,'multiline':False]
['text':' TODO:  snap input parameters to code point boundaries.','line_number':1980,'multiline':False]
['text':' move: copy to destIndex, then replace original with nothing','line_number':1983,'multiline':False]
['text':' copy','line_number':1992,'multiline':False]
['text':' If the change to the text touched the region in the chunk buffer,','line_number':1996,'multiline':False]
['text':'  invalidate the buffer.','line_number':1997,'multiline':False]
['text':' changes may have affected range covered by the chunk','line_number':2003,'multiline':False]
['text':' Put iteration position at the newly inserted (moved) block,','line_number':2007,'multiline':False]
['text':' moved a block of text towards the end of the string.','line_number':2010,'multiline':False]
['text':' Set position, reload chunk if needed.','line_number':2014,'multiline':False]
['text':' Reserved alignment padding','line_number':2021,'multiline':False]
['text':' MapOffsetToNative,','line_number':2028,'multiline':False]
['text':' MapIndexToUTF16,','line_number':2029,'multiline':False]
['text':' spare 1','line_number':2031,'multiline':False]
['text':' spare 2','line_number':2032,'multiline':False]
['text':' spare 3','line_number':2033,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2071,'multiline':False]
['text':'','line_number':2072,'multiline':False]
['text':'     UText implementation for UnicodeString (read/write)  and','line_number':2073,'multiline':False]
['text':'                    for const UnicodeString (read only)','line_number':2074,'multiline':False]
['text':'             (same implementation, only the flags are different)','line_number':2075,'multiline':False]
['text':'','line_number':2076,'multiline':False]
['text':'         Use of UText data members:','line_number':2077,'multiline':False]
['text':'            context    pointer to UnicodeString','line_number':2078,'multiline':False]
['text':'            p          pointer to UnicodeString IF this UText owns the string','line_number':2079,'multiline':False]
['text':'                       and it must be deleted on close().  NULL otherwise.','line_number':2080,'multiline':False]
['text':'','line_number':2081,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2082,'multiline':False]
['text':' First do a generic shallow clone.  Does everything needed for the UText struct itself.','line_number':2089,'multiline':False]
['text':' For deep clones, make a copy of the UnicodeSring.','line_number':2092,'multiline':False]
['text':'  The copied UnicodeString storage is owned by the newly created UText clone.','line_number':2093,'multiline':False]
['text':'  A non-NULL pointer in UText.p is the signal to the close() function to delete','line_number':2094,'multiline':False]
['text':'    the UText.','line_number':2095,'multiline':False]
['text':'','line_number':2096,'multiline':False]
['text':' with deep clone, the copy is writable, even when the source is not.','line_number':2102,'multiline':False]
['text':' Most of the work of close is done by the generic UText framework close.','line_number':2110,'multiline':False]
['text':' All that needs to be done here is delete the UnicodeString if the UText','line_number':2111,'multiline':False]
['text':'  owns it.  This occurs if the UText was created by cloning.','line_number':2112,'multiline':False]
['text':' Check whether request is at the start or end','line_number':2132,'multiline':False]
['text':' replace','line_number':2204,'multiline':False]
['text':' Update the chunk description.','line_number':2208,'multiline':False]
['text':' Set iteration position to the point just following the newly inserted text.','line_number':2214,'multiline':False]
['text':' move: copy to destIndex, then remove original','line_number':2243,'multiline':False]
['text':' copy','line_number':2251,'multiline':False]
['text':' update chunk description, set iteration position.','line_number':2255,'multiline':False]
['text':' copy operation, string length grows','line_number':2258,'multiline':False]
['text':' Iteration position to end of the newly inserted text.','line_number':2264,'multiline':False]
['text':' Reserved alignment padding','line_number':2275,'multiline':False]
['text':' MapOffsetToNative,','line_number':2282,'multiline':False]
['text':' MapIndexToUTF16,','line_number':2283,'multiline':False]
['text':' spare 1','line_number':2285,'multiline':False]
['text':' spare 2','line_number':2286,'multiline':False]
['text':' spare 3','line_number':2287,'multiline':False]
['text':' The UnicodeString is bogus, but we still need to detach the UText','line_number':2309,'multiline':False]
['text':'   from whatever it was hooked to before, if anything.','line_number':2310,'multiline':False]
['text':'    note:  use the standard (writable) function table for UnicodeString.','line_number':2316,'multiline':False]
['text':'           The flag settings disable writing, so having the functions in','line_number':2317,'multiline':False]
['text':'           the table is harmless.','line_number':2318,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2332,'multiline':False]
['text':'','line_number':2333,'multiline':False]
['text':'     UText implementation for const UChar * strings','line_number':2334,'multiline':False]
['text':'','line_number':2335,'multiline':False]
['text':'         Use of UText data members:','line_number':2336,'multiline':False]
['text':'            context    pointer to UnicodeString','line_number':2337,'multiline':False]
['text':'            a          length.  -1 if not yet known.','line_number':2338,'multiline':False]
['text':'','line_number':2339,'multiline':False]
['text':'         TODO:  support 64 bit lengths.','line_number':2340,'multiline':False]
['text':'','line_number':2341,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2342,'multiline':False]
['text':' First do a generic shallow clone.','line_number':2349,'multiline':False]
['text':' For deep clones, make a copy of the string.','line_number':2352,'multiline':False]
['text':'  The copied storage is owned by the newly created clone.','line_number':2353,'multiline':False]
['text':'  A non-NULL pointer in UText.p is the signal to the close() function to delete','line_number':2354,'multiline':False]
['text':'    it.','line_number':2355,'multiline':False]
['text':'','line_number':2356,'multiline':False]
['text':' The cloned string IS going to be NUL terminated, whether or not the original was.','line_number':2361,'multiline':False]
['text':' Most of the work of close is done by the generic UText framework close.','line_number':2382,'multiline':False]
['text':' All that needs to be done here is delete the string if the UText','line_number':2383,'multiline':False]
['text':'  owns it.  This occurs if the UText was created by cloning.','line_number':2384,'multiline':False]
['text':' null terminated, we don't yet know the length.  Scan for it.','line_number':2397,'multiline':False]
['text':'    Access is not convenient for doing this','line_number':2398,'multiline':False]
['text':'    because the current interation postion can't be changed.','line_number':2399,'multiline':False]
['text':' pin the requested index to the bounds of the string,','line_number':2420,'multiline':False]
['text':'  and set current iteration position.','line_number':2421,'multiline':False]
['text':' The request data is within the chunk as it is known so far.','line_number':2425,'multiline':False]
['text':' Put index on a code point boundary.','line_number':2426,'multiline':False]
['text':' We know the length of this string, and the user is requesting something','line_number':2429,'multiline':False]
['text':' at or beyond the length.  Pin the requested index to the length.','line_number':2430,'multiline':False]
['text':' Null terminated string, length not yet known, and the requested index','line_number':2433,'multiline':False]
['text':'  is beyond where we have scanned so far.','line_number':2434,'multiline':False]
['text':'  Scan to 32 UChars beyond the requested index.  The strategy here is','line_number':2435,'multiline':False]
['text':'  to avoid fully scanning a long string when the caller only wants to','line_number':2436,'multiline':False]
['text':'  see a few characters at its beginning.','line_number':2437,'multiline':False]
['text':' note: int64 expression','line_number':2439,'multiline':False]
['text':' We found the end of the string.  Remember it, pin the requested index to it,','line_number':2446,'multiline':False]
['text':'  and bail out of here.','line_number':2447,'multiline':False]
['text':' We scanned through the next batch of UChars without finding the end.','line_number':2462,'multiline':False]
['text':' Scanned to the limit of a 32 bit length.','line_number':2465,'multiline':False]
['text':' Forceably trim the overlength string back so length fits in int32','line_number':2466,'multiline':False]
['text':'  TODO:  add support for 64 bit strings.','line_number':2467,'multiline':False]
['text':' The endpoint of a chunk must not be left in the middle of a surrogate pair.','line_number':2477,'multiline':False]
['text':' If the current end is on a lead surrogate, back the end up by one.','line_number':2478,'multiline':False]
['text':' It doesn't matter if the end char happens to be an unpaired surrogate,','line_number':2479,'multiline':False]
['text':'    and it's simpler not to worry about it.','line_number':2480,'multiline':False]
['text':' Null-terminated chunk with end still unknown.','line_number':2484,'multiline':False]
['text':' Update the chunk length to reflect what has been scanned thus far.','line_number':2485,'multiline':False]
['text':' That the full length is still unknown is (still) flagged by','line_number':2486,'multiline':False]
['text':'    ut->a being < 0.','line_number':2487,'multiline':False]
['text':' Check whether request is at the start or end','line_number':2498,'multiline':False]
['text':'const UChar *s=(const UChar *)ut->context;','line_number':2519,'multiline':False]
['text':' Access the start.  Does two things we need:','line_number':2525,'multiline':False]
['text':'   Pins 'start' to the length of the string, if it came in out-of-bounds.','line_number':2526,'multiline':False]
['text':'   Snaps 'start' to the beginning of a code point.','line_number':2527,'multiline':False]
['text':' Just hit the end of a null-terminated string.','line_number':2541,'multiline':False]
['text':' set string length for this UText','line_number':2542,'multiline':False]
['text':' to ensure di never exceeds INT32_MAX, which must not happen logically ','line_number':2550,'multiline':True]
['text':' only store if there is space.','line_number':2552,'multiline':False]
['text':' We have filled the destination buffer, and the string length is known.','line_number':2556,'multiline':False]
['text':'  Cut the loop short.  There is no need to scan string termination.','line_number':2557,'multiline':False]
['text':' If the limit index points to a lead surrogate of a pair,','line_number':2566,'multiline':False]
['text':'   add the corresponding trail surrogate to the destination.','line_number':2567,'multiline':False]
['text':' store only if there is space in the output buffer.','line_number':2572,'multiline':False]
['text':' Put iteration position at the point just following the extracted text','line_number':2578,'multiline':False]
['text':' Add a terminating NUL if space in the buffer permits,','line_number':2585,'multiline':False]
['text':' and set the error status as required.','line_number':2586,'multiline':False]
['text':' Reserved alignment padding','line_number':2594,'multiline':False]
['text':' Replace','line_number':2599,'multiline':False]
['text':' Copy','line_number':2600,'multiline':False]
['text':' MapOffsetToNative,','line_number':2601,'multiline':False]
['text':' MapIndexToUTF16,','line_number':2602,'multiline':False]
['text':' spare 1','line_number':2604,'multiline':False]
['text':' spare 2','line_number':2605,'multiline':False]
['text':' spare 3','line_number':2606,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2645,'multiline':False]
['text':'','line_number':2646,'multiline':False]
['text':'     UText implementation for text from ICU CharacterIterators','line_number':2647,'multiline':False]
['text':'','line_number':2648,'multiline':False]
['text':'         Use of UText data members:','line_number':2649,'multiline':False]
['text':'            context    pointer to the CharacterIterator','line_number':2650,'multiline':False]
['text':'            a          length of the full text.','line_number':2651,'multiline':False]
['text':'            p          pointer to  buffer 1','line_number':2652,'multiline':False]
['text':'            b          start index of local buffer 1 contents','line_number':2653,'multiline':False]
['text':'            q          pointer to buffer 2','line_number':2654,'multiline':False]
['text':'            c          start index of local buffer 2 contents','line_number':2655,'multiline':False]
['text':'            r          pointer to the character iterator if the UText owns it.','line_number':2656,'multiline':False]
['text':'                       Null otherwise.','line_number':2657,'multiline':False]
['text':'','line_number':2658,'multiline':False]
['text':'------------------------------------------------------------------------------','line_number':2659,'multiline':False]
['text':' Most of the work of close is done by the generic UText framework close.','line_number':2665,'multiline':False]
['text':' All that needs to be done here is delete the CharacterIterator if the UText','line_number':2666,'multiline':False]
['text':'  owns it.  This occurs if the UText was created by cloning.','line_number':2667,'multiline':False]
['text':' reverse iteration, want the position just before what was asked for.','line_number':2690,'multiline':False]
['text':' Forward iteration, don't ask for something past the end of the text.','line_number':2693,'multiline':False]
['text':' Find the native index of the start of the buffer containing what we want.','line_number':2697,'multiline':False]
['text':' The buffer we want is already the current chunk.','line_number':2704,'multiline':False]
['text':' The first buffer (buffer p) has what we need.','line_number':2707,'multiline':False]
['text':' The second buffer (buffer q) has what we need.','line_number':2710,'multiline':False]
['text':' Neither buffer already has what we need.','line_number':2713,'multiline':False]
['text':' Load new data from the character iterator.','line_number':2714,'multiline':False]
['text':' Use the buf that is not the current buffer.','line_number':2715,'multiline':False]
['text':' We have a buffer with the data we need.','line_number':2729,'multiline':False]
['text':' Set it up as the current chunk, if it wasn't already.','line_number':2730,'multiline':False]
['text':' There is no CharacterIterator API for cloning the underlying text storage.','line_number':2755,'multiline':False]
['text':' cast off const on getNativeIndex.','line_number':2765,'multiline':False]
['text':'   For CharacterIterator based UTexts, this is safe, the operation is const.','line_number':2766,'multiline':False]
['text':' flags that this UText owns the CharacterIterator','line_number':2769,'multiline':False]
['text':' Moves ix to lead of surrogate pair, if needed.','line_number':2795,'multiline':False]
['text':' to ensure desti+len never exceeds MAX_INT32, which must not happen logically ','line_number':2801,'multiline':True]
['text':' Reserved alignment padding','line_number':2821,'multiline':False]
['text':' Replace','line_number':2826,'multiline':False]
['text':' Copy','line_number':2827,'multiline':False]
['text':' MapOffsetToNative,','line_number':2828,'multiline':False]
['text':' MapIndexToUTF16,','line_number':2829,'multiline':False]
['text':' spare 1','line_number':2831,'multiline':False]
['text':' spare 2','line_number':2832,'multiline':False]
['text':' spare 3','line_number':2833,'multiline':False]
['text':' No support for CharacterIterators that do not start indexing from zero.','line_number':2845,'multiline':False]
['text':' Extra space in UText for 2 buffers of CIBufSize UChars each.','line_number':2850,'multiline':False]
['text':' Length of text','line_number':2857,'multiline':False]
['text':' First buffer','line_number':2858,'multiline':False]
['text':' Native index of first buffer contents','line_number':2859,'multiline':False]
['text':' Second buffer','line_number':2860,'multiline':False]
['text':' Native index of second buffer contents','line_number':2861,'multiline':False]
['text':' Initialize current chunk contents to be empty.','line_number':2863,'multiline':False]
['text':'   First access will fault something in.','line_number':2864,'multiline':False]
['text':'   Note:  The initial nativeStart and chunkOffset must sum to zero','line_number':2865,'multiline':False]
['text':'          so that getNativeIndex() will correctly compute to zero','line_number':2866,'multiline':False]
['text':'          if no call to Access() has ever been made.  They can't be both','line_number':2867,'multiline':False]
['text':'          zero without Access() thinking that the chunk is valid.','line_number':2868,'multiline':False]
['text':' enables native indexing','line_number':2874,'multiline':False]
