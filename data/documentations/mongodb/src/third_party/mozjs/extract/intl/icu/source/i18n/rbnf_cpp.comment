['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]
['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]
['text':'
*******************************************************************************
* Copyright (C) 1997-2015, International Business Machines Corporation
* and others. All Rights Reserved.
*******************************************************************************
','line_number':3,'multiline':True]
['text':' for 'typeid' to work','line_number':11,'multiline':False]
['text':' debugging','line_number':39,'multiline':False]
['text':' #define RBNF_DEBUG','line_number':40,'multiline':False]
['text':' "%%" ','line_number':51,'multiline':True]
['text':' All urbnf objects are created through openRules, so we init all of the','line_number':53,'multiline':False]
['text':' Unicode string constants required by rbnf, nfrs, or nfr here.','line_number':54,'multiline':False]
['text':' "%%lenient-parse:" ','line_number':58,'multiline':True]
['text':' ";%" ','line_number':63,'multiline':True]
['text':'
This is a utility class. It does not use ICU's RTTI.
If ICU's RTTI is needed again, you can uncomment the RTTI code and derive from UObject.
Please make sure that intltest passes on Windows in Release mode,
since the string pooling per compilation unit will mess up how RTTI works.
The RTTI code was also removed due to lack of code coverage.
','line_number':75,'multiline':True]
['text':'    virtual UClassID getDynamicClassID() const = 0;','line_number':114,'multiline':False]
['text':'    static UClassID getStaticClassID(void);','line_number':115,'multiline':False]
['text':'UOBJECT_DEFINE_ABSTRACT_RTTI_IMPLEMENTATION(LocalizationInfo)','line_number':120,'multiline':False]
['text':' if both strings are NULL, this returns TRUE','line_number':122,'multiline':False]
['text':' if no locale, ix is -1, getLocaleName returns null, so streq returns false','line_number':153,'multiline':False]
['text':' if we couldn't realloc, we leak the memory we've already allocated, but we're in deep trouble anyway','line_number':234,'multiline':False]
['text':' fill with nulls, just because','line_number':240,'multiline':False]
['text':'    virtual UClassID getDynamicClassID() const;','line_number':280,'multiline':False]
['text':'    static UClassID getStaticClassID(void);','line_number':281,'multiline':False]
['text':' '<' ','line_number':289,'multiline':True]
['text':' '>' ','line_number':290,'multiline':True]
['text':'*
 * Utility for parsing a localization string and returning a StringLocalizationInfo*.
 ','line_number':297,'multiline':True]
['text':'
    * On a successful parse, return a StringLocalizationInfo*, otherwise delete locData, set perror and status,
    * and return NULL.  The StringLocalizationInfo will adopt locData if it is created.
    ','line_number':313,'multiline':True]
['text':' subtract first, NULL','line_number':462,'multiline':False]
['text':' subtract first, NULL','line_number':465,'multiline':False]
['text':' terminate by writing to data','line_number':547,'multiline':False]
['text':' just point into data','line_number':548,'multiline':False]
['text':' ok for there to be no next string','line_number':562,'multiline':False]
['text':' SOLIDUS/SLASH ','line_number':597,'multiline':True]
['text':'UOBJECT_DEFINE_RTTI_IMPLEMENTATION(StringLocalizationInfo)','line_number':622,'multiline':False]
['text':' no error;','line_number':632,'multiline':False]
['text':' clear warning about non-termination','line_number':642,'multiline':False]
['text':' remaining data is simply pointer into our unicode string data.','line_number':651,'multiline':False]
['text':' ----------','line_number':684,'multiline':False]
['text':' TODO: read localization info from resource','line_number':842,'multiline':False]
['text':' --------','line_number':898,'multiline':False]
['text':' test for capitalization info equality is adequately handled','line_number':948,'multiline':False]
['text':' by the NumberFormat test for fCapitalizationContext equality;','line_number':949,'multiline':False]
['text':' the info here is just derived from that.','line_number':950,'multiline':False]
['text':' trim trailing portion, skipping over ommitted sections','line_number':1080,'multiline':False]
['text':' underscore','line_number':1081,'multiline':False]
['text':' We're outside of our normal range that this framework can handle.','line_number':1137,'multiline':False]
['text':' The DecimalFormat will provide more accurate results.','line_number':1138,'multiline':False]
['text':' TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.','line_number':1140,'multiline':False]
['text':' f now owns decimalQuantity.','line_number':1150,'multiline':False]
['text':' pos ','line_number':1169,'multiline':True]
['text':' pos ','line_number':1182,'multiline':True]
['text':' pos ','line_number':1207,'multiline':True]
['text':' throw new IllegalArgumentException("Can't use internal rule set");','line_number':1212,'multiline':False]
['text':' pos ','line_number':1229,'multiline':True]
['text':' throw new IllegalArgumentException("Can't use internal rule set");','line_number':1234,'multiline':False]
['text':'*
 * Bottleneck through which all the public format() methods
 * that take a long pass. By the time we get here, we know
 * which rule set we're using to do the formatting.
 * @param number The number to format
 * @param ruleSet The rule set to use to format the number
 * @return The text that resulted from formatting the number
 ','line_number':1266,'multiline':True]
['text':' all API format() routines that take a double vector through','line_number':1277,'multiline':False]
['text':' here.  We have these two identical functions-- one taking a','line_number':1278,'multiline':False]
['text':' double and one taking a long-- the couple digits of precision','line_number':1279,'multiline':False]
['text':' that long has but double doesn't (both types are 8 bytes long,','line_number':1280,'multiline':False]
['text':' but double has to borrow some of the mantissa bits to hold','line_number':1281,'multiline':False]
['text':' the exponent).','line_number':1282,'multiline':False]
['text':' Create an empty string buffer where the result will','line_number':1283,'multiline':False]
['text':' be built, and pass it to the rule set (along with an insertion','line_number':1284,'multiline':False]
['text':' position of 0 and the number being formatted) to the rule set','line_number':1285,'multiline':False]
['text':' for formatting','line_number':1286,'multiline':False]
['text':' We can't handle this value right now. Provide an accurate default value.','line_number':1290,'multiline':False]
['text':' TODO this section should probably be optimized. The DecimalFormat is shared in ICU4J.','line_number':1292,'multiline':False]
['text':' f now owns decimalQuantity.','line_number':1306,'multiline':False]
['text':' capitalize currentResult according to context','line_number':1327,'multiline':False]
['text':' titlecase first word of currentResult, here use sentence iterator unlike current implementations','line_number':1333,'multiline':False]
['text':' in LocaleDisplayNamesImpl::adjustForUsageAndContext and RelativeDateFormat::format','line_number':1334,'multiline':False]
['text':' Note: casting a double to an int when the double is too large or small','line_number':1389,'multiline':False]
['text':'       to fit the destination is undefined behavior. The explicit range checks,','line_number':1390,'multiline':False]
['text':'       above, are required. Just casting and checking the result value is undefined.','line_number':1391,'multiline':False]
['text':' TODO: implement UParseError','line_number':1481,'multiline':False]
['text':' Note: this can leave ruleSets == NULL, so remaining code should check','line_number':1483,'multiline':False]
['text':' start by stripping the trailing whitespace from all the rules','line_number':1503,'multiline':False]
['text':' (this is all the whitespace follwing each semicolon in the','line_number':1504,'multiline':False]
['text':' description).  This allows us to look for rule-set boundaries','line_number':1505,'multiline':False]
['text':' by searching for ";%" without having to worry about whitespace','line_number':1506,'multiline':False]
['text':' between the ; and the %','line_number':1507,'multiline':False]
['text':' check to see if there's a set of lenient-parse rules.  If there','line_number':1510,'multiline':False]
['text':' is, pull them out into our temporary holding place for them,','line_number':1511,'multiline':False]
['text':' and delete them from the description before the real desciption-','line_number':1512,'multiline':False]
['text':' parsing code sees them','line_number':1513,'multiline':False]
['text':' we've got to make sure we're not in the middle of a rule','line_number':1516,'multiline':False]
['text':' (where "%%lenient-parse" would actually get treated as','line_number':1517,'multiline':False]
['text':' rule text)','line_number':1518,'multiline':False]
['text':' locate the beginning and end of the actual collation','line_number':1520,'multiline':False]
['text':' rules (there may be whitespace between the name and','line_number':1521,'multiline':False]
['text':' the first token in the description)','line_number':1522,'multiline':False]
['text':' copy out the lenient-parse rules and delete them','line_number':1533,'multiline':False]
['text':' from the description','line_number':1534,'multiline':False]
['text':' test for NULL ','line_number':1536,'multiline':True]
['text':' pre-flight parsing the description and count the number of','line_number':1547,'multiline':False]
['text':' rule sets (";%" marks the end of one rule set and the beginning','line_number':1548,'multiline':False]
['text':' of the next)','line_number':1549,'multiline':False]
['text':' our rule list is an array of the appropriate size','line_number':1557,'multiline':False]
['text':' test for NULL ','line_number':1559,'multiline':True]
['text':' divide up the descriptions into individual rule-set descriptions','line_number':1569,'multiline':False]
['text':' and store them in a temporary array.  At each step, we also','line_number':1570,'multiline':False]
['text':' new up a rule set, but all this does is initialize its name','line_number':1571,'multiline':False]
['text':' and remove it from its description.  We can't actually parse','line_number':1572,'multiline':False]
['text':' the rest of the descriptions and finish initializing everything','line_number':1573,'multiline':False]
['text':' because we have to know the names and locations of all the rule','line_number':1574,'multiline':False]
['text':' sets before we can actually set everything up','line_number':1575,'multiline':False]
['text':' now we can take note of the formatter's default rule set, which','line_number':1608,'multiline':False]
['text':' is the last public rule set in the description (it's the last','line_number':1609,'multiline':False]
['text':' rather than the first so that a user can create a new formatter','line_number':1610,'multiline':False]
['text':' from an existing formatter and change its default behavior just','line_number':1611,'multiline':False]
['text':' by appending more rule sets to the end)','line_number':1612,'multiline':False]
['text':' {dlf} Initialization of a fraction rule set requires the default rule','line_number':1614,'multiline':False]
['text':' set to be known.  For purposes of initialization, this is always the ','line_number':1615,'multiline':False]
['text':' last public rule set, no matter what the localization data says.','line_number':1616,'multiline':False]
['text':' finally, we can go back through the temporary descriptions','line_number':1619,'multiline':False]
['text':' list and finish setting up the substructure (and we throw','line_number':1620,'multiline':False]
['text':' away the temporary descriptions as we go)','line_number':1621,'multiline':False]
['text':' Now that the rules are initialized, the 'real' default rule','line_number':1628,'multiline':False]
['text':' set can be adjusted by the localization data.','line_number':1629,'multiline':False]
['text':' The C code keeps the localization array as is, rather than building','line_number':1631,'multiline':False]
['text':' a separate array of the public rule set names, so we have less work','line_number':1632,'multiline':False]
['text':' to do here-- but we still need to check the names.','line_number':1633,'multiline':False]
['text':' confirm the names, if any aren't in the rules, that's an error','line_number':1636,'multiline':False]
['text':' it is ok if the rules contain public rule sets that are not in this list','line_number':1637,'multiline':False]
['text':' error','line_number':1642,'multiline':False]
['text':' override the NumberFormat implementation in order to','line_number':1654,'multiline':False]
['text':' lazily initialize relevant items','line_number':1655,'multiline':False]
['text':' iterate through the characters...','line_number':1705,'multiline':False]
['text':' seek to the first non-whitespace character...','line_number':1710,'multiline':False]
['text':' locate the next semicolon in the text and copy the text from','line_number':1716,'multiline':False]
['text':' our current position up to that semicolon into the result','line_number':1717,'multiline':False]
['text':' or if we don't find a semicolon, just copy the rest of','line_number':1720,'multiline':False]
['text':' the string into the result','line_number':1721,'multiline':False]
['text':' when we get here, we've seeked off the end of the string, and','line_number':1730,'multiline':False]
['text':' we terminate the loop (we continue until *start* is -1 rather','line_number':1731,'multiline':False]
['text':' than until *p* is -1, because otherwise we'd miss the last','line_number':1732,'multiline':False]
['text':' rule in the description)','line_number':1733,'multiline':False]
['text':'-----------------------------------------------------------------------','line_number':1787,'multiline':False]
['text':' package-internal API','line_number':1788,'multiline':False]
['text':'-----------------------------------------------------------------------','line_number':1789,'multiline':False]
['text':'*
 * Returns the collator to use for lenient parsing.  The collator is lazily created:
 * this function creates it the first time it's called.
 * @return The collator to use for lenient parsing, or null if lenient parsing
 * is turned off.
','line_number':1791,'multiline':True]
['text':' lazy-evaluate the collator','line_number':1805,'multiline':False]
['text':' create a default collator based on the formatter's locale,','line_number':1807,'multiline':False]
['text':' then pull out that collator's rules, append any additional','line_number':1808,'multiline':False]
['text':' rules specified in the description, and create a _new_','line_number':1809,'multiline':False]
['text':' collator based on the combination of those rules','line_number':1810,'multiline':False]
['text':' Exit if newCollator could not be created.','line_number':1822,'multiline':False]
['text':' cast away const','line_number':1831,'multiline':False]
['text':' if lenient-parse mode is off, this will be null','line_number':1841,'multiline':False]
['text':' (see setLenientParseMode())','line_number':1842,'multiline':False]
['text':' lazy-evaluate the DecimalFormatSymbols object.  This object','line_number':1850,'multiline':False]
['text':' is shared by all DecimalFormat instances belonging to this','line_number':1851,'multiline':False]
['text':' formatter','line_number':1852,'multiline':False]
['text':'*
 * Returns the DecimalFormatSymbols object that should be used by all DecimalFormat
 * instances owned by this formatter.
','line_number':1862,'multiline':True]
['text':' De-owning the current localized symbols and adopt the new symbols.','line_number':1918,'multiline':False]
['text':' do not allow caller to set decimalFormatSymbols to NULL','line_number':1923,'multiline':False]
['text':' Apply the new decimalFormatSymbols by reparsing the rulesets','line_number':1933,'multiline':False]
['text':' Reset with the new DecimalFormatSymbols','line_number':1938,'multiline':False]
['text':' Reset with the new DecimalFormatSymbols','line_number':1942,'multiline':False]
['text':' Setting the symbols is equivalent to adopting a newly created localized symbols.','line_number':1952,'multiline':False]
['text':'*
 * Get the rounding mode.
 * @return A rounding mode
 ','line_number':1971,'multiline':True]
['text':'*
 * Set the rounding mode.  This has no effect unless the rounding
 * increment is greater than zero.
 * @param roundingMode A rounding mode
 ','line_number':1979,'multiline':True]
['text':' U_HAVE_RBNF ','line_number':1990,'multiline':True]
