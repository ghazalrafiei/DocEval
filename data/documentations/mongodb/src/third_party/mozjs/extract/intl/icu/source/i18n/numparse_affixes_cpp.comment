['text':' Â© 2018 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]
['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]
['text':' Allow implicit conversion from char16_t* to UnicodeString for this file:','line_number':8,'multiline':False]
['text':' Helpful in toString methods and elsewhere.','line_number':9,'multiline':False]
['text':'*
 * Helper method to return whether the given AffixPatternMatcher equals the given pattern string.
 * Either both arguments must be null or the pattern string inside the AffixPatternMatcher must equal
 * the given pattern string.
 ','line_number':27,'multiline':True]
['text':'*
 * Helper method to return the length of the given AffixPatternMatcher. Returns 0 for null.
 ','line_number':37,'multiline':True]
['text':'*
 * Helper method to return whether (1) both lhs and rhs are null/invalid, or (2) if they are both
 * valid, whether they are equal according to operator==.  Similar to Java Objects.equals()
 ','line_number':44,'multiline':True]
['text':' This is called by AffixUtils.iterateWithConsumer() for each token.','line_number':71,'multiline':False]
['text':' Add an ignorables matcher between tokens except between two literals, and don't put two','line_number':73,'multiline':False]
['text':' ignorables matchers in a row.','line_number':74,'multiline':False]
['text':' Case 1: the token is a symbol.','line_number':81,'multiline':False]
['text':' All currency symbols use the same matcher','line_number':100,'multiline':False]
['text':' Case 2: the token is an ignorable literal.','line_number':108,'multiline':False]
['text':' No action necessary: the ignorables matcher has already been added.','line_number':109,'multiline':False]
['text':' Case 3: the token is a non-ignorable literal.','line_number':112,'multiline':False]
['text':' OOM; unwind the stack','line_number':116,'multiline':False]
['text':' HACK: Plus and minus sign are a special case: we accept them trailing only if they are','line_number':250,'multiline':False]
['text':' trailing in the pattern string.','line_number':251,'multiline':False]
['text':' The affixes contain only symbols and ignorables.','line_number':256,'multiline':False]
['text':' No need to generate affix matchers.','line_number':257,'multiline':False]
['text':' The affixes have interesting characters, or we are in strict mode.','line_number':271,'multiline':False]
['text':' Use initial capacity of 6, the highest possible number of AffixMatchers.','line_number':272,'multiline':False]
['text':' Pre-process the affix strings to resolve LDML rules like sign display.','line_number':282,'multiline':False]
['text':' Skip affixes in some cases','line_number':286,'multiline':False]
['text':' Generate Prefix','line_number':296,'multiline':False]
['text':' Generate Suffix','line_number':305,'multiline':False]
['text':' Skip adding these matchers (we already have equivalents)','line_number':318,'multiline':False]
['text':' Flags for setting in the ParsedNumber; the token matchers may add more.','line_number':322,'multiline':False]
['text':' Note: it is indeed possible for posPrefix and posSuffix to both be null.','line_number':325,'multiline':False]
['text':' We still need to add that matcher for strict mode to work.','line_number':326,'multiline':False]
['text':' The following if statements are designed to prevent adding two identical matchers.','line_number':329,'multiline':False]
['text':' Put the AffixMatchers in order, and then add them to the output.','line_number':339,'multiline':False]
['text':' Since there are at most 9 elements, do a simple-to-implement bubble sort.','line_number':340,'multiline':False]
['text':' Enable the following line to debug affixes','line_number':355,'multiline':False]
['text':'std::cout << "Adding affix matcher: " << CStr(fAffixMatchers[i].toString())() << std::endl;','line_number':356,'multiline':False]
['text':' Prefix','line_number':367,'multiline':False]
['text':' Do not match if:','line_number':368,'multiline':False]
['text':' 1. We have already seen a prefix (result.prefix != null)','line_number':369,'multiline':False]
['text':' 2. The prefix in this AffixMatcher is empty (prefix == null)','line_number':370,'multiline':False]
['text':' Attempt to match the prefix.','line_number':375,'multiline':False]
['text':' Suffix','line_number':384,'multiline':False]
['text':' Do not match if:','line_number':385,'multiline':False]
['text':' 1. We have already seen a suffix (result.suffix != null)','line_number':386,'multiline':False]
['text':' 2. The suffix in this AffixMatcher is empty (suffix == null)','line_number':387,'multiline':False]
['text':' 3. The matched prefix does not equal this AffixMatcher's prefix','line_number':388,'multiline':False]
['text':' Attempt to match the suffix.','line_number':393,'multiline':False]
['text':' Check to see if our affix is the one that was matched. If so, set the flags in the result.','line_number':409,'multiline':False]
['text':' Fill in the result prefix and suffix with non-null values (empty string).','line_number':411,'multiline':False]
['text':' Used by strict mode to determine whether an entire affix pair was matched.','line_number':412,'multiline':False]
['text':' #if !UCONFIG_NO_FORMATTING ','line_number':449,'multiline':True]
