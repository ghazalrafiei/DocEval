['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]
['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]
['text':'
*******************************************************************************
* Copyright (C) 2010-2014, International Business Machines
* Corporation and others.  All Rights Reserved.
*******************************************************************************
* collationiterator.cpp
*
* created on: 2010oct27
* created by: Markus W. Scherer
','line_number':3,'multiline':True]
['text':' for 'typeid' to work','line_number':14,'multiline':False]
['text':' State of combining marks skipped in discontiguous contraction.','line_number':56,'multiline':False]
['text':' We create a state object on first use and keep it around deactivated between uses.','line_number':57,'multiline':False]
['text':' Born active but empty.','line_number':60,'multiline':False]
['text':' The newBuffer is reset by setFirstSkipped().','line_number':65,'multiline':False]
['text':' Requires hasNext().','line_number':72,'multiline':False]
['text':' Accounts for one more input code point read beyond the end of the marks buffer.','line_number':79,'multiline':False]
['text':' Goes backward through the skipped-marks buffer.','line_number':85,'multiline':False]
['text':' Returns the number of code points read beyond the skipped marks','line_number':86,'multiline':False]
['text':' that need to be backtracked through normal input.','line_number':87,'multiline':False]
['text':' Not back far enough to re-enter the oldBuffer.','line_number':93,'multiline':False]
['text':' Back out all beyond-oldBuffer code points and re-enter the buffer.','line_number':97,'multiline':False]
['text':' Go backwards from inside the oldBuffer.','line_number':102,'multiline':False]
['text':' Replaces the characters we consumed with the newly skipped ones.','line_number':119,'multiline':False]
['text':' Note: UnicodeString.replace() pins pos to at most length().','line_number':121,'multiline':False]
['text':' Combining marks skipped in previous discontiguous-contraction matching.','line_number':130,'multiline':False]
['text':' After that discontiguous contraction was completed, we start reading them from here.','line_number':131,'multiline':False]
['text':' Combining marks newly skipped in current discontiguous-contraction matching.','line_number':133,'multiline':False]
['text':' These might have been read from the normal text or from the oldBuffer.','line_number':134,'multiline':False]
['text':' Reading index in oldBuffer,','line_number':136,'multiline':False]
['text':' or counter for how many code points have been read beyond oldBuffer (pos-oldBuffer.length()).','line_number':137,'multiline':False]
['text':' newBuffer.length() at the time of the last matching character.','line_number':139,'multiline':False]
['text':' When a partial match fails, we back out skipped and partial-matching input characters.','line_number':140,'multiline':False]
['text':' We save the trie state before we attempt to match a character,','line_number':142,'multiline':False]
['text':' so that we can skip it and try the next one.','line_number':143,'multiline':False]
['text':' Subclasses: Call this method and then add more specific checks.','line_number':173,'multiline':False]
['text':' Compare the iterator state but not the collation data (trie & data fields):','line_number':174,'multiline':False]
['text':' Assume that the caller compares the data.','line_number':175,'multiline':False]
['text':' Ignore skipped since that should be unused between calls to nextCE().','line_number':176,'multiline':False]
['text':' (It only stays around to avoid another memory allocation.)','line_number':177,'multiline':False]
['text':' No need to loop for each expansion CE.','line_number':200,'multiline':False]
['text':'ce32','line_number':233,'multiline':True]
['text':' Undo ceBuffer.incLength().','line_number':241,'multiline':False]
['text':' Default if no suffix match.','line_number':307,'multiline':False]
['text':' Backward contractions are handled by previousCEUnsafe().','line_number':309,'multiline':False]
['text':' c has contractions but they were not found.','line_number':310,'multiline':False]
['text':' Some portion of nextCE32FromContraction() pulled out here as an ASCII fast path,','line_number':316,'multiline':False]
['text':' avoiding the function call and the nextSkippedCodePoint() overhead.','line_number':317,'multiline':False]
['text':' No more text.','line_number':320,'multiline':False]
['text':' All contraction suffixes start with characters with lccc!=0','line_number':325,'multiline':False]
['text':' but the next code point has lccc==0.','line_number':326,'multiline':False]
['text':' No more text.','line_number':334,'multiline':False]
['text':' All contraction suffixes start with characters with lccc!=0','line_number':339,'multiline':False]
['text':' but the next code point has lccc==0.','line_number':340,'multiline':False]
['text':' CEs from a discontiguous contraction plus the skipped combining marks','line_number':348,'multiline':False]
['text':' have been appended already.','line_number':349,'multiline':False]
['text':' Fetch the non-numeric-collation CE32 and continue.','line_number':359,'multiline':False]
['text':' Handle NUL-termination. (Not needed in Java.)','line_number':366,'multiline':False]
['text':' Fetch the normal ce32 for U+0000 and continue.','line_number':370,'multiline':False]
['text':' None of the Jamo CE32s are isSpecialCE32().','line_number':382,'multiline':False]
['text':' Avoid recursive function calls and per-Jamo tests.','line_number':383,'multiline':False]
['text':' We should not need to compute each Jamo code point.','line_number':394,'multiline':False]
['text':' In particular, there should be no offset or implicit ce32.','line_number':395,'multiline':False]
['text':' offset 39 = 19 + 21 - 1:','line_number':399,'multiline':False]
['text':' 19 = JAMO_L_COUNT','line_number':400,'multiline':False]
['text':' 21 = JAMO_T_COUNT','line_number':401,'multiline':False]
['text':' -1 = omit t==0','line_number':402,'multiline':False]
['text':' Backward iteration should never see lead surrogate code _unit_ data.','line_number':409,'multiline':False]
['text':' unassigned-implicit','line_number':416,'multiline':False]
['text':' fall back to the base data','line_number':419,'multiline':False]
['text':' c is an unpaired surrogate.','line_number':424,'multiline':False]
['text':' Default if no prefix match.','line_number':451,'multiline':False]
['text':' Number of code points read before the original code point.','line_number':453,'multiline':False]
['text':' c: next code point after the original one','line_number':493,'multiline':False]
['text':' Number of code points read beyond the original code point.','line_number':495,'multiline':False]
['text':' Needed for discontiguous contraction matching.','line_number':496,'multiline':False]
['text':' Number of code points read since the last match (initially only c).','line_number':498,'multiline':False]
['text':' Normally we only need a contiguous match,','line_number':500,'multiline':False]
['text':' and therefore need not remember the suffixes state from before a mismatch for retrying.','line_number':501,'multiline':False]
['text':' If we are already processing skipped combining marks, then we do track the state.','line_number':502,'multiline':False]
['text':' No match for c, or partial match (USTRINGTRIE_NO_VALUE) and no further text.','line_number':516,'multiline':False]
['text':' Back up if necessary, and try a discontiguous contraction.','line_number':517,'multiline':False]
['text':' Discontiguous contraction matching extends an existing match.','line_number':519,'multiline':False]
['text':' If there is no match yet, then there is nothing to do.','line_number':520,'multiline':False]
['text':' The last character of at least one suffix has lccc!=0,','line_number':523,'multiline':False]
['text':' allowing for discontiguous contractions.','line_number':524,'multiline':False]
['text':' UCA S2.1.1 only processes non-starters immediately following','line_number':525,'multiline':False]
['text':' "a match in the table" (sinceMatch=1).','line_number':526,'multiline':False]
['text':' Return to the state after the last match.','line_number':528,'multiline':False]
['text':' (Return to sinceMatch=0 and re-fetch the first partially-matched character.)','line_number':529,'multiline':False]
['text':' Continue after partial match (USTRINGTRIE_NO_VALUE) for c.','line_number':542,'multiline':False]
['text':' It does not have a result value, therefore it is not itself "a match in the table".','line_number':543,'multiline':False]
['text':' If a partially-matched c has ccc!=0 then','line_number':544,'multiline':False]
['text':' it might be skipped in discontiguous contraction.','line_number':545,'multiline':False]
['text':' UCA section 3.3.2 Contractions:','line_number':563,'multiline':False]
['text':' Contractions that end with non-starter characters','line_number':564,'multiline':False]
['text':' are known as discontiguous contractions.','line_number':565,'multiline':False]
['text':' ... discontiguous contractions must be detected in input text','line_number':566,'multiline':False]
['text':' whenever the final sequence of non-starter characters could be rearranged','line_number':567,'multiline':False]
['text':' so as to make a contiguous matching sequence that is canonically equivalent.','line_number':568,'multiline':False]
['text':' UCA: http://www.unicode.org/reports/tr10/#S2.1','line_number':570,'multiline':False]
['text':' S2.1 Find the longest initial substring S at each point that has a match in the table.','line_number':571,'multiline':False]
['text':' S2.1.1 If there are any non-starters following S, process each non-starter C.','line_number':572,'multiline':False]
['text':' S2.1.2 If C is not blocked from S, find if S + C has a match in the table.','line_number':573,'multiline':False]
['text':'     Note: A non-starter in a string is called blocked','line_number':574,'multiline':False]
['text':'     if there is another non-starter of the same canonical combining class or zero','line_number':575,'multiline':False]
['text':'     between it and the last character of canonical combining class 0.','line_number':576,'multiline':False]
['text':' S2.1.3 If there is a match, replace S by S + C, and remove C.','line_number':577,'multiline':False]
['text':' First: Is a discontiguous contraction even possible?','line_number':579,'multiline':False]
['text':' The caller checked this already, as a shortcut.','line_number':581,'multiline':False]
['text':' No further text.','line_number':584,'multiline':False]
['text':' The next code point after c is a starter (S2.1.1 "process each non-starter").','line_number':592,'multiline':False]
['text':' We have read and matched (lookAhead-2) code points,','line_number':597,'multiline':False]
['text':' read non-matching c and peeked ahead at nextCp.','line_number':598,'multiline':False]
['text':' Return to the state before the mismatch and continue matching with nextCp.','line_number':599,'multiline':False]
['text':' Replay the partial match so far.','line_number':610,'multiline':False]
['text':' Skip c (which did not match) and nextCp (which we will try now).','line_number':616,'multiline':False]
['text':' Reset to the trie state before the failed match of c.','line_number':621,'multiline':False]
['text':' Number of code points read since the last match (at this point: c and nextCp).','line_number':626,'multiline':False]
['text':' "If C is not blocked from S, find if S + C has a match in the table." (S2.1.2)','line_number':631,'multiline':False]
['text':' "If there is a match, replace S by S + C, and remove C." (S2.1.3)','line_number':633,'multiline':False]
['text':' Keep prevCC unchanged.','line_number':634,'multiline':False]
['text':' No match for "S + C", skip C.','line_number':641,'multiline':False]
['text':' The next code point after c is a starter (S2.1.1 "process each non-starter").','line_number':650,'multiline':False]
['text':' We did get a match after skipping one or more combining marks,','line_number':658,'multiline':False]
['text':' and we are not in a recursive discontiguous contraction.','line_number':659,'multiline':False]
['text':' Append CEs from the contraction ce32','line_number':660,'multiline':False]
['text':' and then from the combining marks that we skipped before the match.','line_number':661,'multiline':False]
['text':' Fetch CE32s for skipped combining marks from the normal data, with fallback,','line_number':665,'multiline':False]
['text':' rather than from the CollationData where we found the contraction.','line_number':666,'multiline':False]
['text':' Note: A nested discontiguous-contraction match','line_number':676,'multiline':False]
['text':' replaces consumed combining marks with newly skipped ones','line_number':677,'multiline':False]
['text':' and resets the reading position to the beginning.','line_number':678,'multiline':False]
['text':' Signal to the caller that the result is in the ceBuffer.','line_number':681,'multiline':False]
['text':' Collect digits.','line_number':688,'multiline':False]
['text':' Reverse the digit string.','line_number':722,'multiline':False]
['text':' Skip leading zeros.','line_number':734,'multiline':False]
['text':' Write a sequence of CEs for at most 254 digits at a time.','line_number':736,'multiline':False]
['text':' Note: We use primary byte values 2..255: digits are not compressible.','line_number':749,'multiline':False]
['text':' Very dense encoding for small numbers.','line_number':751,'multiline':False]
['text':' Primary weight second byte values:','line_number':756,'multiline':False]
['text':'     74 byte values   2.. 75 for small numbers in two-byte primary weights.','line_number':757,'multiline':False]
['text':'     40 byte values  76..115 for medium numbers in three-byte primary weights.','line_number':758,'multiline':False]
['text':'     16 byte values 116..131 for large numbers in four-byte primary weights.','line_number':759,'multiline':False]
['text':'    124 byte values 132..255 for very large numbers with 4..127 digit pairs.','line_number':760,'multiline':False]
['text':' Two-byte primary for 0..73, good for day & month numbers etc.','line_number':764,'multiline':False]
['text':' Three-byte primary for 74..10233=74+40*254-1, good for year numbers and more.','line_number':773,'multiline':False]
['text':' Four-byte primary for 10234..1042489=10234+16*254*254-1.','line_number':783,'multiline':False]
['text':' original value > 1042489','line_number':792,'multiline':False]
['text':' The second primary byte value 132..255 indicates the number of digit pairs (4..127),','line_number':796,'multiline':False]
['text':' then we generate primary bytes with those pairs.','line_number':797,'multiline':False]
['text':' Omit trailing 00 pairs.','line_number':798,'multiline':False]
['text':' Decrement the value for the last pair.','line_number':799,'multiline':False]
['text':' Set the exponent. 4 pairs->132, 5 pairs->133, ..., 127 pairs->255.','line_number':801,'multiline':False]
['text':' Find the length without trailing 00 pairs.','line_number':804,'multiline':False]
['text':' Read the first pair.','line_number':808,'multiline':False]
['text':' Only "half a pair" if we have an odd number of digits.','line_number':812,'multiline':False]
['text':' Add the pairs of digits between pos and length.','line_number':820,'multiline':False]
['text':' Every three pairs/bytes we need to store a 4-byte-primary CE','line_number':824,'multiline':False]
['text':' and start with a new CE with the '0' primary lead byte.','line_number':825,'multiline':False]
['text':' Return the previous buffered CE.','line_number':844,'multiline':False]
['text':' Simple, safe-backwards iteration:','line_number':854,'multiline':False]
['text':' Get a CE going backwards, handle prefixes but no contractions.','line_number':855,'multiline':False]
['text':' For an expansion, the offset of each non-initial CE is the limit offset,','line_number':871,'multiline':False]
['text':' consistent with forward iteration.','line_number':872,'multiline':False]
['text':' We just move through the input counting safe and unsafe code points','line_number':885,'multiline':False]
['text':' without collecting the unsafe-backward substring into a buffer and','line_number':886,'multiline':False]
['text':' switching to it.','line_number':887,'multiline':False]
['text':' This is to keep the logic simple. Otherwise we would have to handle','line_number':888,'multiline':False]
['text':' prefix matching going before the backward buffer, switching','line_number':889,'multiline':False]
['text':' to iteration and back, etc.','line_number':890,'multiline':False]
['text':' In the most important case of iterating over a normal string,','line_number':891,'multiline':False]
['text':' reading from the string itself is already maximally fast.','line_number':892,'multiline':False]
['text':' The only drawback there is that after getting the CEs we always','line_number':893,'multiline':False]
['text':' skip backward to the safe character rather than switching out','line_number':894,'multiline':False]
['text':' of a backwardBuffer.','line_number':895,'multiline':False]
['text':' But this should not be the common case for previousCE(),','line_number':896,'multiline':False]
['text':' and correctness and maintainability are more important than','line_number':897,'multiline':False]
['text':' complex optimizations.','line_number':898,'multiline':False]
['text':' Find the first safe character before c.','line_number':899,'multiline':False]
['text':' Set the forward iteration limit.','line_number':907,'multiline':False]
['text':' Note: This counts code points.','line_number':908,'multiline':False]
['text':' We cannot enforce a limit in the middle of a surrogate pair or similar.','line_number':909,'multiline':False]
['text':' Reset the forward iterator.','line_number':911,'multiline':False]
['text':' Go forward and collect the CEs.','line_number':914,'multiline':False]
['text':' nextCE() normally reads one code point.','line_number':917,'multiline':False]
['text':' Contraction matching and digit specials read more and check numCpFwd.','line_number':918,'multiline':False]
['text':' Append one or more CEs to the ceBuffer.','line_number':920,'multiline':False]
['text':' No need to loop for getting each expansion CE from nextCE().','line_number':923,'multiline':False]
['text':' However, we need to write an offset for each CE.','line_number':925,'multiline':False]
['text':' This is for CollationElementIterator::getOffset() to return','line_number':926,'multiline':False]
['text':' intermediate offsets from the unsafe-backwards segment.','line_number':927,'multiline':False]
['text':' For an expansion, the offset of each non-initial CE is the limit offset,','line_number':930,'multiline':False]
['text':' consistent with forward iteration.','line_number':931,'multiline':False]
['text':' End offset corresponding to just after the unsafe-backwards segment.','line_number':938,'multiline':False]
['text':' Reset the forward iteration limit','line_number':940,'multiline':False]
['text':' and move backward to before the segment for which we fetched CEs.','line_number':941,'multiline':False]
['text':' Use the collected CEs and return the last one.','line_number':944,'multiline':False]
['text':' Avoid cesIndex > ceBuffer.length when that gets decremented.','line_number':945,'multiline':False]
['text':' !UCONFIG_NO_COLLATION','line_number':955,'multiline':False]
