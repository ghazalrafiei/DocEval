['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]
['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]
['text':'*
 *******************************************************************************
 * Copyright (C) 2006-2016, International Business Machines Corporation
 * and others. All Rights Reserved.
 *******************************************************************************
 ','line_number':3,'multiline':True]
['text':'
 ******************************************************************
 ','line_number':31,'multiline':True]
['text':' TODO: remove this param?','line_number':51,'multiline':False]
['text':' Find the span of characters included in the set.','line_number':54,'multiline':False]
['text':'   The span to break begins at the current position in the text, and','line_number':55,'multiline':False]
['text':'   extends towards the start or end of the text, depending on 'reverse'.','line_number':56,'multiline':False]
['text':' TODO:  recast loop for postincrement','line_number':64,'multiline':False]
['text':' Compact for caching','line_number':78,'multiline':False]
['text':'
 ******************************************************************
 * PossibleWord
 ','line_number':82,'multiline':True]
['text':' Helper class for improving readability of the Thai/Lao/Khmer word break','line_number':87,'multiline':False]
['text':' algorithm. The implementation is completely inline.','line_number':88,'multiline':False]
['text':' List size, limited by the maximum number of words in the dictionary','line_number':90,'multiline':False]
['text':' that form a nested sequence.','line_number':91,'multiline':False]
['text':' list of word candidate lengths, in increasing length order','line_number':96,'multiline':False]
['text':' TODO: bytes would be sufficient for word lengths.','line_number':97,'multiline':False]
['text':' Count of candidates','line_number':98,'multiline':False]
['text':' The longest match with a dictionary word','line_number':99,'multiline':False]
['text':' Offset in the text of these candidates','line_number':100,'multiline':False]
['text':' The preferred candidate's offset','line_number':101,'multiline':False]
['text':' The candidate we're currently looking at','line_number':102,'multiline':False]
['text':' Word Lengths, in code units.','line_number':103,'multiline':False]
['text':' Word Lengths, in code points.','line_number':104,'multiline':False]
['text':' Fill the list of candidates if needed, select the longest, and return the number found','line_number':110,'multiline':False]
['text':' Select the currently marked candidate, point after it in the text, and invalidate self','line_number':113,'multiline':False]
['text':' Back up from the current candidate to the next shorter one; return TRUE if that exists','line_number':116,'multiline':False]
['text':' and point the text after it','line_number':117,'multiline':False]
['text':' Return the longest prefix this candidate location shares with a dictionary word','line_number':120,'multiline':False]
['text':' Return value is in code points.','line_number':121,'multiline':False]
['text':' Mark the current candidate as the one we like','line_number':124,'multiline':False]
['text':' Get length in code points of the marked word.','line_number':127,'multiline':False]
['text':' TODO: If getIndex is too slow, use offset < 0 and add discardAll()','line_number':133,'multiline':False]
['text':' Dictionary leaves text after longest prefix, not longest word. Back up.','line_number':138,'multiline':False]
['text':'
 ******************************************************************
 * ThaiBreakEngine
 ','line_number':167,'multiline':True]
['text':' How many words in a row are "good enough"?','line_number':172,'multiline':False]
['text':' Will not combine a non-word with a preceding dictionary word longer than this','line_number':175,'multiline':False]
['text':' Will not combine a non-word that shares at least this much prefix with a','line_number':178,'multiline':False]
['text':' dictionary word, with a preceding word','line_number':179,'multiline':False]
['text':' Ellision character','line_number':182,'multiline':False]
['text':' Repeat character','line_number':185,'multiline':False]
['text':' Minimum word size','line_number':188,'multiline':False]
['text':' Minimum number of characters for two words','line_number':191,'multiline':False]
['text':' MAI HAN-AKAT','line_number':207,'multiline':False]
['text':' SARA E through SARA AI MAIMALAI','line_number':208,'multiline':False]
['text':' KO KAI through HO NOKHUK','line_number':209,'multiline':False]
['text':' SARA E through SARA AI MAIMALAI','line_number':210,'multiline':False]
['text':' Compact for caching.','line_number':214,'multiline':False]
['text':' Not enough characters for two words','line_number':234,'multiline':False]
['text':' Word Length in Code Points.','line_number':240,'multiline':False]
['text':' Word length in code units (UText native indexing)','line_number':241,'multiline':False]
['text':' Look for candidate words at the current position','line_number':252,'multiline':False]
['text':' If we found exactly one, use that','line_number':255,'multiline':False]
['text':' If there was more than one, see which one can take us forward the most words','line_number':261,'multiline':False]
['text':' If we're already at the end of the range, we're done','line_number':263,'multiline':False]
['text':' Followed by another dictionary word; mark first word as a good candidate','line_number':269,'multiline':False]
['text':' If we're already at the end of the range, we're done','line_number':272,'multiline':False]
['text':' See if any of the possible second words is followed by a third word','line_number':277,'multiline':False]
['text':' If we find a third word, stop right away','line_number':279,'multiline':False]
['text':' Set UText position to after the accepted word.','line_number':290,'multiline':False]
['text':' We come here after having either found a word or not. We look ahead to the','line_number':296,'multiline':False]
['text':' next word. If it's not a dictionary word, we will combine it with the word we','line_number':297,'multiline':False]
['text':' just found (if there is one), but only if the preceding word does not exceed','line_number':298,'multiline':False]
['text':' the threshold.','line_number':299,'multiline':False]
['text':' The text iterator should now be positioned at the end of the word we found.','line_number':300,'multiline':False]
['text':' if it is a dictionary word, do nothing. If it isn't, then if there is','line_number':304,'multiline':False]
['text':' no preceding word, or the non-word shares less than the minimum threshold','line_number':305,'multiline':False]
['text':' of characters with a dictionary word, then scan to resynchronize','line_number':306,'multiline':False]
['text':' Look for a plausible word boundary','line_number':310,'multiline':False]
['text':' Maybe. See if it's in the dictionary.','line_number':325,'multiline':False]
['text':' NOTE: In the original Apple code, checked that the next','line_number':326,'multiline':False]
['text':' two characters after uc were not 0x0E4C THANTHAKHAT before','line_number':327,'multiline':False]
['text':' checking the dictionary. That is just a performance filter,','line_number':328,'multiline':False]
['text':' but it's not clear it's faster than checking the trie.','line_number':329,'multiline':False]
['text':' Bump the word count if there wasn't already one','line_number':338,'multiline':False]
['text':' Update the length with the passed-over characters','line_number':343,'multiline':False]
['text':' Back up to where we were for next iteration','line_number':347,'multiline':False]
['text':' Never stop before a combining mark.','line_number':352,'multiline':False]
['text':' Look ahead for possible suffixes if a dictionary word does not follow.','line_number':359,'multiline':False]
['text':' We do this in code rather than using a rule so that the heuristic','line_number':360,'multiline':False]
['text':' resynch continues to function. For example, one of the suffix characters','line_number':361,'multiline':False]
['text':' could be a typo in the middle of a word.','line_number':362,'multiline':False]
['text':' Skip over previous end and PAIYANNOI','line_number':368,'multiline':False]
['text':' Add PAIYANNOI to word','line_number':372,'multiline':False]
['text':' Fetch next character','line_number':373,'multiline':False]
['text':' Restore prior position','line_number':376,'multiline':False]
['text':' Skip over previous end and MAIYAMOK','line_number':382,'multiline':False]
['text':' Add MAIYAMOK to word','line_number':386,'multiline':False]
['text':' Restore prior position','line_number':389,'multiline':False]
['text':' Did we find a word on this iteration? If so, push it on the break stack','line_number':399,'multiline':False]
['text':' Don't return a break for the end of the dictionary range if there is one there.','line_number':405,'multiline':False]
['text':'
 ******************************************************************
 * LaoBreakEngine
 ','line_number':414,'multiline':True]
['text':' How many words in a row are "good enough"?','line_number':419,'multiline':False]
['text':' Will not combine a non-word with a preceding dictionary word longer than this','line_number':422,'multiline':False]
['text':' Will not combine a non-word that shares at least this much prefix with a','line_number':425,'multiline':False]
['text':' dictionary word, with a preceding word','line_number':426,'multiline':False]
['text':' Minimum word size','line_number':429,'multiline':False]
['text':' Minimum number of characters for two words','line_number':432,'multiline':False]
['text':' prefix vowels','line_number':448,'multiline':False]
['text':' basic consonants (including holes for corresponding Thai characters)','line_number':449,'multiline':False]
['text':' digraph consonants (no Thai equivalent)','line_number':450,'multiline':False]
['text':' prefix vowels','line_number':451,'multiline':False]
['text':' Compact for caching.','line_number':453,'multiline':False]
['text':' Not enough characters for two words','line_number':470,'multiline':False]
['text':' Look for candidate words at the current position','line_number':486,'multiline':False]
['text':' If we found exactly one, use that','line_number':489,'multiline':False]
['text':' If there was more than one, see which one can take us forward the most words','line_number':495,'multiline':False]
['text':' If we're already at the end of the range, we're done','line_number':497,'multiline':False]
['text':' Followed by another dictionary word; mark first word as a good candidate','line_number':503,'multiline':False]
['text':' If we're already at the end of the range, we're done','line_number':506,'multiline':False]
['text':' See if any of the possible second words is followed by a third word','line_number':511,'multiline':False]
['text':' If we find a third word, stop right away','line_number':513,'multiline':False]
['text':' We come here after having either found a word or not. We look ahead to the','line_number':529,'multiline':False]
['text':' next word. If it's not a dictionary word, we will combine it withe the word we','line_number':530,'multiline':False]
['text':' just found (if there is one), but only if the preceding word does not exceed','line_number':531,'multiline':False]
['text':' the threshold.','line_number':532,'multiline':False]
['text':' The text iterator should now be positioned at the end of the word we found.','line_number':533,'multiline':False]
['text':' if it is a dictionary word, do nothing. If it isn't, then if there is','line_number':535,'multiline':False]
['text':' no preceding word, or the non-word shares less than the minimum threshold','line_number':536,'multiline':False]
['text':' of characters with a dictionary word, then scan to resynchronize','line_number':537,'multiline':False]
['text':' Look for a plausible word boundary','line_number':541,'multiline':False]
['text':' Maybe. See if it's in the dictionary.','line_number':557,'multiline':False]
['text':' TODO: this looks iffy; compare with old code.','line_number':558,'multiline':False]
['text':' Bump the word count if there wasn't already one','line_number':567,'multiline':False]
['text':' Update the length with the passed-over characters','line_number':572,'multiline':False]
['text':' Back up to where we were for next iteration','line_number':576,'multiline':False]
['text':' Never stop before a combining mark.','line_number':581,'multiline':False]
['text':' Look ahead for possible suffixes if a dictionary word does not follow.','line_number':588,'multiline':False]
['text':' We do this in code rather than using a rule so that the heuristic','line_number':589,'multiline':False]
['text':' resynch continues to function. For example, one of the suffix characters','line_number':590,'multiline':False]
['text':' could be a typo in the middle of a word.','line_number':591,'multiline':False]
['text':' NOT CURRENTLY APPLICABLE TO LAO','line_number':592,'multiline':False]
['text':' Did we find a word on this iteration? If so, push it on the break stack','line_number':594,'multiline':False]
['text':' Don't return a break for the end of the dictionary range if there is one there.','line_number':600,'multiline':False]
['text':'
 ******************************************************************
 * BurmeseBreakEngine
 ','line_number':609,'multiline':True]
['text':' How many words in a row are "good enough"?','line_number':614,'multiline':False]
['text':' Will not combine a non-word with a preceding dictionary word longer than this','line_number':617,'multiline':False]
['text':' Will not combine a non-word that shares at least this much prefix with a','line_number':620,'multiline':False]
['text':' dictionary word, with a preceding word','line_number':621,'multiline':False]
['text':' Minimum word size','line_number':624,'multiline':False]
['text':' Minimum number of characters for two words','line_number':627,'multiline':False]
['text':' basic consonants and independent vowels','line_number':643,'multiline':False]
['text':' Compact for caching.','line_number':645,'multiline':False]
['text':' Not enough characters for two words','line_number':662,'multiline':False]
['text':' Look for candidate words at the current position','line_number':678,'multiline':False]
['text':' If we found exactly one, use that','line_number':681,'multiline':False]
['text':' If there was more than one, see which one can take us forward the most words','line_number':687,'multiline':False]
['text':' If we're already at the end of the range, we're done','line_number':689,'multiline':False]
['text':' Followed by another dictionary word; mark first word as a good candidate','line_number':695,'multiline':False]
['text':' If we're already at the end of the range, we're done','line_number':698,'multiline':False]
['text':' See if any of the possible second words is followed by a third word','line_number':703,'multiline':False]
['text':' If we find a third word, stop right away','line_number':705,'multiline':False]
['text':' We come here after having either found a word or not. We look ahead to the','line_number':721,'multiline':False]
['text':' next word. If it's not a dictionary word, we will combine it withe the word we','line_number':722,'multiline':False]
['text':' just found (if there is one), but only if the preceding word does not exceed','line_number':723,'multiline':False]
['text':' the threshold.','line_number':724,'multiline':False]
['text':' The text iterator should now be positioned at the end of the word we found.','line_number':725,'multiline':False]
['text':' if it is a dictionary word, do nothing. If it isn't, then if there is','line_number':727,'multiline':False]
['text':' no preceding word, or the non-word shares less than the minimum threshold','line_number':728,'multiline':False]
['text':' of characters with a dictionary word, then scan to resynchronize','line_number':729,'multiline':False]
['text':' Look for a plausible word boundary','line_number':733,'multiline':False]
['text':' Maybe. See if it's in the dictionary.','line_number':749,'multiline':False]
['text':' TODO: this looks iffy; compare with old code.','line_number':750,'multiline':False]
['text':' Bump the word count if there wasn't already one','line_number':759,'multiline':False]
['text':' Update the length with the passed-over characters','line_number':764,'multiline':False]
['text':' Back up to where we were for next iteration','line_number':768,'multiline':False]
['text':' Never stop before a combining mark.','line_number':773,'multiline':False]
['text':' Look ahead for possible suffixes if a dictionary word does not follow.','line_number':780,'multiline':False]
['text':' We do this in code rather than using a rule so that the heuristic','line_number':781,'multiline':False]
['text':' resynch continues to function. For example, one of the suffix characters','line_number':782,'multiline':False]
['text':' could be a typo in the middle of a word.','line_number':783,'multiline':False]
['text':' NOT CURRENTLY APPLICABLE TO BURMESE','line_number':784,'multiline':False]
['text':' Did we find a word on this iteration? If so, push it on the break stack','line_number':786,'multiline':False]
['text':' Don't return a break for the end of the dictionary range if there is one there.','line_number':792,'multiline':False]
['text':'
 ******************************************************************
 * KhmerBreakEngine
 ','line_number':801,'multiline':True]
['text':' How many words in a row are "good enough"?','line_number':806,'multiline':False]
['text':' Will not combine a non-word with a preceding dictionary word longer than this','line_number':809,'multiline':False]
['text':' Will not combine a non-word that shares at least this much prefix with a','line_number':812,'multiline':False]
['text':' dictionary word, with a preceding word','line_number':813,'multiline':False]
['text':' Minimum word size','line_number':816,'multiline':False]
['text':' Minimum number of characters for two words','line_number':819,'multiline':False]
['text':'fBeginWordSet.add(0x17A3, 0x17A4);      // deprecated vowels','line_number':836,'multiline':False]
['text':'fEndWordSet.remove(0x17A5, 0x17A9);     // Khmer independent vowels that can't end a word','line_number':837,'multiline':False]
['text':'fEndWordSet.remove(0x17B2);             // Khmer independent vowel that can't end a word','line_number':838,'multiline':False]
['text':' KHMER SIGN COENG that combines some following characters','line_number':839,'multiline':False]
['text':'fEndWordSet.remove(0x17B6, 0x17C5);     // Remove dependent vowels','line_number':840,'multiline':False]
['text':'    fEndWordSet.remove(0x0E31);             // MAI HAN-AKAT','line_number':841,'multiline':False]
['text':'    fEndWordSet.remove(0x0E40, 0x0E44);     // SARA E through SARA AI MAIMALAI','line_number':842,'multiline':False]
['text':'    fBeginWordSet.add(0x0E01, 0x0E2E);      // KO KAI through HO NOKHUK','line_number':843,'multiline':False]
['text':'    fBeginWordSet.add(0x0E40, 0x0E44);      // SARA E through SARA AI MAIMALAI','line_number':844,'multiline':False]
['text':'    fSuffixSet.add(THAI_PAIYANNOI);','line_number':845,'multiline':False]
['text':'    fSuffixSet.add(THAI_MAIYAMOK);','line_number':846,'multiline':False]
['text':' Compact for caching.','line_number':848,'multiline':False]
['text':'    fSuffixSet.compact();','line_number':852,'multiline':False]
['text':' Not enough characters for two words','line_number':866,'multiline':False]
['text':' Look for candidate words at the current position','line_number':882,'multiline':False]
['text':' If we found exactly one, use that','line_number':885,'multiline':False]
['text':' If there was more than one, see which one can take us forward the most words','line_number':892,'multiline':False]
['text':' If we're already at the end of the range, we're done','line_number':894,'multiline':False]
['text':' Followed by another dictionary word; mark first word as a good candidate','line_number':900,'multiline':False]
['text':' If we're already at the end of the range, we're done','line_number':903,'multiline':False]
['text':' See if any of the possible second words is followed by a third word','line_number':908,'multiline':False]
['text':' If we find a third word, stop right away','line_number':910,'multiline':False]
['text':' We come here after having either found a word or not. We look ahead to the','line_number':926,'multiline':False]
['text':' next word. If it's not a dictionary word, we will combine it with the word we','line_number':927,'multiline':False]
['text':' just found (if there is one), but only if the preceding word does not exceed','line_number':928,'multiline':False]
['text':' the threshold.','line_number':929,'multiline':False]
['text':' The text iterator should now be positioned at the end of the word we found.','line_number':930,'multiline':False]
['text':' if it is a dictionary word, do nothing. If it isn't, then if there is','line_number':932,'multiline':False]
['text':' no preceding word, or the non-word shares less than the minimum threshold','line_number':933,'multiline':False]
['text':' of characters with a dictionary word, then scan to resynchronize','line_number':934,'multiline':False]
['text':' Look for a plausible word boundary','line_number':938,'multiline':False]
['text':' Maybe. See if it's in the dictionary.','line_number':954,'multiline':False]
['text':' Bump the word count if there wasn't already one','line_number':963,'multiline':False]
['text':' Update the length with the passed-over characters','line_number':968,'multiline':False]
['text':' Back up to where we were for next iteration','line_number':972,'multiline':False]
['text':' Never stop before a combining mark.','line_number':977,'multiline':False]
['text':' Look ahead for possible suffixes if a dictionary word does not follow.','line_number':984,'multiline':False]
['text':' We do this in code rather than using a rule so that the heuristic','line_number':985,'multiline':False]
['text':' resynch continues to function. For example, one of the suffix characters','line_number':986,'multiline':False]
['text':' could be a typo in the middle of a word.','line_number':987,'multiline':False]
['text':'        if ((int32_t)utext_getNativeIndex(text) < rangeEnd && wordLength > 0) {','line_number':988,'multiline':False]
['text':'            if (words[wordsFound%KHMER_LOOKAHEAD].candidates(text, fDictionary, rangeEnd) <= 0','line_number':989,'multiline':False]
['text':'                && fSuffixSet.contains(uc = utext_current32(text))) {','line_number':990,'multiline':False]
['text':'                if (uc == KHMER_PAIYANNOI) {','line_number':991,'multiline':False]
['text':'                    if (!fSuffixSet.contains(utext_previous32(text))) {','line_number':992,'multiline':False]
['text':'                        // Skip over previous end and PAIYANNOI','line_number':993,'multiline':False]
['text':'                        utext_next32(text);','line_number':994,'multiline':False]
['text':'                        utext_next32(text);','line_number':995,'multiline':False]
['text':'                        wordLength += 1;            // Add PAIYANNOI to word','line_number':996,'multiline':False]
['text':'                        uc = utext_current32(text);     // Fetch next character','line_number':997,'multiline':False]
['text':'                    }','line_number':998,'multiline':False]
['text':'                    else {','line_number':999,'multiline':False]
['text':'                        // Restore prior position','line_number':1000,'multiline':False]
['text':'                        utext_next32(text);','line_number':1001,'multiline':False]
['text':'                    }','line_number':1002,'multiline':False]
['text':'                }','line_number':1003,'multiline':False]
['text':'                if (uc == KHMER_MAIYAMOK) {','line_number':1004,'multiline':False]
['text':'                    if (utext_previous32(text) != KHMER_MAIYAMOK) {','line_number':1005,'multiline':False]
['text':'                        // Skip over previous end and MAIYAMOK','line_number':1006,'multiline':False]
['text':'                        utext_next32(text);','line_number':1007,'multiline':False]
['text':'                        utext_next32(text);','line_number':1008,'multiline':False]
['text':'                        wordLength += 1;            // Add MAIYAMOK to word','line_number':1009,'multiline':False]
['text':'                    }','line_number':1010,'multiline':False]
['text':'                    else {','line_number':1011,'multiline':False]
['text':'                        // Restore prior position','line_number':1012,'multiline':False]
['text':'                        utext_next32(text);','line_number':1013,'multiline':False]
['text':'                    }','line_number':1014,'multiline':False]
['text':'                }','line_number':1015,'multiline':False]
['text':'            }','line_number':1016,'multiline':False]
['text':'            else {','line_number':1017,'multiline':False]
['text':'                utext_setNativeIndex(text, current+wordLength);','line_number':1018,'multiline':False]
['text':'            }','line_number':1019,'multiline':False]
['text':'        }','line_number':1020,'multiline':False]
['text':' Did we find a word on this iteration? If so, push it on the break stack','line_number':1022,'multiline':False]
['text':' Don't return a break for the end of the dictionary range if there is one there.','line_number':1028,'multiline':False]
['text':'
 ******************************************************************
 * CjkBreakEngine
 ','line_number':1038,'multiline':True]
['text':' Korean dictionary only includes Hangul syllables','line_number':1047,'multiline':False]
['text':' handle Korean and Japanese/Chinese using different dictionaries','line_number':1055,'multiline':False]
['text':'Chinese and Japanese','line_number':1058,'multiline':False]
['text':' HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK','line_number':1063,'multiline':False]
['text':' KATAKANA-HIRAGANA PROLONGED SOUND MARK','line_number':1064,'multiline':False]
['text':' The katakanaCost values below are based on the length frequencies of all','line_number':1075,'multiline':False]
['text':' katakana phrases in the dictionary','line_number':1076,'multiline':False]
['text':'TODO: fill array with actual values from dictionary!','line_number':1082,'multiline':False]
['text':' Function for accessing internal utext flags.','line_number':1094,'multiline':False]
['text':'   Replicates an internal UText function.','line_number':1095,'multiline':False]
['text':'
 * @param text A UText representing the text
 * @param rangeStart The start of the range of dictionary characters
 * @param rangeEnd The end of the range of dictionary characters
 * @param foundBreaks vector<int32> to receive the break positions
 * @return The number of breaks found
 ','line_number':1102,'multiline':True]
['text':' UnicodeString version of input UText, NFKC normalized if necessary.','line_number':1118,'multiline':False]
['text':' inputMap[inStringIndex] = corresponding native index from UText inText.','line_number':1121,'multiline':False]
['text':' If NULL then mapping is 1:1','line_number':1122,'multiline':False]
['text':' if UText has the input string as one contiguous UTF-16 chunk','line_number':1128,'multiline':False]
['text':' Input UText is in one contiguous UTF-16 chunk.','line_number':1134,'multiline':False]
['text':' Use Read-only aliasing UnicodeString.','line_number':1135,'multiline':False]
['text':' Copy the text from the original inText (UText) to inString (UnicodeString).','line_number':1140,'multiline':False]
['text':' Create a map from UnicodeString indices -> UText offsets.','line_number':1141,'multiline':False]
['text':'  normalizedMap[normalizedInput position] ==  original UText position.','line_number':1167,'multiline':False]
['text':' Once per normalization chunk','line_number':1175,'multiline':False]
['text':' Map every position in the normalized chunk to the start of the chunk','line_number':1193,'multiline':False]
['text':'   in the original input.','line_number':1194,'multiline':False]
['text':' There are supplementary characters in the input.','line_number':1215,'multiline':False]
['text':' The dictionary will produce boundary positions in terms of code point indexes,','line_number':1216,'multiline':False]
['text':'   not in terms of code unit string indexes.','line_number':1217,'multiline':False]
['text':' Use the inputMap mechanism to take care of this in addition to indexing differences','line_number':1218,'multiline':False]
['text':'    from normalization and/or UTF-8 input.','line_number':1219,'multiline':False]
['text':' bestSnlp[i] is the snlp of the best segmentation of the first i','line_number':1242,'multiline':False]
['text':' code points in the range to be matched.','line_number':1243,'multiline':False]
['text':' prev[i] is the index of the last CJK code point in the previous word in ','line_number':1251,'multiline':False]
['text':' the best segmentation of the first i characters.','line_number':1252,'multiline':False]
['text':' Dynamic programming to find the best segmentation.','line_number':1267,'multiline':False]
['text':' In outer loop, i  is the code point index,','line_number':1269,'multiline':False]
['text':'                ix is the corresponding string (code unit) index.','line_number':1270,'multiline':False]
['text':'    They differ when the string contains supplementary characters.','line_number':1271,'multiline':False]
['text':' Note: lengths is filled with code point lengths','line_number':1283,'multiline':False]
['text':'       The NULL parameter is the ignored code unit lengths.','line_number':1284,'multiline':False]
['text':' if there are no single character matches found in the dictionary ','line_number':1286,'multiline':False]
['text':' starting with this character, treat character as a 1-character word ','line_number':1287,'multiline':False]
['text':' with the highest value possible, i.e. the least likely to occur.','line_number':1288,'multiline':False]
['text':' Exclude Korean characters from this treatment, as they should be left','line_number':1289,'multiline':False]
['text':' together by default.','line_number':1290,'multiline':False]
['text':' 255','line_number':1293,'multiline':False]
['text':' In Japanese,','line_number':1306,'multiline':False]
['text':' Katakana word in single character is pretty rare. So we apply','line_number':1307,'multiline':False]
['text':' the following heuristic to Katakana: any continuous run of Katakana','line_number':1308,'multiline':False]
['text':' characters is considered a candidate word with a default cost','line_number':1309,'multiline':False]
['text':' specified in the katakanaCost table according to its length.','line_number':1310,'multiline':False]
['text':' Find the end of the continuous run of Katakana characters','line_number':1316,'multiline':False]
['text':' prev[j] = i;','line_number':1326,'multiline':False]
['text':' Start pushing the optimal offset index into t_boundary (t for tentative).','line_number':1334,'multiline':False]
['text':' prev[numCodePts] is guaranteed to be meaningful.','line_number':1335,'multiline':False]
['text':' We'll first push in the reverse order, i.e.,','line_number':1336,'multiline':False]
['text':' t_boundary[0] = numCodePts, and afterwards do a swap.','line_number':1337,'multiline':False]
['text':' No segmentation found, set boundary to end of range','line_number':1341,'multiline':False]
['text':' Add a break for the start of the dictionary range if there is not one','line_number':1353,'multiline':False]
['text':' there already.','line_number':1354,'multiline':False]
['text':' Now that we're done, convert positions in t_boundary[] (indices in ','line_number':1360,'multiline':False]
['text':' the normalized input string) back to indices in the original input UText','line_number':1361,'multiline':False]
['text':' while reversing t_boundary and pushing values to foundBreaks.','line_number':1362,'multiline':False]
['text':' Boundaries are added to foundBreaks output in ascending order.','line_number':1371,'multiline':False]
['text':' Normalization expanded the input text, the dictionary found a boundary','line_number':1375,'multiline':False]
['text':' within the expansion, giving two boundaries with the same index in the','line_number':1376,'multiline':False]
['text':' original text. Ignore the second. See ticket #12918.','line_number':1377,'multiline':False]
['text':' suppress compiler warnings about unused variable','line_number':1383,'multiline':False]
['text':' inString goes out of scope','line_number':1385,'multiline':False]
['text':' inputMap goes out of scope','line_number':1386,'multiline':False]
['text':' #if !UCONFIG_NO_BREAK_ITERATION ','line_number':1393,'multiline':True]
