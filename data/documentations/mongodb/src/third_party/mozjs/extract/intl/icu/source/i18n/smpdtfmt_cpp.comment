['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]
['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]
['text':'
*******************************************************************************
* Copyright (C) 1997-2016, International Business Machines Corporation and    *
* others. All Rights Reserved.                                                *
*******************************************************************************
*
* File SMPDTFMT.CPP
*
* Modification History:
*
*   Date        Name        Description
*   02/19/97    aliu        Converted from java.
*   03/31/97    aliu        Modified extensively to work with 50 locales.
*   04/01/97    aliu        Added support for centuries.
*   07/09/97    helena      Made ParsePosition into a class.
*   07/21/98    stephen     Added initializeDefaultCentury.
*                             Removed getZoneIndex (added in DateFormatSymbols)
*                             Removed subParseLong
*                             Removed chk
*   02/22/99    stephen     Removed character literals for EBCDIC safety
*   10/14/99    aliu        Updated 2-digit year parsing so that only "00" thru
*                           "99" are recognized. {j28 4182066}
*   11/15/99    weiv        Added support for week of year/day of week format
********************************************************************************
','line_number':3,'multiline':True]
['text':' ZONE_NAME_U16_MAX','line_number':76,'multiline':False]
['text':' *****************************************************************************','line_number':83,'multiline':False]
['text':' class SimpleDateFormat','line_number':84,'multiline':False]
['text':' *****************************************************************************','line_number':85,'multiline':False]
['text':'*
 * Last-resort string to use for "GMT" when constructing time zone strings.
 ','line_number':89,'multiline':True]
['text':' For time zones that have no names, use strings GMT+minutes and','line_number':92,'multiline':False]
['text':' GMT-minutes. For instance, in France the time zone is GMT+60.','line_number':93,'multiline':False]
['text':' Also accepted are GMT+H:MM or GMT-H:MM.','line_number':94,'multiline':False]
['text':' Currently not being used','line_number':95,'multiline':False]
['text':'static const UChar gGmt[]      = {0x0047, 0x004D, 0x0054, 0x0000};         // "GMT"','line_number':96,'multiline':False]
['text':'static const UChar gGmtPlus[]  = {0x0047, 0x004D, 0x0054, 0x002B, 0x0000}; // "GMT+"','line_number':97,'multiline':False]
['text':'static const UChar gGmtMinus[] = {0x0047, 0x004D, 0x0054, 0x002D, 0x0000}; // "GMT-"','line_number':98,'multiline':False]
['text':'static const UChar gDefGmtPat[]       = {0x0047, 0x004D, 0x0054, 0x007B, 0x0030, 0x007D, 0x0000}; /* GMT{0} */','line_number':99,'multiline':False]
['text':'static const UChar gDefGmtNegHmsPat[] = {0x002D, 0x0048, 0x0048, 0x003A, 0x006D, 0x006D, 0x003A, 0x0073, 0x0073, 0x0000}; /* -HH:mm:ss */','line_number':100,'multiline':False]
['text':'static const UChar gDefGmtNegHmPat[]  = {0x002D, 0x0048, 0x0048, 0x003A, 0x006D, 0x006D, 0x0000}; /* -HH:mm */','line_number':101,'multiline':False]
['text':'static const UChar gDefGmtPosHmsPat[] = {0x002B, 0x0048, 0x0048, 0x003A, 0x006D, 0x006D, 0x003A, 0x0073, 0x0073, 0x0000}; /* +HH:mm:ss */','line_number':102,'multiline':False]
['text':'static const UChar gDefGmtPosHmPat[]  = {0x002B, 0x0048, 0x0048, 0x003A, 0x006D, 0x006D, 0x0000}; /* +HH:mm */','line_number':103,'multiline':False]
['text':'static const UChar gUt[]       = {0x0055, 0x0054, 0x0000};  // "UT"','line_number':104,'multiline':False]
['text':'static const UChar gUtc[]      = {0x0055, 0x0054, 0x0043, 0x0000};  // "UT"','line_number':105,'multiline':False]
['text':' Stuff needed for numbering system overrides','line_number':118,'multiline':False]
['text':' This is a pattern-of-last-resort used when we can't load a usable pattern out','line_number':159,'multiline':False]
['text':' of a resource.','line_number':160,'multiline':False]
['text':' "yyyyMMdd hh:mm a" ','line_number':164,'multiline':True]
['text':' This prefix is designed to NEVER MATCH real text, in order to','line_number':166,'multiline':False]
['text':' suppress the parsing of negative numbers.  Adjust as needed (if','line_number':167,'multiline':False]
['text':' this becomes valid Unicode).','line_number':168,'multiline':False]
['text':'*
 * These are the tags we expect to see in normal resource bundle files associated
 * with a locale.
 ','line_number':171,'multiline':True]
['text':' Single quote','line_number':175,'multiline':False]
['text':'
 * The field range check bias for each UDateFormatField.
 * The bias is added to the minimum and maximum values
 * before they are compared to the parsed number.
 * For example, the calendar stores zero-based month numbers
 * but the parsed month numbers start at 1, so the bias is 1.
 *
 * A value of -1 means that the value is not checked.
 ','line_number':177,'multiline':True]
['text':' 'G' - UDAT_ERA_FIELD','line_number':187,'multiline':False]
['text':' 'y' - UDAT_YEAR_FIELD','line_number':188,'multiline':False]
['text':' 'M' - UDAT_MONTH_FIELD','line_number':189,'multiline':False]
['text':' 'd' - UDAT_DATE_FIELD','line_number':190,'multiline':False]
['text':' 'k' - UDAT_HOUR_OF_DAY1_FIELD','line_number':191,'multiline':False]
['text':' 'H' - UDAT_HOUR_OF_DAY0_FIELD','line_number':192,'multiline':False]
['text':' 'm' - UDAT_MINUTE_FIELD','line_number':193,'multiline':False]
['text':' 's' - UDAT_SECOND_FIELD','line_number':194,'multiline':False]
['text':' 'S' - UDAT_FRACTIONAL_SECOND_FIELD (0-999?)','line_number':195,'multiline':False]
['text':' 'E' - UDAT_DAY_OF_WEEK_FIELD (1-7?)','line_number':196,'multiline':False]
['text':' 'D' - UDAT_DAY_OF_YEAR_FIELD (1 - 366?)','line_number':197,'multiline':False]
['text':' 'F' - UDAT_DAY_OF_WEEK_IN_MONTH_FIELD (1-5?)','line_number':198,'multiline':False]
['text':' 'w' - UDAT_WEEK_OF_YEAR_FIELD (1-52?)','line_number':199,'multiline':False]
['text':' 'W' - UDAT_WEEK_OF_MONTH_FIELD (1-5?)','line_number':200,'multiline':False]
['text':' 'a' - UDAT_AM_PM_FIELD','line_number':201,'multiline':False]
['text':' 'h' - UDAT_HOUR1_FIELD','line_number':202,'multiline':False]
['text':' 'K' - UDAT_HOUR0_FIELD','line_number':203,'multiline':False]
['text':' 'z' - UDAT_TIMEZONE_FIELD','line_number':204,'multiline':False]
['text':' 'Y' - UDAT_YEAR_WOY_FIELD','line_number':205,'multiline':False]
['text':' 'e' - UDAT_DOW_LOCAL_FIELD','line_number':206,'multiline':False]
['text':' 'u' - UDAT_EXTENDED_YEAR_FIELD','line_number':207,'multiline':False]
['text':' 'g' - UDAT_JULIAN_DAY_FIELD','line_number':208,'multiline':False]
['text':' 'A' - UDAT_MILLISECONDS_IN_DAY_FIELD','line_number':209,'multiline':False]
['text':' 'Z' - UDAT_TIMEZONE_RFC_FIELD','line_number':210,'multiline':False]
['text':' 'v' - UDAT_TIMEZONE_GENERIC_FIELD','line_number':211,'multiline':False]
['text':' 'c' - UDAT_STANDALONE_DAY_FIELD','line_number':212,'multiline':False]
['text':' 'L' - UDAT_STANDALONE_MONTH_FIELD','line_number':213,'multiline':False]
['text':' 'Q' - UDAT_QUARTER_FIELD (1-4?)','line_number':214,'multiline':False]
['text':' 'q' - UDAT_STANDALONE_QUARTER_FIELD','line_number':215,'multiline':False]
['text':' 'V' - UDAT_TIMEZONE_SPECIAL_FIELD','line_number':216,'multiline':False]
['text':' 'U' - UDAT_YEAR_NAME_FIELD','line_number':217,'multiline':False]
['text':' 'O' - UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD','line_number':218,'multiline':False]
['text':' 'X' - UDAT_TIMEZONE_ISO_FIELD','line_number':219,'multiline':False]
['text':' 'x' - UDAT_TIMEZONE_ISO_LOCAL_FIELD','line_number':220,'multiline':False]
['text':' 'r' - UDAT_RELATED_YEAR_FIELD','line_number':221,'multiline':False]
['text':' ':' - UDAT_TIME_SEPARATOR_FIELD','line_number':223,'multiline':False]
['text':' (no pattern character currently) - UDAT_TIME_SEPARATOR_FIELD','line_number':225,'multiline':False]
['text':' When calendar uses hebr numbering (i.e. he@calendar=hebrew),','line_number':229,'multiline':False]
['text':' offset the years within the current millenium down to 1-999','line_number':230,'multiline':False]
['text':'*
 * Maximum range for detecting daylight offset of a time zone when parsed time zone
 * string indicates it's daylight saving time, but the detected time zone does not
 * observe daylight saving time at the parsed date.
 ','line_number':234,'multiline':True]
['text':' no matter what the locale's default number format looked like, we want','line_number':261,'multiline':False]
['text':' to modify it so that it doesn't use thousands separators, doesn't always','line_number':262,'multiline':False]
['text':' show the decimal point, and recognizes integers only when parsing','line_number':263,'multiline':False]
['text':' To prevent "Jan 1.00, 1997.00"','line_number':271,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':325,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':343,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':357,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':377,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':401,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':423,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':449,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':471,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':493,'multiline':False]
['text':' Not for public consumption; used by DateFormat','line_number':495,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':513,'multiline':False]
['text':'*
 * Not for public consumption; used by DateFormat.  This constructor
 * never fails.  If the resource data is not available, it uses the
 * the last resort symbols.
 ','line_number':515,'multiline':True]
['text':' This constructor doesn't fail; it uses last resort data','line_number':537,'multiline':False]
['text':' test for NULL ','line_number':539,'multiline':True]
['text':'----------------------------------------------------------------------','line_number':555,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':569,'multiline':False]
['text':' TimeZoneFormat can now be set independently via setter.','line_number':596,'multiline':False]
['text':' If it is NULL, it will be lazily initialized from locale','line_number':597,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':632,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':640,'multiline':False]
['text':' The DateFormat::operator== check for fCapitalizationContext equality above','line_number':646,'multiline':False]
['text':'   is sufficient to check equality of all derived context-related data.','line_number':647,'multiline':False]
['text':' DateFormat::operator== guarantees following cast is safe','line_number':648,'multiline':False]
['text':' Check for pathological object','line_number':651,'multiline':False]
['text':' Check for pathological object','line_number':652,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':660,'multiline':False]
['text':' kFull','line_number':662,'multiline':False]
['text':' kLong','line_number':663,'multiline':False]
['text':' kMedium','line_number':664,'multiline':False]
['text':' kShort','line_number':665,'multiline':False]
['text':' called by several constructors to load pattern data from the resources','line_number':673,'multiline':False]
['text':' We will need the calendar to know what type of symbols to load.','line_number':676,'multiline':False]
['text':' Load date time patterns directly from resources.','line_number':680,'multiline':False]
['text':' Check for "gregorian" fallback.','line_number':696,'multiline':False]
['text':' create a symbols object from the locale','line_number':717,'multiline':False]
['text':' test for NULL ','line_number':720,'multiline':True]
['text':' empty string if no region','line_number':740,'multiline':False]
['text':' use DTPG if','line_number':743,'multiline':False]
['text':' * baseLoc has a region and validLoc does not have the same one (or has none), OR','line_number':744,'multiline':False]
['text':' * validLoc has a different language code than baseLoc','line_number':745,'multiline':False]
['text':' The standard time formats may have the wrong time cycle, because:','line_number':749,'multiline':False]
['text':' the valid locale differs in important ways (region, language) from','line_number':750,'multiline':False]
['text':' the base locale.','line_number':751,'multiline':False]
['text':' We could *also* check whether they do actually have a mismatch with','line_number':752,'multiline':False]
['text':' the time cycle preferences for the region, but that is a lot more','line_number':753,'multiline':False]
['text':' work for little or no additional benefit, since just going ahead','line_number':754,'multiline':False]
['text':' and always synthesizing the time format as per the following should','line_number':755,'multiline':False]
['text':' create a locale-appropriate pattern with cycle that matches the','line_number':756,'multiline':False]
['text':' region preferences anyway.','line_number':757,'multiline':False]
['text':' if the pattern should include both date and time information, use the date/time','line_number':768,'multiline':False]
['text':' pattern string as a guide to tell use how to glue together the appropriate date','line_number':769,'multiline':False]
['text':' and time pattern strings.','line_number':770,'multiline':False]
['text':' Get proper date time format','line_number':829,'multiline':False]
['text':' if the pattern includes just time data or just date date, load the appropriate','line_number':837,'multiline':False]
['text':' pattern string from the resources','line_number':838,'multiline':False]
['text':' setTo() - see DateFormatSymbols::assignArray comments','line_number':839,'multiline':False]
['text':' and if it includes _neither_, that's an error','line_number':894,'multiline':False]
['text':' finally, finish initializing by creating a Calendar and a NumberFormat','line_number':898,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':902,'multiline':False]
['text':' Need this before initNumberFormatters(), to set fHasHanYearChar','line_number':920,'multiline':False]
['text':' Simple-minded hack to force Gannen year numbering for ja@calendar=japanese','line_number':922,'multiline':False]
['text':' if format is non-numeric (includes å¹´) and fDateOverride is not already specified.','line_number':923,'multiline':False]
['text':' Now this does get updated if applyPattern subsequently changes the pattern type.','line_number':924,'multiline':False]
['text':' We don't need to check that the row count is >= 1, since all 2d arrays have at','line_number':931,'multiline':False]
['text':' least one row','line_number':932,'multiline':False]
['text':'fNumberFormat->setLenient(TRUE); // Java uses a custom DateNumberFormat to format/parse','line_number':937,'multiline':False]
['text':' Initialize the fields we use to disambiguate ambiguous years. Separate
 * so we can call it from readObject().
 ','line_number':949,'multiline':True]
['text':'
 * Initialize the boolean attributes. Separate so we can call it from all constructors.
 ','line_number':966,'multiline':True]
['text':' Define one-century window into which to disambiguate dates using
 * two-digit years. Make public in JDK 1.2.
 ','line_number':979,'multiline':True]
['text':'----------------------------------------------------------------------','line_number':1000,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':1010,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':1020,'multiline':False]
['text':' Different calendar type','line_number':1032,'multiline':False]
['text':' We use the time and time zone from the input calendar, but','line_number':1033,'multiline':False]
['text':' do not use the input calendar for field calculation.','line_number':1034,'multiline':False]
['text':' loop through the pattern string character by character','line_number':1053,'multiline':False]
['text':' Use subFormat() to format a repeated pattern character','line_number':1057,'multiline':False]
['text':' when a different pattern or non-pattern character is seen','line_number':1058,'multiline':False]
['text':' Consecutive single quotes are a single quote literal,','line_number':1065,'multiline':False]
['text':' either outside of quotes or between quotes','line_number':1066,'multiline':False]
['text':' ch is a date-time pattern character to be interpreted','line_number':1075,'multiline':False]
['text':' by subFormat(); count the number of times it is repeated','line_number':1076,'multiline':False]
['text':' Append quoted characters and unquoted non-pattern characters','line_number':1081,'multiline':False]
['text':' Format the last item in the pattern, if any','line_number':1086,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':1099,'multiline':False]
['text':' Map calendar field into calendar field level.
 * the larger the level, the smaller the field unit.
 * For example, UCAL_ERA level is 0, UCAL_YEAR level is 10,
 * UCAL_MONTH level is 20.
 * NOTE: if new fields adds in, the table needs to update.
 ','line_number':1101,'multiline':True]
['text':'GyM','line_number':1110,'multiline':True]
['text':'wW','line_number':1111,'multiline':True]
['text':'dDEF','line_number':1112,'multiline':True]
['text':'ahHm','line_number':1113,'multiline':True]
['text':'sS','line_number':1114,'multiline':True]
['text':'z?Y','line_number':1115,'multiline':True]
['text':'eug','line_number':1116,'multiline':True]
['text':'A?.','line_number':1117,'multiline':True]
['text':' Map date field LETTER into calendar field level.','line_number':1121,'multiline':False]
['text':' the larger the level, the smaller the field unit.','line_number':1122,'multiline':False]
['text':' NOTE: if new fields adds in, the table needs to update.','line_number':1123,'multiline':False]
['text':'','line_number':1126,'multiline':False]
['text':'       !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /','line_number':1128,'multiline':False]
['text':'   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?','line_number':1131,'multiline':False]
['text':'   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?','line_number':1134,'multiline':False]
['text':'   @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O','line_number':1137,'multiline':False]
['text':'   P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _','line_number':1139,'multiline':False]
['text':'   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o','line_number':1141,'multiline':False]
['text':'   p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~','line_number':1143,'multiline':False]
['text':'','line_number':1152,'multiline':False]
['text':'','line_number':1154,'multiline':False]
['text':'','line_number':1156,'multiline':False]
['text':'','line_number':1158,'multiline':False]
['text':'         !      "      #      $      %      &      '','line_number':1160,'multiline':False]
['text':'  (      )      *      +      ,      -      .      /','line_number':1162,'multiline':False]
['text':'  0      1      2      3      4      5      6      7','line_number':1164,'multiline':False]
['text':'  8      9      :      ;      <      =      >      ?','line_number':1167,'multiline':False]
['text':'  8      9      :      ;      <      =      >      ?','line_number':1170,'multiline':False]
['text':'  @      A      B      C      D      E      F      G','line_number':1173,'multiline':False]
['text':'  H      I      J      K      L      M      N      O','line_number':1175,'multiline':False]
['text':'  P      Q      R      S      T      U      V      W','line_number':1177,'multiline':False]
['text':'  X      Y      Z      [      \      ]      ^      _','line_number':1179,'multiline':False]
['text':'  `      a      b      c      d      e      f      g','line_number':1181,'multiline':False]
['text':'  h      i      j      k      l      m      n      o','line_number':1183,'multiline':False]
['text':'  p      q      r      s      t      u      v      w','line_number':1185,'multiline':False]
['text':'  x      y      z      {      |      }      ~','line_number':1187,'multiline':False]
['text':' Map index into pattern character string to Calendar field number.','line_number':1194,'multiline':False]
['text':'GyM','line_number':1198,'multiline':True]
['text':'dkH','line_number':1199,'multiline':True]
['text':'msS','line_number':1200,'multiline':True]
['text':'EDF','line_number':1201,'multiline':True]
['text':'wWa','line_number':1202,'multiline':True]
['text':'hKz','line_number':1203,'multiline':True]
['text':'Yeu','line_number':1204,'multiline':True]
['text':'gAZ','line_number':1205,'multiline':True]
['text':'v','line_number':1206,'multiline':True]
['text':'c','line_number':1207,'multiline':True]
['text':'L','line_number':1208,'multiline':True]
['text':'Q','line_number':1209,'multiline':True]
['text':'q','line_number':1210,'multiline':True]
['text':'V','line_number':1211,'multiline':True]
['text':'U','line_number':1212,'multiline':True]
['text':'O','line_number':1213,'multiline':True]
['text':'Xx','line_number':1214,'multiline':True]
['text':'r','line_number':1215,'multiline':True]
['text':'bB','line_number':1216,'multiline':True]
['text':' no mappings to calendar fields','line_number':1216,'multiline':False]
['text':':','line_number':1218,'multiline':True]
['text':' => no useful mapping to any calendar field ','line_number':1218,'multiline':True]
['text':'no pattern char for UDAT_TIME_SEPARATOR_FIELD','line_number':1220,'multiline':True]
['text':' => no useful mapping to any calendar field ','line_number':1220,'multiline':True]
['text':' Map index into pattern character string to DateFormat field number','line_number':1224,'multiline':False]
['text':'GyM','line_number':1227,'multiline':True]
['text':'dkH','line_number':1228,'multiline':True]
['text':'msS','line_number':1229,'multiline':True]
['text':'EDF','line_number':1230,'multiline':True]
['text':'wWa','line_number':1231,'multiline':True]
['text':'hKz','line_number':1232,'multiline':True]
['text':'Yeu','line_number':1233,'multiline':True]
['text':'gAZ','line_number':1234,'multiline':True]
['text':'v','line_number':1235,'multiline':True]
['text':'c','line_number':1236,'multiline':True]
['text':'L','line_number':1237,'multiline':True]
['text':'Q','line_number':1238,'multiline':True]
['text':'q','line_number':1239,'multiline':True]
['text':'V','line_number':1240,'multiline':True]
['text':'U','line_number':1241,'multiline':True]
['text':'O','line_number':1242,'multiline':True]
['text':'Xx','line_number':1243,'multiline':True]
['text':'r','line_number':1244,'multiline':True]
['text':'bB','line_number':1245,'multiline':True]
['text':':','line_number':1247,'multiline':True]
['text':'no pattern char for UDAT_TIME_SEPARATOR_FIELD','line_number':1249,'multiline':True]
['text':'----------------------------------------------------------------------','line_number':1253,'multiline':False]
['text':'*
 * Append symbols[value] to dst.  Make sure the array index is not out
 * of bounds.
 ','line_number':1255,'multiline':True]
['text':'----------------------------------------------------------------------','line_number':1283,'multiline':False]
['text':' Simple override string such as "hebrew"','line_number':1373,'multiline':False]
['text':' Field specific override string such as "y=hebrew"','line_number':1376,'multiline':False]
['text':' We just need the first character.','line_number':1378,'multiline':False]
['text':' See if the numbering system is in the override list, if not, then add it.','line_number':1382,'multiline':False]
['text':' Now that we have an appropriate number formatter, fill in the appropriate spaces in the','line_number':1423,'multiline':False]
['text':' number formatters table.','line_number':1424,'multiline':False]
['text':' if the pattern character is unrecognized, signal an error and bail out','line_number':1445,'multiline':False]
['text':'---------------------------------------------------------------------','line_number':1465,'multiline':False]
['text':' this function gets called by format() to produce the appropriate substitution','line_number':1481,'multiline':False]
['text':' text for an individual pattern symbol (e.g., "HH" or "yyyy")','line_number':1482,'multiline':False]
['text':' if the pattern character is unrecognized, signal an error and dump out','line_number':1493,'multiline':False]
['text':' pattern char 'l' (SMALL LETTER L) just gets ignored','line_number':1496,'multiline':False]
['text':' Don't get value unless it is useful','line_number':1504,'multiline':False]
['text':' for any "G" symbol, write out the appropriate era string','line_number':1521,'multiline':False]
['text':' "GGGG" is wide era name, "GGGGG" is narrow era name, anything else is abbreviated name','line_number':1522,'multiline':False]
['text':' as in ICU4J','line_number':1525,'multiline':False]
['text':' the Calendar YEAR field runs 1 through 60 for cyclic years','line_number':1542,'multiline':False]
['text':' else fall through to numeric year handling, do not break here','line_number':1546,'multiline':False]
['text':' OLD: for "yyyy", write out the whole year; for "yy", write out the last 2 digits','line_number':1549,'multiline':False]
['text':' NEW: UTS#35:','line_number':1550,'multiline':False]
['text':'Year         y     yy     yyy     yyyy     yyyyy','line_number':1551,'multiline':False]
['text':'AD 1         1     01     001     0001     00001','line_number':1552,'multiline':False]
['text':'AD 12       12     12     012     0012     00012','line_number':1553,'multiline':False]
['text':'AD 123     123     23     123     0123     00123','line_number':1554,'multiline':False]
['text':'AD 1234   1234     34    1234     1234     01234','line_number':1555,'multiline':False]
['text':'AD 12345 12345     45   12345    12345     12345','line_number':1556,'multiline':False]
['text':' for "MMMM"/"LLLL", write out the whole month name, for "MMM"/"LLL", write out the month','line_number':1568,'multiline':False]
['text':' abbreviation, for "M"/"L" or "MM"/"LL", write out the month as a number with the','line_number':1569,'multiline':False]
['text':' appropriate number of digits','line_number':1570,'multiline':False]
['text':' for "MMMMM"/"LLLLL", use the narrow form','line_number':1571,'multiline':False]
['text':' Show alternate form for Adar II in leap years in Hebrew calendar.','line_number':1577,'multiline':False]
['text':' Adjust the month number down 1 in Hebrew non-leap years, i.e. Adar is 6, not 7.','line_number':1579,'multiline':False]
['text':' should consolidate the next section by using arrays of pointers & counts for the right symbols...','line_number':1584,'multiline':False]
['text':' for "k" and "kk", write out the hour, adjusting midnight to appear as "24"','line_number':1623,'multiline':False]
['text':' Fractional seconds left-justify','line_number':1632,'multiline':False]
['text':' for "ee" or "e", use local numeric day-of-the-week','line_number':1647,'multiline':False]
['text':' for "EEEEEE" or "eeeeee", write out the short day-of-the-week name','line_number':1648,'multiline':False]
['text':' for "EEEEE" or "eeeee", write out the narrow day-of-the-week name','line_number':1649,'multiline':False]
['text':' for "EEEE" or "eeee", write out the wide day-of-the-week name','line_number':1650,'multiline':False]
['text':' for "EEE" or "EE" or "E" or "eee", write out the abbreviated day-of-the-week name','line_number':1651,'multiline':False]
['text':' fall through to EEEEE-EEE handling, but for that we don't want local day-of-week,','line_number':1657,'multiline':False]
['text':' we want standard day-of-week, so first fix value to work for EEEEE-EEE.','line_number':1658,'multiline':False]
['text':' fall through, do not break here','line_number':1663,'multiline':False]
['text':' for "ccc", write out the abbreviated day-of-the-week name','line_number':1685,'multiline':False]
['text':' for "cccc", write out the wide day-of-the-week name','line_number':1686,'multiline':False]
['text':' for "ccccc", use the narrow day-of-the-week name','line_number':1687,'multiline':False]
['text':' for "ccccc", use the short day-of-the-week name','line_number':1688,'multiline':False]
['text':' fall through to alpha DOW handling, but for that we don't want local day-of-week,','line_number':1694,'multiline':False]
['text':' we want standard day-of-week, so first fix value.','line_number':1695,'multiline':False]
['text':' count == 3','line_number':1712,'multiline':False]
['text':' for "a" symbol, write out the whole AM/PM string','line_number':1719,'multiline':False]
['text':' if we see pattern character for UDAT_TIME_SEPARATOR_FIELD (none currently defined),','line_number':1730,'multiline':False]
['text':' write out the time separator string. Leave support in for future definition.','line_number':1731,'multiline':False]
['text':' for "h" and "hh", write out the hour, adjusting noon and midnight to show up','line_number':1739,'multiline':False]
['text':' as "12"','line_number':1740,'multiline':False]
['text':' 'z'','line_number':1748,'multiline':False]
['text':' 'Z'','line_number':1749,'multiline':False]
['text':' 'v'','line_number':1750,'multiline':False]
['text':' 'V'','line_number':1751,'multiline':False]
['text':' 'O'','line_number':1752,'multiline':False]
['text':' 'X'','line_number':1753,'multiline':False]
['text':' 'x'','line_number':1754,'multiline':False]
['text':' "z", "zz", "zzz"','line_number':1764,'multiline':False]
['text':' "zzzz" or longer','line_number':1768,'multiline':False]
['text':' "Z"','line_number':1775,'multiline':False]
['text':' "ZZZZZ"','line_number':1778,'multiline':False]
['text':' "ZZ", "ZZZ", "ZZZZ"','line_number':1781,'multiline':False]
['text':' "v"','line_number':1787,'multiline':False]
['text':' "vvvv"','line_number':1791,'multiline':False]
['text':' "V"','line_number':1798,'multiline':False]
['text':' "VV"','line_number':1801,'multiline':False]
['text':' "VVV"','line_number':1804,'multiline':False]
['text':' "VVVV"','line_number':1807,'multiline':False]
['text':' "O"','line_number':1814,'multiline':False]
['text':' "OOOO"','line_number':1817,'multiline':False]
['text':' "X"','line_number':1823,'multiline':False]
['text':' "XX"','line_number':1826,'multiline':False]
['text':' "XXX"','line_number':1829,'multiline':False]
['text':' "XXXX"','line_number':1832,'multiline':False]
['text':' "XXXXX"','line_number':1835,'multiline':False]
['text':' "x"','line_number':1841,'multiline':False]
['text':' "xx"','line_number':1844,'multiline':False]
['text':' "xxx"','line_number':1847,'multiline':False]
['text':' "xxxx"','line_number':1850,'multiline':False]
['text':' "xxxxx"','line_number':1853,'multiline':False]
['text':' Note: "midnight" can be ambiguous as to whether it refers to beginning of day or end of day.','line_number':1892,'multiline':False]
['text':' For ICU 57 output of "midnight" is temporarily suppressed.','line_number':1893,'multiline':False]
['text':' For "midnight" and "noon":','line_number':1895,'multiline':False]
['text':' Time, as displayed, must be exactly noon or midnight.','line_number':1896,'multiline':False]
['text':' This means minutes and seconds, if present, must be zero.','line_number':1897,'multiline':False]
['text':'hour == 0 ||','line_number':1898,'multiline':True]
['text':' Stealing am/pm value to use as our array index.','line_number':1901,'multiline':False]
['text':' It works out: am/midnight are both 0, pm/noon are both 1,','line_number':1902,'multiline':False]
['text':' 12 am is 12 midnight, and 12 pm is 12 noon.','line_number':1903,'multiline':False]
['text':' count == 5','line_number':1910,'multiline':False]
['text':' toAppend is NULL if time isn't exactly midnight or noon (as displayed).','line_number':1915,'multiline':False]
['text':' toAppend is bogus if time is midnight or noon, but no localized string exists.','line_number':1916,'multiline':False]
['text':' In either case, fall back to am/pm.','line_number':1917,'multiline':False]
['text':' Reformat with identical arguments except ch, now changed to 'a'.','line_number':1919,'multiline':False]
['text':' We are passing a different fieldToOutput because we want to add','line_number':1920,'multiline':False]
['text':' 'b' to field position. This makes this fallback stable when','line_number':1921,'multiline':False]
['text':' there is a data change on locales.','line_number':1922,'multiline':False]
['text':' TODO: Maybe fetch the DayperiodRules during initialization (instead of at the first','line_number':1934,'multiline':False]
['text':' loading of an instance) if a relevant pattern character (b or B) is used.','line_number':1935,'multiline':False]
['text':' Data doesn't conform to spec, therefore loading failed.','line_number':1938,'multiline':False]
['text':' Data doesn't exist for the locale we're looking for.','line_number':1942,'multiline':False]
['text':' Falling back to am/pm.','line_number':1943,'multiline':False]
['text':' We are passing a different fieldToOutput because we want to add','line_number':1944,'multiline':False]
['text':' 'B' to field position. This makes this fallback stable when','line_number':1945,'multiline':False]
['text':' there is a data change on locales.','line_number':1946,'multiline':False]
['text':' Get current display time.','line_number':1951,'multiline':False]
['text':' Determine day period.','line_number':1962,'multiline':False]
['text':' Rule set exists, therefore periodType can't be UNKNOWN.','line_number':1972,'multiline':False]
['text':' Get localized string.','line_number':1973,'multiline':False]
['text':' Note: "midnight" can be ambiguous as to whether it refers to beginning of day or end of day.','line_number':1978,'multiline':False]
['text':' For ICU 57 output of "midnight" is temporarily suppressed.','line_number':1979,'multiline':False]
['text':' i.e. short','line_number':1986,'multiline':False]
['text':' count == 5','line_number':1989,'multiline':False]
['text':' Fallback schedule:','line_number':1994,'multiline':False]
['text':' Midnight/Noon -> General Periods -> AM/PM.','line_number':1995,'multiline':False]
['text':' Midnight/Noon -> General Periods.','line_number':1997,'multiline':False]
['text':' i.e. short','line_number':2005,'multiline':False]
['text':' count == 5','line_number':2008,'multiline':False]
['text':' General Periods -> AM/PM.','line_number':2013,'multiline':False]
['text':' We are passing a different fieldToOutput because we want to add','line_number':2017,'multiline':False]
['text':' 'B' to field position iterator. This makes this fallback stable when','line_number':2018,'multiline':False]
['text':' there is a data change on locales.','line_number':2019,'multiline':False]
['text':' all of the other pattern symbols can be formatted as simple numbers with','line_number':2030,'multiline':False]
['text':' appropriate zero padding','line_number':2031,'multiline':False]
['text':' if first field, check to see whether we need to and are able to titlecase it','line_number':2037,'multiline':False]
['text':' titlecase = FALSE;','line_number':2052,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':2068,'multiline':False]
['text':' We successfully set the default number format. Now delete the overrides','line_number':2075,'multiline':False]
['text':' (can't fail).','line_number':2076,'multiline':False]
['text':' Also re-compute the fast formatters.','line_number':2082,'multiline':False]
['text':' We must ensure fSharedNumberFormatters is allocated.','line_number':2095,'multiline':False]
['text':' if the pattern character is unrecognized, signal an error and bail out','line_number':2110,'multiline':False]
['text':' Set the number formatter in the table','line_number':2118,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':2134,'multiline':False]
['text':' NOTE: This uses the heuristic that these five min/max int settings account for the vast majority','line_number':2142,'multiline':False]
['text':' of SimpleDateFormat number formatting cases at the time of writing (ICU 62).','line_number':2143,'multiline':False]
['text':' Can use fast path','line_number':2162,'multiline':False]
['text':' Check for RBNF (no clone necessary)','line_number':2174,'multiline':False]
['text':' 3rd arg is there to speed up processing','line_number':2178,'multiline':False]
['text':' Fall back to slow path (clone and mutate the NumberFormat)','line_number':2182,'multiline':False]
['text':' 3rd arg is there to speed up processing','line_number':2188,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':2192,'multiline':False]
['text':'*
 * Return true if the given format character, occuring count
 * times, represents a numeric field.
 ','line_number':2194,'multiline':True]
['text':' not at any field','line_number':2205,'multiline':False]
['text':' not at any field','line_number':2211,'multiline':False]
['text':' not after any field','line_number':2222,'multiline':False]
['text':' not after any field','line_number':2228,'multiline':False]
['text':' Hold the day period until everything else is parsed, because we need','line_number':2247,'multiline':False]
['text':' the hour to interpret time correctly.','line_number':2248,'multiline':False]
['text':' For parsing abutting numeric fields. 'abutPat' is the','line_number':2256,'multiline':False]
['text':' offset into 'pattern' of the first of 2 or more abutting','line_number':2257,'multiline':False]
['text':' numeric fields.  'abutStart' is the offset into 'text'','line_number':2258,'multiline':False]
['text':' where parsing the fields begins. 'abutPass' starts off as 0','line_number':2259,'multiline':False]
['text':' and increments each time we try to parse the fields.','line_number':2260,'multiline':False]
['text':' If >=0, we are in a run of abutting numeric fields','line_number':2261,'multiline':False]
['text':' Different calendar type','line_number':2271,'multiline':False]
['text':' We use the time/zone from the input calendar, but','line_number':2272,'multiline':False]
['text':' do not use the input calendar for field calculation.','line_number':2273,'multiline':False]
['text':' this will delete numericLeapMonthFormatter','line_number':2294,'multiline':False]
['text':' Handle alphabetic field characters.','line_number':2301,'multiline':False]
['text':' Count the length of this field specifier','line_number':2305,'multiline':False]
['text':' Determine if there is an abutting numeric field.','line_number':2315,'multiline':False]
['text':' Record the start of a set of abutting numeric fields.','line_number':2316,'multiline':False]
['text':' End of any abutting fields','line_number':2324,'multiline':False]
['text':' Handle fields within a run of abutting numeric fields.  Take','line_number':2327,'multiline':False]
['text':' the pattern "HHmmss" as an example. We will try to parse','line_number':2328,'multiline':False]
['text':' 2/2/2 characters of the input text, then if that fails,','line_number':2329,'multiline':False]
['text':' 1/2/2.  We only adjust the width of the leftmost field; the','line_number':2330,'multiline':False]
['text':' others remain fixed.  This allows "123456" => 12:34:56, but','line_number':2331,'multiline':False]
['text':' "12345" => 1:23:45.  Likewise, for the pattern "yyyyMMdd" we','line_number':2332,'multiline':False]
['text':' try 4/2/2, 3/2/2, 2/2/2, and finally 1/2/2.','line_number':2333,'multiline':False]
['text':' If we are at the start of a run of abutting fields, then','line_number':2335,'multiline':False]
['text':' shorten this field in each pass.  If we can't shorten','line_number':2336,'multiline':False]
['text':' this field any more, then the parse of this set of','line_number':2337,'multiline':False]
['text':' abutting numeric fields has failed.','line_number':2338,'multiline':False]
['text':' If the parse fails anywhere in the run, back up to the','line_number':2350,'multiline':False]
['text':' start of the run and retry.','line_number':2351,'multiline':False]
['text':' Handle non-numeric fields and non-abutting numeric','line_number':2359,'multiline':False]
['text':' fields.','line_number':2360,'multiline':False]
['text':' pattern char 'l' (SMALL LETTER L) just gets ignored','line_number':2361,'multiline':False]
['text':' era not present, in special cases allow this to continue','line_number':2366,'multiline':False]
['text':' from the position where the era was expected','line_number':2367,'multiline':False]
['text':' move to next pattern character','line_number':2371,'multiline':False]
['text':' check for whitespace','line_number':2374,'multiline':False]
['text':' Advance over run in pattern','line_number':2377,'multiline':False]
['text':' Handle literal pattern characters.  These are any','line_number':2393,'multiline':False]
['text':' quoted characters and non-alphabetic unquoted','line_number':2394,'multiline':False]
['text':' characters.','line_number':2395,'multiline':False]
['text':' End of any abutting fields','line_number':2398,'multiline':False]
['text':' Special hack for trailing "." after non-numeric field.','line_number':2407,'multiline':False]
['text':' only do if the last field is not numeric','line_number':2409,'multiline':False]
['text':' skip the extra "."','line_number':2411,'multiline':False]
['text':' If dayPeriod is set, use it in conjunction with hour-of-day to determine am/pm.','line_number':2415,'multiline':False]
['text':' If hour is not set, set time to the midpoint of current day period, overwriting','line_number':2421,'multiline':False]
['text':' minutes if it's set.','line_number':2422,'multiline':False]
['text':' If we can't get midPoint we do nothing.','line_number':2425,'multiline':False]
['text':' Truncate midPoint toward zero to get the hour.','line_number':2427,'multiline':False]
['text':' Any leftover means it was a half-hour.','line_number':2428,'multiline':False]
['text':' No need to set am/pm because hour-of-day is set last therefore takes precedence.','line_number':2432,'multiline':False]
['text':' Hour is parsed in 24-hour format.','line_number':2439,'multiline':False]
['text':' Hour is parsed in 12-hour format.','line_number':2441,'multiline':False]
['text':' cal.get() turns 12 to 0 for 12-hour time; change 0 to 12','line_number':2443,'multiline':False]
['text':' so 0 unambiguously means a 24-hour time from above.','line_number':2444,'multiline':False]
['text':' If hour-of-day is 0 or 13 thru 23 then input time in unambiguously in 24-hour format.','line_number':2450,'multiline':False]
['text':' Make hour-of-day take precedence over (hour + am/pm) by setting it again.','line_number':2452,'multiline':False]
['text':' We have a 12-hour time and need to choose between am and pm.','line_number':2455,'multiline':False]
['text':' Behave as if dayPeriod spanned 6 hours each way from its center point.','line_number':2456,'multiline':False]
['text':' This will parse correctly for consistent time + period (e.g. 10 at night) as','line_number':2457,'multiline':False]
['text':' well as provide a reasonable recovery for inconsistent time + period (e.g.','line_number':2458,'multiline':False]
['text':' 9 in the afternoon).','line_number':2459,'multiline':False]
['text':' Assume current time is in the AM.','line_number':2461,'multiline':False]
['text':' - Change 12 back to 0 for easier handling of 12am.','line_number':2462,'multiline':False]
['text':' - Append minutes as fractional hours because e.g. 8:15 and 8:45 could be parsed','line_number':2463,'multiline':False]
['text':' into different half-days if center of dayPeriod is at 14:30.','line_number':2464,'multiline':False]
['text':' - cal.get(MINUTE) will return 0 if MINUTE is unset, which works.','line_number':2465,'multiline':False]
['text':' Assume current time is in the AM.','line_number':2473,'multiline':False]
['text':' Assumption holds; set time as such.','line_number':2475,'multiline':False]
['text':' At this point the fields of Calendar have been set.  Calendar','line_number':2485,'multiline':False]
['text':' will fill in default values for missing fields when the time','line_number':2486,'multiline':False]
['text':' is computed.','line_number':2487,'multiline':False]
['text':' This part is a problem:  When we call parsedDate.after, we compute the time.','line_number':2491,'multiline':False]
['text':' Take the date April 3 2004 at 2:30 am.  When this is first set up, the year','line_number':2492,'multiline':False]
['text':' will be wrong if we're parsing a 2-digit year pattern.  It will be 1904.','line_number':2493,'multiline':False]
['text':' April 3 1904 is a Sunday (unlike 2004) so it is the DST onset day.  2:30 am','line_number':2494,'multiline':False]
['text':' is therefore an "impossible" time, since the time goes from 1:59 to 3:00 am','line_number':2495,'multiline':False]
['text':' on that day.  It is therefore parsed out to fields as 3:30 am.  Then we','line_number':2496,'multiline':False]
['text':' add 100 years, and get April 3 2004 at 3:30 am.  Note that April 3 2004 is','line_number':2497,'multiline':False]
['text':' a Saturday, so it can have a 2:30 am -- and it should. [LIU]','line_number':2498,'multiline':False]
['text':'
        UDate parsedDate = calendar.getTime();
        if( ambiguousYear[0] && !parsedDate.after(fDefaultCenturyStart) ) {
            calendar.add(Calendar.YEAR, 100);
            parsedDate = calendar.getTime();
        }
    ','line_number':2499,'multiline':True]
['text':' Because of the above condition, save off the fields in case we need to readjust.','line_number':2506,'multiline':False]
['text':' The procedure we use here is not particularly efficient, but there is no other','line_number':2507,'multiline':False]
['text':' way to do this given the API restrictions present in Calendar.  We minimize','line_number':2508,'multiline':False]
['text':' inefficiency by only performing this computation when it might apply, that is,','line_number':2509,'multiline':False]
['text':' when the two-digit year is equal to the start year, and thus might fall at the','line_number':2510,'multiline':False]
['text':' front or the back of the default century.  This only works because we adjust','line_number':2511,'multiline':False]
['text':' the year correctly to start with in other cases -- see subParse().','line_number':2512,'multiline':False]
['text':' If this is true then the two-digit year == the default start year','line_number':2513,'multiline':False]
['text':' We need a copy of the fields, and we need to avoid triggering a call to','line_number':2515,'multiline':False]
['text':' complete(), which will recalculate the fields.  Since we can't access','line_number':2516,'multiline':False]
['text':' the fields[] array in Calendar, we clone the entire object.  This will','line_number':2517,'multiline':False]
['text':' stop working if Calendar.clone() is ever rewritten to call complete().','line_number':2518,'multiline':False]
['text':' Check for failed cloning.','line_number':2522,'multiline':False]
['text':' {sfb} check internalGetDefaultCenturyStart','line_number':2528,'multiline':False]
['text':' We can't use add here because that does a complete() first.','line_number':2530,'multiline':False]
['text':' Check for failed cloning.','line_number':2538,'multiline':False]
['text':' Get local millis','line_number':2553,'multiline':False]
['text':' Make sure parsed time zone type (Standard or Daylight)','line_number':2558,'multiline':False]
['text':' matches the rule used by the parsed time zone.','line_number':2559,'multiline':False]
['text':' No good way to resolve ambiguous time at transition,','line_number':2570,'multiline':False]
['text':' but following code work in most case.','line_number':2571,'multiline':False]
['text':' Now, compare the results with parsed type, either standard or daylight saving time','line_number':2575,'multiline':False]
['text':' Override DST_OFFSET = 0 in the result calendar','line_number':2579,'multiline':False]
['text':' tztype == TZTYPE_DST','line_number':2582,'multiline':False]
['text':' This implementation resolves daylight saving time offset','line_number':2585,'multiline':False]
['text':' closest rule after the given time.','line_number':2586,'multiline':False]
['text':' Search for DST rule after the given time','line_number':2593,'multiline':False]
['text':' If no DST rule after the given time was found, search for','line_number':2607,'multiline':False]
['text':' DST rule before.','line_number':2608,'multiline':False]
['text':' final fallback','line_number':2631,'multiline':False]
['text':' Set the parsed result if local calendar is used','line_number':2642,'multiline':False]
['text':' instead of the input calendar','line_number':2643,'multiline':False]
['text':' If any Calendar calls failed, we pretend that we','line_number':2656,'multiline':False]
['text':' couldn't parse the string, when in reality this isn't quite accurate--','line_number':2657,'multiline':False]
['text':' we did parse it; the Calendar calls just failed.','line_number':2658,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':2665,'multiline':False]
['text':' There may be multiple strings in the data[] array which begin with','line_number':2682,'multiline':False]
['text':' the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).','line_number':2683,'multiline':False]
['text':' We keep track of the longest match, and return that.  Note that this','line_number':2684,'multiline':False]
['text':' unfortunately requires us to test all array elements.','line_number':2685,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':2728,'multiline':False]
['text':' scan pattern looking for contiguous literal characters','line_number':2741,'multiline':False]
['text':' Match a quote literal ('') inside OR outside of quotes','line_number':2750,'multiline':False]
['text':' at this point, literal contains the literal text','line_number':2762,'multiline':False]
['text':' and i is the index of the next non-literal pattern character.','line_number':2763,'multiline':False]
['text':' trim leading, trailing whitespace from','line_number':2768,'multiline':False]
['text':' the literal text','line_number':2769,'multiline':False]
['text':' ignore any leading whitespace in the text','line_number':2772,'multiline':False]
['text':' TODO: should we require internal spaces','line_number':2799,'multiline':False]
['text':' in lenient mode? (There won't be any','line_number':2800,'multiline':False]
['text':' leading or trailing spaces)','line_number':2801,'multiline':False]
['text':' didn't find matching whitespace:','line_number':2803,'multiline':False]
['text':' an error in strict mode','line_number':2804,'multiline':False]
['text':' In strict mode, this run of whitespace','line_number':2808,'multiline':False]
['text':' may have been at the end.','line_number':2809,'multiline':False]
['text':' Ran out of text, or found a non-matching character:','line_number':2815,'multiline':False]
['text':' OK in lenient mode, an error in strict mode.','line_number':2816,'multiline':False]
['text':' Lenient mode and the literal input text begins with a "." and','line_number':2820,'multiline':False]
['text':' we are after a non-numeric field: We skip the "."','line_number':2821,'multiline':False]
['text':' Do not update p.','line_number':2823,'multiline':False]
['text':' if it is actual whitespace and we're whitespace lenient it's OK','line_number':2825,'multiline':False]
['text':' Lenient mode and it's just whitespace we skip it','line_number':2829,'multiline':False]
['text':' Do not update p.','line_number':2831,'multiline':False]
['text':' hack around oldleniency being a bit of a catch-all bucket and we're just adding support specifically for paritial matches','line_number':2834,'multiline':False]
['text':' At this point if we're in strict mode we have a complete match.','line_number':2845,'multiline':False]
['text':' If we're in lenient mode we may have a partial match, or no','line_number':2846,'multiline':False]
['text':' match at all.','line_number':2847,'multiline':False]
['text':' no match. Pretend it matched a run of whitespace','line_number':2849,'multiline':False]
['text':' and ignorables in the text.','line_number':2850,'multiline':False]
['text':' if we get here, we've got a complete match.','line_number':2866,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':2873,'multiline':False]
['text':' There may be multiple strings in the data[] array which begin with','line_number':2888,'multiline':False]
['text':' the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).','line_number':2889,'multiline':False]
['text':' We keep track of the longest match, and return that.  Note that this','line_number':2890,'multiline':False]
['text':' unfortunately requires us to test all array elements.','line_number':2891,'multiline':False]
['text':' Adjustment for Hebrew Calendar month Adar II','line_number':2919,'multiline':False]
['text':' only get here for cyclic year names, which match 1-based years 1-60','line_number':2924,'multiline':False]
['text':' default case option ','line_number':2949,'multiline':True]
['text':' normal match ','line_number':2954,'multiline':True]
['text':' match without trailing dot ','line_number':2956,'multiline':True]
['text':'----------------------------------------------------------------------','line_number':2963,'multiline':False]
['text':'*
 * Private member function that converts the parsed date strings into
 * timeFields. Returns -start (for ParsePosition) if failed.
 ','line_number':2971,'multiline':True]
['text':'fprintf(stderr, "%s:%d - [%c]  st=%d \n", __FILE__, __LINE__, (char) ch, start);','line_number':2992,'multiline':False]
['text':' UCAL_FIELD_COUNT if irrelevant','line_number':3003,'multiline':False]
['text':' If there are any spaces here, skip over them.  If we hit the end','line_number':3011,'multiline':False]
['text':' of the string, then fail.','line_number':3012,'multiline':False]
['text':'||','line_number':3018,'multiline':True]
['text':' We handle a few special cases here where we need to parse','line_number':3025,'multiline':False]
['text':' a number value.  We handle further, more generic cases below.  We need','line_number':3026,'multiline':False]
['text':' to handle some of them here because some fields require extra processing on','line_number':3027,'multiline':False]
['text':' the parsed value.','line_number':3028,'multiline':False]
['text':' k','line_number':3029,'multiline':False]
['text':' H','line_number':3030,'multiline':False]
['text':' h','line_number':3031,'multiline':False]
['text':' K','line_number':3032,'multiline':False]
['text':' e','line_number':3033,'multiline':False]
['text':' c','line_number':3034,'multiline':False]
['text':' M','line_number':3035,'multiline':False]
['text':' L','line_number':3036,'multiline':False]
['text':' Q','line_number':3037,'multiline':False]
['text':' q','line_number':3038,'multiline':False]
['text':' y','line_number':3039,'multiline':False]
['text':' Y','line_number':3040,'multiline':False]
['text':' U (falls back to numeric)','line_number':3041,'multiline':False]
['text':' G','line_number':3042,'multiline':False]
['text':' S','line_number':3043,'multiline':False]
['text':' It would be good to unify this with the obeyCount logic below,','line_number':3046,'multiline':False]
['text':' but that's going to be difficult.','line_number':3047,'multiline':False]
['text':' suffix processing','line_number':3086,'multiline':False]
['text':' Check the range of the value','line_number':3098,'multiline':False]
['text':' Make sure that we got a number if','line_number':3109,'multiline':False]
['text':' we want one, and didn't get one','line_number':3110,'multiline':False]
['text':' if we don't want one.','line_number':3111,'multiline':False]
['text':' special range check for hours:','line_number':3117,'multiline':False]
['text':' fall through to gotNumber check','line_number':3122,'multiline':False]
['text':' these must be a number','line_number':3127,'multiline':False]
['text':' we check the rest of the fields below.','line_number':3135,'multiline':False]
['text':' check return position, if it equals -start, then matchString error','line_number':3156,'multiline':False]
['text':' special case the return code so we don't necessarily fail out until we','line_number':3157,'multiline':False]
['text':' verify no year information also','line_number':3158,'multiline':False]
['text':' If there are 3 or more YEAR pattern characters, this indicates','line_number':3165,'multiline':False]
['text':' that the year value is to be treated literally, without any','line_number':3166,'multiline':False]
['text':' two-digit year adjustments (e.g., from "01" to 2001).  Otherwise','line_number':3167,'multiline':False]
['text':' we made adjustments to place the 2-digit year in the proper','line_number':3168,'multiline':False]
['text':' century, for parsed strings from "00" to "99".  Any other string','line_number':3169,'multiline':False]
['text':' is treated literally:  "2250", "-1", "1", "002".','line_number':3170,'multiline':False]
['text':' only adjust year for patterns less than 3.','line_number':3177,'multiline':False]
['text':' Assume for example that the defaultCenturyStart is 6/18/1903.','line_number':3179,'multiline':False]
['text':' This means that two-digit years will be forced into the range','line_number':3180,'multiline':False]
['text':' 6/18/1903 to 6/17/2003.  As a result, years 00, 01, and 02','line_number':3181,'multiline':False]
['text':' correspond to 2000, 2001, and 2002.  Years 04, 05, etc. correspond','line_number':3182,'multiline':False]
['text':' to 1904, 1905, etc.  If the year is 03, then it is 2003 if the','line_number':3183,'multiline':False]
['text':' other fields specify a date before 6/18, or 1903 if they specify a','line_number':3184,'multiline':False]
['text':' date afterwards.  As a result, 03 is an ambiguous year.  All other','line_number':3185,'multiline':False]
['text':' two-digit years are unambiguous.','line_number':3186,'multiline':False]
['text':' check if this formatter even has a pivot year','line_number':3187,'multiline':False]
['text':' Delayed checking for adjustment of Hebrew month numbers in non-leap years.','line_number':3197,'multiline':False]
['text':' Comment is the same as for UDAT_Year_FIELDs - look above','line_number':3210,'multiline':False]
['text':' i.e., M or MM.','line_number':3241,'multiline':False]
['text':' When parsing month numbers from the Hebrew Calendar, we might need to adjust the month depending on whether','line_number':3243,'multiline':False]
['text':' or not it was a leap year.  We may or may not yet know what year it is, so might have to delay checking until','line_number':3244,'multiline':False]
['text':' the year is parsed.','line_number':3245,'multiline':False]
['text':' Don't want to parse the month if it is a string','line_number':3259,'multiline':False]
['text':' while pattern uses numeric style: M/MM, L/LL','line_number':3260,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3261,'multiline':False]
['text':' count >= 3 // i.e., MMM/MMMM, LLL/LLLL','line_number':3266,'multiline':False]
['text':' Want to be able to parse both short and long forms.','line_number':3267,'multiline':False]
['text':' Try count == 4 first:','line_number':3268,'multiline':False]
['text':' try MMMM','line_number':3283,'multiline':False]
['text':' try MMM','line_number':3289,'multiline':False]
['text':' try LLLL','line_number':3293,'multiline':False]
['text':' try LLL','line_number':3299,'multiline':False]
['text':' currently we do not try to parse MMMMM/LLLLL: #8860','line_number':3302,'multiline':False]
['text':' else we allowing parsing as number, below','line_number':3304,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3309,'multiline':False]
['text':' fall through to set field','line_number':3313,'multiline':False]
['text':' Fractional seconds left-justify','line_number':3320,'multiline':False]
['text':' i.e., e or ee','line_number':3339,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3341,'multiline':False]
['text':' else for eee-eeeee fall through to handling of EEE-EEEEE','line_number':3345,'multiline':False]
['text':' fall through, do not break here','line_number':3346,'multiline':False]
['text':' Want to be able to parse both short and long forms.','line_number':3350,'multiline':False]
['text':' Try count == 4 (EEEE) wide first:','line_number':3351,'multiline':False]
['text':' EEEE wide failed, now try EEE abbreviated','line_number':3358,'multiline':False]
['text':' EEE abbreviated failed, now try EEEEEE short','line_number':3364,'multiline':False]
['text':' EEEEEE short failed, now try EEEEE narrow','line_number':3370,'multiline':False]
['text':' else we allowing parsing as number, below','line_number':3378,'multiline':False]
['text':' c or cc','line_number':3384,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3386,'multiline':False]
['text':' Want to be able to parse both short and long forms.','line_number':3390,'multiline':False]
['text':' Try count == 4 (cccc) first:','line_number':3391,'multiline':False]
['text':' else we allowing parsing as number, below','line_number':3410,'multiline':False]
['text':' optionally try both wide/abbrev and narrow forms','line_number':3416,'multiline':False]
['text':' try wide/abbrev','line_number':3418,'multiline':False]
['text':' try narrow','line_number':3424,'multiline':False]
['text':' no matches for given options','line_number':3430,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3435,'multiline':False]
['text':' fall through to set field','line_number':3439,'multiline':False]
['text':' i.e., Q or QQ.','line_number':3446,'multiline':False]
['text':' Don't want to parse the month if it is a string','line_number':3448,'multiline':False]
['text':' while pattern uses numeric style: Q or QQ.','line_number':3449,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3450,'multiline':False]
['text':' count >= 3 // i.e., QQQ or QQQQ','line_number':3454,'multiline':False]
['text':' Want to be able to parse both short and long forms.','line_number':3455,'multiline':False]
['text':' Try count == 4 first:','line_number':3456,'multiline':False]
['text':' else we allowing parsing as number, below','line_number':3471,'multiline':False]
['text':' i.e., q or qq.','line_number':3478,'multiline':False]
['text':' Don't want to parse the month if it is a string','line_number':3480,'multiline':False]
['text':' while pattern uses numeric style: q or q.','line_number':3481,'multiline':False]
['text':' [We computed 'value' above.]','line_number':3482,'multiline':False]
['text':' count >= 3 // i.e., qqq or qqqq','line_number':3486,'multiline':False]
['text':' Want to be able to parse both short and long forms.','line_number':3487,'multiline':False]
['text':' Try count == 4 first:','line_number':3488,'multiline':False]
['text':' else we allowing parsing as number, below','line_number':3503,'multiline':False]
['text':' 'z'','line_number':3509,'multiline':False]
['text':' 'Z'','line_number':3523,'multiline':False]
['text':' 'v'','line_number':3537,'multiline':False]
['text':' 'V'','line_number':3550,'multiline':False]
['text':' 'O'','line_number':3577,'multiline':False]
['text':' 'X'','line_number':3590,'multiline':False]
['text':' 'x'','line_number':3620,'multiline':False]
['text':' currently no pattern character is defined for UDAT_TIME_SEPARATOR_FIELD','line_number':3650,'multiline':False]
['text':' so we should not get here. Leave support in for future definition.','line_number':3651,'multiline':False]
['text':' Try matching a time separator.','line_number':3657,'multiline':False]
['text':' Add the default, if different from the locale.','line_number':3662,'multiline':False]
['text':' If lenient, add also the alternate, if different from the locale.','line_number':3667,'multiline':False]
['text':' => nothing to set ','line_number':3672,'multiline':True]
['text':' Only match the first two strings from the day period strings array.','line_number':3687,'multiline':False]
['text':' count == 4, but allow other counts','line_number':3700,'multiline':False]
['text':' Handle "generic" fields','line_number':3740,'multiline':False]
['text':' this is now handled below, outside the switch block','line_number':3741,'multiline':False]
['text':' Handle "generic" fields:','line_number':3744,'multiline':False]
['text':' switch default case now handled here (outside switch block) to allow','line_number':3745,'multiline':False]
['text':' parsing of some string fields as digits for lenient case','line_number':3746,'multiline':False]
['text':' Don't need suffix processing here (as in number processing at the beginning of the function);','line_number':3763,'multiline':False]
['text':' the new fields being handled as numeric values (month, weekdays, quarters) should not have suffixes.','line_number':3764,'multiline':False]
['text':' Check the range of the value','line_number':3767,'multiline':False]
['text':' For the following, need to repeat some of the "if (gotNumber)" code above:','line_number':3774,'multiline':False]
['text':' UDAT_[STANDALONE_]MONTH_FIELD, UDAT_DOW_LOCAL_FIELD, UDAT_STANDALONE_DAY_FIELD,','line_number':3775,'multiline':False]
['text':' UDAT_[STANDALONE_]QUARTER_FIELD','line_number':3776,'multiline':False]
['text':' See notes under UDAT_MONTH_FIELD case above','line_number':3779,'multiline':False]
['text':'*
 * Parse an integer using fNumberFormat.  This method is semantically
 * const, but actually may modify fNumberFormat.
 ','line_number':3819,'multiline':True]
['text':'*
 * Parse an integer using fNumberFormat up to maxDigits.
 ','line_number':3831,'multiline':True]
['text':' Memory allocation error','line_number':3846,'multiline':False]
['text':' adjust the result to fit into','line_number':3856,'multiline':False]
['text':' the maxDigits and move the position back','line_number':3857,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3885,'multiline':False]
['text':' run through the pattern and convert any pattern symbols from the version','line_number':3893,'multiline':False]
['text':' in "from" to the corresponding character in "to".  This code takes','line_number':3894,'multiline':False]
['text':' quoted strings into account (it doesn't try to translate them), and it signals','line_number':3895,'multiline':False]
['text':' an error if a particular "pattern character" doesn't appear in "from".','line_number':3896,'multiline':False]
['text':' Depending on the values of "from" and "to" this can convert from generic','line_number':3897,'multiline':False]
['text':' to localized patterns or localized to generic.','line_number':3898,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3931,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3940,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3952,'multiline':False]
['text':' Hack to update use of Gannen year numbering for ja@calendar=japanese -','line_number':3960,'multiline':False]
['text':' use only if format is non-numeric (includes å¹´) and no other fDateOverride.','line_number':3961,'multiline':False]
['text':' Gannen numbering is set but new pattern should not use it, unset;','line_number':3965,'multiline':False]
['text':' use procedure from adoptNumberFormat to clear overrides','line_number':3966,'multiline':False]
['text':' record status','line_number':3971,'multiline':False]
['text':' No current override (=> no Gannen numbering) but new pattern needs it;','line_number':3973,'multiline':False]
['text':' use procedures from initNUmberFormatters / adoptNumberFormat','line_number':3974,'multiline':False]
['text':' Now that we have an appropriate number formatter, fill in the','line_number':3985,'multiline':False]
['text':' appropriate slot in the number formatters table.','line_number':3986,'multiline':False]
['text':' record status','line_number':3990,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':3997,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4008,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4016,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4025,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4033,'multiline':False]
['text':' TimeZoneFormat initialization might fail when out of memory.','line_number':4036,'multiline':False]
['text':' If we always initialize TimeZoneFormat instance, we can return','line_number':4037,'multiline':False]
['text':' such status there. For now, this implementation lazily instantiates','line_number':4038,'multiline':False]
['text':' a TimeZoneFormat for performance optimization reasons, but cannot','line_number':4039,'multiline':False]
['text':' propagate such error (probably just out of memory case) to the caller.','line_number':4040,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4045,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4053,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4061,'multiline':False]
['text':' we need a new century (possibly)','line_number':4078,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4082,'multiline':False]
['text':' override the DateFormat implementation in order to','line_number':4085,'multiline':False]
['text':' lazily initialize fCapitalizationBrkIter','line_number':4086,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4107,'multiline':False]
['text':' the larger the level, the smaller the field unit.','line_number':4130,'multiline':False]
['text':' last item','line_number':4149,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4158,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4165,'multiline':False]
['text':' local variables','line_number':4170,'multiline':False]
['text':' check that we are still in range','line_number':4176,'multiline':False]
['text':' out of range, don't advance location in text','line_number':4181,'multiline':False]
['text':' get the suffix','line_number':4185,'multiline':False]
['text':' check for suffix','line_number':4196,'multiline':False]
['text':' check suffix will be encountered in the pattern','line_number':4201,'multiline':False]
['text':' check if a suffix will be encountered in the text','line_number':4204,'multiline':False]
['text':' check if a suffix was encountered in the text','line_number':4207,'multiline':False]
['text':' check for suffix match','line_number':4210,'multiline':False]
['text':' should not get here','line_number':4218,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4222,'multiline':False]
['text':' We may have a pattern like: \u200F \u0020','line_number':4233,'multiline':False]
['text':'        and input text like: \u200F \u0020','line_number':4234,'multiline':False]
['text':' Note that U+200F and U+0020 are Pattern_White_Space but only','line_number':4235,'multiline':False]
['text':' U+0020 is UWhiteSpace.  So we have to first do a direct','line_number':4236,'multiline':False]
['text':' match of the run of Pattern_White_Space in the pattern,','line_number':4237,'multiline':False]
['text':' then match any extra characters.','line_number':4238,'multiline':False]
['text':' Advance over run in pattern','line_number':4255,'multiline':False]
['text':' Advance over run in input text','line_number':4258,'multiline':False]
['text':' Must see at least one white space char in input,','line_number':4259,'multiline':False]
['text':' unless we've already matched some characters literally.','line_number':4260,'multiline':False]
['text':' If we skip UWhiteSpace in the input text, we need to skip it in the pattern.','line_number':4267,'multiline':False]
['text':' Otherwise, the previous lines may have skipped over text (such as U+00A0) that','line_number':4268,'multiline':False]
['text':' is also in the affix.','line_number':4269,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4284,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4292,'multiline':False]
['text':'----------------------------------------------------------------------','line_number':4306,'multiline':False]
['text':' Lazy TimeZoneFormat instantiation, semantically const.','line_number':4308,'multiline':False]
['text':' don't care whether this is inside quotes','line_number':4340,'multiline':False]
['text':' 0x6D == 'm'','line_number':4344,'multiline':False]
['text':' 0x73 == 's'','line_number':4347,'multiline':False]
['text':' #if !UCONFIG_NO_FORMATTING ','line_number':4356,'multiline':True]
['text':'eof','line_number':4358,'multiline':False]
