['text':' Â© 2016 and later: Unicode, Inc. and others.','line_number':1,'multiline':False]
['text':' License & terms of use: http://www.unicode.org/copyright.html','line_number':2,'multiline':False]
['text':'
******************************************************************************
*   Copyright (C) 1997-2015, International Business Machines
*   Corporation and others.  All Rights Reserved.
******************************************************************************
*   file name:  nfrule.cpp
*   encoding:   UTF-8
*   tab size:   8 (not used)
*   indentation:4
*
* Modification history
* Date        Name      Comments
* 10/11/2001  Doug      Ported from ICU4J
','line_number':3,'multiline':True]
['text':'static const UChar gMinus = 0x002d;','line_number':77,'multiline':False]
['text':' "-x" ','line_number':81,'multiline':True]
['text':' "Inf" ','line_number':82,'multiline':True]
['text':' "NaN" ','line_number':83,'multiline':True]
['text':' "$(" ','line_number':85,'multiline':True]
['text':' ")$" ','line_number':86,'multiline':True]
['text':' "<<" ','line_number':88,'multiline':True]
['text':' "<%" ','line_number':89,'multiline':True]
['text':' "<#" ','line_number':90,'multiline':True]
['text':' "<0" ','line_number':91,'multiline':True]
['text':' ">>" ','line_number':92,'multiline':True]
['text':' ">%" ','line_number':93,'multiline':True]
['text':' ">#" ','line_number':94,'multiline':True]
['text':' ">0" ','line_number':95,'multiline':True]
['text':' "=%" ','line_number':96,'multiline':True]
['text':' "=#" ','line_number':97,'multiline':True]
['text':' "=0" ','line_number':98,'multiline':True]
['text':' ">>>" ','line_number':99,'multiline':True]
['text':' we know we're making at least one rule, so go ahead and','line_number':115,'multiline':False]
['text':' new it up and initialize its basevalue and divisor','line_number':116,'multiline':False]
['text':' (this also strips the rule descriptor, if any, off the','line_number':117,'multiline':False]
['text':' descripton string)','line_number':118,'multiline':False]
['text':' test for NULL ','line_number':120,'multiline':True]
['text':' check the description to see whether there's text enclosed','line_number':127,'multiline':False]
['text':' in brackets','line_number':128,'multiline':False]
['text':' if the description doesn't contain a matched pair of brackets,','line_number':132,'multiline':False]
['text':' or if it's of a type that doesn't recognize bracketed text,','line_number':133,'multiline':False]
['text':' then leave the description alone, initialize the rule's','line_number':134,'multiline':False]
['text':' rule text and substitutions, and return that rule','line_number':135,'multiline':False]
['text':' if the description does contain a matched pair of brackets,','line_number':145,'multiline':False]
['text':' then it's really shorthand for two rules (with one exception)','line_number':146,'multiline':False]
['text':' we'll actually only split the rule into two rules if its','line_number':150,'multiline':False]
['text':' base value is an even multiple of its divisor (or it's one','line_number':151,'multiline':False]
['text':' of the special rules)','line_number':152,'multiline':False]
['text':' if it passes that test, new up the second rule.  If the','line_number':158,'multiline':False]
['text':' rule set both rules will belong to is a fraction rule','line_number':159,'multiline':False]
['text':' set, they both have the same base value; otherwise,','line_number':160,'multiline':False]
['text':' increment the original rule's base value ("rule1" actually','line_number':161,'multiline':False]
['text':' goes SECOND in the rule set's rule list)','line_number':162,'multiline':False]
['text':' test for NULL ','line_number':164,'multiline':True]
['text':' if the description began with "x.x" and contains bracketed','line_number':176,'multiline':False]
['text':' text, it describes both the improper fraction rule and','line_number':177,'multiline':False]
['text':' the proper fraction rule','line_number':178,'multiline':False]
['text':' if the description began with "x.0" and contains bracketed','line_number':183,'multiline':False]
['text':' text, it describes both the default rule and the','line_number':184,'multiline':False]
['text':' improper fraction rule','line_number':185,'multiline':False]
['text':' both rules have the same radix and exponent (i.e., the','line_number':191,'multiline':False]
['text':' same divisor)','line_number':192,'multiline':False]
['text':' rule2's rule text omits the stuff in brackets: initalize','line_number':196,'multiline':False]
['text':' its rule text and substitutions accordingly','line_number':197,'multiline':False]
['text':' rule1's text includes the text in the brackets but omits','line_number':205,'multiline':False]
['text':' the brackets themselves: initialize _its_ rule text and','line_number':206,'multiline':False]
['text':' substitutions accordingly','line_number':207,'multiline':False]
['text':' if we only have one rule, return it; if we have two, return','line_number':215,'multiline':False]
['text':' a two-element array containing them (notice that rule2 goes','line_number':216,'multiline':False]
['text':' BEFORE rule1 in the list: in all cases, rule2 OMITS the','line_number':217,'multiline':False]
['text':' material in the brackets and rule1 INCLUDES the material','line_number':218,'multiline':False]
['text':' in the brackets)','line_number':219,'multiline':False]
['text':'*
 * This function parses the rule's rule descriptor (i.e., the base
 * value and/or other tokens that precede the rule's rule text
 * in the description) and sets the rule's base value, radix, and
 * exponent according to the descriptor.  (If the description doesn't
 * include a rule descriptor, then this function sets everything to
 * default values and the rule set sets the rule's real base value).
 * @param description The rule's description
 * @return If "description" included a rule descriptor, this is
 * "description" with the descriptor and any trailing whitespace
 * stripped off.  Otherwise; it's "descriptor" unchangd.
 ','line_number':237,'multiline':True]
['text':' the description consists of a rule descriptor and a rule body,','line_number':252,'multiline':False]
['text':' separated by a colon.  The rule descriptor is optional.  If','line_number':253,'multiline':False]
['text':' it's omitted, just set the base value to 0.','line_number':254,'multiline':False]
['text':' copy the descriptor out into its own string and strip it,','line_number':257,'multiline':False]
['text':' along with any trailing whitespace, out of the original','line_number':258,'multiline':False]
['text':' description','line_number':259,'multiline':False]
['text':' check first to see if the rule descriptor matches the token','line_number':269,'multiline':False]
['text':' for one of the special rules.  If it does, set the base','line_number':270,'multiline':False]
['text':' value to the correct identifier value','line_number':271,'multiline':False]
['text':' if the rule descriptor begins with a digit, it's a descriptor','line_number':276,'multiline':False]
['text':' for a normal rule','line_number':277,'multiline':False]
['text':' since we don't have Long.parseLong, and this isn't much work anyway,','line_number':278,'multiline':False]
['text':' just build up the value as we encounter the digits.','line_number':279,'multiline':False]
['text':' begin parsing the descriptor: copy digits','line_number':284,'multiline':False]
['text':' into "tempValue", skip periods, commas, and spaces,','line_number':285,'multiline':False]
['text':' stop on a slash or > sign (or at the end of the string),','line_number':286,'multiline':False]
['text':' and throw an exception on any other character','line_number':287,'multiline':False]
['text':' throw new IllegalArgumentException("Illegal character in rule descriptor");','line_number':300,'multiline':False]
['text':' we have the base value, so set it','line_number':307,'multiline':False]
['text':' if we stopped the previous loop on a slash, we're','line_number':310,'multiline':False]
['text':' now parsing the rule's radix.  Again, accumulate digits','line_number':311,'multiline':False]
['text':' in tempValue, skip punctuation, stop on a > mark, and','line_number':312,'multiline':False]
['text':' throw an exception on anything else','line_number':313,'multiline':False]
['text':' throw new IllegalArgumentException("Illegal character is rule descriptor");','line_number':329,'multiline':False]
['text':' tempValue now contain's the rule's radix.  Set it','line_number':336,'multiline':False]
['text':' accordingly, and recalculate the rule's exponent','line_number':337,'multiline':False]
['text':' throw new IllegalArgumentException("Rule can't have radix of 0");','line_number':340,'multiline':False]
['text':' if we stopped the previous loop on a > sign, then continue','line_number':347,'multiline':False]
['text':' for as long as we still see > signs.  For each one,','line_number':348,'multiline':False]
['text':' decrement the exponent (unless the exponent is already 0).','line_number':349,'multiline':False]
['text':' If we see another character before reaching the end of','line_number':350,'multiline':False]
['text':' the descriptor, that's also a syntax error.','line_number':351,'multiline':False]
['text':' throw new IllegalArgumentException("Illegal character in rule descriptor");','line_number':358,'multiline':False]
['text':' else use the default base value for now.','line_number':390,'multiline':False]
['text':' finally, if the rule body begins with an apostrophe, strip it off','line_number':392,'multiline':False]
['text':' (this is generally used to put whitespace at the beginning of','line_number':393,'multiline':False]
['text':' a rule's rule text)','line_number':394,'multiline':False]
['text':' return the description with all the stuff we've just waded through','line_number':399,'multiline':False]
['text':' stripped off the front.  It now contains just the rule body.','line_number':400,'multiline':False]
['text':' return description;','line_number':401,'multiline':False]
['text':'*
* Searches the rule's rule text for the substitution tokens,
* creates the substitutions, and removes the substitution tokens
* from the rule's rule text.
* @param owner The rule set containing this rule
* @param predecessor The rule preseding this one in "owners" rule list
* @param ownersOwner The RuleBasedFormat that owns this rule
','line_number':404,'multiline':True]
['text':' Small optimization. There is no need to create a redundant NullSubstitution.','line_number':424,'multiline':False]
['text':'*
* Searches the rule's rule text for the first substitution token,
* creates a substitution based on it, and removes the token from
* the rule's rule text.
* @param owner The rule set containing this rule
* @param predecessor The rule preceding this one in the rule set's
* rule list
* @param ownersOwner The RuleBasedNumberFormat that owns this rule
* @return The newly-created substitution.  This is never null; if
* the rule text doesn't contain any substitution tokens, this will
* be a NullSubstitution.
','line_number':455,'multiline':True]
['text':' search the rule's rule text for the first two characters of','line_number':474,'multiline':False]
['text':' a substitution token','line_number':475,'multiline':False]
['text':' if we didn't find one, create a null substitution positioned','line_number':479,'multiline':False]
['text':' at the end of the rule text','line_number':480,'multiline':False]
['text':' special-case the ">>>" token, since searching for the > at the','line_number':485,'multiline':False]
['text':' end will actually find the > in the middle','line_number':486,'multiline':False]
['text':' otherwise the substitution token ends with the same character','line_number':490,'multiline':False]
['text':' it began with','line_number':491,'multiline':False]
['text':' special case for '<%foo<<'','line_number':495,'multiline':False]
['text':' ordinals use "=#,##0==%abbrev=" as their rule.  Notice that the '==' in the middle','line_number':497,'multiline':False]
['text':' occurs because of the juxtaposition of two different rules.  The check for '<' is a hack','line_number':498,'multiline':False]
['text':' to get around this.  Having the duplicate at the front would cause problems with','line_number':499,'multiline':False]
['text':' rules like "<<%" to format, say, percents...','line_number':500,'multiline':False]
['text':' if we don't find the end of the token (i.e., if we're on a single,','line_number':505,'multiline':False]
['text':' unmatched token character), create a null substitution positioned','line_number':506,'multiline':False]
['text':' at the end of the rule','line_number':507,'multiline':False]
['text':' if we get here, we have a real substitution token (or at least','line_number':512,'multiline':False]
['text':' some text bounded by substitution token characters).  Use','line_number':513,'multiline':False]
['text':' makeSubstitution() to create the right kind of substitution','line_number':514,'multiline':False]
['text':' remove the substitution from the rule text','line_number':520,'multiline':False]
['text':'*
 * Sets the rule's base value, and causes the radix and exponent
 * to be recalculated.  This is used during construction when we
 * don't know the rule's base value until after it's been
 * constructed.  It should be used at any other time.
 * @param The new base value for the rule.
 ','line_number':526,'multiline':True]
['text':' set the base value','line_number':536,'multiline':False]
['text':' if this isn't a special rule, recalculate the radix and exponent','line_number':540,'multiline':False]
['text':' (the radix always defaults to 10; if it's supposed to be something','line_number':541,'multiline':False]
['text':' else, it's cleaned up by the caller and the exponent is','line_number':542,'multiline':False]
['text':' recalculated again-- the only function that does this is','line_number':543,'multiline':False]
['text':' NFRule.parseRuleDescriptor() )','line_number':544,'multiline':False]
['text':' this function gets called on a fully-constructed rule whose','line_number':548,'multiline':False]
['text':' description didn't specify a base value.  This means it','line_number':549,'multiline':False]
['text':' has substitutions, and some substitutions hold on to copies','line_number':550,'multiline':False]
['text':' of the rule's divisor.  Fix their copies of the divisor.','line_number':551,'multiline':False]
['text':' if this is a special rule, its radix and exponent are basically','line_number':559,'multiline':False]
['text':' ignored.  Set them to "safe" default values','line_number':560,'multiline':False]
['text':'*
* This calculates the rule's exponent based on its radix and base
* value.  This will be the highest power the radix can be raised to
* and still produce a result less than or equal to the base value.
','line_number':566,'multiline':True]
['text':' since the log of 0, or the log base 0 of something, causes an','line_number':574,'multiline':False]
['text':' error, declare the exponent in these cases to be 0 (we also','line_number':575,'multiline':False]
['text':' deal with the special-rule identifiers here)','line_number':576,'multiline':False]
['text':' we get rounding error in some cases-- for example, log 1000 / log 10','line_number':581,'multiline':False]
['text':' gives us 1.9999999996 instead of 2.  The extra logic here is to take','line_number':582,'multiline':False]
['text':' that into account','line_number':583,'multiline':False]
['text':'*
 * Searches the rule's rule text for any of the specified strings.
 * @return The index of the first match in the rule's rule text
 * (i.e., the first substring in the rule's rule text that matches
 * _any_ of the strings in "strings").  If none of the strings in
 * "strings" is found in the rule's rule text, returns -1.
 ','line_number':592,'multiline':True]
['text':'-----------------------------------------------------------------------','line_number':612,'multiline':False]
['text':' boilerplate','line_number':613,'multiline':False]
['text':'-----------------------------------------------------------------------','line_number':614,'multiline':False]
['text':'*
* Tests two rules for equality.
* @param that The rule to compare this one against
* @return True is the two rules are functionally equivalent
','line_number':629,'multiline':True]
['text':'*
* Returns a textual representation of the rule.  This won't
* necessarily be the same as the description that this rule
* was created with, but it will produce the same result.
* @return A textual description of the rule
','line_number':645,'multiline':True]
['text':' for a normal rule, write out its base value, and if the radix is','line_number':670,'multiline':False]
['text':' something other than 10, write out the radix (with the preceding','line_number':671,'multiline':False]
['text':' slash, of course).  Then calculate the expected exponent and if','line_number':672,'multiline':False]
['text':' if isn't the same as the actual exponent, write an appropriate','line_number':673,'multiline':False]
['text':' number of > signs.  Finally, terminate the whole thing with','line_number':674,'multiline':False]
['text':' a colon.','line_number':675,'multiline':False]
['text':' if the rule text begins with a space, write an apostrophe','line_number':690,'multiline':False]
['text':' (whitespace after the rule descriptor is ignored; the','line_number':691,'multiline':False]
['text':' apostrophe is used to make the whitespace significant)','line_number':692,'multiline':False]
['text':' now, write the rule's rule text, inserting appropriate','line_number':697,'multiline':False]
['text':' substitution tokens in the appropriate places','line_number':698,'multiline':False]
['text':' and finally, top the whole thing off with a semicolon and','line_number':714,'multiline':False]
['text':' return the result','line_number':715,'multiline':False]
['text':'-----------------------------------------------------------------------','line_number':725,'multiline':False]
['text':' formatting','line_number':726,'multiline':False]
['text':'-----------------------------------------------------------------------','line_number':727,'multiline':False]
['text':'*
* Formats the number, and inserts the resulting text into
* toInsertInto.
* @param number The number being formatted
* @param toInsertInto The string where the resultant text should
* be inserted
* @param pos The position in toInsertInto where the resultant text
* should be inserted
','line_number':729,'multiline':True]
['text':' first, insert the rule's rule text into toInsertInto at the','line_number':741,'multiline':False]
['text':' specified position, then insert the results of the substitutions','line_number':742,'multiline':False]
['text':' into the right places in toInsertInto (notice we do the','line_number':743,'multiline':False]
['text':' substitutions in reverse order so that the offsets don't get','line_number':744,'multiline':False]
['text':' messed up)','line_number':745,'multiline':False]
['text':'*
* Formats the number, and inserts the resulting text into
* toInsertInto.
* @param number The number being formatted
* @param toInsertInto The string where the resultant text should
* be inserted
* @param pos The position in toInsertInto where the resultant text
* should be inserted
','line_number':774,'multiline':True]
['text':' first, insert the rule's rule text into toInsertInto at the','line_number':786,'multiline':False]
['text':' specified position, then insert the results of the substitutions','line_number':787,'multiline':False]
['text':' into the right places in toInsertInto','line_number':788,'multiline':False]
['text':' [again, we have two copies of this routine that do the same thing','line_number':789,'multiline':False]
['text':' so that we don't sacrifice precision in a long by casting it','line_number':790,'multiline':False]
['text':' to a double]','line_number':791,'multiline':False]
['text':' We're in a fractional rule, and we have to match the NumeratorSubstitution behavior.','line_number':806,'multiline':False]
['text':' 2.3 can become 0.2999999999999998 for the fraction due to rounding errors.','line_number':807,'multiline':False]
['text':'*
* Used by the owning rule set to determine whether to invoke the
* rollback rule (i.e., whether this rule or the one that precedes
* it in the rule set's list should be used to format the number)
* @param The number being formatted
* @return True if the rule set should use the rule that precedes
* this one in its list; false if it should use this rule
','line_number':828,'multiline':True]
['text':' we roll back if the rule contains a modulus substitution,','line_number':839,'multiline':False]
['text':' the number being formatted is an even multiple of the rule's','line_number':840,'multiline':False]
['text':' divisor, and the rule's base value is NOT an even multiple','line_number':841,'multiline':False]
['text':' of its divisor','line_number':842,'multiline':False]
['text':' In other words, if the original description had','line_number':843,'multiline':False]
['text':'    100: << hundred[ >>];','line_number':844,'multiline':False]
['text':' that expands into','line_number':845,'multiline':False]
['text':'    100: << hundred;','line_number':846,'multiline':False]
['text':'    101: << hundred >>;','line_number':847,'multiline':False]
['text':' internally.  But when we're formatting 200, if we use the rule','line_number':848,'multiline':False]
['text':' at 101, which would normally apply, we get "two hundred zero".','line_number':849,'multiline':False]
['text':' To prevent this, we roll back and use the rule at 100 instead.','line_number':850,'multiline':False]
['text':' This is the logic that makes this happen: the rule at 101 has','line_number':851,'multiline':False]
['text':' a modulus substitution, its base value isn't an even multiple','line_number':852,'multiline':False]
['text':' of 100, and the value we're trying to format _is_ an even','line_number':853,'multiline':False]
['text':' multiple of 100.  This is called the "rollback rule."','line_number':854,'multiline':False]
['text':'-----------------------------------------------------------------------','line_number':862,'multiline':False]
['text':' parsing','line_number':863,'multiline':False]
['text':'-----------------------------------------------------------------------','line_number':864,'multiline':False]
['text':'*
* Attempts to parse the string with this rule.
* @param text The string being parsed
* @param parsePosition On entry, the value is ignored and assumed to
* be 0. On exit, this has been updated with the position of the first
* character not consumed by matching the text against this rule
* (if this rule doesn't match the text at all, the parse position
* if left unchanged (presumably at 0) and the function returns
* new Long(0)).
* @param isFractionRule True if this rule is contained within a
* fraction rule set.  This is only used if the rule has no
* substitutions.
* @return If this rule matched the text, this is the rule's base value
* combined appropriately with the results of parsing the substitutions.
* If nothing matched, this is new Long(0) and the parse position is
* left unchanged.  The result will be an instance of Long if the
* result is an integer and Double otherwise.  The result is never null.
','line_number':866,'multiline':True]
['text':'new char[len+1];','line_number':889,'multiline':False]
['text':'delete[] buf;','line_number':894,'multiline':False]
['text':' internally we operate on a copy of the string being parsed','line_number':906,'multiline':False]
['text':' (because we're going to change it) and use our own ParsePosition','line_number':907,'multiline':False]
['text':' check to see whether the text before the first substitution','line_number':914,'multiline':False]
['text':' matches the text at the beginning of the string being','line_number':915,'multiline':False]
['text':' parsed.  If it does, strip that off the front of workText;','line_number':916,'multiline':False]
['text':' otherwise, dump out with a mismatch','line_number':917,'multiline':False]
['text':' commented out because ParsePosition doesn't have error index in 1.1.x','line_number':942,'multiline':False]
['text':' restored for ICU4C port','line_number':943,'multiline':False]
['text':' If you match this, don't try to perform any calculations on it.','line_number':949,'multiline':False]
['text':' If you match this, don't try to perform any calculations on it.','line_number':955,'multiline':False]
['text':' this is the fun part.  The basic guts of the rule-matching','line_number':961,'multiline':False]
['text':' logic is matchToDelimiter(), which is called twice.  The first','line_number':962,'multiline':False]
['text':' time it searches the input string for the rule text BETWEEN','line_number':963,'multiline':False]
['text':' the substitutions and tries to match the intervening text','line_number':964,'multiline':False]
['text':' in the input string with the first substitution.  If that','line_number':965,'multiline':False]
['text':' succeeds, it then calls it again, this time to look for the','line_number':966,'multiline':False]
['text':' rule text after the second substitution and to match the','line_number':967,'multiline':False]
['text':' intervening input text against the second substitution.','line_number':968,'multiline':False]
['text':'','line_number':969,'multiline':False]
['text':' For example, say we have a rule that looks like this:','line_number':970,'multiline':False]
['text':'    first << middle >> last;','line_number':971,'multiline':False]
['text':' and input text that looks like this:','line_number':972,'multiline':False]
['text':'    first one middle two last','line_number':973,'multiline':False]
['text':' First we use stripPrefix() to match "first " in both places and','line_number':974,'multiline':False]
['text':' strip it off the front, leaving','line_number':975,'multiline':False]
['text':'    one middle two last','line_number':976,'multiline':False]
['text':' Then we use matchToDelimiter() to match " middle " and try to','line_number':977,'multiline':False]
['text':' match "one" against a substitution.  If it's successful, we now','line_number':978,'multiline':False]
['text':' have','line_number':979,'multiline':False]
['text':'    two last','line_number':980,'multiline':False]
['text':' We use matchToDelimiter() a second time to match " last" and','line_number':981,'multiline':False]
['text':' try to match "two" against a substitution.  If "two" matches','line_number':982,'multiline':False]
['text':' the substitution, we have a successful parse.','line_number':983,'multiline':False]
['text':'','line_number':984,'multiline':False]
['text':' Since it's possible in many cases to find multiple instances','line_number':985,'multiline':False]
['text':' of each of these pieces of rule text in the input string,','line_number':986,'multiline':False]
['text':' we need to try all the possible combinations of these','line_number':987,'multiline':False]
['text':' locations.  This prevents us from prematurely declaring a mismatch,','line_number':988,'multiline':False]
['text':' and makes sure we match as much input text as we can.','line_number':989,'multiline':False]
['text':' our partial parse result starts out as this rule's base','line_number':997,'multiline':False]
['text':' value.  If it finds a successful match, matchToDelimiter()','line_number':998,'multiline':False]
['text':' will compose this in some way with what it gets back from','line_number':999,'multiline':False]
['text':' the substitution, giving us a new partial parse result','line_number':1000,'multiline':False]
['text':' if we got a successful match (or were trying to match a','line_number':1009,'multiline':False]
['text':' null substitution), pp is now pointing at the first unmatched','line_number':1010,'multiline':False]
['text':' character.  Take note of that, and try matchToDelimiter()','line_number':1011,'multiline':False]
['text':' on the input text again','line_number':1012,'multiline':False]
['text':' the second matchToDelimiter() will compose our previous','line_number':1020,'multiline':False]
['text':' partial result with whatever it gets back from its','line_number':1021,'multiline':False]
['text':' substitution if there's a successful match, giving us','line_number':1022,'multiline':False]
['text':' a real result','line_number':1023,'multiline':False]
['text':' if we got a successful match on this second','line_number':1030,'multiline':False]
['text':' matchToDelimiter() call, update the high-water mark','line_number':1031,'multiline':False]
['text':' and result (if necessary)','line_number':1032,'multiline':False]
['text':' commented out because ParsePosition doesn't have error index in 1.1.x','line_number':1040,'multiline':False]
['text':' restored for ICU4C port','line_number':1041,'multiline':False]
['text':' commented out because ParsePosition doesn't have error index in 1.1.x','line_number':1049,'multiline':False]
['text':' restored for ICU4C port','line_number':1050,'multiline':False]
['text':' keep trying to match things until the outer matchToDelimiter()','line_number':1056,'multiline':False]
['text':' call fails to make a match (each time, it picks up where it','line_number':1057,'multiline':False]
['text':' left off the previous time)','line_number':1058,'multiline':False]
['text':' update the caller's ParsePosition with our high-water mark','line_number':1064,'multiline':False]
['text':' (i.e., it now points at the first character this function','line_number':1065,'multiline':False]
['text':' didn't match-- the ParsePosition is therefore unchanged if','line_number':1066,'multiline':False]
['text':' we didn't match anything)','line_number':1067,'multiline':False]
['text':' commented out because ParsePosition doesn't have error index in 1.1.x','line_number':1069,'multiline':False]
['text':' restored for ICU4C port','line_number':1070,'multiline':False]
['text':' this is a hack for one unusual condition: Normally, whether this','line_number':1075,'multiline':False]
['text':' rule belong to a fraction rule set or not is handled by its','line_number':1076,'multiline':False]
['text':' substitutions.  But if that rule HAS NO substitutions, then','line_number':1077,'multiline':False]
['text':' we have to account for it here.  By definition, if the matching','line_number':1078,'multiline':False]
['text':' rule in a fraction rule set has no substitutions, its numerator','line_number':1079,'multiline':False]
['text':' is 1, and so the result is the reciprocal of its base value.','line_number':1080,'multiline':False]
['text':' ??? do we need to worry if it is a long or a double?','line_number':1086,'multiline':False]
['text':'*
* This function is used by parse() to match the text being parsed
* against a possible prefix string.  This function
* matches characters from the beginning of the string being parsed
* to characters from the prospective prefix.  If they match, pp is
* updated to the first character not matched, and the result is
* the unparsed part of the string.  If they don't match, the whole
* string is returned, and pp is left unchanged.
* @param text The string being parsed
* @param prefix The text to match against
* @param pp On entry, ignored and assumed to be 0.  On exit, points
* to the first unmatched character (assuming the whole prefix matched),
* or is unchanged (if the whole prefix didn't match).
* @return If things match, this is the unparsed part of "text";
* if they didn't match, this is "text".
','line_number':1089,'multiline':True]
['text':' if the prefix text is empty, dump out without doing anything','line_number':1108,'multiline':False]
['text':' use prefixLength() to match the beginning of','line_number':1111,'multiline':False]
['text':' "text" against "prefix".  This function returns the','line_number':1112,'multiline':False]
['text':' number of characters from "text" that matched (or 0 if','line_number':1113,'multiline':False]
['text':' we didn't match the whole prefix)','line_number':1114,'multiline':False]
['text':' Memory allocation error.','line_number':1116,'multiline':False]
['text':' if we got a successful match, update the parse position','line_number':1120,'multiline':False]
['text':' and strip the prefix off of "text"','line_number':1121,'multiline':False]
['text':'*
* Used by parse() to match a substitution and any following text.
* "text" is searched for instances of "delimiter".  For each instance
* of delimiter, the intervening text is tested to see whether it
* matches the substitution.  The longest match wins.
* @param text The string being parsed
* @param startPos The position in "text" where we should start looking
* for "delimiter".
* @param baseValue A partial parse result (often the rule's base value),
* which is combined with the result from matching the substitution
* @param delimiter The string to search "text" for.
* @param pp Ignored and presumed to be 0 on entry.  If there's a match,
* on exit this will point to the first unmatched character.
* @param sub If we find "delimiter" in "text", this substitution is used
* to match the text between the beginning of the string and the
* position of "delimiter."  (If "delimiter" is the empty string, then
* this function just matches against this substitution and updates
* everything accordingly.)
* @param upperBound When matching the substitution, it will only
* consider rules with base values lower than this value.
* @return If there's a match, this is the result of composing
* baseValue with the result of matching the substitution.  Otherwise,
* this is new Long(0).  It's never null.  If the result is an integer,
* this will be an instance of Long; otherwise, it's an instance of
* Double.
*
* !!! note {dlf} in point of fact, in the java code the caller always converts
* the result to a double, so we might as well return one.
','line_number':1128,'multiline':True]
['text':' if "delimiter" contains real (i.e., non-ignorable) text, search','line_number':1168,'multiline':False]
['text':' it for "delimiter" beginning at "start".  If that succeeds, then','line_number':1169,'multiline':False]
['text':' use "sub"'s doParse() method to match the text before the','line_number':1170,'multiline':False]
['text':' instance of "delimiter" we just found.','line_number':1171,'multiline':False]
['text':'Memory allocation error.','line_number':1173,'multiline':False]
['text':' use findText() to search for "delimiter".  It returns a two-','line_number':1179,'multiline':False]
['text':' element array: element 0 is the position of the match, and','line_number':1180,'multiline':False]
['text':' element 1 is the number of characters that matched','line_number':1181,'multiline':False]
['text':' "delimiter".','line_number':1182,'multiline':False]
['text':' if findText() succeeded, isolate the text preceding the','line_number':1186,'multiline':False]
['text':' match, and use "sub" to match that text','line_number':1187,'multiline':False]
['text':' if the substitution could match all the text up to','line_number':1201,'multiline':False]
['text':' where we found "delimiter", then this function has','line_number':1202,'multiline':False]
['text':' a successful match.  Bump the caller's parse position','line_number':1203,'multiline':False]
['text':' to point to the first character after the text','line_number':1204,'multiline':False]
['text':' that matches "delimiter", and return the result','line_number':1205,'multiline':False]
['text':' we got from parsing the substitution.','line_number':1206,'multiline':False]
['text':' commented out because ParsePosition doesn't have error index in 1.1.x','line_number':1212,'multiline':False]
['text':' restored for ICU4C port','line_number':1213,'multiline':False]
['text':' if we didn't match the substitution, search for another','line_number':1222,'multiline':False]
['text':' copy of "delimiter" in "text" and repeat the loop if','line_number':1223,'multiline':False]
['text':' we find it','line_number':1224,'multiline':False]
['text':' if we make it here, this was an unsuccessful match, and we','line_number':1228,'multiline':False]
['text':' leave pp unchanged and return 0','line_number':1229,'multiline':False]
['text':' if "delimiter" is empty, or consists only of ignorable characters','line_number':1233,'multiline':False]
['text':' (i.e., is semantically empty), thwe we obviously can't search','line_number':1234,'multiline':False]
['text':' for "delimiter".  Instead, just use "sub" to parse as much of','line_number':1235,'multiline':False]
['text':' "text" as possible.','line_number':1236,'multiline':False]
['text':' try to match the whole string against the substitution','line_number':1245,'multiline':False]
['text':' if there's a successful match (or it's a null','line_number':1255,'multiline':False]
['text':' substitution), update pp to point to the first','line_number':1256,'multiline':False]
['text':' character we didn't match, and pass the result from','line_number':1257,'multiline':False]
['text':' sub.doParse() on through to the caller','line_number':1258,'multiline':False]
['text':' commented out because ParsePosition doesn't have error index in 1.1.x','line_number':1263,'multiline':False]
['text':' restored for ICU4C port','line_number':1264,'multiline':False]
['text':' and if we get to here, then nothing matched, so we return','line_number':1268,'multiline':False]
['text':' 0 and leave pp alone','line_number':1269,'multiline':False]
['text':'*
* Used by stripPrefix() to match characters.  If lenient parse mode
* is off, this just calls startsWith().  If lenient parse mode is on,
* this function uses CollationElementIterators to match characters in
* the strings (only primary-order differences are significant in
* determining whether there's a match).
* @param str The string being tested
* @param prefix The text we're hoping to see at the beginning
* of "str"
* @return If "prefix" is found at the beginning of "str", this
* is the number of characters in "str" that were matched (this
* isn't necessarily the same as the length of "prefix" when matching
* text with a collator).  If there's no match, this is 0.
','line_number':1274,'multiline':True]
['text':' if we're looking for an empty prefix, it obviously matches','line_number':1291,'multiline':False]
['text':' zero characters.  Just go ahead and return 0.','line_number':1292,'multiline':False]
['text':' go through all this grief if we're in lenient-parse mode','line_number':1298,'multiline':False]
['text':' Check if non-lenient rule finds the text before call lenient parsing','line_number':1300,'multiline':False]
['text':' get the formatter's collator and use it to create two','line_number':1304,'multiline':False]
['text':' collation element iterators, one over the target string','line_number':1305,'multiline':False]
['text':' and another over the prefix (right now, we'll throw an','line_number':1306,'multiline':False]
['text':' exception if the collator we get back from the formatter','line_number':1307,'multiline':False]
['text':' isn't a RuleBasedCollator, because RuleBasedCollator defines','line_number':1308,'multiline':False]
['text':' the CollationElementIterator protocol.  Hopefully, this','line_number':1309,'multiline':False]
['text':' will change someday.)','line_number':1310,'multiline':False]
['text':' Check for memory allocation error.','line_number':1318,'multiline':False]
['text':' The original code was problematic.  Consider this match:','line_number':1326,'multiline':False]
['text':' prefix = "fifty-"','line_number':1327,'multiline':False]
['text':' string = " fifty-7"','line_number':1328,'multiline':False]
['text':' The intent is to match string up to the '7', by matching 'fifty-' at position 1','line_number':1329,'multiline':False]
['text':' in the string.  Unfortunately, we were getting a match, and then computing where','line_number':1330,'multiline':False]
['text':' the match terminated by rematching the string.  The rematch code was using as an','line_number':1331,'multiline':False]
['text':' initial guess the substring of string between 0 and prefix.length.  Because of','line_number':1332,'multiline':False]
['text':' the leading space and trailing hyphen (both ignorable) this was succeeding, leaving','line_number':1333,'multiline':False]
['text':' the position before the hyphen in the string.  Recursing down, we then parsed the','line_number':1334,'multiline':False]
['text':' remaining string '-7' as numeric.  The resulting number turned out as 43 (50 - 7).','line_number':1335,'multiline':False]
['text':' This was not pretty, especially since the string "fifty-7" parsed just fine.','line_number':1336,'multiline':False]
['text':'','line_number':1337,'multiline':False]
['text':' We have newer APIs now, so we can use calls on the iterator to determine what we','line_number':1338,'multiline':False]
['text':' matched up to.  If we terminate because we hit the last element in the string,','line_number':1339,'multiline':False]
['text':' our match terminates at this length.  If we terminate because we hit the last element','line_number':1340,'multiline':False]
['text':' in the target, our match terminates at one before the element iterator position.','line_number':1341,'multiline':False]
['text':' match collation elements between the strings','line_number':1343,'multiline':False]
['text':' skip over ignorable characters in the target string','line_number':1348,'multiline':False]
['text':' skip over ignorable characters in the prefix','line_number':1354,'multiline':False]
['text':' dlf: move this above following test, if we consume the','line_number':1360,'multiline':False]
['text':' entire target, aren't we ok even if the source was also','line_number':1361,'multiline':False]
['text':' entirely consumed?','line_number':1362,'multiline':False]
['text':' if skipping over ignorables brought to the end of','line_number':1364,'multiline':False]
['text':' the prefix, we DID match: drop out of the loop','line_number':1365,'multiline':False]
['text':' if skipping over ignorables brought us to the end','line_number':1370,'multiline':False]
['text':' of the target string, we didn't match and return 0','line_number':1371,'multiline':False]
['text':' match collation elements from the two strings','line_number':1376,'multiline':False]
['text':' (considering only primary differences).  If we','line_number':1377,'multiline':False]
['text':' get a mismatch, dump out and return 0','line_number':1378,'multiline':False]
['text':' otherwise, advance to the next character in each string','line_number':1383,'multiline':False]
['text':' and loop (we drop out of the loop when we exhaust','line_number':1384,'multiline':False]
['text':' collation elements in the prefix)','line_number':1385,'multiline':False]
['text':' back over character that we don't want to consume;','line_number':1394,'multiline':False]
['text':'----------------------------------------------------------------','line_number':1402,'multiline':False]
['text':' JDK 1.2-specific API call','line_number':1403,'multiline':False]
['text':' return strIter.getOffset();','line_number':1404,'multiline':False]
['text':'----------------------------------------------------------------','line_number':1405,'multiline':False]
['text':' JDK 1.1 HACK (take out for 1.2-specific code)','line_number':1406,'multiline':False]
['text':' if we make it to here, we have a successful match.  Now we','line_number':1408,'multiline':False]
['text':' have to find out HOW MANY characters from the target string','line_number':1409,'multiline':False]
['text':' matched the prefix (there isn't necessarily a one-to-one','line_number':1410,'multiline':False]
['text':' mapping between collation elements and characters).','line_number':1411,'multiline':False]
['text':' In JDK 1.2, there's a simple getOffset() call we can use.','line_number':1412,'multiline':False]
['text':' In JDK 1.1, on the other hand, we have to go through some','line_number':1413,'multiline':False]
['text':' ugly contortions.  First, use the collator to compare the','line_number':1414,'multiline':False]
['text':' same number of characters from the prefix and target string.','line_number':1415,'multiline':False]
['text':' If they're equal, we're done.','line_number':1416,'multiline':False]
['text':' if they're not equal, then we have to compare successively','line_number':1429,'multiline':False]
['text':' larger and larger substrings of the target string until we','line_number':1430,'multiline':False]
['text':' get to one that matches the prefix.  At that point, we know','line_number':1431,'multiline':False]
['text':' how many characters matched the prefix, and we can return.','line_number':1432,'multiline':False]
['text':' SHOULD NEVER GET HERE!!!','line_number':1444,'multiline':False]
['text':'----------------------------------------------------------------','line_number':1446,'multiline':False]
['text':' If lenient parsing is turned off, forget all that crap above.','line_number':1449,'multiline':False]
['text':' Just use String.startsWith() and be done with it.','line_number':1450,'multiline':False]
['text':'*
* Searches a string for another string.  If lenient parsing is off,
* this just calls indexOf().  If lenient parsing is on, this function
* uses CollationElementIterator to match characters, and only
* primary-order differences are significant in determining whether
* there's a match.
* @param str The string to search
* @param key The string to search "str" for
* @param startingAt The index into "str" where the search is to
* begin
* @return A two-element array of ints.  Element 0 is the position
* of the match, or -1 if there was no match.  Element 1 is the
* number of characters in "str" that matched (which isn't necessarily
* the same as the length of "key")
','line_number':1462,'multiline':True]
['text':' if lenient parsing is turned off, this is easy: just call','line_number':1506,'multiline':False]
['text':' String.indexOf() and we're done','line_number':1507,'multiline':False]
['text':' Check if non-lenient rule finds the text before call lenient parsing','line_number':1512,'multiline':False]
['text':' but if lenient parsing is turned ON, we've got some work ahead of us','line_number':1518,'multiline':False]
['text':'----------------------------------------------------------------','line_number':1530,'multiline':False]
['text':' JDK 1.1 HACK (take out of 1.2-specific code)','line_number':1531,'multiline':False]
['text':' in JDK 1.2, CollationElementIterator provides us with an','line_number':1533,'multiline':False]
['text':' API to map between character offsets and collation elements','line_number':1534,'multiline':False]
['text':' and we can do this by marching through the string comparing','line_number':1535,'multiline':False]
['text':' collation elements.  We can't do that in JDK 1.1.  Insted,','line_number':1536,'multiline':False]
['text':' we have to go through this horrible slow mess:','line_number':1537,'multiline':False]
['text':' basically just isolate smaller and smaller substrings of','line_number':1541,'multiline':False]
['text':' the target string (each running to the end of the string,','line_number':1542,'multiline':False]
['text':' and with the first one running from startingAt to the end)','line_number':1543,'multiline':False]
['text':' and then use prefixLength() to see if the search key is at','line_number':1544,'multiline':False]
['text':' the beginning of each substring.  This is excruciatingly','line_number':1545,'multiline':False]
['text':' slow, but it will locate the key and tell use how long the','line_number':1546,'multiline':False]
['text':' matching text was.','line_number':1547,'multiline':False]
['text':' if we make it to here, we didn't find it.  Return -1 for the','line_number':1562,'multiline':False]
['text':' location.  The length should be ignored, but set it to 0,','line_number':1563,'multiline':False]
['text':' which should be "safe"','line_number':1564,'multiline':False]
['text':'*
* Checks to see whether a string consists entirely of ignorable
* characters.
* @param str The string to test.
* @return true if the string is empty of consists entirely of
* characters that the number formatter's collator says are
* ignorable at the primary-order level.  false otherwise.
','line_number':1569,'multiline':True]
['text':' if the string is empty, we can just return true','line_number':1580,'multiline':False]
['text':' if lenient parsing is turned on, walk through the string with','line_number':1586,'multiline':False]
['text':' a collation element iterator and make sure each collation','line_number':1587,'multiline':False]
['text':' element is 0 (ignorable) at the primary level','line_number':1588,'multiline':False]
['text':' Memory allocation error check.','line_number':1597,'multiline':False]
['text':' if lenient parsing is turned off, there is no such thing as','line_number':1614,'multiline':False]
['text':' an ignorable character: return true only if the string is empty','line_number':1615,'multiline':False]
['text':' U_HAVE_RBNF ','line_number':1631,'multiline':True]
