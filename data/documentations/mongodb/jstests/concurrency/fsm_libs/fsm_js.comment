['text':' args.data = 'this' object of the state functions','line_number':19,'multiline':False]
['text':' args.db = database object','line_number':20,'multiline':False]
['text':' args.collName = collection name','line_number':21,'multiline':False]
['text':' args.cluster = connection strings for all cluster nodes (see fsm_libs/cluster.js for format)','line_number':22,'multiline':False]
['text':' args.passConnectionCache = boolean, whether to pass a connection cache to the workload states','line_number':23,'multiline':False]
['text':' args.startState = name of initial state function','line_number':24,'multiline':False]
['text':' args.states = state functions of the form','line_number':25,'multiline':False]
['text':'               { stateName: function(db, collName) { ... } }','line_number':26,'multiline':False]
['text':' args.tid = the thread identifier','line_number':27,'multiline':False]
['text':' args.transitions = transitions between state functions of the form','line_number':28,'multiline':False]
['text':'                    { stateName: { nextState1: probability,','line_number':29,'multiline':False]
['text':'                                   nextState2: ... } }','line_number':30,'multiline':False]
['text':' args.iterations = number of iterations to run the FSM for','line_number':31,'multiline':False]
['text':' We build a cache of connections that can be used in workload states. This cache','line_number':41,'multiline':False]
['text':' allows state functions to access arbitrary cluster nodes for verification checks.','line_number':42,'multiline':False]
['text':' See fsm_libs/cluster.js for the format of args.cluster.','line_number':43,'multiline':False]
['text':' In order to ensure that all operations performed by a worker thread happen on the','line_number':46,'multiline':False]
['text':' same session, we override the "_defaultSession" property of the connections in the','line_number':47,'multiline':False]
['text':' cache to be the same as the session underlying 'args.db'.','line_number':48,'multiline':False]
['text':' We may fail to connect if the continuous stepdown thread had just terminated','line_number':50,'multiline':False]
['text':' or killed a primary. We therefore use the connect() function defined in','line_number':51,'multiline':False]
['text':' network_error_and_transaction_override.js to add automatic retries to','line_number':52,'multiline':False]
['text':' connections. The override is loaded in worker_thread.js.','line_number':53,'multiline':False]
['text':' default timeout is 10 mins','line_number':67,'multiline':False]
['text':' retry on a 2 second interval','line_number':68,'multiline':False]
['text':'${','line_number':78,'multiline':False]
['text':' We set _isConfigServer=true on the Mongo connection object so','line_number':91,'multiline':False]
['text':' set_read_preference_secondary.js knows to avoid overriding the read preference as the','line_number':92,'multiline':False]
['text':' concurrency suite may be running with a 1-node CSRS.','line_number':93,'multiline':False]
['text':' We make a deep copy of 'args.data' before running the state function in a','line_number':113,'multiline':False]
['text':' transaction so that if the transaction aborts, then we haven't speculatively','line_number':114,'multiline':False]
['text':' modified the thread-local state.','line_number':115,'multiline':False]
['text':' The state function is given a Proxy object to the connection cache which','line_number':121,'multiline':False]
['text':' intercepts property accesses (e.g. `connCacheProxy.rsConns`) and causes','line_number':122,'multiline':False]
['text':' the state function to fall back to being called outside of','line_number':123,'multiline':False]
['text':' withTxnAndAutoRetry() as if an operation within the transaction had','line_number':124,'multiline':False]
['text':' failed with OperationNotSupportedInTransaction or InvalidOptions. Usage','line_number':125,'multiline':False]
['text':' of the connection cache isn't compatible with','line_number':126,'multiline':False]
['text':' `TestData.runInsideTransaction === true`. This is because the','line_number':127,'multiline':False]
['text':' withTxnAndAutoRetry() function isn't aware of transactions started','line_number':128,'multiline':False]
['text':' directly on replica set shards or the config server replica set to','line_number':129,'multiline':False]
['text':' automatically commit them and leaked transactions would stall the test','line_number':130,'multiline':False]
['text':' indefinitely.','line_number':131,'multiline':False]
['text':' Retry state functions that threw OperationNotSupportedInTransaction or','line_number':147,'multiline':False]
['text':' InvalidOptions errors outside of a transaction. Rethrow any other error.','line_number':148,'multiline':False]
['text':' e.isNotSupported added by check_for_operation_not_supported_in_transaction.js','line_number':149,'multiline':False]
['text':' Null out the workload connection cache and perform garbage collection to clean up,','line_number':164,'multiline':False]
['text':' i.e., close, the open connections.','line_number':165,'multiline':False]
['text':' doc = document of the form','line_number':172,'multiline':False]
['text':'       { nextState1: probability, nextState2: ... }','line_number':173,'multiline':False]
['text':' randVal = a value on the interval [0, 1)','line_number':174,'multiline':False]
['text':' returns a state, weighted by its probability,','line_number':175,'multiline':False]
['text':'    assuming randVal was chosen randomly by the caller','line_number':176,'multiline':False]
['text':' weights = [ 0.25, 0.5, 0.25 ]','line_number':184,'multiline':False]
['text':' => accumulated = [ 0.25, 0.75, 1 ]','line_number':185,'multiline':False]
['text':' Scale the random value by the sum of the weights','line_number':196,'multiline':False]
['text':' ~ U[0, sum)','line_number':197,'multiline':False]
['text':' Find the state corresponding to randVal','line_number':199,'multiline':False]
