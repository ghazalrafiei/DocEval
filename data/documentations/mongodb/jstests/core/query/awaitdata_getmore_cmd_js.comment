['text':' Test the awaitData flag for the find/getMore commands.','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' @tags: [','line_number':3,'multiline':False]
['text':'   # The test runs commands that are not allowed with security token: getDefaultRWConcern.','line_number':4,'multiline':False]
['text':'   not_allowed_with_signed_security_token,','line_number':5,'multiline':False]
['text':'   # This test attempts to perform a getMore command and find it using the currentOp command. The','line_number':6,'multiline':False]
['text':'   # former operation may be routed to a secondary in the replica set, whereas the latter must be','line_number':7,'multiline':False]
['text':'   # routed to the primary.','line_number':8,'multiline':False]
['text':'   assumes_read_preference_unchanged,','line_number':9,'multiline':False]
['text':'   requires_capped,','line_number':10,'multiline':False]
['text':'   requires_getmore,','line_number':11,'multiline':False]
['text':'   uses_multiple_connections,','line_number':12,'multiline':False]
['text':'   uses_parallel_shell,','line_number':13,'multiline':False]
['text':' ]','line_number':14,'multiline':False]
['text':' Create a non-capped collection with 10 documents.','line_number':22,'multiline':False]
['text':' Find with tailable flag set should fail for a non-capped collection.','line_number':31,'multiline':False]
['text':' Should also fail in the non-capped case if both the tailable and awaitData flags are set.','line_number':36,'multiline':False]
['text':' With a non-existent collection, should succeed but return no data and a closed cursor.','line_number':42,'multiline':False]
['text':' Create a capped collection with 10 documents.','line_number':51,'multiline':False]
['text':' collection name must match parallel shell task.','line_number':53,'multiline':False]
['text':' GetMore should succeed if query has awaitData but no maxTimeMS is supplied.','line_number':59,'multiline':False]
['text':' Should also succeed if maxTimeMS is supplied on the original find.','line_number':71,'multiline':False]
['text':' Check that we can set up a tailable cursor over the capped collection.','line_number':85,'multiline':False]
['text':' Check that tailing the capped collection with awaitData eventually ends up returning an empty','line_number':93,'multiline':False]
['text':' batch after hitting the timeout.','line_number':94,'multiline':False]
['text':' Issue getMore until we get an empty batch of results.','line_number':103,'multiline':False]
['text':' Keep issuing getMore until we get an empty batch after the timeout expires.','line_number':115,'multiline':False]
['text':' Repeat the test, this time tailing the oplog rather than a user-created capped collection.','line_number':133,'multiline':False]
['text':' The oplog tailing in not possible on mongos.','line_number':134,'multiline':False]
['text':' Test filtered inserts while writing to a capped collection.','line_number':185,'multiline':False]
['text':' Find with a filter which doesn't match any documents in the collection.','line_number':186,'multiline':False]
['text':' The code below will test for the tailable, awaitData cursor being awaken once a matching','line_number':199,'multiline':False]
['text':' document is inserted and expects the document to be returned in the next batch. However, the','line_number':200,'multiline':False]
['text':' logic without waiting for the timeout in order to receive the data only works if the read','line_number':201,'multiline':False]
['text':' concern is not set to majority. The reason for this is that the primary node will notify the','line_number':202,'multiline':False]
['text':' waiting cursor on document being inserted on its node and not on the majority of nodes.','line_number':203,'multiline':False]
['text':' However, since the read concern is set to majority, the awaken cursor won't find the newly','line_number':204,'multiline':False]
['text':' inserted document, as at that time it is present on the primary only. Therefore it will be','line_number':205,'multiline':False]
['text':' waiting till the timeout. In order to avoid the waiting we stop running this test if read','line_number':206,'multiline':False]
['text':' concern majority.','line_number':207,'multiline':False]
['text':' Test that a getMore command on a tailable, awaitData cursor does not return a new batch to','line_number':217,'multiline':False]
['text':' the user if a document was inserted, but it did not match the filter.','line_number':218,'multiline':False]
['text':' Signal to the original shell that the parallel shell has successfully started.','line_number':220,'multiline':False]
['text':' Wait for the parent shell to start watching for the next document.','line_number':223,'multiline':False]
['text':' Now write a non-matching document to the collection.','line_number':231,'multiline':False]
['text':' Make sure the getMore has not ended after a while.','line_number':234,'multiline':False]
['text':' Now write a matching document to wake it up.','line_number':243,'multiline':False]
['text':' Wait until we receive confirmation that the parallel shell has started.','line_number':249,'multiline':False]
['text':' Now issue a getMore which will match the parallel shell's currentOp filter, signalling it to','line_number':252,'multiline':False]
['text':' write a non-matching document into the collection. Confirm that we do not receive this','line_number':253,'multiline':False]
['text':' document and that we subsequently time out.','line_number':254,'multiline':False]
