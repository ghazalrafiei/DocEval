['text':'*
 * Tests basic index bounds generation and planning for $** indexes.
 *
 * Does not support stepdowns because the test issues getMores, which the stepdown/kill_primary
 * passthroughs will reject.
 *
 * @tags: [
 *   assumes_balancer_off,
 *   does_not_support_stepdowns,
 *   # Some expected index bounds require the multi-planner to choose the optimal plan that uses a
 *   # more efficient CWI (non-generic). Sharded suites could mislead the multi-planner to choose a
 *   # worse CWI because the planner may not run sufficient trials if there's no enough docs in some
 *   # shard.
 *   assumes_unsharded_collection,
 * ]
 ','line_number':1,'multiline':True]
['text':' Asserts that the given cursors produce identical result sets.','line_number':26,'multiline':False]
['text':' Template document which defines the 'schema' of the documents in the test collection.','line_number':38,'multiline':False]
['text':' Insert a set of documents into the collection, based on the template document and populated','line_number':45,'multiline':False]
['text':' with an increasing sequence of values. This is to ensure that the range of values present for','line_number':46,'multiline':False]
['text':' each field in the dataset is not entirely homogeneous.','line_number':47,'multiline':False]
['text':' For sharded passthroughs, we need to know the number of shards occupied by the collection.','line_number':64,'multiline':False]
['text':' Set of operations which will be applied to each field in the index in turn. If the 'bounds'','line_number':67,'multiline':False]
['text':' property is null, this indicates that the operation is not supported by $** indexes. The','line_number':68,'multiline':False]
['text':' 'subpathBounds' property indicates whether the bounds for '$_path' are supposed to contain','line_number':69,'multiline':False]
['text':' all subpaths rather than a single point-interval, i.e. ["path.to.field.", "path.to.field/").','line_number':70,'multiline':False]
['text':' In principle we could have tighter bounds for this. See SERVER-36765.','line_number':93,'multiline':False]
['text':' Operations for compound wildcard indexes.','line_number':98,'multiline':False]
['text':' Queries cannot use the compound wildcard index.','line_number':134,'multiline':False]
['text':' The bounds on '$_path' will always include a point-interval on the path, i.e.','line_number':145,'multiline':False]
['text':' ["path.to.field", "path.to.field"]. If 'subpathBounds' is 'true' for this','line_number':146,'multiline':False]
['text':' operation, then we add bounds that include all subpaths as well, i.e.','line_number':147,'multiline':False]
['text':' ["path.to.field.", "path.to.field/")','line_number':148,'multiline':False]
['text':' {$_path: pathBounds, path.to.field: [[computed bounds]]}','line_number':153,'multiline':False]
['text':' Given a keyPattern and (optional) pathProjection, this function builds a $** index on the','line_number':164,'multiline':False]
['text':' collection and then tests each of the match expression in the 'operationList' on each indexed','line_number':165,'multiline':False]
['text':' field in turn. The 'expectedPaths' argument lists the set of paths which we expect to have','line_number':166,'multiline':False]
['text':' been indexed based on the spec; this function will confirm that only the appropriate paths','line_number':167,'multiline':False]
['text':' are present in the $** index. Finally, for each match expression it will perform a rooted-$or','line_number':168,'multiline':False]
['text':' with one predicate on each expected path, and a rooted $and over all predicates and paths.','line_number':169,'multiline':False]
['text':' The 'expectedPaths' argument is the set of paths which we expect to be indexed, based on','line_number':175,'multiline':False]
['text':' the keyPattern and projection. Make sure that the caller has provided this argument.','line_number':176,'multiline':False]
['text':' Verify the expected behaviour for every combination of path and operator.','line_number':179,'multiline':False]
['text':' Build up a list of operations that will later be used to test rooted $or.','line_number':181,'multiline':False]
['text':' Explain the query, and determine whether an indexed solution is available.','line_number':189,'multiline':False]
['text':' If we expect the current path to have been excluded based on the $** keyPattern','line_number':193,'multiline':False]
['text':' and projection, or if the current operation is not supported by $** indexes,','line_number':194,'multiline':False]
['text':' confirm that no indexed solution was found.','line_number':195,'multiline':False]
['text':' Verify that the winning plan uses the $** index with the expected bounds.','line_number':205,'multiline':False]
['text':' Verify that the results obtained from the $** index are identical to a COLLSCAN.','line_number':210,'multiline':False]
['text':' We must explicitly hint the wildcard index, because we also sort on {_id: 1} to','line_number':211,'multiline':False]
['text':' ensure that both result sets are in the same order.','line_number':212,'multiline':False]
['text':' Push the query into the $or and $and predicate arrays.','line_number':216,'multiline':False]
['text':' If the current operation could not use the $** index, skip to the next op.','line_number':221,'multiline':False]
['text':' Perform a rooted $or for this operation across all indexed fields; for instance:','line_number':226,'multiline':False]
['text':' {$or: [{a: {$eq: 25}}, {'b.c': {$eq: 25}}, {'b.d.e': {$eq: 25}}]}.','line_number':227,'multiline':False]
['text':' Obtain the list of index bounds from each individual IXSCAN stage across all shards.','line_number':230,'multiline':False]
['text':' We should find that each branch of the $or has used a separate $** sub-index. In the','line_number':234,'multiline':False]
['text':' sharded passthroughs, we expect to have 'orQueryBounds' on each shard.','line_number':235,'multiline':False]
['text':' Verify that the results obtained from the $** index are identical to a COLLSCAN.','line_number':243,'multiline':False]
['text':' Perform an $and for this operation across all indexed fields; for instance:','line_number':247,'multiline':False]
['text':' {$and: [{a: {$gte: 50}}, {'b.c': {$gte: 50}}, {'b.d.e': {$gte: 50}}]}.','line_number':248,'multiline':False]
['text':' Extract information about the rejected plans. We should have one IXSCAN for each $**','line_number':252,'multiline':False]
['text':' candidate that wasn't the winner. Before SERVER-36521 banned them for $** indexes, a','line_number':253,'multiline':False]
['text':' number of AND_SORTED plans would also be generated here; we search for these in order','line_number':254,'multiline':False]
['text':' to verify that no such plans now exist.','line_number':255,'multiline':False]
['text':' Confirm that no AND_SORTED plans were generated.','line_number':264,'multiline':False]
['text':' We should find that one of the available $** subindexes has been chosen as the','line_number':267,'multiline':False]
['text':' winner, and all other candidate $** indexes are present in 'rejectedPlans'.','line_number':268,'multiline':False]
['text':' Verify that each of the IXSCANs have the expected bounds and $_path key.','line_number':272,'multiline':False]
['text':' {$_path: ["['path.to.field', 'path.to.field']"], path.to.field: [[bounds]]}','line_number':274,'multiline':False]
['text':' Verify that the results obtained from the $** index are identical to a COLLSCAN.','line_number':280,'multiline':False]
['text':' Given a compound wildcard key pattern, runs tests similar to 'runWildcardIndexTest()'.','line_number':286,'multiline':False]
['text':' Verify the expected behaviour for every combination of path and operator.','line_number':292,'multiline':False]
['text':' Explain the query, and determine whether an indexed solution is available.','line_number':296,'multiline':False]
['text':' If the current operation is not supported by $** indexes, confirm that no indexed','line_number':300,'multiline':False]
['text':' solution was found.','line_number':301,'multiline':False]
['text':' Verify that the winning plan uses the compound wildcard index with the expected bounds.','line_number':311,'multiline':False]
['text':' Use "tojson()" in order to make ordering of fields matter.','line_number':313,'multiline':False]
['text':' Verify that the results obtained from the compound wildcard index are identical to a','line_number':319,'multiline':False]
['text':' COLLSCAN. We must explicitly hint the wildcard index, because we also sort on {_id: 1} to','line_number':320,'multiline':False]
['text':' ensure that both result sets are in the same order.','line_number':321,'multiline':False]
['text':' Test a $** index that indexes the entire document.','line_number':328,'multiline':False]
['text':' Test a $** index on a single subtree.','line_number':331,'multiline':False]
['text':' Test a $** index which includes a subset of paths.','line_number':336,'multiline':False]
['text':' Test a $** index which excludes a subset of paths.','line_number':342,'multiline':False]
['text':' Test a compound wildcard index.','line_number':348,'multiline':False]
