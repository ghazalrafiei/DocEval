['text':'*
 * Tests that indexes are distinguished by their "signature", i.e. the combination of parameters
 * which uniquely identify an index. Multiple indexes can be created on the same key pattern if
 * their signature parameters differ.
 *
 * @tags: [
 *   # Asserts on the 'numIndexesAfter' part of the createIndexes command response.
 *   assumes_no_implicit_index_creation,
 *   requires_non_retryable_writes,
 *   # The test that attempts to create an index with partialFilterExpression:
 *   # {a: {$gt: 0, $lt: 10}, b: "BLAH"}} depends on a functionality fixed in 7.3.
 *   requires_fcv_73,
 * ]
 ','line_number':1,'multiline':True]
['text':' The key pattern and spec against which other indexes will be compared during createIndex.','line_number':23,'multiline':False]
['text':' Helper function to build an index spec based on 'initialIndexSpec'.','line_number':34,'multiline':False]
['text':' Runs a createIndex command with the given key pattern and options. Then verifies that the','line_number':39,'multiline':False]
['text':' number of indexes changed in accordance with the 'expectedChange' argument.','line_number':40,'multiline':False]
['text':' In a sharded cluster, the results from all shards are returned in cmdRes.raw.','line_number':45,'multiline':False]
['text':' Runs a createIndex command with the given key pattern and options. Then verifies that no index','line_number':54,'multiline':False]
['text':' was built, since an index with the same signature already existed.','line_number':55,'multiline':False]
['text':' Runs a createIndex command with the given key pattern and options. Then verifies that a new','line_number':60,'multiline':False]
['text':' index was built by checking that the index count increased by 1.','line_number':61,'multiline':False]
['text':' Creates an index on {a: 1}.','line_number':66,'multiline':False]
['text':' Verifies that we can create a second index on {a: 1} with 'sparse':true.','line_number':69,'multiline':False]
['text':' Verifies that we can create two more indexes with 'unique': true. We do not run these tests on','line_number':72,'multiline':False]
['text':' sharded passthroughs, since unique indexes cannot be created on a hash-sharded collection.','line_number':73,'multiline':False]
['text':' Verifies that we can create an index on {a: 1} with 'unique':true.','line_number':75,'multiline':False]
['text':' Verifies that we can create an index on {a: 1} with 'unique':true and 'sparse':true.','line_number':78,'multiline':False]
['text':' Creates an index on {a: 1} with an explicit collation and a partialFilterExpression.','line_number':88,'multiline':False]
['text':' Verifies that an index can be built on the same fields if the collation is different.','line_number':91,'multiline':False]
['text':' Verifies that an index can be built on the same fields if the partialFilterExpression is','line_number':95,'multiline':False]
['text':' different.','line_number':96,'multiline':False]
['text':' Verifies that partialFilterExpressions are normalized before being compared. Below, the','line_number':102,'multiline':False]
['text':' expression is written differently than in the previous index, but the two are considered','line_number':103,'multiline':False]
['text':' equivalent. If we attempt to build this index with the same name as the initial index, the','line_number':104,'multiline':False]
['text':' operation will return success but will not actually do any work, since the requested index','line_number':105,'multiline':False]
['text':' already exists.','line_number':106,'multiline':False]
['text':' Verifies that attempting to build the dupe index with a different name will result in an error.','line_number':111,'multiline':False]
['text':' We take collation into account when checking partialFilterExpression equivalence.','line_number':116,'multiline':False]
['text':' In this instance we are using a case-insensitive collation, and so the predicate {b: "BLAH"} will','line_number':117,'multiline':False]
['text':' match the same set of documents as {b: "blah"} in the initial index's partialFilterExpression.','line_number':118,'multiline':False]
['text':' We do not currently sort MatchExpression trees by leaf predicate value in cases where two or more','line_number':123,'multiline':False]
['text':' branches are otherwise identical, meaning that we cannot identify certain trivial cases where two','line_number':124,'multiline':False]
['text':' partialFilterExpressions are equivalent.','line_number':125,'multiline':False]
['text':' TODO SERVER-47661: provide a way for MatchExpression trees to be sorted in a consistent manner in','line_number':126,'multiline':False]
['text':' cases where two or more otherwise identical branches differ only by leaf predicate value.','line_number':127,'multiline':False]
['text':' Changes the predicate order of the $and and re-run the createIndex. We would expect this index to','line_number':134,'multiline':False]
['text':' be considered identical to the existing index, and for the createIndex to return no-op success.','line_number':135,'multiline':False]
['text':' Instead, we throw an exception because the catalog believes we are trying to create an index with','line_number':136,'multiline':False]
['text':' the same name but a different partialFilterExpression.','line_number':137,'multiline':False]
['text':' Verifies that non-signature options cannot distinguish a new index from an existing index.','line_number':142,'multiline':False]
['text':' Builds a new, basic index on {a: 1}, since some of the options we intend to test are not','line_number':145,'multiline':False]
['text':' compatible with the partialFilterExpression on the existing {a: 1} indexes.','line_number':146,'multiline':False]
['text':' Verifies that none of the options in the list are sufficient to uniquely identify an index,','line_number':149,'multiline':False]
['text':' meaning that we cannot create a new index on 'keyPattern' by changing any of these fields.','line_number':150,'multiline':False]
['text':' Builds a base wildcard index.','line_number':161,'multiline':False]
['text':' Verifies that two indexes which includes or excludes a same field can be created.','line_number':164,'multiline':False]
['text':' Verifies the behavior that _id is excluded by default and so the {_id: 0, a: 1} path projection','line_number':168,'multiline':False]
['text':' equals to the {a: 1} path projection and thus the index with {_id: 0, a: 1} path projection can','line_number':169,'multiline':False]
['text':' not be created.','line_number':170,'multiline':False]
['text':' Verifies that the index with the {_id: 1, a: 1} path projection has the different index signature','line_number':176,'multiline':False]
['text':' from the {a: 1} path projection and thus can be created.','line_number':177,'multiline':False]
['text':' Verifies that the {_id: 0, a: 0} path projection is same as {a: 0} and thus an index with the','line_number':180,'multiline':False]
['text':' projection can not be created.','line_number':181,'multiline':False]
['text':' Verifies that the {a: 0, _id: 1} path projection is different from {a: 0} and an index with the','line_number':187,'multiline':False]
['text':' projection can be created.','line_number':188,'multiline':False]
['text':' Verifies that an index with sub fields for a field which is included in another wildcard path','line_number':191,'multiline':False]
['text':' projection can be created.','line_number':192,'multiline':False]
['text':' Verifies that indexes with a path projection which is identical after normalization can not be','line_number':196,'multiline':False]
['text':' created.','line_number':197,'multiline':False]
['text':' Verifies that two indexes which includes or excludes a same field can be created.','line_number':222,'multiline':False]
['text':' Verifies that the {_id: 0, a: 0} path projection is same as {a: 0} and thus an index with the','line_number':226,'multiline':False]
['text':' projection can not be created.','line_number':227,'multiline':False]
