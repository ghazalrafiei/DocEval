['text':'*
 * Test creating and using partial indexes, on a time-series collection.
 *
 * @tags: [
 *   # Explain of a resolved view must be executed by mongos.
 *   directly_against_shardsvrs_incompatible,
 *   # Refusing to run a test that issues an aggregation command with explain because it may return
 *   # incomplete results if interrupted by a stepdown.
 *   does_not_support_stepdowns,
 *   # We need a timeseries collection.
 *   requires_timeseries,
 * ]
 ','line_number':1,'multiline':True]
['text':' If the collection is sharded, expect an implicitly-created index on time. It will appear','line_number':44,'multiline':False]
['text':' differently in listIndexes depending on whether you look at the time-series collection or','line_number':45,'multiline':False]
['text':' the buckets collection.','line_number':46,'multiline':False]
['text':' TODO SERVER-77112 fix this logic once this issue is fixed.','line_number':47,'multiline':False]
['text':' When enabled, the {meta: 1, time: 1} index gets built by default on the time-series','line_number':60,'multiline':False]
['text':' bucket collection.','line_number':61,'multiline':False]
['text':' In bucket A, some but not all documents match the partial filter.','line_number':80,'multiline':False]
['text':' In bucket B, no documents match the partial filter.','line_number':87,'multiline':False]
['text':' In bucket C, every document matches the partial filter.','line_number':94,'multiline':False]
['text':' Expected partialFilterExpression to be an object.','line_number':104,'multiline':False]
['text':' Test creating and using a partial index.','line_number':107,'multiline':False]
['text':' Make sure the {a: 1} index was considered for this query.','line_number':111,'multiline':False]
['text':' If scan is not present, check rejected plans','line_number':115,'multiline':False]
['text':' Both plans should have an "IXSCAN" stage and one stage should scan the index on','line_number':121,'multiline':False]
['text':' the 'a' field.','line_number':122,'multiline':False]
['text':' Make sure the query results match a collection-scan plan.','line_number':139,'multiline':False]
['text':' Test some predicates on a metric field.','line_number':152,'multiline':False]
['text':' Query predicate mentions partialFilterExpression exactly.','line_number':155,'multiline':False]
['text':' The extra predicate on 'a' is necessary for the multiplanner to think an {a: 1} index is','line_number':156,'multiline':False]
['text':' relevant.','line_number':157,'multiline':False]
['text':' Query predicate is a subset of partialFilterExpression.','line_number':159,'multiline':False]
['text':' Test some predicates on the time field.','line_number':178,'multiline':False]
['text':'  TODO SERVER-77112 we can change this to assert.commandWorkedOrFailed, since the indexes','line_number':180,'multiline':False]
['text':'  made by 'createIndex' should be identical to the implicit index made by','line_number':181,'multiline':False]
['text':'  'shardCollection'.','line_number':182,'multiline':False]
['text':' Drop the index, so it doesn't interfere with other tests.','line_number':214,'multiline':False]
['text':' Check that partialFilterExpression can use a mixture of metadata, time, and measurement fields,','line_number':226,'multiline':False]
['text':' and that this is translated to the bucket-level predicate we expect.','line_number':227,'multiline':False]
['text':' Meta predicates are pushed down verbatim.','line_number':244,'multiline':False]
['text':' $gt on time creates a bound on the max time.','line_number':249,'multiline':False]
['text':' We also have a bound on the min time, derived from bucketMaxSpanSeconds.','line_number':251,'multiline':False]
['text':' The min time is also encoded in the _id, so we have a bound on that as','line_number':253,'multiline':False]
['text':' well.','line_number':254,'multiline':False]
['text':' $gt on a non-time field can only bound the control.max for that field.','line_number':258,'multiline':False]
['text':' Test how partialFilterExpression interacts with collation.','line_number':277,'multiline':False]
['text':' Recreate the collection with a collation.','line_number':279,'multiline':False]
['text':' Queries on the collection use the collection's collation by default.','line_number':290,'multiline':False]
['text':' Specifying a collation and partialFilterExpression together fails, even if the collation','line_number':308,'multiline':False]
['text':' matches the collection's default collation.','line_number':309,'multiline':False]
['text':' The default collation is also numeric, so this index is equivalent to the previous.','line_number':322,'multiline':False]
['text':' Verify that the index contains what we expect.','line_number':328,'multiline':False]
['text':' Verify that the index is used when possible.','line_number':332,'multiline':False]
['text':' a < "25" can use the index, since the collations match.','line_number':350,'multiline':False]
['text':' Likewise a < "24" can use the index.','line_number':366,'multiline':False]
['text':' a < "30" can't use the index; it's not a subset.','line_number':382,'multiline':False]
['text':' a < "100" also can't use the index, because according to the numeric collation, "20" < "100".','line_number':398,'multiline':False]
['text':' Note that if we were using a simple collation we'd get the opposite outcome: "100" < "20",','line_number':399,'multiline':False]
['text':' because it would compare strings lexicographically instead of numerically.','line_number':400,'multiline':False]
['text':' Test which types of predicates are allowed, and test that the bucket-level','line_number':417,'multiline':False]
['text':' partialFilterExpression is what we expect.','line_number':418,'multiline':False]
['text':' A trivial, empty predicate is fine.','line_number':438,'multiline':False]
['text':' It doesn't seem useful but it's allowed on a normal collection.','line_number':439,'multiline':False]
['text':' Comparison with non-scalar.','line_number':444,'multiline':False]
['text':' Always-false predicate on time (which is always a Date).','line_number':450,'multiline':False]
['text':' Scalar $eq is equivalent to a conjunction of $lte and $gte.','line_number':454,'multiline':False]
['text':' Comparisons with null/missing are not implemented. These would be slightly more complicated','line_number':465,'multiline':False]
['text':' because {$eq: null} actually means "null, or missing, or undefined",','line_number':466,'multiline':False]
['text':' while {$_internalExprEq: null} only matches null.','line_number':467,'multiline':False]
['text':' Regex queries are not allowed, but {$eq: /.../} is a simple scalar match, not a regex query.','line_number':472,'multiline':False]
['text':' The min/max for a field is present iff at least one event in the bucket has that field.','line_number':484,'multiline':False]
['text':' So {$exists: true} queries can be mapped to the min/max for that field.','line_number':485,'multiline':False]
['text':' This can be used as an alternative to sparse indexes.','line_number':486,'multiline':False]
['text':' However, this means we can't push down {$exists: false}.  A bucket where the min/max for a','line_number':496,'multiline':False]
['text':' field is non-missing may contain a mixture of missing / non-missing, so we can't exclude it','line_number':497,'multiline':False]
['text':' on the basis of the control fields.','line_number':498,'multiline':False]
['text':' $or on metadata, metric, or both.','line_number':501,'multiline':False]
['text':' If any argument of the $or is disallowed, we report the error even when an always-true','line_number':525,'multiline':False]
['text':' predicate appears in it.','line_number':526,'multiline':False]
['text':' $in on metadata is fine.','line_number':529,'multiline':False]
['text':' $in on a metric is slightly complicated. $in is equivalent to a disjunction of {a: _}.','line_number':535,'multiline':False]
['text':' In a typical case this is the same as a disjunction of $eq:','line_number':536,'multiline':False]
['text':' Since {a: null} is not implemented, neither is {$in: [null]}.','line_number':562,'multiline':False]
['text':' {a: {$in: [/abc/]}} is equivalent to {a: /abc/} which executes the regex, and is not allowed.','line_number':564,'multiline':False]
['text':' Predicates on time are pushed down, and also some extra predicates are inferred.','line_number':567,'multiline':False]
['text':' These inferred predicates don't necessarily result in fewer buckets being indexed:','line_number':568,'multiline':False]
['text':' we're just following the same rules for createIndex that we use when optimizing a query.','line_number':569,'multiline':False]
