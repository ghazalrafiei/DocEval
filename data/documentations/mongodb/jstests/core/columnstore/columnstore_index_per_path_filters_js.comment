['text':'*
 * Testing of just the query layer's integration for columnar index when filters are used that
 * might be pushed down into the column scan stage.
 *
 * @tags: [
 *   # Column store indexes are still under a feature flag.
 *   featureFlagColumnstoreIndexes,
 *   # Runs explain on an aggregate command which is only compatible with readConcern local.
 *   assumes_read_concern_unchanged,
 *   # Columnstore tests set server parameters to disable columnstore query planning heuristics -
 *   # 1) server parameters are stored in-memory only so are not transferred onto the recipient,
 *   # 2) server parameters may not be set in stepdown passthroughs because it is a command that may
 *   #      return different values after a failover
 *   tenant_migration_incompatible,
 *   does_not_support_stepdowns,
 *   not_allowed_with_signed_security_token,
 * ]
 ','line_number':1,'multiline':True]
['text':' Order of the elements within the result and 'expected' is not significant for 'resultsEq' but','line_number':33,'multiline':False]
['text':' use small datasets to make the test failures more readable.','line_number':34,'multiline':False]
['text':' Sanity check that without filters, the cursors on other columns are advanced correctly.','line_number':42,'multiline':False]
['text':' Checks matching on top-level path that contains scalars and arrays.','line_number':61,'multiline':False]
['text':' vals: 42, arrInfo: <empty>','line_number':64,'multiline':False]
['text':' vals: [0,42], arrInfo: "["','line_number':65,'multiline':False]
['text':' vals: [0,0,0,0,42], arrInfo: "[[|2]"','line_number':66,'multiline':False]
['text':' vals: [42], arrInfo: "[o1"','line_number':67,'multiline':False]
['text':' vals: [0,0,42], arrInfo: "[|1o"','line_number':68,'multiline':False]
['text':' vals: [0,0,42], arrInfo: "[[|1]o[o]"','line_number':69,'multiline':False]
['text':' Projecting "_id" out and instead projecting as the first (in alphabetical order) column a','line_number':71,'multiline':False]
['text':' non-existing field helps to flush out bugs with incorrect lookup of the filtered columns','line_number':72,'multiline':False]
['text':' among all columns involved in the query.','line_number':73,'multiline':False]
['text':' vals: <empty>, arrInfo: <empty>','line_number':85,'multiline':False]
['text':' vals: [42, 0], arrInfo: "[["','line_number':86,'multiline':False]
['text':' vals: [42,0,0,0,0], arrInfo: "[[|2]"','line_number':87,'multiline':False]
['text':' vals: [42,0], arrInfo: "[o["','line_number':88,'multiline':False]
['text':' vals: [42], arrInfo: "[[|]o"','line_number':89,'multiline':False]
['text':' vals: [42,42,42], arrInfo: "[[|1]["','line_number':90,'multiline':False]
['text':' vals: [0,42,42,42,42,42], arrInfo: "[|[|[|[|]|]|]["','line_number':94,'multiline':False]
['text':' Projecting "_id" out and instead projecting as the first (in alphabetical order) column a','line_number':96,'multiline':False]
['text':' non-existing field helps to flush out bugs with incorrect lookup of the filtered columns','line_number':97,'multiline':False]
['text':' among all columns involved in the query.','line_number':98,'multiline':False]
['text':' Checks matching on sub-path that contains scalars and arrays.','line_number':108,'multiline':False]
['text':' vals: 42, arrInfo: <empty>','line_number':111,'multiline':False]
['text':' vals: [0,42], arrInfo: "{{["','line_number':112,'multiline':False]
['text':' vals: [0,0,42], arrInfo: "{{[[|1]"','line_number':113,'multiline':False]
['text':' vals: [0,42], arrInfo: "{["','line_number':114,'multiline':False]
['text':' vals: [0,0,42], arrInfo: "{[o{[[|1]"','line_number':115,'multiline':False]
['text':' vals: [0,42], arrInfo: "{[1|+1"','line_number':116,'multiline':False]
['text':' vals: [0,0,0,42], arrInfo: "[|{{[[|1]]"','line_number':120,'multiline':False]
['text':' vals: [0,42], arrInfo: "[o+1{{["','line_number':124,'multiline':False]
['text':' vals: [0,0,42], arrInfo: "[{[o{[|]+1{["','line_number':128,'multiline':False]
['text':' vals: [0,42], arrInfo: "[{[[|]"','line_number':129,'multiline':False]
['text':' vals: [0,42], arrInfo: "[[{[|]]{{["','line_number':130,'multiline':False]
['text':' vals: [0,42], arrInfo: "[{{[|]{{["','line_number':131,'multiline':False]
['text':' Checks matching on sub-path that contains scalars and arrays.','line_number':146,'multiline':False]
['text':' vals: <empty>, arrInfo: <empty>','line_number':149,'multiline':False]
['text':' vals: [0,42], arrInfo: "{{[|["','line_number':150,'multiline':False]
['text':' vals: [0,42], arrInfo: "{[|["','line_number':151,'multiline':False]
['text':' vals: [42], arrInfo: "[1["','line_number':152,'multiline':False]
['text':' Check matching of empty arrays which are treated as values.','line_number':163,'multiline':False]
['text':' NB: expressions for comparing to whole non-empty arrays aren't split into per-path filters.','line_number':164,'multiline':False]
['text':'[{_id: 0}, {_id: 1}, {_id: 2}],','line_number':176,'multiline':False]
['text':' Check matching of empty objects which are treated as values.','line_number':181,'multiline':False]
['text':' NB: expressions for comparing to whole non-empty objects aren't split into per-path filters.','line_number':182,'multiline':False]
['text':' Check that a single filtered column correctly handles matching, no-matching and missing values','line_number':199,'multiline':False]
['text':' when moving the cursor.','line_number':200,'multiline':False]
['text':' Check zig-zagging of two filters. We cannot assert through a JS test that the cursors for the','line_number':224,'multiline':False]
['text':' filtered columns are advanced as described here in the comments, but the test attempts to','line_number':225,'multiline':False]
['text':' exercise various match/no-match/missing combinations of values across columns.','line_number':226,'multiline':False]
['text':' start by iterating x','line_number':229,'multiline':False]
['text':' seek into y and match! - continue iterating on x','line_number':230,'multiline':False]
['text':' seeking into y skips to n:3','line_number':231,'multiline':False]
['text':' iterating on y','line_number':232,'multiline':False]
['text':' seek into x and match! - continue iterating on y','line_number':233,'multiline':False]
['text':' seek into x skips to n:6','line_number':234,'multiline':False]
['text':' seek into y but no match - iterate on y','line_number':235,'multiline':False]
['text':' seek into x but no match - iterate on x','line_number':236,'multiline':False]
['text':' skipped by x','line_number':237,'multiline':False]
['text':' seek into y and match!','line_number':238,'multiline':False]
['text':' Adding into the projection specification non-existent fields doesn't change the output but','line_number':240,'multiline':False]
['text':' helps to flush out bugs with incorrect indexing of filtered paths among all others.','line_number':241,'multiline':False]
['text':' Check zig-zagging of three filters.','line_number':251,'multiline':False]
['text':' x','line_number':254,'multiline':False]
['text':' x->y->z','line_number':255,'multiline':False]
['text':' z->x','line_number':256,'multiline':False]
['text':' x','line_number':257,'multiline':False]
['text':' x->y','line_number':258,'multiline':False]
['text':' y','line_number':259,'multiline':False]
['text':' match! ->y','line_number':260,'multiline':False]
['text':' match! ->y','line_number':261,'multiline':False]
['text':' y->z->x','line_number':262,'multiline':False]
['text':' x','line_number':263,'multiline':False]
['text':' match!','line_number':264,'multiline':False]
['text':' Adding into the projection specification non-existent fields doesn't change the output but','line_number':266,'multiline':False]
['text':' helps to flush out bugs with incorrect indexing of filtered paths among all others.','line_number':267,'multiline':False]
['text':' Check projection of filtered columns.','line_number':277,'multiline':False]
['text':' Check correctness when have both per-path and residual filters.','line_number':293,'multiline':False]
['text':' {$exists: false} causes the residual filter','line_number':305,'multiline':False]
['text':' Check translation of MQL comparison match expressions.','line_number':312,'multiline':False]
['text':' MatchExpression::LT','line_number':330,'multiline':False]
['text':' MatchExpression::GT','line_number':337,'multiline':False]
['text':' MatchExpression::LTE','line_number':344,'multiline':False]
['text':' MatchExpression::GTE','line_number':351,'multiline':False]
['text':' Check translation of MQL bitwise match expressions.','line_number':359,'multiline':False]
['text':' MatchExpression::BITS_ALL_SET','line_number':378,'multiline':False]
['text':' MatchExpression::BITS_ALL_CLEAR','line_number':385,'multiline':False]
['text':' MatchExpression::BITS_ANY_SET','line_number':392,'multiline':False]
['text':' MatchExpression::BITS_ANY_CLEAR','line_number':399,'multiline':False]
['text':' Check translation of MQL {$exists: true}. The tests provide coverage for various cell and array','line_number':407,'multiline':False]
['text':' info structures which would need to be handled if we push {$exists: true} into the column_scan','line_number':408,'multiline':False]
['text':' stage's per-path filters.','line_number':409,'multiline':False]
['text':' Cells that have no sub-paths. NB: empty objects are treated as values by columnstore index.','line_number':427,'multiline':False]
['text':' the first value is too deep','line_number':435,'multiline':False]
['text':' the first value is too deep','line_number':436,'multiline':False]
['text':' the first value is too deep','line_number':437,'multiline':False]
['text':' the first value is too deep','line_number':438,'multiline':False]
['text':' Cells with no values but with sub-paths.','line_number':442,'multiline':False]
['text':' the first object is too deep','line_number':450,'multiline':False]
['text':' the first object is too deep','line_number':451,'multiline':False]
['text':' the first object is too deep','line_number':452,'multiline':False]
['text':' $exist skips object and evals to "true" on value','line_number':458,'multiline':False]
['text':' $exist skips value and evals to "true" on object','line_number':459,'multiline':False]
['text':' Check translation of MQL {$type: "null"}. NB: {$type: "null"} and {$eq: null} aren't equivalent!','line_number':466,'multiline':False]
['text':' The latter evaluates to "true" in some cases when the path is missing. Instead, matching type','line_number':467,'multiline':False]
['text':' "null" is the same as matching other scalar types, such as "double" or "string".','line_number':468,'multiline':False]
['text':' No "null" value on the path.','line_number':477,'multiline':False]
['text':' "null" value is too deep.','line_number':483,'multiline':False]
['text':' "x.y" path is missing.','line_number':488,'multiline':False]
['text':' Check translation of MQL {$type: "array"}.','line_number':502,'multiline':False]
['text':' Terminal array.','line_number':505,'multiline':False]
['text':' No terminal array.','line_number':514,'multiline':False]
['text':' There is a doubly-nested array along the path.','line_number':519,'multiline':False]
['text':' "x.y" path is missing','line_number':522,'multiline':False]
['text':' Check translation of MQL {$type: "object"}.','line_number':536,'multiline':False]
['text':' empty object is a value, no array info','line_number':539,'multiline':False]
['text':' sub-path, no array info, no values','line_number':540,'multiline':False]
['text':' terminal array: array info, no values','line_number':543,'multiline':False]
['text':' array on path: array info, no values','line_number':545,'multiline':False]
['text':' No terminal object.','line_number':548,'multiline':False]
['text':' no array info, single value','line_number':549,'multiline':False]
['text':' The object is too deep.','line_number':553,'multiline':False]
['text':' "x.y" path is missing','line_number':559,'multiline':False]
['text':' Check translation of MQL {$type: ["object", "array", "double", "null]"}.','line_number':573,'multiline':False]
['text':' Only one of the types is present at the single leaf.','line_number':576,'multiline':False]
['text':' double','line_number':577,'multiline':False]
['text':' null','line_number':578,'multiline':False]
['text':' object','line_number':579,'multiline':False]
['text':' array that contains neither object, double or null','line_number':580,'multiline':False]
['text':' Only one of the types is present on the path.','line_number':582,'multiline':False]
['text':' Neither of the types are present','line_number':588,'multiline':False]
['text':' Translation of MQL $not match expression. These tests don't check that lowering of the filter','line_number':600,'multiline':False]
['text':' with $not actually happens, they only check that whatever happens with the filters, the semantics','line_number':601,'multiline':False]
['text':' are correct. However, the dataset is such that incorrect lowering would also produce an incorrect','line_number':602,'multiline':False]
['text':' result and/or asserts in the production code.','line_number':603,'multiline':False]
['text':'','line_number':604,'multiline':False]
['text':' Notes:','line_number':605,'multiline':False]
['text':' 1. We cannot test {x: {$ne: 2, $ne: 42}} via JS because the client drops duplicated fields.','line_number':606,'multiline':False]
['text':'    A conjunction of $not can be tested with $and.','line_number':607,'multiline':False]
['text':' 2. {x: {$not: {$gte: 5}}} isn't the same as {x: {$lt: 5}}; as it doesn't do type bracketing and','line_number':608,'multiline':False]
['text':'    behaves differently on arrays ($lt:5 finds arrays with _an_ element less than 5, while $not of','line_number':609,'multiline':False]
['text':'    $gte finds arrays for which _all_ elements are less than 5).','line_number':610,'multiline':False]
['text':' 3. Can only negate with $not the operations listed in 'queryOperatorMap' (see','line_number':611,'multiline':False]
['text':'    matcher/expression_parser.cpp), that is {$not: {$or: [{x: 2}, {x: 42}]}} isn't allowed.','line_number':612,'multiline':False]
['text':' $ne AND a supported predicate on the same path -> lowered.','line_number':636,'multiline':False]
['text':' AND of multiple $not and a supported predicate on the same path -> lowered.','line_number':639,'multiline':False]
['text':' $ne AND a supported predicate AND an unsupported predicate -> lowered.','line_number':642,'multiline':False]
['text':' A supported predicate on a _different_ path -> not lowered.','line_number':645,'multiline':False]
['text':' if lowered, would skip n:3','line_number':647,'multiline':False]
['text':' $ne AND an unsupported predicate -> not lowered.','line_number':649,'multiline':False]
['text':' if lowered, would skip n:3','line_number':651,'multiline':False]
['text':' $not OF an unsupported predicate -> not lowered.','line_number':653,'multiline':False]
['text':' if lowered would return n:5','line_number':655,'multiline':False]
['text':' $not OF $and -> curretnly not lowered (would require supporting OR on the same path).','line_number':657,'multiline':False]
['text':' if lowered would hit 6733605','line_number':659,'multiline':False]
['text':' $not of $not -> currently not lowered (to simplify the implementation of $not lowering).','line_number':661,'multiline':False]
['text':' if lowered would also return n:5, n:6','line_number':663,'multiline':False]
['text':' $not OF a supported predicate -> lowered.','line_number':665,'multiline':False]
['text':' Two paths with $not AND-ed with supported predicates -> both are lowered.','line_number':668,'multiline':False]
['text':' Two paths with $not, but only one is AND-ed with a supported predicate.','line_number':672,'multiline':False]
['text':' if "x" is lowered would skip n:3','line_number':674,'multiline':False]
['text':' $not of $type -> lowered','line_number':676,'multiline':False]
['text':' $not of $exists (result will be empty when combined with any supported predicate) -> lowered.','line_number':680,'multiline':False]
['text':' For the documents below "x.y" doesn't exist','line_number':726,'multiline':False]
['text':' The following tests below are converted into equality (instead of $in) before execution','line_number':756,'multiline':False]
['text':' "Unsupported" in the following test means that the '$in' filter does not get pushed down into','line_number':768,'multiline':False]
['text':' the stage but will be processed as a residual predicate after the (unconditional) column scan.','line_number':769,'multiline':False]
['text':' For the documents below "x.y" doesn't exist','line_number':785,'multiline':False]
['text':' This test is converted into equality (instead of $in) before execution','line_number':794,'multiline':False]
['text':' $in in this test doesn't get pushed down, as it contains a null value.','line_number':800,'multiline':False]
['text':' $in in this test doesn't get pushed down, as it contains objects.','line_number':806,'multiline':False]
['text':' $in in this test doesn't get pushed down, as it contains an array.','line_number':812,'multiline':False]
['text':' Create a plan cache entry for a query that can use the columnstore index. Run it twice to','line_number':828,'multiline':False]
['text':' make sure that the plan cache entry is active.','line_number':829,'multiline':False]
['text':' Now run a query that is ineligible to use the columnstore index because it has an','line_number':835,'multiline':False]
['text':' equality-to-object predicate. It should not reuse the plan cache entry.','line_number':836,'multiline':False]
['text':' Create a plan cache entry for a query that can use the columnstore index. Run it twice to','line_number':851,'multiline':False]
['text':' make sure that the plan cache entry is active.','line_number':852,'multiline':False]
['text':' Now run a query that is ineligible to use the columnstore index because it has an','line_number':858,'multiline':False]
['text':' object in its $in-list. It should not reuse the plan cache entry.','line_number':859,'multiline':False]
['text':' Check match expressions that use logical AND for predicates on the same path.','line_number':865,'multiline':False]
['text':' OR isn't supported for pushing down but it shouldn't cause any problems, when nested under','line_number':914,'multiline':False]
['text':' AND (the OR term of the filter will be applied as residual).','line_number':915,'multiline':False]
['text':' Check translation of other MQL match expressions.','line_number':926,'multiline':False]
['text':' Check degenerate case with no paths.','line_number':956,'multiline':False]
['text':' While using columnar indexes doesn't guarantee a specific field ordering in the result objects,','line_number':979,'multiline':False]
['text':' we still try to provide a stable experience to the user, so we output "_id" first and other','line_number':980,'multiline':False]
['text':' fields in alphabetically ascending order.','line_number':981,'multiline':False]
['text':' Having a filter on a path that is also being projected, should not affect the order.','line_number':993,'multiline':False]
['text':' Omitting the "_id" field should not affect the order.','line_number':998,'multiline':False]
['text':' Sanity test that per-column filtering is meeting the efficiency expectations.','line_number':1004,'multiline':False]
['text':' There might be multiple columnscan stages, e.g. when running in sharded environment. We'll','line_number':1022,'multiline':False]
['text':' check the stats on the first available stage because we only care about the upper bounds to','line_number':1023,'multiline':False]
['text':' sanity check the perf and most of the test suites would have a single stage and provide the','line_number':1024,'multiline':False]
['text':' necessary coverage.','line_number':1025,'multiline':False]
['text':' When there are no missing fields, the number of "next" calls in zig-zag search algorithm is','line_number':1042,'multiline':False]
['text':' equal to the number of documents docsCount (NB: in non-filtered search the number of "next"','line_number':1043,'multiline':False]
['text':' calls is close to k*docsCount where k is the number of paths).','line_number':1044,'multiline':False]
['text':' The columns with higher selectivity should be preferred by the zig-zag search for driving the','line_number':1048,'multiline':False]
['text':' "next" calls. Due to the regularity of data in this test (if "y" matched "x" would match as','line_number':1049,'multiline':False]
['text':' well), after the first match "y" column would completely take over.','line_number':1050,'multiline':False]
['text':' We seek into each column to set up the cursors, after that seeks into _id should only happen','line_number':1053,'multiline':False]
['text':' on full match, and seeks into x or y should only happen on partial matches.','line_number':1054,'multiline':False]
