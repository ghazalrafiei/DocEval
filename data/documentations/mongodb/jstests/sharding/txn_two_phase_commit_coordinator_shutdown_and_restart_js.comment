['text':'*
 * Tests that if the coordinator goes down after it makes the decision to commit, that both the
 * stable timestamp is still able to advance on the participants and we are able to eventually
 * commit the transaction.
 *
 * This test restarts shard replica sets, so it requires a persistent storage engine.
 * @tags: [uses_transactions, uses_multi_shard_transaction, requires_persistence]
 ','line_number':1,'multiline':True]
['text':' The UUID consistency check uses connections to shards cached on the ShardingTest object, but this','line_number':10,'multiline':False]
['text':' test causes failovers on a shard, so the cached connection is not usable.','line_number':11,'multiline':False]
['text':' Since we expect prepared transactions in progress when shutting down a node, we will need to skip','line_number':14,'multiline':False]
['text':' these validation checks.','line_number':15,'multiline':False]
['text':' Start the participant replSet with one node as a priority 0 node to avoid flip flopping.','line_number':23,'multiline':False]
['text':' Create a sharded collection:','line_number':30,'multiline':False]
['text':' shard0: [-inf, 0)','line_number':31,'multiline':False]
['text':' shard1: [0, inf)','line_number':32,'multiline':False]
['text':' Build the following command as a string since we need to persist the lsid and the txnNumber','line_number':53,'multiline':False]
['text':' into the scope of the parallel shell.','line_number':54,'multiline':False]
['text':' assert.commandFailedWithCode(db.adminCommand({','line_number':55,'multiline':False]
['text':'     commitTransaction: 1,','line_number':56,'multiline':False]
['text':'     maxTimeMS: 2000 * 10,','line_number':57,'multiline':False]
['text':'     lsid: lsid,','line_number':58,'multiline':False]
['text':'     txnNumber: NumberLong(txnNumber),','line_number':59,'multiline':False]
['text':'     stmtId: NumberInt(0),','line_number':60,'multiline':False]
['text':'     autocommit: false,','line_number':61,'multiline':False]
['text':' }), ErrorCodes.MaxTimeMSExpired);','line_number':62,'multiline':False]
['text':' Start a cross shard transaction through mongos.','line_number':76,'multiline':False]
['text':' Make the commit coordination hang before writing the decision, and send commitTransaction.','line_number':99,'multiline':False]
['text':' The transaction on the participant will remain in prepare.','line_number':100,'multiline':False]
['text':' Run commit through mongos in a parallel shell. This should timeout since we have set the','line_number':103,'multiline':False]
['text':' failpoint.','line_number':104,'multiline':False]
['text':' Stop the mongods on the coordinator shard using the SIGTERM signal. We must skip validation','line_number':109,'multiline':False]
['text':' checks since we'll be shutting down a node with a prepared transaction.','line_number':110,'multiline':False]
['text':' forRestart ','line_number':111,'multiline':True]
['text':' opts ','line_number':111,'multiline':True]
['text':' Once the coordinator has gone down, do a majority write on the participant while there is a','line_number':113,'multiline':False]
['text':' prepared transaction. This will ensure that the stable timestamp is able to advance since','line_number':114,'multiline':False]
['text':' this write must be in the committed snapshot.','line_number':115,'multiline':False]
['text':' Confirm that a majority read on the secondary includes the dummy write. This would mean that','line_number':125,'multiline':False]
['text':' the stable timestamp also advanced on the secondary.','line_number':126,'multiline':False]
['text':' In order to do this read with readConcern majority, we must use afterClusterTime with causal','line_number':127,'multiline':False]
['text':' consistency enabled.','line_number':128,'multiline':False]
['text':' Restarting the coordinator will reset the fail point.','line_number':138,'multiline':False]
['text':' Now, commitTransaction should succeed.','line_number':143,'multiline':False]
['text':' TODO: SERVER-59686','line_number':152,'multiline':False]
