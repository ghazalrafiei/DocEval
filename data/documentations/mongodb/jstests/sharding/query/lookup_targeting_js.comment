['text':'
 * Test that the targeting of $lookup queries and any sub-queries works correctly.
 * @tags: [
 *   featureFlagTrackUnshardedCollectionsOnShardingCatalog,
 *   featureFlagMoveCollection,
 *   assumes_balancer_off,
 *   requires_sharding,
 *   requires_spawning_own_processes,
 *   requires_profiling,
 * ]
 ','line_number':1,'multiline':True]
['text':' Map from shard name to database connection. Used to determine which shard to read from when','line_number':28,'multiline':False]
['text':' gathering profiler output.','line_number':29,'multiline':False]
['text':' Create two sharded collections, both of which are distributed across the 3 shards.','line_number':38,'multiline':False]
['text':' Create three unsplittable collections, two of which are on the same shard.','line_number':79,'multiline':False]
['text':' Inner collection is unsplittable and not on the primary shard. Outer collection is sharded.','line_number':119,'multiline':False]
['text':' In this case, we should be merging on the shard which owns the unsplittable collection.','line_number':120,'multiline':False]
['text':'*
         * TODO SERVER-81335: The cursor against 'kShardedColl1Name' may no longer be profiled
         * once the $mergeCursors pipeline can execute it locally. If this is the case, remove
         * this assertion (here and elsewhere).
         ','line_number':129,'multiline':True]
['text':' Outer collection is unsplittable and not on the primary shard. Inner collection is sharded.','line_number':162,'multiline':False]
['text':' We should target the shard which owns the unsplittable collection.','line_number':163,'multiline':False]
['text':' Both collections are unsplittable and are located on different shards. We should merge on the','line_number':183,'multiline':False]
['text':' shard which owns the inner collection in each case.','line_number':184,'multiline':False]
['text':' Issue an aggregate featuring a $lookup whose inner collection is a view over an unsplittable','line_number':222,'multiline':False]
['text':' collection.','line_number':223,'multiline':False]
['text':' TODO SERVER-83902: We currently assert that we merge on the primary shard. Ideally, we should','line_number':224,'multiline':False]
['text':' merge on shard2, the node which owns the underlying collection. Since views are not currently','line_number':225,'multiline':False]
['text':' tracked in the sharding catalog, we default to the primary shard because there does not exist a','line_number':226,'multiline':False]
['text':' routing table entry for our view. Though there will be an entry in the routing table for the','line_number':227,'multiline':False]
['text':' underlying collection, we will not resolve the view until we issue an aggregate for the inner','line_number':228,'multiline':False]
['text':' side (by which point we've already created a distributed plan for this aggregation). Fix this so','line_number':229,'multiline':False]
['text':' that we pick shard2 as the merging node.','line_number':230,'multiline':False]
['text':' viewName ','line_number':233,'multiline':True]
['text':' viewOn ','line_number':233,'multiline':True]
['text':' pipeline ','line_number':233,'multiline':True]
['text':' Clean up the view.','line_number':258,'multiline':False]
['text':' Both collections are unsplittable and are collocated on the same shard. Test that we can do','line_number':262,'multiline':False]
['text':' SBE $lookup pushdown, regardless of which collection is on the inner side.','line_number':263,'multiline':False]
['text':' Verify the targeting behavior of $facet. In particular, we should always merge or target the','line_number':301,'multiline':False]
['text':' shard corresponding to the first inner unsplittable collection among the $lookup facet pipelines.','line_number':302,'multiline':False]
['text':' If our initial query targets a single shard and that shard is the same as the merging shard, then','line_number':398,'multiline':False]
['text':' we can target the facet to a single shard (even if we need to issue remotes reads for the inner','line_number':399,'multiline':False]
['text':' side of the first $lookup).','line_number':400,'multiline':False]
['text':' Issue an aggregate featuring two $lookup stages, where both stages' inner collections are','line_number':472,'multiline':False]
['text':' unsplittable and reside on different shards. We should always merge on the shard which owns the','line_number':473,'multiline':False]
['text':' first inner collection.','line_number':474,'multiline':False]
['text':' Issue aggregates featuring two $lookup stages: one $lookup targets an unsplittable inner','line_number':537,'multiline':False]
['text':' collection and the other targets a sharded inner collection. We should merge on the shard which','line_number':538,'multiline':False]
['text':' owns the unsplittable collection.','line_number':539,'multiline':False]
['text':' Issue aggregates featuring two $lookup stages, where the first one's inner collection is','line_number':603,'multiline':False]
['text':' unsplittable and the second one's inner collection is sharded. We should target the shard which','line_number':604,'multiline':False]
['text':' owns the unsplittable collection.','line_number':605,'multiline':False]
['text':' Issue an aggregate featuring nested $lookup stages where both inner collections are unsplittable','line_number':675,'multiline':False]
['text':' and live on different shards. The $lookup should execute on the shard which owns of the first','line_number':676,'multiline':False]
['text':' inner collection. Then, we should have several $match queries against each of the inner','line_number':677,'multiline':False]
['text':' collections.','line_number':678,'multiline':False]
['text':' Issue an aggregate featuring nested $lookup stages where the innermost collection is sharded','line_number':760,'multiline':False]
['text':' and the top level $lookup's 'from' collection is unsplittable. We should execute on the shard','line_number':761,'multiline':False]
['text':' which owns the unsplittable collection.','line_number':762,'multiline':False]
['text':' Issue an aggregate featuring nested $lookup stages where the innermost collection is','line_number':799,'multiline':False]
['text':' unsplittable, while the top level $lookup's 'from' collection is sharded.','line_number':800,'multiline':False]
['text':' Issue an aggregate featuring three levels of nested $lookups. All involved collections are','line_number':832,'multiline':False]
['text':' unsplittable, and all live on different shards. However, we expect to merge on the shard which','line_number':833,'multiline':False]
['text':' owns the top-level inner collection (in this case, shard1).','line_number':834,'multiline':False]
['text':' Set of tests which involve moving an unsplittable collection during query execution.','line_number':897,'multiline':False]
['text':' Test moving the outer collection to another shard during $lookup execution. This should','line_number':899,'multiline':False]
['text':' result in a 'QueryPlanKilled' error.','line_number':900,'multiline':False]
['text':' Add a set of 20 documents to the outer collection which are at least 1 MB in size. This','line_number':903,'multiline':False]
['text':' makes it so that the documents from the outer collection do not fit in one batch and we','line_number':904,'multiline':False]
['text':' will have to issue at least one getMore against the outer collection to continue','line_number':905,'multiline':False]
['text':' constructing the result set.','line_number':906,'multiline':False]
['text':' Establish our cursor. We should not have exhausted our cursor.','line_number':909,'multiline':False]
['text':' Move the outer collection to a different shard.','line_number':917,'multiline':False]
['text':' Subsequent getMore commands should cause our query plan to be killed because to our','line_number':926,'multiline':False]
['text':' $mergeCursor stage, it will appear as though the outer collection has been dropped.','line_number':927,'multiline':False]
['text':' Move the outer collection back to its original shard.','line_number':930,'multiline':False]
['text':' Test moving the inner collection to another shard during $lookup execution. Because the','line_number':933,'multiline':False]
['text':' move happens in between executions of the inner pipeline, the query plan should not be','line_number':934,'multiline':False]
['text':' killed. Rather, we should be able to target the inner side to the new owning shard.','line_number':935,'multiline':False]
