['text':'*
 * This is an integration test for histogram CE & statistics to ensure that we can create a
 * histogram with appropriate type counts and retrieve that histogram to estimate a simple match
 * predicate. Note that this tests predicates and histograms on several types.
 ','line_number':1,'multiline':True]
['text':' Set up collection to test a simple field path.','line_number':22,'multiline':False]
['text':' Booleans: 1 true, 2 false. ','line_number':26,'multiline':True]
['text':' Null: 3 null, 2 missing. ','line_number':30,'multiline':True]
['text':' Objects: 3. ','line_number':36,'multiline':True]
['text':' Arrays: 4 empty, 1 not. ','line_number':40,'multiline':True]
['text':' NaN ','line_number':46,'multiline':True]
['text':' Generated from the array [1, 2, 3].','line_number':64,'multiline':False]
['text':' Verify type count CE.','line_number':124,'multiline':False]
['text':' Estimate boolean counts.','line_number':128,'multiline':False]
['text':' If we hint the index {a: 1} for this query, we don't get an IndexScan plan; instead, we fail','line_number':133,'multiline':False]
['text':' to optimize. It looks like we can't test CE for this case because we only generate a','line_number':134,'multiline':False]
['text':' PhysicalScan plan.','line_number':135,'multiline':False]
['text':' verifyCEForMatch({','line_number':136,'multiline':False]
['text':'     coll,','line_number':137,'multiline':False]
['text':'     predicate: {a: {$eq: []}},','line_number':138,'multiline':False]
['text':'     expected: [','line_number':139,'multiline':False]
['text':'         {_id: 11, a: []},','line_number':140,'multiline':False]
['text':'         {_id: 12, a: []},','line_number':141,'multiline':False]
['text':'         {_id: 13, a: []},','line_number':142,'multiline':False]
['text':'         {_id: 14, a: []},','line_number':143,'multiline':False]
['text':'     ],','line_number':144,'multiline':False]
['text':'     ce: 4,','line_number':145,'multiline':False]
['text':'     hint','line_number':146,'multiline':False]
['text':' });','line_number':147,'multiline':False]
['text':' Validate estimates for non-empty arrays.','line_number':149,'multiline':False]
['text':' The plan generated in the following two cases has the following shape:','line_number':162,'multiline':False]
['text':'','line_number':163,'multiline':False]
['text':'  Filter (CE: 7)','line_number':164,'multiline':False]
['text':'  |','line_number':165,'multiline':False]
['text':'  Nested Loop Join (CE: 17)','line_number':166,'multiline':False]
['text':'  |      |','line_number':167,'multiline':False]
['text':'  |      LimitSkip (CE: 17)','line_number':168,'multiline':False]
['text':'  |      |','line_number':169,'multiline':False]
['text':'  |      Seek (CE: 17)','line_number':170,'multiline':False]
['text':'  |','line_number':171,'multiline':False]
['text':'  Unique (CE: 1)','line_number':172,'multiline':False]
['text':'  |','line_number':173,'multiline':False]
['text':'  SortedMerge (CE: 1) __','line_number':174,'multiline':False]
['text':'  |                     |','line_number':175,'multiline':False]
['text':'  Ixscan (CE: 1)   Ixscan (CE: 1)','line_number':176,'multiline':False]
['text':'  [1, 1]           [[1, 2, 3], [1, 2, 3]]','line_number':177,'multiline':False]
['text':'','line_number':178,'multiline':False]
['text':' We only care about the Ixscan estimation for now, so those nodes are the only ones we will','line_number':179,'multiline':False]
['text':' verify in this case. Based on the logs, it looks like we estimate the sargable node with both','line_number':180,'multiline':False]
['text':' intervals together, and attach this estimate to both index scans and the sorted merge node','line_number':181,'multiline':False]
['text':' above them. Therefore, we only look at the sorted merge node estimate in the test. Note that','line_number':182,'multiline':False]
['text':' the intervals are combined disjunctively.','line_number':183,'multiline':False]
['text':' We estimate an object equality predicate heuristically as the square root of the total count','line_number':210,'multiline':False]
['text':' of objects.','line_number':211,'multiline':False]
['text':' Test null predicate match.','line_number':222,'multiline':False]
['text':' Set up collection to test a more complex field path.','line_number':236,'multiline':False]
['text':' Booleans: 2 true, 1 false. ','line_number':240,'multiline':True]
['text':' Null: 1 null, 8 missing. ','line_number':244,'multiline':True]
['text':' Scalar: 2. ','line_number':254,'multiline':True]
['text':' Object: 2. ','line_number':257,'multiline':True]
['text':' Arrays: 1 empty, 2 not. ','line_number':260,'multiline':True]
['text':' Verify type count CE.','line_number':366,'multiline':False]
['text':' Test CE for histogrammable types.','line_number':370,'multiline':False]
['text':' For the two asserts below, the PathArr interval was split out of the SargableNode, and the','line_number':382,'multiline':False]
['text':' resulting index scan is estimated as a non-$elemMatch predicate.','line_number':383,'multiline':False]
['text':' This index scan matches [1, 1] only, and is estimated as such.','line_number':391,'multiline':False]
['text':' This index scan matches [nan, 3] only, and is estimated as such.','line_number':407,'multiline':False]
['text':' We estimate an object equality predicate heuristically as the square root of the total count','line_number':435,'multiline':False]
['text':' of objects.','line_number':436,'multiline':False]
['text':' Test null predicate match.','line_number':446,'multiline':False]
['text':' Set up a collection to test CE for nested arrays and non-histogrammable types in arrays.','line_number':464,'multiline':False]
['text':' Booleans. ','line_number':468,'multiline':True]
['text':' Objects. ','line_number':478,'multiline':True]
['text':' Arrays. ','line_number':486,'multiline':True]
['text':' Nulls. ','line_number':493,'multiline':True]
['text':' Mixed array type-counts. ','line_number':499,'multiline':True]
['text':' Verify type count CE. Note that for non-$elemMatch predicates, we include both array and','line_number':584,'multiline':False]
['text':' scalar type-counts, while for $elemMatch predicates, we include only array type counts in','line_number':585,'multiline':False]
['text':' our estimate.','line_number':586,'multiline':False]
['text':' Estimate boolean counts. Note that we have 6 boolean arrays; because we don't have an exact','line_number':590,'multiline':False]
['text':' count of nested true/false values in nested arrays, we estimate this as 0.5* number of arrays','line_number':591,'multiline':False]
['text':' with booleans.','line_number':592,'multiline':False]
['text':' 0.5*6 + 1','line_number':594,'multiline':False]
['text':' We estimate an object equality predicate heuristically as the square root of the total count','line_number':623,'multiline':False]
['text':' of objects.','line_number':624,'multiline':False]
['text':' We estimate an object equality predicate heuristically as the square root of the total count','line_number':650,'multiline':False]
['text':' of objects.','line_number':651,'multiline':False]
['text':' We are estimating the following predicates as two equality intervals joined by a conjunction:','line_number':676,'multiline':False]
['text':'  1. [{}, {}] - estimated as the square root of the sum of scalar and array type counts.','line_number':677,'multiline':False]
['text':'  2. [[{}], [{}]] - estimated as the square root of the count of nested arrays.','line_number':678,'multiline':False]
['text':' The disjunction selectivities are then combined via exponential backoff. This estimate can be','line_number':679,'multiline':False]
['text':' found at the union of the two index scan nodes in the plan. However, the root node estimate','line_number':680,'multiline':False]
['text':' differs due to the filter node & group by node above the union, so we directly verify the','line_number':681,'multiline':False]
['text':' estimate of the sargable nodes together.','line_number':682,'multiline':False]
['text':' Verify CE using array histogram.','line_number':714,'multiline':False]
['text':' We estimate equality to nested arrays as the square root of the total count of nested arrays.','line_number':723,'multiline':False]
['text':' In the following cases, we have two intervals:','line_number':745,'multiline':False]
['text':'  1. ["a", "a"] - This is estimated as 1 based on the array buckets.','line_number':746,'multiline':False]
['text':'  2. [["a", "b", "c"], ["a", "b", "c"]] - this is estimated as sqrt(count of nested arrays).','line_number':747,'multiline':False]
['text':' The selectivities are then combined by disjunctive exponential backoff. Once again, we can','line_number':748,'multiline':False]
['text':' find this estimate in the Union node.','line_number':749,'multiline':False]
['text':' In the following cases, we have two array intervals, each estimated as sqrt(count of nested','line_number':774,'multiline':False]
['text':' arrays), with the selectivities combined by disjunctive exponential backoff. Once again,','line_number':775,'multiline':False]
['text':' we can find this estimate in the Union node.','line_number':776,'multiline':False]
['text':' Verify null CE.','line_number':797,'multiline':False]
['text':' TODO: we only ever get a PhysicalScan plan in this case. Hinting causes optimization to','line_number':822,'multiline':False]
['text':' fail. We estimate scalar empty arrays as 1 correctly, but we also match nested empty','line_number':823,'multiline':False]
['text':' arrays- so we also count all nested empty arrays.','line_number':824,'multiline':False]
['text':' verifyCEForMatch({coll, predicate: {a: []}, expected: [','line_number':825,'multiline':False]
['text':'     {_id: 16, a: []},','line_number':826,'multiline':False]
['text':'     {_id: 17, a: [[]]},','line_number':827,'multiline':False]
['text':'     {_id: 27, a: [null, true, false, [], [1, 2, 3], ["a", "b", "c"], {a: 1}, {}]},','line_number':828,'multiline':False]
['text':' ], ce: 14, hint});','line_number':829,'multiline':False]
['text':' In the following case, we expect to count only nested empty arrays (so we estimate it as the','line_number':831,'multiline':False]
['text':' square root of the count of all nested arrays).','line_number':832,'multiline':False]
['text':' Now create histograms on the same collection for paths that don't exist on any documents.','line_number':844,'multiline':False]
['text':' Verify type count CE. Note that for non-$elemMatch preidcates, we include both array and','line_number':860,'multiline':False]
['text':' scalar type-counts, while for $elemMatch predicates, we include only array type counts in','line_number':861,'multiline':False]
['text':' our estimate.','line_number':862,'multiline':False]
['text':' Note: the hint is omitted because if we hint on a 'notAPath' index, optimization fails by','line_number':865,'multiline':False]
['text':' running out of memory.','line_number':866,'multiline':False]
['text':' Cardinality estimation will be skipped if the query is optimized using a fast path.','line_number':868,'multiline':False]
