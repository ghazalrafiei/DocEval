['text':'*
 * Tests basic functionality of pushing $lookup into the find layer.
 *
 * @tags: [requires_sharding, uses_transactions]
 ','line_number':1,'multiline':True]
['text':' Standalone cases.','line_number':24,'multiline':False]
['text':'*
 * Helper function which verifies that at least one $lookup was lowered into SBE within
 * 'explain', and that the EqLookupNode at 'eqLookupNodeIndex' chose the appropriate strategy.
 * In particular, if 'IndexedLoopJoin' was chosen, we verify that the index described by
 * 'indexKeyPattern' was chosen. Otherwise, we verify that 'NestedLoopJoin' was chosen.
 ','line_number':31,'multiline':True]
['text':' Verify that we're selecting an EQ_LOOKUP node within range.','line_number':43,'multiline':False]
['text':' Fetch the requested EQ_LOOKUP node.','line_number':48,'multiline':False]
['text':' In the classic case, verify that $lookup was not lowered into SBE. Note that we don't','line_number':98,'multiline':False]
['text':' check for the presence of $lookup agg stages because in the sharded case, $lookup will','line_number':99,'multiline':False]
['text':' not execute on each shard and will not show up in the output of 'getAggPlanStages'.','line_number':100,'multiline':False]
['text':' Verify that multiplanning took place by verifying that there was at least one','line_number':110,'multiline':False]
['text':' rejected plan.','line_number':111,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':144,'multiline':True]
['text':' expectedJoinAlgorithm ','line_number':146,'multiline':True]
['text':' Basic $lookup.','line_number':150,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':153,'multiline':True]
['text':' $lookup against a non-existent foreign collection should pick 'NonExistentForeignCollection'.','line_number':155,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':158,'multiline':True]
['text':' $lookup against a non-existent foreign collection should pick 'NonExistentForeignCollection'','line_number':160,'multiline':False]
['text':' even when HJ is eligible.','line_number':161,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':164,'multiline':True]
['text':' indexKeyPattern ','line_number':165,'multiline':True]
['text':' Self join $lookup, no views.','line_number':168,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':171,'multiline':True]
['text':' Self join $lookup; left hand is a view. This is expected to be pushed down because the view','line_number':173,'multiline':False]
['text':' pipeline itself is a $match, which is eligible for pushdown.','line_number':174,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':177,'multiline':True]
['text':' Self join $lookup; right hand is a view.','line_number':179,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':182,'multiline':True]
['text':' Self join $lookup; both namespaces are views.','line_number':184,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':187,'multiline':True]
['text':' $lookup preceded by $match.','line_number':189,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':195,'multiline':True]
['text':' $lookup preceded by $project.','line_number':197,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':203,'multiline':True]
['text':' $lookup preceded by $group.','line_number':205,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':211,'multiline':True]
['text':' Consecutive $lookups, where the first $lookup is against a view.','line_number':213,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':219,'multiline':True]
['text':' Consecutive $lookups, where the first $lookup is against a regular collection. Here, neither','line_number':221,'multiline':False]
['text':' $lookup is eligible for pushdown because currently, we can only know whether any secondary','line_number':222,'multiline':False]
['text':' collection is a view or a sharded collection.','line_number':223,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':229,'multiline':True]
['text':' $lookup with pipeline.','line_number':231,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':244,'multiline':True]
['text':' $lookup that absorbs $unwind.','line_number':246,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':252,'multiline':True]
['text':' $lookup that absorbs $match.','line_number':254,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':261,'multiline':True]
['text':' $lookup that does not absorb $match.','line_number':263,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':269,'multiline':True]
['text':' Run a $lookup with 'allowDiskUse' enabled. Because the foreign collection is very small, we','line_number':271,'multiline':False]
['text':' should select hash join.','line_number':272,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':275,'multiline':True]
['text':' indexKeyPattern ','line_number':276,'multiline':True]
['text':' Run a $lookup with 'allowDiskUse' disabled. We should use NLJ.','line_number':279,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':282,'multiline':True]
['text':' indexKeyPattern ','line_number':283,'multiline':True]
['text':' Build an index on the foreign collection that matches the foreignField. This should cause us','line_number':287,'multiline':False]
['text':' to choose an indexed nested loop join.','line_number':288,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':294,'multiline':True]
['text':' indexKeyPattern ','line_number':295,'multiline':True]
['text':' Construct an index with a partial filter expression. In this case, we should NOT use INLJ.','line_number':299,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':305,'multiline':True]
['text':' If we add an index that is not a partial index, we should then use INLJ.','line_number':307,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':311,'multiline':True]
['text':' indexKeyPattern ','line_number':312,'multiline':True]
['text':' Build a hashed index on the foreign collection that matches the foreignField. Indexed nested loop','line_number':316,'multiline':False]
['text':' join strategy should be used.','line_number':317,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':323,'multiline':True]
['text':' indexKeyPattern ','line_number':324,'multiline':True]
['text':' Build a wildcard index on the foreign collection that matches the foreignField. Nested loop join','line_number':328,'multiline':False]
['text':' strategy should be used.','line_number':329,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':335,'multiline':True]
['text':' Insert a document with multikey paths in the foreign collection that will be used for testing','line_number':337,'multiline':False]
['text':' wildcard indexes.','line_number':338,'multiline':False]
['text':' An incompatible wildcard index should result in using NLJ.','line_number':342,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':350,'multiline':True]
['text':' A compatible wildcard index with no other SBE compatible indexes should result in NLJ.','line_number':352,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':355,'multiline':True]
['text':' expectedJoinAlgorithm ','line_number':359,'multiline':True]
['text':' expectedJoinAlgorithm ','line_number':365,'multiline':True]
['text':' Create a regular index over the foreignField. We should now use INLJ.','line_number':367,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':371,'multiline':True]
['text':' indexKeyPattern ','line_number':372,'multiline':True]
['text':' Verify that a leading $match won't filter out a legitimate wildcard index.','line_number':375,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':382,'multiline':True]
['text':' Build a compound index that is prefixed with the foreignField. We should use an indexed','line_number':387,'multiline':False]
['text':' nested loop join.','line_number':388,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':394,'multiline':True]
['text':' indexKeyPattern ','line_number':395,'multiline':True]
['text':' Build multiple compound indexes prefixed with the foreignField. We should utilize the index with','line_number':399,'multiline':False]
['text':' the least amount of components.','line_number':400,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':407,'multiline':True]
['text':' indexKeyPattern ','line_number':408,'multiline':True]
['text':' In the presence of hashed and BTree indexes with the same number of components, we should','line_number':413,'multiline':False]
['text':' select BTree one.','line_number':414,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':420,'multiline':True]
['text':' indexKeyPattern ','line_number':421,'multiline':True]
['text':' While selecting a BTree index is more preferable, we should favor hashed index if it has','line_number':425,'multiline':False]
['text':' smaller number of components.','line_number':426,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':433,'multiline':True]
['text':' indexKeyPattern ','line_number':434,'multiline':True]
['text':' If we have two indexes of the same type with the same number of components, index keypattern','line_number':438,'multiline':False]
['text':' should be used as a tie breaker.','line_number':439,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':446,'multiline':True]
['text':' Build a 2d index on the foreign collection that matches the foreignField. In this case, we should','line_number':451,'multiline':False]
['text':' use regular nested loop join.','line_number':452,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':458,'multiline':True]
['text':' Build a sparse index on the foreign collection that matches the foreignField. In this case, we','line_number':462,'multiline':False]
['text':' should use regular nested loop join.','line_number':463,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':469,'multiline':True]
['text':' Build a compound index containing the foreignField, but not as the first field. In this case,','line_number':473,'multiline':False]
['text':' we should use regular nested loop join.','line_number':474,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':480,'multiline':True]
['text':' Multiple $lookup stages in a pipeline that should pick different physical joins.','line_number':484,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':493,'multiline':True]
['text':' indexKeyPattern ','line_number':495,'multiline':True]
['text':' expectedJoinAlgorithm ','line_number':498,'multiline':True]
['text':' indexKeyPattern ','line_number':499,'multiline':True]
['text':' aggOptions ','line_number':500,'multiline':True]
['text':' errMsgRegex ','line_number':501,'multiline':True]
['text':' checkMultiPlanning ','line_number':502,'multiline':True]
['text':' eqLookupNodeIndex ','line_number':503,'multiline':True]
['text':' expectedJoinAlgorithm ','line_number':509,'multiline':True]
['text':' expectedJoinAlgorithm ','line_number':512,'multiline':True]
['text':' indexKeyPattern ','line_number':513,'multiline':True]
['text':' aggOptions ','line_number':514,'multiline':True]
['text':' errMsgRegex ','line_number':515,'multiline':True]
['text':' checkMultiPlanning ','line_number':516,'multiline':True]
['text':' eqLookupNodeIndex ','line_number':517,'multiline':True]
['text':' "localField" contains a numeric component (unsupported by SBE).','line_number':523,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':526,'multiline':True]
['text':' "foreignField" contains a numeric component (unsupported by SBE).','line_number':528,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':531,'multiline':True]
['text':' "as" field contains a numeric component (numbers in this field are treated as literal field','line_number':533,'multiline':False]
['text':' names so this is supported by SBE).','line_number':534,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':537,'multiline':True]
['text':' "localField" is a path.','line_number':541,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':544,'multiline':True]
['text':' "foreignField" is a path.','line_number':546,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':549,'multiline':True]
['text':' "as" field is a path.','line_number':551,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':554,'multiline':True]
['text':' Verify that $lookup pushdown works correctly in the presence of multi-planning.','line_number':557,'multiline':False]
['text':' Verify that $lookup still gets pushed down when the pipeline prefix is pushed down and','line_number':563,'multiline':False]
['text':' undergoes multi-planning.','line_number':564,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':571,'multiline':True]
['text':' indexKeyPattern ','line_number':572,'multiline':True]
['text':' aggOptions ','line_number':573,'multiline':True]
['text':' errMsgRegex ','line_number':574,'multiline':True]
['text':' checkMultiplanning ','line_number':575,'multiline':True]
['text':' Verify that multiple $lookups will still get pushed down when the pipeline prefix is','line_number':577,'multiline':False]
['text':' pushed down and undergoes multi-planning.','line_number':578,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':586,'multiline':True]
['text':' indexKeyPattern ','line_number':587,'multiline':True]
['text':' aggOptions ','line_number':588,'multiline':True]
['text':' errMsgRegex ','line_number':589,'multiline':True]
['text':' checkMultiplanning ','line_number':590,'multiline':True]
['text':' Verify that $lookup and $group both get pushed down in the presence of multiplanning.','line_number':592,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':607,'multiline':True]
['text':' indexKeyPattern ','line_number':608,'multiline':True]
['text':' aggOptions ','line_number':609,'multiline':True]
['text':' errMsgRegex ','line_number':610,'multiline':True]
['text':' checkMultiplanning ','line_number':611,'multiline':True]
['text':' expectedJoinAlgorithm ','line_number':620,'multiline':True]
['text':' indexKeyPattern ','line_number':621,'multiline':True]
['text':' aggOptions ','line_number':622,'multiline':True]
['text':' errMsgRegex ','line_number':623,'multiline':True]
['text':' checkMultiplanning ','line_number':624,'multiline':True]
['text':' Verify that $lookup is correctly pushed down when it is nested inside of a $unionWith.','line_number':628,'multiline':False]
['text':' Wrap the subpipeline's explain output in a format that can be parsed by','line_number':641,'multiline':False]
['text':' 'getAggPlanStages'.','line_number':642,'multiline':False]
['text':' Test which verifies that the right side of a classic $lookup is never lowered into SBE, even if','line_number':649,'multiline':False]
['text':' the queries for the right side are eligible on their own to run in SBE.','line_number':650,'multiline':False]
['text':' Confirm that our candidate subpipeline is SBE compatible on its own.','line_number':652,'multiline':False]
['text':' Now, run a lookup and force it to run in the classic engine by prefixing it with','line_number':658,'multiline':False]
['text':' '$_internalInhibitOptimization'.','line_number':659,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':664,'multiline':True]
['text':' Create multiple indexes that can be used to answer the subPipeline query. This will allow','line_number':666,'multiline':False]
['text':' the winning plan to be cached.','line_number':667,'multiline':False]
['text':' Run the pipeline enough times to generate a cache entry for the right side in the foreign','line_number':671,'multiline':False]
['text':' collection.','line_number':672,'multiline':False]
['text':' The cached plan should be a classic plan.','line_number':680,'multiline':False]
['text':' The cached plan should not have slot based plan. Instead, it should be a FETCH + IXSCAN','line_number':686,'multiline':False]
['text':' executed in the classic engine.','line_number':687,'multiline':False]
['text':' Verify that $lookup and $group stages get pushed down as expected.','line_number':698,'multiline':False]
['text':' We should have exactly one EQ_LOOKUP nodes and no $lookup stage.','line_number':715,'multiline':False]
['text':' Run a pipeline where the $group is eligible for push down.','line_number':719,'multiline':False]
['text':' We should have exactly one EQ_LOOKUP nodes and no $lookup stage.','line_number':723,'multiline':False]
['text':' We should have exactly one GROUP node and no $group stages.','line_number':727,'multiline':False]
['text':' Run a pipeline where only the first $group is eligible for push down, but the rest of the','line_number':731,'multiline':False]
['text':' stages are not.','line_number':732,'multiline':False]
['text':' We should have two EQ_LOOKUP nodes and no $lookup stage.','line_number':736,'multiline':False]
['text':' We should have two GROUP nodes and no $group stage.','line_number':740,'multiline':False]
['text':' $group on its own is SBE compatible.','line_number':746,'multiline':False]
['text':' engine ','line_number':747,'multiline':True]
['text':' $group with $match is also SBE compatible.','line_number':749,'multiline':False]
['text':' engine ','line_number':750,'multiline':True]
['text':' A HJ-processed $lookup is also SBE compatible.','line_number':752,'multiline':False]
['text':' engine ','line_number':753,'multiline':True]
['text':' engine ','line_number':754,'multiline':True]
['text':' engine ','line_number':755,'multiline':True]
['text':' Constructing an index over the foreignField of 'lookupStage' will cause the $lookup to be','line_number':757,'multiline':False]
['text':' pushed down.','line_number':758,'multiline':False]
['text':' engine ','line_number':760,'multiline':True]
['text':' Regardless of whether the $lookup will not run in SBE, a preceding $group should still let','line_number':763,'multiline':False]
['text':' SBE be used.','line_number':764,'multiline':False]
['text':' engine ','line_number':765,'multiline':True]
['text':' Create a new scope and start a new mongod so that the mongod-wide global state changes do not','line_number':770,'multiline':False]
['text':' affect subsequent tests if any.','line_number':771,'multiline':False]
['text':' The foreign collection is very small and first verifies that the HJ is chosen under the','line_number':780,'multiline':False]
['text':' default query knob values.','line_number':781,'multiline':False]
['text':' indexKeyPattern ','line_number':785,'multiline':True]
['text':' The fcollStats.count means the number of documents in a collection, the fcollStats.size means','line_number':787,'multiline':False]
['text':' the collection's data size, and the fcollStats.storageSize means the allocated storage size.','line_number':788,'multiline':False]
['text':' Verifies that the HJ is still chosen.','line_number':797,'multiline':False]
['text':' indexKeyPattern ','line_number':801,'multiline':True]
['text':' Setting the 'internalQueryDisableLookupExecutionUsingHashJoin' knob to true will disable','line_number':803,'multiline':False]
['text':' HJ plans from being chosen and since the pipeline is SBE compatible it will fallback to','line_number':804,'multiline':False]
['text':' NLJ.','line_number':805,'multiline':False]
['text':' indexKeyPattern ','line_number':814,'multiline':True]
['text':' Test that we can go back to generating HJ plans.','line_number':816,'multiline':False]
['text':' indexKeyPattern ','line_number':825,'multiline':True]
['text':' Setting the 'internalQueryCollectionMaxNoOfDocumentsToChooseHashJoin' to count - 1 results in','line_number':827,'multiline':False]
['text':' choosing the NLJ algorithm.','line_number':828,'multiline':False]
['text':' indexKeyPattern ','line_number':837,'multiline':True]
['text':' Reverting back 'internalQueryCollectionMaxNoOfDocumentsToChooseHashJoin' to the previous','line_number':839,'multiline':False]
['text':' value. Setting the 'internalQueryCollectionMaxDataSizeBytesToChooseHashJoin' to size - 1','line_number':840,'multiline':False]
['text':' results in choosing the NLJ algorithm.','line_number':841,'multiline':False]
['text':' indexKeyPattern ','line_number':851,'multiline':True]
['text':' Reverting back 'internalQueryCollectionMaxDataSizeBytesToChooseHashJoin' to the previous','line_number':853,'multiline':False]
['text':' value. Setting the 'internalQueryCollectionMaxStorageSizeBytesToChooseHashJoin' to','line_number':854,'multiline':False]
['text':' storageSize - 1 results in choosing the NLJ algorithm.','line_number':855,'multiline':False]
['text':' indexKeyPattern ','line_number':865,'multiline':True]
['text':' Verify that $lookup works in transaction.','line_number':870,'multiline':False]
['text':' Clear the collections.','line_number':878,'multiline':False]
['text':' Start a snapshot transaction.','line_number':882,'multiline':False]
['text':' Transaction starts with single doc.','line_number':896,'multiline':False]
['text':' Insert a document outside the transaction, should not be visible in the transaction.','line_number':901,'multiline':False]
['text':' Basic $lookup should exercise NLJ.','line_number':910,'multiline':False]
['text':' $lookup with index on '_id' foreign field should exercise INLJ.','line_number':915,'multiline':False]
['text':' $lookup with 'allowDiskUse' should exercise HJ.','line_number':920,'multiline':False]
['text':' $lookup with HJ in transaction still works with spilling.','line_number':929,'multiline':False]
['text':' Sharded cases.','line_number':936,'multiline':False]
['text':' Setup. Here, 'coll' is sharded, 'foreignColl' is unsharded, 'viewName' is an unsharded view,','line_number':940,'multiline':False]
['text':' and 'shardedViewName' is a sharded view.','line_number':941,'multiline':False]
['text':' Both collections are unsharded.','line_number':956,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':959,'multiline':True]
['text':' Sharded main collection, unsharded right side. This is not expected to be eligible for','line_number':961,'multiline':False]
['text':' pushdown because the $lookup will be preceded by a $mergeCursors stage on the merging shard.','line_number':962,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':965,'multiline':True]
['text':' Sharded main collection, unsharded right side. Here, we are targeting a single shard, so','line_number':967,'multiline':False]
['text':' there will be no leading $mergeCursors stage. We should still avoid pushing down $lookup.','line_number':968,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':973,'multiline':True]
['text':' Verify that the above pipeline targets a single shard and doesn't use a $mergeCursors stage.','line_number':975,'multiline':False]
['text':' Both collections are sharded.','line_number':987,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':990,'multiline':True]
['text':' Unsharded main collection, sharded right side.','line_number':992,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':995,'multiline':True]
['text':' Unsharded main collection, unsharded view right side.','line_number':997,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':1000,'multiline':True]
['text':' Unsharded main collection, sharded view on the right side.','line_number':1002,'multiline':False]
['text':' expectedJoinAlgorithm ','line_number':1005,'multiline':True]
