['text':' Tests basic use cases for all $merge modes.','line_number':1,'multiline':False]
['text':' All tests use the same data in the source collection.','line_number':11,'multiline':False]
['text':' Test 'whenMatched=replace whenNotMatched=insert' mode. This is an equivalent of a','line_number':16,'multiline':False]
['text':' replacement-style update with upsert=true.','line_number':17,'multiline':False]
['text':' Test 'whenMatched=replace whenNotMatched=fail' mode. For matched documents the update','line_number':34,'multiline':False]
['text':' should be unordered and report an error at the end when all documents in a batch have been','line_number':35,'multiline':False]
['text':' processed, it will not fail as soon as we hit the first document without a match.','line_number':36,'multiline':False]
['text':' Test 'whenMatched=replace whenNotMatched=discard' mode. Documents in the target','line_number':52,'multiline':False]
['text':' collection without a match in the source collection should not be modified as a result','line_number':53,'multiline':False]
['text':' of the merge operation.','line_number':54,'multiline':False]
['text':' Test 'whenMatched=fail whenNotMatched=insert' mode. For matched documents the update should','line_number':67,'multiline':False]
['text':' be unordered and report an error at the end when all documents in a batch have been','line_number':68,'multiline':False]
['text':' processed, it will not fail as soon as we hit the first document with a match.','line_number':69,'multiline':False]
['text':' Besides ensuring that a DuplicateKey error is raised when we find a matching document,','line_number':74,'multiline':False]
['text':' this test also verifies that this $merge mode does perform an unordered insert and all','line_number':75,'multiline':False]
['text':' documents in the batch without a matching document get inserted into the target','line_number':76,'multiline':False]
['text':' collection. There is a special case when we can bail out early without processing all','line_number':77,'multiline':False]
['text':' documents which fit into a single batch. Namely, if we have a sharded cluster with two','line_number':78,'multiline':False]
['text':' shards, and shard documents by {_id: "hashed"}, we will end up with the document {_id: 3}','line_number':79,'multiline':False]
['text':' landed on shard0, and {_id: 1} and {_id: 2} on shard1 in the source collection. Note','line_number':80,'multiline':False]
['text':' that {_id: 3} has a duplicate key with the document in the target collection. For this','line_number':81,'multiline':False]
['text':' particlar case, the entire pipeline is sent to each shard. Lets assume that shard0 has','line_number':82,'multiline':False]
['text':' processed its single document with {_id: 3} and raised a DuplicateKey error, whilst','line_number':83,'multiline':False]
['text':' shard1 hasn't performed any writes yet (or even hasn't started reading from the cursor).','line_number':84,'multiline':False]
['text':' The mongos, after receiving the DuplicateKey, will stop pulling data from the shards','line_number':85,'multiline':False]
['text':' and will kill the cursors open on the remaining shards. Shard1, eventually, will throw','line_number':86,'multiline':False]
['text':' a CursorKilled during an interrupt check, and so no writes will be done into the target','line_number':87,'multiline':False]
['text':' collection. To workaround this scenario and guarantee that the writes will always be','line_number':88,'multiline':False]
['text':' performed, we will sort the documents by _id in ascending order. In this case, the','line_number':89,'multiline':False]
['text':' pipeline will be split and we will pull everything to mongos before doing the $merge.','line_number':90,'multiline':False]
['text':' This also ensures that documents with {_id: 1 } and {_id: 2} will be inserted first','line_number':91,'multiline':False]
['text':' before the DuplicateKey error is raised.','line_number':92,'multiline':False]
['text':' Test 'whenMatched=fail whenNotMatched=fail' mode. This mode is not supported and should fail.','line_number':111,'multiline':False]
['text':' Ensure the target collection has not been modified.','line_number':119,'multiline':False]
['text':' Test 'whenMatched=fail whenNotMatched=discard' mode. This mode is not supported and should','line_number':123,'multiline':False]
['text':' fail.','line_number':124,'multiline':False]
['text':' Ensure the target collection has not been modified.','line_number':132,'multiline':False]
['text':' Test 'whenMatched=merge whenNotMatched=insert' mode. This is an equivalent of an update','line_number':136,'multiline':False]
['text':' with a $set operator and upsert=true.','line_number':137,'multiline':False]
['text':' Test 'whenMatched=merge whenNotMatched=fail' mode. For matched documents the update','line_number':156,'multiline':False]
['text':' should be unordered and report an error at the end when all documents in a batch have been','line_number':157,'multiline':False]
['text':' processed, it will not fail as soon as we hit the first document without a match.','line_number':158,'multiline':False]
['text':' Test 'whenMatched=merge whenNotMatched=discard' mode. Documents in the target collection','line_number':179,'multiline':False]
['text':' without','line_number':180,'multiline':False]
['text':' a match in the source collection should not be modified as a result of the merge operation.','line_number':181,'multiline':False]
['text':' Test 'whenMatched=[pipeline] whenNotMatched=insert' mode. This is an equivalent of a','line_number':199,'multiline':False]
['text':' pipeline-style update with upsert=true and upsertSupplied=true.','line_number':200,'multiline':False]
['text':' We match {_id: 1} and apply the pipeline to add the field {x: 2}. The other source collection','line_number':208,'multiline':False]
['text':' documents are copied directly into the target collection.','line_number':209,'multiline':False]
['text':' Test 'whenMatched=[pipeline] whenNotMatched=fail' mode. For matched documents the update','line_number':216,'multiline':False]
['text':' should be unordered and report an error at the end when all documents in a batch have been','line_number':217,'multiline':False]
['text':' processed, it will not fail as soon as we hit the first document without a match.','line_number':218,'multiline':False]
['text':' Test 'whenMatched=[pipeline] whenNotMatched=discard' mode. Documents in the target collection','line_number':242,'multiline':False]
['text':' without a match in the source collection should not be modified as a result of the merge','line_number':243,'multiline':False]
['text':' operation.','line_number':244,'multiline':False]
['text':' Test 'whenMatched=keepExisting whenNotMatched=insert' mode. Existing documents in the target','line_number':260,'multiline':False]
['text':' collection which have a matching document in the source collection must not be updated, only','line_number':261,'multiline':False]
['text':' documents without a match must be inserted into the target collection.','line_number':262,'multiline':False]
['text':' Test 'whenMatched=keepExisting whenNotMatched=fail' mode. This mode is not supported and','line_number':275,'multiline':False]
['text':' should fail.','line_number':276,'multiline':False]
['text':' Ensure the target collection has not been modified.','line_number':284,'multiline':False]
['text':' Test 'whenMatched=keepExisting whenNotMatched=discard' mode. This mode is not supported and','line_number':288,'multiline':False]
['text':' should fail.','line_number':289,'multiline':False]
['text':' Ensure the target collection has not been modified.','line_number':297,'multiline':False]
