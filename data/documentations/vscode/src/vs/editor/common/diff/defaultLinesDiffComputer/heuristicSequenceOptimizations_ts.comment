['text':'---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------','line_number':1,'multiline':True]
['text':' Sometimes, calling this function twice improves the result.','line_number':15,'multiline':False]
['text':' Uncomment the second invocation and run the tests to see the difference.','line_number':16,'multiline':False]
['text':'*
 * This function fixes issues like this:
 * ```
 * import { Baz, Bar } from "foo";
 * ```
 * <->
 * ```
 * import { Baz, Bar, Foo } from "foo";
 * ```
 * Computed diff: [ {Add "," after Bar}, {Add "Foo " after space} }
 * Improved diff: [{Add ", Foo" after Bar}]
 ','line_number':22,'multiline':True]
['text':' First move them all to the left as much as possible and join them if possible','line_number':42,'multiline':False]
['text':' Merge previous and current diff','line_number':60,'multiline':False]
['text':' Then move them all to the right and join them again if possible','line_number':75,'multiline':False]
['text':' Merge previous and current diff, write to result!','line_number':93,'multiline':False]
['text':' align character level diffs at whitespace characters','line_number':116,'multiline':False]
['text':' import { IBar } from "foo";','line_number':117,'multiline':False]
['text':' import { I[Arr, I]Bar } from "foo";','line_number':118,'multiline':False]
['text':' ->','line_number':119,'multiline':False]
['text':' import { [IArr, ]IBar } from "foo";','line_number':120,'multiline':False]
['text':' import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';','line_number':122,'multiline':False]
['text':' import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';','line_number':123,'multiline':False]
['text':' ->','line_number':124,'multiline':False]
['text':' import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';','line_number':125,'multiline':False]
['text':' collectBrackets(level + 1, levelPerBracketType);','line_number':127,'multiline':False]
['text':' collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);','line_number':128,'multiline':False]
['text':' ->','line_number':129,'multiline':False]
['text':' collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);','line_number':130,'multiline':False]
['text':' To prevent performance issues','line_number':156,'multiline':False]
['text':' don't touch previous or next!','line_number':158,'multiline':False]
['text':' Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`','line_number':182,'multiline':False]
['text':' and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`','line_number':183,'multiline':False]
['text':' find best scored delta','line_number':187,'multiline':False]
['text':' The words do not touch previous equals mappings, as we would have processed them already.','line_number':245,'multiline':False]
['text':' But they might touch the next ones.','line_number':246,'multiline':False]
['text':' Because there is an intersection, we know that the words are not empty.','line_number':257,'multiline':False]
['text':' The word extends beyond the next equal mapping.','line_number':267,'multiline':False]
['text':' The equal parts are not empty, so -1 gives us a character that is equal in both parts.','line_number':287,'multiline':False]
['text':' TODO: Maybe a neural net can be used to derive the result from these numbers','line_number':408,'multiline':False]
['text':' Remove short suffixes/prefixes','line_number':436,'multiline':False]
