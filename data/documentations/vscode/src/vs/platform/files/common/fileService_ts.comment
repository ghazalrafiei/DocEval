['text':'---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------','line_number':1,'multiline':True]
['text':' Choose a buffer size that is a balance between memory needs and','line_number':30,'multiline':False]
['text':' manageable IPC overhead. The larger the buffer size, the less','line_number':31,'multiline':False]
['text':' roundtrips we have to do for reading/writing data.','line_number':32,'multiline':False]
['text':'#region File System Provider','line_number':39,'multiline':False]
['text':' Add provider with event','line_number':61,'multiline':False]
['text':' Forward events from provider','line_number':65,'multiline':False]
['text':' Always emit any event internally','line_number':69,'multiline':False]
['text':' Only emit uncorrelated events in the global `onDidFilesChange` event','line_number':72,'multiline':False]
['text':' Emit an event that we are about to activate a provider with the given scheme.','line_number':96,'multiline':False]
['text':' Listeners can participate in the activation by registering a provider for it.','line_number':97,'multiline':False]
['text':' provider is already here so we can return directly','line_number':107,'multiline':False]
['text':' If the provider is not yet there, make sure to join on the listeners assuming','line_number':110,'multiline':False]
['text':' that it takes a bit longer to register the file system provider.','line_number':111,'multiline':False]
['text':' Await activation of potentially extension contributed providers','line_number':117,'multiline':False]
['text':' Assert path is absolute','line_number':139,'multiline':False]
['text':' Activate provider','line_number':144,'multiline':False]
['text':' Assert provider','line_number':147,'multiline':False]
['text':'#endregion','line_number':179,'multiline':False]
['text':'#region Operation events','line_number':181,'multiline':False]
['text':'#endregion','line_number':186,'multiline':False]
['text':'#region File Metadata Resolving','line_number':188,'multiline':False]
['text':' Specially handle file not found case as file operation result','line_number':197,'multiline':False]
['text':' Bubble up any other error as is','line_number':202,'multiline':False]
['text':' lazy trie to check for recursive resolving','line_number':223,'multiline':False]
['text':' check for recursive resolving','line_number':232,'multiline':False]
['text':' required for https://github.com/microsoft/vscode/issues/128151 ','line_number':233,'multiline':True]
['text':' check for resolving single child folders','line_number':237,'multiline':False]
['text':' convert to file stat','line_number':251,'multiline':False]
['text':' check to recurse for directories','line_number':267,'multiline':False]
['text':' can happen e.g. due to permission errors','line_number':280,'multiline':False]
['text':' make sure to get rid of null values that signal a failure to resolve a particular entry','line_number':284,'multiline':False]
['text':' gracefully handle errors, we may not have permissions to read','line_number':289,'multiline':False]
['text':' Do not resolve any children ','line_number':317,'multiline':True]
['text':'#endregion','line_number':332,'multiline':False]
['text':'#region File Reading/Writing','line_number':334,'multiline':False]
['text':' validate overwrite','line_number':348,'multiline':False]
['text':' validate','line_number':356,'multiline':False]
['text':' do write into file (this will create it too)','line_number':359,'multiline':False]
['text':' events','line_number':362,'multiline':False]
['text':' validate write','line_number':382,'multiline':False]
['text':' mkdir recursively as needed','line_number':385,'multiline':False]
['text':' optimization: if the provider has unbuffered write capability and the data','line_number':390,'multiline':False]
['text':' to write is not a buffer, we consume up to 3 chunks and try to write the data','line_number':391,'multiline':False]
['text':' unbuffered to reduce the overhead. If the stream or readable has more data','line_number':392,'multiline':False]
['text':' to provide we continue to write buffered.','line_number':393,'multiline':False]
['text':' write file: unbuffered','line_number':410,'multiline':False]
['text':' buffered writing is unsupported','line_number':412,'multiline':False]
['text':' data is a full buffer already','line_number':413,'multiline':False]
['text':' atomic write forces unbuffered write if the provider supports it','line_number':414,'multiline':False]
['text':' write file: buffered','line_number':419,'multiline':False]
['text':' events','line_number':424,'multiline':False]
['text':' Validate unlock support','line_number':435,'multiline':False]
['text':' Validate atomic support','line_number':441,'multiline':False]
['text':' Validate via file stat meta data','line_number':457,'multiline':False]
['text':' file might not exist','line_number':462,'multiline':False]
['text':' File cannot be directory','line_number':465,'multiline':False]
['text':' File cannot be readonly','line_number':470,'multiline':False]
['text':' Dirty write prevention: if the file on disk has been changed and does not match our expected','line_number':473,'multiline':False]
['text':' mtime and etag, we bail out to prevent dirty writing.','line_number':474,'multiline':False]
['text':'','line_number':475,'multiline':False]
['text':' First, we check for a mtime that is in the future before we do more checks. The assumption is','line_number':476,'multiline':False]
['text':' that only the mtime is an indicator for a file that has changed on disk.','line_number':477,'multiline':False]
['text':'','line_number':478,'multiline':False]
['text':' Second, if the mtime has advanced, we compare the size of the file on disk with our previous','line_number':479,'multiline':False]
['text':' one using the etag() function. Relying only on the mtime check has prooven to produce false','line_number':480,'multiline':False]
['text':' positives due to file system weirdness (especially around remote file systems). As such, the','line_number':481,'multiline':False]
['text':' check for size is a weaker check because it can return a false negative if the file has changed','line_number':482,'multiline':False]
['text':' but to the same length. This is a compromise we take to avoid having to produce checksums of','line_number':483,'multiline':False]
['text':' the file content for comparison which would be much slower to compute.','line_number':484,'multiline':False]
['text':' not using stat.mtime for a reason, see above ','line_number':488,'multiline':True]
['text':' optimization: since we know that the caller does not','line_number':522,'multiline':False]
['text':' care about buffering, we indicate this to the reader.','line_number':523,'multiline':False]
['text':' this reduces all the overhead the buffered reading','line_number':524,'multiline':False]
['text':' has (open, read, close) if the provider supports','line_number':525,'multiline':False]
['text':' unbuffered reading.','line_number':526,'multiline':False]
['text':' install a cancellation token that gets cancelled','line_number':544,'multiline':False]
['text':' when any error occurs. this allows us to resolve','line_number':545,'multiline':False]
['text':' the content of the file while resolving metadata','line_number':546,'multiline':False]
['text':' but still cancel the operation in certain cases.','line_number':547,'multiline':False]
['text':'','line_number':548,'multiline':False]
['text':' in addition, we pass the optional token in that','line_number':549,'multiline':False]
['text':' we got from the outside to even allow for external','line_number':550,'multiline':False]
['text':' cancellation of the read operation.','line_number':551,'multiline':False]
['text':' validate read operation','line_number':559,'multiline':False]
['text':' if the etag is provided, we await the result of the validation','line_number':569,'multiline':False]
['text':' due to the likelihood of hitting a NOT_MODIFIED_SINCE result.','line_number':570,'multiline':False]
['text':' otherwise, we let it run in parallel to the file reading for','line_number':571,'multiline':False]
['text':' optimal startup performance.','line_number':572,'multiline':False]
['text':' read unbuffered','line_number':577,'multiline':False]
['text':' atomic reads are always unbuffered','line_number':579,'multiline':False]
['text':' provider has no buffered capability','line_number':580,'multiline':False]
['text':' unbuffered read is preferred','line_number':581,'multiline':False]
['text':' read streamed (always prefer over primitive buffered read)','line_number':586,'multiline':False]
['text':' read buffered','line_number':591,'multiline':False]
['text':' Await the stream to finish so that we exit this method','line_number':607,'multiline':False]
['text':' in a consistent state with file handles closed','line_number':608,'multiline':False]
['text':' (https://github.com/microsoft/vscode/issues/114024)','line_number':609,'multiline':False]
['text':' Re-throw errors as file operation errors but preserve','line_number':614,'multiline':False]
['text':' specific errors (such as not modified since)','line_number':615,'multiline':False]
['text':' Read the file into the stream async but do not wait for','line_number':658,'multiline':False]
['text':' this to complete because streams work via events','line_number':659,'multiline':False]
['text':' respect position option','line_number':669,'multiline':False]
['text':' respect length option','line_number':674,'multiline':False]
['text':' Throw if file is too large to load','line_number':679,'multiline':False]
['text':' End stream with data','line_number':682,'multiline':False]
['text':' Throw if resource is a directory','line_number':696,'multiline':False]
['text':' Throw if file not modified since (unless disabled)','line_number':701,'multiline':False]
['text':' Throw if file is too large to load','line_number':706,'multiline':False]
['text':'#endregion','line_number':718,'multiline':False]
['text':'#region Move/Copy/Delete/Create Folder','line_number':720,'multiline':False]
['text':' move','line_number':749,'multiline':False]
['text':' resolve and send events','line_number':752,'multiline':False]
['text':' copy','line_number':763,'multiline':False]
['text':' resolve and send events','line_number':766,'multiline':False]
['text':' simulate node.js behaviour here and do a no-op if paths match','line_number':775,'multiline':False]
['text':' validation','line_number':778,'multiline':False]
['text':' delete as needed (unless target is same resurce with different path case)','line_number':781,'multiline':False]
['text':' create parent folders','line_number':786,'multiline':False]
['text':' copy source => target','line_number':789,'multiline':False]
['text':' same provider with fast copy: leverage copy() functionality','line_number':792,'multiline':False]
['text':' when copying via buffer/unbuffered, we have to manually','line_number':797,'multiline':False]
['text':' traverse the source if it is a folder and not a file','line_number':798,'multiline':False]
['text':' move source => target','line_number':811,'multiline':False]
['text':' same provider: leverage rename() functionality','line_number':814,'multiline':False]
['text':' across providers: copy to target & delete at source','line_number':821,'multiline':False]
['text':' copy: source (buffered) => target (buffered)','line_number':833,'multiline':False]
['text':' copy: source (buffered) => target (unbuffered)','line_number':838,'multiline':False]
['text':' copy: source (unbuffered) => target (buffered)','line_number':843,'multiline':False]
['text':' copy: source (unbuffered) => target (unbuffered)','line_number':848,'multiline':False]
['text':' create folder in target','line_number':856,'multiline':False]
['text':' create children in target','line_number':859,'multiline':False]
['text':' Check if source is equal or parent to target (requires providers to be the same)','line_number':875,'multiline':False]
['text':' Extra checks if target exists and this is not a rename','line_number':891,'multiline':False]
['text':' Bail out if target exists and we are not about to overwrite','line_number':895,'multiline':False]
['text':' Special case: if the target is a parent of the source, we cannot delete','line_number':900,'multiline':False]
['text':' it as it would delete the source as well. In this case we have to throw','line_number':901,'multiline':False]
['text':' mkdir recursively','line_number':929,'multiline':False]
['text':' events','line_number':932,'multiline':False]
['text':' mkdir until we reach root','line_number':942,'multiline':False]
['text':' we have hit a directory that exists -> good','line_number':951,'multiline':False]
['text':' Bubble up any other error that is not file not found','line_number':954,'multiline':False]
['text':' Upon error, remember directories that need to be created','line_number':959,'multiline':False]
['text':' Continue up','line_number':962,'multiline':False]
['text':' Create directories as needed','line_number':967,'multiline':False]
['text':' For mkdirp() we tolerate that the mkdir() call fails','line_number':975,'multiline':False]
['text':' in case the folder already exists. This follows node.js','line_number':976,'multiline':False]
['text':' own implementation of fs.mkdir({ recursive: true }) and','line_number':977,'multiline':False]
['text':' reduces the chances of race conditions leading to errors','line_number':978,'multiline':False]
['text':' if multiple calls try to create the same folders','line_number':979,'multiline':False]
['text':' As such, we only throw an error here if it is other than','line_number':980,'multiline':False]
['text':' the fact that the file already exists.','line_number':981,'multiline':False]
['text':' (see also https://github.com/microsoft/vscode/issues/89834)','line_number':982,'multiline':False]
['text':' Validate trash support','line_number':1002,'multiline':False]
['text':' Validate atomic support','line_number':1008,'multiline':False]
['text':' Validate delete','line_number':1018,'multiline':False]
['text':' Handled later','line_number':1023,'multiline':False]
['text':' Validate recursive','line_number':1032,'multiline':False]
['text':' Delete through provider','line_number':1059,'multiline':False]
['text':' Events','line_number':1062,'multiline':False]
['text':'#endregion','line_number':1066,'multiline':False]
['text':'#region Clone File','line_number':1068,'multiline':False]
['text':' return early if paths are equal','line_number':1075,'multiline':False]
['text':' same provider, use `cloneFile` when native support is provided','line_number':1078,'multiline':False]
['text':' otherwise, either providers are different or there is no native','line_number':1083,'multiline':False]
['text':' `cloneFile` support, then we fallback to emulate a clone as best','line_number':1084,'multiline':False]
['text':' as we can with the other primitives','line_number':1085,'multiline':False]
['text':' create parent folders','line_number':1087,'multiline':False]
['text':' queue on the source to ensure atomic read','line_number':1090,'multiline':False]
['text':' leverage `copy` method if provided and providers are identical','line_number':1093,'multiline':False]
['text':' otherwise copy via buffer/unbuffered and use a write queue','line_number':1098,'multiline':False]
['text':' on the source to ensure atomic operation as much as possible','line_number':1099,'multiline':False]
['text':'#endregion','line_number':1103,'multiline':False]
['text':'#region File Watching','line_number':1105,'multiline':False]
['text':' global `onDidFilesChange` skips correlated events','line_number':1110,'multiline':False]
['text':' watch request hash ','line_number':1115,'multiline':True]
['text':' Explicitly set a correlation id so that file events that originate','line_number':1122,'multiline':False]
['text':' from requests from extensions are exclusively routed back to the','line_number':1123,'multiline':False]
['text':' extension host and not into the workbench.','line_number':1124,'multiline':False]
['text':' Forward watch request to provider and wire in disposables','line_number':1134,'multiline':False]
['text':' Watch and wire in disposable which is async but','line_number':1139,'multiline':False]
['text':' check if we got disposed meanwhile and forward','line_number':1140,'multiline':False]
['text':' When a correlation identifier is set, return a specific','line_number':1154,'multiline':False]
['text':' watcher that only emits events matching that correalation.','line_number':1155,'multiline':False]
['text':' Deduplicate identical watch requests','line_number':1179,'multiline':False]
['text':' Increment usage counter','line_number':1191,'multiline':False]
['text':' Unref','line_number':1197,'multiline':False]
['text':' Dispose only when last user is reached','line_number':1200,'multiline':False]
['text':'#endregion','line_number':1219,'multiline':False]
['text':'#region Helpers','line_number':1221,'multiline':False]
['text':' open handle','line_number':1228,'multiline':False]
['text':' write into handle until all bytes from buffer have been written','line_number':1231,'multiline':False]
['text':' close handle always','line_number':1242,'multiline':False]
['text':' Buffered stream: consume the buffer first by writing','line_number':1252,'multiline':False]
['text':' it to the target before reading from the stream.','line_number':1253,'multiline':False]
['text':' If the stream has been consumed, return early','line_number':1262,'multiline':False]
['text':' Unbuffered stream - just take as is','line_number':1270,'multiline':False]
['text':' pause stream to perform async write operation','line_number':1279,'multiline':False]
['text':' resume stream now that we have successfully written','line_number':1290,'multiline':False]
['text':' run this on the next tick to prevent increasing the','line_number':1291,'multiline':False]
['text':' execution stack because resume() may call the event','line_number':1292,'multiline':False]
['text':' handler again before finishing.','line_number':1293,'multiline':False]
['text':' Write through the provider','line_number':1317,'multiline':False]
['text':' Write through the provider','line_number':1339,'multiline':False]
['text':' Open handles','line_number':1353,'multiline':False]
['text':' read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at','line_number':1363,'multiline':False]
['text':' buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).','line_number':1364,'multiline':False]
['text':' write into target (targetHandle) at current position (posInFile) from buffer (buffer) at','line_number':1367,'multiline':False]
['text':' buffer position (posInBuffer) all bytes we read (bytesRead).','line_number':1368,'multiline':False]
['text':' when buffer full, fill it again from the beginning','line_number':1374,'multiline':False]
['text':' Open handle','line_number':1403,'multiline':False]
['text':' Read entire buffer from source and write buffered','line_number':1406,'multiline':False]
['text':' Read buffer via stream buffered','line_number':1419,'multiline':False]
['text':' Write buffer into target at once','line_number':1422,'multiline':False]
['text':'#endregion','line_number':1448,'multiline':False]
