['text':' gznorm.c -- normalize a gzip stream
 * Copyright (C) 2018 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 * Version 1.0  7 Oct 2018  Mark Adler ','line_number':1,'multiline':True]
['text':' gznorm takes a gzip stream, potentially containing multiple members, and','line_number':6,'multiline':False]
['text':' converts it to a gzip stream with a single member. In addition the gzip','line_number':7,'multiline':False]
['text':' header is normalized, removing the file name and time stamp, and setting the','line_number':8,'multiline':False]
['text':' other header contents (XFL, OS) to fixed values. gznorm does not recompress','line_number':9,'multiline':False]
['text':' the data, so it is fast, but no advantage is gained from the history that','line_number':10,'multiline':False]
['text':' could be available across member boundaries.','line_number':11,'multiline':False]
['text':' fread, fwrite, putc, fflush, ferror, fprintf,','line_number':13,'multiline':False]
['text':' vsnprintf, stdout, stderr, NULL, FILE','line_number':14,'multiline':False]
['text':' malloc, free','line_number':15,'multiline':False]
['text':' strerror','line_number':16,'multiline':False]
['text':' errno','line_number':17,'multiline':False]
['text':' va_list, va_start, va_end','line_number':18,'multiline':False]
['text':' inflateInit2, inflate, inflateReset, inflateEnd,','line_number':19,'multiline':False]
['text':' z_stream, z_off_t, crc32_combine, Z_NULL, Z_BLOCK,','line_number':20,'multiline':False]
['text':' Z_OK, Z_STREAM_END, Z_BUF_ERROR, Z_DATA_ERROR,','line_number':21,'multiline':False]
['text':' Z_MEM_ERROR','line_number':22,'multiline':False]
['text':' printf to an allocated string. Return the string, or NULL if the printf or','line_number':34,'multiline':False]
['text':' allocation fails.','line_number':35,'multiline':False]
['text':' Get the length of the result of the printf.','line_number':37,'multiline':False]
['text':' Allocate the required space and printf to it.','line_number':45,'multiline':False]
['text':' Return with an error, putting an allocated error message in *err. Doing an','line_number':55,'multiline':False]
['text':' inflateEnd() on an already ended state, or one with state set to Z_NULL, is','line_number':56,'multiline':False]
['text':' permitted.','line_number':57,'multiline':False]
['text':' Chunk size for buffered reads and for decompression. Twice this many bytes','line_number':65,'multiline':False]
['text':' will be allocated on the stack by gzip_normalize(). Must fit in an unsigned.','line_number':66,'multiline':False]
['text':' Read a gzip stream from in and write an equivalent normalized gzip stream to','line_number':69,'multiline':False]
['text':' out. If given no input, an empty gzip stream will be written. If successful,','line_number':70,'multiline':False]
['text':' 0 is returned, and *err is set to NULL. On error, 1 is returned, where the','line_number':71,'multiline':False]
['text':' details of the error are returned in *err, a pointer to an allocated string.','line_number':72,'multiline':False]
['text':'','line_number':73,'multiline':False]
['text':' The input may be a stream with multiple gzip members, which is converted to','line_number':74,'multiline':False]
['text':' a single gzip member on the output. Each gzip member is decompressed at the','line_number':75,'multiline':False]
['text':' level of deflate blocks. This enables clearing the last-block bit, shifting','line_number':76,'multiline':False]
['text':' the compressed data to concatenate to the previous member's compressed data,','line_number':77,'multiline':False]
['text':' which can end at an arbitrary bit boundary, and identifying stored blocks in','line_number':78,'multiline':False]
['text':' order to resynchronize those to byte boundaries. The deflate compressed data','line_number':79,'multiline':False]
['text':' is terminated with a 10-bit empty fixed block. If any members on the input','line_number':80,'multiline':False]
['text':' end with a 10-bit empty fixed block, then that block is excised from the','line_number':81,'multiline':False]
['text':' stream. This avoids appending empty fixed blocks for every normalization,','line_number':82,'multiline':False]
['text':' and assures that gzip_normalize applied a second time will not change the','line_number':83,'multiline':False]
['text':' input. The pad bits after stored block headers and after the final deflate','line_number':84,'multiline':False]
['text':' block are all forced to zeros.','line_number':85,'multiline':False]
['text':' initialize the inflate engine to process a gzip member','line_number':87,'multiline':False]
['text':' State while processing the input gzip stream.','line_number':97,'multiline':False]
['text':' BETWEEN -> HEAD -> BLOCK -> TAIL -> BETWEEN -> ...','line_number':98,'multiline':False]
['text':' between gzip members (must end in this state)','line_number':99,'multiline':False]
['text':' reading a gzip header','line_number':100,'multiline':False]
['text':' reading deflate blocks','line_number':101,'multiline':False]
['text':' reading a gzip trailer','line_number':102,'multiline':False]
['text':' current component being processed','line_number':103,'multiline':False]
['text':' accumulated CRC of uncompressed data','line_number':104,'multiline':False]
['text':' accumulated length of uncompressed data','line_number':105,'multiline':False]
['text':' deflate stream bit buffer of num bits','line_number':106,'multiline':False]
['text':' number of bits in buf (at bottom)','line_number':107,'multiline':False]
['text':' Write a canonical gzip header (no mod time, file name, comment, extra','line_number':109,'multiline':False]
['text':' block, or extra flags, and OS is marked as unknown).','line_number':110,'multiline':False]
['text':' Process the gzip stream from in until reaching the end of the input,','line_number':113,'multiline':False]
['text':' encountering invalid input, or experiencing an i/o error.','line_number':114,'multiline':False]
['text':' true if not at the end of the input','line_number':115,'multiline':False]
['text':' State inside this loop.','line_number':117,'multiline':False]
['text':' next input buffer location to process','line_number':118,'multiline':False]
['text':' number of bits from previous block in','line_number':119,'multiline':False]
['text':' the bit buffer, or -1 if not at the','line_number':120,'multiline':False]
['text':' start of a block','line_number':121,'multiline':False]
['text':' uncompressed length of member','line_number':122,'multiline':False]
['text':' number of trailer bytes read (0..8)','line_number':123,'multiline':False]
['text':' accumulated trailer component','line_number':124,'multiline':False]
['text':' Get the next chunk of input from in.','line_number':126,'multiline':False]
['text':' Run that chunk of input through the inflate engine to exhaustion.','line_number':134,'multiline':False]
['text':' At this point it is assured that strm.avail_in > 0.','line_number':136,'multiline':False]
['text':' Inflate until the end of a gzip component (header, deflate','line_number':138,'multiline':False]
['text':' block, trailer) is reached, or until all of the chunk is','line_number':139,'multiline':False]
['text':' consumed. The resulting decompressed data is discarded, though','line_number':140,'multiline':False]
['text':' the total size of the decompressed data in each member is','line_number':141,'multiline':False]
['text':' tracked, for the calculation of the total CRC.','line_number':142,'multiline':False]
['text':' inflate and handle any errors','line_number':144,'multiline':False]
['text':' Update the number of uncompressed bytes generated in this','line_number':156,'multiline':False]
['text':' member. The actual count (not modulo 2^32) is required to','line_number':157,'multiline':False]
['text':' correctly compute the total CRC.','line_number':158,'multiline':False]
['text':' Continue to process this chunk until it is consumed, or','line_number':164,'multiline':False]
['text':' until the end of a component (header, deflate block, or','line_number':165,'multiline':False]
['text':' trailer) is reached.','line_number':166,'multiline':False]
['text':' Since strm.avail_in was > 0 for the inflate call, some input was','line_number':169,'multiline':False]
['text':' just consumed. It is therefore assured that put < strm.next_in.','line_number':170,'multiline':False]
['text':' Disposition the consumed component or part of a component.','line_number':172,'multiline':False]
['text':' Fall through to HEAD when some or all of the header is','line_number':176,'multiline':False]
['text':' processed.','line_number':177,'multiline':False]
['text':' Discard the header.','line_number':180,'multiline':False]
['text':' End of header reached -- deflate blocks follow.','line_number':182,'multiline':False]
['text':' Copy the deflate stream to the output, but with the','line_number':191,'multiline':False]
['text':' last-block-bit cleared. Re-synchronize stored block','line_number':192,'multiline':False]
['text':' headers to the output byte boundaries. The bytes at','line_number':193,'multiline':False]
['text':' put..strm.next_in-1 is the compressed data that has been','line_number':194,'multiline':False]
['text':' processed and is ready to be copied to the output.','line_number':195,'multiline':False]
['text':' At this point, it is assured that new compressed data is','line_number':197,'multiline':False]
['text':' available, i.e., put < strm.next_in. If prev is -1, then','line_number':198,'multiline':False]
['text':' that compressed data starts in the middle of a deflate','line_number':199,'multiline':False]
['text':' block. If prev is not -1, then the bits in the bit','line_number':200,'multiline':False]
['text':' buffer, possibly combined with the bits in *put, contain','line_number':201,'multiline':False]
['text':' the three-bit header of the new deflate block. In that','line_number':202,'multiline':False]
['text':' case, prev is the number of bits from the previous block','line_number':203,'multiline':False]
['text':' that remain in the bit buffer. Since num is the number','line_number':204,'multiline':False]
['text':' of bits in the bit buffer, we have that num - prev is','line_number':205,'multiline':False]
['text':' the number of bits from the new block currently in the','line_number':206,'multiline':False]
['text':' bit buffer.','line_number':207,'multiline':False]
['text':' If strm.data_type & 0xc0 is 0x80, then the last byte of','line_number':209,'multiline':False]
['text':' the available compressed data includes the last bits of','line_number':210,'multiline':False]
['text':' the end of a deflate block. In that case, that last byte','line_number':211,'multiline':False]
['text':' also has strm.data_type & 0x1f bits of the next deflate','line_number':212,'multiline':False]
['text':' block, in the range 0..7. If strm.data_type & 0xc0 is','line_number':213,'multiline':False]
['text':' 0xc0, then the last byte of the compressed data is the','line_number':214,'multiline':False]
['text':' end of the deflate stream, followed by strm.data_type &','line_number':215,'multiline':False]
['text':' 0x1f pad bits, also in the range 0..7.','line_number':216,'multiline':False]
['text':' Set bits to the number of bits not yet consumed from the','line_number':218,'multiline':False]
['text':' last byte. If we are at the end of the block, bits is','line_number':219,'multiline':False]
['text':' either the number of bits in the last byte belonging to','line_number':220,'multiline':False]
['text':' the next block, or the number of pad bits after the','line_number':221,'multiline':False]
['text':' final block. In either of those cases, bits is in the','line_number':222,'multiline':False]
['text':' range 0..7.','line_number':223,'multiline':False]
['text':' (required due to C syntax oddity)','line_number':224,'multiline':False]
['text':' We are at the start of a new block. Clear the last','line_number':228,'multiline':False]
['text':' block bit, and check for special cases. If it is a','line_number':229,'multiline':False]
['text':' stored block, then emit the header and pad to the','line_number':230,'multiline':False]
['text':' next byte boundary. If it is a final, empty fixed','line_number':231,'multiline':False]
['text':' block, then excise it.','line_number':232,'multiline':False]
['text':' Some or all of the three header bits for this block','line_number':234,'multiline':False]
['text':' may already be in the bit buffer. Load any remaining','line_number':235,'multiline':False]
['text':' header bits into the bit buffer.','line_number':236,'multiline':False]
['text':' Set last to have a 1 in the position of the last','line_number':242,'multiline':False]
['text':' block bit in the bit buffer.','line_number':243,'multiline':False]
['text':' This is a final fixed block. Load at least ten','line_number':247,'multiline':False]
['text':' bits from this block, including the header, into','line_number':248,'multiline':False]
['text':' the bit buffer. We already have at least three,','line_number':249,'multiline':False]
['text':' so at most one more byte needs to be loaded.','line_number':250,'multiline':False]
['text':' Need to go get and process more input.','line_number':253,'multiline':False]
['text':' We'll end up back here to finish this.','line_number':254,'multiline':False]
['text':' That final fixed block is empty. Delete it','line_number':260,'multiline':False]
['text':' to avoid adding an empty block every time a','line_number':261,'multiline':False]
['text':' gzip stream is normalized.','line_number':262,'multiline':False]
['text':' zero the pad bits','line_number':264,'multiline':False]
['text':' This is a stored block. Flush to the next','line_number':268,'multiline':False]
['text':' byte boundary after the three-bit header.','line_number':269,'multiline':False]
['text':' zero the pad bits','line_number':271,'multiline':False]
['text':' Clear the last block bit.','line_number':274,'multiline':False]
['text':' Write out complete bytes in the bit buffer.','line_number':277,'multiline':False]
['text':' If no more bytes left to process, then we have','line_number':284,'multiline':False]
['text':' consumed the byte that had bits from the next block.','line_number':285,'multiline':False]
['text':' We are done handling the deflate block header. Now copy','line_number':290,'multiline':False]
['text':' all or almost all of the remaining compressed data that','line_number':291,'multiline':False]
['text':' has been processed so far. Don't copy one byte at the','line_number':292,'multiline':False]
['text':' end if it contains bits from the next deflate block or','line_number':293,'multiline':False]
['text':' pad bits at the end of a deflate block.','line_number':294,'multiline':False]
['text':' mix is 1 if we are at the end of a deflate block, and if','line_number':296,'multiline':False]
['text':' some of the bits in the last byte follow this block. mix','line_number':297,'multiline':False]
['text':' is 0 if we are in the middle of a deflate block, if the','line_number':298,'multiline':False]
['text':' deflate block ended on a byte boundary, or if all of the','line_number':299,'multiline':False]
['text':' compressed data processed so far has been consumed.','line_number':300,'multiline':False]
['text':' Copy all of the processed compressed data to the output,','line_number':303,'multiline':False]
['text':' except for the last byte if it contains bits from the','line_number':304,'multiline':False]
['text':' next deflate block or pad bits at the end of the deflate','line_number':305,'multiline':False]
['text':' stream. Copy the data after shifting in num bits from','line_number':306,'multiline':False]
['text':' buf in front of it, leaving num bits from the end of the','line_number':307,'multiline':False]
['text':' compressed data in buf when done.','line_number':308,'multiline':False]
['text':' Insert num bits from buf before the data being','line_number':312,'multiline':False]
['text':' copied.','line_number':313,'multiline':False]
['text':' No shifting needed -- write directly.','line_number':320,'multiline':False]
['text':' Process the last processed byte if it wasn't written.','line_number':326,'multiline':False]
['text':' Load the last byte into the bit buffer.','line_number':328,'multiline':False]
['text':' We are at the end of the deflate stream and','line_number':333,'multiline':False]
['text':' there are bits pad bits. Discard the pad bits','line_number':334,'multiline':False]
['text':' and write a byte to the output, if available.','line_number':335,'multiline':False]
['text':' Leave the num bits left over in buf to prepend','line_number':336,'multiline':False]
['text':' to the next deflate stream.','line_number':337,'multiline':False]
['text':' Force the pad bits in the bit buffer to zeros.','line_number':345,'multiline':False]
['text':' Don't need to set prev here since going to TAIL.','line_number':348,'multiline':False]
['text':' At the end of an internal deflate block. Leave','line_number':351,'multiline':False]
['text':' the last byte in the bit buffer to examine on','line_number':352,'multiline':False]
['text':' the next entry to BLOCK, when more bits from the','line_number':353,'multiline':False]
['text':' next block will be available.','line_number':354,'multiline':False]
['text':' number of bits in buffer','line_number':355,'multiline':False]
['text':' from current block','line_number':356,'multiline':False]
['text':' Don't have a byte left over, so we are in the middle of','line_number':359,'multiline':False]
['text':' a deflate block, or the deflate block ended on a byte','line_number':360,'multiline':False]
['text':' boundary. Set prev appropriately for the next entry into','line_number':361,'multiline':False]
['text':' BLOCK.','line_number':362,'multiline':False]
['text':' The block ended on a byte boundary, so no header','line_number':364,'multiline':False]
['text':' bits are in the bit buffer.','line_number':365,'multiline':False]
['text':' In the middle of a deflate block, so no header here.','line_number':368,'multiline':False]
['text':' Check for the end of the deflate stream.','line_number':371,'multiline':False]
['text':' That ends the deflate stream on the input side, the','line_number':373,'multiline':False]
['text':' pad bits were discarded, and any remaining bits from','line_number':374,'multiline':False]
['text':' the last block in the stream are saved in the bit','line_number':375,'multiline':False]
['text':' buffer to prepend to the next stream. Process the','line_number':376,'multiline':False]
['text':' gzip trailer next.','line_number':377,'multiline':False]
['text':' Accumulate available trailer bytes to update the total','line_number':385,'multiline':False]
['text':' CRC and the total uncompressed length.','line_number':386,'multiline':False]
['text':' Update the total CRC.','line_number':391,'multiline':False]
['text':' Update the total uncompressed length. (It's ok','line_number':399,'multiline':False]
['text':' if this sum is done modulo 2^32.)','line_number':400,'multiline':False]
['text':' At the end of a member. Set up to inflate an','line_number':403,'multiline':False]
['text':' immediately following gzip member. (If we made','line_number':404,'multiline':False]
['text':' it this far, then the trailer was valid.)','line_number':405,'multiline':False]
['text':' Process the input buffer until completely consumed.','line_number':415,'multiline':False]
['text':' Process input until end of file, invalid input, or i/o error.','line_number':418,'multiline':False]
['text':' Done with the inflate engine.','line_number':421,'multiline':False]
['text':' Verify the validity of the input.','line_number':424,'multiline':False]
['text':' Write the remaining deflate stream bits, followed by a terminating','line_number':428,'multiline':False]
['text':' deflate fixed block.','line_number':429,'multiline':False]
['text':' Write the gzip trailer, which is the CRC and the uncompressed length','line_number':436,'multiline':False]
['text':' modulo 2^32, both in little-endian order.','line_number':437,'multiline':False]
['text':' Check for any i/o errors.','line_number':448,'multiline':False]
['text':' All good!','line_number':452,'multiline':False]
['text':' Normalize the gzip stream on stdin, writing the result to stdout.','line_number':457,'multiline':False]
['text':' Avoid end-of-line conversions on evil operating systems.','line_number':459,'multiline':False]
['text':' Normalize from stdin to stdout, returning 1 on error, 0 if ok.','line_number':463,'multiline':False]
