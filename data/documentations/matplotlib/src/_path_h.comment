['text':' -*- mode: c++; c-basic-offset: 4 -*- ','line_number':1,'multiline':True]
['text':' Clean up the last polygon in the result.  ','line_number':56,'multiline':True]
['text':'','line_number':68,'multiline':False]
['text':' The following function was found in the Agg 2.3 examples (interactive_polygon.cpp).','line_number':69,'multiline':False]
['text':' It has been generalized to work on (possibly curved) polylines, rather than','line_number':70,'multiline':False]
['text':' just polygons.  The original comments have been kept intact.','line_number':71,'multiline':False]
['text':'  -- Michael Droettboom 2007-10-02','line_number':72,'multiline':False]
['text':'','line_number':73,'multiline':False]
['text':'======= Crossings Multiply algorithm of InsideTest ========================','line_number':74,'multiline':False]
['text':'','line_number':75,'multiline':False]
['text':' By Eric Haines, 3D/Eye Inc, erich@eye.com','line_number':76,'multiline':False]
['text':'','line_number':77,'multiline':False]
['text':' This version is usually somewhat faster than the original published in','line_number':78,'multiline':False]
['text':' Graphics Gems IV; by turning the division for testing the X axis crossing','line_number':79,'multiline':False]
['text':' into a tricky multiplication test this part of the test became faster,','line_number':80,'multiline':False]
['text':' which had the additional effect of making the test for "both to left or','line_number':81,'multiline':False]
['text':' both to right" a bit slower for triangles than simply computing the','line_number':82,'multiline':False]
['text':' intersection each time.  The main increase is in triangle testing speed,','line_number':83,'multiline':False]
['text':' which was about 15% faster; all other polygon complexities were pretty much','line_number':84,'multiline':False]
['text':' the same as before.  On machines where division is very expensive (not the','line_number':85,'multiline':False]
['text':' case on the HP 9000 series on which I tested) this test should be much','line_number':86,'multiline':False]
['text':' faster overall than the old code.  Your mileage may (in fact, will) vary,','line_number':87,'multiline':False]
['text':' depending on the machine and the test data, but in general I believe this','line_number':88,'multiline':False]
['text':' code is both shorter and faster.  This test was inspired by unpublished','line_number':89,'multiline':False]
['text':' Graphics Gems submitted by Joseph Samosky and Mark Haigh-Hutchinson.','line_number':90,'multiline':False]
['text':' Related work by Samosky is in:','line_number':91,'multiline':False]
['text':'','line_number':92,'multiline':False]
['text':' Samosky, Joseph, "SectionView: A system for interactively specifying and','line_number':93,'multiline':False]
['text':' visualizing sections through three-dimensional medical image data",','line_number':94,'multiline':False]
['text':' M.S. Thesis, Department of Electrical Engineering and Computer Science,','line_number':95,'multiline':False]
['text':' Massachusetts Institute of Technology, 1993.','line_number':96,'multiline':False]
['text':'','line_number':97,'multiline':False]
['text':' Shoot a test ray along +X axis.  The strategy is to compare vertex Y values','line_number':98,'multiline':False]
['text':' to the testing point's Y and quickly discard edges which are entirely to one','line_number':99,'multiline':False]
['text':' side of the test ray.  Note that CONVEX and WINDING code can be added as','line_number':100,'multiline':False]
['text':' for the CrossingsTest() code; it is left out here for clarity.','line_number':101,'multiline':False]
['text':'','line_number':102,'multiline':False]
['text':' Input 2D polygon _pgon_ with _numverts_ number of vertices and test point','line_number':103,'multiline':False]
['text':' _point_, returns 1 if inside, 0 if outside.','line_number':104,'multiline':False]
['text':' get test bit for above/below X axis','line_number':144,'multiline':False]
['text':' The following cases denote the beginning on a new subpath','line_number':154,'multiline':False]
['text':' Check if endpoints straddle (are on opposite sides) of','line_number':172,'multiline':False]
['text':' X axis (i.e. the Y's differ); if so, +X ray could','line_number':173,'multiline':False]
['text':' intersect this edge.  The old test also checked whether','line_number':174,'multiline':False]
['text':' the endpoints are both to the right or to the left of','line_number':175,'multiline':False]
['text':' the test point.  However, given the faster intersection','line_number':176,'multiline':False]
['text':' point computation used below, this test was found to be','line_number':177,'multiline':False]
['text':' a break-even proposition for most polygons and a loser','line_number':178,'multiline':False]
['text':' for triangles (where 50% or more of the edges which','line_number':179,'multiline':False]
['text':' survive this test will cross quadrants and so have to','line_number':180,'multiline':False]
['text':' have the X intersection computed anyway).  I credit','line_number':181,'multiline':False]
['text':' Joseph Samosky with inspiring me to try dropping the','line_number':182,'multiline':False]
['text':' "both left or both right" part of my code.','line_number':183,'multiline':False]
['text':' Check intersection of pgon segment with +X ray.','line_number':185,'multiline':False]
['text':' Note if >= point's X; if so, the ray hits it.  The','line_number':186,'multiline':False]
['text':' division operation is avoided for the ">=" test by','line_number':187,'multiline':False]
['text':' checking the sign of the first vertex wrto the test','line_number':188,'multiline':False]
['text':' point; idea inspired by Joseph Samosky's and Mark','line_number':189,'multiline':False]
['text':' Haigh-Hutchinson's different polygon inclusion','line_number':190,'multiline':False]
['text':' tests.','line_number':191,'multiline':False]
['text':' Move to the next pair of vertices, retaining info as','line_number':197,'multiline':False]
['text':' possible.','line_number':198,'multiline':False]
['text':' xm and ym are the minimum positive values in the data, used
       by log scaling ','line_number':329,'multiline':True]
['text':' xm and ym are the minimum positive values in the data, used
       by log scaling ','line_number':345,'multiline':True]
['text':'* The clip_path_to_rect code here is a clean-room implementation of
    the Sutherland-Hodgman clipping algorithm described here:

  https://en.wikipedia.org/wiki/Sutherland-Hodgman_clipping_algorithm
','line_number':510,'multiline':True]
['text':' There are four different passes needed to create/remove
   vertices (one for each side of the rectangle).  The differences
   between those passes are encapsulated in these functor classes.
','line_number':518,'multiline':True]
['text':' Grab the next subpath and store it in polygon1','line_number':674,'multiline':False]
['text':' The result of each step is fed into the next (note the','line_number':692,'multiline':False]
['text':' swapping of polygon1 and polygon2 at each step).','line_number':693,'multiline':False]
['text':' Empty polygons aren't very useful, so skip them','line_number':699,'multiline':False]
['text':' relative and absolute tolerance values are chosen empirically','line_number':800,'multiline':False]
['text':' it looks the atol value matters here because of round-off errors','line_number':801,'multiline':False]
['text':' as per python's math.isclose','line_number':805,'multiline':False]
['text':' determinant','line_number':819,'multiline':False]
['text':' If den == 0 we have two possibilities:','line_number':822,'multiline':False]
['text':' 1 - If the area of the triangle made by the 3 first points (2 from the first segment','line_number':825,'multiline':False]
['text':' plus one from the second) is zero, they are collinear','line_number':826,'multiline':False]
['text':' segments have infinite slope (vertical lines)','line_number':828,'multiline':False]
['text':' and lie on the same line','line_number':829,'multiline':False]
['text':' 2 - If t_area is not zero, the segments are parallel, but not collinear','line_number':838,'multiline':False]
['text':' if the segment in path 1 is (almost) 0 length, skip to next vertex','line_number':877,'multiline':False]
['text':' if the segment in path 2 is (almost) 0 length, skip to next vertex','line_number':885,'multiline':False]
['text':' returns whether the segment from (x1,y1) to (x2,y2)','line_number':903,'multiline':False]
['text':' intersects the rectangle centered at (cx,cy) with size (w,h)','line_number':904,'multiline':False]
['text':' see doc/segment_intersects_rectangle.svg for a more detailed explanation','line_number':905,'multiline':False]
['text':' Special-case for compat with old ttconv code, which *truncated*','line_number':1080,'multiline':False]
['text':' values with a cast to int instead of rounding them as printf','line_number':1081,'multiline':False]
['text':' would do.  The only point where non-integer values arise is from','line_number':1082,'multiline':False]
['text':' quad2cubic conversion (as we already perform a first truncation','line_number':1083,'multiline':False]
['text':' on Python's side), which can introduce additional floating point','line_number':1084,'multiline':False]
['text':' error (by adding 2/3 delta-x and then 1/3 delta-x), so compensate by','line_number':1085,'multiline':False]
['text':' first rounding to the closest 1/3 and then truncating.','line_number':1086,'multiline':False]
['text':' Delete trailing zeros and decimal point','line_number':1093,'multiline':False]
['text':' Start at last character.','line_number':1094,'multiline':False]
['text':' Rewind through all the zeros and, if present, the trailing decimal','line_number':1095,'multiline':False]
['text':' point.  Py_DTSF_ADD_DOT_0 ensures we won't go past the start of str.','line_number':1096,'multiline':False]
['text':' For formats that don't support quad curves, convert to
               cubic curves ','line_number':1143,'multiline':True]
['text':' Unknown code value','line_number':1170,'multiline':False]
['text':' The following tests !isnan(current), but also works for integral','line_number':1239,'multiline':False]
['text':' types.  (The isnan(IntegralType) overload is absent on MSVC.)','line_number':1240,'multiline':False]
