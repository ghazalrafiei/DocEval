['text':' Uses code derived from gemmlowp,','line_number':17,'multiline':False]
['text':' https://github.com/google/gemmlowp/blob/6c91e1ed0c2eff1182d804310b92911fe9c18019/internal/multi_thread_gemm.h','line_number':18,'multiline':False]
['text':' Changes:','line_number':19,'multiline':False]
['text':' - allocation-free execute()','line_number':20,'multiline':False]
['text':' - Use RAII where possible.','line_number':21,'multiline':False]
['text':' - Run the first task on the main thread (since that is the largest task).','line_number':22,'multiline':False]
['text':' - removed custom allocator.','line_number':23,'multiline':False]
['text':' - Removed some ifdef's','line_number':24,'multiline':False]
['text':' - cache-line align Worker.','line_number':25,'multiline':False]
['text':' - use std::atomic instead of volatile and custom barriers.','line_number':26,'multiline':False]
['text':' - use std::mutex/std::condition_variable instead of raw pthreads.','line_number':27,'multiline':False]
['text':' Allocate a T aligned at an `align` byte address','line_number':33,'multiline':False]
['text':' Free a T previously allocated via AllocAligned<T>::alloc()','line_number':54,'multiline':False]
['text':' Deleter object for unique_ptr for an aligned object','line_number':67,'multiline':False]
['text':' make_unique that guarantees alignment','line_number':73,'multiline':False]
['text':' Waits until *var != initial_value.','line_number':112,'multiline':False]
['text':'','line_number':113,'multiline':False]
['text':' Returns the new value of *var. The guarantee here is that','line_number':114,'multiline':False]
['text':' the return value is different from initial_value, and that that','line_number':115,'multiline':False]
['text':' new value has been taken by *var at some point during the','line_number':116,'multiline':False]
['text':' execution of this function. There is no guarantee that this is','line_number':117,'multiline':False]
['text':' still the value of *var when this function returns, since *var is','line_number':118,'multiline':False]
['text':' not assumed to be guarded by any lock.','line_number':119,'multiline':False]
['text':'','line_number':120,'multiline':False]
['text':' First does some busy-waiting for a fixed number of no-op cycles,','line_number':121,'multiline':False]
['text':' then falls back to passive waiting for the given condvar, guarded','line_number':122,'multiline':False]
['text':' by the given mutex.','line_number':123,'multiline':False]
['text':'','line_number':124,'multiline':False]
['text':' The idea of doing some initial busy-waiting is to help get','line_number':125,'multiline':False]
['text':' better and more consistent multithreading benefits for small GEMM sizes.','line_number':126,'multiline':False]
['text':' Busy-waiting help ensuring that if we need to wake up soon after having','line_number':127,'multiline':False]
['text':' started waiting, then we can wake up quickly (as opposed to, say,','line_number':128,'multiline':False]
['text':' having to wait to be scheduled again by the OS). On the other hand,','line_number':129,'multiline':False]
['text':' we must still eventually revert to passive waiting for longer waits','line_number':130,'multiline':False]
['text':' (e.g. worker threads having finished a GEMM and waiting until the next GEMM)','line_number':131,'multiline':False]
['text':' so as to avoid permanently spinning.','line_number':132,'multiline':False]
['text':'','line_number':133,'multiline':False]
['text':' If we are on a platform that supports it, spin for some time.','line_number':139,'multiline':False]
['text':' First, trivial case where the variable already changed value.','line_number':142,'multiline':False]
['text':' Then try busy-waiting.','line_number':148,'multiline':False]
['text':' Finally, do real passive waiting.','line_number':159,'multiline':False]
['text':' Handle spurious wakeups.','line_number':163,'multiline':False]
['text':' A BlockingCounter lets one thread to wait for N events to occur.','line_number':173,'multiline':False]
['text':' This is how the master thread waits for all the worker threads','line_number':174,'multiline':False]
['text':' to have finished working.','line_number':175,'multiline':False]
['text':' Sets/resets the counter; initial_count is the number of','line_number':178,'multiline':False]
['text':' decrementing events that the Wait() call will be waiting for.','line_number':179,'multiline':False]
['text':' Decrements the counter; if the counter hits zero, signals','line_number':186,'multiline':False]
['text':' the thread that was waiting for that, and returns true.','line_number':187,'multiline':False]
['text':' Otherwise (if the decremented count is still nonzero),','line_number':188,'multiline':False]
['text':' returns false.','line_number':189,'multiline':False]
['text':' Waits for the N other threads (N having been set by Reset())','line_number':201,'multiline':False]
['text':' to hit the BlockingCounter.','line_number':202,'multiline':False]
['text':' A workload for a worker.','line_number':215,'multiline':False]
['text':' A worker thread.','line_number':222,'multiline':False]
['text':' The initial state before the thread main loop runs.','line_number':226,'multiline':False]
['text':' Is not working, has not yet received new work to do.','line_number':227,'multiline':False]
['text':' Has work to do.','line_number':228,'multiline':False]
['text':' Should exit at earliest convenience.','line_number':229,'multiline':False]
['text':' Changes State; may be called from either the worker thread','line_number':244,'multiline':False]
['text':' or the master thread; however, not all state transitions are legal,','line_number':245,'multiline':False]
['text':' which is guarded by assertions.','line_number':246,'multiline':False]
['text':' Thread entry point.','line_number':270,'multiline':False]
['text':' Thread main loop','line_number':275,'multiline':False]
['text':' Get a state to act on','line_number':277,'multiline':False]
['text':' In the 'Ready' state, we have nothing to do but to wait until','line_number':278,'multiline':False]
['text':' we switch to another state.','line_number':279,'multiline':False]
['text':' We now have a state to act on, so act.','line_number':283,'multiline':False]
['text':' Got work to do! So do it, and then revert to 'Ready' state.','line_number':286,'multiline':False]
['text':' Called by the master thread to give this worker work to do.','line_number':305,'multiline':False]
['text':' It is only legal to call this if the worker','line_number':306,'multiline':False]
['text':' The underlying thread.','line_number':315,'multiline':False]
['text':' The task to be worked on.','line_number':318,'multiline':False]
['text':' The condition variable and mutex guarding state changes.','line_number':321,'multiline':False]
['text':' The state enum tells if we're currently working, waiting for work, etc.','line_number':325,'multiline':False]
['text':' pointer to the master's thread BlockingCounter object, to notify the','line_number':328,'multiline':False]
['text':' master thread of when this worker switches to the 'Ready' state.','line_number':329,'multiline':False]
['text':' One of the tasks will be run on the current thread.','line_number':339,'multiline':False]
['text':' Execute the remaining workload immediately on the current thread.','line_number':347,'multiline':False]
['text':' Wait for the workers submitted above to finish.','line_number':350,'multiline':False]
['text':' Ensures that the pool has at least the given count of workers.','line_number':355,'multiline':False]
['text':' If any new worker has to be created, this function waits for it to','line_number':356,'multiline':False]
['text':' be ready.','line_number':357,'multiline':False]
['text':' The BlockingCounter used to wait for the workers.','line_number':371,'multiline':False]
['text':' namespace caffe2','line_number':374,'multiline':False]
