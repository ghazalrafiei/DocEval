['text':' compute the block in X.','line_number':31,'multiline':False]
['text':' zero'd already.','line_number':38,'multiline':False]
['text':' Use unsigned integer math to avoid multiple comparisons (>= H, < 0).','line_number':91,'multiline':False]
['text':' compute the block in X.','line_number':147,'multiline':False]
['text':' In our NEON kernel we read up to TileSize, so align allocation to TileSize elements.','line_number':162,'multiline':False]
['text':' TODO: pass pre-resized output?','line_number':194,'multiline':False]
['text':' TODO: handle strides?','line_number':195,'multiline':False]
['text':' We can do a larger memcpy, of size KW * KC','line_number':230,'multiline':False]
['text':' Use unsigned integer math to avoid multiple comparisons (>= H, < 0).','line_number':239,'multiline':False]
['text':' This should be simply padded with zero.','line_number':246,'multiline':False]
['text':' TODO: incorporate center distance normalization.','line_number':276,'multiline':False]
['text':' Since inputs to convs are [0, 1, 2, 3], instead of [0, x, 2 * x, ...],','line_number':277,'multiline':False]
['text':' we can just uniformly rescale the outputs by x, i.e.,','line_number':278,'multiline':False]
['text':' for (auto i = 0; i < r->WQL1Norm.size(); ++i) {','line_number':279,'multiline':False]
['text':'   r->WQL1Norm.mutable_data<float>()[i] *= center_distance;','line_number':280,'multiline':False]
['text':' }','line_number':281,'multiline':False]
['text':' TODO: Support multiple quantization methods instead of assuming 2b1b.','line_number':365,'multiline':False]
['text':' namespace caffe2','line_number':387,'multiline':False]
