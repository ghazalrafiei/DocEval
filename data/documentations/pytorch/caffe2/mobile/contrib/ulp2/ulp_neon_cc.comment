['text':' TODO: tune this with cache size detection code. Changing to 32 helps on some','line_number':8,'multiline':False]
['text':' devices (Snapdragon 820).','line_number':9,'multiline':False]
['text':' Applies 2-bit uniform quantization to the floating point data at Xdata,','line_number':14,'multiline':False]
['text':' storing QC bytes into XQdata (i.e. reading 8 * QC floats from Xdata).','line_number':15,'multiline':False]
['text':' Requires QC to be a multiple of 8.','line_number':16,'multiline':False]
['text':' logic.','line_number':40,'multiline':False]
['text':' if (v >= offset + inter_center_distance) {','line_number':41,'multiline':False]
['text':'   p[1] |= 1 << b;','line_number':42,'multiline':False]
['text':' } else {','line_number':43,'multiline':False]
['text':'   p[1] |= 0 << b;','line_number':44,'multiline':False]
['text':' }','line_number':45,'multiline':False]
['text':' if ((v >= offset && v < offset + inter_center_distance) ||','line_number':47,'multiline':False]
['text':'     (v >= offset * 2 * inter_center_distance)) {','line_number':48,'multiline':False]
['text':'   p[0] |= 1 << b;','line_number':49,'multiline':False]
['text':' } else {','line_number':50,'multiline':False]
['text':'   p[0] |= 0 << b;','line_number':51,'multiline':False]
['text':' }','line_number':52,'multiline':False]
['text':' Each worker loads an L1 cache sized block.','line_number':115,'multiline':False]
['text':' We read/write B * K * 4 + 2 * B * (K / 8), so to fit inside C, we have','line_number':116,'multiline':False]
['text':' B = 4 * C / 17 K.','line_number':117,'multiline':False]
['text':' QCUnroll = 0;','line_number':118,'multiline':False]
['text':' compute the block in X.','line_number':129,'multiline':False]
['text':' zero'd already.','line_number':136,'multiline':False]
['text':' Each worker loads an L1 cache sized block.','line_number':176,'multiline':False]
['text':' We read/write B * K * TileSize * 4 + 2 * B * TileSize * (K / 8), so to fit inside C, we have','line_number':177,'multiline':False]
['text':' B = 4 * C / (17 * K * TileSize).','line_number':178,'multiline':False]
['text':' we have a full tile. Just memcpy.','line_number':187,'multiline':False]
['text':' We can just read the stripe directly.','line_number':208,'multiline':False]
['text':' We need to pad the stripe to the full amount read by','line_number':212,'multiline':False]
['text':' quantize2bNeon.','line_number':213,'multiline':False]
['text':' Packs a matrix (of size MxK) into a tiled array of size','line_number':227,'multiline':False]
['text':' (M/TileSize)x(K/TileDepthBytes)xTileSizexTileDepthBytes.','line_number':228,'multiline':False]
['text':' Load L1 sized tiles per thread.','line_number':239,'multiline':False]
['text':' We read/write 2 * B * QK * TileSize bytes, so','line_number':240,'multiline':False]
['text':' B = C / (2 * QK * TileSize)','line_number':241,'multiline':False]
['text':' we have a full tile. Just memcpy.','line_number':250,'multiline':False]
['text':' get value from X','line_number':266,'multiline':False]
['text':' Computes the kUnrollM x kUnrollM tile of a GEMM by multiplying two packed','line_number':279,'multiline':False]
['text':' slices of size (kUnrolLMxK). These tiles are constructed by the qpack_tiles','line_number':280,'multiline':False]
['text':' function, which packs an input array of size [M][K] into an','line_number':281,'multiline':False]
['text':' [M/TileSize][K/TileDepthBytes][TileSize][TileDepthBytes], which ensures all','line_number':282,'multiline':False]
['text':' the array accesses in this function is contiguous.','line_number':283,'multiline':False]
['text':' Computes the (normal + transpose) matrix-matrix product of two -1/1 binary','line_number':354,'multiline':False]
['text':' matrices, laid out in the standard format.','line_number':355,'multiline':False]
['text':' Assume TxT tile. Each input slice is of size T x (K/8) bytes, and the output','line_number':379,'multiline':False]
['text':' is a tile of size T x T x sizeof(float) bytes. We want the sum of this to fit','line_number':380,'multiline':False]
['text':' in L1 cache. This means for a block number of tiles B , we load B * T * K /','line_number':381,'multiline':False]
['text':' 8 + B * T * K / 8 + B * B * T * T * sizeof(float).','line_number':382,'multiline':False]
['text':' If cache size = C, we get','line_number':384,'multiline':False]
['text':' B = 1/(32 * T) (sqrt(256 C + K^2) - K)','line_number':385,'multiline':False]
['text':' taking floor (by integer division), gives the result.','line_number':386,'multiline':False]
['text':' Assume 16KB L1 cache.','line_number':388,'multiline':False]
['text':' A layout: [M/TileSize][QK / TileDepth][TileSize][TileDepth]','line_number':415,'multiline':False]
['text':' C layout: [M/TileSize][TileSize][N/TileSize][TileSize]','line_number':416,'multiline':False]
['text':' TODO: packing + quantization in same block.','line_number':432,'multiline':False]
['text':' We can fuse the bias addition into the filter normalization. We can','line_number':448,'multiline':False]
['text':' replace the bias + 3/2 normalization factor by replacing normalization','line_number':449,'multiline':False]
['text':' with (2/3 bias + normalization), and setting bias to zero.','line_number':450,'multiline':False]
['text':' If we have to pad when we pack our weight tiles, then we need to adjust','line_number':458,'multiline':False]
['text':' the normalization factor by the number of zeros that we added.','line_number':459,'multiline':False]
['text':' Since 1x1s are so common, we fuse the quantization + packing steps.','line_number':468,'multiline':False]
['text':' We can run inplace by operating on our Y vector, and then shrinking Y.','line_number':483,'multiline':False]
['text':' acc[c] = 3/2 WQN[c] + 1/2 value[c];','line_number':505,'multiline':False]
['text':' In this case, the stride does not match, so we need to copy the output','line_number':529,'multiline':False]
['text':' data into the contiguous Y matrix.','line_number':530,'multiline':False]
['text':' TODO: insert specialized cases (e.g. depthwise convolutions, the direct','line_number':546,'multiline':False]
['text':' convolution.','line_number':547,'multiline':False]
['text':' namespace caffe2','line_number':555,'multiline':False]
