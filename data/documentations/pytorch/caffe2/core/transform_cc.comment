['text':' checks if the node at index i is matched already or not','line_number':16,'multiline':False]
['text':' stores matches, which are ordered subgraphs of G','line_number':19,'multiline':False]
['text':' Consider every possible node as the starting point.','line_number':22,'multiline':False]
['text':' The current working subgraph. We will try to add new nodes to this,','line_number':24,'multiline':False]
['text':' when invoking the PatternRule.','line_number':25,'multiline':False]
['text':' The largest "validated" subgraph found so far.','line_number':28,'multiline':False]
['text':' This will be mutated by PatternMatchHelper.','line_number':29,'multiline':False]
['text':' Only begin to match if the start node is accepted.','line_number':32,'multiline':False]
['text':' match found','line_number':38,'multiline':False]
['text':' If the current subgraph is valid, and the largest we've seen so far,','line_number':77,'multiline':False]
['text':' make it the best_subgraph.','line_number':78,'multiline':False]
['text':' Connected Component Order Pattern Matching','line_number':87,'multiline':False]
['text':' We want to match subgraphs which are connected ConnectedComponents','line_number':88,'multiline':False]
['text':' Try adding each parent and child of every node in the subgraph,','line_number':90,'multiline':False]
['text':' and see if we can accept it.','line_number':91,'multiline':False]
['text':' Sorted Execution Order Pattern matching','line_number':114,'multiline':False]
['text':' We want to be able to match subgraphs in sorted execution order','line_number':115,'multiline':False]
['text':' We can safely assume our subgraph is already sorted.','line_number':117,'multiline':False]
['text':' This means, we only need to consider nodes that come after the LAST','line_number':118,'multiline':False]
['text':' node in our current subgraph.','line_number':119,'multiline':False]
['text':' Thus, we simply iterate over the nodes that come AFTER the last node of','line_number':120,'multiline':False]
['text':' our current subgraph.','line_number':121,'multiline':False]
['text':' General Pattern matching','line_number':134,'multiline':False]
['text':' We want to be able to match any ordered subgraph','line_number':135,'multiline':False]
['text':' For every current subgraph, we consider all nodes to be','line_number':137,'multiline':False]
['text':' the next candidate node, as long as it isn't already matched.','line_number':138,'multiline':False]
['text':' Then we try appending it to the subgraph.','line_number':141,'multiline':False]
['text':' Make sure each matched node is still active (not overwritten)','line_number':158,'multiline':False]
['text':' Simply try to apply the replace rule upon every match.','line_number':166,'multiline':False]
['text':' The simple interface - performs the transformation upon a NetDef, and returns','line_number':173,'multiline':False]
['text':' the result.','line_number':174,'multiline':False]
['text':' Create a Transform object','line_number':182,'multiline':False]
['text':' Create a Transform object from registry,','line_number':189,'multiline':False]
['text':' and immediately apply it to a Netdef.','line_number':190,'multiline':False]
['text':' If a proper init_net is not provided, then this is the best we can do.','line_number':207,'multiline':False]
['text':' NOLINTNEXTLINE(performance-for-range-copy)','line_number':208,'multiline':False]
['text':' Create a Transform object from registry, apply it to a NetDef.','line_number':237,'multiline':False]
['text':' Will only return the transformed net if it is faster than the old net.','line_number':238,'multiline':False]
['text':' This will run the init net first, will run the two nets warmup_runs times.','line_number':239,'multiline':False]
['text':' Then, we will take the average time of main_runs runs, and only keep the','line_number':240,'multiline':False]
['text':' transformed net if it is faster by a factor of improvement_threshold.','line_number':241,'multiline':False]
['text':' namespace Caffe2','line_number':260,'multiline':False]
