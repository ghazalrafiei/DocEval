['text':' The reference implementation is susceptible to numerical cancellation when','line_number':15,'multiline':False]
['text':' *lambda1* is small and *data* is near one. We leave it up to the caller to','line_number':16,'multiline':False]
['text':' truncate lambda to zero or bound data away from one. Unfortunately, the C++','line_number':17,'multiline':False]
['text':' implementation may be using higher precision than the python version, which','line_number':18,'multiline':False]
['text':' could cause this test to fail. We bound inputs away from the critical values.','line_number':19,'multiline':False]
['text':' (Note that a tolerance of 1e-6 on _either_ parameter is typically sufficient','line_number':20,'multiline':False]
['text':' to avoid catastrophic cancellation when the other is far from zero/one.)','line_number':21,'multiline':False]
['text':' N, D, data, lambda1, lambda2','line_number':29,'multiline':False]
['text':' Bound data away from one. See comment in _inputs() above.','line_number':106,'multiline':False]
['text':' Note examples above with D=5, 6, 7.','line_number':132,'multiline':False]
['text':' A zero value falls back to the naive implementation.','line_number':133,'multiline':False]
