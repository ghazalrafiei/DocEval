['text':' Enqueuing more should fail now since the queue is closed','line_number':106,'multiline':False]
['text':' Dequeuing more should fail now since the queue is closed','line_number':112,'multiline':False]
['text':'## Init ###','line_number':180,'multiline':False]
['text':'## Producers ###','line_number':188,'multiline':False]
['text':'## Consumers ###','line_number':217,'multiline':False]
['text':' Extend is atomic','line_number':221,'multiline':False]
['text':' This is just a way of deterministally read all the elements.','line_number':226,'multiline':False]
['text':' We make `num_consumers` almost equal splits','line_number':227,'multiline':False]
['text':' (the reminder goes to the last consumer).','line_number':228,'multiline':False]
['text':' If we have nothing to read this consumer will be idle','line_number':234,'multiline':False]
['text':' Now we have to make a split on number of iterations and the read','line_number':238,'multiline':False]
['text':' size for each iteration. This is again just one of many','line_number':239,'multiline':False]
['text':' deterministic  ways of doing it. We factorize the total number of','line_number':240,'multiline':False]
['text':' elements we have to read and assign half of the factors to the','line_number':241,'multiline':False]
['text':' iterations half to the read size.','line_number':242,'multiline':False]
['text':'## Execute Plan ###','line_number':272,'multiline':False]
['text':'## Check Results ###','line_number':279,'multiline':False]
['text':' We check that the outputs are a permutation of inputs','line_number':280,'multiline':False]
