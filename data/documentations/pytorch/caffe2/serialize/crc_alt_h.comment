['text':' //////////////////////////////////////////////////////////','line_number':3,'multiline':False]
['text':' Crc32.h','line_number':4,'multiline':False]
['text':' Copyright (c) 2011-2019 Stephan Brumme. All rights reserved.','line_number':5,'multiline':False]
['text':' Slicing-by-16 contributed by Bulat Ziganshin','line_number':6,'multiline':False]
['text':' Tableless bytewise CRC contributed by Hagai Gold','line_number':7,'multiline':False]
['text':' see http://create.stephan-brumme.com/disclaimer.html','line_number':8,'multiline':False]
['text':'','line_number':9,'multiline':False]
['text':' if running on an embedded system, you might consider shrinking the','line_number':11,'multiline':False]
['text':' big Crc32Lookup table by undefining these lines:','line_number':12,'multiline':False]
['text':' - crc32_bitwise  doesn't need it at all','line_number':17,'multiline':False]
['text':' - crc32_halfbyte has its own small lookup table','line_number':18,'multiline':False]
['text':' - crc32_1byte_tableless and crc32_1byte_tableless2 don't need it at all','line_number':19,'multiline':False]
['text':' - crc32_1byte    needs only Crc32Lookup[0]','line_number':20,'multiline':False]
['text':' - crc32_4bytes   needs only Crc32Lookup[0..3]','line_number':21,'multiline':False]
['text':' - crc32_8bytes   needs only Crc32Lookup[0..7]','line_number':22,'multiline':False]
['text':' - crc32_4x8bytes needs only Crc32Lookup[0..7]','line_number':23,'multiline':False]
['text':' - crc32_16bytes  needs all of Crc32Lookup','line_number':24,'multiline':False]
['text':' using the aforementioned #defines the table is automatically fitted to your needs','line_number':25,'multiline':False]
['text':' uint8_t, uint32_t, int32_t','line_number':27,'multiline':False]
['text':' size_t','line_number':29,'multiline':False]
['text':' crc32_fast selects the fastest algorithm depending on flags (CRC32_USE_LOOKUP_...)','line_number':32,'multiline':False]
['text':'/ compute CRC32 using the fastest algorithm for large datasets on modern CPUs','line_number':33,'multiline':False]
['text':'/ merge two CRC32 such that result = crc32(dataB, lengthB, crc32(dataA, lengthA))','line_number':36,'multiline':False]
['text':'/ compute CRC32 (bitwise algorithm)','line_number':39,'multiline':False]
['text':'/ compute CRC32 (half-byte algoritm)','line_number':41,'multiline':False]
['text':'/ compute CRC32 (standard algorithm)','line_number':45,'multiline':False]
['text':'/ compute CRC32 (byte algorithm) without lookup tables','line_number':49,'multiline':False]
['text':'/ compute CRC32 (byte algorithm) without lookup tables','line_number':51,'multiline':False]
['text':'/ compute CRC32 (Slicing-by-4 algorithm)','line_number':55,'multiline':False]
['text':'/ compute CRC32 (Slicing-by-8 algorithm)','line_number':60,'multiline':False]
['text':'/ compute CRC32 (Slicing-by-8 algorithm), unroll inner loop 4 times','line_number':62,'multiline':False]
['text':'/ compute CRC32 (Slicing-by-16 algorithm)','line_number':67,'multiline':False]
['text':'/ compute CRC32 (Slicing-by-16 algorithm, prefetch upcoming data blocks)','line_number':69,'multiline':False]
['text':' //////////////////////////////////////////////////////////','line_number':73,'multiline':False]
['text':' Crc32.cpp','line_number':74,'multiline':False]
['text':' Copyright (c) 2011-2019 Stephan Brumme. All rights reserved.','line_number':75,'multiline':False]
['text':' Slicing-by-16 contributed by Bulat Ziganshin','line_number':76,'multiline':False]
['text':' Tableless bytewise CRC contributed by Hagai Gold','line_number':77,'multiline':False]
['text':' see http://create.stephan-brumme.com/disclaimer.html','line_number':78,'multiline':False]
['text':'','line_number':79,'multiline':False]
['text':' if running on an embedded system, you might consider shrinking the','line_number':81,'multiline':False]
['text':' big Crc32Lookup table:','line_number':82,'multiline':False]
['text':' - crc32_bitwise  doesn't need it at all','line_number':83,'multiline':False]
['text':' - crc32_halfbyte has its own small lookup table','line_number':84,'multiline':False]
['text':' - crc32_1byte    needs only Crc32Lookup[0]','line_number':85,'multiline':False]
['text':' - crc32_4bytes   needs only Crc32Lookup[0..3]','line_number':86,'multiline':False]
['text':' - crc32_8bytes   needs only Crc32Lookup[0..7]','line_number':87,'multiline':False]
['text':' - crc32_4x8bytes needs only Crc32Lookup[0..7]','line_number':88,'multiline':False]
['text':' - crc32_16bytes  needs all of Crc32Lookup','line_number':89,'multiline':False]
['text':' define endianess and some integer data types','line_number':99,'multiline':False]
['text':' Windows always little endian','line_number':101,'multiline':False]
['text':' intrinsics / prefetching','line_number':104,'multiline':False]
['text':' defines __BYTE_ORDER as __LITTLE_ENDIAN or __BIG_ENDIAN','line_number':146,'multiline':False]
['text':' intrinsics / prefetching','line_number':150,'multiline':False]
['text':' no prefetching','line_number':155,'multiline':False]
['text':' abort if byte order is undefined','line_number':160,'multiline':False]
['text':'/ zlib's CRC32 polynomial','line_number':168,'multiline':False]
['text':'/ swap endianess','line_number':171,'multiline':False]
['text':'/ Slicing-By-16','line_number':184,'multiline':False]
['text':' don't need Crc32Lookup at all','line_number':194,'multiline':False]
['text':' anonymous namespace','line_number':197,'multiline':False]
['text':'/ forward declaration, table is at the end of this file','line_number':200,'multiline':False]
['text':' extern is needed to keep compiler happy','line_number':201,'multiline':False]
['text':'/ compute CRC32 (bitwise algorithm)','line_number':205,'multiline':False]
['text':' same as previousCrc32 ^ 0xFFFFFFFF','line_number':208,'multiline':False]
['text':' branch-free','line_number':217,'multiline':False]
['text':' branching, much slower:','line_number':220,'multiline':False]
['text':'if (crc & 1)','line_number':221,'multiline':False]
['text':'  crc = (crc >> 1) ^ Polynomial;','line_number':222,'multiline':False]
['text':'else','line_number':223,'multiline':False]
['text':'  crc =  crc >> 1;','line_number':224,'multiline':False]
['text':' same as crc ^ 0xFFFFFFFF','line_number':228,'multiline':False]
['text':'/ compute CRC32 (half-byte algoritm)','line_number':232,'multiline':False]
['text':' same as previousCrc32 ^ 0xFFFFFFFF','line_number':235,'multiline':False]
['text':'/ look-up table for half-byte, same as crc32Lookup[0][16*i]','line_number':238,'multiline':False]
['text':' same as crc ^ 0xFFFFFFFF','line_number':252,'multiline':False]
['text':'/ compute CRC32 (standard algorithm)','line_number':257,'multiline':False]
['text':' same as previousCrc32 ^ 0xFFFFFFFF','line_number':260,'multiline':False]
['text':' same as crc ^ 0xFFFFFFFF','line_number':266,'multiline':False]
['text':'/ compute CRC32 (byte algorithm) without lookup tables','line_number':271,'multiline':False]
['text':' same as previousCrc32 ^ 0xFFFFFFFF','line_number':274,'multiline':False]
['text':' Hagai Gold made me aware of this table-less algorithm and send me code','line_number':281,'multiline':False]
['text':' polynomial 0xEDB88320 can be written in binary as 11101101101110001000001100100000b','line_number':283,'multiline':False]
['text':' reverse the bits (or just assume bit 0 is the first one)','line_number':284,'multiline':False]
['text':' and we have bits set at position 0, 1, 2, 4, 5, 7, 8, 10, 11, 12, 16, 22, 23, 26','line_number':285,'multiline':False]
['text':' => those are the shift offsets:','line_number':286,'multiline':False]
['text':'crc = (crc >> 8) ^','line_number':287,'multiline':False]
['text':'       t ^','line_number':288,'multiline':False]
['text':'      (t >>  1) ^ (t >>  2) ^ (t >>  4) ^ (t >>  5) ^  // == y','line_number':289,'multiline':False]
['text':'      (t >>  7) ^ (t >>  8) ^ (t >> 10) ^ (t >> 11) ^  // == y >> 6','line_number':290,'multiline':False]
['text':'      (t >> 12) ^ (t >> 16) ^                          // == z','line_number':291,'multiline':False]
['text':'      (t >> 22) ^ (t >> 26) ^                          // == z >> 10','line_number':292,'multiline':False]
['text':'      (t >> 23);','line_number':293,'multiline':False]
['text':' the fastest I can come up with:','line_number':295,'multiline':False]
['text':' Hagai's code:','line_number':307,'multiline':False]
['text':'uint32_t t = (s ^ (s << 6)) << 24;
    // some temporaries to optimize XOR
    uint32_t x = (t >> 1) ^ (t >> 2);
    uint32_t y = x ^ (x >> 3);
    uint32_t z = (t >> 12) ^ (t >> 16);
    crc = (crc >> 8) ^
           t ^ (t >> 23) ^
           y ^ (y >>  6) ^
           z ^ (z >> 10);','line_number':308,'multiline':True]
['text':' same as crc ^ 0xFFFFFFFF','line_number':319,'multiline':False]
['text':'/ compute CRC32 (byte algorithm) without lookup tables','line_number':323,'multiline':False]
['text':' note: signed integer, right shift distributes sign bit into lower bits','line_number':326,'multiline':False]
['text':' convert to unsigned integer before right shift','line_number':342,'multiline':False]
['text':' same as crc ^ 0xFFFFFFFF','line_number':345,'multiline':False]
['text':'/ compute CRC32 (Slicing-by-4 algorithm)','line_number':350,'multiline':False]
['text':' same as previousCrc32 ^ 0xFFFFFFFF','line_number':353,'multiline':False]
['text':' process four bytes at once (Slicing-by-4)','line_number':356,'multiline':False]
['text':' remaining 1 to 3 bytes (standard algorithm)','line_number':377,'multiline':False]
['text':' same as crc ^ 0xFFFFFFFF','line_number':381,'multiline':False]
['text':'/ compute CRC32 (Slicing-by-8 algorithm)','line_number':387,'multiline':False]
['text':' same as previousCrc32 ^ 0xFFFFFFFF','line_number':390,'multiline':False]
['text':' process eight bytes at once (Slicing-by-8)','line_number':393,'multiline':False]
['text':' remaining 1 to 7 bytes (standard algorithm)','line_number':424,'multiline':False]
['text':' same as crc ^ 0xFFFFFFFF','line_number':428,'multiline':False]
['text':'/ compute CRC32 (Slicing-by-8 algorithm), unroll inner loop 4 times','line_number':432,'multiline':False]
['text':' same as previousCrc32 ^ 0xFFFFFFFF','line_number':435,'multiline':False]
['text':' enabling optimization (at least -O2) automatically unrolls the inner for-loop','line_number':438,'multiline':False]
['text':' process 4x eight bytes at once (Slicing-by-8)','line_number':442,'multiline':False]
['text':' remaining 1 to 31 bytes (standard algorithm)','line_number':477,'multiline':False]
['text':' same as crc ^ 0xFFFFFFFF','line_number':481,'multiline':False]
['text':' CRC32_USE_LOOKUP_TABLE_SLICING_BY_8','line_number':483,'multiline':False]
['text':'/ compute CRC32 (Slicing-by-16 algorithm)','line_number':487,'multiline':False]
['text':' same as previousCrc32 ^ 0xFFFFFFFF','line_number':490,'multiline':False]
['text':' enabling optimization (at least -O2) automatically unrolls the inner for-loop','line_number':493,'multiline':False]
['text':' remaining 1 to 63 bytes (standard algorithm)','line_number':550,'multiline':False]
['text':' same as crc ^ 0xFFFFFFFF','line_number':554,'multiline':False]
['text':'/ compute CRC32 (Slicing-by-16 algorithm, prefetch upcoming data blocks)','line_number':558,'multiline':False]
['text':' CRC code is identical to crc32_16bytes (including unrolling), only added prefetching','line_number':561,'multiline':False]
['text':' 256 bytes look-ahead seems to be the sweet spot on Core i7 CPUs','line_number':562,'multiline':False]
['text':' same as previousCrc32 ^ 0xFFFFFFFF','line_number':564,'multiline':False]
['text':' enabling optimization (at least -O2) automatically unrolls the for-loop','line_number':567,'multiline':False]
['text':' remaining 1 to 63 bytes (standard algorithm)','line_number':626,'multiline':False]
['text':' same as crc ^ 0xFFFFFFFF','line_number':630,'multiline':False]
['text':'/ compute CRC32 using the fastest algorithm for large datasets on modern CPUs','line_number':635,'multiline':False]
['text':'/ merge two CRC32 such that result = crc32(dataB, lengthB, crc32(dataA, lengthA))','line_number':652,'multiline':False]
['text':' based on Mark Adler's crc_combine from','line_number':655,'multiline':False]
['text':' https://github.com/madler/pigz/blob/master/pigz.c','line_number':656,'multiline':False]
['text':' main idea:','line_number':658,'multiline':False]
['text':' - if you have two equally-sized blocks A and B,','line_number':659,'multiline':False]
['text':'   then you can create a block C = A ^ B','line_number':660,'multiline':False]
['text':'   which has the property crc(C) = crc(A) ^ crc(B)','line_number':661,'multiline':False]
['text':' - if you append length(B) zeros to A and call it A' (think of it as AAAA000)','line_number':662,'multiline':False]
['text':'   and   prepend length(A) zeros to B and call it B' (think of it as 0000BBB)','line_number':663,'multiline':False]
['text':'   then exists a C' = A' ^ B'','line_number':664,'multiline':False]
['text':' - remember: if you XOR someting with zero, it remains unchanged: X ^ 0 = X','line_number':665,'multiline':False]
['text':' - that means C' = A concat B so that crc(A concat B) = crc(C') = crc(A') ^ crc(B')','line_number':666,'multiline':False]
['text':' - the trick is to compute crc(A') based on crc(A)','line_number':667,'multiline':False]
['text':'                       and crc(B') based on crc(B)','line_number':668,'multiline':False]
['text':' - since B' starts with many zeros, the crc of those initial zeros is still zero','line_number':669,'multiline':False]
['text':' - that means crc(B') = crc(B)','line_number':670,'multiline':False]
['text':' - unfortunately the trailing zeros of A' change the crc, so usually crc(A') != crc(A)','line_number':671,'multiline':False]
['text':' - the following code is a fast algorithm to compute crc(A')','line_number':672,'multiline':False]
['text':' - starting with crc(A) and appending length(B) zeros, needing just log2(length(B)) iterations','line_number':673,'multiline':False]
['text':' - the details are explained by the original author at','line_number':674,'multiline':False]
['text':'   https://stackoverflow.com/questions/23122312/crc-calculation-of-a-mostly-static-data-stream/23126768','line_number':675,'multiline':False]
['text':'','line_number':676,'multiline':False]
['text':' notes:','line_number':677,'multiline':False]
['text':' - I squeezed everything into one function to keep global namespace clean (original code two helper functions)','line_number':678,'multiline':False]
['text':' - most original comments are still in place, I added comments where these helper functions where made inline code','line_number':679,'multiline':False]
['text':' - performance-wise there isn't any differenze to the original zlib/pigz code','line_number':680,'multiline':False]
['text':' degenerated case','line_number':682,'multiline':False]
['text':'/ CRC32 => 32 bits','line_number':686,'multiline':False]
['text':' odd-power-of-two  zeros operator','line_number':689,'multiline':False]
['text':' even-power-of-two zeros operator','line_number':690,'multiline':False]
['text':' put operator for one zero bit in odd','line_number':692,'multiline':False]
['text':' CRC-32 polynomial','line_number':693,'multiline':False]
['text':' put operator for two zero bits in even','line_number':697,'multiline':False]
['text':' same as gf2_matrix_square(even, odd);','line_number':698,'multiline':False]
['text':' put operator for four zero bits in odd','line_number':707,'multiline':False]
['text':' same as gf2_matrix_square(odd, even);','line_number':708,'multiline':False]
['text':' the following loop becomes much shorter if I keep swapping even and odd','line_number':718,'multiline':False]
['text':' apply secondLength zeros to firstCrc32','line_number':721,'multiline':False]
['text':' same as gf2_matrix_square(a, b);','line_number':724,'multiline':False]
['text':' apply zeros operator for this bit','line_number':734,'multiline':False]
['text':' same as firstCrc32 = gf2_matrix_times(a, firstCrc32);','line_number':737,'multiline':False]
['text':' switch even and odd','line_number':745,'multiline':False]
['text':' return combined crc','line_number':749,'multiline':False]
['text':' //////////////////////////////////////////////////////////','line_number':754,'multiline':False]
['text':' constants','line_number':755,'multiline':False]
['text':'/ look-up table, already declared above','line_number':759,'multiline':False]
['text':'// same algorithm as crc32_bitwise','line_number':762,'multiline':False]
['text':'for (int i = 0; i <= 0xFF; i++)','line_number':763,'multiline':False]
['text':'{','line_number':764,'multiline':False]
['text':'  uint32_t crc = i;','line_number':765,'multiline':False]
['text':'  for (int j = 0; j < 8; j++)','line_number':766,'multiline':False]
['text':'    crc = (crc >> 1) ^ ((crc & 1) * Polynomial);','line_number':767,'multiline':False]
['text':'  Crc32Lookup[0][i] = crc;','line_number':768,'multiline':False]
['text':'}','line_number':769,'multiline':False]
['text':'// ... and the following slicing-by-8 algorithm (from Intel):','line_number':770,'multiline':False]
['text':'// http://www.intel.com/technology/comms/perfnet/download/CRC_generators.pdf','line_number':771,'multiline':False]
['text':'// http://sourceforge.net/projects/slicing-by-8/','line_number':772,'multiline':False]
['text':'for (int slice = 1; slice < MaxSlice; slice++)','line_number':773,'multiline':False]
['text':'  Crc32Lookup[slice][i] = (Crc32Lookup[slice - 1][i] >> 8) ^ Crc32Lookup[0][Crc32Lookup[slice - 1][i] & 0xFF];','line_number':774,'multiline':False]
['text':' note: the first number of every second row corresponds to the half-byte look-up table !','line_number':776,'multiline':False]
['text':' beyond this point only relevant for Slicing-by-4, Slicing-by-8 and Slicing-by-16','line_number':812,'multiline':False]
['text':' defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_4) || defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_8) || defined(CRC32_USE_LOOKUP_TABLE_SLICING_BY_16)','line_number':917,'multiline':False]
['text':' beyond this point only relevant for Slicing-by-8 and Slicing-by-16','line_number':919,'multiline':False]
['text':' CRC32_USE_LOOKUP_TABLE_SLICING_BY_8 || CRC32_USE_LOOKUP_TABLE_SLICING_BY_16','line_number':1059,'multiline':False]
['text':' beyond this point only relevant for Slicing-by-16','line_number':1061,'multiline':False]
['text':' CRC32_USE_LOOKUP_TABLE_SLICING_BY_16','line_number':1341,'multiline':False]
