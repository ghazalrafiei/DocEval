['text':' conv_transpose_op_impl.h is the templated implementation of the','line_number':1,'multiline':False]
['text':' conv_transpose_op.h file.','line_number':2,'multiline':False]
['text':' The tile size is exactly the length of a single row','line_number':43,'multiline':False]
['text':' gemm tile','line_number':49,'multiline':False]
['text':' col2im tile','line_number':66,'multiline':False]
['text':' We assume that there is no padding in the columns (padL and padR','line_number':67,'multiline':False]
['text':' == 0).','line_number':68,'multiline':False]
['text':' FIXME: it is actually possible for us to handle padding, figure','line_number':69,'multiline':False]
['text':' out how to adjust the bounds','line_number':70,'multiline':False]
['text':' We write into Y in a de-interleaved fashion; in other words,','line_number':72,'multiline':False]
['text':' every column (mod strideW) == 0 together in one block,','line_number':73,'multiline':False]
['text':' every column (mod strideW) == 1 in another,','line_number':74,'multiline':False]
['text':' ... and so on.','line_number':75,'multiline':False]
['text':' Each row is a separate tile that we handle. First determine the','line_number':84,'multiline':False]
['text':' row into which we are writing the output.','line_number':85,'multiline':False]
['text':' We can properly handle padding for the rows.','line_number':86,'multiline':False]
['text':' If this row is out of bounds, then skip it','line_number':89,'multiline':False]
['text':' FIXME: we don't actually handle a dynamic padL > 0','line_number':94,'multiline':False]
['text':' However, within a block we may not start writing at offset','line_number':99,'multiline':False]
['text':' 0. The offset at which we begin writing is determined by','line_number':100,'multiline':False]
['text':' colOffsetStart','line_number':101,'multiline':False]
['text':' So, this is where we begin reading/writing in Y','line_number':104,'multiline':False]
['text':' This is the complete offset into Y from the start','line_number':107,'multiline':False]
['text':' Each row has strideW blocks of size colBlockSize','line_number':108,'multiline':False]
['text':' We vectorize the loop within the row','line_number':117,'multiline':False]
['text':' Handle un-vectorizable epilogue','line_number':166,'multiline':False]
['text':' Each row in src is of the form:','line_number':253,'multiline':False]
['text':' [w mod strideW == 0 elements]...[w mod strideW == strideW - 1','line_number':254,'multiline':False]
['text':' elements]','line_number':255,'multiline':False]
['text':' We need to re-interleave the values and write them in the output','line_number':256,'multiline':False]
['text':' We need to interleave in terms of kStrideW units','line_number':275,'multiline':False]
['text':' add per-channel bias','line_number':284,'multiline':False]
['text':' Write interleaved into the output','line_number':290,'multiline':False]
['text':' Handle non-vectorizable remainder','line_number':299,'multiline':False]
['text':' add per-channel bias','line_number':307,'multiline':False]
['text':' Write interleaved into the output','line_number':312,'multiline':False]
['text':' We have handled 0 .. (inputW - 1) * stride inclusive so far.','line_number':319,'multiline':False]
['text':' Handle the remainder','line_number':320,'multiline':False]
['text':' Output width may include adjustment into which we don't','line_number':324,'multiline':False]
['text':' write; ignore it','line_number':325,'multiline':False]
['text':' Remainder of the buffer comprised of just the `adj` must have','line_number':339,'multiline':False]
['text':' bias added','line_number':340,'multiline':False]
['text':' # channels times height','line_number':360,'multiline':False]
['text':' Performs acc[i] += sum_j toSum_j[i] pointwise','line_number':504,'multiline':False]
['text':' Otherwise, use fallback implementation','line_number':519,'multiline':False]
['text':' Initialize per-thread buffers for output','line_number':570,'multiline':False]
['text':' The main thread will write directly into the output Y, we just','line_number':571,'multiline':False]
['text':' need buffers for the worker threads','line_number':572,'multiline':False]
['text':' Require 16 byte alignment, so 4-element alignment as these are floats.','line_number':575,'multiline':False]
['text':' Work around GCC 4.9 bug when this is declared inside the inner lambda.','line_number':580,'multiline':False]
['text':' Group together thread buffers for accumulation','line_number':615,'multiline':False]
['text':' Each time through, we have to reset all per-thread output','line_number':623,'multiline':False]
['text':' buffers, since the output buffer is only per-batch element','line_number':624,'multiline':False]
['text':' The column buffers are overwritten by the matrix multiplication','line_number':625,'multiline':False]
['text':' each time, so we need not clear them out each round','line_number':626,'multiline':False]
['text':' Run tiled gemm and col2im in our threadpool; all of these tiles','line_number':633,'multiline':False]
['text':' are guaranteed to be full tiles','line_number':634,'multiline':False]
['text':' Each tile handles a single row of the input','line_number':635,'multiline':False]
['text':' We need to accumulate the per-thread results into the output','line_number':642,'multiline':False]
['text':' Y; the first worker thread (main thread) already produced its','line_number':643,'multiline':False]
['text':' results in Y','line_number':644,'multiline':False]
['text':' y0 now contains the final output, but it is in deinterleaved','line_number':648,'multiline':False]
['text':' form. We have to re-interleave it to produce the final form in Y','line_number':649,'multiline':False]
['text':' This operation also handles adding the per-channel bias.','line_number':650,'multiline':False]
['text':' namespace caffe2','line_number':697,'multiline':False]
['text':' C10_MOBILE','line_number':699,'multiline':False]
['text':' CAFFE2_OPERATORS_CONV_TRANSPOSE_MOBILE_OP_IMPL_H_','line_number':701,'multiline':False]
