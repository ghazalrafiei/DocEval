['text':' This file describes the translation of JIT schema to API's used','line_number':23,'multiline':False]
['text':' when creating view lambdas that are used by the functionalization pass.','line_number':24,'multiline':False]
['text':' There are two types of lambdas: forward lambdas and reverse lambdas.','line_number':25,'multiline':False]
['text':' These API's mostly follow the dispatcher API, with a few quirks:','line_number':26,'multiline':False]
['text':' - The lambda capture has to convert reference types to value types','line_number':27,'multiline':False]
['text':' - While the forward lambda just directly calls into the at::_ops API','line_number':28,'multiline':False]
['text':'   (following the dispatcher convention), the logic here for the reverse lambda','line_number':29,'multiline':False]
['text':'   is responsible for generating both the call-site, and the declarations','line_number':30,'multiline':False]
['text':'   (which are implemented manually in the at::functionalization::impl namespace).','line_number':31,'multiline':False]
['text':' The lambdas generated for each view op in the functionalization pass are of the form','line_number':33,'multiline':False]
['text':' [capture_arguments](outer_arguments) -> returns_type {','line_number':34,'multiline':False]
['text':'     return name(inner_arguments);','line_number':35,'multiline':False]
['text':' }','line_number':36,'multiline':False]
['text':' Define some specific lambda input arguments.','line_number':38,'multiline':False]
['text':' The lambda capture itself doesn't have a name.','line_number':73,'multiline':False]
['text':' The name returned here corresponds to the name of the inner function called by the lambda.','line_number':74,'multiline':False]
['text':' reapply_views is only important for the fwd lambda,','line_number':83,'multiline':False]
['text':' since we always plumb the runtime "reapply_views" argument into the reverse function.','line_number':84,'multiline':False]
['text':' for the reverse: the name of the inverse function always involves "view_copy",','line_number':87,'multiline':False]
['text':' and we plumb the "reapply_views" flag into that function.','line_number':88,'multiline':False]
['text':' (We could avoid doing that, but that would require writing out twice as many view inverse functions).','line_number':89,'multiline':False]
['text':' in the reverse case, we codegen both the call-sites (which need the full namespace) and the declarations (which don't)','line_number':92,'multiline':False]
['text':' in the forward case, we just directly call into the at::_ops API (so we always need the namespace)','line_number':97,'multiline':False]
['text':' capture arguments include all arguments except `self`.','line_number':109,'multiline':False]
['text':' Importantly, they don't include any C++ reference types (or else we'll get a dangling reference in the capture),','line_number':110,'multiline':False]
['text':' So any reference types (IntArrayRef) need to be converted to value types (vector<int64_t>)','line_number':111,'multiline':False]
['text':' Assertion: all view ops return tensor-like outputs','line_number':123,'multiline':False]
['text':' However, the return type of the lambda is always an individual tensor.','line_number':127,'multiline':False]
['text':' For multi-tensor outputs, each tensor needs to be tracked individually.','line_number':128,'multiline':False]
['text':' For view ops that return multiple tensors (like `split`), we generate a separate lambda for each output.','line_number':140,'multiline':False]
['text':' When we replay a view op that returns multiple tensors, we need to index into the output appropriately','line_number':141,'multiline':False]
['text':' The forward lambda calls the at::_ops API, while the reverse lambda calls the view inverse API.','line_number':153,'multiline':False]
['text':' Both of these follow the dispatcher API.','line_number':154,'multiline':False]
['text':' the forward lambda swaps out the original tensor argument with the lambd arg "base"','line_number':157,'multiline':False]
['text':' the reverse lambda does the same, but with an additional "mutated_view" arg','line_number':160,'multiline':False]
['text':' additionally, we have a calling convention: for view ops that return multiple tensor outputs','line_number':161,'multiline':False]
['text':' their corresponding view_inverse function takes in an additional index argument.','line_number':162,'multiline':False]
