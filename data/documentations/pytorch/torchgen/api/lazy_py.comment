['text':' A ValueT is an IR type which represents the computation of a Tensor.  In other','line_number':41,'multiline':False]
['text':' words, a PyTorch user will do operations on lazy tensors, and each output lazy','line_number':42,'multiline':False]
['text':' tensor internally tracks a ValueT representing the IR node that would have','line_number':43,'multiline':False]
['text':' actually produced the value of this tensor for real.','line_number':44,'multiline':False]
['text':'','line_number':45,'multiline':False]
['text':' This is configurable because different lazy tensor backends (LTC vs XLA) will','line_number':46,'multiline':False]
['text':' have different IR representations.  (Though, arguably, after unification they','line_number':47,'multiline':False]
['text':' shouldn't!)','line_number':48,'multiline':False]
['text':' this is a bad hack. I need to refactor the data model to represent each arg in the schema as an object,','line_number':64,'multiline':False]
['text':' making it easier to represent special properties of an arg.','line_number':65,'multiline':False]
['text':' at::scalar has special handling,','line_number':93,'multiline':False]
['text':' and is wrapped in an lazy::Value just like at::tensor','line_number':94,'multiline':False]
['text':' TODO(whc) is this actually correct? or should it use a Vector like above','line_number':125,'multiline':False]
['text':' this is a TensorList which comes in from GetTensorList as a Value','line_number':128,'multiline':False]
['text':' TODO: return a value type.  The problem here is analogous to','line_number':131,'multiline':False]
['text':' the problem with tensorListValueT: if you have SymInt[] you','line_number':132,'multiline':False]
['text':' cannot conveniently save the list of Value directly, as nodes','line_number':133,'multiline':False]
['text':' expect to save values as a vector for ALL arguments.  So you','line_number':134,'multiline':False]
['text':' need a separate IR node that represents all of the size nodes','line_number':135,'multiline':False]
['text':' assembled into a list.  I'm not an LTC dev so I don't want to','line_number':136,'multiline':False]
['text':' figure it out right now.  Y'all figure it out...','line_number':137,'multiline':False]
['text':' TODO: Determining this based off of CType is bad; this should be computed','line_number':146,'multiline':False]
['text':' from Type directly; then the same logic as process_ir_type can be used','line_number':147,'multiline':False]
['text':'','line_number':148,'multiline':False]
['text':' Invariant: passed typ should be an *owning* CType (e.g., we will report','line_number':149,'multiline':False]
['text':' that ArrayRef<Value> is NOT a value type)','line_number':150,'multiline':False]
['text':' I am regretting my naming conventions, but now we are wrapping at::scalar in','line_number':157,'multiline':False]
['text':' lazy value, while preserving other 'scalar' types as scalars in the IR','line_number':158,'multiline':False]
['text':' TODO: report True for this','line_number':166,'multiline':False]
['text':' I am regretting my naming conventions, but now we are wrapping at::scalar in','line_number':184,'multiline':False]
['text':' lazy value, while preserving other 'scalar' types as scalars in the IR','line_number':185,'multiline':False]
['text':' TODO: dedupe with Type.is_generator_like','line_number':192,'multiline':False]
['text':' This class caches a few derived properties computed from an Argument','line_number':201,'multiline':False]
['text':' and LazyIrProperties','line_number':202,'multiline':False]
['text':' TODO: this is lies, it is false for symint list','line_number':209,'multiline':False]
['text':' Whether or not we are treating this as symint or not','line_number':212,'multiline':False]
['text':' true if this argument is or contains a lazy IR value','line_number':215,'multiline':False]
['text':' TODO: lists of symints are not currently treated as value types','line_number':229,'multiline':False]
['text':' or (isinstance(arg.type, ListType) and isSymIntType(arg.type.elem))','line_number':230,'multiline':False]
['text':' Assume shape has been precomputed','line_number':254,'multiline':False]
['text':' Need to compute the shape on construction','line_number':255,'multiline':False]
['text':' Utilize the shape cache to defer computation','line_number':256,'multiline':False]
['text':' Codegen full lower function','line_number':259,'multiline':False]
['text':' Codegen only lower function declaration','line_number':260,'multiline':False]
['text':' Codegen full reuse function','line_number':263,'multiline':False]
['text':' Codegen only reuse function declaration','line_number':264,'multiline':False]
['text':' Codegen full create function','line_number':267,'multiline':False]
['text':' Codegen only create function declaration','line_number':268,'multiline':False]
['text':' Treat Scalars as constants instead of handling like values','line_number':271,'multiline':False]
['text':' Inspired by a FunctionSchema object, a LazyIrSchema holds the schema of a Lazy IR node.','line_number':301,'multiline':False]
['text':' Unlike a FunctionSchema, it has no round-trippable string form (relating to the YAML),','line_number':302,'multiline':False]
['text':' but carries type information from a native FunctionSchema modified for use with IR nodes,','line_number':303,'multiline':False]
['text':' and preserving original argument names.','line_number':304,'multiline':False]
['text':'','line_number':305,'multiline':False]
['text':' TODO: This is not idiomatic with how other torchgen APIs transform on schema.','line_number':306,'multiline':False]
['text':' The name of the operator this function schema describes.','line_number':308,'multiline':False]
['text':' TODO: Need to handle collisions with argument names at some point','line_number':314,'multiline':False]
['text':' if this schema has a Generator arg, list its orig ctype/name but don't','line_number':317,'multiline':False]
['text':' build a LazyArgument since lazy IR doesn't support it','line_number':318,'multiline':False]
['text':' original function schema','line_number':321,'multiline':False]
['text':' Whether or not we are code-genning for SymInt or not','line_number':324,'multiline':False]
['text':' default properties','line_number':328,'multiline':False]
['text':' type:ignore[arg-type]','line_number':378,'multiline':False]
['text':' This function maintains the sorted order of arguments but provides different filtered views.','line_number':416,'multiline':False]
['text':' Some parts of the code care about kwargs vs args (TS lowerings),','line_number':417,'multiline':False]
['text':' other parts care about whether they need to wrap the arg in a lazy value or leave it alone.','line_number':418,'multiline':False]
['text':' Generators are special cased, as they are needed for fallback/shape-inference but not supported','line_number':419,'multiline':False]
['text':' in TS lowerings and therefore also omitted from lazy IR.','line_number':420,'multiline':False]
