['text':' Welcome to the ATen code generator v2!  The ATen code generator is','line_number':102,'multiline':False]
['text':' responsible for parsing native_functions.yaml and then generating','line_number':103,'multiline':False]
['text':' various generated files (e.g., TypeDefault.cpp) based on the operators','line_number':104,'multiline':False]
['text':' defined in this file.  This means that the code generator knows how to','line_number':105,'multiline':False]
['text':' parse function schema, and then translate this into various C++ types','line_number':106,'multiline':False]
['text':' and boilerplate code.','line_number':107,'multiline':False]
['text':'','line_number':108,'multiline':False]
['text':' Some things to know about this file when you modify it:','line_number':109,'multiline':False]
['text':'','line_number':110,'multiline':False]
['text':' - This file has STRICT mypy typechecking.  Typecheck it with','line_number':111,'multiline':False]
['text':'   `mypy --config mypy-strict.ini` in the root source directory','line_number':112,'multiline':False]
['text':'','line_number':113,'multiline':False]
['text':' - Most of the heavy lifting lives in external modules:','line_number':114,'multiline':False]
['text':'   - 'model' has the data model for native_functions.yaml.  The classes','line_number':115,'multiline':False]
['text':'     in those file represent what you see when you look at','line_number':116,'multiline':False]
['text':'     a native_functions.yaml','line_number':117,'multiline':False]
['text':'   - 'api' has conversions for how to translate JIT schema into','line_number':118,'multiline':False]
['text':'     the various C++ APIs that the codegen interacts with.  There','line_number':119,'multiline':False]
['text':'     are in fact THREE different C++ APIs: the public C++ API,','line_number':120,'multiline':False]
['text':'     the dispatcher API, and the legacy dispatcher API.  See each','line_number':121,'multiline':False]
['text':'     of these respective files for more information','line_number':122,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':124,'multiline':False]
['text':'','line_number':125,'multiline':False]
['text':'                         HELPER FUNCTIONS','line_number':126,'multiline':False]
['text':'','line_number':127,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':128,'multiline':False]
['text':' A custom loader for YAML to let us also keep track of line numbers','line_number':131,'multiline':False]
['text':' of each entry in the YAML file','line_number':132,'multiline':False]
['text':' type: ignore[no-untyped-def]','line_number':134,'multiline':False]
['text':' type: ignore[no-untyped-call]','line_number':135,'multiline':False]
['text':' Add 1 so line numbering starts at 1','line_number':136,'multiline':False]
['text':' Parse native_functions.yaml into a sequence of NativeFunctions and Backend Indices.','line_number':144,'multiline':False]
['text':' Default dict is to prevent the codegen from barfing when we have a dispatch key that has no kernels yet.','line_number':167,'multiline':False]
['text':' I'm actually not sure about this; undefined could be hit on','line_number':174,'multiline':False]
['text':' empty TensorList, hypothetically that could have sizes in it','line_number':175,'multiline':False]
['text':' All structured in-tree operators are implemented in terms of their out operator.','line_number':182,'multiline':False]
['text':' Only cuda-like devices in tree require device guards','line_number':187,'multiline':False]
['text':' ensure that each tag has a non-empty description','line_number':205,'multiline':False]
['text':' if a loaded yaml is provided, use that instead of reading from path','line_number':234,'multiline':False]
['text':' Some assertions are already performed during parsing, but those are only within a single NativeFunction.','line_number':252,'multiline':False]
['text':' Assertions here are meant to be performed across NativeFunctions.','line_number':253,'multiline':False]
['text':' See Note [resize_ in Functionalization]','line_number':268,'multiline':False]
['text':' resize_() is technically an inplace view op (and therefore needs the tag),','line_number':269,'multiline':False]
['text':' but it would be overkill to add a true "view" variant of resize.','line_number':270,'multiline':False]
['text':' Instead, resize_() gets special treatment in functionalization,','line_number':271,'multiline':False]
['text':' and we have a resize() op that is non-aliasing + functional.','line_number':272,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':306,'multiline':False]
['text':'','line_number':307,'multiline':False]
['text':'                        C++ CODE GENERATION','line_number':308,'multiline':False]
['text':'','line_number':309,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':310,'multiline':False]
['text':' Most functions in this section are curried: they consist of a function','line_number':312,'multiline':False]
['text':' that takes some parameters (e.g., what is to be generated) which itself','line_number':313,'multiline':False]
['text':' returns a function that actually maps NativeFunction to the code','line_number':314,'multiline':False]
['text':' to be generated.  This pattern makes it convenient to use map, concatMap','line_number':315,'multiline':False]
['text':' and similar functional combinators.','line_number':316,'multiline':False]
['text':' TODO: for ops with structured_delegate it should check the dispatch table of','line_number':335,'multiline':False]
['text':' the out variant instead. For now, these structured ops all have CPU/CUDA kernels','line_number':336,'multiline':False]
['text':' so we always dispatch to the `backend`, but this could be wrong when we','line_number':337,'multiline':False]
['text':' migrate math/default_backend ops to use structured delegate.','line_number':338,'multiline':False]
['text':' Translates arguments of `sig` to CppSignature bindings.','line_number':374,'multiline':False]
['text':' Note that we have a special case for `memory_format` argument and this case is not covered by','line_number':375,'multiline':False]
['text':' tools.codegen.api.translate() yet as its application is limited to static dispatch.','line_number':376,'multiline':False]
['text':' Adds SpecialArgName.possibly_redundant_memory_format NamedCType for memory_format bindings','line_number':381,'multiline':False]
['text':' When last argument of CPP signature has SpecialArgName.possibly_redundant_memory_format NCType,','line_number':402,'multiline':False]
['text':' get memory_format bindings of dispatcher signature to have the same NCType as well','line_number':403,'multiline':False]
['text':' Generates RegisterSchema.cpp.  Depending on the selector, either','line_number':539,'multiline':False]
['text':' all schemas are registered, or only some are (in the case of','line_number':540,'multiline':False]
['text':' selective build)','line_number':541,'multiline':False]
['text':' Generates Operators.h and Operators.cpp.','line_number':562,'multiline':False]
['text':' These provide macros that, given an operator and overload name, allow users','line_number':563,'multiline':False]
['text':' to access an "un-overloaded" function version of the operator. This','line_number':564,'multiline':False]
['text':' is useful for extension writers who want to (1) want to decltype the operator','line_number':565,'multiline':False]
['text':' and (2) don't want to worry about method-only operators.','line_number':566,'multiline':False]
['text':' Note [The ATen Operators API]','line_number':578,'multiline':False]
['text':' The ATen Operators API lives in the at::_ops namespace, and contains compile-time','line_number':579,'multiline':False]
['text':' metadata about each operator + entry points into the Dispatcher.','line_number':580,'multiline':False]
['text':' The C++ function, method, and redispatch API's are all implemented as wrappers','line_number':581,'multiline':False]
['text':' into various bits of the structs defined here.','line_number':582,'multiline':False]
['text':'','line_number':583,'multiline':False]
['text':' Important characteristics about the Operators API:','line_number':584,'multiline':False]
['text':' (1) It follows the Dispatcher API.','line_number':585,'multiline':False]
['text':'     This is kind of necessary to avoid overhead.','line_number':586,'multiline':False]
['text':'     For example: if it followed the C++ API, then all of the faithful C++ factory functions','line_number':587,'multiline':False]
['text':'     would need to wrap their arguments into TensorOptions only to unwrap them again.','line_number':588,'multiline':False]
['text':' (2) Overload names are disambiguated.','line_number':589,'multiline':False]
['text':'     This is helpful for pytorch extenders who would like to decltype() an aten operator,','line_number':590,'multiline':False]
['text':'     that has overloads, e.g. decltype(at::_ops::mul_Tensor::call)','line_number':591,'multiline':False]
['text':' (3) No argument defaulting is allowed.','line_number':592,'multiline':False]
['text':'     This is more of an implementation detail to avoid #include cycles,','line_number':593,'multiline':False]
['text':'     since TensorBody.h (which defines the Tensor class) needs to include this file.','line_number':594,'multiline':False]
['text':' (4) manual_cpp_bindings and faithful names are not included in the API.','line_number':595,'multiline':False]
['text':'     This applies to stuff like __dispatch__is_complex(), and add_outf().','line_number':596,'multiline':False]
['text':'     These aren't "real aten ops", they're just additional functions provided by the C++ API.','line_number':597,'multiline':False]
['text':'     They're implemented as wrappers in Functions.h that call into the actual operators','line_number':598,'multiline':False]
['text':'     defined here, i.e. at::_ops::is_complex::call() and at::_ops::add_out::call().','line_number':599,'multiline':False]
['text':'     This means that ATEN_OP(is_complex) will not fastpath, and will go through the dispatcher.','line_number':600,'multiline':False]
['text':' call() should go through static dispatch','line_number':647,'multiline':False]
['text':' Generates Functions.h, which provides the functional public C++ API,','line_number':662,'multiline':False]
['text':' and the scaffolding to call into the dispatcher from these functions.','line_number':663,'multiline':False]
['text':' See Note [The ATen Operators API]','line_number':675,'multiline':False]
['text':' The template function can be used from template situations','line_number':692,'multiline':False]
['text':' where you want to switch between the symint or not version','line_number':693,'multiline':False]
['text':' depending on a template argument','line_number':694,'multiline':False]
['text':'','line_number':695,'multiline':False]
['text':' NB: we ALWAYS generate this even for methods.  But we put it in','line_number':696,'multiline':False]
['text':' this header so it can take advantage of per-op headers','line_number':697,'multiline':False]
['text':' Generates TensorBody.h. This file provides the object-oriented (method-based)','line_number':710,'multiline':False]
['text':' public C++ API, and the scaffolding to call into the dispatcher from these functions.','line_number':711,'multiline':False]
['text':' Generates RedispatchFunctions.h.','line_number':755,'multiline':False]
['text':' This is similar to the C++ API defined in Functions.h, but provides access','line_number':756,'multiline':False]
['text':' to the dispatcher's redispatch API.','line_number':757,'multiline':False]
['text':' We unconditionally generate function variants of the redispatch API.','line_number':762,'multiline':False]
['text':' This is mainly because we can namespace functions separately, but not methods,','line_number':763,'multiline':False]
['text':' Generates ATenOpList.cpp, a runtime accessible list of all aten','line_number':784,'multiline':False]
['text':' operators.','line_number':785,'multiline':False]
['text':' TODO: This was historically used to help some JIT interop code','line_number':786,'multiline':False]
['text':' figure out whether or not to treat aten namespace'd operators','line_number':787,'multiline':False]
['text':' one way or another, we should reevaluate if this is actually needed.','line_number':788,'multiline':False]
['text':' Generates MetaFunctions.h','line_number':794,'multiline':False]
['text':' Generate the template declaration with one bool parameter for each','line_number':809,'multiline':False]
['text':' precomputed element. Each parameter is true if the corresponding (in','line_number':810,'multiline':False]
['text':' terms of position) precomputed element has been set.','line_number':811,'multiline':False]
['text':' Generate a string containing declarations of all precomputed elements.','line_number':824,'multiline':False]
['text':' Generate "setter" methods for each precomputed element. Each method will return','line_number':835,'multiline':False]
['text':' a new instance of precompute_out with the template parameter that corresponds to','line_number':836,'multiline':False]
['text':' the member set by the method to true (to indicate that it has been set).','line_number':837,'multiline':False]
['text':' Generate the signature. The return type will be the same','line_number':840,'multiline':False]
['text':' as the type of `this` but with the template parameter','line_number':841,'multiline':False]
['text':' corresponding to the element set by this method set to true.','line_number':842,'multiline':False]
['text':' The assert generated below will ensure that this template','line_number':843,'multiline':False]
['text':' parameter is false on the type of `this`.','line_number':844,'multiline':False]
['text':' Generate an assert which checks that the','line_number':856,'multiline':False]
['text':' template parameter corresponding to the precomputed','line_number':857,'multiline':False]
['text':' element that is set by this method is false on the','line_number':858,'multiline':False]
['text':' class corresponding to the object that `this` points to.','line_number':859,'multiline':False]
['text':' This ensures that each element can be set only once.','line_number':860,'multiline':False]
['text':' Generate the new object construction block. All state','line_number':864,'multiline':False]
['text':' except the element that this method sets is copied from the','line_number':865,'multiline':False]
['text':' object that `this` points to. The value for the element that','line_number':866,'multiline':False]
['text':' the method sets is taken from a method parameter.','line_number':867,'multiline':False]
['text':' Meta should return an instance of the struct containing the precomputed elements.','line_number':892,'multiline':False]
['text':' This typedef (actually a using statement) is needed so that TORCH_META_FUNC can reuse the return','line_number':896,'multiline':False]
['text':' type (which has a variable number of template parameters).','line_number':897,'multiline':False]
['text':' Generates RegisterBackendSelect.cpp, a series of kernels which provide','line_number':928,'multiline':False]
['text':' specialized computation of dispatch key for operator signatures which cannot','line_number':929,'multiline':False]
['text':' be easily done automatically using templating.','line_number':930,'multiline':False]
['text':' Selector object to determine which operators to generate','line_number':935,'multiline':False]
['text':' registration code for.','line_number':936,'multiline':False]
['text':' BackendSelect can go to Meta, so it must preserve symints','line_number':945,'multiline':False]
['text':' I don't think there's actually a good reason to generate','line_number':962,'multiline':False]
['text':' these two cases differently','line_number':963,'multiline':False]
['text':' The first case could probably be improved though- it calls computeDispatchKeySet(),','line_number':964,'multiline':False]
['text':' which looks at TLS dispatch keys- there should not be any by the time we reach backend select.','line_number':965,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':993,'multiline':False]
['text':'','line_number':994,'multiline':False]
['text':'                       YAML CODE GENERATION','line_number':995,'multiline':False]
['text':'','line_number':996,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':997,'multiline':False]
['text':' Ignore alias in Dumper','line_number':1001,'multiline':False]
['text':' type: ignore[assignment]','line_number':1002,'multiline':False]
['text':' Support serializing OrderedDict','line_number':1004,'multiline':False]
['text':' type: ignore[no-untyped-call]','line_number':1008,'multiline':False]
['text':' Some yaml parsers (e.g. Haskell's) don't understand line breaks.','line_number':1009,'multiline':False]
['text':' width=1e9 turns off optional line breaks and improves','line_number':1010,'multiline':False]
['text':' the portability of the outputted yaml.','line_number':1011,'multiline':False]
['text':' type: ignore[no-any-return, call-overload]','line_number':1012,'multiline':False]
['text':' For some reason, some defaults we write to YAML are written as native','line_number':1015,'multiline':False]
['text':' YAML objects, rather than doing them uniformly as strings.  This','line_number':1016,'multiline':False]
['text':' function detects those cases and converts them into native Python','line_number':1017,'multiline':False]
['text':' objects.','line_number':1018,'multiline':False]
['text':' What is a dynamic type?  Over time, the semantic meaning of','line_number':1034,'multiline':False]
['text':' dynamic type has degraded to meaninglessness (in the old days,','line_number':1035,'multiline':False]
['text':' it captured dtype-ness of types, but that has gone away with','line_number':1036,'multiline':False]
['text':' the removal of TH).  These days, it's mostly the same thing as','line_number':1037,'multiline':False]
['text':' the C++ API argument type, except that Tensor and Tensor?','line_number':1038,'multiline':False]
['text':' arguments simply present as Tensor.','line_number':1039,'multiline':False]
['text':'','line_number':1040,'multiline':False]
['text':' TODO: Get rid of dynamic_type, after getting tools/autograd','line_number':1041,'multiline':False]
['text':' to use the new codegen framework','line_number':1042,'multiline':False]
['text':' Note we don't use t.is_tensor_like() here because it would','line_number':1046,'multiline':False]
['text':' also include Tensor[]','line_number':1047,'multiline':False]
['text':' This is a legacy concept, so never report SymInt','line_number':1050,'multiline':False]
['text':' This is written out explicitly to ensure that Tensor and','line_number':1057,'multiline':False]
['text':' namespace are put into the list in the right order','line_number':1058,'multiline':False]
['text':' Note [name and field_name]','line_number':1070,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':1071,'multiline':False]
['text':' To understand name_to_field_name, we must first talk about this','line_number':1072,'multiline':False]
['text':' schema:','line_number':1073,'multiline':False]
['text':'','line_number':1074,'multiline':False]
['text':'   lstsq.X(Tensor self, Tensor A, *, Tensor(a!) X, Tensor(b!) qr) -> (Tensor(a!) solution, Tensor(b!) QR)','line_number':1075,'multiline':False]
['text':'','line_number':1076,'multiline':False]
['text':' There is something very odd about this schema: it is an out','line_number':1077,'multiline':False]
['text':' variant of the function (that is to say, it will convert into','line_number':1078,'multiline':False]
['text':' at::lstsq_out() in the C++ API), but the names of the output','line_number':1079,'multiline':False]
['text':' return arguments don't match the keyword argument names of','line_number':1080,'multiline':False]
['text':' the inputs.  It TURNS OUT that in this situation, the historical','line_number':1081,'multiline':False]
['text':' Declarations.yaml we want to output is this (abbreviated to','line_number':1082,'multiline':False]
['text':' only show relevant fields):','line_number':1083,'multiline':False]
['text':'','line_number':1084,'multiline':False]
['text':'   arguments:','line_number':1085,'multiline':False]
['text':'     ...','line_number':1086,'multiline':False]
['text':'   - field_name: solution','line_number':1087,'multiline':False]
['text':'     name: X','line_number':1088,'multiline':False]
['text':'   - field_name: QR','line_number':1089,'multiline':False]
['text':'     name: qr','line_number':1090,'multiline':False]
['text':'     ...','line_number':1091,'multiline':False]
['text':'','line_number':1092,'multiline':False]
['text':'   returns:','line_number':1093,'multiline':False]
['text':'   - field_name: solution','line_number':1094,'multiline':False]
['text':'     name: X','line_number':1095,'multiline':False]
['text':'   - field_name: QR','line_number':1096,'multiline':False]
['text':'     name: qr','line_number':1097,'multiline':False]
['text':'','line_number':1098,'multiline':False]
['text':' The name of the return fields is stored in 'field_name', and the','line_number':1099,'multiline':False]
['text':' name of the arguments is stored in 'name'.  So when we process','line_number':1100,'multiline':False]
['text':' arguments, we need a way to get at the corresponding return.  At','line_number':1101,'multiline':False]
['text':' the moment, this is most conveniently done by constructing a','line_number':1102,'multiline':False]
['text':' mapping from name (the argument concept) to field_name (the','line_number':1103,'multiline':False]
['text':' return concept) while processing return arguments, since we don't','line_number':1104,'multiline':False]
['text':' directly maintain this correspondence in the modeling of function','line_number':1105,'multiline':False]
['text':' schema itself.','line_number':1106,'multiline':False]
['text':'','line_number':1107,'multiline':False]
['text':' See also https://github.com/pytorch/pytorch/issues/43114','line_number':1108,'multiline':False]
['text':' Compute the returns field of the YAML entry','line_number':1111,'multiline':False]
['text':' legacy, report ints','line_number':1118,'multiline':False]
['text':' See Note [name and field_name]','line_number':1123,'multiline':False]
['text':' arguments in yaml roughly corresponds to the public C++ API','line_number':1133,'multiline':False]
['text':' legacy, report ints','line_number':1179,'multiline':False]
['text':' See Note [name and field_name]','line_number':1191,'multiline':False]
['text':' Historically, booleans don't get their size recorded, because it','line_number':1194,'multiline':False]
['text':' is already built into the cpp type (e.g., std::array<bool, 4>)','line_number':1195,'multiline':False]
['text':' These sets are used to conveniently test if an argument is a','line_number':1206,'multiline':False]
['text':' kwarg-only or out argument','line_number':1207,'multiline':False]
['text':' NB: method here doesn't matter','line_number':1240,'multiline':False]
['text':' legacy, report ints','line_number':1253,'multiline':False]
['text':' See Note [Auto generated composite kernels]','line_number':1291,'multiline':False]
['text':' TODO: What exactly is the semantics of the 'dispatch' field?','line_number':1310,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':1326,'multiline':False]
['text':'','line_number':1327,'multiline':False]
['text':'                           RUN IT ALL','line_number':1328,'multiline':False]
['text':'','line_number':1329,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':1330,'multiline':False]
['text':' Take the remaining functions that weren't part of the view group','line_number':1383,'multiline':False]
['text':' and emit them separately','line_number':1384,'multiline':False]
['text':' We need to group up ops relevant to the same "view", consisting of:','line_number':1395,'multiline':False]
['text':' view op (ViewSchemaKind.aliasing)','line_number':1396,'multiline':False]
['text':' view_inplace op (ViewSchemaKind.aliasing_inplace)','line_number':1397,'multiline':False]
['text':' view_copy op (SchemaKind.functional)','line_number':1398,'multiline':False]
['text':' Invariant: any NativeFunctions that are code-generated','line_number':1418,'multiline':False]
['text':' should have been grouped into NativeFunctionsGroup objects','line_number':1419,'multiline':False]
['text':' TODO: how come ValuesView isn't a Sequence lol','line_number':1425,'multiline':False]
['text':' Convert to a set first to remove duplicate kernel names. Backends are','line_number':1473,'multiline':False]
['text':' allowed to repeat kernel names; only generate the declaration once!','line_number':1474,'multiline':False]
['text':' Return native function declarations grouped by their namespaces.','line_number':1488,'multiline':False]
['text':' Return native function definitions grouped by dispatch key and custom namespace.','line_number':1529,'multiline':False]
['text':' Used in RegisterDispatchKey.cpp and etc.','line_number':1530,'multiline':False]
['text':' Return native function declarations grouped by dispatch key and custom namespace.','line_number':1632,'multiline':False]
['text':' Used in CPUFunctions_inl.h and etc.','line_number':1633,'multiline':False]
['text':' Return native function schema registration code for aten and other namespaces.','line_number':1683,'multiline':False]
['text':' NB: we have to separate aten namespace registration from other namespaces,','line_number':1699,'multiline':False]
['text':' because in the template we hardcoded an operator for ATen already.','line_number':1700,'multiline':False]
['text':' if the namespace is predefined, we should use define a library fragment','line_number':1706,'multiline':False]
['text':' instead of a new library','line_number':1707,'multiline':False]
['text':' Buck doesn't support dynamic output files, so we aggregate all operator','line_number':1734,'multiline':False]
['text':' headers into a single file','line_number':1735,'multiline':False]
['text':' For CMake builds, split operator declarations into separate headers in','line_number':1855,'multiline':False]
['text':' the ATen/ops folder to split up header dependencies','line_number':1856,'multiline':False]
['text':' All function argument names','line_number':2130,'multiline':False]
['text':' All ATen function names','line_number':2131,'multiline':False]
['text':' Some operators don't have a functional variant but we still create a','line_number':2134,'multiline':False]
['text':' symbol without the underscore','line_number':2135,'multiline':False]
['text':' These are keywords in C++, so aren't valid symbol names','line_number':2141,'multiline':False]
['text':' https://en.cppreference.com/w/cpp/language/operator_alternative','line_number':2142,'multiline':False]
['text':' The above has_kernel test on a group will only test for','line_number':2217,'multiline':False]
['text':' the existence of out dispatch, because that's how','line_number':2218,'multiline':False]
['text':' structured kernels work. But sometimes functions can be','line_number':2219,'multiline':False]
['text':' grouped but not be structured, and then you need to check','line_number':2220,'multiline':False]
['text':' each individual piece, as they may have manual dispatch','line_number':2221,'multiline':False]
['text':' entries.','line_number':2222,'multiline':False]
['text':' TODO: this condition is a bit questionable','line_number':2227,'multiline':False]
['text':' (It has to do with the fact that structured kernels get generated kernels','line_number':2228,'multiline':False]
['text':' to the Meta + CompositeExplicitAutogradNonFunctional keys).','line_number':2229,'multiline':False]
['text':' CompositeImplicitAutogradNestdTensor does not currently user the helpers generated','line_number':2273,'multiline':False]
['text':' compilation will fail when `-Werror=unused-function` flag is set','line_number':2274,'multiline':False]
['text':' BackendSelect is generated specially','line_number':2354,'multiline':False]
['text':' view ops always get a functionalization kernel','line_number':2448,'multiline':False]
['text':' type: ignore[assignment, arg-type, operator]','line_number':2499,'multiline':False]
['text':' Note: all operators that functionalization needs to handle (mutable and aliasing ops) should be grouped properly.','line_number':2501,'multiline':False]
['text':' The only reason we really need to deal with direct NativeFunctions here (instead of the groups) is because:','line_number':2502,'multiline':False]
['text':' (1) We can provide better error checking (error out if someone introduces a mutable op that doesn't obey the grouping logic)','line_number':2503,'multiline':False]
['text':' (2) functionalization needs to manually register CompositeImplicitAutograd kernels, which might not be grouped.','line_number':2504,'multiline':False]
['text':'     Although this could go away long-term if we add a dedicated dispatch key for decompositions.','line_number':2505,'multiline':False]
['text':' Note [view_copy NativeFunctions]','line_number':2546,'multiline':False]
['text':' Every view operator in native_functions.yaml that is not CompositeImplicitAutograd','line_number':2547,'multiline':False]
['text':' needs to have a corresponding non-aliasing {view}_copy variant.','line_number':2548,'multiline':False]
['text':' Backends that use functionalization and don't know how to handle aliasing ops','line_number':2549,'multiline':False]
['text':' are expected to implement kernels for these {view}_copy kernels instead.','line_number':2550,'multiline':False]
['text':' The code for {view}_copy operators in core is pretty boilerplate-heavy however,','line_number':2551,'multiline':False]
['text':' so we codegen the following:','line_number':2552,'multiline':False]
['text':' (1) A CompositeExplicitAutogradNonFunctional kernel for every {view}_copy operator.','line_number':2553,'multiline':False]
['text':'     These are never explicitly invoked by the functionalization pass,','line_number':2554,'multiline':False]
['text':'     but they could theoretically be called from user code (I added these kernels for completeness,','line_number':2555,'multiline':False]
['text':'     since the ops are part of the public API).','line_number':2556,'multiline':False]
['text':' (2) A derivative formula for every {view}_copy operator','line_number':2557,'multiline':False]
['text':'     {view}_copy operators can re-use the same derivative formulas as their {view} op counterparts,','line_number':2558,'multiline':False]
['text':'     so rather than stamping all of the entries out in derivatives.yaml,','line_number':2559,'multiline':False]
['text':'     we codegen them in.','line_number':2560,'multiline':False]
['text':'     This is similar to how autograd codegen doesn't require inplace ops to have a derivatives.yaml entry.','line_number':2561,'multiline':False]
['text':' NB: this include is important as it ensures we','line_number':2568,'multiline':False]
['text':' set the visibility on generated view_copy kernels','line_number':2569,'multiline':False]
['text':' correctly','line_number':2570,'multiline':False]
['text':' TODO: --op-registration-whitelist will be removed when all call-sites','line_number':2669,'multiline':False]
['text':' for gen.py are moved over to using the operator YAML file for mobile','line_number':2670,'multiline':False]
['text':' custom build.','line_number':2671,'multiline':False]
['text':' TODO: stop generating CUDA kernels for non-CUDA builds','line_number':2736,'multiline':False]
['text':' NB: It is mandatory to NOT use os.path.join here, as the install directory','line_number':2765,'multiline':False]
['text':' will eventually be ingested by cmake, which does not respect Windows style','line_number':2766,'multiline':False]
['text':' path slashes.  If you switch this to use os.path.join, you'll get an error','line_number':2767,'multiline':False]
['text':' like:','line_number':2768,'multiline':False]
['text':'','line_number':2769,'multiline':False]
['text':'   Syntax error in cmake code when parsing string','line_number':2770,'multiline':False]
['text':'','line_number':2771,'multiline':False]
['text':'     C:/Jenkins/workspace/pytorch-builds/pytorch-win-ws2016-cuda9-cudnn7-py3-build/build/aten/src/ATen\core/TensorMethods.h','line_number':2772,'multiline':False]
['text':'','line_number':2773,'multiline':False]
['text':'   Invalid character escape '\c'.','line_number':2774,'multiline':False]
['text':' Only a limited set of dispatch keys get CPUFunctions.h headers generated','line_number':2786,'multiline':False]
['text':' for them; this is the set','line_number':2787,'multiline':False]
