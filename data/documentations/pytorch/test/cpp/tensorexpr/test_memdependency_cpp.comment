['text':' Test helper function used to determine if two regions of a buffer have an','line_number':17,'multiline':False]
['text':' overlap. No Overlap & partial overlap is obvious. Contains means A is','line_number':18,'multiline':False]
['text':' larger and fully encloses B, while ContainedOrEqual is the reverse. Equal','line_number':19,'multiline':False]
['text':' ranges are ContainedOrEqual.','line_number':20,'multiline':False]
['text':' Sanity check 3 overlap cases.','line_number':28,'multiline':False]
['text':' Partial overlap works in either order.','line_number':33,'multiline':False]
['text':' Total Overlap works when one bound encloses the other, and returns which.','line_number':37,'multiline':False]
['text':' Total overlap works when the bounds are an identical range, returns','line_number':41,'multiline':False]
['text':' ContainedOrEqual.','line_number':42,'multiline':False]
['text':' Total overlap when only one end of the bound matches.','line_number':45,'multiline':False]
['text':' No overlap when a < b.','line_number':52,'multiline':False]
['text':' No overlap when a > b.','line_number':57,'multiline':False]
['text':' No overlap when adjacent.','line_number':62,'multiline':False]
['text':' Partial overlap when middle bounds match.','line_number':66,'multiline':False]
['text':' Total overlap when one bound is single length over one end of the other.','line_number':74,'multiline':False]
['text':' Sanity check cases where the start and end is symbolic but the diff is','line_number':221,'multiline':False]
['text':' constant.','line_number':222,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':223,'multiline':False]
['text':' We can't infer the sign of y, so cannot tell whether adding y is larger or','line_number':230,'multiline':False]
['text':' smaller than y/2.','line_number':231,'multiline':False]
['text':' No information about this bound, have to take the most conservative option:','line_number':236,'multiline':False]
['text':' there may be an overlap.','line_number':237,'multiline':False]
['text':' Math on opaque terms works.','line_number':240,'multiline':False]
['text':' Even requiring simplification.','line_number':244,'multiline':False]
['text':' Tests the helper function for overlap of multi dimensional indices bounds.','line_number':250,'multiline':False]
['text':' This uses boundOverlap on each dimension and return the "lowest" kind of','line_number':251,'multiline':False]
['text':' overlap.','line_number':252,'multiline':False]
['text':' Sanity check one dimensional cases.','line_number':260,'multiline':False]
['text':' Total overlap in 3 dims.','line_number':266,'multiline':False]
['text':' Total overlap in 2 dims, no overlap in another.','line_number':275,'multiline':False]
['text':' Total overlap in 2 dims, partial overlap in another.','line_number':281,'multiline':False]
['text':' This case is most important, so verify the overlap in any dim. (dim 2)','line_number':286,'multiline':False]
['text':' Dim 1.','line_number':290,'multiline':False]
['text':' Total overlap in 1 dim, partial in 2.','line_number':294,'multiline':False]
['text':' Total overlap, partial overlap, no overlap.','line_number':299,'multiline':False]
['text':' Total overlap (B) in 2 dims, total overlap (A) in another.','line_number':305,'multiline':False]
['text':' Total overlap (A) in 2 dims, total overlap (B) in another.','line_number':310,'multiline':False]
['text':' Total (B), No Overlap, Total (A).','line_number':316,'multiline':False]
['text':' Test the helper we use to subtract bounds: returns the regions(s) of A which','line_number':323,'multiline':False]
['text':' remain after removing the region of B.','line_number':324,'multiline':False]
['text':' One element subtract.','line_number':335,'multiline':False]
['text':' No Overlap.','line_number':339,'multiline':False]
['text':' one side overlap.','line_number':343,'multiline':False]
['text':' both sides overlap.','line_number':349,'multiline':False]
['text':' internal overlap.','line_number':353,'multiline':False]
['text':' One element subtract.','line_number':373,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':374,'multiline':False]
['text':' Subtract constant range low.','line_number':379,'multiline':False]
['text':' Subtract constant range high.','line_number':382,'multiline':False]
['text':' Subtract constant range total overlap.','line_number':385,'multiline':False]
['text':' Subtract constant range internal.','line_number':388,'multiline':False]
['text':' Size is inferable but not constant, only works with a single var.','line_number':393,'multiline':False]
['text':' Size is not inferable.','line_number':397,'multiline':False]
['text':' Tests the helper function that does subtraction, but for multi dimensional','line_number':404,'multiline':False]
['text':' indices bounds.','line_number':405,'multiline':False]
['text':' sanity check one dimension.','line_number':424,'multiline':False]
['text':' Multi dim total overlap.','line_number':434,'multiline':False]
['text':' Mutli dim one way partial in dim 1.','line_number':440,'multiline':False]
['text':' Mutli dim one way partial in dim 2.','line_number':445,'multiline':False]
['text':' Partial overlap in 2 dims.','line_number':450,'multiline':False]
['text':' Partial overlap in 3 dims.','line_number':455,'multiline':False]
['text':' Tests the multi dimensional subtraction code for bounds that cannot be fully','line_number':464,'multiline':False]
['text':' materialized.','line_number':465,'multiline':False]
['text':' Cannot determine overlaps.','line_number':488,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':489,'multiline':False]
['text':' Various total Overlaps.','line_number':492,'multiline':False]
['text':' one-way overlap in first dim.','line_number':502,'multiline':False]
['text':' second dim.','line_number':506,'multiline':False]
['text':' Internal overlap in first dim.','line_number':511,'multiline':False]
['text':' second dim.','line_number':515,'multiline':False]
['text':' Overlap in both dimensions.','line_number':520,'multiline':False]
['text':' Simple check that the analyzer does anything at all...','line_number':532,'multiline':False]
['text':'
   * A[0] = 3;
   * B[0] = A[0] + 1;
   ','line_number':539,'multiline':True]
['text':' sanity check, but anything that depends directly must depend indirectly.','line_number':553,'multiline':False]
['text':' Check that there is a difference between direct and indirect dependence.','line_number':557,'multiline':False]
['text':'
   * A[0] = 3;
   * B[0] = A[0];
   * C[0] = B[0] + 1;
   ','line_number':565,'multiline':True]
['text':' C depends on A indirectly.','line_number':579,'multiline':False]
['text':' C depends on B directly, which depends on A directly.','line_number':583,'multiline':False]
['text':' Dependency goes top to bottom only.','line_number':587,'multiline':False]
['text':' Verify that we do filter writes that are totally overlapped by later writes.','line_number':593,'multiline':False]
['text':'
   * A[0] = 3;
   * A[0] = 6;
   * B[0] = A[0] + 1;
   ','line_number':600,'multiline':True]
['text':' B store depends on second A store but not first since it is completely','line_number':614,'multiline':False]
['text':' overlapped.','line_number':615,'multiline':False]
['text':' No dependency between either A store.','line_number':619,'multiline':False]
['text':' Verify that bounds match loop iterations, and that dependencies progress','line_number':624,'multiline':False]
['text':' across loop scopes.','line_number':625,'multiline':False]
['text':'
   * for (int x = 0; x < 10; ++x) {
   *   A[x] = x;
   * }
   * B[0] = A[0] + 1;
   ','line_number':635,'multiline':True]
['text':' Same A->B dependency.','line_number':650,'multiline':False]
['text':' B depends on the loop.','line_number':653,'multiline':False]
['text':' A is in the loop but does not depend on any loop iteration.','line_number':655,'multiline':False]
['text':' It should have bounds covering the range of x: 0 <= x < 10.','line_number':661,'multiline':False]
['text':' Reductions should promote dependencies as well.','line_number':666,'multiline':False]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; ++x) {
   *   A[0] = A[x] + 1;
   * }
   * B[0] = A[0];
   ','line_number':676,'multiline':True]
['text':' B -> A.','line_number':694,'multiline':False]
['text':' B depends indirectly on the initializer of A, since the reduction depends','line_number':697,'multiline':False]
['text':' on it.','line_number':698,'multiline':False]
['text':' B depends on the loop.','line_number':704,'multiline':False]
['text':' A is in the loop and depends on other iterations.','line_number':706,'multiline':False]
['text':' The loop contents depend on the initializer too.','line_number':709,'multiline':False]
['text':' Find loads within the reduction:','line_number':712,'multiline':False]
['text':' Pull out the access for the load inside the loop.','line_number':714,'multiline':False]
['text':' It should have 10 element long bounds.','line_number':717,'multiline':False]
['text':' Lowering a reduction doesn't affect dependency analysis.','line_number':723,'multiline':False]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; ++x) {
   *   A[0] = A[x] + 1;
   * }
   * B[0] = A[0];
   ','line_number':733,'multiline':True]
['text':' B -> A.','line_number':751,'multiline':False]
['text':' B depends indirectly on the initializer of A, since the reduction depends','line_number':754,'multiline':False]
['text':' on it.','line_number':755,'multiline':False]
['text':' B depends on the loop.','line_number':761,'multiline':False]
['text':' A is in the loop and depends on other iterations.','line_number':763,'multiline':False]
['text':' The loop contents depend on the initializer too.','line_number':766,'multiline':False]
['text':' Pull out the access for the store inside the loop.','line_number':769,'multiline':False]
['text':' It should have 10 element long bounds.','line_number':771,'multiline':False]
['text':' Can determine dependencies of outputs, through to inputs.','line_number':776,'multiline':False]
['text':' initialize analyzer with inputs and outputs.','line_number':782,'multiline':False]
['text':' Here's a Relu.','line_number':785,'multiline':False]
['text':'
   * for (int x = 0; x < 10; ++x) {
   *   B[x] = Max(A[x], 0);
   * }
   ','line_number':786,'multiline':True]
['text':' Output depends indirectly on input.','line_number':800,'multiline':False]
['text':' aLoad depends directly on the input A.','line_number':802,'multiline':False]
['text':' bStore therefore depends directly on the input A.','line_number':804,'multiline':False]
['text':' The output depends directly on the store.','line_number':806,'multiline':False]
['text':' Check AccessInfo based overloads.','line_number':809,'multiline':False]
['text':' Output depends indirectly on input.','line_number':813,'multiline':False]
['text':' Not directly.','line_number':815,'multiline':False]
['text':' Not in reverse order.','line_number':817,'multiline':False]
['text':' output -> bStore -> bLoad -> input.','line_number':820,'multiline':False]
['text':' Can tell if an output does not depend on an input.','line_number':828,'multiline':False]
['text':' initialize analyzer with inputs and outputs.','line_number':834,'multiline':False]
['text':' Here's a dumb Relu.','line_number':837,'multiline':False]
['text':'
   * for (int x = 0; x < 10; ++x) {
   *   B[x] = Max(x, 0);
   * }
   ','line_number':838,'multiline':True]
['text':' Output does not depend indirectly on input.','line_number':851,'multiline':False]
['text':' The output still depends directly on the store.','line_number':854,'multiline':False]
['text':' Check AccessInfo based overloads.','line_number':857,'multiline':False]
['text':' Output does not depend indirectly on input.','line_number':861,'multiline':False]
['text':' Verify different loop extents produce accesses with different bounds, and','line_number':865,'multiline':False]
['text':' that later accesses find dependencies that overlap their entire bound range.','line_number':866,'multiline':False]
['text':' This enables using the execution order of the loops to determine if some','line_number':876,'multiline':False]
['text':' loops are self dependent or not.','line_number':877,'multiline':False]
['text':'
   * for (int x = 1; x < 10; ++x) {
   *   B[x] = A[x];
   * }
   * for (int x = 1; x < 9; ++x) {
   *   B[x] = B[x] * 2;
   * }
   * for (int x = 3; x < 4; ++x) {
   *   C[x] = A[x];
   * }
   * for (int x = 0; x < 10; ++x) {
   *   C[x] = B[x];
   * }
   ','line_number':880,'multiline':True]
['text':' sanity check Output -> Input.','line_number':909,'multiline':False]
['text':' Check the For loop dependencies:','line_number':912,'multiline':False]
['text':' Last write to C depends on both writes to B since they contain the last','line_number':914,'multiline':False]
['text':' write to at least one element.','line_number':915,'multiline':False]
['text':' The last write to C does not depend on the other write to C.','line_number':919,'multiline':False]
['text':'  0. Input: A[(0, 9)] - dependents: 1 5
   *  1. Load: A[(1, 9)] - depends on: 0  - dependents: 2
   *  2. Store: B[(1, 9)] - depends on: 1  - dependents: 3 7
   *  3. Load: B[(1, 8)] - depends on: 2  - dependents: 4
   *  4. Store: B[(1, 8)] - depends on: 3  - dependents: 7
   *  5. Load: A[(3, 3)] - depends on: 0  - dependents: 6
   *  6. Store: C[(3, 3)] - depends on: 5
   *  7. Load: B[(0, 9)] - depends on: 2 4  - dependents: 8
   *  8. Store: C[(0, 9)] - depends on: 7  - dependents: 9
   *  9. Output: C[(0, 9)] - depends on: 8
   ','line_number':929,'multiline':True]
['text':' Now let's look at the bounds of each access.','line_number':941,'multiline':False]
['text':' There are 9 accesses in this Stmt, so this is exhaustive, we wont do this','line_number':942,'multiline':False]
['text':' much.','line_number':943,'multiline':False]
['text':' The first access is the input A.','line_number':950,'multiline':False]
['text':' It has the bounds of the producing Input.','line_number':953,'multiline':False]
['text':' sanity check the input we retrieved earlier matches.','line_number':955,'multiline':False]
['text':' The second access is the load of A in the first loop.','line_number':958,'multiline':False]
['text':' It has the bounds of the loop, i.e. start == 1.','line_number':961,'multiline':False]
['text':' It reads from A, so it should have a dependency on the last write to this','line_number':963,'multiline':False]
['text':' range - with is the input.','line_number':964,'multiline':False]
['text':' The third access is the store into B in the first loop.','line_number':968,'multiline':False]
['text':' It also has the bounds of the loop, i.e. start == 1.','line_number':971,'multiline':False]
['text':' The previous load is in its RHS, so it depends on it.','line_number':973,'multiline':False]
['text':' The third access is the load from B in the second loop.','line_number':977,'multiline':False]
['text':' It has the bounds of the second loop, i.e. >= 1 < 9.','line_number':980,'multiline':False]
['text':' It reads from B in a smaller range, so should depend on the previous','line_number':982,'multiline':False]
['text':' store.','line_number':983,'multiline':False]
['text':' The fourth: the store to B in the second loop.','line_number':987,'multiline':False]
['text':' It also has the bounds of the second loop.','line_number':990,'multiline':False]
['text':' The previous load is in its RHS, so it depends on it as before.','line_number':992,'multiline':False]
['text':' The fifth access is the load is from the 3rd loop, and skips previous B','line_number':996,'multiline':False]
['text':' accesses.','line_number':997,'multiline':False]
['text':' It has the bounds of the third loop: >= 3 < 4.','line_number':1000,'multiline':False]
['text':' It depends on the last thing to write to A, which is the A input.','line_number':1002,'multiline':False]
['text':' Sixth: the store into the output C.','line_number':1006,'multiline':False]
['text':' It also has the bounds of the third loop.','line_number':1009,'multiline':False]
['text':' The previous load is in its RHS, so it depends on it as always.','line_number':1011,'multiline':False]
['text':' The seventh access is the load of B in the fourth loop.','line_number':1015,'multiline':False]
['text':' It has the bounds of the final loop, >= 0 < 10','line_number':1018,'multiline':False]
['text':' The bounds of this read are larger than the bounds of the previous write,','line_number':1020,'multiline':False]
['text':' so it depends on both previous Stores to B.','line_number':1021,'multiline':False]
['text':' Eight: the final store into the output C.','line_number':1026,'multiline':False]
['text':' It also has the bounds of the final loop.','line_number':1029,'multiline':False]
['text':' The previous load is in its RHS, so it depends on it as always.','line_number':1031,'multiline':False]
['text':' The last access represents the output Buf.','line_number':1035,'multiline':False]
['text':' It has the bounds of the output Buf.','line_number':1038,'multiline':False]
['text':' sanity check the input we retrieved earlier matches.','line_number':1040,'multiline':False]
['text':' It depends on the last write to C only.','line_number':1042,'multiline':False]
['text':' Verify that we can still infer bounds when the loop var is offset.','line_number':1047,'multiline':False]
['text':' This enables using the execution order of the loops to determine if some','line_number':1057,'multiline':False]
['text':' loops are self dependent or not.','line_number':1058,'multiline':False]
['text':'
   * for (int x = 1; x < 10; x++) {
   *   A[x] = A[x - 1];
   * }
   * for (int x = 0; x < 9; x++) {
   *   A[x] = A[x + 1];
   * }
   * for (int x = 0; x < 9; x++) {
   *   A[9 - x] = A[8 - x];
   * }
   * for (int x = 0; x < 10; x++) {
   *   A[x] = A[9 - x];
   * }
   * for (int x = 0; x < 10; x++) {
   *   B[x] = A[x];
   * }
   ','line_number':1061,'multiline':True]
['text':' Sanity check output depends on Input.','line_number':1094,'multiline':False]
['text':'  0. Input: A[(0, 9)] - dependents: 1
   *  1. Load: A[(0, 8)] - depends on: 0 2  - dependents: 2
   *  2. Store: A[(1, 9)] - depends on: 1  - dependents: 1 3
   *  3. Load: A[(1, 9)] - depends on: 2  - dependents: 4
   *  4. Store: A[(0, 8)] - depends on: 3  - dependents: 5 7
   *  5. Load: A[(0, 8)] - depends on: 4  - dependents: 6
   *  6. Store: A[(1, 9)] - depends on: 5  - dependents: 7
   *  7. Load: A[(0, 9)] - depends on: 4 6 8  - dependents: 8
   *  8. Store: A[(0, 9)] - depends on: 7  - dependents: 7 9
   *  9. Load: A[(0, 9)] - depends on: 8  - dependents: 10
   *  10. Store: B[(0, 9)] - depends on: 9  - dependents: 11
   *  11. Output: B[(0, 9)] - depends on: 10
   ','line_number':1104,'multiline':True]
['text':' Now let's look at the bounds of each access.','line_number':1118,'multiline':False]
['text':' The first access is the input A.','line_number':1124,'multiline':False]
['text':' It has the bounds of the producing Input.','line_number':1127,'multiline':False]
['text':' The second access is the load A[x-1].','line_number':1130,'multiline':False]
['text':' It has the bounds of the loop modified by the offset of each index, in','line_number':1133,'multiline':False]
['text':' this case -1.','line_number':1134,'multiline':False]
['text':' It depends on the input, but also the store in the same loop, since','line_number':1136,'multiline':False]
['text':' different interations of the loop depend on each other.','line_number':1137,'multiline':False]
['text':' The third access is the Store to A[x] in the first loop.','line_number':1142,'multiline':False]
['text':' It has no offset on x, so should have the same bounds as the loop.','line_number':1145,'multiline':False]
['text':' The fourth access is the load A[x+1] in the second loop.','line_number':1148,'multiline':False]
['text':' It has the bounds of the loop (0 <= x < 9) modified by the offset of each','line_number':1151,'multiline':False]
['text':' index, in this case 1.','line_number':1152,'multiline':False]
['text':' This load totally overlaps the previous write to A, so it depends only on','line_number':1154,'multiline':False]
['text':' it and not the input.','line_number':1155,'multiline':False]
['text':' The fifth access is the store to A[x] in the second loop.','line_number':1159,'multiline':False]
['text':' It has no offset on x, so should have the same bounds as the loop.','line_number':1162,'multiline':False]
['text':' The sixth access is the load to A[8 - x] in the third loop.','line_number':1165,'multiline':False]
['text':' It has the bounds of the loop (0 <= x < 9) modified by the offset of each','line_number':1168,'multiline':False]
['text':' index, in this case 8 - x.','line_number':1169,'multiline':False]
['text':' This access has a negative stride, which will be normalized.','line_number':1170,'multiline':False]
['text':' This load totally overlaps the most recent write to A, so it depends only','line_number':1172,'multiline':False]
['text':' on it and not the input or the first write to A.','line_number':1173,'multiline':False]
['text':' The seventh access is the store to A[9 - x] in the third loop.','line_number':1177,'multiline':False]
['text':' This store has a negative stride on it's indices, but is normalized','line_number':1180,'multiline':False]
['text':' internally.','line_number':1181,'multiline':False]
['text':' The eighth access is the load A[9-x] in the second loop.','line_number':1184,'multiline':False]
['text':' It has the bounds of the loop (0 <= x < 9), modified by the offset 9 - x,','line_number':1187,'multiline':False]
['text':' which essentially traverses the loop backwards.','line_number':1188,'multiline':False]
['text':' This Load has three write dependencies:','line_number':1190,'multiline':False]
['text':'  * The previous store (#6) for elements 1-9','line_number':1192,'multiline':False]
['text':'  * An earlier store (#4) covering element 0','line_number':1194,'multiline':False]
['text':'  * A future store inside this loop, since this loop modifies the buffer','line_number':1196,'multiline':False]
['text':'  in a non distinct way (due to the load and store having different access','line_number':1197,'multiline':False]
['text':'  strides).','line_number':1198,'multiline':False]
['text':' The ninth access is the store to A[x] in the fourth loop.','line_number':1201,'multiline':False]
['text':' This store has a negative stride on it's indices, but is normalized','line_number':1204,'multiline':False]
['text':' internally.','line_number':1205,'multiline':False]
['text':' The tenth and 11th accesses are the copy from A[x] to B[x].','line_number':1208,'multiline':False]
['text':' The last access represents the output Buf.','line_number':1214,'multiline':False]
['text':' It has the bounds of the output Buf.','line_number':1217,'multiline':False]
['text':' It depends on the last write to B only.','line_number':1219,'multiline':False]
['text':' ok that's enough of that.','line_number':1223,'multiline':False]
['text':' Check many different cases of loop self dependency - when a load within a','line_number':1226,'multiline':False]
['text':' loop is dependent on a Store later in the same loop but in different','line_number':1227,'multiline':False]
['text':' iteration. This is affected by whether or not we can trust the execution','line_number':1228,'multiline':False]
['text':' order of the loop.','line_number':1229,'multiline':False]
['text':' This check assumes that the Stmt has a single Store with a single Load on','line_number':1239,'multiline':False]
['text':' the RHS.','line_number':1240,'multiline':False]
['text':' for (int y = 0; y < 10; y++) {
     *   A[y] = (A[y]) + 1;
     * } ','line_number':1247,'multiline':True]
['text':' Not self dependent since all loop iterations use a different y.','line_number':1251,'multiline':False]
['text':' for (int y = 0; y < 10; y++) {
     *   A[y + 1] = (A[y + 1]) + 1;
     * }
     ','line_number':1266,'multiline':True]
['text':' Not self dependent due to different y (with offset).','line_number':1271,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[0] = (A[0]) + x;
     * }
     ','line_number':1287,'multiline':True]
['text':' Is self dependent since all loops use a common constant element of A.','line_number':1292,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[0] = (B[0]) + x;
     * }
     ','line_number':1306,'multiline':True]
['text':' Is not self dependent because there is no store to the buffer that is','line_number':1311,'multiline':False]
['text':' read.','line_number':1312,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[y] = (A[y]) + x;
     * }
     ','line_number':1326,'multiline':True]
['text':' Is self dependent since all loops use a common symbolic element of A.','line_number':1331,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x] = A[x + 1];
     * }
     ','line_number':1345,'multiline':True]
['text':' In this case it depends if we are considering execution order.','line_number':1350,'multiline':False]
['text':' With analysis of order disabled, this is self dependent since the read','line_number':1358,'multiline':False]
['text':' from X+1 and the write to X+1 could be in reverse order.','line_number':1359,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x] = A[x + 1];
     * }
     ','line_number':1364,'multiline':True]
['text':' If order analysis is enabled, this is not dependent since the read for','line_number':1376,'multiline':False]
['text':' each element occurs before the write to that element.','line_number':1377,'multiline':False]
['text':' for (int x = 1; x < 10; x++) {
     *   A[x] = A[x - 1];
     * }
     ','line_number':1382,'multiline':True]
['text':' for (int x = 1; x < 10; x++) {
     *   A[x] = A[x - 1];
     * }
     ','line_number':1397,'multiline':True]
['text':' In this case, even with order analysis the Load is dependent on the','line_number':1409,'multiline':False]
['text':' Store, since the write to X occurs before the read from X.','line_number':1410,'multiline':False]
['text':' for (int x = 0; x < 9; x++) {
     *   A[9 - x] = A[8 - x];
     * }
     ','line_number':1415,'multiline':True]
['text':' Still works if the execution order is reversed, so long as the read','line_number':1420,'multiline':False]
['text':' comes before the write.','line_number':1421,'multiline':False]
['text':' However here was can determine the A store is earlier in the order than','line_number':1434,'multiline':False]
['text':' the load.','line_number':1435,'multiline':False]
['text':' for (int x = 0; x < 9; x++) {
     *   A[8 - x] = A[9 - x];
     * }
     ','line_number':1440,'multiline':True]
['text':' But not if it doesn't.','line_number':1445,'multiline':False]
['text':' for (int x = 0; x < 9; x++) {
     *   A[9 - x] = A[8 - x];
     * }
     ','line_number':1462,'multiline':True]
['text':' And not if we're not relying on execution order.','line_number':1467,'multiline':False]
['text':' for (int x = 3; x < 10; x++) {
     *   A[x - 2] = A[x - 1];
     * }
     ','line_number':1483,'multiline':True]
['text':' Forward order but negative indices.','line_number':1488,'multiline':False]
['text':' However here was can determine the A store is earlier in the order than','line_number':1497,'multiline':False]
['text':' the load.','line_number':1498,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2] = A[x * 2];
     * }
     ','line_number':1503,'multiline':True]
['text':' With an access stride.','line_number':1508,'multiline':False]
['text':' Execution order doesn't matter since the read and the write are totally','line_number':1511,'multiline':False]
['text':' distinct.','line_number':1512,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2] = A[x * 2 + 1];
     * }
     ','line_number':1522,'multiline':True]
['text':' Here we can use the common stride of the accesses to determine they are','line_number':1527,'multiline':False]
['text':' distinct.','line_number':1528,'multiline':False]
['text':' Note, this is the only place (loop self dependency) we use this stride','line_number':1529,'multiline':False]
['text':' to avoid unnecessary dependence.','line_number':1530,'multiline':False]
['text':' Execution order doesn't matter since the read and the write are totally','line_number':1533,'multiline':False]
['text':' distinct.','line_number':1534,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2] = A[x * 2 - 1];
     * }
     ','line_number':1544,'multiline':True]
['text':' same if the read is behind the write so long as they are distinct.','line_number':1549,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2] = A[x * 2 + 2];
     * }
     ','line_number':1560,'multiline':True]
['text':' But not if the offset is in the stride.','line_number':1565,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2] = A[x * 2 - 2];
     * }
     ','line_number':1576,'multiline':True]
['text':' Works with negative offsets too.','line_number':1581,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2] = A[x * 2 + 7];
     * }
     ','line_number':1592,'multiline':True]
['text':' Detects accesses are distinct when offset is large but not a multiple','line_number':1597,'multiline':False]
['text':' of stride.','line_number':1598,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2] = A[x * 2 + 4];
     * }
     ','line_number':1608,'multiline':True]
['text':' Works with offsets which are multiples of the stride.','line_number':1613,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 6] = A[x * 6 + 5];
     * }
     ','line_number':1623,'multiline':True]
['text':' detects accesses are distinct with large strides when the offset is','line_number':1628,'multiline':False]
['text':' within.','line_number':1629,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2] = A[x * 6];
     * }
     ','line_number':1640,'multiline':True]
['text':' detects accesses are overlapping when stride is different but a','line_number':1645,'multiline':False]
['text':' multiple.','line_number':1646,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 4] = A[x * 2];
     * }
     ','line_number':1657,'multiline':True]
['text':' still works when the read axis is the smaller stride.','line_number':1662,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2] = A[x * 6 + 1];
     * }
     ','line_number':1673,'multiline':True]
['text':' detects accesses are distinct when stride is different but a multiple','line_number':1678,'multiline':False]
['text':' and there is an offset.','line_number':1679,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2] = A[x * 6 + 4];
     * }
     ','line_number':1690,'multiline':True]
['text':' The smaller stride determines whether there is overlap.','line_number':1695,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2 + 3] = A[x * 6];
     * }
     ','line_number':1706,'multiline':True]
['text':' The smaller stride determines whether there is overlap, not the larger.','line_number':1711,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2] = A[x * 3 + 1];
     * }
     ','line_number':1722,'multiline':True]
['text':' If they have strides with no common multiple > 1, they overlap.','line_number':1727,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x] = A[x + 10];
     * }
     ','line_number':1737,'multiline':True]
['text':' If the offset is greater than the size of the loop, they can't overlap.','line_number':1742,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x] = A[9 - x];
     * }
     ','line_number':1753,'multiline':True]
['text':' If they have different execution orders they may overlap.','line_number':1758,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x * 2] = A[19 - x * 2];
     * }
     ','line_number':1768,'multiline':True]
['text':' Or they may not, depending on their start offset and strides.','line_number':1773,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x / 2] = A[x / 2];
     * }
     ','line_number':1786,'multiline':True]
['text':' If the stride is not monotonic, they overlap.','line_number':1791,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x / 2] = A[x / 2] + 1;
     * }
     ','line_number':1802,'multiline':True]
['text':' If the stride is not monotonic, they overlap - even with an offset.','line_number':1807,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   A[x % 2] = A[x % 2];
     * }
     ','line_number':1817,'multiline':True]
['text':' Mod too...','line_number':1822,'multiline':False]
['text':' for (int x = y; x < z; x++) {
     *   A[x] = A[x + 1];
     * }
     ','line_number':1836,'multiline':True]
['text':' Still works with symbolic loop extents.','line_number':1841,'multiline':False]
['text':' Verify that a strided access still works.','line_number':1864,'multiline':False]
['text':' TODO: actually this only works because of the size of the ranges, revisit','line_number':1865,'multiline':False]
['text':' this test after strided overlap is implemented.','line_number':1866,'multiline':False]
['text':' Sanity check output depends on input.','line_number':1883,'multiline':False]
['text':' Output has 2 dependencies... the store in each loop.','line_number':1886,'multiline':False]
['text':' TODO(nickg) - this test will fail due to the lack of stride math in Bound
TEST(MemDependency, MemDependencyCheckerLoopDistinctStrides) {
  BufHandle a("A", {20}, kInt);
  BufHandle b("B", {20}, kInt);
  BufHandle c("C", {10}, kInt);
  VarHandle x("x", kInt);
  VarHandle y("y", kInt);

  {
    analysis::MemDependencyChecker analyzer({a.node()}, {c.node()});
    StmtPtr stmt = Block::make(
        {For::make(
             x,
             0,
             10,
             Store::make(b, {x * 2 + 1}, Load::make(a, {x * 2 + 1}))),
         For::make(
             x, 0, 10, Store::make(b, {x * 2}, Load::make(a, {x * 2}))),
         For::make(x, 0, 10, Store::make(c, {x}, Load::make(b, {x})))

        });
    stmt->accept(&analyzer);

    std::cout << *stmt << "\n";
    for (auto& wi : analyzer.getHistory()) {
      wi->print();
    }
  }
}','line_number':1891,'multiline':True]
['text':' analysis on Stmts using Cond.','line_number':1921,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   C[x] = A[x];
     * }
     * if (y<5 ? 1 : 0) {
     *   C[0] = (B[0]) + 1;
     * } else {
     *   C[0] = (B[1]) + 1;
     * }
     ','line_number':1932,'multiline':True]
['text':' Future usages may depend on accesses in both branches of a condition.','line_number':1942,'multiline':False]
['text':' Output C should have 3 dependencies, each of the three stores.','line_number':1954,'multiline':False]
['text':' C depends indirectly on A and B.','line_number':1959,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   C[x] = A[x];
     * }
     * if (y<5 ? 1 : 0) {
     *   for (int x = 0; x < 10; x++) {
     *     C[x] = B[x];
     *   }
     * } else {
     *   for (int x = 0; x < 10; x++) {
     *     C[x] = (B[x]) + 1;
     *   }
     * }
     ','line_number':1965,'multiline':True]
['text':' Future usages may depend on accesses in both branches of a condition.','line_number':1979,'multiline':False]
['text':' Output C should have 3 dependencies, each of the three stores.','line_number':1995,'multiline':False]
['text':' TODO(nickg): actually since the true and false branch cover the total','line_number':2000,'multiline':False]
['text':' range of the first store this should have 2 dependencies, but we don't','line_number':2001,'multiline':False]
['text':' do that yet.','line_number':2002,'multiline':False]
['text':' C depends indirectly on A and B.','line_number':2004,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   C[x] = A[x];
     * }
     * if (y<5 ? 1 : 0) {
     *   for (int x = 0; x < 10; x++) {
     *     C[x] = (B[x]) + 1;
     *   }
     * }
     ','line_number':2010,'multiline':True]
['text':' Only has true branch.','line_number':2020,'multiline':False]
['text':' Output C should have 3 dependencies, each of the three stores.','line_number':2036,'multiline':False]
['text':' C depends indirectly on A and B.','line_number':2041,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   C[x] = A[x];
     * }
     * if (y<5 ? 1 : 0) {
     * } else {
     *   for (int x = 0; x < 10; x++) {
     *     C[x] = (B[x]) + 1;
     *   }
     * }
     ','line_number':2047,'multiline':True]
['text':' Only has false branch.','line_number':2058,'multiline':False]
['text':' Output C should have 3 dependencies, each of the three stores.','line_number':2074,'multiline':False]
['text':' C depends indirectly on A and B.','line_number':2079,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   C[x] = A[x];
     * }
     * if (C[0]<5 ? 1 : 0) {
     *   C[0] = 5;
     * }
     ','line_number':2085,'multiline':True]
['text':' Cond's Condition depends on a previous access.','line_number':2093,'multiline':False]
['text':' Stmts using IfThenElse.','line_number':2116,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   C[x] = A[x];
     * }
     * C[0] = (y < 5 ? (B[0]) + 1 : (B[1]) + 1;
     ','line_number':2127,'multiline':True]
['text':' Future usages may depend on accesses in both branches of a condition.','line_number':2133,'multiline':False]
['text':' Output C should have 2 dependencies, each of the two stores.','line_number':2149,'multiline':False]
['text':' Now we need to check the Store containing the IfThenElse.','line_number':2154,'multiline':False]
['text':' It should have 2 dependencies.','line_number':2157,'multiline':False]
['text':' C depends indirectly on A and B.','line_number':2160,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   C[x] = A[x];
     * }
     * C[0] = (y < 5 ? (B[0]) + 1 : 42;
     ','line_number':2166,'multiline':True]
['text':' If the load appears in only one side of an IfThenElse the output may be','line_number':2172,'multiline':False]
['text':' dependent on it.','line_number':2173,'multiline':False]
['text':' C depends indirectly on A and B.','line_number':2189,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   C[x] = (x < 5 ? B[x] : A[x];
     * }
     ','line_number':2195,'multiline':True]
['text':' In this case C is dependent on both A and B.','line_number':2200,'multiline':False]
['text':' TODO: in cases like this it would be possible to split the range of B','line_number':2202,'multiline':False]
['text':' into two bounds, one dependent on A and one dependent on B. We'd need to','line_number':2203,'multiline':False]
['text':' examine conditions relative to previously encountered loop variables. I'm','line_number':2204,'multiline':False]
['text':' uncertain if this would be helpful.','line_number':2205,'multiline':False]
['text':' C depends indirectly on A and B.','line_number':2219,'multiline':False]
['text':' Cutting a loop with single elem writes','line_number':2225,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   B[x] = A[x];
     * }
     * B[5] = 100;
     ','line_number':2234,'multiline':True]
['text':' Cutting a loop with single element writes.','line_number':2240,'multiline':False]
['text':' Output depends on input.','line_number':2249,'multiline':False]
['text':' Output has 2 dependencies.','line_number':2252,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   B[x] = A[x];
     * }
     * for (int x = 4; x < 7; x++) {
     *   B[x] = B[x] + 3;
     * }
     * B[5] = 100;
     * B[6] = 101;
     * B[7] = 102;
     ','line_number':2259,'multiline':True]
['text':' Cutting a loop with a smaller loop but then totally overlap that second','line_number':2270,'multiline':False]
['text':' loop with one element writes.','line_number':2271,'multiline':False]
['text':' Output depends on input.','line_number':2289,'multiline':False]
['text':' Output has 4 dependencies.','line_number':2292,'multiline':False]
['text':' Second loop depends on first loop.','line_number':2297,'multiline':False]
['text':' Output does not depend on second loop or store.','line_number':2300,'multiline':False]
['text':' Dynamic shapes (load in indices).','line_number':2306,'multiline':False]
['text':' for (int x = 0; x < B[0]; x++) {
     *   C[x] = A[x];
     * }
     ','line_number':2324,'multiline':True]
['text':'  0. Input: B[(0, 99)] - dependents: 2
     *  1. Input: A[(0, 99)] - dependents: 3
     *  2. Load: B[(0, 0)] - depends on: 0  - dependents: 3 4
     *  3. Load: A[(0, (B[0]) - 1)] - depends on: 1 2  - dependents: 4
     *  4. Store: C[(0, (B[0]) - 1)] - depends on: 2 3  - dependents: 5
     *  5. Output: C[(0, 99)] - depends on: 4
     ','line_number':2334,'multiline':True]
['text':' Output dependent on A input.','line_number':2342,'multiline':False]
['text':' Also dependent on B input to determine the size of the region written.','line_number':2344,'multiline':False]
['text':' The accesses in the loop depend on the load in the stop condition.','line_number':2350,'multiline':False]
['text':' Make a load from B to compare against.','line_number':2354,'multiline':False]
['text':' for (int x = B[0]; x < B[1]; x++) {
     *   C[x] = A[x];
     * }
     ','line_number':2362,'multiline':True]
['text':'  0. Input: B[(0, 99)] - dependents: 2 3
     *  1. Input: A[(0, 99)] - dependents: 4
     *  2. Load: B[(0, 0)] - depends on: 0  - dependents: 4 5
     *  3. Load: B[(1, 1)] - depends on: 0  - dependents: 4 5
     *  4. Load: A[(B[0], (B[1]) - 1)] - depends on: 1 2 3  - dependents: 5
     *  5. Store: C[(B[0], (B[1]) - 1)] - depends on: 2 3 4  - dependents: 6
     *  6. Output: C[(0, 99)] - depends on: 5
     ','line_number':2375,'multiline':True]
['text':' Sanity check output depends on input.','line_number':2384,'multiline':False]
['text':' The accesses in the loop depend on the load in the start condition.','line_number':2391,'multiline':False]
['text':' also the stop condition.','line_number':2395,'multiline':False]
['text':' Make loads from B to compare against.','line_number':2399,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   C[x] = A[B[x]];
     * }
     ','line_number':2407,'multiline':True]
['text':'  0. Input: B[(0, 99)] - dependents: 2
     *  1. Input: A[(0, 99)] - dependents: 3
     *  2. Load: B[(0, 9)] - depends on: 0  - dependents: 3 4
     *  3. Load: A[(B[0], B[9])] - depends on: 1 2  - dependents: 4
     *  4. Store: C[(0, 9)] - depends on: 2 3  - dependents: 5
     *  5. Output: C[(0, 99)] - depends on: 4
     ','line_number':2417,'multiline':True]
['text':' Sanity check output depends on input.','line_number':2425,'multiline':False]
['text':' The store depends on both loads, the load of A depends on the load of B.','line_number':2432,'multiline':False]
['text':' The loads in the indices depend on the relevant input buffer.','line_number':2438,'multiline':False]
['text':' The load from B has the loop bounds.','line_number':2442,'multiline':False]
['text':' The load from A has bounds B[0] to B[9].','line_number':2445,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   C[B[x]] = A[x];
     * }
     ','line_number':2452,'multiline':True]
['text':'  0. Input: B[(0, 99)] - dependents: 3
     *  1. Input: A[(0, 99)] - dependents: 2
     *  2. Load: A[(0, 9)] - depends on: 1  - dependents: 4
     *  3. Load: B[(0, 9)] - depends on: 0  - dependents: 4
     *  4. Store: C[(B[0], B[9])] - depends on: 2 3  - dependents: 5
     *  5. Output: C[(0, 99)] - depends on: 4
     ','line_number':2462,'multiline':True]
['text':' Sanity check output depends on input.','line_number':2469,'multiline':False]
['text':' The store depends on both loads, neither load is dependent.','line_number':2476,'multiline':False]
['text':' The loads each depend on their relevant input. (but accesses are in a','line_number':2483,'multiline':False]
['text':' different order than the last case).','line_number':2484,'multiline':False]
['text':' The load from B has the loop bounds.','line_number':2488,'multiline':False]
['text':' And so does the load from A.','line_number':2491,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   C[B[A[x]]] = x;
     * }
     ','line_number':2496,'multiline':True]
['text':'  0. Input: B[(0, 99)] - dependents: 3
     *  1. Input: A[(0, 99)] - dependents: 2
     *  2. Load: A[(0, 9)] - depends on: 1  - dependents: 3 4
     *  3. Load: B[(A[0], A[9])] - depends on: 0 2  - dependents: 4
     *  4. Store: C[(B[A[0]], B[A[9]])] - depends on: 2 3  - dependents: 5
     *  5. Output: C[(0, 99)] - depends on: 4
     ','line_number':2506,'multiline':True]
['text':' Sanity check output depends on input.','line_number':2514,'multiline':False]
['text':' The store depends on both loads.','line_number':2521,'multiline':False]
['text':' The outer load depends on the inner.','line_number':2525,'multiline':False]
['text':' The loads each depend on their relevant input. (but accesses are in a','line_number':2528,'multiline':False]
['text':' different order than the last case).','line_number':2529,'multiline':False]
['text':' The load from A has the loop bounds.','line_number':2533,'multiline':False]
['text':' The load from B as bounds A[0] to A[9].','line_number':2535,'multiline':False]
['text':' The store has bounds of B[A[0]] to B[A[9]].','line_number':2540,'multiline':False]
['text':' Verify multi dimensional bounds work.','line_number':2547,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   for (int y = 0; y < 9; y++) {
     *     for (int z = 0; z < 12; z++) {
     *       B[x, y, z] = A[x, y, z];
     *     }
     *   }
     * }
     ','line_number':2568,'multiline':True]
['text':' Full range.','line_number':2576,'multiline':False]
['text':' Sanity test: Output depends on input.','line_number':2595,'multiline':False]
['text':' 4 accesses: input, load, store, output.','line_number':2598,'multiline':False]
['text':' Simple chain from input to output.','line_number':2602,'multiline':False]
['text':' for (int x = 0; x < 5; x++) {
     *   for (int y = 0; y < 5; y++) {
     *     for (int z = 0; z < 5; z++) {
     *       B[x, y, z] = A[x, y, z];
     *     }
     *   }
     * }
     ','line_number':2614,'multiline':True]
['text':' Partial range.','line_number':2622,'multiline':False]
['text':' Sanity test: Output depends on input.','line_number':2641,'multiline':False]
['text':' 4 accesses: input, load, store, output.','line_number':2644,'multiline':False]
['text':' Simple chain from input to output.','line_number':2648,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   for (int y = 0; y < 12; y++) {
     *     B[x, 0, y] = A[x, 0, y];
     *   }
     * }
     ','line_number':2658,'multiline':True]
['text':' Partial loops.','line_number':2665,'multiline':False]
['text':' Sanity test: Output depends on input.','line_number':2677,'multiline':False]
['text':' 4 accesses: input, load, store, output.','line_number':2680,'multiline':False]
['text':' Simple chain from input to output.','line_number':2684,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
     *   for (int y = 0; y < 100; y++) {
     *     for (int z = 0; z < 12; z++) {
     *       B[x, 0, z] = (A[x, 0, z]) + (C[x, z]);
     *     }
     *   }
     * }
     ','line_number':2696,'multiline':True]
['text':' Loops that don't correspond to an index, bufs with different','line_number':2705,'multiline':False]
['text':' dimensionality.','line_number':2706,'multiline':False]
['text':' Sanity test: Output depends on both inputs.','line_number':2729,'multiline':False]
['text':' 6 accesses: 2 inputs, 2 loads, store, output.','line_number':2733,'multiline':False]
['text':' Simple chain from input to output over the A buf.','line_number':2737,'multiline':False]
['text':' history[0] is the C input, history[3] is the load from C.','line_number':2738,'multiline':False]
['text':' The store also depends on the load from the C input.','line_number':2742,'multiline':False]
['text':' A Buf accesses.','line_number':2746,'multiline':False]
['text':' C buf access.','line_number':2752,'multiline':False]
['text':' for (int x = 0; x < 9; x++) {
     *   for (int y = 0; y < 10; y++) {
     *     for (int z = 0; z < 12; z++) {
     *       B[x, 0, 0] = (B[x, y, z]) + (A[x, y, z]);
     *     }
     *   }
     * }
     ','line_number':2757,'multiline':True]
['text':' Multi-dim reductions.','line_number':2765,'multiline':False]
['text':' Sanity test: Output depends on input.','line_number':2789,'multiline':False]
['text':' 4 accesses: input, 2 loads, store, output.','line_number':2792,'multiline':False]
['text':' Simple chain from input to output.','line_number':2796,'multiline':False]
['text':' The load from B depends on the store to B.','line_number':2802,'multiline':False]
['text':' Various tests using the external Compute/Reduce API.','line_number':2813,'multiline':False]
['text':' for (int m = 0; m < 4; m++) {
   *   for (int n = 0; n < 5; n++) {
   *     for (int k = 0; k < 6; k++) {
   *       broadcast_add[m, n, k] = (a[m, n]) + (b[n, k]);
   *     }
   *   }
   * }
   * for (int m_1 = 0; m_1 < 4; m_1++) {
   *   for (int n_1 = 0; n_1 < 5; n_1++) {
   *     for (int k_1 = 0; k_1 < 6; k_1++) {
   *       d[m_1, n_1, k_1] = (broadcast_add(m_1, n_1, k_1)) + float(1);
   *     }
   *   }
   * }
   ','line_number':2817,'multiline':True]
['text':' Can determine if 2 loops created by Compute are dependent.','line_number':2833,'multiline':False]
['text':' Sanity test: Output depends on input.','line_number':2855,'multiline':False]
['text':' Second loop depends on first loop.','line_number':2859,'multiline':False]
['text':' for (int m = 0; m < 4; m++) {
   *   for (int n = 0; n < 5; n++) {
   *     for (int k = 0; k < 6; k++) {
   *       d[m, n, k] = ((a[m, n]) + (b[n, k])) + float(1);
   *     }
   *   }
   * }
   ','line_number':2868,'multiline':True]
['text':' Check inlining affects the number of accesses returned.','line_number':2877,'multiline':False]
['text':' Sanity test: Output depends on input.','line_number':2900,'multiline':False]
['text':' broadcast_add tensor should not appear in trace at all.','line_number':2904,'multiline':False]
['text':' Split an axis, so the number of loops != the number of dimensions.','line_number':2912,'multiline':False]
['text':' Splitting should not change accesses at all.','line_number':2934,'multiline':False]
['text':' Reorder an axis, so the loop order doesn't match the indexing order.','line_number':2958,'multiline':False]
['text':' Reordering should not change accesses at all.','line_number':2981,'multiline':False]
['text':' for (int l2 = 0; l2 < 2; l2++) {
   *   for (int n1 = 0; n1 < 3; n1++) {
   *     for (int m1 = 0; m1 < 6; m1++) {
   *       scale[l2, n1, m1] = (b[l2, n1, m1]) * (a[l2, n1, m1]);
   *     }
   *   }
   * }
   * for (int l1 = 0; l1 < 2; l1++) {
   *   sum[l1] = float(0);
   *   for (int n1_1 = 0; n1_1 < 3; n1_1++) {
   *     for (int m1_1 = 0; m1_1 < 6; m1_1++) {
   *       sum[l1] = ReduceOp(sum, (sum[l1]) + (scale(l1, n1_1, m1_1)),
   *                    out_args={l1}, reduce_args={n1, m1});
   *     }
   *   }
   * }
   ','line_number':3005,'multiline':True]
['text':' Can determine dependencies of a Reduction.','line_number':3023,'multiline':False]
['text':' Sanity test: Output depends on input.','line_number':3041,'multiline':False]
['text':' Second loop depends on first loop.','line_number':3045,'multiline':False]
['text':' Reduction depends on both inputs.','line_number':3050,'multiline':False]
['text':' mo, mi, no, ni, k ->','line_number':3084,'multiline':False]
['text':' mo, no, mi, ni, k','line_number':3085,'multiline':False]
['text':' mo, no, mi, ni, k ->','line_number':3092,'multiline':False]
['text':' mo, no, mi, k, ni','line_number':3093,'multiline':False]
['text':' mo, no, mi, k, ni ->','line_number':3100,'multiline':False]
['text':' mo, no, k, mi, ni','line_number':3101,'multiline':False]
['text':' Test both unlowered and lowered form.','line_number':3119,'multiline':False]
['text':' Outputs depend on inputs.','line_number':3124,'multiline':False]
['text':' The last write to gemm should cover the total bound of the output.','line_number':3128,'multiline':False]
['text':' A single dependency.','line_number':3131,'multiline':False]
['text':' dependencies is a set with 1 element, so can just deref begin().','line_number':3134,'multiline':False]
['text':' Check its a store.','line_number':3137,'multiline':False]
['text':' Likewise the first read from each input cover the entire range of the','line_number':3142,'multiline':False]
['text':' input.','line_number':3143,'multiline':False]
['text':' A single dependent each.','line_number':3147,'multiline':False]
['text':' They're both loads.','line_number':3151,'multiline':False]
['text':' now check lowered dependency graph.','line_number':3164,'multiline':False]
['text':' Lowering will change the dimensionality of all bounds due to index','line_number':3169,'multiline':False]
['text':' flattening and will insert Allocates and Frees.','line_number':3170,'multiline':False]
['text':' Filter out the alloc/free;','line_number':3177,'multiline':False]
['text':' Must depend on an Alloc.','line_number':3194,'multiline':False]
['text':' Must depend on an Free.','line_number':3209,'multiline':False]
['text':' Inputs and outputs are not flattened, only accesses.','line_number':3222,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':3238,'multiline':False]
['text':' namespace jit','line_number':3251,'multiline':False]
['text':' namespace torch','line_number':3252,'multiline':False]
