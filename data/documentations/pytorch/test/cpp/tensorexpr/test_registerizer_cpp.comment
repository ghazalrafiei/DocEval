['text':' Can replace a simple scalar access with a local variable.','line_number':14,'multiline':False]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[0] = (A[0]) + x;
   * }
   ','line_number':27,'multiline':True]
['text':'
   * int A_1 = 0;
   * for (int x = 0; x < 10; x++) {
   *   A_1 = x + A_1;
   * }
   * A[0] = A_1;
   ','line_number':36,'multiline':True]
['text':' Won't do replacement of a loop access.','line_number':58,'multiline':False]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[x] = (A[x]) + x;
   * }
   ','line_number':71,'multiline':True]
['text':' No change.','line_number':78,'multiline':False]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[x] = (A[x]) + x;
   * }
   ','line_number':81,'multiline':True]
['text':' Won't replace even if the load is a fixed scalar, since the store could','line_number':103,'multiline':False]
['text':' invalidate it.','line_number':104,'multiline':False]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[x] = (A[0]) + x;
   * }
   ','line_number':117,'multiline':True]
['text':' No change.','line_number':124,'multiline':False]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[x] = (A[0]) + x;
   * }
   ','line_number':127,'multiline':True]
['text':' We can registerize accesses that occur entirely within inner scopes, even if','line_number':149,'multiline':False]
['text':' they depend on the loop var.','line_number':150,'multiline':False]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   A[x] = (A[x]) + x;
   *   A[x] = (A[x]) + x;
   * }
   ','line_number':162,'multiline':True]
['text':' TODO: the order of terms in addition changes and in general depends on','line_number':171,'multiline':False]
['text':' some hash value. This results in unpredictable swaps of the operands from','line_number':172,'multiline':False]
['text':' random changes, which is not great. Ideally, we should ensure some','line_number':173,'multiline':False]
['text':' specific order (ideally, the original one).','line_number':174,'multiline':False]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   int A_1 = A[x];
   *   A_1 = x + A_1;
   *   A_1 = x + A_1;
   *   A[x] = A_1;
   * }
   ','line_number':175,'multiline':True]
['text':' An access can be overlapped by another read in the same Expr. In this case','line_number':199,'multiline':False]
['text':' B[z] and B[y] overlap and prevent registerization of both accesses.','line_number':200,'multiline':False]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   A[x] = (B[y]) + (B[z]);
   * }
   ','line_number':214,'multiline':True]
['text':' No change.','line_number':223,'multiline':False]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   A[0] = x + (A[1]);
   *   A[0] = x + (A[1]);
   * }
   * for (int x = 0; x < 10; x++) {
   *   A[0] = x + (A[1]);
   *   A[0] = x + (A[1]);
   * }
   ','line_number':253,'multiline':True]
['text':'
   * int A_1 = A[1];
   * int A_2 = A[0];
   * for (int x = 0; x < 10; x++) {
   *   A_2 = A_1 + x;
   *   A_2 = A_1 + x;
   * }
   * for (int x = 0; x < 10; x++) {
   *   A_2 = A_1 + x;
   *   A_2 = A_1 + x;
   * }
   * A[0] = A_2;
   ','line_number':266,'multiline':True]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   A[0] = (A[x]) + x;
   *   A[0] = (A[x]) + x;
   * }
   * for (int x = 0; x < 10; x++) {
   *   A[0] = (A[x]) + x;
   *   A[0] = (A[x]) + x;
   * }
   ','line_number':325,'multiline':True]
['text':' No change.','line_number':339,'multiline':False]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   A[0] = (A[x]) + x;
   *   A[0] = (A[x]) + x;
   * }
   * for (int x = 0; x < 10; x++) {
   *   A[0] = (A[x]) + x;
   *   A[0] = (A[x]) + x;
   * }
   ','line_number':370,'multiline':True]
['text':' No change.','line_number':384,'multiline':False]
['text':' Will registerize multiple accesses of different items of the same buffer.','line_number':393,'multiline':False]
['text':'
   * A[0] = 0;
   * A[1] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[0] = (A[0]) + x;
   *   A[1] = (A[1]) - x;
   * }
   ','line_number':409,'multiline':True]
['text':'
   * int A_1 = 0;
   * int A_2 = 0;
   * for (int x = 0; x < 10; x++) {
   *   A_2 = x + A_2;
   *   A_1 = A_1 - x;
   * }
   * A[1] = A_2;
   * A[0] = A_1;
   ','line_number':420,'multiline':True]
['text':' Will registerize the valid accesses while skipping invalid replacements.','line_number':448,'multiline':False]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   B[x] = x;
   * }
   * for (int x_1 = 0; x_1 < 10; x_1++) {
   *   A[0] = (A[0]) + (B[x_1]);
   * }
   ','line_number':464,'multiline':True]
['text':'
   * int A_1 = 0;
   * for (int x = 0; x < 10; x++) {
   *   B[x] = x;
   * }
   * for (int x_1 = 0; x_1 < 10; x_1++) {
   *   A_1 = A_1 + (B[x_1]);
   * }
   * A[0] = A_1;
   ','line_number':476,'multiline':True]
['text':' Can registerize variable accesses so long as the variable does not change.','line_number':503,'multiline':False]
['text':'
   * A[i] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[i] = (A[i]) + x;
   * }
   ','line_number':518,'multiline':True]
['text':'
   * int A_1 = 0;
   * for (int x = 0; x < 10; x++) {
   *   A_1 = x + A_1;
   * }
   * A[i] = A_1;
   ','line_number':527,'multiline':True]
['text':' Can registerize accesses dependent on multiple loop vars.','line_number':549,'multiline':False]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   for (int y = 0; y < 10; y++) {
   *     A[0] = x * y + (A[0]) * y;
   *   }
   * }
   ','line_number':569,'multiline':True]
['text':'
   * int A_1 = 0;
   * for (int x = 0; x < 10; x++) {
   *   for (int y = 0; y < 10; y++) {
   *     A_1 = x * y + y * A_1;
   *   }
   * }
   * A[0] = A_1;
   ','line_number':580,'multiline':True]
['text':' Can registerize correctly if scalars already exist in the program.','line_number':605,'multiline':False]
['text':' Registerize manually to make sure we only replace a single target.','line_number':621,'multiline':False]
['text':' Re-analyze and replace the second target.','line_number':633,'multiline':False]
['text':' Can registerize the load of A.','line_number':661,'multiline':False]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[0] = x + 1;
   * }
   ','line_number':670,'multiline':True]
['text':'
   * int A_1 = 0;
   * for (int x = 0; x < 10; x++) {
   *   A_1 = x + 1;
   * }
   * A[0] = A_1;
   ','line_number':679,'multiline':True]
['text':' Can registerize the load of A but not the store of B.','line_number':701,'multiline':False]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   B[x] = (A[0]) + x;
   * }
   ','line_number':715,'multiline':True]
['text':' TODO: its unnecessary to reorder the initializer of A[0], but it's not','line_number':724,'multiline':False]
['text':' actually worse so lets not worry for now.','line_number':725,'multiline':False]
['text':'
   * int A_1 = 0;
   * for (int x = 0; x < 10; x++) {
   *   B[x] = x + A_1;
   * }
   * A[0] = A_1;
   ','line_number':727,'multiline':True]
['text':' Won't registerize if there are multiple accesses which may overlap.','line_number':749,'multiline':False]
['text':' No change.','line_number':769,'multiline':False]
['text':'
   * Allocate(B, int, {C[0]});
   * A[0] = C[0];
   * B[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   B[0] = (B[0]) + x;
   *   A[0] = C[0];
   * }
   * Free(B);
   ','line_number':798,'multiline':True]
['text':'
   * int C_1 = C[0];
   * Allocate(B, int, {C_});
   * int A_1 = C_1;
   * int B_1 = 0;
   * for (int x = 0; x < 10; x++) {
   *   B_1 = B_1 + x;
   *   A_1 = C_1;
   * }
   * B[0] = B_1;
   * A[0] = A_1;
   * Free(B);
   ','line_number':811,'multiline':True]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   A[0] = (A[0]) + x;
   * }
   ','line_number':853,'multiline':True]
['text':'
   * int A_1 = A[0];
   * for (int x = 0; x < 10; x++) {
   *   A_1 = x + A_1;
   * }
   * A[0] = A_1;
   ','line_number':861,'multiline':True]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   A[x] = (A[x]) + x;
   * }
   ','line_number':893,'multiline':True]
['text':' No change.','line_number':902,'multiline':False]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   B[0] = (A[0]) + x;
   *   A[0] = B[0];
   * }
   ','line_number':923,'multiline':True]
['text':'
   * int A_1 = A[0];
   * int B_1 = B[0];
   * for (int x = 0; x < 10; x++) {
   *   B_1 = x + A_1;
   *   A_1 = B_1;
   * }
   * B[0] = B_1;
   * A[0] = A_1;
   ','line_number':932,'multiline':True]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[0] = (A[0]) + x;
   * }
   ','line_number':975,'multiline':True]
['text':' Should be able to registerize this since the scalar would exist before the','line_number':987,'multiline':False]
['text':' branch.','line_number':988,'multiline':False]
['text':'
   * A[x] = B[x];
   * C[x] = A[x];
   * if (x<5 ? 1 : 0) {
   *   A[x] = (A[x]) + 1;
   * }
   ','line_number':1003,'multiline':True]
['text':'
   * int A_1 = B[x];
   * C[x] = A_1;
   * if (x<5 ? 1 : 0) {
   *   A_1 = A_1 + 1;
   * }
   * A[x] = A_1;
   ','line_number':1013,'multiline':True]
['text':' Should be able to registerize this since the scalar exists in the same form','line_number':1036,'multiline':False]
['text':' after the branch and there is no overlap.','line_number':1037,'multiline':False]
['text':'
   * if (x<5 ? 1 : 0) {
   *   A[x] = (A[x]) + 1;
   * }
   * A[x] = B[x];
   * C[x] = A[x];
   ','line_number':1052,'multiline':True]
['text':'
   * int A_ 1 = A[x];
   * if (x<5 ? 1 : 0) {
   *   A_1 = A_1 + 1;
   * }
   * A_1 = B[x];
   * C[x] = A_1;
   * A[x] = A_1;
   ','line_number':1062,'multiline':True]
['text':' Should be able to registerize this as the combination of the two above rules.','line_number':1088,'multiline':False]
['text':'
   * A[x] = B[x];
   * C[x] = A[x];
   * if (x<5 ? 1 : 0) {
   *   A[x] = (A[x]) + 1;
   * }
   * B[x] = A[x];
   * A[x] = C[x];
   ','line_number':1105,'multiline':True]
['text':'
   * int A_1 = B[x];
   * C[x] = A_1;
   * if (x<5 ? 1 : 0) {
   *   A_1 = A_1 + 1;
   * }
   * B[x] = A_1;
   * A_1 = C[x];
   * A[x] = A_1;
   ','line_number':1117,'multiline':True]
['text':' An example where an access is cut by an overlapping access inside a','line_number':1145,'multiline':False]
['text':' condition, and both sides are large enough to be registerized but cannot be','line_number':1146,'multiline':False]
['text':' because there is no safe place to put the initializer or finalizer.','line_number':1147,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':1156,'multiline':False]
['text':'
   * A[x] = B[x];
   * C[x] = A[x];
   * if (x<5 ? 1 : 0) {
   *   A[x] = (A[x]) + 1;
   *   A[0] = 3;
   *   A[x] = (A[x]) + 1;
   * }
   * B[x] = A[x];
   * A[x] = C[x];
   ','line_number':1170,'multiline':True]
['text':' The A[0] store overlaps, A[x] cutting the region that can be registerized','line_number':1182,'multiline':False]
['text':' into two groups.','line_number':1183,'multiline':False]
['text':' Each group has 2 loads and 2 stores however, so we could registerize it,','line_number':1184,'multiline':False]
['text':' but the first group would need to be finalized inside the condition block,','line_number':1185,'multiline':False]
['text':' the second would need to be initialized inside the condition block. There's','line_number':1186,'multiline':False]
['text':' no safe place to put these that's visible to the other uses in the group','line_number':1187,'multiline':False]
['text':' and so neither registerization is possible.','line_number':1188,'multiline':False]
['text':' No change.','line_number':1193,'multiline':False]
['text':' Same as the above, but the access group before the condition (and after the','line_number':1202,'multiline':False]
['text':' condition) are large enough to be registerized without needing the access','line_number':1203,'multiline':False]
['text':' from the loop. Registerization occurs but does not include any accesses in','line_number':1204,'multiline':False]
['text':' the condition, and the first group must be finalized before the Cond, the','line_number':1205,'multiline':False]
['text':' second initialized after it.','line_number':1206,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':1215,'multiline':False]
['text':'
   * A[x] = B[x];
   * A[x] = B[x + 1];
   * C[x] = A[x];
   * if (x<5 ? 1 : 0) {
   *   A[x] = (A[x]) + 1;
   *   A[0] = 3;
   *   A[x] = (A[x]) + 1;
   * }
   * B[x] = A[x];
   * B[x + 1] = A[x];
   * A[x] = C[x];
   ','line_number':1231,'multiline':True]
['text':'
   * int A_1 = B[x];              // A_1 initializer
   * A_1 = B[x + 1];              //
   * C[x] = A_1;                  //
   * A[x] = A_1;                  // A_1 finalizer
   * if (x<5 ? 1 : 0) {
   *   A[x] = (A[x]) + 1;
   *   A[0] = 3;
   *   A[x] = (A[x]) + 1;
   * }
   * int A_2 = A[x];              // A_2 initialier
   * B[x] = A_2;                  //
   * B[x + 1] = A_2;              //
   * A_2 = C[x];                  //
   * A[x] = A_2;                  // A_2 finalizer
   ','line_number':1247,'multiline':True]
['text':' When accesses are within conditional blocks they are not visible to the wider','line_number':1288,'multiline':False]
['text':' program, because we don't know if the branch would be taken and if it isn't','line_number':1289,'multiline':False]
['text':' the accesses in it don't need to be valid (think size checks on the index).','line_number':1290,'multiline':False]
['text':' In this case the accesses cannot be registerized.','line_number':1291,'multiline':False]
['text':'
   * if (x<5 ? 1 : 0) {
   *   A[x] = (A[x]) + 1;
   * }
   * if (x>5 ? 1 : 0) {
   *   A[x] = (A[x]) + 1;
   * }
   ','line_number':1308,'multiline':True]
['text':' No change.','line_number':1320,'multiline':False]
['text':' But... if the same access is found in a non conditional scope, that means','line_number':1329,'multiline':False]
['text':' that that access is valid in the higher scope (or at least if its not it's','line_number':1330,'multiline':False]
['text':' the user's fault). It "unhides" the conditional accesses, allowing','line_number':1331,'multiline':False]
['text':' registerization to occur.','line_number':1332,'multiline':False]
['text':'
   * if (x<5 ? 1 : 0) {
   *   A[x] = (A[x]) + 1;
   * }
   * A[x] = (A[x]) + 1;            <-- this is doing the unhiding.
   * if (x>5 ? 1 : 0) {
   *   A[x] = (A[x]) + 1;
   * }
   ','line_number':1350,'multiline':True]
['text':'
   * int A_1 = A[x];
   * if (x<5 ? 1 : 0) {
   *   A_1 = A_1 + 1;
   * }
   * A_1 = A_1 + 1;
   * if (x>5 ? 1 : 0) {
   *   A_1 = A_1 + 1;
   * }
   * A[x] = A_1;
   ','line_number':1362,'multiline':True]
['text':' Can registerize a load that occurs in the condition of a Cond.','line_number':1392,'multiline':False]
['text':'
   * A[x] = B[x];
   * C[x] = A[x];
   * if ((A[x])<5 ? 1 : 0) {
   *   C[x] = (C[x]) + 1;
   * }
   ','line_number':1408,'multiline':True]
['text':'
   * int A_1 = B[x];
   * int C_1 = A_1;
   * if (A_1<5 ? 1 : 0) {
   *   C_1 = C_1 + 1;
   * }
   * C[x] = C_1;
   ','line_number':1418,'multiline':True]
['text':' Appearing in the condition of a Cond makes it visible to the enclosing scope,','line_number':1441,'multiline':False]
['text':' and so we can registerize internal usages.','line_number':1442,'multiline':False]
['text':'
   * if ((A[x])<5 ? 1 : 0) {
   *   A[x] = (A[x]) + 1;
   * } else {
   *   A[x] = (A[x]) + 10;
   * }
   ','line_number':1454,'multiline':True]
['text':'
   * int A_1 = A[x];
   * if (A_1<5 ? 1 : 0) {
   *   A_1 = A_1 + 1;
   * } else {
   *   A_1 = A_1 + 10;
   * }
   * A[x] = A_1;
   ','line_number':1464,'multiline':True]
['text':' Conditional hiding also works for IfThenElse exprs.','line_number':1490,'multiline':False]
['text':'
   * B[y] = IfThenElse(x<5 ? 1 : 0, (A[x]) + 1, (A[x + 1]) + 2);
   * B[y + 1] = IfThenElse(x<5 ? 1 : 0, (A[x]) + 1, (A[x + 1]) + 2);
   ','line_number':1514,'multiline':True]
['text':' No change.','line_number':1522,'multiline':False]
['text':' Conditional unhiding also works for IfThenElse exprs.','line_number':1531,'multiline':False]
['text':'
   * A[x] = 0;
   * B[y] = IfThenElse(x<5 ? 1 : 0, (A[x]) + 1, (A[x + 1]) + 2);
   * B[y + 1] = IfThenElse(x<5 ? 1 : 0, (A[x]) + 1, (A[x + 1]) + 2);
   ','line_number':1557,'multiline':True]
['text':'
   * int A_1 = 0;
   * B[y] = IfThenElse(x<5 ? 1 : 0, A_1 + 1, (A[x + 1]) + 2);
   * B[y + 1] = IfThenElse(x<5 ? 1 : 0, A_1 + 1, (A[x + 1]) + 2);
   * A[x] = A_1;
   ','line_number':1565,'multiline':True]
['text':' Nested IfThenElse exprs can't promote to higher level scopes.','line_number':1585,'multiline':False]
['text':'
   * A[x] = IfThenElse(x<3 ? 1 : 0,
   *          IfThenElse(x==2 ? 1 : 0, D[x], B[x]),
   *            IfThenElse(x==5 ? 1 : 0, C[x], D[x]));
   ','line_number':1607,'multiline':True]
['text':' No change.','line_number':1616,'multiline':False]
['text':' Cannot registerize an access completely contained within an IfThenElse','line_number':1625,'multiline':False]
['text':' branch, since it is not a Stmt and cannot hold variable definitions. We need','line_number':1626,'multiline':False]
['text':' to check that we don't promote the initializer/finalizer to the enclosing','line_number':1627,'multiline':False]
['text':' Block.','line_number':1628,'multiline':False]
['text':' Making these floats so they don't get simplified to a single access.','line_number':1630,'multiline':False]
['text':'
   * A[x] = IfThenElse(x<3 ? 1 : 0, (B[x]) + (B[x]), B[x]);
   ','line_number':1643,'multiline':True]
['text':' No change.','line_number':1650,'multiline':False]
['text':' If this was a Cond instead of an IfThenElse then we could registerize the','line_number':1658,'multiline':False]
['text':' two accesses to B[x] in the True branch.','line_number':1659,'multiline':False]
['text':' Actually lets verify that.','line_number':1661,'multiline':False]
['text':'
   * if (x<3 ? 1 : 0) {
   *   A[x] = (B[x]) + (B[x]);
   * } else {
   *   A[x] = B[x];
   * }
   ','line_number':1668,'multiline':True]
['text':'
   * if (x<3 ? 1 : 0) {
   *   float B_1 = B[x];
   *   A[x] = B_1 + B_1;
   * } else {
   *   A[x] = B[x];
   * }
   ','line_number':1678,'multiline':True]
['text':' Can registerize a load that occurs in the condition of an IfThenElse;','line_number':1706,'multiline':False]
['text':'
   * A[x] = A[x];       <---- just here so there are enough accesses to combine.
   * A[x] = IfThenElse((A[x])<5 ? 1 : 0, B[0], C[0]);
   ','line_number':1724,'multiline':True]
['text':'
   * int A_1 = A[x];
   * A_1 = A_1;
   * A_1 = IfThenElse(A_1<5 ? 1 : 0, B[0], C[0]);
   * A[x] = A_1;
   ','line_number':1731,'multiline':True]
['text':' Appearing in the condition of a Cond makes it visible to the enclosing scope,','line_number':1750,'multiline':False]
['text':' and so we can registerize internal usages.','line_number':1751,'multiline':False]
['text':'
   * B[x] = IfThenElse((A[x])<5 ? 1 : 0, (A[x]) + 1, (A[x]) + 10);
   ','line_number':1767,'multiline':True]
['text':'
   * int A_1 = A[x];
   * B[x] = IfThenElse(A_1<5 ? 1 : 0, A_1 + 1, A_1 + 10);
   ','line_number':1773,'multiline':True]
['text':' Cannot promote accesses internal to IfThenElse branches even if the enclosing','line_number':1789,'multiline':False]
['text':' scope if conditional.','line_number':1790,'multiline':False]
['text':' for (int x = 0; x < 10; x++) {
   *   if (x<5 ? 1 : 0) {
   *     A[x] = IfThenElse(x<5 ? 1 : 0, (A[x]) + x, (A[x - 5]) + x);
   *   } else {
   *     A[x - 5] = IfThenElse(x<5 ? 1 : 0, (A[x]) + x, (A[x - 5]) + x);
   *   }
   * }
   ','line_number':1821,'multiline':True]
['text':' No change.','line_number':1830,'multiline':False]
['text':' We can registerize an IfThenElse that appears in the condition branch of a','line_number':1839,'multiline':False]
['text':' Cond. This is a weird but valid thing to do.','line_number':1840,'multiline':False]
['text':'
   * if ((IfThenElse((A[x])<5 ? 1 : 0, A[x], B[x]))==x ? 1 : 0) {
   *   C[x] = (C[x]) + 1;
   * }
   ','line_number':1859,'multiline':True]
['text':' access to A can be registerized, but not B or C','line_number':1867,'multiline':False]
['text':'
   * int A_1 = A[x];
   * if ((IfThenElse(A_1<5 ? 1 : 0, A_1, B[x]))==x ? 1 : 0) {
   *   C[x] = (C[x]) + 1;
   * }
   ','line_number':1869,'multiline':True]
['text':' Can registerize a conditional access in the RHS of a store unhidden by it's','line_number':1888,'multiline':False]
['text':' LHS, and hoist it out of a loop.','line_number':1889,'multiline':False]
['text':'
   * for (int y = 0; y < 10; y++) {
   *   A[x] = IfThenElse(x<3 ? 1 : 0, A[x], B[y]);
   * }
   ','line_number':1908,'multiline':True]
['text':'
   * int A_1 = A[x];
   * for (int y = 0; y < 10; y++) {
   *   A_1 = IfThenElse(x<3 ? 1 : 0, A_1, B[y]);
   * }
   * A[x] = A_1;
   ','line_number':1916,'multiline':True]
['text':' Cannot registerize if the RHS overlaps the access creating visibility.','line_number':1938,'multiline':False]
['text':'
   * for (int y = 0; y < 10; y++) {
   *   A[x] = IfThenElse(x<3 ? 1 : 0, A[x], A[y]);
   * }
   ','line_number':1957,'multiline':True]
['text':' No change.','line_number':1966,'multiline':False]
['text':' Simple case where an access is cut by an overlapping access later in the','line_number':1975,'multiline':False]
['text':' program, we can registerize up until the overlap.','line_number':1976,'multiline':False]
['text':'
   * A[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[0] = (A[0]) + x;
   * }
   * for (int x = 1; x < 10; x++) {
   *   A[x] = A[x - 1];
   * }
   ','line_number':1990,'multiline':True]
['text':'
   * int A_1 = 0;
   * for (int x = 0; x < 10; x++) {
   *   A_1 = A_1 + x;
   * }
   * A[0] = A_1;
   * for (int x = 1; x < 10; x++) {
   *   A[x] = A[x - 1];
   * }
   ','line_number':2002,'multiline':True]
['text':' We can registerize an access which overlaps a previous access, the','line_number':2031,'multiline':False]
['text':' initializer must be inserted after the previous access.','line_number':2032,'multiline':False]
['text':'
   * for (int x = 1; x < 10; x++) {
   *   A[x] = A[x - 1];
   * }
   * A[0] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[0] = (A[0]) + x;
   * }
   ','line_number':2046,'multiline':True]
['text':'
   * for (int x = 1; x < 10; x++) {
   *   A[x] = A[x - 1];
   * }
   * int A_1 = 0;
   * for (int x = 0; x < 10; x++) {
   *   A_1 = A_1 + x;
   * }
   * A[0] = A_1;
   ','line_number':2058,'multiline':True]
['text':' The combination of the previous two tests, an access is cut by an overlapping','line_number':2087,'multiline':False]
['text':' access in both directions.','line_number':2088,'multiline':False]
['text':'
   * A[0] = 2;
   * for (int x1 = 0; x1 < 10; x1++) {
   *   A[0] = (A[0]) + x1;
   * }
   * for (int x2 = 1; x2 < 10; x2++) {
   *   A[x2] = A[x2 - 1];
   * }
   * for (int x3 = 0; x3 < 10; x3++) {
   *   A[0] = (A[0]) + x3;
   * }
   ','line_number':2102,'multiline':True]
['text':'
   * int A_1 = 2;
   * for (int x1 = 0; x1 < 10; x1++) {
   *   A_1 = A_1 + x1;
   * }
   * A[0] = A_1;
   * for (int x2 = 1; x2 < 10; x2++) {
   *   A[x2] = A[x2 - 1];
   * }
   * int A_2 = A[0];
   * for (int x3 = 0; x3 < 10; x3++) {
   *   A_2 = A_2 + x3;
   * }
   * A[0] = A_2;
   ','line_number':2117,'multiline':True]
['text':' An element could be registerized program wide but is cut by a conditional','line_number':2155,'multiline':False]
['text':' access, we should break this into two scalars and write back to the buffer','line_number':2156,'multiline':False]
['text':' before the condition.','line_number':2157,'multiline':False]
['text':'
   * A[0] = 2;
   * for (int x = 0; x < 10; x++) {
   *   A[0] = (A[0]) + x;
   * }
   * if (x<5 ? 1 : 0) {
   *   A[x] = A[x - 1];
   * }
   * for (int x = 0; x < 10; x++) {
   *   A[0] = (A[0]) + x;
   * }
   ','line_number':2172,'multiline':True]
['text':'
   * int A_1 = 2;
   * for (int x = 0; x < 10; x++) {
   *   A_1 = A_1 + x;
   * }
   * A[0] = A_1;
   * if (x<5 ? 1 : 0) {
   *   A[x] = A[x - 1];
   * }
   * int A_2 = A[0];
   * for (int x = 0; x < 10; x++) {
   *   A_2 = A_2 + x;
   * }
   * A[0] = A_2;
   ','line_number':2187,'multiline':True]
['text':' Tests case where an access is cut by an internal conditional access which','line_number':2225,'multiline':False]
['text':' itself is registerized.','line_number':2226,'multiline':False]
['text':'
   * A[0] = 1;
   * A[0] = 3;
   * if (x<5 ? 1 : 0) {
   *   A[x] = 1;
   *   A[x] = 3;
   * }
   * A[0] = 4;
   * A[0] = 6;
   ','line_number':2240,'multiline':True]
['text':'
   * int A_1 = 1;
   * A_1 = 3;
   * A[0] = A_1;
   * if (x<5 ? 1 : 0) {
   *   int A_2 = 1;
   *   A_2 = 3;
   *   A[x] = A_2;
   * }
   * int A_3 = 4;
   * A_3 = 6;
   * A[0] = A_3;
   ','line_number':2253,'multiline':True]
['text':' First statement in condition closes outer access, but can be registerized','line_number':2287,'multiline':False]
['text':' with later statements.','line_number':2288,'multiline':False]
['text':'
   * A[0] = 1;
   * A[0] = 3;
   * if (x<5 ? 1 : 0) {
   *   A[x] = 1;
   *   A[x] = 3;
   * }
   * A[x] = 4;
   * A[x] = 6;
   ','line_number':2302,'multiline':True]
['text':'
   * int A_1 = 1;
   * A_1 = 3;
   * A[0] = A_1;
   * int A_2 = A[x];    <--- must read from the input here.
   * if (x<5 ? 1 : 0) {
   *   A_2 = 1;
   *   A_2 = 3;
   * }
   * A_2 = 4;
   * A_2 = 6;
   * A[x] = A_2;
   ','line_number':2315,'multiline':True]
['text':' TODO: I suppose we could refactor with a conditional initializer?','line_number':2329,'multiline':False]
['text':' An access cuts two open overlaps and creates four scalar variables.','line_number':2351,'multiline':False]
['text':'
   * A[1] = A[0];
   * A[0] = A[1];
   * A[0] = A[1];
   * for (int x = 1; x < 10; x++) {
   *   A[x] = x;
   * }
   * A[1] = A[0];
   * A[0] = A[1];
   * A[0] = A[1];
   ','line_number':2364,'multiline':True]
['text':'
   * int A_1 = A[0];
   * int A_2 = A_1;
   * A_1 = A_2;
   * A_1 = A_2;
   * A[1] = A_2;
   * A[0] = A_1;
   * for (int x = 1; x < 10; x++) {
   *   A[x] = x;
   * }
   * int A_3 = A[0];
   * int A_4 = A_3;
   * A_3 = A_4;
   * A_3 = A_4;
   * A[1] = A_4;
   * A[0] = A_3;
   ','line_number':2378,'multiline':True]
['text':' Nested blocks will automatically be flattened and do not provent','line_number':2420,'multiline':False]
['text':' registerization of enclosed accesses.','line_number':2421,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':2426,'multiline':False]
['text':'
   * A[0] = (A[0]) + 1;
   * {
   *   A[0] = (A[0]) + 2;
   * }
   * {
   *   A[0] = (A[0]) + 3;
   *   {
   *     A[0] = (A[0]) + 4;
   *   }
   * }
   ','line_number':2434,'multiline':True]
['text':'
   * int A_1 = A[0];
   * A_1 = A_1 + 1;
   * A_1 = A_1 + 2;
   * A_1 = A_1 + 3;
   * A_1 = A_1 + 4;
   * A[0] = A_1;
   ','line_number':2449,'multiline':True]
['text':' The access can be registerized internally to a condition, but must ensure','line_number':2473,'multiline':False]
['text':' that both initializer and finalizer are within the same condition.','line_number':2474,'multiline':False]
['text':'
   * if (x<5 ? 1 : 0) {
   *   A[0] = (A[0]) + 1;
   *   if (x==2 ? 1 : 0) {
   *
   *     A[0] = (A[0]) + 1;
   *   }
   * }
   ','line_number':2488,'multiline':True]
['text':'
   * if (x<5 ? 1 : 0) {
   *   int A_1 = A[0];
   *   A_1 = A_1 + 1;
   *   if (x==2 ? 1 : 0) {
   *     A_1 = A_1 + 1;
   *   }
   * A[0] = A_1;
   * }
   ','line_number':2500,'multiline':True]
['text':' If an access exists outside the scope of the condition then we can lift','line_number':2528,'multiline':False]
['text':' nested conditional usages into the same scalar.','line_number':2529,'multiline':False]
['text':'
   * A[0] = (A[0]) + 1;
   * if (x<5 ? 1 : 0) {
   *   A[1] = 1;
   *   if (x==2 ? 1 : 0) {
   *     A[0] = (A[0]) + 1;
   *   }
   * }
   ','line_number':2545,'multiline':True]
['text':'
   * int A_1 = A[0];
   * A_1 = A_1 + 1;
   * if (x<5 ? 1 : 0) {
   *   A[1] = 1;
   *   if (x==2 ? 1 : 0) {
   *     A_1 = A_1 + 1;
   *   }
   * }
   * A[0] = A_1;
   ','line_number':2557,'multiline':True]
['text':'
   * if (x==2 ? 1 : 0) {
   *   A[0] = (A[0]) + 1;
   * }
   * if (x<5 ? 1 : 0) {
   *   if (x==2 ? 1 : 0) {
   *     A[0] = (A[0]) + 1;
   *   }
   * }
   ','line_number':2601,'multiline':True]
['text':' No change.','line_number':2615,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-deadcode.DeadStores)','line_number':2623,'multiline':False]
['text':'
   * if (x<5 ? 1 : 0) {
   *   if (x==2 ? 1 : 0) {
   *     A[0] = (A[0]) + 1;
   *   }
   * }
   * if (x==2 ? 1 : 0) {
   *   A[0] = (A[0]) + 1;
   * }
   ','line_number':2643,'multiline':True]
['text':' No change.','line_number':2657,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-deadcode.DeadStores)','line_number':2665,'multiline':False]
['text':' If an access is cut by another access internal to a condition block, it still','line_number':2669,'multiline':False]
['text':' cuts the access.','line_number':2670,'multiline':False]
['text':'
   * A[0] = (A[0]) + 1;
   * if (x<5 ? 1 : 0) {
   *   A[x] = 1;
   *   if (x==2 ? 1 : 0) {
   *
   *     A[0] = (A[0]) + 1;
   *   }
   * }
   ','line_number':2686,'multiline':True]
['text':' No change.','line_number':2700,'multiline':False]
['text':'
   * if (x==2 ? 1 : 0) {
   *   A[0] = (A[0]) + 1;
   * }
   * for (int x = 0; x < 10; x++) {
   *   B[x] = 0;     <-- this is only here to prevent Loop/Cond reordering.
   *   if (x==2 ? 1 : 0) {
   *     A[0] = (A[0]) + 1;
   *   }
   * }
   ','line_number':2729,'multiline':True]
['text':' No change.','line_number':2744,'multiline':False]
['text':' Three loops and four element regions, three of which should be registerized','line_number':2753,'multiline':False]
['text':' at different levels of the IR.','line_number':2754,'multiline':False]
['text':'
   * A[4] = 0;
   * if (x>2 ? 1 : 0) {
   *   if (x>3 ? 1 : 0) {
   *     if (x>4 ? 1 : 0) {
   *       A[1] = (A[1]) + 1;
   *       A[2] = (A[2]) + 1;
   *       A[3] = (A[3]) + 1;
   *       A[4] = (A[4]) + 1;
   *       A[1] = (A[1]) + 1;
   *     }
   *     A[2] = (A[2]) + 1;
   *   }
   * }
   ','line_number':2786,'multiline':True]
['text':'
   * int A_1 = 0;
   * if (x>2 ? 1 : 0) {
   *   if (x>3 ? 1 : 0) {
   *     int A_3 = A[2];
   *     if (x>4 ? 1 : 0) {
   *       int A_2 = A[1];
   *       A_2 = A_2 + 1;
   *       A_3 = A_3 + 1;
   *       A[3] = (A[3]) + 1;
   *       A_1 = A_1 + 1;
   *       A_2 = A_2 + 1;
   *       A[1] = A_2;
   *     }
   *     A_3 = A_3 + 1;
   *     A[2] = A_3;
   *   }
   * }
   * A[4] = A_1;
   ','line_number':2804,'multiline':True]
['text':' Can replace a simple scalar access with a local variable even when that','line_number':2852,'multiline':False]
['text':' variable is an outer loop var.','line_number':2853,'multiline':False]
['text':'
   * for (int y = 0; y < 10; y++) {
   *   for (int x = 0; x < 10; x++) {
   *     A[y] = (A[y]) + x;
   *   }
   * }
   ','line_number':2869,'multiline':True]
['text':'
   * for (int y = 0; y < 10; y++) {
   *   int A_1 = A[y];
   *   for (int x = 0; x < 10; x++) {
   *     A_1 = A_1 + x;
   *   }
   * A[y] = A_1;
   * }
   ','line_number':2879,'multiline':True]
['text':' Test the positive case of the hiddenAccess split, where an internal','line_number':2905,'multiline':False]
['text':' conditional access can be hoisted up through a loop to match an existing','line_number':2906,'multiline':False]
['text':' access in a higher scope and the two can be registerized.','line_number':2907,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':2923,'multiline':False]
['text':'
   * if (x==2 ? 1 : 0) {
   *   A[0] = 0;
   *   for (int x = 0; x < 10; x++) {
   *     B[x] = 0;
   *     if (x==3 ? 1 : 0) {
   *       for (int y = 0; y < 10; y++) {
   *         A[0] = (A[0]) + 1;
   *       }
   *     }
   *   }
   * }
   ','line_number':2935,'multiline':True]
['text':'
   * if (x==2 ? 1 : 0) {
   *   int A_1 = 0;
   *   for (int x = 0; x < 10; x++) {
   *     B[x] = 0;
   *     if (x==3 ? 1 : 0) {
   *       for (int y = 0; y < 10; y++) {
   *         A_1 = A_1 + 1;
   *       }
   *     }
   *   }
   *   A[0] = A_1;
   * }
   ','line_number':2951,'multiline':True]
['text':' Test the negative case of the hiddenAccess split, where the hoisted access is','line_number':2987,'multiline':False]
['text':' never unhidden at a higher scope and registerization occurs at the lower','line_number':2988,'multiline':False]
['text':' scope.','line_number':2989,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':3003,'multiline':False]
['text':'
   * if (x==2 ? 1 : 0) {
   *   A[0] = 0;
   *   for (int x = 0; x < 10; x++) {
   *     B[x] = 0;
   *     if (x==3 ? 1 : 0) {
   *       for (int y = 0; y < 10; y++) {
   *         A[0] = (A[0]) + 1;
   *       }
   *     }
   *   }
   * }
   ','line_number':3014,'multiline':True]
['text':'
   * if (x==2 ? 1 : 0) {
   *   for (int x = 0; x < 10; x++) {
   *     B[x] = 0;
   *     if (x==3 ? 1 : 0) {
   *       int A_1 = A[0];
   *       for (int y = 0; y < 10; y++) {
   *         A_1 = A_1 + 1;
   *       }
   *       A[0] = A_1;
   *     }
   *   }
   * }
   ','line_number':3030,'multiline':True]
['text':' In this case the conditional access must be hoisted by two loops, there are','line_number':3066,'multiline':False]
['text':' two accesses here one is unhidden and the other isnt. A[0] can be','line_number':3067,'multiline':False]
['text':' registerized but B[0] cannot.','line_number':3068,'multiline':False]
['text':'
   * if (x==2 ? 1 : 0) {
   *   A[0] = 0;
   *   for (int x = 0; x < 10; x++) {
   *     for (int y = 0; y < 10; y++) {
   *       if (y==3 ? 1 : 0) {
   *         A[0] = (A[0]) + 1;
   *         B[0] = (B[0]) + 1;
   *       }
   *     }
   *   }
   * }
   ','line_number':3096,'multiline':True]
['text':'
   * if (x==2 ? 1 : 0) {
   *   int A_1 = 0;
   *   for (int x = 0; x < 10; x++) {
   *     for (int y = 0; y < 10; y++) {
   *       if (y==3 ? 1 : 0) {
   *         A_1 = A_1 + 1;
   *         B[0] = (B[0]) + 1;
   *       }
   *     }
   *   }
   *   A[0] = A_1;
   * }
   ','line_number':3112,'multiline':True]
['text':' Accesses are registerized inside two conditions, but the immediate parent is','line_number':3148,'multiline':False]
['text':' not a condition.','line_number':3149,'multiline':False]
['text':'
   * if (x<5 ? 1 : 0) {
   *   for (int x = 0; x < 10; x++) {
   *     A[0] = (A[0]) + 1;
   *   }
   * }
   * if (x>5 ? 1 : 0) {
   *   for (int x = 0; x < 10; x++) {
   *     A[0] = (A[0]) + 1;
   *   }
   * }
   ','line_number':3165,'multiline':True]
['text':'
   * if (x<5 ? 1 : 0) {
   *   int A_1 = A[0];
   *   for (int x = 0; x < 10; x++) {
   *     A_1 = A_1 + 1;
   *   }
   *   A[0] = A_1;
   * }
   * if (x>5 ? 1 : 0) {
   *   int A_2 = A[0];
   *   for (int x = 0; x < 10; x++) {
   *     A_2 = A_2 + 1;
   *   }
   *   A[0] = A_2;
   * }
   ','line_number':3180,'multiline':True]
['text':' Accesses are registerized inside two conditions, cut in the middle.','line_number':3220,'multiline':False]
['text':'
   * if (x<5 ? 1 : 0) {
   *   for (int x = 0; x < 10; x++) {
   *     A[0] = (A[0]) + 1;
   *   }
   * }
   * for (int x = 0; x < 10; x++) {
   *   A[x] = 1;
   * }
   * if (x>5 ? 1 : 0) {
   *   for (int x = 0; x < 10; x++) {
   *     A[0] = (A[0]) + 1;
   *   }
   * }
   ','line_number':3237,'multiline':True]
['text':'
   * if (x<5 ? 1 : 0) {
   *   int A_1 = A[0];
   *   for (int x = 0; x < 10; x++) {
   *     A_1 = A_1 + 1;
   *   }
   *   A[0] = A_1;
   * }
   * for (int x = 0; x < 10; x++) {
   *   A[x] = 1;
   * }
   * if (x>5 ? 1 : 0) {
   *   int A_2 = A[0];
   *   for (int x = 0; x < 10; x++) {
   *     A_2 = A_2 + 1;
   *   }
   *   A[0] = A_2;
   * }
   ','line_number':3255,'multiline':True]
['text':' references a Let var in a local scope which cannot be hoisted out of the','line_number':3300,'multiline':False]
['text':' loop.','line_number':3301,'multiline':False]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   int y = 30;
   *   A[y] = x + (A[y]);
   * }
   ','line_number':3314,'multiline':True]
['text':' No change.','line_number':3324,'multiline':False]
['text':' references a Let var in an outer scope that does not prevent hoisting the','line_number':3333,'multiline':False]
['text':' initializer.','line_number':3334,'multiline':False]
['text':'
   * int y = 30;
   * for (int x = 0; x < 10; x++) {
   *   A[y] = x + (A[y]);
   * }
   ','line_number':3348,'multiline':True]
['text':'
   * int y = 30;
   * int A_1 = A[y];
   * for (int x = 0; x < 10; x++) {
   *   A_1 = A_1 + x;
   * }
   * A[y] = A_1;
   ','line_number':3357,'multiline':True]
['text':' Okay so the registerizer generally goes after index flattening, but just in','line_number':3380,'multiline':False]
['text':' case. Test multi index registerization.','line_number':3381,'multiline':False]
['text':'
   * A[0, 1, 2] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[0, 1, 2] = (A[0, 1, 2]) + x;
   * }
   ','line_number':3394,'multiline':True]
['text':'
   * int A_1 = 0;
   * for (int x = 0; x < 10; x++) {
   *   A_1 = x + A_1;
   * }
   * A[0, 1, 2] = A_1;
   ','line_number':3403,'multiline':True]
['text':' Wont registerize if only some dims match, but will still registerize distinct','line_number':3425,'multiline':False]
['text':' elements.','line_number':3426,'multiline':False]
['text':'
   * A[0, 1, 2] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[0, 2, 2] = (A[0, 1, 4]) + x;
   * }
   ','line_number':3439,'multiline':True]
['text':'
   * A[0, 1, 2] = 0;
   * int A_1 = A[0, 1, 4];
   * int A_2 = A[0, 2, 2];
   * for (int x = 0; x < 10; x++) {
   *   A_2 = A_1 + x;
   * }
   * A[0, 2, 2] = A_2;
   ','line_number':3448,'multiline':True]
['text':' If they could overlap across all dimensions we cannot registerize.','line_number':3473,'multiline':False]
['text':'
   * A[0, 1, 2] = 0;
   * for (int x = 0; x < 10; x++) {
   *   A[0, x, 2] = (A[y, 2, 2]) + x;
   * }
   ','line_number':3488,'multiline':True]
['text':' No change.','line_number':3498,'multiline':False]
['text':' But, if one dimension is known to be distinct they do not overlap.','line_number':3507,'multiline':False]
['text':'
   * A[0, 1, 2] = 0;                          <---- 2nd dim overlaps with store.
   * for (int x = 0; x < 10; x++) {
   *   A[0, x, 2] = (A[y, 2, 4]) + x;           <---- 3rd dim has constant diff.
   * }
   ','line_number':3521,'multiline':True]
['text':'
   * A[0, 1, 2] = 0;
   * int A_1 = A[y, 2, 4];
   * for (int x = 0; x < 10; x++) {
   *   A[0, x, 2] = A_1 + x;
   * }
   ','line_number':3530,'multiline':True]
['text':' A 3D reduction with different input dimensionality.','line_number':3552,'multiline':False]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   for (int y = 0; y < 10; y++) {
   *     for (int z = 0; z < 10; z++) {
   *       C[x, y, z] = (C[x, y, z]) + (B[x, y]) * (A[x]);
   *     }
   *   }
   * }
   ','line_number':3579,'multiline':True]
['text':' We can registerize the A and B access since they can be hoisted before','line_number':3589,'multiline':False]
['text':' hitting a dependent loop var.','line_number':3590,'multiline':False]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   int A_1 = A[x];
   *   for (int y = 0; y < 10; y++) {
   *     int B_1 = B[x, y];
   *     for (int z = 0; z < 10; z++) {
   *       C[x, y, z] = A_1 * B_1 + (C[x, y, z]);
   *     }
   *   }
   * }
   ','line_number':3594,'multiline':True]
['text':' A 3D reduction with the same smaller dimensionality using different loop','line_number':3622,'multiline':False]
['text':' vars.','line_number':3623,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':3635,'multiline':False]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   for (int y = 0; y < 10; y++) {
   *     for (int z = 0; z < 10; z++) {
   *       C[x] = (C[x]) + (B[y]) * (A[x]);
   *     }
   *   }
   * }
   ','line_number':3651,'multiline':True]
['text':' We can registerize all accesses, the A and C access can be hoisted to the','line_number':3661,'multiline':False]
['text':' outer loop since they depend only on it's loop var while the B can only be','line_number':3662,'multiline':False]
['text':' raised to the loop of y.','line_number':3663,'multiline':False]
['text':'
   * for (int x = 0; x < 10; x++) {
   *   int A_1 = A[x];
   *   int C_1 = C[x];
   *   for (int y = 0; y < 10; y++) {
   *     int B_1 = B[y];
   *     for (int z = 0; z < 10; z++) {
   *       C_1 = A_1 * B_1 + C_1;
   *     }
   *   }
   *   C[x] = C_1;
   * }
   ','line_number':3667,'multiline':True]
['text':' namespace jit','line_number':3701,'multiline':False]
['text':' namespace torch','line_number':3702,'multiline':False]
