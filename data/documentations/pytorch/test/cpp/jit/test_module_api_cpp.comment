['text':'version=','line_number':44,'multiline':True]
['text':' Module m("m");','line_number':49,'multiline':False]
['text':' m.define(R"(','line_number':50,'multiline':False]
['text':'   def forward(self):','line_number':51,'multiline':False]
['text':'     r1 = torch.jit.fork(torch.mm, torch.rand(100,100),torch.rand(100,100))','line_number':52,'multiline':False]
['text':'     r2 = torch.jit.fork(torch.mm, torch.rand(100,100),torch.rand(100,100))','line_number':53,'multiline':False]
['text':'     return r1.wait() + r2.wait()','line_number':54,'multiline':False]
['text':' )");','line_number':55,'multiline':False]
['text':' borrow model file from TEST(GraphExecutorTest, runAsync_executor)','line_number':58,'multiline':False]
['text':' expect 2 forks and 2 wait callbacks being executed on provided taskLauncher','line_number':80,'multiline':False]
['text':' but ivalue::Future would be marked completed and release wait before','line_number':81,'multiline':False]
['text':' finishing all callbacks','line_number':82,'multiline':False]
['text':' creating child module','line_number':88,'multiline':False]
['text':' attach two child module instance to parent that shares','line_number':99,'multiline':False]
['text':' ClassType','line_number':100,'multiline':False]
['text':' clone parent','line_number':106,'multiline':False]
['text':' check the two child module has the same ClassType','line_number':108,'multiline':False]
['text':' but different instances','line_number':110,'multiline':False]
['text':' define a initial module with two submods share same interface','line_number':118,'multiline':False]
['text':' clone will copy both type and data, therefore we'll have a','line_number':154,'multiline':False]
['text':' different type','line_number':155,'multiline':False]
['text':' Make sure copy works','line_number':171,'multiline':False]
['text':' clone will copy both type and data, therefore we'll have a','line_number':175,'multiline':False]
['text':' different type','line_number':176,'multiline':False]
['text':' copy only copies data, type is shared','line_number':178,'multiline':False]
['text':' change value of copied instance','line_number':181,'multiline':False]
['text':' Verify value of original instance doesn't change','line_number':183,'multiline':False]
['text':' Make sure copy works','line_number':208,'multiline':False]
['text':' Test overlaps','line_number':212,'multiline':False]
['text':' Both deepcopy and copy will preserve the type','line_number':216,'multiline':False]
['text':' change int value of copied instances','line_number':220,'multiline':False]
['text':' Verify value of original instance doesn't change','line_number':224,'multiline':False]
['text':' change Tensor value of copied instances','line_number':229,'multiline':False]
['text':' deepcopy will copy the Tensor','line_number':232,'multiline':False]
['text':' copy will not copy the Tensor','line_number':234,'multiline':False]
['text':' check copy works','line_number':235,'multiline':False]
['text':' zero out t1','line_number':239,'multiline':False]
['text':' check that t2 is not affected because it is a deep copy','line_number':241,'multiline':False]
['text':' check that t3 is the same as t1 since it is a shallow copy','line_number':243,'multiline':False]
['text':' check string mutation is not reflected in the copied module','line_number':258,'multiline':False]
['text':' Make sure deepcopy works','line_number':280,'multiline':False]
['text':' Test overlaps','line_number':286,'multiline':False]
['text':' Deepcopy will preserve the type','line_number':289,'multiline':False]
['text':' Change original, should not affect deepcopy','line_number':292,'multiline':False]
['text':' check deepcopy preserves aliasing','line_number':303,'multiline':False]
['text':' first element of attr1 and attr2 are aliased','line_number':321,'multiline':False]
['text':' test tensor aliasing','line_number':328,'multiline':False]
['text':' test aliasing from view','line_number':333,'multiline':False]
['text':' Tensor parameter','line_number':359,'multiline':False]
['text':' is_buffer ','line_number':361,'multiline':True]
['text':' None parameter','line_number':362,'multiline':False]
['text':' is_param ','line_number':364,'multiline':True]
['text':' is_param ','line_number':366,'multiline':True]
['text':' Removal of GetAttr is done by freezing','line_number':396,'multiline':False]
['text':' If no training mode is set, the module is NOT frozen by OFI','line_number':401,'multiline':False]
['text':' Before freezing, we have a GetAttr check','line_number':417,'multiline':False]
['text':' Demonstrate that freezing happens when OFI is called','line_number':421,'multiline':False]
['text':' Removal of GetAttr is done by freezing, but only when training','line_number':422,'multiline':False]
['text':' attribute is set','line_number':423,'multiline':False]
['text':' OFI is called without the presence of forward methods','line_number':438,'multiline':False]
['text':' test cuda to cpu for params and buffers','line_number':449,'multiline':False]
['text':' test cpu to cuda for params and buffers','line_number':459,'multiline':False]
['text':' namespace jit','line_number':469,'multiline':False]
['text':' namespace torch','line_number':470,'multiline':False]
