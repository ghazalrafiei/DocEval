['text':' Does not delete anything','line_number':12,'multiline':False]
['text':' A detail::UniqueVoidPtr is an owning smart pointer like unique_ptr, but','line_number':15,'multiline':False]
['text':' with three major differences:','line_number':16,'multiline':False]
['text':'','line_number':17,'multiline':False]
['text':'    1) It is specialized to void','line_number':18,'multiline':False]
['text':'','line_number':19,'multiline':False]
['text':'    2) It is specialized for a function pointer deleter','line_number':20,'multiline':False]
['text':'       void(void* ctx); i.e., the deleter doesn't take a','line_number':21,'multiline':False]
['text':'       reference to the data, just to a context pointer','line_number':22,'multiline':False]
['text':'       (erased as void*).  In fact, internally, this pointer','line_number':23,'multiline':False]
['text':'       is implemented as having an owning reference to','line_number':24,'multiline':False]
['text':'       context, and a non-owning reference to data; this is why','line_number':25,'multiline':False]
['text':'       you release_context(), not release() (the conventional','line_number':26,'multiline':False]
['text':'       API for release() wouldn't give you enough information','line_number':27,'multiline':False]
['text':'       to properly dispose of the object later.)','line_number':28,'multiline':False]
['text':'','line_number':29,'multiline':False]
['text':'    3) The deleter is guaranteed to be called when the unique','line_number':30,'multiline':False]
['text':'       pointer is destructed and the context is non-null; this is different','line_number':31,'multiline':False]
['text':'       from std::unique_ptr where the deleter is not called if the','line_number':32,'multiline':False]
['text':'       data pointer is null.','line_number':33,'multiline':False]
['text':'','line_number':34,'multiline':False]
['text':' Some of the methods have slightly different types than std::unique_ptr','line_number':35,'multiline':False]
['text':' to reflect this.','line_number':36,'multiline':False]
['text':'','line_number':37,'multiline':False]
['text':' Lifetime tied to ctx_','line_number':40,'multiline':False]
['text':' Note [How UniqueVoidPtr is implemented]','line_number':92,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':93,'multiline':False]
['text':' UniqueVoidPtr solves a common problem for allocators of tensor data, which','line_number':94,'multiline':False]
['text':' is that the data pointer (e.g., float*) which you are interested in, is not','line_number':95,'multiline':False]
['text':' the same as the context pointer (e.g., DLManagedTensor) which you need','line_number':96,'multiline':False]
['text':' to actually deallocate the data.  Under a conventional deleter design, you','line_number':97,'multiline':False]
['text':' have to store extra context in the deleter itself so that you can actually','line_number':98,'multiline':False]
['text':' delete the right thing.  Implementing this with standard C++ is somewhat','line_number':99,'multiline':False]
['text':' error-prone: if you use a std::unique_ptr to manage tensors, the deleter will','line_number':100,'multiline':False]
['text':' not be called if the data pointer is nullptr, which can cause a leak if the','line_number':101,'multiline':False]
['text':' context pointer is non-null (and the deleter is responsible for freeing both','line_number':102,'multiline':False]
['text':' the data pointer and the context pointer).','line_number':103,'multiline':False]
['text':'','line_number':104,'multiline':False]
['text':' So, in our reimplementation of unique_ptr, which just store the context','line_number':105,'multiline':False]
['text':' directly in the unique pointer, and attach the deleter to the context','line_number':106,'multiline':False]
['text':' pointer itself.  In simple cases, the context pointer is just the pointer','line_number':107,'multiline':False]
['text':' itself.','line_number':108,'multiline':False]
['text':' namespace detail','line_number':123,'multiline':False]
['text':' namespace c10','line_number':124,'multiline':False]
