['text':'===- llvm/ADT/SmallVector.h - 'Normally small' vectors --------*- C++ -*-===//','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.','line_number':3,'multiline':False]
['text':' See https://llvm.org/LICENSE.txt for license information.','line_number':4,'multiline':False]
['text':' SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':'===----------------------------------------------------------------------===//','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':' This file defines the SmallVector class.','line_number':9,'multiline':False]
['text':'','line_number':10,'multiline':False]
['text':'===----------------------------------------------------------------------===//','line_number':11,'multiline':False]
['text':' ATen: modified from llvm::SmallVector.','line_number':13,'multiline':False]
['text':' used std::is_trivially_{copy,move}_constructible','line_number':14,'multiline':False]
['text':' replaced iterator_range constructor with inline Container&& constructor','line_number':15,'multiline':False]
['text':' replaced LLVM_NODISCARD, LLVM_LIKELY, and LLVM_UNLIKELY with c10 equivalents','line_number':16,'multiline':False]
['text':' removed LLVM_GSL_OWNER','line_number':17,'multiline':False]
['text':' added SmallVector::at','line_number':18,'multiline':False]
['text':' added operator<< for std::ostream','line_number':19,'multiline':False]
['text':' added C10_API to export SmallVectorBase','line_number':20,'multiline':False]
['text':'/ This is all the stuff common to all SmallVectors.','line_number':49,'multiline':False]
['text':'/','line_number':50,'multiline':False]
['text':'/ The template parameter specifies the type which should be used to hold the','line_number':51,'multiline':False]
['text':'/ Size and Capacity of the SmallVector, so it can be adjusted.','line_number':52,'multiline':False]
['text':'/ Using 32 bit size is desirable to shrink the size of the SmallVector.','line_number':53,'multiline':False]
['text':'/ Using 64 bit size is desirable for cases like SmallVector<char>, where a','line_number':54,'multiline':False]
['text':'/ 32 bit size would limit the vector to ~4GB. SmallVectors are used for','line_number':55,'multiline':False]
['text':'/ buffering bitcode output - which can exceed 4GB.','line_number':56,'multiline':False]
['text':'/ The maximum value of the Size_T used.','line_number':63,'multiline':False]
['text':'/ This is a helper for \a grow() that's out of line to reduce code','line_number':71,'multiline':False]
['text':'/ duplication.  This function will report a fatal error if it can't grow at','line_number':72,'multiline':False]
['text':'/ least to \p MinSize.','line_number':73,'multiline':False]
['text':'/ This is an implementation of the grow() method which only works','line_number':76,'multiline':False]
['text':'/ on POD-like data types and is out of line to reduce code duplication.','line_number':77,'multiline':False]
['text':'/ This function will report a fatal error if it cannot increase capacity.','line_number':78,'multiline':False]
['text':'/ Set the array size to \p N, which the current array must have enough','line_number':94,'multiline':False]
['text':'/ capacity for.','line_number':95,'multiline':False]
['text':'/','line_number':96,'multiline':False]
['text':'/ This does not construct or destroy any elements in the vector.','line_number':97,'multiline':False]
['text':'/','line_number':98,'multiline':False]
['text':'/ Clients can use this in conjunction with capacity() to write past the end','line_number':99,'multiline':False]
['text':'/ of the buffer when they know that more elements are available, and only','line_number':100,'multiline':False]
['text':'/ update the size later. This avoids the cost of value initializing elements','line_number':101,'multiline':False]
['text':'/ which will only be overwritten.','line_number':102,'multiline':False]
['text':'/ Figure out the offset of the first element.','line_number':113,'multiline':False]
['text':'/ This is the part of SmallVectorTemplateBase which does not depend on whether','line_number':121,'multiline':False]
['text':'/ the type T is a POD. The extra dummy template argument is used by ArrayRef','line_number':122,'multiline':False]
['text':'/ to avoid unnecessarily requiring T to be complete.','line_number':123,'multiline':False]
['text':'/ Find the address of the first element.  For this pointer math to be valid','line_number':129,'multiline':False]
['text':'/ with small-size of 0 for T with lots of alignment, it's important that','line_number':130,'multiline':False]
['text':'/ SmallVectorStorage is properly-aligned even for small-size of 0.','line_number':131,'multiline':False]
['text':' Space after 'FirstEl' is clobbered, do not add any instance vars after it.','line_number':137,'multiline':False]
['text':'/ Return true if this is a smallvector which has not had dynamic','line_number':146,'multiline':False]
['text':'/ memory allocated for it.','line_number':147,'multiline':False]
['text':'/ Put this vector in a state of being small.','line_number':152,'multiline':False]
['text':' FIXME: Setting Capacity to 0 is suspect.','line_number':155,'multiline':False]
['text':'/ Return true if V is an internal reference to the given range.','line_number':158,'multiline':False]
['text':' Use std::less to avoid UB.','line_number':161,'multiline':False]
['text':'/ Return true if V is an internal reference to this vector.','line_number':166,'multiline':False]
['text':'/ Return true if First and Last form a valid (possibly empty) range in this','line_number':171,'multiline':False]
['text':'/ vector's storage.','line_number':172,'multiline':False]
['text':' Use std::less to avoid UB.','line_number':174,'multiline':False]
['text':'/ Return true unless Elt will be invalidated by resizing the vector to','line_number':180,'multiline':False]
['text':'/ NewSize.','line_number':181,'multiline':False]
['text':' Past the end.','line_number':183,'multiline':False]
['text':' Return false if Elt will be destroyed by shrinking.','line_number':187,'multiline':False]
['text':' Return false if we need to grow.','line_number':191,'multiline':False]
['text':'/ Check whether Elt will be invalidated by resizing the vector to NewSize.','line_number':195,'multiline':False]
['text':' Suppress unused variable warning','line_number':197,'multiline':False]
['text':' Suppress unused variable warning','line_number':198,'multiline':False]
['text':'/ Check whether Elt will be invalidated by increasing the size of the','line_number':205,'multiline':False]
['text':'/ vector by N.','line_number':206,'multiline':False]
['text':'/ Check whether any part of the range will be invalidated by clearing.','line_number':211,'multiline':False]
['text':'/ Check whether any part of the range will be invalidated by growing.','line_number':225,'multiline':False]
['text':'/ Reserve enough space to add one element, and return the updated element','line_number':239,'multiline':False]
['text':'/ pointer in case it was a reference to the storage.','line_number':240,'multiline':False]
['text':' forward iterator creation methods.','line_number':281,'multiline':False]
['text':' reverse iterator creation methods.','line_number':295,'multiline':False]
['text':'/ Return a pointer to the vector's buffer, even if empty().','line_number':320,'multiline':False]
['text':'/ Return a pointer to the vector's buffer, even if empty().','line_number':324,'multiline':False]
['text':' SmallVector::at is NOT from LLVM.','line_number':329,'multiline':False]
['text':'/ SmallVectorTemplateBase<TriviallyCopyable = false> - This is where we put','line_number':366,'multiline':False]
['text':'/ method implementations that are designed to work with non-trivial T's.','line_number':367,'multiline':False]
['text':'/','line_number':368,'multiline':False]
['text':'/ We approximate is_trivially_copyable with trivial move/copy construction and','line_number':369,'multiline':False]
['text':'/ trivial destruction. While the standard doesn't specify that you're allowed','line_number':370,'multiline':False]
['text':'/ copy these types with memcpy, there is no way for the type to observe this.','line_number':371,'multiline':False]
['text':'/ This catches the important case of std::pair<POD, POD>, which is not','line_number':372,'multiline':False]
['text':'/ trivially assignable.','line_number':373,'multiline':False]
['text':'/','line_number':374,'multiline':False]
['text':'/ XXX: if build fails here fall back to C10_IS_TRIVIALLY_COPYABLE and make a','line_number':375,'multiline':False]
['text':'/ note','line_number':376,'multiline':False]
['text':'/ Move the range [I, E) into the uninitialized memory starting with "Dest",','line_number':398,'multiline':False]
['text':'/ constructing elements as needed.','line_number':399,'multiline':False]
['text':'/ Copy the range [I, E) onto the uninitialized memory starting with "Dest",','line_number':406,'multiline':False]
['text':'/ constructing elements as needed.','line_number':407,'multiline':False]
['text':'/ Grow the allocated memory (without initializing new elements), doubling','line_number':413,'multiline':False]
['text':'/ the size of the allocated memory. Guarantees space for at least one more','line_number':414,'multiline':False]
['text':'/ element, or MinSize more elements if specified.','line_number':415,'multiline':False]
['text':'/ Create a new allocation big enough for \p MinSize and pass back its size','line_number':418,'multiline':False]
['text':'/ in \p NewCapacity. This is the first section of \a grow().','line_number':419,'multiline':False]
['text':'/ Move existing elements over to the new allocation \p NewElts, the middle','line_number':426,'multiline':False]
['text':'/ section of \a grow().','line_number':427,'multiline':False]
['text':'/ Transfer ownership of the allocation, finishing up \a grow().','line_number':430,'multiline':False]
['text':'/ Reserve enough space to add one element, and return the updated element','line_number':433,'multiline':False]
['text':'/ pointer in case it was a reference to the storage.','line_number':434,'multiline':False]
['text':'/ Reserve enough space to add one element, and return the updated element','line_number':439,'multiline':False]
['text':'/ pointer in case it was a reference to the storage.','line_number':440,'multiline':False]
['text':' Grow manually in case Elt is an internal reference.','line_number':453,'multiline':False]
['text':' Grow manually in case one of Args is an internal reference.','line_number':464,'multiline':False]
['text':' Define this out-of-line to dissuade the C++ compiler from inlining it.','line_number':493,'multiline':False]
['text':' Define this out-of-line to dissuade the C++ compiler from inlining it.','line_number':502,'multiline':False]
['text':' Move the elements over.','line_number':506,'multiline':False]
['text':' Destroy the original elements.','line_number':509,'multiline':False]
['text':' Define this out-of-line to dissuade the C++ compiler from inlining it.','line_number':513,'multiline':False]
['text':' If this wasn't grown from the inline copy, deallocate the old space.','line_number':518,'multiline':False]
['text':'/ SmallVectorTemplateBase<TriviallyCopyable = true> - This is where we put','line_number':526,'multiline':False]
['text':'/ method implementations that are designed to work with trivially copyable','line_number':527,'multiline':False]
['text':'/ T's. This allows using memcpy in place of copy/move construction and','line_number':528,'multiline':False]
['text':'/ skipping destruction.','line_number':529,'multiline':False]
['text':'/ True if it's cheap enough to take parameters by value. Doing so avoids','line_number':535,'multiline':False]
['text':'/ overhead related to mitigations for reference invalidation.','line_number':536,'multiline':False]
['text':'/ Either const T& or T, depending on whether it's cheap enough to take','line_number':539,'multiline':False]
['text':'/ parameters by value.','line_number':540,'multiline':False]
['text':' No need to do a destroy loop for POD's.','line_number':546,'multiline':False]
['text':'/ Move the range [I, E) onto the uninitialized memory','line_number':549,'multiline':False]
['text':'/ starting with "Dest", constructing elements into it as needed.','line_number':550,'multiline':False]
['text':' Just do a copy.','line_number':553,'multiline':False]
['text':'/ Copy the range [I, E) onto the uninitialized memory','line_number':557,'multiline':False]
['text':'/ starting with "Dest", constructing elements into it as needed.','line_number':558,'multiline':False]
['text':' Arbitrary iterator types; just use the basic implementation.','line_number':561,'multiline':False]
['text':'/ Copy the range [I, E) onto the uninitialized memory','line_number':565,'multiline':False]
['text':'/ starting with "Dest", constructing elements into it as needed.','line_number':566,'multiline':False]
['text':' Use memcpy for PODs iterated by pointers (which includes SmallVector','line_number':575,'multiline':False]
['text':' iterators): std::uninitialized_copy optimizes to memmove, but we can','line_number':576,'multiline':False]
['text':' use memcpy here. Note that I and E are iterators and thus might be','line_number':577,'multiline':False]
['text':' invalid for memcpy if they are equal.','line_number':578,'multiline':False]
['text':'/ Double the size of the allocated memory, guaranteeing space for at','line_number':583,'multiline':False]
['text':'/ least one more element or MinSize if specified.','line_number':584,'multiline':False]
['text':'/ Reserve enough space to add one element, and return the updated element','line_number':589,'multiline':False]
['text':'/ pointer in case it was a reference to the storage.','line_number':590,'multiline':False]
['text':'/ Reserve enough space to add one element, and return the updated element','line_number':595,'multiline':False]
['text':'/ pointer in case it was a reference to the storage.','line_number':596,'multiline':False]
['text':'/ Copy \p V or return a reference, depending on \a ValueParamT.','line_number':601,'multiline':False]
['text':' Elt has been copied in case it's an internal reference, side-stepping','line_number':607,'multiline':False]
['text':' reference invalidation problems without losing the realloc optimization.','line_number':608,'multiline':False]
['text':' Use push_back with a copy in case Args has an internal reference,','line_number':617,'multiline':False]
['text':' side-stepping reference invalidation problems without losing the realloc','line_number':618,'multiline':False]
['text':' optimization.','line_number':619,'multiline':False]
['text':'/ This class consists of common code factored out of the SmallVector class to','line_number':636,'multiline':False]
['text':'/ reduce code duplication based on the SmallVector 'N' template parameter.','line_number':637,'multiline':False]
['text':' Default ctor - Initialize to empty.','line_number':652,'multiline':False]
['text':' Subclass has already destructed this vector's elements.','line_number':659,'multiline':False]
['text':' If this wasn't grown from the inline copy, deallocate the old space.','line_number':660,'multiline':False]
['text':'/ Like resize, but \ref T is POD, the new values won't be initialized.','line_number':691,'multiline':False]
['text':' N > this->size(). Defer to append.','line_number':705,'multiline':False]
['text':'/ Add the specified range to the end of the SmallVector.','line_number':728,'multiline':False]
['text':'/ Append \p NumInputs copies of \p Elt to the end.','line_number':742,'multiline':False]
['text':' Note that Elt could be an internal reference.','line_number':758,'multiline':False]
['text':' Assign over existing elements.','line_number':764,'multiline':False]
['text':' FIXME: Consider assigning over existing elements, rather than clearing &','line_number':773,'multiline':False]
['text':' re-initializing them - for all assign(...) variants.','line_number':774,'multiline':False]
['text':' Just cast away constness because this is a non-const member function.','line_number':797,'multiline':False]
['text':' Shift all elts down one.','line_number':805,'multiline':False]
['text':' Drop the last elt.','line_number':807,'multiline':False]
['text':' Just cast away constness because this is a non-const member function.','line_number':813,'multiline':False]
['text':' Shift all elts down.','line_number':820,'multiline':False]
['text':' Drop the last elts.','line_number':822,'multiline':False]
['text':' Callers ensure that ArgType is derived from T.','line_number':831,'multiline':False]
['text':' Important special case for empty vector.','line_number':837,'multiline':False]
['text':' Grow if necessary.','line_number':846,'multiline':False]
['text':' Push everything else over.','line_number':853,'multiline':False]
['text':' If we just moved the element we're inserting, be sure to update','line_number':857,'multiline':False]
['text':' the reference (never happens if TakesParamByValue).','line_number':858,'multiline':False]
['text':' Convert iterator to elt# to avoid invalidating iterator when we reserve()','line_number':879,'multiline':False]
['text':' Important special case for empty vector.','line_number':882,'multiline':False]
['text':' Ensure there is enough space, and get the (maybe updated) address of','line_number':891,'multiline':False]
['text':' Elt.','line_number':892,'multiline':False]
['text':' Uninvalidate the iterator.','line_number':895,'multiline':False]
['text':' If there are more elements between the insertion point and the end of the','line_number':898,'multiline':False]
['text':' range than there are being inserted, we can use a simple approach to','line_number':899,'multiline':False]
['text':' insertion.  Since we already reserved space, we know that this won't','line_number':900,'multiline':False]
['text':' reallocate the vector.','line_number':901,'multiline':False]
['text':' Copy the existing elements that get replaced.','line_number':908,'multiline':False]
['text':' If we just moved the element we're inserting, be sure to update','line_number':911,'multiline':False]
['text':' the reference (never happens if TakesParamByValue).','line_number':912,'multiline':False]
['text':' Otherwise, we're inserting more elements than exist already, and we're','line_number':920,'multiline':False]
['text':' not inserting at the end.','line_number':921,'multiline':False]
['text':' Move over the elements that we're about to overwrite.','line_number':923,'multiline':False]
['text':' If we just moved the element we're inserting, be sure to update','line_number':929,'multiline':False]
['text':' the reference (never happens if TakesParamByValue).','line_number':930,'multiline':False]
['text':' Replace the overwritten part.','line_number':934,'multiline':False]
['text':' Insert the non-overwritten middle part.','line_number':937,'multiline':False]
['text':' Convert iterator to elt# to avoid invalidating iterator when we reserve()','line_number':948,'multiline':False]
['text':' Important special case for empty vector.','line_number':951,'multiline':False]
['text':' Check that the reserve that follows doesn't invalidate the iterators.','line_number':960,'multiline':False]
['text':' Ensure there is enough space.','line_number':965,'multiline':False]
['text':' Uninvalidate the iterator.','line_number':968,'multiline':False]
['text':' If there are more elements between the insertion point and the end of the','line_number':971,'multiline':False]
['text':' range than there are being inserted, we can use a simple approach to','line_number':972,'multiline':False]
['text':' insertion.  Since we already reserved space, we know that this won't','line_number':973,'multiline':False]
['text':' reallocate the vector.','line_number':974,'multiline':False]
['text':' Copy the existing elements that get replaced.','line_number':981,'multiline':False]
['text':' Otherwise, we're inserting more elements than exist already, and we're','line_number':988,'multiline':False]
['text':' not inserting at the end.','line_number':989,'multiline':False]
['text':' Move over the elements that we're about to overwrite.','line_number':991,'multiline':False]
['text':' Replace the overwritten part.','line_number':997,'multiline':False]
['text':' Insert the non-overwritten middle part.','line_number':1004,'multiline':False]
['text':' We can only avoid copying elements if neither vector is small.','line_number':1049,'multiline':False]
['text':' Swap the shared elements.','line_number':1059,'multiline':False]
['text':' Copy over the extra elts.','line_number':1066,'multiline':False]
['text':' Avoid self-assignment.','line_number':1085,'multiline':False]
['text':' If we already have sufficient space, assign the common elements, then','line_number':1089,'multiline':False]
['text':' destroy any excess.','line_number':1090,'multiline':False]
['text':' Assign common elements.','line_number':1094,'multiline':False]
['text':' Destroy excess elements.','line_number':1101,'multiline':False]
['text':' Trim.','line_number':1104,'multiline':False]
['text':' If we have to grow to have enough elements, destroy the current elements.','line_number':1109,'multiline':False]
['text':' This allows us to avoid copying them during the grow.','line_number':1110,'multiline':False]
['text':' FIXME: don't do this if they're efficiently moveable.','line_number':1111,'multiline':False]
['text':' Destroy current elements.','line_number':1113,'multiline':False]
['text':' Otherwise, use assignment for the already-constructed elements.','line_number':1118,'multiline':False]
['text':' Copy construct the new elements in place.','line_number':1122,'multiline':False]
['text':' Set end.','line_number':1126,'multiline':False]
['text':' Avoid self-assignment.','line_number':1135,'multiline':False]
['text':' If the RHS isn't small, clear this vector and then steal its buffer.','line_number':1139,'multiline':False]
['text':' If we already have sufficient space, assign the common elements, then','line_number':1151,'multiline':False]
['text':' destroy any excess.','line_number':1152,'multiline':False]
['text':' Assign common elements.','line_number':1156,'multiline':False]
['text':' Destroy excess elements and trim the bounds.','line_number':1161,'multiline':False]
['text':' Clear the RHS.','line_number':1165,'multiline':False]
['text':' If we have to grow to have enough elements, destroy the current elements.','line_number':1171,'multiline':False]
['text':' This allows us to avoid copying them during the grow.','line_number':1172,'multiline':False]
['text':' FIXME: this may not actually make any sense if we can efficiently move','line_number':1173,'multiline':False]
['text':' elements.','line_number':1174,'multiline':False]
['text':' Destroy current elements.','line_number':1176,'multiline':False]
['text':' Otherwise, use assignment for the already-constructed elements.','line_number':1181,'multiline':False]
['text':' Move-construct the new elements in place.','line_number':1185,'multiline':False]
['text':' Set end.','line_number':1189,'multiline':False]
['text':'/ Storage for the SmallVector elements.  This is specialized for the N=0 case','line_number':1196,'multiline':False]
['text':'/ to avoid allocating unnecessary storage.','line_number':1197,'multiline':False]
['text':'/ We need the storage to be properly aligned even for small-size of 0 so that','line_number':1203,'multiline':False]
['text':'/ the pointer math in \a SmallVectorTemplateCommon::getFirstEl() is','line_number':1204,'multiline':False]
['text':'/ well-defined.','line_number':1205,'multiline':False]
['text':'/ Forward declaration of SmallVector so that','line_number':1209,'multiline':False]
['text':'/ calculateSmallVectorDefaultInlinedElements can reference','line_number':1210,'multiline':False]
['text':'/ `sizeof(SmallVector<T, 0>)`.','line_number':1211,'multiline':False]
['text':' LLVM_GSL_OWNER ','line_number':1213,'multiline':True]
['text':'/ Helper class for calculating the default number of inline elements for','line_number':1215,'multiline':False]
['text':'/ `SmallVector<T>`.','line_number':1216,'multiline':False]
['text':'/','line_number':1217,'multiline':False]
['text':'/ This should be migrated to a constexpr function when our minimum','line_number':1218,'multiline':False]
['text':'/ compiler support is enough for multi-statement constexpr functions.','line_number':1219,'multiline':False]
['text':' Parameter controlling the default number of inlined elements','line_number':1222,'multiline':False]
['text':' for `SmallVector<T>`.','line_number':1223,'multiline':False]
['text':'','line_number':1224,'multiline':False]
['text':' The default number of inlined elements ensures that','line_number':1225,'multiline':False]
['text':' 1. There is at least one inlined element.','line_number':1226,'multiline':False]
['text':' 2. `sizeof(SmallVector<T>) <= kPreferredSmallVectorSizeof` unless','line_number':1227,'multiline':False]
['text':' it contradicts 1.','line_number':1228,'multiline':False]
['text':' static_assert that sizeof(T) is not "too big".','line_number':1231,'multiline':False]
['text':'','line_number':1232,'multiline':False]
['text':' Because our policy guarantees at least one inlined element, it is possible','line_number':1233,'multiline':False]
['text':' for an arbitrarily large inlined element to allocate an arbitrarily large','line_number':1234,'multiline':False]
['text':' amount of inline storage. We generally consider it an antipattern for a','line_number':1235,'multiline':False]
['text':' SmallVector to allocate an excessive amount of inline storage, so we want','line_number':1236,'multiline':False]
['text':' to call attention to these cases and make sure that users are making an','line_number':1237,'multiline':False]
['text':' intentional decision if they request a lot of inline storage.','line_number':1238,'multiline':False]
['text':'','line_number':1239,'multiline':False]
['text':' We want this assertion to trigger in pathological cases, but otherwise','line_number':1240,'multiline':False]
['text':' not be too easy to hit. To accomplish that, the cutoff is actually somewhat','line_number':1241,'multiline':False]
['text':' larger than kPreferredSmallVectorSizeof (otherwise,','line_number':1242,'multiline':False]
['text':' `SmallVector<SmallVector<T>>` would be one easy way to trip it, and that','line_number':1243,'multiline':False]
['text':' pattern seems useful in practice).','line_number':1244,'multiline':False]
['text':'','line_number':1245,'multiline':False]
['text':' One wrinkle is that this assertion is in theory non-portable, since','line_number':1246,'multiline':False]
['text':' sizeof(T) is in general platform-dependent. However, we don't expect this','line_number':1247,'multiline':False]
['text':' to be much of an issue, because most LLVM development happens on 64-bit','line_number':1248,'multiline':False]
['text':' hosts, and therefore sizeof(T) is expected to *decrease* when compiled for','line_number':1249,'multiline':False]
['text':' 32-bit hosts, dodging the issue. The reverse situation, where development','line_number':1250,'multiline':False]
['text':' happens on a 32-bit host and then fails due to sizeof(T) *increasing* on a','line_number':1251,'multiline':False]
['text':' 64-bit host, is expected to be very rare.','line_number':1252,'multiline':False]
['text':' Discount the size of the header itself when calculating the maximum inline','line_number':1260,'multiline':False]
['text':' bytes.','line_number':1261,'multiline':False]
['text':'/ This is a 'vector' (really, a variable-sized array), optimized','line_number':1269,'multiline':False]
['text':'/ for the case when the array is small.  It contains some number of elements','line_number':1270,'multiline':False]
['text':'/ in-place, which allows it to avoid heap allocation when the actual number of','line_number':1271,'multiline':False]
['text':'/ elements is below that threshold.  This allows normal "small" cases to be','line_number':1272,'multiline':False]
['text':'/ fast without losing generality for large inputs.','line_number':1273,'multiline':False]
['text':'/','line_number':1274,'multiline':False]
['text':'/ \note','line_number':1275,'multiline':False]
['text':'/ In the absence of a well-motivated choice for the number of inlined','line_number':1276,'multiline':False]
['text':'/ elements \p N, it is recommended to use \c SmallVector<T> (that is,','line_number':1277,'multiline':False]
['text':'/ omitting the \p N). This will choose a default number of inlined elements','line_number':1278,'multiline':False]
['text':'/ reasonable for allocation on the stack (for example, trying to keep \c','line_number':1279,'multiline':False]
['text':'/ sizeof(SmallVector<T>) around 64 bytes).','line_number':1280,'multiline':False]
['text':'/','line_number':1281,'multiline':False]
['text':'/ \warning This does not attempt to be exception safe.','line_number':1282,'multiline':False]
['text':'/','line_number':1283,'multiline':False]
['text':'/ \see https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h','line_number':1284,'multiline':False]
['text':' LLVM_GSL_OWNER ','line_number':1288,'multiline':True]
['text':' Destroy the constructed elements in the vector.','line_number':1294,'multiline':False]
['text':' note: The enable_if restricts Container to types that have a .begin() and','line_number':1312,'multiline':False]
['text':' .end() that return valid input iterators.','line_number':1313,'multiline':False]
['text':' note: The enable_if restricts Container to types that have a .begin() and','line_number':1353,'multiline':False]
['text':' .end() that return valid input iterators.','line_number':1354,'multiline':False]
['text':' note: The enable_if restricts Container to types that have a .begin() and','line_number':1393,'multiline':False]
['text':' .end() that return valid input iterators.','line_number':1394,'multiline':False]
['text':'/ Given a range of type R, iterate the entire range and return a','line_number':1443,'multiline':False]
['text':'/ SmallVector with elements of the vector.  This is useful, for example,','line_number':1444,'multiline':False]
['text':'/ when you want to iterate a range and then sort the results.','line_number':1445,'multiline':False]
['text':' end namespace c10','line_number':1459,'multiline':False]
['text':'/ Implement std::swap in terms of SmallVector swap.','line_number':1463,'multiline':False]
['text':'/ Implement std::swap in terms of SmallVector swap.','line_number':1469,'multiline':False]
['text':' end namespace std','line_number':1475,'multiline':False]
