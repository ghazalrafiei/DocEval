['text':' Taken from','line_number':1,'multiline':False]
['text':' https://github.com/skarupke/flat_hash_map/blob/2c4687431f978f02a3780e24b8b701d22aa32d9c/flat_hash_map.hpp','line_number':2,'multiline':False]
['text':' with fixes applied:','line_number':3,'multiline':False]
['text':' - https://github.com/skarupke/flat_hash_map/pull/25','line_number':4,'multiline':False]
['text':' - https://github.com/skarupke/flat_hash_map/pull/26','line_number':5,'multiline':False]
['text':' - replace size_t with uint64_t to fix it for 32bit','line_number':6,'multiline':False]
['text':' - add "GCC diagnostic" pragma to ignore -Wshadow','line_number':7,'multiline':False]
['text':' - make sherwood_v3_table::convertible_to_iterator public because GCC5 seems','line_number':8,'multiline':False]
['text':' to have issues with it otherwise','line_number':9,'multiline':False]
['text':' - fix compiler warnings in operator templated_iterator<const value_type>','line_number':10,'multiline':False]
['text':'          Copyright Malte Skarupke 2017.','line_number':12,'multiline':False]
['text':' Distributed under the Boost Software License, Version 1.0.','line_number':13,'multiline':False]
['text':'    (See http://www.boost.org/LICENSE_1_0.txt)','line_number':14,'multiline':False]
['text':' destructor was implicitly defined as deleted','line_number':36,'multiline':False]
['text':' Implementation taken from http://en.cppreference.com/w/cpp/types/void_t','line_number':220,'multiline':False]
['text':' (it takes CWG1558 into account and also works for older compilers)','line_number':221,'multiline':False]
['text':' the template automatically disables the operator when value_type is','line_number':492,'multiline':False]
['text':' already const, because that would cause a lot of compiler warnings','line_number':493,'multiline':False]
['text':' otherwise.','line_number':494,'multiline':False]
['text':' the return value is a type that can be converted to an iterator','line_number':658,'multiline':False]
['text':' the reason for doing this is that it's not free to find the','line_number':659,'multiline':False]
['text':' iterator pointing at the next element. if you care about the','line_number':660,'multiline':False]
['text':' next iterator, turn the return value into an iterator','line_number':661,'multiline':False]
['text':' namespace detailv3','line_number':911,'multiline':False]
['text':' prime numbers generated by the following method:','line_number':1479,'multiline':False]
['text':' 1. start with a prime p = 2','line_number':1480,'multiline':False]
['text':' 2. go to wolfram alpha and get p = NextPrime(2 * p)','line_number':1481,'multiline':False]
['text':' 3. repeat 2. until you overflow 64 bits','line_number':1482,'multiline':False]
['text':' you now have large gaps which you would hit if somebody called reserve()','line_number':1483,'multiline':False]
['text':' with an unlucky number.','line_number':1484,'multiline':False]
['text':' 4. to fill the gaps for every prime p go to wolfram alpha and get','line_number':1485,'multiline':False]
['text':' ClosestPrime(p * 2^(1/3)) and ClosestPrime(p * 2^(2/3)) and put those in','line_number':1486,'multiline':False]
['text':' the gaps','line_number':1487,'multiline':False]
['text':' 5. get PrevPrime(2^64) and put it at the end','line_number':1488,'multiline':False]
['text':'num_slots_minus_one','line_number':1876,'multiline':True]
['text':'num_slots_minus_one','line_number':1904,'multiline':True]
['text':' end namespace ska','line_number':2111,'multiline':False]
