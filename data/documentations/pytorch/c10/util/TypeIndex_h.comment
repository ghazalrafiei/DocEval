['text':' TODO Make it work for more compilers','line_number':13,'multiline':False]
['text':' Intel compiler works','line_number':15,'multiline':False]
['text':' Clang works','line_number':20,'multiline':False]
['text':' except for NVCC','line_number':23,'multiline':False]
['text':' Windows works','line_number':32,'multiline':False]
['text':' except for NVCC','line_number':35,'multiline':False]
['text':' GCC works','line_number':44,'multiline':False]
['text':' except when gcc < 9','line_number':47,'multiline':False]
['text':' some other compiler we don't know about','line_number':56,'multiline':False]
['text':' Allow usage in std::map / std::set','line_number':65,'multiline':False]
['text':' TODO Disallow this and rather use std::unordered_map/set everywhere','line_number':66,'multiline':False]
['text':' Getting __PRETTY_FUNCTION__ at compile time only works with GCC >= 5','line_number':80,'multiline':False]
['text':' Getting __PRETTY_FUNCTION__ at compile time only works with Clang >= 4','line_number':85,'multiline':False]
['text':' CUDA doesn't like std::logic_error in device code','line_number':93,'multiline':False]
['text':' Idea: __PRETTY_FUNCTION__ (or __FUNCSIG__ on msvc) contains a qualified name','line_number':136,'multiline':False]
['text':' of this function, including its template parameter, i.e. including the','line_number':137,'multiline':False]
['text':' type we want an id for. We use this name and run crc64 on it to get a type','line_number':138,'multiline':False]
['text':' id.','line_number':139,'multiline':False]
['text':' namespace detail','line_number':150,'multiline':False]
['text':' To enforce that this is really computed at compile time, we pass the','line_number':155,'multiline':False]
['text':' type index through std::integral_constant.','line_number':156,'multiline':False]
['text':' There's nothing in theory preventing us from running this on device code','line_number':161,'multiline':False]
['text':' except for nvcc throwing a compiler error if we enable it.','line_number':162,'multiline':False]
['text':' Use precomputed hashsum for std::string','line_number':168,'multiline':False]
['text':' Needed to workaround ambiguity in class name resolution','line_number':169,'multiline':False]
['text':' into __PRETTY_FUNCTION__ when abovementioned class is defined in inlined','line_number':170,'multiline':False]
['text':' namespace. In multi-ABI C++ library, `std::string` is an alias to','line_number':171,'multiline':False]
['text':' `std::__cxx11::basic_string<char>` which depending on compiler flags can be','line_number':172,'multiline':False]
['text':' resolved to `basic_string<char>` either in `std` namespace or in','line_number':173,'multiline':False]
['text':' `std::__cxx11` one (`__cxx11` is an inline namespace)','line_number':174,'multiline':False]
['text':' hashsum for std::basic_string<char>','line_number':177,'multiline':False]
['text':' namespace util','line_number':193,'multiline':False]
['text':' namespace c10','line_number':194,'multiline':False]
