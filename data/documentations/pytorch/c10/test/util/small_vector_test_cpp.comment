['text':'===- llvm/unittest/ADT/SmallVectorTest.cpp ------------------------------===//','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.','line_number':3,'multiline':False]
['text':' See https://llvm.org/LICENSE.txt for license information.','line_number':4,'multiline':False]
['text':' SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':'===----------------------------------------------------------------------===//','line_number':7,'multiline':False]
['text':'','line_number':8,'multiline':False]
['text':' SmallVector unit tests.','line_number':9,'multiline':False]
['text':'','line_number':10,'multiline':False]
['text':'===----------------------------------------------------------------------===//','line_number':11,'multiline':False]
['text':' NOLINTBEGIN(*arrays, bugprone-forwarding-reference-overload)','line_number':19,'multiline':False]
['text':'/ A helper class that counts the total number of constructor and','line_number':25,'multiline':False]
['text':'/ destructor calls.','line_number':26,'multiline':False]
['text':' Size tests','line_number':167,'multiline':False]
['text':' Iterator tests','line_number':171,'multiline':False]
['text':' Assert that v contains the specified values, in order.','line_number':175,'multiline':False]
['text':' Generate a sequence of values to initialize the vector.','line_number':190,'multiline':False]
['text':' Test fixture class','line_number':199,'multiline':False]
['text':' Constructor test.','line_number':216,'multiline':False]
['text':' Constructor test.','line_number':223,'multiline':False]
['text':' New vector test.','line_number':232,'multiline':False]
['text':' Simple insertions and deletions.','line_number':241,'multiline':False]
['text':' Track whether the vector will potentially have to grow.','line_number':245,'multiline':False]
['text':' Push an element','line_number':248,'multiline':False]
['text':' Size tests','line_number':251,'multiline':False]
['text':' Push another element','line_number':256,'multiline':False]
['text':' Insert at beginning. Reserve space to avoid reference invalidation from','line_number':260,'multiline':False]
['text':' this->theVector[1].','line_number':261,'multiline':False]
['text':' Pop one element','line_number':266,'multiline':False]
['text':' Pop remaining elements','line_number':270,'multiline':False]
['text':' Check number of constructor calls. Should be 2 for each list element,','line_number':274,'multiline':False]
['text':' one for the argument to push_back, one for the argument to insert,','line_number':275,'multiline':False]
['text':' and one for the list element itself.','line_number':276,'multiline':False]
['text':' If we had to grow the vector, these only have a lower bound, but should','line_number':281,'multiline':False]
['text':' always be equal.','line_number':282,'multiline':False]
['text':' Clear test.','line_number':290,'multiline':False]
['text':' Resize smaller test.','line_number':303,'multiline':False]
['text':' Resize bigger test.','line_number':316,'multiline':False]
['text':' Resize with fill value.','line_number':342,'multiline':False]
['text':' Heap allocated storage.','line_number':352,'multiline':False]
['text':' Inline storage.','line_number':363,'multiline':False]
['text':' Overflow past fixed size.','line_number':375,'multiline':False]
['text':' Push more elements than the fixed size.','line_number':379,'multiline':False]
['text':' Test size and values.','line_number':382,'multiline':False]
['text':' Now resize back to fixed size.','line_number':388,'multiline':False]
['text':' Iteration tests.','line_number':394,'multiline':False]
['text':' Forward Iteration','line_number':398,'multiline':False]
['text':' Reverse Iteration','line_number':416,'multiline':False]
['text':' Swap test.','line_number':433,'multiline':False]
['text':' Append test','line_number':444,'multiline':False]
['text':' Append repeated test','line_number':456,'multiline':False]
['text':' Append test','line_number':465,'multiline':False]
['text':' Assign test','line_number':505,'multiline':False]
['text':' Assign test','line_number':514,'multiline':False]
['text':' Assign test','line_number':524,'multiline':False]
['text':' Move-assign test','line_number':542,'multiline':False]
['text':' Set up our vector with a single element, but enough capacity for 4.','line_number':546,'multiline':False]
['text':' Set up the other vector with 2 elements.','line_number':550,'multiline':False]
['text':' Move-assign from the other vector.','line_number':554,'multiline':False]
['text':' Make sure we have the right result.','line_number':557,'multiline':False]
['text':' Make sure the # of constructor/destructor calls line up. There','line_number':560,'multiline':False]
['text':' are two live objects after clearing the other vector.','line_number':561,'multiline':False]
['text':' There shouldn't be any live objects any more.','line_number':567,'multiline':False]
['text':' Erase a single element','line_number':574,'multiline':False]
['text':' Erase a range of elements','line_number':584,'multiline':False]
['text':' Insert a single element.','line_number':594,'multiline':False]
['text':' Insert a copy of a single element.','line_number':605,'multiline':False]
['text':' Insert repeated elements.','line_number':617,'multiline':False]
['text':' Move construct the top element into newly allocated space, and optionally','line_number':625,'multiline':False]
['text':' reallocate the whole buffer, move constructing into it.','line_number':626,'multiline':False]
['text':' FIXME: This is inefficient, we shouldn't move things into newly allocated','line_number':627,'multiline':False]
['text':' space, then move them up/around, there should only be 2 or 4 move','line_number':628,'multiline':False]
['text':' constructions here.','line_number':629,'multiline':False]
['text':' Move assign the next two to shift them up and make a gap.','line_number':633,'multiline':False]
['text':' Copy construct the two new elements from the parameter.','line_number':635,'multiline':False]
['text':' All without any copy construction.','line_number':637,'multiline':False]
['text':' Just copy construct them into newly allocated space','line_number':659,'multiline':False]
['text':' Move everything across if reallocation is needed.','line_number':661,'multiline':False]
['text':' Without ever moving or copying anything else.','line_number':665,'multiline':False]
['text':' Empty insert.','line_number':678,'multiline':False]
['text':' Insert range.','line_number':688,'multiline':False]
['text':' Move construct the top 3 elements into newly allocated space.','line_number':698,'multiline':False]
['text':' Possibly move the whole sequence into new space first.','line_number':699,'multiline':False]
['text':' FIXME: This is inefficient, we shouldn't move things into newly allocated','line_number':700,'multiline':False]
['text':' space, then move them up/around, there should only be 2 or 3 move','line_number':701,'multiline':False]
['text':' constructions here.','line_number':702,'multiline':False]
['text':' Copy assign the lower 2 new elements into existing space.','line_number':706,'multiline':False]
['text':' Copy construct the third element into newly allocated space.','line_number':708,'multiline':False]
['text':' Insert at end.','line_number':722,'multiline':False]
['text':' Copy construct the 3 elements into new space at the top.','line_number':725,'multiline':False]
['text':' Don't copy/move anything else.','line_number':727,'multiline':False]
['text':' Reallocation might occur, causing all elements to be moved into the new','line_number':729,'multiline':False]
['text':' buffer.','line_number':730,'multiline':False]
['text':' Empty insert.','line_number':744,'multiline':False]
['text':' Comparison tests.','line_number':759,'multiline':False]
['text':' Constant vector tests.','line_number':776,'multiline':False]
['text':' Direct array access.','line_number':785,'multiline':False]
['text':' Small mode -> Small mode.','line_number':825,'multiline':False]
['text':' Small mode -> Big mode.','line_number':827,'multiline':False]
['text':' Big mode -> Small mode.','line_number':829,'multiline':False]
['text':' Big mode -> Big mode.','line_number':831,'multiline':False]
['text':' Set up our vector with four elements.','line_number':840,'multiline':False]
['text':' Move-assign from the other vector.','line_number':846,'multiline':False]
['text':' Make sure we have the right result.','line_number':850,'multiline':False]
['text':' Make sure the # of constructor/destructor calls line up. There','line_number':853,'multiline':False]
['text':' are two live objects after clearing the other vector.','line_number':854,'multiline':False]
['text':' If the source vector (otherVector) was in small-mode, assert that we just','line_number':860,'multiline':False]
['text':' moved the data pointer over.','line_number':861,'multiline':False]
['text':' There shouldn't be any live objects any more.','line_number':866,'multiline':False]
['text':' We shouldn't have copied anything in this whole process.','line_number':872,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)','line_number':877,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-use-after-move)','line_number':1040,'multiline':False]
['text':' Check that at least a couple layers of nested SmallVector<T>'s are allowed','line_number':1066,'multiline':False]
['text':' by the default inline elements policy. This pattern happens in practice','line_number':1067,'multiline':False]
['text':' with some frequency, and it seems fairly harmless even though each layer of','line_number':1068,'multiline':False]
['text':' SmallVector's will grow the total sizeof by a vector header beyond the','line_number':1069,'multiline':False]
['text':' "preferred" maximum sizeof.','line_number':1070,'multiline':False]
['text':' Fill up the small size so that insertions move the elements.','line_number':1116,'multiline':False]
['text':' Test one type that's trivially copyable (int) and one that isn't','line_number':1122,'multiline':False]
['text':' (Constructable) since reference invalidation may be fixed differently for','line_number':1123,'multiline':False]
['text':' each.','line_number':1124,'multiline':False]
['text':' Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.','line_number':1133,'multiline':False]
['text':' Push back a reference to last element when growing from small storage.','line_number':1137,'multiline':False]
['text':' Check that the old value is still there (not moved away).','line_number':1141,'multiline':False]
['text':' Fill storage again.','line_number':1144,'multiline':False]
['text':' Push back a reference to last element when growing from large storage.','line_number':1149,'multiline':False]
['text':' Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.','line_number':1155,'multiline':False]
['text':' Push back a reference to last element when growing from small storage.','line_number':1159,'multiline':False]
['text':' Check that the value was moved (not copied).','line_number':1163,'multiline':False]
['text':' Fill storage again.','line_number':1167,'multiline':False]
['text':' Push back a reference to last element when growing from large storage.','line_number':1172,'multiline':False]
['text':' Check the values.','line_number':1175,'multiline':False]
['text':' Check the value got moved out.','line_number':1178,'multiline':False]
['text':' Resize to add enough elements that V will grow again. If reference','line_number':1190,'multiline':False]
['text':' invalidation breaks in the future, sanitizers should be able to catch a','line_number':1191,'multiline':False]
['text':' use-after-free here.','line_number':1192,'multiline':False]
['text':' Append enough more elements that V will grow again. This tests growing','line_number':1204,'multiline':False]
['text':' when already in large mode.','line_number':1205,'multiline':False]
['text':'','line_number':1206,'multiline':False]
['text':' If reference invalidation breaks in the future, sanitizers should be able','line_number':1207,'multiline':False]
['text':' to catch a use-after-free here.','line_number':1208,'multiline':False]
['text':' Confirm this checks for growth when there's more than one element','line_number':1224,'multiline':False]
['text':' appended.','line_number':1225,'multiline':False]
['text':' Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.','line_number':1231,'multiline':False]
['text':' Check assign that shrinks in small mode.','line_number':1238,'multiline':False]
['text':' Check assign that grows within small mode.','line_number':1243,'multiline':False]
['text':' Reset to [1, 2, ...].','line_number':1249,'multiline':False]
['text':' Check assign that grows to large mode.','line_number':1253,'multiline':False]
['text':' Reset to [1, 2, ...].','line_number':1259,'multiline':False]
['text':' Check assign that shrinks in large mode.','line_number':1263,'multiline':False]
['text':' Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.','line_number':1279,'multiline':False]
['text':' Insert a reference to the back (not at end() or else insert delegates to','line_number':1283,'multiline':False]
['text':' push_back()), growing out of small mode. Confirm the value was copied out','line_number':1284,'multiline':False]
['text':' (moving out Constructable sets it to 0).','line_number':1285,'multiline':False]
['text':' Fill up the vector again.','line_number':1290,'multiline':False]
['text':' Grow again from large storage to large storage.','line_number':1294,'multiline':False]
['text':' Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.','line_number':1301,'multiline':False]
['text':' Insert a reference to the back (not at end() or else insert delegates to','line_number':1305,'multiline':False]
['text':' push_back()), growing out of small mode. Confirm the value was copied out','line_number':1306,'multiline':False]
['text':' (moving out Constructable sets it to 0).','line_number':1307,'multiline':False]
['text':' Check the value got moved out.','line_number':1311,'multiline':False]
['text':' Fill up the vector again.','line_number':1315,'multiline':False]
['text':' Grow again from large storage to large storage.','line_number':1319,'multiline':False]
['text':' Check the value got moved out.','line_number':1323,'multiline':False]
['text':' Cover NumToInsert <= this->end() - I.','line_number':1332,'multiline':False]
['text':' Cover NumToInsert > this->end() - I, inserting enough elements that V will','line_number':1337,'multiline':False]
['text':' also grow again; V.capacity() will be more elements than necessary but','line_number':1338,'multiline':False]
['text':' it's a simple way to cover both conditions.','line_number':1339,'multiline':False]
['text':'','line_number':1340,'multiline':False]
['text':' If reference invalidation breaks in the future, sanitizers should be able','line_number':1341,'multiline':False]
['text':' to catch a use-after-free here.','line_number':1342,'multiline':False]
['text':' Confirm this checks for growth when there's more than one element','line_number':1359,'multiline':False]
['text':' inserted.','line_number':1360,'multiline':False]
['text':' Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.','line_number':1366,'multiline':False]
['text':' Push back a reference to last element when growing from small storage.','line_number':1370,'multiline':False]
['text':' Check that the old value is still there (not moved away).','line_number':1374,'multiline':False]
['text':' Fill storage again.','line_number':1377,'multiline':False]
['text':' Push back a reference to last element when growing from large storage.','line_number':1382,'multiline':False]
['text':' Fill up the small size so that insertions move the elements.','line_number':1405,'multiline':False]
['text':' Test pairs of the same types from SmallVectorReferenceInvalidationTestTypes.','line_number':1411,'multiline':False]
['text':' Note: setup adds [1, 2, ...] to V until it's at capacity in small mode.','line_number':1421,'multiline':False]
['text':' Push back a reference to last element when growing from small storage.','line_number':1425,'multiline':False]
['text':' Check that the old value is still there (not moved away).','line_number':1430,'multiline':False]
['text':' Fill storage again.','line_number':1434,'multiline':False]
['text':' Push back a reference to last element when growing from large storage.','line_number':1439,'multiline':False]
['text':' end namespace','line_number':1445,'multiline':False]
['text':' NOLINTEND(*arrays, bugprone-forwarding-reference-overload)','line_number':1446,'multiline':False]
