['text':' SymInt represents either a regular int64_t, or a symbolic integer','line_number':16,'multiline':False]
['text':' (represented in a type erased way as SymNode).  The intention is for SymInt','line_number':17,'multiline':False]
['text':' to represent symbolic sizes that arise when doing shape computation in','line_number':18,'multiline':False]
['text':' operator kernels. This allows for tracing through programs without baking in','line_number':19,'multiline':False]
['text':' concrete sizes into kernel calls.','line_number':20,'multiline':False]
['text':'','line_number':21,'multiline':False]
['text':' SymInt has an API equivalent to int64_t.  In particular, it is a value type.','line_number':22,'multiline':False]
['text':' Internally, SymInt is represented in a clever packed way, so that it only','line_number':23,'multiline':False]
['text':' occupies one word of space; but morally, it is a union between an int64_t','line_number':24,'multiline':False]
['text':' and an intrusive pointer to SymNodeImpl.','line_number':25,'multiline':False]
['text':'','line_number':26,'multiline':False]
['text':' Invariant: the referenced SymNodeImpl is guaranteed to be a SymNode where','line_number':27,'multiline':False]
['text':' is_int() returns true','line_number':28,'multiline':False]
['text':'implicit','line_number':36,'multiline':True]
['text':' Large negative number, heap allocate it','line_number':38,'multiline':False]
['text':' unchecked c-tor accepting raw `data_`','line_number':45,'multiline':False]
['text':' One appropriate use for this is when you are constructing a symint','line_number':46,'multiline':False]
['text':' in a situation where you know it is non-negative (or, if it is negative,','line_number':47,'multiline':False]
['text':' the negative value is -1; i.e., not user controlled)','line_number':48,'multiline':False]
['text':' TODO: these implementations are not optimal because they allocate a','line_number':51,'multiline':False]
['text':' temporary and then use the move constructor/assignment','line_number':52,'multiline':False]
['text':' release the current SymNode if any','line_number':76,'multiline':False]
['text':' https://stackoverflow.com/questions/42534749/signed-extension-from-24-bit-to-32-bit-in-c','line_number':88,'multiline':False]
['text':' NOLINTNEXTLINE(performance-no-int-to-ptr)','line_number':91,'multiline':False]
['text':' steal','line_number':97,'multiline':False]
['text':' transfer ownership','line_number':105,'multiline':False]
['text':' Only valid if is_heap_allocated()','line_number':112,'multiline':False]
['text':' Guaranteed to return a SymNode, wrapping using base if necessary','line_number':115,'multiline':False]
['text':' Require the int to be non-symbolic, and if it is symbolic raise an','line_number':122,'multiline':False]
['text':' error.  This is safe to use for C++ code that doesn't work for symbolic','line_number':123,'multiline':False]
['text':' shapes, and you don't have time to fix it immediately, as if we','line_number':124,'multiline':False]
['text':' try to trigger the path in C++ you'll appropriately get an error','line_number':125,'multiline':False]
['text':' Test if we have a hint for this int (e.g., guard_int would work).','line_number':134,'multiline':False]
['text':' Most of the time this is true; it is only false when you have','line_number':135,'multiline':False]
['text':' an unbacked SymInt.','line_number':136,'multiline':False]
['text':' Insert a guard for the int to be its concrete value, and then return','line_number':139,'multiline':False]
['text':' that value.  This operation always works, even if the int is symbolic,','line_number':140,'multiline':False]
['text':' so long as we know what the underlying value is (e.g., this won't work','line_number':141,'multiline':False]
['text':' if you call it on the size of nonzero output).  Don't blindly put this','line_number':142,'multiline':False]
['text':' everywhere; you can cause overspecialization of PyTorch programs with','line_number':143,'multiline':False]
['text':' this method.','line_number':144,'multiline':False]
['text':'','line_number':145,'multiline':False]
['text':' It should be called as guard_int(__FILE__, __LINE__).  The file and line','line_number':146,'multiline':False]
['text':' number can be used to diagnose overspecialization.','line_number':147,'multiline':False]
['text':' Insert a guard that this SymInt must be size-like, returning true if','line_number':150,'multiline':False]
['text':' the integer actually is >= 0.  Unlike manually performing a >= 0 test,','line_number':151,'multiline':False]
['text':' if the SymInt in question is an unbacked SymInt (or, potentially in the','line_number':152,'multiline':False]
['text':' future, if it contains unbacked SymInts), we will also treat the','line_number':153,'multiline':False]
['text':' unbacked SymInt as statically testing >= 2 (which will prevent us from','line_number':154,'multiline':False]
['text':' choking on, e.g., contiguity checks.)','line_number':155,'multiline':False]
['text':' Distinguish actual symbolic values from constants stored on the heap','line_number':158,'multiline':False]
['text':' N.B. It's important to keep this definition in the header','line_number':164,'multiline':False]
['text':' as we expect if checks to be folded for mobile builds','line_number':165,'multiline':False]
['text':' where `is_heap_allocated` is always false and optimize dead code paths','line_number':166,'multiline':False]
['text':' If both are symbolic, this checks if','line_number':215,'multiline':False]
['text':' they share the same node.','line_number':216,'multiline':False]
['text':' If both are not symbolic this just checks normal equality.','line_number':217,'multiline':False]
['text':' Don't use this.  Prefer maybe_as_int instead','line_number':222,'multiline':False]
['text':' Return whether the integer is directly coercible to a SymInt','line_number':239,'multiline':False]
['text':' without requiring heap allocation.  You don't need to use this','line_number':240,'multiline':False]
['text':' to check if you can pass an integer to SymInt; this is guaranteed','line_number':241,'multiline':False]
['text':' to work (it just might heap allocate!)','line_number':242,'multiline':False]
['text':' Return the min representable integer as a SymInt without','line_number':247,'multiline':False]
['text':' heap allocation.  For quantities that count bytes (or larger),','line_number':248,'multiline':False]
['text':' this is still much larger than you need, so you may consider','line_number':249,'multiline':False]
['text':' using this as a more efficient version of MIN_INT','line_number':250,'multiline':False]
['text':' Constraints on the internal representation:','line_number':258,'multiline':False]
['text':'','line_number':259,'multiline':False]
['text':' - Should represent positive and small negative ints','line_number':260,'multiline':False]
['text':' - No conversion necessary for operations on ints','line_number':261,'multiline':False]
['text':' - Must represent valid 64-bit pointers','line_number':262,'multiline':False]
['text':' - Is symbolic test should be FAST (two arithmetic instructions is too','line_number':263,'multiline':False]
['text':' much).','line_number':264,'multiline':False]
['text':'   This code being a hotpath is based on Strobelight profiles of','line_number':265,'multiline':False]
['text':'   is_heap_allocated().  FB only: https://fburl.com/strobelight/5l50ncxd','line_number':266,'multiline':False]
['text':'   (you will need to change the time window).','line_number':267,'multiline':False]
['text':'','line_number':268,'multiline':False]
['text':' So, the scheme is to reserve large negative numbers (assuming','line_number':269,'multiline':False]
['text':' two's complement):','line_number':270,'multiline':False]
['text':'','line_number':271,'multiline':False]
['text':' - 0b0.... means we are a positive int','line_number':272,'multiline':False]
['text':' - 0b11... means we are a small negative int','line_number':273,'multiline':False]
['text':' - 0b10... means we are are a pointer. This means that','line_number':274,'multiline':False]
['text':'           [-2^63, -2^62-1] are not representable as ints.','line_number':275,'multiline':False]
['text':'           We don't actually need all of this space as on x86_64','line_number':276,'multiline':False]
['text':'           as the top 16bits aren't used for anything','line_number':277,'multiline':False]
['text':' We must manually translate the bit pattern test into a greater','line_number':280,'multiline':False]
['text':' than test because compiler doesn't figure it out:','line_number':281,'multiline':False]
['text':' https://godbolt.org/z/356aferaW','line_number':282,'multiline':False]
['text':'/ Sum of a list of SymInt; accumulates into the c10::SymInt expression','line_number':288,'multiline':False]
['text':' make sure constants work','line_number':346,'multiline':False]
['text':' just for completeness','line_number':350,'multiline':False]
['text':' On OSX size_t is different than uint64_t so we have to','line_number':352,'multiline':False]
['text':' define it separately','line_number':353,'multiline':False]
['text':' namespace c10','line_number':363,'multiline':False]
