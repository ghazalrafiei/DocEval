['text':' Wraps a DataPtr with a copy-on-write DataPtr.','line_number':18,'multiline':False]
['text':'/ Copies a copy-on-write DataPtr.','line_number':25,'multiline':False]
['text':' namespace','line_number':45,'multiline':False]
['text':' There are three possible circumstances:','line_number':60,'multiline':False]
['text':'','line_number':61,'multiline':False]
['text':' 1) The storage has a normal data pointer with no out of the ordinary','line_number':62,'multiline':False]
['text':'    context. In this case we know that there are no blind aliases to the','line_number':63,'multiline':False]
['text':'    storage impl: they all will be public aliases and the user is expected','line_number':64,'multiline':False]
['text':'    to synchronize manually.','line_number':65,'multiline':False]
['text':'','line_number':66,'multiline':False]
['text':'    No locking is required in this case.','line_number':67,'multiline':False]
['text':'','line_number':68,'multiline':False]
['text':' 2) The storage already has a copy on write context. There','line_number':69,'multiline':False]
['text':'    is a potential race condition with a blind alias (i.e. an','line_number':70,'multiline':False]
['text':'    alias that the user is not required to synchronize','line_number':71,'multiline':False]
['text':'    with). Because our input storage is bound to a live reference','line_number':72,'multiline':False]
['text':'    to the data, we know that it isn't going away. A blind alias','line_number':73,'multiline':False]
['text':'    could be copying from it right now, but we will grab the','line_number':74,'multiline':False]
['text':'    context's mutex to protect us.','line_number':75,'multiline':False]
['text':'','line_number':76,'multiline':False]
['text':'    We do not need to lock in this case either, because we're just','line_number':77,'multiline':False]
['text':'    wrapping a context that we know isn't going away.','line_number':78,'multiline':False]
['text':'','line_number':79,'multiline':False]
['text':' 3) The storage has a context that is not the copy on write','line_number':80,'multiline':False]
['text':'    context. This is not supported, so we just return null.','line_number':81,'multiline':False]
['text':'','line_number':82,'multiline':False]
['text':'    No locking is required in this case.','line_number':83,'multiline':False]
['text':' must be set below','line_number':85,'multiline':False]
['text':' Case 1) We have a simple data pointer: wrap it.','line_number':88,'multiline':False]
['text':' Save this for the result.','line_number':94,'multiline':False]
['text':' Update this storage to the new copy on write context.','line_number':98,'multiline':False]
['text':' Case 2): there is already a copy on write context. Just return a','line_number':101,'multiline':False]
['text':' new storage impl.','line_number':102,'multiline':False]
['text':' Case 3) There is a context and it's not copy-on-write. Nothing','line_number':105,'multiline':False]
['text':' we can do here.','line_number':106,'multiline':False]
['text':' namespace c10::impl::cow','line_number':120,'multiline':False]
