['text':' empty constructor shouldn't be used; only needed to initialize','line_number':12,'multiline':False]
['text':' the array before populating it.','line_number':13,'multiline':False]
['text':' This needs to big enough to cover the size of the operator table.','line_number':17,'multiline':False]
['text':' See Note [No More Than 16 Backends]','line_number':19,'multiline':False]
['text':' This mask needs to be big enough to mask all of the backend bits.','line_number':20,'multiline':False]
['text':' We probably don't ever want to have more than 16 backend bits, so uint16_t','line_number':21,'multiline':False]
['text':' should be enough.','line_number':22,'multiline':False]
['text':' A representation of a set of DispatchKeys. A DispatchKeySet contains both','line_number':39,'multiline':False]
['text':' "functionality" bits and "backend bits", and every tensor holds its own','line_number':40,'multiline':False]
['text':' DispatchKeySet. The Dispatcher implements multiple dispatch by grabbing the','line_number':41,'multiline':False]
['text':' keyset on every input tensor, orâ€™ing them together, and dispatching to a','line_number':42,'multiline':False]
['text':' specific piece of functionality. The functionality bits are *ordered*. When','line_number':43,'multiline':False]
['text':' multiple functionality bits are set, we use the highest priority','line_number':44,'multiline':False]
['text':' functionality. Similarly, multiple backend bits can theoretically be set if','line_number':45,'multiline':False]
['text':' you call an operator with multiple tensors from difference devices (e.g. CPU','line_number':46,'multiline':False]
['text':' and CUDA), although support for mixed device dispatch is limited (the only','line_number':47,'multiline':False]
['text':' kernels that gracefully handle mixed device inputs for now are cuda kernels','line_number':48,'multiline':False]
['text':' that take in a scalar cpu tensor).','line_number':49,'multiline':False]
['text':' A representation of a set of DispatchKeys.  A tensor may have multiple','line_number':51,'multiline':False]
['text':' tensor type ids, e.g., a Variable tensor can also be a CPU tensor; the','line_number':52,'multiline':False]
['text':' DispatchKeySet specifies what type ids apply.  The internal representation is','line_number':53,'multiline':False]
['text':' as a 64-bit bit set (this means only 64 tensor type ids are supported).','line_number':54,'multiline':False]
['text':'','line_number':55,'multiline':False]
['text':' As mentioned above, DispatchKeys are ordered; thus, we can ask questions like','line_number':56,'multiline':False]
['text':' "what is the highest priority DispatchKey in the set"?  (The set itself is','line_number':57,'multiline':False]
['text':' not ordered; two sets with the same ids will always have the ids ordered in','line_number':58,'multiline':False]
['text':' the same way.)','line_number':59,'multiline':False]
['text':'','line_number':60,'multiline':False]
['text':' Note [DispatchKeySet Internal Representation]','line_number':61,'multiline':False]
['text':' Internally, dispatch keys are packed into 64-bit DispatchKeySet objects','line_number':62,'multiline':False]
['text':' that get passed around at runtime.','line_number':63,'multiline':False]
['text':' However, there isn't necessarily a 1-to-1 mapping between bits in the keyset','line_number':64,'multiline':False]
['text':' and individual dispatch keys.','line_number':65,'multiline':False]
['text':'','line_number':66,'multiline':False]
['text':' First: why do we have this distinction, and why not map every dispatch key','line_number':67,'multiline':False]
['text':' directly to a bit? This is mostly because we have several types of','line_number':68,'multiline':False]
['text':' functionalities that different backends would like to customize. For example,','line_number':69,'multiline':False]
['text':' we have:','line_number':70,'multiline':False]
['text':' - "Dense":     CPU, CUDA, XLA, ... (~12 keys)','line_number':71,'multiline':False]
['text':' - "Sparse":    SparseCPU, SparseCUDA, ...','line_number':72,'multiline':False]
['text':' - "Quantized": QuantizedCPU, QuantizedCUDA, QuantizedXLA, ...','line_number':73,'multiline':False]
['text':' - "Autograd":  AutogradCPU, AutogradCUDA, Autograd XLA, ...','line_number':74,'multiline':False]
['text':' The problem is that total number of keys grows quadratically with [#','line_number':75,'multiline':False]
['text':' backends] x [# functionalities], making it very difficult to map each key','line_number':76,'multiline':False]
['text':' directly to a bit in a bitset without dramatically increasing the size of the','line_number':77,'multiline':False]
['text':' bitset over time.','line_number':78,'multiline':False]
['text':'','line_number':79,'multiline':False]
['text':' The two enums (BackendComponent and DispatchKey) can be divided roughly into','line_number':80,'multiline':False]
['text':' 5 categories.','line_number':81,'multiline':False]
['text':'','line_number':82,'multiline':False]
['text':' (1) "Building block" keys','line_number':83,'multiline':False]
['text':'    (a) backends: Everything in the BackendComponent enum (e.g. CPUBit,','line_number':84,'multiline':False]
['text':'    CUDABit) (b) functionalities: (per-backend) functionality-bit DispatchKeys','line_number':85,'multiline':False]
['text':'    (e.g. AutogradFunctionality, Sparse, Dense)','line_number':86,'multiline':False]
['text':' (2) "Runtime" keys','line_number':87,'multiline':False]
['text':'    (a) "non-customizable backends" (e.g. FPGA)','line_number':88,'multiline':False]
['text':'    (b) "non-customizable functionalities" (e.g. Functionalize)','line_number':89,'multiline':False]
['text':'    (c) "per-backend instances of customizable functionalities" (e.g. CPU,','line_number':90,'multiline':False]
['text':'    SparseCPU, AutogradCPU)','line_number':91,'multiline':False]
['text':' (3) "Alias" DispatchKeys (see Note [Alias Dispatch Keys])','line_number':92,'multiline':False]
['text':'','line_number':93,'multiline':False]
['text':' (1) Building block keys always correspond to individual bits in a','line_number':94,'multiline':False]
['text':' DispatchKeySet. They can also be combined in a DispatchKeySet to form actual','line_number':95,'multiline':False]
['text':' runtime keys. e.g.','line_number':96,'multiline':False]
['text':'     auto dense_cpu_ks = DispatchKeySet({DispatchKey::CPUBit,','line_number':97,'multiline':False]
['text':'     DispatchKey::Dense});','line_number':98,'multiline':False]
['text':'     // The keyset has the runtime dense-cpu key.','line_number':99,'multiline':False]
['text':'     dense_cpu_ks.has(DispatchKey::CPU);','line_number':100,'multiline':False]
['text':'     // And it contains the building block keys too.','line_number':101,'multiline':False]
['text':'     dense_cpu_ks.has(DispatchKey::CPUBit);','line_number':102,'multiline':False]
['text':'     dense_cpu_ks.has(DispatchKey::Dense);','line_number':103,'multiline':False]
['text':'','line_number':104,'multiline':False]
['text':' Not every backend and not every functionality counts as a "building block','line_number':105,'multiline':False]
['text':' key". This is mostly to give us more levers to pull in the design space.','line_number':106,'multiline':False]
['text':' Backend keys and functionality keys that count as "building blocks" will','line_number':107,'multiline':False]
['text':' contribute to a full cross product of functionality that can be overriden.','line_number':108,'multiline':False]
['text':'','line_number':109,'multiline':False]
['text':' For example, right now we have at least 12 "backend" building blocks (CPU,','line_number':110,'multiline':False]
['text':' CUDA, XLA, ...) and at least 4 "functionality" building blocks (Dense,','line_number':111,'multiline':False]
['text':' Sparse, Quantized, AutogradFunctionality, ...). These keys together allow','line_number':112,'multiline':False]
['text':' every dispatcher operator to be customized in up to 12*4 different ways. Each','line_number':113,'multiline':False]
['text':' of those requires a slot in the operator table of every dispatcher operator.','line_number':114,'multiline':False]
['text':' Not every piece of functionality necessarily needs to be customizable','line_number':115,'multiline':False]
['text':' per-backend, and not every backend necessarily needs to be able to customize','line_number':116,'multiline':False]
['text':' every type of functionality.','line_number':117,'multiline':False]
['text':'','line_number':118,'multiline':False]
['text':'','line_number':119,'multiline':False]
['text':' (2) Every runtime key corresponds directly to a slot in an operator's runtime','line_number':120,'multiline':False]
['text':' dispatch table, and you can directly register kernels to a runtime dispatch','line_number':121,'multiline':False]
['text':' key.','line_number':122,'multiline':False]
['text':'','line_number':123,'multiline':False]
['text':' For per-backend functionalities like "Dense" or "AutogradFunctionality",','line_number':124,'multiline':False]
['text':' you can think of the corresponding runtime dispatch keys as "instances" of','line_number':125,'multiline':False]
['text':' that functionality, per backend. E.g. "CPU", "CUDA", "XLA", etc. are all','line_number':126,'multiline':False]
['text':' runtime instances of the "Dense" building block key.','line_number':127,'multiline':False]
['text':' (2a) and (2b) are represented identically in the DispatchKeySet logic:','line_number':129,'multiline':False]
['text':' - backend-agnostic functionalities (e.g. FuncTorchBatched) are NOT','line_number':130,'multiline':False]
['text':' customizable per backend.','line_number':131,'multiline':False]
['text':'   In order to do so, we'd need to promote it to a per-backend functionality','line_number':132,'multiline':False]
['text':'   "building block" key.','line_number':133,'multiline':False]
['text':' - non-customizable backends (e.g. FPGA) can NOT customize existing','line_number':134,'multiline':False]
['text':' functionality like Sparse, Autograd, etc.','line_number':135,'multiline':False]
['text':'   In order to do so, we'd need to promote it to a backend "building block"','line_number':136,'multiline':False]
['text':'   key.','line_number':137,'multiline':False]
['text':'','line_number':138,'multiline':False]
['text':' In both cases, these keys directly correspond to runtime slots in the','line_number':139,'multiline':False]
['text':' operator table.','line_number':140,'multiline':False]
['text':'','line_number':141,'multiline':False]
['text':'','line_number':142,'multiline':False]
['text':' (3) "Alias" keys','line_number':143,'multiline':False]
['text':' See Note [Alias Dispatch Keys]','line_number':144,'multiline':False]
['text':'','line_number':145,'multiline':False]
['text':' Final note: for anyone making future changes to the Dispatcher +','line_number':146,'multiline':False]
['text':' DispatchKeySet internals, there's a closed PR with a basic','line_number':147,'multiline':False]
['text':' python-implementation of the Dispatcher that might be useful in quickly','line_number':148,'multiline':False]
['text':' testing out and validating changes. See it at','line_number':149,'multiline':False]
['text':' https://github.com/pytorch/pytorch/pull/68743','line_number':150,'multiline':False]
['text':' An undefined tensor is one with an empty tensor type set.','line_number':152,'multiline':False]
['text':' NB: default constructor representation as zero is MANDATORY as','line_number':159,'multiline':False]
['text':' use of DispatchKeySet in TLS requires this.','line_number':160,'multiline':False]
['text':' LSB after t are OK, but not t itself.','line_number':167,'multiline':False]
['text':' "functionalities" have a notion of ordering (e.g. Autograd > Sparse >','line_number':168,'multiline':False]
['text':' Quantized > Dense). But backends don't really have an ordering.','line_number':169,'multiline':False]
['text':' Therefore, we're enforcing that FullAfter can only be used on','line_number':170,'multiline':False]
['text':' "functionality" keys.','line_number':171,'multiline':False]
['text':' Public version of DispatchKeySet(uint64_t) API; external users','line_number':180,'multiline':False]
['text':' must be explicit when they do this!','line_number':181,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-branch-clone)','line_number':193,'multiline':False]
['text':' Case 1: handle Undefined specifically','line_number':195,'multiline':False]
['text':' Case 2: handle "functionality-only" keys','line_number':198,'multiline':False]
['text':' These keys have a functionality bit set, but no backend bits','line_number':199,'multiline':False]
['text':' These can technically be either:','line_number':200,'multiline':False]
['text':' - valid runtime keys (e.g. DispatchKey::AutogradOther,','line_number':201,'multiline':False]
['text':' DispatchKey::FuncTorchBatched, etc)','line_number':202,'multiline':False]
['text':' - "building block" keys that aren't actual runtime keys (e.g.','line_number':203,'multiline':False]
['text':' DispatchKey::Dense or Sparse)','line_number':204,'multiline':False]
['text':' Case 3: "runtime" keys that have a functionality bit AND a backend bit.','line_number':209,'multiline':False]
['text':' First compute which bit to flip for the functionality.','line_number':210,'multiline':False]
['text':' The - 1 is because Undefined is technically a "functionality" that','line_number':212,'multiline':False]
['text':' doesn't show up in the bitset. So e.g. Dense is technically the second','line_number':213,'multiline':False]
['text':' functionality, but the lowest functionality bit.','line_number':214,'multiline':False]
['text':' then compute which bit to flip for the backend','line_number':218,'multiline':False]
['text':' Case 4a: handle the runtime instances of "per-backend functionality"','line_number':219,'multiline':False]
['text':' keys For example, given DispatchKey::CPU, we should set:','line_number':220,'multiline':False]
['text':' - the Dense functionality bit','line_number':221,'multiline':False]
['text':' - the CPUBit backend bit','line_number':222,'multiline':False]
['text':' first compute which bit to flip for the backend','line_number':223,'multiline':False]
['text':' At this point, we should have covered every case except for alias keys.','line_number':230,'multiline':False]
['text':' Technically it would be possible to add alias dispatch keys to a','line_number':231,'multiline':False]
['text':' DispatchKeySet, but the semantics are a little confusing and this','line_number':232,'multiline':False]
['text':' currently isn't needed anywhere.','line_number':233,'multiline':False]
['text':' Note: for some reason, putting this logic directly in the constructor','line_number':259,'multiline':False]
['text':' appears to fail to compile on CUDA 10.1.','line_number':260,'multiline':False]
['text':' See an example internal failure at','line_number':261,'multiline':False]
['text':' https://www.internalfb.com/intern/skycastle/run/76561193669136035/artifact/actionlog.76561193742069401.stderr','line_number':262,'multiline':False]
['text':' Test if a DispatchKey is in the set','line_number':265,'multiline':False]
['text':' Test if a DispatchKey is in the set','line_number':274,'multiline':False]
['text':' Given a DispatchKeySet of functionality keys and (potentially) backend','line_number':275,'multiline':False]
['text':' keys, tests if all of them are in the current set.','line_number':276,'multiline':False]
['text':' Given a DispatchKeySet of functionality keys and (potentially) backend','line_number':281,'multiline':False]
['text':' keys, tests if any of them are in the current set. This could technically','line_number':282,'multiline':False]
['text':' be pretty easily implemented using has(). It is strictly a perf','line_number':283,'multiline':False]
['text':' optimization though. There are many places in the code base where we want','line_number':284,'multiline':False]
['text':' to test for multiple functionality keys together. HOWEVER, runtime','line_number':285,'multiline':False]
['text':' per-backend functionality keys aren't allowed to be used with this','line_number':286,'multiline':False]
['text':' function, because you can end up with weird results. e.g.','line_number':287,'multiline':False]
['text':' DispatchKeySet(DispatchKey::AutogradCPU).has_any(DispatchKeySet(DispatchKey::CPU))','line_number':288,'multiline':False]
['text':' would return true.','line_number':289,'multiline':False]
['text':' Either there are no backend bits in the input keyset','line_number':292,'multiline':False]
['text':' or there are no per-backend-functionality bits','line_number':294,'multiline':False]
['text':' See [Note: Per-Backend Functionality Dispatch Keys]','line_number':295,'multiline':False]
['text':' Test if DispatchKeySet is a superset of ks.','line_number':306,'multiline':False]
['text':' Perform set union','line_number':310,'multiline':False]
['text':' Perform set intersection','line_number':314,'multiline':False]
['text':' Compute the set difference self - other,','line_number':318,'multiline':False]
['text':' but ONLY for the functionality keys.','line_number':319,'multiline':False]
['text':' Any backend bits set on self will remain unchanged.','line_number':320,'multiline':False]
['text':' See Note [Removing keys from DispatchKeySet Only Affects Functionality','line_number':321,'multiline':False]
['text':' Keys]','line_number':322,'multiline':False]
['text':' Compute self ^ other','line_number':327,'multiline':False]
['text':' Add a DispatchKey to the DispatchKey set.  Does NOT mutate,','line_number':337,'multiline':False]
['text':' returns the extended DispatchKeySet!','line_number':338,'multiline':False]
['text':' Remove a DispatchKey from the DispatchKey set.','line_number':346,'multiline':False]
['text':' This is generally not an operation you should be doing','line_number':347,'multiline':False]
['text':' (it's used to implement the printing overload, operator<<)','line_number':348,'multiline':False]
['text':'','line_number':349,'multiline':False]
['text':' Note [Removing keys from DispatchKeySet Only Affects Functionality Keys]','line_number':350,'multiline':False]
['text':' Only functionality bits are allowed to be removed from a keyset.','line_number':351,'multiline':False]
['text':' For now, we're only allowing removal of "functionality bits" from the','line_number':352,'multiline':False]
['text':' keyset, which is specifically needed by the fallthrough key calculation','line_number':353,'multiline':False]
['text':' logic. Why is removing backend bits problematic? Consider this example:','line_number':354,'multiline':False]
['text':'','line_number':355,'multiline':False]
['text':' DispatchKeySet([DispatchKey.CPU, DispatchKey.AutogradCUDA,','line_number':356,'multiline':False]
['text':' DispatchKey.CUDA]).remove(DispatchKey.AutogradCUDA)','line_number':357,'multiline':False]
['text':' DispatchKeySet([DispatchKey.CPU,','line_number':358,'multiline':False]
['text':' DispatchKey.AutogradCUDA]).remove(DispatchKey.AutogradCUDA)','line_number':359,'multiline':False]
['text':'','line_number':360,'multiline':False]
['text':' What do we want to happen?','line_number':361,'multiline':False]
['text':' Technically, we'd like it to be true that after removal,','line_number':362,'multiline':False]
['text':' the first keyset still has the CUDA dispatch key while the second doesn't.','line_number':363,'multiline':False]
['text':' Unfortunately there's no way to represent that, because the two keysets are','line_number':364,'multiline':False]
['text':' represented the same way internally: functionality bits: Autograd, Dense','line_number':365,'multiline':False]
['text':' backend bits: CPU, CUDA','line_number':366,'multiline':False]
['text':'','line_number':367,'multiline':False]
['text':' Instead, remove(DispatchKey.AutogradCPU) will only remove the "Autograd"','line_number':368,'multiline':False]
['text':' bit from the bitset.','line_number':369,'multiline':False]
['text':' You're allowed to remove a backend bit from a DispatchKeySet,','line_number':374,'multiline':False]
['text':' but you have to be explicit about it (remove_backend() instead of','line_number':375,'multiline':False]
['text':' remove()).','line_number':376,'multiline':False]
['text':' Is the set empty?  (AKA undefined tensor)','line_number':380,'multiline':False]
['text':' This means that none of the functionality bits were set.','line_number':390,'multiline':False]
['text':' The first num_backend bits in the keyset don't correspond to real','line_number':393,'multiline':False]
['text':' dispatch keys.','line_number':394,'multiline':False]
['text':' This is similar like toBackendComponent(DispatchKey), but less restrictive.','line_number':398,'multiline':False]
['text':' toBackendComponent() errors out if the key that it was passed has no','line_number':399,'multiline':False]
['text':' backend bits, which is useful for error checking. We need a version of that','line_number':400,'multiline':False]
['text':' here that can also handle "fake" backends like FPGA, because they need to','line_number':401,'multiline':False]
['text':' map to the AutogradOther key. For those backends, we return','line_number':402,'multiline':False]
['text':' BackendComponent::InvalidBit.','line_number':403,'multiline':False]
['text':' mask to mask out functionality bits','line_number':405,'multiline':False]
['text':' all zeros across the backend bits means that no backend bits are set.','line_number':408,'multiline':False]
['text':' returns the DispatchKey of highest priority in the set.','line_number':414,'multiline':False]
['text':' Returns the index of the most-significant bit in the keyset.','line_number':424,'multiline':False]
['text':' This is used to as part of the calculation into the operator table to get:','line_number':425,'multiline':False]
['text':' - the highest "functionality" bit in the keyset.','line_number':426,'multiline':False]
['text':' - the highest "backend" bit in the keyset.','line_number':427,'multiline':False]
['text':' [Note: Trimmed Mobile Dispatch Keys]','line_number':433,'multiline':False]
['text':'*
   * The method below maps the dispatch key in the enum DispatchKey to an
   * integer index in the dispatchTable_ array in OperatorEntry. The array
   * is trimmed for mobile to reduce peak memory usage since it's
   * unnecessary to reserve additional space for dispatch keys that will
   * never be used on mobile.
   ','line_number':434,'multiline':True]
['text':' returns the index in the operator table of highest priority key in the the','line_number':465,'multiline':False]
['text':' keyset Note that we could in theory implement this using','line_number':466,'multiline':False]
['text':' highestPriorityTypeId(), but this code is very hotpath and we can do it','line_number':467,'multiline':False]
['text':' faster without it.','line_number':468,'multiline':False]
['text':' Mask the functionality bits out first, then right-shift by 1.','line_number':473,'multiline':False]
['text':' right-shifting by 1 because everything is zero-indexed.','line_number':474,'multiline':False]
['text':' E.g. 000001 (CPU) should give us an offset of 0, 000010 (CUDA) should','line_number':475,'multiline':False]
['text':' give us an offset of 1, etc.','line_number':476,'multiline':False]
['text':' returns the "index" of the highest priority backend in the keyset.','line_number':483,'multiline':False]
['text':' This is pretty similar to getBackendKey(), but:','line_number':484,'multiline':False]
['text':' - It's hotpath code (part of the runtime bitset calculation)','line_number':485,'multiline':False]
['text':' - I's returns an integer index, not an enum value','line_number':486,'multiline':False]
['text':' - Everything is shifted to the right by 1.','line_number':487,'multiline':False]
['text':'   BackendComponent::InvalidBit is technically the lowest enum value,','line_number':488,'multiline':False]
['text':'   but it isn't included in the runtime table. So CPUBit = 1, CUDABit = 2,','line_number':489,'multiline':False]
['text':'   etc.','line_number':490,'multiline':False]
['text':' STL iterator for DispatchKeySet. Iterates through all runtime DispatchKeys','line_number':500,'multiline':False]
['text':' in the set. The iterator is only invalidated by the destruction of the','line_number':501,'multiline':False]
['text':' underlying DispatchKeySet as the iterator stores a pointer to the raw','line_number':502,'multiline':False]
['text':' representation of the DispatchKeySet. Note: When we encounter a per-backend','line_number':503,'multiline':False]
['text':' functionality (e.g. Dense or Sparse), we will iterate through EVERY backend','line_number':504,'multiline':False]
['text':' in the keyset, for that functionality. For example, if the next','line_number':505,'multiline':False]
['text':' functionality key to iterate over is Autograd, and the backend bits in the','line_number':506,'multiline':False]
['text':' keyset correspond to [BackendComponent::CPUBit, BackendComponent::CUDABit],','line_number':507,'multiline':False]
['text':' then the next two keys we return will be DispatchKey::AutogradCPU,','line_number':508,'multiline':False]
['text':' DispatchKey::AutogradCUDA (CPU first because it has lower precedence than','line_number':509,'multiline':False]
['text':' CUDA in DispatchKey.h).','line_number':510,'multiline':False]
['text':' final mask value should mask out the entire keyset','line_number':519,'multiline':False]
['text':' final key value should be the last DispatchKey','line_number':522,'multiline':False]
['text':' current_dispatchkey_idx_ will iterate through all functionality bits.','line_number':525,'multiline':False]
['text':' current_backendcomponent_idx_ will iterate through all backend bits.','line_number':526,'multiline':False]
['text':' These are in an invalid state at construction time, and set by the','line_number':534,'multiline':False]
['text':' first increment call','line_number':535,'multiline':False]
['text':' Go to the first key in the set','line_number':538,'multiline':False]
['text':' We expect all of the Dense, Sparse, Quantized, and Autograd keys to','line_number':575,'multiline':False]
['text':' be ordered the same way with respect to their backends','line_number':576,'multiline':False]
['text':' Returns iterator to the first key in the set. If no keys are in the','line_number':604,'multiline':False]
['text':' set, then will return the end iterator.','line_number':605,'multiline':False]
['text':' We do not need to iterate beyond EndOfFunctionalityKeys so we will treat','line_number':610,'multiline':False]
['text':' this as the end iterator.','line_number':611,'multiline':False]
['text':' Alias key DispatchKey::Autograd maps to','line_number':624,'multiline':False]
['text':' (autograd_dispatch_keyset x full_backend_mask)','line_number':625,'multiline':False]
['text':' NB: keys in this set also get associated with CompositeImplicitAutograd','line_number':626,'multiline':False]
['text':'','line_number':627,'multiline':False]
['text':' Note [autograd_dispatch_keyset Does Not Include Backend Bits]','line_number':628,'multiline':False]
['text':' We don't want to include any backend bits (BackendComponent::CPUBit, etc)','line_number':629,'multiline':False]
['text':' directly in autograd_dispatch_keyset.','line_number':630,'multiline':False]
['text':' Why? keysets like autograd_dispatch_keyset are commonly used to remove','line_number':631,'multiline':False]
['text':' autograd keys from a DispatchKeySet throughout the code base. However, you','line_number':632,'multiline':False]
['text':' are only allowed to remove functionality bits from a keyset, not backend','line_number':633,'multiline':False]
['text':' bits. See Note [Removing keys from DispatchKeySet Only Affects Functionality','line_number':634,'multiline':False]
['text':' Keys] for details. To be consistent and avoid confusion, we're explicitly','line_number':635,'multiline':False]
['text':' setting up autograd_dispatch_keyset to not have any backend bits.','line_number':636,'multiline':False]
['text':' See Note [TLS Initialization]','line_number':653,'multiline':False]
['text':' backend dispatch keys that map to DispatchKey::AutogradOther','line_number':684,'multiline':False]
['text':' NB: keys in this set also get associated with CompositeImplicitAutograd','line_number':685,'multiline':False]
['text':' HIP and VE aren't in this list: they now have their own backend bits','line_number':688,'multiline':False]
['text':' which means that they can now have their own Autograd keys.','line_number':689,'multiline':False]
['text':' Technically, HIP will now redispatch to its own custom AutogradHIP','line_number':690,'multiline':False]
['text':' slot in the runtime table.','line_number':691,'multiline':False]
['text':' Sparse and Quantized backends also live here.','line_number':700,'multiline':False]
['text':' Including the backend bits because this keyset is used during op','line_number':703,'multiline':False]
['text':' registration, which requires looping over all runtime autogradother','line_number':704,'multiline':False]
['text':' backend keys.','line_number':705,'multiline':False]
['text':' The set of dispatch keys that come after autograd','line_number':708,'multiline':False]
['text':' n.b. this relies on the fact that AutogradOther is currently the lowest','line_number':709,'multiline':False]
['text':' Autograd key','line_number':710,'multiline':False]
['text':' The set of dispatch keys that come after ADInplaceOrView','line_number':714,'multiline':False]
['text':' The set of dispatch keys that come after Functionalize','line_number':719,'multiline':False]
['text':' NOTE: we also need to remove ADInplaceOrView from the keyset when','line_number':723,'multiline':False]
['text':' redispatching after the func kernels. This is because we're not','line_number':724,'multiline':False]
['text':' calling the same op; we originally called an inplace op, and now','line_number':725,'multiline':False]
['text':' we aren't. The original key calculation figured out which keys','line_number':726,'multiline':False]
['text':' were Fallthrough based on the inplace op. That means that it did','line_number':727,'multiline':False]
['text':' not include the ADInPlaceOrView kernel as a fallthrough key.','line_number':728,'multiline':False]
['text':' However, we WANT the ADInPlaceOrView kernel to be ignored now','line_number':729,'multiline':False]
['text':' that we're calling an out-of-place op. Re-invoking','line_number':730,'multiline':False]
['text':' Dispatcher::call would re-run the Fallthrough key calculation and','line_number':731,'multiline':False]
['text':' get us that, But at::redispatch is more performant. We can get','line_number':732,'multiline':False]
['text':' away with it by explicitly removing the key here.','line_number':733,'multiline':False]
['text':' keyset corresponding to functorch keys that have their own dedicated','line_number':759,'multiline':False]
['text':' TensorImpl subclass.','line_number':760,'multiline':False]
['text':' This keyset has:','line_number':771,'multiline':False]
['text':' (1) the functionality bits corresponding to backends (dense, sparse,','line_number':772,'multiline':False]
['text':' quantized) (2) all of the backend bits set','line_number':773,'multiline':False]
['text':' true if t is a backend dispatch key','line_number':792,'multiline':False]
['text':' Resolve alias dispatch key to DispatchKeySet if applicable','line_number':795,'multiline':False]
['text':' Resolve alias dispatch key to DispatchKeySet if applicable,','line_number':798,'multiline':False]
['text':' and check if k is a part of that set','line_number':799,'multiline':False]
['text':' Returns a DispatchKeySet of all backend keys mapped to Autograd dispatch key','line_number':802,'multiline':False]
['text':' t, DispatchKeySet is empty if t is not alias of DispatchKey::Autograd.','line_number':803,'multiline':False]
['text':' Returns a DispatchKeySet of autograd related keys mapped to backend.','line_number':806,'multiline':False]
['text':' for a given backend key, use the associated autograd key.','line_number':807,'multiline':False]
['text':' for non-backend keys, use AutogradOther as a default.','line_number':808,'multiline':False]
['text':' Note: it's convenient and fast to return a default here rather than (say)','line_number':809,'multiline':False]
['text':' returning an optional<DispatchKey>, or throwing. But it makes callers','line_number':810,'multiline':False]
['text':' responsible for either a) enforcing the invariant that only backend keys','line_number':811,'multiline':False]
['text':' be passed as arguments, or b) interpreting our return value carefully.','line_number':812,'multiline':False]
['text':' Returns a DispatchKeySet of autocast related keys mapped to backend.','line_number':844,'multiline':False]
['text':' returns the "backend" DispatchKey of highest priority in the set.','line_number':874,'multiline':False]
['text':' This is basically like highestBackendKey(), except that we have some','line_number':875,'multiline':False]
['text':' "functionality" bits that correspond to backends (Sparse, Quantized)','line_number':876,'multiline':False]
['text':' This API exists because we have a use case for checking','line_number':881,'multiline':False]
['text':' getRuntimeDispatchKeySet(alias).has(DispatchKey::Undefined)','line_number':882,'multiline':False]
['text':' in OperatorEntry.cpp but we disallow it in has() API.','line_number':883,'multiline':False]
['text':' Historically, every tensor only had a single DispatchKey, and it was always','line_number':886,'multiline':False]
['text':' something like CPU, and there wasn't any of this business where TLS','line_number':887,'multiline':False]
['text':' could cause the DispatchKey of a tensor to change.  But we still have some','line_number':888,'multiline':False]
['text':' legacy code that is still using DispatchKey for things like instanceof','line_number':889,'multiline':False]
['text':' checks; if at all possible, refactor the code to stop using DispatchKey in','line_number':890,'multiline':False]
['text':' those cases.','line_number':891,'multiline':False]
['text':' NB: If you add any extra keys that can be stored in TensorImpl on','line_number':893,'multiline':False]
['text':' top of existing "backend" keys like CPU/CUDA, you need to add it','line_number':894,'multiline':False]
['text':' here.  At the moment, autograd keys and ADInplaceOrView key need this','line_number':895,'multiline':False]
['text':' treatment;','line_number':896,'multiline':False]
['text':' Given a function type, constructs a function_traits type that drops the first','line_number':909,'multiline':False]
['text':' parameter type if the first parameter is of type DispatchKeySet. NB:','line_number':910,'multiline':False]
['text':' DispatchKeySet is currently explicitly hidden from JIT (mainly to avoid','line_number':911,'multiline':False]
['text':' pushing unnecessary arguments on the stack - see Note [ Plumbing Keys Through','line_number':912,'multiline':False]
['text':' the Dispatcher] for details). If at any point in the future we need to expose','line_number':913,'multiline':False]
['text':' this type to JIT, revisit the usage of this type alias.','line_number':914,'multiline':False]
['text':' namespace c10','line_number':929,'multiline':False]
