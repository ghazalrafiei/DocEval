['text':' Main entry for c10/macros.
 *
 * In your code, include c10/macros/Macros.h directly, instead of individual
 * files in this folder.
 ','line_number':5,'multiline':True]
['text':' For build systems that do not directly depend on CMake and directly build','line_number':11,'multiline':False]
['text':' from the source directory (such as Buck), one may not have a cmake_macros.h','line_number':12,'multiline':False]
['text':' file at all. In this case, the build system is responsible for providing','line_number':13,'multiline':False]
['text':' correct macro definitions corresponding to the cmake_macros.h.in file.','line_number':14,'multiline':False]
['text':'','line_number':15,'multiline':False]
['text':' In such scenarios, one should define the macro','line_number':16,'multiline':False]
['text':'     C10_USING_CUSTOM_GENERATED_MACROS','line_number':17,'multiline':False]
['text':' to inform this header that it does not need to include the cmake_macros.h','line_number':18,'multiline':False]
['text':' file.','line_number':19,'multiline':False]
['text':' C10_USING_CUSTOM_GENERATED_MACROS','line_number':23,'multiline':False]
['text':' Detect address sanitizer as some stuff doesn't work with it','line_number':44,'multiline':False]
['text':' for clang','line_number':47,'multiline':False]
['text':' for gcc','line_number':54,'multiline':False]
['text':' Disable the copy and assignment operator for a class. Note that this will','line_number':67,'multiline':False]
['text':' disable the usage of the class in std containers.','line_number':68,'multiline':False]
['text':'*
 * C10_ANONYMOUS_VARIABLE(str) introduces an identifier starting with
 * str and ending with a number that varies with the line.
 ','line_number':81,'multiline':True]
['text':'/ C10_NODISCARD - Warn if a type or return value is discarded.','line_number':99,'multiline':False]
['text':' Technically, we should check if __cplusplus > 201402L here, because','line_number':101,'multiline':False]
['text':' [[nodiscard]] is only defined in C++17.  However, some compilers','line_number':102,'multiline':False]
['text':' we care about don't advertise being C++17 (e.g., clang), but','line_number':103,'multiline':False]
['text':' support the attribute anyway.  In fact, this is not just a good idea,','line_number':104,'multiline':False]
['text':' it's the law: clang::warn_unused_result doesn't work on nvcc + clang','line_number':105,'multiline':False]
['text':' and the best workaround for this case is to use [[nodiscard]]','line_number':106,'multiline':False]
['text':' instead; see https://github.com/pytorch/pytorch/issues/13118','line_number':107,'multiline':False]
['text':'','line_number':108,'multiline':False]
['text':' Note to future editors: if you have noticed that a compiler is','line_number':109,'multiline':False]
['text':' misbehaving (e.g., it advertises support, but the support doesn't','line_number':110,'multiline':False]
['text':' actually work, or it is emitting warnings).  Some compilers which','line_number':111,'multiline':False]
['text':' are strict about the matter include MSVC, which will complain:','line_number':112,'multiline':False]
['text':'','line_number':113,'multiline':False]
['text':'  error C2429: attribute 'nodiscard' requires compiler flag '/std:c++latest'','line_number':114,'multiline':False]
['text':'','line_number':115,'multiline':False]
['text':' Exhibits:','line_number':116,'multiline':False]
['text':'  - MSVC 19.14: https://godbolt.org/z/Dzd7gn (requires /std:c++latest)','line_number':117,'multiline':False]
['text':'  - Clang 8.0.0: https://godbolt.org/z/3PYL4Z (always advertises support)','line_number':118,'multiline':False]
['text':'  - gcc 8.3: https://godbolt.org/z/4tLMQS (always advertises support)','line_number':119,'multiline':False]
['text':' Workaround for llvm.org/PR23435, since clang 3.6 and below emit a spurious','line_number':122,'multiline':False]
['text':' error when __has_cpp_attribute is given a scoped attribute in C mode.','line_number':123,'multiline':False]
['text':' TODO: It's possible this is still triggering','line_number':125,'multiline':False]
['text':' https://github.com/pytorch/pytorch/issues/13118 on Windows; if it is, better','line_number':126,'multiline':False]
['text':' fix it.','line_number':127,'multiline':False]
['text':' suppress an unused variable.','line_number':133,'multiline':False]
['text':'_MSC_VER','line_number':138,'multiline':False]
['text':' Direct port of LLVM_ATTRIBUTE_USED.','line_number':144,'multiline':False]
['text':' Simply define the namespace, in case a dependent library want to refer to','line_number':153,'multiline':False]
['text':' the c10 namespace but not any nontrivial files.','line_number':154,'multiline':False]
['text':' namespace c10','line_number':155,'multiline':False]
['text':' namespace c10','line_number':158,'multiline':False]
['text':' namespace c10','line_number':161,'multiline':False]
['text':' Since C10 is the core library for caffe2 (and aten), we will simply reroute','line_number':163,'multiline':False]
['text':' all abstractions defined in c10 to be available in caffe2 as well.','line_number':164,'multiline':False]
['text':' This is only for backwards compatibility. Please use the symbols from the','line_number':165,'multiline':False]
['text':' c10 namespace where possible.','line_number':166,'multiline':False]
['text':' namespace at','line_number':177,'multiline':False]
['text':' WARNING!!! THIS IS A GIANT HACK!!!','line_number':179,'multiline':False]
['text':' This line means you cannot simultaneously include c10/hip','line_number':180,'multiline':False]
['text':' and c10/cuda and then use them from the at::cuda namespace.','line_number':181,'multiline':False]
['text':' This is true in practice, because HIPIFY works inplace on','line_number':182,'multiline':False]
['text':' files in ATen/cuda, so it assumes that c10::hip is available','line_number':183,'multiline':False]
['text':' from at::cuda.  This namespace makes that happen.  When','line_number':184,'multiline':False]
['text':' HIPIFY is no longer out-of-place, we can switch the cuda','line_number':185,'multiline':False]
['text':' here to hip and everyone is happy.','line_number':186,'multiline':False]
['text':' namespace at','line_number':191,'multiline':False]
['text':' C10_LIKELY/C10_UNLIKELY','line_number':193,'multiline':False]
['text':'','line_number':194,'multiline':False]
['text':' These macros provide parentheses, so you can use these macros as:','line_number':195,'multiline':False]
['text':'','line_number':196,'multiline':False]
['text':'    if C10_LIKELY(some_expr) {','line_number':197,'multiline':False]
['text':'      ...','line_number':198,'multiline':False]
['text':'    }','line_number':199,'multiline':False]
['text':'','line_number':200,'multiline':False]
['text':' NB: static_cast to boolean is mandatory in C++, because __builtin_expect','line_number':201,'multiline':False]
['text':' takes a long argument, which means you may trigger the wrong conversion','line_number':202,'multiline':False]
['text':' without it.','line_number':203,'multiline':False]
['text':'','line_number':204,'multiline':False]
['text':'/ C10_NOINLINE - Functions whose declaration is annotated with this will not','line_number':213,'multiline':False]
['text':'/ be inlined.','line_number':214,'multiline':False]
['text':' C10_FALLTHROUGH - Annotate fallthrough to the next case in a switch.','line_number':241,'multiline':False]
['text':' Unlike CUDA, HIP requires a HIP header to be included for __host__ to work.','line_number':251,'multiline':False]
['text':' We do this #include here so that C10_HOST_DEVICE and friends will Just Work.','line_number':252,'multiline':False]
['text':' See https://github.com/ROCm-Developer-Tools/HIP/issues/441','line_number':253,'multiline':False]
['text':' Designates functions callable from the host (CPU) and the device (GPU)','line_number':258,'multiline':False]
['text':' constants from','line_number':262,'multiline':False]
['text':' (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#features-and-technical-specifications)','line_number':263,'multiline':False]
['text':' The maximum number of threads per multiprocessor is 1024 for Turing','line_number':264,'multiline':False]
['text':' architecture (7.5), 1536 for Geforce Ampere (8.6)/Jetson Orin (8.7), and','line_number':265,'multiline':False]
['text':' 2048 for all other architectures. You'll get warnings if you exceed these','line_number':266,'multiline':False]
['text':' constants. Hence, the following macros adjust the input values from the user','line_number':267,'multiline':False]
['text':' to resolve potential warnings.','line_number':268,'multiline':False]
['text':' CUDA_MAX_THREADS_PER_BLOCK is same for all architectures currently','line_number':276,'multiline':False]
['text':' CUDA_THREADS_PER_BLOCK_FALLBACK is the "canonical fallback" choice of block','line_number':278,'multiline':False]
['text':' size. 256 is a good number for this fallback and should give good occupancy','line_number':279,'multiline':False]
['text':' and versatility across all architectures.','line_number':280,'multiline':False]
['text':' NOTE: if you are thinking of constexpr-ify the inputs to launch bounds, it','line_number':282,'multiline':False]
['text':'       turns out that although __launch_bounds__ can take constexpr, it','line_number':283,'multiline':False]
['text':'       can't take a constexpr that has anything to do with templates.','line_number':284,'multiline':False]
['text':'       Currently we use launch_bounds that depend on template arguments in','line_number':285,'multiline':False]
['text':'       Loops.cuh, Reduce.cuh and LossCTC.cuh. Hence, C10_MAX_THREADS_PER_BLOCK','line_number':286,'multiline':False]
['text':'       and C10_MIN_BLOCKS_PER_SM are kept as macros.','line_number':287,'multiline':False]
['text':' Suppose you were planning to write __launch_bounds__(a, b), based on your','line_number':288,'multiline':False]
['text':' performance tuning on a modern GPU. Instead, you should write','line_number':289,'multiline':False]
['text':' __launch_bounds__(C10_MAX_THREADS_PER_BLOCK(a), C10_MIN_BLOCKS_PER_SM(a, b)),','line_number':290,'multiline':False]
['text':' which will also properly respect limits on old architectures.','line_number':291,'multiline':False]
['text':' C10_LAUNCH_BOUNDS is analogous to __launch_bounds__','line_number':300,'multiline':False]
['text':' default launch bounds that should give good occupancy and','line_number':303,'multiline':False]
['text':' versatility across all architectures.','line_number':304,'multiline':False]
['text':' = 64 or 32 (Defined in hip_runtime.h)','line_number':324,'multiline':False]
['text':' CUDA_KERNEL_ASSERT checks the assertion','line_number':333,'multiline':False]
['text':' even when NDEBUG is defined. This is useful for important assertions in CUDA','line_number':334,'multiline':False]
['text':' code that would otherwise be suppressed when building Release.','line_number':335,'multiline':False]
['text':' Those platforms do not support assert()','line_number':338,'multiline':False]
['text':' __CUDA_ARCH__','line_number':353,'multiline':False]
['text':' __SYCL_DEVICE_ONLY__','line_number':356,'multiline':False]
['text':' NDEBUG','line_number':358,'multiline':False]
['text':' __APPLE__, _MSC_VER','line_number':367,'multiline':False]
['text':' __SYCL_DEVICE_ONLY__','line_number':376,'multiline':False]
['text':' CUDA supports __assert_fail function which are common for both device','line_number':378,'multiline':False]
['text':' and host side code.','line_number':379,'multiline':False]
['text':' This forward declaration matching the declaration of __assert_fail','line_number':383,'multiline':False]
['text':' exactly how it is in glibc in case parts of the program are compiled with','line_number':384,'multiline':False]
['text':' different NDEBUG settings. Otherwise we might get 'ambiguous declaration'','line_number':385,'multiline':False]
['text':' error. Note: On ROCm - this declaration serves for host side compilation.','line_number':386,'multiline':False]
['text':' __SYCL_DEVICE_ONLY__','line_number':394,'multiline':False]
['text':' NDEBUG','line_number':396,'multiline':False]
['text':' ROCm disable kernel assert by default','line_number':397,'multiline':False]
['text':'  C10_USE_ROCM_KERNEL_ASSERT and USE_ROCM','line_number':412,'multiline':False]
['text':' __APPLE__','line_number':413,'multiline':False]
['text':' ANDROID / IOS','line_number':427,'multiline':False]
['text':' Portable determination of whether type T is trivially copyable.','line_number':435,'multiline':False]
['text':' Warning: __has_trivial_copy for GCC may not always detect the non-POD','line_number':436,'multiline':False]
['text':' correctly. For example, T = std::unique_ptr may evaluate to true and be','line_number':437,'multiline':False]
['text':' treated as POD. This can cause unexpected behavior.','line_number':438,'multiline':False]
['text':' Note [static constexpr char* members for windows NVCC]','line_number':450,'multiline':False]
['text':' The Windows NVCC compiler doesn't handle static constexpr class members,','line_number':451,'multiline':False]
['text':' although it's fixed in a later version.','line_number':452,'multiline':False]
['text':' (see','line_number':453,'multiline':False]
['text':' https://developercommunity.visualstudio.com/t/intellisense-error-c11-static-constexpr-member-ini/245425)','line_number':454,'multiline':False]
['text':'','line_number':455,'multiline':False]
['text':' If we want to ensure that our field is static under all builds, then we need','line_number':456,'multiline':False]
['text':' to work around it specifically for windows NVCC by making it (a) const, (b)','line_number':457,'multiline':False]
['text':' defined outside of the class definition We need to define it outside of the','line_number':458,'multiline':False]
['text':' class definition because of the C++ standard; char* is not an integral type','line_number':459,'multiline':False]
['text':' (see','line_number':460,'multiline':False]
['text':' https://stackoverflow.com/questions/24278473/intellisense-a-member-of-type-const-char-const-cannot-have-an-in-class-in)','line_number':461,'multiline':False]
['text':'','line_number':462,'multiline':False]
['text':' So instead of this:','line_number':463,'multiline':False]
['text':' struct Foo {','line_number':464,'multiline':False]
['text':'     static constexpr const char* name = "foo";','line_number':465,'multiline':False]
['text':' }','line_number':466,'multiline':False]
['text':' In Windows NVCC, we end up with this:','line_number':467,'multiline':False]
['text':' struct Foo {','line_number':468,'multiline':False]
['text':'     static const char* name;','line_number':469,'multiline':False]
['text':' }','line_number':470,'multiline':False]
['text':' const char* Foo::name = "foo";','line_number':471,'multiline':False]
['text':'','line_number':472,'multiline':False]
['text':' This gives us a small perf hit for any code that wants to access these field','line_number':473,'multiline':False]
['text':' members, but right now it isn't used in any perf-critical code paths.','line_number':474,'multiline':False]
['text':' HAS_DEMANGLE','line_number':515,'multiline':False]
['text':' C10_MACROS_MACROS_H_','line_number':558,'multiline':False]
