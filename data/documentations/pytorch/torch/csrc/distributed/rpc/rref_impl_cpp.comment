['text':' If the type is subtype of named type, return its qualifiedname, otherwise','line_number':14,'multiline':False]
['text':' return its type str.','line_number':15,'multiline':False]
['text':' namespace','line_number':31,'multiline':False]
['text':'////////////////////////  RRefForkData  /////////////////////////////////','line_number':39,'multiline':False]
['text':'////////////////////////////  RRef  /////////////////////////////////////','line_number':53,'multiline':False]
['text':' unused ','line_number':78,'multiline':True]
['text':' unused ','line_number':80,'multiline':True]
['text':' Default error handler','line_number':82,'multiline':False]
['text':'////////////////////////  UserRRef  /////////////////////////////////////','line_number':88,'multiline':False]
['text':' Do nothing,','line_number':98,'multiline':False]
['text':' (1) If this UserRRef is a fork of an existing RRef, RRefContext will send','line_number':99,'multiline':False]
['text':'     a RREF_FORK_REQUEST message to the owner.','line_number':100,'multiline':False]
['text':' (2) If this the creator UserRRef, ScriptRemoteCall or PythonRemoteCall will','line_number':101,'multiline':False]
['text':'     properly notify the owner.','line_number':102,'multiline':False]
['text':' see Note [Best-Effort Check on Deleted UserRRefs]','line_number':138,'multiline':False]
['text':' ScriptRRefFetchCall message always carries autograd context id even if','line_number':164,'multiline':False]
['text':' the message itself does not contain any tensor, because the response would','line_number':165,'multiline':False]
['text':' potentially contain tensors.','line_number':166,'multiline':False]
['text':' toHere is profiled as a blocking call, and does not execute operations on','line_number':175,'multiline':False]
['text':' the remote node. Hence, don't wrap it with a profiling message since we','line_number':176,'multiline':False]
['text':' don't need the profiler to be enabled remotely.','line_number':177,'multiline':False]
['text':' forceGradRecording ','line_number':182,'multiline':True]
['text':' forceDisableProfiling ','line_number':184,'multiline':True]
['text':' TODO: we should ideally be able to interrupt this blocking wait if we check','line_number':186,'multiline':False]
['text':' getTimedOut() and it is true','line_number':187,'multiline':False]
['text':' (https://github.com/pytorch/pytorch/issues/39411).','line_number':188,'multiline':False]
['text':' wrap python serialized vector of ivalues into tuple, this','line_number':201,'multiline':False]
['text':' made the C++ toHere interface to return single IValue','line_number':202,'multiline':False]
['text':' Note [Best-Effort Check on Deleted UserRRefs]','line_number':210,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':211,'multiline':False]
['text':' This check does not guarantee correctness, as there could be another thread','line_number':212,'multiline':False]
['text':' trying to delete this UserRRef concurrently. Passing this check does not','line_number':213,'multiline':False]
['text':' mean this RRef will be alive throughout this function. This is just our','line_number':214,'multiline':False]
['text':' best-effort attempt to raise proper error messages. The behavior of using','line_number':215,'multiline':False]
['text':' deleted UserRRefs is undefined.','line_number':216,'multiline':False]
['text':'','line_number':217,'multiline':False]
['text':' The reason for not implementing strict checks are:','line_number':218,'multiline':False]
['text':' 1. This would need to acquire lock on deletedOnOwnerMutex_, which would','line_number':219,'multiline':False]
['text':'    introduce unnecessary overhead for most normal use cases.','line_number':220,'multiline':False]
['text':' 2. This would introduce a lot of complexities to get the behavior correct.','line_number':221,'multiline':False]
['text':'    Assume we acquired the lock here, and there is another thread X block','line_number':222,'multiline':False]
['text':'    waiting in tryDel() on the lock. Exiting this fork function would','line_number':223,'multiline':False]
['text':'    unblock thread X. However, while X proceeds with deleting this UserRRef,','line_number':224,'multiline':False]
['text':'    the call site of fork() might have added the UserRRef to','line_number':225,'multiline':False]
['text':'    pendingChildren_ map, but up to this point, nothing prevents X from','line_number':226,'multiline':False]
['text':'    deleting this RRef even if it shouldn't do so due to the state change','line_number':227,'multiline':False]
['text':'    in pendingChildren_. We might be able to get it right for now by locking','line_number':228,'multiline':False]
['text':'    and checking pendingChildren_ in X, but the gain does not seem to','line_number':229,'multiline':False]
['text':'    worth the complexity.','line_number':230,'multiline':False]
['text':'////////////////////////  OwnerRRef  /////////////////////////////////////','line_number':238,'multiline':False]
['text':' value ','line_number':245,'multiline':True]
['text':' namespace rpc','line_number':298,'multiline':False]
['text':' namespace distributed','line_number':299,'multiline':False]
['text':' namespace torch','line_number':300,'multiline':False]
