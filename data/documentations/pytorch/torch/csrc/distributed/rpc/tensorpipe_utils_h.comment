['text':' namespace tensorpipe','line_number':11,'multiline':False]
['text':' Inspired by c10/core/impl/DeviceGuardImplInterface.h.','line_number':21,'multiline':False]
['text':' Ideally we'd want this to also return a tensorpipe::Message::Tensor object','line_number':25,'multiline':False]
['text':' but we cannot forward-declare that class (because it's nested), and we','line_number':26,'multiline':False]
['text':' cannot include the TensorPipe headers because it's a private dependency.','line_number':27,'multiline':False]
['text':' Thus we bend over backwards and entrust this method with appending that','line_number':28,'multiline':False]
['text':' object to the `tensors` field of the tensorpipe::Message object we pass.','line_number':29,'multiline':False]
['text':' Same as above: this method cannot return a tensorpipe::Allocation::Tensor,','line_number':35,'multiline':False]
['text':' thus it appends it to the `tensors` field of the tensorpipe::Allocation.','line_number':36,'multiline':False]
['text':' A struct that holds pointers that keep alive all the memory that will be','line_number':69,'multiline':False]
['text':' accessed by TensorPipe during a write operation.','line_number':70,'multiline':False]
['text':' Allocate on heap so pointers stay valid as we move the holder.','line_number':72,'multiline':False]
['text':' This contains the original tensors and the clones of the sparse tensors.','line_number':77,'multiline':False]
['text':' This contains the copies of the data of the tensors that didn't own their','line_number':79,'multiline':False]
['text':' memory, e.g., the ones created from torch::from_blob() with no deleter.','line_number':80,'multiline':False]
['text':' A struct that holds pointers that keep alive all the memory that will be','line_number':84,'multiline':False]
['text':' accessed by TensorPipe during a read operation.','line_number':85,'multiline':False]
['text':' Allocate on heap so pointers stay valid as we move the holder.','line_number':87,'multiline':False]
['text':' Convert an RPC message into a TensorPipe message, plus a holder to all the','line_number':95,'multiline':False]
['text':' data that must be kept alive while the write is performed asynchronously.','line_number':96,'multiline':False]
['text':' Allocate the buffers that will hold the incoming data. They will be managed','line_number':103,'multiline':False]
['text':' by the returned holder, which must be kept alive until the asynchronous read','line_number':104,'multiline':False]
['text':' has finished. Pointers to these buffers will be stored in the returned','line_number':105,'multiline':False]
['text':' tensorpipe::Allocation struct.','line_number':106,'multiline':False]
['text':' Convert a TensorPipe message back into an RPC message. This requires the data','line_number':112,'multiline':False]
['text':' to be available and can thus only be performed once the asynchronous read has','line_number':113,'multiline':False]
['text':' completed. The holder can be destroyed once this function returns.','line_number':114,'multiline':False]
['text':' namespace rpc','line_number':119,'multiline':False]
['text':' namespace distributed','line_number':120,'multiline':False]
['text':' namespace torch','line_number':121,'multiline':False]
['text':' USE_TENSORPIPE','line_number':123,'multiline':False]
