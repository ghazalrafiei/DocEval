['text':'/ Interface for chunk reader, which performs data chunking and reading of','line_number':16,'multiline':False]
['text':'/ entire chunks.','line_number':17,'multiline':False]
['text':'/','line_number':18,'multiline':False]
['text':'/ A chunk could be an entire file, such as an audio data file or an image,','line_number':19,'multiline':False]
['text':'/ or part of a file in the case of a large text-file split based on seek','line_number':20,'multiline':False]
['text':'/ positions.','line_number':21,'multiline':False]
['text':'/ Read an entire chunk.','line_number':32,'multiline':False]
['text':'/ Returns the number of chunks available in this reader.','line_number':35,'multiline':False]
['text':'/ This will clear any internal state associate with this reader.','line_number':38,'multiline':False]
['text':'/ BatchDataBuffer manages a queue of UnwrappedBatchData. After a new chunk is','line_number':43,'multiline':False]
['text':'/ loaded, BatchDataBuffer splits it into small batches and push them into the','line_number':44,'multiline':False]
['text':'/ queue. When get_batch is called from data loader, it pops cached batches and','line_number':45,'multiline':False]
['text':'/ return. If the cache is empty, it either waits to load more chunks or return','line_number':46,'multiline':False]
['text':'/ null if all chunks are loaded.','line_number':47,'multiline':False]
['text':'/ Return batch data from the queue. Called from the ChunkDataset main','line_number':65,'multiline':False]
['text':'/ thread.','line_number':66,'multiline':False]
['text':' wait till there is available data in the queue or if all chunks are','line_number':70,'multiline':False]
['text':' loaded (i.e. the dataset is exhausted for this epoch)','line_number':71,'multiline':False]
['text':' All batches have been retrieved. Return an empty batch.','line_number':77,'multiline':False]
['text':'/ Push preloaded chunks to batch queue. Called from the ChunkDataset worker','line_number':94,'multiline':False]
['text':'/ threads.','line_number':95,'multiline':False]
['text':' stop loading if we have preloaded enough data.','line_number':99,'multiline':False]
['text':' When stop_ is true, it means no further chunk loading is necessary.','line_number':104,'multiline':False]
['text':' Return without any further processing.','line_number':105,'multiline':False]
['text':' if the queue has existing data, and the last batch doesn't have enough','line_number':127,'multiline':False]
['text':' examples to fill a batch_size batch, add more example to this batch','line_number':128,'multiline':False]
['text':' first.','line_number':129,'multiline':False]
['text':' If we still have data remaining after filling the last pushed batch, add','line_number':139,'multiline':False]
['text':' them to the queue too.','line_number':140,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-infinite-loop)','line_number':141,'multiline':False]
['text':' Allocate the batch memory ahead of time.','line_number':145,'multiline':False]
['text':'/ Push exceptions thrown during preloading into batch queue. Called from','line_number':157,'multiline':False]
['text':'/ the ChunkDataset worker threads.','line_number':158,'multiline':False]
['text':' stop loading if we have preloaded enough data.','line_number':162,'multiline':False]
['text':' When stop_ is true, it means this current thread needs to be tore down,','line_number':168,'multiline':False]
['text':' the batch buffer will be discarded, so no need to enqueue any new','line_number':169,'multiline':False]
['text':' exceptions.','line_number':170,'multiline':False]
['text':' Hold the lock before changing stop_ to prevent a race condition which','line_number':181,'multiline':False]
['text':' can cause a deadlock. To be more specific, conditional variable','line_number':182,'multiline':False]
['text':' cv_write_ waits on predicate stop_ in add_chunk_data(). The wait','line_number':183,'multiline':False]
['text':' happens in two steps: 1) while still holding the lock, check if','line_number':184,'multiline':False]
['text':' predicate is true; 2) if it is true, proceeds, otherwise, release the','line_number':185,'multiline':False]
['text':' lock and wait until notified. Without holding a lock, cv_write_'s','line_number':186,'multiline':False]
['text':' notification can happen in between step 1) and 2). In that case, as','line_number':187,'multiline':False]
['text':' cv_write_ is not in waiting status yet, so the notification is lost and','line_number':188,'multiline':False]
['text':' cv_write_ will sleep forever. By taking a lock before changing','line_number':189,'multiline':False]
['text':' predicate stop_, it is ensured updating and evaluating stop_ always','line_number':190,'multiline':False]
['text':' happen in a synchronized way','line_number':191,'multiline':False]
['text':' notify all writers, wake them from wait to exit current method.','line_number':196,'multiline':False]
['text':' notify all readers too.','line_number':198,'multiline':False]
['text':'/ The batch size is needed to create batches from the chunk data. Similar to','line_number':201,'multiline':False]
['text':'/ regular dataloader where the batches are created with prefetches,','line_number':202,'multiline':False]
['text':'/ BatchDataBuffer perform the batch creation using the provided batch size.','line_number':203,'multiline':False]
['text':'/ count of total example stored in the queue','line_number':206,'multiline':False]
['text':'/ struct that contains a raw unwrapped batch unit. An unwrapped batch unit','line_number':209,'multiline':False]
['text':'/ is the raw data without 'optional' wrapper. It can be a collection of','line_number':210,'multiline':False]
['text':'/ images, utterances, e.t.c.','line_number':211,'multiline':False]
['text':' NOLINTNEXTLINE(modernize-pass-by-value)','line_number':216,'multiline':False]
['text':'/ batch data to return','line_number':219,'multiline':False]
['text':'/ exception pointer which captures any abnormal exceptions while creating','line_number':222,'multiline':False]
['text':'/ the batch.','line_number':223,'multiline':False]
['text':'/ local cache to store example batches from loaded chunk','line_number':227,'multiline':False]
['text':' sync batch_queue_ update.','line_number':230,'multiline':False]
['text':' configurable maximun number of elements the queue can hold at one time.','line_number':238,'multiline':False]
['text':' When set to true, it wakes the writer threads from the wait and exit','line_number':241,'multiline':False]
['text':' current function call. This is needed when ChunkDataSet.Reset is called','line_number':242,'multiline':False]
['text':' while the previous epoch is not exhausted yet. When ChunkDataset is waiting','line_number':243,'multiline':False]
['text':' its preloader to finish previous work before tearing down the thread, the','line_number':244,'multiline':False]
['text':' preloader could be still waiting for the conditional variable, thus cause','line_number':245,'multiline':False]
['text':' the program to hang. This boolean is used to break this waiting condition.','line_number':246,'multiline':False]
['text':' namespace detail','line_number':249,'multiline':False]
['text':'/ Options to configure a `ChunkDataset`.','line_number':251,'multiline':False]
['text':'/ The number of worker thread to preload chunk data.','line_number':281,'multiline':False]
['text':'/ The size of each batch.','line_number':284,'multiline':False]
['text':'/ The capacity of the queue for batch caching.','line_number':287,'multiline':False]
['text':' The number of chunks to perfrom cross-chunk shuffling. Default to 1 meaning','line_number':290,'multiline':False]
['text':' no cross-chunk shuffling. When it is equal to n (n > 1), n random','line_number':291,'multiline':False]
['text':' chunks will be loaded at once and example shuffling will be performed','line_number':292,'multiline':False]
['text':' across all those n chunks.','line_number':293,'multiline':False]
['text':' Note: Usually the default config (1 chunk shuffle + example shuffle) is','line_number':294,'multiline':False]
['text':' good enough to generate random distributed data. Use this parameter only if','line_number':295,'multiline':False]
['text':' you know cross-shuffle is needed in your case. Also there is a performance','line_number':296,'multiline':False]
['text':' penalty when this value is greater than 1, as we need to do extra merge','line_number':297,'multiline':False]
['text':' between multiple chunks before performing example sampling.','line_number':298,'multiline':False]
['text':'/ A stateful dataset that support hierarchical sampling and prefetching of','line_number':302,'multiline':False]
['text':'/ entre chunks.','line_number':303,'multiline':False]
['text':'/','line_number':304,'multiline':False]
['text':'/ Unlike regular dataset, chunk dataset require two samplers to operate and','line_number':305,'multiline':False]
['text':'/ keeps an internal state. `ChunkSampler` selects, which chunk to load next,','line_number':306,'multiline':False]
['text':'/ while the `ExampleSampler` determins the order of Examples that are returned','line_number':307,'multiline':False]
['text':'/ in each `get_batch` call. The hierarchical sampling approach used here is','line_number':308,'multiline':False]
['text':'/ inspired by this paper http://martin.zinkevich.org/publications/nips2010.pdf','line_number':309,'multiline':False]
['text':' stop batch buffer first.','line_number':343,'multiline':False]
['text':'/ Default get_batch method of BatchDataset. This method returns','line_number':350,'multiline':False]
['text':'/ Example batches created from the preloaded chunks. The implemenation','line_number':351,'multiline':False]
['text':'/ is dataset agnostic and does not need overriding in different chunk','line_number':352,'multiline':False]
['text':'/ datasets.','line_number':353,'multiline':False]
['text':'/ Helper method around get_batch as `batch_size` is not strictly necessary','line_number':369,'multiline':False]
['text':'/ This will clear any internal state and starts the internal prefetching','line_number':374,'multiline':False]
['text':'/ mechanism for the chunk dataset.','line_number':375,'multiline':False]
['text':' We need this to support partial data reads via dataloader iterator.','line_number':377,'multiline':False]
['text':' free workers from previous reset if there is any.','line_number':381,'multiline':False]
['text':' Throw out any existing cached batch in the buffer and re-creates a new','line_number':391,'multiline':False]
['text':' chunk buffer.','line_number':392,'multiline':False]
['text':' create new workers for this new epoch.','line_number':397,'multiline':False]
['text':'/ size is not used for chunk dataset.','line_number':407,'multiline':False]
['text':' provide a references to chunk sampler. Used mainly in distributed data','line_number':412,'multiline':False]
['text':' loading to set the epoch number for the sampler.','line_number':413,'multiline':False]
['text':'/ running on worker thread to preload chunk data.','line_number':430,'multiline':False]
['text':' skip empty chunks.','line_number':453,'multiline':False]
['text':' all preloaders are completed, so we can notify the batch_buffer.','line_number':463,'multiline':False]
['text':'/ Block the current thread until the workers finish execution and exit.','line_number':468,'multiline':False]
['text':' Templated class that defines what is a chunk and how to read chunk data.','line_number':479,'multiline':False]
['text':' When a chunk is returned by chunk_reader_, ChunkDataset split it into','line_number':480,'multiline':False]
['text':' batches and caches them in batch_buffer_.','line_number':481,'multiline':False]
['text':' chunk sampler to shuffle different chunks','line_number':484,'multiline':False]
['text':' example sampler to shuffle examples in a specific chunk','line_number':487,'multiline':False]
['text':' batch data buffer which holds chunk data from preloading thread.','line_number':490,'multiline':False]
['text':' worker thread pool','line_number':495,'multiline':False]
['text':'/ The options the Dataset was configured with.','line_number':498,'multiline':False]
['text':' function pointer wrapper to apply custom processing over chunk data. This','line_number':501,'multiline':False]
['text':' is considered an advanced parameter for developers who want to apply a','line_number':502,'multiline':False]
['text':' pre-process to the chunk data before sampling into minibatch.','line_number':503,'multiline':False]
['text':' Different than the collate function, this policy is applied on the chunk','line_number':504,'multiline':False]
['text':' level, instead of minibatch level. When a chunk of data is loaded (multiple','line_number':505,'multiline':False]
['text':' chunks if cross_chunk_shuffle_count_ is greater than 1), this policy is','line_number':506,'multiline':False]
['text':' applied to the full loaded data. It is useful if developers want to','line_number':507,'multiline':False]
['text':' perform pre-processing (like bucketing) to the chunk data before','line_number':508,'multiline':False]
['text':' example sampler samples the data. By default it's an empty pointer and no','line_number':509,'multiline':False]
['text':' action will be taken.','line_number':510,'multiline':False]
['text':' indicate whether the worker thread can be teared down','line_number':513,'multiline':False]
['text':' keep track of running preloaders to notify batch buffer. A value 0','line_number':516,'multiline':False]
['text':' indicates that the chunk loading is completed.','line_number':517,'multiline':False]
['text':' mutex to synchronize chunk sampler next() call.','line_number':520,'multiline':False]
['text':' boolean value to indicate whether we need to load the checkpoint for','line_number':523,'multiline':False]
['text':' chunk_sampler_.','line_number':524,'multiline':False]
['text':' namespace datasets','line_number':527,'multiline':False]
['text':' namespace data','line_number':528,'multiline':False]
['text':' namespace torch','line_number':529,'multiline':False]
