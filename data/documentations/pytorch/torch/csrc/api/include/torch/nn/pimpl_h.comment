['text':' Dump all the template metaprogramming in this file.','line_number':16,'multiline':False]
['text':' namespace detail','line_number':18,'multiline':False]
['text':'/ A `ModuleHolder` is essentially a wrapper around `std::shared_ptr<M>` where','line_number':22,'multiline':False]
['text':'/ `M` is an `nn::Module` subclass, with convenient constructors defined for','line_number':23,'multiline':False]
['text':'/ the kind of constructions we want to allow for our modules.','line_number':24,'multiline':False]
['text':'/ The module pointer this class wraps.','line_number':28,'multiline':False]
['text':'/ NOTE: Must be placed at the top of the class so that we can use it with','line_number':29,'multiline':False]
['text':'/ trailing return types below.','line_number':30,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':31,'multiline':False]
['text':'/ Default constructs the contained module if if has a default constructor,','line_number':37,'multiline':False]
['text':'/ else produces a static error.','line_number':38,'multiline':False]
['text':'/','line_number':39,'multiline':False]
['text':'/ NOTE: This uses the behavior of template','line_number':40,'multiline':False]
['text':'/ classes in C++ that constructors (or any methods) are only compiled when','line_number':41,'multiline':False]
['text':'/ actually used.','line_number':42,'multiline':False]
['text':'/ Constructs the `ModuleHolder` with an empty contained value. Access to','line_number':51,'multiline':False]
['text':'/ the underlying module is not permitted and will throw an exception, until','line_number':52,'multiline':False]
['text':'/ a value is assigned.','line_number':53,'multiline':False]
['text':' implicit ','line_number':54,'multiline':True]
['text':'/ Constructs the `ModuleHolder` with a contained module, forwarding all','line_number':56,'multiline':False]
['text':'/ arguments to its constructor.','line_number':57,'multiline':False]
['text':'/ Constructs the `ModuleHolder` from a pointer to the contained type.','line_number':69,'multiline':False]
['text':'/ Example: `Linear(std::make_shared<LinearImpl>(...))`.','line_number':70,'multiline':False]
['text':' implicit ','line_number':71,'multiline':True]
['text':'/ Returns true if the `ModuleHolder` contains a module, or false if it is','line_number':74,'multiline':False]
['text':'/ `nullptr`.','line_number':75,'multiline':False]
['text':'/ Forwards to the contained module.','line_number':80,'multiline':False]
['text':'/ Forwards to the contained module.','line_number':85,'multiline':False]
['text':'/ Returns a reference to the contained module.','line_number':90,'multiline':False]
['text':'/ Returns a const reference to the contained module.','line_number':95,'multiline':False]
['text':'/ Returns a shared pointer to the underlying module.','line_number':100,'multiline':False]
['text':'/ Returns a pointer to the underlying module.','line_number':106,'multiline':False]
['text':'/ Returns a const pointer to the underlying module.','line_number':112,'multiline':False]
['text':'/ Calls the `forward()` method of the contained module.','line_number':118,'multiline':False]
['text':' This will not compile if the module does not have a `forward()` method','line_number':122,'multiline':False]
['text':' (as expected).','line_number':123,'multiline':False]
['text':' NOTE: `std::forward` is qualified to prevent VS2017 emitting','line_number':124,'multiline':False]
['text':' error C2872: 'std': ambiguous symbol','line_number':125,'multiline':False]
['text':'/ Forwards to the subscript operator of the contained module.','line_number':129,'multiline':False]
['text':'/ NOTE: std::forward is qualified to prevent VS2017 emitting','line_number':130,'multiline':False]
['text':'/       error C2872: 'std': ambiguous symbol','line_number':131,'multiline':False]
['text':'/ Returns true if the `ModuleHolder` does not contain a module.','line_number':137,'multiline':False]
['text':'/ In C++17, the two methods below could be written as the following:','line_number':143,'multiline':False]
['text':'/ if constexpr (std::is_default_constructible_v<Contained>) {','line_number':144,'multiline':False]
['text':'/   return std::make_shared<Contained>();','line_number':145,'multiline':False]
['text':'/ } else {','line_number':146,'multiline':False]
['text':'/   return nullptr;','line_number':147,'multiline':False]
['text':'/ }','line_number':148,'multiline':False]
['text':'/ In C++11, we use SFINAE instead of `if constexpr`.','line_number':149,'multiline':False]
['text':'/ Pretty prints the given `Module` into the `ostream`.','line_number':167,'multiline':False]
['text':'/ Serializes a `ModuleHolder` into an `OutputArchive`.','line_number':175,'multiline':False]
['text':'/ Deserializes a `ModuleHolder` from an `InputArchive`.','line_number':183,'multiline':False]
['text':' namespace nn','line_number':191,'multiline':False]
['text':' namespace torch','line_number':192,'multiline':False]
['text':' Workaround for CUDA 10.2 and below not allowing attribute unused on','line_number':194,'multiline':False]
['text':' using declarations.','line_number':195,'multiline':False]
['text':'/ Defines a class `Name` which inherits from `nn::ModuleHolder` to provide a','line_number':202,'multiline':False]
['text':'/ wrapper over a `std::shared_ptr<ImplType>`.','line_number':203,'multiline':False]
['text':'/ `Impl` is a type alias for `ImplType` which provides a way to call static','line_number':204,'multiline':False]
['text':'/ method of `ImplType`.','line_number':205,'multiline':False]
['text':' NOLINT ','line_number':207,'multiline':True]
['text':'/ Like `TORCH_MODULE_IMPL`, but defaults the `ImplType` name to `<Name>Impl`.','line_number':213,'multiline':False]
