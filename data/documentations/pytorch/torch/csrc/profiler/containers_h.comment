['text':' ============================================================================','line_number':19,'multiline':False]
['text':' == AppendOnlyList ==========================================================','line_number':20,'multiline':False]
['text':' ============================================================================','line_number':21,'multiline':False]
['text':'   During profiling, we have a very predictable access pattern: we only','line_number':22,'multiline':False]
['text':' append to the end of the container. We can specialize and outperform both','line_number':23,'multiline':False]
['text':' std::vector (which must realloc) and std::deque (which performs a double','line_number':24,'multiline':False]
['text':' indirection), and this class of operation is sufficiently important to the','line_number':25,'multiline':False]
['text':' profiling hot path to warrant specializing:','line_number':26,'multiline':False]
['text':'   https://godbolt.org/z/rTjozf1c4','line_number':27,'multiline':False]
['text':'   https://quick-bench.com/q/mmfuu71ogwaiULDCJyHdKnHZms4    (Prototype #1,','line_number':28,'multiline':False]
['text':'   int) https://quick-bench.com/q/5vWDW6jjdXVdoffev2zst8D09no    (Prototype','line_number':29,'multiline':False]
['text':'   #1, int pair) https://quick-bench.com/q/IfEkfAQMeJSNBA52xtMP6Agcl-Q','line_number':30,'multiline':False]
['text':'   (Prototype #2, int pair)','line_number':31,'multiline':False]
['text':'   https://quick-bench.com/q/wJV2lKmuXL4XyGJzcI5hs4gEHFg    (Prototype #3, int','line_number':32,'multiline':False]
['text':'   pair) https://quick-bench.com/q/xiO8ZaBEkYRYUA9dFrMuPLlW9fo    (Full impl,','line_number':33,'multiline':False]
['text':'   int pair)','line_number':34,'multiline':False]
['text':' AppendOnlyList has 2x lower emplace overhead compared to more generic STL','line_number':35,'multiline':False]
['text':' containers.','line_number':36,'multiline':False]
['text':'','line_number':37,'multiline':False]
['text':'   The optimal value of `ChunkSize` will vary by use case, but testing shows','line_number':38,'multiline':False]
['text':' that a value of 1024 does a good job amortizing the `malloc` cost of growth.','line_number':39,'multiline':False]
['text':' Performance drops off for larger values, so testing on a case-by-case basis','line_number':40,'multiline':False]
['text':' is recommended if performance is absolutely critical.','line_number':41,'multiline':False]
['text':' We could chunk this into several `memcpy`s, but because we expect this','line_number':89,'multiline':False]
['text':' fallback to be infrequent (n << ChunkSize) the performance impact is','line_number':90,'multiline':False]
['text':' negligible.','line_number':91,'multiline':False]
['text':' End iterator.','line_number':116,'multiline':False]
['text':'checked=','line_number':124,'multiline':True]
['text':'checked=','line_number':127,'multiline':True]
['text':' Prefix increment','line_number':130,'multiline':False]
['text':' Postfix increment','line_number':138,'multiline':False]
['text':' TODO: cbegin and cend()','line_number':180,'multiline':False]
['text':' We maintain a pointer to the last element of `buffer_` so that we can','line_number':194,'multiline':False]
['text':' insert at the end in O(1) time.','line_number':195,'multiline':False]
['text':' namespace impl','line_number':204,'multiline':False]
['text':' namespace profiler','line_number':205,'multiline':False]
['text':' namespace torch','line_number':206,'multiline':False]
