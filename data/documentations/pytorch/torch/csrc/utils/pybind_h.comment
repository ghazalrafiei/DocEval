['text':' This makes intrusive_ptr to be available as a custom pybind11 holder type,','line_number':23,'multiline':False]
['text':' see','line_number':24,'multiline':False]
['text':' https://pybind11.readthedocs.io/en/stable/advanced/smart_ptrs.html#custom-smart-pointers','line_number':25,'multiline':False]
['text':' torch.Tensor <-> at::Tensor conversions (without unwrapping)','line_number':34,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':38,'multiline':False]
['text':' policy ','line_number':45,'multiline':True]
['text':' parent ','line_number':46,'multiline':True]
['text':' torch._StorageBase <-> at::Storage','line_number':49,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':53,'multiline':False]
['text':' policy ','line_number':67,'multiline':True]
['text':' parent ','line_number':68,'multiline':True]
['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':76,'multiline':False]
['text':' policy ','line_number':90,'multiline':True]
['text':' parent ','line_number':91,'multiline':True]
['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':99,'multiline':False]
['text':' policy ','line_number':105,'multiline':True]
['text':' parent ','line_number':106,'multiline':True]
['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':115,'multiline':False]
['text':' policy ','line_number':121,'multiline':True]
['text':' parent ','line_number':122,'multiline':True]
['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':131,'multiline':False]
['text':' policy ','line_number':137,'multiline':True]
['text':' parent ','line_number':138,'multiline':True]
['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':147,'multiline':False]
['text':' policy ','line_number':160,'multiline':True]
['text':' parent ','line_number':161,'multiline':True]
['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':169,'multiline':False]
['text':' PYBIND11_TYPE_CASTER defines a member field called value. Since at::Device','line_number':172,'multiline':False]
['text':' cannot be default-initialized, we provide this constructor to explicitly','line_number':173,'multiline':False]
['text':' initialize that field. The value doesn't matter as it will be overwritten','line_number':174,'multiline':False]
['text':' after a successful call to load.','line_number':175,'multiline':False]
['text':' policy ','line_number':189,'multiline':True]
['text':' parent ','line_number':190,'multiline':True]
['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':198,'multiline':False]
['text':' policy ','line_number':215,'multiline':True]
['text':' parent ','line_number':216,'multiline':True]
['text':' policy ','line_number':258,'multiline':True]
['text':' parent ','line_number':259,'multiline':True]
['text':' policy ','line_number':270,'multiline':True]
['text':' parent ','line_number':271,'multiline':True]
['text':' policy ','line_number':282,'multiline':True]
['text':' parent ','line_number':283,'multiline':True]
['text':' policy ','line_number':294,'multiline':True]
['text':' parent ','line_number':295,'multiline':True]
['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':301,'multiline':False]
['text':' Refered from `THPUtils_unpackComplexDouble`','line_number':307,'multiline':False]
['text':' Python's Complex is always double precision.','line_number':313,'multiline':False]
['text':' policy ','line_number':320,'multiline':True]
['text':' parent ','line_number':321,'multiline':True]
['text':' Python only knows double precision complex.','line_number':322,'multiline':False]
['text':' namespace detail','line_number':327,'multiline':False]
['text':' namespace pybind11','line_number':328,'multiline':False]
['text':' Use this function if you have a C++ object that is used from both C++','line_number':333,'multiline':False]
['text':' and Python contexts, and you need its GIL to be released when you','line_number':334,'multiline':False]
['text':' destruct it in the Python context.','line_number':335,'multiline':False]
['text':'','line_number':336,'multiline':False]
['text':' This function is a valid shared_ptr destructor and can be used to','line_number':337,'multiline':False]
['text':' conveniently allocate a shared_ptr to an object whose destructor will be run','line_number':338,'multiline':False]
['text':' without the GIL.  Pass it as the second argument to shared_ptr, e.g.,','line_number':339,'multiline':False]
['text':'','line_number':340,'multiline':False]
['text':'    shared_ptr<T>(new T(), destroy_without_gil<T>)','line_number':341,'multiline':False]
['text':'','line_number':342,'multiline':False]
['text':' Attaching the GIL release logic to the holder pointer rather than the','line_number':343,'multiline':False]
['text':' actual destructor of T is helpful when T is Python-agnostic and','line_number':344,'multiline':False]
['text':' shouldn't refer to the PYthon API.','line_number':345,'multiline':False]
['text':'','line_number':346,'multiline':False]
['text':' Note there are limitations to the correctness of code that makes use of this.','line_number':347,'multiline':False]
['text':' In particular, if a shared_ptr is constructed from C++ code without this','line_number':348,'multiline':False]
['text':' destructor and then passed to pybind11, pybind11 will happily take ownership','line_number':349,'multiline':False]
['text':' of the shared_ptr (and be willing to destruct it from a context where it is','line_number':350,'multiline':False]
['text':' holding the GIL).  unique_ptr with a type branded deleter is less prone to','line_number':351,'multiline':False]
['text':' this problem, because a stock deleter unique_ptr is not convertible with it.','line_number':352,'multiline':False]
['text':' I plan to mitigate this problem by adding DEBUG-only asserts to the true C++','line_number':353,'multiline':False]
['text':' destructors that the GIL is not held (using a virtual call to get to the','line_number':354,'multiline':False]
['text':' Python interpreter); alternately, we could use a virtual call to simply','line_number':355,'multiline':False]
['text':' ensure we release the GIL in the C++ destructor, however, this is a layering','line_number':356,'multiline':False]
['text':' violation (why does code that is ostensibly Python agnostic calling into the','line_number':357,'multiline':False]
['text':' GIL).','line_number':358,'multiline':False]
['text':'','line_number':359,'multiline':False]
['text':' Adapted from','line_number':360,'multiline':False]
['text':' https://github.com/pybind/pybind11/issues/1446#issuecomment-406341510','line_number':361,'multiline':False]
['text':' Because the ownership of a shared_ptr is diffuse, it's not possible to','line_number':364,'multiline':False]
['text':' necessarily predict whether or not the last reference to an object will','line_number':365,'multiline':False]
['text':' be destructed from Python or C++.  This means that in the destructor here,','line_number':366,'multiline':False]
['text':' we don't necessarily know if we actually have the GIL or not; in fact,','line_number':367,'multiline':False]
['text':' we don't even know if the Python interpreter still exists!  Thus, we have','line_number':368,'multiline':False]
['text':' to test for it before releasing the GIL.','line_number':369,'multiline':False]
['text':'','line_number':370,'multiline':False]
['text':' PyGILState_Check is hopefully self explanatory.  But Py_IsInitialized or','line_number':371,'multiline':False]
['text':' _PyIsFinalizing?  Both get set at the same time during the Python','line_number':372,'multiline':False]
['text':' destruction process:','line_number':373,'multiline':False]
['text':' https://github.com/python/cpython/blob/d92513390a1a0da781bb08c284136f4d7abea36d/Python/pylifecycle.c#L1716-L1717','line_number':374,'multiline':False]
['text':' so the operant question is whether or not you want to release the GIL after','line_number':375,'multiline':False]
['text':' finalization has completed (and there is just no Python interpreter).','line_number':376,'multiline':False]
['text':' Clearly there is no need to release GIL in that state, so we want','line_number':377,'multiline':False]
['text':' Py_IsInitialized.','line_number':378,'multiline':False]
['text':' namespace impl','line_number':387,'multiline':False]
['text':' namespace torch','line_number':388,'multiline':False]
