['text':'allocator=','line_number':88,'multiline':True]
['text':'resizable=','line_number':89,'multiline':True]
['text':' Storage is already in shared memory, just return a handle','line_number':103,'multiline':False]
['text':' done','line_number':105,'multiline':False]
['text':' TODO: retry on collision','line_number':107,'multiline':False]
['text':' TODO: free GIL - but remember to reacquire it when an exception is thrown','line_number':108,'multiline':False]
['text':' Create a new storage in shared memory','line_number':111,'multiline':False]
['text':'allocator=','line_number':117,'multiline':True]
['text':'resizable=','line_number':118,'multiline':True]
['text':' Copying into shared memory can be slow, so release the GIL','line_number':121,'multiline':False]
['text':' Copy data from old storage into the new one','line_number':123,'multiline':False]
['text':' Replace the old data_ptr and allocator with the new ones','line_number':127,'multiline':False]
['text':'allocator=','line_number':184,'multiline':True]
['text':'resizable=','line_number':185,'multiline':True]
['text':' Storage is already in shared memory, just return a handle','line_number':213,'multiline':False]
['text':' done','line_number':215,'multiline':False]
['text':' Copying into shared memory can be slow, so release the GIL','line_number':219,'multiline':False]
['text':' Copy data from old storage into the new one','line_number':221,'multiline':False]
['text':' Replace the old data_ptr and allocator with the new ones','line_number':225,'multiline':False]
['text':'allocator=','line_number':280,'multiline':True]
['text':'resizable=','line_number':281,'multiline':True]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':316,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':322,'multiline':False]
['text':' Put Storage Data behind new ref counting context','line_number':329,'multiline':False]
['text':' See Note [CUDA IPC Refcounting implementation explained]','line_number':330,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':340,'multiline':False]
['text':' cudaIpcMemHandle_t(of basePtr)','line_number':358,'multiline':False]
['text':' Size(in bytes) of the real storage, note this is not the size of basePtr','line_number':360,'multiline':False]
['text':' memory block.','line_number':361,'multiline':False]
['text':' Offset(in bytes) of the real storage in the basePtr memory block.','line_number':363,'multiline':False]
['text':' NB: this offset MUST be in bytes instead of numel, since we use','line_number':364,'multiline':False]
['text':' (storage_handle, offset)','line_number':365,'multiline':False]
['text':'     as key in shared_cache(multiprocessing/reduction.py).','line_number':366,'multiline':False]
['text':'     Offset in numel cannot uniquely represent a storage.','line_number':367,'multiline':False]
['text':' We don't want to break existing code, so resource deletion is best','line_number':401,'multiline':False]
['text':' effort basis. Exception expected if producer process terminated','line_number':402,'multiline':False]
['text':' before consumer released data.','line_number':403,'multiline':False]
['text':' Already warned inside of producer process','line_number':413,'multiline':False]
['text':' Ensure that producer prepared all tensor's data','line_number':472,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':480,'multiline':False]
['text':' Offset the basePtr to reconstruct the real storage','line_number':494,'multiline':False]
['text':' devPtr = basePtr + storage_offset','line_number':495,'multiline':False]
['text':' Sync default stream to make sure all operations related to the','line_number':525,'multiline':False]
['text':' storage is finished (otherwise another process may reuse memory and','line_number':526,'multiline':False]
['text':' corrupt data)','line_number':527,'multiline':False]
['text':' Ideally all shared memory reference counting could be replaced by','line_number':529,'multiline':False]
['text':' sending untriggered CUDA event from the producer to consumer and','line_number':530,'multiline':False]
['text':' using this event as the criteria of memory release. However, CUDA','line_number':531,'multiline':False]
['text':' (atm 10.1) does not support the creation of untriggered events and','line_number':532,'multiline':False]
['text':' performance impact of having thousands of shared events is unknown.','line_number':533,'multiline':False]
['text':' TODO: Instead of cudaStreamSynchronize it is possible to add Stream','line_number':535,'multiline':False]
['text':' Callback and release counter inside of it (need to check performance','line_number':536,'multiline':False]
['text':' impact)','line_number':537,'multiline':False]
['text':' We don't want to break existing code, so resource deletion is best','line_number':541,'multiline':False]
['text':' effort basis. Exception expected if producer process terminated','line_number':542,'multiline':False]
['text':' before consumer released data.','line_number':543,'multiline':False]
['text':' Already warned inside of producer process','line_number':554,'multiline':False]
['text':'allocator=','line_number':563,'multiline':True]
['text':'resizable=','line_number':564,'multiline':True]
['text':' Returns an object that holds a "weak" pointer to the c10::StorageImpl.  This','line_number':579,'multiline':False]
['text':' pointer keeps the c10::StorageImpl struct live, but does not retain the data','line_number':580,'multiline':False]
['text':' pointer.','line_number':581,'multiline':False]
['text':'','line_number':582,'multiline':False]
['text':' NB: This does NOT preserve object identity when you call it multiple times','line_number':583,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,modernize-avoid-c-arrays,cppcoreguidelines-avoid-non-const-global-variables)','line_number':654,'multiline':False]
