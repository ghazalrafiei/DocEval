['text':' This is a hack to remove instances deleted in C++ from the PyBind cache','line_number':30,'multiline':False]
['text':' C++->Python. We need this because otherwise we may get the old Python object','line_number':31,'multiline':False]
['text':' if C++ creates a new object at the memory location of the deleted object.','line_number':32,'multiline':False]
['text':' WARNING: Precondition for this function is that, e.g., you have tested if a','line_number':44,'multiline':False]
['text':' SymIntList is in fact only ints, and if so, you called this with T=int64_t.','line_number':45,'multiline':False]
['text':' This precondition is NOT checked at runtime.','line_number':46,'multiline':False]
['text':' Promises that we have decayed the list appropriately','line_number':54,'multiline':False]
['text':' None gets converted to undefined Tensors','line_number':62,'multiline':False]
['text':' TODO: Properly fake this type','line_number':123,'multiline':False]
['text':' For backwards compatibility','line_number':128,'multiline':False]
['text':' For backwards compatibility','line_number':154,'multiline':False]
['text':' For backwards compatibility','line_number':162,'multiline':False]
['text':' For backwards compatibility','line_number':170,'multiline':False]
['text':' If the object is a ScriptList, retrieve the c10::List','line_number':251,'multiline':False]
['text':' instance inside it.','line_number':252,'multiline':False]
['text':' If not (i.e. it is a regular Python list), make a new','line_number':257,'multiline':False]
['text':' c10::List.','line_number':258,'multiline':False]
['text':' allows single int/float to be broadcasted to a fixed size list','line_number':261,'multiline':False]
['text':' TODO: what about SymInt conversion to SymFloat?','line_number':293,'multiline':False]
['text':' If the object is a ScriptDict, retrieve the c10::Dict','line_number':343,'multiline':False]
['text':' instance inside it.','line_number':344,'multiline':False]
['text':' If not (i.e. it is a regular Python dictionary), make a new','line_number':351,'multiline':False]
['text':' c10::Dict.','line_number':352,'multiline':False]
['text':' check if it's a none obj since optional accepts NoneType','line_number':359,'multiline':False]
['text':' check if it's a none obj since optional accepts NoneType','line_number':361,'multiline':False]
['text':' return an IValue() to denote a NoneType','line_number':362,'multiline':False]
['text':' if obj is already a ScriptModule, just return its ivalue','line_number':371,'multiline':False]
['text':' Check if the obj is a ScriptObject.','line_number':375,'multiline':False]
['text':' otherwise is a normal class object, we create a fresh','line_number':380,'multiline':False]
['text':' ivalue::Object to use from the py object.','line_number':381,'multiline':False]
['text':' 1. create a bare ivalue','line_number':382,'multiline':False]
['text':' 2. copy all the contained types','line_number':388,'multiline':False]
['text':' When converting an pyobj to an interface, we check if rhs','line_number':419,'multiline':False]
['text':' is module or normal torchscript class, get the type and ivalue','line_number':420,'multiline':False]
['text':' from them correspondingly.','line_number':421,'multiline':False]
['text':' We inspect the value to found the compiled TorchScript class','line_number':431,'multiline':False]
['text':' and then create a ivalue::Object from that class type.','line_number':432,'multiline':False]
['text':' check if the classType conform with the interface or not','line_number':447,'multiline':False]
['text':' TODO: https://github.com/pytorch/pytorch/issues/77134','line_number':565,'multiline':False]
['text':' If we have a NamedTuple','line_number':616,'multiline':False]
['text':' return borrowed reference to ensure it correctly incref the underlying','line_number':688,'multiline':False]
['text':' PyObject','line_number':689,'multiline':False]
['text':' Create a stack full of the arguments and keyword arguments.','line_number':730,'multiline':False]
['text':' throw_error ','line_number':795,'multiline':True]
['text':' NB: for kwargs, we cannot guarantee the order of appending','line_number':797,'multiline':False]
['text':' is the same as the argument order in operator's schema.','line_number':798,'multiline':False]
['text':' This is suboptimal, but should be fine. Later when we have','line_number':799,'multiline':False]
['text':' better schema matching and argument parsing, we could','line_number':800,'multiline':False]
['text':' match the operator in `operations` first, then the order will','line_number':801,'multiline':False]
['text':' be guaranteed.','line_number':802,'multiline':False]
['text':' throw_error ','line_number':809,'multiline':True]
['text':' namespace torch::jit','line_number':841,'multiline':False]
