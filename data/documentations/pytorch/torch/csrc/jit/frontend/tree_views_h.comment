['text':' clang-format off','line_number':16,'multiline':False]
['text':' TreeView provides a statically-typed way to traverse the tree, which should','line_number':17,'multiline':False]
['text':' be formed according to the grammar below.','line_number':18,'multiline':False]
['text':'','line_number':19,'multiline':False]
['text':' A few notes on types and their aliases:','line_number':20,'multiline':False]
['text':' - List<T> is really a Tree with kind TK_LIST and elements as subtrees','line_number':21,'multiline':False]
['text':' - Maybe<T> is really a Tree with kind TK_OPTION that has 0 or 1 subtree of type T','line_number':22,'multiline':False]
['text':' - Builtin types are: Ident (TK_IDENT), String (TK_STRING)','line_number':23,'multiline':False]
['text':'','line_number':24,'multiline':False]
['text':' Param = Param(Maybe<Expr> type, Ident name)                          TK_PARAM','line_number':25,'multiline':False]
['text':'','line_number':26,'multiline':False]
['text':' Decl  = Decl(List<Param> params, Maybe<Expr> return_type)            TK_DECL','line_number':27,'multiline':False]
['text':' Def   = Def(Ident name, Decl decl, List<Stmt> body)                  TK_DEF','line_number':28,'multiline':False]
['text':' ClassDef = ClassDef(Ident name,                                      TK_CLASS_DEF','line_number':29,'multiline':False]
['text':'                     Maybe<Expr> superclass,','line_number':30,'multiline':False]
['text':'                     List<Stmt> body)','line_number':31,'multiline':False]
['text':'','line_number':32,'multiline':False]
['text':' Stmt  = If(Expr cond, List<Stmt> true_body, List<Stmt> false_body)   TK_IF','line_number':33,'multiline':False]
['text':'       | For(List<Expr> targets, List<Expr> iters, List<Stmt> body)   TK_FOR','line_number':34,'multiline':False]
['text':'       | While(Expr cond, List<Stmt> body)                            TK_WHILE','line_number':35,'multiline':False]
['text':'       | Global(List<Ident> idents)                                   TK_GLOBAL','line_number':36,'multiline':False]
['text':'       -- NB: the only type of Expr's allowed on lhs are Var','line_number':37,'multiline':False]
['text':'          Or a tuple containing Var with an optional terminating Starred','line_number':38,'multiline':False]
['text':'       | Assign(Expr lhs, Maybe<Expr> rhs, Maybe<Expr> type)          TK_ASSIGN','line_number':39,'multiline':False]
['text':'       | AugAssign(Expr lhs, AugAssignKind aug_op, Expr rhs)          TK_AUG_ASSIGN','line_number':40,'multiline':False]
['text':'       | Return(List<Expr> values)                                    TK_RETURN','line_number':41,'multiline':False]
['text':'       | ExprStmt(List<Expr> expr)                                    TK_EXPR_STMT','line_number':42,'multiline':False]
['text':'       | Raise(Expr expr)                                             TK_RAISE','line_number':43,'multiline':False]
['text':'       | Def                                                          TK_DEF','line_number':44,'multiline':False]
['text':'       | With(List<WithItem> targets, List<Stmt> body)                TK_WITH','line_number':45,'multiline':False]
['text':'','line_number':46,'multiline':False]
['text':' Expr  = TernaryIf(Expr cond, Expr true_expr, Expr false_expr)        TK_IF_EXPR','line_number':47,'multiline':False]
['text':'       | BinOp(Expr lhs, Expr rhs)','line_number':48,'multiline':False]
['text':'       |     And                                                      TK_AND','line_number':49,'multiline':False]
['text':'       |     Or                                                       TK_OR','line_number':50,'multiline':False]
['text':'       |     Lt                                                       '<'','line_number':51,'multiline':False]
['text':'       |     Gt                                                       '>'','line_number':52,'multiline':False]
['text':'       |     Eq                                                       TK_EQ','line_number':53,'multiline':False]
['text':'       |     Le                                                       TK_LE','line_number':54,'multiline':False]
['text':'       |     Ge                                                       TK_GE','line_number':55,'multiline':False]
['text':'       |     Ne                                                       TK_NE','line_number':56,'multiline':False]
['text':'       |     Is                                                       TK_IS','line_number':57,'multiline':False]
['text':'       |     IsNot                                                    TK_ISNOT','line_number':58,'multiline':False]
['text':'       |     Add                                                      '+'','line_number':59,'multiline':False]
['text':'       |     Sub                                                      '-'','line_number':60,'multiline':False]
['text':'       |     Mul                                                      '*'','line_number':61,'multiline':False]
['text':'       |     Div                                                      '/'','line_number':62,'multiline':False]
['text':'       |     Mod                                                      '%'','line_number':63,'multiline':False]
['text':'       |     MatMult                                                  '@'','line_number':64,'multiline':False]
['text':'       |     Pow                                                      TK_POW','line_number':65,'multiline':False]
['text':'       | UnaryOp(Expr expr)','line_number':66,'multiline':False]
['text':'       |     Not                                                      TK_NOT','line_number':67,'multiline':False]
['text':'       |     USub                                                     '-'','line_number':68,'multiline':False]
['text':'       | Const(String value)                                          TK_CONST','line_number':69,'multiline':False]
['text':'       -- NB: x.name(y) is desugared into name(x, y)','line_number':70,'multiline':False]
['text':'       | Apply(Ident name, List<Expr> args, List<Attribute> kwargs)   TK_APPLY','line_number':71,'multiline':False]
['text':'       | Select(Expr value, Ident selector)                           '.'','line_number':72,'multiline':False]
['text':'       | Subscript(Expr value, List<Expr> subscript_exprs)            TK_SUBSCRIPT','line_number':73,'multiline':False]
['text':'       | SliceExpr(Maybe<Expr> start, Maybe<Expr> end)                TK_SLICE_EXPR','line_number':74,'multiline':False]
['text':'       | Var(Ident name)                                              TK_VAR','line_number':75,'multiline':False]
['text':'       | ListLiteral(List<Expr> inputs)                               TK_LIST_LITERAL','line_number':76,'multiline':False]
['text':'       | TupleLiteral(List<Expr> inputs)                              TK_TUPLE_LITERAL','line_number':77,'multiline':False]
['text':'       | Starred(Expr expr)                                           TK_STARRED','line_number':78,'multiline':False]
['text':'       | WithItem(Expr target, Maybe<Var> var)                        TK_WITH_ITEM','line_number':79,'multiline':False]
['text':' -- NB: only allowed expressions are Const or List(Const)','line_number':80,'multiline':False]
['text':'        (List as a value, not type constructor)','line_number':81,'multiline':False]
['text':' Attribute = Attribute(Ident name, Expr value)                        TK_ATTRIBUTE','line_number':82,'multiline':False]
['text':'','line_number':83,'multiline':False]
['text':' AugAssignKind =','line_number':84,'multiline':False]
['text':'            | Add()                                                   TK_PLUS_EQ','line_number':85,'multiline':False]
['text':'            | Sub()                                                   TK_MINUS_EQ','line_number':86,'multiline':False]
['text':'            | Mul()                                                   TK_TIMES_EQ','line_number':87,'multiline':False]
['text':'            | Div()                                                   TK_DIV_EQ','line_number':88,'multiline':False]
['text':'            | Mod()                                                   TK_MOD_EQ','line_number':89,'multiline':False]
['text':'','line_number':90,'multiline':False]
['text':' Each subclass of TreeView should provide:','line_number':92,'multiline':False]
['text':' 1. Constructor that takes a TreeRef, and checks that it's of the right type.','line_number':93,'multiline':False]
['text':' 2. Accessors that get underlying information out of the object. If they','line_number':94,'multiline':False]
['text':'    return subtrees, they should wrap them in appropriate views too.','line_number':95,'multiline':False]
['text':' 3. Static method 'create' that creates the underlying TreeRef object','line_number':96,'multiline':False]
['text':'    for every TreeRef kind that has a TreeView, the parser always uses','line_number':97,'multiline':False]
['text':'    (e.g.) Ident::create rather than Compound::Create, this means that','line_number':98,'multiline':False]
['text':'    changes to the structure of Ident are always made right here rather','line_number':99,'multiline':False]
['text':'    than both in the parser and in this code.','line_number':100,'multiline':False]
['text':' XXX: these structs should have no fields to prevent slicing when passing by value','line_number':101,'multiline':False]
['text':' clang-format on','line_number':102,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':128,'multiline':False]
['text':' Iterate over list to temporarily instantiate Ts that will check the type','line_number':168,'multiline':False]
['text':' silence unused warning','line_number':170,'multiline':False]
['text':' implicit ','line_number':207,'multiline':True]
['text':'//////////////////////////////////////////////////////////////////////////////','line_number':238,'multiline':False]
['text':' Base types (production LHS)','line_number':239,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////////////','line_number':240,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////////////','line_number':328,'multiline':False]
['text':' Helper nodes (mostly for function arguments)','line_number':329,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////////////','line_number':330,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////////////','line_number':382,'multiline':False]
['text':' Top level definitions','line_number':383,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////////////','line_number':384,'multiline':False]
['text':' Property represents a named attribute combined with a getter and setter','line_number':433,'multiline':False]
['text':' method to access and mutate that attribute.','line_number':434,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////////////','line_number':511,'multiline':False]
['text':' Statements','line_number':512,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////////////','line_number':513,'multiline':False]
['text':' TODO: supports only single comprehension for now','line_number':583,'multiline':False]
['text':' TODO: no ifs for now','line_number':597,'multiline':False]
['text':' TODO: supports only single comprehension for now','line_number':607,'multiline':False]
['text':' TODO: no ifs for now','line_number':624,'multiline':False]
['text':' Augmented assignment, like "foo += bar"','line_number':669,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////////////','line_number':814,'multiline':False]
['text':' Expressions','line_number':815,'multiline':False]
['text':'//////////////////////////////////////////////////////////////////////////////','line_number':816,'multiline':False]
['text':' NOLINTNEXTLINE(modernize-use-nullptr)','line_number':909,'multiline':False]
['text':'__idx=','line_number':910,'multiline':True]
['text':'base=','line_number':910,'multiline':True]
['text':' We can't pass in nullptr as the dummy pointer gets dereferenced for','line_number':917,'multiline':False]
['text':' Android version of strtod_c().','line_number':918,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':919,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':924,'multiline':False]
['text':' Complex numbers (a+bj, where a is non-zero) are parsed as an addition','line_number':927,'multiline':False]
['text':' between float/int a and a complex number "bj". When a is 0, a complex','line_number':928,'multiline':False]
['text':' number bj is created as above. So, while parsing the string, we don't','line_number':929,'multiline':False]
['text':' have to worry about the real component of the complex number.','line_number':930,'multiline':False]
['text':' WithItem represents an item using with a WithStmt.','line_number':1072,'multiline':False]
['text':' With represents a with statement consisting of a list of with items and a','line_number':1094,'multiline':False]
['text':' body of statements.','line_number':1095,'multiline':False]
['text':'
 * NOTE: transforming PEP 604 union into equivalent union type
 *
 * NOTE: Union[int, float] parses into:
 * <EXPR> expr:(subscript
 *  (variable (ident Union))
 *  (list
 *    (variable (ident int))
 *    (variable (ident float))))
 * <KIND> subscript
 *
 * NOTE: (int | float) parses into:
 * <EXPR> expr:(|
 *  (variable (ident int))
 *  (variable (ident float)))
 * <KIND> |
 ','line_number':1211,'multiline':True]
['text':' flatten possibly nested union expressions like (int | (float | str))','line_number':1232,'multiline':False]
['text':' into a flat list of expressions like [int, float, str]','line_number':1233,'multiline':False]
['text':' Flattens a PEP 604 union into a classical union.','line_number':1249,'multiline':False]
['text':' For example, ((x | y) | z) is transformed into Union[x, y, z].','line_number':1250,'multiline':False]
['text':' noop if not a pep604 union','line_number':1252,'multiline':False]
['text':' In order to support unions with more than 2 operands ((x|y)|z), we need to','line_number':1256,'multiline':False]
['text':' recursively flatten the tree of | expressions.','line_number':1257,'multiline':False]
['text':' namespace jit','line_number':1266,'multiline':False]
['text':' namespace torch','line_number':1267,'multiline':False]
['text':' namespace std','line_number':1275,'multiline':False]
