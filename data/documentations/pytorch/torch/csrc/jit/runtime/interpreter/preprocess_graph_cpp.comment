['text':' Insert explicit prim::MethodCall nodes after prim::Enter nodes','line_number':10,'multiline':False]
['text':' to actually call __enter__ on the object. All prim::Enter does','line_number':11,'multiline':False]
['text':' is push the object onto the stack of currently entered objects.','line_number':12,'multiline':False]
['text':' This is necessary because emitting two instructions for a','line_number':13,'multiline':False]
['text':' prim::Enter nodes (one ENTER to push onto the entered objects','line_number':14,'multiline':False]
['text':' stack and one CALL to call __enter__) does not work; the','line_number':15,'multiline':False]
['text':' accounting that determines when to move a value out of a register','line_number':16,'multiline':False]
['text':' is based on the number of uses it has in the IR.','line_number':17,'multiline':False]
['text':' Traverse the graph while drilling down into blocks belonging to','line_number':23,'multiline':False]
['text':' a node and add all encountered prim::Enter nodes to enter_nodes.','line_number':24,'multiline':False]
['text':' For each prim::Enter, emit a prim::MethodCall after it that actually','line_number':41,'multiline':False]
['text':' calls __enter__ on the object.','line_number':42,'multiline':False]
['text':' insert Drop nodes to kill references for anything unused:','line_number':59,'multiline':False]
['text':' this can happen in a few places, e.g. when a node returns','line_number':60,'multiline':False]
['text':' many values but only one is used','line_number':61,'multiline':False]
['text':' a, b = foo()','line_number':62,'multiline':False]
['text':' return a','line_number':63,'multiline':False]
['text':' ensure every value has a final use in the same block where it is defined.','line_number':91,'multiline':False]
['text':' This already true for most nodes. The exceptions are:','line_number':92,'multiline':False]
['text':' 1. A value that is unused.','line_number':93,'multiline':False]
['text':' 2. A value whose last use is nested in some control flow.','line_number':94,'multiline':False]
['text':' For (1) we simply add a prim::Drop node that uses the value right after','line_number':95,'multiline':False]
['text':' it is defined. For (2), we insert a prim::Drop right after the control','line_number':96,'multiline':False]
['text':' flow node where the last use occurs','line_number':97,'multiline':False]
['text':' struct to share common data structures','line_number':99,'multiline':False]
['text':' have we seen this value, yet, if not, it is the last use of the value','line_number':102,'multiline':False]
['text':' A map from an If or Loop node to the optional Drop block that','line_number':105,'multiline':False]
['text':' occurs directly after it to release any tensors that go out of scope','line_number':106,'multiline':False]
['text':' when the If/Loop exits. These are created and inserted on demand.','line_number':107,'multiline':False]
['text':' scan backwards so if a value is used twice in the list then it is a','line_number':123,'multiline':False]
['text':' move','line_number':124,'multiline':False]
['text':' the last use of v may be in a nested block of an If or Loop statement','line_number':136,'multiline':False]
['text':' find the node 'same_depth_node' at the same depth as the definition of','line_number':137,'multiline':False]
['text':' v, and consider that node to be the last use of v. This ensures we do','line_number':138,'multiline':False]
['text':' not delete nodes in nested scopes that may be executed multiple times','line_number':139,'multiline':False]
['text':' and that nodes used on one side of an if','line_number':140,'multiline':False]
['text':' but not the other get deleted regardless of the branch','line_number':141,'multiline':False]
['text':' e.g.','line_number':142,'multiline':False]
['text':' a = 4','line_number':143,'multiline':False]
['text':' while <...>:','line_number':144,'multiline':False]
['text':'   y = a + a','line_number':145,'multiline':False]
['text':' drop(a)','line_number':146,'multiline':False]
['text':' In other words, we find the first program point for v that','line_number':147,'multiline':False]
['text':' _reverse_ dominates the definition of v, and add a drop point there.','line_number':148,'multiline':False]
['text':' failure means v is not in scope for n, use lint!','line_number':151,'multiline':False]
['text':' In the case where v and n are in the same block,','line_number':153,'multiline':False]
['text':' we have a legit final use already.','line_number':154,'multiline':False]
['text':' in the case where the use is nested in a block','line_number':159,'multiline':False]
['text':' add a Drop node after that block which will drop 'v'.','line_number':160,'multiline':False]
['text':' finds the node in block 'block' that contains in 'n'','line_number':165,'multiline':False]
['text':' or nullptr if no such node exists, e.g.:','line_number':166,'multiline':False]
['text':' n0: a = 4','line_number':167,'multiline':False]
['text':' n1: if <cond>:','line_number':168,'multiline':False]
['text':' n2:    b = a + a','line_number':169,'multiline':False]
['text':' findOwnerInBlock(n2, n0.block()) == n1','line_number':170,'multiline':False]
['text':' we already accounted for this use','line_number':193,'multiline':False]
['text':' namespace','line_number':205,'multiline':False]
['text':' fill in move_flags by scanning blocks;','line_number':210,'multiline':False]
['text':' namespace torch::jit::interpreter','line_number':214,'multiline':False]
