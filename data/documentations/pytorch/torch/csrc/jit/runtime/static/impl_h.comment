['text':' NOTE: NumberType may allocate because it includes complex.','line_number':34,'multiline':False]
['text':' Group values used by `graph` into three categories:','line_number':64,'multiline':False]
['text':'','line_number':65,'multiline':False]
['text':' - output_aliases:','line_number':66,'multiline':False]
['text':'     values that are either outputs or contain aliases of outputs','line_number':67,'multiline':False]
['text':' - external_aliases:','line_number':68,'multiline':False]
['text':'     values that are inputs, constants, or their aliases.','line_number':69,'multiline':False]
['text':'     The output aliases that end up here are as a result of aliasDb failing to','line_number':70,'multiline':False]
['text':'     recognize them as outputs due to collection object (e.g., Tuple) aliasing','line_number':71,'multiline':False]
['text':'     inputs.','line_number':72,'multiline':False]
['text':' Values that dont't show up in output_aliases or external_aliases are created','line_number':73,'multiline':False]
['text':' and consumed within the graph.','line_number':74,'multiline':False]
['text':' If true, then this node is the last use of at least one','line_number':112,'multiline':False]
['text':' managed tensor. availableTensorValuesAfterNode(node) will return a vector','line_number':113,'multiline':False]
['text':' of the managed tensors that are available for re-use','line_number':114,'multiline':False]
['text':' in the nodes following this one.','line_number':115,'multiline':False]
['text':' For testing. True if v1 and v2 are both mutable types and have lifetimes','line_number':120,'multiline':False]
['text':' that overlap.','line_number':121,'multiline':False]
['text':' Returns nullptr if we are not tracking the lifetime of value','line_number':131,'multiline':False]
['text':' Collect all values in the input that have tracked lifetimes.','line_number':134,'multiline':False]
['text':' A value's lifetime may not be tracked if it is a graph input','line_number':135,'multiline':False]
['text':' or immutable type (containers with at least one mutable','line_number':136,'multiline':False]
['text':' type are mutable)','line_number':137,'multiline':False]
['text':' Maps Node* to the set of managed tensors that are now available','line_number':141,'multiline':False]
['text':' for re-use after this node.','line_number':142,'multiline':False]
['text':' Maps each Value* to its lifetime (start node index, end node index)','line_number':144,'multiline':False]
['text':' enabling out variant allows Static Runtime to do memory planning','line_number':149,'multiline':False]
['text':' to reuse tensor storage for tensors whose live-range do not overlap to','line_number':151,'multiline':False]
['text':' reduce memory footprint (enable_out_variant must be true)','line_number':152,'multiline':False]
['text':' to batch allocate tensor storage for output tensors of the','line_number':154,'multiline':False]
['text':' graph, where storage is deallocated outside static runtime','line_number':155,'multiline':False]
['text':' (enable_out_variant must be true)','line_number':156,'multiline':False]
['text':' Gates the ReplaceWithCopy pass, which replaces ops that','line_number':158,'multiline':False]
['text':' sometimes alias their outputs with out variants that','line_number':159,'multiline':False]
['text':' always copy (so the output may participate in memory planning).','line_number':160,'multiline':False]
['text':' Since replacing with copies is done after TensorExpr fusion, the','line_number':161,'multiline':False]
['text':' resulting graph does not conform to the assumptions made in the fuser.','line_number':162,'multiline':False]
['text':' So, even if this flag is turned on, the ReplaceWithCopy pass will not','line_number':163,'multiline':False]
['text':' be executed if TensorExpr fusion is enabled.','line_number':164,'multiline':False]
['text':' Gates the ReplaceWithMaybeCopy pass, which replaces ops that','line_number':166,'multiline':False]
['text':' sometimes alias their outputs with subgraphs that include an out','line_number':167,'multiline':False]
['text':' variant.','line_number':168,'multiline':False]
['text':' For the same reason as `use_copy_variants`, the ReplaceWithMaybeCopy pass','line_number':169,'multiline':False]
['text':' will not be executed if TensorExpr fusion is enabled, even if this flag','line_number':170,'multiline':False]
['text':' is turned on.','line_number':171,'multiline':False]
['text':' enable TensorExpr fusion of ops at model loading time','line_number':173,'multiline':False]
['text':'
  Responsible for plugging StaticRuntime metadata onto the
  IR nodes. StaticRuntimeMetdata extends CustomClassHolder
  which can be casted to IValue and attached to IR node.
  This is needed to pass parent graph metadata to forked
  graph in presence of prim::fork operator
','line_number':177,'multiline':True]
['text':'/ The static runime supports two execution modes.','line_number':197,'multiline':False]
['text':'/','line_number':198,'multiline':False]
['text':'/ Mode 1: single-threaded with no parallelism except for intra-op parallelism','line_number':199,'multiline':False]
['text':'/ For this mode, you can do either:','line_number':200,'multiline':False]
['text':'/ @code','line_number':201,'multiline':False]
['text':'/   // m is a TorchScript module','line_number':202,'multiline':False]
['text':'/   auto module = StaticModule(m, opts);','line_number':203,'multiline':False]
['text':'/   auto output = module(args, kwargs);','line_number':204,'multiline':False]
['text':'/ @endcode','line_number':205,'multiline':False]
['text':'/','line_number':206,'multiline':False]
['text':'/ or','line_number':207,'multiline':False]
['text':'/','line_number':208,'multiline':False]
['text':'/ @code','line_number':209,'multiline':False]
['text':'/   // g is the TorchScript graph','line_number':210,'multiline':False]
['text':'/   auto module = StaticModule(g, opts);','line_number':211,'multiline':False]
['text':'/   auto output = module(args, kwargs);','line_number':212,'multiline':False]
['text':'/ @endcode','line_number':213,'multiline':False]
['text':'/','line_number':214,'multiline':False]
['text':'/ Mode 2: similar to data parallelism, run the same model for different inputs','line_number':215,'multiline':False]
['text':'/ on different threads at the same time.','line_number':216,'multiline':False]
['text':'/ You should have one StaticModule per model, and one StaticRuntime instance','line_number':217,'multiline':False]
['text':'/ per running thread. To avoiding creating StaticRuntimes on the fly, use a','line_number':218,'multiline':False]
['text':'/ synchronized stack (i.e. boost::lockfree::stack) to cache all the','line_number':219,'multiline':False]
['text':'/ StaticRuntime instances in your code.','line_number':220,'multiline':False]
['text':'/ @code','line_number':221,'multiline':False]
['text':'/   // initialization','line_number':222,'multiline':False]
['text':'/   auto module = std::make_shared<StaticModule>(m, opts);','line_number':223,'multiline':False]
['text':'/','line_number':224,'multiline':False]
['text':'/   // 128 is good for most cases. Pick a number that works for you','line_number':225,'multiline':False]
['text':'/   boost::lockfree::stack<std::shared_ptr<StaticRuntime>,','line_number':226,'multiline':False]
['text':'/     boost::lockfree::fixed_sized<true>> pool(128);','line_number':227,'multiline':False]
['text':'/','line_number':228,'multiline':False]
['text':'/   // inference','line_number':229,'multiline':False]
['text':'/   std::shared_ptr<StaticRuntime> runtime = nullptr;','line_number':230,'multiline':False]
['text':'/   pool.pop(runtime);','line_number':231,'multiline':False]
['text':'/   if (!runtime) {','line_number':232,'multiline':False]
['text':'/     // holds a reference to the underlying module','line_number':233,'multiline':False]
['text':'/     // but does its own memory management','line_number':234,'multiline':False]
['text':'/     runtime = std::make_shared<StaticRuntime>(*module);','line_number':235,'multiline':False]
['text':'/   }','line_number':236,'multiline':False]
['text':'/   auto output = runtime(args, kwargs);','line_number':237,'multiline':False]
['text':'/   pool.push(runtime);','line_number':238,'multiline':False]
['text':'/ @endcode','line_number':239,'multiline':False]
['text':'/','line_number':240,'multiline':False]
['text':' A `BlockInfo` instance stores all of the shared state that each','line_number':262,'multiline':False]
['text':' `BlockRunner` will need to access. Most of this information is','line_number':263,'multiline':False]
['text':' read-only and shared between threads.','line_number':264,'multiline':False]
['text':' - Each `BlockInfo` corresponds to one block in the graph.','line_number':265,'multiline':False]
['text':' - Each `BlockInfo` may be used by multiple block runners (when there are many','line_number':266,'multiline':False]
['text':'   threads).','line_number':267,'multiline':False]
['text':' - All of the `BlockInfo`s are stored in a vector in the `StaticModule` and','line_number':268,'multiline':False]
['text':'   are initialized during `StaticModule` construction.','line_number':269,'multiline':False]
['text':' - Most of the information stored is used to initialize the block's memory','line_number':270,'multiline':False]
['text':'   planner.','line_number':271,'multiline':False]
['text':' The index of this block's inputs in the shared values_ array.','line_number':363,'multiline':False]
['text':' The indices of this block's outputs in the shared values_ array.','line_number':365,'multiline':False]
['text':' See [Shared values array]','line_number':468,'multiline':False]
['text':' Recursively prepares the BlockInfo array.','line_number':474,'multiline':False]
['text':' - Populates `value_to_index` with the indices of each intermediate value','line_number':475,'multiline':False]
['text':' - Returns the number of Value* processed, including sub-blocks.','line_number':476,'multiline':False]
['text':' Recursively traverse the graph and attach SR metadata','line_number':487,'multiline':False]
['text':' to the prim::fork nodes as additional attributes','line_number':488,'multiline':False]
['text':' Recurses on sub-blocks and populates the array of ProcessedNodes','line_number':491,'multiline':False]
['text':' Returns (number of nodes processed, number of blocks processed)','line_number':492,'multiline':False]
['text':' Initialize various attributes that the memory planner will need.','line_number':499,'multiline':False]
['text':' To be called at the tail of the ctor.','line_number':500,'multiline':False]
['text':' metadata that is stored in IR nodes as attribute','line_number':504,'multiline':False]
['text':' Bookkeeping for creating new StaticRuntime instances','line_number':511,'multiline':False]
['text':' IValue table (defined by prim::Constant nodes)','line_number':512,'multiline':False]
['text':' The functions to be called by corresponding ProcessedNode.','line_number':514,'multiline':False]
['text':' A list of pre-processed nodes from which ProcessedNode are created per','line_number':516,'multiline':False]
['text':' StaticRuntime instance.','line_number':517,'multiline':False]
['text':' Indices of graph outputs in the single values array.','line_number':519,'multiline':False]
['text':' Includes self if module_ != nullopt.','line_number':524,'multiline':False]
['text':' Note that we might have num_inputs_ == 0 even if the schema has a `self`','line_number':525,'multiline':False]
['text':' argument. In this case, `self` isn't used in the graph, but the schema','line_number':526,'multiline':False]
['text':' includes it anyways to be consistent with the JIT interpreter.','line_number':527,'multiline':False]
['text':' See `BlockInfo` definition. The blocks are stored in depth-first order.','line_number':529,'multiline':False]
['text':' `BlockRunner` contains the core runtime logic. Each block runner','line_number':534,'multiline':False]
['text':' corresponds to one block in the graph and has its own memory planner.','line_number':535,'multiline':False]
['text':' `StaticRuntime` will initialize all `BlockRunner`s','line_number':536,'multiline':False]
['text':' upon construction. Each block runner only directly executes nodes from its','line_number':537,'multiline':False]
['text':' block. Special ops with sub-blocks like `prim::If` may have','line_number':538,'multiline':False]
['text':' `BlockRunner`s stored in their `ProcessedNode`s; these','line_number':539,'multiline':False]
['text':' sub-blocks get executed in the op's implementation.','line_number':540,'multiline':False]
['text':' `StaticRuntime` stores a vector of IValues that all','line_number':541,'multiline':False]
['text':' `BlockRunner`s share. This vector is used to store all','line_number':542,'multiline':False]
['text':' constants, inputs, and intermediate tensors.','line_number':543,'multiline':False]
['text':' Input is readwrite','line_number':605,'multiline':False]
['text':' Output is readonly. The writing process happens inside ProcessedNodes','line_number':611,'multiline':False]
['text':' WARNING: Deallocate managed output tensors.  A client receiving Static','line_number':645,'multiline':False]
['text':' Runtime-managed Tensors needs to be very careful to call','line_number':646,'multiline':False]
['text':' `StaticRuntime::deallocateOutputTensors` after all references of output','line_number':647,'multiline':False]
['text':' Tensors are gone.','line_number':648,'multiline':False]
['text':' This is the fallback path taken if we can't construct the memory planner','line_number':658,'multiline':False]
['text':' on the first iteration.','line_number':659,'multiline':False]
['text':' IMPORTANT: Nothing here should be able to throw!!!','line_number':660,'multiline':False]
['text':' This function can be called from the (implicitly) `noexcept` destructor','line_number':661,'multiline':False]
['text':' of Deallocator, meaning that std::terminate will be called','line_number':662,'multiline':False]
['text':' if any exception escapes. Even if resetMemory and ~Deallocator were','line_number':663,'multiline':False]
['text':' `noexcept(false)`, it's possible that when ~Deallocator is called, the','line_number':664,'multiline':False]
['text':' stack is already unwinding, so there's still danger of calling','line_number':665,'multiline':False]
['text':' std::terminate.','line_number':666,'multiline':False]
['text':' A helper object that invokes memory planner deallocation code','line_number':670,'multiline':False]
['text':' when destructed.','line_number':671,'multiline':False]
['text':' helper method for copying input args/kwargs into inputs_','line_number':712,'multiline':False]
['text':' Set Input(idx) to args[idx]. Invoked by set_inputs. Copies or moves','line_number':716,'multiline':False]
['text':' depending on overload.','line_number':717,'multiline':False]
['text':' Set Input(idx) to arg. Always copies. Used for kwargs.','line_number':721,'multiline':False]
['text':' clean up owning refs of input IValues','line_number':729,'multiline':False]
['text':' Cache this so we don't have to call static_module_.first_input_is_self()','line_number':756,'multiline':False]
['text':' Index of the start of this blocks inputs in the shared values_ array.','line_number':758,'multiline':False]
['text':' [Shared values array]','line_number':763,'multiline':False]
['text':' ProcessedNodes reference their inputs and outputs with','line_number':764,'multiline':False]
['text':' offsets into this array, which saves memory.','line_number':765,'multiline':False]
['text':' All BlockRunners share the same array. The layout is as','line_number':766,'multiline':False]
['text':' follows:','line_number':767,'multiline':False]
['text':' [constants][block_0][block_1]...[block_N]','line_number':768,'multiline':False]
['text':' Note that constants from all blocks are pooled together at the start.','line_number':769,'multiline':False]
['text':' The block ordering is depth-first.','line_number':770,'multiline':False]
['text':' Each block is further divided into inputs and intermediates:','line_number':771,'multiline':False]
['text':' [block_i] = [inputs_i][intermediates_i]','line_number':772,'multiline':False]
['text':' Each BlockRunner knows where its inputs start. Each ProcessedNode','line_number':773,'multiline':False]
['text':' knows how to find the indices of its outputs/inputs in this array.','line_number':774,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':817,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':820,'multiline':False]
['text':'
  ProcessedNodeMetadata class wraps the possible metadata
  for ProcessedNode. Depending upon the nature of op, processedNode
  can have one of the below possibilities of metadata:
  - prim::If/prim::Loop ops contains block_runners_ as their metadata
  - prim::fork op contains TaskLauncher (std::function) responsible for
    execution of forked subgraph
','line_number':853,'multiline':True]
['text':' deleted copy ctor/assignment as standard containers (vector) always','line_number':870,'multiline':False]
['text':' have copy constructors, but their instantiation is not well-formed','line_number':871,'multiline':False]
['text':' if the contained type (BlockRunner) is not copyable','line_number':872,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':897,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':900,'multiline':False]
['text':' These should be noexcept, but some Android build is failing','line_number':911,'multiline':False]
['text':' saying the noexcept specification doesn't match the calculated','line_number':912,'multiline':False]
['text':' one. Maybe std::variant is throwing it off?','line_number':913,'multiline':False]
['text':' Input is readonly','line_number':926,'multiline':False]
['text':' Output is readwrite','line_number':931,'multiline':False]
['text':' used in debug mode','line_number':998,'multiline':False]
['text':' returns pointer to ProcessedNodeMetadata or nullptr if no object is owned','line_number':1001,'multiline':False]
['text':' attach block_runner to metadata of ProcessedNode','line_number':1006,'multiline':False]
['text':' attach TaskLauncher to metadata of ProcessedNode','line_number':1014,'multiline':False]
['text':' unowned','line_number':1032,'multiline':False]
['text':' Metadata for ProcessedNode.','line_number':1033,'multiline':False]
['text':' 1. prim::If/Loop nodes contains sub-blocks as metadata','line_number':1034,'multiline':False]
['text':' 2. prim::fork nodes contains custom executor for async execution','line_number':1035,'multiline':False]
['text':' `StaticRuntime` is the owner of the array of IValues (used for constants,','line_number':1039,'multiline':False]
['text':' inputs, and intermediate tensors) that all `BlockRunner`s share.','line_number':1040,'multiline':False]
['text':' Upon construction, it initializes all block runners. `operator()` simply','line_number':1041,'multiline':False]
['text':' forwards the inputs to the top-level block runner. Each `StaticRuntime`','line_number':1042,'multiline':False]
['text':' instance corresponds to one `StaticModule`. Multiple `StaticRuntime`','line_number':1043,'multiline':False]
['text':' instances can be created; this is useful for multi-threaded execution, since','line_number':1044,'multiline':False]
['text':' `operator()` is not thread-safe.','line_number':1045,'multiline':False]
['text':' runAsync performs inline execution of graph on','line_number':1058,'multiline':False]
['text':' caller thread and async execution on taskLauncher','line_number':1059,'multiline':False]
['text':' If no custom taskLauncher is specified, execution is done','line_number':1060,'multiline':False]
['text':' on inter-op thread pool.','line_number':1061,'multiline':False]
['text':' Gets the top-level memory planner. Used for testing.','line_number':1079,'multiline':False]
['text':' An array of IValues with unchanging size/data ptr.','line_number':1110,'multiline':False]
['text':' NOLINTNEXTLINE(modernize-avoid-c-arrays)','line_number':1125,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays)','line_number':1126,'multiline':False]
['text':' NOLINTNEXTLINE(modernize-avoid-c-arrays)','line_number':1134,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays)','line_number':1135,'multiline':False]
['text':' for execution of async operations present in graph','line_number':1141,'multiline':False]
['text':' namespace torch::jit','line_number':1146,'multiline':False]
