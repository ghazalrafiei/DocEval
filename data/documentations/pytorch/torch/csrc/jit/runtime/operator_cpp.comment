['text':' list of operators whose schema have not yet been parsed, and must','line_number':21,'multiline':False]
['text':' be registered before any call to lookup an operator','line_number':22,'multiline':False]
['text':' Those two maps are used to implement lookupByLiteral, which is needed for','line_number':24,'multiline':False]
['text':' the n->match(...) calls. Basically, every function schema is assigned a','line_number':25,'multiline':False]
['text':' unique string you can use to match it. However, parsing those strings or','line_number':26,'multiline':False]
['text':' comparing and hashing them character by character would be very slow, so we','line_number':27,'multiline':False]
['text':' use a trick here! Every string literal in your program is guaranteed to','line_number':28,'multiline':False]
['text':' have static storage duration and so its address won't change at runtime.','line_number':29,'multiline':False]
['text':' This allows us to memoize answers for every pointer, which is done by the','line_number':30,'multiline':False]
['text':' operators_by_sig_literal map. Still, this map is initially empty, and so we','line_number':31,'multiline':False]
['text':' still need to do the complete string matching at the first time, which is','line_number':32,'multiline':False]
['text':' implemented by performing a lookup in the operators_by_sig map.','line_number':33,'multiline':False]
['text':' Remember all registered operator names to check that they aren't','line_number':38,'multiline':False]
['text':' registered a second time. Registering an op multiple times is','line_number':39,'multiline':False]
['text':' fragile because it might depend on static initialization order','line_number':40,'multiline':False]
['text':' which one is picked at runtime.','line_number':41,'multiline':False]
['text':' XXX - caller must be holding lock','line_number':46,'multiline':False]
['text':' Try removing from pending operators list first','line_number':83,'multiline':False]
['text':' Remove operator from signature map','line_number':93,'multiline':False]
['text':' Remove operator from symbol map','line_number':101,'multiline':False]
['text':' Handy debugging code that dumps all operators we know about on mismatch','line_number':128,'multiline':False]
['text':' WARNING: by adding a value to this set, you are asserting','line_number':202,'multiline':False]
['text':' that you have also added special handling of this symbol to','line_number':203,'multiline':False]
['text':' the python_print.cpp. Not adding handling will cause import and export','line_number':204,'multiline':False]
['text':' of modules with this new operator to fail. This is only required','line_number':205,'multiline':False]
['text':' for operators without schema. Prefer registering your operator with','line_number':206,'multiline':False]
['text':' schema to editing this list here. These cases should only be things','line_number':207,'multiline':False]
['text':' that require special handling because they do not fit normal schema','line_number':208,'multiline':False]
['text':' WARNING: by adding a value to this set, you are asserting that your','line_number':219,'multiline':False]
['text':' primitive is only ever added during optimization and does not need','line_number':220,'multiline':False]
['text':' to be correctly printed for export (a process that happens before','line_number':221,'multiline':False]
['text':' optimization passes run)','line_number':222,'multiline':False]
['text':' only used in onnx','line_number':224,'multiline':False]
['text':' only used in onnx','line_number':225,'multiline':False]
['text':' temporarily inserted by autograd','line_number':226,'multiline':False]
['text':' temporarily inserted by autograd','line_number':227,'multiline':False]
['text':' temporarily inserted by autograd','line_number':228,'multiline':False]
['text':' temporarily inserted by autograd','line_number':229,'multiline':False]
['text':' temporarily inserted by autograd','line_number':230,'multiline':False]
['text':' optimization pass adds it','line_number':231,'multiline':False]
['text':' optimization pass adds it,','line_number':232,'multiline':False]
['text':' optimization pass adds it,','line_number':233,'multiline':False]
['text':' optimization pass (fuser) adds it','line_number':234,'multiline':False]
['text':' optimization pass (fuser) adds it','line_number':235,'multiline':False]
['text':' optimization pass (fuser) adds it','line_number':236,'multiline':False]
['text':' used in interpreter only','line_number':237,'multiline':False]
['text':' optimization pass adds it','line_number':238,'multiline':False]
['text':' optimization pass adds it','line_number':239,'multiline':False]
['text':' optimization pass adds it','line_number':240,'multiline':False]
['text':' optimization pass adds it','line_number':241,'multiline':False]
['text':' optimization pass adds it','line_number':242,'multiline':False]
['text':' optimization pass adds it','line_number':243,'multiline':False]
['text':' optimization pass adds it','line_number':244,'multiline':False]
['text':' optimization pass adds it','line_number':245,'multiline':False]
['text':' optimization pass adds it','line_number':246,'multiline':False]
['text':' optimization pass adds it','line_number':247,'multiline':False]
['text':' optimization pass adds it','line_number':248,'multiline':False]
['text':' used in SR only','line_number':249,'multiline':False]
['text':' used in interpreter only','line_number':250,'multiline':False]
['text':' used as an optimization','line_number':251,'multiline':False]
['text':' used as an optimization','line_number':252,'multiline':False]
['text':' used in interpreter only','line_number':253,'multiline':False]
['text':' used in interpreter only','line_number':254,'multiline':False]
['text':' used in interpreter only','line_number':255,'multiline':False]
['text':' used in interpreter only','line_number':256,'multiline':False]
['text':' used in interpreter only','line_number':257,'multiline':False]
['text':' converted into prim::CallFunction','line_number':258,'multiline':False]
['text':' These namespaces are required to have Python printers unless','line_number':262,'multiline':False]
['text':' otherwise noted in unneeded.','line_number':263,'multiline':False]
['text':' anonymous namespace','line_number':274,'multiline':False]
['text':' WARNING: by adding a case to this list, you are asserting that you have','line_number':278,'multiline':False]
['text':' added a case for the unschematized node in AliasDb::analyze','line_number':279,'multiline':False]
['text':' Operators that should not be used by alias analysis','line_number':341,'multiline':False]
['text':' Depending on the order of registration, aten or jit ops may be','line_number':397,'multiline':False]
['text':' registered first. This sorting is helpful in cases where','line_number':398,'multiline':False]
['text':' deterministic (i.e. not dependent on build config) behavior is','line_number':399,'multiline':False]
['text':' desired; e.g. torch.ops.aten.* uses this function, and tries to','line_number':400,'multiline':False]
['text':' find the "first" op that matches input args. Without the sorting,','line_number':401,'multiline':False]
['text':' the "first" op may change depending on registration order.','line_number':402,'multiline':False]
['text':' namespace torch::jit','line_number':471,'multiline':False]
