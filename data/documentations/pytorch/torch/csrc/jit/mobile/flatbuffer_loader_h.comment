['text':'*
 * Defines the public API for loading flatbuffer-serialized mobile modules.
 * Note that this header must not include or depend on flatbuffer-defined
 * types, to avoid leaking those details to PyTorch clients.
 ','line_number':15,'multiline':True]
['text':'/ All non-copied data pointers provided to `parse_and_initialize_*` functions','line_number':24,'multiline':False]
['text':'/ must be aligned to this boundary. Since the Module will point directly into','line_number':25,'multiline':False]
['text':'/ the data, this alignment is necessary to ensure that certain types/structs','line_number':26,'multiline':False]
['text':'/ are properly aligned.','line_number':27,'multiline':False]
['text':'/ Maps file names to file contents.','line_number':30,'multiline':False]
['text':' On high level, to produce a Module from a file on disk, we need to go','line_number':33,'multiline':False]
['text':' through the follow steps:','line_number':34,'multiline':False]
['text':' 1. Read: Read the file from disk -> memory','line_number':35,'multiline':False]
['text':' 2. Deserialize: Parse the bytes to produce some in memory manipulable','line_number':36,'multiline':False]
['text':'    structure','line_number':37,'multiline':False]
['text':' 3. Module initialization: Produce mobile::Module out of the structure','line_number':38,'multiline':False]
['text':'    produced in 2.','line_number':39,'multiline':False]
['text':' Under this context, the structure described in 2. is the flatbuffer-defined','line_number':40,'multiline':False]
['text':' type mobile::serialization::Module. However, this step/type is not visible in','line_number':41,'multiline':False]
['text':' the public API.','line_number':42,'multiline':False]
['text':' Parse a mobile::Module from raw bytes.','line_number':44,'multiline':False]
['text':'','line_number':45,'multiline':False]
['text':' This function does steps 2+3 described above.','line_number':46,'multiline':False]
['text':'','line_number':47,'multiline':False]
['text':' Does not take ownership of `data`; if you want it to take ownership, see the','line_number':48,'multiline':False]
['text':' shared_ptr overload of this function.','line_number':49,'multiline':False]
['text':'','line_number':50,'multiline':False]
['text':' If should_copy_tensor_memory is true, then the returned module will NOT have','line_number':51,'multiline':False]
['text':' refences to `data`, so `data` can be freed immediately.','line_number':52,'multiline':False]
['text':'','line_number':53,'multiline':False]
['text':' If should_copy_tensor_memory is false, then returned module will have tensors','line_number':54,'multiline':False]
['text':' that points inside of `data`; the caller will need to make sure that `data`','line_number':55,'multiline':False]
['text':' outlives the returned Module. Also, `data` must be aligned to','line_number':56,'multiline':False]
['text':' kFlatbufferDataAlignmentBytes.','line_number':57,'multiline':False]
['text':' of `data`, in bytes.','line_number':60,'multiline':False]
['text':' Parse a mobile::Module from raw bytes.','line_number':65,'multiline':False]
['text':'','line_number':66,'multiline':False]
['text':' This function does steps 2+3 described above.','line_number':67,'multiline':False]
['text':'','line_number':68,'multiline':False]
['text':' The returned Module holds a reference to `data`, which must be aligned to','line_number':69,'multiline':False]
['text':' kFlatbufferDataAlignmentBytes.','line_number':70,'multiline':False]
['text':'','line_number':71,'multiline':False]
['text':' If you do not want the Module to hold a reference to `data`, see the raw','line_number':72,'multiline':False]
['text':' pointer overload of this function.','line_number':73,'multiline':False]
['text':' of `data`, in bytes.','line_number':76,'multiline':False]
['text':' Parse a mobile::Module from raw bytes, also returning JIT-related metadata.','line_number':80,'multiline':False]
['text':'','line_number':81,'multiline':False]
['text':' This is the same as parse_and_initialize_mobile_module() except that it also','line_number':82,'multiline':False]
['text':' extracts JIT source files and constants. Can be used to construct a','line_number':83,'multiline':False]
['text':' jit::Module.','line_number':84,'multiline':False]
['text':' of `data`, in bytes.','line_number':87,'multiline':False]
['text':' Load a mobile::Module from a filepath.','line_number':93,'multiline':False]
['text':'','line_number':94,'multiline':False]
['text':' This function does steps 1+2+3 described above.','line_number':95,'multiline':False]
['text':'','line_number':96,'multiline':False]
['text':' We need to have this as a convienience because Python API will need to wrap','line_number':97,'multiline':False]
['text':' this. C++ clients should use one of the versions of','line_number':98,'multiline':False]
['text':' parse_and_initialize_mobile_module() so they can manage the raw data more','line_number':99,'multiline':False]
['text':' directly.','line_number':100,'multiline':False]
['text':' The methods below are less efficient because it need to read the stream in','line_number':113,'multiline':False]
['text':' its entirity to a buffer','line_number':114,'multiline':False]
['text':' no op, TODO(qihan) delete','line_number':132,'multiline':False]
['text':' namespace jit','line_number':135,'multiline':False]
['text':' namespace torch','line_number':136,'multiline':False]
