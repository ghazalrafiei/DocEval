['text':' The import process to serialize the bytecode package.','line_number':29,'multiline':False]
['text':' An example for bytecode.pkl of a small mobile_module looks like:','line_number':30,'multiline':False]
['text':' (4,  # model version number (caffe2::serialize::kProducedBytecodeVersion)','line_number':31,'multiline':False]
['text':'  # first method','line_number':32,'multiline':False]
['text':'  (','line_number':33,'multiline':False]
['text':'   # function name','line_number':34,'multiline':False]
['text':'   '__torch__.m.forward',','line_number':35,'multiline':False]
['text':'   # code','line_number':36,'multiline':False]
['text':'   (('instructions',','line_number':37,'multiline':False]
['text':'     (('STOREN', 1, 2),','line_number':38,'multiline':False]
['text':'      ('DROPR', 1, 0),','line_number':39,'multiline':False]
['text':'      ('MOVE', 2, 0),','line_number':40,'multiline':False]
['text':'      ('OP', 0, 0),','line_number':41,'multiline':False]
['text':'      ('RET', 0, 0))),','line_number':42,'multiline':False]
['text':'    ('operators', (('aten::Int', 'Tensor'),)),','line_number':43,'multiline':False]
['text':'    ('constants', ()),','line_number':44,'multiline':False]
['text':'    ('types', ()),','line_number':45,'multiline':False]
['text':'    ('register_size', 2)),','line_number':46,'multiline':False]
['text':'   # schema -- optional (forward-compatible addition to version 4)','line_number':47,'multiline':False]
['text':'   (('arguments',','line_number':48,'multiline':False]
['text':'     ((('name', 'x'), ('type', 'Tensor'), ('default_value', 13)),','line_number':49,'multiline':False]
['text':'      ...)),  # more args follow here','line_number':50,'multiline':False]
['text':'    ('returns',','line_number':51,'multiline':False]
['text':'     ((('name', ''), ('type', 'Tensor'), ('default_value', None)),','line_number':52,'multiline':False]
['text':'      ...)),  # more return values follow here','line_number':53,'multiline':False]
['text':'   )),','line_number':54,'multiline':False]
['text':'  # more methods follow here','line_number':55,'multiline':False]
['text':'  ...)','line_number':56,'multiline':False]
['text':' In addition, the module debugging information can be saved','line_number':58,'multiline':False]
['text':' in mobile_debug_handles.pkl. An example for it looks like:','line_number':59,'multiline':False]
['text':' (4,','line_number':60,'multiline':False]
['text':'  ('__torch__.m.forward',','line_number':61,'multiline':False]
['text':'   (('module_debug_handles', 10))))','line_number':62,'multiline':False]
['text':'   Here 10 is the debug handle.','line_number':63,'multiline':False]
['text':' We also store separately and optionally callstack_debug_map.','line_number':64,'multiline':False]
['text':' This serializes inlined callstack (InlinedCallStack data structure)','line_number':65,'multiline':False]
['text':' corresponding to the debug handles.','line_number':66,'multiline':False]
['text':' Callstack_debug_map serializes tuples of','line_number':67,'multiline':False]
['text':' (int64_t(debug_handle), int64_t(source_range_tag), InlinedCallStack)','line_number':68,'multiline':False]
['text':' source_range_tag maps to .debug_pkl files where this tag maps it to','line_number':69,'multiline':False]
['text':' source range.','line_number':70,'multiline':False]
['text':' InlinedCallStack is serialized as:','line_number':71,'multiline':False]
['text':' IValue(InlinedCallStack) = {IValue(ModuleInstanceInfo),','line_number':72,'multiline':False]
['text':' int64_t(source_range_tag), IValue(InlinedCallStack)} ModuleInstanceInfo is','line_number':73,'multiline':False]
['text':' serialized as a tuple of (class_type_name, instance_name)','line_number':74,'multiline':False]
['text':' Note that currently the backward compatibility is not supported by bytecode.','line_number':76,'multiline':False]
['text':' This format and process need to be revisited and redesigned if we want to','line_number':77,'multiline':False]
['text':' support backward compatibility in future.','line_number':78,'multiline':False]
['text':' Note that the following function-schema fields are not supported:','line_number':80,'multiline':False]
['text':'  - Argument::{known_length_,kwarg_only_}','line_number':81,'multiline':False]
['text':'  - FunctionSchema::{overload_name_, is_vararg_, is_varret_}','line_number':82,'multiline':False]
['text':' HACK: first we check whether the name starts with special prefix to','line_number':95,'multiline':False]
['text':' tell if it's a supported pytorch class type. There are two special','line_number':96,'multiline':False]
['text':' prefixes. "__torch__" for nn module, and "torch.jit" from to_backend.','line_number':97,'multiline':False]
['text':' This is a reliable','line_number':98,'multiline':False]
['text':' check today, but there is no guarantee that this is the case. The','line_number':99,'multiline':False]
['text':' real solution is to merge type parsers so we can share class','line_number':100,'multiline':False]
['text':' resolution logic.','line_number':101,'multiline':False]
['text':' The deserializer class which loads the bytecode package from bc files.','line_number':188,'multiline':False]
['text':' From `version` or `.data/version` in model.ptl and it's compute','line_number':222,'multiline':False]
['text':' dynamically. It's used for finding the minimum required runtime to run all','line_number':223,'multiline':False]
['text':' operators from the given model. If it's less than the current runtime,','line_number':224,'multiline':False]
['text':' upgrader will be applied at loading stage.','line_number':225,'multiline':False]
['text':' It requires compilation_unit_ when parsing function schema. Keep it in','line_number':241,'multiline':False]
['text':' BytecodeDeserializer. It may be refacotred later to make it independent','line_number':242,'multiline':False]
['text':' of the specific BytecodeDeserializer, like parsing other tables','line_number':243,'multiline':False]
['text':' function schema','line_number':249,'multiline':False]
['text':' (schema is optional for back compat)','line_number':250,'multiline':False]
['text':'N','line_number':270,'multiline':True]
['text':'overload_name','line_number':291,'multiline':True]
['text':'is_varargs','line_number':294,'multiline':True]
['text':'is_varret','line_number':295,'multiline':True]
['text':' Initialized with the version number when kProducedBytecodeVersion was','line_number':311,'multiline':False]
['text':' introduced. The old models (some of them already in production) without','line_number':312,'multiline':False]
['text':' version number are seen as version 3 (deprecated).','line_number':313,'multiline':False]
['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':322,'multiline':False]
['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':324,'multiline':False]
['text':' Process all methods in this mobile module.','line_number':340,'multiline':False]
['text':' older files do not store function schema','line_number':347,'multiline':False]
['text':' 1. First pass all operators from models','line_number':386,'multiline':False]
['text':' 2. Decides if upgrader is needed','line_number':389,'multiline':False]
['text':' 3. If upgrader is needed, change change the OP instrunction to CALL','line_number':399,'multiline':False]
['text':' instruction (In next PR, use_upgrader will be parsed to parseInstruction','line_number':400,'multiline':False]
['text':' function and do the actual change)','line_number':401,'multiline':False]
['text':' bvals can have 2 possible formats:','line_number':445,'multiline':False]
['text':'','line_number':446,'multiline':False]
['text':' 1. Old format: bvals is an array (Tuple) of N elements, each element being','line_number':447,'multiline':False]
['text':' itself a Tuple(method_name, method_table).','line_number':448,'multiline':False]
['text':'','line_number':449,'multiline':False]
['text':' 2. New format: bvals is an array (Tuple) of 1+N elements. The first element','line_number':450,'multiline':False]
['text':' being a Tuple (int, table), and the integer stands for the bytecode version','line_number':451,'multiline':False]
['text':' number. The rest of the elements are the same as before.','line_number':452,'multiline':False]
['text':'','line_number':453,'multiline':False]
['text':'pickle_prefix=','line_number':494,'multiline':True]
['text':'tensor_prefix=','line_number':495,'multiline':True]
['text':' NOLINTNEXTLINE(clang-analyzer-security.insecureAPI.rand)','line_number':511,'multiline':False]
['text':' Add files in defaultExtraFileList to fail_extra_files and extra_files','line_number':518,'multiline':False]
['text':' ExtraFilesMap is serialized with a "extra/", hence it is necessary to','line_number':528,'multiline':False]
['text':' account for when we de-serialize de-serialized filemap key values contain','line_number':529,'multiline':False]
['text':' prefix and we need to remove prior to construct the map. "extra/" string','line_number':530,'multiline':False]
['text':' has a length of 6 characters, hence we need only sub-string 6th position','line_number':531,'multiline':False]
['text':' of a string. Please refer to following link for a detail:','line_number':532,'multiline':False]
['text':' https://www.internalfb.com/code/fbsource/[9996fcb7a6fb]/fbcode/caffe2/torch/csrc/jit/mobile/import.cpp?lines=427-434','line_number':533,'multiline':False]
['text':' Add model_name and model_size to metadata_map','line_number':561,'multiline':False]
['text':' namespace','line_number':602,'multiline':False]
['text':' TODO optimize file read for non-flatbuffer models','line_number':672,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-security.insecureAPI.rand)','line_number':683,'multiline':False]
['text':' TODO: the current flatbuffers implementation will always load the','line_number':700,'multiline':False]
['text':' whole module including the extra files. Ideally it should be','line_number':701,'multiline':False]
['text':' possible to just get the extra files given data','line_number':702,'multiline':False]
['text':' op_names below isn't a list of unique operator names. In fact','line_number':720,'multiline':False]
['text':' it can contain the same operator name many many times, so we need','line_number':721,'multiline':False]
['text':' to de-dup the list by adding all the operator names into','line_number':722,'multiline':False]
['text':' an std::set<std::string>.','line_number':723,'multiline':False]
['text':' namespace mobile','line_number':732,'multiline':False]
['text':' namespace jit','line_number':733,'multiline':False]
['text':' namespace torch','line_number':734,'multiline':False]
