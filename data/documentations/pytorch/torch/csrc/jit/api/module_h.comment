['text':' This file contains classes which assist in desugaring Python style','line_number':31,'multiline':False]
['text':' modules and their methods into flattened graphs which don't have any','line_number':32,'multiline':False]
['text':' function calls.','line_number':33,'multiline':False]
['text':' Map which stores filename to content.','line_number':40,'multiline':False]
['text':' namespace detail','line_number':67,'multiline':False]
['text':' In script modules, buffers are Tensors attribute that are _not_ registered','line_number':119,'multiline':False]
['text':' as parameters. This is different than in nn.Module where there is a special','line_number':120,'multiline':False]
['text':' register_buffer method. With this simplification, we only need to track','line_number':121,'multiline':False]
['text':' whether a slot is a parameter to be able to classify it.','line_number':122,'multiline':False]
['text':' direct modules','line_number':160,'multiline':False]
['text':' all modules, including this one, recursively','line_number':162,'multiline':False]
['text':' all tensors involved in gradient optimization','line_number':165,'multiline':False]
['text':' all members of the object, similar to iterating over dir(obj) in python','line_number':169,'multiline':False]
['text':'/ Enables "training" mode.','line_number':183,'multiline':False]
['text':'/ Calls train(false) to enable "eval" mode.','line_number':185,'multiline':False]
['text':'/ Do not override this method, override `train()` instead.','line_number':186,'multiline':False]
['text':'on=','line_number':188,'multiline':True]
['text':'/ True if the module is in training mode.','line_number':190,'multiline':False]
['text':'/ Recursively casts all parameters to the given `dtype` and `device`.','line_number':195,'multiline':False]
['text':'/','line_number':196,'multiline':False]
['text':'/ If `non_blocking` is true and the source is in pinned memory and','line_number':197,'multiline':False]
['text':'/ destination is on the GPU or vice versa, the copy is performed','line_number':198,'multiline':False]
['text':'/ asynchronously with respect to the host. Otherwise, the argument has no','line_number':199,'multiline':False]
['text':'/ effect.','line_number':200,'multiline':False]
['text':'/ Recursively casts all parameters to the given dtype.','line_number':203,'multiline':False]
['text':'/','line_number':204,'multiline':False]
['text':'/ If `non_blocking` is true and the source is in pinned memory and','line_number':205,'multiline':False]
['text':'/ destination is on the GPU or vice versa, the copy is performed','line_number':206,'multiline':False]
['text':'/ asynchronously with respect to the host. Otherwise, the argument has no','line_number':207,'multiline':False]
['text':'/ effect.','line_number':208,'multiline':False]
['text':'/ Recursively moves all parameters to the given device.','line_number':211,'multiline':False]
['text':'/','line_number':212,'multiline':False]
['text':'/ If `non_blocking` is true and the source is in pinned memory and','line_number':213,'multiline':False]
['text':'/ destination is on the GPU or vice versa, the copy is performed','line_number':214,'multiline':False]
['text':'/ asynchronously with respect to the host. Otherwise, the argument has no','line_number':215,'multiline':False]
['text':'/ effect.','line_number':216,'multiline':False]
['text':' Clones both the underlying `ClassType` and the module instance(data), this','line_number':243,'multiline':False]
['text':' function creates a new `ClassType` and returns a new instance that has the','line_number':244,'multiline':False]
['text':' same data as the current instance but with the new type, shared ClassType','line_number':245,'multiline':False]
['text':' will be preserved as well','line_number':246,'multiline':False]
['text':' Clones both the underlying `ClassType` and the module instance(data), this','line_number':249,'multiline':False]
['text':' function creates a new `ClassType` and returns a new instance that has the','line_number':250,'multiline':False]
['text':' same data as the current instance but with the new type, shared ClassType','line_number':251,'multiline':False]
['text':' will be preserved as well. Also allows the caller to specify a set of','line_number':252,'multiline':False]
['text':' method and attribute names to not clone.','line_number':253,'multiline':False]
['text':' A set of functions to maintain input shapes through torch.jit.save and','line_number':278,'multiline':False]
['text':' torch.jit.load. It only works on tensors and lists/dicts of tensors','line_number':279,'multiline':False]
['text':' because tracing is only supported by these types.','line_number':280,'multiline':False]
['text':' Not checking whether this is traceable type as that is already checked','line_number':287,'multiline':False]
['text':' higher up in the stack and changing that would require a larger','line_number':288,'multiline':False]
['text':' restructuring.','line_number':289,'multiline':False]
['text':' Extra handle for the module to delete when itself is deleted','line_number':322,'multiline':False]
['text':' Map of function names to the traced inputs that they have been traced with','line_number':325,'multiline':False]
['text':' Mutex to keep registring buffer or parameter thread safe.','line_number':328,'multiline':False]
['text':' C++ equivalent api of `torch.jit.freeze`. See documentation there for','line_number':332,'multiline':False]
['text':' details.','line_number':333,'multiline':False]
['text':' C++ equivalent api of `torch.jit.optimize_for_inference`. See documentation','line_number':340,'multiline':False]
['text':' there for details.','line_number':341,'multiline':False]
['text':' clang-format off','line_number':349,'multiline':False]
['text':'
Sets the type and number of specializations that can occur during fusion.

Usage: provide a list of pairs (type, depth) where type is one of STATIC or DYNAMIC
and depth is an integer.

Behavior - static vs dynamic:
    In STATIC fusion, fused ops are compiled to have fixed input shapes. The shape is determined
    based on some initial profiling runs.
    In DYNAMIC fusion, fused ops are compiled to have variable input shapes, so that multiple
    shapes are possible.

In both cases, we also recompile on new striding behavior, device, or dtype.

Behavior - fallback functions & depth:
    When an input doesn't match the format required by the specialized compiled op, it will run
    a fallback function. Fallback functions are recursively be compiled and specialized based
    on the observed tensor shapes. Since compilation can be slow, the "depth" parameter is provided to
    limit the number of specializations that can be compiled, before giving up on recompiling and
    falling back to a completely un-fused, un-specialized implementation.

The list of (type, depth) pairs controls the type of specializations and the number of
specializations. For example: [(STATIC, 2), (DYNAMIC, 2)] indicates that the first
two specializations will use static fusions, the following two specializations will use
dynamic fusion, and any inputs that satisfy none of the 4 options will run an
unfused implementation.

NB: in the future, if more as more fusion backends are added there may be more granular
apis for specific fusers.
','line_number':350,'multiline':True]
['text':' clang-format on','line_number':380,'multiline':False]
['text':' returns previous strategy','line_number':382,'multiline':False]
['text':' slot offset, -1 indicates the module itself','line_number':389,'multiline':False]
['text':' namespace detail','line_number':392,'multiline':False]
['text':' This iterator allows the (optionally recursive) enumeration of','line_number':394,'multiline':False]
['text':' the  members of a Module. It performs a depth-first pre-order','line_number':395,'multiline':False]
['text':' traversal of the module. The Policy template parameter determines','line_number':396,'multiline':False]
['text':' which slots of the object should be included. For instance,','line_number':397,'multiline':False]
['text':' when iterating parameters, we return the parameter tensors,','line_number':398,'multiline':False]
['text':' but skip modules, buffers, and other attributes.','line_number':399,'multiline':False]
['text':' See ModulePolicy for comments about Policy object's API.','line_number':400,'multiline':False]
['text':' if true, do a depth-first search, otherwise, just look at','line_number':407,'multiline':False]
['text':' slots of root','line_number':408,'multiline':False]
['text':' if true include root itself as the first thing','line_number':409,'multiline':False]
['text':' visited (used in modules())','line_number':410,'multiline':False]
['text':' advance iterator to first valid element (or the end, if empty)','line_number':413,'multiline':False]
['text':' empty cursors_, represents end of iteration','line_number':416,'multiline':False]
['text':' this is really expensive, should we delete it so people don't use it','line_number':429,'multiline':False]
['text':' instead of prefix?','line_number':430,'multiline':False]
['text':' return_module() is a corner case where instead of returning a submodule','line_number':437,'multiline':False]
['text':' of root, we are returning root itself, because we are iterating modules(),','line_number':438,'multiline':False]
['text':' which contains the root module itself.','line_number':439,'multiline':False]
['text':' It is represented with a single SlotCursor whose index is -1.','line_number':440,'multiline':False]
['text':' advance to the next slot in a depth first pre-order traversal of the','line_number':455,'multiline':False]
['text':' modules slots. This function does not guarantee the next slot is a','line_number':456,'multiline':False]
['text':' valid element of the iteration. That is done by valid().','line_number':457,'multiline':False]
['text':' invariant: !cursors_.empty()','line_number':458,'multiline':False]
['text':' we just returned the module itself, advance i_ to 0 so we are now','line_number':460,'multiline':False]
['text':' at the first slot of the module.','line_number':461,'multiline':False]
['text':' the last traversal action advanced beyond the number of slots in the','line_number':466,'multiline':False]
['text':' module so continue the iteration in the parent.','line_number':467,'multiline':False]
['text':' if the current thing is a module, we have to scan it for recursive','line_number':475,'multiline':False]
['text':' traversals. We do this by adding a new SlotCursor to track the traversal.','line_number':476,'multiline':False]
['text':' common case: advance to the next slot.','line_number':482,'multiline':False]
['text':' is the current position of the iterator a valid one?','line_number':485,'multiline':False]
['text':' otherwise, we have to continue advancing.','line_number':486,'multiline':False]
['text':' advance iteration until we are either at the end (cursors_.empty())','line_number':496,'multiline':False]
['text':' or in a valid state. return_module() is a special case,','line_number':497,'multiline':False]
['text':' and is always considered valid, regardless of Policy, because it is','line_number':498,'multiline':False]
['text':' it is only true when we are iterating modules.','line_number':499,'multiline':False]
['text':' avoid crashing if this is empty','line_number':505,'multiline':False]
['text':' advance to next element, which is maybe not valid','line_number':509,'multiline':False]
['text':' we are finished iteration when we have no more iteration SlotCursors.','line_number':520,'multiline':False]
['text':' end is always an empty iterator with no cursors.','line_number':521,'multiline':False]
['text':' This type represents lists of parameters, attributes, and','line_number':526,'multiline':False]
['text':' submodules contained in the module. It is abstract because','line_number':527,'multiline':False]
['text':' they are not stored directly in std::vectors but inside the','line_number':528,'multiline':False]
['text':' module's IValue object itself.','line_number':529,'multiline':False]
['text':' NOLINTNEXTLINE(clang-diagnostic-unused-variable)','line_number':544,'multiline':False]
['text':' Suppress unused variable warning','line_number':546,'multiline':False]
['text':' size of this list, cached on first request','line_number':567,'multiline':False]
['text':' when we need to filter the slot list','line_number':568,'multiline':False]
['text':' slot_iterator_impl always iterate over all the slots in a module,','line_number':575,'multiline':False]
['text':' the Policy template argument determines slots should be returned and their','line_number':576,'multiline':False]
['text':' types','line_number':577,'multiline':False]
['text':' the type of the value being returned','line_number':579,'multiline':False]
['text':' the logic for creating the type being returned, given the raw IValue','line_number':582,'multiline':False]
['text':' of that object.','line_number':583,'multiline':False]
['text':' is slot i in typ something that this iterator should return, otherwise,','line_number':589,'multiline':False]
['text':' we skip it.','line_number':590,'multiline':False]
['text':' are we going to return everything? If so, we can optimize the calculate','line_number':594,'multiline':False]
['text':' of the size of the list.','line_number':595,'multiline':False]
['text':' take a Policy object, and make a version of it that returns the slot.','line_number':639,'multiline':False]
['text':' along with the fully qualified name of that slot. This is used for the named_','line_number':640,'multiline':False]
['text':' variants like named_parameters().','line_number':641,'multiline':False]
['text':' namespace detail','line_number':674,'multiline':False]
['text':' We once had a `script::` namespace that was deleted. This is for backcompat','line_number':679,'multiline':False]
['text':' of the public API; new code should not use this type alias.','line_number':680,'multiline':False]
['text':' namespace script','line_number':683,'multiline':False]
['text':' namespace torch::jit','line_number':685,'multiline':False]
