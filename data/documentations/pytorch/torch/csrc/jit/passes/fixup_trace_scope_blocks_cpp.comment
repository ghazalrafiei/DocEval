['text':' This pass does several things:','line_number':22,'multiline':False]
['text':' 1) It looks at TracedModuleForward nodes and resolves the type of `self`','line_number':23,'multiline':False]
['text':'    for that (to-be) method call. It adds an input of that type to the','line_number':24,'multiline':False]
['text':'    block, and adds the TracedAttr value corresponding to that `self`','line_number':25,'multiline':False]
['text':'    value as a Node input. This ensures `self` is an explicit Use on','line_number':26,'multiline':False]
['text':'    the node, a property we take advantage of downstream. Example:','line_number':27,'multiline':False]
['text':' 2) Convert all references to prim::TracedAttr values to prim::GetAttr','line_number':28,'multiline':False]
['text':'    calls in the tightest scope possible. Concretely, for each use of','line_number':29,'multiline':False]
['text':'    a prim::TracedAttr value, we compare the scope of that attribute','line_number':30,'multiline':False]
['text':'    to the scope of the Use. We emit GetAttr nodes for all atoms','line_number':31,'multiline':False]
['text':'    that are not shared between the two. For example, if an','line_number':32,'multiline':False]
['text':'    attribute `f.param` is referenced in scope `f`, we emit a','line_number':33,'multiline':False]
['text':'    GetAttr[name="param"](%self) node in the `f` block, where','line_number':34,'multiline':False]
['text':'    `self` is the previously-added `self` argument to the block.','line_number':35,'multiline':False]
['text':' 3) Destroy all the prim::TracedAttr nodes, as they should have','line_number':36,'multiline':False]
['text':'    no more uses.','line_number':37,'multiline':False]
['text':'','line_number':38,'multiline':False]
['text':' A quick example:','line_number':39,'multiline':False]
['text':'','line_number':40,'multiline':False]
['text':'','line_number':41,'multiline':False]
['text':' Input graph:','line_number':42,'multiline':False]
['text':'','line_number':43,'multiline':False]
['text':'     graph(%self : ClassType<Module>,','line_number':44,'multiline':False]
['text':'           %x : Float(3, 4)):','line_number':45,'multiline':False]
['text':'       %1 : bool = prim::TracedAttr[scope="__module.training"]()','line_number':46,'multiline':False]
['text':'       %2 : ClassType<Module> = prim::TracedAttr[scope="__module.f"]()','line_number':47,'multiline':False]
['text':'       %3 : Float(4, 4) = prim::TracedAttr[scope="__module.f.param"]()','line_number':48,'multiline':False]
['text':'       %4 : bool = prim::TracedAttr[scope="__module.f.training"]()','line_number':49,'multiline':False]
['text':'       = prim::TracedModuleForward[scope="__module.f"](),','line_number':50,'multiline':False]
['text':'         block0():','line_number':51,'multiline':False]
['text':'           %6 : Float(3, 4) = aten::mm(%x, %3),','line_number':52,'multiline':False]
['text':'           -> ()','line_number':53,'multiline':False]
['text':'       return (%6)','line_number':54,'multiline':False]
['text':'','line_number':55,'multiline':False]
['text':' The diff after step (1)','line_number':56,'multiline':False]
['text':'','line_number':57,'multiline':False]
['text':'     -   = prim::TracedModuleForward[scope="__module.f"](),','line_number':58,'multiline':False]
['text':'     -    block0():','line_number':59,'multiline':False]
['text':'     +   = prim::TracedModuleForward[scope="__module.f"](%2),','line_number':60,'multiline':False]
['text':'     +    block0(%self : ClassType<Module>):','line_number':61,'multiline':False]
['text':'','line_number':62,'multiline':False]
['text':' The diff after step (2)','line_number':63,'multiline':False]
['text':'','line_number':64,'multiline':False]
['text':'       graph(%self.1 : ClassType<Module>,','line_number':65,'multiline':False]
['text':'             %x : Float(3, 4)):','line_number':66,'multiline':False]
['text':'       +  %9 : ClassType<Module> = prim::GetAttr[name="f"](%self.1)','line_number':67,'multiline':False]
['text':'         %1 : bool = prim::TracedAttr[scope="__module.training"]()','line_number':68,'multiline':False]
['text':'           <....>','line_number':69,'multiline':False]
['text':'         %4 : bool = prim::TracedAttr[scope="__module.f.training"]()','line_number':70,'multiline':False]
['text':'       -   = prim::TracedModuleForward[scope="__module.f"](%2),','line_number':71,'multiline':False]
['text':'       +   = prim::TracedModuleForward[scope="__module.f"](%9),','line_number':72,'multiline':False]
['text':'           block0(%self : ClassType<Module>):','line_number':73,'multiline':False]
['text':'       -      %6 : Float(3, 4) = aten::mm(%x, %3),','line_number':74,'multiline':False]
['text':'       +      %8 : Tensor = prim::GetAttr[name="param"](%self)','line_number':75,'multiline':False]
['text':'       +      %6 : Float(3, 4) = aten::mm(%x, %8),','line_number':76,'multiline':False]
['text':'             -> ()','line_number':77,'multiline':False]
['text':'         return (%6)','line_number':78,'multiline':False]
['text':'','line_number':79,'multiline':False]
['text':' The diff after step (3)','line_number':80,'multiline':False]
['text':'','line_number':81,'multiline':False]
['text':'       -  %1 : bool = prim::TracedAttr[scope="__module.training"]()','line_number':82,'multiline':False]
['text':'       -  %2 : ClassType<Module> = prim::TracedAttr[scope="__module.f"]()','line_number':83,'multiline':False]
['text':'       -  %3 : Float(4, 4) = prim::TracedAttr[scope="__module.f.param"]()','line_number':84,'multiline':False]
['text':'       -  %4 : bool = prim::TracedAttr[scope="__module.f.training"]()','line_number':85,'multiline':False]
['text':' Build a table mapping--for each TracedAttr node--the','line_number':88,'multiline':False]
['text':' qualified name of the attribute to the Value* output','line_number':89,'multiline':False]
['text':' of the Node.','line_number':90,'multiline':False]
['text':' Step 1','line_number':92,'multiline':False]
['text':' Step 2','line_number':94,'multiline':False]
['text':' Step 3','line_number':97,'multiline':False]
['text':' This is a recursive function that descends down all blocks in the Graph','line_number':124,'multiline':False]
['text':' (NB: not just TracedModuleForward blocks). Each descension has a','line_number':125,'multiline':False]
['text':' corresponding `prefix`, i.e. the qualified name of the scope this','line_number':126,'multiline':False]
['text':' Block represents (or the scope in which this block resides for','line_number':127,'multiline':False]
['text':' non-TracedModuleForward nodes). We use this prefix to make decisions','line_number':128,'multiline':False]
['text':' about whether to emit a GetAttr node for an attribute reference, or','line_number':129,'multiline':False]
['text':' to defer that emission to the caller (in the case where an attribute','line_number':130,'multiline':False]
['text':' reference does not reside in the `prefix` scope).','line_number':131,'multiline':False]
['text':' Store away Value*'s which are references to TracedAttr's which are','line_number':136,'multiline':False]
['text':' not in the `prefix` scope. We pass this back to the caller, who','line_number':137,'multiline':False]
['text':' should add these Values as explicit inputs as well as inductively','line_number':138,'multiline':False]
['text':' make the same decision on those Values.','line_number':139,'multiline':False]
['text':' To ensure we don't emit redundant GetAttr Nodes in a given scope,','line_number':141,'multiline':False]
['text':' we maintain this map of original TracedAttr Value* to the Value*','line_number':142,'multiline':False]
['text':' corresponding to the GetAttr for that attribute.','line_number':143,'multiline':False]
['text':' We don't rely on CSE here because we currently can't reason about','line_number':144,'multiline':False]
['text':' the correctness of CSE over GetAttr Nodes (i think)','line_number':145,'multiline':False]
['text':' The only difference between these two branches is for','line_number':149,'multiline':False]
['text':' TracedModuleForward we advance the scope, but for other','line_number':150,'multiline':False]
['text':' Nodes with Blocks we don't','line_number':151,'multiline':False]
['text':' Short circuit: if we've already emitted a new Value for this','line_number':171,'multiline':False]
['text':' attribute, just use that.','line_number':172,'multiline':False]
['text':' for (Value *inp : n->inputs())','line_number':181,'multiline':False]
['text':' for (Node *n : b->nodes())','line_number':182,'multiline':False]
['text':' Prefix case: the attribute resides in this scope or a','line_number':199,'multiline':False]
['text':' sub-scope. Continually emit GetAttr nodes until we've reached','line_number':200,'multiline':False]
['text':' the proper attribute.','line_number':201,'multiline':False]
['text':' if (i < prefix_atoms.size())','line_number':210,'multiline':False]
['text':' for(const auto i : c10::irange(attr_atoms.size()))','line_number':211,'multiline':False]
['text':' Non-prefix case: this is a use of an attribute somewhere','line_number':215,'multiline':False]
['text':' higher in the Module hierarchy. Add a captured input to','line_number':216,'multiline':False]
['text':' the block for this attribute and add to the vector of','line_number':217,'multiline':False]
['text':' Value*'s for the caller to handle.','line_number':218,'multiline':False]
['text':' if (prefix.isPrefixOf(attr_qualname))','line_number':223,'multiline':False]
['text':' if (inp_node->kind() == prim::TracedAttr)','line_number':224,'multiline':False]
['text':' The previous pass should have deleted all uses of TracedAttr','line_number':227,'multiline':False]
['text':' nodes. Let's explicitly delete them here.','line_number':228,'multiline':False]
['text':' For each prim::TracedAttr, record the `scope` value mapped','line_number':235,'multiline':False]
['text':' to the Value* in the graph for that attribute.','line_number':236,'multiline':False]
['text':' Iterate through all the nodes in program order and--for each use--','line_number':240,'multiline':False]
['text':' if the Value referenced is not in a scope that dominates the node,','line_number':241,'multiline':False]
['text':' add block and Node outputs to lift it into a scope in which','line_number':242,'multiline':False]
['text':' it dominates the Use.','line_number':243,'multiline':False]
['text':' Already lifted to this level by a previously processed Use, switch to','line_number':260,'multiline':False]
['text':' remapped value','line_number':261,'multiline':False]
['text':' This conditional isn't strictly necessary, but saves a lot of','line_number':268,'multiline':False]
['text':' computation in the common case that we're using a local value.','line_number':269,'multiline':False]
['text':' Find the common ancestor block between this node and the node that','line_number':271,'multiline':False]
['text':' produced this input. For this input Use to be valid, the Value's','line_number':272,'multiline':False]
['text':' def must be present in this common ancestor node.','line_number':273,'multiline':False]
['text':' Starting from the initial def for this input, iterate to','line_number':280,'multiline':False]
['text':' wider and wider blocks, adding Block outputs and Node outputs','line_number':281,'multiline':False]
['text':' along the way. Then, log the lifted values in the remap table','line_number':282,'multiline':False]
['text':' so we can make subsequent Uses refer to the lifted value, if','line_number':283,'multiline':False]
['text':' the domination condition is met.','line_number':284,'multiline':False]
['text':' From now on, references to `inp` will be replaced with','line_number':292,'multiline':False]
['text':' references to `v_itr`, the lifted Value','line_number':293,'multiline':False]
['text':' This holds the mapping between a Value* we would see in a Use','line_number':304,'multiline':False]
['text':' and the lifted value, if present. We use this to ensure that','line_number':305,'multiline':False]
['text':' Uses refer to a Value* that is in a dominating scope.','line_number':306,'multiline':False]
['text':' For all blocks except graph->block(), convert multiple block','line_number':311,'multiline':False]
['text':' returns to a TupleConstruct. This is required for turning the','line_number':312,'multiline':False]
['text':' blocks into Methods. (and in the case that self is nullptr,','line_number':313,'multiline':False]
['text':' it is required to properly inline the blocks).','line_number':314,'multiline':False]
['text':' Make block returns go through a Tuple','line_number':327,'multiline':False]
['text':' Make node outputs a single tuple;','line_number':337,'multiline':False]
['text':' Lambda lift Values (i.e. add Graph inputs for the purpose of','line_number':358,'multiline':False]
['text':' referencing values that dominate the block) and convert','line_number':359,'multiline':False]
['text':' the block to a Graph. blocks()[0] on each TracedModuleForward then','line_number':360,'multiline':False]
['text':' appears as a Graph attribute attr::Subgraph','line_number':361,'multiline':False]
['text':' Find a unique name to add this method as','line_number':383,'multiline':False]
['text':' We try {method_name}, {method_name}1, {method_name}2, ...','line_number':384,'multiline':False]
['text':' Register the attr::Subgraph Graph values as Functions in the','line_number':407,'multiline':False]
['text':' class compilation unit and register that Function as a method','line_number':408,'multiline':False]
['text':' on the corresponding Module in the Module hierarchy. Note that we','line_number':409,'multiline':False]
['text':' unique the methods by naming them forward, forward1, forward2...','line_number':410,'multiline':False]
['text':' Convert the block to a graph so we can inline it','line_number':449,'multiline':False]
['text':' Run a few clean-up passes to make the graph a bit cleaner.','line_number':492,'multiline':False]
['text':' namespace','line_number':525,'multiline':False]
['text':' We have no Module, so we're just going to inline everything.','line_number':538,'multiline':False]
['text':' This should give us a totally flat graph.','line_number':539,'multiline':False]
['text':' For TracedFork nodes','line_number':541,'multiline':False]
['text':' `graph` isn't referenced in `self` yet, so we need to run','line_number':548,'multiline':False]
['text':' this separately','line_number':549,'multiline':False]
['text':' namespace jit','line_number':554,'multiline':False]
['text':' namespace torch','line_number':555,'multiline':False]
