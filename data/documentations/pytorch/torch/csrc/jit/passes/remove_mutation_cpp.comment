['text':' bail on nodes with side effects, blocks, or graph / graph inputs','line_number':16,'multiline':False]
['text':' if the output isn't contained or alias by the inputs to its node, it's','line_number':22,'multiline':False]
['text':' unique. No need to check for alias if the node is a ListConstruct.','line_number':23,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':32,'multiline':False]
['text':' TODO: we should have normal_like operator','line_number':50,'multiline':False]
['text':' normal(float mean, float std, int[] size, *, Generator? generator=None,','line_number':51,'multiline':False]
['text':' ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool?','line_number':52,'multiline':False]
['text':' pin_memory=None) -> Tensor','line_number':53,'multiline':False]
['text':' We can only remove mutation to values that are unique aliases in the','line_number':107,'multiline':False]
['text':' graph. if x = y[0] or y = self.y, then removing the mutation could','line_number':108,'multiline':False]
['text':' change observable semantics','line_number':109,'multiline':False]
['text':' In order to safely remove a mutation, the creation of a tensor and its','line_number':114,'multiline':False]
['text':' subsequent mutation need to be one atomic operation','line_number':115,'multiline':False]
['text':' if cond:','line_number':123,'multiline':False]
['text':'    x = op()','line_number':124,'multiline':False]
['text':' else:','line_number':125,'multiline':False]
['text':'    x = op()','line_number':126,'multiline':False]
['text':' x = add_(1)','line_number':127,'multiline':False]
['text':' if x in both blocks have no other uses and are unaliased in the graph,','line_number':128,'multiline':False]
['text':' and we make the if node and the mutation atomic,','line_number':129,'multiline':False]
['text':' then removing mutation add_ does not change observable semantics','line_number':130,'multiline':False]
['text':' We rewrite something like:','line_number':175,'multiline':False]
['text':' x = {v0}','line_number':176,'multiline':False]
['text':' x.append(v1) (or x.insert(0, v1))','line_number':177,'multiline':False]
['text':' to:','line_number':178,'multiline':False]
['text':' x = {v0, v1} (or x = {v1, v0})','line_number':179,'multiline':False]
['text':' We can remove x.append from the alias db list of writes.','line_number':180,'multiline':False]
['text':' All other aliasing properties remain valid.','line_number':181,'multiline':False]
['text':' insert to neg position equals insert to std::max(pos+size, 0)','line_number':190,'multiline':False]
['text':' insert beyond current list length is the same as append','line_number':194,'multiline':False]
['text':' process use-chain and aliasing of node output','line_number':212,'multiline':False]
['text':' TODO: don't strictly need to reset write cache, evaluate on models','line_number':221,'multiline':False]
['text':' TODO: out op variants','line_number':245,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':256,'multiline':False]
['text':' weird case where there is an inplace op and an equivalent functional op','line_number':271,'multiline':False]
['text':' of the same symbol, but they have different schemas','line_number':272,'multiline':False]
['text':' We rewrite something like:','line_number':283,'multiline':False]
['text':' x = torch.zeros()','line_number':284,'multiline':False]
['text':' x.add_(1)','line_number':285,'multiline':False]
['text':' x.add_(2)','line_number':286,'multiline':False]
['text':' to:','line_number':287,'multiline':False]
['text':' x = torch.zeros()','line_number':288,'multiline':False]
['text':' x0 = x.add(1)','line_number':289,'multiline':False]
['text':' x0.add_(2)','line_number':290,'multiline':False]
['text':' For the remainder of the function, x0 will have the','line_number':291,'multiline':False]
['text':' same aliasing relationships as the original x.','line_number':292,'multiline':False]
['text':' To avoid rebuilding the entire alias db, we can replace','line_number':293,'multiline':False]
['text':' the memory DAG element of x with x0.','line_number':294,'multiline':False]
['text':' it is an invariant that all mutable types have an element in the memory','line_number':298,'multiline':False]
['text':' DAG so we must regive x an alias db element. We have already verified','line_number':299,'multiline':False]
['text':' that the mutated value is a fresh alias with a single use.','line_number':300,'multiline':False]
['text':' We must erase the destroyed node from the AliasDb lists of writes','line_number':303,'multiline':False]
['text':' now that we have removed a mutating op, the write cache is stale','line_number':307,'multiline':False]
['text':' TODO: don't strictly need to reset write cache, evaluate on models','line_number':308,'multiline':False]
['text':' needs to have alias analysis by schema','line_number':330,'multiline':False]
['text':' all inplace ops at time of writing have a single input that is mutated','line_number':339,'multiline':False]
['text':' and returned. check that this is true, anything else could have strange','line_number':340,'multiline':False]
['text':' semantics,','line_number':341,'multiline':False]
['text':' namespace jit','line_number':383,'multiline':False]
['text':' namespace torch','line_number':384,'multiline':False]
