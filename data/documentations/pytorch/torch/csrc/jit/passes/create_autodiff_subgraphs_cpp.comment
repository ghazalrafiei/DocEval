['text':' We maintain alias db correctness in-place while building up the autodiff','line_number':44,'multiline':False]
['text':' subgraphs, however it is difficult to preserve correctness when','line_number':45,'multiline':False]
['text':' un-inlining autodiff subgraphs. We first recursively construct all','line_number':46,'multiline':False]
['text':' subgraphs and then recursively cleanup & unmerge the small subgraphs','line_number':47,'multiline':False]
['text':' Run CSE globally onceto eliminate duplicates that may have occurred','line_number':52,'multiline':False]
['text':' while inlining subgraphs.','line_number':53,'multiline':False]
['text':' Save the previous node, since we might delete `curNode` in next block','line_number':60,'multiline':False]
['text':' Inlining nodes may cause some subexpression to come back in the','line_number':63,'multiline':False]
['text':' subgraphs (for example, copying constants in repeatedly will generate','line_number':64,'multiline':False]
['text':' redundant prim::Constants). Run CSE to clean them up.','line_number':65,'multiline':False]
['text':' We need to run the slicer multiple times in order to get all merge','line_number':84,'multiline':False]
['text':' opportunities. This is because moveBeforeTopologicalValid may reorder','line_number':85,'multiline':False]
['text':' nodes to be AFTER the current iteration point. In order to properly','line_number':86,'multiline':False]
['text':' consider those nodes for merging, we need run the pass until no changes','line_number':87,'multiline':False]
['text':' have been made.','line_number':88,'multiline':False]
['text':'','line_number':89,'multiline':False]
['text':' Example:','line_number':90,'multiline':False]
['text':'   c = f(a, b)','line_number':91,'multiline':False]
['text':'   d = f(c)','line_number':92,'multiline':False]
['text':'   e = f(d)  <- iter is here, moving upward','line_number':93,'multiline':False]
['text':' After c.moveBeforeTopologicallyValid(e), we have:','line_number':94,'multiline':False]
['text':'   c = f(a, b)','line_number':95,'multiline':False]
['text':'   e = f(d)  <- iter still here','line_number':96,'multiline':False]
['text':'   d = f(c)  <- this was node moved on the other side.','line_number':97,'multiline':False]
['text':' see [workblocks]','line_number':99,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':107,'multiline':False]
['text':' Construct Subgraphs Recursively','line_number':115,'multiline':False]
['text':' we walk in the reverse order, so we can skip','line_number':130,'multiline':False]
['text':' nodes that might get unfused after the current','line_number':131,'multiline':False]
['text':' prim::DifferentiableGraph','line_number':132,'multiline':False]
['text':' aliased outputs in DifferentiableGraphs must be unfused','line_number':135,'multiline':False]
['text':' since autodiff doesn't know how to handle them correctly','line_number':136,'multiline':False]
['text':' N.B. Note, |= since we don't want `unfuseAliasedOutputs`','line_number':137,'multiline':False]
['text':' to short-circuit','line_number':138,'multiline':False]
['text':' [workblocks]','line_number':158,'multiline':False]
['text':' the IR has many nodes which can never be reordered around, such as a','line_number':159,'multiline':False]
['text':' prim::Bailout. if a node N is surrounded by two nodes which cannot be','line_number':160,'multiline':False]
['text':' reordered, A and B, then a differentiable subgraph that is created from N','line_number':161,'multiline':False]
['text':' can only contain nodes from (A, B) The nodes from A to B represent one','line_number':162,'multiline':False]
['text':' work block for the subgraph slicer to work on. By creating these up','line_number':163,'multiline':False]
['text':' front, we avoid retraversing the whole graph block any time scanNode','line_number':164,'multiline':False]
['text':' returns, and we can also avoid attempting to create differentiable','line_number':165,'multiline':False]
['text':' subgraphs in work blocks that do not contain a # of differentiable nodes','line_number':166,'multiline':False]
['text':' >= minSubgraphSize_','line_number':167,'multiline':False]
['text':' cannot reorder around side effectful nodes','line_number':178,'multiline':False]
['text':' not enough differentiable nodes to create a differentiable subgraph','line_number':180,'multiline':False]
['text':' Inline this node's group subgraph into the outer graph if it's smaller','line_number':197,'multiline':False]
['text':' than the specified minimum size.','line_number':198,'multiline':False]
['text':'','line_number':199,'multiline':False]
['text':' Returns true if an inlining has occurred, false otherwise.','line_number':200,'multiline':False]
['text':' Sort in reverse topological order','line_number':224,'multiline':False]
['text':' if we're already in the process of merging','line_number':246,'multiline':False]
['text':' view ops as outputs of differentiable subgraphs can cause incorrect','line_number':254,'multiline':False]
['text':' differentiation for now, do not include them in the subgraph','line_number':255,'multiline':False]
['text':' we successfully merged, so the new group's `inputs` may have','line_number':272,'multiline':False]
['text':' changed. So rescan the new group for more merging opportunities.','line_number':273,'multiline':False]
['text':' Try to merge `producer` into `consumer`. If successful, this destroys','line_number':282,'multiline':False]
['text':' `producer` and returns the `consumer` group.','line_number':283,'multiline':False]
['text':' [Only consider profiles in the same context]','line_number':367,'multiline':False]
['text':' Ignore profiled uses if the use is within a different context.','line_number':368,'multiline':False]
['text':' For example, a profile node within a no_grad() context will record the','line_number':369,'multiline':False]
['text':' wrong requires_grad information.','line_number':370,'multiline':False]
['text':' maybe the profile node got absorbed into a differentiable graph','line_number':383,'multiline':False]
['text':' check all the uses of this graph input to look for profile nodes.','line_number':386,'multiline':False]
['text':' See [Only consider profiles in the same context]','line_number':389,'multiline':False]
['text':' already have requires_grad info from this profile node','line_number':417,'multiline':False]
['text':' non-tensors don't get profiled.','line_number':421,'multiline':False]
['text':' this node doesn't have any requires_grad info.','line_number':428,'multiline':False]
['text':' look at its uses to try to find a profile node.','line_number':429,'multiline':False]
['text':' autodiff.cpp needs to know, for each output, whether or not it requires','line_number':451,'multiline':False]
['text':' grad. Sometimes a profile node will be present on the output, but sometimes','line_number':452,'multiline':False]
['text':' it won't be present. This might happen if there's a node with side effects','line_number':453,'multiline':False]
['text':' in between the definition of the output node and the profile node; in this','line_number':454,'multiline':False]
['text':' case the profile node and output node would be in different workblocks and','line_number':455,'multiline':False]
['text':' couldn't be merged into the same DifferentiableGraph. (see [workblocks])','line_number':456,'multiline':False]
['text':' Or it could happen if the output is profiled twice and the profile nodes get','line_number':457,'multiline':False]
['text':' removed by unfusedAliasedOutputs.','line_number':458,'multiline':False]
['text':' anonymous namespace','line_number':463,'multiline':False]
['text':' namespace jit','line_number':477,'multiline':False]
['text':' namespace torch','line_number':478,'multiline':False]
