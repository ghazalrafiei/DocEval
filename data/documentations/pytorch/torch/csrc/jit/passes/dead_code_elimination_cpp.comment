['text':' The algorithm is an inverse mark-and-sweep. Starting from the return node,','line_number':28,'multiline':False]
['text':' we mark "live" nodes that are necessary for the output. Nodes that have','line_number':29,'multiline':False]
['text':' side effects are also marked.','line_number':30,'multiline':False]
['text':' clean up unused fork inputs before starting the main algorithm','line_number':32,'multiline':False]
['text':' Initialize by marking the return node and all its consumed values as live','line_number':35,'multiline':False]
['text':' WARNING: Do not use a ranged loop. The loop bounds are changed by the','line_number':63,'multiline':False]
['text':' loop body.','line_number':64,'multiline':False]
['text':' Special handling for block return nodes. Unlike other nodes, the block','line_number':82,'multiline':False]
['text':' return node doesn't really "use" its inputs. Consider:','line_number':83,'multiline':False]
['text':'','line_number':84,'multiline':False]
['text':' %a0 = aten::foo()','line_number':85,'multiline':False]
['text':' %b = aten::foo()','line_number':86,'multiline':False]
['text':' %a2, %b2 = prim::If(%cond) {','line_number':87,'multiline':False]
['text':'   block0() {','line_number':88,'multiline':False]
['text':'     %a1 = aten::foo(%.0)','line_number':89,'multiline':False]
['text':'     %b1 = aten::foo(%b)','line_number':90,'multiline':False]
['text':'   } -> (%a1, %b1)','line_number':91,'multiline':False]
['text':' }','line_number':92,'multiline':False]
['text':' return (%a2)','line_number':93,'multiline':False]
['text':'','line_number':94,'multiline':False]
['text':' We want to be able to DCE all the %b stuff. So when processing block','line_number':95,'multiline':False]
['text':' returns, we only mark producers for values that "live" (i.e. used outside','line_number':96,'multiline':False]
['text':' the block).','line_number':97,'multiline':False]
['text':'','line_number':98,'multiline':False]
['text':' Returns true iff this marked something we haven't marked before.','line_number':99,'multiline':False]
['text':' If there's no outer node, we're looking at the graph's top-level','line_number':108,'multiline':False]
['text':' return block. We consider all graph outputs to be "used", so just mark','line_number':109,'multiline':False]
['text':' this node normally.','line_number':110,'multiline':False]
['text':' Collect all inputs that are actually live','line_number':114,'multiline':False]
['text':' Special handling to deal with loop carried dependencies.','line_number':117,'multiline':False]
['text':' Special handling for onnx loop.','line_number':121,'multiline':False]
['text':' The number of body carried inputs and outputs are different.','line_number':122,'multiline':False]
['text':' They cannot be mapped to each other easily by the same index.','line_number':123,'multiline':False]
['text':' Also mark the loop next condition as live, since it will be used inside','line_number':135,'multiline':False]
['text':' the loop body.','line_number':136,'multiline':False]
['text':' Loops are special, because we need to run them to convergence.','line_number':153,'multiline':False]
['text':' Consider the following loop:','line_number':154,'multiline':False]
['text':'   for i in range(3):','line_number':155,'multiline':False]
['text':'     tot += a[0][0]','line_number':156,'multiline':False]
['text':'     b = a[0]','line_number':157,'multiline':False]
['text':'     b[0] += 1','line_number':158,'multiline':False]
['text':'   print(tot)','line_number':159,'multiline':False]
['text':'','line_number':160,'multiline':False]
['text':' If we only process the loop block once, we will conclude that `b[0]` and','line_number':161,'multiline':False]
['text':' `b` are dead, even though `b[0] += 1` mutates a live memory location (since','line_number':162,'multiline':False]
['text':' `b[0]` is an alias of `a`). i.e. `a` is used to compute `tot` in the next','line_number':163,'multiline':False]
['text':' iteration','line_number':164,'multiline':False]
['text':'','line_number':165,'multiline':False]
['text':' We need to mark the loop again with the information that `a` is live, and','line_number':166,'multiline':False]
['text':' repeat until we're not marking new stuff anymore.','line_number':167,'multiline':False]
['text':'','line_number':168,'multiline':False]
['text':' Returns true iff this marked something we haven't marked before.','line_number':169,'multiline':False]
['text':' Did a single iteration over the loop block mark anything new?','line_number':172,'multiline':False]
['text':' If this is false, we've converged.','line_number':173,'multiline':False]
['text':' Did we ever mark anything new?','line_number':175,'multiline':False]
['text':' Returns true iff this marked something we haven't marked before.','line_number':184,'multiline':False]
['text':' Mark all nodes with side effects.','line_number':187,'multiline':False]
['text':' Initialize by marking the return node','line_number':196,'multiline':False]
['text':' Special casing for loops, see comment in markLoop.','line_number':202,'multiline':False]
['text':' Other nodes with sub-blocks get marked normally.','line_number':205,'multiline':False]
['text':' If we output or write to a live memory location, mark this node','line_number':215,'multiline':False]
['text':' Returns true iff this marked something we haven't marked before.','line_number':216,'multiline':False]
['text':' Mark this node as live and add this node's inputs and aliases to the live','line_number':233,'multiline':False]
['text':' value sets.','line_number':234,'multiline':False]
['text':' Returns true iff this marked something we haven't marked before.','line_number':235,'multiline':False]
['text':' Mark all nodes in this node's blockchain (since owning nodes are','line_number':243,'multiline':False]
['text':' considered live if they contain a live node)','line_number':244,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)','line_number':255,'multiline':False]
['text':' Delete all unmarked nodes.','line_number':265,'multiline':False]
['text':' note these occur before the recursion because we want to uncover','line_number':270,'multiline':False]
['text':' dead code in the blocks used to calculate the output','line_number':271,'multiline':False]
['text':' NB: Checking hasUses() is required. AD graphs are not perfectly','line_number':279,'multiline':False]
['text':' valid, as a node in grad_desc.f might be used in reverse_block.','line_number':280,'multiline':False]
['text':' Reverse_block is inlined in grad_desc.f before it's separated','line_number':281,'multiline':False]
['text':' to grad_desc.df.','line_number':282,'multiline':False]
['text':' If we don't have alias information, all mutable ops have unknown','line_number':298,'multiline':False]
['text':' effects and can't be considered for elimination.','line_number':299,'multiline':False]
['text':' SetAttr is a special case: it doesn't have a schema, but does','line_number':302,'multiline':False]
['text':' have untracked mutations','line_number':303,'multiline':False]
['text':' onnx export calls EliminateDeadCode but sometimes passes invalid','line_number':307,'multiline':False]
['text':' aten operators. So we call maybeSchema so we handle the cases when','line_number':308,'multiline':False]
['text':' there is no valid schema for a node','line_number':309,'multiline':False]
['text':' offset of loop carried deps in input list','line_number':368,'multiline':False]
['text':' offset to the loop carried dependencies in block inputs/outputs','line_number':370,'multiline':False]
['text':' lazily initialized','line_number':428,'multiline':False]
['text':'recurse=','line_number':441,'multiline':True]
['text':'recurse=','line_number':458,'multiline':True]
['text':' namespace jit','line_number':461,'multiline':False]
['text':' namespace torch','line_number':462,'multiline':False]
