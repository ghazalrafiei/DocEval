['text':' namespace','line_number':26,'multiline':False]
['text':' This pass looks for trees in the graph, where leaves are mm ops, and the','line_number':28,'multiline':False]
['text':' inner vertices are add nodes. Once we have such a tree they can be reduced to','line_number':29,'multiline':False]
['text':' two concats and a single mm (basically into a single multiply of a wide','line_number':30,'multiline':False]
['text':' matrix, with a tall matrix). Such patterns show up mostly in backward of','line_number':31,'multiline':False]
['text':' RNNs, since the derivative of many uses of matrix multiplies with same','line_number':32,'multiline':False]
['text':' weights forms exactly such a tree (note that it's usually also highly','line_number':33,'multiline':False]
['text':' imbalanced i.e. has O(n) depth).','line_number':34,'multiline':False]
['text':'','line_number':35,'multiline':False]
['text':' This (or any tree of adds of MMs):','line_number':36,'multiline':False]
['text':'','line_number':37,'multiline':False]
['text':' +------+ +------+   +------+ +------+   +------+','line_number':38,'multiline':False]
['text':' |      | |      |   |      | |      |   |      |','line_number':39,'multiline':False]
['text':' |  L1  | |  R1  | + |  L2  | |  R2  | = |  O   |','line_number':40,'multiline':False]
['text':' |      | |      |   |      | |      |   |      |','line_number':41,'multiline':False]
['text':' +------+ +------+   +------+ +------+   +------+','line_number':42,'multiline':False]
['text':'','line_number':43,'multiline':False]
['text':' can be basically transformed into a single MM which looks like this','line_number':44,'multiline':False]
['text':' (we concat all lhs operands, concat rhs operands, do mm):','line_number':45,'multiline':False]
['text':'','line_number':46,'multiline':False]
['text':'                 +------+','line_number':47,'multiline':False]
['text':'                 |      |','line_number':48,'multiline':False]
['text':'                 |  R1  |','line_number':49,'multiline':False]
['text':'                 |      |','line_number':50,'multiline':False]
['text':'                 +------+','line_number':51,'multiline':False]
['text':'                 |      |','line_number':52,'multiline':False]
['text':'                 |  R2  |','line_number':53,'multiline':False]
['text':'                 |      |','line_number':54,'multiline':False]
['text':'                 +------+','line_number':55,'multiline':False]
['text':' +------+------+ +------+','line_number':56,'multiline':False]
['text':' |      |      | |      |','line_number':57,'multiline':False]
['text':' |  L1  |  L2  | |  O   |','line_number':58,'multiline':False]
['text':' |      |      | |      |','line_number':59,'multiline':False]
['text':' +------+------+ +------+','line_number':60,'multiline':False]
['text':' Note [Further optimizations]','line_number':62,'multiline':False]
['text':' It would be straightforward to extend the TreeToken class to also detect if','line_number':63,'multiline':False]
['text':' all MMs had the same lhs/rhs. In such case it's more efficient to expand the','line_number':64,'multiline':False]
['text':' lhs and use bmm + sum instead of repeating it in memory via concat.','line_number':65,'multiline':False]
['text':' Note [Overlapping trees]','line_number':67,'multiline':False]
['text':' Additionally it wouldn't be too hard to add support for partially overlapping','line_number':68,'multiline':False]
['text':' trees. Right now the it's forbidden in the algorithm (only a single tree will','line_number':69,'multiline':False]
['text':' be allowed), so theoretically we might miss some optimization options,','line_number':70,'multiline':False]
['text':' especially that the rejected tree could be much larger. I didn't implement','line_number':71,'multiline':False]
['text':' that because it's not necessary for the simple RNN cases I saw, so I decided','line_number':72,'multiline':False]
['text':' to keep stuff simple. If we ever get around implementing this, the right','line_number':73,'multiline':False]
['text':' solution is probably to fuse MMs for the common part, and assume it's an','line_number':74,'multiline':False]
['text':' input leaf for the outer two parts (I don't think it's beneficial to','line_number':75,'multiline':False]
['text':' recompute, unless the subtree is super small, but let's not get into such','line_number':76,'multiline':False]
['text':' details).','line_number':77,'multiline':False]
['text':' The algorithm we're using is simple. We're iterating through the graph in the','line_number':79,'multiline':False]
['text':' topological order and labeling nodes with TreeTokens. Then, we look for roots','line_number':80,'multiline':False]
['text':' of the trees we formed and fuse them.','line_number':81,'multiline':False]
['text':' Tunable parameter. Set to something larger if it turns out to be better.','line_number':83,'multiline':False]
['text':' Numbers obtained by some simple benchmarks of fp32 gemms on a TITAN V','line_number':110,'multiline':False]
['text':' TODO: checking this is not free, so we should stop if this keeps','line_number':130,'multiline':False]
['text':' failing','line_number':131,'multiline':False]
['text':' sometimes lhs_inputs or rhs_inputs are not contiguous, and that','line_number':134,'multiline':False]
['text':' causes at::cat to go through slow path view them as contiguous if','line_number':135,'multiline':False]
['text':' possible by transposing','line_number':136,'multiline':False]
['text':'dim','line_number':143,'multiline':True]
['text':'dim=','line_number':146,'multiline':True]
['text':'dim','line_number':151,'multiline':True]
['text':'dim=','line_number':154,'multiline':True]
['text':' TreeTokens will be used to label nodes of the graph, if the nodes will fit','line_number':167,'multiline':False]
['text':' our mm/add tree pattern. Basically we do dynamic programming on DAGs, where','line_number':168,'multiline':False]
['text':' when we reach node N with inputs A and B, then A and B have already been','line_number':169,'multiline':False]
['text':' processed, and we can try to unify their TreeTokens (if they have them)','line_number':170,'multiline':False]
['text':' and build a larger tree.','line_number':171,'multiline':False]
['text':' NOTE: measured in number of leaves i.e. mm ops','line_number':173,'multiline':False]
['text':' NB: the returned token might be invalid, so make sure to check its boolean','line_number':185,'multiline':False]
['text':' value!','line_number':186,'multiline':False]
['text':' NB: the returned token might be invalid, so make sure to check its boolean','line_number':200,'multiline':False]
['text':' value!','line_number':201,'multiline':False]
['text':' See Note [Overlapping trees]','line_number':204,'multiline':False]
['text':' Reserve the subtrees, so they can't be used again.','line_number':211,'multiline':False]
['text':' (AB)^T == B^TA^T','line_number':232,'multiline':False]
['text':' Look for trees in the block','line_number':259,'multiline':False]
['text':' See Note [Overlapping trees] (regarding the uses().size() == 1 check)','line_number':280,'multiline':False]
['text':' We could treat a subtree with multiple uses as if it was overlapping.','line_number':281,'multiline':False]
['text':' XXX: uses().size() == 1 is also something that guarantees that this','line_number':282,'multiline':False]
['text':' transform is valid, because we know for sure that the none of these','line_number':283,'multiline':False]
['text':' operands depend on the result of the other. If we were to remove this,','line_number':284,'multiline':False]
['text':' we need to compute a transitive closure and actually check the','line_number':285,'multiline':False]
['text':' dependencies.','line_number':286,'multiline':False]
['text':' Merge trees we've found','line_number':301,'multiline':False]
['text':' NB: don't bother with cleaning up after yourself. We'll use DCE for that.','line_number':317,'multiline':False]
['text':' Cutoff chosed by benchmarking on a TITAN V','line_number':322,'multiline':False]
['text':'dim=','line_number':353,'multiline':True]
['text':' Filter out dependent MMs. This algorithm might do very badly if e.g. you','line_number':383,'multiline':False]
['text':' have a lot of independent MMs, that depend on the first one, but I doubt','line_number':384,'multiline':False]
['text':' this will be a common scenario.','line_number':385,'multiline':False]
['text':' Will contain nodes where value is used as an lhs','line_number':401,'multiline':False]
['text':' Like above, but rhs','line_number':402,'multiline':False]
['text':' NB: 8 is the current loop unrolling factor','line_number':419,'multiline':False]
['text':'inputs=','line_number':431,'multiline':True]
['text':'num_outputs=','line_number':432,'multiline':True]
['text':'bool not_inserted = ','line_number':448,'multiline':True]
['text':' It's possible that transpose rearrangements have created sequences of','line_number':498,'multiline':False]
['text':' consecutive transposes that didn't exist before.','line_number':499,'multiline':False]
['text':' tensor type properties are not guaranteed to be correct','line_number':501,'multiline':False]
['text':'disable_shape_peepholes','line_number':502,'multiline':True]
['text':' namespace jit','line_number':505,'multiline':False]
['text':' namespace torch','line_number':506,'multiline':False]
