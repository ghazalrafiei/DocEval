['text':' EDITING THIS FILE? READ THIS FIRST!','line_number':12,'multiline':False]
['text':' see Note [Edit Pattern Conversion] in pattern_conversion.h','line_number':13,'multiline':False]
['text':' Converting inplace index_put to ONNX','line_number':18,'multiline':False]
['text':' Create index tensor based on index input of aten::select node.','line_number':29,'multiline':False]
['text':' Create index tensor based on aten::slice node.','line_number':36,'multiline':False]
['text':' Loop over fetched slice and select nodes and convert them to index tensors.','line_number':75,'multiline':False]
['text':' keep track of which dimension the current slice/select node is applying to.','line_number':76,'multiline':False]
['text':' select does not keep dims,','line_number':84,'multiline':False]
['text':' this creates offset for latter slice and select nodes.','line_number':85,'multiline':False]
['text':' NOTE: Cannot rely on get(attr::dim), because op no longer match schema.','line_number':86,'multiline':False]
['text':' Rank of original tensor to index on.','line_number':93,'multiline':False]
['text':' Minus the offset created by select operators.','line_number':94,'multiline':False]
['text':' Handle skipped dims, these are created from ..., or tensor indices','line_number':105,'multiline':False]
['text':' E.g.: x[torch.tensor([1, 0]), ..., 0] = update, where x has rank 3.','line_number':106,'multiline':False]
['text':' Both torch.tensor([1, 0]) and ... are skipped, we only observe','line_number':107,'multiline':False]
['text':' aten::select node with dim == 2. Tensor indices will be handled later.','line_number':108,'multiline':False]
['text':' Ellipsis(...) are treated as a complete slice over the axes, thus we','line_number':109,'multiline':False]
['text':' create index tensors here accordingly.','line_number':110,'multiline':False]
['text':' Each dimension should have its associated index tensor.','line_number':169,'multiline':False]
['text':' Convert slice/select operators to tensor indices.','line_number':174,'multiline':False]
['text':' Reshape the tensor indices according to their axis.','line_number':175,'multiline':False]
['text':' E.g.                 x[1:3, 0, ind1, ind2] = y','line_number':176,'multiline':False]
['text':'  slice index shape:   [2,   1, 1 ]','line_number':177,'multiline':False]
['text':'  select index shape:  [     1, 1 ]','line_number':178,'multiline':False]
['text':'  ind1 shape:          [        _ ]','line_number':179,'multiline':False]
['text':'  ind2 shape:          [        _ ]','line_number':180,'multiline':False]
['text':' where _ is the original size of ind1 and ind2.','line_number':181,'multiline':False]
['text':' ind1 and ind2 are both 1-d tensors since currently we only supports 1-d','line_number':182,'multiline':False]
['text':' tensor indices.','line_number':183,'multiline':False]
['text':' Trace back all the slice & select nodes associated with the index_put node,','line_number':253,'multiline':False]
['text':' and convert them to associated indices.','line_number':254,'multiline':False]
['text':' E.g. The IR for x[1:3, 0] = update','line_number':255,'multiline':False]
['text':'    ...','line_number':256,'multiline':False]
['text':'    %8 : Float(2, 4) = aten::slice(%0, %4, %5, %6, %7)','line_number':257,'multiline':False]
['text':'    ...','line_number':258,'multiline':False]
['text':'    %11 : Float(2) = aten::select(%8, %9, %10)','line_number':259,'multiline':False]
['text':'    ...','line_number':260,'multiline':False]
['text':'    %13 : Tensor?[] = prim::ListConstruct()','line_number':261,'multiline':False]
['text':'    ...','line_number':262,'multiline':False]
['text':'    %16 : Float(2) = aten::index_put(%11, %13, %14, %15)','line_number':263,'multiline':False]
['text':' The aten::index_put node alone does not contain any indices (%13 : Tensor?[]','line_number':264,'multiline':False]
['text':' = prim::ListConstruct()).','line_number':265,'multiline':False]
['text':'    ...','line_number':266,'multiline':False]
['text':'    # Below constructs index from slice node.','line_number':267,'multiline':False]
['text':'    %23 : Long() = aten::size(%0, %4)','line_number':268,'multiline':False]
['text':'    %28 : Tensor = aten::arange(%23, %24, %25, %26, %27)','line_number':269,'multiline':False]
['text':'    %33 : Tensor = aten::slice(%28, %4, %5, %6, %7)','line_number':270,'multiline':False]
['text':'    %39 : int[] = prim::Constant[value=[-1, 1]]()','line_number':271,'multiline':False]
['text':'    %40 : Tensor = aten::view(%33, %39)','line_number':272,'multiline':False]
['text':'    ...','line_number':273,'multiline':False]
['text':'    # Below constructs index from select node.','line_number':274,'multiline':False]
['text':'    %36 : int = prim::Constant[value=0]()','line_number':275,'multiline':False]
['text':'    %37 : Tensor = aten::unsqueeze(%10, %36)','line_number':276,'multiline':False]
['text':'    %42 : int[] = prim::Constant[value=[-1]]()','line_number':277,'multiline':False]
['text':'    %43 : Tensor = aten::view(%37, %42)','line_number':278,'multiline':False]
['text':'    ...','line_number':279,'multiline':False]
['text':'    # Adding the above two indices to index_put','line_number':280,'multiline':False]
['text':'    %44 : Tensor?[] = prim::ListConstruct(%40, %43)','line_number':281,'multiline':False]
['text':'    %45 : Float(2, 5) = aten::index_put(%0, %44, %14, %15)','line_number':282,'multiline':False]
['text':' Find slice and select operators that are associated with this index','line_number':298,'multiline':False]
['text':' operator. E.g. x[1:3, 0] = y will generate one slice operator(1:3) and one','line_number':299,'multiline':False]
['text':' select operator(0).','line_number':300,'multiline':False]
['text':' Update inner block input originates from outside.','line_number':306,'multiline':False]
['text':' Convert slice and select operators to indices.','line_number':310,'multiline':False]
['text':' Reshape indices to advanced indexing format.','line_number':315,'multiline':False]
['text':' Create new index_put node with converted indices.','line_number':319,'multiline':False]
['text':' Convert aten type to onnx type.','line_number':336,'multiline':False]
['text':' Convert all the new aten nodes that were just created to onnx.','line_number':343,'multiline':False]
['text':' New onnx nodes are appended at the end of new_block.','line_number':344,'multiline':False]
['text':' Find onnx outputs corresponding to the aten outputs of index_put.','line_number':353,'multiline':False]
['text':' namespace','line_number':361,'multiline':False]
['text':' The pattern conversion code should not alter nodes outside the Placeholder','line_number':373,'multiline':False]
['text':' subblock.','line_number':374,'multiline':False]
['text':' namespace jit','line_number':383,'multiline':False]
['text':' namespace torch','line_number':384,'multiline':False]
