['text':' InplaceConverter defines a set of functions that together enables the','line_number':24,'multiline':False]
['text':' conversion from prim::GetAttr, prim::SetAttr, and ATen in-place operators to','line_number':25,'multiline':False]
['text':' ONNX out-place operators.','line_number':26,'multiline':False]
['text':' ValueTracker provides apis to record aliases for a single value,','line_number':55,'multiline':False]
['text':' and to retrieve the correct alias of any given value based on the location','line_number':56,'multiline':False]
['text':' in the graph it is used.','line_number':57,'multiline':False]
['text':' Map from aliases to root value.','line_number':70,'multiline':False]
['text':' A single value can have multiple aliases throughout the graph,','line_number':71,'multiline':False]
['text':' created by inplace operators, and preserved through loop carried','line_number':72,'multiline':False]
['text':' input/output. For each such value, its first occurrence will be set as','line_number':73,'multiline':False]
['text':' root value.','line_number':74,'multiline':False]
['text':' Sort the alias based on their order in graph.','line_number':77,'multiline':False]
['text':' A tie can happen when two distinct aliases belong to different blocks,','line_number':78,'multiline':False]
['text':' while having the same ancestor node. The unique id is used as tie','line_number':79,'multiline':False]
['text':' breaker, otherwise the two aliases will be considered equal to each','line_number':80,'multiline':False]
['text':' other. aliasComp must satisfy strict weak ordering.','line_number':81,'multiline':False]
['text':' Map from root value to aliases sorted by their order in graph.','line_number':97,'multiline':False]
['text':'num_outputs =','line_number':125,'multiline':True]
['text':' For scripting mode, aten::clone requires input to be a TensorType','line_number':139,'multiline':False]
['text':' Hence if we encounter an IntType, FloatType, or BoolType,','line_number':140,'multiline':False]
['text':' we set the input to the appropriate TensorType','line_number':141,'multiline':False]
['text':'num_outputs =','line_number':154,'multiline':True]
['text':' aten::copy_ can be viewed as a special case of index_put, where the','line_number':177,'multiline':False]
['text':' tensor indices input is empty.','line_number':178,'multiline':False]
['text':' Remove aten::copy_, and replace it with index_put.','line_number':179,'multiline':False]
['text':' 1. create an empty listConstruct node as indices input for index_put.','line_number':180,'multiline':False]
['text':' 2. create index_put node.','line_number':181,'multiline':False]
['text':' Tracing aten::copy_ broadcasts the rhs values.','line_number':183,'multiline':False]
['text':' 3. Apply broadcasting for scripting.','line_number':184,'multiline':False]
['text':' Cases from a[i] = x. Convert to copy_ and eventually index_put_.','line_number':246,'multiline':False]
['text':' Direct aliasing, the node is a standalone inplace op.','line_number':259,'multiline':False]
['text':' aten::pop is inplace. The tensor list input is updated.','line_number':264,'multiline':False]
['text':' This pass creates an aten::__getitem__ op to return the original output from','line_number':265,'multiline':False]
['text':' aten::pop. Then it makes the original aten::pop operator return the updated','line_number':266,'multiline':False]
['text':' tensor list, and replaces all later uses of that tensor list with this new','line_number':267,'multiline':False]
['text':' output.','line_number':268,'multiline':False]
['text':'   %ten : Tensor = aten::pop(%seq, %pos)','line_number':271,'multiline':False]
['text':' Convert to','line_number':272,'multiline':False]
['text':'   %ten : Tensor = aten::__getitem__(%seq, %pos)','line_number':273,'multiline':False]
['text':'   %new_seq : Tensor[] = aten::pop(%seq, %pos)','line_number':274,'multiline':False]
['text':' And replace all uses of %seq afterwards with %new_seq','line_number':275,'multiline':False]
['text':' It seems the JIT does not always produce an output for _set_item.','line_number':306,'multiline':False]
['text':' In particular it seems to for list but not for dict.','line_number':307,'multiline':False]
['text':' So we add one if needed.','line_number':308,'multiline':False]
['text':' Remove Mutation pass does not handle mutation on block inputs.','line_number':316,'multiline':False]
['text':' To fix this, insert a clone node following the graph input:','line_number':317,'multiline':False]
['text':' Example for graph input node %0:','line_number':318,'multiline':False]
['text':' Before:','line_number':319,'multiline':False]
['text':' graph(%0 : Tensor):','line_number':320,'multiline':False]
['text':'   %5 : Tensor = aten::zero_(%0)','line_number':321,'multiline':False]
['text':'   ...','line_number':322,'multiline':False]
['text':' After:','line_number':323,'multiline':False]
['text':' graph(%0 : Tensor):','line_number':324,'multiline':False]
['text':'   %2 : None = prim::Constant()','line_number':325,'multiline':False]
['text':'   %3 : Tensor = aten::clone(%0, %2)','line_number':326,'multiline':False]
['text':'   %5 : Tensor = aten::zero_(%3)','line_number':327,'multiline':False]
['text':'   ...','line_number':328,'multiline':False]
['text':' findSubModuleAttr function chases getAttr chains backwards to locate the','line_number':377,'multiline':False]
['text':' submodules. For example: module M {','line_number':378,'multiline':False]
['text':'   attributes {','line_number':379,'multiline':False]
['text':'     A = <SubModule at ...>','line_number':380,'multiline':False]
['text':'   }','line_number':381,'multiline':False]
['text':'   ...','line_number':382,'multiline':False]
['text':'   %A = prim::GetAttr[name="A"](%self)','line_number':383,'multiline':False]
['text':'   ...','line_number':384,'multiline':False]
['text':'   %B = prim::GetAttr[name="B"](%A)','line_number':385,'multiline':False]
['text':'   ...','line_number':386,'multiline':False]
['text':'   %weight = prim::GetAttr[name="scale"](%B)','line_number':387,'multiline':False]
['text':'   ...','line_number':388,'multiline':False]
['text':' Loop starts from inner submodule and follows the chain until reaches the','line_number':397,'multiline':False]
['text':' top module.','line_number':398,'multiline':False]
['text':' Assign the inner module to attrModule.','line_number':410,'multiline':False]
['text':' ss << "Current graph: " << graph_->toString() << std::endl;','line_number':439,'multiline':False]
['text':' check if new_v is created inside if or loop subblock.','line_number':485,'multiline':False]
['text':' The data of this value has been changed.','line_number':513,'multiline':False]
['text':' If this value has alias from outer block,','line_number':514,'multiline':False]
['text':' then the update must be reflected back to outside.','line_number':515,'multiline':False]
['text':' Thus it needs to be registered as a subblock output.','line_number':516,'multiline':False]
['text':' This step can be skipped if other alias of this value has already been','line_number':517,'multiline':False]
['text':' registered as subblock output.','line_number':518,'multiline':False]
['text':' Based on current value aliases record, pass over graph and correct alias','line_number':550,'multiline':False]
['text':' reference for all the nodes.','line_number':551,'multiline':False]
['text':' node n can be destroyed','line_number':559,'multiline':False]
['text':' For every input of Node n, find the correct alias representing that input.','line_number':573,'multiline':False]
['text':' Find the correct alias representing Value v at Node n.','line_number':592,'multiline':False]
['text':' This value was not affected by any inplace operator.','line_number':598,'multiline':False]
['text':' alias is accessible only if','line_number':607,'multiline':False]
['text':' 1. alias owning block is ancestor of n.','line_number':608,'multiline':False]
['text':' 2. alias owning node is before n.','line_number':609,'multiline':False]
['text':' return the last alias that satisfies this condition.','line_number':610,'multiline':False]
['text':' Pass over block, and gather the initial value for any attribute.','line_number':634,'multiline':False]
['text':' Also cache the full name of the attribute for every GetAttr/SetAttr node.','line_number':635,'multiline':False]
['text':' node n can be destroyed','line_number':642,'multiline':False]
['text':' Add model_parameters and model_buffers as model inputs. Order is','line_number':673,'multiline':False]
['text':' preserved based on the appearance in the graph.','line_number':674,'multiline':False]
['text':' TODO: Extend support for attribute of type List[Tensor] etc.','line_number':681,'multiline':False]
['text':' If attribute is a custom class object, instead of primitive types,','line_number':689,'multiline':False]
['text':' Tensor, or List/Tuple/Dict of Tensors.','line_number':690,'multiline':False]
['text':' Create dummy initial value, if initial value does not exist for this','line_number':698,'multiline':False]
['text':' attribute.','line_number':699,'multiline':False]
['text':' Replace prim::GetAttr and prim::SetAttr with ATen inplace operators.','line_number':709,'multiline':False]
['text':' Example graph:','line_number':710,'multiline':False]
['text':' clang-format off','line_number':711,'multiline':False]
['text':'  Before graph(%x.1 : Float(12, strides=[1], requires_grad=0, device=cpu)):','line_number':712,'multiline':False]
['text':'    %1 : __torch__.___torch_mangle_1.M = prim::CreateObject()','line_number':713,'multiline':False]
['text':'    ...','line_number':714,'multiline':False]
['text':'    %10 : Tensor = aten::arange(%6, %7, %7, %7, %7)','line_number':715,'multiline':False]
['text':'     = prim::SetAttr[name="_bias"](%1, %10)','line_number':716,'multiline':False]
['text':'     = prim::Loop(%5, %8)','line_number':717,'multiline':False]
['text':'      block0(%i.1 : int):','line_number':718,'multiline':False]
['text':'        %12 : bool = aten::eq(%i.1, %4)','line_number':719,'multiline':False]
['text':'         = prim::If(%12)','line_number':720,'multiline':False]
['text':'          block0():','line_number':721,'multiline':False]
['text':'             = prim::Loop(%3, %8)','line_number':722,'multiline':False]
['text':'              block0(%j : int):','line_number':723,'multiline':False]
['text':'                %14 : Tensor = prim::GetAttr[name="_bias"](%1)','line_number':724,'multiline':False]
['text':'                %15 : Tensor = aten::add_(%14, %2, %9)','line_number':725,'multiline':False]
['text':'                 = prim::SetAttr[name="_bias"](%1, %15)','line_number':726,'multiline':False]
['text':'                -> (%8)','line_number':727,'multiline':False]
['text':'            -> ()','line_number':728,'multiline':False]
['text':'          block1():','line_number':729,'multiline':False]
['text':'            %16 : Tensor = aten::arange(%6, %7, %7, %7, %7)','line_number':730,'multiline':False]
['text':'             = prim::SetAttr[name="_bias"](%1, %16)','line_number':731,'multiline':False]
['text':'            -> ()','line_number':732,'multiline':False]
['text':'        -> (%8)','line_number':733,'multiline':False]
['text':'    %17 : Tensor = prim::GetAttr[name="_bias"](%1)','line_number':734,'multiline':False]
['text':'    %18 : Tensor = aten::add(%17, %x.1, %9)','line_number':735,'multiline':False]
['text':'    return (%18)','line_number':736,'multiline':False]
['text':'','line_number':737,'multiline':False]
['text':'  After graph(%x.1 : Float(12, strides=[1], requires_grad=0, device=cpu)):','line_number':738,'multiline':False]
['text':'    %19 : Float(2, strides=[1], requires_grad=0, device=cpu) = prim::Constant[value= 1  1 [ CPUFloatType{2} ]]()','line_number':739,'multiline':False]
['text':'    %1 : __torch__.___torch_mangle_1.M = prim::CreateObject()','line_number':740,'multiline':False]
['text':'    ...','line_number':741,'multiline':False]
['text':'    %10 : Tensor = aten::arange(%6, %7, %7, %7, %7)','line_number':742,'multiline':False]
['text':'    %28 : Tensor = aten::set_(%19, %10)','line_number':743,'multiline':False]
['text':'     = prim::Loop(%5, %8)','line_number':744,'multiline':False]
['text':'      block0(%i.1 : int):','line_number':745,'multiline':False]
['text':'        %12 : bool = aten::eq(%i.1, %4)','line_number':746,'multiline':False]
['text':'         = prim::If(%12)','line_number':747,'multiline':False]
['text':'          block0():','line_number':748,'multiline':False]
['text':'             = prim::Loop(%3, %8)','line_number':749,'multiline':False]
['text':'              block0(%j : int):','line_number':750,'multiline':False]
['text':'                %15 : Tensor = aten::add_(%19, %2, %9)','line_number':751,'multiline':False]
['text':'                %25 : Tensor = aten::set_(%19, %15)','line_number':752,'multiline':False]
['text':'                -> (%8)','line_number':753,'multiline':False]
['text':'            -> ()','line_number':754,'multiline':False]
['text':'          block1():','line_number':755,'multiline':False]
['text':'            %16 : Tensor = aten::arange(%6, %7, %7, %7, %7)','line_number':756,'multiline':False]
['text':'            %22 : Tensor = aten::set_(%19, %16)','line_number':757,'multiline':False]
['text':'            -> ()','line_number':758,'multiline':False]
['text':'        -> (%8)','line_number':759,'multiline':False]
['text':'    %18 : Tensor = aten::add(%19, %x.1, %9)','line_number':760,'multiline':False]
['text':'    return (%18)','line_number':761,'multiline':False]
['text':' clang-format on','line_number':762,'multiline':False]
['text':' Convert SetAttr to inplace op aten::set_.','line_number':776,'multiline':False]
['text':' Replace use of GetAttr with first seen alias (usually initial value) of','line_number':784,'multiline':False]
['text':' that particular value. Correct alias at point of this node will be','line_number':785,'multiline':False]
['text':' discovered and assigned in later pass.','line_number':786,'multiline':False]
['text':' First pass over graph, to gather all attribute names, and their initial','line_number':797,'multiline':False]
['text':' values. Create dummy initial values for attributes if necessary. By the end','line_number':798,'multiline':False]
['text':' of this pass, these dummy initial values should have zero uses, and can be','line_number':799,'multiline':False]
['text':' safely removed. Otherwise it will imply an error in the model for using','line_number':800,'multiline':False]
['text':' uninitialized values.','line_number':801,'multiline':False]
['text':' Second pass over graph,','line_number':806,'multiline':False]
['text':' replace GetAttr with first seen alias (usually initial value),','line_number':807,'multiline':False]
['text':' and replace SetAttr with inplace op, updating new value onto first seen','line_number':808,'multiline':False]
['text':' alias.','line_number':809,'multiline':False]
['text':' Convert inplace ops to outplace version, and record the associated new alias','line_number':813,'multiline':False]
['text':' in ValueTracker.','line_number':814,'multiline':False]
['text':' node n can be destroyed','line_number':818,'multiline':False]
['text':' special case, index_put is not inplace.','line_number':832,'multiline':False]
['text':' Not inplace op.','line_number':848,'multiline':False]
['text':' First pass to convert all prim::GetAttr and prim::SetAttr to ATen inplace','line_number':867,'multiline':False]
['text':' operators.','line_number':868,'multiline':False]
['text':' Second pass to convert all inplace operators to outplace version, and','line_number':872,'multiline':False]
['text':' record the associated new alias in ValueTracker.','line_number':873,'multiline':False]
['text':' Third pass to check and correct alias reference for all the nodes.','line_number':875,'multiline':False]
['text':' namespace','line_number':879,'multiline':False]
['text':' namespace jit','line_number':893,'multiline':False]
['text':' namespace torch','line_number':894,'multiline':False]
