['text':' This api will be used by serialization/export.cpp to extract function','line_number':8,'multiline':False]
['text':' information. It should do conversion on graph to','line_number':9,'multiline':False]
['text':'    1. Extract subgraph pattern of functions and define as local function','line_number':10,'multiline':False]
['text':'    node.','line_number':11,'multiline':False]
['text':'    2. Replace subgraph pattern of functions with a single node reflecting','line_number':12,'multiline':False]
['text':'    that local function node type.','line_number':13,'multiline':False]
['text':' Function attribute map information is also returned, as Torch IR cannot','line_number':14,'multiline':False]
['text':' represent these info inside Graph object.','line_number':15,'multiline':False]
['text':' export.cpp will serialize the ONNX model with function_proto with','line_number':16,'multiline':False]
['text':' above information.','line_number':17,'multiline':False]
['text':' The following return types are used to track information regarding function','line_number':20,'multiline':False]
['text':' attributes, that are unable to be traced through Torch IR.','line_number':21,'multiline':False]
['text':' NodeAttrNameMap tracks mapping from attribute name of IR Node inside function','line_number':22,'multiline':False]
['text':' subgraph, to function attribute name. Here's an example of exporting CELU and','line_number':23,'multiline':False]
['text':' LayerNorm.','line_number':24,'multiline':False]
['text':'','line_number':25,'multiline':False]
['text':' clang-format off','line_number':26,'multiline':False]
['text':' class M(torch.nn.Module):','line_number':27,'multiline':False]
['text':'     def __init__(self):','line_number':28,'multiline':False]
['text':'         super().__init__()','line_number':29,'multiline':False]
['text':'         self.lns = torch.nn.ModuleList([torch.nn.LayerNorm(3, eps = i) for i in range(2)])','line_number':30,'multiline':False]
['text':'         self.celu1 = torch.nn.CELU(1.0)','line_number':31,'multiline':False]
['text':'         self.celu2 = torch.nn.CELU(2.0)','line_number':32,'multiline':False]
['text':'     def forward(self, x: torch.Tensor, y: torch.Tensor, z: torch.Tensor) -> torch.Tensor:','line_number':34,'multiline':False]
['text':'         res1 = self.celu1(x)','line_number':35,'multiline':False]
['text':'         res2 = self.celu2(y)','line_number':36,'multiline':False]
['text':'         for ln in self.lns:','line_number':37,'multiline':False]
['text':'             z = ln(z)','line_number':38,'multiline':False]
['text':'         return res1 + res2 + z','line_number':39,'multiline':False]
['text':' clang-format on','line_number':40,'multiline':False]
['text':'','line_number':41,'multiline':False]
['text':' Returning','line_number':42,'multiline':False]
['text':'','line_number':43,'multiline':False]
['text':' NodeAttrNameMap:','line_number':44,'multiline':False]
['text':' {','line_number':45,'multiline':False]
['text':'    %1 : Float(2, 3) = onnx::Celu[alpha=2.](%y) : {','line_number':46,'multiline':False]
['text':'      'alpha' : 'Celu_alpha'','line_number':47,'multiline':False]
['text':'    }','line_number':48,'multiline':False]
['text':' }','line_number':49,'multiline':False]
['text':'','line_number':50,'multiline':False]
['text':' The info here helps graph._export_onnx to construct function attributes for','line_number':51,'multiline':False]
['text':' onnx local FunctionProto.','line_number':52,'multiline':False]
['text':' namespace onnx','line_number':67,'multiline':False]
['text':' namespace jit','line_number':69,'multiline':False]
['text':' namespace torch','line_number':70,'multiline':False]
