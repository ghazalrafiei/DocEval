['text':' Represents nested namespaces, like `foo.bar.Baz`.','line_number':28,'multiline':False]
['text':' Right now these namespaces can only contain other namespaces or NamedTypes','line_number':29,'multiline':False]
['text':'*
   * @param  name  The fully qualified path, which can resolve either to a
   *               namespace or a NamedType
   * @param  si    The source importer that searches for and loads
   * classes/functions.
   ','line_number':31,'multiline':True]
['text':' This value maps attributes CONSTANTS.c0 CONSTANTS.c1 to entries','line_number':55,'multiline':False]
['text':' in the 'constants' vector. This table is will be stored in a container format','line_number':56,'multiline':False]
['text':' and given to the import_method when restoring the code.','line_number':57,'multiline':False]
['text':' select an attribute on it, e.g. `this.field`','line_number':64,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':70,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':81,'multiline':False]
['text':' see [Constant Object Weak CompilationUnit Reference]','line_number':84,'multiline':False]
['text':' specializing tensor type on compilation messes up typing relations','line_number':95,'multiline':False]
['text':' Constants present in the model. Used to resolve "CONSTANTS.n" to the','line_number':120,'multiline':False]
['text':' actual value','line_number':121,'multiline':False]
['text':' qualifier may be blank, for instance checking if __torch__ is a class.','line_number':157,'multiline':False]
['text':' The importer, when looking for classes/functions doesn't know if 'foo'','line_number':164,'multiline':False]
['text':' contains definitions or if it is a prefix of 'foo.bar', we only figure it','line_number':165,'multiline':False]
['text':' out by testing if `foo.py` exists in the source loader. If it doesn't','line_number':166,'multiline':False]
['text':' then there is nothing to load here','line_number':167,'multiline':False]
['text':'is_method=','line_number':187,'multiline':True]
['text':'is_method=','line_number':212,'multiline':True]
['text':'properties=','line_number':218,'multiline':True]
['text':'propResolvers=','line_number':219,'multiline':True]
['text':'properties=','line_number':271,'multiline':True]
['text':'propResolvers=','line_number':272,'multiline':True]
['text':'is_module=','line_number':284,'multiline':True]
['text':'is_module=','line_number':288,'multiline':True]
['text':' NamedTuples have special rules (since they are TupleTypes and not','line_number':290,'multiline':False]
['text':' ClassTypes)','line_number':291,'multiline':False]
['text':'is_module=','line_number':295,'multiline':True]
['text':'is_module=','line_number':298,'multiline':True]
['text':' module demangled qualname -> ReplacementDescr','line_number':317,'multiline':False]
['text':' BC Stuff','line_number':347,'multiline':False]
['text':' @lint-ignore-every CLANGTIDY facebook-hte-StdRegexIsAwful','line_number':368,'multiline':False]
['text':' BC for TorchBind classes','line_number':399,'multiline':False]
['text':'','line_number':400,'multiline':False]
['text':' Previously we would serialize TorchBind classes as actual','line_number':401,'multiline':False]
['text':' classes with methods that delegate to things in the','line_number':402,'multiline':False]
['text':' torch.ops.* namespace. We've switched away from this and','line_number':403,'multiline':False]
['text':' now just rely on those classes being present in the binary','line_number':404,'multiline':False]
['text':' and emit code for them based on the ClassType in memory.','line_number':405,'multiline':False]
['text':'','line_number':406,'multiline':False]
['text':' TODO: remove this once we no longer have old TorchBind code','line_number':407,'multiline':False]
['text':' in production models','line_number':408,'multiline':False]
['text':' Module-specific: which attrs are parameters?','line_number':427,'multiline':False]
['text':' used to keep track of original ordering of hooks and prehooks','line_number':432,'multiline':False]
['text':' in case any are called more than once','line_number':433,'multiline':False]
['text':' Process statements, splitting things into attribute and method','line_number':436,'multiline':False]
['text':' definitions.','line_number':437,'multiline':False]
['text':' Populate the module parameter list. This is a field that','line_number':452,'multiline':False]
['text':' looks like:','line_number':453,'multiline':False]
['text':'   __parameters__ = ["foo", "bar", "baz"]','line_number':454,'multiline':False]
['text':' which tells us which attributes are module parameters.','line_number':455,'multiline':False]
['text':' This is to initialize the annotations dict, just ignore.','line_number':466,'multiline':False]
['text':' This is a constant assignment, of the form:','line_number':504,'multiline':False]
['text':' foo : Final[int] = 3','line_number':505,'multiline':False]
['text':' This is a regular attribute assignment, of the form:','line_number':508,'multiline':False]
['text':' foo : Tensor','line_number':509,'multiline':False]
['text':' This is a special attribute assignment where the attribute','line_number':515,'multiline':False]
['text':' is not a valid python, identifier. Looks like:','line_number':516,'multiline':False]
['text':'    __annotations__["0"] = Tensor','line_number':517,'multiline':False]
['text':' Populate class attributes','line_number':555,'multiline':False]
['text':' Populate class constants','line_number':582,'multiline':False]
['text':' build pre hook and hook def/resolver pairs','line_number':589,'multiline':False]
['text':' pairs are dedupped in ir_emitter.cpp's CompilationUnit::define_hooks()','line_number':590,'multiline':False]
['text':' ordering here is call order for hooks','line_number':591,'multiline':False]
['text':' TODO (this will include the version number later)','line_number':608,'multiline':False]
['text':'properties=','line_number':611,'multiline':True]
['text':'propResolvers=','line_number':612,'multiline':True]
['text':'shouldMangle=','line_number':616,'multiline':True]
['text':'operator_set_version=','line_number':617,'multiline':True]
['text':' Older versions of serialization produced an op_version_set string','line_number':729,'multiline':False]
['text':' per-file We now just use a single version which is handled by','line_number':730,'multiline':False]
['text':' PyTorchStreamReader. We used to check if op_version_set was _newer_ for','line_number':731,'multiline':False]
['text':' forward compatibility reasons but now that it doesn't exist there can't','line_number':732,'multiline':False]
['text':' be a newer one, so we just discard this.','line_number':733,'multiline':False]
['text':' older versions of serialization required import statements,','line_number':743,'multiline':False]
['text':' and defined classes file-at-a-time in import order.','line_number':744,'multiline':False]
['text':' The problem is that in Python','line_number':745,'multiline':False]
['text':' it is possible to construct cyclic dependencies between files even','line_number':746,'multiline':False]
['text':' when there are none between individual classes. New versions of loading','line_number':747,'multiline':False]
['text':' just compile class-at-a-time, so we no longer need to follow the import','line_number':748,'multiline':False]
['text':' order. Future serialization may stop producing the import code.','line_number':749,'multiline':False]
['text':' Could be a ClassType or NamedTuple constructor','line_number':766,'multiline':False]
['text':' Or it could be a free function','line_number':777,'multiline':False]
['text':' If it's none of those things, assume it's another namespace','line_number':782,'multiline':False]
['text':' The compilation unit that will own the imported source','line_number':787,'multiline':False]
['text':' namespace torch::jit','line_number':811,'multiline':False]
