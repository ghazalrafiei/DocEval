['text':' AccessInfo','line_number':7,'multiline':False]
['text':' If there is already a usage and it's this store, that means the same','line_number':13,'multiline':False]
['text':' access is present in the RHS.','line_number':14,'multiline':False]
['text':' update first and last usage to be in the parent Block.','line_number':68,'multiline':False]
['text':' All accesses to a buf must have the same dimensionality.','line_number':75,'multiline':False]
['text':' They don't overlap if there is a guaranteed difference in any','line_number':83,'multiline':False]
['text':' dimension.','line_number':84,'multiline':False]
['text':' Scope','line_number':145,'multiline':False]
['text':' create and return','line_number':154,'multiline':False]
['text':' RegisterizerAnalysis','line_number':175,'multiline':False]
['text':' now we need to see which accesses we can hoist out of the for loop, their','line_number':210,'multiline':False]
['text':' costs should be multiplied by the loop extent.','line_number':211,'multiline':False]
['text':' If the access is open, but conditional, then we have a problem. It's','line_number':222,'multiline':False]
['text':' possible that an access at a higher scope could "unhide" the','line_number':223,'multiline':False]
['text':' conditional access, in which case we need to hoist. If there is no','line_number':224,'multiline':False]
['text':' access to this element at a higher scope then we cannot safely hoist.','line_number':225,'multiline':False]
['text':' We cannot know at this level whether that will or wont occur.','line_number':226,'multiline':False]
['text':'','line_number':227,'multiline':False]
['text':' The solution we take here is to split the space-time continuum, and','line_number':228,'multiline':False]
['text':' keep both versions of the access handy. If the hoisted access is not','line_number':229,'multiline':False]
['text':' used above, we'll fall back to using the hidden, conditional','line_number':230,'multiline':False]
['text':' AccessInfo - if it is, we'll delete the copy.','line_number':231,'multiline':False]
['text':' If this access depends on a locally scoped variable, it cannot be','line_number':237,'multiline':False]
['text':' hosted out of the loop.','line_number':238,'multiline':False]
['text':' hoist!','line_number':251,'multiline':False]
['text':' By hoisting we pull the reads and writes out of the loop, and so the','line_number':252,'multiline':False]
['text':' benefit of registerizing this access is multiplied by the loop extent.','line_number':253,'multiline':False]
['text':' in the parent block, this loop Stmt is the insertion point for the','line_number':257,'multiline':False]
['text':' initializer and finalizer.','line_number':258,'multiline':False]
['text':' If an access is closed within a loop then it cannot be merged into an','line_number':265,'multiline':False]
['text':' existing open access, but will still close that existing access. This is','line_number':266,'multiline':False]
['text':' somewhat different from the regular merge so we need to handle closed','line_number':267,'multiline':False]
['text':' accesses first.','line_number':268,'multiline':False]
['text':' having hoisted, now we can merge normally.','line_number':271,'multiline':False]
['text':' condition is in the enclosing scope.','line_number':282,'multiline':False]
['text':' TODO: even though both scopes are conditional, we can merge accesses if','line_number':304,'multiline':False]
['text':' they totally overlap in both branches, since we can guarantee one','line_number':305,'multiline':False]
['text':' definition will be hit. We might need a 3-way merge? Not as simple as','line_number':306,'multiline':False]
['text':' merging the true and false scopes together first.','line_number':307,'multiline':False]
['text':' IfThenElses are just like Conds except they are not Stmts, which means no','line_number':312,'multiline':False]
['text':' registerization can occur internally. However, the first reference to an','line_number':313,'multiline':False]
['text':' access can occur within one if its visible outside the condition.','line_number':314,'multiline':False]
['text':' condition is in enclosing scope.','line_number':320,'multiline':False]
['text':' We store IfThenElse scopes in a global map, which we use to prevent closing','line_number':329,'multiline':False]
['text':' any access that would require inserting statements in the values, which','line_number':330,'multiline':False]
['text':' cannot enclose Stmts.','line_number':331,'multiline':False]
['text':' merge the inner block's accesses into this Block's accesses.','line_number':369,'multiline':False]
['text':' close any open candidates.','line_number':377,'multiline':False]
['text':' already a scalar.','line_number':392,'multiline':False]
['text':' hash the Store:','line_number':396,'multiline':False]
['text':' If an identical access already exists, add this Store to it.','line_number':405,'multiline':False]
['text':' Otherwise make a new AccessInfo and add this store.','line_number':411,'multiline':False]
['text':' This new access may overlap an existing open access, in which case we need','line_number':416,'multiline':False]
['text':' to close the older of the two.','line_number':417,'multiline':False]
['text':' we are already overlapped by an access in the RHS.','line_number':423,'multiline':False]
['text':' already a scalar.','line_number':442,'multiline':False]
['text':' hash the Load:','line_number':445,'multiline':False]
['text':' found the right access, can just insert.','line_number':454,'multiline':False]
['text':' This new access may overlap an existing open access, in which case we need','line_number':464,'multiline':False]
['text':' to finalize the older of the two.','line_number':465,'multiline':False]
['text':' if these two accesses are from the same Stmt, they already overlap','line_number':470,'multiline':False]
['text':' each other.','line_number':471,'multiline':False]
['text':' Loop and Conditional scopes are different in that it may or may not be','line_number':488,'multiline':False]
['text':' possible to hoist the initializer of a scalar variable outside the block','line_number':489,'multiline':False]
['text':' depending on if we can tell that the Buffer access is valid outside. This is','line_number':490,'multiline':False]
['text':' tricky because the access that demonstrates this may be later in the tree and','line_number':491,'multiline':False]
['text':' we haven't encountered it yet.','line_number':492,'multiline':False]
['text':' The allowClosed flag indicates whether we want to keep the closed accesses','line_number':493,'multiline':False]
['text':' (For and Cond), or not (IfThenElse).','line_number':494,'multiline':False]
['text':' The rule is that if any access is closed within the conditional block, any','line_number':496,'multiline':False]
['text':' accesses which overlap it must also be closed - since their initializer','line_number':497,'multiline':False]
['text':' cannot be hoisted out of the block.','line_number':498,'multiline':False]
['text':' Merge currentScope_ into it's parent, and make parent the new currentScope_.','line_number':523,'multiline':False]
['text':' copy across current closed accesses, merging / closing as necessary','line_number':527,'multiline':False]
['text':' if the access is closed inside a condition, it can only be merged if','line_number':535,'multiline':False]
['text':' the parent is in the same condition.','line_number':536,'multiline':False]
['text':' the parent's access must be closed.','line_number':539,'multiline':False]
['text':' the childs access inserted into the parent scope.','line_number':543,'multiline':False]
['text':' merge totally overlapping accesses.','line_number':548,'multiline':False]
['text':' we didn't find a perfect match, but we need to check all open accesses of','line_number':555,'multiline':False]
['text':' this buf for partial overlap.','line_number':556,'multiline':False]
['text':' Partial overlap of parent access: close parent access.','line_number':559,'multiline':False]
['text':' Insert the childs closed access into the parent scope.','line_number':568,'multiline':False]
['text':' copy across current open accesses, merging as necessary.','line_number':572,'multiline':False]
['text':' for each Buf with an open access:','line_number':573,'multiline':False]
['text':' for each open access in the child scope for this Buf:','line_number':582,'multiline':False]
['text':' If it completely overlaps then merge.','line_number':590,'multiline':False]
['text':' if both accesses are found in conditional blocks, they cannot be','line_number':592,'multiline':False]
['text':' merged, but the earlier must be closed.','line_number':593,'multiline':False]
['text':' It can overlap an access in the parent: close the parent access.','line_number':606,'multiline':False]
['text':' The child access may still be open.','line_number':607,'multiline':False]
['text':' If this access depends on a locally scoped variable, it cannot be','line_number':617,'multiline':False]
['text':' lifted out of the loop.','line_number':618,'multiline':False]
['text':' If the inner scope was not conditional, but the outer scope is: all','line_number':628,'multiline':False]
['text':' current accesses are now conditional in the parent scope.','line_number':629,'multiline':False]
['text':' RegisterizerReplacer','line_number':650,'multiline':False]
['text':' This access cannot be registerized.','line_number':655,'multiline':False]
['text':' This store is the initializer for a scalar var that is already inserted.','line_number':666,'multiline':False]
['text':' This access cannot be registerized.','line_number':672,'multiline':False]
['text':' Insert the initializer for any Scalars scoped to this block.','line_number':692,'multiline':False]
['text':' Insert the finalizer for any Scalars scoped to this block.','line_number':713,'multiline':False]
['text':' Traverse the list of replacements, creating vars and updating our local','line_number':730,'multiline':False]
['text':' maps.','line_number':731,'multiline':False]
['text':' we need to wrap the Var in a Buf so we can Load or Store it.','line_number':740,'multiline':False]
['text':' Only finalize if the scalar is written.','line_number':763,'multiline':False]
['text':' push front to finalize in reverse order of encounter.','line_number':765,'multiline':False]
['text':' create a default initializer by reading the access.','line_number':769,'multiline':False]
['text':' namespace registerizer','line_number':777,'multiline':False]
['text':' Apply scalar replacement to all accesses in s.','line_number':779,'multiline':False]
['text':' The outermost node must be a Block so we have somewhere to put outer scope','line_number':783,'multiline':False]
['text':' scalars.','line_number':784,'multiline':False]
['text':' namespace torch::jit::tensorexpr','line_number':797,'multiline':False]
