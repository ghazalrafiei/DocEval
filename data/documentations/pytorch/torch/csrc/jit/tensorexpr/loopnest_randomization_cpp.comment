['text':' Reuse the env variable PYTORCH_JIT_OPT_LIMIT to control the max number of','line_number':21,'multiline':False]
['text':' transformations.  Example - set the env variable','line_number':22,'multiline':False]
['text':' PYTORCH_JIT_OPT_LIMIT="loopnest_randomization=10" to set max','line_number':23,'multiline':False]
['text':' transformations to 10.  This can be helpful in gradually reducing the','line_number':24,'multiline':False]
['text':' number of transformations when we see an error.','line_number':25,'multiline':False]
['text':' Find the first set of loops that can be reordered','line_number':38,'multiline':False]
['text':' Find valid factors','line_number':85,'multiline':False]
['text':' namespace randomization_helper','line_number':124,'multiline':False]
['text':' This is to help with deterministic testing of randomized infrastructure.','line_number':127,'multiline':False]
['text':' When seed value is 1, we perform preset loop transformations. This allows','line_number':128,'multiline':False]
['text':' testing of interface.','line_number':129,'multiline':False]
['text':' Set the maximum allowed number of transformations beyond which it is hard','line_number':137,'multiline':False]
['text':' to track and debug. Arbitrarily choosing 20 as maximum number.','line_number':138,'multiline':False]
['text':' clang-format off','line_number':143,'multiline':False]
['text':'   Transformations list:','line_number':144,'multiline':False]
['text':'','line_number':145,'multiline':False]
['text':'       StmtPtr simplify();','line_number':146,'multiline':False]
['text':'       bool computeInline(BufPtr b);','line_number':147,'multiline':False]
['text':'       void inlineIntermediateBufs(bool allow_duplicated_work);','line_number':148,'multiline':False]
['text':'       bool optimizeConditionals();','line_number':149,'multiline':False]
['text':'       static void splitWithTail(ForPtr f, int factor);','line_number':150,'multiline':False]
['text':'       static void splitWithMask(ForPtr f, int factor);','line_number':151,'multiline':False]
['text':'       static std::vector<ForPtr> distributeLoop(ForPtr loop, const std::unordered_set<StmtPtr>& pivots);','line_number':152,'multiline':False]
['text':'       static std::vector<ForPtr> distributeLoop(ForPtr loop);','line_number':153,'multiline':False]
['text':'       static std::vector<ForPtr> distributeLoopAndParents(ForPtr loop);','line_number':154,'multiline':False]
['text':'       static std::vector<ForPtr> distributeLoopOverInnerLoops(ForPtr loop);','line_number':155,'multiline':False]
['text':'       static std::vector<ForPtr> distributeLoopAndParentsOverInnerLoops(ForPtr loop);','line_number':156,'multiline':False]
['text':'       static bool fuseLoops(const std::vector<ForPtr>& loops, ForPtr* fused);','line_number':157,'multiline':False]
['text':'       static void reorderAxis(ForPtr a, ForPtr b);','line_number':158,'multiline':False]
['text':'       static std::vector<ForPtr> reorder(const std::vector<ForPtr>& loops, const std::vector<size_t>& permutation);','line_number':159,'multiline':False]
['text':'       ForPtr tile(ForPtr x, ForPtr y, int x_factor, int y_factor);','line_number':160,'multiline':False]
['text':'       static void fullUnroll(ForPtr f);','line_number':161,'multiline':False]
['text':'       static bool normalize(ForPtr f);','line_number':162,'multiline':False]
['text':'       static bool flatten(const std::vector<ForPtr>& f, ForPtr* flattened);','line_number':163,'multiline':False]
['text':'       static void compressBuffer(BufPtr buf, StmtPtr stmt);','line_number':164,'multiline':False]
['text':'       static void compressAllBuffers(StmtPtr stmt);','line_number':165,'multiline':False]
['text':'       static void sliceHead(ForPtr f, int factor, ForPtr* head, ForPtr* tail);','line_number':166,'multiline':False]
['text':'       static void sliceHead(ForPtr f, int factor);','line_number':167,'multiline':False]
['text':'       static void sliceTail(ForPtr f, int factor, ForPtr* head, ForPtr* tail);','line_number':168,'multiline':False]
['text':'       static void sliceTail(ForPtr f, int factor);','line_number':169,'multiline':False]
['text':'       static AccessResult cacheAccesses(BufPtr producer, const std::string& name, StmtPtr consumer);','line_number':170,'multiline':False]
['text':'       static void computeAt(StmtPtr s, ForPtr at);','line_number':171,'multiline':False]
['text':'       static bool rfactor(StmtPtr s, ForPtr outer_reduction_for);','line_number':172,'multiline':False]
['text':'       static bool vectorize(ForPtr);','line_number':173,'multiline':False]
['text':'       void vectorizeInnerLoops();','line_number':174,'multiline':False]
['text':'       void eliminateDeadStores();','line_number':175,'multiline':False]
['text':'       void prepareForCodegen();','line_number':176,'multiline':False]
['text':' clang-format on','line_number':177,'multiline':False]
['text':' Get all the loops','line_number':364,'multiline':False]
['text':' Find a random number of loops to fuse','line_number':370,'multiline':False]
['text':' Fuse the loops','line_number':383,'multiline':False]
['text':' Get all the loops','line_number':390,'multiline':False]
['text':' Find pairs of axes that can be reordered','line_number':396,'multiline':False]
['text':' Choose a pair randomly','line_number':406,'multiline':False]
['text':' reorder the axis','line_number':424,'multiline':False]
['text':' Get all the loops','line_number':430,'multiline':False]
['text':' Find all perfectly nested loop nests','line_number':436,'multiline':False]
['text':' Randomly pick a set of consecutive loops to reorder','line_number':443,'multiline':False]
['text':' Create a random permutation for reordering','line_number':447,'multiline':False]
['text':' Generate a good history message','line_number':452,'multiline':False]
['text':' reorder','line_number':462,'multiline':False]
['text':' Get all the loops','line_number':468,'multiline':False]
['text':' Tile needs two perfectly nested loops. To find such loops, we find','line_number':474,'multiline':False]
['text':' all perfectly nested loop nests, randomly pick one of them, and','line_number':475,'multiline':False]
['text':' randomly pick 2 consecutive loops in that loop nest.','line_number':476,'multiline':False]
['text':' Find all perfectly nested loop nests','line_number':477,'multiline':False]
['text':' tile','line_number':510,'multiline':False]
['text':' Get all the loops','line_number':544,'multiline':False]
['text':' Find all perfectly nested loop nests','line_number':550,'multiline':False]
['text':' Randomly pick a set of consecutive loops to flatten','line_number':557,'multiline':False]
['text':' Generate a good history message','line_number':561,'multiline':False]
['text':' flatten','line_number':570,'multiline':False]
['text':' Get all the loops','line_number':595,'multiline':False]
['text':' Get all the loops','line_number':614,'multiline':False]
['text':' TODO - Implement cache_access','line_number':633,'multiline':False]
['text':' To find valid compute at pairs, we need to collect the producer','line_number':638,'multiline':False]
['text':' consumer pairs. For now, we do not collect all such pairs for','line_number':639,'multiline':False]
['text':' simplicity. For now, we collect producer and the immediate parent','line_number':640,'multiline':False]
['text':' loop of the consumer. We could collect all the consumer enclosing','line_number':641,'multiline':False]
['text':' loops, but then we will have to clean up the ones that are shared','line_number':642,'multiline':False]
['text':' with the producer encloser loop. Currently, we only test on the','line_number':643,'multiline':False]
['text':' immediate parent loop.','line_number':644,'multiline':False]
['text':' Choose a random pair','line_number':668,'multiline':False]
['text':' TODO - come up with better message','line_number':674,'multiline':False]
['text':' TODO - Implement rfactor','line_number':682,'multiline':False]
['text':' TODO: Add remaining transforms','line_number':731,'multiline':False]
['text':' namespace torch::jit::tensorexpr','line_number':746,'multiline':False]
