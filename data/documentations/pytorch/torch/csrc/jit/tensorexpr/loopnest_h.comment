['text':' A constructor for building a LoopNest from a list of Tensors','line_number':28,'multiline':False]
['text':' A convenience constructor for the case when all tensors are output tensors','line_number':33,'multiline':False]
['text':' A constructor for building a LoopNest from an Stmt and a list of output','line_number':36,'multiline':False]
['text':' buffers.','line_number':37,'multiline':False]
['text':' A constructor for building a LoopNest from another loopnest. It clones the','line_number':40,'multiline':False]
['text':' other loopnest's stmt.','line_number':41,'multiline':False]
['text':' Returns the For stmt indexed by 'indices' in the 'root' For stmt.','line_number':54,'multiline':False]
['text':''indices' indicates the path to the returned loop from 'root' in AST, e.g.,','line_number':55,'multiline':False]
['text':'','line_number':56,'multiline':False]
['text':' root: for(int i...){','line_number':57,'multiline':False]
['text':' j_loop: for (int j...){','line_number':58,'multiline':False]
['text':' k1_loop:  for (int k1...){','line_number':59,'multiline':False]
['text':'            A[i, j, k1] = ....','line_number':60,'multiline':False]
['text':'          }','line_number':61,'multiline':False]
['text':'          B[i, j] = ...','line_number':62,'multiline':False]
['text':' k2_loop:  for (int k2...){','line_number':63,'multiline':False]
['text':'            A[i, j, k2] = ...','line_number':64,'multiline':False]
['text':'          }','line_number':65,'multiline':False]
['text':'        }','line_number':66,'multiline':False]
['text':'      }','line_number':67,'multiline':False]
['text':'','line_number':68,'multiline':False]
['text':' the path from 'root' to 'j_loop' is [0]','line_number':69,'multiline':False]
['text':' the path from 'root' to 'k1_loop' is [0, 0]','line_number':70,'multiline':False]
['text':' the path from 'root' to 'k2_loop' is [0, 2]','line_number':71,'multiline':False]
['text':' Returns the For stmt that is immediately enclosing the given stmt.','line_number':74,'multiline':False]
['text':' Returns the list of For stmts corresponding to the loopnest that is','line_number':77,'multiline':False]
['text':' enclosing the given stmt.','line_number':78,'multiline':False]
['text':' Returns a list of all Stmts that write to the given buf.','line_number':81,'multiline':False]
['text':' The following methods return the For loops that contain writes to','line_number':84,'multiline':False]
['text':' the given buf.','line_number':85,'multiline':False]
['text':'','line_number':86,'multiline':False]
['text':' For example, consider the following code:','line_number':87,'multiline':False]
['text':'   for i1','line_number':88,'multiline':False]
['text':'     for j1','line_number':89,'multiline':False]
['text':'       a[i1,j1] =','line_number':90,'multiline':False]
['text':'   for i2','line_number':91,'multiline':False]
['text':'     for j2','line_number':92,'multiline':False]
['text':'       for k2','line_number':93,'multiline':False]
['text':'         a[i2,j2] =','line_number':94,'multiline':False]
['text':'     for j3','line_number':95,'multiline':False]
['text':'       a[i2,j3] =','line_number':96,'multiline':False]
['text':' Returns a list of For loops which directly contain a Stmt that writes','line_number':98,'multiline':False]
['text':' to buf.','line_number':99,'multiline':False]
['text':' For the above example:','line_number':100,'multiline':False]
['text':'   getAllInnermostLoopsWritingToBuf(a) => {j1, k2, j3}','line_number':101,'multiline':False]
['text':' Returns a list of For loopnests which contain a Stmt that writes to','line_number':104,'multiline':False]
['text':' the given buf. Each loopnest here is a vector For loops.','line_number':105,'multiline':False]
['text':' For the above example:','line_number':106,'multiline':False]
['text':'   getAllLoopNestsWritingToBuf(a) => {{i1,j1}, {i2,j2,k2}, {i2,j3}}','line_number':107,'multiline':False]
['text':' Sanitize variables and buffer names.','line_number':112,'multiline':False]
['text':' The pass assigns predefined names for loop index variables','line_number':113,'multiline':False]
['text':' (i,j,k,l,m,n,o,p,i1,j1,k1,...) and ensures these names are not conflicting','line_number':114,'multiline':False]
['text':' anywhere. It also removes duplicates from other Buf nad Var names as well','line_number':115,'multiline':False]
['text':' as replaces illegal characters in them with underscores.','line_number':116,'multiline':False]
['text':'','line_number':117,'multiline':False]
['text':' Note: since it's currently technically possible to use the same variable','line_number':118,'multiline':False]
['text':' as index in two different loops, this transformation finds such cases and','line_number':119,'multiline':False]
['text':' introduces new variables to avoid duplication.','line_number':120,'multiline':False]
['text':' Optimizes conditionals.','line_number':127,'multiline':False]
['text':'','line_number':128,'multiline':False]
['text':' Currently, only the following pattern of conditionals is optimized.','line_number':129,'multiline':False]
['text':' This corresponds to the conditional format that is generated to handle','line_number':130,'multiline':False]
['text':' `aten::cat` op.','line_number':131,'multiline':False]
['text':'','line_number':132,'multiline':False]
['text':'   for (int i = 0; i < 20; i++) {','line_number':133,'multiline':False]
['text':'     A[i] = IfThenElse(i<5 ? 1 : 0, B[i], C[i-5])','line_number':134,'multiline':False]
['text':'   }','line_number':135,'multiline':False]
['text':'','line_number':136,'multiline':False]
['text':' Constraints that must be satisfied for this optimization:','line_number':137,'multiline':False]
['text':'   * All conditions should be of the form "var < expr".','line_number':138,'multiline':False]
['text':'   * All conditions should have the same variable, say v.','line_number':139,'multiline':False]
['text':'   * The condition variable found should be the same as the inner-most','line_number':140,'multiline':False]
['text':'     loop variable. TODO: Remove this constraint.','line_number':141,'multiline':False]
['text':'   * If there are multiple stores that contain conditionals using the same','line_number':142,'multiline':False]
['text':'     loop variable, only the first conditional will be optimized.','line_number':143,'multiline':False]
['text':'     TODO: Remove this constraint.','line_number':144,'multiline':False]
['text':' Splits the given loop into 2 nested loops with the given factor as the','line_number':147,'multiline':False]
['text':' inner loop bound. If the factor does not evenly divide the loop bound,','line_number':148,'multiline':False]
['text':' then the remaining iterations are extracted into a tail loop that is','line_number':149,'multiline':False]
['text':' added after the given loop.','line_number':150,'multiline':False]
['text':'','line_number':151,'multiline':False]
['text':' For example, consider the following code:','line_number':152,'multiline':False]
['text':'   for (int i = 0; i < 100; ++i) {','line_number':153,'multiline':False]
['text':'     A[i] =','line_number':154,'multiline':False]
['text':'   }','line_number':155,'multiline':False]
['text':'','line_number':156,'multiline':False]
['text':' splitWithTail(i, 8, ...) will result in:','line_number':157,'multiline':False]
['text':'   for (int i_outer = 0; i_outer < 12; ++i_outer) {','line_number':158,'multiline':False]
['text':'     for (int i_inner = 0; i_inner < 8; ++i_inner) {','line_number':159,'multiline':False]
['text':'       A[i_outer * 8 + i_inner] =','line_number':160,'multiline':False]
['text':'     }','line_number':161,'multiline':False]
['text':'   }','line_number':162,'multiline':False]
['text':'   for (int i_tail = 0; i_tail < 4; ++i_tail) {','line_number':163,'multiline':False]
['text':'     A[i_tail + 96] =','line_number':164,'multiline':False]
['text':'   }','line_number':165,'multiline':False]
['text':'','line_number':166,'multiline':False]
['text':' The given loop will be transformed to the outer loop after splitting.','line_number':167,'multiline':False]
['text':' So, the pointer to the input loop should be valid after splitting and','line_number':168,'multiline':False]
['text':' will point to the outer loop. The `inner` and `tail` parameters will be','line_number':169,'multiline':False]
['text':' set to point to the inner and tail loops that are generated.','line_number':170,'multiline':False]
['text':' A convenience wrapper when the caller does not need to access the','line_number':172,'multiline':False]
['text':' split loops.','line_number':173,'multiline':False]
['text':' Splits the given loop into 2 nested loops with the given factor as the','line_number':176,'multiline':False]
['text':' inner loop bound. If the factor does not evenly divide the loop bound,','line_number':177,'multiline':False]
['text':' then a conditional is inserted into the body to handle the remaining','line_number':178,'multiline':False]
['text':' iterations appropriately.','line_number':179,'multiline':False]
['text':'','line_number':180,'multiline':False]
['text':' For example, consider the following code:','line_number':181,'multiline':False]
['text':'   for (int i = 0; i < 100; ++i) {','line_number':182,'multiline':False]
['text':'     A[i] =','line_number':183,'multiline':False]
['text':'   }','line_number':184,'multiline':False]
['text':'','line_number':185,'multiline':False]
['text':' splitWithMask(i, 8, ...) will result in:','line_number':186,'multiline':False]
['text':'   for (int i_outer = 0; i_outer < 13; ++i_outer) {','line_number':187,'multiline':False]
['text':'     for (int i_inner = 0; i_inner < 8; ++i_inner) {','line_number':188,'multiline':False]
['text':'       if (i_outer * 8 + i_inner < 100) {','line_number':189,'multiline':False]
['text':'         A[i_outer * 8 + i_inner] =','line_number':190,'multiline':False]
['text':'       }','line_number':191,'multiline':False]
['text':'     }','line_number':192,'multiline':False]
['text':'   }','line_number':193,'multiline':False]
['text':'','line_number':194,'multiline':False]
['text':' The given loop will be transformed to the outer loop after splitting.','line_number':195,'multiline':False]
['text':' So, the pointer to the input loop should be valid after splitting and','line_number':196,'multiline':False]
['text':' will point to the outer loop. The `inner` parameter will be set to point','line_number':197,'multiline':False]
['text':' to the inner loop that is generated.','line_number':198,'multiline':False]
['text':' A convenience wrapper when the caller does not need to access the','line_number':200,'multiline':False]
['text':' split loops.','line_number':201,'multiline':False]
['text':' The following methods support loop distribution.','line_number':204,'multiline':False]
['text':' For example, consider the following code. This will be used to','line_number':205,'multiline':False]
['text':' demonstrate the methods below.','line_number':206,'multiline':False]
['text':'','line_number':207,'multiline':False]
['text':' S0:  for m','line_number':208,'multiline':False]
['text':' S1:    for i','line_number':209,'multiline':False]
['text':' S2:      A[i] = 0','line_number':210,'multiline':False]
['text':' S3:      for j','line_number':211,'multiline':False]
['text':' S4:        A[i] = A[i] +','line_number':212,'multiline':False]
['text':' S5:      B[i] = A[i]','line_number':213,'multiline':False]
['text':' S6:      for k','line_number':214,'multiline':False]
['text':' S7:        B[i] = B[i] +','line_number':215,'multiline':False]
['text':' This method distributes the given loop over its body by splitting','line_number':217,'multiline':False]
['text':' after every given pivot stmt.','line_number':218,'multiline':False]
['text':'','line_number':219,'multiline':False]
['text':' NOTE: Pivot stmts that are not in the given loop's body will be ignored.','line_number':220,'multiline':False]
['text':'','line_number':221,'multiline':False]
['text':' For the above example:','line_number':222,'multiline':False]
['text':'   distributeLoop(S1, {S3, S5})','line_number':223,'multiline':False]
['text':' will result in:','line_number':224,'multiline':False]
['text':' S0:  for m','line_number':225,'multiline':False]
['text':' S1:    for i','line_number':226,'multiline':False]
['text':' S2:      A[i] = 0','line_number':227,'multiline':False]
['text':' S3:      for j','line_number':228,'multiline':False]
['text':' S4:        A[i] = A[i] +','line_number':229,'multiline':False]
['text':'   :    for i','line_number':230,'multiline':False]
['text':' S5:      B[i] = A[i]','line_number':231,'multiline':False]
['text':'   :    for i','line_number':232,'multiline':False]
['text':' S6:      for k','line_number':233,'multiline':False]
['text':' S7:        B[i] = B[i] +','line_number':234,'multiline':False]
['text':' This method distributes the given loop over every stmt in its body.','line_number':239,'multiline':False]
['text':'','line_number':240,'multiline':False]
['text':' For the above example:','line_number':241,'multiline':False]
['text':'   distributeLoop(S1)','line_number':242,'multiline':False]
['text':' will result in:','line_number':243,'multiline':False]
['text':' S0:  for m','line_number':244,'multiline':False]
['text':' S1:    for i','line_number':245,'multiline':False]
['text':' S2:      A[i] = 0','line_number':246,'multiline':False]
['text':'   :    for i','line_number':247,'multiline':False]
['text':' S3:      for j','line_number':248,'multiline':False]
['text':' S4:        A[i] = A[i] +','line_number':249,'multiline':False]
['text':'   :    for i','line_number':250,'multiline':False]
['text':' S5:      B[i] = A[i]','line_number':251,'multiline':False]
['text':'   :    for i','line_number':252,'multiline':False]
['text':' S6:      for k','line_number':253,'multiline':False]
['text':' S7:        B[i] = B[i] +','line_number':254,'multiline':False]
['text':' Same as above, but also distribute parent loops.','line_number':256,'multiline':False]
['text':' Returns the result of distributing the outermost loop.','line_number':257,'multiline':False]
['text':'','line_number':258,'multiline':False]
['text':' For the above example:','line_number':259,'multiline':False]
['text':'   distributeLoopAndParents(S1) will result in:','line_number':260,'multiline':False]
['text':' S0:  for m','line_number':261,'multiline':False]
['text':' S1:    for i','line_number':262,'multiline':False]
['text':' S2:      A[i] = 0','line_number':263,'multiline':False]
['text':'   :  for m','line_number':264,'multiline':False]
['text':'   :    for i','line_number':265,'multiline':False]
['text':' S3:      for j','line_number':266,'multiline':False]
['text':' S4:        A[i] = A[i] +','line_number':267,'multiline':False]
['text':'   :  for m','line_number':268,'multiline':False]
['text':'   :    for i','line_number':269,'multiline':False]
['text':' S5:      B[i] = A[i]','line_number':270,'multiline':False]
['text':'   :  for m','line_number':271,'multiline':False]
['text':'   :    for i','line_number':272,'multiline':False]
['text':' S6:      for k','line_number':273,'multiline':False]
['text':' S7:        B[i] = B[i] +','line_number':274,'multiline':False]
['text':' This method distributes the given loop over its body by splitting','line_number':277,'multiline':False]
['text':' after every For stmt in its body.','line_number':278,'multiline':False]
['text':'','line_number':279,'multiline':False]
['text':' For the above example:','line_number':280,'multiline':False]
['text':'   distributeLoopOverInnerLoops(S1)','line_number':281,'multiline':False]
['text':' will result in:','line_number':282,'multiline':False]
['text':' S0:  for m','line_number':283,'multiline':False]
['text':' S1:    for i','line_number':284,'multiline':False]
['text':' S2:      A[i] = 0','line_number':285,'multiline':False]
['text':' S3:      for j','line_number':286,'multiline':False]
['text':' S4:        A[i] = A[i] +','line_number':287,'multiline':False]
['text':'   :    for i','line_number':288,'multiline':False]
['text':' S5:      B[i] = A[i]','line_number':289,'multiline':False]
['text':' S6:      for k','line_number':290,'multiline':False]
['text':' S7:        B[i] = B[i] +','line_number':291,'multiline':False]
['text':' Same as above, but also distribute parent loops.','line_number':293,'multiline':False]
['text':' Returns the result of distributing the outermost loop.','line_number':294,'multiline':False]
['text':'','line_number':295,'multiline':False]
['text':' For the above example:','line_number':296,'multiline':False]
['text':'   distributeLoopAndParentsOverInnerLoops(S1)','line_number':297,'multiline':False]
['text':' will result in:','line_number':298,'multiline':False]
['text':' S0:  for m','line_number':299,'multiline':False]
['text':' S1:    for i','line_number':300,'multiline':False]
['text':' S2:      A[i] = 0','line_number':301,'multiline':False]
['text':' S3:      for j','line_number':302,'multiline':False]
['text':' S4:        A[i] = A[i] +','line_number':303,'multiline':False]
['text':'   :  for m','line_number':304,'multiline':False]
['text':'   :    for i','line_number':305,'multiline':False]
['text':' S5:      B[i] = A[i]','line_number':306,'multiline':False]
['text':' S6:      for k','line_number':307,'multiline':False]
['text':' S7:        B[i] = B[i] +','line_number':308,'multiline':False]
['text':' This method performs loop fusion.','line_number':312,'multiline':False]
['text':' For example, consider the following code.','line_number':313,'multiline':False]
['text':'','line_number':314,'multiline':False]
['text':' S1:  for m','line_number':315,'multiline':False]
['text':' S2:    A[m] = 0','line_number':316,'multiline':False]
['text':' S3:    for j','line_number':317,'multiline':False]
['text':' S4:      A[m] = A[m] +','line_number':318,'multiline':False]
['text':' S5:  for n','line_number':319,'multiline':False]
['text':' S5:    B[n] = A[n]','line_number':320,'multiline':False]
['text':' S6:    for k','line_number':321,'multiline':False]
['text':' S7:      B[n] = B[n] +','line_number':322,'multiline':False]
['text':'','line_number':323,'multiline':False]
['text':' fuseLoops({S1, S5}), will return the following loop:','line_number':324,'multiline':False]
['text':' S1:  for m','line_number':325,'multiline':False]
['text':' S2:    A[m] = 0','line_number':326,'multiline':False]
['text':' S3:    for j','line_number':327,'multiline':False]
['text':' S4:      A[m] = A[m] +','line_number':328,'multiline':False]
['text':' S5:    B[m] = A[m]','line_number':329,'multiline':False]
['text':' S6:    for k','line_number':330,'multiline':False]
['text':' S7:      B[m] = B[m] +','line_number':331,'multiline':False]
['text':'','line_number':332,'multiline':False]
['text':' This transformation is unsafe as it simply add all loops into the body of','line_number':333,'multiline':False]
['text':' the first loop for fusion without correctness checks.','line_number':334,'multiline':False]
['text':'','line_number':335,'multiline':False]
['text':' Below are the two requirements to apply unsafeFuseLoops:','line_number':336,'multiline':False]
['text':'  * All the loops have the same parent.','line_number':337,'multiline':False]
['text':'  * There are no statements between these loops in their parent body.','line_number':338,'multiline':False]
['text':' Loop fusion is done only when all the conditions below are satisfied.','line_number':341,'multiline':False]
['text':'  * All the loops have the same parent.','line_number':342,'multiline':False]
['text':'  * There are no statements between these loops in their parent body.','line_number':343,'multiline':False]
['text':'  * The start bounds are the same for all loops.','line_number':344,'multiline':False]
['text':'  * The stop bounds are the same for all loops.','line_number':345,'multiline':False]
['text':'  * Fusing the loops does not violate or add any dependencies.','line_number':346,'multiline':False]
['text':' Reorder the given list of loops according to the permutation specified.','line_number':351,'multiline':False]
['text':' Here `permutation[i]` represents the position of the loop in the input','line_number':352,'multiline':False]
['text':' which will end up at position `i` after the reorder.','line_number':353,'multiline':False]
['text':'','line_number':354,'multiline':False]
['text':' For example, consider the following code:','line_number':355,'multiline':False]
['text':'   for p','line_number':356,'multiline':False]
['text':'     for q','line_number':357,'multiline':False]
['text':'       for r','line_number':358,'multiline':False]
['text':'         for s','line_number':359,'multiline':False]
['text':'           A[p,q,r,s] =','line_number':360,'multiline':False]
['text':'','line_number':361,'multiline':False]
['text':' reorder({p, q, r, s}, {2, 3, 0, 1}) will return the list of loops in the','line_number':362,'multiline':False]
['text':' following form:','line_number':363,'multiline':False]
['text':'    for r','line_number':364,'multiline':False]
['text':'      for s','line_number':365,'multiline':False]
['text':'        for p','line_number':366,'multiline':False]
['text':'          for q','line_number':367,'multiline':False]
['text':'            A[p,q,r,s] =','line_number':368,'multiline':False]
['text':' Tile takes a 2d domain (x, y) and splits it into small rectangular blocks','line_number':373,'multiline':False]
['text':' each with shape (x_factor, y_factor). The traversal over the domain turns','line_number':374,'multiline':False]
['text':' into an outer iteration over the blocks and an inner traversal over all','line_number':375,'multiline':False]
['text':' points in the block.','line_number':376,'multiline':False]
['text':' Note that if x dim % x_factor or y dim % y_factor does not equal to 0, the','line_number':377,'multiline':False]
['text':' loop body will generate corresponding tailing loops.','line_number':378,'multiline':False]
['text':' The transformation is in-place and returns 'xtail'.','line_number':379,'multiline':False]
['text':'','line_number':380,'multiline':False]
['text':' For example, consider the following code:','line_number':381,'multiline':False]
['text':'   for i: [0, 64)','line_number':382,'multiline':False]
['text':'     for j: [0, 64)','line_number':383,'multiline':False]
['text':'       for k: [0, 32)','line_number':384,'multiline':False]
['text':'         A[i, j] = B[i, k] + C[j, k]','line_number':385,'multiline':False]
['text':'','line_number':386,'multiline':False]
['text':' tile(i, j, 4, 8) will transform "i" for-stmt into the following nested','line_number':387,'multiline':False]
['text':' loop:','line_number':388,'multiline':False]
['text':'   for i_outer: [0, 16)','line_number':389,'multiline':False]
['text':'     for j_outer: [0, 8)','line_number':390,'multiline':False]
['text':'       for i_inner: [0, 4)','line_number':391,'multiline':False]
['text':'         for j_inner: [0, 8)','line_number':392,'multiline':False]
['text':'           for k: [0, 32)','line_number':393,'multiline':False]
['text':'             A[i_outer * 4 + i_inner, j_outer * 8 + j_inner] =','line_number':394,'multiline':False]
['text':'             B[i_outer * 4 + i_inner, k] + C[j_outer * 8 + j_inner, k]','line_number':395,'multiline':False]
['text':'','line_number':396,'multiline':False]
['text':' tile(i, j, 4, 9) will transform "i" for-stmt into the following nested','line_number':397,'multiline':False]
['text':' loop:','line_number':398,'multiline':False]
['text':'   for i_outer: [0, 16)','line_number':399,'multiline':False]
['text':'     for j_outer: [0, 7)','line_number':400,'multiline':False]
['text':'       for i_inner: [0, 4)','line_number':401,'multiline':False]
['text':'         for j_inner: [0, 9)','line_number':402,'multiline':False]
['text':'           for k: (0, 32)','line_number':403,'multiline':False]
['text':'             A[i_outer * 4 + i_inner, j_outer * 9 + j_inner] =','line_number':404,'multiline':False]
['text':'             B[i_outer * 4 + i_inner, k] + C[j_outer * 9 + j_inner, k]','line_number':405,'multiline':False]
['text':'     for j_tail: [0, 1)','line_number':406,'multiline':False]
['text':'       for i_inner: [0, 4)','line_number':407,'multiline':False]
['text':'         for k: (0, 32)','line_number':408,'multiline':False]
['text':'           A[i_outer * 4 + i_inner, 7 * 9 + j_tail] =','line_number':409,'multiline':False]
['text':'           B[i_outer * 4 + i_inner, k] + C[7 * 9 + j_tail, k]','line_number':410,'multiline':False]
['text':' Returns true if the given loops are perfectly nested, i.e., every loop','line_number':413,'multiline':False]
['text':' (except the innermost) should have exactly one statement in its body','line_number':414,'multiline':False]
['text':' and that statement must be the next inner loop.','line_number':415,'multiline':False]
['text':' Returns true if the given loop has a loop-carried dependence.','line_number':418,'multiline':False]
['text':' Unrolls all the iterations of the given loop.','line_number':421,'multiline':False]
['text':' Requires that the loop bounds are constant.','line_number':422,'multiline':False]
['text':' Unrolls the given loop for the specified factor.','line_number':426,'multiline':False]
['text':' This does not require constant bounds for the loop being unrolled.','line_number':427,'multiline':False]
['text':' Compresses the given buffer based on its use in the given Stmts.','line_number':437,'multiline':False]
['text':'','line_number':438,'multiline':False]
['text':' NOTE: This API assumes that there are no accesses to the given buffer','line_number':439,'multiline':False]
['text':' outside the given statement. So, this should be called with the entire','line_number':440,'multiline':False]
['text':' kernel statement to avoid incorrect buffer compressions.','line_number':441,'multiline':False]
['text':'','line_number':442,'multiline':False]
['text':' For example, given the input:','line_number':443,'multiline':False]
['text':'','line_number':444,'multiline':False]
['text':' for (int i = 0; i < 100; ++i) {','line_number':445,'multiline':False]
['text':'   for (int j = 0; j < 200; ++j) {','line_number':446,'multiline':False]
['text':'     A[i,j] = sin(i*j)','line_number':447,'multiline':False]
['text':'   }','line_number':448,'multiline':False]
['text':'   for (int j = 0; j < 199; ++j) {','line_number':449,'multiline':False]
['text':'     B[i,j] = A[i,j] + A[i, j+1]','line_number':450,'multiline':False]
['text':'   }','line_number':451,'multiline':False]
['text':' }','line_number':452,'multiline':False]
['text':'','line_number':453,'multiline':False]
['text':' compressBuffer(A, ...) will compress buffer A from','line_number':454,'multiline':False]
['text':' [100, 200] to [1, 200] and modify the code as follows:','line_number':455,'multiline':False]
['text':'','line_number':456,'multiline':False]
['text':' for (int i = 0; i < 100; ++i) {','line_number':457,'multiline':False]
['text':'   for (int j = 0; j < 200; ++j) {','line_number':458,'multiline':False]
['text':'     A[0,j] = sin(i*j)','line_number':459,'multiline':False]
['text':'   }','line_number':460,'multiline':False]
['text':'   for (int j = 0; j < 199; ++j) {','line_number':461,'multiline':False]
['text':'     B[i,j] = A[0,j] + A[0, j+1]','line_number':462,'multiline':False]
['text':'   }','line_number':463,'multiline':False]
['text':' }','line_number':464,'multiline':False]
['text':' Compresses all buffers in the given statement.','line_number':467,'multiline':False]
['text':'','line_number':468,'multiline':False]
['text':' NOTE: This API assumes that there are no accesses to buffers outside','line_number':469,'multiline':False]
['text':' the given statement. So, this should be called with the entire','line_number':470,'multiline':False]
['text':' kernel statement to avoid incorrect buffer compressions.','line_number':471,'multiline':False]
['text':'','line_number':472,'multiline':False]
['text':' TODO: Add an IR verifier check to detect invalidly compressed buffers.','line_number':473,'multiline':False]
['text':' Get 'num' loops from the loopnest starting at 'f'.','line_number':476,'multiline':False]
['text':' LoopOptions are propagated to tail.','line_number':479,'multiline':False]
['text':' LoopOptions are propagated to head.','line_number':482,'multiline':False]
['text':' Insert a cache for the consumer's usages of the buffer produced in','line_number':487,'multiline':False]
['text':' consumer, and redirect reads and writes in the consumer to that cache.','line_number':488,'multiline':False]
['text':' Returns a pair of the new cache buffer, and the new rewritten consumer.','line_number':489,'multiline':False]
['text':' Insert a temporary computation of statement S in the scope of loop AT.','line_number':495,'multiline':False]
['text':' S is assumed to be a Store or a Block containing a Store. Along with the','line_number':496,'multiline':False]
['text':' computation itself, this transformation inserts Alloc/Free statements for','line_number':497,'multiline':False]
['text':' the temporary buffer used in the computation.','line_number':498,'multiline':False]
['text':' Rfactor a reduction axis into a normal axis.','line_number':501,'multiline':False]
['text':'','line_number':502,'multiline':False]
['text':' Requirements:','line_number':503,'multiline':False]
['text':'  * S is the reduction store','line_number':504,'multiline':False]
['text':'  * S is the only statement in the innermost loop','line_number':505,'multiline':False]
['text':'  * There is at least two reduction arguments in S','line_number':506,'multiline':False]
['text':'  * OUTER_REDUCTION_FOR loop corresponds to the outermost reduction variable','line_number':507,'multiline':False]
['text':'  used in the store and all other reduction variables are index variables of','line_number':508,'multiline':False]
['text':'  children loops of OUTER_REDUCTION_FOR','line_number':509,'multiline':False]
['text':'  * OUTER_REDUCTION_FOR is a perfect loop nest, i.e. it has only loops','line_number':510,'multiline':False]
['text':'  corresponding to the other reduction variables and the store, nested into','line_number':511,'multiline':False]
['text':'  each other','line_number':512,'multiline':False]
['text':'','line_number':513,'multiline':False]
['text':' What it does:','line_number':514,'multiline':False]
['text':'   * Introduce a new buffer with an extra dimension of a size equal to the','line_number':515,'multiline':False]
['text':'   span of the loop OUTER_REDUCTION_FOR (the new buffer is returned via','line_number':516,'multiline':False]
['text':'   RFAC_BUF_PTR)','line_number':517,'multiline':False]
['text':'   * Insert an initialization store for the new buffer in','line_number':518,'multiline':False]
['text':'   OUTER_REDUCTION_FOR before its nested loop','line_number':519,'multiline':False]
['text':'   * Replace the reduction store to the original buffer with the reduction','line_number':520,'multiline':False]
['text':'   store to the temp buffer, removing the index var of OUTER_REDUCTION_FOR','line_number':521,'multiline':False]
['text':'   from reduction arguments','line_number':522,'multiline':False]
['text':'   * Insert a final reduction store over the extra dimension of the new','line_number':523,'multiline':False]
['text':'   buffer to the original buffer','line_number':524,'multiline':False]
['text':'   * Returns TRUE if the transformation succeeded and FALSE otherwise','line_number':525,'multiline':False]
['text':'','line_number':526,'multiline':False]
['text':' Example:','line_number':527,'multiline':False]
['text':' Original IR:','line_number':528,'multiline':False]
['text':' S1: for i      # normal axis','line_number':529,'multiline':False]
['text':' S2:   X[i] = 0','line_number':530,'multiline':False]
['text':' S3:   for j    # reduction axis','line_number':531,'multiline':False]
['text':' S4:     for k  # reduction axis','line_number':532,'multiline':False]
['text':' S5:       X[i] = ReduceOp(X[i] + Y[i,j,k], reduce_axis={j,k})','line_number':533,'multiline':False]
['text':'','line_number':534,'multiline':False]
['text':' After RFACTOR(S5, S3)','line_number':535,'multiline':False]
['text':' S1: for i               # normal axis','line_number':536,'multiline':False]
['text':' S2:   X[i] = 0','line_number':537,'multiline':False]
['text':' S3:   for j             # reduction axis for X, normal axis for X_rfac','line_number':538,'multiline':False]
['text':'         X_rfac[i,j] = 0','line_number':539,'multiline':False]
['text':' S4:     for k           # reduction axis','line_number':540,'multiline':False]
['text':'           X_rfac[i,j] = ReduceOp(X_rfac[i,j] + Y[i,j,k], reduce_axis={k})','line_number':541,'multiline':False]
['text':'         X[i] = ReduceOp(X[i] + X_rfac[i,j], reduce_axis={j})','line_number':542,'multiline':False]
['text':' Vectorize the given loop. This method requires that the given loop','line_number':549,'multiline':False]
['text':' does not perform a reduction.','line_number':550,'multiline':False]
['text':' It returns true if vectorization is successful and false otherwise.','line_number':551,'multiline':False]
['text':' Find the inner-most loops and vectorize them. Currently, this only works','line_number':554,'multiline':False]
['text':' for the LLVM backend, when no reductions are involved.','line_number':555,'multiline':False]
['text':' Finds which is the outer For between a and b for loops. If neither of the 2','line_number':568,'multiline':False]
['text':' Fors is an ancestor of the other, it returns nullptr.','line_number':569,'multiline':False]
['text':' TODO: Revisit this once we decide on how dependencies analysis should look','line_number':584,'multiline':False]
['text':' like. Maybe we would choose to use a different API and BufUse would be','line_number':585,'multiline':False]
['text':' removed, or if we decide to keep it we need to properly document its API.','line_number':586,'multiline':False]
['text':'
 * Returns a map ( Buf -> uses of this Buf), uses are represented as vectors of
 * BufUse elements, which are StmtPtr and a bool isStore flag. The order of uses
 * in the vectors reflects the order in which the uses appear in the given
 * statement.
 ','line_number':592,'multiline':True]
['text':' replaces all invalid characters with underscore','line_number':601,'multiline':False]
['text':' namespace tensorexpr','line_number':604,'multiline':False]
['text':' namespace jit','line_number':605,'multiline':False]
['text':' namespace torch','line_number':606,'multiline':False]
