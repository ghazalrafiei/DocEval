['text':' Creates a new Expr of the given type with the provided lhs and rhs.','line_number':10,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-branch-clone)','line_number':17,'multiline':False]
['text':' Can only fold if both sides are constant.','line_number':66,'multiline':False]
['text':' Simple recursive GCD.','line_number':74,'multiline':False]
['text':' Helper for determining if an Expr is a multi-lane primitive (e.g. Broadcast','line_number':83,'multiline':False]
['text':' or Ramp).','line_number':84,'multiline':False]
['text':' order of ops important for float','line_number':99,'multiline':False]
['text':' Once we removed duplicates, sort terms alphabetically for stability.','line_number':149,'multiline':False]
['text':' Once we removed duplicates, sort terms alphabetically for stability.','line_number':172,'multiline':False]
['text':' Handles optimization cases for Broadcast/Ramp +/- Broadcast/Ramp','line_number':185,'multiline':False]
['text':' Handles optimization cases for Broadcast/Ramp * Broadcast/Ramp','line_number':234,'multiline':False]
['text':' If the term is canceled out, remove from the map.','line_number':296,'multiline':False]
['text':' simplify common components','line_number':309,'multiline':False]
['text':' The key here is the variable hash, not the term's hash since we do want','line_number':310,'multiline':False]
['text':' to combine terms that have the same vars but different scalar components.','line_number':311,'multiline':False]
['text':' Insert a new Term into the provided polynomial. If the new term has common','line_number':325,'multiline':False]
['text':' variables to an existing term it is combined.','line_number':326,'multiline':False]
['text':' Skip this term if we cancelled it out.','line_number':336,'multiline':False]
['text':' Constant Folding.','line_number':363,'multiline':False]
['text':' Multilane folding.','line_number':369,'multiline':False]
['text':' If there is a scalar, and it's zero: short circuit and return the other','line_number':386,'multiline':False]
['text':' side.','line_number':387,'multiline':False]
['text':' If this is a floating point Add then order of operations is important, we','line_number':393,'multiline':False]
['text':' dont want to combine ops.','line_number':394,'multiline':False]
['text':' If the terms refer to the same variables: combine them.','line_number':419,'multiline':False]
['text':' If the terms cancelled out, return zero.','line_number':424,'multiline':False]
['text':' Otherwise this is a new polynomial with no scalar and two variable','line_number':432,'multiline':False]
['text':' terms.','line_number':433,'multiline':False]
['text':' Adds are commutative.','line_number':437,'multiline':False]
['text':' Add to Polynomial->scalar().','line_number':440,'multiline':False]
['text':' Simple Polynomial with a scalar and Term.','line_number':446,'multiline':False]
['text':' Simple Term with a scalar and variable type.','line_number':452,'multiline':False]
['text':' If LHS is neither Term not Polynomial, wrap it in a Term.','line_number':458,'multiline':False]
['text':' Same for RHS.','line_number':463,'multiline':False]
['text':' If we now have a poly and a term, we can insert.','line_number':468,'multiline':False]
['text':' If all else fails we have a new Polynomial with two new variable Terms.','line_number':480,'multiline':False]
['text':' If RHS not already negated, negate it.','line_number':488,'multiline':False]
['text':' If the terms cancel out, return zero.','line_number':498,'multiline':False]
['text':' Subtract the RHS Polynomial from the LHS Polynomial, cancelling out where','line_number':513,'multiline':False]
['text':' possible.','line_number':514,'multiline':False]
['text':' simplify common components','line_number':518,'multiline':False]
['text':' The key here is the variable hash, not the term's hash since we do want','line_number':519,'multiline':False]
['text':' to combine terms that have the same vars but different scalar components.','line_number':520,'multiline':False]
['text':' Polynomials add their terms, so negate the RHS's Terms.','line_number':528,'multiline':False]
['text':' No vars means this cancelled out to a scalar, return it unwrapped.','line_number':536,'multiline':False]
['text':' If there is no scalar and zero or one terms, don't wrap.','line_number':541,'multiline':False]
['text':' Wrap new variables in a Polynomial.','line_number':551,'multiline':False]
['text':' Constant Folding.','line_number':559,'multiline':False]
['text':' Multilane folding.','line_number':565,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':568,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':575,'multiline':False]
['text':' If this is a floating point Sub then order of operations is important, we','line_number':579,'multiline':False]
['text':' dont want to combine ops.','line_number':580,'multiline':False]
['text':' Cancelled out completely.','line_number':592,'multiline':False]
['text':' Polynomial - Term.','line_number':601,'multiline':False]
['text':' Negate the term.','line_number':603,'multiline':False]
['text':' Term - Polynomial.','line_number':610,'multiline':False]
['text':' Negate every part of the Polynomial.','line_number':612,'multiline':False]
['text':' Easy path, just sub the scalar component.','line_number':634,'multiline':False]
['text':' Sub the scalar component.','line_number':640,'multiline':False]
['text':' Negate each term in the Polynomial RHS.','line_number':643,'multiline':False]
['text':' Negate the constant.','line_number':655,'multiline':False]
['text':' Negate the RHS Term.','line_number':661,'multiline':False]
['text':' simple term with a scalar and variable type.','line_number':669,'multiline':False]
['text':' Create a negated term.','line_number':671,'multiline':False]
['text':' Negate the scalar.','line_number':677,'multiline':False]
['text':' no scalar...','line_number':683,'multiline':False]
['text':' Insert wrapped Term into LHS Polynomial.','line_number':698,'multiline':False]
['text':' Insert wrapper Term into negated RHS Poly.','line_number':704,'multiline':False]
['text':' Negate each term in the Polynomial RHS.','line_number':710,'multiline':False]
['text':' Multiply two terms together, usually creating a new term with the variable','line_number':724,'multiline':False]
['text':' lists concatenated.','line_number':725,'multiline':False]
['text':' Can reorder here since floating point ops don't get put into Terms.','line_number':732,'multiline':False]
['text':' For now don't handle exponents.','line_number':735,'multiline':False]
['text':' Merge all the multilane vars:','line_number':751,'multiline':False]
['text':' Multiply a Polynomial by a Term.','line_number':772,'multiline':False]
['text':' poly * term','line_number':774,'multiline':False]
['text':'    = (poly_terms + poly_scalar) * term','line_number':775,'multiline':False]
['text':'    = poly_terms * term + poly_scalar * term','line_number':776,'multiline':False]
['text':' First, multiply all variables (terms) in the polynomial by the input','line_number':778,'multiline':False]
['text':' term.','line_number':779,'multiline':False]
['text':' If the scalar in poly is not 0, it must be multiplied by term.','line_number':788,'multiline':False]
['text':' If there are no variables in term, this becomes the scalar in the result','line_number':789,'multiline':False]
['text':' polynomial. If there are variables in term, this becomes a new term in','line_number':790,'multiline':False]
['text':' the result polynomial.','line_number':791,'multiline':False]
['text':' The only case when the result polynomial has a scalar is when the input','line_number':800,'multiline':False]
['text':' term does not have any variables and the input polynomial has a non-zero','line_number':801,'multiline':False]
['text':' scalar. That case is handled above. So, at this point, we do not have any','line_number':802,'multiline':False]
['text':' scalars in the result polynomial.','line_number':803,'multiline':False]
['text':' Does multiplying these two expressions make a Rounding Off operation.','line_number':807,'multiline':False]
['text':' e.g. LHS = (x/y),  RHS = y => (x / y) * y => RoundOff(x, y).','line_number':808,'multiline':False]
['text':' If the denominator is equal to the other, then yes it's a RoundOff.','line_number':831,'multiline':False]
['text':' If they are both scalar we may be able to find a common factor.','line_number':839,'multiline':False]
['text':' Inserts a new component into a term, looking for opportunities to simplify.','line_number':851,'multiline':False]
['text':' Search for RoundOffs.','line_number':855,'multiline':False]
['text':' Constant Folding.','line_number':881,'multiline':False]
['text':' Multilane folding.','line_number':886,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':889,'multiline':False]
['text':' Order doesn't matter.','line_number':894,'multiline':False]
['text':' Handle special case mul by 1 since thats safe for floating point, even if','line_number':905,'multiline':False]
['text':' it's Nan/Inf.','line_number':906,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':909,'multiline':False]
['text':' If this is a floating point Mul then order of operations is important, we','line_number':913,'multiline':False]
['text':' dont want to combine ops.','line_number':914,'multiline':False]
['text':' Handle special case mul by 0.','line_number':920,'multiline':False]
['text':' Catch cases of rounding (Div(A/B) * B).','line_number':925,'multiline':False]
['text':' We can break the Round + Mod pattern via factorization of the Div, so','line_number':929,'multiline':False]
['text':' check whether it would have worked on the unsimplified tree. If so, we','line_number':930,'multiline':False]
['text':' need to simplify again.','line_number':931,'multiline':False]
['text':' This expands to more terms that we can't generally fix without variable','line_number':939,'multiline':False]
['text':' factorization, it's more efficient to just leave these as Muls.','line_number':940,'multiline':False]
['text':' If this is a scalar * a Polynomial, push the scalar term down.','line_number':969,'multiline':False]
['text':' We can wrap the scalar with a Term and use polyByTerm.','line_number':970,'multiline':False]
['text':' simple term with a scalar and variable type.','line_number':978,'multiline':False]
['text':' Multiplying Polynomial by variable can be wrapped in a term and handled','line_number':983,'multiline':False]
['text':' by polyByTerm also.','line_number':984,'multiline':False]
['text':' Multiplying Term by a variable is equivalent to adding the variable to','line_number':994,'multiline':False]
['text':' the term's list of vars.','line_number':995,'multiline':False]
['text':' Two variables, create a new Term.','line_number':1003,'multiline':False]
['text':' Constant Folding.','line_number':1059,'multiline':False]
['text':' If this is a floating point Div then order of operations is important, we','line_number':1064,'multiline':False]
['text':' dont want to combine ops.','line_number':1065,'multiline':False]
['text':' If the numerator is zero, so is the result.','line_number':1071,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':1073,'multiline':False]
['text':' If the denominator is one, return numerator.','line_number':1077,'multiline':False]
['text':' If numberator and denominator are equal the result is 1.','line_number':1082,'multiline':False]
['text':' Unless the demoninator could be zero.','line_number':1083,'multiline':False]
['text':' if (hasher_.hash(lhs_new) == hasher_.hash(rhs_new)) {','line_number':1084,'multiline':False]
['text':'   return getImmediateByType(v->dtype(), 1);','line_number':1085,'multiline':False]
['text':' }','line_number':1086,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':1089,'multiline':False]
['text':' Constant Folding.','line_number':1100,'multiline':False]
['text':' 0 % x => 0.','line_number':1105,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':1107,'multiline':False]
['text':' x % 1 == 0.','line_number':1111,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':1113,'multiline':False]
['text':' x % x => 0.','line_number':1117,'multiline':False]
['text':' Can still optimize this out if we can factorize the polynomial.','line_number':1126,'multiline':False]
['text':' ((C1 * C2) * x) % C1 => 0.','line_number':1132,'multiline':False]
['text':' (x * y * z) % x => 0.','line_number':1139,'multiline':False]
['text':' (6 * x * y) % (3 * x * y) => 0.','line_number':1146,'multiline':False]
['text':' also, (x * y * z) % (z * y) => 0.','line_number':1147,'multiline':False]
['text':' This requires all variable terms found in the RHS to be present in the','line_number':1148,'multiline':False]
['text':' LHS.','line_number':1149,'multiline':False]
['text':' Combines two MinTerm / MaxTerm expressions into one.','line_number':1186,'multiline':False]
['text':' The first type on the template refers to the op, as in Min or Max and the','line_number':1187,'multiline':False]
['text':' second type refers to the corresponding term, as in MinTerm or MaxTerm.','line_number':1188,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)','line_number':1224,'multiline':False]
['text':' Returns true if op is one of the 2 operands in opterm and also returns','line_number':1252,'multiline':False]
['text':' the other op of opterm in other_op.','line_number':1253,'multiline':False]
['text':' Simplifies the nested min-max pattern like:','line_number':1276,'multiline':False]
['text':'   * Max(Min(x, y), Min(x, z)) => Min(x, Max(y, z))','line_number':1277,'multiline':False]
['text':'   * Min(Max(x, y), Max(x, z)) => Max(x, Min(y, z))','line_number':1278,'multiline':False]
['text':' This function is called while processing the outer Min / Max ops.','line_number':1279,'multiline':False]
['text':' At that point the inner Min / Max ops would have been converted to','line_number':1280,'multiline':False]
['text':' MinTerm / MaxTerm as appropriate. So, this function checks for those','line_number':1281,'multiline':False]
['text':' term expressions in the given lhs and rhs.','line_number':1282,'multiline':False]
['text':'','line_number':1283,'multiline':False]
['text':' The first type of the template must be the term type corresponding to the','line_number':1284,'multiline':False]
['text':' outer op (e.g. MaxTerm) and the second type of the template must be the term','line_number':1285,'multiline':False]
['text':' type corresponding to the expected inner op (e.g. MinTerm).','line_number':1286,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1304,'multiline':False]
['text':' namespace','line_number':1328,'multiline':False]
['text':' Constant Folding.','line_number':1334,'multiline':False]
['text':' If diff is constant, return the appropriate operand.','line_number':1339,'multiline':False]
['text':' Max(Min(x, y), Min(x, z)) => Min(x, Max(y, z))','line_number':1349,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1350,'multiline':False]
['text':' Constant Folding.','line_number':1365,'multiline':False]
['text':' If diff is constant, return the appropriate operand.','line_number':1370,'multiline':False]
['text':' Min(Max(x, y), Max(x, z)) => Max(x, Min(y, z))','line_number':1380,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1381,'multiline':False]
['text':' Constant Folding.','line_number':1398,'multiline':False]
['text':' If the comparison is done in float, don't attempt diff simplification,','line_number':1411,'multiline':False]
['text':' since we can't correctly handle NaN.','line_number':1412,'multiline':False]
['text':' If diff is constant, we can determine it.','line_number':1424,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':1428,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':1435,'multiline':False]
['text':' should not be possible but just in case.','line_number':1458,'multiline':False]
['text':' we're evaluating, but the evaluator only supports float intrinsics.','line_number':1489,'multiline':False]
['text':' If the condition is constant then we can choose the right branch now.','line_number':1529,'multiline':False]
['text':' If both branches are the same then don't do the condition.','line_number':1538,'multiline':False]
['text':' If the condition is constant then we can choose the right branch now.','line_number':1576,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':1579,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':1582,'multiline':False]
['text':' If both branches are the same then don't do the condition.','line_number':1587,'multiline':False]
['text':' If the condition depends on a Var that is modified in the loop body, it','line_number':1620,'multiline':False]
['text':' may not be safe to reorder.','line_number':1621,'multiline':False]
['text':' Flatten sub-blocks:','line_number':1692,'multiline':False]
['text':' Be careful to avoid invalidating the iterator.','line_number':1704,'multiline':False]
['text':' TermExpander','line_number':1720,'multiline':False]
['text':' Assume we can reorder here because we wont merge floating terms.','line_number':1731,'multiline':False]
['text':' If the sub-Expr resolved to a multiplication, lift it into this','line_number':1736,'multiline':False]
['text':' term.','line_number':1737,'multiline':False]
['text':' simplify first, then re-expand.','line_number':1763,'multiline':False]
['text':' We want to avoid a leaving a CastNode on the scalar, so handle that','line_number':1779,'multiline':False]
['text':' now.','line_number':1780,'multiline':False]
['text':' Take care of lane mismatch first.','line_number':1785,'multiline':False]
['text':' Now take care of scalar type as well.','line_number':1789,'multiline':False]
['text':' For scalars, we can simplify the cast further.','line_number':1792,'multiline':False]
['text':' Returns an immediate containing the greatest common divisor of all terms','line_number':1809,'multiline':False]
['text':' (inc. the scalar term) in the polynomial. If the GCD is uninteresting','line_number':1810,'multiline':False]
['text':' (e.g. 1) then returns nullptr.','line_number':1811,'multiline':False]
['text':' We ony want to factorize if we're saving complete operations, i.e. no','line_number':1816,'multiline':False]
['text':' value in factorizing 6x + 4y into 2 * (3x + 2y) since we don't save work.','line_number':1817,'multiline':False]
['text':' default to saving the scalar.','line_number':1818,'multiline':False]
['text':' Not worth, can be a Sub.','line_number':1845,'multiline':False]
['text':' A ModRound is a div-mod-mul in which the divisor in div and multiplier in mul','line_number':1853,'multiline':False]
['text':' are identical and not equal to 1.','line_number':1854,'multiline':False]
['text':' In a ModRound x/y%z*y*c (c is constant), 'scalar' denotes c, 'denominator'','line_number':1855,'multiline':False]
['text':' denotes x, 'divisor' denotes y and 'mod_divisor' denotes z.','line_number':1856,'multiline':False]
['text':' TODO: currently only identify terms with one variable being mod; it is','line_number':1882,'multiline':False]
['text':' possible to extend this if we have to handle terms like (t/(x%2 * y) %','line_number':1883,'multiline':False]
['text':' z) * (x%2 *y).','line_number':1884,'multiline':False]
['text':' Take care of special cases before multiplying the scalar and variable.','line_number':1891,'multiline':False]
['text':' Take care of lane mismatch first.','line_number':1893,'multiline':False]
['text':' Take care of scalar type mismatch.','line_number':1897,'multiline':False]
['text':' All non-mod variables are considered as part of the multiplier.','line_number':1906,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':1913,'multiline':False]
['text':' Deny cases in which divisor!=multiplier.','line_number':1929,'multiline':False]
['text':' TODO: currently we do not extract a common factor if divisor and','line_number':1932,'multiline':False]
['text':' multiplier are not constants. The extraction is not supported (e.g.,','line_number':1933,'multiline':False]
['text':' x*2/x -> 2) in IRSimplifier.simplify because x could be 0. As future','line_number':1934,'multiline':False]
['text':' work, we can extend division to 2 versions: 1) division for customers','line_number':1935,'multiline':False]
['text':' that has to be strictly simplified and 2) division we introduced in our','line_number':1936,'multiline':False]
['text':' transformations which can be simplified without considering 0s, e.g.,','line_number':1937,'multiline':False]
['text':' Div_nonzero. The second division will be only used to facilitate our','line_number':1938,'multiline':False]
['text':' transformations.','line_number':1939,'multiline':False]
['text':' If both are scalar we may be able to find a common factor.','line_number':1941,'multiline':False]
['text':' The common factor becomes 'scalar' of the term, e.g.,in t/3%7*6,','line_number':1943,'multiline':False]
['text':' divisor=multiplier=3, scalar=2.','line_number':1944,'multiline':False]
['text':' The common factor becomes part of 'denom', e.g., in t/14%7*2,','line_number':1949,'multiline':False]
['text':' divisor=multiplier=2, denom=t/7.','line_number':1950,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':1953,'multiline':False]
['text':' Deny cases in which divisor=1. Such cases are considered as Mods.','line_number':1963,'multiline':False]
['text':' Search the polynomial for Terms that can be merged in','line_number':1975,'multiline':False]
['text':' (1) Round + Mod pattern: (x/y) * y + x % y => RoundOff(x,y) + Mod(x, y) => x','line_number':1976,'multiline':False]
['text':' (2) Mod round + Mod pattern: (x/y % z)*y + x%y => ModRound(x, y, z) + Mod(x,','line_number':1977,'multiline':False]
['text':' y) => x % (y*z)','line_number':1978,'multiline':False]
['text':' Split out the Mod, ModRounds and RoundOffs operations so we can inspect.','line_number':1985,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)','line_number':2000,'multiline':False]
['text':' Can't continue without at least one RoundOff/ModRound and one Mod.','line_number':2012,'multiline':False]
['text':' Repeat merging terms till there are no Mods or the terms cannot be merged','line_number':2021,'multiline':False]
['text':' any further.','line_number':2022,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-narrowing-conversions,cppcoreguidelines-narrowing-conversions)','line_number':2025,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-narrowing-conversions,cppcoreguidelines-narrowing-conversions)','line_number':2033,'multiline':False]
['text':' TODO: for now don't attempt partial factorization of this','line_number':2040,'multiline':False]
['text':' optimization. E.g. it's possible to do: 2 * (x/y%z) * y + (x%y) =>','line_number':2041,'multiline':False]
['text':' x%(y*z) + (x/y%z) * y','line_number':2042,'multiline':False]
['text':' Valid optimization if mod LHS matches denom and mod RHS matches','line_number':2047,'multiline':False]
['text':' divisor.','line_number':2048,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':2051,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-narrowing-conversions,cppcoreguidelines-narrowing-conversions)','line_number':2072,'multiline':False]
['text':' TODO: for now don't attempt partial factorization of this','line_number':2078,'multiline':False]
['text':' optimization. E.g. it's possible to do: 2 * (x/y) * y + (x%y) => x +','line_number':2079,'multiline':False]
['text':' (x/y) * y but unsure thats actually much better, particularly with','line_number':2080,'multiline':False]
['text':' CSE.','line_number':2081,'multiline':False]
['text':' Valid optimization if LHS and RHS are equal for both.','line_number':2088,'multiline':False]
['text':' If we didn't merge, move out the Mod.','line_number':2101,'multiline':False]
['text':' end of for-loop','line_number':2107,'multiline':False]
['text':' Add newly generated Mods for merging opportunities in the next iteration.','line_number':2109,'multiline':False]
['text':' end of while-loop','line_number':2115,'multiline':False]
['text':' If we made no changes, just exit.','line_number':2117,'multiline':False]
['text':' Keep remaining ModRounds and RoundOffs.','line_number':2122,'multiline':False]
['text':' Trivially factorize terms by GCD of scalar components.','line_number':2134,'multiline':False]
['text':' Compute the GCD of terms.','line_number':2139,'multiline':False]
['text':' No GCD means 0 or 1 and can't be factored.','line_number':2142,'multiline':False]
['text':' Create new structure.','line_number':2147,'multiline':False]
['text':' New term with the scalar divided by the GCD.','line_number':2151,'multiline':False]
['text':' If this Polynomial can be factorized: do it, then expand the result.','line_number':2169,'multiline':False]
['text':' If this Polynomial can be factorized: do it, then expand the result.','line_number':2174,'multiline':False]
['text':' partition the terms into a list to add and list to subtract.','line_number':2194,'multiline':False]
['text':' Skip terms with a scalar of zero.','line_number':2201,'multiline':False]
['text':' The last node constructed.','line_number':2204,'multiline':False]
['text':' simplify result first, then expand.','line_number':2218,'multiline':False]
['text':' If we have no add terms the scalar should go first.','line_number':2228,'multiline':False]
['text':' E.g. 1 - x.','line_number':2229,'multiline':False]
['text':' Can still be first node if scalarVal is 0.','line_number':2241,'multiline':False]
['text':' Negate the term back to positive since we'll be subtracting it.','line_number':2247,'multiline':False]
['text':' Negate the scalar and subtract.','line_number':2262,'multiline':False]
['text':' we want to avoid a cast to the scalar if it would happen.','line_number':2267,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)','line_number':2268,'multiline':False]
['text':' This case should never happen because MaxTerm will be created only','line_number':2284,'multiline':False]
['text':' on valid Max expressions.','line_number':2285,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2290,'multiline':False]
['text':' This case should never happen because MinTerm will be created only','line_number':2307,'multiline':False]
['text':' on valid Min expressions.','line_number':2308,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2313,'multiline':False]
['text':' Expands RoundOff(x, y) => Term(1, Div(x, y), y), which will later be expanded','line_number':2326,'multiline':False]
['text':' to Mul(Div(x, y), y).','line_number':2327,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':2348,'multiline':False]
['text':' Combines adjacent Cond nodes with identical conditions.','line_number':2389,'multiline':False]
['text':' If the previous statement is a Cond and the conditions are identical,','line_number':2403,'multiline':False]
['text':' then we fuse.','line_number':2404,'multiline':False]
['text':' Fuse the two Conds by appending the bodies of the second Cond to the','line_number':2413,'multiline':False]
['text':' first.','line_number':2414,'multiline':False]
['text':' avoid unflattening this Cond if we can.','line_number':2434,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':2443,'multiline':False]
['text':' erase, which shortens the list.','line_number':2448,'multiline':False]
['text':' clean up parents.','line_number':2458,'multiline':False]
['text':' only really first if highest level Block.','line_number':2469,'multiline':False]
['text':' clean up parents.','line_number':2503,'multiline':False]
['text':' fuseConditions will return the original block if it cannot fuse.','line_number':2520,'multiline':False]
['text':'/ fuseSyncThreads too.','line_number':2522,'multiline':False]
['text':' SimplifierUnderContext','line_number':2526,'multiline':False]
['text':'','line_number':2527,'multiline':False]
['text':' This function records the bounds(range) info of the index var in a for-stmt.','line_number':2528,'multiline':False]
['text':' The bounds info will be used later when simplifying expressions with the','line_number':2529,'multiline':False]
['text':' index var.','line_number':2530,'multiline':False]
['text':' save bounds info before this for-stmt','line_number':2543,'multiline':False]
['text':'','line_number':2544,'multiline':False]
['text':' The same variable could have appeared in a if-stmt which the for-stmt is','line_number':2545,'multiline':False]
['text':' nested inside, and we need to restore its bounds info after the for-stmt.','line_number':2546,'multiline':False]
['text':'','line_number':2547,'multiline':False]
['text':' An example,','line_number':2548,'multiline':False]
['text':' if (i>=0 && i<5) {','line_number':2549,'multiline':False]
['text':'   for (i=0; i<3; i++){','line_number':2550,'multiline':False]
['text':'     A[i] = ...','line_number':2551,'multiline':False]
['text':'   }','line_number':2552,'multiline':False]
['text':'   x = (i+20) / 5;','line_number':2553,'multiline':False]
['text':'}','line_number':2554,'multiline':False]
['text':' Inside the if stmt, i is in the range of [0, 5); and if we can restore this','line_number':2555,'multiline':False]
['text':' bound info after the for stmt, we can use it to simplify the assignment','line_number':2556,'multiline':False]
['text':' stmt x = (i+20)/5 to x = 4.','line_number':2557,'multiline':False]
['text':' set bounds info for index var','line_number':2566,'multiline':False]
['text':' erase index var bounds info or restore old bounds info','line_number':2579,'multiline':False]
['text':' erase index var bounds info or restore old bounds info','line_number':2592,'multiline':False]
['text':' if the stmt in the loop body is a if-stmt, try to move the branching','line_number':2609,'multiline':False]
['text':' out of the loop','line_number':2610,'multiline':False]
['text':' Simplify division using distributive laws for the following cases:','line_number':2635,'multiline':False]
['text':' 1) (i + x) / n => x/n, if','line_number':2636,'multiline':False]
['text':'   a) n is a positive integer constant;','line_number':2637,'multiline':False]
['text':'   b) i is the index var of a for-stmt and the range of i is','line_number':2638,'multiline':False]
['text':' a subset of [0, n);','line_number':2639,'multiline':False]
['text':'   c) x is a constant and the end value of i's range is less than n - x%n;','line_number':2640,'multiline':False]
['text':'   TODO: remove d) from the requirements because the simplification formula','line_number':2641,'multiline':False]
['text':'   still holds when x is a negative integer. In integer division, the result','line_number':2642,'multiline':False]
['text':'   of the division is converted to an integer using `floor` function which','line_number':2643,'multiline':False]
['text':'   returns the largest integer that is not greater than X. For example, -1/6','line_number':2644,'multiline':False]
['text':'   returns -1. But currently, both Pytorch and NNC are performing an incorrect','line_number':2645,'multiline':False]
['text':'   integer division: (-1)/6 = 0. With the current implementation of integer','line_number':2646,'multiline':False]
['text':'   division, x has to be not negative. d) x is not negative','line_number':2647,'multiline':False]
['text':'','line_number':2648,'multiline':False]
['text':' 2) (i + j*n) / n => j, if','line_number':2649,'multiline':False]
['text':'   a) n is a positive integer constant;','line_number':2650,'multiline':False]
['text':'   b) i is the index var of a for-stmt and the range of i is','line_number':2651,'multiline':False]
['text':' a subset of [0, n);','line_number':2652,'multiline':False]
['text':'   c) j is an integer variable;','line_number':2653,'multiline':False]
['text':'   TODO: remove d) from the requirements because the simplification formula','line_number':2654,'multiline':False]
['text':'   still holds when j is a negative integer. In integer division, the result','line_number':2655,'multiline':False]
['text':'   of the division is converted to an integer using `floor` function which','line_number':2656,'multiline':False]
['text':'   returns the largest integer that is not greater than X. For example, -1/6','line_number':2657,'multiline':False]
['text':'   returns -1. But currently, both Pytorch and NNC are performing an incorrect','line_number':2658,'multiline':False]
['text':'   integer division: (-1)/6 = 0. With the current implementation of integer','line_number':2659,'multiline':False]
['text':'   division, x has to be not negative. d) j is not negative','line_number':2660,'multiline':False]
['text':' return if not integer division','line_number':2668,'multiline':False]
['text':' identify n: a positive integer constant','line_number':2673,'multiline':False]
['text':' identify index var 'i'','line_number':2691,'multiline':False]
['text':' check the bounds of 'i'','line_number':2708,'multiline':False]
['text':' open upper bound, i.e.,  end is one more than the maximum value in the','line_number':2710,'multiline':False]
['text':' range','line_number':2711,'multiline':False]
['text':' simplify type 1) exprs: '(i+x)/n' => 'x/n'','line_number':2724,'multiline':False]
['text':' simplify type 2 exprs: '(i+j*n)/n' => 'j'','line_number':2735,'multiline':False]
['text':' FIXME: Allow any integral type.','line_number':2737,'multiline':False]
['text':' retrieve j's range info','line_number':2739,'multiline':False]
['text':' check if j is not negative','line_number':2745,'multiline':False]
['text':' Simplify mod using distributive laws for the following cases:','line_number':2756,'multiline':False]
['text':' 1) (i + x) % n => i + x%n if','line_number':2757,'multiline':False]
['text':'   a) n is a positive integer constant;','line_number':2758,'multiline':False]
['text':'   b) i is the index var of a for-stmt and the range of i is','line_number':2759,'multiline':False]
['text':' a subset of [0, n);','line_number':2760,'multiline':False]
['text':'   c) x is a constant and the end value of i's range is less than n - x%n;','line_number':2761,'multiline':False]
['text':'   TODO: remove d) from the requirements because the simplification formula','line_number':2762,'multiline':False]
['text':'   still holds when x is a negative integer. In integer division, the result','line_number':2763,'multiline':False]
['text':'   of the division is converted to an integer using `floor` function which','line_number':2764,'multiline':False]
['text':'   returns the largest integer that is not greater than X. For example, -1/6','line_number':2765,'multiline':False]
['text':'   returns -1. But currently, both Pytorch and NNC are performing an incorrect','line_number':2766,'multiline':False]
['text':'   integer division: (-1)/6 = 0. With the current implementation of integer','line_number':2767,'multiline':False]
['text':'   division, x has to be not negative. d) x is not negative','line_number':2768,'multiline':False]
['text':'','line_number':2769,'multiline':False]
['text':' 2) (i + j*n) % n => i if','line_number':2770,'multiline':False]
['text':'   a) n is a positive integer constant;','line_number':2771,'multiline':False]
['text':'   b) i is the index var of a for-stmt and the range of i is','line_number':2772,'multiline':False]
['text':' a subset of [0, n);','line_number':2773,'multiline':False]
['text':'   c) j is an integer variable;','line_number':2774,'multiline':False]
['text':'   TODO: remove d) from the requirements because the simplification formula','line_number':2775,'multiline':False]
['text':'   still holds when j is a negative integer. In integer division, the result','line_number':2776,'multiline':False]
['text':'   of the division is converted to an integer using `floor` function which','line_number':2777,'multiline':False]
['text':'   returns the largest integer that is not greater than X. For example, -1/6','line_number':2778,'multiline':False]
['text':'   returns -1. But currently, both Pytorch and NNC are performing an incorrect','line_number':2779,'multiline':False]
['text':'   integer division: (-1)/6 = 0. With the current implementation of integer','line_number':2780,'multiline':False]
['text':'   division, j has to be not negative. d) j is not negative','line_number':2781,'multiline':False]
['text':' return if not integer mod','line_number':2789,'multiline':False]
['text':' identify n: a positive integer constant','line_number':2794,'multiline':False]
['text':' identify index var 'i'','line_number':2815,'multiline':False]
['text':' check the bounds of 'i'','line_number':2831,'multiline':False]
['text':' open upper bound, i.e.,  end is one more than the maximum value in the','line_number':2833,'multiline':False]
['text':' range','line_number':2834,'multiline':False]
['text':' simplify type 1) exprs: '(i+x)%n' => 'i+x%n'','line_number':2845,'multiline':False]
['text':' simplify type 2) exprs: '(i+j*n)%n' => 'i'','line_number':2856,'multiline':False]
['text':' FIXME: Allow any integral type.','line_number':2859,'multiline':False]
['text':' retrieve j's range info','line_number':2861,'multiline':False]
['text':' check if j is not negative','line_number':2867,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':2885,'multiline':False]
['text':' i / N -> 0 if the range of i's values is a subset of [0, N)','line_number':2889,'multiline':False]
['text':' where N is an integer constant','line_number':2890,'multiline':False]
['text':' Return the simplified ret1/ret2 if the compare result is deterministic.','line_number':2988,'multiline':False]
['text':' Otherwise, return the simplified CompareSelect directly.','line_number':2989,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':3006,'multiline':False]
['text':' i % N -> i if the range of i's values is a subset of [0, N)','line_number':3010,'multiline':False]
['text':' where N is an integer constant','line_number':3011,'multiline':False]
['text':' TODO: Need to add the boundary information(close/open) of a range to','line_number':3062,'multiline':False]
['text':' Bound. Currently, the VarBoundInfo comes from for-loop statement while','line_number':3063,'multiline':False]
['text':' the end of the boundary is open. But we assume the start and end of a','line_number':3064,'multiline':False]
['text':' range are always close. Hence, we explicitly convert the open boundary to','line_number':3065,'multiline':False]
['text':' close.','line_number':3066,'multiline':False]
['text':'   [for-start, for-stop) => [for-start, for-stop -1]','line_number':3067,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':3075,'multiline':False]
['text':' There may be terms left in the IR, expand them.','line_number':3094,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':3097,'multiline':False]
['text':' There may be terms left in the IR, expand them.','line_number':3118,'multiline':False]
['text':' namespace torch::jit::tensorexpr','line_number':3129,'multiline':False]
