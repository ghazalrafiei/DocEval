['text':' Returns true if the given expression is guaranteed to be positive.','line_number':10,'multiline':False]
['text':' Returns true if the given expression is guaranteed to be negative.','line_number':19,'multiline':False]
['text':' Returns true if the given expression is guaranteed to be zero.','line_number':28,'multiline':False]
['text':' If they're equal they're equal.','line_number':85,'multiline':False]
['text':' We have to figure out if the bounds fall under the following 2 cases:','line_number':92,'multiline':False]
['text':' 1. a is before b','line_number':93,'multiline':False]
['text':'      a.start ... a.end ... b.start ... b.end','line_number':94,'multiline':False]
['text':' 2. b is before a','line_number':95,'multiline':False]
['text':'      b.start ... b.end ... a.start ... a.end','line_number':96,'multiline':False]
['text':'','line_number':97,'multiline':False]
['text':' So, we compute "a.start - b.end" and "b.start - a.end". If even one of','line_number':98,'multiline':False]
['text':' those is positive, then it is guaranteed that the bounds do not overlap.','line_number':99,'multiline':False]
['text':'','line_number':100,'multiline':False]
['text':' If the diff is a constant, then we can directly check if the constant is','line_number':101,'multiline':False]
['text':' positive. If the diff is not a constant, then it will be made of','line_number':102,'multiline':False]
['text':' variables that correspond to the bounds of buffers involved. These buffer','line_number':103,'multiline':False]
['text':' bounds can never be negative. So, we check if the given expression is','line_number':104,'multiline':False]
['text':' guaranteed to be positive under the assumption that the variables involved','line_number':105,'multiline':False]
['text':' are never negative.','line_number':106,'multiline':False]
['text':' If one side fully encloses the other, they're adjacent.','line_number':121,'multiline':False]
['text':' If diff_start and diff_end have different signs they are enclosing.','line_number':125,'multiline':False]
['text':' We can't be sure there's no overlap so the conservative answer is','line_number':135,'multiline':False]
['text':' partial.','line_number':136,'multiline':False]
['text':' All accesses to a buf must have the same dimensionality.','line_number':207,'multiline':False]
['text':' The bounds must overlap.','line_number':249,'multiline':False]
['text':' If the diff has only a single var, we can try to guess sign.','line_number':260,'multiline':False]
['text':' If we can't infer the bound lengths, there's no way to create a safe','line_number':285,'multiline':False]
['text':' subset. Just bail out.','line_number':286,'multiline':False]
['text':' All accesses to a buf must have the same dimensionality.','line_number':316,'multiline':False]
['text':' Each dimension can be sliced into multiple bound segments.','line_number':319,'multiline':False]
['text':' In some cases, we might end up with empty remainingSlices due to the','line_number':348,'multiline':False]
['text':' optimization done in subtraction while handling diff expressions','line_number':349,'multiline':False]
['text':' that have a single variable in `subtractBound()`.','line_number':350,'multiline':False]
['text':' namespace torch::jit::tensorexpr::analysis','line_number':370,'multiline':False]
