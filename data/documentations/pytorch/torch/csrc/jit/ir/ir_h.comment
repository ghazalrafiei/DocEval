['text':' Forward declare, the real meat is in python_ir.cpp','line_number':30,'multiline':False]
['text':' namespace utils','line_number':40,'multiline':False]
['text':' namespace cuda','line_number':85,'multiline':False]
['text':' A Graph represents one "function" of computation.','line_number':91,'multiline':False]
['text':' It uses a simple ownership model where the graph owns all the nodes inside','line_number':92,'multiline':False]
['text':' it. All references inside the graph are raw pointers. Destroying the Graph','line_number':93,'multiline':False]
['text':' will invalidate any pointers to nodes in the graph.','line_number':94,'multiline':False]
['text':' Node is the base class of the IR graph. It represents one computation','line_number':97,'multiline':False]
['text':' and dependencies on a list of Values. The "prim-ops", so to speak.','line_number':98,'multiline':False]
['text':' A Value represents an input or output to node that is either a','line_number':101,'multiline':False]
['text':' Tensor or an opaque Handle object, as determined by type().','line_number':102,'multiline':False]
['text':' A list of nodes, with inputs and outputs','line_number':108,'multiline':False]
['text':' Each use is represented by this type, see 'Node::uses()'','line_number':111,'multiline':False]
['text':' 'user' is the consumer of the value, 'offset' is the index into','line_number':112,'multiline':False]
['text':' 'user's input this where the producers will be found.','line_number':113,'multiline':False]
['text':' Note [User node does not uniquely identify use]','line_number':124,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':125,'multiline':False]
['text':' A while back, we wrote some code manipulating uses that looked like this:','line_number':126,'multiline':False]
['text':'','line_number':127,'multiline':False]
['text':'    for (auto& use : used_val->uses_) {','line_number':128,'multiline':False]
['text':'      if (use.user == this_node) {','line_number':129,'multiline':False]
['text':'        use.offset += 1;','line_number':130,'multiline':False]
['text':'        break;','line_number':131,'multiline':False]
['text':'      }','line_number':132,'multiline':False]
['text':'    }','line_number':133,'multiline':False]
['text':'','line_number':134,'multiline':False]
['text':' This code is trying to find a particular use (our node's use) to update it.','line_number':135,'multiline':False]
['text':' However, it's wrong: there may be *multiple* uses of a value %x in a node,','line_number':136,'multiline':False]
['text':' as might be the case in this IR:','line_number':137,'multiline':False]
['text':'','line_number':138,'multiline':False]
['text':'    %y = Add %x %x','line_number':139,'multiline':False]
['text':'','line_number':140,'multiline':False]
['text':' In this case, there are two uses of %x whose user is the node 'Add %x %x'.','line_number':141,'multiline':False]
['text':' So, "use induced by this node" is not a well-formed concept.','line_number':142,'multiline':False]
['text':'','line_number':143,'multiline':False]
['text':' If you are looking for "use induced by an input", it's best to use','line_number':144,'multiline':False]
['text':' findUseForInput() to get it.','line_number':145,'multiline':False]
['text':' the list types are intentionally simple, but we type-def','line_number':147,'multiline':False]
['text':' them here so if we need to change them, refactoring will be easier','line_number':148,'multiline':False]
['text':' This is a wrapper to allow invalidating the Python object','line_number':162,'multiline':False]
['text':' safely when the C++ object for a Node/Value/Block is deleted','line_number':163,'multiline':False]
['text':' like much of graph, it isn't safe for different threads to','line_number':164,'multiline':False]
['text':' access the same graph','line_number':165,'multiline':False]
['text':' unique id','line_number':188,'multiline':False]
['text':' a managing wrapper for Python to allow invalidation','line_number':192,'multiline':False]
['text':'*
   * @warning NEVER pass raw pointer of smart pointer managed Graph to Python.
   * Check #87343 for details.
   ','line_number':243,'multiline':True]
['text':' TODO: make this more const correct','line_number':249,'multiline':False]
['text':' Replaces all uses of this value with 'newValue'.','line_number':260,'multiline':False]
['text':'','line_number':261,'multiline':False]
['text':' Given:   %3 = f(%1, %2)','line_number':262,'multiline':False]
['text':'          %4 = g(%3)','line_number':263,'multiline':False]
['text':'          %5 = h(%3, %3)','line_number':264,'multiline':False]
['text':' Execute: %3.replaceAllUsesWith(%6)','line_number':265,'multiline':False]
['text':' Result:  %3 = f(%1, %2)','line_number':266,'multiline':False]
['text':'          %4 = g(%6)','line_number':267,'multiline':False]
['text':'          %5 = h(%6, %6)','line_number':268,'multiline':False]
['text':' Replaces all uses of this value with 'newValue' after 'node'.','line_number':271,'multiline':False]
['text':' Given:   %3 = f(%1, %2)','line_number':272,'multiline':False]
['text':'          %4 = g(%3)','line_number':273,'multiline':False]
['text':'          %5 = inplace_(%3)','line_number':274,'multiline':False]
['text':'          %6 = h(%3, %3)','line_number':275,'multiline':False]
['text':' Execute: %3.replaceAllUsesAfterNodeWith(%5.node(), %5)','line_number':276,'multiline':False]
['text':' Result:  %3 = f(%1, %2)','line_number':277,'multiline':False]
['text':'          %4 = g(%3)','line_number':278,'multiline':False]
['text':'          %5 = inplace_(%3)','line_number':279,'multiline':False]
['text':'          %6 = h(%5, %5)','line_number':280,'multiline':False]
['text':' XXX: does not check scoping legality, consider using','line_number':281,'multiline':False]
['text':' replaceAllUsesDominatedByNodeWith','line_number':282,'multiline':False]
['text':' Replaces all uses of this value with 'newValue' that are dominated by','line_number':285,'multiline':False]
['text':' 'node'. Given:','line_number':286,'multiline':False]
['text':' x = op(...).','line_number':287,'multiline':False]
['text':' if cond:','line_number':288,'multiline':False]
['text':'    z = foo(..)','line_number':289,'multiline':False]
['text':'    bar(x)','line_number':290,'multiline':False]
['text':' else:','line_number':291,'multiline':False]
['text':'    print(x)','line_number':292,'multiline':False]
['text':' x.replaceAllUsesDominatedByNodeWith(foo, z) would replace bar(x)','line_number':293,'multiline':False]
['text':' but not print(x) because print is not dominated by foo.','line_number':294,'multiline':False]
['text':' replaceAllUsesAfterNode does not check domination, so in this example','line_number':295,'multiline':False]
['text':' it would produce invalid IR.','line_number':296,'multiline':False]
['text':' subblocks','line_number':331,'multiline':False]
['text':' Assumes FunctionSchemas are persistent, so we don't manage their lifetime.','line_number':338,'multiline':False]
['text':' This field is effective a cache that's populated on attribute lookups and','line_number':339,'multiline':False]
['text':' invalidated every time we perform an operation that could potentially','line_number':340,'multiline':False]
['text':' change the schema. note: mutable because schema_ is effectively a cache','line_number':341,'multiline':False]
['text':' a managing wrapper for Python to allow invalidation','line_number':344,'multiline':False]
['text':' Stores the full schema name, if the operator is historic','line_number':346,'multiline':False]
['text':' When the operator is deprecated or the name of the operator','line_number':347,'multiline':False]
['text':' is changed, we need to rely on this name','line_number':348,'multiline':False]
['text':' to retrieve old schemas to successfully apply upgraders','line_number':349,'multiline':False]
['text':' for this operator.','line_number':350,'multiline':False]
['text':' defined after graph','line_number':354,'multiline':False]
['text':' Each Node but Return/Param Nodes are associated with exactly one','line_number':356,'multiline':False]
['text':' place in the Node list of the Graph. The Graph itself is a circular','line_number':357,'multiline':False]
['text':' doubly-linked list. The Return Node is used as the sentinel for the','line_number':358,'multiline':False]
['text':' "beginning"/"end" of the list. This means that you can tell when','line_number':359,'multiline':False]
['text':' you've traversed the entire list without means worrying about null','line_number':360,'multiline':False]
['text':' pointers. `next_in_graph[0]` is the pointer to the next Node, while','line_number':361,'multiline':False]
['text':' `next_in_graph[1]` is the pointer to the previous Node. The','line_number':362,'multiline':False]
['text':' linked list is implemented as an array to allow the same iterator','line_number':363,'multiline':False]
['text':' class for forward and reversed Node lists. Taken together, this','line_number':364,'multiline':False]
['text':' list also represents a topological sort of the Nodes in the Graph.','line_number':365,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,cppcoreguidelines-non-private-member-variables-in-classes,modernize-avoid-c-arrays)','line_number':366,'multiline':False]
['text':'*
   * @warning NEVER pass raw pointer of smart pointer managed Graph to Python.
   * Check #87343 for details.
   ','line_number':406,'multiline':True]
['text':' Copies the source range, scope and callstack from another node.','line_number':435,'multiline':False]
['text':' NB: This returns an ArrayRef; that means that it will','line_number':452,'multiline':False]
['text':' get invalidated if you resize inputs (e.g., using addInput)','line_number':453,'multiline':False]
['text':' We can't return a std::vector<Node*>& because there's no','line_number':454,'multiline':False]
['text':' way to soundly cast to std::vector<const Node*> (an insane','line_number':455,'multiline':False]
['text':' implementation of std::vector could make this representationally','line_number':456,'multiline':False]
['text':' different.)','line_number':457,'multiline':False]
['text':' Vectors are not convertible in const-ness of elements, but','line_number':462,'multiline':False]
['text':' raw pointers are.','line_number':463,'multiline':False]
['text':' NB: This returns an ArrayRef; that means that it will','line_number':466,'multiline':False]
['text':' get invalidated if you resize inputs (e.g., using addInput)','line_number':467,'multiline':False]
['text':' We can't return a std::vector<Node*>& because there's no','line_number':468,'multiline':False]
['text':' way to soundly cast to std::vector<const Node*> (an insane','line_number':469,'multiline':False]
['text':' implementation of std::vector could make this representationally','line_number':470,'multiline':False]
['text':' different.)','line_number':471,'multiline':False]
['text':' Vectors are not convertible in const-ness of elements, but','line_number':476,'multiline':False]
['text':' raw pointers are.','line_number':477,'multiline':False]
['text':' replaces `this` with a new node with the same inputs and outputs','line_number':494,'multiline':False]
['text':' but a new node symbol. does not destroy `this`','line_number':495,'multiline':False]
['text':' Checks if this node is dominated by `dominator` which means that','line_number':498,'multiline':False]
['text':' `dominator` will always be executed before `this` and `dominator`','line_number':499,'multiline':False]
['text':' is in scope of `this.','line_number':500,'multiline':False]
['text':' lots of things like chunk have a single input or single output, so we have','line_number':503,'multiline':False]
['text':' a helper to make accessing it easier','line_number':504,'multiline':False]
['text':' Access a particular input.  This is a checked index.','line_number':521,'multiline':False]
['text':' Returns true if the value of input name is statically known','line_number':540,'multiline':False]
['text':' instructions lowered by the interpreter and not run in the optimized graph','line_number':549,'multiline':False]
['text':' Graphs','line_number':555,'multiline':False]
['text':' Note [Topological invariant]','line_number':557,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':558,'multiline':False]
['text':' We always maintain an up-to-date topological ordering of all nodes via','line_number':559,'multiline':False]
['text':' the next()/prev() links.  All transformations to graphs must preserve','line_number':560,'multiline':False]
['text':' this topological ordering: for example, it is only valid to 'addInput'','line_number':561,'multiline':False]
['text':' with an input which is topologically before the current node.','line_number':562,'multiline':False]
['text':'','line_number':563,'multiline':False]
['text':' Usually, it is obvious whether or not topological order is maintained;','line_number':564,'multiline':False]
['text':' for example, if you are adding nodes to the end of the topsort, it's','line_number':565,'multiline':False]
['text':' impossible for them to refer to inputs that are not in the topsort.','line_number':566,'multiline':False]
['text':' If it is not obvious, please comment accordingly.','line_number':567,'multiline':False]
['text':' Add 'node' as an input to 'this' at the end of existing','line_number':569,'multiline':False]
['text':' arguments.  Returns the added node for ease of chaining.','line_number':570,'multiline':False]
['text':'','line_number':571,'multiline':False]
['text':' Given:   %3 = f(%1, %2)','line_number':572,'multiline':False]
['text':' Execute: %3.addInput(%4)','line_number':573,'multiline':False]
['text':' Result:  %3 = f(%1, %2, %4)','line_number':574,'multiline':False]
['text':' Add 'value' as an input to 'this' at the specified position in the','line_number':577,'multiline':False]
['text':' arguments. Returns the added value for ease of chaining.','line_number':578,'multiline':False]
['text':' Replace the input of 'this' at position 'i' with','line_number':581,'multiline':False]
['text':' 'newValue', returning the old node.','line_number':582,'multiline':False]
['text':'','line_number':583,'multiline':False]
['text':' Given:   %3 = f(%1, %2)','line_number':584,'multiline':False]
['text':' Execute: %3.replaceInput(1, %4)','line_number':585,'multiline':False]
['text':' Result:  %3 = f(%1, %4)','line_number':586,'multiline':False]
['text':' Replace all occurrences of 'from' in the inputs of this','line_number':589,'multiline':False]
['text':' node with 'to'. Corresponds to llvm's replaceUsesOfWith.','line_number':590,'multiline':False]
['text':'','line_number':591,'multiline':False]
['text':' Given:   %3 = f(%1, %2, %1)','line_number':592,'multiline':False]
['text':' Execute: %3.replaceInputWith(%1, %4)','line_number':593,'multiline':False]
['text':' Result:  %3 = f(%4, %2, %4)','line_number':594,'multiline':False]
['text':' Each Node can have a list of subblocks. These are used to define structured','line_number':606,'multiline':False]
['text':' nested control flow operators such as If and Loop.','line_number':607,'multiline':False]
['text':' The meaning of a block is specific to the kind of node it is in, but','line_number':608,'multiline':False]
['text':' all blocks share these semantics:','line_number':609,'multiline':False]
['text':' * Nested lexical scoping: If a node 'Parent' has a subblock which contains','line_number':610,'multiline':False]
['text':'   a node 'Child', Child can use any value that was in scope for the Parent','line_number':611,'multiline':False]
['text':'   node in addition to any values defined before 'Child' in the subblock.','line_number':612,'multiline':False]
['text':' * The list of inputs to the block are in scope for the duration of the','line_number':613,'multiline':False]
['text':'   block','line_number':614,'multiline':False]
['text':' * the outputs of the Parent node are not in scope for the subblocks','line_number':615,'multiline':False]
['text':' Typically the inputs to a block that represents control flow act as','line_number':616,'multiline':False]
['text':' as the equivalents phi-nodes in standard SSA form,','line_number':617,'multiline':False]
['text':' defining a new Value to represent any term that has multiple','line_number':618,'multiline':False]
['text':' definitions depending on how control flowed. Outputs of the node containing','line_number':619,'multiline':False]
['text':' control flow serve a similiar purpose defining new values for variables','line_number':620,'multiline':False]
['text':' that would have different definitions depending on which way control','line_number':621,'multiline':False]
['text':' flowed.','line_number':622,'multiline':False]
['text':' Vectors are not convertible in const-ness of elements, but','line_number':628,'multiline':False]
['text':' raw pointers are.','line_number':629,'multiline':False]
['text':' Is 'this' before 'n' in the topological order?','line_number':633,'multiline':False]
['text':' Is 'this' after 'n' in the topological order?','line_number':636,'multiline':False]
['text':' Insert unattached 'this' node before 'n' in the topological order.','line_number':639,'multiline':False]
['text':' Returns this (for chaining).','line_number':640,'multiline':False]
['text':'','line_number':641,'multiline':False]
['text':' Given:   %3 = f(%1, %2)','line_number':642,'multiline':False]
['text':'          %4 = g(%3)','line_number':643,'multiline':False]
['text':' and unattached: %5 = h(%1)','line_number':644,'multiline':False]
['text':' Execute: %5.insertBefore(%4)','line_number':645,'multiline':False]
['text':' Result:  %3 = f(%1, %2)','line_number':646,'multiline':False]
['text':'          %5 = h(%1)','line_number':647,'multiline':False]
['text':'          %4 = g(%3)','line_number':648,'multiline':False]
['text':' Insert unattached 'this' node after 'n' in the topological order.','line_number':651,'multiline':False]
['text':' Returns this (for chaining).','line_number':652,'multiline':False]
['text':'','line_number':653,'multiline':False]
['text':' Given: %3 = f(%1, %2)','line_number':654,'multiline':False]
['text':'        %4 = g(%3)','line_number':655,'multiline':False]
['text':' and unattached: %5 = h(%1)','line_number':656,'multiline':False]
['text':' Execute: %5.insertAfter(%4)','line_number':657,'multiline':False]
['text':' Result:  %3 = f(%1, %2)','line_number':658,'multiline':False]
['text':'          %4 = g(%3)','line_number':659,'multiline':False]
['text':'          %5 = h(%1)','line_number':660,'multiline':False]
['text':' Move 'this' (already in the graph) after 'n' in the topological order.','line_number':663,'multiline':False]
['text':'','line_number':664,'multiline':False]
['text':' NOTE: Does not check that value dependencies are preserved, see','line_number':665,'multiline':False]
['text':'   AliasDb::moveAfterTopologicallyValid','line_number':666,'multiline':False]
['text':'','line_number':667,'multiline':False]
['text':' Given: %2 = f(%1)','line_number':668,'multiline':False]
['text':'        %3 = g(%1)','line_number':669,'multiline':False]
['text':' Execute: %2.moveAfter(%3)','line_number':670,'multiline':False]
['text':' Result: %3 = g(%1)','line_number':671,'multiline':False]
['text':'         %2 = f(%1)','line_number':672,'multiline':False]
['text':'','line_number':673,'multiline':False]
['text':' Move a node 'n' (already in the graph) before 'this' in the topological','line_number':676,'multiline':False]
['text':' order.','line_number':677,'multiline':False]
['text':'','line_number':678,'multiline':False]
['text':' NOTE: Does not check that value dependencies are preserved, see','line_number':679,'multiline':False]
['text':'   AliasDb::moveBeforeTopologicallyValid','line_number':680,'multiline':False]
['text':'','line_number':681,'multiline':False]
['text':' Given: %2 = f(%1)','line_number':682,'multiline':False]
['text':'        %3 = g(%1)','line_number':683,'multiline':False]
['text':' Execute: %3.moveBefore(%2)','line_number':684,'multiline':False]
['text':' Result: %3 = g(%1)','line_number':685,'multiline':False]
['text':'         %2 = f(%1)','line_number':686,'multiline':False]
['text':' Remove the input at 'i' from this node.','line_number':689,'multiline':False]
['text':'','line_number':690,'multiline':False]
['text':' WARNING: This is O(n) in the number of inputs, so avoid repeatedly calling','line_number':691,'multiline':False]
['text':' removeInput.','line_number':692,'multiline':False]
['text':'','line_number':693,'multiline':False]
['text':' Given: %3 = f(%1, %2)','line_number':694,'multiline':False]
['text':' Execute: %3.removeInput(1)','line_number':695,'multiline':False]
['text':' Result: %3 = f(%1)','line_number':696,'multiline':False]
['text':' Remove all inputs from a node.','line_number':699,'multiline':False]
['text':'','line_number':700,'multiline':False]
['text':' Given: %3 = f(%1, %2)','line_number':701,'multiline':False]
['text':' Execute: %3.removeAllInputs()','line_number':702,'multiline':False]
['text':' Result: %3 = f()','line_number':703,'multiline':False]
['text':' Remove all outputs from a node.','line_number':706,'multiline':False]
['text':'','line_number':707,'multiline':False]
['text':' Given: %1, %2 = f()','line_number':708,'multiline':False]
['text':' Execute:removeAllInputs()','line_number':709,'multiline':False]
['text':' Result: = f()','line_number':710,'multiline':False]
['text':' Rearrange the ordering of inputs or outputs of a node','line_number':713,'multiline':False]
['text':' Given: %3 = f(%1, %2)','line_number':714,'multiline':False]
['text':' Execute: %3.permuteInputs({1, 0})','line_number':715,'multiline':False]
['text':' Result: %3 = f(%2, %1)','line_number':716,'multiline':False]
['text':' Each index must appear exactly once','line_number':717,'multiline':False]
['text':' iterators of the node list starting at this node','line_number':721,'multiline':False]
['text':' useful for resuming a search starting at this node','line_number':722,'multiline':False]
['text':' Remove 'this' from the instruction list and deallocate it.','line_number':736,'multiline':False]
['text':'','line_number':737,'multiline':False]
['text':' Invariant: no outputs of 'this' may have any uses.','line_number':738,'multiline':False]
['text':'','line_number':739,'multiline':False]
['text':' Given: %2 = f(%1)','line_number':740,'multiline':False]
['text':'        %3 = g(%1)','line_number':741,'multiline':False]
['text':' Execute: %2.destroy()','line_number':742,'multiline':False]
['text':' Result: %3 = g(%1)','line_number':743,'multiline':False]
['text':' Dynamically cast this node to the subclass indicated by the','line_number':746,'multiline':False]
['text':' template variable, returning nullptr if the cast is invalid..','line_number':747,'multiline':False]
['text':'','line_number':748,'multiline':False]
['text':' Example usage: if(auto s = n.cast<Select>()) { ... }','line_number':749,'multiline':False]
['text':' XXX: this function is meant to be used with string literals only!','line_number':778,'multiline':False]
['text':' Methods for accessing attributes','line_number':822,'multiline':False]
['text':' The names are returned in order, since name actually is the index.','line_number':858,'multiline':False]
['text':' Our Graphs are not very const-correct, so we need to allow returning','line_number':901,'multiline':False]
['text':' non-const references too','line_number':902,'multiline':False]
['text':' does not use CREATE_ACCESSOR because we need additional asserts','line_number':907,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-branch-clone)','line_number':937,'multiline':False]
['text':' NB: For determinism, we use a vector rather than a hash map.  This does','line_number':956,'multiline':False]
['text':' mean that lookups are O(n), so you shouldn't use Attributes to store','line_number':957,'multiline':False]
['text':' a big pile of messages.','line_number':958,'multiline':False]
['text':' Lookup iterator in use list of _input i_ that corresponds to its use of','line_number':988,'multiline':False]
['text':' _this_','line_number':989,'multiline':False]
['text':' remove the use of input i, this sets input i to nullptr, but','line_number':992,'multiline':False]
['text':' is only used internally to Node before setting it to a new value','line_number':993,'multiline':False]
['text':' or erasing the entry from the list.','line_number':994,'multiline':False]
['text':' subclasses must override','line_number':1010,'multiline':False]
['text':' this function is used by createClone to initialize a new version','line_number':1011,'multiline':False]
['text':' of a node in another graph. It should allocate a new instance of the same','line_number':1012,'multiline':False]
['text':' concrete type as 'this', but in graph 'g' which might be different','line_number':1013,'multiline':False]
['text':' than graph_','line_number':1014,'multiline':False]
['text':' create a copy of all properties of Node s into this.','line_number':1018,'multiline':False]
['text':' subclasses should extend if they have additional information to copy.','line_number':1019,'multiline':False]
['text':' 'this' will be allocated with s->allocNewInstance(g) so it should have','line_number':1020,'multiline':False]
['text':' the same concrete type as 's'','line_number':1021,'multiline':False]
['text':'*
   * @warning NEVER pass raw pointer of smart pointer managed Graph to Python.
   * Check #87343 for details.
   ','line_number':1063,'multiline':True]
['text':' clone all inputs, nodes, and outputs from src and append them','line_number':1132,'multiline':False]
['text':' to the inputs, nodes, and outputs of this block','line_number':1133,'multiline':False]
['text':' value_map is used whenever a node in src references a free variable','line_number':1134,'multiline':False]
['text':' in src to look up its corresponding value','line_number':1135,'multiline':False]
['text':' get rid of all nodes','line_number':1163,'multiline':False]
['text':' destroys in reverse order so that uses internal to this block','line_number':1164,'multiline':False]
['text':' do not have to be removed before you can destroy the block','line_number':1165,'multiline':False]
['text':' holds outputs in a way that can be reflected','line_number':1169,'multiline':False]
['text':' as a Use object','line_number':1170,'multiline':False]
['text':' also used as the beginning/end of the circular node list to avoid','line_number':1171,'multiline':False]
['text':' having corner cases where the list is empty.','line_number':1172,'multiline':False]
['text':' either the node that has this block or nullptr for root','line_number':1176,'multiline':False]
['text':' a managing wrapper for Python to allow invalidation','line_number':1177,'multiline':False]
['text':' only used to keep track of allocated nodes','line_number':1188,'multiline':False]
['text':' actual representation of Graph is done with','line_number':1189,'multiline':False]
['text':' inputs, outputs, nodes','line_number':1190,'multiline':False]
['text':' name_base_suffix tracks largest suffix currently used by all names sharing','line_number':1198,'multiline':False]
['text':' same name_base. Key of this map is name_base, value is largest suffix','line_number':1199,'multiline':False]
['text':' numeric value.','line_number':1200,'multiline':False]
['text':' when insertNode() is called, the node is inserted before this node','line_number':1206,'multiline':False]
['text':' by default this is set to append to the top level block','line_number':1207,'multiline':False]
['text':' Insert a ToList operator with argument \p v and output type \p type.','line_number':1343,'multiline':False]
['text':' \returns the output of the operation.','line_number':1344,'multiline':False]
['text':' Note: defined in python_ir.cpp and can be used only in python extension','line_number':1354,'multiline':False]
['text':' clone n, making a new node in _this_ graph.','line_number':1359,'multiline':False]
['text':' use value_map to translate inputs of n to inputs of the cloned node','line_number':1360,'multiline':False]
['text':' if copy_blocks is false, it will not recursively clone the nested blocks','line_number':1361,'multiline':False]
['text':' this node contains.','line_number':1362,'multiline':False]
['text':' Insert constant IValue into the graph.','line_number':1368,'multiline':False]
['text':' Schema-driven insert:','line_number':1374,'multiline':False]
['text':' This inserts a node into the graph with inputs determined from args and','line_number':1375,'multiline':False]
['text':' kwargs using Python argument matching rules, and checks that the op matches','line_number':1376,'multiline':False]
['text':' a known schema.','line_number':1377,'multiline':False]
['text':'','line_number':1378,'multiline':False]
['text':' If this node successfully completes, it guarentees the node','line_number':1379,'multiline':False]
['text':' is a correctly-formed invocation of opname','line_number':1380,'multiline':False]
['text':' insert before insert_before_ node','line_number':1395,'multiline':False]
['text':' initialized to insert at the end of the top level block','line_number':1396,'multiline':False]
['text':' can be changed with setInsertPoint()','line_number':1397,'multiline':False]
['text':' set where nodes are inserted to append to the end of this block','line_number':1404,'multiline':False]
['text':' set where nodes are inserted to insert _before_ this node','line_number':1409,'multiline':False]
['text':' for implementation simplicity we only support inserting before a node for','line_number':1410,'multiline':False]
['text':' now','line_number':1411,'multiline':False]
['text':' the top level block','line_number':1421,'multiline':False]
['text':' Checks well-formedness and invariants of graph','line_number':1429,'multiline':False]
['text':' for use in debugger','line_number':1431,'multiline':False]
['text':'* \brief An utility class for setting temporary insertion points.
 *
 * When an object of this class is created, it stores the current insertion
 * point, sets the new one, and restores the original insertion point when the
 * object is destroyed.
 ','line_number':1456,'multiline':True]
['text':'* \brief An utility class for setting temporary scopes.
 *
 * When an object of this class is created, it stores the current scope, sets
 * the new one, and restores the original scope when the object is destroyed.
 ','line_number':1476,'multiline':True]
['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':1495,'multiline':False]
['text':'************ All nodes not required to be defined before Graph *************','line_number':1524,'multiline':True]
['text':' execute a Python function, used for Ops we can't optimize but that we want to','line_number':1577,'multiline':False]
['text':' optimize around','line_number':1578,'multiline':False]
['text':'','line_number':1579,'multiline':False]
['text':' Note: actual implementation (ConcretePythonOp) is defined in python_ir.cpp','line_number':1580,'multiline':False]
['text':' which is not included in libtorch.so. We still include some bits and pieces','line_number':1581,'multiline':False]
['text':' of PythonOp here to enable writing simple passes generically. In general,','line_number':1582,'multiline':False]
['text':' python-aware bits need to be moved to the descendant classes.','line_number':1583,'multiline':False]
['text':' recover the autograd.Function instance, if this PythonOp's function','line_number':1591,'multiline':False]
['text':' was originally SomeFunction.apply','line_number':1592,'multiline':False]
['text':' used in ONNX for discovering symbolics','line_number':1593,'multiline':False]
['text':'* Insert graph \p CALLEE into graph \p G using \p INPUTS as input values.
 * The insertion happens at the current insertion point.
 * Optionally, one can also pass \p VALUE_MAP to get a map between \p CALLEE
 * values and their cloned copies in \p G.
 ','line_number':1603,'multiline':True]
['text':'* Insert function \p CALLEE after node \p TO_REPLACE, remove the node and
 * replace all its uses with corresponding outputs of the inserted function.
 * This asserts that the number of outputs of the original node and the
 * graph are the same.
 ','line_number':1618,'multiline':True]
['text':'* If there is only one value in \p OUTPUTS and its kind is Tuple, insert a
 * tuple unpack node and return the resulting values.
 ','line_number':1633,'multiline':True]
['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':1656,'multiline':False]
['text':' Type aliasing','line_number':1658,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':1664,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':1669,'multiline':False]
['text':' Remove if exists before insert','line_number':1675,'multiline':False]
['text':' TODO: return iterator','line_number':1746,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1748,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':1765,'multiline':False]
['text':' Type aliasing','line_number':1767,'multiline':False]
['text':' Remove if exists before insert','line_number':1774,'multiline':False]
['text':' TODO: return iterator','line_number':1822,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1824,'multiline':False]
['text':' namespace jit','line_number':1840,'multiline':False]
['text':' namespace torch','line_number':1841,'multiline':False]
