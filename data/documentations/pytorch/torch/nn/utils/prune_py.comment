['text':' to carry out the multiplication, the mask needs to have been computed,','line_number':65,'multiline':False]
['text':' so the pruning method must know what tensor it's operating on','line_number':66,'multiline':False]
['text':' this gets set in apply()','line_number':67,'multiline':False]
['text':' Check if a pruning method has already been applied to','line_number':97,'multiline':False]
['text':' `module[name]`. If so, store that in `old_method`.','line_number':98,'multiline':False]
['text':' there should technically be only 1 hook with hook.name == name','line_number':101,'multiline':False]
['text':' assert this using `found`','line_number':102,'multiline':False]
['text':' if it exists, take existing thing, remove hook, then','line_number':105,'multiline':False]
['text':' go through normal thing','line_number':106,'multiline':False]
['text':' Apply the new pruning method, either from scratch or on top of','line_number':119,'multiline':False]
['text':' the previous one.','line_number':120,'multiline':False]
['text':' new pruning','line_number':121,'multiline':False]
['text':' Have the pruning method remember what tensor it's been applied to','line_number':122,'multiline':False]
['text':' combine `methods` with `old_method`, if `old_method` exists','line_number':125,'multiline':False]
['text':' meaning that there was a hook','line_number':126,'multiline':False]
['text':' if the hook is already a pruning container, just add the','line_number':127,'multiline':False]
['text':' new pruning method to the container','line_number':128,'multiline':False]
['text':' rename old_method --> method','line_number':131,'multiline':False]
['text':' if the hook is simply a single pruning method, create a','line_number':133,'multiline':False]
['text':' container, add the old pruning method and the new one','line_number':134,'multiline':False]
['text':' Have the pruning method remember the name of its tensor','line_number':137,'multiline':False]
['text':' setattr(container, '_tensor_name', name)','line_number':138,'multiline':False]
['text':' rename container --> method','line_number':140,'multiline':False]
['text':' at this point we have no forward_pre_hooks but we could have an','line_number':144,'multiline':False]
['text':' active reparametrization of the tensor if another pruning method','line_number':145,'multiline':False]
['text':' had been applied (in which case `method` would be a PruningContainer','line_number':146,'multiline':False]
['text':' and not a simple pruning method).','line_number':147,'multiline':False]
['text':' Pruning is to be applied to the module's tensor named `name`,','line_number':149,'multiline':False]
['text':' starting from the state it is found in prior to this iteration of','line_number':150,'multiline':False]
['text':' pruning. The pruning mask is calculated based on importances scores.','line_number':151,'multiline':False]
['text':' If this is the first time pruning is applied, take care of moving','line_number':161,'multiline':False]
['text':' the original tensor to a new parameter called name + '_orig' and','line_number':162,'multiline':False]
['text':' and deleting the original parameter','line_number':163,'multiline':False]
['text':' copy `module[name]` to `module[name + '_orig']`','line_number':165,'multiline':False]
['text':' temporarily delete `module[name]`','line_number':167,'multiline':False]
['text':' temp','line_number':169,'multiline':False]
['text':' If this is not the first time pruning is applied, all of the above','line_number':170,'multiline':False]
['text':' has been done before in a previous pruning iteration, so we're good','line_number':171,'multiline':False]
['text':' to go','line_number':172,'multiline':False]
['text':' Use try/except because if anything goes wrong with the mask','line_number':180,'multiline':False]
['text':' computation etc., you'd want to roll back.','line_number':181,'multiline':False]
['text':' get the final mask, computed according to the specific method','line_number':183,'multiline':False]
['text':' reparameterize by saving mask to `module[name + '_mask']`...','line_number':185,'multiline':False]
['text':' ... and the new pruned tensor to `module[name]`','line_number':187,'multiline':False]
['text':' associate the pruning method to the module via a hook to','line_number':189,'multiline':False]
['text':' compute the function before every forward() (compile by run)','line_number':190,'multiline':False]
['text':' before removing pruning from a tensor, it has to have been applied','line_number':242,'multiline':False]
['text':' this gets set in apply()','line_number':245,'multiline':False]
['text':' to update module[name] to latest trained weights','line_number':247,'multiline':False]
['text':' masked weights','line_number':248,'multiline':False]
['text':' delete and reset','line_number':250,'multiline':False]
['text':' only 1 item','line_number':272,'multiline':False]
['text':' only 1 item in a tuple','line_number':275,'multiline':False]
['text':' manual construction from list or other iterable (or no args)','line_number':278,'multiline':False]
['text':' check that we're adding a pruning method to the container','line_number':289,'multiline':False]
['text':' if all checks passed, add to _pruning_methods tuple','line_number':300,'multiline':False]
['text':' type: ignore[operator]','line_number':301,'multiline':False]
['text':' start off from existing mask','line_number':355,'multiline':False]
['text':' compute a slice of t onto which the new pruning method will operate','line_number':358,'multiline':False]
['text':' prune entries of t where the mask is 1','line_number':360,'multiline':False]
['text':' for struct pruning, exclude channels that have already been','line_number':363,'multiline':False]
['text':' entirely pruned','line_number':364,'multiline':False]
['text':' find the channels to keep by removing the ones that have been','line_number':372,'multiline':False]
['text':' zeroed out already (i.e. where sum(entries) == 0)','line_number':373,'multiline':False]
['text':' "is this a 2D tensor? 3D? ..."','line_number':374,'multiline':False]
['text':' convert negative indexing','line_number':376,'multiline':False]
['text':' if dim is still negative after subtracting it from n_dims','line_number':379,'multiline':False]
['text':' find channels along dim = dim that aren't already tots 0ed out','line_number':384,'multiline':False]
['text':' create slice to identify what to prune','line_number':386,'multiline':False]
['text':' "is this a 2D tensor? 3D? ..."','line_number':391,'multiline':False]
['text':' compute the new mask on the unpruned slice of the tensor t','line_number':399,'multiline':False]
['text':' Check range of validity of pruning amount','line_number':450,'multiline':False]
['text':' Check that the amount of units to prune is not > than the number of','line_number':455,'multiline':False]
['text':' parameters in t','line_number':456,'multiline':False]
['text':' Compute number of units to prune: amount if int,','line_number':458,'multiline':False]
['text':' else amount * tensor_size','line_number':459,'multiline':False]
['text':' This should raise an error if the number of units to prune is larger','line_number':461,'multiline':False]
['text':' than the number of units in the tensor','line_number':462,'multiline':False]
['text':' k=0 not supported by torch.kthvalue','line_number':467,'multiline':False]
['text':' Check range of validity of pruning amount','line_number':507,'multiline':False]
['text':' Check that the amount of units to prune is not > than the number of','line_number':512,'multiline':False]
['text':' parameters in t','line_number':513,'multiline':False]
['text':' Compute number of units to prune: amount if int,','line_number':515,'multiline':False]
['text':' else amount * tensor_size','line_number':516,'multiline':False]
['text':' This should raise an error if the number of units to prune is larger','line_number':518,'multiline':False]
['text':' than the number of units in the tensor','line_number':519,'multiline':False]
['text':' k=0 not supported by torch.kthvalue','line_number':524,'multiline':False]
['text':' largest=True --> top k; largest=False --> bottom k','line_number':525,'multiline':False]
['text':' Prune the smallest k','line_number':526,'multiline':False]
['text':' topk will have .indices and .values','line_number':528,'multiline':False]
['text':' Check range of validity of amount','line_number':575,'multiline':False]
['text':' Check that tensor has structure (i.e. more than 1 dimension) such','line_number':600,'multiline':False]
['text':' that the concept of "channels" makes sense','line_number':601,'multiline':False]
['text':' Check that self.dim is a valid dim to index t, else raise IndexError','line_number':604,'multiline':False]
['text':' Check that the amount of channels to prune is not > than the number of','line_number':607,'multiline':False]
['text':' channels in t along the dim to prune','line_number':608,'multiline':False]
['text':' Compute number of units to prune: amount if int,','line_number':610,'multiline':False]
['text':' else amount * tensor_size','line_number':611,'multiline':False]
['text':' This should raise an error if the number of units to prune is larger','line_number':613,'multiline':False]
['text':' than the number of units in the tensor','line_number':614,'multiline':False]
['text':' Compute binary mask by initializing it to all 0s and then filling in','line_number':617,'multiline':False]
['text':' 1s wherever topk.indices indicates, along self.dim.','line_number':618,'multiline':False]
['text':' mask has the same shape as tensor t','line_number':619,'multiline':False]
['text':' generate a random number in [0, 1] to associate to each channel','line_number':621,'multiline':False]
['text':' generate mask for each channel by 0ing out the channels that','line_number':623,'multiline':False]
['text':' got assigned the k = nchannels_toprune lowest values in prob','line_number':624,'multiline':False]
['text':' k=0 not supported by torch.kthvalue','line_number':634,'multiline':False]
['text':' apply the new structured mask on top of prior (potentially','line_number':637,'multiline':False]
['text':' unstructured) mask','line_number':638,'multiline':False]
['text':' Check range of validity of amount','line_number':682,'multiline':False]
['text':' Check that tensor has structure (i.e. more than 1 dimension) such','line_number':708,'multiline':False]
['text':' that the concept of "channels" makes sense','line_number':709,'multiline':False]
['text':' Check that self.dim is a valid dim to index t, else raise IndexError','line_number':711,'multiline':False]
['text':' Check that the amount of channels to prune is not > than the number of','line_number':714,'multiline':False]
['text':' channels in t along the dim to prune','line_number':715,'multiline':False]
['text':' Compute number of units to prune: amount if int,','line_number':717,'multiline':False]
['text':' else amount * tensor_size','line_number':718,'multiline':False]
['text':' This should raise an error if the number of units to prune is larger','line_number':721,'multiline':False]
['text':' than the number of units in the tensor','line_number':722,'multiline':False]
['text':' Structured pruning prunes entire channels so we need to know the','line_number':725,'multiline':False]
['text':' L_n norm along each channel to then find the topk based on this','line_number':726,'multiline':False]
['text':' metric','line_number':727,'multiline':False]
['text':' largest=True --> top k; largest=False --> bottom k','line_number':729,'multiline':False]
['text':' Keep the largest k channels along dim=self.dim','line_number':730,'multiline':False]
['text':' topk will have .indices and .values','line_number':732,'multiline':False]
['text':' Compute binary mask by initializing it to all 0s and then filling in','line_number':734,'multiline':False]
['text':' 1s wherever topk.indices indicates, along self.dim.','line_number':735,'multiline':False]
['text':' mask has the same shape as tensor t','line_number':736,'multiline':False]
['text':' init mask to 0','line_number':738,'multiline':False]
['text':' e.g.: slc = [None, None, None], if len(t.shape) = 3','line_number':740,'multiline':False]
['text':' replace a None at position=dim with indices','line_number':742,'multiline':False]
['text':' e.g.: slc = [None, None, [0, 2, 3]] if dim=2 & indices=[0,2,3]','line_number':743,'multiline':False]
['text':' use slc to slice mask and replace all its entries with 1s','line_number':745,'multiline':False]
['text':' e.g.: mask[:, :, [0, 2, 3]] = 1','line_number':746,'multiline':False]
['text':' k=0 not supported by torch.kthvalue','line_number':750,'multiline':False]
['text':' ensure parameters is a list or generator of tuples','line_number':1087,'multiline':False]
['text':' flatten importance scores to consider them all at once in global pruning','line_number':1095,'multiline':False]
['text':' similarly, flatten the masks (if they exist), or use a flattened vector','line_number':1102,'multiline':False]
['text':' of 1s of the same dimensions as t','line_number':1103,'multiline':False]
['text':' use the canonical pruning methods to compute the new mask, even if the','line_number':1111,'multiline':False]
['text':' parameter is now a flattened out version of `parameters`','line_number':1112,'multiline':False]
['text':' to make it match that of `method`','line_number':1114,'multiline':False]
['text':' to make it match that of `container`','line_number':1116,'multiline':False]
['text':' use the `compute_mask` method from `PruningContainer` to combine the','line_number':1125,'multiline':False]
['text':' mask computed by the new method with the pre-existing mask','line_number':1126,'multiline':False]
['text':' Pointer for slicing the mask to match the shape of each parameter','line_number':1129,'multiline':False]
['text':' The length of the parameter','line_number':1134,'multiline':False]
['text':' Slice the mask, reshape it','line_number':1136,'multiline':False]
['text':' Assign the correct pre-computed mask to each parameter and add it','line_number':1138,'multiline':False]
['text':' to the forward_pre_hooks like any other pruning method','line_number':1139,'multiline':False]
['text':' Increment the pointer to continue slicing the final_mask','line_number':1142,'multiline':False]
['text':' so it's a float','line_number':1262,'multiline':False]
['text':' TODO: consider removing this check and allowing users to specify','line_number':1284,'multiline':False]
['text':' a number of units to prune that is greater than the number of units','line_number':1285,'multiline':False]
['text':' left to prune. In this case, the tensor will just be fully pruned.','line_number':1286,'multiline':False]
['text':' incorrect type already checked in _validate_pruning_amount_init','line_number':1334,'multiline':False]
['text':' dims = all axes, except for the one identified by `dim`','line_number':1371,'multiline':False]
['text':' convert negative indexing','line_number':1373,'multiline':False]
