['text':' Check if type was created from collections.namedtuple or a typing.NamedTuple.','line_number':9,'multiline':False]
['text':' Check if type was created from collections.namedtuple or a typing.NamedTuple.','line_number':14,'multiline':False]
['text':' For some reason, 'scatter' returns a tuple when given a single Tensor input but a list otherwise.','line_number':22,'multiline':False]
['text':' After scatter_map is called, a scatter_map cell will exist. This cell','line_number':53,'multiline':False]
['text':' has a reference to the actual function scatter_map, which has references','line_number':54,'multiline':False]
['text':' to a closure that has a reference to the scatter_map cell (because the','line_number':55,'multiline':False]
['text':' fn is recursive). To avoid this reference cycle, we set the function to','line_number':56,'multiline':False]
['text':' None, clearing the cell','line_number':57,'multiline':False]
['text':' type: ignore[assignment]','line_number':61,'multiline':False]
['text':' Recursive function calls like this create reference cycles.','line_number':101,'multiline':False]
['text':' Setting the function to None clears the refcycle.','line_number':102,'multiline':False]
['text':' type: ignore[assignment]','line_number':106,'multiline':False]
