['text':' TODO(jansel): double check exception handling','line_number':11,'multiline':False]
['text':' change exception table entries if start/end instructions are dead','line_number':60,'multiline':False]
['text':' assumes that exception table entries have been propagated,','line_number':61,'multiline':False]
['text':' e.g. with bytecode_transformation.propagate_inst_exn_table_entries,','line_number':62,'multiline':False]
['text':' and that instructions with an exn_tab_entry lies within its start/end.','line_number':63,'multiline':False]
['text':' find leftmost live instruction >= start','line_number':68,'multiline':False]
['text':' find rightmost live instruction <= end','line_number':73,'multiline':False]
['text':' CALL_FINALLY in Python 3.8 is handled differently when determining stack depth.','line_number':216,'multiline':False]
['text':' See https://github.com/python/cpython/blob/3.8/Python/compile.c#L5450.','line_number':217,'multiline':False]
['text':' Essentially, the stack effect of CALL_FINALLY is computed with jump=True,','line_number':218,'multiline':False]
['text':' but the resulting stack depth is propagated to the next instruction, not the','line_number':219,'multiline':False]
['text':' jump target.','line_number':220,'multiline':False]
['text':' see https://github.com/python/cpython/blob/3.11/Objects/exception_handling_notes.txt','line_number':235,'multiline':False]
['text':' on why depth is computed this way.','line_number':236,'multiline':False]
