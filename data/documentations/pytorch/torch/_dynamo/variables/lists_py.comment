['text':' Most list-like variables implement comparison ops the same way,','line_number':154,'multiline':False]
['text':' so they can re-use this helper.','line_number':155,'multiline':False]
['text':' There are quirks though, like how `tuple([2]) == torch.Size([2])`,','line_number':156,'multiline':False]
['text':' but `tuple([2]) != list([2])`','line_number':157,'multiline':False]
['text':' Generic list comparison works by iterating over left aka self and right the compared-to list.','line_number':163,'multiline':False]
['text':' If we hit here, their lengths are the same and they cannot be expressed as python constants.','line_number':164,'multiline':False]
['text':' So, we iterate over the zipped list items.','line_number':165,'multiline':False]
['text':' early exit in false case','line_number':170,'multiline':False]
['text':' List copy() doesn't have args and kwargs','line_number':285,'multiline':False]
['text':' torch.Size needs special handling.  Normally, we pun a list-like','line_number':431,'multiline':False]
['text':' container to directly contain Proxy/Node objects from FX, and FX','line_number':432,'multiline':False]
['text':' knows to look inside containers (via map_aggregate).  But torch.Size','line_number':433,'multiline':False]
['text':' is weird; although it subclasses from tuple, it doesn't allow','line_number':434,'multiline':False]
['text':' members which aren't int-like (rejecting Proxy and Node).  This','line_number':435,'multiline':False]
['text':' means we can't use the normal representation trick','line_number':436,'multiline':False]
['text':' torch.Size([proxy0, proxy1]).  I looked into seeing if I could','line_number':437,'multiline':False]
['text':' relax torch.Size in PyTorch proper, but if torch.Size constructor','line_number':438,'multiline':False]
['text':' sees a type that it doesn't recognize, it will try to call','line_number':439,'multiline':False]
['text':' __index__() on it, so there is no BC way to actually change this','line_number':440,'multiline':False]
['text':' behavior (though it occurs to me that I could have just added a','line_number':441,'multiline':False]
['text':' YOLO no checking alternate constructor.)','line_number':442,'multiline':False]
['text':'','line_number':443,'multiline':False]
['text':' To work around this problem, I represent a torch.Size proxy as','line_number':444,'multiline':False]
['text':' a straight up proxy, that would have been constructed by taking','line_number':445,'multiline':False]
['text':' the constituent proxies as arguments.  This trick can be generally','line_number':446,'multiline':False]
['text':' used for any construct that we need a proxy for but we can't','line_number':447,'multiline':False]
['text':' directly represent as an aggregate; I don't see very many examples','line_number':448,'multiline':False]
['text':' of this in torchdynamo though!','line_number':449,'multiline':False]
['text':' Look for a proxy.  If there are none, do the legacy behavior','line_number':451,'multiline':False]
['text':' Delay proxy calls  until we know it will be necessary','line_number':494,'multiline':False]
['text':' Skip multiplying by 1','line_number':499,'multiline':False]
['text':' We need the unbounded cls method to avoid the inline __self__','line_number':564,'multiline':False]
['text':' Removing this check as it slows things down too much','line_number':634,'multiline':False]
['text':' https://github.com/pytorch/pytorch/pull/87533#issuecomment-1287574492','line_number':635,'multiline':False]
['text':' assert all(isinstance(x, VariableTracker) for x in items)','line_number':637,'multiline':False]
['text':' not subclass','line_number':728,'multiline':False]
['text':' inline the method','line_number':783,'multiline':False]
