['text':' TODO: there should be a more principled way of doing this.','line_number':32,'multiline':False]
['text':' Make sure the name present in the resulting AST will match the name','line_number':79,'multiline':False]
['text':' requested here. The only time they don't match is if you do something','line_number':80,'multiline':False]
['text':' like:','line_number':81,'multiline':False]
['text':'   def _forward(self):','line_number':82,'multiline':False]
['text':'       pass','line_number':83,'multiline':False]
['text':'   forward = _forward','line_number':84,'multiline':False]
['text':' In this case, the actual function object will have the name `_forward`,','line_number':85,'multiline':False]
['text':' even though we requested a stub for `forward`.','line_number':86,'multiline':False]
['text':' base types that can be constants','line_number':120,'multiline':False]
['text':' in addition, tuples and lists of these base types are also considered constants','line_number':121,'multiline':False]
['text':' If you edit this list, then you also need to edit the handlers in','line_number':122,'multiline':False]
['text':' ConstantValue in jit/script/init.cpp','line_number':123,'multiline':False]
['text':' In Python-3.10+ it is recommended to use inspect.get_annotations','line_number':163,'multiline':False]
['text':' See https://docs.python.org/3.10/howto/annotations.html','line_number':164,'multiline':False]
['text':' But also, in 3.10 annotations from base class are not inherited','line_number':165,'multiline':False]
['text':' by unannotated derived one, so they must be manually extracted','line_number':166,'multiline':False]
['text':' Get user-annotated ignored attributes.','line_number':206,'multiline':False]
['text':' try to infer the type from type annotation or from the object itself','line_number':213,'multiline':False]
['text':' The forward function from Module is special; never use this annotations; we','line_number':215,'multiline':False]
['text':' need to infer type directly using JIT.  I originally wanted to write','line_number':216,'multiline':False]
['text':' this test as isinstance(class_annotations[name], Callable) but','line_number':217,'multiline':False]
['text':' isinstance on typing things doesn't seem to work: isinstance(list, Callable)','line_number':218,'multiline':False]
['text':' is also true!','line_number':219,'multiline':False]
['text':' We currently have the invariant in various places in our code','line_number':250,'multiline':False]
['text':' that parameters must be Tensors. However, the nn.Module API also','line_number':251,'multiline':False]
['text':' allows NoneType parameters. These parameters are not returned as','line_number':252,'multiline':False]
['text':' part of `parameters()` and its variants, but are available','line_number':253,'multiline':False]
['text':' through direct attribute access.','line_number':254,'multiline':False]
['text':' Modules can be None. We don't have direct support for optional','line_number':273,'multiline':False]
['text':' Modules, so the register it as an NoneType attribute instead.','line_number':274,'multiline':False]
['text':' if the type can be inferred, it should be a module interface type','line_number':279,'multiline':False]
['text':' otherwise we get the concrete module type for item and add it to concrete_type','line_number':284,'multiline':False]
['text':' populate constants_set','line_number':290,'multiline':False]
['text':' Constants annotated via `Final[T]` rather than being added to `__constants__`','line_number':293,'multiline':False]
['text':' TODO: We should really error in this case, but its bc-breaking so','line_number':300,'multiline':False]
['text':' we need to warn for at least one release','line_number':301,'multiline':False]
['text':' TODO: We should really error in this case, but its bc-breaking so','line_number':319,'multiline':False]
['text':' we need to warn for at least one release','line_number':320,'multiline':False]
['text':' populate overloads','line_number':333,'multiline':False]
['text':' update with any annotated overloads','line_number':335,'multiline':False]
['text':' Python objects have lots of random attributes attached to them;','line_number':346,'multiline':False]
['text':' PyTorch adds a few more. Prevent these from getting compiled.','line_number':347,'multiline':False]
['text':' Don't re-add anything we already added','line_number':354,'multiline':False]
['text':' Handle Python function attributes','line_number':360,'multiline':False]
['text':' If we fail to script the function, it isn't a hard error.','line_number':368,'multiline':False]
['text':' Instead, we will add it to the list of attributes we failed','line_number':369,'multiline':False]
['text':' to convert, with the compilation error.','line_number':370,'multiline':False]
['text':' Handle calls to builtin functions (either bespoke builtins from torch.jit._builtins or','line_number':381,'multiline':False]
['text':' a call to an aten function like torch.add)','line_number':382,'multiline':False]
['text':' Handle Script function attributes','line_number':388,'multiline':False]
['text':' If we got here, this is a regular "data" attribute, add it to the concrete type','line_number':395,'multiline':False]
['text':' TODO: could add more detail here. For example, what the user should do','line_number':400,'multiline':False]
['text':' when the pytype is `list` or `NoneType`','line_number':401,'multiline':False]
['text':' add hooks to concrete type','line_number':415,'multiline':False]
['text':' Python module type => List[ConcreteModuleType)]','line_number':429,'multiline':False]
['text':' ConcreteTypes that have had their methods already compiled','line_number':431,'multiline':False]
['text':' Search the type store for an already-available JIT type','line_number':442,'multiline':False]
['text':' We didn't find anything; generate a new JIT type from this concrete type','line_number':448,'multiline':False]
['text':' Look into the store of cached JIT types','line_number':503,'multiline':False]
['text':' Get a concrete type directly, without trying to re-use an existing JIT','line_number':506,'multiline':False]
['text':' type from the type store.','line_number':507,'multiline':False]
['text':' Script the type of obj if it hasn't already been scripted.','line_number':524,'multiline':False]
['text':' Create an empty torch._C.ScriptObject with the scripted type.','line_number':527,'multiline':False]
['text':' Copy all of the attributes over to the torch._C.ScriptObject.','line_number':529,'multiline':False]
['text':' Wrap the torch._C.ScriptObject in a RecursiveScriptClass instance.','line_number':533,'multiline':False]
['text':' Initialize the ScriptModule:','line_number':581,'multiline':False]
['text':' 1. Copy the attributes/parameters/buffers from the original `nn_module` to the new ScriptModule.','line_number':582,'multiline':False]
['text':' 2. Copy the submodules from the original `nn_module` to the new ScriptModule,','line_number':592,'multiline':False]
['text':'    recursively scripting them.','line_number':593,'multiline':False]
['text':' use the interface inference rule to compile the module','line_number':601,'multiline':False]
['text':' always reuse the provided stubs_fn to infer the methods to compile','line_number':606,'multiline':False]
['text':' 3. Copy @ignored/@unused methods and attrs from the original `nn_module` to the new ScriptModule.','line_number':614,'multiline':False]
['text':'    This ensures we can access these Python methods on the ScriptModule.','line_number':615,'multiline':False]
['text':' For convenience, attach the concrete type to the new ScriptModule','line_number':627,'multiline':False]
['text':' Actually create the ScriptModule, initializing it with the function we just defined','line_number':630,'multiline':False]
['text':' Compile methods if necessary','line_number':633,'multiline':False]
['text':' Create hooks after methods to ensure no name collisions between hooks and methods.','line_number':638,'multiline':False]
['text':' If done before, hooks can overshadow methods that aren't exported.','line_number':639,'multiline':False]
['text':' Copy the forward hooks and pre-hooks to the new ScriptModule','line_number':644,'multiline':False]
['text':' to allow the hooks to be run from eager as ScriptFunctions','line_number':645,'multiline':False]
['text':' Special handling so methods like __len__ work in script methods on classes derived from containers','line_number':651,'multiline':False]
['text':' Make the compiled methods available to the Python ScriptModule class.','line_number':671,'multiline':False]
['text':' define()'d methods don't have an Python original_method, so we','line_number':674,'multiline':False]
['text':' don't need to do any Python re-wrapping stuff','line_number':675,'multiline':False]
['text':' TODO: Why skip this? Because @torch.jit._overload_method will','line_number':680,'multiline':False]
['text':' mangle the name of the function.','line_number':681,'multiline':False]
['text':' Wrap the original to propagate docstrings and such.','line_number':685,'multiline':False]
['text':' TODO: we don't currently do this functions that are recursively','line_number':686,'multiline':False]
['text':' compiled, we should.','line_number':687,'multiline':False]
['text':' Add the methods to the script_module directly. This ensures they will','line_number':692,'multiline':False]
['text':' be found first when `name` is looked up (as opposed to the stubs or','line_number':693,'multiline':False]
['text':' nn.Module.forward)','line_number':694,'multiline':False]
['text':' Make module properties available on the Python ScriptModule class.','line_number':697,'multiline':False]
['text':' Setter is optional, so it may not exist.','line_number':701,'multiline':False]
['text':' type: ignore[arg-type]','line_number':704,'multiline':False]
['text':' copy over python methods to script module if they aren't defined on the script module','line_number':706,'multiline':False]
['text':' this is currently an internal api used only on module containers','line_number':707,'multiline':False]
['text':' We define shims of certain attributes on the RecursiveScriptModule to support','line_number':721,'multiline':False]
['text':' magic methods. To check if a script model defines an attribute we need','line_number':722,'multiline':False]
['text':' to also check that the attribute is not the shim','line_number':723,'multiline':False]
['text':' original function => [(mangled overload name, overload function)]','line_number':740,'multiline':False]
['text':' builtin functions like repr() in python 2 do not have __module__ defined','line_number':750,'multiline':False]
['text':' Same format as __overloads__','line_number':772,'multiline':False]
['text':' original function => [overload names]','line_number':773,'multiline':False]
['text':' This is to avoid importing torch.distributed.nn','line_number':822,'multiline':False]
['text':' we shouldn't directly compile overloaded methods, just its overloads','line_number':880,'multiline':False]
['text':' Unique the methods. We don't want to use a set to store the methods because it','line_number':886,'multiline':False]
['text':' introduces non-determinism to compile order.','line_number':887,'multiline':False]
['text':' Don't do anything for @ignore'd functions','line_number':984,'multiline':False]
['text':' Since modules are callable pybind recognizes them as functions, but','line_number':988,'multiline':False]
['text':' don't do anything for them','line_number':989,'multiline':False]
['text':' We don't have the actual scope where the function was defined, but we can','line_number':999,'multiline':False]
['text':' extract the necessary info from the closed over variables on the function','line_number':1000,'multiline':False]
['text':' object','line_number':1001,'multiline':False]
['text':' We don't want to call the hooks here since the graph that is calling','line_number':1034,'multiline':False]
['text':' this function is not yet complete','line_number':1035,'multiline':False]
['text':' Copy @ignored/@unused methods from the original module to the new one.','line_number':1052,'multiline':False]
['text':' This ensures they are available during execution.','line_number':1053,'multiline':False]
['text':' Copy constants over so they are available during execution.','line_number':1059,'multiline':False]
['text':' make the lazy binding method "look like" the original method','line_number':1067,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':1068,'multiline':False]
