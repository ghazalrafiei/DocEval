['text':' TODO: make pt2e folder private?','line_number':27,'multiline':False]
['text':' path compression','line_number':46,'multiline':False]
['text':' union the two trees by pointing the root of child to root of parent','line_number':55,'multiline':False]
['text':' we point from edge_or_node to the node that it is sharing_with, e.g.','line_number':65,'multiline':False]
['text':' qspec for a = SharedQuantizationSpec(b) means `a` points to `b`','line_number':66,'multiline':False]
['text':' TODO: add assertions for types of root qspecs','line_number':125,'multiline':False]
['text':' the input arg to the node should reuse the existing output observer for arg','line_number':131,'multiline':False]
['text':' since dtype is the same (we may want to extend this to be a more strict check','line_number':132,'multiline':False]
['text':' in the future)','line_number':133,'multiline':False]
['text':' so we point from `input_edge` to `arg` (output of the argument)','line_number':134,'multiline':False]
['text':' means the observer of key should be shared with observer with value, by default it will','line_number':187,'multiline':False]
['text':' be shared with itself','line_number':188,'multiline':False]
['text':' NOTE: the order is important here, we first share with other users and then share with previous','line_number':201,'multiline':False]
['text':' output because the reverse order could cause circular dependency','line_number':202,'multiline':False]
['text':' e.g node1 -> node2','line_number':203,'multiline':False]
['text':'          \ -> node3','line_number':204,'multiline':False]
['text':' when processing (node1, node2), if we first point (node1, node2) to node1','line_number':205,'multiline':False]
['text':' Step 1. shared_map = {(node1, node2): node1}','line_number':206,'multiline':False]
['text':' Step 2. after that, we point the (node1, node2) to its other user (node1, node3) ,','line_number':207,'multiline':False]
['text':' which means shared_map = {(node1, node2): node1, node1: (node1, node3)}','line_number':208,'multiline':False]
['text':' because we will point the root of (node1, node2) (in this case node1) to the root of (node1, node3)','line_number':209,'multiline':False]
['text':' Step 3. and when we process (node1, node3), it can try to point to node1 as well, then we'll','line_number':210,'multiline':False]
['text':' have a circular dependency','line_number':211,'multiline':False]
['text':' the following order works around this issue, but this does not allow arbitrary configuration','line_number':212,'multiline':False]
['text':' of sharing so it might break in a different case in the future, when it breaks','line_number':213,'multiline':False]
['text':' quantizer writer can check the notes here to debug the issue','line_number':214,'multiline':False]
['text':' sharing with other users of the producer node','line_number':216,'multiline':False]
['text':' (arg, user)','line_number':217,'multiline':False]
['text':' sharing with output of producer node','line_number':230,'multiline':False]
['text':' now that we get the sharing relations between all edges and nodes, we can assingn group ids','line_number':235,'multiline':False]
['text':' TODO: maybe edge_or_node_to_qspec should be edge_or_node_to_root_qspec, this will simplify','line_number':261,'multiline':False]
['text':' the implementation for _create_obs_or_fq_from_qspec','line_number':262,'multiline':False]
['text':' for ops such as torch.cat([x0, x1]),','line_number':280,'multiline':False]
['text':' traverse through the list','line_number':281,'multiline':False]
['text':' default (no observer)','line_number':294,'multiline':False]
['text':' find the original `arg` node to the current node, skipping inserted observer/fake_quant nodes','line_number':297,'multiline':False]
['text':' type: ignore[assignment]','line_number':300,'multiline':False]
['text':' input_edge needs to be observed','line_number':306,'multiline':False]
['text':' the arg is observed as the output and is using the same instance as the input_edge','line_number':312,'multiline':False]
['text':' we'll reuse the inserted observer/fake_quant','line_number':313,'multiline':False]
['text':' otherwise, we'll insert a new observer/fake_quant node','line_number':317,'multiline':False]
['text':' skip inserting new observers if the same observer instance is inserted before for another user','line_number':320,'multiline':False]
['text':' Example:','line_number':321,'multiline':False]
['text':' conv1 -> obs1 -> existing_obs -> conv2','line_number':322,'multiline':False]
['text':'             \ -> conv3','line_number':323,'multiline':False]
['text':'','line_number':324,'multiline':False]
['text':' instead of inserting new observers we will have:','line_number':325,'multiline':False]
['text':' conv1 -> obs1 -> existing_obs -> conv2','line_number':326,'multiline':False]
['text':'                            \ -> conv3','line_number':327,'multiline':False]
['text':' type: ignore[index]','line_number':331,'multiline':False]
['text':' Look through every input arg.  If that arg's target dtype does not','line_number':359,'multiline':False]
['text':' match the current node's target dtype, insert an observer.','line_number':360,'multiline':False]
['text':' Clone has a memory_format kwarg and zeros_like has a pin_memory kwarg','line_number':368,'multiline':False]
['text':' that persist in exported graph. This is just a work around for these.','line_number':369,'multiline':False]
['text':' assign the new args to the node, inplace','line_number':376,'multiline':False]
['text':' qconfig','line_number':405,'multiline':False]
['text':' this returns the new observer node if it was needed','line_number':416,'multiline':False]
['text':' Update users of original node to use the output observer','line_number':422,'multiline':False]
['text':' instead. For example, change','line_number':423,'multiline':False]
['text':'','line_number':424,'multiline':False]
['text':'           next_node','line_number':425,'multiline':False]
['text':'          /','line_number':426,'multiline':False]
['text':'   cur_node -> obs','line_number':427,'multiline':False]
['text':'','line_number':428,'multiline':False]
['text':' to','line_number':429,'multiline':False]
['text':'','line_number':430,'multiline':False]
['text':'                 next_node','line_number':431,'multiline':False]
['text':'                 /','line_number':432,'multiline':False]
['text':'   cur_node -> obs','line_number':433,'multiline':False]
['text':'','line_number':434,'multiline':False]
['text':' We need to save orig users before updating uses because','line_number':435,'multiline':False]
['text':' the list of users will change as we update uses','line_number':436,'multiline':False]
['text':' Since we are mutating the graph as we go, we iterate over the original','line_number':448,'multiline':False]
['text':' nodes before observer insertion, instead of model.graph.nodes.','line_number':449,'multiline':False]
['text':' At the high level we construct a map from EdgeOrNode to a observer_or_fake_quant instance','line_number':452,'multiline':False]
['text':' all edge/nodes that belongs to the same group will use the same instance','line_number':453,'multiline':False]
['text':' and when we insert observers we'll just query this map to get the correct observer_or_fake_quant','line_number':454,'multiline':False]
['text':' instance','line_number':455,'multiline':False]
['text':' TODO: simplify logic for inserting observers','line_number':461,'multiline':False]
['text':' node_name_to_qconfig','line_number':468,'multiline':False]
['text':' equalization_node_name_to_qconfig','line_number':471,'multiline':False]
['text':' observed_node_names','line_number':474,'multiline':False]
