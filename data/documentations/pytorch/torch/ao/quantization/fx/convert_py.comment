['text':' importing the lib so that the quantized_decomposed ops are registered','line_number':74,'multiline':False]
['text':' noqa: F401','line_number':75,'multiline':False]
['text':' skip replacing observers to quant/dequant nodes if the qconfigs of all','line_number':115,'multiline':False]
['text':' consumers and producers of this observer are None','line_number':116,'multiline':False]
['text':' didn't find corresponding quantize op and info for the activation_post_process','line_number':120,'multiline':False]
['text':' so we just remove the observer','line_number':121,'multiline':False]
['text':' otherwise, we can convert the activation_post_process module call to quantize/dequantize node','line_number':127,'multiline':False]
['text':' 1. extract the information from activation_post_process module for generating','line_number':129,'multiline':False]
['text':' the quantize and dequantize operator','line_number':130,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':131,'multiline':False]
['text':' type: ignore[assignment]','line_number':135,'multiline':False]
['text':' TODO: probably should cleanup this condition check, it's hard','line_number':139,'multiline':False]
['text':' to reason about this if and the following elif','line_number':140,'multiline':False]
['text':' uint8/int8/int32 static quantization branch','line_number':142,'multiline':False]
['text':' 1. extract information for inserting q/dq node from activation_post_process','line_number':144,'multiline':False]
['text':' type: ignore[attr-defined, operator]','line_number':147,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':148,'multiline':False]
['text':' type: ignore[attr-defined, arg-type]','line_number':149,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':168,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':169,'multiline':False]
['text':' 2. replace activation_post_process node with quantize and dequantize','line_number':179,'multiline':False]
['text':' TODO: we can add the information of whether a value needs to','line_number':184,'multiline':False]
['text':' be registered as an attribute in qparams dict itself','line_number':185,'multiline':False]
['text':' For scale and zero_point values we register them as buffers in the root module.','line_number':187,'multiline':False]
['text':' However, note that when the values are not tensors, as in the case of','line_number':188,'multiline':False]
['text':' per_tensor quantization, they will be treated as literals.','line_number':189,'multiline':False]
['text':' However, registering them as a node seems to cause issue with dynamo','line_number':190,'multiline':False]
['text':' tracing where it may consider tensor overload as opposed to default.','line_number':191,'multiline':False]
['text':' With extra check of scale and zero_point being scalar, it makes','line_number':192,'multiline':False]
['text':' sure that the default overload can be used.','line_number':193,'multiline':False]
['text':' TODO: maybe need more complex attr name here','line_number':194,'multiline':False]
['text':' for qparams that are not scale/zero_point (like axis, dtype) we store them as literals in the graph.','line_number':199,'multiline':False]
['text':' use the same qparams from quantize op','line_number':203,'multiline':False]
['text':' uint8/int8/fp16 dynamic quantization','line_number':214,'multiline':False]
['text':' 1. extract information for inserting q/dq node from activation_post_process','line_number':216,'multiline':False]
['text':' we only use choose_qparams for is_decomposed now,','line_number':219,'multiline':False]
['text':' but we should probably align the non-decomposed path with this as well,','line_number':220,'multiline':False]
['text':' and that can be done after we remove reduce_range flag','line_number':221,'multiline':False]
['text':' 1. extract qparams from activation_post_process module','line_number':222,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':227,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':228,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':229,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':230,'multiline':False]
['text':' note: scale and zero_point are missing for quantize_per_tensor op','line_number':231,'multiline':False]
['text':' we'll need to get this from choose_qparams op, which we'll add after','line_number':232,'multiline':False]
['text':' this step','line_number':233,'multiline':False]
['text':' 2. insert choose_qparams op and update the qparams list','line_number':242,'multiline':False]
['text':' we have quant_min, quant_max and dtype, all should be stored','line_number':247,'multiline':False]
['text':' as literals','line_number':248,'multiline':False]
['text':' choose_qparms returns (scale, zero_point)','line_number':256,'multiline':False]
['text':' 3. replace activation_post_process node to quantize and dequantize node','line_number':280,'multiline':False]
['text':' TODO: we can add the information of whether a value needs to','line_number':285,'multiline':False]
['text':' be registered as an attribute in qparams dict itself','line_number':286,'multiline':False]
['text':' in this case we have a node in the graph since it's dynamically','line_number':288,'multiline':False]
['text':' computed from the input, with choose_qparams op','line_number':289,'multiline':False]
['text':' for qparams that are not scale/zero_point (like axis, dtype) we','line_number':293,'multiline':False]
['text':' store them as literals in the graph.','line_number':294,'multiline':False]
['text':' use the same qparams from quantize op','line_number':298,'multiline':False]
['text':' need to use the tensor variant of this op, since scale and zero_point','line_number':300,'multiline':False]
['text':' from choose_qparam are Tensors, instead of float/int, this is to','line_number':301,'multiline':False]
['text':' prevent these nodes being traced away by downstream systems','line_number':302,'multiline':False]
['text':' should not reach since we have checks in the beginning to make sure the','line_number':314,'multiline':False]
['text':' activation_post_process is supported','line_number':315,'multiline':False]
['text':' skip replacing observers to quant/dequant nodes if the qconfigs of all','line_number':336,'multiline':False]
['text':' consumers and producers of this observer are None','line_number':337,'multiline':False]
['text':' didn't find corresponding quantize op and info for the activation_post_process','line_number':341,'multiline':False]
['text':' so we just remove the observer','line_number':342,'multiline':False]
['text':' otherwise, we can convert the activation_post_process module call to quantize/dequantize node','line_number':348,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':349,'multiline':False]
['text':' type: ignore[attr-defined, assignment]','line_number':353,'multiline':False]
['text':' TODO: probably should cleanup this condition check, it's hard','line_number':357,'multiline':False]
['text':' to reason about this if and the following elif','line_number':358,'multiline':False]
['text':' uint8/int8/int32 static quantization branch','line_number':360,'multiline':False]
['text':' 1. extract the information from activation_post_process module for generating','line_number':362,'multiline':False]
['text':' the quantize and dequantize operator','line_number':363,'multiline':False]
['text':' type: ignore[attr-defined, operator]','line_number':366,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':367,'multiline':False]
['text':' type: ignore[attr-defined, arg-type]','line_number':368,'multiline':False]
['text':' 2. replace activation_post_process node with quantize and dequantize','line_number':377,'multiline':False]
['text':' TODO: we can add the information of whether a value needs to','line_number':382,'multiline':False]
['text':' be registered as an attribute in qparams dict itself','line_number':383,'multiline':False]
['text':' For scale and zero_point values we register them as buffers in the root module.','line_number':385,'multiline':False]
['text':' TODO: maybe need more complex attr name here','line_number':386,'multiline':False]
['text':' for qparams that are not scale/zero_point (like axis, dtype) we store them as literals in the graph.','line_number':391,'multiline':False]
['text':' uint8/int8/fp16 dynamic quantization branch','line_number':400,'multiline':False]
['text':' TODO: get reduce range from observer','line_number':404,'multiline':False]
['text':' reduce_range = activation_post_process.reduce_range','line_number':405,'multiline':False]
['text':' type: ignore[assignment]','line_number':421,'multiline':False]
['text':' TODO: we can add the information of whether a value needs to','line_number':427,'multiline':False]
['text':' be registered as an attribute in qparams dict itself','line_number':428,'multiline':False]
['text':' should not reach since we have checks in the beginning to make sure the','line_number':436,'multiline':False]
['text':' activation_post_process is supported','line_number':437,'multiline':False]
['text':' this is a temporary hack for custom module, we may want to implement','line_number':439,'multiline':False]
['text':' this properly after the custom module class design is finalized','line_number':440,'multiline':False]
['text':' TODO: DeQuantStubs are currently inserted only after custom module LSTM, while observers are inserted','line_number':441,'multiline':False]
['text':' after all other custom modules. In the future, we should simply insert QuantStubs before and DeQuantStubs','line_number':442,'multiline':False]
['text':' after custom modules in general, and replace these with "quantize" and "dequantize" nodes respectively.','line_number':443,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':453,'multiline':False]
['text':' type: ignore[attr-defined, assignment]','line_number':457,'multiline':False]
['text':' type: ignore[return-value]','line_number':468,'multiline':False]
['text':' node_arg is weight','line_number':489,'multiline':False]
['text':' run the weight observer','line_number':497,'multiline':False]
['text':' we only replace the specific use since dequantize could be used by other nodes','line_number':508,'multiline':False]
['text':' as well','line_number':509,'multiline':False]
['text':' an observer can be inserted for both input of the next operator or output of the previous','line_number':532,'multiline':False]
['text':' operator (they can be the same)','line_number':533,'multiline':False]
['text':' this flag identifies if the observer is inserted only because the observed node is','line_number':534,'multiline':False]
['text':' the input of the next operator','line_number':535,'multiline':False]
['text':' if the quantize function is at the input of op, then we find the first user of the observer_node','line_number':541,'multiline':False]
['text':' to get the path. If a linear call_function is in the user list, we return the first instance','line_number':542,'multiline':False]
['text':' of linear node to get the FQN.','line_number':543,'multiline':False]
['text':' if the quantize function is at the output of the op, we use the observer input node to get the path','line_number':555,'multiline':False]
['text':' TODO: it's not used, so actually we can skip quantization','line_number':562,'multiline':False]
['text':' but this requires changing return type of quantize_node','line_number':563,'multiline':False]
['text':' we can fix it later if needed','line_number':564,'multiline':False]
['text':' TODO: remove is_reference flag','line_number':613,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':617,'multiline':False]
['text':' We know that observed standalone module is a GraphModule since','line_number':618,'multiline':False]
['text':' it's produced by us','line_number':619,'multiline':False]
['text':' type: ignore[assignment]','line_number':620,'multiline':False]
['text':' remove the dequantize nodes for inputs','line_number':624,'multiline':False]
['text':' type: ignore[union-attr]','line_number':629,'multiline':False]
['text':' type: ignore[union-attr]','line_number':630,'multiline':False]
['text':' type: ignore[union-attr]','line_number':632,'multiline':False]
['text':' add dequantize node for output','line_number':634,'multiline':False]
['text':' if it's non-empty, then it means the output is kept in quantized form','line_number':642,'multiline':False]
['text':' we'll just add a dequantize node after this node','line_number':643,'multiline':False]
['text':' TODO: allow convert_custom_config to override backend_config','line_number':646,'multiline':False]
['text':' for standalone module','line_number':647,'multiline':False]
['text':' update the modules dict','line_number':652,'multiline':False]
['text':' type: ignore[assignment]','line_number':676,'multiline':False]
['text':' Converting qat module to a float module, we need to attach','line_number':683,'multiline':False]
['text':' weight fake_quant to the module, weight fake_quant is assumed to be run during','line_number':684,'multiline':False]
['text':' QAT so we don't need to run it again here','line_number':685,'multiline':False]
['text':' type: ignore[operator]','line_number':687,'multiline':False]
['text':' change qat module to float module','line_number':688,'multiline':False]
['text':' If a qconfig is not defined for this node, then skip converting to a reference module','line_number':693,'multiline':False]
['text':' skip converting to reference quantized module if the qconfig is not supported','line_number':697,'multiline':False]
['text':' TODO: rename weight_is_statically_quantized to weight_is_int8_quantized','line_number':703,'multiline':False]
['text':' the condition for swapping the module to reference quantized module is:','line_number':706,'multiline':False]
['text':' weights need to be quantized','line_number':707,'multiline':False]
['text':' extract the individual float_module and fused module','line_number':713,'multiline':False]
['text':' type: ignore[index]','line_number':716,'multiline':False]
['text':' TODO: move this to the reference quantized module','line_number':718,'multiline':False]
['text':' weight_qparams or weight_qparams dict','line_number':719,'multiline':False]
['text':' type: ignore[union-attr, operator]','line_number':722,'multiline':False]
['text':' type: ignore[union-attr, operator]','line_number':723,'multiline':False]
['text':' format for wq_or_wq_dict (flattened attributes):','line_number':733,'multiline':False]
['text':' {"weight_ih_l0_scale": ..., "weight_ih_l0_qscheme": ..., ...}','line_number':734,'multiline':False]
['text':' type: ignore[union-attr, operator]','line_number':738,'multiline':False]
['text':' type: ignore[union-attr]','line_number':739,'multiline':False]
['text':' type: ignore[operator, misc]','line_number':740,'multiline':False]
['text':' weight_post_process is None means the original module is not a QAT module','line_number':743,'multiline':False]
['text':' we need to get weight_post_process from qconfig in this case','line_number':744,'multiline':False]
['text':' type: ignore[union-attr, operator]','line_number':747,'multiline':False]
['text':' Call weight observer/fake_quant at least once to ensure the scales and zero points','line_number':752,'multiline':False]
['text':' have the right shapes. Note: there are two cases where we don't have to do this:','line_number':753,'multiline':False]
['text':'','line_number':754,'multiline':False]
['text':' (1) QAT: The model's forward method already calls the weight observer/fake_quant,','line_number':755,'multiline':False]
['text':'     and this typically happens during training, so we don't need to do it here.','line_number':756,'multiline':False]
['text':'','line_number':757,'multiline':False]
['text':' (2) Non-reference (lowered) case: The quantized module's from_float method already','line_number':758,'multiline':False]
['text':'     calls the weight observer/fake_quant, so we don't have to do it here.','line_number':759,'multiline':False]
['text':'','line_number':760,'multiline':False]
['text':' Currently we ignore both cases and call the weight observer/fake_quant here','line_number':761,'multiline':False]
['text':' regardless, which is technically incorrect. For (1), this is mainly to preserve BC','line_number':762,'multiline':False]
['text':' in test code, which may not always train before convert. In the future, we should','line_number':763,'multiline':False]
['text':' break BC for these two cases. See https://github.com/pytorch/pytorch/issues/73941.','line_number':764,'multiline':False]
['text':'','line_number':765,'multiline':False]
['text':' For PT2, however, we don't need to preserve BC here, so we can skip this hack','line_number':766,'multiline':False]
['text':' for QAT. We identify this case as (is_decomposed + is_reference + is_qat).','line_number':767,'multiline':False]
['text':' Note that we still need it for PTQ in the PT2 flow since the model's forward','line_number':768,'multiline':False]
['text':' method doesn't call the weight observer.','line_number':769,'multiline':False]
['text':' type: ignore[operator]','line_number':772,'multiline':False]
['text':' We use the same reference module for all modes of quantization: static, dynamic, weight_only','line_number':776,'multiline':False]
['text':' root_module_to_quantized_reference_module: module mapping from root (floating point) module class','line_number':777,'multiline':False]
['text':' to quantized reference module class, e.g. nn.Conv2d to nn.quantized._reference.Conv2d','line_number':778,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':784,'multiline':False]
['text':' type: ignore[operator]','line_number':786,'multiline':False]
['text':' expecting the input node for a custom module node to be a Node','line_number':799,'multiline':False]
['text':' Remove the dequantize node if it doesn't have other users','line_number':804,'multiline':False]
['text':' The inputs are tuples in the form (input, (hidden0, hidden1))','line_number':844,'multiline':False]
['text':' Ensure all three input nodes are quantized','line_number':845,'multiline':False]
['text':' type: ignore[misc]','line_number':851,'multiline':False]
['text':' Inputs are in the form (query, key, value)','line_number':859,'multiline':False]
['text':' TODO: This is the first step in enabling the full fx custom module','line_number':860,'multiline':False]
['text':' quantization path for MultiheadAttention, and only covers the inputs','line_number':861,'multiline':False]
['text':' to the module.','line_number':862,'multiline':False]
['text':' Additional handling is yet to be implemented for the outputs, similar','line_number':863,'multiline':False]
['text':' to LSTM custom module','line_number':864,'multiline':False]
['text':' remove the previous dequant node to ensure the inputs are quantized','line_number':874,'multiline':False]
['text':' absorb the following observer into the module conversion','line_number':878,'multiline':False]
['text':' swap the observed custom module to quantized custom module','line_number':883,'multiline':False]
['text':' type: ignore[assignment]','line_number':958,'multiline':False]
['text':' mapping from fully qualified module name to module instance','line_number':960,'multiline':False]
['text':' for example,','line_number':961,'multiline':False]
['text':' {','line_number':962,'multiline':False]
['text':'   '': Model(...),','line_number':963,'multiline':False]
['text':'   'linear': Linear(...),','line_number':964,'multiline':False]
['text':'   'linear.weight_fake_quant': PerChannelMinMaxObserver(...),','line_number':965,'multiline':False]
['text':' }','line_number':966,'multiline':False]
['text':' We use remove_duplicate=False here because torch.cat uses','line_number':967,'multiline':False]
['text':' the same activation_post_process module instance but different names','line_number':968,'multiline':False]
['text':' TODO refactor this code once we update the prepare logic to have additional information on','line_number':971,'multiline':False]
['text':' which graph nodes have been observed and share that with convert to decide which observers to ignore.','line_number':972,'multiline':False]
['text':' type: ignore[assignment]','line_number':974,'multiline':False]
['text':' type: ignore[arg-type]','line_number':981,'multiline':False]
['text':' check the convert_node_name_to_qconfig generated and ensure that','line_number':984,'multiline':False]
['text':' all the values either match what was set in prepare node_name_to_qconfig','line_number':985,'multiline':False]
['text':' or are set to None in the convert_node_name_to_qconfig.','line_number':986,'multiline':False]
['text':' If we want to do equalization then do the following:','line_number':999,'multiline':False]
['text':' Calculate the equalization scale, update the observers with the scaled','line_number':1000,'multiline':False]
['text':' inputs, and scale the weight','line_number':1001,'multiline':False]
['text':' always run weight observers in the top level forward method','line_number':1005,'multiline':False]
['text':' for dynamic quant ops or weight only quant ops','line_number':1006,'multiline':False]
['text':' additional state to override inputs to be quantized, if specified','line_number':1014,'multiline':False]
['text':' by the user','line_number':1015,'multiline':False]
['text':' convert tuples so that it can work with isinstance(module, tuple_of_classes)','line_number':1021,'multiline':False]
['text':' Inputs are assumed to be quantized if the user specified the','line_number':1032,'multiline':False]
['text':' input_quantized_idxs override.','line_number':1033,'multiline':False]
['text':' we need to dequantize the inputs since all operators took','line_number':1034,'multiline':False]
['text':' floating point inputs in reference quantized models','line_number':1035,'multiline':False]
['text':' If the argument is empty we don't need to do anything','line_number':1038,'multiline':False]
['text':' Result are kept quantized if the user specified the','line_number':1041,'multiline':False]
['text':' output_quantized_idxs override.','line_number':1042,'multiline':False]
['text':' Remove the dequantize operator for the node in the end if any','line_number':1043,'multiline':False]
['text':' outputs can be Node, list, tuple, dict, other cases are not supported yet','line_number':1046,'multiline':False]
['text':' we treat dict as a single argument currently, but it can be extended','line_number':1051,'multiline':False]
['text':' to support {"key": dtype} after we change output_quantized_idxs to','line_number':1052,'multiline':False]
['text':' dict','line_number':1053,'multiline':False]
['text':' below this point `type_before_parametrizations` is used','line_number':1079,'multiline':False]
['text':' instead of `type` to handle situations with fx quant + sparsity','line_number':1080,'multiline':False]
['text':' extra check for fused module classes to make sure they are fused module classes','line_number':1083,'multiline':False]
['text':' of target modules','line_number':1084,'multiline':False]
['text':' type: ignore[index]','line_number':1086,'multiline':False]
['text':' remove deadcode after converting observers to quant/dequant ops','line_number':1096,'multiline':False]
['text':' TODO: maybe move this to quantize_fx.py','line_number':1100,'multiline':False]
['text':' TODO: this looks hacky, we want to check why we need this and see if we can','line_number':1104,'multiline':False]
['text':' remove this','line_number':1105,'multiline':False]
['text':' removes qconfig and activation_post_process modules','line_number':1106,'multiline':False]
