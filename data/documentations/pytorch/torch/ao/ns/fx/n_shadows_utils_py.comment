['text':' TODO(future PR): make this work correctly for methods','line_number':10,'multiline':False]
['text':' TODO(future PR): reuse existing mapping instead of creating a new one','line_number':33,'multiline':False]
['text':' the original matches variable is unique by node, make it unique by subgraph','line_number':105,'multiline':False]
['text':' instead','line_number':106,'multiline':False]
['text':' Dict items are not reversible until Python 3.8, so we hack it','line_number':110,'multiline':False]
['text':' to be compatible with previous Python versions','line_number':111,'multiline':False]
['text':' TODO(future PR): try reversed(list(matches.items()))','line_number':112,'multiline':False]
['text':' Note: the order is important.  `matches` currently provides the matches','line_number':117,'multiline':False]
['text':' in reverse order.  We would like to process the matches in non-reverse','line_number':118,'multiline':False]
['text':' order, so that we can create an intuitive naming scheme, such as','line_number':119,'multiline':False]
['text':' naming the first op's submodules `shadow_0_0` through `shadow_0_(n-1)`','line_number':120,'multiline':False]
['text':' type: ignore[call-overload]','line_number':121,'multiline':False]
['text':' Cur_match[1] has an unusual type. It says that it's a `List[Node]`,','line_number':125,'multiline':False]
['text':' but it is really not. Furthermore, the contents of this field','line_number':126,'multiline':False]
['text':' can change from match results of multiple nodes of the same pattern','line_number':127,'multiline':False]
['text':'','line_number':128,'multiline':False]
['text':' For example, for conv -> bn -> relu, we see','line_number':129,'multiline':False]
['text':' match_results = {','line_number':130,'multiline':False]
['text':'   'conv': (relu, [(bn, conv), relu], ...),','line_number':131,'multiline':False]
['text':'   'bn': (relu, [(bn, conv), relu], ...),','line_number':132,'multiline':False]
['text':'   'relu': (relu, [(bn, conv), relu], ...),','line_number':133,'multiline':False]
['text':' }','line_number':134,'multiline':False]
['text':'','line_number':135,'multiline':False]
['text':' Ideally we should clean up the `find_matches` function to make','line_number':136,'multiline':False]
['text':' this more intuitive. For the purposes of this prototype, we hack','line_number':137,'multiline':False]
['text':' around it.','line_number':138,'multiline':False]
['text':' Start with the unusual type, convert it to [op_0, ..., op_n]','line_number':156,'multiline':False]
['text':' either (a, b), or ((a, b), c) or (c, (a, b))','line_number':163,'multiline':False]
['text':' cannot make any assumptions on order, not clear what the','line_number':164,'multiline':False]
['text':' _find_matches function is doing to populate this','line_number':165,'multiline':False]
['text':' TODO(future PR): make this code less confusing,  see discussion','line_number':166,'multiline':False]
['text':' in https://github.com/pytorch/pytorch/pull/80521/files#r975918836','line_number':167,'multiline':False]
['text':' (a, b)','line_number':190,'multiline':False]
['text':' ((a, b), c)','line_number':193,'multiline':False]
['text':' (a, (b, c))','line_number':198,'multiline':False]
['text':' [node_n, ..., node_0], note that the order is reversed','line_number':203,'multiline':False]
['text':' to make it chronological for simple subgraphs','line_number':204,'multiline':False]
['text':' ref_node_name','line_number':228,'multiline':False]
['text':' prev_node_name','line_number':229,'multiline':False]
['text':' model_name','line_number':230,'multiline':False]
['text':' ref_name','line_number':231,'multiline':False]
['text':' prev_node_target_type','line_number':232,'multiline':False]
['text':' ref_node_target_type','line_number':233,'multiline':False]
['text':' results_type','line_number':234,'multiline':False]
['text':' index_within_arg','line_number':235,'multiline':False]
['text':' index_of_arg','line_number':236,'multiline':False]
['text':' fqn','line_number':237,'multiline':False]
['text':' Usually we expect the user to add loggers, then calibrate, then convert,','line_number':240,'multiline':False]
['text':' and then populate loggers.  This is why the loggers start disabled.','line_number':241,'multiline':False]
['text':' TODO(future PR): reconsider the design to make this more intuitive.','line_number':242,'multiline':False]
['text':'','line_number':277,'multiline':False]
['text':' create a blank GraphModule with an empty graph','line_number':278,'multiline':False]
['text':'','line_number':279,'multiline':False]
['text':'','line_number':291,'multiline':False]
['text':' modify the graph to have a copy of our subgraph','line_number':292,'multiline':False]
['text':'','line_number':293,'multiline':False]
['text':' we are at the first node, we need to set up graph inputs','line_number':306,'multiline':False]
['text':' TODO(future): some graphs could have placeholders which are unrelated','line_number':307,'multiline':False]
['text':' to the first node, need to handle this','line_number':308,'multiline':False]
['text':' note: for graphs starting with patterns such as `y = x + x`, we','line_number':317,'multiline':False]
['text':' need to ensure we do not add multiple placeholders with the','line_number':318,'multiline':False]
['text':' same name','line_number':319,'multiline':False]
['text':' TODO(future PR): handle non-normalized kwargs','line_number':346,'multiline':False]
['text':' type: ignore[assignment]','line_number':361,'multiline':False]
['text':' we are not at first node, first arg is from the previous node,','line_number':363,'multiline':False]
['text':' and all other args are copied','line_number':364,'multiline':False]
['text':' the current implementation is simplistic and cannot handle','line_number':366,'multiline':False]
['text':' ops with two or more arguments which need to be passed from','line_number':367,'multiline':False]
['text':' the previous op, so we assert them out','line_number':368,'multiline':False]
['text':' at this point in the code, cur_node_copy is pointing to the copy','line_number':371,'multiline':False]
['text':' of the previous node','line_number':372,'multiline':False]
['text':' TODO(future PR): this is not handling complicated graphs correctly, need to','line_number':373,'multiline':False]
['text':' look at actual relationships instead of assuming sequential graph','line_number':374,'multiline':False]
['text':' TODO(future PR): this is ignoring kwargs, will need to support kwargs','line_number':375,'multiline':False]
['text':' for any fusion pattern which has them for a node that is not the','line_number':376,'multiline':False]
['text':' first node.','line_number':377,'multiline':False]
['text':' type: ignore[has-type]','line_number':378,'multiline':False]
['text':' type: ignore[assignment]','line_number':383,'multiline':False]
['text':' type: ignore[assignment]','line_number':393,'multiline':False]
['text':' copy the node','line_number':395,'multiline':False]
['text':' type: ignore[arg-type]','line_number':397,'multiline':False]
['text':' go to next node','line_number':418,'multiline':False]
['text':' set up outputs','line_number':429,'multiline':False]
['text':' TODO(future PR): move logger classes to utils to remove circular dependency','line_number':459,'multiline':False]
['text':' idx = 0 is the floating point (original) version of the subgraph','line_number':463,'multiline':False]
['text':' We keep the subgraph as is, and add a logger at the end','line_number':464,'multiline':False]
['text':' idx > 0 means we have a candidate qconfig to try, so we need','line_number':479,'multiline':False]
['text':' to make a copy of the subgraph, feed it with the right inputs,','line_number':480,'multiline':False]
['text':' and add a logger at the end','line_number':481,'multiline':False]
['text':' get the qconfig','line_number':483,'multiline':False]
['text':' subtract one because the first candidate is the floating point','line_number':484,'multiline':False]
['text':' version of the subgraph','line_number':485,'multiline':False]
['text':' if no quantization is requested, skip','line_number':490,'multiline':False]
['text':' TODO(future PR): deduplicate equivalent qconfigs that come from','line_number':491,'multiline':False]
['text':'   different qconfig mapping objects','line_number':492,'multiline':False]
['text':' create a copy of the submodule, wrapped in a separate module','line_number':498,'multiline':False]
['text':' add a call to prepare_fx on the wrapper module','line_number':502,'multiline':False]
['text':' attach the wrapper to the model','line_number':520,'multiline':False]
['text':' add a call to the wrapper module from the parent graph','line_number':525,'multiline':False]
['text':' TODO(future PR): handle fusion patterns where non-first nodes','line_number':528,'multiline':False]
['text':' need inputs','line_number':529,'multiline':False]
['text':' pass in all node args and kwargs','line_number':531,'multiline':False]
['text':' TODO(future PR): clarify why we are adding kwargs to args','line_number':548,'multiline':False]
['text':' type: ignore[assignment]','line_number':551,'multiline':False]
['text':' add a logger to parent graph to observe the shadow wrapper','line_number':556,'multiline':False]
['text':' for now, assume that','line_number':584,'multiline':False]
['text':' 1. the first node has one input','line_number':585,'multiline':False]
['text':' 2. the last node has one output','line_number':586,'multiline':False]
['text':' for now, ignore all subgraphs that contain non-nodes (tuples, etc)','line_number':588,'multiline':False]
['text':' TODO(future PR): implement this','line_number':589,'multiline':False]
['text':' We used output propagation to populate example values on each','line_number':598,'multiline':False]
['text':' node. Use the example values from the previous node as the input','line_number':599,'multiline':False]
['text':' to the current node.','line_number':600,'multiline':False]
['text':' type: ignore[assignment]','line_number':605,'multiline':False]
['text':' currently some customer models do not have a traced_result in','line_number':607,'multiline':False]
['text':' every node, so we have to guard for this case since we cannot','line_number':608,'multiline':False]
['text':' quantize without an example input','line_number':609,'multiline':False]
['text':' TODO(future PR): add a test case for this once we have an easy','line_number':610,'multiline':False]
['text':' repro, see https://github.com/pytorch/pytorch/pull/80521/files#r975940489','line_number':611,'multiline':False]
['text':' for additional context','line_number':612,'multiline':False]
['text':' type: ignore[attr-defined, assignment]','line_number':614,'multiline':False]
['text':' If there are no quantization configs for this subgraph, skip adding','line_number':621,'multiline':False]
['text':' loggers. This reduces memory usage for models where not all layers are','line_number':622,'multiline':False]
['text':' quantized.','line_number':623,'multiline':False]
['text':' TODO(future): consider making this configurable','line_number':624,'multiline':False]
['text':' fp32 baseline does not need a qconfig','line_number':629,'multiline':False]
['text':' a. we have N shadows, so len(qconfig_mappings) is N','line_number':632,'multiline':False]
['text':' b. we will have the fp32 layer + N shadows, so overall number of','line_number':633,'multiline':False]
['text':'    (original_op) + (*shadows) will be N+1','line_number':634,'multiline':False]
['text':' c. since `subgraph_candidate_idx` represents (b), we need','line_number':635,'multiline':False]
['text':'    to subtract 1 to query from (a)','line_number':636,'multiline':False]
['text':' We want the results to contain the subgraphs in natural order,','line_number':650,'multiline':False]
['text':' and the graph to also contain shadow wrappers and shadow loggers','line_number':651,'multiline':False]
['text':' in natural order.','line_number':652,'multiline':False]
['text':' If we just iterate in reverse, the graph will be in natural','line_number':653,'multiline':False]
['text':' order but the eventual results will be in reverse order.','line_number':654,'multiline':False]
['text':' So, we keep track of the last shadow logger we added and','line_number':655,'multiline':False]
['text':' always insert after it.','line_number':656,'multiline':False]
['text':' TODO(future PR): move logger classes to utils to remove circular dependency','line_number':703,'multiline':False]
['text':' First, we need to create shadow branches, going from','line_number':712,'multiline':False]
['text':'','line_number':713,'multiline':False]
['text':'   x0 -> op0 -> x1 -> ...','line_number':714,'multiline':False]
['text':'','line_number':715,'multiline':False]
['text':'','line_number':716,'multiline':False]
['text':' to','line_number':717,'multiline':False]
['text':'','line_number':718,'multiline':False]
['text':'   x0 -> op0_0 -> x1_0 -> log -> ...','line_number':719,'multiline':False]
['text':'    \                     \','line_number':720,'multiline':False]
['text':'      -> op0_1 -> x1_1 -> clog','line_number':721,'multiline':False]
['text':'','line_number':722,'multiline':False]
['text':' Later, the outputs of each shadow will be rerouted to calculate','line_number':723,'multiline':False]
['text':' propagation error.','line_number':724,'multiline':False]
['text':' Note: we cannot iterate over matched subgraphs because some nodes','line_number':726,'multiline':False]
['text':' may not be matched. So, we iterate over nodes in the graph, and','line_number':727,'multiline':False]
['text':' associate them to matched subgraphs if possible.','line_number':728,'multiline':False]
['text':' for each subgraph, save a mapping from first node of subgraph','line_number':731,'multiline':False]
['text':' to first and last node of the shadow of this subgraph','line_number':732,'multiline':False]
['text':' need to record original list because we will mutate the graph as we go','line_number':735,'multiline':False]
['text':' type: ignore[union-attr, arg-type]','line_number':736,'multiline':False]
['text':' type: ignore[arg-type]','line_number':759,'multiline':False]
['text':' find the created shadow module and record it so we','line_number':761,'multiline':False]
['text':' can find it easily in step 2','line_number':762,'multiline':False]
['text':' create a copy of the subgraph by only copying FX nodes','line_number':775,'multiline':False]
['text':' but not copying any parameters, to minimize memory usage','line_number':776,'multiline':False]
['text':' add a regular logger after last_node','line_number':780,'multiline':False]
['text':' create a copy of the subgraph','line_number':796,'multiline':False]
['text':' TODO(future PR): make this support all possible args/kwargs','line_number':801,'multiline':False]
['text':' noqa: C409','line_number':807,'multiline':False]
['text':' make a copy of cur_node_orig','line_number':809,'multiline':False]
['text':' cur_node_orig.name,  # TODO(future PR): set name explicitly','line_number':816,'multiline':False]
['text':' since now only linear subgraphs are supported, all nodes','line_number':820,'multiline':False]
['text':' except the last one must have only one user','line_number':821,'multiline':False]
['text':' add a comparison logger after last_node's copy','line_number':828,'multiline':False]
['text':' save the final node so we can use it in step 2','line_number':840,'multiline':False]
['text':' Now, we go from','line_number':848,'multiline':False]
['text':'','line_number':849,'multiline':False]
['text':'   x0 -> op0_0 -> x1_0 -> log -> x1 -> op1_0 -> ...','line_number':850,'multiline':False]
['text':'    \                     \       \','line_number':851,'multiline':False]
['text':'      -> op0_1 -> x1_1 -> clog      -> op1_1 -> ...','line_number':852,'multiline':False]
['text':'','line_number':853,'multiline':False]
['text':' to','line_number':854,'multiline':False]
['text':'','line_number':855,'multiline':False]
['text':'   x0 -> op0_0 -> x1_0 -> log --> x1_0 -> op1_0 -> ...','line_number':856,'multiline':False]
['text':'    \                     \','line_number':857,'multiline':False]
['text':'      -> op0_1 -> x1_1 -> clog -> x1_1 -> op1_1 -> ...','line_number':858,'multiline':False]
['text':'','line_number':859,'multiline':False]
['text':' sample values of key internal variables for the example above:','line_number':860,'multiline':False]
['text':'','line_number':861,'multiline':False]
['text':'   orig_first_node_to_shadow_in_node = {op0_0: op0_1, op1_0: op1_1}','line_number':862,'multiline':False]
['text':'   orig_first_node_to_shadow_out_node = {op0_0: op0_1, op1_0: op1_1}','line_number':863,'multiline':False]
['text':'','line_number':864,'multiline':False]
['text':' note: for subgraphs with more than one node, in_node will be different','line_number':865,'multiline':False]
['text':' compared to out_node','line_number':866,'multiline':False]
['text':' handle scalars','line_number':888,'multiline':False]
['text':' Find the shadowed version of this arg from the previous','line_number':894,'multiline':False]
['text':' subgraph. For this, we need to:','line_number':895,'multiline':False]
['text':' 1. navigate to the first node of the previous subgraph','line_number':896,'multiline':False]
['text':' 2. get the output of the shadow wrapper which has (1) as an input','line_number':897,'multiline':False]
['text':' For now, assume the arg is in matched subgraphs. In the','line_number':899,'multiline':False]
['text':' future we may have to handle the case where this is not true.','line_number':900,'multiline':False]
['text':' input: shadow wrapper module','line_number':921,'multiline':False]
['text':' output if shadow wrapper module has a weighted op:','line_number':922,'multiline':False]
['text':'   (quantize_fn, (quantize_fn_args))','line_number':923,'multiline':False]
['text':' output if shadow wrapper module doesn't have a weighted op:','line_number':924,'multiline':False]
['text':'   None','line_number':925,'multiline':False]
['text':' For now, assume that the weight is the second input','line_number':927,'multiline':False]
['text':' to the shadow module. If that changes, we can fix it later.','line_number':928,'multiline':False]
['text':' type: ignore[union-attr]','line_number':930,'multiline':False]
['text':' the subgraph looks like','line_number':938,'multiline':False]
['text':'','line_number':939,'multiline':False]
['text':'   _input_scale_1 = self._input_scale_1','line_number':940,'multiline':False]
['text':'   _input_zero_point_1 = self._input_zero_point_1','line_number':941,'multiline':False]
['text':'   quantize_per_channel = torch.quantize_per_channel(','line_number':942,'multiline':False]
['text':'       w2_0, _input_scale_1, _input_zero_point_1,','line_number':943,'multiline':False]
['text':'       0, torch.qint8)','line_number':944,'multiline':False]
['text':'','line_number':945,'multiline':False]
['text':'  we have `w2_0`, and are navigating this subgraph','line_number':946,'multiline':False]
['text':'  to get `_input_scale_1` and `_input_zero_point_1`','line_number':947,'multiline':False]
['text':' example graph:','line_number':974,'multiline':False]
['text':'','line_number':975,'multiline':False]
['text':'   w1 = self.w1','line_number':976,'multiline':False]
['text':'   b1 = self.b1','line_number':977,'multiline':False]
['text':'   linear = torch._C._nn.linear(x, w1, b1)','line_number':978,'multiline':False]
['text':'   shadow_0_0 = self.shadow_0_0(linear)','line_number':979,'multiline':False]
['text':'   shadow_wrapper_0_1 = self.shadow_wrapper_0_1(x, w1, b1)','line_number':980,'multiline':False]
['text':'   shadow_0_1 = self.shadow_0_1(shadow_wrapper_0_1, linear)','line_number':981,'multiline':False]
['text':'','line_number':982,'multiline':False]
['text':' algorithm:','line_number':983,'multiline':False]
['text':' 1. for each call_function node matching our allowlist:','line_number':984,'multiline':False]
['text':' 2.   if corresponding shadow wrapper exists, extract the weight pair','line_number':985,'multiline':False]
['text':'','line_number':986,'multiline':False]
['text':' Note: this is not super robust, but that's ok because this is','line_number':987,'multiline':False]
['text':' just for legacy customers who depend on the previous two-model version','line_number':988,'multiline':False]
['text':' of this API. TBD if we need to make this robust.','line_number':989,'multiline':False]
['text':' Note: modules are not supported, since existing customers only','line_number':990,'multiline':False]
['text':' use functions.','line_number':991,'multiline':False]
['text':' TODO(future PR): move this to config','line_number':993,'multiline':False]
['text':' type: ignore[union-attr]','line_number':1002,'multiline':False]
['text':' Check if we have a corresponding shadow wrapper','line_number':1006,'multiline':False]
['text':' TODO(future PR, if needed): support kwargs','line_number':1007,'multiline':False]
['text':' TODO(future PR, if needed): support multiple shadow users','line_number':1008,'multiline':False]
['text':' TODO(before land): fix string match','line_number':1012,'multiline':False]
['text':' type: ignore[arg-type]','line_number':1022,'multiline':False]
['text':' get weight','line_number':1028,'multiline':False]
['text':' get a quantized version of weight','line_number':1032,'multiline':False]
['text':' add a comparison','line_number':1037,'multiline':False]
['text':' type: ignore[index]','line_number':1044,'multiline':False]
['text':' go from subgraph_n_1 to subgraph_n_0','line_number':1075,'multiline':False]
['text':' TODO(future PR): redesign this to make it easier to consume outputs','line_number':1087,'multiline':False]
['text':' node_output or weight','line_number':1147,'multiline':False]
['text':' convert from `subgraph_m_n` to `subgraph_m` and `n`','line_number':1153,'multiline':False]
['text':' TODO(future PR): redesign this to make it easier to consume outputs','line_number':1173,'multiline':False]
['text':' skip comparing baseline to baseline','line_number':1228,'multiline':False]
['text':' we expect the comparisons to be precalculated from','line_number':1232,'multiline':False]
['text':' calibration, so we just fetch them here','line_number':1233,'multiline':False]
['text':' TODO(future PR): redesign this to make it easier to consume outputs','line_number':1253,'multiline':False]
