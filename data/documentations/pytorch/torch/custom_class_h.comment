['text':'/ This function is used in conjunction with `class_::def()` to register','line_number':19,'multiline':False]
['text':'/ a constructor for a given C++ class type. For example,','line_number':20,'multiline':False]
['text':'/ `torch::init<int, std::string>()` would register a two-argument constructor','line_number':21,'multiline':False]
['text':'/ taking an `int` and a `std::string` as argument.','line_number':22,'multiline':False]
['text':'/ Entry point for custom C++ class registration. To register a C++ class','line_number':42,'multiline':False]
['text':'/ in PyTorch, instantiate `torch::class_` with the desired class as the','line_number':43,'multiline':False]
['text':'/ template parameter. Typically, this instantiation should be done in','line_number':44,'multiline':False]
['text':'/ the initialization of a global variable, so that the class will be','line_number':45,'multiline':False]
['text':'/ made available on dynamic library loading without any additional API','line_number':46,'multiline':False]
['text':'/ calls needed. For example, to register a class named Foo, you might','line_number':47,'multiline':False]
['text':'/ create a global variable like so:','line_number':48,'multiline':False]
['text':'/','line_number':49,'multiline':False]
['text':'/     static auto register_foo = torch::class_<Foo>("myclasses", "Foo")','line_number':50,'multiline':False]
['text':'/       .def("myMethod", &Foo::myMethod)','line_number':51,'multiline':False]
['text':'/       .def("lambdaMethod", [](const c10::intrusive_ptr<Foo>& self) {','line_number':52,'multiline':False]
['text':'/         // Do something with `self`','line_number':53,'multiline':False]
['text':'/       });','line_number':54,'multiline':False]
['text':'/','line_number':55,'multiline':False]
['text':'/ In addition to registering the class, this registration also chains','line_number':56,'multiline':False]
['text':'/ `def()` calls to register methods. `myMethod()` is registered with','line_number':57,'multiline':False]
['text':'/ a pointer to the Foo class's `myMethod()` method. `lambdaMethod()`','line_number':58,'multiline':False]
['text':'/ is registered with a C++ lambda expression.','line_number':59,'multiline':False]
['text':'/ This constructor actually registers the class type.','line_number':67,'multiline':False]
['text':'/ String argument `namespaceName` is an identifier for the','line_number':68,'multiline':False]
['text':'/ namespace you would like this class to appear in.','line_number':69,'multiline':False]
['text':'/ String argument `className` is the name you would like to','line_number':70,'multiline':False]
['text':'/ see this class exposed as in Python and TorchScript. For example, if','line_number':71,'multiline':False]
['text':'/ you pass `foo` as the namespace name and `Bar` as the className, the','line_number':72,'multiline':False]
['text':'/ class will appear as `torch.classes.foo.Bar` in Python and TorchScript','line_number':73,'multiline':False]
['text':'/ def() can be used in conjunction with `torch::init()` to register','line_number':85,'multiline':False]
['text':'/ a constructor for a given C++ class type. For example, passing','line_number':86,'multiline':False]
['text':'/ `torch::init<int, std::string>()` would register a two-argument','line_number':87,'multiline':False]
['text':'/ constructor taking an `int` and a `std::string` as argument.','line_number':88,'multiline':False]
['text':' Used in combination with','line_number':94,'multiline':False]
['text':' torch::init<...>()','line_number':95,'multiline':False]
['text':' Used in combination with torch::init([]lambda(){......})','line_number':110,'multiline':False]
['text':'/ This is the normal method registration API. `name` is the name that','line_number':134,'multiline':False]
['text':'/ the method will be made accessible by in Python and TorchScript.','line_number':135,'multiline':False]
['text':'/ `f` is a callable object that defines the method. Typically `f`','line_number':136,'multiline':False]
['text':'/ will either be a pointer to a method on `CurClass`, or a lambda','line_number':137,'multiline':False]
['text':'/ expression that takes a `c10::intrusive_ptr<CurClass>` as the first','line_number':138,'multiline':False]
['text':'/ argument (emulating a `this` argument in a C++ method.)','line_number':139,'multiline':False]
['text':'/','line_number':140,'multiline':False]
['text':'/ Examples:','line_number':141,'multiline':False]
['text':'/','line_number':142,'multiline':False]
['text':'/     // Exposes method `foo` on C++ class `Foo` as `call_foo()` in','line_number':143,'multiline':False]
['text':'/     // Python and TorchScript','line_number':144,'multiline':False]
['text':'/     .def("call_foo", &Foo::foo)','line_number':145,'multiline':False]
['text':'/','line_number':146,'multiline':False]
['text':'/     // Exposes the given lambda expression as method `call_lambda()`','line_number':147,'multiline':False]
['text':'/     // in Python and TorchScript.','line_number':148,'multiline':False]
['text':'/     .def("call_lambda", [](const c10::intrusive_ptr<Foo>& self) {','line_number':149,'multiline':False]
['text':'/       // do something','line_number':150,'multiline':False]
['text':'/     })','line_number':151,'multiline':False]
['text':'/ Method registration API for static methods.','line_number':167,'multiline':False]
['text':'/ Property registration API for properties with both getter and setter','line_number':191,'multiline':False]
['text':'/ functions.','line_number':192,'multiline':False]
['text':'/ Property registration API for properties with only getter function.','line_number':214,'multiline':False]
['text':'/ Property registration API for properties with read-write access.','line_number':230,'multiline':False]
['text':'/ Property registration API for properties with read-only access.','line_number':246,'multiline':False]
['text':'/ This is an unsafe method registration API added for adding custom JIT','line_number':257,'multiline':False]
['text':'/ backend support via custom C++ classes. It is not for general purpose use.','line_number':258,'multiline':False]
['text':'/ def_pickle() is used to define exactly what state gets serialized','line_number':274,'multiline':False]
['text':'/ or deserialized for a given instance of a custom C++ class in','line_number':275,'multiline':False]
['text':'/ Python or TorchScript. This protocol is equivalent to the Pickle','line_number':276,'multiline':False]
['text':'/ concept of `__getstate__` and `__setstate__` from Python','line_number':277,'multiline':False]
['text':'/ (https://docs.python.org/2/library/pickle.html#object.__getstate__)','line_number':278,'multiline':False]
['text':'/','line_number':279,'multiline':False]
['text':'/ Currently, both the `get_state` and `set_state` callables must be','line_number':280,'multiline':False]
['text':'/ C++ lambda expressions. They should have the following signatures,','line_number':281,'multiline':False]
['text':'/ where `CurClass` is the class you're registering and `T1` is some object','line_number':282,'multiline':False]
['text':'/ that encapsulates the state of the object.','line_number':283,'multiline':False]
['text':'/','line_number':284,'multiline':False]
['text':'/     __getstate__(intrusive_ptr<CurClass>) -> T1','line_number':285,'multiline':False]
['text':'/     __setstate__(T2) -> intrusive_ptr<CurClass>','line_number':286,'multiline':False]
['text':'/','line_number':287,'multiline':False]
['text':'/ `T1` must be an object that is convertable to IValue by the same rules','line_number':288,'multiline':False]
['text':'/ for custom op/method registration.','line_number':289,'multiline':False]
['text':'/','line_number':290,'multiline':False]
['text':'/ For the common case, T1 == T2. T1 can also be a subtype of T2. An','line_number':291,'multiline':False]
['text':'/ example where it makes sense for T1 and T2 to differ is if __setstate__','line_number':292,'multiline':False]
['text':'/ handles legacy formats in a backwards compatible way.','line_number':293,'multiline':False]
['text':'/','line_number':294,'multiline':False]
['text':'/ Example:','line_number':295,'multiline':False]
['text':'/','line_number':296,'multiline':False]
['text':'/     .def_pickle(','line_number':297,'multiline':False]
['text':'/         // __getstate__','line_number':298,'multiline':False]
['text':'/         [](const c10::intrusive_ptr<MyStackClass<std::string>>& self) {','line_number':299,'multiline':False]
['text':'/           return self->stack_;','line_number':300,'multiline':False]
['text':'/         },','line_number':301,'multiline':False]
['text':'/         [](std::vector<std::string> state) { // __setstate__','line_number':302,'multiline':False]
['text':'/            return c10::make_intrusive<MyStackClass<std::string>>(','line_number':303,'multiline':False]
['text':'/               std::vector<std::string>{"i", "was", "deserialized"});','line_number':304,'multiline':False]
['text':'/         })','line_number':305,'multiline':False]
['text':' __setstate__ needs to be registered with some custom handling:','line_number':315,'multiline':False]
['text':' We need to wrap the invocation of the user-provided function','line_number':316,'multiline':False]
['text':' such that we take the return value (i.e. c10::intrusive_ptr<CurrClass>)','line_number':317,'multiline':False]
['text':' and assign it to the `capsule` attribute.','line_number':318,'multiline':False]
['text':' type validation','line_number':336,'multiline':False]
['text':' If default values are provided for function arguments, there must be','line_number':382,'multiline':False]
['text':' none (no default values) or default values for all function','line_number':383,'multiline':False]
['text':' arguments, except for self. This is because argument names are not','line_number':384,'multiline':False]
['text':' extracted by inferFunctionSchemaSingleReturn, and so there must be a','line_number':385,'multiline':False]
['text':' torch::arg instance in default_args even for arguments that do not','line_number':386,'multiline':False]
['text':' have an actual default value provided.','line_number':387,'multiline':False]
['text':' If there are default args, copy the argument names and default values to','line_number':393,'multiline':False]
['text':' the function schema.','line_number':394,'multiline':False]
['text':' TODO: we need to figure out how to profile calls to custom functions','line_number':401,'multiline':False]
['text':' like this! Currently can't do it because the profiler stuff is in','line_number':402,'multiline':False]
['text':' libtorch and not ATen','line_number':403,'multiline':False]
['text':' Register the method here to keep the Method alive.','line_number':414,'multiline':False]
['text':' ClassTypes do not hold ownership of their methods (normally it','line_number':415,'multiline':False]
['text':' those are held by the CompilationUnit), so we need a proxy for','line_number':416,'multiline':False]
['text':' that behavior here.','line_number':417,'multiline':False]
['text':'/ make_custom_class() is a convenient way to create an instance of a','line_number':425,'multiline':False]
['text':'/ registered custom class and wrap it in an IValue, for example when you want','line_number':426,'multiline':False]
['text':'/ to pass the object to TorchScript. Its syntax is equivalent to APIs like','line_number':427,'multiline':False]
['text':'/ `std::make_shared<>` or `c10::make_intrusive<>`.','line_number':428,'multiline':False]
['text':'/','line_number':429,'multiline':False]
['text':'/ For example, if you have a custom C++ class that can be constructed from an','line_number':430,'multiline':False]
['text':'/ `int` and `std::string`, you might use this API like so:','line_number':431,'multiline':False]
['text':'/','line_number':432,'multiline':False]
['text':'/     IValue custom_class_iv = torch::make_custom_class<MyClass>(3,','line_number':433,'multiline':False]
['text':'/     "foobarbaz");','line_number':434,'multiline':False]
['text':' Alternative api for creating a torchbind class over torch::class_ this api is','line_number':442,'multiline':False]
['text':' preffered to prevent size regressions on Edge usecases. Must be used in','line_number':443,'multiline':False]
['text':' conjunction with TORCH_SELECTIVE_CLASS macro aka','line_number':444,'multiline':False]
['text':' selective_class<foo>("foo_namespace", TORCH_SELECTIVE_CLASS("foo"))','line_number':445,'multiline':False]
['text':' jit namespace for backward-compatibility','line_number':461,'multiline':False]
['text':' We previously defined everything in torch::jit but moved it out to','line_number':462,'multiline':False]
['text':' better reflect that these features are not limited only to TorchScript','line_number':463,'multiline':False]
['text':' namespace jit','line_number':471,'multiline':False]
['text':' namespace torch','line_number':515,'multiline':False]
