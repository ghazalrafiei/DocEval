['text':' Convert the n-dimensional list to a NumPy array','line_number':16,'multiline':False]
['text':' Create a dictionary to map each value to its coordinate','line_number':19,'multiline':False]
['text':' device is unique in device_mesh','line_number':22,'multiline':False]
['text':' Calculate row_range and column_range','line_number':38,'multiline':False]
['text':' Convert value to string to match your desired format','line_number':42,'multiline':False]
['text':' Extract unique row and column ranges','line_number':62,'multiline':False]
['text':' Create a matrix initialized with empty strings','line_number':66,'multiline':False]
['text':' Fill the matrix with values','line_number':69,'multiline':False]
['text':' Prepare headers','line_number':78,'multiline':False]
['text':' if rank not in the mesh, return empty offset','line_number':97,'multiline':False]
['text':' On a given dimension, if the local_offset[shard_dim] is smaller than global_offset[shard_dim],','line_number':121,'multiline':False]
['text':' it means that this dimension has been already sharded in previous placement.','line_number':122,'multiline':False]
['text':' Therefore, we cannot simply replace the global_offset[shard_dim] with local_offset[shard_dim].','line_number':123,'multiline':False]
['text':' Instead, for the given shard_dim, we need to add local_offset[shard_dim] to existing global_offset[shard_dim].','line_number':124,'multiline':False]
['text':' Convert offsets to blocks with row_ranges for tabulate','line_number':154,'multiline':False]
