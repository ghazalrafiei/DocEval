['text':' Randomize the data and run the traced graph with it, to catch bugs','line_number':33,'multiline':False]
['text':' where we may have baked in Tensor data into the trace.','line_number':34,'multiline':False]
['text':' This is not guaranteed to succeed, because `f` might have preconditions','line_number':35,'multiline':False]
['text':' on the values of the inputs, so we just ignore if we used','line_number':36,'multiline':False]
['text':' random data and it fails.','line_number':37,'multiline':False]
['text':' Arguably we should make make_fx promote torch.Size() objects to symbolic shapes.','line_number':50,'multiline':False]
['text':' Absent that, here is our strategy:','line_number':51,'multiline':False]
['text':'','line_number':52,'multiline':False]
['text':' If any argument is a torch.Size(), maybe get dynamic shapes for it by:','line_number':53,'multiline':False]
['text':' - Create a temporary Tensor whose size is the torch.Size() we want. Note that','line_number':54,'multiline':False]
['text':'   we use an expanded Tensor as we cannot pass "meta" Tensors to make_fx.','line_number':55,'multiline':False]
['text':' - Pass it to make_fx such that it is is converted to a proxy Tensor','line_number':56,'multiline':False]
['text':' - Unpack the size in the wrapper to get a torch.Size with dynamic shapes (in','line_number':57,'multiline':False]
['text':'   symbolic mode, a no-op otherwise)','line_number':58,'multiline':False]
