['text':' Some analysis of tolerance by logging tests from test_torch.py can be found in','line_number':59,'multiline':False]
['text':' https://github.com/pytorch/pytorch/pull/32538.','line_number':60,'multiline':False]
['text':' {dtype: (rtol, atol)}','line_number':61,'multiline':False]
['text':' The default tolerances of torch.float32 are used for quantized dtypes, because quantized tensors are compared in','line_number':71,'multiline':False]
['text':' their dequantized and floating point representation. For more details see `TensorLikePair._compare_quantized_values`','line_number':72,'multiline':False]
['text':' We require both tolerance to be omitted or specified, because specifying only one might lead to surprising','line_number':131,'multiline':False]
['text':' results. Imagine setting atol=0.0 and the tensors still match because rtol>0.0.','line_number':132,'multiline':False]
['text':' TODO: Instead of always upcasting to int64, it would be sufficient to cast to the next higher dtype to avoid','line_number':286,'multiline':False]
['text':'  overflow','line_number':287,'multiline':False]
['text':' Ensure that only mismatches are used for the max_abs_diff computation','line_number':292,'multiline':False]
['text':' Ensure that only mismatches are used for the max_rel_diff computation','line_number':297,'multiline':False]
['text':' noqa: B903','line_number':313,'multiline':False]
['text':' We are not using `self._raise_error_meta` here since we need the exception chaining','line_number':410,'multiline':False]
['text':' type: ignore[return-value]','line_number':573,'multiline':False]
['text':' The comparison logic uses operators currently not supported by the MPS backends.','line_number':791,'multiline':False]
['text':'  See https://github.com/pytorch/pytorch/issues/77144 for details.','line_number':792,'multiline':False]
['text':' TODO: Remove this conversion as soon as all operations are supported natively by the MPS backend','line_number':793,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':794,'multiline':False]
['text':' These checks are needed, since Tensor.to_dense() fails on tensors that are already strided','line_number':808,'multiline':False]
['text':' Compressed and plain indices in the CSR / CSC / BSR / BSC sparse formates can be `torch.int32` _or_','line_number':957,'multiline':False]
['text':' `torch.int64`. While the same dtype is enforced for the compressed and plain indices of a single tensor, it','line_number':958,'multiline':False]
['text':' can be different between two tensors. Thus, we need to convert them to the same dtype, or the comparison will','line_number':959,'multiline':False]
['text':' fail.','line_number':960,'multiline':False]
['text':' We explicitly exclude str's here since they are self-referential and would cause an infinite recursion loop:','line_number':1078,'multiline':False]
['text':' "a" == "a"[0][0]...','line_number':1079,'multiline':False]
['text':' Since the origination aborts after the first failure, we try to be deterministic','line_number':1127,'multiline':False]
['text':' Raising an `UnsupportedInputs` during origination indicates that the pair type is not able to handle the','line_number':1150,'multiline':False]
['text':' inputs. Thus, we try the next pair type.','line_number':1151,'multiline':False]
['text':' Raising an `ErrorMeta` during origination is the orderly way to abort and so we simply re-raise it. This','line_number':1154,'multiline':False]
['text':' is only in a separate branch, because the one below would also except it.','line_number':1155,'multiline':False]
['text':' Raising any other exception during origination is unexpected and will give some extra information about','line_number':1158,'multiline':False]
['text':' what happened. If applicable, the exception should be expected in the future.','line_number':1159,'multiline':False]
['text':' Hide this function from `pytest`'s traceback','line_number':1203,'multiline':False]
['text':' Explicitly raising from None to hide the internal traceback','line_number':1216,'multiline':False]
['text':' Raising any exception besides `ErrorMeta` while comparing is unexpected and will give some extra information','line_number':1225,'multiline':False]
['text':' about what happened. If applicable, the exception should be expected in the future.','line_number':1226,'multiline':False]
['text':' [ErrorMeta Cycles]','line_number':1238,'multiline':False]
['text':' ErrorMeta objects in this list capture','line_number':1239,'multiline':False]
['text':' tracebacks that refer to the frame of this function.','line_number':1240,'multiline':False]
['text':' The local variable `error_metas` refers to the error meta','line_number':1241,'multiline':False]
['text':' objects, creating a reference cycle. Frames in the traceback','line_number':1242,'multiline':False]
['text':' would not get freed until cycle collection, leaking cuda memory in tests.','line_number':1243,'multiline':False]
['text':' We break the cycle by removing the reference to the error_meta objects','line_number':1244,'multiline':False]
['text':' from this frame as it returns.','line_number':1245,'multiline':False]
['text':' Hide this function from `pytest`'s traceback','line_number':1495,'multiline':False]
['text':' TODO: compose all metas into one AssertionError','line_number':1519,'multiline':False]
