['text':' NB: The sym_* functions are used via getattr() and must be imported here.','line_number':34,'multiline':False]
['text':' type: ignore[has-type]','line_number':59,'multiline':False]
['text':' FX node metadata keys for symbolic shape FX graph.','line_number':70,'multiline':False]
['text':' These are modules that contain generic code for interacting with ShapeEnv','line_number':74,'multiline':False]
['text':' which are unlikely to identify a particular interesting guard statement','line_number':75,'multiline':False]
['text':' We don't bother with the metaclass as all of the dispatching logic happens','line_number':90,'multiline':False]
['text':' entirely from Python','line_number':91,'multiline':False]
['text':'','line_number':92,'multiline':False]
['text':' Didn't bother with ancestors for now, unlikely to have multiple modes for','line_number':93,'multiline':False]
['text':' symints right now','line_number':94,'multiline':False]
['text':' Canonicalise an inequality by transforming it into a lt / le','line_number':152,'multiline':False]
['text':' inequality and moving all the non-constant terms to the rhs','line_number':153,'multiline':False]
['text':' We canonicalise And / Ors / Not via cnf','line_number':154,'multiline':False]
['text':' nb. Relational.canonical in sympy is broken','line_number':155,'multiline':False]
['text':' https://github.com/sympy/sympy/issues/25924','line_number':156,'multiline':False]
['text':' check for SingletonSymNode','line_number':208,'multiline':False]
['text':' check for symbolic variable wrapping a SingletonSymNode (fake-ifying causes this)','line_number':214,'multiline':False]
['text':' This allow applies to the jagged layout NestedTensor case as','line_number':224,'multiline':False]
['text':' singleton ints are not symbolic','line_number':225,'multiline':False]
['text':' we need at least 1 to call union, so we hand code the identity','line_number':244,'multiline':False]
['text':' Like free_symbols, but filtered to only report unbacked symbols','line_number':256,'multiline':False]
['text':' NB: keep synced with is_unbacked_symint','line_number':258,'multiline':False]
['text':' WARNING: Don't use this on Dynamo produced graphs, they don't have meta','line_number':261,'multiline':False]
['text':' setup!','line_number':262,'multiline':False]
['text':' TODO: could improve parallel_or/parallel_and by avoiding guards','line_number':321,'multiline':False]
['text':' if there exists a quantity that can be handled un-guardedly.  However,','line_number':322,'multiline':False]
['text':' for backed SymInts, avoiding guards doesn't really matter in practice,','line_number':323,'multiline':False]
['text':' so I chose not to do it.','line_number':324,'multiline':False]
['text':' This must always succeed, because the sole allowed caller _check_is_size','line_number':410,'multiline':False]
['text':' was responsible for expect_true'ing this','line_number':411,'multiline':False]
['text':' NB: it's important not to constrain range for size for *hinted* SymInts,','line_number':414,'multiline':False]
['text':' because it is not only unsound, it will immediately trip our asserts','line_number':415,'multiline':False]
['text':' that hints have to be consistent with static analysis!  If you somehow','line_number':416,'multiline':False]
['text':' have an unbounded SymInt that later constrains to 1, this will be','line_number':417,'multiline':False]
['text':' inconsistent with the range','line_number':418,'multiline':False]
['text':' inclusive both ways','line_number':465,'multiline':False]
['text':' TODO: Shouldn't we install a guard if the symbol is backed?  Or is the','line_number':522,'multiline':False]
['text':' semantics that this is an "unchecked" assert (but it this actually','line_number':523,'multiline':False]
['text':' something useful?  Might be better to restrict only for unbacked','line_number':524,'multiline':False]
['text':' SymInt).','line_number':525,'multiline':False]
['text':' TODO: Maybe dedupe this with _maybe_guard_eq?','line_number':543,'multiline':False]
['text':' TODO: Actually, we can support this as long as one of them is a symbol.','line_number':552,'multiline':False]
['text':' NB: We can't actually do "unification" as our operators are not','line_number':553,'multiline':False]
['text':' injective','line_number':554,'multiline':False]
['text':' Assume that a boolean is true for the purposes of subsequent symbolic','line_number':565,'multiline':False]
['text':' reasoning.  This will keep track of corresponding runtime checks to verify','line_number':566,'multiline':False]
['text':' that the result is upheld: either as a regular guard, or as a special set','line_number':567,'multiline':False]
['text':' of asserts which are triggered when an unbacked SymInt is allocated.','line_number':568,'multiline':False]
['text':'','line_number':569,'multiline':False]
['text':' DO NOT use this function for these cases:','line_number':570,'multiline':False]
['text':'','line_number':571,'multiline':False]
['text':'  - This is inappropriate for "branching" conditions (where both','line_number':572,'multiline':False]
['text':'    true and false result in valid programs).  We will always assume','line_number':573,'multiline':False]
['text':'    the condition evaluates true, and so it will never be possible','line_number':574,'multiline':False]
['text':'    to trace the false condition when you use it.  For true branching','line_number':575,'multiline':False]
['text':'    on unbacked SymInts, you must use torch.cond; if you incorrectly','line_number':576,'multiline':False]
['text':'    use expect_true in this case, you will make the false branch','line_number':577,'multiline':False]
['text':'    unreachable (as we will simply assume that only the true branch','line_number':578,'multiline':False]
['text':'    is ever exercised).','line_number':579,'multiline':False]
['text':'','line_number':580,'multiline':False]
['text':'  - This is inappropriate for situations where you know some other system','line_number':581,'multiline':False]
['text':'    invariant guarantees that this property holds, since you don't','line_number':582,'multiline':False]
['text':'    really need to insert a runtime check in that case.  Use something','line_number':583,'multiline':False]
['text':'    like constrain_range in that case.','line_number':584,'multiline':False]
['text':'','line_number':585,'multiline':False]
['text':' This API has a hitch.  To avoid having to reimplement error reporting','line_number':586,'multiline':False]
['text':' capabilities, this function CAN return False.  The invariant is that','line_number':587,'multiline':False]
['text':' the surrounding code must raise an error when this function returns','line_number':588,'multiline':False]
['text':' False.  This is quite low level, so we recommend using other functions','line_number':589,'multiline':False]
['text':' like check() which enforce this in a more intuitive way.','line_number':590,'multiline':False]
['text':'','line_number':591,'multiline':False]
['text':' By the way, this name is a nod to the __builtin_expect macro,','line_number':592,'multiline':False]
['text':' which is used similarly (but unlike __builtin_expect, you MUST fail','line_number':593,'multiline':False]
['text':' in the unlikely branch.)  (I think expect is a good name; in recent','line_number':594,'multiline':False]
['text':' versions of C++, this is replaced with [[likely]], which is weaker','line_number':595,'multiline':False]
['text':' and not accurate for this function!)','line_number':596,'multiline':False]
['text':' TODO: check perf implications of this','line_number':599,'multiline':False]
['text':' always run this loop at least once','line_number':601,'multiline':False]
['text':' NB: uses Python backtrace','line_number':609,'multiline':False]
['text':' NB: uses Python backtrace','line_number':615,'multiline':False]
['text':' NB: uses Python backtrace','line_number':621,'multiline':False]
['text':' Given a GraphModule, return all the FakeTensors for all the placeholders','line_number':625,'multiline':False]
['text':' Given a GraphModule and arguments to run it with, evaluate that the guards','line_number':632,'multiline':False]
['text':' for its associated ShapeEnv are satisfied by the passed arguments.  This','line_number':633,'multiline':False]
['text':' WILL check for duck sizing.','line_number':634,'multiline':False]
['text':' Treat the dimension symbolically','line_number':671,'multiline':False]
['text':' Treat the dimension symbolically, but if its hint matches another','line_number':673,'multiline':False]
['text':' dynamic dimension, unify the two symbols ("duck sizing")','line_number':674,'multiline':False]
['text':' Treat the dimension statically based on its hint','line_number':676,'multiline':False]
['text':' NB: These constraints affect both clients and backends: given some','line_number':680,'multiline':False]
['text':' constraint C, the client must pass inputs that satisfy the constraint,','line_number':681,'multiline':False]
['text':' while a backend must not introduce guards BEYOND this constraint.','line_number':682,'multiline':False]
['text':' For clarity, we document the implications on both sides for both the client','line_number':683,'multiline':False]
['text':' and the backend.','line_number':684,'multiline':False]
['text':'','line_number':685,'multiline':False]
['text':' NB: These constraints are on a *single* dimension.  In principle, we could','line_number':686,'multiline':False]
['text':' also have multi-dimension constraints, but our guess is that this is not','line_number':687,'multiline':False]
['text':' actually useful and so we are not supporting it right now.','line_number':688,'multiline':False]
['text':'','line_number':689,'multiline':False]
['text':' NB: Strict constraints are typically only suitable for export, as in eager','line_number':690,'multiline':False]
['text':' a backend like inductor may validly introduce extra, discretionary guards','line_number':691,'multiline':False]
['text':' to improve performance of code.  A StrictMinMaxConstraint would be brittle','line_number':692,'multiline':False]
['text':' under future optimizations performed by inductor; we don't guarantee','line_number':693,'multiline':False]
['text':' eager code with StrictMinMaxConstraint will keep working in the future!','line_number':694,'multiline':False]
['text':' TODO: better printing for -oo and oo','line_number':723,'multiline':False]
['text':' NB: None here indicates the client constraint is whatever is implicitly','line_number':749,'multiline':False]
['text':' inferred by guards from tracing, and that a backend can add whatever guards','line_number':750,'multiline':False]
['text':' it wants (including fully specializing the value).','line_number':751,'multiline':False]
['text':' TODO: add storage offset and stride symbolic_context','line_number':817,'multiline':False]
['text':' note [Tensor Fakification and Symbol Caching]','line_number':824,'multiline':False]
['text':'','line_number':825,'multiline':False]
['text':' As of the time of this note, dynamo creates a fresh fake tensor mode for backends.','line_number':826,'multiline':False]
['text':' The reason we do this is because there are certain classes of operations, namely,','line_number':827,'multiline':False]
['text':' metadata mutations, that change tensor size, stride, etc. This means that the fake tensor','line_number':828,'multiline':False]
['text':' state at the end of a dynamo trace is different than the fake tensor state at the beginning','line_number':829,'multiline':False]
['text':' of a trace. Backends like aot_autograd need a fresh fake tensor to correctly track metadata mutation,','line_number':830,'multiline':False]
['text':' view relationships, etc.','line_number':831,'multiline':False]
['text':'','line_number':832,'multiline':False]
['text':' As we create a new fake mode, we also lose the memoization that comes with it. Rather than','line_number':833,'multiline':False]
['text':' transfer the memoization cache, we instead transfer the shape env. However, with this','line_number':834,'multiline':False]
['text':' comes nuance - as dynamo is selective in how it makes symbolic shapes. Due to strategies in','line_number':835,'multiline':False]
['text':' automatic dynamic and constraints, the policy for which dims are dynamic is nuanced and varies across','line_number':836,'multiline':False]
['text':' recompilations.','line_number':837,'multiline':False]
['text':'','line_number':838,'multiline':False]
['text':' In order to preserve the symbolic decisions made during dynamo tensor fakification, we pass','line_number':839,'multiline':False]
['text':' a StatefulSymbolicContext at creation time. This object is tracked, per tensor, on the TracingContext.','line_number':840,'multiline':False]
['text':' The lifecycle of this object should match the lifecycle of the original dynamo tracked tensor, and it is','line_number':841,'multiline':False]
['text':' safe to reuse this object as many times as necessary to create a fake tensor. Fake tensors','line_number':842,'multiline':False]
['text':' created with new fake modes should produce the same exact symbols as the original, providing the same shape_env','line_number':843,'multiline':False]
['text':' is used.','line_number':844,'multiline':False]
['text':' TODO(voz): Shape env validation','line_number':845,'multiline':False]
['text':' Why is this keyd on int first?','line_number':861,'multiline':False]
['text':' That integer is actually the id of the shape_env. This cache short-circuits symbol','line_number':862,'multiline':False]
['text':' creation, and we must store it per shape env. Now, while tracing invariants are a single','line_number':863,'multiline':False]
['text':' shape env per tracing context, and every new frame gets a new shape_env. So where would we have','line_number':864,'multiline':False]
['text':' multiple shape envs? The answer lies in recording. When we are replaying, replay_shape_env_events','line_number':865,'multiline':False]
['text':' is invoked, and creates a new shape_env. Replaying events against this new shape_env will','line_number':866,'multiline':False]
['text':' cause it to fail with unknown symbols, as the symbols cached here will skip creation, and never','line_number':867,'multiline':False]
['text':' get recorded in var_to_val, etc.','line_number':868,'multiline':False]
['text':' TODO(voz): consider a weakref to the shape_env here','line_number':869,'multiline':False]
['text':' The None default is annoying, but required because of dataclass limitations','line_number':873,'multiline':False]
['text':' TODO: Deduplicate this with torch/_prims_common/__init__.py','line_number':915,'multiline':False]
['text':' Short-circuits for tensors of rank one, which are','line_number':922,'multiline':False]
['text':' non-overlapping and "dense" if their stride is one','line_number':923,'multiline':False]
['text':' or it is a 0/1 element tensor','line_number':924,'multiline':False]
['text':' Checks that there exists a permutation of the strides s.t. the tensor would be contiguous','line_number':928,'multiline':False]
['text':' Sorts (length, stride) pairs by stride','line_number':929,'multiline':False]
['text':' Unlike the C++ code, we don't move the 0/1 size dimensions to the','line_number':934,'multiline':False]
['text':' end.  So we have to keep going for this code.','line_number':935,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':1022,'multiline':False]
['text':' This is pretty similar to ShapeGuard but it also comes with a message,','line_number':1026,'multiline':False]
['text':' and is exclusively used for things that MUST be true (unlike guards,','line_number':1027,'multiline':False]
['text':' which can evaluate False, in which case you just choose not to use','line_number':1028,'multiline':False]
['text':' a particular specialization)','line_number':1029,'multiline':False]
['text':' We try to solve systems of inequalities with 1 free variable.','line_number':1118,'multiline':False]
['text':' Among them, we prioritize solving for a free variable that has equalities.','line_number':1120,'multiline':False]
['text':' NOTE: _symbols_with_equalities is always a subset of _univariate_inequalities.keys()','line_number':1121,'multiline':False]
['text':' and removing a symbol from the former => removing it from the latter.','line_number':1122,'multiline':False]
['text':' A solution of a free variable with equalities becomes a substitution.','line_number':1124,'multiline':False]
['text':' We use these substitutions to simplify other constraints.','line_number':1125,'multiline':False]
['text':' NOTE: removing a symbol from _symbols_with_equalities => adding it to _substitutions.','line_number':1126,'multiline':False]
['text':' In general, constraints may have // and % operations.','line_number':1129,'multiline':False]
['text':' Of course, // can be expressed in terms of / and %.','line_number':1130,'multiline':False]
['text':' Our inequality solver can handle / but not %. So we need to transform them away.','line_number':1131,'multiline':False]
['text':' We do so by using the values of variables as hints to evaluate %.','line_number':1132,'multiline':False]
['text':' For soundness we record additional congruence guards and solve them separately.','line_number':1133,'multiline':False]
['text':' We do not try to (directly) solve inequalities with > 1 free variables.','line_number':1137,'multiline':False]
['text':' NOTE: free variables in these inequalities cannot also be in _substitutions.','line_number':1138,'multiline':False]
['text':' We park external equalities between free variables here.','line_number':1141,'multiline':False]
['text':' Solutions come in two forms:','line_number':1144,'multiline':False]
['text':' - (static) specializations','line_number':1145,'multiline':False]
['text':' - (dynamic) inequalities / congruences','line_number':1146,'multiline':False]
['text':' printer for solutions','line_number':1150,'multiline':False]
['text':' inconsistencies found on substituting with concrete values / static solutions','line_number':1153,'multiline':False]
['text':' symbols that are marked dynamic','line_number':1156,'multiline':False]
['text':' Suppose that we have an expression of the form b % d with free variable s.','line_number':1166,'multiline':False]
['text':' Using the value of s as a "hint," we can evaluate b % d to a value k.','line_number':1167,'multiline':False]
['text':' Then we can rewrite b % d to k while adding the guard b % d == k.','line_number':1168,'multiline':False]
['text':' NOTE(avik): This abstraction is provably sound but, in general, incomplete. It is complete IFF','line_number':1170,'multiline':False]
['text':' the original expression always evaluates to a constant value (i.e., it does not vary with s).','line_number':1171,'multiline':False]
['text':' In other words,','line_number':1172,'multiline':False]
['text':' - solutions of s with the rewritten expression are guaranteed to also be solutions of s with','line_number':1173,'multiline':False]
['text':'   the original expression;','line_number':1174,'multiline':False]
['text':' - while it may be possible to find solutions of s with the original expression that are not','line_number':1175,'multiline':False]
['text':'   solutions with the rewritten expression, in that case the original expression cannot evaluate','line_number':1176,'multiline':False]
['text':'   to the same value for all solutions of s.','line_number':1177,'multiline':False]
['text':'','line_number':1178,'multiline':False]
['text':' Should we be worried about this incompleteness? No, because of the following reasons:','line_number':1179,'multiline':False]
['text':' 1. It unblocks dramatic simplification that would not be otherwise possible with current tech','line_number':1180,'multiline':False]
['text':'    (i.e., "don't let perfect be the enemy of the good").','line_number':1181,'multiline':False]
['text':' 2. We already have a tradition of using hints to add guards in the compiler for making progress.','line_number':1182,'multiline':False]
['text':' 3. We have not yet seen a counterexample arise in practice! In particular, any congruence guards','line_number':1183,'multiline':False]
['text':'    we generate (or simplify to) seem to be of the form b % d == k where k is a constant.','line_number':1184,'multiline':False]
['text':'','line_number':1185,'multiline':False]
['text':' Here's a theoretical counterexample: 3*s % (s + 1) == s - 2, that is satisfied by all s >= 2.','line_number':1186,'multiline':False]
['text':' With any hint (say) s = k, we'd rewrite this to: 3*s % (s + 1) == k - 2. But, substituting, we','line_number':1187,'multiline':False]
['text':' would then get k - 2 == s - 2, and thus s = k as the (only, constant) solution!','line_number':1188,'multiline':False]
['text':' Suppose that we have an expression of the form b // d with free variable s.','line_number':1198,'multiline':False]
['text':' Using the value of s, we can evaluate b % d to a value k.','line_number':1199,'multiline':False]
['text':' Then we can rewrite b // d to (b - k) / d, while adding the guard b % d == k.','line_number':1200,'multiline':False]
['text':' NOTE(avik): This is exactly equivalent to rewriting b // d as (b - (b % d)) / d','line_number':1202,'multiline':False]
['text':' and eliminating b % d as above.','line_number':1203,'multiline':False]
['text':' Add an expression to the set of constraints.','line_number':1219,'multiline':False]
['text':' Return whether the expression is a trivial constraint (i.e., an obvious tautology).','line_number':1220,'multiline':False]
['text':' TODO(avik): https://github.com/pytorch/pytorch/issues/101093','line_number':1225,'multiline':False]
['text':' It is possible that `expr` will fail the consistency check because of','line_number':1226,'multiline':False]
['text':' precision errors. Specifically, on substituting its free symbols with','line_number':1227,'multiline':False]
['text':' their concrete values, we might end up comparing floats. Until we have','line_number':1228,'multiline':False]
['text':' a fix for this issue, we delay raising such failures. See solve().','line_number':1229,'multiline':False]
['text':' multivariate: record and move on','line_number':1235,'multiline':False]
['text':' univariate: can solve these immediately','line_number':1238,'multiline':False]
['text':' eliminate // and % (see documentation of `rewrite_with_congruences` above)','line_number':1240,'multiline':False]
['text':' special status for symbols that have equalities (see `solve` below)','line_number':1251,'multiline':False]
['text':' specialization, right here','line_number':1258,'multiline':False]
['text':' these will resolve to either specializations or dynamic equality constraints','line_number':1261,'multiline':False]
['text':' We are given a congruence of the form base % divisor == 0 with a free variable s. So:','line_number':1271,'multiline':False]
['text':' - we transform this into an equation of the form base = divisor * tmp;','line_number':1272,'multiline':False]
['text':' - we solve this equation for s to get a linear solution with free variable tmp.','line_number':1273,'multiline':False]
['text':' See https://docs.sympy.org/latest/modules/solvers/solvers.html#sympy.solvers.solvers.solve_linear','line_number':1276,'multiline':False]
['text':' for how to interpret the results.','line_number':1277,'multiline':False]
['text':' This means the solution is of the form s = modulus*tmp + remainder.','line_number':1279,'multiline':False]
['text':' Make sure 0 <= remainder <= modulus.','line_number':1282,'multiline':False]
['text':' This means that we did not get a unique solution to the equation.','line_number':1286,'multiline':False]
['text':' No problem, we will check it.','line_number':1287,'multiline':False]
['text':' Finally we solve for a congruence s such that s = r_i mod m_i for each (r_i, m_i).','line_number':1289,'multiline':False]
['text':' The solution will be a congruence of the form s = r mod m.','line_number':1290,'multiline':False]
['text':' NOTE(avik): Since the given m_i may not be pairwise coprime, we can't just use CRT.','line_number':1291,'multiline':False]
['text':' as long as there are symbols with equalities, solve for them','line_number':1341,'multiline':False]
['text':' NOTE(avik): this is guaranteed to terminate (#iterations <= #symbols)','line_number':1342,'multiline':False]
['text':' because this is univariate, the solution is a specialization','line_number':1352,'multiline':False]
['text':' add this as a substitution to simplify other constraints','line_number':1354,'multiline':False]
['text':' simplify multivariate inequalities: some of them will now become univariate!','line_number':1357,'multiline':False]
['text':' solve linear congruences','line_number':1366,'multiline':False]
['text':' NOTE(avik): We do not need to solve them for symbols that have already been specialized.','line_number':1367,'multiline':False]
['text':' any congruence that cannot be checked becomes a dynamic constraint as well','line_number':1371,'multiline':False]
['text':' remaining symbols have only pure inequalities (no equalities)','line_number':1379,'multiline':False]
['text':' because this is univariate, the solution is a dynamic (range) constraint','line_number':1383,'multiline':False]
['text':' simplify symbolic equivalences: some of them will now become specializations!','line_number':1394,'multiline':False]
['text':' remaining symbolic equivalences become dynamic equality constraints','line_number':1405,'multiline':False]
['text':' Instead of 2 <= dynamic_dim(...) simply suggest dynamic_dim(...).','line_number':1427,'multiline':False]
['text':' There is no change in behavior since 2 is the default lower bound.','line_number':1428,'multiline':False]
['text':' remove dynamic_dim(t, 0) as a constraint when dynamic_dim(t, 0) also','line_number':1435,'multiline':False]
['text':' appears as part of another constraint','line_number':1436,'multiline':False]
['text':' Note: Model inputs are wrapped as LocalSource in dynamo.','line_number':1546,'multiline':False]
['text':' LocalSource.name() wraps the name with L[""]. We use regular','line_number':1547,'multiline':False]
['text':' expression to do the replacement to avoid traversing up','line_number':1548,'multiline':False]
['text':' the source hierarchy manually.','line_number':1549,'multiline':False]
['text':' This can happen, e.g., with `assume_constant_result`.','line_number':1563,'multiline':False]
['text':' In that case, we drop the constraint.','line_number':1564,'multiline':False]
['text':' TODO(avik) Maybe we should generate an assertion here?','line_number':1565,'multiline':False]
['text':' This can happen, e.g., with decorators that change the signature.','line_number':1571,'multiline':False]
['text':' In that case, we drop the constraint. Seems hard to do better. :/','line_number':1572,'multiline':False]
['text':' TODO(avik) Maybe warn that `arg` in not in `signature`?','line_number':1573,'multiline':False]
['text':' This is a wrapper over the actual __init__ function.','line_number':1638,'multiline':False]
['text':'','line_number':1639,'multiline':False]
['text':' Where to add a new constructor parameter to ShapeEnv?','line_number':1640,'multiline':False]
['text':' =====================================================','line_number':1641,'multiline':False]
['text':' This __init__ function should be used only for parameters related to event recording.','line_number':1642,'multiline':False]
['text':' These are parameters that we don't wish to pass down the road to new ShapeEnv instances','line_number':1643,'multiline':False]
['text':' created from replaying events.','line_number':1644,'multiline':False]
['text':'','line_number':1645,'multiline':False]
['text':' If you wish to add a parameter to the constructor of ShapeEnv, unrelated to event','line_number':1646,'multiline':False]
['text':' recording, do so in the _init function.','line_number':1647,'multiline':False]
['text':' Disable event recording when replaying.','line_number':1656,'multiline':False]
['text':' If not specified, enable event recording if both:','line_number':1662,'multiline':False]
['text':'   - Translation validation is on','line_number':1663,'multiline':False]
['text':'   - Translation validation bisection is not disabled','line_number':1664,'multiline':False]
['text':' Enable event recording check if both:','line_number':1674,'multiline':False]
['text':'   - It should record events','line_number':1675,'multiline':False]
['text':'   - The recording check is enabled','line_number':1676,'multiline':False]
['text':' This will make sure we only record the top-level function call.','line_number':1681,'multiline':False]
['text':' Keep track of the list of tracked fakes.','line_number':1683,'multiline':False]
['text':' List of events for reconstructing ShapeEnv at arbitrary points in time.','line_number':1685,'multiline':False]
['text':' NB: These are legacy configuration that help us make good choices','line_number':1694,'multiline':False]
['text':' when the constraint/dynamic dims are not explicitly passed to us.','line_number':1695,'multiline':False]
['text':' Ideally we will fix all call sites to be explicit and not have','line_number':1696,'multiline':False]
['text':' implicit choices, but this apparently was pretty involved.','line_number':1697,'multiline':False]
['text':' Note - On 0/1 specialization','line_number':1699,'multiline':False]
['text':'','line_number':1700,'multiline':False]
['text':' The following options affect decisions we make about eager','line_number':1701,'multiline':False]
['text':' specialization.  Disabling them will increase trace time (as we do','line_number':1702,'multiline':False]
['text':' more symbolic reasoning) and can also harm the quality of generated','line_number':1703,'multiline':False]
['text':' code (because inductor may not be able to specialize for bounds','line_number':1704,'multiline':False]
['text':' being equal--although if we later respecialize because of a guard,','line_number':1705,'multiline':False]
['text':' your code may be just as good as it was before.)','line_number':1706,'multiline':False]
['text':'','line_number':1707,'multiline':False]
['text':' When True, eagerly specialize input sizes which have 0/1.','line_number':1708,'multiline':False]
['text':' When True, assume input sizes which have the same size are','line_number':1710,'multiline':False]
['text':' symbolically equal.','line_number':1711,'multiline':False]
['text':' For debugging','line_number':1713,'multiline':False]
['text':' Not directly used by ShapeEnv; indirectly used by FakeTensor','line_number':1716,'multiline':False]
['text':' Maps symbolic ints to their original concrete values','line_number':1720,'multiline':False]
['text':' Currently populated from tensors','line_number':1721,'multiline':False]
['text':' Maps symbolic ints to their min/max range.  These ranges','line_number':1723,'multiline':False]
['text':' are conservative: the int MUST fall in the range, but the','line_number':1724,'multiline':False]
['text':' range may contain ints which may not actually appear in','line_number':1725,'multiline':False]
['text':' practice','line_number':1726,'multiline':False]
['text':' Maps symbolic ints to their min/max range for runtime checks.','line_number':1729,'multiline':False]
['text':' This is because we assume a graph generated with N=2 is general enough','line_number':1730,'multiline':False]
['text':' for N < 2. Therefore, it will be too strict to assert N=2 at runtime.','line_number':1731,'multiline':False]
['text':' Maps symbolic ints to the guards that refine their lower/upper','line_number':1735,'multiline':False]
['text':' bound. If one of them is None, it means that there are no guards','line_number':1736,'multiline':False]
['text':' that refine that respective bound.','line_number':1737,'multiline':False]
['text':' Maps from sympy ints to expressions representing them','line_number':1739,'multiline':False]
['text':' Populated from equality guards (i.e. a.shape[0] == b.shape[0])','line_number':1740,'multiline':False]
['text':'','line_number':1741,'multiline':False]
['text':' Set holds a % b expressions that evaluate to 0.','line_number':1742,'multiline':False]
['text':' Duck-shaping says that if two input tensors have the same size,','line_number':1744,'multiline':False]
['text':' they get assigned the same symbolic variable','line_number':1745,'multiline':False]
['text':' Similar to guards, but these MUST evaluate to true and can','line_number':1751,'multiline':False]
['text':' only be evaluated at runtime midway through (i.e., they always','line_number':1752,'multiline':False]
['text':' involve unbacked symints)','line_number':1753,'multiline':False]
['text':'','line_number':1754,'multiline':False]
['text':' For efficiency reasons, we index in the following way.  Suppose you have','line_number':1755,'multiline':False]
['text':' a runtime assert i0 + i1 <= s1.  We pick the most recently allocated','line_number':1756,'multiline':False]
['text':' symbol in the source expression and add the assert to the list for','line_number':1757,'multiline':False]
['text':' that symbol e.g., {i1: [i0 + i1 <= s1]}.','line_number':1758,'multiline':False]
['text':'','line_number':1759,'multiline':False]
['text':' We access the runtime asserts in two situations:','line_number':1760,'multiline':False]
['text':'','line_number':1761,'multiline':False]
['text':'   - When we are guarding on an expression, we will attempt to','line_number':1762,'multiline':False]
['text':'     statically evaluate it, in case the unbacked SymInts can','line_number':1763,'multiline':False]
['text':'     simplify away.  If we have a runtime assert, we may be able','line_number':1764,'multiline':False]
['text':'     to discharge the guard entirely.  We only need to attempt','line_number':1765,'multiline':False]
['text':'     runtime asserts that mention freevars of the expression in','line_number':1766,'multiline':False]
['text':'     question.','line_number':1767,'multiline':False]
['text':'','line_number':1768,'multiline':False]
['text':'   - When we are performing codegen (in Inductor for eager, or','line_number':1769,'multiline':False]
['text':'     when finalizing the export FX graph), we need to know what','line_number':1770,'multiline':False]
['text':'     extra runtime asserts to insert.  Whenever an unbacked','line_number':1771,'multiline':False]
['text':'     SymInt comes into scope, all runtime asserts involving it','line_number':1772,'multiline':False]
['text':'     become eligible for insertion (so long as all of their other','line_number':1773,'multiline':False]
['text':'     free unbacked symbols are also in scope).  We technically','line_number':1774,'multiline':False]
['text':'     can handle any choice of key by kicking inexpressible asserts','line_number':1775,'multiline':False]
['text':'     to the next unbacked symbol to wait on, but if we choose the','line_number':1776,'multiline':False]
['text':'     latest key, an assert will only show up at the moment when','line_number':1777,'multiline':False]
['text':'     we can actually codegen it.','line_number':1778,'multiline':False]
['text':' This exists so we can efficiently invalidate the cache (it's used as','line_number':1780,'multiline':False]
['text':' part of the cache key); otherwise we'd have to iterate through','line_number':1781,'multiline':False]
['text':' deferred_runtime_asserts to compute its length','line_number':1782,'multiline':False]
['text':' A selection of important fields on co_field; solely used for','line_number':1792,'multiline':False]
['text':' signpost_event','line_number':1793,'multiline':False]
['text':' Version counter used to invalidate cached values','line_number':1796,'multiline':False]
['text':' Cache for FX nodes.','line_number':1800,'multiline':False]
['text':' Maps an already built node a tuple of:','line_number':1801,'multiline':False]
['text':'   1. node's target','line_number':1802,'multiline':False]
['text':'   2. list of arguments','line_number':1803,'multiline':False]
['text':' This drastically reduces the size of the FX graph, avoiding','line_number':1804,'multiline':False]
['text':' duplicated nodes.','line_number':1805,'multiline':False]
['text':' Create an output graph and start inserting before that.','line_number':1817,'multiline':False]
['text':' This is needed when 'deepcopy'-ing this object.','line_number':1818,'multiline':False]
['text':' Mapping of each node name to the node itself.','line_number':1821,'multiline':False]
['text':'','line_number':1822,'multiline':False]
['text':' This is useful for matching an FX node from a recorded ShapeEnv.graph','line_number':1823,'multiline':False]
['text':' to the FX node of the ShapeEnv we are running the event on.','line_number':1824,'multiline':False]
['text':'','line_number':1825,'multiline':False]
['text':' Whenever you add a node to self.graph, you must add a mapping to this','line_number':1826,'multiline':False]
['text':' variable. Otherwise, the built FX graph on the replayed ShapeEnv will','line_number':1827,'multiline':False]
['text':' not be valid.','line_number':1828,'multiline':False]
['text':' ShapeEnv fields that are not relevant for the outcome of','line_number':1832,'multiline':False]
['text':' ShapeEnv.produce_guards call:','line_number':1833,'multiline':False]
['text':'   - Debugging variables','line_number':1834,'multiline':False]
['text':'   - Translation validation related variables','line_number':1835,'multiline':False]
['text':'   - Events recording related variables','line_number':1836,'multiline':False]
['text':' Mapping of the value of each to-be-compared field into the values that','line_number':1854,'multiline':False]
['text':' should actually be compared.','line_number':1855,'multiline':False]
['text':'','line_number':1856,'multiline':False]
['text':' You should modify this if, for example, the field that holds state and','line_number':1857,'multiline':False]
['text':' debugging information. e.g. ShapeGuard holds the actual guard (sympy.Expr)','line_number':1858,'multiline':False]
['text':' and the stack when it was added to the set of guards. In order to compare','line_number':1859,'multiline':False]
['text':' it, we throw away the stack information.','line_number':1860,'multiline':False]
['text':' For itertools.count(), we compare the next integer returned','line_number':1865,'multiline':False]
['text':' by the count iterators. Not that we need to copy the iterator','line_number':1866,'multiline':False]
['text':' first. Otherwise we are mutating the object.','line_number':1867,'multiline':False]
['text':' Transform the list of ShapeGuard into a list of expressions.','line_number':1870,'multiline':False]
['text':' Transform the tuple of optional ShapeGuards of each entry into','line_number':1873,'multiline':False]
['text':' a tuple of optional expressions.','line_number':1874,'multiline':False]
['text':' Transform the list of RuntimeAsserts into a list of expressions.','line_number':1883,'multiline':False]
['text':' Compare just the set of keys is the same.','line_number':1886,'multiline':False]
['text':' Even though TrackedFake accepts either a Union[SymInt, FakeTensor], here we give it a','line_number':1902,'multiline':False]
['text':' FakeTensorMeta for two reasons:','line_number':1903,'multiline':False]
['text':'   1. this is all the information we need when recording ShapeEnvEvents.','line_number':1904,'multiline':False]
['text':'   2. it works even if each TrackedFake changes its metadata.','line_number':1905,'multiline':False]
['text':' type: ignore[arg-type]','line_number':1906,'multiline':False]
['text':' Cache this tuple in order to avoid duplicated nodes.','line_number':1961,'multiline':False]
['text':' Flags whether the returned node was cached or not.','line_number':1963,'multiline':False]
['text':' Presence of None in the arguments implies that we should ignore this operation.','line_number':1969,'multiline':False]
['text':' We check if we are not mixing SymNode that should not be ignored','line_number':1971,'multiline':False]
['text':' (fx_node is not None) with those that should (fx_node is None).','line_number':1972,'multiline':False]
['text':' If translation validation is enabled, all arguments must have its','line_number':1979,'multiline':False]
['text':' own FX node.','line_number':1980,'multiline':False]
['text':' Check if we haven't added this symbol already.','line_number':1997,'multiline':False]
['text':' If so, skip the placeholder creation, as it','line_number':1998,'multiline':False]
['text':' generates invalid Python code.','line_number':1999,'multiline':False]
['text':' Add a Z3 variable according to 'type'.','line_number':2001,'multiline':False]
['text':' Create the FX placeholder out of a mangled name.','line_number':2003,'multiline':False]
['text':' Attach the 'symbol' to the placeholder so that we can retrieve','line_number':2007,'multiline':False]
['text':' the Z3 variable later.','line_number':2008,'multiline':False]
['text':' The shape environment is queried orders of magnitude more often than','line_number':2052,'multiline':False]
['text':' it is changed, so we summarise the cache key into a linearly','line_number':2053,'multiline':False]
['text':' increasing version counter which is cheaper to check in _lru_cache','line_number':2054,'multiline':False]
['text':' Only update version counter if the state actually changed','line_number':2056,'multiline':False]
['text':' Dynamo may want to wrap FakeTensors with SymInt sizes up e.g. make_fx(opt_f(), tracing_mode="symbolic").','line_number':2103,'multiline':False]
['text':' We create symbols in shape_env using the backed hints behind SymInt.','line_number':2104,'multiline':False]
['text':' Case 1: when SymInt is backed, dynamo can proceed with FakeTensors that have concrete shape.','line_number':2106,'multiline':False]
['text':' produce_guards will trigger specializations on the outer stuff','line_number':2107,'multiline':False]
['text':' Case 2: when the SymInt is unbacked, we will throw an data dependent error in require_hint().','line_number':2109,'multiline':False]
['text':'','line_number':2110,'multiline':False]
['text':' It's probably good for now but it's important to note that this approach has implications for','line_number':2111,'multiline':False]
['text':' the original shape_env when checking guards in different order.','line_number':2112,'multiline':False]
['text':' Example:','line_number':2114,'multiline':False]
['text':' ---------','line_number':2115,'multiline':False]
['text':' Consider a function "opt_f" as shown below:','line_number':2116,'multiline':False]
['text':' @torch.compile()','line_number':2118,'multiline':False]
['text':' def opt_f(x: bool, y: Tensor):','line_number':2119,'multiline':False]
['text':'   if x == True:','line_number':2120,'multiline':False]
['text':'     return y + torch.randn([4])','line_number':2121,'multiline':False]
['text':'   else:','line_number':2122,'multiline':False]
['text':'     return y','line_number':2123,'multiline':False]
['text':' Depending on the sequence of calls, we might install two different sets of guards:','line_number':2124,'multiline':False]
['text':' 1. opt_f(False, y):','line_number':2126,'multiline':False]
['text':'    - "x == False" (always works for any size y)','line_number':2127,'multiline':False]
['text':' 2. opt_f(True, y):','line_number':2129,'multiline':False]
['text':'    - Triggers recompilation and results in guards like:','line_number':2130,'multiline':False]
['text':'      - "x == True and y.size(0) == 4"','line_number':2131,'multiline':False]
['text':'      - (or "y.size(0) == 4 and x == True")','line_number':2132,'multiline':False]
['text':' The order of checking the guards matters. In this specific example:','line_number':2134,'multiline':False]
['text':' If True branch guard check precedes False branch and for True branch, y.size(0) check precedes x == True,','line_number':2135,'multiline':False]
['text':' we may have an unnessary shape speciliazation for y.','line_number':2136,'multiline':False]
['text':' Reimplement the legacy behavior','line_number':2171,'multiline':False]
['text':' NB: This is encapsulation breaking!  Legacy behavior was','line_number':2176,'multiline':False]
['text':' bad.','line_number':2177,'multiline':False]
['text':' symbolic_context is None - set one','line_number':2186,'multiline':False]
['text':' We got a StatelessSymbolicContext','line_number':2188,'multiline':False]
['text':' TODO: make this configurable from outside symbolic_context; we made a symbolic_context','line_number':2193,'multiline':False]
['text':' decision here where if all sizes are static, we are going to','line_number':2194,'multiline':False]
['text':' specialize all of the inner strides/offset too. We don't have to','line_number':2195,'multiline':False]
['text':' do this, and arguably we should ALWAYS allow for dynamic offset,','line_number':2196,'multiline':False]
['text':' this is cheap.','line_number':2197,'multiline':False]
['text':' TODO: This should be DYNAMIC, using DUCK for BC','line_number':2198,'multiline':False]
['text':' iterate over unbound strides in sorted order','line_number':2216,'multiline':False]
['text':' Order singletons by their coefficients.','line_number':2220,'multiline':False]
['text':' 1 here to order singletons after non-singletons.','line_number':2221,'multiline':False]
['text':' bind the smallest unbound stride to a new variable','line_number':2232,'multiline':False]
['text':' NB: Don't duck size the stride; instead use the expression','line_number':2259,'multiline':False]
['text':' we computed','line_number':2260,'multiline':False]
['text':' If you know what the current hint value of the SymInt to be created','line_number':2276,'multiline':False]
['text':' is, pass it into hint.  Otherwise, pass None and we will make our best','line_number':2277,'multiline':False]
['text':' guess','line_number':2278,'multiline':False]
['text':' Create a new symbol for this source.','line_number':2290,'multiline':False]
['text':' Create a new FX placeholder and Z3 variable for 'symbol'.','line_number':2294,'multiline':False]
['text':' Add an equality assertion for the newly created symbol and 'sym'.','line_number':2297,'multiline':False]
['text':' This function is only being used in serialization, so we do not track it','line_number':2323,'multiline':False]
['text':' for validation.','line_number':2324,'multiline':False]
['text':' Create a new FX placeholder and Z3 variable for 'symbol'.','line_number':2334,'multiline':False]
['text':' Create a new FX placeholder and Z3 variable for 'symbol'.','line_number':2346,'multiline':False]
['text':' NB: keep synced with free_unbacked_symbols','line_number':2355,'multiline':False]
['text':' Create a new FX placeholder and Z3 variable for 'symbol'.','line_number':2365,'multiline':False]
['text':' NB: includes None','line_number':2376,'multiline':False]
['text':' 'positive' is None for unspecified symbols, since we can't','line_number':2378,'multiline':False]
['text':' assume that it will be neither positive nor negative.','line_number':2379,'multiline':False]
['text':' We don't want to specialize zero one val for unspecified symbol','line_number':2381,'multiline':False]
['text':' so that we can always get a new symbol despite val.','line_number':2382,'multiline':False]
['text':' NB: includes None','line_number':2398,'multiline':False]
['text':' see note [Tensor Fakification and Symbol Caching]','line_number':2403,'multiline':False]
['text':' It's always sound to allocate a symbol as DYNAMIC.  If the user','line_number':2421,'multiline':False]
['text':' constrained the symbol, force the symbolic_context to DYNAMIC, because our','line_number':2422,'multiline':False]
['text':' constraint code will do weird stuff if, e.g., it's duck shaped','line_number':2423,'multiline':False]
['text':' duck_shape can be used to globally turn off duck shaping, even','line_number':2434,'multiline':False]
['text':' if it was requested','line_number':2435,'multiline':False]
['text':' If we're not duck shaping, we always create a new symbol','line_number':2445,'multiline':False]
['text':' Even if we're duck shaping, if we haven't seen this particular','line_number':2446,'multiline':False]
['text':' value before, we also create a new symbol','line_number':2447,'multiline':False]
['text':' We always associate vars to vals','line_number':2449,'multiline':False]
['text':' Only used for jagged layout nested tensors','line_number':2453,'multiline':False]
['text':' Do the appending later, because we always want to populate this','line_number':2456,'multiline':False]
['text':' Create a Z3 variable for the new symbol.','line_number':2458,'multiline':False]
['text':' Make sure to reuse this symbol for subsequent duck shaping','line_number':2462,'multiline':False]
['text':' Add assertions for the newly created symbols','line_number':2467,'multiline':False]
['text':' Apply default range, which assumes not zero-one','line_number':2470,'multiline':False]
['text':' Small performance optimization: if we have a min-max constraint,','line_number':2475,'multiline':False]
['text':' we can proactively narrow to that range','line_number':2476,'multiline':False]
['text':' Initialize default runtime range to match compile time range,','line_number':2486,'multiline':False]
['text':' for backed SymInts (this is allowed to diverge for unbacked)','line_number':2487,'multiline':False]
['text':' Skip var_range logic for SingletonInt','line_number':2492,'multiline':False]
['text':' Only used for jagged layout nested tensors','line_number':2493,'multiline':False]
['text':' This implements duck-shaping: input sizes that match are assigned','line_number':2500,'multiline':False]
['text':' the same symint','line_number':2501,'multiline':False]
['text':' Generates a list of guards strings which, when evaluated in a context that','line_number':2534,'multiline':False]
['text':' defines tensors for all the sources, returns True or False depending','line_number':2535,'multiline':False]
['text':' on if the guards in the list evaluated to True or not.  Primarily used by Dynamo,','line_number':2536,'multiline':False]
['text':' but this is also helpful for manual testing of guards (see','line_number':2537,'multiline':False]
['text':' evaluate_guards_for_args)','line_number':2538,'multiline':False]
['text':'','line_number':2539,'multiline':False]
['text':' For convenience in testing, a source is allowed to be a str,','line_number':2540,'multiline':False]
['text':' in which case we will assume it is a LocalSource','line_number':2541,'multiline':False]
['text':'','line_number':2542,'multiline':False]
['text':' simplified lets you omit duck sizing, equality and 0/1 guards.','line_number':2543,'multiline':False]
['text':' This is useful for testing when you don't care about the boilerplate','line_number':2544,'multiline':False]
['text':' guards, and it may be helpful for user output too (be careful though;','line_number':2545,'multiline':False]
['text':' some equality guards are nontrivial!  It would be nice to get simplified','line_number':2546,'multiline':False]
['text':' output to print them too).  It's private because it's not','line_number':2547,'multiline':False]
['text':' intended for normal use','line_number':2548,'multiline':False]
['text':' Indicates if we should produce guards for known static values.','line_number':2558,'multiline':False]
['text':' Check if we get to the same ShapeEnv state by replaying the recorded events.','line_number':2563,'multiline':False]
['text':' This will create a new ShapeEnv instance, and call all recorded function','line_number':2564,'multiline':False]
['text':' calls on this new instance. Finally, it will check whether this new instance','line_number':2565,'multiline':False]
['text':' has equal state.','line_number':2566,'multiline':False]
['text':'','line_number':2567,'multiline':False]
['text':' It's important that we do it in the begining of this function, since it modifies','line_number':2568,'multiline':False]
['text':' self.dim_constraints through its execution. Changes that happen in this method','line_number':2569,'multiline':False]
['text':' aren't interesting, since this is the function call we wish to reproduce at the','line_number':2570,'multiline':False]
['text':' end. If we wish to simply reproduce ShapeEnv instances even after this call,','line_number':2571,'multiline':False]
['text':' this method should also be recorded.','line_number':2572,'multiline':False]
['text':' Ignored; only the constraints part is relevant below.','line_number':2582,'multiline':False]
['text':' Expand optional inputs, or verify invariants are upheld','line_number':2587,'multiline':False]
['text':' It took a lot of sweat to figure out the algorithm here.  Let's','line_number':2603,'multiline':False]
['text':' explain how it works.','line_number':2604,'multiline':False]
['text':'','line_number':2605,'multiline':False]
['text':' The ShapeEnv lifecycle looks something like this:','line_number':2606,'multiline':False]
['text':'','line_number':2607,'multiline':False]
['text':' - For each input, you either generate a fresh Sympy symbol (s0) to','line_number':2608,'multiline':False]
['text':'   represent its value (a binding site), or you reuse some','line_number':2609,'multiline':False]
['text':'   preexisting symbol or expression, skipping the symbol allocation','line_number':2610,'multiline':False]
['text':'   (e.g., duck sizing to a preexisting symbol, or expressing a','line_number':2611,'multiline':False]
['text':'   stride as a multiplication of a separate stride and size.)','line_number':2612,'multiline':False]
['text':'   Naively, you might expect to bind a fresh Sympy symbol for','line_number':2613,'multiline':False]
['text':'   every input, but this is fairly wasteful as most of these','line_number':2614,'multiline':False]
['text':'   symbols immediately simplify away, and if you don't eagerly','line_number':2615,'multiline':False]
['text':'   specialize, e.g., 0/1 symbols, you end up with very complicated','line_number':2616,'multiline':False]
['text':'   expressions that are not optimizable in practice.','line_number':2617,'multiline':False]
['text':'','line_number':2618,'multiline':False]
['text':' - You perform some compute on these symbols, occasionally','line_number':2619,'multiline':False]
['text':'   introducing guards on boolean expressions on these symbols.','line_number':2620,'multiline':False]
['text':'   In particular, whenever we guard on equality (_maybe_guard_eq),','line_number':2621,'multiline':False]
['text':'   we can simplify shapes; e.g., when s0 == s1 * 2, we can now','line_number':2622,'multiline':False]
['text':'   replace all occurrences of s0 with s1 * 2.  Sometimes, a','line_number':2623,'multiline':False]
['text':'   boolean expression evaluation doesn't introduce a guard, as','line_number':2624,'multiline':False]
['text':'   the guard is already entailed by the simplifications we have','line_number':2625,'multiline':False]
['text':'   applied.','line_number':2626,'multiline':False]
['text':'','line_number':2627,'multiline':False]
['text':' - In the end, you have a bunch of replacements (saying how to','line_number':2628,'multiline':False]
['text':'   simplify shapes) and a bunch of guards (all the equality guards','line_number':2629,'multiline':False]
['text':'   are trivial, because they're covered by the replacements).','line_number':2630,'multiline':False]
['text':'','line_number':2631,'multiline':False]
['text':' From the ShapeEnv, we must generate a Python expression that, when','line_number':2632,'multiline':False]
['text':' evaluated on a set of inputs, tells us whether or not these boolean','line_number':2633,'multiline':False]
['text':' expressions would have evaluated in the same way.  However,','line_number':2634,'multiline':False]
['text':' we cannot easily compute this, as we elide recording boolean','line_number':2635,'multiline':False]
['text':' expressions when we think they are vacuously true.  Thus, we seek','line_number':2636,'multiline':False]
['text':' an approximation: we must generate an expression, if true, would have','line_number':2637,'multiline':False]
['text':' produced an "equivalent" ShapeEnv, which would answer guard','line_number':2638,'multiline':False]
['text':' expressions in the same way.','line_number':2639,'multiline':False]
['text':'','line_number':2640,'multiline':False]
['text':' Our notion of equivalence is a bit subtle.  For example, consider','line_number':2641,'multiline':False]
['text':' the ShapeEnv created from an input of size (5, 4) versus (4, 4)','line_number':2642,'multiline':False]
['text':' (no other guards.)  Duck sizing would generate (s0, s1) in the first','line_number':2643,'multiline':False]
['text':' case but (s0, s0) in the second.  We do NOT assume that size','line_number':2644,'multiline':False]
['text':' variables are disjoint; so in fact a graph that assumes the input','line_number':2645,'multiline':False]
['text':' could be (s0, s1) subsumes (s0, s0) (setting s0 == s1), but not','line_number':2646,'multiline':False]
['text':' vice versa.  However, consider an analogous case (1,) versus (2,).','line_number':2647,'multiline':False]
['text':' Duck sizing generates (1,) and (s0,); the (s0,) graph does NOT','line_number':2648,'multiline':False]
['text':' subsume the (1,) graph because we assume that any size variables','line_number':2649,'multiline':False]
['text':' is NOT 0/1 (and make simplifications according to this; e.g., if','line_number':2650,'multiline':False]
['text':' we queried s0 == 0, we would immediately return False without','line_number':2651,'multiline':False]
['text':' returning a guard.)','line_number':2652,'multiline':False]
['text':'','line_number':2653,'multiline':False]
['text':' So, it is perhaps easier to flip things on their head: the guard','line_number':2654,'multiline':False]
['text':' expressions we generate here say what simplifications are valid,','line_number':2655,'multiline':False]
['text':' and what are not.  Below, we explain each of the guard expressions','line_number':2656,'multiline':False]
['text':' we generate','line_number':2657,'multiline':False]
['text':' TODO: Make this more efficient by binding all the size/stride/offsets','line_number':2659,'multiline':False]
['text':' to locals before performing tests on them.','line_number':2660,'multiline':False]
['text':' Actual codegen must be delayed as we don't necessarily know what','line_number':2664,'multiline':False]
['text':' the symbol mapping is','line_number':2665,'multiline':False]
['text':' How do we know what the value of s0 is?  Fresh variables can only be','line_number':2701,'multiline':False]
['text':' bound by inputs, so there MUST be some other input which binds the','line_number':2702,'multiline':False]
['text':' variable.  If there is no such input, this is an error in our','line_number':2703,'multiline':False]
['text':' system.  We record where all symbols come from, to help you diagnose','line_number':2704,'multiline':False]
['text':' why those symbols didn't occur.','line_number':2705,'multiline':False]
['text':'','line_number':2706,'multiline':False]
['text':' In fact, generally speaking it is only possible for the "outermost"','line_number':2707,'multiline':False]
['text':' user of a ShapeEnv to evaluate the guards, because some inputs may','line_number':2708,'multiline':False]
['text':' not be available to inner levels.  For example, Dynamo can guard on','line_number':2709,'multiline':False]
['text':' tensors that never actually become graph arguments (they are','line_number':2710,'multiline':False]
['text':' pruned).  In this case, only Dynamo knows about these arguments.','line_number':2711,'multiline':False]
['text':' try inferring the ranges of the expr s','line_number':2730,'multiline':False]
['text':' the expr and constrain ranges don't match','line_number':2735,'multiline':False]
['text':' some of the free symbols in s don't have ranges','line_number':2738,'multiline':False]
['text':' Don't complain about 0/1 specialization, we','line_number':2743,'multiline':False]
['text':' expect to have to compile in this case anyway','line_number':2744,'multiline':False]
['text':' Don't complain about 0/1 specialization, we','line_number':2772,'multiline':False]
['text':' expect to have to compile in this case anyway','line_number':2773,'multiline':False]
['text':' For subclasses, we need to track symints on BOTH the outer','line_number':2800,'multiline':False]
['text':' and inner tensors.','line_number':2801,'multiline':False]
['text':' 1. Every input must equal the final simplified symbolic expression','line_number':2825,'multiline':False]
['text':'    stored on the placeholder.  Given a placeholder (s0*2, s1),','line_number':2826,'multiline':False]
['text':'    if we have an input (2, 3), we must show s0*2 == 2 and s1 == 3.','line_number':2827,'multiline':False]
['text':'    This does a lot of work: it covers duck sizing and equality guards.','line_number':2828,'multiline':False]
['text':' Ignore sources that were not turned into SymInts.','line_number':2840,'multiline':False]
['text':' Small optimization','line_number':2845,'multiline':False]
['text':' This logic excludes static values found on tensors from guarding, because','line_number':2853,'multiline':False]
['text':' dynamo's check_tensor_fn does that (see guards.cpp).','line_number':2854,'multiline':False]
['text':' However, for non tensor sources, we still need to guard here.','line_number':2855,'multiline':False]
['text':' NB: Not necessary to report constraint violations here:','line_number':2880,'multiline':False]
['text':' constraints are guaranteed to be on symbols (we've already','line_number':2881,'multiline':False]
['text':' caught constants and non-atomic expressions), so we only','line_number':2882,'multiline':False]
['text':' have relational constraints, but we don't support those','line_number':2883,'multiline':False]
['text':' at the moment','line_number':2884,'multiline':False]
['text':' 2. Every guard must evaluate to True (but remember many guards','line_number':2886,'multiline':False]
['text':'    like s0 == s1*2 because trivial due to simplification)','line_number':2887,'multiline':False]
['text':' Avoid re-issueing the same guard.','line_number':2893,'multiline':False]
['text':' A non-relational constraint on a single sizevar can violate','line_number':2906,'multiline':False]
['text':' a constraint','line_number':2907,'multiline':False]
['text':' This is fine, we allow guards here as long as it','line_number':2921,'multiline':False]
['text':' didn't constrain it to one value  (we don't','line_number':2922,'multiline':False]
['text':' actually know this; this depends on our','line_number':2923,'multiline':False]
['text':' ValueRanges reasoning capability)','line_number':2924,'multiline':False]
['text':' First, issue all the non-trivial guards.','line_number':2932,'multiline':False]
['text':' Then, issue the guards that refine the value range of tracked symbols.','line_number':2938,'multiline':False]
['text':' We need to explicitly issue these guards, since they are the ones that','line_number':2939,'multiline':False]
['text':' guarantee the symbol's value range. Plus, due to the updated value','line_number':2940,'multiline':False]
['text':' range, they may be skipped in the previous step.','line_number':2941,'multiline':False]
['text':' 3. Every symbol must be within its value range (this handles 0/1','line_number':2949,'multiline':False]
['text':' specialization too).  NB: because we never update value ranges','line_number':2950,'multiline':False]
['text':' except in case of explicit user annotation, these are not included','line_number':2951,'multiline':False]
['text':' in simplified.  However, when we start updating value ranges','line_number':2952,'multiline':False]
['text':' these should probably get reported in tests too','line_number':2953,'multiline':False]
['text':' NB: This looks like an off-by-one error but it's not: the','line_number':2971,'multiline':False]
['text':' upper bound may be sys.maxsize - 1 because we intentionally','line_number':2972,'multiline':False]
['text':' exclude sys.maxsize from our bounds to deal with direct','line_number':2973,'multiline':False]
['text':' == INT_MAX guards, but it's still dumb to actually test it.','line_number':2974,'multiline':False]
['text':' Note that you can be off by a pretty large constant and it','line_number':2975,'multiline':False]
['text':' won't matter because sizes in practice will be no where near','line_number':2976,'multiline':False]
['text':' the 64-bit limit.','line_number':2977,'multiline':False]
['text':' Add all deferred runtime assertions; these are not technically','line_number':3022,'multiline':False]
['text':' handled by produce_guards but we need to put them in the target','line_number':3023,'multiline':False]
['text':' set','line_number':3024,'multiline':False]
['text':' Add value range bound guards for all symbols with no trivial bounds.','line_number':3029,'multiline':False]
['text':' Reason: '_maybe_evaluate_static' may eliminate guards based on the','line_number':3030,'multiline':False]
['text':' refined value ranges.','line_number':3031,'multiline':False]
['text':'','line_number':3032,'multiline':False]
['text':' NB: do NOT use runtime var ranges, they're unsound!  You will','line_number':3033,'multiline':False]
['text':' only get correct TV with the compile-time ranges.','line_number':3034,'multiline':False]
['text':' Before validating, populate the input of the validator with the','line_number':3041,'multiline':False]
['text':' built FX graph.','line_number':3042,'multiline':False]
['text':' Given a paired list of placeholders (fake tensors with','line_number':3077,'multiline':False]
['text':' symbolic sizes) and concrete arguments (regular tensors','line_number':3078,'multiline':False]
['text':' with real sizes), returns a dictionary mapping each','line_number':3079,'multiline':False]
['text':' symbol to its real value.  So for example, if you','line_number':3080,'multiline':False]
['text':' have a placeholder with size (s0, s1), binding','line_number':3081,'multiline':False]
['text':' (2, 4) to it will give you {s0: 2, s1: 4}.  This is','line_number':3082,'multiline':False]
['text':' not guaranteed to bind ALL symbols in the ShapeEnv;','line_number':3083,'multiline':False]
['text':' we can't bind a symbol if it doesn't occur in any placeholder,','line_number':3084,'multiline':False]
['text':' and symbols that already have replacements won't get bindings.','line_number':3085,'multiline':False]
['text':' This is a little duplicative with evaluate_guards but','line_number':3087,'multiline':False]
['text':' it's different enough that it seemed cleanest to make','line_number':3088,'multiline':False]
['text':' another copy.  This assumes the guards are already checked,','line_number':3089,'multiline':False]
['text':' though if it's cheap we'll check for shenanigans','line_number':3090,'multiline':False]
['text':' Apply known runtime asserts','line_number':3166,'multiline':False]
['text':' Unbacked symints only','line_number':3168,'multiline':False]
['text':' e is already canonical','line_number':3177,'multiline':False]
['text':' NB: this helps us deal with And/Or connectives','line_number':3186,'multiline':False]
['text':' Simplify making use of value range lower bound','line_number':3189,'multiline':False]
['text':' Skip var_to_range logic for SingletonInt which is only used','line_number':3194,'multiline':False]
['text':' for jagged layout NestedTensors today','line_number':3195,'multiline':False]
['text':' Don't do anything if we don't have a nontrivial lower bound','line_number':3198,'multiline':False]
['text':' Also don't do anything if we asked only to simplify unbacked','line_number':3199,'multiline':False]
['text':' SymInt','line_number':3200,'multiline':False]
['text':' Positive means >= 1','line_number':3207,'multiline':False]
['text':' Positive - 1 means >= 0','line_number':3208,'multiline':False]
['text':' Positive + lower - 1 means >= lower','line_number':3209,'multiline':False]
['text':' The new symbol 's' is "too low", so when we substitute it in','line_number':3210,'multiline':False]
['text':' we have to increase it by offset (and conversely, the new','line_number':3211,'multiline':False]
['text':' variables have to have their value range bounds adjusted as','line_number':3212,'multiline':False]
['text':' well)','line_number':3213,'multiline':False]
['text':' TODO: when unbacked_only, can sometimes early return even when there','line_number':3233,'multiline':False]
['text':' are still free symbols','line_number':3234,'multiline':False]
['text':' Check if the range can solve it statically','line_number':3238,'multiline':False]
['text':' TODO it would seem that this pass is not necessary given the','line_number':3266,'multiline':False]
['text':' below replacement of // with /, but for nested FloorDivs','line_number':3267,'multiline':False]
['text':' the non-recursive replacement doesn't work, and','line_number':3268,'multiline':False]
['text':' recursive makes it hard to look up divisibility,','line_number':3269,'multiline':False]
['text':' because existing divisibility info has FloorDiv in it, not /','line_number':3270,'multiline':False]
['text':' for now just do a separate pass to catch common nested case','line_number':3271,'multiline':False]
['text':' divisions simplified away','line_number':3296,'multiline':False]
['text':' NB: keep in sync with size_hint','line_number':3323,'multiline':False]
['text':' TODO: in a Dynamo context, having user code, and having the','line_number':3330,'multiline':False]
['text':' name of the local, will be much better','line_number':3331,'multiline':False]
['text':' TODO: Help text about how to use our runtime tests to fix this','line_number':3340,'multiline':False]
['text':' problem','line_number':3341,'multiline':False]
['text':' specializing to a constant, which is likely unexpected','line_number':3350,'multiline':False]
['text':' NOTE(avik): It is possible that we try logging the same specialization multiple times, e.g.,','line_number':3352,'multiline':False]
['text':' when adding a to self.replacements, and again when simplifying an expression containing a.','line_number':3353,'multiline':False]
['text':' Thus to avoid duplication, checking whether a is in self.replacements isn't enough; if it is,','line_number':3354,'multiline':False]
['text':' it must not already map to `expr`. Fortunately this check is cheap because `expr` is a constant.','line_number':3355,'multiline':False]
['text':' When specializing 'a == expr', the equality should be also conveyed to','line_number':3363,'multiline':False]
['text':' Z3, in case an expression uses 'a'.','line_number':3364,'multiline':False]
['text':' NB: Apparently this is load bearing; to see what test fails if','line_number':3398,'multiline':False]
['text':' you comment it out run:','line_number':3399,'multiline':False]
['text':' python test/functorch/test_aotdispatch.py -k','line_number':3400,'multiline':False]
['text':' test_aot_autograd_symbolic_module_exhaustive_nn_LazyConv3d_cpu_float32','line_number':3401,'multiline':False]
['text':' In case of really gnarly expression, we don't blow up','line_number':3408,'multiline':False]
['text':' NB: prioritize unbacked symints for solving by ordering them last','line_number':3411,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':3412,'multiline':False]
['text':' short-circuit when no solving is needed','line_number':3420,'multiline':False]
['text':' If you have i0 + i1 + i2 = s0, don't substitute i2 =','line_number':3431,'multiline':False]
['text':' s0 - i0 - i1.  Arguably this should be OK but the','line_number':3432,'multiline':False]
['text':' runtime assert machinery is very delicate right now','line_number':3433,'multiline':False]
['text':' so this causes things to fail e.g.,','line_number':3434,'multiline':False]
['text':' test_split_unbacked_sizes','line_number':3435,'multiline':False]
['text':' Never substitute backed with unbacked','line_number':3438,'multiline':False]
['text':' This is a little bit of extra logic to make things like','line_number':3450,'multiline':False]
['text':' torch.empty(i0, q).view(c, -1, q) work out','line_number':3451,'multiline':False]
['text':' Given Mod(c * i0, q) == 0','line_number':3455,'multiline':False]
['text':' We have Mod(i0, q / c) == 0, which means we can','line_number':3461,'multiline':False]
['text':' rewrite i0 as (q / gcd(q, c)) * i1','line_number':3462,'multiline':False]
['text':' Propagate the value ranges.  It doesn't really','line_number':3465,'multiline':False]
['text':' matter if we use truediv or floordiv, because we','line_number':3466,'multiline':False]
['text':' have established divisibility.','line_number':3467,'multiline':False]
['text':' See: Note - On 0/1 specialization','line_number':3480,'multiline':False]
['text':' NB: sys.maxsize is NOT allowed for sizes, because we use MAX_INT','line_number':3481,'multiline':False]
['text':' as a sentinel sometimes.  Your sizevar isn't going to be','line_number':3482,'multiline':False]
['text':' anywhere near the max 64-bit integer anyway.','line_number':3483,'multiline':False]
['text':' we expect floor_divs to be exact,','line_number':3494,'multiline':False]
['text':' and thus add the guards for the exact floordivs,','line_number':3495,'multiline':False]
['text':' even if tracing doesn't require them otherwise','line_number':3496,'multiline':False]
['text':' add necessary mod guards','line_number':3501,'multiline':False]
['text':' We're about to add a guard/runtime assert, check if the ShapeEnv is frozen','line_number':3505,'multiline':False]
['text':' and if so issue a warning','line_number':3506,'multiline':False]
['text':' no version = original state (this signpost is expected)','line_number':3516,'multiline':False]
['text':' version 2 = dynamic backwards is eagerly compiled','line_number':3517,'multiline':False]
['text':' NB: this stack is truncated, but it's fine because the main','line_number':3540,'multiline':False]
['text':' stack_info will give you the rest of the info you need','line_number':3541,'multiline':False]
['text':' TODO: make this an artifact','line_number':3553,'multiline':False]
['text':' Check if:','line_number':3584,'multiline':False]
['text':'   1. 'translation_validation' is set','line_number':3585,'multiline':False]
['text':'   2. the corresponding 'fx_node' is not 'None'','line_number':3586,'multiline':False]
['text':'   3. the guard should not be suppressed','line_number':3587,'multiline':False]
['text':'','line_number':3588,'multiline':False]
['text':' If all of the above check, we create an FX node representing the','line_number':3589,'multiline':False]
['text':' actual expression to be guarded.','line_number':3590,'multiline':False]
['text':' If this is a fresh node, we have to remember the event index that','line_number':3608,'multiline':False]
['text':' corresponds to this assertion node.','line_number':3609,'multiline':False]
['text':' Reason: so that, given an assertion node, we can replay the ShapeEnv','line_number':3610,'multiline':False]
['text':' events until the point where this assertion node was freshly created.','line_number':3611,'multiline':False]
['text':' After creating the FX node corresponding to orig_expr, we must make sure that','line_number':3615,'multiline':False]
['text':' no error will be raised until the end of this function.','line_number':3616,'multiline':False]
['text':'','line_number':3617,'multiline':False]
['text':' Reason: the translation validation may become invalid otherwise.','line_number':3618,'multiline':False]
['text':'','line_number':3619,'multiline':False]
['text':' If an error is raised before the end of this function, we remove the FX node','line_number':3620,'multiline':False]
['text':' inserted, and re-raise the error.','line_number':3621,'multiline':False]
['text':' NB: don't test float as there may be precision issues','line_number':3628,'multiline':False]
['text':' NB: don't test float as there may be precision issues','line_number':3639,'multiline':False]
['text':' TODO: dedupe this with _maybe_evaluate_static','line_number':3645,'multiline':False]
['text':' Attempt to eliminate the unbacked SymInt','line_number':3646,'multiline':False]
['text':' TODO: If we successfully eliminate a symbol via equality, it','line_number':3663,'multiline':False]
['text':' is not actually necessary to save a guard for the equality,','line_number':3664,'multiline':False]
['text':' as we will implicitly generate a guard when we match that','line_number':3665,'multiline':False]
['text':' input against the symbol','line_number':3666,'multiline':False]
['text':' WARNING: we cannot actually do simplifications on guards','line_number':3668,'multiline':False]
['text':' on floating point values, because Sympy generally does not','line_number':3669,'multiline':False]
['text':' think expressions on integers can ever be equal to floating','line_number':3670,'multiline':False]
['text':' point (e.g., sympy.Eq(s0/6, 0.5) evaluates to False).  Without','line_number':3671,'multiline':False]
['text':' very clear algebraic laws that hold for floating point, such','line_number':3672,'multiline':False]
['text':' simplifications are error prone anyway, so be sure not to','line_number':3673,'multiline':False]
['text':' maybe_guard_eq in those cases.','line_number':3674,'multiline':False]
['text':' type: ignore[arg-type]','line_number':3682,'multiline':False]
['text':' Break reference cycles.','line_number':3705,'multiline':False]
['text':' This destroys the stacks. If you really want to keep them, we','line_number':3706,'multiline':False]
['text':' just need some way to break references on code objects.','line_number':3707,'multiline':False]
['text':' Attempt to eliminate the unbacked SymInt','line_number':3725,'multiline':False]
['text':' Do a normal guard','line_number':3728,'multiline':False]
['text':' NB: Don't use new_expr as expr; it could contain gunk like shape0','line_number':3730,'multiline':False]
['text':' which we don't want to guard on','line_number':3731,'multiline':False]
['text':' OK, we're definitely doing a runtime assert now','line_number':3733,'multiline':False]
['text':' eliminate symbols on equality tests','line_number':3746,'multiline':False]
['text':' canonicalise to remove equations that are trivially equal','line_number':3751,'multiline':False]
['text':' TODO: Do this in a way that is less janky than int(s.name[1:])','line_number':3755,'multiline':False]
['text':' TODO: refine ranges','line_number':3760,'multiline':False]
['text':' Unfortunately, range refinement is probably going to not','line_number':3761,'multiline':False]
['text':' work most of the time, because we don't support symbols','line_number':3762,'multiline':False]
['text':' in ranges.  For example, i0 <= s0 is un-rangeable, because','line_number':3763,'multiline':False]
['text':' we can't put s0 in the range.  So this is not very high','line_number':3764,'multiline':False]
['text':' priority at the moment.','line_number':3765,'multiline':False]
['text':' Refines the ranges of the variables present in 'guard'.','line_number':3772,'multiline':False]
['text':'','line_number':3773,'multiline':False]
['text':' This function tries to refine the range of the variables inside','line_number':3774,'multiline':False]
['text':' 'guard' by reasoning about it. Specifically, when 'guard' is a','line_number':3775,'multiline':False]
['text':' 'sympy.Relational' operation.','line_number':3776,'multiline':False]
['text':'','line_number':3777,'multiline':False]
['text':' It does mainly 3 things:','line_number':3778,'multiline':False]
['text':'   1. Tries to isolate a variable in the left-hand side','line_number':3779,'multiline':False]
['text':'   2. Compute the value range of the right-hand side','line_number':3780,'multiline':False]
['text':'   3. Update the value range of the variable, if better','line_number':3781,'multiline':False]
['text':' Skip var_to_range logic for SingletonInt which is only used','line_number':3789,'multiline':False]
['text':' for jagged layout NestedTensors today','line_number':3790,'multiline':False]
['text':' Range refinement only supports integer symbols for now.','line_number':3796,'multiline':False]
['text':' There are lots of SymPy bugs when it comes to comparing','line_number':3797,'multiline':False]
['text':' reals and integers, so we skip that for now.','line_number':3798,'multiline':False]
['text':' Let's suppose that we have a preexisting range for x [0, 100].','line_number':3809,'multiline':False]
['text':' Now, we issue a guard x > y, where the range for y is [50, 150].','line_number':3810,'multiline':False]
['text':' Then, lower = 0, rhs_vr.lower = 50 and therefore refinement can happen,','line_number':3811,'multiline':False]
['text':' refining x to [51, 100], since x must be greater than y, but the lowest','line_number':3812,'multiline':False]
['text':' y could be is 50.','line_number':3813,'multiline':False]
['text':'','line_number':3814,'multiline':False]
['text':' sympy.Eq may update both lower and upper bounds.','line_number':3815,'multiline':False]
['text':' sympy.G{t,e} may update the lower bound, only.','line_number':3816,'multiline':False]
['text':' sympy.L{t,e} may update the upper bound, only.','line_number':3817,'multiline':False]
['text':' Strictly greater relations allow us to refine a bit more, since','line_number':3819,'multiline':False]
['text':' x < y implies that the lower bound for x is: y + 1.','line_number':3820,'multiline':False]
['text':' Do nothing if the new value range is no better than what we already have.','line_number':3827,'multiline':False]
['text':' Updates the range and the guards corresponding to each bound of the symbol.','line_number':3831,'multiline':False]
['text':' Clears the cache, since this update can change the result.','line_number':3834,'multiline':False]
['text':' WARNING: This is legacy, DO NOT USE','line_number':3840,'multiline':False]
