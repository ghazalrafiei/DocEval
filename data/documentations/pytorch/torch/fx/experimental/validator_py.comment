['text':' type: ignore[import]','line_number':21,'multiline':False]
['text':' Translation Validation for Dynamo guards','line_number':23,'multiline':False]
['text':' ========================================','line_number':24,'multiline':False]
['text':'','line_number':25,'multiline':False]
['text':' Checks whether optimizations applied to the collected guards are','line_number':26,'multiline':False]
['text':' valid. In other words, whether the guard function we actually run','line_number':27,'multiline':False]
['text':' does not have false positives (unsound).','line_number':28,'multiline':False]
['text':'','line_number':29,'multiline':False]
['text':' In order to do so, we build the guards using 2 different information','line_number':30,'multiline':False]
['text':' attached to each 'SymNode':','line_number':31,'multiline':False]
['text':'   1. SymPy expressions','line_number':32,'multiline':False]
['text':'   2. FX nodes','line_number':33,'multiline':False]
['text':'','line_number':34,'multiline':False]
['text':' SymPy expressions have implicit optimizations baked within itself,','line_number':35,'multiline':False]
['text':' which may have a few bugs. On the other hand, we build the FX graph','line_number':36,'multiline':False]
['text':' manually, with no optimizations enabled. This gives us access to','line_number':37,'multiline':False]
['text':' the "ground truth".','line_number':38,'multiline':False]
['text':'','line_number':39,'multiline':False]
['text':' We then convert into Z3 expressions both the SymPy expressions','line_number':40,'multiline':False]
['text':' (see [Note: SympyToZ3]) that reach 'ShapeEnv.produce_guards' function','line_number':41,'multiline':False]
['text':' and the FX nodes (see [Note: PopulateValidator]) that go through','line_number':42,'multiline':False]
['text':' 'ShapeEnv.evaluate_expr' function. Finally, we run the validation.','line_number':43,'multiline':False]
['text':' (see [Note: TranslationValidator])','line_number':44,'multiline':False]
['text':' Better Z3 to string implementation (for a small fraction of Z3).','line_number':46,'multiline':False]
['text':'','line_number':47,'multiline':False]
['text':' Here are the things we clean before showing the Z3 expression:','line_number':48,'multiline':False]
['text':'   - Rename a few ops (e.g. "Distinct" ==> "!=")','line_number':49,'multiline':False]
['text':'','line_number':50,'multiline':False]
['text':'   - Ignore ToInt and ToReal operations:','line_number':51,'multiline':False]
['text':'     usually they don't really matter','line_number':52,'multiline':False]
['text':'','line_number':53,'multiline':False]
['text':'   - Transform (ToInt (/ ...)) into (idiv ...):','line_number':54,'multiline':False]
['text':'     this is the pattern for floor division','line_number':55,'multiline':False]
['text':'','line_number':56,'multiline':False]
['text':'   - Collect a chain of the same operations into one','line_number':57,'multiline':False]
['text':' First, we simplify the given expression.','line_number':64,'multiline':False]
['text':' This is done using rewriting rules, so shouldn't take long.','line_number':65,'multiline':False]
['text':' Only support function applications.','line_number':69,'multiline':False]
['text':' Even Z3 "variables" are, in fact, function applications.','line_number':70,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':75,'multiline':False]
['text':' Collect the arguments of chains of ADD and MUL.','line_number':86,'multiline':False]
['text':' This is safe, since they are associative.','line_number':87,'multiline':False]
['text':' Revert some conversions that z3.simplify applies:','line_number':102,'multiline':False]
['text':'   - a != b ==> (Not (== a b)) ==> (!= a b)','line_number':103,'multiline':False]
['text':'   - a < b ==> (Not (<= b a)) ==> (> b a)','line_number':104,'multiline':False]
['text':'   - a > b ==> (Not (<= a b)) ==> (> a b)','line_number':105,'multiline':False]
['text':' Check if it's the floor division pattern.','line_number':127,'multiline':False]
['text':' Otherwise, just ignore it.','line_number':131,'multiline':False]
['text':' Implementation of Python semantics as Z3 expressions.','line_number':141,'multiline':False]
['text':'','line_number':142,'multiline':False]
['text':' Z3 Real-Int theory has operators with semantics that differ that of','line_number':143,'multiline':False]
['text':' Python. Therefore, in order to get it right, we need to implement','line_number':144,'multiline':False]
['text':' the (Python) semantics we are relying on in Z3.','line_number':145,'multiline':False]
['text':' Validator used for adding assertions as needed.','line_number':148,'multiline':False]
['text':' e.g. div(a, b) requires b != 0.','line_number':149,'multiline':False]
['text':' The 2 functions below are used for conditionally casting between','line_number':152,'multiline':False]
['text':' integer and reals.','line_number':153,'multiline':False]
['text':'','line_number':154,'multiline':False]
['text':' Returns a real expression from 'x'.','line_number':155,'multiline':False]
['text':' Returns an integer expression from 'x'.','line_number':160,'multiline':False]
['text':' Implements Python division semantics.','line_number':165,'multiline':False]
['text':' type: ignore[arg-type]','line_number':167,'multiline':False]
['text':' Z3 ToInt function rounds a real number towards negative infinity.','line_number':171,'multiline':False]
['text':' Python semantics for 'FloorDiv' states that before applying the floor','line_number':174,'multiline':False]
['text':' function, the operands are converted to their common type.','line_number':175,'multiline':False]
['text':' Since the 'result' is already an integer, we just have to check','line_number':179,'multiline':False]
['text':' whether we should cast it to real.','line_number':180,'multiline':False]
['text':' type: ignore[return-value]','line_number':188,'multiline':False]
['text':' type: ignore[return-value]','line_number':191,'multiline':False]
['text':' type: ignore[return-value]','line_number':194,'multiline':False]
['text':' Python semantics for 'Mod' is defined as: p % q = p - floordiv(p, q) * q','line_number':196,'multiline':False]
['text':' It should work with both integer and reals.','line_number':197,'multiline':False]
['text':' Z3 can't handle complex numbers very well.','line_number':202,'multiline':False]
['text':' type: ignore[arg-type]','line_number':203,'multiline':False]
['text':' Square-root:','line_number':207,'multiline':False]
['text':' 1. Only work with reals','line_number':208,'multiline':False]
['text':' 2. The number should be positive or zero.','line_number':210,'multiline':False]
['text':'    Otherwise, Z3 returns 'unknown'.','line_number':211,'multiline':False]
['text':' Lifts a callable to be used in Z3.','line_number':218,'multiline':False]
['text':'','line_number':219,'multiline':False]
['text':' This function replaces the given 'op' by a function that:','line_number':220,'multiline':False]
['text':'','line_number':221,'multiline':False]
['text':'   1. Lifts the arguments into Z3 (i.e. make them inhabitants of Z3)','line_number':222,'multiline':False]
['text':'','line_number':223,'multiline':False]
['text':'   2. Calls an operation that corresponds to 'op', but works with Z3','line_number':224,'multiline':False]
['text':'      inhabitants (left as is if it works as is)','line_number':225,'multiline':False]
['text':' Operations that have booleans as their argument.','line_number':229,'multiline':False]
['text':' This is needed because the argument of some FX nodes were','line_number':230,'multiline':False]
['text':' literal integers, instead of booleans. So, whenever this flag','line_number':231,'multiline':False]
['text':' is set, we also convert ints to booleans.','line_number':232,'multiline':False]
['text':' Lifts the function into 'z3.ExprRef' domain.','line_number':236,'multiline':False]
['text':' Convert it into a Z3 value, if it is some of the supported','line_number':241,'multiline':False]
['text':' types below.','line_number':242,'multiline':False]
['text':' Lifts the arguments into a list of Z3 inhabitants.','line_number':253,'multiline':False]
['text':' Run the function on the Z3 expressions.','line_number':255,'multiline':False]
['text':' Operator module.','line_number':262,'multiline':False]
['text':' Math module.','line_number':271,'multiline':False]
['text':' Torch module.','line_number':275,'multiline':False]
['text':' Not lifted because we only use this function as a','line_number':281,'multiline':False]
['text':' marker for adding the expression as validator input.','line_number':282,'multiline':False]
['text':' Processes an FX graph, populating the given validator.','line_number':287,'multiline':False]
['text':'','line_number':288,'multiline':False]
['text':' [Note: PopulateValidator]','line_number':289,'multiline':False]
['text':' This class walks through each node in the FX graph, translating','line_number':290,'multiline':False]
['text':' them into the Z3 world.','line_number':291,'multiline':False]
['text':'','line_number':292,'multiline':False]
['text':' Then, whenever it finds an 'torch._assert' call_function operation,','line_number':293,'multiline':False]
['text':' it adds the Z3 expression corresponding to the argument as validator','line_number':294,'multiline':False]
['text':' input.','line_number':295,'multiline':False]
['text':' Reference to the translation validator.','line_number':298,'multiline':False]
['text':' Build the graph module and call `Interpreter` constructor.','line_number':301,'multiline':False]
['text':' Actually runs the node target function (which is already','line_number':311,'multiline':False]
['text':' lifted) with its arguments.','line_number':312,'multiline':False]
['text':' Adds the Z3 expression corresponding to the first argument','line_number':314,'multiline':False]
['text':' as a validator input.','line_number':315,'multiline':False]
['text':' type: ignore[arg-type]','line_number':317,'multiline':False]
['text':' Translates SymPy expressions into Z3 expressions.','line_number':319,'multiline':False]
['text':'','line_number':320,'multiline':False]
['text':' [Note: SympyToZ3]','line_number':321,'multiline':False]
['text':' At the time of the translation, all free variables present in the','line_number':322,'multiline':False]
['text':' SymPy expression being translated must be already mapped to a Z3','line_number':323,'multiline':False]
['text':' integer variable.','line_number':324,'multiline':False]
['text':' type: ignore[arg-type]','line_number':377,'multiline':False]
['text':' Dynamo guards translation validator.','line_number':379,'multiline':False]
['text':'','line_number':380,'multiline':False]
['text':' [Note: TranslationValidator]','line_number':381,'multiline':False]
['text':' Verifies whether the guards issued by 'ShapeEnv.produce_guards' are sound.','line_number':382,'multiline':False]
['text':' That is: whether those (target) guards only yield TRUE whenever the original,','line_number':383,'multiline':False]
['text':' unoptimized, (source) guards yield TRUE.','line_number':384,'multiline':False]
['text':'','line_number':385,'multiline':False]
['text':' More concretely, given 'source' and 'target' guard expressions, we wish to','line_number':386,'multiline':False]
['text':' check whether the following expression holds:','line_number':387,'multiline':False]
['text':'','line_number':388,'multiline':False]
['text':' Not(And(source)) AND And(target)','line_number':389,'multiline':False]
['text':'','line_number':390,'multiline':False]
['text':' i.e. whether there is an assignment of the free variables where the opposite','line_number':391,'multiline':False]
['text':' happens: target is TRUE, but source is FALSE.','line_number':392,'multiline':False]
['text':' Mapping of SymPy symbols to Z3 variables.','line_number':397,'multiline':False]
['text':' Set of source Z3 expressions.','line_number':400,'multiline':False]
['text':' They represent the generated guards without any kind of','line_number':401,'multiline':False]
['text':' simplification or transformation.','line_number':402,'multiline':False]
['text':' Set of target Z3 expressions.','line_number':405,'multiline':False]
['text':' They represent the actual checked guards at runtime. They might','line_number':406,'multiline':False]
['text':' be simplified or transformed versions of the source guards.','line_number':407,'multiline':False]
['text':' Set of Z3 expressions representing assertions over both the','line_number':410,'multiline':False]
['text':' source and target expressions.','line_number':411,'multiline':False]
['text':' Retrieves the corresponding Z3 variable.','line_number':414,'multiline':False]
['text':' Create a variable in Z3 of 'type' for 'symbol', if it doesn't already exists.','line_number':419,'multiline':False]
['text':' If 'symbol' is positive (SymPy assumption), we have to','line_number':429,'multiline':False]
['text':' convey it to Z3 as well.','line_number':430,'multiline':False]
['text':' type: ignore[attr-defined]','line_number':431,'multiline':False]
['text':' Checks whether all symbols were already added.','line_number':443,'multiline':False]
['text':' Call 'z3var' just to check whether there's already a','line_number':447,'multiline':False]
['text':' Z3 variable corresponding to 's'.','line_number':448,'multiline':False]
['text':' If there are no source/target expressions, there's nothing we really','line_number':484,'multiline':False]
['text':' wish to prove. So, we just return.','line_number':485,'multiline':False]
['text':' Here, we use "QF_NRA" logic for the solver:','line_number':488,'multiline':False]
['text':'   "Quantifier-free Non-linear Real Arithmetic".','line_number':489,'multiline':False]
['text':'','line_number':490,'multiline':False]
['text':' Most of the guards expressions have:','line_number':491,'multiline':False]
['text':'   1. arithmetic between integer and reals','line_number':492,'multiline':False]
['text':'   2. no quantifiers','line_number':493,'multiline':False]
['text':'   3. potentially non-linear.','line_number':494,'multiline':False]
['text':'','line_number':495,'multiline':False]
['text':' Although there's also "QF_NIRA" (mixed integer-real arithmetic),','line_number':496,'multiline':False]
['text':' "QF_NRA" seems to work better on 'dynamo/test_dynamic_shapes.py'.','line_number':497,'multiline':False]
['text':' Set a timeout for finding a solution.','line_number':499,'multiline':False]
['text':' Add all the assertions to the solver.','line_number':502,'multiline':False]
['text':' "Is there any case where it's TRUE for the target expressions,','line_number':506,'multiline':False]
['text':'  but FALSE for the source expressions?"','line_number':507,'multiline':False]
['text':' Target expressions are unsound.','line_number':514,'multiline':False]
['text':' Log the found model and the source expressions that failed.','line_number':515,'multiline':False]
['text':' Could not find a solution. It didn't fail, but it also','line_number':525,'multiline':False]
['text':' didn't succeed. Canceling the validation execution (keyboard','line_number':526,'multiline':False]
['text':' interrupt) also gets to this branch.','line_number':527,'multiline':False]
['text':' Target expressions are sound.','line_number':530,'multiline':False]
['text':' Checks everytime this function is called, in case the Dynamo','line_number':554,'multiline':False]
['text':' option is set, but Z3 is not installed.','line_number':555,'multiline':False]
['text':' Checks when this module is loaded.','line_number':616,'multiline':False]
['text':' Translation validation bisection.','line_number':619,'multiline':False]
['text':'','line_number':620,'multiline':False]
['text':' Bisect into the torch._assert nodes recorded in the shape_env FX graph, and raise','line_number':621,'multiline':False]
['text':' the earliest ValidationException.','line_number':622,'multiline':False]
['text':'','line_number':623,'multiline':False]
['text':' As guards are added by ShapeEnv.evaluate_expr calls, some simplification errors','line_number':624,'multiline':False]
['text':' might be silently happening. This function tries to nail down exactly at which','line_number':625,'multiline':False]
['text':' point things went wrong from a validation perspective.','line_number':626,'multiline':False]
['text':' Retrieves the ShapeEnvEvent associated with node.','line_number':633,'multiline':False]
['text':' Creates a new instance of fake, but updating every symbolic value's ShapeEnv','line_number':638,'multiline':False]
['text':' reference to the one given as argument.','line_number':639,'multiline':False]
['text':'','line_number':640,'multiline':False]
['text':' This is needed so as not to simplify a symbolic expression using a ShapeEnv','line_number':641,'multiline':False]
['text':' "from the future", where it may have a different set of replacements.','line_number':642,'multiline':False]
['text':' Checks whether the given shape_env fails when produce_guards is called.','line_number':656,'multiline':False]
['text':' This produce_guards call is a best-effort replication, since we','line_number':660,'multiline':False]
['text':' don't populate EqualityConstraint list. Reason: we would also have','line_number':661,'multiline':False]
['text':' to save OutputGraph.tracked_fakes_id_to_source.','line_number':662,'multiline':False]
['text':' Checks whether the ShapeEnv reconstructed by replaying the events until','line_number':672,'multiline':False]
['text':' node is created fails when produce_guards is called.','line_number':673,'multiline':False]
['text':' Reconstruct shape_env until the event at event_number.','line_number':676,'multiline':False]
['text':' We don't actually fail due to a produce_guards call.','line_number':684,'multiline':False]
['text':' Stop and don't bisect.','line_number':685,'multiline':False]
['text':' Bisection is off.','line_number':690,'multiline':False]
['text':' Return the last ValidationException we got.','line_number':691,'multiline':False]
['text':' Cache the raised exception (if any) at each bisection point.','line_number':694,'multiline':False]
['text':' Bisection happens on the assertion nodes of the recorded FX graph for','line_number':697,'multiline':False]
['text':' dynamic shapes.','line_number':698,'multiline':False]
['text':' Preparing the indices for binary search.','line_number':701,'multiline':False]
['text':' Check whether the new shape_env raises a ValidationException or not.','line_number':710,'multiline':False]
