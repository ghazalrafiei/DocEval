['text':' If there's no const subgraph module or attr output names to use, return','line_number':45,'multiline':False]
['text':' early as there is no const folding to perform.','line_number':46,'multiline':False]
['text':' Actually run const folding subgraph. Note that single attr const fold','line_number':56,'multiline':False]
['text':' subgraphs output a single Tensor while multiple outputs are returned as','line_number':57,'multiline':False]
['text':' Tuple[Tensor,].','line_number':58,'multiline':False]
['text':' Fetch the inner graph module that we want to inline inside `gm`.','line_number':82,'multiline':False]
['text':' Now actually do the swap. Note that we have to keep track of new nodes that are','line_number':92,'multiline':False]
['text':' copied into `gm` -- we do this via replacement_mapping.','line_number':93,'multiline':False]
['text':' Delete all characters that are illegal in a Python identifier.','line_number':126,'multiline':False]
['text':' Now make sure it is in fact unique to the module by incrementing suffix value.','line_number':130,'multiline':False]
['text':' Build up a list of const_nodes, defined as nodes that are themselves','line_number':159,'multiline':False]
['text':' get_attrs, or have all get_attr or other constant node inputs.','line_number':160,'multiline':False]
['text':' Skip over placeholders/outputs because they can't be const folded and','line_number':164,'multiline':False]
['text':' we don't want to add tags to them.','line_number':165,'multiline':False]
['text':' If the node itself is constant, or all of its inputs are constant,','line_number':169,'multiline':False]
['text':' then tag it as constant.','line_number':170,'multiline':False]
['text':' If provided skip folding function says to skip, then skip.','line_number':176,'multiline':False]
['text':' Skip folding side-effectful functions','line_number':180,'multiline':False]
['text':' Must be a constant foldable node at this point.','line_number':184,'multiline':False]
['text':' If we did not find any const folding then return early without a const fold subgraph.','line_number':189,'multiline':False]
['text':' Partition the module into two: submod_0 for constant folding subgraph, and','line_number':193,'multiline':False]
['text':' submod_1 for the rest.','line_number':194,'multiline':False]
['text':' The module that a call_module node refers to gets copied to submodules during split.','line_number':203,'multiline':False]
['text':' The path to the module also gets inlined, i.e. mod.a.b -> mod_a_b. Here we need to','line_number':204,'multiline':False]
['text':' attach inlined modules to `split` as it's the owning module now.','line_number':205,'multiline':False]
['text':' split_module currently does not use get_attrs for attrs. Instead it passes','line_number':213,'multiline':False]
['text':' them in as args from the parent module, which used get_attrs. Here we set','line_number':214,'multiline':False]
['text':' them as get_attrs inside const_gm, allowing for running folding without','line_number':215,'multiline':False]
['text':' somehow a priori knowing the attrs that should be passed as args. We can','line_number':216,'multiline':False]
['text':' unconditionally do this for all placeholders because we know all','line_number':217,'multiline':False]
['text':' placeholders to const_gm must be constants accessible via get_attr.','line_number':218,'multiline':False]
['text':' Here we do the actual replacement of placeholders to get_attrs. Note that here we','line_number':227,'multiline':False]
['text':' set the const_gm.graph into a new root_const_gm with split as the root module,','line_number':228,'multiline':False]
['text':' because we are fetching attributes directly from the root module, instead of','line_number':229,'multiline':False]
['text':' fetching them from const_gm. Example: The const_gm must have some format like:','line_number':230,'multiline':False]
['text':' graph():','line_number':231,'multiline':False]
['text':'    %inp : [num_users=1] = placeholder[target=const_inp]','line_number':232,'multiline':False]
['text':'    %add : [num_users=1] = call_function[target=operator.add](args = (%inp, %inp), kwargs = {})','line_number':233,'multiline':False]
['text':'    return add','line_number':234,'multiline':False]
['text':' We replace that with the following, which does not have any placeholders:','line_number':235,'multiline':False]
['text':' graph():','line_number':236,'multiline':False]
['text':'    %inp_1 : [num_users=1] = get_attr[target=const_inp]','line_number':237,'multiline':False]
['text':'    %add : [num_users=1] = call_function[target=operator.add](args = (%inp_1, %inp_1), kwargs = {})','line_number':238,'multiline':False]
['text':'    return add','line_number':239,'multiline':False]
['text':' Now find the call to const_gm inside split, and replace it with a getattr to the','line_number':256,'multiline':False]
['text':' folded tensor(s) that result from constant folding. Note that we don't need to','line_number':257,'multiline':False]
['text':' worry about whether this is one or more tensors because the original graph','line_number':258,'multiline':False]
['text':' correctly uses getitem to extract individual tensors if there are multiple folded.','line_number':259,'multiline':False]
['text':' Finally, inline the non-constant submod into the split submod. This is so that the','line_number':278,'multiline':False]
['text':' original caller who may have passed in a graph module will get back out a graph','line_number':279,'multiline':False]
['text':' module whose graph is traced to the same granularity.','line_number':280,'multiline':False]
