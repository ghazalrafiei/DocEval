['text':' SymDispatchMode gets invoked whenever an operation is processed on','line_number':8,'multiline':False]
['text':' a PySymInt.  When this occurs, you get called at __sym_dispatch__','line_number':9,'multiline':False]
['text':' with the operation in question.  This is symmetric to TorchDispatchMode','line_number':10,'multiline':False]
['text':' but with some caveats:','line_number':11,'multiline':False]
['text':'','line_number':12,'multiline':False]
['text':'   - In TorchDispatchMode, you get the same arguments as what a user','line_number':13,'multiline':False]
['text':'     invoked your API with; e.g., if you call torch.ops.aten.foo(a, b),','line_number':14,'multiline':False]
['text':'     you get (a, b) as args to your call.  In SymDispatchMode, if','line_number':15,'multiline':False]
['text':'     you call a + b (where a and b are SymInts), you will get','line_number':16,'multiline':False]
['text':'     (a.node, b.node) as your args (these are PySymInts)','line_number':17,'multiline':False]
['text':'','line_number':18,'multiline':False]
['text':'   - SymInt/PySymInt don't have FX proxy support (unlike, e.g., Tensor).','line_number':19,'multiline':False]
['text':'     So you have to manually call Tracer/create_node to write into','line_number':20,'multiline':False]
['text':'     the graph.  See ProxySymDispatchMode for an example','line_number':21,'multiline':False]
['text':'','line_number':22,'multiline':False]
['text':' TODO: properly compute types','line_number':50,'multiline':False]
