['text':' noqa: F401','line_number':25,'multiline':False]
['text':' noqa: F401','line_number':26,'multiline':False]
['text':' Mapping of builtins to their `typing` equivalent.','line_number':29,'multiline':False]
['text':' Signature for functions thattransforms the body (`list[str]`) of the','line_number':39,'multiline':False]
['text':' generated code','line_number':40,'multiline':False]
['text':' How to import this object from the standard library.','line_number':51,'multiline':False]
['text':' The actual object, produced from that import string.','line_number':53,'multiline':False]
['text':' exclude torch because torch.torch.torch.torch works. idk mang','line_number':106,'multiline':False]
['text':' delete all characters that are illegal in a Python identifier','line_number':142,'multiline':False]
['text':' 1. keywords are never allowed as names.','line_number':186,'multiline':False]
['text':' 2. Can't shadow a builtin name, unless you *are* that builtin.','line_number':190,'multiline':False]
['text':' 3. Can't shadow our custom builtins either','line_number':194,'multiline':False]
['text':' Python source code for the forward function definition.','line_number':229,'multiline':False]
['text':' Values in global scope during execution of `src_def`.','line_number':231,'multiline':False]
['text':' Optional mapping from the forward function's line number to','line_number':233,'multiline':False]
['text':' node index.','line_number':234,'multiline':False]
['text':' get File:lineno code from stack_trace','line_number':287,'multiline':False]
['text':' stacktrace should have innermost frame last, so we','line_number':294,'multiline':False]
['text':' iterate backwards to find the first line that starts','line_number':295,'multiline':False]
['text':' with 'File '','line_number':296,'multiline':False]
['text':' next line should be the code','line_number':304,'multiline':False]
['text':' If the original function didn't have self as its first argument, we','line_number':321,'multiline':False]
['text':' would have added it.','line_number':322,'multiline':False]
['text':' Wrap string in list to pass by reference','line_number':368,'multiline':False]
['text':' to support registering torch.device','line_number':379,'multiline':False]
['text':' HACK: workaround for how torch custom ops are registered. We','line_number':380,'multiline':False]
['text':' can't import them like normal modules so they must retain their','line_number':381,'multiline':False]
['text':' fully qualified name.','line_number':382,'multiline':False]
['text':' normalize the name hint to get a proper identifier','line_number':385,'multiline':False]
['text':' Pre-fill the globals table with registered builtins.','line_number':394,'multiline':False]
['text':' Empty tuple is used for empty tuple type annotation Tuple[()]','line_number':400,'multiline':False]
['text':' This is a generic type, e.g. typing.List[torch.Tensor]','line_number':406,'multiline':False]
['text':' Assign global names for each of the inner type variables.','line_number':411,'multiline':False]
['text':' Bare type, such as `typing.Tuple` with no subscript','line_number':415,'multiline':False]
['text':' This code-path used in Python < 3.9','line_number':416,'multiline':False]
['text':' Bare type, such as `typing.Tuple` with no subscript','line_number':421,'multiline':False]
['text':' This code-path used in Python 3.9+','line_number':422,'multiline':False]
['text':' Common case: this is a regular module name like 'foo.bar.baz'','line_number':425,'multiline':False]
['text':' Handle NamedTuples (if it has `_fields`) via add_global.','line_number':429,'multiline':False]
['text':' Run through reverse nodes and record the first instance of a use','line_number':451,'multiline':False]
['text':' of a given node. This represents the *last* use of the node in the','line_number':452,'multiline':False]
['text':' execution order of the program, which we will use to free unused','line_number':453,'multiline':False]
['text':' values','line_number':454,'multiline':False]
['text':' override annotation with more detailed information','line_number':519,'multiline':False]
['text':' use string as annotation, to make it valid python code','line_number':526,'multiline':False]
['text':' pretty print operators','line_number':550,'multiline':False]
['text':' pretty print inplace operators; required for jit.script to work properly','line_number':557,'multiline':False]
['text':' not currently supported in normal FX graphs, but generated by torchdynamo','line_number':558,'multiline':False]
['text':' special case for getattr: node.args could be 2-argument or 3-argument','line_number':566,'multiline':False]
['text':' 2-argument: attribute access; 3-argument: fall through to attrib function call with default value','line_number':567,'multiline':False]
['text':' NOTE: emit_node does not emit a string with newline. It depends','line_number':596,'multiline':False]
['text':' on delete_unused_values to append one','line_number':597,'multiline':False]
['text':' emit a counter comment to keep track of','line_number':600,'multiline':False]
['text':' node index, which will be deleted later','line_number':601,'multiline':False]
['text':' after going through _body_transformer','line_number':602,'multiline':False]
['text':' If the Graph has no non-placeholder nodes, no lines for the body','line_number':608,'multiline':False]
['text':' have been emitted. To continue to have valid Python code, emit a','line_number':609,'multiline':False]
['text':' single pass statement','line_number':610,'multiline':False]
['text':' remove counter and generate lineno to node index mapping','line_number':629,'multiline':False]
['text':' Ideally, we'd like to refactor all of the pytree logic into this codegen','line_number':653,'multiline':False]
['text':' class. Unfortunately, there are 3 areas we currently need extra logic in FX.','line_number':654,'multiline':False]
['text':' 1. In the initial symbolic trace, the pytree logic is tied up with `concrete_args`.','line_number':655,'multiline':False]
['text':' 2. In the FX graph, we need to access 2 attributes - in_spec and out_spec.','line_number':656,'multiline':False]
['text':'    Since we can't access .graph within the FX forward, we need to copy the attribute to the module.','line_number':657,'multiline':False]
['text':' 3. We currently can't register the pytree imports with `add_global` - not sure why.','line_number':658,'multiline':False]
['text':' Given a user function/model:','line_number':677,'multiline':False]
['text':'   myargs = [myargs0, myargs1]','line_number':678,'multiline':False]
['text':'   mykwargs = {'mykwargs0': ..., 'mykwargs1': ...}','line_number':679,'multiline':False]
['text':'   def forward(self, mypos, *myargs, mykey=None, **mykwargs):','line_number':680,'multiline':False]
['text':'','line_number':681,'multiline':False]
['text':' The generated code flattens all keywords into positional arguments for `forward()`','line_number':682,'multiline':False]
['text':'   e.g forward(self, mypos, myargs0, myargs1, mykey, mykwargs0, mykwargs1):','line_number':683,'multiline':False]
['text':'','line_number':684,'multiline':False]
['text':' Within `forward`, `tree_flatten_spec``still parses args and kwargs separately','line_number':685,'multiline':False]
['text':'   e.g. tree_flatten_spec(([mypos, myargs0, myargs1],','line_number':686,'multiline':False]
['text':'                           {'mykey':mykey, 'mykwargs0':mykwargs0, 'mykwargs1':mykwargs1}),','line_number':687,'multiline':False]
['text':'                          self._in_spec)','line_number':688,'multiline':False]
['text':'','line_number':689,'multiline':False]
['text':' If the user function/model does not have keywords, the dict is suppressed from tree_flatten_spec','line_number':690,'multiline':False]
['text':'   e.g. tree_flatten_spec([mypos, myargs0, myargs1]), self._in_spec)','line_number':691,'multiline':False]
['text':' pytree has placeholders in it','line_number':701,'multiline':False]
['text':' when kwargs is present, in_spec is tuple(args, kwargs)','line_number':702,'multiline':False]
['text':' in Python, `var1: annotation1, var2: annotation2 = function_call()` is invalid.','line_number':717,'multiline':False]
['text':' we need to split it to two lines:','line_number':718,'multiline':False]
['text':' one for annotation: `var1: annotation1; var2: annotation2;` (note the semicolon)','line_number':719,'multiline':False]
['text':' one for code: `var1, var2, = function_call()`','line_number':720,'multiline':False]
['text':' base name -> number','line_number':787,'multiline':False]
['text':' iterators may retain handles to erased nodes','line_number':942,'multiline':False]
['text':' Null out this Node's argument nodes so that the Nodes referred to','line_number':945,'multiline':False]
['text':' can update their ``users`` accordingly','line_number':946,'multiline':False]
['text':' NOTE: [Graph Namespaces]','line_number':1284,'multiline':False]
['text':'','line_number':1285,'multiline':False]
['text':' There are two types of symbols in generated Python source code:','line_number':1286,'multiline':False]
['text':' locals and globals.','line_number':1287,'multiline':False]
['text':'   Locals are locally defined by the output of a node in the Graph.','line_number':1288,'multiline':False]
['text':'   Globals are references to external objects, like functions or types.','line_number':1289,'multiline':False]
['text':'','line_number':1290,'multiline':False]
['text':' When generating Python code, we need to make sure to name things','line_number':1291,'multiline':False]
['text':' appropriately. In particular:','line_number':1292,'multiline':False]
['text':' - All names should be unique, to avoid weird shadowing bugs.','line_number':1293,'multiline':False]
['text':' - These names need to be consistent, e.g. a object should always be','line_number':1294,'multiline':False]
['text':'   referenced by the same name.','line_number':1295,'multiline':False]
['text':'','line_number':1296,'multiline':False]
['text':' To do this, we create a new namespace just for this source. All names','line_number':1297,'multiline':False]
['text':' that get printed must come from this namespace.','line_number':1298,'multiline':False]
['text':'','line_number':1299,'multiline':False]
['text':' Why can't we re-use node.name? Because it was generated within the','line_number':1300,'multiline':False]
['text':' namespace `self._graph_namespace`. In order to provide uniqueness','line_number':1301,'multiline':False]
['text':' over both locals (node.name) *and* globals, we create a completely','line_number':1302,'multiline':False]
['text':' new namespace to put all identifiers in.','line_number':1303,'multiline':False]
['text':' Override Node's repr to generate a valid name within our namespace.','line_number':1306,'multiline':False]
['text':' Since repr() is designed to produce a valid Python expression, it','line_number':1307,'multiline':False]
['text':' makes sense to re-use it. This way, it's easy to print something like','line_number':1308,'multiline':False]
['text':' Tuple[Node, Node] by simply calling repr() on it. Node's __repr__ is','line_number':1309,'multiline':False]
['text':' implemented cooperatively to allow this.','line_number':1310,'multiline':False]
['text':' restore the original repr functions','line_number':1323,'multiline':False]
['text':' This is a one-element array just so ``format_node`` can modify the closed','line_number':1340,'multiline':False]
['text':' over value','line_number':1341,'multiline':False]
['text':' Check topo order','line_number':1383,'multiline':False]
['text':' Check targets are legit','line_number':1409,'multiline':False]
['text':' Lint the graph first to make sure its topologically sorted, otherwise','line_number':1480,'multiline':False]
['text':' DCE below will not behave as expected.','line_number':1481,'multiline':False]
['text':' Reverse iterate so that when we remove a node, any nodes used as an','line_number':1484,'multiline':False]
['text':' input to that node have an updated user count that no longer reflects','line_number':1485,'multiline':False]
['text':' the removed node.','line_number':1486,'multiline':False]
