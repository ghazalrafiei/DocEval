['text':' type: ignore[no-redef]','line_number':36,'multiline':False]
['text':' TODO: Figure out if this is safe. It seems like when generating the type signatures for','line_number':72,'multiline':False]
['text':' PythonArgParser, we emit signatures with `input` instead of `self` as the first tensor','line_number':73,'multiline':False]
['text':' argument name. Downstream, if someone converts that positional argument to a keyword','line_number':74,'multiline':False]
['text':' argument, the name mismatch will break things, so here we're going to normalize the','line_number':75,'multiline':False]
['text':' name to "input"','line_number':76,'multiline':False]
['text':' "from" is a keyword therefore it must be a POSITIONAL_ONLY argument','line_number':79,'multiline':False]
['text':' ParameterKind type is internal implementation detail to inspec package','line_number':82,'multiline':False]
['text':' which makes it hard to do type annotation','line_number':83,'multiline':False]
['text':' type: ignore[assignment]','line_number':84,'multiline':False]
['text':' This renders all previous arguments to positional only','line_number':85,'multiline':False]
['text':' Cached as it's called in the hot path of FakeTensor dispatch','line_number':103,'multiline':False]
['text':' Iterate through all of the schema until we find one that matches','line_number':120,'multiline':False]
['text':' If one matches, populate `new_args_and_kwargs` with the new args/kwargs','line_number':121,'multiline':False]
['text':' values. If none matches, `new_args_and_kwargs` will be None','line_number':122,'multiline':False]
['text':' Did not match any schema. Cannot check for mutation','line_number':137,'multiline':False]
['text':' Matched exactly one schema, unambiguous','line_number':140,'multiline':False]
['text':' Ambiguous schema match. Since mutability checking is best effort,','line_number':145,'multiline':False]
['text':' do nothing.','line_number':146,'multiline':False]
['text':' todo(chilli): Figure out the right way for mypy to handle this','line_number':187,'multiline':False]
['text':' type: ignore[valid-type]','line_number':190,'multiline':False]
['text':' We tried to create a type hint for list but failed.','line_number':206,'multiline':False]
['text':' Union types in signature. Given type needs to match one of the','line_number':218,'multiline':False]
['text':' contained types in the Union','line_number':219,'multiline':False]
['text':' int can be promoted to List[int]','line_number':225,'multiline':False]
['text':' Tuple[()].__args__ == ((),) for some reason','line_number':241,'multiline':False]
['text':' Tuple[T] is accepted for List[T] parameters','line_number':245,'multiline':False]
['text':' Dtype is an int in schemas','line_number':248,'multiline':False]
['text':' HACK: `boolean_dispatch` as used in `torch.nn.functional` makes it so that we have','line_number':294,'multiline':False]
['text':' a 2-way dispatch based on a boolean value. Here we check that the `true` and `false`','line_number':295,'multiline':False]
['text':' branches of the dispatch have exactly the same signature. If they do, use the `true`','line_number':296,'multiline':False]
['text':' branch signature for analysis. Otherwise, leave this un-normalized','line_number':297,'multiline':False]
['text':' Iterate through all of the schema until we find one that matches','line_number':313,'multiline':False]
['text':' If one matches, populate `new_args_and_kwargs` with the new args/kwargs','line_number':314,'multiline':False]
['text':' values. If none matches, `new_args_and_kwargs` will be None','line_number':315,'multiline':False]
['text':' Did not match any schema. Cannot normalize','line_number':324,'multiline':False]
['text':' Matched exactly one schema, unambiguous','line_number':327,'multiline':False]
['text':' Matched more than one schema. In this situation, the caller must provide the types of','line_number':348,'multiline':False]
['text':' the arguments of the overload they expect.','line_number':349,'multiline':False]
['text':' Don't currently support positional-only','line_number':417,'multiline':False]
['text':' or varargs (*args, **kwargs) signatures','line_number':418,'multiline':False]
['text':' Add an exception for one signature, which is common for random/uniform, i.e.:','line_number':422,'multiline':False]
['text':' Tensor(a!) self, float from=0, float to=1, *, Generator? generator=None','line_number':423,'multiline':False]
['text':' `from` is Python keyword and as such functions with that signature should have','line_number':424,'multiline':False]
['text':' positional-only args, but at the same time they could be dispatched as kwargs','line_number':425,'multiline':False]
