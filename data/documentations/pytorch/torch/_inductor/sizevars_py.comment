['text':' This class is a little awkward, because ShapeEnv is doing most of the heavy','line_number':19,'multiline':False]
['text':' lifting and in some cases we should be directly passing through to ShapeEnv,','line_number':20,'multiline':False]
['text':' but there is some extra inductor logic that needs to be handled here','line_number':21,'multiline':False]
['text':' Maps of dynamic sizes that have to be precomputed on the host to the kernel args.','line_number':30,'multiline':False]
['text':' The basic idea is if we have some complicated sympy expression','line_number':31,'multiline':False]
['text':' f(s0), we may choose to precompute it on the host and then replace','line_number':32,'multiline':False]
['text':' all occurrences of that sympy expression with ps0, so that when we','line_number':33,'multiline':False]
['text':' codegen we simply reference ps0 directly without repeating','line_number':34,'multiline':False]
['text':' f(s0).  Unlike regular size variables, ps variables cannot be','line_number':35,'multiline':False]
['text':' guarded upon; so if we are asked to guard on a Sympy expression','line_number':36,'multiline':False]
['text':' which potentially could have already had a precomputed replacement','line_number':37,'multiline':False]
['text':' on it, we are obligated to invert the precomputed replacements','line_number':38,'multiline':False]
['text':' (inv_precomputed_replacements).','line_number':39,'multiline':False]
['text':' new replacements invalidates cached results','line_number':59,'multiline':False]
['text':' new replacements invalidates cached results','line_number':81,'multiline':False]
['text':' var smaller than divisor can be removed','line_number':106,'multiline':False]
['text':' if the rest is guaranteed to be multiple of divisor','line_number':107,'multiline':False]
['text':' for modular indexing, biggest values from the ranges don't necessarily result in','line_number':124,'multiline':False]
['text':' the biggest result, the biggest result is modulus - 1','line_number':125,'multiline':False]
['text':' actual iteration range is to size-1','line_number':128,'multiline':False]
['text':' can't replace with indexing div if base can be negative','line_number':132,'multiline':False]
['text':' remove dim','line_number':183,'multiline':False]
['text':' approximate test passed, try sound version','line_number':191,'multiline':False]
['text':' Note - [On Statically Known]','line_number':232,'multiline':False]
['text':'','line_number':233,'multiline':False]
['text':' The statically_known_* family of functions below replaces a prior system, called maybe_guard_*. The prior system','line_number':234,'multiline':False]
['text':' operated by providing essentially a question, where the size hinted values were evaluated. If the condition was','line_number':235,'multiline':False]
['text':' true, we add a guard and return True, otherwise, False.','line_number':236,'multiline':False]
['text':'','line_number':237,'multiline':False]
['text':' def maybe_guard_foo(args):','line_number':238,'multiline':False]
['text':'   if size_hinted_check(args):','line_number':239,'multiline':False]
['text':'       return False # No guard, no optim','line_number':240,'multiline':False]
['text':'   guard(args) # Make a guard','line_number':241,'multiline':False]
['text':'   return True # Safe to apply optimization','line_number':242,'multiline':False]
['text':'','line_number':243,'multiline':False]
['text':' The prior system incurred a guard, and green lit an optimization.','line_number':244,'multiline':False]
['text':'','line_number':245,'multiline':False]
['text':' The new system works in reverse - in the new system, if we know that the inputs are static, and evaluate the','line_number':246,'multiline':False]
['text':' condition as true, we green light the optimization, and we do not incur a guard. If we cannot prove that, we','line_number':247,'multiline':False]
['text':' return False.','line_number':248,'multiline':False]
['text':'','line_number':249,'multiline':False]
['text':' def maybe_guard_foo(args):','line_number':250,'multiline':False]
['text':'   if all_static(args):','line_number':251,'multiline':False]
['text':'       return True # Safe to apply optimization','line_number':252,'multiline':False]
['text':'   else:','line_number':253,'multiline':False]
['text':'       return False # No guard, no optim','line_number':254,'multiline':False]
['text':' See Note - [On Statically Known]','line_number':256,'multiline':False]
['text':' See Note - [On Statically Known]','line_number':277,'multiline':False]
['text':' See Note - [On Statically Known]','line_number':288,'multiline':False]
['text':' See Note - [On Statically Known]','line_number':296,'multiline':False]
['text':' See Note - [On Statically Known]','line_number':304,'multiline':False]
['text':' The guard functions require you to ALREADY KNOW that a particular','line_number':312,'multiline':False]
['text':' condition holds.  If you don't know (you want to guard on an expression','line_number':313,'multiline':False]
['text':' being a particular value, and then get access to that value), use','line_number':314,'multiline':False]
['text':' the evaluate functions.','line_number':315,'multiline':False]
['text':' The evaluate functions evaluate some symbolic sympy expression','line_number':331,'multiline':False]
['text':' (NB: not necessarily an Expr) and return what the concrete result','line_number':332,'multiline':False]
['text':' is, guarding on the expression being that result','line_number':333,'multiline':False]
['text':' NB: write evaluate_expr(sympy.Lt(a, b)) rather than evaluate_expr(a < b)','line_number':335,'multiline':False]
['text':' as this will ensure that you actually have a sympy'ified expression,','line_number':336,'multiline':False]
['text':' and will prevent you from incorrectly writing evaluate_expr(a == b)','line_number':337,'multiline':False]
['text':' which does the wrong thing if a or b is a sympy expression','line_number':338,'multiline':False]
['text':' Substitute all hints into expr, but leave unbacked symints alone','line_number':363,'multiline':False]
['text':' Use the provided heuristic fallback hint','line_number':378,'multiline':False]
['text':' remove any offset','line_number':446,'multiline':False]
['text':' drop all the other dims','line_number':451,'multiline':False]
['text':' TODO(jansel): should we use sympy.diff here?','line_number':464,'multiline':False]
['text':' fast exit path','line_number':512,'multiline':False]
['text':' in case of success we get an empty dict here','line_number':560,'multiline':False]
['text':' type: ignore[name-defined]','line_number':571,'multiline':False]
