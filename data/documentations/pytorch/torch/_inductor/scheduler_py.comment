['text':' TODO when we drop support for Python < 3.10, we can use','line_number':58,'multiline':False]
['text':' @dataclass(slots=True) instead of manually specifying __slots__.','line_number':59,'multiline':False]
['text':' pformat has trouble with sets of sympy exprs','line_number':81,'multiline':False]
['text':' TODO(xmfan): reuse an existing mapping for this if it exists, or formalize this into ir.py:ExternKernel','line_number':113,'multiline':False]
['text':' buffers that won't be used after this kernel','line_number':135,'multiline':False]
['text':' deduplicate','line_number':181,'multiline':False]
['text':' needed to avoid deallocating aliased buffer','line_number':227,'multiline':False]
['text':' if there are still uses of aliases ahead','line_number':228,'multiline':False]
['text':' Prune weak dependencies on buffers that have been removed','line_number':241,'multiline':False]
['text':' These can occur because fused nodes always gather deps from their snodes','line_number':268,'multiline':False]
['text':' If B has a weakdep on A','line_number':269,'multiline':False]
['text':' B gets fused with C, then any time BC is fused, the weakdep will reappear','line_number':270,'multiline':False]
['text':' o what have i done.  lets make this an api','line_number':331,'multiline':False]
['text':' hacky check for if V.kernel is a real kernel or NullHandler','line_number':380,'multiline':False]
['text':' if there isn't a triton kernel, then we don't need to call triton-specific things.','line_number':382,'multiline':False]
['text':' but TODO this might be a convenient place to signal to the Collective kernels to inplace','line_number':383,'multiline':False]
['text':' (and, can we make "kernel" less generic of a name?)','line_number':384,'multiline':False]
['text':' mutations not tracked in cpp kernels','line_number':388,'multiline':False]
['text':' update last usage of reused node','line_number':395,'multiline':False]
['text':' hacky check for if V.kernel is a real kernel or NullHandler','line_number':413,'multiline':False]
['text':' These are boring and samey','line_number':444,'multiline':False]
['text':' TODO(voz): Should the pragma be constant somewhere?','line_number':448,'multiline':False]
['text':' TODO(voz): Ostensibly, we should not need this. But there are cases where C++ codegen does','line_number':469,'multiline':False]
['text':' not use BracesBuffer, so we have no good indicator of a C++ buffer atm.','line_number':470,'multiline':False]
['text':' Kind of a lazy way to get the MultiOutput nodes corresponding to','line_number':544,'multiline':False]
['text':' a MultiOutputLayout','line_number':545,'multiline':False]
['text':' default to no reordering based on runtime','line_number':578,'multiline':False]
['text':' if there is a resolved op, dry-run using fake mode and record flop count','line_number':591,'multiline':False]
['text':' TODO(xmfan): find a better heuristic to model FLOPS/latency relationship','line_number':608,'multiline':False]
['text':' Return estimated runtime in nanoseconds','line_number':615,'multiline':False]
['text':' Return estimated runtime in nanoseconds (bytes / gbps)','line_number':621,'multiline':False]
['text':' Collective kernels','line_number':624,'multiline':False]
['text':' ir.Wait is only used for collective ops.','line_number':628,'multiline':False]
['text':' The time needed for the collective op is already estimated and considered','line_number':629,'multiline':False]
['text':' when we are processing the collective op IR node, so ir.Wait takes 0 time','line_number':630,'multiline':False]
['text':' since it doesn't take extra time to get the result after the collective is completed.','line_number':631,'multiline':False]
['text':' don't allow reuse of an 'input' buffer, we don't own it','line_number':652,'multiline':False]
['text':' (would this have been fixed if I tracked mutations properly above?)','line_number':653,'multiline':False]
['text':' TODO make this a property of the IR','line_number':658,'multiline':False]
['text':' type: ignore[arg-type]','line_number':814,'multiline':False]
['text':' NB: No need to call super().__init__() because we don't need to re-use any of its logic.','line_number':817,'multiline':False]
['text':' type: ignore[assignment]','line_number':820,'multiline':False]
['text':' Set self.last_usage using the global information','line_number':862,'multiline':False]
['text':' This will be used for inter-kernel optimisations','line_number':863,'multiline':False]
['text':' Set self.last_usage on the snodes','line_number':865,'multiline':False]
['text':' This will be used for optimisations within the kernel','line_number':866,'multiline':False]
['text':' type: ignore[arg-type]','line_number':870,'multiline':False]
['text':' None of these need to be implemented, as a FusedSchedulerNode is just an','line_number':924,'multiline':False]
['text':' abstraction for scheduling purposes','line_number':925,'multiline':False]
['text':' type: ignore[assignment]','line_number':1060,'multiline':False]
['text':' 1-sizes don't matter, just move them to the end','line_number':1133,'multiline':False]
['text':' equivalent to','line_number':1139,'multiline':False]
['text':' np.logical_or(stride_lengths[:, b] == 0, stride_lengths[:, a] < stride_lengths[:, b]).all()','line_number':1140,'multiline':False]
['text':' otherwise contiguous','line_number':1152,'multiline':False]
['text':' if we have priority node, only use that node's order','line_number':1157,'multiline':False]
['text':' A weak user must be scheduled after a given node, but doesn't actually','line_number':1169,'multiline':False]
['text':' use the result','line_number':1170,'multiline':False]
['text':' some new constants could have been created above','line_number':1214,'multiline':False]
['text':' set in fuse_nods()','line_number':1224,'multiline':False]
['text':' mutation_real_name: Maps back to the original name for codegen','line_number':1226,'multiline':False]
['text':' Example:','line_number':1227,'multiline':False]
['text':' If you mutate buf0 inside of buf1's kernel, then:','line_number':1228,'multiline':False]
['text':' mutation_real_name = {"buf0" : "buf1"}','line_number':1229,'multiline':False]
['text':' all subsequent uses of buf0 become buf1's usage in dependency graph','line_number':1230,'multiline':False]
['text':' We handle mutation by renaming modified versions of the same','line_number':1233,'multiline':False]
['text':' buffer in the dependency graph to prevent cycles.','line_number':1234,'multiline':False]
['text':' mutation_renames: tracks the current name for a given buffer','line_number':1235,'multiline':False]
['text':'                   (changed once per mutation)','line_number':1236,'multiline':False]
['text':' Example:','line_number':1237,'multiline':False]
['text':' If you mutate buf0 inside of buf1's kernel, then:','line_number':1238,'multiline':False]
['text':' mutation_renames = {"buf1" : "buf0"}','line_number':1239,'multiline':False]
['text':' in codegen we only use buf0, never buf1','line_number':1240,'multiline':False]
['text':' Refresh node_users and inverse_users to reflect fused nodes','line_number':1259,'multiline':False]
['text':' used during codegen:','line_number':1267,'multiline':False]
['text':' type: ignore[assignment]','line_number':1268,'multiline':False]
['text':' fx graph node to the position it appears in the graph','line_number':1271,'multiline':False]
['text':' for debug attribution','line_number':1272,'multiline':False]
['text':' All nodes eliminated','line_number':1323,'multiline':False]
['text':' type: ignore[arg-type]','line_number':1329,'multiline':False]
['text':' handle aliasing by using python aliasing in name_to_users','line_number':1379,'multiline':False]
['text':' if foo aliases bar then we will make name_to_users["foo"] point','line_number':1380,'multiline':False]
['text':' to the same python list as name_to_users["bar"]','line_number':1381,'multiline':False]
['text':' merge the two','line_number':1386,'multiline':False]
['text':' unbacked symbols don't follow ordinary buffer dependencies, so','line_number':1428,'multiline':False]
['text':' we track their def/uses separately','line_number':1429,'multiline':False]
['text':' Pick the first definer as canonical.  There may be multiple','line_number':1432,'multiline':False]
['text':' because if a MultiOutputLayout buffer propagates an unbacked','line_number':1433,'multiline':False]
['text':' symint to multiple outputs, they will all claim to def it.','line_number':1434,'multiline':False]
['text':' if a kernel takes unbacked symints, register dependencies','line_number':1438,'multiline':False]
['text':' a node will mutate either 0 or 1 buffers','line_number':1445,'multiline':False]
['text':' this node must run after the prior writer','line_number':1449,'multiline':False]
['text':' this node must run after all prior readers','line_number':1453,'multiline':False]
['text':' If this node already directly or indirectly depends on other_node,','line_number':1457,'multiline':False]
['text':' we don't need to insert an extra dep.','line_number':1458,'multiline':False]
['text':' add normal non-mutation dependencies','line_number':1462,'multiline':False]
['text':' update our renaming scheme for the next iteration','line_number':1469,'multiline':False]
['text':' make sure outputs aren't dead-code-eliminated','line_number':1477,'multiline':False]
['text':' make sure unbacked symints aren't dead-code-eliminated','line_number':1482,'multiline':False]
['text':' make sure input mutation isn't dead-code-eliminated','line_number':1495,'multiline':False]
['text':' copy users information onto the nodes','line_number':1508,'multiline':False]
['text':' populate inverse_users','line_number':1512,'multiline':False]
['text':' set up buffer name to (fused)snode mapping','line_number':1518,'multiline':False]
['text':' compute inverse_users','line_number':1530,'multiline':False]
['text':' compute node_users','line_number':1539,'multiline':False]
['text':' TODO: ideally, we should deduplicate .users and .node_users,','line_number':1540,'multiline':False]
['text':' but currently .users contains extra information that's difficult to','line_number':1541,'multiline':False]
['text':' extract into a standalone container.','line_number':1542,'multiline':False]
['text':' repeat until a fixed point','line_number':1554,'multiline':False]
['text':' dead code','line_number':1569,'multiline':False]
['text':' Prune any WeakDeps no longer needed','line_number':1576,'multiline':False]
['text':' note self.nodes is topologically sorted','line_number':1606,'multiline':False]
['text':' TODO support benchmarking epilogue fusion','line_number':1662,'multiline':False]
['text':' don't support benchmark fusion for CPU right now.','line_number':1668,'multiline':False]
['text':' We can not accurately benchmark kernel using atomic_add','line_number':1675,'multiline':False]
['text':' due to how we generate random integer inputs.','line_number':1676,'multiline':False]
['text':' Skip benchmarking them by allowing fusion.','line_number':1677,'multiline':False]
['text':' workaround triton issue: https://github.com/openai/triton/issues/2151','line_number':1708,'multiline':False]
['text':' allow fusion','line_number':1710,'multiline':False]
['text':' foreach fusions and epilogue fusions are order dependent','line_number':1801,'multiline':False]
['text':' only fused nodes can introduce new ancestors.','line_number':1835,'multiline':False]
['text':' All fusion outputs are in ancestors of node1 and node2, thus','line_number':1839,'multiline':False]
['text':' cannot introduce new path:','line_number':1840,'multiline':False]
['text':'','line_number':1841,'multiline':False]
['text':' 1. if output is neither descendent of node1 or node2, the','line_number':1842,'multiline':False]
['text':'        output cannot introduce a path','line_number':1843,'multiline':False]
['text':' 2. due to [can_fuse]: if WLOG output is descendent of node1, it cannot be','line_number':1844,'multiline':False]
['text':'        on path(node1->node2), hence it cannot be ancestor of node2','line_number':1845,'multiline':False]
['text':' 3. due to [acyclic]: if WLOG output is descendent of node1, it cannot be','line_number':1846,'multiline':False]
['text':'        ancestor of node1','line_number':1847,'multiline':False]
['text':' continue DFS of new ancestors introduced by the fusion','line_number':1850,'multiline':False]
['text':' Fix issue: https://github.com/pytorch/pytorch/issues/108963','line_number':1928,'multiline':False]
['text':' Check:','line_number':1929,'multiline':False]
['text':'   If node2 reads a buf which is a mutation buf of node1(SchedulerNode) or among nodes in node1(FusedSchedulerNode),','line_number':1930,'multiline':False]
['text':'   we will get the corresponding mutation buf and check if this mutation buf is stored by atomic_add mode.','line_number':1931,'multiline':False]
['text':' If True, we will disable the fusion of node1 and node2.','line_number':1932,'multiline':False]
['text':' heuristic not needed for correctness','line_number':1965,'multiline':False]
['text':' heuristic not needed for correctness','line_number':1973,'multiline':False]
['text':' node2 depends on node1 outputs','line_number':1976,'multiline':False]
['text':' nodes don't depend on each other, but may have common reads','line_number':1980,'multiline':False]
['text':' StarDep doesn't match MemoryDep, different indices don't match','line_number':2000,'multiline':False]
['text':' However, broadcasting sometimes strips dimensions, and if that's the case','line_number':2001,'multiline':False]
['text':' we still can match unmet dep','line_number':2002,'multiline':False]
['text':' if there's indirect indexing, don't match it','line_number':2003,'multiline':False]
['text':' MemoryDeps didn't match and read different locations of the same buffer.','line_number':2017,'multiline':False]
['text':' Examples here include:','line_number':2018,'multiline':False]
['text':'   - MemoryDep("foo", x) != MemoryDep("foo", x + 1)','line_number':2019,'multiline':False]
['text':'   - MemoryDep("foo", x) != StarDep("foo")','line_number':2020,'multiline':False]
['text':' V.kernel.store_buffer_names should represent the set of nodes','line_number':2107,'multiline':False]
['text':' get fused','line_number':2108,'multiline':False]
['text':' Assign a special value instead of deleting the entry','line_number':2141,'multiline':False]
['text':' because we still rely on output_buffers's length to','line_number':2142,'multiline':False]
['text':' generate unique arg name.','line_number':2143,'multiline':False]
['text':' 'decide_inplace_update' stores the inplace update decisions in','line_number':2163,'multiline':False]
['text':' the current kernel from where 'allocate' retrieve those decisions.','line_number':2164,'multiline':False]
['text':' We have to make sure there is a non-NULL kernel handler to store','line_number':2165,'multiline':False]
['text':' those inplace update decisions.','line_number':2166,'multiline':False]
['text':' noqa: B950','line_number':2189,'multiline':False]
['text':' noqa: B950','line_number':2193,'multiline':False]
['text':' all graph inputs or constants are assumed to be aligned','line_number':2281,'multiline':False]
