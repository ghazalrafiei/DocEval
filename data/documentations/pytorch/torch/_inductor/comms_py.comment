['text':' pyre-strict','line_number':1,'multiline':False]
['text':' Enforce ordering by making previous comm a `WeakDep` dependency of the next comm','line_number':105,'multiline':False]
['text':' if there is no comm nodes, return the current order','line_number':149,'multiline':False]
['text':' NOTE: since model graph is always a DAG and does not have circular dependency inside,','line_number':187,'multiline':False]
['text':' there should be at least one node that is a "free node" (i.e. indeg == 0),','line_number':188,'multiline':False]
['text':' hence infinite loop is not possible. But we check here just to be safe.','line_number':189,'multiline':False]
['text':' First, schedule all compute nodes that are required by first comm node,','line_number':202,'multiline':False]
['text':' as well as the first comm node itself.','line_number':203,'multiline':False]
['text':' Step 1: Given that we've currently scheduled comm `idx-1`, we now schedule','line_number':211,'multiline':False]
['text':' all compute nodes that are required for comm `idx` but do not depend on comm `idx-1`,','line_number':212,'multiline':False]
['text':' to run at the same time with comm `idx-1`.','line_number':213,'multiline':False]
['text':' Step 2: If all those compute nodes are sufficient to overlap comm `idx-1`, we're done.','line_number':228,'multiline':False]
['text':' Otherwise, we now need to look elsewhere to find compute that overlaps with comm `idx`.','line_number':229,'multiline':False]
['text':' We prioritize compute nodes that are needed sooner.','line_number':230,'multiline':False]
['text':' Find all ready to schedule compute nodes that do not depend on comm `idx-1`.','line_number':235,'multiline':False]
['text':' Prioritize compute nodes that are needed sooner.','line_number':247,'multiline':False]
['text':' If accumulated compute runtime cost is greater than comm `idx-1` runtime cost,','line_number':254,'multiline':False]
['text':' it means we have maximized overlap for comm `idx-1`, and hence we stop looking','line_number':255,'multiline':False]
['text':' for more compute to schedule.','line_number':256,'multiline':False]
['text':' If we're not able to leverage more than half of this','line_number':259,'multiline':False]
['text':' node's compute to overlap, we skip it.','line_number':260,'multiline':False]
['text':' TODO: Smarter heuristics here','line_number':261,'multiline':False]
['text':' Step 3: We schedule the compute nodes dependent on comm `idx-1` and required for comm `idx`.','line_number':270,'multiline':False]
['text':' Step 4: We schedule comm `idx`.','line_number':274,'multiline':False]
['text':' The idea here is that if there are no compute nodes from Step 3','line_number':278,'multiline':False]
['text':' (i.e. if prev comm is not blocking next comm), we can roll over the compute nodes','line_number':279,'multiline':False]
['text':' in Step 2 to overlap with the next comm, since they're not required to finish','line_number':280,'multiline':False]
['text':' before the next comm starts.','line_number':281,'multiline':False]
['text':' type: ignore[assignment]','line_number':285,'multiline':False]
['text':' exposed compute op','line_number':322,'multiline':False]
['text':' noqa: G004','line_number':324,'multiline':False]
['text':' cur_comm_node is not None','line_number':325,'multiline':False]
['text':' end of this comm op','line_number':331,'multiline':False]
['text':' noqa: G004','line_number':332,'multiline':False]
['text':' overlapped compute op','line_number':334,'multiline':False]
['text':' noqa: G004','line_number':335,'multiline':False]
['text':' noqa: G004','line_number':337,'multiline':False]
['text':' it is a builtin pass','line_number':347,'multiline':False]
['text':' noqa: G004','line_number':350,'multiline':False]
['text':' type: ignore[operator]','line_number':356,'multiline':False]
['text':' noqa: G004','line_number':359,'multiline':False]
