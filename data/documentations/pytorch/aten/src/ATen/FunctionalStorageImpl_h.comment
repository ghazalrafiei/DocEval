['text':' See Note [Functionalization Pass In Core]','line_number':7,'multiline':False]
['text':' ViewMeta is a class used by the functionalization pass to navigate between','line_number':9,'multiline':False]
['text':' a base tensor and a view tensor.','line_number':10,'multiline':False]
['text':' For example, if I call `b = a.view1(...)`','line_number':11,'multiline':False]
['text':' the functionalization pass will generate and store a ViewMeta on b that looks','line_number':12,'multiline':False]
['text':' like:','line_number':13,'multiline':False]
['text':'','line_number':14,'multiline':False]
['text':' ViewMeta(','line_number':15,'multiline':False]
['text':'   [<captures>](const Tensor& base, int64_t mutated_view_idx) {','line_number':16,'multiline':False]
['text':'     return base.view1(...);','line_number':17,'multiline':False]
['text':'   },','line_number':18,'multiline':False]
['text':'   [<captures>](const at::Tensor& base, const at::Tensor& mutated_view,','line_number':19,'multiline':False]
['text':'   int64_t mutated_view_idx) -> at::Tensor {','line_number':20,'multiline':False]
['text':'     return at::functionalization::impl::view1_inverse(base, mutated_view,','line_number':21,'multiline':False]
['text':'     ...);','line_number':22,'multiline':False]
['text':'   }','line_number':23,'multiline':False]
['text':'','line_number':24,'multiline':False]
['text':' The forward_fn lambda describes how to replay view1 on a tensor.','line_number':25,'multiline':False]
['text':'','line_number':26,'multiline':False]
['text':' The reverse_fn lambda describes how, given a tensor that is already a view,','line_number':27,'multiline':False]
['text':' how to get the corresponding base tensor. See Note [Functionalization Pass:','line_number':28,'multiline':False]
['text':' View Inverses] for details.','line_number':29,'multiline':False]
['text':' See Note [out_idx in ViewMeta]','line_number':43,'multiline':False]
['text':' Tells us if this is a multi-output view','line_number':46,'multiline':False]
['text':' Returns a copy of the current ViewMeta, if out_idx matches the current','line_number':49,'multiline':False]
['text':' out_index. Otherwise, returns a new ViewMeta with the same forward/reverse','line_number':50,'multiline':False]
['text':' functions, but a new out index.','line_number':51,'multiline':False]
['text':' FunctionalStorageImpl is a subclass of StorageImpl used by the','line_number':55,'multiline':False]
['text':' functionalization pass. It has no underlying data (similar to meta storage).','line_number':56,'multiline':False]
['text':' It also knows how to reflect mutations to tensors in the absence of a valid','line_number':57,'multiline':False]
['text':' data pointer.','line_number':58,'multiline':False]
['text':'','line_number':59,'multiline':False]
['text':' A storage represents the state shared by (potentially multiple) views of the','line_number':60,'multiline':False]
['text':' same tensor. For example, in the following code:','line_number':61,'multiline':False]
['text':'','line_number':62,'multiline':False]
['text':' b = a.view1(...)','line_number':63,'multiline':False]
['text':' c = b.view2(...)','line_number':64,'multiline':False]
['text':' b.add_(1)','line_number':65,'multiline':False]
['text':' --> storage.add_update(b, {view1_meta})','line_number':66,'multiline':False]
['text':'','line_number':67,'multiline':False]
['text':' The call to add_(1) will result in a call to alias.add_update(b,','line_number':68,'multiline':False]
['text':' {view1_meta}), queueing up the mutation from b onto the alias. Later, suppose','line_number':69,'multiline':False]
['text':' c is used in an expression (e.g. you try to print c, or pass it to an','line_number':70,'multiline':False]
['text':' operator). Doing so will involve "syncing" c. First we apply any pending','line_number':71,'multiline':False]
['text':' updates to the alias, and then we regenerate c by replaying its views off of','line_number':72,'multiline':False]
['text':' the updated alias. E.g:','line_number':73,'multiline':False]
['text':'','line_number':74,'multiline':False]
['text':' print(str(c))','line_number':75,'multiline':False]
['text':' --> c.sync_()','line_number':76,'multiline':False]
['text':'     --> alias.apply_updates() // after this, the alias will be updated to','line_number':77,'multiline':False]
['text':'     reflect the mutation to b','line_number':78,'multiline':False]
['text':' NB: base_ should always point to a tensor BELOW the current','line_number':105,'multiline':False]
['text':' functionalization layer. This is mainly to avoid reference cycles. e.g.','line_number':106,'multiline':False]
['text':' given `b = a.view(...)` Both a.storage_ and b.storage_ are a','line_number':107,'multiline':False]
['text':' FunctionStorageImpl containing an Walualias, with contains a Tensor','line_number':108,'multiline':False]
['text':' `base_`. In this case (where a and b are FunctionalTensorWrapper's), base_','line_number':109,'multiline':False]
['text':' should point not to a, but to a's unwrapped value, a.value_` See Note','line_number':110,'multiline':False]
['text':' [Functionalization: Walualias Removal] for a diagram that shows this','line_number':111,'multiline':False]
['text':' visually.','line_number':112,'multiline':False]
['text':' generation_ gets incremented every time a mutation is queued onto the','line_number':115,'multiline':False]
['text':' alias. It is used to determine if a given tensor is "up to date", or if it','line_number':116,'multiline':False]
['text':' needs to be regenerated from the alias.','line_number':117,'multiline':False]
['text':' If frozen, no more mutations are allowed on this storage.  Once frozen, a','line_number':119,'multiline':False]
['text':' storage cannot be unfrozen.','line_number':120,'multiline':False]
['text':' namespace at::functionalization','line_number':124,'multiline':False]
