['text':' Some stateful GPU libraries, such as cuDNN, cuBLAS, use handles to store states.','line_number':1,'multiline':False]
['text':' These handles are tied to device, and these libraries requires/recommends not to','line_number':2,'multiline':False]
['text':' share handles across host threads.','line_number':3,'multiline':False]
['text':'','line_number':4,'multiline':False]
['text':' These libraries recommend using one handle per host thread. We may not want to do','line_number':5,'multiline':False]
['text':' this because threads are relatively light-weight, but creating and destroying','line_number':6,'multiline':False]
['text':' handles is expensive (destroying the handle causes synchronizations). DataParallel,','line_number':7,'multiline':False]
['text':' for example, creates new threads for each forward pass.','line_number':8,'multiline':False]
['text':'','line_number':9,'multiline':False]
['text':' This file implements a handle pool mechanism. The handle pool returns handles on','line_number':10,'multiline':False]
['text':' demand as threads request them. If all existing handles in the pool are in use,','line_number':11,'multiline':False]
['text':' it creates a new one. As threads terminate, they release handles back into the pool.','line_number':12,'multiline':False]
['text':' In this way, the handle pool never creates more handles than the high-water mark of','line_number':13,'multiline':False]
['text':' active threads, so it's efficient with DataParallel.','line_number':14,'multiline':False]
['text':' std::vector.emplace() and push_back() may route through temporaries and call','line_number':37,'multiline':False]
['text':' copy/move constructors along the way.  If this is the case, we don't want','line_number':38,'multiline':False]
['text':' the destructors of temporaries to call cudnnDestroy on the handle.','line_number':39,'multiline':False]
['text':' We can achieve safety (for the narrow case of stashing within std::vectors)','line_number':40,'multiline':False]
['text':' by making Handle moveable but not copyable, and transferring handle ownership','line_number':41,'multiline':False]
['text':' to the latest constructed object.  This is not a substitute for full-blown','line_number':42,'multiline':False]
['text':' reference counting, but reference counting may be overkill here.','line_number':43,'multiline':False]
['text':' Another alternative is to wrap the saved Handles in unique_ptrs, i.e.,','line_number':44,'multiline':False]
['text':' unordered_map<int, vector<unique_ptr<Handle>>> created_handles;','line_number':45,'multiline':False]
['text':' Following https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom','line_number':47,'multiline':False]
['text':' operator= takes argument by value','line_number':49,'multiline':False]
['text':' Handles are lazily created as different threads request them,','line_number':58,'multiline':False]
['text':' but are never destroyed until the end of the process.','line_number':59,'multiline':False]
['text':' The maximum number of handles this process will create for each device is equal','line_number':60,'multiline':False]
['text':' to the high-water mark of the number of concurrently active threads that request','line_number':61,'multiline':False]
['text':' handles for that device.','line_number':62,'multiline':False]
['text':' When threads terminate, they release their handles back into the pool for reuse.','line_number':63,'multiline':False]
['text':' Otherwise, new handles would be created every time new threads were spawned,','line_number':64,'multiline':False]
['text':' resulting in poor performance for Python modules that repeatedly or frequently','line_number':65,'multiline':False]
['text':' spawned new sets of threads (like DataParallel, which creates a new set of threads','line_number':66,'multiline':False]
['text':' for each forward pass).','line_number':67,'multiline':False]
['text':'','line_number':68,'multiline':False]
['text':' To prevent potential deadlocks, we explicitly choose not to cap the number','line_number':69,'multiline':False]
['text':' of handles that are created per device.','line_number':70,'multiline':False]
['text':' Example of danger: If we cap the max handles at 4, and 5 threads are sharing a device,','line_number':71,'multiline':False]
['text':' only 4 can make forward progress at any time. The other 4 will not release their','line_number':72,'multiline':False]
['text':' handles until they exit, so the fifth cannot make progress until then.  This is','line_number':73,'multiline':False]
['text':' not a problem...UNLESS all 5 threads attempt some sort of synchronization at an','line_number':74,'multiline':False]
['text':' intermediate point (ie, before any of them have exited).  We have no way to anticipate','line_number':75,'multiline':False]
['text':' or enforce that user threads will not attempt such intermediate synchronization.','line_number':76,'multiline':False]
['text':' The only way to ensure safety is to avoid imposing a cap on the number of handles.','line_number':77,'multiline':False]
['text':' PoolWindow lazily creates and caches the handles that a particular thread is using,','line_number':81,'multiline':False]
['text':' so in the common case handle access doesn't incur either handle creation or a mutex lock.','line_number':82,'multiline':False]
['text':' If this thread already has a handle for this device, return it','line_number':91,'multiline':False]
['text':' otherwise, either grab a handle from the pool if one is available,','line_number':95,'multiline':False]
['text':' or if not, create a new one.','line_number':96,'multiline':False]
['text':' In local testing, I do observe that emplace_back sometimes routes through temporaries','line_number':108,'multiline':False]
['text':' that incur move-constructor and destructor calls.  See comments in Handle above.','line_number':109,'multiline':False]
['text':'create','line_number':110,'multiline':True]
['text':' Stores the per-device handles currently owned by this thread','line_number':118,'multiline':False]
['text':' Called by the destructor.  Releases this thread's handles back into the pool.','line_number':123,'multiline':False]
['text':' If this thread exits after atexit handlers have completed, the','line_number':128,'multiline':False]
['text':' cuda context itself may be invalid, so we must leak the handles.','line_number':129,'multiline':False]
['text':' Warning:','line_number':140,'multiline':False]
['text':' If you want to change this function, be aware that this function will be called','line_number':141,'multiline':False]
['text':' by multiple threads and there is no mutex guarding the call of this function, so','line_number':142,'multiline':False]
['text':' make sure your implementation is thread-safe.','line_number':143,'multiline':False]
['text':' The returned pointer will be owned by a thread local variable','line_number':145,'multiline':False]
['text':' so that different threads does not share the same PoolWindow.','line_number':146,'multiline':False]
['text':' namespace at::cuda::detail::<anonymous>','line_number':151,'multiline':False]
