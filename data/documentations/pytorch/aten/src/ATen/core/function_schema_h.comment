['text':' schema as used in the compiler for resolving function calls and reporting','line_number':17,'multiline':False]
['text':' errors. These objects should be constructed from C10 schema once those','line_number':18,'multiline':False]
['text':' are available.','line_number':19,'multiline':False]
['text':' this is an softly-enforced invariant for out arguments.','line_number':53,'multiline':False]
['text':' if type() is non-null, this is guaranteed to be non-null (if no real','line_number':92,'multiline':False]
['text':' type was provided, this takes on type()'s value)','line_number':93,'multiline':False]
['text':' this function checks whether this Argument is backward compatible with','line_number':156,'multiline':False]
['text':' the old one. we consider the following cases are backward compatible:','line_number':157,'multiline':False]
['text':'   1) two arguments are equal','line_number':158,'multiline':False]
['text':'   2) this arg's type should be subtype of old','line_number':159,'multiline':False]
['text':'   3) this arg must provide the same default value if old arg has one,','line_number':160,'multiline':False]
['text':' this function checks whether this Argument is forward compatible with','line_number':165,'multiline':False]
['text':' the old one. we consider the following cases are forward compatible:','line_number':166,'multiline':False]
['text':'   1) two arguments are equal','line_number':167,'multiline':False]
['text':'   2) this arg's type should be subtype of old','line_number':168,'multiline':False]
['text':'   3) this arg must provide the same default value if old arg has one,','line_number':169,'multiline':False]
['text':' this is ScalarType, not int, e.g.','line_number':177,'multiline':False]
['text':' for list types, an optional statically known length for the list','line_number':178,'multiline':False]
['text':' e.g. for int[3]: type = ListType::ofInts(), N = 3','line_number':179,'multiline':False]
['text':' If present, this will allow scalars to be broadcast to this length to','line_number':180,'multiline':False]
['text':' become a list.','line_number':181,'multiline':False]
['text':' AliasInfo is huge, so let's only allocate memory for it if','line_number':185,'multiline':False]
['text':' necessary (which it isn't during schema parsing on startup, to','line_number':186,'multiline':False]
['text':' give a pertinent example).','line_number':187,'multiline':False]
['text':' is this only specifiable as a keyword argument?','line_number':189,'multiline':False]
['text':' marks if the argument is out variant of the schema','line_number':191,'multiline':False]
['text':'*
 * struct SchemaArgument
 *
 * Structure used to represent arguments or returns for a schema.
 ','line_number':212,'multiline':True]
['text':' Checks whether this schema is backward compatible with the old one.','line_number':261,'multiline':False]
['text':' The following conditions must be true:','line_number':262,'multiline':False]
['text':' [Function structure] The new schema's name, overload-name, varargs, and','line_number':263,'multiline':False]
['text':'      return arity are the same.','line_number':264,'multiline':False]
['text':' [Output Narrowing] The new schema's output type must be the same class','line_number':265,'multiline':False]
['text':'      or inherit from the old schema's output type.','line_number':266,'multiline':False]
['text':' [Argument count] The new schema must have at least as many arguments as','line_number':267,'multiline':False]
['text':'      the old schema (considering the list of positional and kwargs).','line_number':268,'multiline':False]
['text':' [Arg Compatibility] Every argument in the old schema has a corresponding','line_number':269,'multiline':False]
['text':'      argument in the new schema that:','line_number':270,'multiline':False]
['text':'        * is at the same position.','line_number':271,'multiline':False]
['text':'        * has the same name.','line_number':272,'multiline':False]
['text':'        * is either positional, or kwarg and the old argument was kwarg.','line_number':273,'multiline':False]
['text':'        * has the same type, or the old argument's type inherits from the','line_number':274,'multiline':False]
['text':'          new argument's type.','line_number':275,'multiline':False]
['text':' [Default Values] Every new argument must have a default value.','line_number':276,'multiline':False]
['text':' E.g.','line_number':277,'multiline':False]
['text':'   OK    f_new(a, b, c=1) => f_old(a, b)','line_number':278,'multiline':False]
['text':'   NOK   f_new(a, c=1, *, b) => f_old(a, *, b)','line_number':279,'multiline':False]
['text':'   OK    f_new(a, b, *, c) => f_old(a, *, b, c)','line_number':280,'multiline':False]
['text':'   NOK   f_new(a, *, b, c) -> f_old(a, b, *, c)','line_number':281,'multiline':False]
['text':'   NOK   f_new(a, *, c, b) => f_old(a, *, b, c)','line_number':282,'multiline':False]
['text':'   OK    f_new(a, *, b, c, d=1) => f_old(a, *, b, c)','line_number':283,'multiline':False]
['text':' Checks whether this schema is forward compatible with the old one.','line_number':288,'multiline':False]
['text':' The following conditions must be true:','line_number':289,'multiline':False]
['text':' [Function structure] The new schema's name, overload-name, varargs, and','line_number':290,'multiline':False]
['text':'      return arity are the same.','line_number':291,'multiline':False]
['text':' [Output Narrowing] The new schema's output type must be the same class','line_number':292,'multiline':False]
['text':'      or inherit from the old schema's output type.','line_number':293,'multiline':False]
['text':' [Arg Compatibility] Every argument in the old schema has a corresponding','line_number':294,'multiline':False]
['text':'      argument in the new schema that:','line_number':295,'multiline':False]
['text':'        * is at the same position.','line_number':296,'multiline':False]
['text':'        * has the same name.','line_number':297,'multiline':False]
['text':'        * is either positional, or kwarg and the old argument was kwarg.','line_number':298,'multiline':False]
['text':'        * has the same type, or the old argument's type inherits from the','line_number':299,'multiline':False]
['text':'          new argument's type.','line_number':300,'multiline':False]
['text':' [Default Values] Every new argument must have a default value.','line_number':301,'multiline':False]
['text':'         Each default value type should NOT be a container type.','line_number':302,'multiline':False]
['text':' [Positioning] All defaults arguments MUST go after either old','line_number':303,'multiline':False]
['text':'         default arguments or the end of positional arguments','line_number':304,'multiline':False]
['text':'         and right BEFORE all out arguments','line_number':305,'multiline':False]
['text':' if true then this schema takes an arbitrary number of additional arguments','line_number':314,'multiline':False]
['text':' after the argument specified in arguments','line_number':315,'multiline':False]
['text':' currently this is used primarily to represent 'primitive' operators whose','line_number':316,'multiline':False]
['text':' arguments are not checked by schema','line_number':317,'multiline':False]
['text':' if no alias information is directly specified, what kind of "default"','line_number':321,'multiline':False]
['text':' alias information should we infer?','line_number':322,'multiline':False]
['text':' NB: due to alias analysis kind merging, this may be nullopt.  Eventually','line_number':323,'multiline':False]
['text':' this should always be set no matter what','line_number':324,'multiline':False]
['text':' we have historically serialized broadcasting lists wo/default values,','line_number':336,'multiline':False]
['text':' so to not break BC allow lists here','line_number':337,'multiline':False]
['text':' Returns whether lhs and rhs may alias directly.','line_number':405,'multiline':False]
['text':' This does not account for cases where lhs or rhs are a container that','line_number':406,'multiline':False]
['text':' may contain elements that alias the other argument.','line_number':407,'multiline':False]
['text':' FunctionSchema::may_contain_alias will include that functionality.','line_number':408,'multiline':False]
['text':' Returns whether lhs and rhs may alias directly or whether lhs/rhs are a container','line_number':411,'multiline':False]
['text':' that may contain elements that alias the other argument.','line_number':412,'multiline':False]
['text':' bidirectional = false only returns whether lhs may contain an alias of rhs','line_number':413,'multiline':False]
['text':' while bidirectional = true returns both directions.','line_number':414,'multiline':False]
['text':' Returns whether the two AliasTypeSets contain any similarities','line_number':417,'multiline':False]
['text':' ie: whether the two type sets can alias.','line_number':418,'multiline':False]
['text':' Recursively Finds all contained types within the AliasTypeSet.','line_number':421,'multiline':False]
['text':' Similar to mapTypeToAliasTypeSet defined in alias_analysis.cpp.','line_number':424,'multiline':False]
['text':' Used to map types to a type such that all types that can alias will be mapped to the same type.','line_number':425,'multiline':False]
['text':' For example, calling this method on 'Optional[List[int]]' is the same as calling this method','line_number':426,'multiline':False]
['text':' on 'List[int]'.','line_number':427,'multiline':False]
['text':' Returns either arguments() or returns() depending on the SchemaArgType','line_number':430,'multiline':False]
['text':' output => returns(), input => arguments()','line_number':431,'multiline':False]
['text':' Check that inputs have the correct types and appends any missing default','line_number':481,'multiline':False]
['text':' values.','line_number':482,'multiline':False]
['text':' TODO remove the mutation here','line_number':506,'multiline':False]
['text':' Returns true if we successfully set the namespace (as there','line_number':521,'multiline':False]
['text':' was none set, and false otherwise)','line_number':522,'multiline':False]
['text':' can a function with this schema be substituted for a function of rhs's','line_number':527,'multiline':False]
['text':' schema and have the program typecheck?','line_number':528,'multiline':False]
['text':' as_method - if true, treat this schema as a method and ignore','line_number':529,'multiline':False]
['text':' the first argument, which will be the object in both cases','line_number':530,'multiline':False]
['text':' print out Argument, which is compatible with FunctionSchema parser','line_number':547,'multiline':False]
['text':' full format: Type(alias)? name=default_value','line_number':548,'multiline':False]
['text':' for adjusting the ? position.','line_number':551,'multiline':False]
['text':' in schema, we have Tensor?(a!) input, and t(a!)?.','line_number':552,'multiline':False]
['text':' however, t?(a!) doesn't work with schema parser.','line_number':553,'multiline':False]
['text':' so we always use Type(alias)? format','line_number':554,'multiline':False]
['text':' real_type versus fake_type: in order to be compatible with FunctionSchema','line_number':555,'multiline':False]
['text':' parser, printing an argument with either MemoryFormat or Layout type should','line_number':556,'multiline':False]
['text':' give us the original schema string, hence printing out real_type.','line_number':557,'multiline':False]
['text':' sized lists get size N from arg, not type','line_number':563,'multiline':False]
['text':' print alias info if it has beforeSets.','line_number':578,'multiline':False]
['text':' We want to faithfully replicate JIT schema.','line_number':598,'multiline':False]
['text':' in native_functions.yaml defaults for int arrays with a single value always look like','line_number':599,'multiline':False]
['text':'   int[2] stride=1','line_number':600,'multiline':False]
['text':' instead of','line_number':601,'multiline':False]
['text':'   int[2] stride=[1, 1]','line_number':602,'multiline':False]
['text':' namespace c10','line_number':633,'multiline':False]
['text':' hashing optional fields if they exist','line_number':652,'multiline':False]
['text':' namespace std','line_number':684,'multiline':False]
['text':' IWYU pragma: keep','line_number':687,'multiline':False]
