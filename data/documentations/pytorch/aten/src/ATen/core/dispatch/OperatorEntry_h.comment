['text':' This data structure represents a kernel that was registered to us from a','line_number':32,'multiline':False]
['text':' user.  Unlike KernelFunction, AnnotatedKernel contains some extra metadata','line_number':33,'multiline':False]
['text':' about the kernel that isn't necessary for actual dispatching (this is why','line_number':34,'multiline':False]
['text':' we don't put AnnotatedKernel in the actual DispatchTable), but is useful for','line_number':35,'multiline':False]
['text':' giving good error messages.','line_number':36,'multiline':False]
['text':' A little debug string to help us identify the kernel in question.','line_number':46,'multiline':False]
['text':' Most importantly it records the TORCH_LIBRARY block that did the','line_number':47,'multiline':False]
['text':' registration.','line_number':48,'multiline':False]
['text':' This data structure represents operator schema, with metadata specifying','line_number':52,'multiline':False]
['text':' where the registration of this schema occurred','line_number':53,'multiline':False]
['text':' Internal data structure that records information about a specific operator.','line_number':63,'multiline':False]
['text':' It's not part of the public API; typically, users will interact with','line_number':64,'multiline':False]
['text':' OperatorHandle instead.','line_number':65,'multiline':False]
['text':'','line_number':66,'multiline':False]
['text':' Concurrent writes to OperatorEntry are protected by the GLOBAL Dispatcher','line_number':67,'multiline':False]
['text':' lock (this is important because some methods in OperatorEntry access','line_number':68,'multiline':False]
['text':' dispatcher state)','line_number':69,'multiline':False]
['text':' We may allocate an OperatorEntry for an operator even when we don't','line_number':95,'multiline':False]
['text':' have a schema.  When we receive the schema registration, we post','line_number':96,'multiline':False]
['text':' facto register a schema.','line_number':97,'multiline':False]
['text':'','line_number':98,'multiline':False]
['text':' NB: registerSchema/deregisterSchema are not idempotent; if you','line_number':99,'multiline':False]
['text':' attempt to register a schema when one is already present or vice','line_number':100,'multiline':False]
['text':' versa that is an error.  (Refcounting for the registrations is','line_number':101,'multiline':False]
['text':' handled in the OperatorHandle in Dispatcher)','line_number':102,'multiline':False]
['text':' Why are kernels and fallback asymmetric?  It has to do with ownership.','line_number':117,'multiline':False]
['text':' Kernels and the computed dispatch tables for them are canonically','line_number':118,'multiline':False]
['text':' owned by OperatorEntry, but backend fallbacks are specified once','line_number':119,'multiline':False]
['text':' and apply for all operators, so they should be owned by Dispatcher.','line_number':120,'multiline':False]
['text':' However, the registration of a backend fallback affects the','line_number':121,'multiline':False]
['text':' state of the computed dispatch table, so when a backend fallback','line_number':122,'multiline':False]
['text':' is updated, we need to update the operator tables too.  Thus,','line_number':123,'multiline':False]
['text':' registerKernel is the mechanism by which we give kernels to','line_number':124,'multiline':False]
['text':' operator entry to own (and update dispatch table), but we only','line_number':125,'multiline':False]
['text':' need a non-owning mechanism to update fallback.','line_number':126,'multiline':False]
['text':' Precondition: Dispatcher::mutex_ is held','line_number':128,'multiline':False]
['text':' Postcondition: caller is responsible for disposing of the kernel','line_number':129,'multiline':False]
['text':' Precondition: Dispatcher::mutex_ is held','line_number':139,'multiline':False]
['text':' Precondition: Dispatcher::mutex_ is held','line_number':146,'multiline':False]
['text':' Precondition: Dispatcher::mutex_ is held','line_number':152,'multiline':False]
['text':' Asserts that the given FuncType is correct for calling this operator in an unboxed way.','line_number':164,'multiline':False]
['text':' A valid kernel *always* has a boxed kernel and *may* have an','line_number':180,'multiline':False]
['text':' unboxed kernel. However, we typically do unboxed calls in at::','line_number':181,'multiline':False]
['text':' APIs, where the kernel 1) will very likely be valid and 2)','line_number':182,'multiline':False]
['text':' should have an unboxed kernel. Checking the unboxed kernel','line_number':183,'multiline':False]
['text':' first will allow us to avoid touching the boxed kernel at all','line_number':184,'multiline':False]
['text':' in the common case.','line_number':185,'multiline':False]
['text':' Returns true if kernel_ has entry for any key in ks.','line_number':196,'multiline':False]
['text':'','line_number':197,'multiline':False]
['text':' Invariant: There are no alias keys in the passed-in dispatch key set.','line_number':198,'multiline':False]
['text':' Note [No Alias Keys in DispatchKeySet]','line_number':199,'multiline':False]
['text':' Alias keys should be checked using `hasKernelForDispatchKey`','line_number':200,'multiline':False]
['text':' Alias keys shouldn't go inside of a DispatchKeySet, since they can technically','line_number':201,'multiline':False]
['text':' have a value > 63 (causing overflow).','line_number':202,'multiline':False]
['text':' Returns true if kernel_ has entry for a particular key.','line_number':204,'multiline':False]
['text':' Retrieves the kernel entry at a particular key.  Symmetric with','line_number':206,'multiline':False]
['text':' hasKernelForDispatchKey.  To get the AnnotatedKernel, see','line_number':207,'multiline':False]
['text':' getKernelForDispatchKey (private)','line_number':208,'multiline':False]
['text':' Returns true if the "computed table" has an entry for a particular key.','line_number':210,'multiline':False]
['text':' Returns all the operator tags added at the time of registration','line_number':212,'multiline':False]
['text':' Pointer to the torch.ops.ns.op.overload object for speed','line_number':230,'multiline':False]
['text':' kernels_ stores all registered kernels for the corresponding dispatch key','line_number':233,'multiline':False]
['text':' and catchAllKernels_ stores the catch-all kernels.','line_number':234,'multiline':False]
['text':' If an operator library gets loaded that overwrites an already existing kernel,','line_number':235,'multiline':False]
['text':' both kernels will be in that list but only the newer one will be in','line_number':236,'multiline':False]
['text':' dispatchTable. If any of the kernels go away (say the library gets','line_number':237,'multiline':False]
['text':' unloaded), we remove the kernel from this list and update the','line_number':238,'multiline':False]
['text':' dispatchTable if necessary.','line_number':239,'multiline':False]
['text':' Kernels in the list are ordered by registration time descendingly,','line_number':240,'multiline':False]
['text':' newer registrations are before older registrations.','line_number':241,'multiline':False]
['text':' We do not combine dispatchTable and kernels into one hash map because','line_number':242,'multiline':False]
['text':' kernels is a larger data structure and accessed quite infrequently','line_number':243,'multiline':False]
['text':' while dispatchTable is accessed often and should be kept small to fit','line_number':244,'multiline':False]
['text':' into CPU caches.','line_number':245,'multiline':False]
['text':' Invariants:','line_number':246,'multiline':False]
['text':'  - dispatchTable[dispatch_key] == kernels_[dispatch_key].front()','line_number':247,'multiline':False]
['text':'  - dispatchTable[dispatch_key] does not exist if and only if','line_number':248,'multiline':False]
['text':'    kernels_[dispatch_key] does not exist','line_number':249,'multiline':False]
['text':'  - If kernels_[dispatch_key] exists, then it has elements.','line_number':250,'multiline':False]
['text':'    It is never an empty list.','line_number':251,'multiline':False]
['text':'','line_number':252,'multiline':False]
['text':' Why do we do that?','line_number':253,'multiline':False]
['text':' -----','line_number':254,'multiline':False]
['text':' We mostly do this to enable Jupyter notebooks where a cell registering','line_number':255,'multiline':False]
['text':' a kernel could be executed multiple times and the later execution','line_number':256,'multiline':False]
['text':' should overwrite the earlier one. Note that this still fails when the','line_number':257,'multiline':False]
['text':' function schema changed between the executions, but it works as long','line_number':258,'multiline':False]
['text':' as the function schema didn't change. A better solution would be to','line_number':259,'multiline':False]
['text':' unload the old extension library from the Jupyter cell when the cell is','line_number':260,'multiline':False]
['text':' re-executed and then only allow one kernel here, i.e. error if a kernel','line_number':261,'multiline':False]
['text':' is already registered, but that's a lot of effort to implement and','line_number':262,'multiline':False]
['text':' currently not high-pri.','line_number':263,'multiline':False]
['text':' On mobile, we needn't worry about Jupyter notebooks.','line_number':266,'multiline':False]
['text':' cpp_signature_ stores function signature if any of','line_number':276,'multiline':False]
['text':' the kernels was created in a way that allowed us to know the function','line_number':277,'multiline':False]
['text':' signature (i.e. by supplying an unboxed C++ kernel function).','line_number':278,'multiline':False]
['text':' If this is set, it will be used to check that future kernel','line_number':279,'multiline':False]
['text':' registrations match and it will be used in unboxed function calls','line_number':280,'multiline':False]
['text':' to verify their arguments against the known function signature.','line_number':281,'multiline':False]
['text':' A Python custom error handler for OperatorEntry::reportError','line_number':290,'multiline':False]
['text':' Whether this operator needs to be observed with RecordFunction','line_number':293,'multiline':False]
['text':' This function re-establishes the invariant that dispatchTable','line_number':301,'multiline':False]
['text':' contains the front element from the kernels list for a given runtime dispatch key.','line_number':302,'multiline':False]
['text':' Like above, but also handles alias dispatch keys.','line_number':304,'multiline':False]
['text':' Like above, but for ALL entries in the dispatch table.','line_number':306,'multiline':False]
['text':' Retrieves a pointer to AnnotatedKernel at kernels_.at(dispatch_key).front().','line_number':308,'multiline':False]
['text':' namespace impl','line_number':312,'multiline':False]
['text':' namespace c10','line_number':313,'multiline':False]
