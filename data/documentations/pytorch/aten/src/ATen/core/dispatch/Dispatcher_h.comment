['text':'*
 * Implement this interface and register your instance with the dispatcher
 * to get notified when operators are registered or deregistered with
 * the dispatcher.
 *
 * NB: registration events only occur when a 'def' occurs; we don't trigger
 * on 'impl' or 'fallback' calls.
 ','line_number':40,'multiline':True]
['text':'*
 * Top-level dispatch interface for dispatching via the dynamic dispatcher.
 * Most end users shouldn't use this directly; if you're trying to register
 * ops look in op_registration
 ','line_number':61,'multiline':True]
['text':' For direct access to backend fallback information','line_number':68,'multiline':False]
['text':' These refer to the number of outstanding RegistrationHandleRAII','line_number':77,'multiline':False]
['text':' for this operator.  def_count reflects only def() registrations','line_number':78,'multiline':False]
['text':' (in the new world, this should only ever be 1, but old style','line_number':79,'multiline':False]
['text':' registrations may register the schema multiple times, which','line_number':80,'multiline':False]
['text':' will increase this count).  def_and_impl_count reflects the number','line_number':81,'multiline':False]
['text':' of combined def() and impl() registrations.  When the last def() gets','line_number':82,'multiline':False]
['text':' unregistered, we must immediately call the Deregistered listeners, but we','line_number':83,'multiline':False]
['text':' must not actually delete the handle as there are other outstanding RAII','line_number':84,'multiline':False]
['text':' destructors which will try to destruct and they had better still have a','line_number':85,'multiline':False]
['text':' working operator handle in this case','line_number':86,'multiline':False]
['text':' Implementation note: this class abstracts over the fact that we have per-operator','line_number':102,'multiline':False]
['text':' dispatch tables.  This could be easily adjusted to have a single global hash','line_number':103,'multiline':False]
['text':' table.','line_number':104,'multiline':False]
['text':' Implemented inline so that steady-state code needn't incur','line_number':109,'multiline':False]
['text':' function-call overhead. We can't just inline `realSingleton`','line_number':110,'multiline':False]
['text':' because the function-local static would get duplicated across','line_number':111,'multiline':False]
['text':' all DSOs that include & use this header, leading to multiple','line_number':112,'multiline':False]
['text':' singleton instances.','line_number':113,'multiline':False]
['text':' For C10_MOBILE, we should never inline a static function that','line_number':117,'multiline':False]
['text':' has a static member, since the generated code calls','line_number':118,'multiline':False]
['text':' __cxa_guard_acquire and __cxa_guard_release which help','line_number':119,'multiline':False]
['text':' implement exactly once semantics for the initialization of the','line_number':120,'multiline':False]
['text':' static Dispatcher& s above (for the non-mobile case). That','line_number':121,'multiline':False]
['text':' additional code when duplicated across all operator stubs','line_number':122,'multiline':False]
['text':' for every backend results in a lot of additional code','line_number':123,'multiline':False]
['text':' being generated by the compiler.','line_number':124,'multiline':False]
['text':' ------------------------------------------------------------------------','line_number':129,'multiline':False]
['text':'','line_number':130,'multiline':False]
['text':' Accessing operators by schema','line_number':131,'multiline':False]
['text':'','line_number':132,'multiline':False]
['text':' ------------------------------------------------------------------------','line_number':133,'multiline':False]
['text':'*
   * Looks for an operator schema with the given name and overload name
   * and returns it if it is registered WITH A SCHEMA.
   * Returns nullopt otherwise.
   ','line_number':135,'multiline':True]
['text':'*
   * Variant of findSchema that results in less code generated at the call site.
   * It (1) takes const char* pointer rather than OperatorName (so we skip
   * generating std::string constructor calls at the call site), and (2)
   * it raises an exception if the operator is not found (so we skip
   * generating exception raising code at the call site)
   *
   * Irritatingly, we still have to generate the handful of instructions
   * for dealing with an exception being thrown during static initialization
   * (e.g. __cxa_guard_abort).  If we could annotate this method noexcept we
   * could avoid this code too, but as the name of the function suggests,
   * it does throw exceptions.
   ','line_number':142,'multiline':True]
['text':' Like findSchema, but also returns OperatorHandle even if there is no schema','line_number':157,'multiline':False]
['text':' Returns a list of all operator names present in the operatorLookupTable_','line_number':160,'multiline':False]
['text':' ------------------------------------------------------------------------','line_number':163,'multiline':False]
['text':'','line_number':164,'multiline':False]
['text':' Invoking operators','line_number':165,'multiline':False]
['text':'','line_number':166,'multiline':False]
['text':' ------------------------------------------------------------------------','line_number':167,'multiline':False]
['text':' Like call, but intended for use in a redispatch in kernels that have explicitly performed the DispatchKey update calculatulation.','line_number':176,'multiline':False]
['text':' This will take the DispatchKeySet completely as is and dispatch to the kernel of the corresponding highest priority key in the set.','line_number':177,'multiline':False]
['text':' Note that this version of redispatch treats the inputted DispatchKeySet *as is*, and does NOT mask out the highest priority key.','line_number':178,'multiline':False]
['text':' See Note [Plumbing Keys Through The Dispatcher]','line_number':179,'multiline':False]
['text':' Invoke an operator via the boxed calling convention using an IValue stack','line_number':183,'multiline':False]
['text':' TODO: This will only be useful if we write a backend fallback that plumbs dispatch keys (currently there are none)','line_number':187,'multiline':False]
['text':' See Note [Plumbing Keys Through The Dispatcher]','line_number':188,'multiline':False]
['text':' Used by torchdeploy/multipy for multiple interpreters racing.','line_number':197,'multiline':False]
['text':' ------------------------------------------------------------------------','line_number':201,'multiline':False]
['text':'','line_number':202,'multiline':False]
['text':' Performing registrations (NON user public; use op_registration)','line_number':203,'multiline':False]
['text':'','line_number':204,'multiline':False]
['text':' ------------------------------------------------------------------------','line_number':205,'multiline':False]
['text':'*
   * Register a new operator schema.
   *
   * If a schema with the same operator name and overload name already exists,
   * this function will check that both schemas are exactly identical.
   ','line_number':207,'multiline':True]
['text':'*
   * Register a kernel to the dispatch table for an operator.
   * If dispatch_key is nullopt, then this registers a fallback kernel.
   *
   * @return A RAII object that manages the lifetime of the registration.
   *         Once that object is destructed, the kernel will be deregistered.
   ','line_number':215,'multiline':True]
['text':' NB: steals the inferred function schema, as we may need to hold on to','line_number':222,'multiline':False]
['text':' it for a bit until the real schema turns up','line_number':223,'multiline':False]
['text':'*
   * Given an operator, tells the Dispatcher that we have implemented an abstract impl
   * for this op in the given Python module. Call this a "pystub".
   ','line_number':226,'multiline':True]
['text':'*
   * Given an operator, throws if we have an abstract impl pystub.
   ','line_number':232,'multiline':True]
['text':'*
   * Register a new operator by name.
   ','line_number':239,'multiline':True]
['text':'*
   * Register a fallback kernel for a backend.
   * If an operator is called but there is no concrete kernel for the dispatch
   * key of the given operator arguments, it will check if there is such a
   * fallback kernel for the given dispatch key and, if yes, call that one.
   ','line_number':244,'multiline':True]
['text':'*
   * Use to register whenever we had a TORCH_LIBRARY declaration in the frontend
   * API.  These invocations are only permitted once per program, so we raise
   * an error if this is called again for the same namespace.
   ','line_number':252,'multiline':True]
['text':' ------------------------------------------------------------------------','line_number':259,'multiline':False]
['text':'','line_number':260,'multiline':False]
['text':' Listeners on registrations','line_number':261,'multiline':False]
['text':'','line_number':262,'multiline':False]
['text':' ------------------------------------------------------------------------','line_number':263,'multiline':False]
['text':'*
   * Add a listener that gets called whenever a new op is registered or an existing
   * op is deregistered. Immediately after registering, this listener gets called
   * for all previously registered ops, so it can be used to keep track of ops
   * registered with this dispatcher.
   ','line_number':265,'multiline':True]
['text':'','line_number':275,'multiline':False]
['text':' ------------------------------------------------------------------------','line_number':276,'multiline':False]
['text':'','line_number':277,'multiline':False]
['text':' Assertions','line_number':278,'multiline':False]
['text':'','line_number':279,'multiline':False]
['text':' ------------------------------------------------------------------------','line_number':280,'multiline':False]
['text':'*
   * For testing purposes.
   * Returns a list of all operators that were created through calls to registerImpl(),
   * without any corresponding calls to registerDef(). After static initialization
   * is done this is almost certainly a bug, as the created OperatorHandle won't have
   * any schema associated with it and users calling the op through the dispatcher
   * won't be able to access it
   *
   * Note that we cannot enforce this invariant "as we go" during static initialization,
   * due to undefined static initialization order- we have no guarantees over the order
   * in which .def() and .impl() calls are registered in the dispatcher at static
   * initialization time. So this function should only be called after static initialization.
   ','line_number':282,'multiline':True]
['text':'*
   * Useful for inspecting global Dispatcher registration state.
   * Returns the names of all operators with a kernel registered for the specified DispatchKey.
   * If no DispatchKey is specified, it returns all registered operators.
   ','line_number':297,'multiline':True]
['text':' FBCODE_CAFFE2','line_number':315,'multiline':False]
['text':' Map from namespace to debug string (saying, e.g., where the library was defined)','line_number':338,'multiline':False]
['text':' This condition variable gets notified whenever we add a new def/impl to the','line_number':345,'multiline':False]
['text':' dispatch table.  This is primarily used by multipy/torchdeploy, when','line_number':346,'multiline':False]
['text':' we have multiple interpreters trying to register to the dispatch table.','line_number':347,'multiline':False]
['text':' In this situation, whenever the non-primary interpreter would have tried','line_number':348,'multiline':False]
['text':' to register to the dispatch table, instead it will check to see if the','line_number':349,'multiline':False]
['text':' expected registration has already been made, and if it hasn't, wait on','line_number':350,'multiline':False]
['text':' this condition variable to see if it was just racing with the primary','line_number':351,'multiline':False]
['text':' interpreter.','line_number':352,'multiline':False]
['text':'','line_number':353,'multiline':False]
['text':' We expect it to be rare for there to be any waiters on this condition','line_number':354,'multiline':False]
['text':' variable.  This is mostly just to help give better diagnostics if','line_number':355,'multiline':False]
['text':' something goes horribly wrong','line_number':356,'multiline':False]
['text':' Protect concurrent access to the dispatcher.  We store this in a','line_number':359,'multiline':False]
['text':' `shared_ptr` as we return callbacks that call back into dispatcher methods,','line_number':360,'multiline':False]
['text':' and we need to be able to handle and guard against the event when the','line_number':361,'multiline':False]
['text':' `Dispatcher` has been destroyed before the callbacks fire.','line_number':362,'multiline':False]
['text':'*
 * This is a handle to an operator schema registered with the dispatcher.
 * This handle can be used to register kernels with the dispatcher or
 * to lookup a kernel for a certain set of arguments.
 ','line_number':366,'multiline':True]
['text':' NOLINTNEXTLINE(performance-trivially-destructible)','line_number':379,'multiline':False]
['text':' NB: This assert is not 100% sound: you can retrieve a typed() operator','line_number':441,'multiline':False]
['text':' handle prior to ANY C++ signature being registered on the operator','line_number':442,'multiline':False]
['text':' and the check will say everything is OK (at which point you can then','line_number':443,'multiline':False]
['text':' smuggle in a kernel that is typed incorrectly).  For everything','line_number':444,'multiline':False]
['text':' in core library this won't happen, because all the static registrations','line_number':445,'multiline':False]
['text':' will be done by the time a typed() handle is acquired.','line_number':446,'multiline':False]
['text':' Storing a direct pointer to the OperatorDef even though we','line_number':491,'multiline':False]
['text':' already have the iterator saves an instruction in the critical','line_number':492,'multiline':False]
['text':' dispatch path. The iterator is effectively a','line_number':493,'multiline':False]
['text':' pointer-to-std::list-node, and (at least in libstdc++'s','line_number':494,'multiline':False]
['text':' implementation) the element is at an offset 16 bytes from that,','line_number':495,'multiline':False]
['text':' because the prev/next pointers come first in the list node','line_number':496,'multiline':False]
['text':' struct. So, an add instruction would be necessary to convert from the','line_number':497,'multiline':False]
['text':' iterator to an OperatorDef*.','line_number':498,'multiline':False]
['text':' We need to store this iterator in order to make','line_number':501,'multiline':False]
['text':' Dispatcher::cleanup() fast -- it runs a lot on program','line_number':502,'multiline':False]
['text':' termination (and presuambly library unloading).','line_number':503,'multiline':False]
['text':'*
 * This is a handle to an operator schema registered with the dispatcher.
 * It holds the same information as an OperatorHandle, but it is templated
 * on the operator arguments and allows calling the operator in an
 * unboxed way.
 ','line_number':507,'multiline':True]
['text':' See [Note: Argument forwarding in the dispatcher] for why Args doesn't use &&','line_number':525,'multiline':False]
['text':' See [Note: Argument forwarding in the dispatcher] for why Args doesn't use &&','line_number':530,'multiline':False]
['text':' CaptureKernelCall is intended to capture return values from Dispatcher','line_number':544,'multiline':False]
['text':' unboxed kernel calls. A record function may request to get outputs from the','line_number':545,'multiline':False]
['text':' kernel calls. For boxed kernels, it's straightforward, the returned values','line_number':546,'multiline':False]
['text':' are in the stack object. The stack can be passed to record functions. For','line_number':547,'multiline':False]
['text':' unboxed kernels, we need to handle different kinds of return values, cache','line_number':548,'multiline':False]
['text':' them temporarily, then release the values for the actual function call','line_number':549,'multiline':False]
['text':' return.','line_number':550,'multiline':False]
['text':' Calls the kernel and capture the result in output_.','line_number':559,'multiline':False]
['text':' Wraps the return values in a Stack.','line_number':564,'multiline':False]
['text':' Since we are returning the output_, we don't expect the output_ to be used','line_number':570,'multiline':False]
['text':' afterward. Copy elision and RVO do not apply to class data members. Using','line_number':571,'multiline':False]
['text':' move semantic to avoid copies when possible.','line_number':572,'multiline':False]
['text':' Handle the lvalue reference differently since it should not be moved.','line_number':581,'multiline':False]
['text':' Handle case where the kernel returns void.','line_number':587,'multiline':False]
['text':' Calling the kernel and no need to capture void.','line_number':596,'multiline':False]
['text':' namespace detail','line_number':606,'multiline':False]
['text':' See [Note: Argument forwarding in the dispatcher] for why Args doesn't use &&','line_number':608,'multiline':False]
['text':' If callbacks need inputs, we box the arguments and pass them to the guard.','line_number':611,'multiline':False]
['text':' Note: For perf reasons we wouldn't want to prematurely box the arguments.','line_number':612,'multiline':False]
['text':' If we used std::array<IValue, num_boxed_args> here, we would','line_number':621,'multiline':False]
['text':' have to spend time default constructing the IValues in','line_number':622,'multiline':False]
['text':' boxedArgs. aligned_storage has no such requirement.','line_number':623,'multiline':False]
['text':' For debugging only; could be removed (but the compiler will do','line_number':625,'multiline':False]
['text':' that for us and it's nice to have the extra assurance of','line_number':626,'multiline':False]
['text':' correctness from our debug builds).','line_number':627,'multiline':False]
['text':' I don't *think* we need std::launder here, because IValue has','line_number':631,'multiline':False]
['text':' no subclasses and no const or reference fields.','line_number':632,'multiline':False]
['text':' Calls the kernel and capture the output temporarily to pass to','line_number':645,'multiline':False]
['text':' RecordFunction.','line_number':646,'multiline':False]
['text':' Releases the captured output to return to caller.','line_number':650,'multiline':False]
['text':' keeping the guard alive while executing the kernel','line_number':654,'multiline':False]
['text':' See [Note: Argument forwarding in the dispatcher] for why Args doesn't use &&','line_number':658,'multiline':False]
['text':' workaround for a false-positive warning about unused parameters in gcc 5','line_number':661,'multiline':False]
['text':' PYTORCH_DISABLE_PER_OP_PROFILING','line_number':678,'multiline':False]
['text':' FBCODE_CAFFE2','line_number':695,'multiline':False]
['text':' See [Note: Argument forwarding in the dispatcher] for why Args doesn't use &&','line_number':698,'multiline':False]
['text':' workaround for a false-positive warning about unused parameters in gcc 5','line_number':701,'multiline':False]
['text':' do not use RecordFunction on redispatch','line_number':702,'multiline':False]
['text':' note: this doesn't need the mutex because write operations on the list keep iterators intact.','line_number':716,'multiline':False]
['text':' keeping the guard alive while executing the kernel','line_number':738,'multiline':False]
['text':' PYTORCH_DISABLE_PER_OP_PROFILING','line_number':746,'multiline':False]
['text':' NB: this doesn't count as a "true" dispatcher jump, so no instrumentation','line_number':750,'multiline':False]
['text':' note: this doesn't need the mutex because write operations on the list keep iterators intact.','line_number':752,'multiline':False]
['text':' We still compute this as we're obligated to pass it on to the internal','line_number':754,'multiline':False]
['text':' kernel, if it is a boxed fallback','line_number':755,'multiline':False]
['text':' note: this doesn't need the mutex because write operations on the list keep iterators intact.','line_number':770,'multiline':False]
['text':' namespace c10','line_number':784,'multiline':False]
['text':' namespace std','line_number':795,'multiline':False]
