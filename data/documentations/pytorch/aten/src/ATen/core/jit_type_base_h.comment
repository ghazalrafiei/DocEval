['text':' Use this to customize how a Type is printed using `annotation_str()`. If','line_number':75,'multiline':False]
['text':' c10::nullopt is returned, `annotation_str()` falls through to its default','line_number':76,'multiline':False]
['text':' implementation.','line_number':77,'multiline':False]
['text':' namespace detail','line_number':83,'multiline':False]
['text':' namespace detail','line_number':144,'multiline':False]
['text':'printer','line_number':159,'multiline':True]
['text':' a == b','line_number':162,'multiline':False]
['text':' a == b <=> b == a','line_number':164,'multiline':False]
['text':' implicit ','line_number':177,'multiline':True]
['text':' implicit ','line_number':181,'multiline':True]
['text':' implicit ','line_number':184,'multiline':True]
['text':' implicit ','line_number':187,'multiline':True]
['text':' implicit ','line_number':191,'multiline':True]
['text':' We need to support construction from T* for pybind. The problem','line_number':195,'multiline':False]
['text':' is that it's not clear if we are supposed to be taking shared','line_number':196,'multiline':False]
['text':' ownership or not.','line_number':197,'multiline':False]
['text':'','line_number':198,'multiline':False]
['text':' Case 1: if T is known statically to derive from SharedType, we should use','line_number':199,'multiline':False]
['text':' shared_from_this() and take shared_ownership.','line_number':200,'multiline':False]
['text':'','line_number':201,'multiline':False]
['text':' Case 2: if T is exactly Type, we need to do a dynamic_cast to','line_number':202,'multiline':False]
['text':' check if it's a SharedType and do the right thing.','line_number':203,'multiline':False]
['text':'','line_number':204,'multiline':False]
['text':' Case 3: Otherwise, T is not a SharedType. (debug-check this','line_number':205,'multiline':False]
['text':' assumption!) Use a singleton pointer.','line_number':206,'multiline':False]
['text':' implicit ','line_number':209,'multiline':True]
['text':' implicit ','line_number':212,'multiline':True]
['text':' implicit ','line_number':221,'multiline':True]
['text':' NOTE: SharedPtrWrapper exists to work around a baffling bug in','line_number':257,'multiline':False]
['text':' nvcc; see comment in destroy() below.','line_number':258,'multiline':False]
['text':' NOTE: the only non-UB way to access our null state is through','line_number':280,'multiline':False]
['text':' rawRepr(), because our copy operation doesn't preserve which','line_number':281,'multiline':False]
['text':' union member is active for null pointers.','line_number':282,'multiline':False]
['text':' It is UB to read the singleton part of Repr if it was','line_number':357,'multiline':False]
['text':' constructed as a shared_ptr and vice versa, but memcpying out','line_number':358,'multiline':False]
['text':' the representation is always OK, so here's an accessor to obey','line_number':359,'multiline':False]
['text':' the letter of the law.','line_number':360,'multiline':False]
['text':' Without SharedPtrWrapper, this line would read','line_number':380,'multiline':False]
['text':' `shared_.~shared_ptr()` and nvcc would complain with','line_number':381,'multiline':False]
['text':' "error: expected primary-expression before '>' token"','line_number':382,'multiline':False]
['text':' referring to the "t" in "shared_ptr". SharedPtrWrapper','line_number':383,'multiline':False]
['text':' exists to work around this compiler bug.','line_number':384,'multiline':False]
['text':' subtyping relation. By default, we return true for the case','line_number':395,'multiline':False]
['text':' when the type is exactly equal or if this <: T where rhs = Optional[T]','line_number':396,'multiline':False]
['text':' if this returns false and the why_not stream is non-null, it contains','line_number':398,'multiline':False]
['text':' additional details that describe why this is not a subtype of 'rhs'.','line_number':399,'multiline':False]
['text':' This additional information should only contain details that are not','line_number':400,'multiline':False]
['text':' obvious from the annotation_str() that describes the type. For instance it','line_number':401,'multiline':False]
['text':' is clear that `int <: str` is false but not clear why `Foo <: InterfaceBar`','line_number':402,'multiline':False]
['text':' might be false.','line_number':403,'multiline':False]
['text':' Compatibility shims to accommodate existing code that passes shared_ptrs','line_number':409,'multiline':False]
['text':' around. Ideally, we would just delete this, but it should be harmless.','line_number':410,'multiline':False]
['text':' How this type will appear in FunctionSchema declarations','line_number':447,'multiline':False]
['text':' How this type will appear as if it were a type annotation in Python','line_number':450,'multiline':False]
['text':' which is sometimes different than how it appears in declarations (e.g.','line_number':451,'multiline':False]
['text':' int[] vs List[int])','line_number':452,'multiline':False]
['text':'','line_number':453,'multiline':False]
['text':' Takes a custom printer that users can pass in to customize the output of','line_number':454,'multiline':False]
['text':' this method.','line_number':455,'multiline':False]
['text':' the printer can return nullopt to fall through to the default impl','line_number':458,'multiline':False]
['text':' Overload instead of define a default value for `printer` to help','line_number':466,'multiline':False]
['text':' debuggers out.','line_number':467,'multiline':False]
['text':' Returns a human readable string that includes additional information like','line_number':471,'multiline':False]
['text':' "type is inferred rather than explicitly defined" to help construct more','line_number':472,'multiline':False]
['text':' user-friendly messages.','line_number':473,'multiline':False]
['text':' Dynamically cast this object to the subclass indicated by the','line_number':495,'multiline':False]
['text':' template variable, returning nullptr if the cast is invalid.','line_number':496,'multiline':False]
['text':' list of types this type contains, e.g. for a List then element type of a','line_number':569,'multiline':False]
['text':' list for a tuple, the types of the tuple elements','line_number':570,'multiline':False]
['text':' create a new version of this type, replacing its contained types with','line_number':580,'multiline':False]
['text':' contained_types','line_number':581,'multiline':False]
['text':' per-type constructor, you only need to override this if the','line_number':583,'multiline':False]
['text':' containedTypes() is not empty','line_number':584,'multiline':False]
['text':'contained_types','line_number':586,'multiline':True]
['text':' Explicitly enable MaybeOwned<shared_ptr<T>>, rather than allowing','line_number':651,'multiline':False]
['text':' MaybeOwned to be used for any type right away.','line_number':652,'multiline':False]
['text':' Base class for Types that are guaranteed to be owned by std::shared_ptr.','line_number':657,'multiline':False]
['text':' Types with no contained_types don't need this call. Check before calling!','line_number':664,'multiline':False]
['text':'','line_number':665,'multiline':False]
['text':' (We can't support this efficiently because types without','line_number':666,'multiline':False]
['text':' contained types may be singletons, in which case','line_number':667,'multiline':False]
['text':' shared_from_this will crash; we would have to provide a virtual','line_number':668,'multiline':False]
['text':' typeptr_from_this or isSingleton.)','line_number':669,'multiline':False]
['text':' Fully qualified name of type','line_number':700,'multiline':False]
['text':' Looks like: "foo.bar.Baz".','line_number':701,'multiline':False]
['text':' namespace c10','line_number':710,'multiline':False]
['text':' namespace std','line_number':719,'multiline':False]
