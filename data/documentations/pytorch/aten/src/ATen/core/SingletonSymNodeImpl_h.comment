['text':' The motivating usecase for this is to represent the ragged size structure','line_number':10,'multiline':False]
['text':' of a jagged tensor [B, [s_0, s_1, s_2], D] as a single integer j0. This','line_number':11,'multiline':False]
['text':' allows us to simply return [B, j0, D] if someone queries for the size of our','line_number':12,'multiline':False]
['text':' tensor.','line_number':13,'multiline':False]
['text':'','line_number':14,'multiline':False]
['text':' Morally we define comparison between two singleton ints to return true if','line_number':15,'multiline':False]
['text':' that comparison holds for all corresponding elements of the arrays they','line_number':16,'multiline':False]
['text':' represent. Comparison between a singleton int and a plain int is defined','line_number':17,'multiline':False]
['text':' similarly.','line_number':18,'multiline':False]
['text':'','line_number':19,'multiline':False]
['text':' To simulate this desired behavior but also avoid the O(N) cost of checking,','line_number':20,'multiline':False]
['text':' we associate each raggedness pattern with an integer "id" that can be used as','line_number':21,'multiline':False]
['text':' a proxy to evaluate equality. We also constrain the range of values for this','line_number':22,'multiline':False]
['text':' as to enable inequality checks.','line_number':23,'multiline':False]
['text':'','line_number':24,'multiline':False]
['text':' We also support a positive integer scalar "coeff" that is used for computing','line_number':25,'multiline':False]
['text':' strides. For example given, a [B, j0, D] tensor, it can be strided in two','line_number':26,'multiline':False]
['text':' different ways: [D * j0, D, 1] and [j0, 1, sum(j0)]. The coeff is used to','line_number':27,'multiline':False]
['text':' differentiate the two cases.','line_number':28,'multiline':False]
['text':'','line_number':29,'multiline':False]
['text':' During tracing the strides of the outputs need to be a function of the size','line_number':30,'multiline':False]
['text':' and strides of the inputs so it is important that SingletonSymNode itself is','line_number':31,'multiline':False]
['text':' able to express this.','line_number':32,'multiline':False]
['text':' CAUTION: you should probably not be constructing these directly; please','line_number':35,'multiline':False]
['text':' the higher-level API in python instead (TODO: actually introduce that).','line_number':36,'multiline':False]
['text':' NOTE [ Inequalities with SingletonInt ]','line_number':87,'multiline':False]
['text':'','line_number':88,'multiline':False]
['text':' The semantics of SingletonInt when it comes to relations is that it is','line_number':89,'multiline':False]
['text':' treated as integer known to be within a certain range,','line_number':90,'multiline':False]
['text':'','line_number':91,'multiline':False]
['text':'     j0 \in [2, int64_t::max]','line_number':92,'multiline':False]
['text':'','line_number':93,'multiline':False]
['text':' allowing us to answer queries like j0 >= 1 (True), and j0 == 0 (False).','line_number':94,'multiline':False]
['text':' This is a useful default range for the raggedness pattern of a jagged','line_number':95,'multiline':False]
['text':' tensor (1) since sizes are non-negative, and (2) we need to get past 0/1','line_number':96,'multiline':False]
['text':' specialization checks.','line_number':97,'multiline':False]
['text':'','line_number':98,'multiline':False]
['text':' [ Indeterminate inequalities error out ]','line_number':99,'multiline':False]
['text':'','line_number':100,'multiline':False]
['text':' Given the semantic defined above, certain relations like j0 < 3 are thus','line_number':101,'multiline':False]
['text':' indeterminable. In our impl today, evaluating such relations error','line_number':102,'multiline':False]
['text':'','line_number':103,'multiline':False]
['text':' It may seem convenient to just define indeterminate relations to return','line_number':104,'multiline':False]
['text':' False, but the implementation we maintain in parallel using sympy does not','line_number':105,'multiline':False]
['text':' allow this.','line_number':106,'multiline':False]
['text':'','line_number':107,'multiline':False]
['text':' Sympy only allows overriding of Ge. The other relations (Lt, Gt, Le) are,','line_number':108,'multiline':False]
['text':' by consequence, all derived from Ge e.g., Lt(a, b) := !Ge(a, b). This','line_number':109,'multiline':False]
['text':' would mean that means that if we define the indeterminate j0 >= 3 to be','line_number':110,'multiline':False]
['text':' False, the also indeterminate j0 < 3 will be evaluated to be True!','line_number':111,'multiline':False]
['text':'','line_number':112,'multiline':False]
['text':' [ Coefficient are assumed positive ]','line_number':113,'multiline':False]
['text':'','line_number':114,'multiline':False]
['text':' For the purpose of computing inequalities, we consider the coefficient of','line_number':115,'multiline':False]
['text':' the SingletonInt to be a positive integer.','line_number':116,'multiline':False]
['text':'','line_number':117,'multiline':False]
['text':' Thus, no modifications are needed to the logic since','line_number':118,'multiline':False]
['text':' j0 >= k implies coeff * j0 >= k','line_number':119,'multiline':False]
['text':'','line_number':120,'multiline':False]
['text':' namespace c10','line_number':178,'multiline':False]
