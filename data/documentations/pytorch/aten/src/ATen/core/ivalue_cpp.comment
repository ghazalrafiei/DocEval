['text':' Like Python, for containers we consider identity equality to be','line_number':20,'multiline':False]
['text':' sufficient but not necessary for value equality','line_number':21,'multiline':False]
['text':' This is in ivalue.cpp because we need to access Type::annotation_str, which','line_number':29,'multiline':False]
['text':' is declared in jit_type.h','line_number':30,'multiline':False]
['text':' NB: doing pointer comparison here','line_number':32,'multiline':False]
['text':' If in the future there ever arises a need to call operator== on custom class','line_number':33,'multiline':False]
['text':' Type's, this needs to be changed!','line_number':34,'multiline':False]
['text':' see [container equality]','line_number':59,'multiline':False]
['text':' namespace ivalue','line_number':84,'multiline':False]
['text':' switch above is complete but this silences compiler warnings','line_number':145,'multiline':False]
['text':' This static_assert has to go into some IValue member function; I','line_number':148,'multiline':False]
['text':' chose this one. It's not in the class body because that's in','line_number':149,'multiline':False]
['text':' ivalue.h, which is a very high-fanout header file and we want to','line_number':150,'multiline':False]
['text':' minimize build time.','line_number':151,'multiline':False]
['text':' Shortcut','line_number':159,'multiline':False]
['text':' Record Object IValue and its attributes.','line_number':233,'multiline':False]
['text':' don't record scalars.','line_number':263,'multiline':False]
['text':' The only case we don't return bool is for tensor comparison. In Python,','line_number':289,'multiline':False]
['text':' `bool()` is called on the return value of `__eq__` if the return value is','line_number':290,'multiline':False]
['text':' not a boolean. Mimic that behavior here.','line_number':291,'multiline':False]
['text':' In Python you're not supposed to do this comparison apparently. Not','line_number':307,'multiline':False]
['text':' sure if we should warn here or what','line_number':308,'multiline':False]
['text':' Unitialized ivalues show up in no-ops when the compiler can prove a','line_number':357,'multiline':False]
['text':' value will never be used. Just return false on any equality comparison.','line_number':358,'multiline':False]
['text':' the above switch should be exhaustive','line_number':361,'multiline':False]
['text':' Tensor __hash__ is equivalent to `id()`, so take the pointer value of','line_number':374,'multiline':False]
['text':' the tensor to emulate it','line_number':375,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-branch-clone)','line_number':377,'multiline':False]
['text':' NB: these are technically strict aliasing violations','line_number':382,'multiline':False]
['text':' the above switch should be exhaustive','line_number':413,'multiline':False]
['text':' Special handling for undefined tensors:','line_number':423,'multiline':False]
['text':' 1. Undefined_tensor is None and vice versa.','line_number':424,'multiline':False]
['text':' 2. Undefined_tensor is Undefined_tensor.','line_number':429,'multiline':False]
['text':' Use the standard way of comparing two tensors for identity','line_number':435,'multiline':False]
['text':' note: avoids calling type() to avoid extra referencing counting for the returned type.','line_number':447,'multiline':False]
['text':' Properly disambiguate the type of an empty list','line_number':513,'multiline':False]
['text':' Properly disambiguate the type of an empty dict','line_number':554,'multiline':False]
['text':' First check if the caller has provided a custom formatter. Use that if possible.','line_number':586,'multiline':False]
['text':' continue to use custom formatter in recursion','line_number':592,'multiline':False]
['text':' -0.0 (signed zero) needs to be parsed as -0.','line_number':605,'multiline':False]
['text':' Reaching here means two tuples are equal.','line_number':750,'multiline':False]
['text':' Quick pass to satisfy "strict weak ordering" requirement','line_number':764,'multiline':False]
['text':' gt(a, b) === lt(b, a)','line_number':782,'multiline':False]
['text':' TODO we should attempt to call __str__ if the object defines it.','line_number':859,'multiline':False]
['text':' print this out the way python would do it','line_number':861,'multiline':False]
['text':' NB: this doesn't work if an object contains itself, and it may','line_number':974,'multiline':False]
['text':' come up in the future when we expand the object system, we will','line_number':975,'multiline':False]
['text':' have a follow up PR to fix this when it becomes an issue.','line_number':976,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-unchecked-optional-access)','line_number':988,'multiline':False]
['text':' If we've gotten here, it means that we have *not* copied this','line_number':1043,'multiline':False]
['text':' class via __getstate__ and __setstate__. That fact and the','line_number':1044,'multiline':False]
['text':' fact that we have a Capsule attribute mean that this is a','line_number':1045,'multiline':False]
['text':' custom C++ class without serialization methods defined.','line_number':1046,'multiline':False]
['text':' Needs to be in this .cpp file to access the full definition of PyObjectHolder','line_number':1081,'multiline':False]
['text':' getSubValues works poorly on Python objects: it only works if they can be','line_number':1085,'multiline':False]
['text':' converted to a "regular" IValue type hence, for example, it doesn't support','line_number':1086,'multiline':False]
['text':' custom subclasses. Thus, instead, we extract the tensors through pickling.','line_number':1087,'multiline':False]
['text':' Sparse tensor is indices and values. Both are tensors','line_number':1094,'multiline':False]
['text':' and contain storage. Therefore num_storages needs to be','line_number':1095,'multiline':False]
['text':' incremented by 2.','line_number':1096,'multiline':False]
['text':' A dense/strided tensor contains 1 storage.','line_number':1099,'multiline':False]
['text':' Sparse tensor is indices and values. Both are tensors','line_number':1106,'multiline':False]
['text':' and contain storage.','line_number':1107,'multiline':False]
['text':' TODO (rohan-varma): for tensors created with at::sparse_coo_tensor held','line_number':1108,'multiline':False]
['text':' in a python object, this might need a coalesce().','line_number':1109,'multiline':False]
['text':' A dense/strided tensor contains 1 storage','line_number':1113,'multiline':False]
['text':' Prefer getSubValues() over visit() as the latter is a silent no-op for','line_number':1119,'multiline':False]
['text':' some unsupported types, whereas the former at least fails loudly.','line_number':1120,'multiline':False]
['text':' sparse tensors have 2 storages! One for indices one for values','line_number':1126,'multiline':False]
['text':' No need to pass devices, because dstFuture won't directly contain','line_number':1146,'multiline':False]
['text':' the value, it will contain the srcFutures (which have no DataPtrs).','line_number':1147,'multiline':False]
['text':' Set error and exit early if encountered.','line_number':1162,'multiline':False]
['text':' No need to pass DataPtrs, because dstFuture won't directly contain','line_number':1169,'multiline':False]
['text':' the value, it will contain the srcFutures (which have no DataPtrs).','line_number':1170,'multiline':False]
['text':' Once future is satisfied, remove refs.','line_number':1231,'multiline':False]
['text':' namespace c10','line_number':1247,'multiline':False]
