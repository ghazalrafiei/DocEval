['text':' This hashing is all hidden behind a static initializer so it','line_number':20,'multiline':False]
['text':' doesn't have to be optimal','line_number':21,'multiline':False]
['text':' namespace std','line_number':36,'multiline':False]
['text':' Perf from the lock is ok because this function is guarded behind','line_number':279,'multiline':False]
['text':' a static initializer; it should only be called once per type.','line_number':280,'multiline':False]
['text':' Perf from the lock is ok because this function is guarded behind','line_number':292,'multiline':False]
['text':' a static initializer; it should only be called once per type.','line_number':293,'multiline':False]
['text':' Perf from the lock is ok because this function is guarded behind','line_number':306,'multiline':False]
['text':' a static initializer; it should only be called once per type.','line_number':307,'multiline':False]
['text':' "Dict[" ','line_number':322,'multiline':True]
['text':' ", " ','line_number':322,'multiline':True]
['text':' "]" ','line_number':322,'multiline':True]
['text':' check direct subtyping relation','line_number':368,'multiline':False]
['text':' Handle non-container types which do not subtype each other and unify','line_number':375,'multiline':False]
['text':' NB: we do not return NumberType because there is not currently enough','line_number':386,'multiline':False]
['text':' operator support for it','line_number':387,'multiline':False]
['text':' Attempt to unify Complete Tensor Types for immutable type containers','line_number':389,'multiline':False]
['text':' unify(Optional[t1], t2) => Optional[unify(t1, t2)]','line_number':391,'multiline':False]
['text':' Check direct subtyping relations again with Unshaped Types,','line_number':427,'multiline':False]
['text':' to handle unification of mutable container types which might contain two different','line_number':428,'multiline':False]
['text':' specialized tensors (ListType / DictType)','line_number':429,'multiline':False]
['text':' Check whether or not `type_hint` is a common parent. This case','line_number':439,'multiline':False]
['text':' could occur if we had two class types that had been annotated with','line_number':440,'multiline':False]
['text':' a common interface','line_number':441,'multiline':False]
['text':' NOTE: This function actually does need to take const TypePtr&','line_number':485,'multiline':False]
['text':' because it sometimes calls unifyTypes, which needs const TypePtr&.','line_number':486,'multiline':False]
['text':' note: unifyTypes allows subtyping in either direction, so actual','line_number':504,'multiline':False]
['text':' may be a supertype of the current binding. we're not responsible','line_number':505,'multiline':False]
['text':' for reporting the error, only for keeping type_env stable','line_number':506,'multiline':False]
['text':' propagate the errMsg onward','line_number':519,'multiline':False]
['text':' If the actual type is a non-optional, allow matching to the formal if','line_number':601,'multiline':False]
['text':' its element type matches the actual.','line_number':602,'multiline':False]
['text':' Don't match None because it is already an optional (but one of','line_number':603,'multiline':False]
['text':' unknown type).','line_number':604,'multiline':False]
['text':' note: if actual was None here we potentially did not fill in the type','line_number':607,'multiline':False]
['text':' variables contained in the formal. It is still a valid match because None','line_number':608,'multiline':False]
['text':' matches Optional[T] later error checking on tryEvalTypeVariables will','line_number':609,'multiline':False]
['text':' report the problem if we never match variables in type T','line_number':610,'multiline':False]
['text':' change return types like List[List[t]] into List[List[int]]','line_number':635,'multiline':False]
['text':' Builtin Union types','line_number':672,'multiline':False]
['text':' since classes can be members of multiple interfaces, we cannot','line_number':676,'multiline':False]
['text':' construct which interface the list holds from the members alone','line_number':677,'multiline':False]
['text':' List of Any can contains heterogenous types','line_number':681,'multiline':False]
['text':' Check if `this` is a subtype of any of the types within the Union','line_number':704,'multiline':False]
['text':'name=','line_number':758,'multiline':True]
['text':'type=','line_number':759,'multiline':True]
['text':'N=','line_number':760,'multiline':True]
['text':'name=','line_number':770,'multiline':True]
['text':'type=','line_number':771,'multiline':True]
['text':'N=','line_number':772,'multiline':True]
['text':'default_value=','line_number':773,'multiline':True]
['text':'name=','line_number':779,'multiline':True]
['text':'overload_name=','line_number':780,'multiline':True]
['text':'arguments=','line_number':781,'multiline':True]
['text':'returns=','line_number':782,'multiline':True]
['text':' NOLINT(modernize-make-shared)','line_number':784,'multiline':False]
['text':' unnamed tuple is not a subtype of nametuple','line_number':851,'multiline':False]
['text':' namedtuple may be a subtype of unnamed tuple','line_number':854,'multiline':False]
['text':' co-variant rules for tuples','line_number':870,'multiline':False]
['text':' `compare` guarantees that rhs is always a TupleType.','line_number':893,'multiline':False]
['text':' `typing.Tuple` special-cases the annotation syntax for empty tuple','line_number':925,'multiline':False]
['text':' with `typing.Tuple[()]`. See','line_number':926,'multiline':False]
['text':' https://docs.python.org/3/library/typing.html#typing.Tuple','line_number':927,'multiline':False]
['text':' Fast path for expectedly-small Tuples.','line_number':931,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-argument-comment)','line_number':1000,'multiline':False]
['text':'is_method=','line_number':1001,'multiline':True]
['text':' to improve performance this check can be cached','line_number':1017,'multiline':False]
['text':' namespace c10','line_number':1093,'multiline':False]
