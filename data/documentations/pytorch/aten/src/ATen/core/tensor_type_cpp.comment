['text':' The idea is to only mark possible overlap across dimensions. We want to','line_number':11,'multiline':False]
['text':' return false for expanded tensors and permuted tensors, for which dimensional','line_number':12,'multiline':False]
['text':' collapsing is safe.','line_number':13,'multiline':False]
['text':' sort indices going with ascending strides','line_number':19,'multiline':False]
['text':' we are being conservative on checking for memory overlap','line_number':32,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-unchecked-optional-access)','line_number':79,'multiline':False]
['text':' TODO: Unranked SymbolicShape printing is ambiguous with that of','line_number':99,'multiline':False]
['text':' dynamic-shaped vector.','line_number':100,'multiline':False]
['text':' default has_overlap to false as we only compute overlap when:','line_number':156,'multiline':False]
['text':' 1. input sizes/strides fails format check;','line_number':157,'multiline':False]
['text':' 2. tensor_contiguity are not set.','line_number':158,'multiline':False]
['text':' Sorting strides in ascending order','line_number':161,'multiline':False]
['text':' Example:','line_number':162,'multiline':False]
['text':'  Prior to sorting','line_number':163,'multiline':False]
['text':'  Idx:     [0,   1,  2,  3]','line_number':164,'multiline':False]
['text':'  sizes:   [8,   1, 10, 16]','line_number':165,'multiline':False]
['text':'  Strides: [160, 1, 16,  1]','line_number':166,'multiline':False]
['text':'  After sorting','line_number':167,'multiline':False]
['text':'  Idx:     [1,  3,  2,   0]','line_number':168,'multiline':False]
['text':'  sizes:   [1, 16, 10,   8]','line_number':169,'multiline':False]
['text':'  Strides: [1,  1, 16, 160]','line_number':170,'multiline':False]
['text':'','line_number':171,'multiline':False]
['text':' The logic below follows what TensorIterator uses in its logic:','line_number':172,'multiline':False]
['text':'   1. Fast_set_up is the short-cut to identify a. channels_last and','line_number':173,'multiline':False]
['text':'      b. contiguous format, which is what we have in the below logic.','line_number':174,'multiline':False]
['text':'   2. In more generla cases, it does best effort to preserve permutatoin.','line_number':175,'multiline':False]
['text':' case 1.a. short cut channels last','line_number':177,'multiline':False]
['text':' case 1.b. short cut contiguous','line_number':182,'multiline':False]
['text':' case 2.','line_number':186,'multiline':False]
['text':'','line_number':187,'multiline':False]
['text':' For broadcasted dimension where stride is 0, we have to stick to','line_number':188,'multiline':False]
['text':' TensorIterator behavior in eager, where they introduce an ambiguous','line_number':189,'multiline':False]
['text':' comparison result to preserve permutation by best effort.','line_number':190,'multiline':False]
['text':' For more details, see NOTE: [Computing output strides]','line_number':191,'multiline':False]
['text':' strides[a] == strides[b]','line_number':199,'multiline':False]
['text':' conveniently is_contiguous_strides/is_contiguous_strides only returns','line_number':218,'multiline':False]
['text':' true when there's no memory overlap, so we only re-compute has_overlap','line_number':219,'multiline':False]
['text':' in the last branch when both returns false','line_number':220,'multiline':False]
['text':' trust tensor_contiguity and only computes overlap when it is not set','line_number':222,'multiline':False]
['text':' innermost stride expected to be 1','line_number':233,'multiline':False]
['text':' TODO: turn contiguous_ into an enum CONTIGUOUS, NONCONTIGUOUS,','line_number':234,'multiline':False]
['text':' BROADCASTED','line_number':235,'multiline':False]
['text':' leaving this assign statement for readability;','line_number':245,'multiline':False]
['text':' handles case where strides are set','line_number':284,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-unchecked-optional-access)','line_number':285,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-unchecked-optional-access)','line_number':288,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-unchecked-optional-access)','line_number':291,'multiline':False]
['text':' strides are all null, but still have number of strides equal to number of ranks','line_number':296,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-unchecked-optional-access)','line_number':298,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-unchecked-optional-access)','line_number':301,'multiline':False]
['text':' NOLINTNEXTLINE(bugprone-unchecked-optional-access)','line_number':347,'multiline':False]
['text':' we turn symbolic shapes into unknowns','line_number':349,'multiline':False]
['text':' When the followings are true, we consider it's not a match:','line_number':380,'multiline':False]
['text':' - undefined().has_value() == true','line_number':381,'multiline':False]
['text':' - undefined().value() != !t.defined()','line_number':382,'multiline':False]
['text':' When the followings are true, we consider it's a match:','line_number':385,'multiline':False]
['text':' - t is not defined','line_number':386,'multiline':False]
['text':' - undefined() == null or undefined().value() == true','line_number':387,'multiline':False]
['text':' Here we know t.defined() == true and compare all other properties.','line_number':390,'multiline':False]
['text':' if we have the same pointer, avoid computing the merge','line_number':467,'multiline':False]
