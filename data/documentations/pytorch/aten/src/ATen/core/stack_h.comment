['text':' TODO move this to c10 namespace','line_number':9,'multiline':False]
['text':' An operation with N inputs and M outputs pops the last N inputs off','line_number':53,'multiline':False]
['text':' the stack and pushes its M inputs onto the stack','line_number':54,'multiline':False]
['text':' before: <other stack items> I0, I1, ... IN <- stack.back()','line_number':55,'multiline':False]
['text':' after: <other stack items> O0, O1, ... OM','line_number':56,'multiline':False]
['text':' operations are defined this way so that ownership of inputs can be','line_number':57,'multiline':False]
['text':' transferred to the operation and it can incrementally drop ownership of','line_number':58,'multiline':False]
['text':' tensors when they become unneeded. For large operations, like 'run an entire','line_number':59,'multiline':False]
['text':' subgraph', this functionality is very important for minimizing gpu memory','line_number':60,'multiline':False]
['text':' usage return value is the relative 'offset' to jump to for the next','line_number':61,'multiline':False]
['text':' operation:','line_number':62,'multiline':False]
['text':'   pc += 1 + offset','line_number':63,'multiline':False]
['text':' so a return value of 0 goes to the next instruction','line_number':64,'multiline':False]
['text':' treat the last N elements of the stack as a list, looking up','line_number':66,'multiline':False]
['text':' element i','line_number':67,'multiline':False]
['text':' treat the last N elements of the stack as a list, looking up the','line_number':80,'multiline':False]
['text':' slice starting at index i and having length len','line_number':81,'multiline':False]
['text':' variadic pop:','line_number':119,'multiline':False]
['text':' int64_t a; at::Tensor b;','line_number':120,'multiline':False]
['text':' pop(stack, a, b);','line_number':121,'multiline':False]
['text':' equivalent to:','line_number':122,'multiline':False]
['text':' b = pop(stack).toTensor();','line_number':123,'multiline':False]
['text':' a = pop(stack).toInt();','line_number':124,'multiline':False]
['text':' The packer here is carefully written not to make any unnecessary','line_number':164,'multiline':False]
['text':' copies.','line_number':165,'multiline':False]
['text':' pack takes the return values of aten functions pushes them onto the stack','line_number':167,'multiline':False]
['text':' NB: *Not* a universal reference.','line_number':179,'multiline':False]
['text':' NB: The move here does not "destroy" the entire tuple, that is','line_number':181,'multiline':False]
['text':' not what std::move does; only the particular tuple index','line_number':182,'multiline':False]
['text':' processed here gets stolen.','line_number':183,'multiline':False]
['text':'stack','line_number':191,'multiline':True]
['text':'t','line_number':191,'multiline':True]
['text':' namespace jit','line_number':199,'multiline':False]
['text':' namespace torch','line_number':200,'multiline':False]
