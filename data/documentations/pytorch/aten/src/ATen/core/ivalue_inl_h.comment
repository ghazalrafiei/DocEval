['text':' namespace jit','line_number':34,'multiline':False]
['text':' namespace torch','line_number':36,'multiline':False]
['text':' For custom class __init__ registration, we need to pass in a function','line_number':44,'multiline':False]
['text':' that looks like this: [](IValue x, args...)','line_number':45,'multiline':False]
['text':' However, make_boxed_from_unboxed_functor.h automatically sets the input types','line_number':47,'multiline':False]
['text':' of the function by introspecting the types of the functor (which is IValue in','line_number':48,'multiline':False]
['text':' this case). However, we need the type it binds to be Foo.','line_number':49,'multiline':False]
['text':' Instead, we pass in a lambda [](ivalue_holder<CurClass> x, args...) from','line_number':51,'multiline':False]
['text':' which getTypePtr can recover the original class pointer.','line_number':52,'multiline':False]
['text':' As far as I can tell, omitting the usual explicit destructor call','line_number':164,'multiline':False]
['text':' is not UB in and of itself, and it's a slight perf win. The','line_number':165,'multiline':False]
['text':' destructor is a no-op, because the moved-from Tensor is','line_number':166,'multiline':False]
['text':' effectively an intrusive_ptr in the null state, so we don't need','line_number':167,'multiline':False]
['text':' the behavior for correctness reasons either. Leaving this','line_number':168,'multiline':False]
['text':' explanatory comment, including commented-out destructor call, to','line_number':169,'multiline':False]
['text':' make this abundantly clear.','line_number':170,'multiline':False]
['text':'','line_number':171,'multiline':False]
['text':' payload.as_tensor.~Tensor();','line_number':172,'multiline':False]
['text':' string','line_number':294,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)','line_number':297,'multiline':False]
['text':' We represent TupleElements this way to save doing a heap','line_number':327,'multiline':False]
['text':' allocation in the common (at least for unpickling) case where we','line_number':328,'multiline':False]
['text':' have only 3 elements. We have our own union instead of','line_number':329,'multiline':False]
['text':' c10::SmallVector<IValue> because c10::SmallVector<IValue> always','line_number':330,'multiline':False]
['text':' stores the begin/end/capacity pointers, which would be a waste of','line_number':331,'multiline':False]
['text':' space in our use case.','line_number':332,'multiline':False]
['text':' Don't want to declare a std::array because the convenient','line_number':335,'multiline':False]
['text':' iteration and size members are a footgun in this case -- the','line_number':336,'multiline':False]
['text':' actual size of the array may be smaller than 3!','line_number':337,'multiline':False]
['text':' NOLINTNEXTLINE(*c-arrays*)','line_number':338,'multiline':False]
['text':' It would be nice to make this noncopyable to prevent people from','line_number':403,'multiline':False]
['text':' writing code like `auto output =','line_number':404,'multiline':False]
['text':' forward(...).toTupleRef().elements()` (which does refcount bumps on','line_number':405,'multiline':False]
['text':' each element, unlike the more efficient but verbose','line_number':406,'multiline':False]
['text':' ```','line_number':407,'multiline':False]
['text':' auto outputIntrusivePtr = forward(...).toTuple();','line_number':408,'multiline':False]
['text':' const auto& output = outputIntrusivePtr->elements();','line_number':409,'multiline':False]
['text':' ```','line_number':410,'multiline':False]
['text':' ), but there is simply an overwhelming amount of code that does','line_number':411,'multiline':False]
['text':' it the inefficient way.','line_number':412,'multiline':False]
['text':' See also operator std::vector below.','line_number':413,'multiline':False]
['text':' Mimic implicit conversion from std::vector to ArrayRef.','line_number':510,'multiline':False]
['text':' More compatibility shims for the overwhelming amount of code that','line_number':635,'multiline':False]
['text':' likes to copy tuple elements into a vector; see comment above the','line_number':636,'multiline':False]
['text':' copy constructor.','line_number':637,'multiline':False]
['text':' lazily computed for unnamed tuples','line_number':667,'multiline':False]
['text':' named tuples have additional type information, so we','line_number':670,'multiline':False]
['text':' directly create them tagged','line_number':671,'multiline':False]
['text':' MSVC apparently can't disambiguate the other two overloads of','line_number':690,'multiline':False]
['text':' create when passed an initializer_list without this.','line_number':691,'multiline':False]
['text':' Workaround inability to use `>` operator in template argument list.','line_number':721,'multiline':False]
['text':' Again, it would be nice to make this noncopyable, but there's a','line_number':741,'multiline':False]
['text':' lot of extant code that copies Tuples.','line_number':742,'multiline':False]
['text':' Tuple(const Tuple& rhs) = delete;','line_number':743,'multiline':False]
['text':' NOTE: If we try to avoid the overloads without','line_number':795,'multiline':False]
['text':' `std::shared_ptr<TupleType> type` by defaulting it to nullptr, we','line_number':796,'multiline':False]
['text':' end up having to call (part of) the shared_ptr destructor for','line_number':797,'multiline':False]
['text':' `type` even though we should know statically it won't do','line_number':798,'multiline':False]
['text':' anything.','line_number':799,'multiline':False]
['text':' namespace ivalue','line_number':836,'multiline':False]
['text':' Future','line_number':838,'multiline':False]
['text':' Keep this private in order to force users to go through make_intrusive and','line_number':841,'multiline':False]
['text':' thus prevent creating a Future that's not held by an intrusive_ptr.','line_number':842,'multiline':False]
['text':' whether the Future& passed in is actually used','line_number':852,'multiline':False]
['text':'*
   * Wait on the future until it completes.
   ','line_number':878,'multiline':True]
['text':'*
   * Wait on the future until it completes and throw an
   * exception if an error exists.
   ','line_number':887,'multiline':True]
['text':'*
   * Explicitly mark the future as completed with the output value. Optionally,
   * the storages for all tensors in IValue can be passed as well. The DataPtrs
   * of these storages are used to synchronize CUDA streams. If storages isn't
   * given we will attempt to extract it from the value, if we need to (this
   * happens if a non-empty set of devices was given to the constructor). Thus
   * one only needs to provide storages when 1) they cannot be extracted through
   * IValue::getSubValues() or through pickling in case of Python object; or
   * when 2) customized storage extraction is more efficient.
   ','line_number':899,'multiline':True]
['text':' Start by performing all steps that can throw, before setting any field.','line_number':913,'multiline':False]
['text':' Do this before even acquiring the mutex, because extractStorages might','line_number':914,'multiline':False]
['text':' acquire the GIL, which could lead to a lock inversion with our mutex.','line_number':915,'multiline':False]
['text':' See https://github.com/pytorch/pytorch/issues/58239.','line_number':916,'multiline':False]
['text':' FIXME We should always extract DataPtrs, in order to catch the case of','line_number':920,'multiline':False]
['text':' users using CUDA values but forgetting to set devices, which currently','line_number':921,'multiline':False]
['text':' leads to a silent synchronization/correctness issue. However, as this','line_number':922,'multiline':False]
['text':' might worsen perf in CPU-only cases, we should only do so after careful','line_number':923,'multiline':False]
['text':' benchmarks.','line_number':924,'multiline':False]
['text':' Only set value_ and completed_ flag once all checks and preparation steps','line_number':942,'multiline':False]
['text':' have returned successfully to allow for proper error propagation.','line_number':943,'multiline':False]
['text':' This should be rare and shouldn't cause log spew. Its important to','line_number':977,'multiline':False]
['text':' log errors and thats why we have this log here.','line_number':978,'multiline':False]
['text':' Get the result of the current future.','line_number':996,'multiline':False]
['text':' This accessor should only be used if we know that the future is','line_number':1006,'multiline':False]
['text':' completed() with no error.','line_number':1007,'multiline':False]
['text':' This accessor should only be used if we know that the future is','line_number':1020,'multiline':False]
['text':' completed() with no error.','line_number':1021,'multiline':False]
['text':'*
   * Add a callback to the future.
   * The callbacks will be executed once the future completes.
   * If the future has already completed,
   * this function will execute the callback immediately.
   ','line_number':1029,'multiline':True]
['text':'*
   * Add a callback to the future, and return another Future to hold the return
   * value of the callback. This is necessary when the callback provider needs
   * to know for sure when the callback has finished.
   ','line_number':1052,'multiline':True]
['text':' Tries to retrieve the error message from std::exception_ptr.','line_number':1115,'multiline':False]
['text':' Check if the current future has completed','line_number':1122,'multiline':False]
['text':' This method should be used when one intends to manually create a child','line_number':1154,'multiline':False]
['text':' future, for example when implementing a customized version of then().','line_number':1155,'multiline':False]
['text':' This method should always be used when invoking a callback (regardless of','line_number':1162,'multiline':False]
['text':' how/when that happens) as it will ensure that the proper "environment" is','line_number':1163,'multiline':False]
['text':' set up before running the callback, as in, it will set up the CUDA streams,','line_number':1164,'multiline':False]
['text':' synchronize them with the value, and so on (if needed).','line_number':1165,'multiline':False]
['text':' The synchronization performed below shouldn't be needed when the future','line_number':1174,'multiline':False]
['text':' is not used by the callback.','line_number':1175,'multiline':False]
['text':' This method should be called before this future's value is used, as it','line_number':1192,'multiline':False]
['text':' ensures that the CUDA streams that are "current" at the callsite properly','line_number':1193,'multiline':False]
['text':' synchronize with the value.','line_number':1194,'multiline':False]
['text':' Tries to retrieve the error message from std::exception_ptr.','line_number':1235,'multiline':False]
['text':' Defined in ivalue.cpp.','line_number':1246,'multiline':False]
['text':' We need devices to be sorted in order to use ensureIsSubsetOfDevices.','line_number':1315,'multiline':False]
['text':'impl','line_number':1317,'multiline':True]
['text':' Deduplicate by compacting.','line_number':1322,'multiline':False]
['text':' It's a duplicate, skip it.','line_number':1329,'multiline':False]
['text':' If there were duplicates there's now a gap at the end: trim it. Resizing','line_number':1337,'multiline':False]
['text':' requires the item type to be default-constructible (which c10::Device is','line_number':1338,'multiline':False]
['text':' not) because in principle it could be required to create new items. Since','line_number':1339,'multiline':False]
['text':' we know we'll shrink the vector, we provide a custom dummy value instead.','line_number':1340,'multiline':False]
['text':' We assume the devices in both vectors have the same consistent type, and','line_number':1348,'multiline':False]
['text':' their indices are unique and sorted.','line_number':1349,'multiline':False]
['text':' is this future complete','line_number':1367,'multiline':False]
['text':' when finished the value','line_number':1370,'multiline':False]
['text':' An upcast pointer to a virtual class which allows us to manipulate events,','line_number':1375,'multiline':False]
['text':' streams, ... in a generic way, without an explicit dependency on CUDA.','line_number':1376,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)','line_number':1377,'multiline':False]
['text':' The device that was current when markCompleted was called, which we'll','line_number':1380,'multiline':False]
['text':' restore when invoking callbacks. It's optional because we'll only store it','line_number':1381,'multiline':False]
['text':' if the future completes successfully.','line_number':1382,'multiline':False]
['text':' The events that correspond to the completion of the async I/O kernels. They','line_number':1385,'multiline':False]
['text':' are recorded on the appropriate streams when the future is marked completed','line_number':1386,'multiline':False]
['text':' and can then be queried/waited/blocked on. There is one event for each','line_number':1387,'multiline':False]
['text':' distinct device on which the value's tensors reside.','line_number':1388,'multiline':False]
['text':' A cached version of the storages extracted from the value when the future','line_number':1391,'multiline':False]
['text':' is first marked completed.','line_number':1392,'multiline':False]
['text':' The bounding set of devices that this future, and any of its children, is','line_number':1395,'multiline':False]
['text':' allowed to use. This is a superset of the set of devices used by the events','line_number':1396,'multiline':False]
['text':' above. We need this to know what streams (for which devices) to set as','line_number':1397,'multiline':False]
['text':' current when invoking a callback, thus allowing the callback to use devices','line_number':1398,'multiline':False]
['text':' that the parent future didn't use. This field is set to the value provided','line_number':1399,'multiline':False]
['text':' in the constructor and will be "inherited" by all child futures.','line_number':1400,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-const-or-ref-data-members)','line_number':1401,'multiline':False]
['text':' Input is a list of Futures with the same target type.','line_number':1477,'multiline':False]
['text':' Output is a Future to the List of completed Futures.','line_number':1478,'multiline':False]
['text':' Input is a List of Futures with the same target type.','line_number':1481,'multiline':False]
['text':' Output is a Future that will be updated with a seen value.','line_number':1482,'multiline':False]
['text':' User-defined object.','line_number':1486,'multiline':False]
['text':' In general, class types hold a shared_ptr to its owning CompilationUnit,','line_number':1489,'multiline':False]
['text':' so that its type and methods do not get deallocated while the class exists.','line_number':1490,'multiline':False]
['text':' However, the CompilationUnit holds ownership of the type's graphs, so','line_number':1491,'multiline':False]
['text':' inserting a constant object into a Graph would create a reference cycle if','line_number':1492,'multiline':False]
['text':' that constant object held a shared_ptr to its CU. For these objects we','line_number':1493,'multiline':False]
['text':' instatiate them with non-owning references to its CU','line_number':1494,'multiline':False]
['text':'*
   * Slot API.
   *
   * Attributes are stored as a simple vector so that lookups are fast at
   * runtime. A "slot" is just an index into that vector, which can be computed
   * statically if you have access to the class type. Use this API if you are
   * writing compiler stuff.
   ','line_number':1518,'multiline':True]
['text':' for module types, it is possible that the members of the class have','line_number':1528,'multiline':False]
['text':' expanded after the object was created. In this case, we expand','line_number':1529,'multiline':False]
['text':' the slots to the right size','line_number':1530,'multiline':False]
['text':' NOTE: This lookup is fairly hot, so we use unchecked access to the','line_number':1538,'multiline':False]
['text':' vector.  Errors should still be detectable with ASan.','line_number':1539,'multiline':False]
['text':'*
   * Attribute API.
   *
   * Wrappers around the slot stuff so that users can access attributes
   * directly. Use this API if you are a user.
   *
   * Note: Unlike in Python, TorchScript must make a distinction between
   * attributes (which are IValues) and methods (which are Methods). If you
   * want a method, use `obj.type()->getMethod()`
   ','line_number':1548,'multiline':True]
['text':' Remove attribute by name, caller is responsible for','line_number':1560,'multiline':False]
['text':' the safety of this operation','line_number':1561,'multiline':False]
['text':' We didn't remove the attribute in the type because the type','line_number':1562,'multiline':False]
['text':' might be shared by multiple objects.','line_number':1563,'multiline':False]
['text':' Therefore after removing attribute, the object is in an inconsistent','line_number':1564,'multiline':False]
['text':' state where it has more attribute types in its Type than','line_number':1565,'multiline':False]
['text':' the attribute slots it has, user needs to make sure the object','line_number':1566,'multiline':False]
['text':' has consistent by removing the attribute in type as well','line_number':1567,'multiline':False]
['text':' virtual ivalue PyObjectHolder that hold a py::object, we make this virtual','line_number':1615,'multiline':False]
['text':' because the py::object and refcounting logic should happen in libtorch_python','line_number':1616,'multiline':False]
['text':' see concrete implementation in python_ivalue.h','line_number':1617,'multiline':False]
['text':' namespace detail','line_number':1683,'multiline':False]
['text':' note: when adding a DEFINE_TO case here you should also add a','line_number':1691,'multiline':False]
['text':' toX method to IValue. These named methods are much more discoverable','line_number':1692,'multiline':False]
['text':' than the to templated function.','line_number':1693,'multiline':False]
['text':' generic_to<T> converts an IValue from a generic list or generic dict','line_number':1755,'multiline':False]
['text':' to a concrete list/dict type likelike List<T>, Dict<...> or optional<T>.','line_number':1756,'multiline':False]
['text':' Note that in the case of lists, this only works for IValue-based lists,','line_number':1757,'multiline':False]
['text':' i.e. not for int64_t, double, ...','line_number':1758,'multiline':False]
['text':' generic_to<T> is an implementation detail of IValue::to<T> and not','line_number':1759,'multiline':False]
['text':' supposed to be called directly.','line_number':1760,'multiline':False]
['text':' The _fake_type<T> parameter allows us to overload','line_number':1761,'multiline':False]
['text':' based on the return type.','line_number':1762,'multiline':False]
['text':' TODO this is deprecated but we don't throw a warning because a lot of ops in','line_number':1764,'multiline':False]
['text':' native_functions.yaml still return std::vector.','line_number':1765,'multiline':False]
['text':' C10_DEPRECATED_MESSAGE("IValues based on std::vector<T> are potentially slow','line_number':1766,'multiline':False]
['text':' and deprecated. Please use torch::List<T> instead.")','line_number':1767,'multiline':False]
['text':' We need to do a deep copy of the vector because there might be other','line_number':1769,'multiline':False]
['text':' references to this same IValue that also use the list. We can't just','line_number':1770,'multiline':False]
['text':' move the elements out.','line_number':1771,'multiline':False]
['text':' We need to do a deep copy of the array because there might be other','line_number':1874,'multiline':False]
['text':' references to this same IValue that also use the list. We can't just','line_number':1875,'multiline':False]
['text':' move the elements out.','line_number':1876,'multiline':False]
['text':' namespace detail','line_number':1886,'multiline':False]
['text':' namespace detail','line_number':1933,'multiline':False]
['text':' In the default implementation, the IValue is destroyed with std::move.','line_number':1956,'multiline':False]
['text':' But if the unboxed type is optional<string_view> we cannot destroy','line_number':1957,'multiline':False]
['text':' the IValue.','line_number':1958,'multiline':False]
['text':' This list is entirely integers; ensure it is typed as','line_number':2166,'multiline':False]
['text':' an IntList so toIntList works','line_number':2167,'multiline':False]
['text':' This list has SymInts; type it as a SymInt','line_number':2170,'multiline':False]
['text':' First, we try to use the boxed value.','line_number':2216,'multiline':False]
['text':' If we fail (either it's not in the boxed state, or its boxed type','line_number':2217,'multiline':False]
['text':' can not construct an IValue), we fallback to copying the list.','line_number':2218,'multiline':False]
['text':' numSlots ','line_number':2295,'multiline':True]
['text':' We choose to not use memcmp for payload check due to potential random','line_number':2386,'multiline':False]
['text':' padding characters on union type','line_number':2387,'multiline':False]
['text':' Semantics:','line_number':2389,'multiline':False]
['text':' 1. Immutable primitive values of the same type (Int, Double, None, Bool,','line_number':2390,'multiline':False]
['text':' Str) return value equality','line_number':2391,'multiline':False]
['text':' 2. If it is a tensor type, we need to take undefined tensor into account','line_number':2392,'multiline':False]
['text':' 3. Undefined_tensor is None and vice versa should be true','line_number':2393,'multiline':False]
['text':' 4. If it is a reference type (i.e. isIntrusivePtr()), then is True when','line_number':2394,'multiline':False]
['text':' the pointed-to object is the same.','line_number':2395,'multiline':False]
['text':' 5. False for all other comparisons.','line_number':2396,'multiline':False]
['text':' for bool type, do equality check','line_number':2400,'multiline':False]
['text':' special case: undefined tensor and None are the same identity','line_number':2405,'multiline':False]
['text':' special case: undefined tensor and None are the same identity','line_number':2408,'multiline':False]
['text':' for objects holding in IValue, do shallow compare on pointer address to','line_number':2417,'multiline':False]
['text':' testify the identity','line_number':2418,'multiline':False]
['text':'x','line_number':2436,'multiline':True]
['text':' namespace detail','line_number':2442,'multiline':False]
['text':' namespace ivalue','line_number':2450,'multiline':False]
['text':' namespace c10','line_number':2512,'multiline':False]
