['text':' NOTE: [functorch interpreter stack]','line_number':12,'multiline':False]
['text':'','line_number':13,'multiline':False]
['text':' functorch's dispatching system uses a stack of interpreters.','line_number':14,'multiline':False]
['text':' Historically we've referred to this as the "DynamicLayerStack".','line_number':15,'multiline':False]
['text':'','line_number':16,'multiline':False]
['text':' An interpreter is something that reads in the code it is passed','line_number':17,'multiline':False]
['text':' and then executes it. We have a different interpreter per-transform:','line_number':18,'multiline':False]
['text':' the "VmapInterpreter" is responsible for reading in operators (like aten::mv)','line_number':19,'multiline':False]
['text':' and executing the batched version of it (the batching rule for aten::mv).','line_number':20,'multiline':False]
['text':'','line_number':21,'multiline':False]
['text':' Concretely, each interpreter is responsible for two things:','line_number':22,'multiline':False]
['text':'','line_number':23,'multiline':False]
['text':' 1) process(ophandle, stack)','line_number':24,'multiline':False]
['text':' Given an operator handle and a stack of arguments, the interpreter is','line_number':25,'multiline':False]
['text':' responsible for figuring out how to execute the operation under the semantics','line_number':26,'multiline':False]
['text':' of the interpreter. For e.g. VmapInterpreter, this is figuring out how to call','line_number':27,'multiline':False]
['text':' the batching rule.','line_number':28,'multiline':False]
['text':'','line_number':29,'multiline':False]
['text':' The batching rules are stored as kernels on the FuncTorchBatched key, so the way','line_number':30,'multiline':False]
['text':' VmapInterpreter calls the batching rule is roughly: (A) exclude all','line_number':31,'multiline':False]
['text':' dispatch keys aside from the Batched key, (B) redispatch so we get to the','line_number':32,'multiline':False]
['text':' Batched key.','line_number':33,'multiline':False]
['text':'','line_number':34,'multiline':False]
['text':' 2) sendToNextInterpreter(ophandle, stack)','line_number':35,'multiline':False]
['text':' The VmapInterpreter, when it sees aten::mv, will process it into a call to','line_number':36,'multiline':False]
['text':' aten::mm. It then needs to send the call to aten::mm to the next interpreter','line_number':37,'multiline':False]
['text':' in the interpreter stack.','line_number':38,'multiline':False]
['text':'','line_number':39,'multiline':False]
['text':' The VmapInterpreter just does this via a call to ophandle.callBoxed(stack)','line_number':40,'multiline':False]
['text':' and most Interpreters will implement it this way.','line_number':41,'multiline':False]
['text':' always errors when calling a random function','line_number':44,'multiline':False]
['text':' randomness appears the same across batches','line_number':45,'multiline':False]
['text':' randomness appears different across batches','line_number':46,'multiline':False]
['text':' Unused','line_number':51,'multiline':False]
['text':' reverse-mode AD, aka vjp','line_number':53,'multiline':False]
['text':' forward-mode AD','line_number':54,'multiline':False]
['text':' NOTE: [Interpreter "subclassing" design]','line_number':60,'multiline':False]
['text':'','line_number':61,'multiline':False]
['text':' How are various Interpreters for different transforms (vmap, grad, ...)','line_number':62,'multiline':False]
['text':' implemented?','line_number':63,'multiline':False]
['text':'','line_number':64,'multiline':False]
['text':' Accessing interpreters is in the hot-path of functorch so we have a constraint','line_number':65,'multiline':False]
['text':' that this code must be as fast as possible.','line_number':66,'multiline':False]
['text':'','line_number':67,'multiline':False]
['text':' As a result, we stay away from virtual methods and this causes our code','line_number':68,'multiline':False]
['text':' to look a little funny.','line_number':69,'multiline':False]
['text':'','line_number':70,'multiline':False]
['text':' `Interpreter` is the struct for Interpreters. It holds ALL of the','line_number':71,'multiline':False]
['text':' relevant information (what type of interpreter it is and the metadata).','line_number':72,'multiline':False]
['text':' Metadata for each interpreter is represented as a Union (std::variant)','line_number':73,'multiline':False]
['text':' of all possible metadata (VmapInterpreterMeta, GradInterpreterMeta, ...).','line_number':74,'multiline':False]
['text':'','line_number':75,'multiline':False]
['text':' Given an Interpreter, how do I get a "VmapInterpreter"? You may wish to do this','line_number':76,'multiline':False]
['text':' if you want to access the metadata fields (like batchSize and randomness).','line_number':77,'multiline':False]
['text':'','line_number':78,'multiline':False]
['text':' Each type of interpreter (e.g. Vmap) has a convenience struct','line_number':79,'multiline':False]
['text':' (e.g. VmapInterpreterPtr) associated with it.','line_number':80,'multiline':False]
['text':'','line_number':81,'multiline':False]
['text':' Construct the convenience struct with VmapInterpreterPtr(Interpreter*),','line_number':82,'multiline':False]
['text':' and then one can access methods on VmapInterpreterPtr like so:','line_number':83,'multiline':False]
['text':' >>> VmapInterpreterPtr(&interpreter).batchSize()','line_number':84,'multiline':False]
['text':'','line_number':85,'multiline':False]
['text':' Finally, Interpreter::process switches on the type of the interpreter','line_number':86,'multiline':False]
['text':' and calls one of {Transform}Intepreter::processImpl under the hood.','line_number':87,'multiline':False]
['text':' Same for Interpreter::sendToNextInterpreter :)','line_number':88,'multiline':False]
['text':' factory functions','line_number':123,'multiline':False]
['text':' methods','line_number':137,'multiline':False]
['text':' An Interpreter is alive if we are currently inside the ongoing transform','line_number':158,'multiline':False]
['text':' for the interpreter. For example, vmap(f)(x); inside of f, the vmap's','line_number':159,'multiline':False]
['text':' corresponding Interpreter is alive, even when it is not on the DynamicLayerStack.','line_number':160,'multiline':False]
['text':' Please don't use this','line_number':171,'multiline':False]
['text':' fields','line_number':178,'multiline':False]
['text':' Applies the following for-loop:','line_number':186,'multiline':False]
['text':' for i in range(begin, end):','line_number':187,'multiline':False]
['text':'   args[i] = func(args[i])','line_number':188,'multiline':False]
['text':' Applies the following for-loop:','line_number':192,'multiline':False]
['text':' for i in range(begin, end):','line_number':193,'multiline':False]
['text':'   if use_flag_relative[i] == 1: <-- treats use_flag_relative as a bitset','line_number':194,'multiline':False]
['text':'     args[i] = func(args[i], i - begin, true)','line_number':195,'multiline':False]
['text':'   args[i] = func(args[i], i - begin)','line_number':196,'multiline':False]
['text':' namespace at::functorch','line_number':208,'multiline':False]
