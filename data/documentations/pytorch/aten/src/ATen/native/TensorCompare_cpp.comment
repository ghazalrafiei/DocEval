['text':' Bail out for dtypes unsupported by the sorting algorithm to keep the interface consistent.','line_number':79,'multiline':False]
['text':'Manual type promotion, since scalars have to participate in it','line_number':94,'multiline':False]
['text':'Floating is the highest supported','line_number':97,'multiline':False]
['text':'disallow type promoting inplace op','line_number':109,'multiline':False]
['text':'make sure scalars weren't complex','line_number':115,'multiline':False]
['text':'we could wrap max into tensor and send to tensor overload,','line_number':149,'multiline':False]
['text':'but relu is implemented via clamp_min, so for perf an uniformity reasons','line_number':150,'multiline':False]
['text':'do a faster but correct thing','line_number':151,'multiline':False]
['text':'Floating is the highest supported','line_number':155,'multiline':False]
['text':'Floating is the highest supported','line_number':183,'multiline':False]
['text':'assume_unique','line_number':204,'multiline':True]
['text':'invert','line_number':204,'multiline':True]
['text':'assume_unique','line_number':212,'multiline':True]
['text':'invert','line_number':212,'multiline':True]
['text':'assume_unique','line_number':220,'multiline':True]
['text':'invert','line_number':220,'multiline':True]
['text':' namespace meta','line_number':264,'multiline':False]
['text':' NOLINT(cppcoreguidelines-avoid-non-const-global-variables)','line_number':268,'multiline':False]
['text':' NOLINT(cppcoreguidelines-avoid-non-const-global-variables)','line_number':269,'multiline':False]
['text':' NOLINT(cppcoreguidelines-avoid-non-const-global-variables)','line_number':270,'multiline':False]
['text':' NOLINT(cppcoreguidelines-avoid-non-const-global-variables)','line_number':271,'multiline':False]
['text':' NOLINT(cppcoreguidelines-avoid-non-const-global-variables)','line_number':272,'multiline':False]
['text':' NOLINT(cppcoreguidelines-avoid-non-const-global-variables)','line_number':273,'multiline':False]
['text':' NOLINT(cppcoreguidelines-avoid-non-const-global-variables)','line_number':274,'multiline':False]
['text':' NOLINT(cppcoreguidelines-avoid-non-const-global-variables)','line_number':275,'multiline':False]
['text':' NOLINT(cppcoreguidelines-avoid-non-const-global-variables)','line_number':276,'multiline':False]
['text':' NOLINT(cppcoreguidelines-avoid-non-const-global-variables)','line_number':277,'multiline':False]
['text':' NOLINT(cppcoreguidelines-avoid-non-const-global-variables)','line_number':278,'multiline':False]
['text':' Note [closeness]','line_number':284,'multiline':False]
['text':' A number A is close to B when either:','line_number':285,'multiline':False]
['text':'','line_number':286,'multiline':False]
['text':' (1) A is equal to B, with NaNs comparing equal when equal_nan is true.','line_number':287,'multiline':False]
['text':' (2) The error abs(A - B) is finite and less than the max error','line_number':288,'multiline':False]
['text':'      (atol + abs(rtol * B)).','line_number':289,'multiline':False]
['text':'','line_number':290,'multiline':False]
['text':' Note that this is consistent with NumPy's isclose but divergent from','line_number':291,'multiline':False]
['text':' Python's isclose, which computes the max error symmetrically as','line_number':292,'multiline':False]
['text':' max(rtol * max(abs(A), abs(B)), atol).','line_number':293,'multiline':False]
['text':' TODO: use bitwise operator overloads once we add them','line_number':294,'multiline':False]
['text':' TODO: revisit complex inputs and equal_nan=true after','line_number':295,'multiline':False]
['text':'  https://github.com/numpy/numpy/issues/15959 is resolved','line_number':296,'multiline':False]
['text':' Checks that rtol and atol are non-negative','line_number':302,'multiline':False]
['text':' Note: consistent with Python's isclose but divergent from NumPy's, which','line_number':303,'multiline':False]
['text':'  allows negative atol and rtol.','line_number':304,'multiline':False]
['text':' Computes equality closeness','line_number':308,'multiline':False]
['text':' For CompositeCompliance, if `other` is a CCT and `self` is a regular Tensor,','line_number':311,'multiline':False]
['text':' then we can't perform inplace op into `self` with `other`.','line_number':312,'multiline':False]
['text':' NOTE: Inplacing into `close` is fine because it is generated from','line_number':313,'multiline':False]
['text':' out-of-place with args `self` and `other`. So if either of them is','line_number':314,'multiline':False]
['text':' a CCT then `close` will also be a `CCT`.','line_number':315,'multiline':False]
['text':' In case of zero tolerances the closeness inequality degenerates to an equality check.','line_number':323,'multiline':False]
['text':' In this case, the short-circuit prevents false positives as detailed in the paragraph below.','line_number':324,'multiline':False]
['text':' Note [closeness error computation]','line_number':329,'multiline':False]
['text':' atol and rtol are provided as doubles, so the computation','line_number':330,'multiline':False]
['text':' rtol * other will produce a float or complex tensor.','line_number':331,'multiline':False]
['text':' When the difference (self - other) is compared to it then the','line_number':332,'multiline':False]
['text':' tensor representing the difference will also be cast to float or complex.','line_number':333,'multiline':False]
['text':' However, since (self - other) in uint8 is very likely to produce a','line_number':334,'multiline':False]
['text':' negative value, this moves the cast forward so the difference is','line_number':335,'multiline':False]
['text':' always computed in a float or complex type.','line_number':336,'multiline':False]
['text':' If the values of the integer tensors cannot be exactly represented','line_number':337,'multiline':False]
['text':' by the default scalar type then this may cause an incorrect result.','line_number':338,'multiline':False]
['text':' Computes allowed and actual error','line_number':340,'multiline':False]
['text':'includeBool=','line_number':343,'multiline':True]
['text':' Computes finite closeness','line_number':352,'multiline':False]
['text':' Note: Integral and Floating tensor values are always real','line_number':363,'multiline':False]
['text':'includeBool=','line_number':364,'multiline':True]
['text':' Note: Integral tensor values are never infinite','line_number':385,'multiline':False]
['text':'includeBool=','line_number':386,'multiline':True]
['text':' Note: a complex value is infinite when either part is infinite','line_number':390,'multiline':False]
['text':' Note: Integral tensor values are always finite','line_number':402,'multiline':False]
['text':'includeBool=','line_number':403,'multiline':True]
['text':' Note: a complex value is finite iff both parts are finite','line_number':407,'multiline':False]
['text':' Sorting-based algorithm for isin(); used when the number of test elements is large.','line_number':434,'multiline':False]
['text':' 1. Concatenate unique elements with unique test elements in 1D form. If','line_number':441,'multiline':False]
['text':'    assume_unique is true, skip calls to unique().','line_number':442,'multiline':False]
['text':'sorted=','line_number':449,'multiline':True]
['text':'return_inverse=','line_number':449,'multiline':True]
['text':'sorted=','line_number':450,'multiline':True]
['text':' 2. Stable sort all elements, maintaining order indices to reverse the','line_number':453,'multiline':False]
['text':'    operation. Stable sort is necessary to keep elements before test','line_number':454,'multiline':False]
['text':'    elements within the sorted list.','line_number':455,'multiline':False]
['text':'stable=','line_number':459,'multiline':True]
['text':'dim=','line_number':459,'multiline':True]
['text':'descending=','line_number':459,'multiline':True]
['text':' 3. Create a mask for locations of adjacent duplicate values within the','line_number':461,'multiline':False]
['text':'    sorted list. Duplicate values are in both elements and test elements.','line_number':462,'multiline':False]
['text':' 4. Reorder the mask to match the pre-sorted element order.','line_number':470,'multiline':False]
['text':' 5. Index the mask to match the pre-unique element order. If','line_number':474,'multiline':False]
['text':'    assume_unique is true, just take the first N items of the mask,','line_number':475,'multiline':False]
['text':'    where N is the original number of elements.','line_number':476,'multiline':False]
['text':' allow CPU scalars on non-cpu device','line_number':507,'multiline':False]
['text':' if there's still a device mismatch, let tensoriterator error out with it','line_number':524,'multiline':False]
['text':' TODO: qscheme','line_number':660,'multiline':False]
['text':' DEPRECATED: Use at::aminmax instead','line_number':675,'multiline':False]
['text':'self','line_number':684,'multiline':True]
['text':'TODO this is not great, building TI again is expensive, but I can't use','line_number':718,'multiline':False]
['text':'fill_stub because fill is not structured','line_number':719,'multiline':False]
['text':'this is a corner case anyway','line_number':720,'multiline':False]
['text':' Implements the "clip" alias for clamp','line_number':746,'multiline':False]
['text':' Named tensor overloads','line_number':771,'multiline':False]
['text':'self','line_number':785,'multiline':True]
['text':'dim','line_number':785,'multiline':True]
['text':'keepdim','line_number':785,'multiline':True]
['text':'self','line_number':788,'multiline':True]
['text':'dim','line_number':788,'multiline':True]
['text':'keepdim','line_number':788,'multiline':True]
['text':'self','line_number':791,'multiline':True]
['text':'dim','line_number':791,'multiline':True]
['text':'keepdim','line_number':791,'multiline':True]
['text':' Heuristic taken from numpy's implementation.','line_number':808,'multiline':False]
['text':' See https://github.com/numpy/numpy/blob/fb215c76967739268de71aa4bda55dd1b062bc2e/numpy/lib/arraysetops.py#L575','line_number':809,'multiline':False]
['text':' redispatch to eq / ne','line_number':822,'multiline':False]
['text':' redispatch','line_number':833,'multiline':False]
['text':'includeBool=','line_number':839,'multiline':True]
['text':'includeBool=','line_number':847,'multiline':True]
['text':' namespace native','line_number':854,'multiline':False]
['text':' namespace at','line_number':855,'multiline':False]
