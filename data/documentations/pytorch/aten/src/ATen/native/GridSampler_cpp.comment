['text':' See NOTE [ grid_sampler Native Functions ].','line_number':45,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':46,'multiline':False]
['text':' loop over each output pixel','line_number':81,'multiline':False]
['text':' get the corresponding input x, y, z co-ordinates from grid','line_number':89,'multiline':False]
['text':' get corner pixel values from (x, y, z)','line_number':100,'multiline':False]
['text':' for 4d, we used north-east-south-west','line_number':101,'multiline':False]
['text':' for 5d, we add top-bottom','line_number':102,'multiline':False]
['text':' get surfaces to each neighbor:','line_number':135,'multiline':False]
['text':' calculate bilinear weighted pixel value and set output pixel','line_number':145,'multiline':False]
['text':'   (c, iz_tnw, iy_tnw, ix_tnw) * tnw + (c, iz_tne, iy_tne, ix_tne) * tne','line_number':149,'multiline':False]
['text':' + (c, iz_tsw, iy_tsw, ix_tsw) * tsw + (c, iz_tse, iy_tse, ix_tse) * tse','line_number':150,'multiline':False]
['text':' + (c, iz_bnw, iy_bnw, ix_bnw) * bnw + (c, iz_bne, iy_bne, ix_bne) * bne','line_number':151,'multiline':False]
['text':' + (c, iz_bsw, iy_bsw, ix_bsw) * bsw + (c, iz_bse, iy_bse, ix_bse) * bse','line_number':152,'multiline':False]
['text':' assign nearest neighor pixel value to output pixel','line_number':184,'multiline':False]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':210,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':211,'multiline':False]
['text':' If interpolation mode is Nearest, then grad_grid is not filled in the','line_number':229,'multiline':False]
['text':' loop below.','line_number':230,'multiline':False]
['text':' loop over each output pixel','line_number':279,'multiline':False]
['text':' grad_grid is contiguous ','line_number':287,'multiline':True]
['text':' get the corresponding input x, y, z co-ordinates from grid','line_number':288,'multiline':False]
['text':' multipliers for gradients on ix, iy, and iz','line_number':294,'multiline':False]
['text':' get corner pixel values from (x, y, z)','line_number':301,'multiline':False]
['text':' for 4d, we used north-east-south-west','line_number':302,'multiline':False]
['text':' for 5d, we add top-bottom','line_number':303,'multiline':False]
['text':' get surfaces to each neighbor:','line_number':336,'multiline':False]
['text':' calculate bilinear weighted pixel value and set output pixel','line_number':350,'multiline':False]
['text':' calculate and set grad_input','line_number':354,'multiline':False]
['text':' calculate grad_grid','line_number':365,'multiline':False]
['text':' assuming grad_grid is contiguous','line_number':416,'multiline':False]
['text':' assign nearest neighor pixel value to output pixel','line_number':425,'multiline':False]
['text':' calculate and set grad_input','line_number':430,'multiline':False]
['text':' namespace','line_number':444,'multiline':False]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':452,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':453,'multiline':False]
['text':' Bilinear interpolation is supported using the fact that we can perform
   * linear interpolations on quantized values without rescaling. ','line_number':459,'multiline':True]
['text':' get the corresponding input x, y, z co-ordinates from grid','line_number':499,'multiline':False]
['text':' get corner pixel values from (x, y)','line_number':509,'multiline':False]
['text':' for 4d, we use north-east-south-west','line_number':510,'multiline':False]
['text':' get surfaces to each neighbor:','line_number':523,'multiline':False]
['text':' calculate bilinear weighted pixel value and set output pixel','line_number':529,'multiline':False]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':561,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':562,'multiline':False]
['text':' loop over each output pixel','line_number':595,'multiline':False]
['text':' get the corresponding input x, y, z co-ordinates from grid','line_number':602,'multiline':False]
['text':' get corner pixel values from (x, y)','line_number':611,'multiline':False]
['text':' for 4d, we use north-east-south-west','line_number':612,'multiline':False]
['text':' get surfaces to each neighbor:','line_number':626,'multiline':False]
['text':' calculate bilinear weighted pixel value and set output pixel','line_number':632,'multiline':False]
['text':' assign nearest neighor pixel value to output pixel','line_number':655,'multiline':False]
['text':' grid_sampler_compute_source_index will "clip the value" of idx depends on the padding,','line_number':666,'multiline':False]
['text':' which would cause calculation to be wrong,','line_number':667,'multiline':False]
['text':' for example x = -0.1 -> ix = 0 for zero padding, but in bicubic ix = floor(x) = -1','line_number':668,'multiline':False]
['text':' There would be more problem in reflection padding, since the -1 and +1 direction is not fixed in boundary condition','line_number':669,'multiline':False]
['text':' NOLINTNEXTLINE(modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays)','line_number':682,'multiline':False]
['text':' Interpolate 4 values in the x directon','line_number':685,'multiline':False]
['text':' Interpolate in the y direction','line_number':695,'multiline':False]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':717,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':718,'multiline':False]
['text':' If interpolation mode is Nearest, then grad_grid is not filled in the','line_number':732,'multiline':False]
['text':' loop below.','line_number':733,'multiline':False]
['text':' loop over each output pixel','line_number':766,'multiline':False]
['text':' grad_grid is contiguous ','line_number':773,'multiline':True]
['text':' get the corresponding input x, y co-ordinates from grid','line_number':774,'multiline':False]
['text':' multipliers for gradients on ix, iy','line_number':779,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':780,'multiline':False]
['text':' get corner pixel values from (x, y)','line_number':786,'multiline':False]
['text':' for 4d, we use north-east-south-west','line_number':787,'multiline':False]
['text':' get surfaces to each neighbor:','line_number':800,'multiline':False]
['text':' calculate bilinear weighted pixel value and set output pixel','line_number':810,'multiline':False]
['text':' calculate and set grad_input','line_number':814,'multiline':False]
['text':' calculate grad_grid','line_number':820,'multiline':False]
['text':' assuming grad_grid is contiguous','line_number':843,'multiline':False]
['text':' assign nearest neighor pixel value to output pixel','line_number':850,'multiline':False]
['text':' calculate and set grad_input','line_number':854,'multiline':False]
['text':' NOLINTNEXTLINE(modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays)','line_number':869,'multiline':False]
['text':' NOLINTNEXTLINE(modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays)','line_number':871,'multiline':False]
['text':' NOLINTNEXTLINE(modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays)','line_number':873,'multiline':False]
['text':' NOLINTNEXTLINE(modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays)','line_number':875,'multiline':False]
['text':' set input gradient','line_number':896,'multiline':False]
['text':' set grid gradient','line_number':900,'multiline':False]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':922,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':923,'multiline':False]
['text':' AVX gather instructions use signed 32-bit offsets to gather float values.','line_number':931,'multiline':False]
['text':' Check for possible overflow and fallback to scalar implementation','line_number':932,'multiline':False]
['text':' NOTE: Gather offsets are only used for the input H, W dimensions','line_number':939,'multiline':False]
['text':'       or only for strided access to the grid tensor','line_number':940,'multiline':False]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':966,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':967,'multiline':False]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':982,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':983,'multiline':False]
['text':' AVX gather instructions use signed 32-bit offsets to gather float values.','line_number':987,'multiline':False]
['text':' Check for possible overflow and fallback to scalar implementation','line_number':988,'multiline':False]
['text':' NOTE: Gather offsets are only used for the height and width dimensions','line_number':997,'multiline':False]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':1031,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':1032,'multiline':False]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':1045,'multiline':False]
['text':' namespace at::native','line_number':1071,'multiline':False]
