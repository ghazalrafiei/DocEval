['text':' Note on naming: it is unconventional.','line_number':16,'multiline':False]
['text':' grad_in does not mean that it is a gradient wrt to input,','line_number':17,'multiline':False]
['text':' grad_in/grad_out is just an input/output of unfold_backward kernel.','line_number':18,'multiline':False]
['text':'','line_number':19,'multiline':False]
['text':' unfold_backward, the algorithm.','line_number':20,'multiline':False]
['text':'','line_number':21,'multiline':False]
['text':' Consider out = in.unfold(dim, size, step), then','line_number':22,'multiline':False]
['text':' out.shape[dim] == (in.shape[dim] - size) / step + 1,','line_number':23,'multiline':False]
['text':' out.shape[-1] == size.','line_number':24,'multiline':False]
['text':' out.dims() == in.dims() + 1','line_number':25,'multiline':False]
['text':'','line_number':26,'multiline':False]
['text':' unfold_backward receives grad_in and returns grad_out such that','line_number':27,'multiline':False]
['text':' grad_in.shape == out.shape,','line_number':28,'multiline':False]
['text':' grad_out.shape = in.shape.','line_number':29,'multiline':False]
['text':'','line_number':30,'multiline':False]
['text':' unfold_backward considers the following two cases:','line_number':31,'multiline':False]
['text':' case1. step >= size.','line_number':32,'multiline':False]
['text':' case2. step < size.','line_number':33,'multiline':False]
['text':'','line_number':34,'multiline':False]
['text':' case1. step >= size.','line_number':35,'multiline':False]
['text':' In this case the iteration takes over grad_in and performs the following copy:','line_number':36,'multiline':False]
['text':' grad_out[..., i_out_dim,...] = grad_in[..., i_in_dim,..., i_in_last_dim],','line_number':37,'multiline':False]
['text':' where i_out_dim = i_in_dim * step + i_in_last_dim.','line_number':38,'multiline':False]
['text':'','line_number':39,'multiline':False]
['text':' case2. step < size.','line_number':40,'multiline':False]
['text':' In this case the iteration takes over grad_out,','line_number':41,'multiline':False]
['text':' where grad_out[...,i_out_dim,...] accumulates all values','line_number':42,'multiline':False]
['text':' grad_in[...,i_in_dim,...,i_in_last_dim], where','line_number':43,'multiline':False]
['text':' i_in_dim is in [left_idx_fold, right_idx_fold],','line_number':44,'multiline':False]
['text':' i_in_last_dim = i_out_dim - i_in_dim * step,','line_number':45,'multiline':False]
['text':' left_idx_fold = (i_out_dim - size) / step','line_number':46,'multiline':False]
['text':'  if i_out_dim in [left_idx_fold * step, left_idx_fold * step + size)','line_number':47,'multiline':False]
['text':'  else (i_out_dim - size) / step + 1,','line_number':48,'multiline':False]
['text':' right_idx_fold = i_out_dim / step.','line_number':49,'multiline':False]
['text':'','line_number':50,'multiline':False]
['text':' Simply put, given i_out_dim, we find which folds of grad_in','line_number':51,'multiline':False]
['text':' intersect with i_out_dim, these are precisely [left_idx_fold, right_idx_fold],','line_number':52,'multiline':False]
['text':' and then the corresponding value of grad_in[...,i_in_dim,...,i_in_last_dim]','line_number':53,'multiline':False]
['text':' gets added up to grad_out[...,i_out_dim,...].','line_number':54,'multiline':False]
['text':' left_fold potentially intersecting with idx_dim','line_number':85,'multiline':False]
['text':' is either (idx_dim - size) / step or the next integer.','line_number':86,'multiline':False]
['text':' last dim stores the folds','line_number':119,'multiline':False]
['text':' namespace at::native','line_number':152,'multiline':False]
