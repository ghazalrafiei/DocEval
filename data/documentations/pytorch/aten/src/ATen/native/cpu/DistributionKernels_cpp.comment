['text':' See Note [Acquire lock when using random generators]','line_number':53,'multiline':False]
['text':' vectorized copy if using buffer and contiguous, i.e., being non-int','line_number':82,'multiline':False]
['text':' type and contiguous','line_number':83,'multiline':False]
['text':' grain_size= ','line_number':92,'multiline':True]
['text':' copy_ if using buffer and non contiguous','line_number':94,'multiline':False]
['text':' See Note [Acquire lock when using random generators]','line_number':120,'multiline':False]
['text':' Intel MKL vRngExponential variate originally does not exclude 0.','line_number':145,'multiline':False]
['text':' However, to align with pytorch exponential variate definition which excludes 0,','line_number':146,'multiline':False]
['text':' we shift the MKL vRngExponential distribution location by adding a very small constant, eps.','line_number':147,'multiline':False]
['text':' If X ~ Exp(lambda), then E(X) = 1/lambda, and V(X) = 1/lambda**2.','line_number':148,'multiline':False]
['text':' If Y = X + eps, where eps ~= 0, then E(Y) = (1/lambda) + eps, and V(Y) = 1/lambda**2.','line_number':149,'multiline':False]
['text':' If eps is very small, the two distributions are indistinguishable, and are almost identical.','line_number':150,'multiline':False]
['text':' The detail of location-shifted MKL vRngExponential is as follows.','line_number':151,'multiline':False]
['text':' PDF:         f(x) = lambda * exp( -lambda * (x - eps) )','line_number':152,'multiline':False]
['text':' CDF:         F(x) = 1 - exp( -lambda * (x - eps) )','line_number':153,'multiline':False]
['text':' Mean:        E[X+eps] = (1/lambda) + eps','line_number':154,'multiline':False]
['text':' Variance:    V[X+eps] = 1/lambda**2','line_number':155,'multiline':False]
['text':' vectorized copy if using buffer and contiguous','line_number':175,'multiline':False]
['text':' grain_size= ','line_number':184,'multiline':True]
['text':' copy_ if using buffer and non contiguous','line_number':186,'multiline':False]
['text':' The situation of inf and nan, move to using the default version','line_number':192,'multiline':False]
['text':' This is the special kernel to handle single specific case:','line_number':228,'multiline':False]
['text':' from(inclusive) = std::numeric_limits<int64_t>::lowest()','line_number':229,'multiline':False]
['text':' to(exclusive) = None (= std::numeric_limits<int64_t>::max() + 1)','line_number':230,'multiline':False]
['text':' namespace (anonymous)','line_number':236,'multiline':False]
['text':' namespace at::native','line_number':250,'multiline':False]
