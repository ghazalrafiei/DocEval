['text':'
The Python Imaging Library (PIL) is

    Copyright © 1997-2011 by Secret Labs AB
    Copyright © 1995-2011 by Fredrik Lundh

Pillow is the friendly PIL fork. It is

    Copyright © 2010-2022 by Alex Clark and contributors

Like PIL, Pillow is licensed under the open source HPND License
','line_number':1,'multiline':True]
['text':' This code is heavily inspired from PILLOW-SIMD's implementation:','line_number':14,'multiline':False]
['text':' https://github.com/uploadcare/pillow-simd/blob/simd/master/src/libImaging/Resample.c','line_number':15,'multiline':False]
['text':' TODO: This file only supports AVX2. We could split the AVX kernels into','line_number':19,'multiline':False]
['text':' smaller logical blocks in order to port them into the Vec.h logic. This would','line_number':20,'multiline':False]
['text':' allow to support other vectorization architectures and perhaps also support','line_number':21,'multiline':False]
['text':' the non-vectorized fallback (we'd need to make sure it's not slower than the','line_number':22,'multiline':False]
['text':' current fallback).','line_number':23,'multiline':False]
['text':' data is (R G B X), output is (X1 X2 X3 | R1 B1 G1 R2 ...)','line_number':56,'multiline':False]
['text':' Here we explicitly set X as R1','line_number':57,'multiline':False]
['text':' Convert a "packed" tensor (typically RGBRGBRGB if channels_last) into','line_number':64,'multiline':False]
['text':' RGBARGBARGBA format where A is hard-coded to 0. Each pixel is encoded','line_number':65,'multiline':False]
['text':' into as 32 bits. This generalizes to num_channels <= 4 and also works for','line_number':66,'multiline':False]
['text':' non-channels_last tensors.','line_number':67,'multiline':False]
['text':' IN','line_number':89,'multiline':False]
['text':' OUT','line_number':90,'multiline':False]
['text':' Convert from unpacked channels last 3-channels or 4-channels tensor into original data layout.','line_number':92,'multiline':False]
['text':' Interpolation horizontal pass: we compute x-axis (image width) interpolation outputs.','line_number':164,'multiline':False]
['text':' Input data is stored as','line_number':166,'multiline':False]
['text':'   input = [r[0], g[0], b[0], a[0], r[1], g[1], b[1], a[1], r[2], g[2], b[2], a[2], ...]','line_number':167,'multiline':False]
['text':' Weights are float values computed for each output pixel and rescaled to uint16:','line_number':168,'multiline':False]
['text':'   weights[i] = [w[i, 0], w[i, 1], ..., w[i, K-1]]','line_number':169,'multiline':False]
['text':' We want to compute the output as following:','line_number':170,'multiline':False]
['text':'   output = [oR[0], oG[0], oB[0], oA[0], oR[1], oG[1], oB[1], oA[1], ...]','line_number':171,'multiline':False]
['text':' where','line_number':172,'multiline':False]
['text':'   oR[yoffset + i] = r[yoffset + xmin[i]] * w[i, 0] + ... + r[yoffset + xmin[i] + K-1] * w[i, K-1]','line_number':173,'multiline':False]
['text':'   oG[yoffset + i] = g[yoffset + xmin[i]] * w[i, 0] + ... + g[yoffset + xmin[i] + K-1] * w[i, K-1]','line_number':174,'multiline':False]
['text':'   oB[yoffset + i] = b[yoffset + xmin[i]] * w[i, 0] + ... + b[yoffset + xmin[i] + K-1] * w[i, K-1]','line_number':175,'multiline':False]
['text':'','line_number':176,'multiline':False]
['text':' TODO: we may want to merge that into the fallback code (currently called','line_number':178,'multiline':False]
['text':' basic_loop_aa_horizontal<uint8_t>)','line_number':179,'multiline':False]
['text':' Although this may not be needed if / when we port all this code to use','line_number':180,'multiline':False]
['text':' Vec.h since this would potentially give us another fall-back implem','line_number':181,'multiline':False]
['text':' Interpolation vertical pass: we compute y-axis interpolation outputs.','line_number':242,'multiline':False]
['text':' Input data is stored as','line_number':243,'multiline':False]
['text':'   input = [r[0], g[0], b[0], a[0], r[1], g[1], b[1], a[1], r[2], g[2], b[2], a[2], ...]','line_number':244,'multiline':False]
['text':' Weights are float values computed for each output pixel and rescaled to uint16:','line_number':245,'multiline':False]
['text':'   weights[i] = [w[i, 0], w[i, 1], ..., w[i, K-1]]','line_number':246,'multiline':False]
['text':' We want to compute the output as following:','line_number':247,'multiline':False]
['text':'   output = [oR[0], oG[0], oB[0], oA[0], oR[1], oG[1], oB[1], oA[1], ...]','line_number':248,'multiline':False]
['text':' where','line_number':249,'multiline':False]
['text':'   oR[xoffset + i] = r[xoffset + ymin[i]] * w[i, 0] + ... + r[xoffset + ymin[i] + (K-1) * xsize] * w[i, K-1]','line_number':250,'multiline':False]
['text':'   oG[xoffset + i] = g[xoffset + ymin[i]] * w[i, 0] + ... + g[xoffset + ymin[i] + (K-1) * xsize] * w[i, K-1]','line_number':251,'multiline':False]
['text':'   oB[xoffset + i] = b[xoffset + ymin[i]] * w[i, 0] + ... + b[xoffset + ymin[i] + (K-1) * xsize] * w[i, K-1]','line_number':252,'multiline':False]
['text':' TODO: we may want to merge that into the fallback code (currently called','line_number':254,'multiline':False]
['text':' basic_loop_aa_vertical<uint8_t>)','line_number':255,'multiline':False]
['text':' Although this may not be needed if / when we port all this code to use','line_number':256,'multiline':False]
['text':' Vec.h since this would potentially give us another fall-back implem','line_number':257,'multiline':False]
['text':' This is the only public entry point in this file.  It supports bilinear or bicubic','line_number':288,'multiline':False]
['text':' mode for uint8 dtype when C <= 4, with or without antialias. The','line_number':289,'multiline':False]
['text':' implem is based on PIL-SIMD.','line_number':290,'multiline':False]
['text':' Its equivalent implementation (fallback) for when AVX isn't supported or when','line_number':291,'multiline':False]
['text':' C > 4 is separable_upsample_generic_Nd_kernel_impl()  There are a bunch of','line_number':292,'multiline':False]
['text':' future improvement that can be done: look for the TODOs in this file.','line_number':293,'multiline':False]
['text':' For details on how the weights are computed and how the multiplications are','line_number':294,'multiline':False]
['text':' run on int (instead of float weights), see','line_number':295,'multiline':False]
['text':' [ Weights computation for uint8_t and multiplication trick ]','line_number':296,'multiline':False]
['text':' For details on how the AVX kernels are implemented, see','line_number':297,'multiline':False]
['text':' https://gist.github.com/NicolasHug/47c97d731f05eaad5694c173849b86f5','line_number':298,'multiline':False]
['text':' See also [ Support for antialias=False as a subcase of antilias=True ] to','line_number':299,'multiline':False]
['text':' learn more about how the antialias=False case is computed. The same holds','line_number':300,'multiline':False]
['text':' here: all these kernels are general enough to handle an arbitrary number of','line_number':301,'multiline':False]
['text':' weights, but when aa=False they could be optimized further.','line_number':302,'multiline':False]
['text':' If input is not contiguous with memory format channels first or channels last,','line_number':324,'multiline':False]
['text':' we explicitly convert the input to contiguous channels last memory format.','line_number':325,'multiline':False]
['text':' This simplifies the rest of the code and let us assume that the format is only contiguous channels first or channels last,','line_number':326,'multiline':False]
['text':' Most tensors going through this `if` block won't need to go through unpacking, but those having C < 3 may','line_number':327,'multiline':False]
['text':' have to (this means 2 copies are made). We could avoid the extra copy by handling non-contiguous input','line_number':328,'multiline':False]
['text':' directly within unpack_rgb() and pack_rgb(), but initial attempts showed that this is fairly complex.','line_number':329,'multiline':False]
['text':'input_size=','line_number':348,'multiline':True]
['text':'output_size=','line_number':349,'multiline':True]
['text':'stride=','line_number':350,'multiline':True]
['text':'ndims=','line_number':351,'multiline':True]
['text':'reshape_dim=','line_number':352,'multiline':True]
['text':'align_corners=','line_number':353,'multiline':True]
['text':'opt_scale=','line_number':354,'multiline':True]
['text':'antialias=','line_number':355,'multiline':True]
['text':'align_i32=','line_number':356,'multiline':True]
['text':'input_size=','line_number':364,'multiline':True]
['text':'output_size=','line_number':365,'multiline':True]
['text':'stride=','line_number':366,'multiline':True]
['text':'ndims=','line_number':367,'multiline':True]
['text':'reshape_dim=','line_number':368,'multiline':True]
['text':'align_corners=','line_number':369,'multiline':True]
['text':'opt_scale=','line_number':370,'multiline':True]
['text':'antialias=','line_number':371,'multiline':True]
['text':'align_i32=','line_number':372,'multiline':True]
['text':' Minor optimization: we can avoid allocating an extra buffer if we're performing','line_number':376,'multiline':False]
['text':' horizontal-only or vertical-only interpolation, and if the tensor doesn't','line_number':377,'multiline':False]
['text':' need repacking','line_number':378,'multiline':False]
['text':' Interpolation horizontal pass processing together 4 vertical lines.','line_number':452,'multiline':False]
['text':' - Input data format is RGBA or RGB with R,G,B,A being uint8. In case of RGBA','line_number':453,'multiline':False]
['text':'   we can encode 4 values as a single uint32 value.','line_number':454,'multiline':False]
['text':' - We split the size of weight vector for a given output index as a sum:','line_number':455,'multiline':False]
['text':'   ids_size = num_blocks_4 * 4 + num_blocks_2 * 2 + num_blocks_1.','line_number':456,'multiline':False]
['text':' - We load and process 4 weights values in a loop ("block 4") then we process 2 weights values','line_number':457,'multiline':False]
['text':' in another loop ("block 2") and finally we process 1 weights value in the final loop ("block 1").','line_number':458,'multiline':False]
['text':' Define shuffling masks (low/high) for num_channels 4 and 3','line_number':460,'multiline':False]
['text':' Mask low casts lower half of each lane to epi16 and reorder RGBARGBA -> RRGGBBAA:','line_number':461,'multiline':False]
['text':'   [r1 g1 b1 a1  r2 g2 b2 a2  ... | R1 G1 B1 A1  R2 G2 B2 A2 ... ] ->','line_number':462,'multiline':False]
['text':'   [r1 0 r2 0  g1 0 g2 0  b1 0 b2 0  a1 0 a2 0 | R1 0 R2 0  G1 0 G2 0  B1 0 B2 0  A1 0 A2 0]','line_number':463,'multiline':False]
['text':' Mask high casts upper half of each lane to epi16 and reorder RGBARGBA -> RRGGBBAA::','line_number':464,'multiline':False]
['text':'   [ ... r3 g3 b3 a3  r4 g4 b4 a4 | ... R3 G3 B3 A3  R4 G4 B4 A4 ] ->','line_number':465,'multiline':False]
['text':'   [r3 0 r4 0  g3 0 g4 0  b3 0 b4 0  a3 0 a4 0 | R3 0 R4 0  G3 0 G4 0  B3 0 B4 0  A3 0 A4 0]','line_number':466,'multiline':False]
['text':' out_xsize = output width, out_x = output x index','line_number':488,'multiline':False]
['text':' ids_min is the input offset index corresponding to out_x','line_number':489,'multiline':False]
['text':' ids_size is the interpolation size for out_x','line_number':490,'multiline':False]
['text':' Let's precompute ids_size limits for block 4 and block 2.','line_number':492,'multiline':False]
['text':'','line_number':493,'multiline':False]
['text':' In block 4 (4 means we process 4 weight values together), we read input data','line_number':494,'multiline':False]
['text':' with _mm_loadu_si128, i.e. 16 bytes, per one line:','line_number':495,'multiline':False]
['text':' lineIn0 + stride * (i + ids_min) + 16 <= lineIn0 + stride * (ids_size + ids_min)','line_number':496,'multiline':False]
['text':' --> i <= ids_size - 16.0 / stride','line_number':497,'multiline':False]
['text':' Strict boundary:','line_number':498,'multiline':False]
['text':' --> i < ids_size + 1 - int(ceil(16.0 / stride)) = ids_size - b4_delta','line_number':499,'multiline':False]
['text':' Soft boundary for reading inside the buffer except its boundaries:','line_number':500,'multiline':False]
['text':' --> i < ids_size + 1 - int(16.0 / stride) = ids_size - b4_delta_soft','line_number':501,'multiline':False]
['text':' RGBA: b4_delta = b4_delta_soft = 3','line_number':502,'multiline':False]
['text':' RGB : b4_delta = 5','line_number':503,'multiline':False]
['text':' RGB : b4_delta_soft = 4','line_number':504,'multiline':False]
['text':' In block 2 (2 means we process 2 weights values together), we read input data','line_number':507,'multiline':False]
['text':' with _mm_loadl_epi64, i.e. 8 bytes, per one line:','line_number':508,'multiline':False]
['text':' lineIn0 + stride * (i + ids_min) + 8 <= lineIn0 + stride * (ids_size + ids_min)','line_number':509,'multiline':False]
['text':' --> i <= ids_size - 8.0 / stride','line_number':510,'multiline':False]
['text':' Strict boundary:','line_number':511,'multiline':False]
['text':' --> i < ids_size + 1 - int(ceil(8.0 / stride)) = ids_size - b2_delta','line_number':512,'multiline':False]
['text':' Soft boundary for reading inside the buffer except its boundaries:','line_number':513,'multiline':False]
['text':' --> i < ids_size + 1 - int(8.0 / stride) = ids_size - b2_delta_soft','line_number':514,'multiline':False]
['text':' RGBA: b2_delta = b2_delta_soft = 1','line_number':515,'multiline':False]
['text':' RGB : b2_delta = 2','line_number':516,'multiline':False]
['text':' RGB : b2_delta_soft = 1','line_number':517,'multiline':False]
['text':' block 4','line_number':540,'multiline':False]
['text':' Load 4 values from weight vector','line_number':542,'multiline':False]
['text':' mmk0 = [wl_0 wh_0 wl_1 wh_1  wl_0 wh_0 wl_1 wh_1  ...]','line_number':543,'multiline':False]
['text':' mmk1 = [wl_2 wh_2 wl_3 wh_3  wl_2 wh_2 wl_3 wh_3  ...]','line_number':544,'multiline':False]
['text':' RGBA: Load 8 pixels (4 per line) from input lines 0 and 1:','line_number':548,'multiline':False]
['text':' source = [','line_number':549,'multiline':False]
['text':'   r0 g0 b0 a0  r1 g1 b1 a1  r2 g2 b2 a2  r3 g3 b3 a3','line_number':550,'multiline':False]
['text':'   R0 G0 B0 A0  R1 G1 B1 A1  R2 G2 B2 A2  R3 G3 B3 A3','line_number':551,'multiline':False]
['text':' ]','line_number':552,'multiline':False]
['text':' RGB: Load 10 pixels (5 per line)','line_number':553,'multiline':False]
['text':' source = [','line_number':554,'multiline':False]
['text':'   r0 g0 b0 r1  g1 b1 r2 g2  b2 r3 g3 b3  r4 g4 b4 r5','line_number':555,'multiline':False]
['text':'   R0 G0 B0 R1  G1 B1 R2 G2  B2 R3 G3 B3  R4 G4 B4 R5','line_number':556,'multiline':False]
['text':' ]','line_number':557,'multiline':False]
['text':' Apply mask_low:','line_number':562,'multiline':False]
['text':' RGBA:','line_number':563,'multiline':False]
['text':'   [r0 0 r1 0  g0 0 g1 0  b0 0 b1 0  a0 0 a1 0 | R0 0 R1 0  G0 0 G1 0  B0 0 B1 0  A0 0 A1 0]','line_number':564,'multiline':False]
['text':' RGB:','line_number':565,'multiline':False]
['text':'   [r0 0 r1 0  g0 0 g1 0  b0 0 b1 0  0 0 0 0 | R0 0 R1 0  G0 0 G1 0  B0 0 B1 0  0 0 0 0]','line_number':566,'multiline':False]
['text':' Compute output value as C += w0 * C0 + w1 * C1 for each channel in 32-bit precision','line_number':568,'multiline':False]
['text':' Apply mask_high:','line_number':571,'multiline':False]
['text':' RGBA:','line_number':572,'multiline':False]
['text':'   [r2 0 r3 0  g2 0 g3 0  b2 0 b3 0  a2 0 a3 0 | R2 0 R3 0  G2 0 G3 0  B2 0 B3 0  A2 0 A3 0]','line_number':573,'multiline':False]
['text':' RGB:','line_number':574,'multiline':False]
['text':'   [r2 0 r3 0  g2 0 g3 0  b2 0 b3 0  0 0 0 0 | R2 0 R3 0  G2 0 G3 0  B2 0 B3 0  0 0 0 0]','line_number':575,'multiline':False]
['text':' Compute output value as C += w2 * C2 + w3 * C3 for each channel in 32-bit precision','line_number':577,'multiline':False]
['text':' Same as above to next lines 2 and 3:','line_number':580,'multiline':False]
['text':' block 2','line_number':590,'multiline':False]
['text':' Load 2 values from weight vector','line_number':592,'multiline':False]
['text':' mmk = [wl_0 wh_0 wl_1 wh_1  wl_0 wh_0 wl_1 wh_1  ...]','line_number':593,'multiline':False]
['text':' Load 4 pixels (2 per line) from input lines 0 and 1:','line_number':596,'multiline':False]
['text':' RGBA: source1 = [','line_number':597,'multiline':False]
['text':'   r0 g0 b0 a0  r1 g1 b1 a1  0 0 0 0  0 0 0 0','line_number':598,'multiline':False]
['text':'   R0 G0 B0 A0  R1 G1 B1 A1  0 0 0 0  0 0 0 0','line_number':599,'multiline':False]
['text':' ]','line_number':600,'multiline':False]
['text':' RGB: source1 = [','line_number':601,'multiline':False]
['text':'   r0 g0 b0 r1  g1 b1 r2  0 0 0 0  0 0 0 0','line_number':602,'multiline':False]
['text':'   R0 G0 B0 R1  G1 B1 R2  0 0 0 0  0 0 0 0','line_number':603,'multiline':False]
['text':' ]','line_number':604,'multiline':False]
['text':' Apply mask_low:','line_number':608,'multiline':False]
['text':' RGBA:','line_number':609,'multiline':False]
['text':'   [r0 0 r1 0  g0 0 g1 0  b0 0 b1 0  a0 0 a1 0 | R0 0 R1 0  G0 0 G1 0  B0 0 B1 0  A0 0 A1 0]','line_number':610,'multiline':False]
['text':' RGB:','line_number':611,'multiline':False]
['text':'   [r0 0 r1 0  g0 0 g1 0  b0 0 b1 0  0 0 0 0 | R0 0 R1 0  G0 0 G1 0  B0 0 B1 0  0 0 0 0]','line_number':612,'multiline':False]
['text':' Compute output value as C += w0 * C0 + w1 * C1 for each channel in 32-bit precision','line_number':614,'multiline':False]
['text':' Same as above for lines 2 and 3:','line_number':617,'multiline':False]
['text':' block 1','line_number':625,'multiline':False]
['text':' Load 1 value from weight vector','line_number':628,'multiline':False]
['text':' mmk = [wl_0 wh_0 0 0  wl_0 wh_0 0 0  ...]','line_number':629,'multiline':False]
['text':' Load 2 pixels (one per line) from input lines 0 and 1:','line_number':632,'multiline':False]
['text':' RGBA: pix1 = [','line_number':633,'multiline':False]
['text':'   r0 0 0 0  g0 0 0 0  b0 0 0 0  a0 0 0 0','line_number':634,'multiline':False]
['text':'   R0 0 0 0  G0 0 0 0  B0 0 0 0  A0 0 0 0','line_number':635,'multiline':False]
['text':' ]','line_number':636,'multiline':False]
['text':' RGB: pix1 = [','line_number':637,'multiline':False]
['text':'   r0 0 0 0  g0 0 0 0  b0 0 0 0  r1 0 0 0','line_number':638,'multiline':False]
['text':'   R0 0 0 0  G0 0 0 0  B0 0 0 0  R1 0 0 0','line_number':639,'multiline':False]
['text':' ]','line_number':640,'multiline':False]
['text':' Compute output value as C += w0 * C0 for each channel in 32-bit precision','line_number':644,'multiline':False]
['text':' Same as above for lines 2 and 3','line_number':647,'multiline':False]
['text':' last element','line_number':655,'multiline':False]
['text':' For num_channels == 3 (3 bytes = one pixel) we tolerate to read 4 bytes','line_number':657,'multiline':False]
['text':' lines 0, 1 and 2 wont go out of allocated memory bounds','line_number':658,'multiline':False]
['text':' Convert fixed point values back to integers (truncating)','line_number':677,'multiline':False]
['text':' Convert packed signed 32-bit integers to packed 16-bit integers using signed saturation','line_number':680,'multiline':False]
['text':' (a a a a b b b b c c c c d d d d) -> (a a b b c c d d 0 0 0 0 0 0 0 0)','line_number':681,'multiline':False]
['text':' Convert packed signed 16-bit integers to packed 8-bit integers using unsigned saturation','line_number':684,'multiline':False]
['text':' (a a b b c c d d) -> (a b c d 0 0 0 0)','line_number':685,'multiline':False]
['text':' Write the output into single uint32','line_number':689,'multiline':False]
['text':' (a b c d) -> x_uint32','line_number':690,'multiline':False]
['text':' Memcpy 4-bytes is faster than 3-bytes and this is a boundary case when we want to write','line_number':699,'multiline':False]
['text':' 4 bytes (R G B | X) to the output buffer (X1 X2 X3 | R1).','line_number':700,'multiline':False]
['text':' The 4th byte in the register (X) has a garbage value and 4th byte in the output buffer (R1) has a correct','line_number':701,'multiline':False]
['text':' value which was preveiously computed by another line. In other words, it means that we can not overwrite','line_number':702,'multiline':False]
['text':' it by simply writing 4 bytes from the register to the output. We'll do the following:','line_number':703,'multiline':False]
['text':'               v----------|','line_number':704,'multiline':False]
['text':' Output = [... X1 X2 X3 | R1 G1 B1 R2 ...]','line_number':705,'multiline':False]
['text':' First, we write R1 value to the 4th byte of (R G B | X) -> (R G B | R1)','line_number':706,'multiline':False]
['text':' Second, we write 4 bytes from the register to the output: (X1 X2 X3 | R1) -> (R G B | R1)','line_number':707,'multiline':False]
['text':' Output = [... R G B | R1 G1 B1 R2 ...]','line_number':708,'multiline':False]
['text':' When we handle the last line, we can not access the next 4 bytes','line_number':715,'multiline':False]
['text':' as they are out of memory bounds.','line_number':716,'multiline':False]
['text':' Memcpy 4-bytes is faster than 3-bytes and here','line_number':722,'multiline':False]
['text':' we simply write 4 bytes (... R G B X 0 0 0 0 0 ...) where X is a garbage value','line_number':723,'multiline':False]
['text':' that we will overwrite on the next iteration: (... R G B R G B X 0 0 ...)','line_number':724,'multiline':False]
['text':' num_channels = 4 -> lineOutX + out_x_strided should be uint32 aligned','line_number':730,'multiline':False]
['text':' Interpolation horizontal pass processing only one vertical line.','line_number':752,'multiline':False]
['text':' - Input data format is RGBA or RGB with R,G,B,A being uint8. In case of RGBA','line_number':753,'multiline':False]
['text':'   we can encode 4 values as a single uint32 value.','line_number':754,'multiline':False]
['text':' - We split the size of weight vector for a given output index as a sum:','line_number':755,'multiline':False]
['text':'   ids_size = num_blocks_8 * 8 + num_blocks_4 * 4 + num_blocks_2 * 2 + num_blocks_1','line_number':756,'multiline':False]
['text':' - We load and process 8 weights values in a loop ("block 8") then 4 weights and 2 weights values in','line_number':757,'multiline':False]
['text':' in another loops ("block 4" and "block 2") and finally we process 1 weight value in the final loop ("block 1").','line_number':758,'multiline':False]
['text':' Define various shuffling masks','line_number':760,'multiline':False]
['text':' out_xsize = output width, out_x = output x index','line_number':800,'multiline':False]
['text':' ids_min is the input offset index corresponding to out_x','line_number':801,'multiline':False]
['text':' ids_size is the interpolation size for out_x','line_number':802,'multiline':False]
['text':' Let's precompute ids_size limits for block 8, block 4 and block 2','line_number':809,'multiline':False]
['text':'','line_number':810,'multiline':False]
['text':' In block 8 (8 means we process 8 weight values together), we read at','line_number':811,'multiline':False]
['text':' most 32 bytes input data (16 + 16 bytes for RGBA and 12 + 16 bytes for RGB)','line_number':812,'multiline':False]
['text':' lineIn + stride * (i + ids_min) + 32 <= lineIn + stride * (ids_size + ids_min)','line_number':813,'multiline':False]
['text':' --> i <= ids_size - 32.0 / stride','line_number':814,'multiline':False]
['text':' Strict boundary:','line_number':815,'multiline':False]
['text':' --> i < ids_size + 1 - int(ceil(32.0 / stride)) = ids_size - b8_delta','line_number':816,'multiline':False]
['text':' Soft boundary for reading inside the buffer except its boundaries:','line_number':817,'multiline':False]
['text':' --> i < ids_size + 1 - int(32.0 / stride) = ids_size - b8_delta_soft','line_number':818,'multiline':False]
['text':' RGBA: b8_delta = b8_delta_soft = 7','line_number':819,'multiline':False]
['text':' RGB : b8_delta = 10','line_number':820,'multiline':False]
['text':' RGB : b8_delta_soft = 9','line_number':821,'multiline':False]
['text':' In block 4 (4 means we process 4 weight values together), we read','line_number':824,'multiline':False]
['text':' 16 bytes of input data.','line_number':825,'multiline':False]
['text':' lineIn + stride * (i + ids_min) + 16 <= lineIn0 + stride * (ids_size + ids_min)','line_number':826,'multiline':False]
['text':' --> i <= ids_size - 16.0 / stride','line_number':827,'multiline':False]
['text':' Strict boundary:','line_number':828,'multiline':False]
['text':' --> i < ids_size + 1 - int(ceil(16.0 / stride)) = ids_size - b4_delta','line_number':829,'multiline':False]
['text':' Soft boundary for reading inside the buffer except its boundaries:','line_number':830,'multiline':False]
['text':' --> i < ids_size + 1 - int(16.0 / stride) = ids_size - b4_delta_soft','line_number':831,'multiline':False]
['text':' RGBA: b4_delta = b4_delta_soft = 3','line_number':832,'multiline':False]
['text':' RGB : b4_delta = 5','line_number':833,'multiline':False]
['text':' RGB : b4_delta_soft = 4','line_number':834,'multiline':False]
['text':' In block 2 (2 means we process 2 weight values together), we read','line_number':837,'multiline':False]
['text':' 8 bytes of input data.','line_number':838,'multiline':False]
['text':' lineIn0 + stride * (i + ids_min) + 8 <= lineIn0 + stride * (ids_size + ids_min)','line_number':839,'multiline':False]
['text':' --> i <= ids_size - 8.0 / stride','line_number':840,'multiline':False]
['text':' Strict boundary:','line_number':841,'multiline':False]
['text':' --> i < ids_size + 1 - int(ceil(8.0 / stride)) = ids_size - b2_delta','line_number':842,'multiline':False]
['text':' Soft boundary for reading inside the buffer except its boundaries:','line_number':843,'multiline':False]
['text':' --> i < ids_size + 1 - int(8.0 / stride) = ids_size - b2_delta_soft','line_number':844,'multiline':False]
['text':' RGBA: b2_delta = b2_delta_soft = 1','line_number':845,'multiline':False]
['text':' RGB : b2_delta = 2','line_number':846,'multiline':False]
['text':' RGB : b2_delta_soft = 1','line_number':847,'multiline':False]
['text':' Lower part will be added to higher, use only half of the error','line_number':865,'multiline':False]
['text':' block 8','line_number':868,'multiline':False]
['text':' Load 8 values from weight vector','line_number':870,'multiline':False]
['text':' ksource = [','line_number':872,'multiline':False]
['text':'    wl_0 wh_0 wl_1 wh_1  wl_2 wh_2 wl_3 wh_3  wl_4 wh_4 wl_5 wh_5  wl_6 wh_6 wl_7 wh_7','line_number':873,'multiline':False]
['text':'    wl_0 wh_0 wl_1 wh_1  wl_2 wh_2 wl_3 wh_3  wl_4 wh_4 wl_5 wh_5  wl_6 wh_6 wl_7 wh_7','line_number':874,'multiline':False]
['text':' ]','line_number':875,'multiline':False]
['text':' RGBA: Load 8 pixels from input:','line_number':878,'multiline':False]
['text':' source = [','line_number':879,'multiline':False]
['text':'    r0 g0 b0 a0  r1 g1 b1 a1  r2 g2 b2 a2  r3 g3 b3 a3','line_number':880,'multiline':False]
['text':'    r4 g4 b4 a4  r5 g5 b5 a5  r6 g6 b6 a6  r7 g7 b7 a7','line_number':881,'multiline':False]
['text':' ]','line_number':882,'multiline':False]
['text':' RGB: Load 10 pixels from input (however we can process only 8 pixels):','line_number':883,'multiline':False]
['text':' source = [','line_number':884,'multiline':False]
['text':'    r0 g0 b0 r1  g1 b1 r2 g2  b2 r3 g3 b3  r4 g4 b4 r5','line_number':885,'multiline':False]
['text':'    r4 g4 b4 r5  g5 b5 r6 g6  b6 r7 g7 b7  r8 g8 b8 r9','line_number':886,'multiline':False]
['text':' ]','line_number':887,'multiline':False]
['text':' Extract lower part of each lane, cast to epi16 and reoder RGBARGBA -> RRGGBBAA','line_number':892,'multiline':False]
['text':' RGBA: pix1 = [','line_number':893,'multiline':False]
['text':'   r0 0 r1 0  g0 0 g1 0  b0 0 b1 0  a0 0 a1 0','line_number':894,'multiline':False]
['text':'   r4 0 r5 0  g4 0 g5 0  b4 0 b5 0  a4 0 a5 0','line_number':895,'multiline':False]
['text':' ]','line_number':896,'multiline':False]
['text':' RGB: pix1 = [','line_number':897,'multiline':False]
['text':'   r0 0 r1 0  g0 0 g1 0  b0 0 b1 0  0 0 0 0','line_number':898,'multiline':False]
['text':'   r4 0 r5 0  g4 0 g5 0  b4 0 b5 0  0 0 0 0','line_number':899,'multiline':False]
['text':' ]','line_number':900,'multiline':False]
['text':' mmk1 = [','line_number':902,'multiline':False]
['text':'   wl_0 wh_0 wl_1 wh_1  wl_0 wh_0 wl_1 wh_1  ...  ...','line_number':903,'multiline':False]
['text':'   wl_4 wh_4 wl_5 wh_5  wl_4 wh_4 wl_5 wh_5  ...  ...','line_number':904,'multiline':False]
['text':' ]','line_number':905,'multiline':False]
['text':' Compute output value as','line_number':907,'multiline':False]
['text':'   C += w0 * C0 + w1 * C1','line_number':908,'multiline':False]
['text':'   C += w4 * C4 + w5 * C5 for each channel in 32-bit precision','line_number':909,'multiline':False]
['text':' Same as above for higher part of each lane','line_number':912,'multiline':False]
['text':' Compute output value as','line_number':915,'multiline':False]
['text':'    C += w2 * C2 + w3 * C3','line_number':916,'multiline':False]
['text':'    C += w6 * C6 + w7 * C7 for each channel in 32-bit precision','line_number':917,'multiline':False]
['text':' block 4','line_number':921,'multiline':False]
['text':' Load 4 values from weight vector','line_number':923,'multiline':False]
['text':' ksource = [','line_number':925,'multiline':False]
['text':'    wl_0 wh_0 wl_1 wh_1  wl_2 wh_2 wl_3 wh_3  0 0 0 0  0 0 0 0','line_number':926,'multiline':False]
['text':'    wl_0 wh_0 wl_1 wh_1  wl_2 wh_2 wl_3 wh_3  0 0 0 0  0 0 0 0','line_number':927,'multiline':False]
['text':' ]','line_number':928,'multiline':False]
['text':' Load pixels from input line','line_number':931,'multiline':False]
['text':' RGBA: source = [','line_number':933,'multiline':False]
['text':'   r0 g0 b0 a0  r1 g1 b1 a1  r2 g2 b2 a2  r3 g3 b3 a3','line_number':934,'multiline':False]
['text':'   r0 g0 b0 a0  r1 g1 b1 a1  r2 g2 b2 a2  r3 g3 b3 a3','line_number':935,'multiline':False]
['text':' ]','line_number':936,'multiline':False]
['text':' RGB: source = [','line_number':937,'multiline':False]
['text':'   r0 g0 b0 r1  g1 b1 r2 g2  b2 r3 g3 b3  r4 g4 b4 r5','line_number':938,'multiline':False]
['text':'   r0 g0 b0 r1  g1 b1 r2 g2  b2 r3 g3 b3  r4 g4 b4 r5','line_number':939,'multiline':False]
['text':' ]','line_number':940,'multiline':False]
['text':' Cast source to epi16 and reorder RGBARGBA -> RRGGBBAA','line_number':943,'multiline':False]
['text':' RGBA: pix = [','line_number':944,'multiline':False]
['text':'   r0 0 r1 0  g0 0 g1 0  b0 0 b1 0  a0 0 a1 0','line_number':945,'multiline':False]
['text':'   r2 0 r3 0  g2 0 g3 0  b2 0 b3 0  a2 0 a3 0','line_number':946,'multiline':False]
['text':' ]','line_number':947,'multiline':False]
['text':' RGB: pix = [','line_number':948,'multiline':False]
['text':'   r0 0 r1 0  g0 0 g1 0  b0 0 b1 0  0 0 0 0','line_number':949,'multiline':False]
['text':'   r2 0 r3 0  g2 0 g3 0  b2 0 b3 0  0 0 0 0','line_number':950,'multiline':False]
['text':' ]','line_number':951,'multiline':False]
['text':' mmk = [','line_number':953,'multiline':False]
['text':'   wl_0 wh_0 wl_1 wh_1  wl_0 wh_0 wl_1 wh_1  ... ...','line_number':954,'multiline':False]
['text':'   wl_2 wh_2 wl_3 wh_3  wl_2 wh_2 wl_3 wh_3  ... ...','line_number':955,'multiline':False]
['text':' ]','line_number':956,'multiline':False]
['text':' Compute output value as','line_number':958,'multiline':False]
['text':'   C += w0 * C0 + w1 * C1','line_number':959,'multiline':False]
['text':'   C += w2 * C2 + w3 * C3 for each channel in 32-bit precision','line_number':960,'multiline':False]
['text':' Sum results between the lanes','line_number':964,'multiline':False]
['text':' block 2','line_number':970,'multiline':False]
['text':' Load 2 values from weight vector','line_number':972,'multiline':False]
['text':' mmk = [wl_0 wh_0 wl_1 wh_1  wl_0 wh_0 wl_1 wh_1  ...]','line_number':973,'multiline':False]
['text':' Load pixels from input line','line_number':975,'multiline':False]
['text':' RGBA: source = [','line_number':976,'multiline':False]
['text':'   r0 g0 b0 a0  r1 g1 b1 a1  0 0 0 0  0 0 0 0','line_number':977,'multiline':False]
['text':' ]','line_number':978,'multiline':False]
['text':' RGB: source = [','line_number':979,'multiline':False]
['text':'   r0 g0 b0 r1  g1 b1 r2 g2  0 0 0 0  0 0 0 0','line_number':980,'multiline':False]
['text':' ]','line_number':981,'multiline':False]
['text':' Cast source to epi16 and reorder RGBARGBA -> RRGGBBAA','line_number':983,'multiline':False]
['text':' Compute output value as C += w0 * C0 + w1 * C1 for each channel in 32-bit precision','line_number':985,'multiline':False]
['text':' block 1','line_number':989,'multiline':False]
['text':' Load 1 value from weight vector','line_number':992,'multiline':False]
['text':' mmk = [wl_0 wh_0 0 0  wl_0 wh_0 0 0  ...]','line_number':993,'multiline':False]
['text':' Load one pixel from input line','line_number':995,'multiline':False]
['text':' RGBA: pix = [','line_number':996,'multiline':False]
['text':'   r0 0 0 0  g0 0 0 0  b0 0 0 0  a0 0 0 0','line_number':997,'multiline':False]
['text':' ]','line_number':998,'multiline':False]
['text':' RGB: pix = [','line_number':999,'multiline':False]
['text':'   r0 0 0 0  g0 0 0 0  b0 0 0 0  r1 0 0 0','line_number':1000,'multiline':False]
['text':' ]','line_number':1001,'multiline':False]
['text':' Compute output value as C += w0 * C0 for each channel in 32-bit precision','line_number':1003,'multiline':False]
['text':' last element','line_number':1008,'multiline':False]
['text':' Convert fixed point values back to integers (truncating)','line_number':1022,'multiline':False]
['text':' Convert packed signed 32-bit integers to packed 16-bit integers using signed saturation','line_number':1024,'multiline':False]
['text':' (a a a a b b b b c c c c d d d d) -> (a a b b c c d d 0 0 0 0 0 0 0 0)','line_number':1025,'multiline':False]
['text':' Convert packed signed 16-bit integers to packed 8-bit integers using unsigned saturation','line_number':1027,'multiline':False]
['text':' (a a b b c c d d) -> (a b c d 0 0 0 0)','line_number':1028,'multiline':False]
['text':' Write the output into single uint32','line_number':1030,'multiline':False]
['text':' (a b c d) -> x_uint32','line_number':1031,'multiline':False]
['text':' When we handle the last line, we can not access the next 4 bytes','line_number':1036,'multiline':False]
['text':' as they are out of memory bounds.','line_number':1037,'multiline':False]
['text':' Memcpy 4-bytes is faster than 3-bytes and this is a boundary case when we want to write','line_number':1040,'multiline':False]
['text':' 4 bytes (R G B | X) to the output buffer (X1 X2 X3 | R1).','line_number':1041,'multiline':False]
['text':' The 4th byte in the register (X) has a garbage value and 4th byte in the output buffer (R1) has a correct','line_number':1042,'multiline':False]
['text':' value which was preveiously computed by another line. In other words, it means that we can not overwrite','line_number':1043,'multiline':False]
['text':' it by simply writing 4 bytes from the register to the output. We'll do the following:','line_number':1044,'multiline':False]
['text':'               v----------|','line_number':1045,'multiline':False]
['text':' Output = [... X1 X2 X3 | R1 G1 B1 R2 ...]','line_number':1046,'multiline':False]
['text':' First, we write R1 value to the 4th byte of (R G B | X) -> (R G B | R1)','line_number':1047,'multiline':False]
['text':' Second, we write 4 bytes from the register to the output: (X1 X2 X3 | R1) -> (R G B | R1)','line_number':1048,'multiline':False]
['text':' Output = [... R G B | R1 G1 B1 R2 ...]','line_number':1049,'multiline':False]
['text':' Memcpy 4-bytes is faster than 3-bytes and here','line_number':1053,'multiline':False]
['text':' we simply write 4 bytes (... R G B X 0 0 0 0 0 ...) where X is a garbage value','line_number':1054,'multiline':False]
['text':' that we will overwrite on the next iteration: (... R G B R G B X 0 0 ...)','line_number':1055,'multiline':False]
['text':' num_channels = 4 -> lineOut + out_x_strided should be uint32 aligned','line_number':1058,'multiline':False]
['text':' Interpolation vertical pass processing one line.','line_number':1074,'multiline':False]
['text':' - We process x-axis data with blocks of 8, 2 and 1','line_number':1075,'multiline':False]
['text':' - We split the size of weight vector for a given output index as a sum: K = n * 2 + m.','line_number':1076,'multiline':False]
['text':' xsize = output width, also equals to input width','line_number':1078,'multiline':False]
['text':' ids_size = interpolation size','line_number':1079,'multiline':False]
['text':' ids_min = input y start index','line_number':1080,'multiline':False]
['text':' block 8','line_number':1095,'multiline':False]
['text':' Load 2 values from weight vector','line_number':1106,'multiline':False]
['text':' RGBA: Load 8 pixels per line','line_number':1109,'multiline':False]
['text':' source1 = [','line_number':1110,'multiline':False]
['text':'    r0 g0 b0 a0  r1 g1 b1 a1  r2 g2 b2 a2  r3 g3 b3 a3','line_number':1111,'multiline':False]
['text':'    r4 g4 b4 a4  r5 g5 b5 a5  r6 g6 b6 a6  r7 g7 b7 a7','line_number':1112,'multiline':False]
['text':' ]','line_number':1113,'multiline':False]
['text':' RGB: Load 10 pixels per line (however we can process only 8 pixels):','line_number':1114,'multiline':False]
['text':' source1 = [','line_number':1115,'multiline':False]
['text':'    r0 g0 b0 r1  g1 b1 r2 g2  b2 r3 g3 b3  r4 g4 b4 r5','line_number':1116,'multiline':False]
['text':'    r4 g4 b4 r5  g5 b5 r6 g6  b6 r7 g7 b7  r8 g8 b8 r9','line_number':1117,'multiline':False]
['text':' ]','line_number':1118,'multiline':False]
['text':' Interleave source1 and source2 from the low half of each 128-bit lane','line_number':1124,'multiline':False]
['text':' and cast the result to epi16','line_number':1125,'multiline':False]
['text':' RGBA: pix1 = [','line_number':1126,'multiline':False]
['text':'    r0 0 R0 0  g0 0 G0 0  b0 0 B0 0  a0 0 A0 0','line_number':1127,'multiline':False]
['text':'    r1 0 R1 0  g1 0 G1 0  b1 0 B1 0  a1 0 A1 0','line_number':1128,'multiline':False]
['text':' ]','line_number':1129,'multiline':False]
['text':' RGB: pix1 = [','line_number':1130,'multiline':False]
['text':'    r0 0 R0 0  g0 0 G0 0  b0 0 B0 0  0 0 0 0','line_number':1131,'multiline':False]
['text':'    r1 0 R1 0  g1 0 G1 0  b1 0 B1 0  0 0 0 0','line_number':1132,'multiline':False]
['text':' ]','line_number':1133,'multiline':False]
['text':' Compute output value as','line_number':1136,'multiline':False]
['text':'   C += w0 * c0 + w1 * C0','line_number':1137,'multiline':False]
['text':'   C += w0 * c1 + w1 * C1 for each channel in 32-bit precision','line_number':1138,'multiline':False]
['text':' RGBA: pix2 = [','line_number':1141,'multiline':False]
['text':'    r2 0 R2 0  g2 0 G2 0  b2 0 B2 0  a2 0 A2 0','line_number':1142,'multiline':False]
['text':'    r3 0 R3 0  g3 0 G3 0  b3 0 B3 0  a3 0 A3 0','line_number':1143,'multiline':False]
['text':' ]','line_number':1144,'multiline':False]
['text':' RGB: pix2 = [','line_number':1145,'multiline':False]
['text':'    r2 0 R2 0  g2 0 G2 0  b2 0 B2 0  0 0 0 0','line_number':1146,'multiline':False]
['text':'    r3 0 R3 0  g3 0 G3 0  b3 0 B3 0  0 0 0 0','line_number':1147,'multiline':False]
['text':' ]','line_number':1148,'multiline':False]
['text':' Compute output value as','line_number':1150,'multiline':False]
['text':'   C += w0 * c2 + w1 * C2','line_number':1151,'multiline':False]
['text':'   C += w0 * c3 + w1 * C3 for each channel in 32-bit precision','line_number':1152,'multiline':False]
['text':' Same as above for the high half of each 128-bit lane','line_number':1155,'multiline':False]
['text':' Same processing as above but with a single weight value','line_number':1162,'multiline':False]
['text':' Convert fixed point values back to integers (truncating)','line_number':1180,'multiline':False]
['text':' Convert packed signed 32-bit integers to packed 16-bit integers using signed saturation','line_number':1185,'multiline':False]
['text':' (a a a a b b b b c c c c d d d d) -> (a a b b c c d d)','line_number':1186,'multiline':False]
['text':' Convert packed signed 16-bit integers to packed 8-bit integers using unsigned saturation','line_number':1189,'multiline':False]
['text':' (a a b b c c d d) -> (a b c d)','line_number':1190,'multiline':False]
['text':' Stores 32 bytes','line_number':1193,'multiline':False]
['text':' TODO: Do we also need block 4 ???','line_number':1197,'multiline':False]
['text':' block 2','line_number':1198,'multiline':False]
['text':' Load 2 values from weight vector','line_number':1207,'multiline':False]
['text':' mmk = [wl_0 wh_0 wl_1 wh_1  wl_0 wh_0 wl_1 wh_1  ... ]','line_number':1208,'multiline':False]
['text':' Load 2 pixels per line','line_number':1211,'multiline':False]
['text':' RGBA: source1 = [','line_number':1212,'multiline':False]
['text':'    r0 g0 b0 a0  r1 g1 b1 a1  0 0 0 0  0 0 0 0','line_number':1213,'multiline':False]
['text':' ]','line_number':1214,'multiline':False]
['text':' RGB: source1 = [','line_number':1215,'multiline':False]
['text':'    r0 g0 b0 r1  g1 b1 r2 g2  0 0 0 0  0 0 0 0','line_number':1216,'multiline':False]
['text':' ]','line_number':1217,'multiline':False]
['text':' Interleave source1 and source2 and cast the result to epi16','line_number':1220,'multiline':False]
['text':' RGBA: pix = [','line_number':1221,'multiline':False]
['text':'    r0 0 R0 0  g0 0 G0 0  b0 0 B0 0  a0 0 A0 0','line_number':1222,'multiline':False]
['text':' ]','line_number':1223,'multiline':False]
['text':' RGB: pix = [','line_number':1224,'multiline':False]
['text':'    r0 0 R0 0  g0 0 G0 0  b0 0 B0 0  0 0 0 0','line_number':1225,'multiline':False]
['text':' ]','line_number':1226,'multiline':False]
['text':' Compute output value as C += w0 * c0 + w1 * C0 for each channel in 32-bit precision','line_number':1229,'multiline':False]
['text':' RGBA: pix = [','line_number':1231,'multiline':False]
['text':'    r1 0 R1 0  g1 0 G1 0  b1 0 B1 0  a1 0 A1 0','line_number':1232,'multiline':False]
['text':' ]','line_number':1233,'multiline':False]
['text':' RGB: pix = [','line_number':1234,'multiline':False]
['text':'    r1 0 R1 0  g1 0 G1 0  b1 0 B1 0  0 0 0 0','line_number':1235,'multiline':False]
['text':' ]','line_number':1236,'multiline':False]
['text':' Compute output value as C += w0 * c1 + w1 * C1 for each channel in 32-bit precision','line_number':1238,'multiline':False]
['text':' Same processing as above but with a single weight value','line_number':1241,'multiline':False]
['text':' Convert fixed point values back to integers (truncating)','line_number':1253,'multiline':False]
['text':' Convert packed signed 32-bit integers to packed 16-bit integers using signed saturation','line_number':1256,'multiline':False]
['text':' (a a a a b b b b c c c c d d d d) -> (a a b b c c d d)','line_number':1257,'multiline':False]
['text':' Convert packed signed 16-bit integers to packed 8-bit integers using unsigned saturation','line_number':1259,'multiline':False]
['text':' (a a b b c c d d) -> (a b c d)','line_number':1260,'multiline':False]
['text':' Store 2 pixels to the output','line_number':1262,'multiline':False]
['text':' block 1','line_number':1266,'multiline':False]
['text':' Load 2 values from weight vector','line_number':1275,'multiline':False]
['text':' mmk = [wl_0 wh_0 wl_1 wh_1  wl_0 wh_0 wl_1 wh_1  ... ]','line_number':1276,'multiline':False]
['text':' Load one pixel per line','line_number':1279,'multiline':False]
['text':' RGBA: source1 = [','line_number':1280,'multiline':False]
['text':'    r0 g0 b0 a0  0 0 0 0  0 0 0 0  0 0 0 0','line_number':1281,'multiline':False]
['text':' ]','line_number':1282,'multiline':False]
['text':' RGB: source1 = [','line_number':1283,'multiline':False]
['text':'    r0 g0 b0 r1  0 0 0 0  0 0 0 0  0 0 0 0','line_number':1284,'multiline':False]
['text':' ]','line_number':1285,'multiline':False]
['text':' Interleave source1 and source2 and cast the result to epi16','line_number':1289,'multiline':False]
['text':' RGBA: pix = [','line_number':1290,'multiline':False]
['text':'    r0 0 R0 0  g0 0 G0 0  b0 0 B0 0  a0 0 A0 0','line_number':1291,'multiline':False]
['text':' ]','line_number':1292,'multiline':False]
['text':' RGB: pix = [','line_number':1293,'multiline':False]
['text':'    r0 0 R0 0  g0 0 G0 0  b0 0 B0 0  0 0 0 0','line_number':1294,'multiline':False]
['text':' ]','line_number':1295,'multiline':False]
['text':' Compute output value as C += w0 * c0 + w1 * C0 for each channel in 32-bit precision','line_number':1298,'multiline':False]
['text':' Here we write 4 bytes to the output even if num_channels < 4, e.g o = {r,g,b,X} for num_channels=3','line_number':1313,'multiline':False]
['text':' It is OK to write 4th byte (e.g. X) as on the next step we will overwrite it with new data.','line_number':1314,'multiline':False]
['text':' We also wont go out of bounds of lineOut memory allocation','line_number':1315,'multiline':False]
['text':' For RGBA we can use (ids_size - 1) as tighter limit but for RGB we can read outside memory boundary','line_number':1323,'multiline':False]
['text':' for the last remaining line','line_number':1324,'multiline':False]
['text':' Load two coefficients at once','line_number':1326,'multiline':False]
['text':' Load 2 lines','line_number':1329,'multiline':False]
['text':' Same processing as above but with a single weight value','line_number':1338,'multiline':False]
['text':' There is no much perf gain using more detailed condition like','line_number':1344,'multiline':False]
['text':' num_channels == 3 && ids_min + j + data_size * i + 4 >= in_max_size','line_number':1345,'multiline':False]
['text':' const int64_t in_max_size = data_size * in_ysize;','line_number':1346,'multiline':False]
['text':' Convert fixed point values back to integers (truncating)','line_number':1357,'multiline':False]
['text':' Convert packed signed 32-bit integers to packed 16-bit integers using signed saturation','line_number':1359,'multiline':False]
['text':' (a a a a b b b b c c c c d d d d) -> (a a b b c c d d)','line_number':1360,'multiline':False]
['text':' Convert packed signed 16-bit integers to packed 8-bit integers using unsigned saturation','line_number':1362,'multiline':False]
['text':' (a a b b c c d d) -> (a b c d)','line_number':1363,'multiline':False]
['text':' Store one pixel to the output','line_number':1365,'multiline':False]
['text':' anonymous namespace','line_number':1375,'multiline':False]
['text':' CPU_CAPABILITY_AVX2','line_number':1376,'multiline':False]
