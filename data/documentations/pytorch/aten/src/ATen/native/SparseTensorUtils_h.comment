['text':' Just for documentary purposes','line_number':16,'multiline':False]
['text':' This is an internal utility function for getting at the SparseTensorImpl,','line_number':20,'multiline':False]
['text':' so that we can write sparse tensor specific accessors for special fields','line_number':21,'multiline':False]
['text':' in SparseTensor.  You should only use this for writing low level','line_number':22,'multiline':False]
['text':' setters/getters for SparseTensorImpl fields; otherwise, you should use','line_number':23,'multiline':False]
['text':' the low level setters/getters that were implemented using this.','line_number':24,'multiline':False]
['text':'','line_number':25,'multiline':False]
['text':' This may be called repeatedly, so make sure it's pretty cheap.','line_number':26,'multiline':False]
['text':' Takes indices and values and directly puts them into the sparse tensor, no','line_number':33,'multiline':False]
['text':' copy.  This used to be called THSTensor_(_move)','line_number':34,'multiline':False]
['text':' Take indices and values and makes a (data) copy of them to put into the','line_number':42,'multiline':False]
['text':' sparse indices/values.  This used to be called THSTensor_(_set)','line_number':43,'multiline':False]
['text':'copy=','line_number':51,'multiline':True]
['text':'copy=','line_number':52,'multiline':True]
['text':' TODO: put this into the public API','line_number':55,'multiline':False]
['text':' Give us a new values tensor, with the same dimensionality','line_number':65,'multiline':False]
['text':' as 'values' but with a new number of non-zero elements.','line_number':66,'multiline':False]
['text':' TODO: Expose this for real in ATen, some day?','line_number':67,'multiline':False]
['text':' NB: Doesn't preserve data.','line_number':68,'multiline':False]
['text':' NOTE [ Flatten Sparse Indices ]','line_number':75,'multiline':False]
['text':' This helper function flattens a sparse indices tensor (a Tensor) into a 1D','line_number':76,'multiline':False]
['text':' indices tensor. E.g.,','line_number':77,'multiline':False]
['text':'   input = [[2, 4, 0],','line_number':78,'multiline':False]
['text':'            [3, 1, 10]]','line_number':79,'multiline':False]
['text':'   full_size = [2, 12]','line_number':80,'multiline':False]
['text':'   output = [ 2 * 12 + 3, 4 * 12 + 1, 0 * 12 + 10 ] = [27, 49, 10]','line_number':81,'multiline':False]
['text':'','line_number':82,'multiline':False]
['text':' In other words, assuming that each `indices[i, :]` is a valid index to a','line_number':83,'multiline':False]
['text':' tensor `t` of shape `full_size`. This returns the corresponding indices to','line_number':84,'multiline':False]
['text':' the flattened tensor `t.reshape( prod(full_size[:indices.size(0)]), -1 )`.','line_number':85,'multiline':False]
['text':' if forceClone is true, the result will forced to be a clone of self.','line_number':86,'multiline':False]
['text':' if force_clone is true, the result will forced to be a clone of self.','line_number':87,'multiline':False]
['text':' Flatten sparse tensor's indices from nD to 1D, similar to NOTE [ Flatten','line_number':93,'multiline':False]
['text':' Sparse Indices ], except this one allows partial flatten: only flatten on','line_number':94,'multiline':False]
['text':' specified dims. Note that the flatten indices might be uncoalesced if','line_number':95,'multiline':False]
['text':' dims_to_flatten.size() < sparse_dim. Also if input indices is already','line_number':96,'multiline':False]
['text':' coalesced, the flattened indices will also be sorted.','line_number':97,'multiline':False]
['text':'','line_number':98,'multiline':False]
['text':' args:','line_number':99,'multiline':False]
['text':'    indices: sparse tensor indices','line_number':100,'multiline':False]
['text':'    sizes: sparse tensor sizes','line_number':101,'multiline':False]
['text':'    dims_to_flatten: a list of dim index to flatten','line_number':102,'multiline':False]
['text':'','line_number':103,'multiline':False]
['text':' Ex1:','line_number':104,'multiline':False]
['text':'   indices = [[2, 4, 0],','line_number':105,'multiline':False]
['text':'             [3, 1, 3]]','line_number':106,'multiline':False]
['text':'   sizes = [2, 12]','line_number':107,'multiline':False]
['text':'   dims_to_flatten = [0, 1]','line_number':108,'multiline':False]
['text':'   new_indices = [ 2 * 12 + 3, 4 * 12 + 1, 0 * 12 + 3 ] = [27, 49, 3]','line_number':109,'multiline':False]
['text':'','line_number':110,'multiline':False]
['text':' Ex2:','line_number':111,'multiline':False]
['text':'   dims_to_flatten = [1]','line_number':112,'multiline':False]
['text':'   new_indices = [ 3, 1, 3 ]  # uncoalesced','line_number':113,'multiline':False]
['text':' Find the CSR representation for a row `indices` from the COO format','line_number':119,'multiline':False]
['text':' namespace at::sparse','line_number':184,'multiline':False]
