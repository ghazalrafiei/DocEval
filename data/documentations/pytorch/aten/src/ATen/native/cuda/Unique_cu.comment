['text':' inverse indices','line_number':51,'multiline':False]
['text':' unique and count','line_number':69,'multiline':False]
['text':'*
    * The idea for implementing this is basically the same as unique.
    * For unique_dim, we are taking the unique with respect to a index
    * tensor, but during the processes, we override the compare and equal
    * operator by checking the data underlying it instead. After the
    * algorithm, we would use index_select to map the resulting indicies
    * to the result on the actual data.
    ','line_number':97,'multiline':True]
['text':' check how many zero dimensions exist','line_number':111,'multiline':False]
['text':' tensor is not well formed as it has 0 sized dimensions','line_number':114,'multiline':False]
['text':' namespace','line_number':186,'multiline':False]
['text':' The current CUDA implementation of unique always sort due to the','line_number':192,'multiline':False]
['text':' lack of hashtable implementation in thrust','line_number':193,'multiline':False]
['text':' The current CUDA implementation of unique always sort due to the','line_number':203,'multiline':False]
['text':' lack of hashtable implementation in thrust','line_number':204,'multiline':False]
['text':' The current CUDA implementation of unique always sort due to the','line_number':227,'multiline':False]
['text':' lack of hashtable implementation in thrust','line_number':228,'multiline':False]
['text':' namespace at::native','line_number':235,'multiline':False]
