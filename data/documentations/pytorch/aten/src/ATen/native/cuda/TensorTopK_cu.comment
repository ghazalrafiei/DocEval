['text':' TODO: remove this when CUDA <11.6 is no longer supported','line_number':24,'multiline':False]
['text':' single_block_topk','line_number':29,'multiline':False]
['text':' aka `k`','line_number':42,'multiline':False]
['text':' Indices are limited to integer fp precision, so counts can fit in','line_number':54,'multiline':False]
['text':' int32, regardless of IndexType','line_number':55,'multiline':False]
['text':' one per each warp, up to warp limit','line_number':59,'multiline':False]
['text':' Find the start offset for our slice','line_number':66,'multiline':False]
['text':' Find the k-th highest element in our input','line_number':78,'multiline':False]
['text':' Every value that is strictly less/greater than `pattern`','line_number':91,'multiline':False]
['text':' (depending on sort dir) in sorted int format is in the top-K.','line_number':92,'multiline':False]
['text':' The top-K value itself might not be unique.','line_number':93,'multiline':False]
['text':'','line_number':94,'multiline':False]
['text':' Since there are a variable number of elements that we see that','line_number':95,'multiline':False]
['text':' are within the top-k, we don't know at what index to write out','line_number':96,'multiline':False]
['text':' the resulting values.','line_number':97,'multiline':False]
['text':' In order to get this, we perform an exclusive prefix sum of','line_number':98,'multiline':False]
['text':' `hasTopK`. This will return the resulting index into which we','line_number':99,'multiline':False]
['text':' need to write the result, if a thread has a result.','line_number':100,'multiline':False]
['text':' All threads need to participate in the loop and the prefix sum,','line_number':102,'multiline':False]
['text':' but not necessarily in the load; hence loop bounds being rounded','line_number':103,'multiline':False]
['text':' up to a multiple of the block dim.','line_number':104,'multiline':False]
['text':' We need to fill in the rest with actual == top-K values.','line_number':139,'multiline':False]
['text':' The number that we need is outputSliceSize -','line_number':140,'multiline':False]
['text':' writeIndexStart. There might be more than that number available,','line_number':141,'multiline':False]
['text':' in which case we have to choose the first seen set. We do this','line_number':142,'multiline':False]
['text':' via a prefix sum to calculate indices for writing results.','line_number':143,'multiline':False]
['text':' aka `k`','line_number':184,'multiline':False]
['text':' WithKthValues= ','line_number':200,'multiline':True]
['text':' namespace sbtopk','line_number':214,'multiline':False]
['text':' multi_block_topk','line_number':216,'multiline':False]
['text':' Assumptions:','line_number':218,'multiline':False]
['text':' The number of elements can be larger than UINT32_MAX, but','line_number':219,'multiline':False]
['text':' the number of total blocks can not be larger than UINT32_MAX.','line_number':220,'multiline':False]
['text':' So we can not have more than UINT32_MAX slices. The actual limit','line_number':221,'multiline':False]
['text':' for number of slices could be a few fold smaller than UINT32_MAX,','line_number':222,'multiline':False]
['text':' because we could be using multiple blocks per slice.','line_number':223,'multiline':False]
['text':' Further more, the size of each input slice is also assumped to be','line_number':224,'multiline':False]
['text':' smaller than UINT32_MAX','line_number':225,'multiline':False]
['text':' Over what radix we are selecting values','line_number':229,'multiline':False]
['text':' 2 ^ RADIX_BITS','line_number':231,'multiline':False]
['text':' find the kth smallest value,','line_number':245,'multiline':False]
['text':' for largest topk, k_to_find = slice_size - k + 1','line_number':246,'multiline':False]
['text':' size: num_slices','line_number':252,'multiline':False]
['text':' outputs','line_number':262,'multiline':False]
['text':' size: num_slices','line_number':263,'multiline':False]
['text':' size: num_slices','line_number':264,'multiline':False]
['text':' size: num_slices * blocks_per_slice * radix_digits','line_number':265,'multiline':False]
['text':' size: num_slices, only write when current_bit reaches 0','line_number':266,'multiline':False]
['text':' only used if this it the last block for this slice','line_number':288,'multiline':False]
['text':' fill digit_counters with zeros','line_number':293,'multiline':False]
['text':' collect digit counts and store in shared memorey','line_number':303,'multiline':False]
['text':' Find the start offset for this slice','line_number':305,'multiline':False]
['text':' load digit counter to register, one digit per thread','line_number':320,'multiline':False]
['text':' We always write out counts regardless if blocks_per_slice == 1 because','line_number':327,'multiline':False]
['text':' it will be used to compute offsets for `gatherTopK`.','line_number':328,'multiline':False]
['text':' if blocks_per_slice == 1, there is no need to do cross-block reduction','line_number':332,'multiline':False]
['text':' in this case we use counts saved at registers directly','line_number':333,'multiline':False]
['text':' make sure writes are globally visible','line_number':335,'multiline':False]
['text':' make sure all writes are finished before update semaphores','line_number':336,'multiline':False]
['text':' the last block of each slice accumulates counters from multiple blocks and updates desired and ks_to_find','line_number':339,'multiline':False]
['text':' accumulates counters from multiple blocks','line_number':356,'multiline':False]
['text':' compute the block-wide inclusive prefix sum','line_number':364,'multiline':False]
['text':' every thread also need the perfix_sum of it's left value for comparison, so save a copy in shared mem','line_number':368,'multiline':False]
['text':' if not the last pass: update desired and ks_to_find','line_number':377,'multiline':False]
['text':' if last pass: write out the kth value','line_number':378,'multiline':False]
['text':' reset semaphores for the next pass','line_number':390,'multiline':False]
['text':' Assumption: k can not be larger than UINT32_MAX','line_number':397,'multiline':False]
['text':' one thread per digit','line_number':399,'multiline':False]
['text':' size: num_slices','line_number':401,'multiline':False]
['text':' size: num_slices * blocks_per_slice * radix_digits','line_number':402,'multiline':False]
['text':' outputs:','line_number':406,'multiline':False]
['text':' size: num_slices * blocks_per_slice == num_blocks','line_number':407,'multiline':False]
['text':' This kernel should be launched with the same number of blocks as the `radixFindKthValues` kernel.','line_number':410,'multiline':False]
['text':' The grid is computed from `getGridFromTiles`, when there are lots of','line_number':415,'multiline':False]
['text':' elements, we will use both blockIdx.x and blockIdx.y, and maybe blockIdx.z','line_number':416,'multiline':False]
['text':' when this is the case, the number of blocks that we are launching can be','line_number':417,'multiline':False]
['text':' more than the number of blocks we need. So we need to check the range of','line_number':418,'multiline':False]
['text':' `block_idx`.','line_number':419,'multiline':False]
['text':' if largest, then only threads that has tidx > desired_digit are active','line_number':427,'multiline':False]
['text':' if !largest, then only threads that has tidx < desired_digit are active','line_number':428,'multiline':False]
['text':' each active thread will read the count for its corresponding, and','line_number':429,'multiline':False]
['text':' do warp reduction followed by shared memory reduction to get the total count','line_number':430,'multiline':False]
['text':' non-active thread should not load, and non-active warp should not do reduction.','line_number':431,'multiline':False]
['text':' Assumption: slice_size can not be larger than UINT32_MAX','line_number':476,'multiline':False]
['text':' size: num_slices','line_number':479,'multiline':False]
['text':' size: num_slices * blocks_per_slice * radix_digits','line_number':480,'multiline':False]
['text':' the number of blocks used by `radixFindKthValues` kernel','line_number':481,'multiline':False]
['text':' outputs:','line_number':483,'multiline':False]
['text':' size: num_slices * blocks_per_slice == num_blocks','line_number':484,'multiline':False]
['text':' aka `k`','line_number':498,'multiline':False]
['text':' The grid is computed from `getGridFromTiles`, when there are lots of','line_number':522,'multiline':False]
['text':' elements, we will use both blockIdx.x and blockIdx.y, and maybe blockIdx.z','line_number':523,'multiline':False]
['text':' when this is the case, the number of blocks that we are launching can be','line_number':524,'multiline':False]
['text':' more than the number of blocks we need. So we need to check the range of','line_number':525,'multiline':False]
['text':' `block_idx`.','line_number':526,'multiline':False]
['text':' Find the start offset for our slice','line_number':538,'multiline':False]
['text':' Find the k-th highest element in our input','line_number':550,'multiline':False]
['text':' Find the start index in output tensor of this block','line_number':554,'multiline':False]
['text':' Read input, select topk out and write','line_number':564,'multiline':False]
['text':' Find the start offset for this slice','line_number':568,'multiline':False]
['text':' occupancy of this kernel is limited by registers per threads','line_number':610,'multiline':False]
['text':' from nsight launch statistics','line_number':611,'multiline':False]
['text':' clamp to (4, 64)','line_number':628,'multiline':False]
['text':' aka `k`','line_number':645,'multiline':False]
['text':' configure items_per_thread based on device architecture and input size','line_number':658,'multiline':False]
['text':' temporary storage','line_number':666,'multiline':False]
['text':' iterate radix bits for multiple passes','line_number':706,'multiline':False]
['text':' Do a prefix scan of withinKCounts and kthCounts using slice_idx as keys to get the starting index of each block','line_number':735,'multiline':False]
['text':' copy topk values to output tensor','line_number':741,'multiline':False]
['text':' Find topk values based on kth values','line_number':748,'multiline':False]
['text':' WithKthValues= ','line_number':754,'multiline':True]
['text':' namespace mbtopk','line_number':771,'multiline':False]
['text':' This heuristics is based on the experiment in https://github.com/pytorch/pytorch/pull/74267','line_number':777,'multiline':False]
['text':' This heuristics is based on the experiment in https://github.com/pytorch/pytorch/pull/71081','line_number':786,'multiline':False]
['text':' static_cast is required to ensure that the correct type (INDEX_T)','line_number':802,'multiline':False]
['text':' is provided to the kernel for the arguments.','line_number':803,'multiline':False]
['text':' The actual dimension that the k-selection is running in ','line_number':811,'multiline':True]
['text':' may have changed from collapseDims() ','line_number':812,'multiline':True]
['text':' tensorInfoLegacyIfScalar','line_number':845,'multiline':True]
['text':' We use these structures solely to find the offset to ','line_number':857,'multiline':True]
['text':' each slice we are operating on ','line_number':858,'multiline':True]
['text':' stash the stride of dim because it can be accidentally collapsed ','line_number':862,'multiline':True]
['text':' Collapse all other dims ','line_number':865,'multiline':True]
['text':' restore stride in case it was collapsed ','line_number':869,'multiline':True]
['text':' This is used as a template parameter to calculate indices. ','line_number':877,'multiline':True]
['text':' We only specialize it if all collapsed dim sizes are the ','line_number':878,'multiline':True]
['text':' same; otherwise, we use -1 which is the specialization ','line_number':879,'multiline':True]
['text':' parameter for arbitrary dimensions ','line_number':880,'multiline':True]
['text':' the below is safe with 0-dimensional tensors because it is based on','line_number':889,'multiline':False]
['text':' TensorInfo which implicitly expands to 1-dimensional.','line_number':890,'multiline':False]
['text':' Based on required index size, run the algorithm with the','line_number':892,'multiline':False]
['text':' appropriate index type','line_number':893,'multiline':False]
['text':' at::native','line_number':907,'multiline':False]
