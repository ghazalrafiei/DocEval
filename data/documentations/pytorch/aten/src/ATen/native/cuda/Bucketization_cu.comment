['text':' Implement a numpy like searchsorted and a TF like bucketize function running on cuda','line_number':20,'multiline':False]
['text':' See details in ATen/nativate/Bucketization.cpp','line_number':21,'multiline':False]
['text':' sorter gives relative ordering for ND tensors, so we need to save and add the non-updated start as an offset','line_number':27,'multiline':False]
['text':' i.e. the second row of a 3x3 tensors starts at element 3 but sorter's second row only contains 0, 1, or 2','line_number':28,'multiline':False]
['text':' sorter gives relative ordering for ND tensors, so we need to save and add the non-updated start as an offset','line_number':45,'multiline':False]
['text':' i.e. the second row of a 3x3 tensors starts at element 3 but sorter's second row only contains 0, 1, or 2','line_number':46,'multiline':False]
['text':' If boundaries tensor is 1d, we always search the entire boundary tensor','line_number':74,'multiline':False]
['text':' type conversion might happen here','line_number':82,'multiline':False]
['text':' inner most dim size of input and boundaries','line_number':91,'multiline':False]
['text':' See [Note: hacky wrapper removal for optional tensor]','line_number':140,'multiline':False]
['text':' we have two inputs to set right, pre_check checks that they aren't set to opposites','line_number':146,'multiline':False]
['text':' for non-contiguous result tensors, we write the output to a contiguous copy so we can later copy back, maintaing the original result tensor','line_number':152,'multiline':False]
['text':' if result is non-contiguous, we wrote the answer to a copied version, so we copy back to the original result tensor','line_number':171,'multiline':False]
['text':' namespace at::native','line_number':233,'multiline':False]
