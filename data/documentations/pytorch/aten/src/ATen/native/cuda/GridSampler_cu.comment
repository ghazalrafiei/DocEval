['text':' get the corresponding input x, y co-ordinates from grid','line_number':60,'multiline':False]
['text':' get NE, NW, SE, SW pixel values from (x, y)','line_number':68,'multiline':False]
['text':' get surfaces to each neighbor:','line_number':78,'multiline':False]
['text':' calculate bilinear weighted pixel value and set output pixel','line_number':84,'multiline':False]
['text':' assign nearest neighor pixel value to output pixel','line_number':107,'multiline':False]
['text':' get the corresponding input x, y, z co-ordinates from grid','line_number':196,'multiline':False]
['text':' get corner pixel values from (x, y, z)','line_number':206,'multiline':False]
['text':' for 4d, we used north-east-south-west','line_number':207,'multiline':False]
['text':' for 5d, we add top-bottom','line_number':208,'multiline':False]
['text':' get surfaces to each neighbor:','line_number':241,'multiline':False]
['text':'   (c, iz_tnw, iy_tnw, ix_tnw) * tnw + (c, iz_tne, iy_tne, ix_tne) * tne','line_number':254,'multiline':False]
['text':' + (c, iz_tsw, iy_tsw, ix_tsw) * tsw + (c, iz_tse, iy_tse, ix_tse) * tse','line_number':255,'multiline':False]
['text':' + (c, iz_bnw, iy_bnw, ix_bnw) * bnw + (c, iz_bne, iy_bne, ix_bne) * bne','line_number':256,'multiline':False]
['text':' + (c, iz_bsw, iy_bsw, ix_bsw) * bsw + (c, iz_bse, iy_bse, ix_bse) * bse','line_number':257,'multiline':False]
['text':' assign nearest neighor pixel value to output pixel','line_number':290,'multiline':False]
['text':' Note [Passing pointer and offset to fastAtomicAdd]','line_number':304,'multiline':False]
['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':305,'multiline':False]
['text':' For its internal bounds checking, fastAtomicAdd needs to know where the destination address','line_number':306,'multiline':False]
['text':' lies relative to the entire tensor, so we pass the base grad_input.data and full offset information,','line_number':307,'multiline':False]
['text':' including batch * channel offset (NC_offset).','line_number':308,'multiline':False]
['text':' initialized to zeros (or unused if input_requires_grad is false)','line_number':317,'multiline':False]
['text':' initialized to empty','line_number':318,'multiline':False]
['text':' gInp_* (and NC_offset below) are not really needed if input_requires_grad is false.','line_number':342,'multiline':False]
['text':' get the corresponding input x, y co-ordinates from grid','line_number':361,'multiline':False]
['text':' multipliers for gradients on ix and iy','line_number':365,'multiline':False]
['text':' get NE, NW, SE, SW pixel values from (x, y)','line_number':371,'multiline':False]
['text':' get surfaces to each neighbor:','line_number':381,'multiline':False]
['text':' calculate and set grad_input. See Note [Passing pointer and offset to fastAtomicAdd].','line_number':395,'multiline':False]
['text':' calculate grad_grid','line_number':402,'multiline':False]
['text':' assuming grad_grid is contiguous','line_number':425,'multiline':False]
['text':' thus we can','line_number':426,'multiline':False]
['text':'   1. use index with gGrid_sW to directly compute gGrid_ptr_NHW','line_number':427,'multiline':False]
['text':'   2. directly assign to gGrid_ptr_NHW[0], gGrid_ptr_NHW[1]','line_number':428,'multiline':False]
['text':' assign nearest neighor pixel value to output pixel','line_number':437,'multiline':False]
['text':' calculate and set grad_input. See Note [Passing pointer and offset to fastAtomicAdd].','line_number':441,'multiline':False]
['text':' assuming grad_grid is contiguous','line_number':446,'multiline':False]
['text':' thus we can','line_number':447,'multiline':False]
['text':'   1. use index with gGrid_sW to directly compute gGrid_ptr_NHW','line_number':448,'multiline':False]
['text':'   2. directly assign to gGrid_ptr_NHW[0], gGrid_ptr_NHW[1]','line_number':449,'multiline':False]
['text':' set input gradient. See Note [Passing pointer and offset to fastAtomicAdd].','line_number':490,'multiline':False]
['text':' set grid gradient','line_number':499,'multiline':False]
['text':' initialized to zeros (or unused if input_requires_grad is false)','line_number':523,'multiline':False]
['text':' initialized to empty','line_number':524,'multiline':False]
['text':' gInp_* (and NC_offset below) are not really needed if input_requires_grad is false.','line_number':553,'multiline':False]
['text':' get the corresponding input x, y, z co-ordinates from grid','line_number':575,'multiline':False]
['text':' multipliers for gradients on ix, iy, and iz','line_number':580,'multiline':False]
['text':' get corner pixel values from (x, y, z)','line_number':587,'multiline':False]
['text':' for 4d, we used north-east-south-west','line_number':588,'multiline':False]
['text':' for 5d, we add top-bottom','line_number':589,'multiline':False]
['text':' get surfaces to each neighbor:','line_number':622,'multiline':False]
['text':' calculate bilinear weighted pixel value and set output pixel','line_number':639,'multiline':False]
['text':' calculate and set grad_input. See Note [Passing pointer and offset to fastAtomicAdd].','line_number':643,'multiline':False]
['text':' calculate grad_grid','line_number':662,'multiline':False]
['text':' assuming grad_grid is contiguous','line_number':713,'multiline':False]
['text':' thus we can','line_number':714,'multiline':False]
['text':'   1. use index with gGrid_sW to directly compute gGrid_ptr_NDHW','line_number':715,'multiline':False]
['text':'   2. directly assign to gGrid_ptr_NDHW[0], gGrid_ptr_NDHW[1], gGrid_ptr_NDHW[2]','line_number':716,'multiline':False]
['text':' assign nearest neighor pixel value to output pixel','line_number':727,'multiline':False]
['text':' calculate and set grad_input. See Note [Passing pointer and offset to fastAtomicAdd].','line_number':731,'multiline':False]
['text':' assuming grad_grid is contiguous','line_number':737,'multiline':False]
['text':' thus we can','line_number':738,'multiline':False]
['text':'   1. use index with gGrid_sW to directly compute gGrid_ptr_NDHW','line_number':739,'multiline':False]
['text':'   2. directly assign to gGrid_ptr_NDHW[0], gGrid_ptr_NDHW[1], gGrid_ptr_NDHW[2]','line_number':740,'multiline':False]
['text':' namespace','line_number':748,'multiline':False]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':753,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':754,'multiline':False]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':797,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':798,'multiline':False]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':844,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':845,'multiline':False]
['text':' See Note [Writing Nondeterministic Operations]','line_number':849,'multiline':False]
['text':' Nondeterministic because of atomicAdd usage','line_number':850,'multiline':False]
['text':' If `input` gradient is not required, we skip computing it -- not needing to create','line_number':856,'multiline':False]
['text':' the tensor to hold the gradient can markedly increase performance. (`grid` gradient','line_number':857,'multiline':False]
['text':' is always computed.)','line_number':858,'multiline':False]
['text':'grad_input_memory_span =','line_number':879,'multiline':True]
['text':'grad_input_memory_span =','line_number':894,'multiline':True]
['text':' See NOTE [ grid_sampler Native Functions ].','line_number':907,'multiline':False]
['text':' Add checks here in case this is called instead of grid_sampler.','line_number':908,'multiline':False]
['text':' See Note [Writing Nondeterministic Operations]','line_number':912,'multiline':False]
['text':' Nondeterministic because of atomicAdd usage','line_number':913,'multiline':False]
['text':'grad_input_memory_span =','line_number':938,'multiline':True]
['text':'grad_input_memory_span =','line_number':953,'multiline':True]
['text':' namespace at::native','line_number':961,'multiline':False]
