['text':' Enum representing the FFT type','line_number':21,'multiline':False]
['text':' Complex-to-complex','line_number':23,'multiline':False]
['text':' Real-to-complex','line_number':24,'multiline':False]
['text':' Complex-to-real','line_number':25,'multiline':False]
['text':' This struct is used to let us easily compute hashes of the','line_number':28,'multiline':False]
['text':' parameters.','line_number':29,'multiline':False]
['text':' It will be the **key** to the plan cache.','line_number':30,'multiline':False]
['text':' between 1 and max_rank, i.e., 1 <= signal_ndim <= 3','line_number':33,'multiline':False]
['text':' These include additional batch dimension as well.','line_number':34,'multiline':False]
['text':' Padding bits must be zeroed for hashing','line_number':45,'multiline':False]
['text':' Returns true if the transform type has complex input','line_number':63,'multiline':False]
['text':' Returns true if the transform type has complex output','line_number':76,'multiline':False]
['text':' Create transform type enum from bools representing if input and output are complex','line_number':89,'multiline':False]
['text':' Not using fftDestroy() for rocFFT to work around double freeing of handles','line_number':114,'multiline':False]
['text':' Struct representing a tensor in CuFFT's data layout for planning transforms','line_number':134,'multiline':False]
['text':' See NOTE [ cuFFT Embedded Strides ].','line_number':135,'multiline':False]
['text':' Returns a cufft embedding for a contiguous signal of the given size.','line_number':142,'multiline':False]
['text':' e.g. if the input is cloned, this will be the resulting data layout','line_number':143,'multiline':False]
['text':' See NOTE [ cuFFT Embedded Strides ].','line_number':144,'multiline':False]
['text':' Convert strides to a CuFFT embedded representation.','line_number':161,'multiline':False]
['text':' If strides cannot be embedded, returns a simple layout and sets must_clone flag','line_number':162,'multiline':False]
['text':' See NOTE [ cuFFT Embedded Strides ].','line_number':163,'multiline':False]
['text':' Zero stides are not allowed, even if the batch size is one.','line_number':174,'multiline':False]
['text':' If that happens just set a dummy case','line_number':175,'multiline':False]
['text':' Calculate the embedding shape, or set must_clone if the strides cannot be embedded','line_number':184,'multiline':False]
['text':' If the input needs to be cloned, assume it will be contiguous','line_number':199,'multiline':False]
['text':' Determine if layout represents a simple embedding (contiguous data)','line_number':205,'multiline':False]
['text':' This class contains all the information needed to execute a cuFFT plan:','line_number':220,'multiline':False]
['text':'   1. the plan','line_number':221,'multiline':False]
['text':'   2. whether to clone input before executing the plan','line_number':222,'multiline':False]
['text':'   3. the workspace size needed','line_number':223,'multiline':False]
['text':'','line_number':224,'multiline':False]
['text':' This class will be the **value** in the plan cache.','line_number':225,'multiline':False]
['text':' It **owns** the raw plan via a unique_ptr.','line_number':226,'multiline':False]
['text':' Only move semantics is enought for this class. Although we already use','line_number':230,'multiline':False]
['text':' unique_ptr for the plan, still remove copy constructor and assignment op so','line_number':231,'multiline':False]
['text':' we don't accidentally copy and take perf hit.','line_number':232,'multiline':False]
['text':' For complex types, strides are in units of 2 * element_size(dtype)','line_number':244,'multiline':False]
['text':' sizes are for the full signal, including batch size and always two-sided','line_number':245,'multiline':False]
['text':' signal sizes (excluding batch dim)','line_number':250,'multiline':False]
['text':' input batch size','line_number':253,'multiline':False]
['text':' Since cuFFT has limited non-unit stride support and various constraints, we','line_number':257,'multiline':False]
['text':' use a flag to keep track throughout this function to see if we need to','line_number':258,'multiline':False]
['text':' input = input.clone();','line_number':259,'multiline':False]
['text':' clone input to avoid issues with hipfft clobering the input and failing tests','line_number':262,'multiline':False]
['text':' For half, base strides on the real part of real-to-complex and','line_number':268,'multiline':False]
['text':' complex-to-real transforms are not supported. Since our output is always','line_number':269,'multiline':False]
['text':' contiguous, only need to check real-to-complex case.','line_number':270,'multiline':False]
['text':' cuFFT on half requires compute capability of at least SM_53','line_number':272,'multiline':False]
['text':' Check if we can take advantage of simple data layout.','line_number':297,'multiline':False]
['text':'','line_number':298,'multiline':False]
['text':' See NOTE [ cuFFT Embedded Strides ] in native/cuda/SpectralOps.cu.','line_number':299,'multiline':False]
['text':' disable auto allocation of workspace to use THC allocator','line_number':341,'multiline':False]
['text':' autoAllocate ','line_number':342,'multiline':True]
['text':' make plan','line_number':346,'multiline':False]
['text':' If with unit-stride, we tell cuFFT by setting inembed == onembed == NULL.','line_number':348,'multiline':False]
['text':' In such case, cuFFT ignores istride, ostride, idist, and odist','line_number':349,'multiline':False]
['text':' by assuming istride = ostride = 1.','line_number':350,'multiline':False]
['text':'','line_number':351,'multiline':False]
['text':' See NOTE [ cuFFT Embedded Strides ] in native/cuda/SpectralOps.cu.','line_number':352,'multiline':False]
['text':' inembed ','line_number':355,'multiline':True]
['text':' base_istride ','line_number':355,'multiline':True]
['text':' idist ','line_number':355,'multiline':True]
['text':' onembed ','line_number':356,'multiline':True]
['text':' base_ostride ','line_number':356,'multiline':True]
['text':' odist ','line_number':356,'multiline':True]
['text':' inembed ','line_number':360,'multiline':True]
['text':' base_istride ','line_number':360,'multiline':True]
['text':' idist ','line_number':360,'multiline':True]
['text':' onembed ','line_number':361,'multiline':True]
['text':' base_ostride ','line_number':361,'multiline':True]
['text':' odist ','line_number':361,'multiline':True]
['text':' Note that the max plan number for CUDA version < 10 has to be 1023','line_number':396,'multiline':False]
['text':' due to a bug that fails on the 1024th plan','line_number':397,'multiline':False]
['text':' The default max cache size chosen for CUDA version > 10 is arbitrary.','line_number':402,'multiline':False]
['text':' This number puts a limit on how big of a plan cache should we maintain by','line_number':403,'multiline':False]
['text':' default. Users can always configure it via cufft_set_plan_cache_max_size.','line_number':404,'multiline':False]
['text':' This cache assumes that the mapping from key to value never changes.','line_number':412,'multiline':False]
['text':' This is **NOT** thread-safe. Please use a mutex when using it **AND** the','line_number':413,'multiline':False]
['text':' value returned from try_emplace_value.','line_number':414,'multiline':False]
['text':' The contract of using this cache is that try_emplace_value should only be','line_number':415,'multiline':False]
['text':' used when the max_size is positive.','line_number':416,'multiline':False]
['text':' If key is in this cache, return the cached config. Otherwise, emplace the','line_number':445,'multiline':False]
['text':' config in this cache and return it.','line_number':446,'multiline':False]
['text':' Return const reference because CuFFTConfig shouldn't be tampered with once','line_number':447,'multiline':False]
['text':' created.','line_number':448,'multiline':False]
['text':' Hit, put to list front','line_number':453,'multiline':False]
['text':' Miss','line_number':459,'multiline':False]
['text':' remove if needed','line_number':460,'multiline':False]
['text':' construct new plan at list front, then insert into _cache_map','line_number':468,'multiline':False]
['text':' Only sets size and does value check. Does not resize the data structures.','line_number':504,'multiline':False]
['text':' We check that 0 <= new_size <= CUFFT_MAX_PLAN_NUM here. Since','line_number':506,'multiline':False]
['text':' CUFFT_MAX_PLAN_NUM is of type size_t, we need to do non-negativity check','line_number':507,'multiline':False]
['text':' first.','line_number':508,'multiline':False]
['text':' Since ATen is separated into CPU build and CUDA build, we need a way to call','line_number':521,'multiline':False]
['text':' these functions only when CUDA is loaded. We use CUDA hooks for this purpose','line_number':522,'multiline':False]
['text':' (at cuda/detail/CUDAHooks.cpp), and call the hooked functions from the actual','line_number':523,'multiline':False]
['text':' native function counterparts (at native/SpectralOps.cpp), i.e.,','line_number':524,'multiline':False]
['text':' _cufft_get_plan_cache_max_size, _cufft_set_plan_cache_max_size','line_number':525,'multiline':False]
['text':' _cufft_get_plan_cache_size, and _cufft_clear_plan_cache.','line_number':526,'multiline':False]
['text':' namespace at::native::detail','line_number':532,'multiline':False]
