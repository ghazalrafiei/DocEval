['text':' See Note [CPU_CAPABILITY namespace]','line_number':21,'multiline':False]
['text':' define for int64_t properly for load','line_number':83,'multiline':False]
['text':' clamp it between 0 and both','line_number':105,'multiline':False]
['text':' return  (a._vec0, a._vec1)','line_number':107,'multiline':False]
['text':' return (b._vec0,b._vec1)','line_number':110,'multiline':False]
['text':' return  (b._vec0, a._vec1)','line_number':113,'multiline':False]
['text':' return  (a._vec0,b._vec1)','line_number':116,'multiline':False]
['text':' return  (*_vec0,a._vec1)','line_number':119,'multiline':False]
['text':' return  (*_vec0,b._vec1)','line_number':122,'multiline':False]
['text':' return (a._vec0,*_vec1)','line_number':125,'multiline':False]
['text':' return (b._vec0,*_vec1)','line_number':128,'multiline':False]
['text':' return (*_vec0,*_vec1)','line_number':131,'multiline':False]
['text':' it can be used to emulate blend faster','line_number':135,'multiline':False]
['text':' clamp it 0 and 0xF','line_number':159,'multiline':False]
['text':' unnamed namespace ','line_number':296,'multiline':True]
['text':' unnamed namespace ','line_number':318,'multiline':True]
['text':'','line_number':320,'multiline':False]
['text':' because of gcc inconsistency for int64_t we are obliged to use this, not','line_number':375,'multiline':False]
['text':' value_type','line_number':376,'multiline':False]
['text':' load only first 8 bytes','line_number':414,'multiline':False]
['text':' only intended to be used with uint8_t','line_number':415,'multiline':False]
['text':' blend section','line_number':630,'multiline':False]
['text':' generated masks','line_number':673,'multiline':False]
['text':' generated masks','line_number':681,'multiline':False]
['text':' right shift value to retain sign bit for signed and no bits for unsigned','line_number':780,'multiline':False]
['text':' Propagates NaN if either input is a NaN. ','line_number':1181,'multiline':True]
['text':' Propagates NaN if either input is a NaN. ','line_number':1198,'multiline':True]
['text':' Keeps NaN if actual value is NaN ','line_number':1215,'multiline':True]
['text':' Keeps NaN if actual value is NaN ','line_number':1231,'multiline':True]
['text':' we will simulate it differently with 6 instructions total','line_number':1280,'multiline':False]
['text':' lets permute second so that we can add it getting horizontal sums','line_number':1281,'multiline':False]
['text':' 2perm','line_number':1282,'multiline':False]
['text':' 2perm','line_number':1283,'multiline':False]
['text':' summ','line_number':1284,'multiline':False]
['text':' 2add','line_number':1285,'multiline':False]
['text':' 2 add','line_number':1286,'multiline':False]
['text':' now lets choose evens','line_number':1287,'multiline':False]
['text':' 2 mergee's','line_number':1288,'multiline':False]
['text':' we will simulate it differently with 6 instructions total','line_number':1294,'multiline':False]
['text':' lets permute second so that we can add it getting horizontal sums','line_number':1295,'multiline':False]
['text':' 2perm','line_number':1296,'multiline':False]
['text':' 2perm','line_number':1297,'multiline':False]
['text':' summ','line_number':1298,'multiline':False]
['text':' 2sub','line_number':1299,'multiline':False]
['text':' 2 sub','line_number':1300,'multiline':False]
['text':' now lets choose evens','line_number':1301,'multiline':False]
['text':' 2 mergee's','line_number':1302,'multiline':False]
['text':' helper function for float to uint8_t conversion','line_number':1344,'multiline':False]
['text':' unnamed namespace ','line_number':1434,'multiline':True]
['text':' unnamed namespace ','line_number':1466,'multiline':True]
['text':' int32_t and float have same size','line_number':1531,'multiline':False]
['text':' unnamed namespace ','line_number':1615,'multiline':True]
['text':' auto mask = Vectorized<uint16_t>(0xFF);','line_number':1634,'multiline':False]
['text':' vec0 = vec0 & mask;','line_number':1635,'multiline':False]
['text':' vec1 = vec1 & mask;','line_number':1636,'multiline':False]
['text':' vec2 = vec2 & mask;','line_number':1637,'multiline':False]
['text':' vec3 = vec3 & mask;','line_number':1638,'multiline':False]
['text':' unnamed namespace ','line_number':1660,'multiline':True]
['text':'////////////////////////////////QUANT///////////////////////////////////////////','line_number':1662,'multiline':False]
['text':' unpacking unsigned as signed','line_number':1803,'multiline':False]
['text':' unpacking unsigned as signed','line_number':1826,'multiline':False]
['text':' convert std::complex<V> index mask to V index mask: xy -> xxyy','line_number':2176,'multiline':False]
['text':'(a + bi)  * (c + di) = (ac - bd) + (ad + bc)i','line_number':2328,'multiline':False]
['text':' this is more z arch friendly than simulating horizontal from x86','line_number':2331,'multiline':False]
['text':' Unfortunately, this breaks some tests','line_number':2374,'multiline':False]
['text':' Implement it like it's done for avx2','line_number':2375,'multiline':False]
['text':' |c|    |d|','line_number':2376,'multiline':False]
['text':' |d|    |c|','line_number':2377,'multiline':False]
['text':' 1/sc     1/sc','line_number':2378,'multiline':False]
['text':' a/sc     b/sc','line_number':2379,'multiline':False]
['text':' c/sc     d/sc','line_number':2380,'multiline':False]
['text':' ac/sc^2  bd/sc^2','line_number':2381,'multiline':False]
['text':' d/sc         c/sc','line_number':2383,'multiline':False]
['text':' -d/|c,d|        c/sc','line_number':2384,'multiline':False]
['text':' -ad/sc^2      bc/sc^2','line_number':2385,'multiline':False]
['text':' (ac+bd)/sc^2  (ac+bd)/sc^2','line_number':2386,'multiline':False]
['text':' (bc-ad)/sc^2  (bc-ad)/sc^2','line_number':2387,'multiline':False]
['text':' (ac+bd)/sc^2  (bc-ad)/sc^2','line_number':2388,'multiline':False]
['text':' get the denominator','line_number':2390,'multiline':False]
['text':' (c^2+d^2)/sc^2   (c^2+d^2)/sc^2','line_number':2391,'multiline':False]
['text':' b        a','line_number':2397,'multiline':False]
['text':' atan(x) = i/2 * ln((i + z)/(i - z))','line_number':2406,'multiline':False]
['text':' ln((i + z)/(i - z))','line_number':2410,'multiline':False]
['text':' i/2*ln()','line_number':2412,'multiline':False]
['text':' asin(x)','line_number':2420,'multiline':False]
['text':' = -i*ln(iz + sqrt(1 -z^2))','line_number':2421,'multiline':False]
['text':' = -i*ln((ai - b) + sqrt(1 - (a + bi)*(a + bi)))','line_number':2422,'multiline':False]
['text':' = -i*ln((-b + ai) + sqrt(1 - (a**2 - b**2) - 2*abi))','line_number':2423,'multiline':False]
['text':' 0x0A for complex<double> , 0xAA for complex<float>','line_number':2434,'multiline':False]
['text':' acos(x) = pi/2 - asin(x)','line_number':2445,'multiline':False]
['text':' compares real and imag individually','line_number':2503,'multiline':False]
['text':' If both real numbers and imag numbers are equal, then the complex numbers are equal','line_number':2504,'multiline':False]
['text':' compares real and imag individually','line_number':2510,'multiline':False]
['text':' If either real numbers or imag numbers are not equal, then the complex numbers are not equal','line_number':2511,'multiline':False]
['text':' log2eB_inv','line_number':2564,'multiline':False]
['text':' re + im*i = (a + bi)  / (c + di)','line_number':2591,'multiline':False]
['text':' re = (ac + bd)/abs_2() = c/abs_2()','line_number':2592,'multiline':False]
['text':' im = (bc - ad)/abs_2() = d/abs_2()','line_number':2593,'multiline':False]
['text':' inputs:','line_number':2640,'multiline':False]
['text':'   a      = {a0, a1, a2, a3}','line_number':2641,'multiline':False]
['text':'   b      = {b0, b1, b2, b3}','line_number':2642,'multiline':False]
['text':'   return {a0, b0, a1, b1}','line_number':2648,'multiline':False]
['text':'          {a2, b2, a3, b3}','line_number':2649,'multiline':False]
['text':' inputs:','line_number':2658,'multiline':False]
['text':'   a = {a0, b0, a1, b1}','line_number':2659,'multiline':False]
['text':'   b = {a2, b2, a3, b3}','line_number':2660,'multiline':False]
['text':' swap lanes:','line_number':2668,'multiline':False]
['text':'   return {a0, a1, a2, a3}','line_number':2669,'multiline':False]
['text':'          {b0, b1, b2, b3}','line_number':2670,'multiline':False]
['text':' inputs:','line_number':2678,'multiline':False]
['text':'   a = {a0, a1, a2, a3,, a4, a5, a6, a7}','line_number':2679,'multiline':False]
['text':'   b = {b0, b1, b2, b3,, b4, b5, b6, b7}','line_number':2680,'multiline':False]
['text':' group cols crossing lanes:','line_number':2687,'multiline':False]
['text':'   return {a0, b0, a1, b1,, a2, b2, a3, b3}','line_number':2688,'multiline':False]
['text':'          {a4, b4, a5, b5,, a6, b6, a7, b7}','line_number':2689,'multiline':False]
['text':' inputs:','line_number':2699,'multiline':False]
['text':'   a = {a0, b0, a1, b1,, a2, b2, a3, b3}','line_number':2700,'multiline':False]
['text':'   b = {a4, b4, a5, b5,, a6, b6, a7, b7}','line_number':2701,'multiline':False]
['text':' {a0,a2,b0,b2} {a1,a3,b1,b3}','line_number':2703,'multiline':False]
['text':' it could be done with vec_perm ,too','line_number':2716,'multiline':False]
['text':' swap lanes:','line_number':2717,'multiline':False]
['text':'   return {a0, a1, a2, a3,, a4, a5, a6, a7}','line_number':2718,'multiline':False]
['text':'          {b0, b1, b2, b3,, b4, b5, b6, b7}','line_number':2719,'multiline':False]
['text':' Note: this function only convert inputs number of elements equal to at::vec::Vectorized<float>.size()','line_number':2780,'multiline':False]
['text':' Only handle first 64 bits','line_number':2781,'multiline':False]
['text':' namespace','line_number':2798,'multiline':False]
['text':' namespace vec','line_number':2799,'multiline':False]
['text':' namespace at','line_number':2800,'multiline':False]
