['text':' DO NOT DEFINE STATIC DATA IN THIS HEADER!','line_number':3,'multiline':False]
['text':' See Note [Do not compile initializers with AVX]','line_number':4,'multiline':False]
['text':' dummy definition to make Vectorizedi always defined','line_number':34,'multiline':False]
['text':' CPU_CAPABILITY_AVX2','line_number':36,'multiline':False]
['text':' Ensure uninitialized memory does not change the output value See https://github.com/pytorch/pytorch/issues/32502','line_number':97,'multiline':False]
['text':' for more details. We do not initialize arrays to zero using "={0}" because gcc would compile it to two','line_number':98,'multiline':False]
['text':' instructions while a loop would be compiled to one instruction.','line_number':99,'multiline':False]
['text':' ptr need not to be aligned here. See','line_number':108,'multiline':False]
['text':' https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/intrinsics/intrinsics-for-intel-advanced-vector-extensions/intrinsics-for-load-and-store-operations-1/mm256-storeu-si256.html','line_number':109,'multiline':False]
['text':' Ensure uninitialized memory does not change the output value See https://github.com/pytorch/pytorch/issues/32502','line_number':219,'multiline':False]
['text':' for more details. We do not initialize arrays to zero using "={0}" because gcc would compile it to two','line_number':220,'multiline':False]
['text':' instructions while a loop would be compiled to one instruction.','line_number':221,'multiline':False]
['text':' ptr need not to be aligned here. See','line_number':230,'multiline':False]
['text':' https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/intrinsics/intrinsics-for-intel-advanced-vector-extensions/intrinsics-for-load-and-store-operations-1/mm256-storeu-si256.html','line_number':231,'multiline':False]
['text':' int32_t and float have same size','line_number':283,'multiline':False]
['text':' int32_t has half the size of double','line_number':303,'multiline':False]
['text':' Ensure uninitialized memory does not change the output value See https://github.com/pytorch/pytorch/issues/32502','line_number':432,'multiline':False]
['text':' for more details. We do not initialize arrays to zero using "={0}" because gcc would compile it to two','line_number':433,'multiline':False]
['text':' instructions while a loop would be compiled to one instruction.','line_number':434,'multiline':False]
['text':' ptr need not to be aligned here. See','line_number':443,'multiline':False]
['text':' https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/intrinsics/intrinsics-for-intel-advanced-vector-extensions/intrinsics-for-load-and-store-operations-1/mm256-storeu-si256.html','line_number':444,'multiline':False]
['text':' Fast path if only load element number of 8.','line_number':682,'multiline':False]
['text':' Note: We didn't merge it as fast path of loadu(const void* ptr, T count),','line_number':683,'multiline':False]
['text':' Because loadu(const void* ptr, T count) requires zero initialization for upper 128 bits.','line_number':684,'multiline':False]
['text':' However, by using _mm256_castsi128_si256, the upper 128 bits of the result are undefined.','line_number':685,'multiline':False]
['text':' TODO<leslie> We can use _mm256_zextsi128_si256 in the furture,','line_number':686,'multiline':False]
['text':' since gcc 9.3 doesn't support it now.','line_number':687,'multiline':False]
['text':' Ensure uninitialized memory does not change the output value See https://github.com/pytorch/pytorch/issues/32502','line_number':693,'multiline':False]
['text':' for more details. We do not initialize arrays to zero using "={0}" because gcc would compile it to two','line_number':694,'multiline':False]
['text':' instructions while a loop would be compiled to one instruction.','line_number':695,'multiline':False]
['text':' ptr need not to be aligned here. See','line_number':704,'multiline':False]
['text':' https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/intrinsics/intrinsics-for-intel-advanced-vector-extensions/intrinsics-for-load-and-store-operations-1/mm256-storeu-si256.html','line_number':705,'multiline':False]
['text':' Fast path if only store element number of 8','line_number':709,'multiline':False]
['text':' Negation. Defined here so we can utilize operator-','line_number':859,'multiline':False]
['text':' Emulate operations with no native 64-bit support in avx,','line_number':880,'multiline':False]
['text':' by extracting each element, performing the operation pointwise,','line_number':881,'multiline':False]
['text':' then combining the results into a vector.','line_number':882,'multiline':False]
['text':' AVX2 has no intrinsic for int64_t multiply so it needs to be emulated','line_number':928,'multiline':False]
['text':' This could be implemented more efficiently using epi32 instructions','line_number':929,'multiline':False]
['text':' This is also technically avx compatible, but then we'll need AVX','line_number':930,'multiline':False]
['text':' code for add as well.','line_number':931,'multiline':False]
['text':' Note: intentionally ignores undefined behavior like (-lowest * -1).','line_number':932,'multiline':False]
['text':' We don't have an instruction for multiplying int8_t','line_number':962,'multiline':False]
['text':' We don't have an instruction for multiplying uint8_t','line_number':968,'multiline':False]
['text':' No vector instruction for shifting int16_t, so emulating it instead.','line_number':1272,'multiline':False]
['text':' Control masks for shuffle operation, treating 256 bits as an','line_number':1274,'multiline':False]
['text':' array of 16-bit elements, and considering pairs of neighboring','line_number':1275,'multiline':False]
['text':' elements.  Specifially, a mask named "ctl_M_N" (M,N in [0,1], and','line_number':1276,'multiline':False]
['text':' M!=N) is set so that shuffle will move element with index M from','line_number':1277,'multiline':False]
['text':' input pair into element with index N in output pair, and element','line_number':1278,'multiline':False]
['text':' with index M in output pair will be set to all 0s.','line_number':1279,'multiline':False]
['text':' Masks for bitwise and operation, treating 256 bits as an array of','line_number':1289,'multiline':False]
['text':' 16-bit elements, and considering them in pairs of neighboring','line_number':1290,'multiline':False]
['text':' elements.  A mask named "keep_M" (M in [0,1]) is set so that','line_number':1291,'multiline':False]
['text':' bitwise and will copy element with index M from input pair into','line_number':1292,'multiline':False]
['text':' element with the same index in output pair, while the other','line_number':1293,'multiline':False]
['text':' element in output pair will be set to all 0s.','line_number':1294,'multiline':False]
['text':' Take each 16-bit element with idx%2==0 from input array to be','line_number':1298,'multiline':False]
['text':' shifted and extend it to 32 bits so that 0s are added to the','line_number':1299,'multiline':False]
['text':' right.  Then, perform shifting on this 32-bit number.  Upper 16','line_number':1300,'multiline':False]
['text':' bits will be proper result of shifting original 16-bit number, so','line_number':1301,'multiline':False]
['text':' write them to result array, into the same position from which','line_number':1302,'multiline':False]
['text':' corresponding input element is taken.  Also, make sure that','line_number':1303,'multiline':False]
['text':' result array elements with idx%2!=0 are set to all 0s.','line_number':1304,'multiline':False]
['text':'','line_number':1305,'multiline':False]
['text':' Note that number of bits to shift for is extended to 32 bits by','line_number':1306,'multiline':False]
['text':' adding 0s to the left.  That means this number is not properly','line_number':1307,'multiline':False]
['text':' sign-extended for negative values.  However, number of bits to','line_number':1308,'multiline':False]
['text':' shift is treated as an unsigned integer by respective shift','line_number':1309,'multiline':False]
['text':' intrinsics anyway so if negative then either with or without','line_number':1310,'multiline':False]
['text':' proper sign extension, it will be interpreted as a number greater','line_number':1311,'multiline':False]
['text':' than 32, and the shifting result will be the same.','line_number':1312,'multiline':False]
['text':' Peform shifting the same way for input array elements with','line_number':1322,'multiline':False]
['text':' idx%2==1.','line_number':1323,'multiline':False]
['text':' Merge partial results into the final result.','line_number':1333,'multiline':False]
['text':' No vector instruction for shifting int8_t/uint8_t, so emulating','line_number':1341,'multiline':False]
['text':' it instead.','line_number':1342,'multiline':False]
['text':' Control masks for shuffle operation, treating 256 bits as an','line_number':1344,'multiline':False]
['text':' array of 8-bit elements, and considering quadruples of','line_number':1345,'multiline':False]
['text':' neighboring elements.  Specifially, a mask named "ctl_M_N" (M,N','line_number':1346,'multiline':False]
['text':' in [0,1,2,3], and M!=N) is set so that shuffle will move element','line_number':1347,'multiline':False]
['text':' with index M from input quadruple into element with index N in','line_number':1348,'multiline':False]
['text':' output quadruple, and other elements in output quadruple will be','line_number':1349,'multiline':False]
['text':' set to all 0s.','line_number':1350,'multiline':False]
['text':' Masks for bitwise and operation, treating 256 bits as an array of','line_number':1384,'multiline':False]
['text':' 8-bit elements, and considering them in quadruples of neighboring','line_number':1385,'multiline':False]
['text':' elements.  A mask named "keep_M" (M in [0,1,2,3]) is set so that','line_number':1386,'multiline':False]
['text':' bitwise and will copy element with index M from input quadruple','line_number':1387,'multiline':False]
['text':' into element with the same index in output quadruple, while the','line_number':1388,'multiline':False]
['text':' other elements in output quadruple will be set to all 0s.','line_number':1389,'multiline':False]
['text':' Take each 8-bit element with idx%4==0 from input array to be','line_number':1393,'multiline':False]
['text':' shifted and extend it to 32 bits so that 0s are added to the','line_number':1394,'multiline':False]
['text':' right.  Then, perform shifting on this 32-bit number.  Upper 8','line_number':1395,'multiline':False]
['text':' bits will be proper result of shifting original 8-bit number, so','line_number':1396,'multiline':False]
['text':' write them to result array, into the same position from which','line_number':1397,'multiline':False]
['text':' corresponding input element is taken.  Also, make sure that','line_number':1398,'multiline':False]
['text':' result array elements with idx%4!=0 are set to all 0s.','line_number':1399,'multiline':False]
['text':'','line_number':1400,'multiline':False]
['text':' Note that number of bits to shift for is extended to 32 bits by','line_number':1401,'multiline':False]
['text':' adding 0s to the left.  That means this number is not properly','line_number':1402,'multiline':False]
['text':' sign-extended for negative values.  However, number of bits to','line_number':1403,'multiline':False]
['text':' shift is treated as an unsigned integer by respective shift','line_number':1404,'multiline':False]
['text':' intrinsics anyway so if negative then either with or without','line_number':1405,'multiline':False]
['text':' proper sign extension, it will be interpreted as a number greater','line_number':1406,'multiline':False]
['text':' than 32, and the shifting result will be the same.','line_number':1407,'multiline':False]
['text':' Peform shifting the same way for input array elements with','line_number':1420,'multiline':False]
['text':' idx%4==1.','line_number':1421,'multiline':False]
['text':' Peform shifting the same way for input array elements with','line_number':1434,'multiline':False]
['text':' idx%4==2.','line_number':1435,'multiline':False]
['text':' Peform shifting the same way for input array elements with','line_number':1448,'multiline':False]
['text':' idx%4==3.','line_number':1449,'multiline':False]
['text':' Merge partial results into the final result.','line_number':1462,'multiline':False]
['text':' No vector instruction for right arithmetic shifting int64_t, so emulating it','line_number':1497,'multiline':False]
['text':' instead.','line_number':1498,'multiline':False]
['text':' Clamp the shift values such that shift values < 0 and > 64 are changed to 64','line_number':1500,'multiline':False]
['text':' which results in -1 for negative input and 0 for non-negative input.','line_number':1501,'multiline':False]
['text':' Shift the number logically to the right, thus filling the most','line_number':1506,'multiline':False]
['text':' significant bits with 0s.  Then, replace these bits with the sign','line_number':1507,'multiline':False]
['text':' bit.','line_number':1508,'multiline':False]
['text':' namespace at::vec::CPU_CAPABILITY','line_number':1540,'multiline':False]
