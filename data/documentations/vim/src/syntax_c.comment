['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]
['text':'
 * syntax.c: code for syntax highlighting
 ','line_number':10,'multiline':True]
['text':' maximum length of a syntax name','line_number':18,'multiline':False]
['text':' different types of offsets that are possible','line_number':20,'multiline':False]
['text':' match  start offset','line_number':21,'multiline':False]
['text':' match  end	offset','line_number':22,'multiline':False]
['text':' highl. start offset','line_number':23,'multiline':False]
['text':' highl. end	offset','line_number':24,'multiline':False]
['text':' region start offset','line_number':25,'multiline':False]
['text':' region end	offset','line_number':26,'multiline':False]
['text':' leading context offset','line_number':27,'multiline':False]
['text':'
 * The patterns that are being searched for are stored in a syn_pattern.
 * A match item consists of one pattern.
 * A start/end item consists of n start patterns and m end patterns.
 * A start/skip/end item consists of n start patterns, one skip pattern and m
 * end patterns.
 * For the latter two, the patterns are always consecutive: start-skip-end.
 *
 * A character offset can be given for the matched text (_m_start and _m_end)
 * and for the actually highlighted text (_h_start and _h_end).
 *
 * Note that ordering of members is optimized to reduce padding.
 ','line_number':33,'multiline':True]
['text':' see SPTYPE_ defines below','line_number':48,'multiline':False]
['text':' this item used for syncing','line_number':49,'multiline':False]
['text':' highlight group ID of pattern','line_number':50,'multiline':False]
['text':' see below','line_number':51,'multiline':False]
['text':' offsets','line_number':52,'multiline':False]
['text':' see HL_ defines below','line_number':53,'multiline':False]
['text':' conceal substitute character','line_number':55,'multiline':False]
['text':' ignore-case flag for sp_prog','line_number':57,'multiline':False]
['text':' sync item index (syncing only)','line_number':58,'multiline':False]
['text':' ID of last line where tried','line_number':59,'multiline':False]
['text':' next match in sp_line_id line','line_number':60,'multiline':False]
['text':' cont. group IDs, if non-zero','line_number':61,'multiline':False]
['text':' next group IDs, if non-zero','line_number':62,'multiline':False]
['text':' struct passed to in_id_list()','line_number':63,'multiline':False]
['text':' regexp to match, pattern','line_number':64,'multiline':False]
['text':' regexp to match, program','line_number':65,'multiline':False]
['text':' The sp_off_flags are computed like this:','line_number':71,'multiline':False]
['text':' offset from the start of the matched text: (1 << SPO_XX_OFF)','line_number':72,'multiline':False]
['text':' offset from the end	 of the matched text: (1 << (SPO_XX_OFF + SPO_COUNT))','line_number':73,'multiline':False]
['text':' When both are present, only one is used.','line_number':74,'multiline':False]
['text':' match keyword with this group ID','line_number':76,'multiline':False]
['text':' match a regexp, start of item','line_number':77,'multiline':False]
['text':' match a regexp, end of item','line_number':78,'multiline':False]
['text':' match a regexp, skip within item','line_number':79,'multiline':False]
['text':' value of sp_sync_idx for "NONE"','line_number':84,'multiline':False]
['text':'
 * Flags for b_syn_sync_flags:
 ','line_number':86,'multiline':True]
['text':' sync on a C-style comment','line_number':89,'multiline':False]
['text':' sync by matching a pattern','line_number':90,'multiline':False]
['text':' maximum length of a keyword','line_number':94,'multiline':False]
['text':'
 * The attributes of the syntax item that has been recognized.
 ','line_number':96,'multiline':True]
['text':' attr of current syntax word','line_number':99,'multiline':False]
['text':' ID of current char for syn_get_id()','line_number':101,'multiline':False]
['text':' idem, transparency removed','line_number':102,'multiline':False]
['text':' syntax cluster name','line_number':112,'multiline':False]
['text':' uppercase of scl_name','line_number':113,'multiline':False]
['text':' IDs in this syntax cluster','line_number':114,'multiline':False]
['text':'
 * Methods of combining two clusters
 ','line_number':117,'multiline':True]
['text':' replace first list with second','line_number':120,'multiline':False]
['text':' add second list to first','line_number':121,'multiline':False]
['text':' subtract second list from first','line_number':122,'multiline':False]
['text':'
 * Syntax group IDs have different types:
 *     0 - 19999  normal syntax groups
 * 20000 - 20999  ALLBUT indicator (current_syn_inc_tag added)
 * 21000 - 21999  TOP indicator (current_syn_inc_tag added)
 * 22000 - 22999  CONTAINED indicator (current_syn_inc_tag added)
 * 23000 - 32767  cluster IDs (subtract SYNID_CLUSTER for the cluster ID)
 ','line_number':126,'multiline':True]
['text':' syntax group ID for contains=ALLBUT','line_number':134,'multiline':False]
['text':' syntax group ID for contains=TOP','line_number':135,'multiline':False]
['text':' syntax group ID for contains=CONTAINED','line_number':136,'multiline':False]
['text':' first syntax group ID for clusters','line_number':137,'multiline':False]
['text':' maximum before the above overflow','line_number':139,'multiline':False]
['text':'
 * Annoying Hack(TM):  ":syn include" needs this pointer to pass to
 * expand_filename().  Most of the other syntax commands don't need it, so
 * instead of passing it to them, we stow it here.
 ','line_number':142,'multiline':True]
['text':'
 * Another Annoying Hack(TM):  To prevent rules from other ":syn include"'d
 * files from leaking into ALLBUT lists, we assign a unique ID to the
 * rules in each ":syn include"'d file.
 ','line_number':149,'multiline':True]
['text':'
 * In a hashtable item "hi_key" points to "keyword" in a keyentry.
 * This avoids adding a pointer to the hashtable item.
 * KE2HIKEY() converts a var pointer to a hashitem key pointer.
 * HIKEY2KE() converts a hashitem key pointer to a var pointer.
 * HI2KE() converts a hashitem pointer to a var pointer.
 ','line_number':157,'multiline':True]
['text':'
 * To reduce the time spent in keepend(), remember at which level in the state
 * stack the first item with "keepend" is present.  When "-1", there is no
 * "keepend" on the stack.
 ','line_number':169,'multiline':True]
['text':'
 * For the current state we need to remember more than just the idx.
 * When si_m_endpos.lnum is 0, the items other than si_idx are unknown.
 * (The end positions have the column number of the next char)
 ','line_number':178,'multiline':True]
['text':' index of syntax pattern or','line_number':185,'multiline':False]
['text':' KEYWORD_IDX','line_number':186,'multiline':False]
['text':' highlight group ID for keywords','line_number':187,'multiline':False]
['text':' idem, transparency removed','line_number':188,'multiline':False]
['text':' lnum of the match','line_number':189,'multiline':False]
['text':' starting column of the match','line_number':190,'multiline':False]
['text':' just after end posn of the match','line_number':191,'multiline':False]
['text':' start position of the highlighting','line_number':192,'multiline':False]
['text':' end position of the highlighting','line_number':193,'multiline':False]
['text':' end position of end pattern','line_number':194,'multiline':False]
['text':' group ID for end pattern or zero','line_number':195,'multiline':False]
['text':' if match ends before si_m_endpos','line_number':196,'multiline':False]
['text':' attributes in this state','line_number':197,'multiline':False]
['text':' HL_HAS_EOL flag in this state, and','line_number':198,'multiline':False]
['text':' HL_SKIP* for si_next_list','line_number':199,'multiline':False]
['text':' sequence number','line_number':201,'multiline':False]
['text':' substitution character for conceal','line_number':202,'multiline':False]
['text':' list of contained groups','line_number':204,'multiline':False]
['text':' nextgroup IDs after this item ends','line_number':205,'multiline':False]
['text':' \z(...\) matches from start','line_number':206,'multiline':False]
['text':' pattern','line_number':207,'multiline':False]
['text':' value of si_idx for keywords','line_number':210,'multiline':False]
['text':' valid of si_cont_list for containing all','line_number':211,'multiline':False]
['text':' but contained groups','line_number':212,'multiline':False]
['text':' value to use for si_seqnr','line_number':215,'multiline':False]
['text':'
 * Struct to reduce the number of arguments to get_syn_options(), it's used
 * very often.
 ','line_number':218,'multiline':True]
['text':' flags for contained and transparent','line_number':224,'multiline':False]
['text':' TRUE for ":syn keyword"','line_number':225,'multiline':False]
['text':' syntax item for "grouphere" argument, NULL','line_number':226,'multiline':False]
['text':' if not allowed','line_number':227,'multiline':False]
['text':' TRUE if "cont_list" can be used','line_number':228,'multiline':False]
['text':' group IDs for "contains" argument','line_number':229,'multiline':False]
['text':' group IDs for "containedin" argument','line_number':230,'multiline':False]
['text':' group IDs for "nextgroup" argument','line_number':231,'multiline':False]
['text':'
 * The next possible match in the current line for any pattern is remembered,
 * to avoid having to try for a match in each column.
 * If next_match_idx == -1, not tried (in this line) yet.
 * If next_match_col == MAXCOL, no match found in this line.
 * (All end positions have the column of the char after the end)
 ','line_number':234,'multiline':True]
['text':' column for start of next match','line_number':241,'multiline':False]
['text':' position for end of next match','line_number':242,'multiline':False]
['text':' pos. for highl. start of next match','line_number':243,'multiline':False]
['text':' pos. for highl. end of next match','line_number':244,'multiline':False]
['text':' index of matched item','line_number':245,'multiline':False]
['text':' flags for next match','line_number':246,'multiline':False]
['text':' end of start pattn (start region)','line_number':247,'multiline':False]
['text':' pos. for end of end pattern','line_number':248,'multiline':False]
['text':' ID of group for end pattn or zero','line_number':249,'multiline':False]
['text':'
 * A state stack is an array of integers or stateitem_T, stored in a
 * garray_T.  A state stack is invalid if its itemsize entry is zero.
 ','line_number':252,'multiline':True]
['text':'
 * The current state (within the line) of the recognition engine.
 * When current_state.ga_itemsize is 0 the current state is invalid.
 ','line_number':262,'multiline':True]
['text':' current window for highlighting','line_number':266,'multiline':False]
['text':' current buffer for highlighting','line_number':267,'multiline':False]
['text':' current buffer for highlighting','line_number':268,'multiline':False]
['text':' lnum of current state','line_number':269,'multiline':False]
['text':' column of current state','line_number':270,'multiline':False]
['text':' TRUE if stored current state','line_number':271,'multiline':False]
['text':' after setting current_finished','line_number':272,'multiline':False]
['text':' current line has been finished','line_number':273,'multiline':False]
['text':' current stack of state_items','line_number':274,'multiline':False]
['text':' when non-zero, nextgroup list','line_number':276,'multiline':False]
['text':' flags for current_next_list','line_number':277,'multiline':False]
['text':' unique number for current line','line_number':278,'multiline':False]
['text':'
 * Start the syntax recognition for a line.  This function is normally called
 * from the screen updating, once for each displayed line.
 * The buffer is remembered in syn_buf, because get_syntax_attr() doesn't get
 * it.	Careful: curbuf and curwin are likely to point to another buffer and
 * window.
 ','line_number':350,'multiline':True]
['text':' remember the last change ID','line_number':367,'multiline':False]
['text':'
     * After switching buffers, invalidate current_state.
     * Also do this when a change was made, the current state may be invalid
     * then.
     ','line_number':373,'multiline':True]
['text':'
     * Allocate syntax stack when needed.
     ','line_number':389,'multiline':True]
['text':' out of memory','line_number':394,'multiline':False]
['text':'
     * If the state of the end of the previous line is useful, store it.
     ','line_number':397,'multiline':True]
['text':'
	 * If the current_lnum is now the same as "lnum", keep the current
	 * state (this happens very often!).  Otherwise invalidate
	 * current_state and figure it out below.
	 ','line_number':411,'multiline':True]
['text':'
     * Try to synchronize from a saved state in b_sst_array[].
     * Only do this if lnum is not before and not to far beyond a saved state.
     ','line_number':422,'multiline':True]
['text':' Find last valid saved state before start_lnum.','line_number':428,'multiline':False]
['text':'
     * If "lnum" is before or far beyond a line with a saved state, need to
     * re-synchronize.
     ','line_number':444,'multiline':True]
['text':' First line is always valid, no matter "minlines".','line_number':452,'multiline':False]
['text':' Need to parse "minlines" lines before state can be considered','line_number':455,'multiline':False]
['text':' valid to store.','line_number':456,'multiline':False]
['text':'
     * Advance from the sync point or saved state until the current line.
     * Save some entries for syncing with later on.
     ','line_number':462,'multiline':True]
['text':' If we parsed at least "minlines" lines or started at a valid','line_number':476,'multiline':False]
['text':' state, the current state is considered valid.','line_number':477,'multiline':False]
['text':' Check if the saved state entry is for the current line and is','line_number':480,'multiline':False]
['text':' equal to the current state.  If so, then validate all saved','line_number':481,'multiline':False]
['text':' states that depended on a change before the parsed line.','line_number':482,'multiline':False]
['text':' valid state before desired line, use this one','line_number':500,'multiline':False]
['text':' past saved states depending on change, break here.','line_number':503,'multiline':False]
['text':' Store the state at this line when it's the first one, the line','line_number':510,'multiline':False]
['text':' where we start parsing, or some distance from the previously','line_number':511,'multiline':False]
['text':' saved state.  But only when parsed at least 'minlines'.','line_number':512,'multiline':False]
['text':' This can take a long time: break when CTRL-C pressed.  The current','line_number':519,'multiline':False]
['text':' state will be wrong then.','line_number':520,'multiline':False]
['text':'
 * We cannot simply discard growarrays full of state_items or buf_states; we
 * have to manually release their extmatch pointers first.
 ','line_number':532,'multiline':True]
['text':'
 * Cleanup the current_state stack.
 ','line_number':556,'multiline':True]
['text':'
 * Try to find a synchronisation point for line "lnum".
 *
 * This sets current_lnum and the current state.  One of three methods is
 * used:
 * 1. Search backwards for the end of a C-comment.
 * 2. Search backwards for given sync patterns.
 * 3. Simply start on a given number of lines above "lnum".
 ','line_number':571,'multiline':True]
['text':'
     * Clear any current state that might be hanging around.
     ','line_number':604,'multiline':True]
['text':'
     * Start at least "minlines" back.  Default starting point for parsing is
     * there.
     * Start further back, to avoid that scrolling backwards will result in
     * resyncing for every line.  Now it resyncs only one out of N lines,
     * where N is minlines * 1.5, or minlines * 2 if minlines is small.
     * Watch out for overflow when minlines is MAXLNUM.
     ','line_number':609,'multiline':True]
['text':'
     * 1. Search backwards for the end of a C-style comment.
     ','line_number':637,'multiline':True]
['text':' Need to make syn_buf the current buffer for a moment, to be able to','line_number':642,'multiline':False]
['text':' use find_start_comment().','line_number':643,'multiline':False]
['text':'
	 * Skip lines that end in a backslash.
	 ','line_number':649,'multiline':True]
['text':' set cursor to start of search','line_number':660,'multiline':False]
['text':'
	 * If the line is inside a comment, need to find the syntax item that
	 * defines the comment.
	 * Restrict the search for the end of a comment to b_syn_sync_maxlines.
	 ','line_number':665,'multiline':True]
['text':' restore cursor and buffer','line_number':684,'multiline':False]
['text':'
     * 2. Search backwards for given sync patterns.
     ','line_number':690,'multiline':True]
['text':' This can take a long time: break when CTRL-C pressed.','line_number':707,'multiline':False]
['text':' Check if we have run into a valid saved state stack now.','line_number':716,'multiline':False]
['text':'
	     * Check if the previous line has the line-continuation pattern.
	     ','line_number':723,'multiline':True]
['text':'
	     * Start with nothing on the state stack
	     ','line_number':729,'multiline':True]
['text':'
		     * When a sync point has been found, remember where, and
		     * continue to look for another one, further on in the line.
		     ','line_number':740,'multiline':True]
['text':' ignore match that goes to after where started','line_number':749,'multiline':False]
['text':' Cannot happen?','line_number':755,'multiline':False]
['text':'
			 * Continue after the match (be aware of a zero-length
			 * match).
			 ','line_number':768,'multiline':True]
['text':' syn_current_attr() will have skipped the check for','line_number':784,'multiline':False]
['text':' an item that ends here, need to do that now.  Be','line_number':785,'multiline':False]
['text':' careful not to go past the NUL.','line_number':786,'multiline':False]
['text':'
	     * If a sync point was encountered, break here.
	     ','line_number':798,'multiline':True]
['text':'
		 * Put the item that was specified by the sync point on the
		 * state stack.  If there was no item specified, make the
		 * state stack empty.
		 ','line_number':803,'multiline':True]
['text':'
		 * When using "grouphere", continue from the sync point
		 * match, until the end of the line.  Parsing starts at
		 * the next line.
		 * For "groupthere" the parsing starts at start_lnum.
		 ','line_number':813,'multiline':True]
['text':' Ran into start of the file or exceeded maximum number of lines','line_number':844,'multiline':False]
['text':'
 * Return TRUE if the line-continuation pattern matches in line "lnum".
 ','line_number':872,'multiline':True]
['text':' chartab array for syn iskyeyword','line_number':880,'multiline':False]
['text':' use syntax iskeyword option','line_number':885,'multiline':False]
['text':'
 * Prepare the current state for the start of a line.
 ','line_number':896,'multiline':True]
['text':'
     * Need to update the end of a start/skip/end that continues from the
     * previous line and regions that have "keepend".
     ','line_number':905,'multiline':True]
['text':'
 * Check for items in the stack that need their end updated.
 * When "startofline" is TRUE the last item is always updated.
 * When "startofline" is FALSE the item with "keepend" is forcefully updated.
 ','line_number':922,'multiline':True]
['text':' Check for a match carried over from a previous line with a','line_number':936,'multiline':False]
['text':' contained region.  The match ends as soon as the region ends.','line_number':937,'multiline':False]
['text':'
     * Need to update the end of a start/skip/end that continues from the
     * previous line.  And regions that have "keepend", because they may
     * influence contained items.  If we've just removed "extend"
     * (startofline == 0) then we should update ends of normal regions
     * contained inside "keepend" because "extend" could have extended
     * these "keepend" regions as well as contained normal regions.
     * Then check for items ending in column 0.
     ','line_number':955,'multiline':True]
['text':' start highl. in col 0','line_number':978,'multiline':False]
['text':'///////////////////////////////////////','line_number':991,'multiline':False]
['text':' Handling of the state stack cache.','line_number':992,'multiline':False]
['text':'
 * EXPLANATION OF THE SYNTAX STATE STACK CACHE
 *
 * To speed up syntax highlighting, the state stack for the start of some
 * lines is cached.  These entries can be used to start parsing at that point.
 *
 * The stack is kept in b_sst_array[] for each buffer.  There is a list of
 * valid entries.  b_sst_first points to the first one, then follow sst_next.
 * The entries are sorted on line number.  The first entry is often for line 2
 * (line 1 always starts with an empty stack).
 * There is also a list for free entries.  This construction is used to avoid
 * having to allocate and free memory blocks too often.
 *
 * When making changes to the buffer, this is logged in b_mod_*.  When calling
 * update_screen() to update the display, it will call
 * syn_stack_apply_changes() for each displayed buffer to adjust the cached
 * entries.  The entries which are inside the changed area are removed,
 * because they must be recomputed.  Entries below the changed have their line
 * number adjusted for deleted/inserted lines, and have their sst_change_lnum
 * set to indicate that a check must be made if the changed lines would change
 * the cached entry.
 *
 * When later displaying lines, an entry is stored for each line.  Displayed
 * lines are likely to be displayed again, in which case the state at the
 * start of the line is needed.
 * For not displayed lines, an entry is stored for every so many lines.  These
 * entries will be used e.g., when scrolling backwards.  The distance between
 * entries depends on the number of lines in the buffer.  For small buffers
 * the distance is fixed at SST_DIST, for large buffers there is a fixed
 * number of entries SST_MAX_ENTRIES, and the distance is computed.
 ','line_number':994,'multiline':True]
['text':'
 * Free b_sst_array[] for buffer "buf".
 * Used when syntax items changed to force resyncing everywhere.
 ','line_number':1040,'multiline':True]
['text':' When using "syntax" fold method, must update all folds.','line_number':1054,'multiline':False]
['text':'
 * Allocate the syntax state stack for syn_buf when needed.
 * If the number of entries in b_sst_array[] is much too big or a bit too
 * small, reallocate it.
 * Also used to allocate b_sst_array[] for the first time.
 ','line_number':1063,'multiline':True]
['text':' Allocate 50% too much, to avoid reallocating too often.','line_number':1083,'multiline':False]
['text':' When shrinking the array, cleanup the existing stack.','line_number':1093,'multiline':False]
['text':' Make sure that all valid entries fit in the new array.','line_number':1094,'multiline':False]
['text':' out of memory!','line_number':1103,'multiline':False]
['text':' Move the states from the old array to the new one.','line_number':1109,'multiline':False]
['text':' Create the list of free entries.','line_number':1130,'multiline':False]
['text':'
 * Check for changes in a buffer to affect stored syntax states.  Uses the
 * b_mod_* fields.
 * Called from update_screen(), before screen is being updated, once for each
 * displayed buffer.
 ','line_number':1142,'multiline':True]
['text':' this state is inside the changed area, remove it','line_number':1176,'multiline':False]
['text':' This state is below the changed area.  Remember the line','line_number':1186,'multiline':False]
['text':' that needs to be parsed before this entry can be made valid','line_number':1187,'multiline':False]
['text':' again.','line_number':1188,'multiline':False]
['text':'
 * Reduce the number of entries in the state stack for syn_buf.
 * Returns TRUE if at least one entry was freed.
 ','line_number':1207,'multiline':True]
['text':' Compute normal distance between non-displayed entries.','line_number':1223,'multiline':False]
['text':'
     * Go through the list to find the "tick" for the oldest entry that can
     * be removed.  Set "above" when the "tick" for the oldest entry is above
     * "b_sst_lasttick" (the display tick wraps around).
     ','line_number':1229,'multiline':True]
['text':'
     * Go through the list to make the entries for the oldest tick at an
     * interval of several lines.
     ','line_number':1252,'multiline':True]
['text':' Move this entry from used list to free list','line_number':1261,'multiline':False]
['text':'
 * Free the allocated memory for a syn_state item.
 * Move the entry into the free list.
 ','line_number':1271,'multiline':True]
['text':'
 * Find an entry in the list of state stacks at or before "lnum".
 * Returns NULL when there is no entry or the first entry is after "lnum".
 ','line_number':1284,'multiline':True]
['text':'
 * Try saving the current state in b_sst_array[].
 * The current state must be valid for the start of the current_lnum line!
 ','line_number':1304,'multiline':True]
['text':'
     * If the current state contains a start or end pattern that continues
     * from the previous line, we can't use it.  Don't store it then.
     ','line_number':1317,'multiline':True]
['text':' find "sp" in the list and remove it','line_number':1335,'multiline':False]
['text':' it's the first entry','line_number':1337,'multiline':False]
['text':' find the entry just before this one to adjust sst_next','line_number':1341,'multiline':False]
['text':' just in case','line_number':1345,'multiline':False]
['text':'
	 * Add a new entry
	 ','line_number':1354,'multiline':True]
['text':' If no free items, cleanup the array first.','line_number':1357,'multiline':False]
['text':' "sp" may have been moved to the freelist now','line_number':1361,'multiline':False]
['text':' Still no free items?  Must be a strange problem...','line_number':1364,'multiline':False]
['text':' Take the first item from the free list and put it in the used','line_number':1369,'multiline':False]
['text':' list, after *sp','line_number':1370,'multiline':False]
['text':' Insert in front of the list','line_number':1376,'multiline':False]
['text':' insert in list after *sp','line_number':1382,'multiline':False]
['text':' When overwriting an existing state stack, clear it first','line_number':1393,'multiline':False]
['text':' Need to clear it, might be something remaining from when the','line_number':1398,'multiline':False]
['text':' length was less than SST_FIX_STATES.','line_number':1399,'multiline':False]
['text':'
 * Copy a state stack from "from" in b_sst_array[] to current_state;
 ','line_number':1428,'multiline':True]
['text':'
 * Compare saved state stack "*sp" with the current state.
 * Return TRUE when they are equal.
 ','line_number':1474,'multiline':True]
['text':' First a quick check if the stacks have the same size end nextlist.','line_number':1485,'multiline':False]
['text':' Need to compare all states on both stacks.','line_number':1490,'multiline':False]
['text':' If the item has another index the state is different.','line_number':1498,'multiline':False]
['text':' When the extmatch pointers are different, the strings in them can','line_number':1503,'multiline':False]
['text':' still be the same.  Check if the extmatch references are equal.','line_number':1504,'multiline':False]
['text':' If one of the extmatch pointers is NULL the states are different.','line_number':1507,'multiline':False]
['text':' Check each referenced match string. They must all be equal.','line_number':1512,'multiline':False]
['text':' If the pointer is different it can still be the same text.','line_number':1515,'multiline':False]
['text':' Compare the strings, ignore case when the start item has the','line_number':1516,'multiline':False]
['text':' sp_ic flag set.','line_number':1517,'multiline':False]
['text':'
 * We stop parsing syntax above line "lnum".  If the stored state at or below
 * this line depended on a change before it, it now depends on the line below
 * the last parsed line.
 * The window looks like this:
 *	    line which changed
 *	    displayed line
 *	    displayed line
 * lnum ->  line below window
 ','line_number':1532,'multiline':True]
['text':' not the right window','line_number':1548,'multiline':False]
['text':'
 * End of handling of the state stack.
 ***************************************','line_number':1557,'multiline':True]
['text':' mark current_state invalid','line_number':1565,'multiline':False]
['text':'
 * Return TRUE if the syntax at start of lnum changed since last time.
 * This will only be called just after get_syntax_attr() for the previous
 * line, to check if the next line needs to be redrawn too.
 ','line_number':1577,'multiline':True]
['text':'
     * Check the state stack when:
     * - lnum is just below the previously syntaxed line.
     * - lnum is not before the lines with saved states.
     * - lnum is not past the lines with saved states.
     * - lnum is at or before the last changed line.
     ','line_number':1588,'multiline':True]
['text':'
	     * finish the previous line (needed when not all of the line was
	     * drawn)
	     ','line_number':1600,'multiline':True]
['text':'
	     * Compare the current state with the previously saved state of
	     * the line.
	     ','line_number':1606,'multiline':True]
['text':'
	     * Store the current state in b_sst_array[] for later use.
	     ','line_number':1613,'multiline':True]
['text':'
 * Finish the current line.
 * This doesn't return any attributes, it only gets the state at the end of
 * the line.  It can start anywhere in the line, as long as the current state
 * is valid.
 ','line_number':1624,'multiline':True]
['text':' called for syncing','line_number':1632,'multiline':False]
['text':'
	 * When syncing, and found some item, need to check the item.
	 ','line_number':1640,'multiline':True]
['text':'
	     * Check for match with sync item.
	     ','line_number':1645,'multiline':True]
['text':' syn_current_attr() will have skipped the check for an item','line_number':1654,'multiline':False]
['text':' that ends here, need to do that now.  Be careful not to go','line_number':1655,'multiline':False]
['text':' past the NUL.','line_number':1656,'multiline':False]
['text':'
 * Return highlight attributes for next character.
 * Must first call syntax_start() once for the line.
 * "col" is normally 0 for the first use in a line, and increments by one each
 * time.  It's allowed to skip characters and to stop before the end of the
 * line.  But only a "col" after a previously used column is allowed.
 * When "can_spell" is not NULL set it to TRUE when spell-checking should be
 * done.
 ','line_number':1668,'multiline':True]
['text':' keep state of char at "col"','line_number':1681,'multiline':False]
['text':' Default: Only do spelling when there is no @Spell cluster or when','line_number':1686,'multiline':False]
['text':' ":syn spell toplevel" was used.','line_number':1687,'multiline':False]
['text':' check for out of memory situation','line_number':1692,'multiline':False]
['text':' After 'synmaxcol' the attribute is always zero.','line_number':1696,'multiline':False]
['text':' Make sure current_state is valid','line_number':1711,'multiline':False]
['text':'
     * Skip from the current column to "col", get the attributes for "col".
     ','line_number':1715,'multiline':True]
['text':'
 * Get syntax attributes for current_lnum, current_col.
 ','line_number':1728,'multiline':True]
['text':' When 1: called for syncing','line_number':1733,'multiline':False]
['text':' result will be displayed','line_number':1734,'multiline':False]
['text':' return: do spell checking','line_number':1735,'multiline':False]
['text':' keep syntax stack afterwards','line_number':1736,'multiline':False]
['text':' was: char_u *endp;','line_number':1739,'multiline':False]
['text':' was: int hl_startcol;','line_number':1740,'multiline':False]
['text':' end-of-start match (start region)','line_number':1742,'multiline':False]
['text':' end-of-end pattern','line_number':1743,'multiline':False]
['text':' group ID for end pattern','line_number':1744,'multiline':False]
['text':' found usable match','line_number':1753,'multiline':False]
['text':' must try in next col','line_number':1754,'multiline':False]
['text':' chartab array for syn iskyeyword','line_number':1760,'multiline':False]
['text':' current line.  NOTE: becomes invalid after','line_number':1761,'multiline':False]
['text':' looking for a pattern match!','line_number':1762,'multiline':False]
['text':' variables for zero-width matches that have a "nextgroup" argument','line_number':1764,'multiline':False]
['text':'
     * No character, no attributes!  Past end of line?
     * Do try matching with an empty line (could be the start of a region).
     ','line_number':1769,'multiline':True]
['text':'
	 * If we found a match after the last column, use it.
	 ','line_number':1776,'multiline':True]
['text':' if the current or next character is NUL, we will finish the line now','line_number':1788,'multiline':False]
['text':'
     * When in the previous column there was a match but it could not be used
     * (empty match or already matched in this column) need to try again in
     * the next column.
     ','line_number':1795,'multiline':True]
['text':' Only check for keywords when not syncing and there are some.','line_number':1806,'multiline':False]
['text':' Init the list of zero-width matches with a nextlist.  This is used to','line_number':1811,'multiline':False]
['text':' avoid matching the same item in the same position twice.','line_number':1812,'multiline':False]
['text':' use syntax iskeyword option','line_number':1815,'multiline':False]
['text':'
     * Repeat matching keywords and patterns, to find contained items at the
     * same column.  This stops when there are no extra matches at the current
     * column.
     ','line_number':1818,'multiline':True]
['text':'
	 * 1. Check for a current state.
	 *    Only when there is no current state, or if the current state may
	 *    contain other things, we need to check for keywords and patterns.
	 *    Always need to check for contained items if some item has the
	 *    "containedin" argument (takes extra time!).
	 ','line_number':1830,'multiline':True]
['text':'
	     * 2. Check for keywords, if on a keyword char after a non-keyword
	     *	  char.  Don't do this when syncing.
	     ','line_number':1845,'multiline':True]
['text':' starts right away','line_number':1869,'multiline':False]
['text':'
	     * 3. Check for patterns (only if no keyword found).
	     ','line_number':1914,'multiline':True]
['text':'
		 * If we didn't check for a match yet, or we are past it, check
		 * for any match with a pattern.
		 ','line_number':1919,'multiline':True]
['text':'
		     * Check all relevant patterns for a match at this
		     * position.  This is complicated, because matching with a
		     * pattern takes quite a bit of time, thus we want to
		     * avoid doing it when it's not needed.
		     ','line_number':1925,'multiline':True]
['text':' no match in this line yet','line_number':1931,'multiline':False]
['text':' If we already tried matching in this line, and','line_number':1951,'multiline':False]
['text':' there isn't a match before next_match_col, skip','line_number':1952,'multiline':False]
['text':' this item.','line_number':1953,'multiline':False]
['text':' no match in this line, try another one','line_number':1972,'multiline':False]
['text':'
			     * Compute the first column of the match.
			     ','line_number':1977,'multiline':True]
['text':' must have used end of match in a next line,','line_number':1984,'multiline':False]
['text':' we can't handle that','line_number':1985,'multiline':False]
['text':' remember the next column where this pattern','line_number':1991,'multiline':False]
['text':' matches in the current line','line_number':1992,'multiline':False]
['text':'
			     * If a previously found match starts at a lower
			     * column number, don't use this one.
			     ','line_number':1995,'multiline':True]
['text':'
			     * If we matched this pattern at this position
			     * before, skip it.  Must retry in the next
			     * column, because it may match from there.
			     ','line_number':2002,'multiline':True]
['text':' Compute the highlight start.','line_number':2016,'multiline':False]
['text':' Compute the region start.','line_number':2020,'multiline':False]
['text':' Default is to use the end of the match.','line_number':2021,'multiline':False]
['text':'
			     * Grab the external submatches before they get
			     * overwritten.  Reference count doesn't change.
			     ','line_number':2025,'multiline':True]
['text':' avoid warning','line_number':2034,'multiline':False]
['text':'
			     * For a "oneline" the end must be found in the
			     * same line too.  Search for it after the end of
			     * the match with the start pattern.  Set the
			     * resulting end positions at the same time.
			     ','line_number':2039,'multiline':True]
['text':' not found','line_number':2054,'multiline':False]
['text':'
			     * For a "match" the size must be > 0 after the
			     * end offset needs has been added.  Except when
			     * syncing.
			     ','line_number':2057,'multiline':True]
['text':'
				     * If an empty string is matched, may need
				     * to try matching again at next column.
				     ','line_number':2071,'multiline':True]
['text':'
			     * keep the best match so far in next_match_*
			     ','line_number':2082,'multiline':True]
['text':' Highlighting must start after startpos and end','line_number':2085,'multiline':False]
['text':' before endpos.','line_number':2086,'multiline':False]
['text':'
		 * If we found a match at the current column, use it.
		 ','line_number':2108,'multiline':True]
['text':' When a zero-width item matched which has a nextgroup,','line_number':2115,'multiline':False]
['text':' don't push the item but set nextgroup.','line_number':2116,'multiline':False]
['text':' Add the index to a list, so that we can check','line_number':2127,'multiline':False]
['text':' later that we don't match it again (and cause an','line_number':2128,'multiline':False]
['text':' endless loop).','line_number':2129,'multiline':False]
['text':'
	 * Handle searching for nextgroup match.
	 ','line_number':2144,'multiline':True]
['text':'
	     * If a nextgroup was not found, continue looking for one if:
	     * - this is an empty line and the "skipempty" option was given
	     * - we are on white space and the "skipwhite" option was given
	     ','line_number':2149,'multiline':True]
['text':'
	     * If a nextgroup was found: Use it, and continue looking for
	     * contained matches.
	     * If a nextgroup was not found: Continue looking for a normal
	     * match.
	     * When did set current_next_list for a zero-width item and no
	     * match was found don't loop (would get stuck).
	     ','line_number':2164,'multiline':True]
['text':'
     * Use attributes from the current state, if within its highlighting.
     * If not, use attributes from the current-but-one state, etc.
     ','line_number':2182,'multiline':True]
['text':'
	     * set "can_spell" to TRUE if spell checking is supposed to be
	     * done in the current item.
	     ','line_number':2229,'multiline':True]
['text':' There is no @Spell cluster: Do spelling for items without','line_number':2235,'multiline':False]
['text':' @NoSpell cluster.','line_number':2236,'multiline':False]
['text':' The @Spell cluster is defined: Do spelling in items with','line_number':2250,'multiline':False]
['text':' the @Spell cluster.  But not when @NoSpell is also there.','line_number':2251,'multiline':False]
['text':' At the toplevel only spell check when ":syn spell toplevel"','line_number':2252,'multiline':False]
['text':' was used.','line_number':2253,'multiline':False]
['text':'
	 * Check for end of current state (and the states before it) at the
	 * next column.  Don't do this for syncing, because we would miss a
	 * single character match.
	 * First check if the current state ends at the current column.  It
	 * may be for an empty match and a containing item might end in the
	 * current column.
	 ','line_number':2274,'multiline':True]
['text':' Default: Only do spelling when there is no @Spell cluster or when','line_number':2295,'multiline':False]
['text':' ":syn spell toplevel" was used.','line_number':2296,'multiline':False]
['text':' nextgroup ends at end of line, unless "skipnl" or "skipempty" present','line_number':2301,'multiline':False]
['text':' No longer need external matches.  But keep next_match_extmatch.','line_number':2311,'multiline':False]
['text':'
 * Check if we already matched pattern "idx" at the current column.
 ','line_number':2320,'multiline':True]
['text':' Zero-width matches with a nextgroup argument are not put on the syntax','line_number':2334,'multiline':False]
['text':' stack, and can only be matched once anyway.','line_number':2335,'multiline':False]
['text':'
 * Push the next match onto the stack.
 ','line_number':2343,'multiline':True]
['text':'
     * Push the item in current_state stack;
     ','line_number':2356,'multiline':True]
['text':'
	 * If it's a start-skip-end type that crosses lines, figure out how
	 * much it continues in this line.  Otherwise just fill in the length.
	 ','line_number':2361,'multiline':True]
['text':' Try to find the end pattern in the current line','line_number':2381,'multiline':False]
['text':'
	 * If the start pattern has another highlight group, push another item
	 * on the stack for the start pattern.
	 ','line_number':2402,'multiline':True]
['text':' try other match next time','line_number':2431,'multiline':False]
['text':'
 * Check for end of current state (and the states before it).
 ','line_number':2436,'multiline':True]
['text':'
	     * If there is an end pattern group ID, highlight the end pattern
	     * now.  No need to pop the current item from the stack.
	     * Only do this if the end pattern continues beyond the current
	     * position.
	     ','line_number':2453,'multiline':True]
['text':' nextgroup= should not match in the end pattern','line_number':2476,'multiline':False]
['text':' what matches next may be different now, clear it','line_number':2479,'multiline':False]
['text':' handle next_list, unless at end of line and no "skipnl" or','line_number':2485,'multiline':False]
['text':' "skipempty"','line_number':2486,'multiline':False]
['text':' When the ended item has "extend", another item with','line_number':2493,'multiline':False]
['text':' "keepend" now needs to check for its end.','line_number':2494,'multiline':False]
['text':'
	     * Only for a region the search for the end continues after
	     * the end of the contained item.  If the contained match
	     * included the end-of-line, break here, the region continues.
	     * Don't do this when:
	     * - "keepend" is used for the contained item
	     * - not at the end of the line (could be end="x$"me=e-1).
	     * - "excludenl" is used (HL_HAS_EOL won't be set)
	     ','line_number':2511,'multiline':True]
['text':'
 * Update an entry in the current_state stack for a match or region.  This
 * fills in si_attr, si_next_list and si_cont_list.
 ','line_number':2538,'multiline':True]
['text':' This should not happen...','line_number':2548,'multiline':False]
['text':'
     * For transparent items, take attr from outer item.
     * Also take cont_list, if there is none.
     * Don't do this for the matchgroup of a start or end pattern.
     ','line_number':2564,'multiline':True]
['text':'
 * Check the current stack for patterns with "keepend" flag.
 * Propagate the match-end to contained items, until a "skipend" item is found.
 ','line_number':2591,'multiline':True]
['text':'
     * This check can consume a lot of time; only do it from the level where
     * there really is a keepend.
     ','line_number':2603,'multiline':True]
['text':'
     * Find the last index of an "extend" item.  "keepend" items before that
     * won't do anything.  If there is no "extend" item "i" will be
     * "keepend_level" and all "keepend" items will work normally.
     ','line_number':2610,'multiline':True]
['text':'
 * Update an entry in the current_state stack for a start-skip-end pattern.
 * This finds the end of the current item, if it's in the current line.
 *
 * Return the flags for the matched END.
 ','line_number':2649,'multiline':True]
['text':' where to start searching for the end','line_number':2658,'multiline':False]
['text':' when TRUE overrule a previous end','line_number':2659,'multiline':False]
['text':' return quickly for a keyword','line_number':2667,'multiline':False]
['text':' Don't update when it's already done.  Can be a match of an end pattern','line_number':2671,'multiline':False]
['text':' that started in a previous line.  Watch out: can also be a "keepend"','line_number':2672,'multiline':False]
['text':' from a containing item.','line_number':2673,'multiline':False]
['text':'
     * We need to find the end of the region.  It may continue in the next
     * line.
     ','line_number':2677,'multiline':True]
['text':' No end pattern matched.','line_number':2689,'multiline':False]
['text':' a "oneline" never continues in the next line','line_number':2692,'multiline':False]
['text':' continues in the next line','line_number':2699,'multiline':False]
['text':' match within this line','line_number':2707,'multiline':False]
['text':'
 * Add a new state to the current state stack.
 * It is cleared and the index set to "idx".
 * Return FAIL if it's not possible (out of memory).
 ','line_number':2716,'multiline':True]
['text':'
 * Remove a state from the current_state stack.
 ','line_number':2732,'multiline':True]
['text':' after the end of a pattern, try matching a keyword or pattern','line_number':2743,'multiline':False]
['text':' if first state with "keepend" is popped, reset keepend_level','line_number':2746,'multiline':False]
['text':'
 * Find the end of a start/skip/end syntax region after "startpos".
 * Only checks one line.
 * Also handles a match item that continued from a previous line.
 * If not found, the syntax item continues in the next line.  m_endpos->lnum
 * will be 0.
 * If found, the end of the region and the end of the highlighting is
 * computed.
 ','line_number':2751,'multiline':True]
['text':' index of the pattern','line_number':2762,'multiline':False]
['text':' where to start looking for an END match','line_number':2763,'multiline':False]
['text':' return: end of match','line_number':2764,'multiline':False]
['text':' return: end of highlighting','line_number':2765,'multiline':False]
['text':' return: flags of matching END','line_number':2766,'multiline':False]
['text':' return: end of end pattern match','line_number':2767,'multiline':False]
['text':' return: group ID for end pat. match, or 0','line_number':2768,'multiline':False]
['text':' submatches from the start pattern','line_number':2769,'multiline':False]
['text':' startpos/endpos of best match','line_number':2776,'multiline':False]
['text':' chartab array for syn option iskyeyword','line_number':2780,'multiline':False]
['text':' just in case we are invoked for a keyword','line_number':2782,'multiline':False]
['text':'
     * Check for being called with a START pattern.
     * Can happen with a match that continues to the next line, because it
     * contained a region.
     ','line_number':2786,'multiline':True]
['text':'
     * Find the SKIP or first END pattern after the last START pattern.
     ','line_number':2798,'multiline':True]
['text':'
     *	Lookup the SKIP pattern (if present)
     ','line_number':2809,'multiline':True]
['text':' Setup external matches for syn_regexec().','line_number':2820,'multiline':False]
['text':' start looking for a match at sstart','line_number':2824,'multiline':False]
['text':' remember the first END pattern.','line_number':2825,'multiline':False]
['text':' avoid compiler warning','line_number':2826,'multiline':False]
['text':' use syntax iskeyword option','line_number':2828,'multiline':False]
['text':'
	 * Find end pattern that matches first after "matchcol".
	 ','line_number':2833,'multiline':True]
['text':' past last END pattern','line_number':2843,'multiline':False]
['text':'
	 * If all end patterns have been tried, and there is no match, the
	 * item continues until end-of-line.
	 ','line_number':2866,'multiline':True]
['text':'
	 * If the skip pattern matches before the end pattern,
	 * continue searching after the skip pattern.
	 ','line_number':2873,'multiline':True]
['text':' Add offset to skip pattern match','line_number':2894,'multiline':False]
['text':' If the skip pattern goes on to the next line, there is no','line_number':2897,'multiline':False]
['text':' match with an end pattern in this line.','line_number':2898,'multiline':False]
['text':' take care of an empty match or negative offset','line_number':2905,'multiline':False]
['text':' Be careful not to jump over the NUL at the end-of-line','line_number':2911,'multiline':False]
['text':' if the skip pattern includes end-of-line, break here','line_number':2917,'multiline':False]
['text':' start with first end pattern again','line_number':2921,'multiline':False]
['text':'
	 * Match from start pattern to end pattern.
	 * Correct for match and highlight offset of end pattern.
	 ','line_number':2925,'multiline':True]
['text':' can't end before the start','line_number':2931,'multiline':False]
['text':' can't end before the start','line_number':2936,'multiline':False]
['text':' can't end after the match','line_number':2940,'multiline':False]
['text':'
	 * If the end group is highlighted differently, adjust the pointers.
	 ','line_number':2943,'multiline':True]
['text':' can't end before the start','line_number':2961,'multiline':False]
['text':' now the match ends where the highlighting ends, it is turned','line_number':2967,'multiline':False]
['text':' into the matchgroup for the end','line_number':2968,'multiline':False]
['text':' no match for an END pattern in this line','line_number':2983,'multiline':False]
['text':' Remove external matches.','line_number':2989,'multiline':False]
['text':'
 * Limit "pos" not to be after "limit".
 ','line_number':2994,'multiline':True]
['text':'
 * Limit "pos" not to be after "limit", unless pos->lnum is zero.
 ','line_number':3006,'multiline':True]
['text':'
 * Add offset to matched text for end of match or highlight.
 ','line_number':3020,'multiline':True]
['text':' returned position','line_number':3025,'multiline':False]
['text':' start/end of match','line_number':3026,'multiline':False]
['text':' matched pattern','line_number':3027,'multiline':False]
['text':' index of offset','line_number':3028,'multiline':False]
['text':' extra chars for offset to start','line_number':3029,'multiline':False]
['text':' Don't go past the end of the line.  Matters for "rs=e+2" when there','line_number':3048,'multiline':False]
['text':' is a matchgroup. Watch out for match with last NL in the buffer.','line_number':3049,'multiline':False]
['text':'
 * Add offset to matched text for start of match or highlight.
 * Avoid resulting column to become negative.
 ','line_number':3071,'multiline':True]
['text':' returned position','line_number':3077,'multiline':False]
['text':' start/end of match','line_number':3078,'multiline':False]
['text':' extra chars for offset to end','line_number':3081,'multiline':False]
['text':' a "\n" at the end of the pattern may take us below the last line','line_number':3102,'multiline':False]
['text':'
 * Get current line in syntax buffer.
 ','line_number':3125,'multiline':True]
['text':'
 * Call vim_regexec() to find a match with "rmp" in "syn_buf".
 * Returns TRUE when there is a match.
 ','line_number':3134,'multiline':True]
['text':' This can happen if a previous call to vim_regexec_multi() tried to','line_number':3155,'multiline':False]
['text':' use the NFA engine, which resulted in NFA_TOO_EXPENSIVE, and','line_number':3156,'multiline':False]
['text':' compiling the pattern with the other engine fails.','line_number':3157,'multiline':False]
['text':'
 * Check one position in a line for a matching keyword.
 * The caller must check if a keyword can start at startcol.
 * Return its ID if found, 0 otherwise.
 ','line_number':3192,'multiline':True]
['text':' position in line to check for keyword','line_number':3200,'multiline':False]
['text':' return: character after found keyword','line_number':3201,'multiline':False]
['text':' return: flags of matching keyword','line_number':3202,'multiline':False]
['text':' return: next_list of matching keyword','line_number':3203,'multiline':False]
['text':' item at the top of the stack','line_number':3204,'multiline':False]
['text':' conceal substitution char','line_number':3205,'multiline':False]
['text':' assume max. keyword len is 80','line_number':3211,'multiline':False]
['text':' Find first character after the keyword.  First character was already','line_number':3215,'multiline':False]
['text':' checked.','line_number':3216,'multiline':False]
['text':'
     * Must make a copy of the keyword, so we can add a NUL and make it
     * lowercase.
     ','line_number':3231,'multiline':True]
['text':'
     * Try twice:
     * 1. matching case
     * 2. ignoring case
     ','line_number':3237,'multiline':True]
['text':' ignore case','line_number':3247,'multiline':False]
['text':'
	 * Find keywords that match.  There can be several with different
	 * attributes.
	 * When current_next_list is non-zero accept only that group, otherwise:
	 *  Accept a not-contained keyword at toplevel.
	 *  Accept a keyword at other levels only if it is in the contains list.
	 ','line_number':3250,'multiline':True]
['text':'
 * Handle ":syntax conceal" command.
 ','line_number':3281,'multiline':True]
['text':'
 * Handle ":syntax case" command.
 ','line_number':3312,'multiline':True]
['text':'
 * Handle ":syntax foldlevel" command.
 ','line_number':3341,'multiline':True]
['text':'
 * Handle ":syntax spell" command.
 ','line_number':3383,'multiline':True]
['text':' assume spell checking changed, force a redraw','line_number':3418,'multiline':False]
['text':'
 * Handle ":syntax iskeyword" command.
 ','line_number':3422,'multiline':True]
['text':'
 * Clear all syntax info for one buffer.
 ','line_number':3473,'multiline':True]
['text':' clear previous error','line_number':3481,'multiline':False]
['text':' clear previous timeout','line_number':3483,'multiline':False]
['text':' Use case, by default','line_number':3485,'multiline':False]
['text':' default spell checking','line_number':3487,'multiline':False]
['text':' free the keywords','line_number':3493,'multiline':False]
['text':' free the syntax patterns','line_number':3497,'multiline':False]
['text':' free the syntax clusters','line_number':3502,'multiline':False]
['text':' free the stored states','line_number':3522,'multiline':False]
['text':' Reset the counter for ":syn include"','line_number':3526,'multiline':False]
['text':'
 * Get rid of ownsyntax for window "wp".
 ','line_number':3530,'multiline':True]
['text':'
 * Clear syncing info for one buffer.
 ','line_number':3544,'multiline':True]
['text':' free the syntax patterns','line_number':3552,'multiline':False]
['text':' Need to recompute all syntax.','line_number':3567,'multiline':False]
['text':'
 * Remove one pattern from the buffer's pattern list.
 ','line_number':3570,'multiline':True]
['text':'
 * Clear and free one syntax pattern.  When clearing all, must be called from
 * last to first!
 ','line_number':3591,'multiline':True]
['text':' Only free sp_cont_list and sp_next_list of first start pattern','line_number':3600,'multiline':False]
['text':'
 * Clear and free one syntax cluster.
 ','line_number':3609,'multiline':True]
['text':'
 * Handle ":syntax clear" command.
 ','line_number':3620,'multiline':True]
['text':'
     * We have to disable this within ":syn include @group filename",
     * because otherwise @group would get deleted.
     * Only required for Vim 5.x syntax files, 6.0 ones don't contain ":syn
     * clear".
     ','line_number':3634,'multiline':True]
['text':'
	 * No argument: Clear all syntax items.
	 ','line_number':3645,'multiline':True]
['text':'
	 * Clear the group IDs that are in the argument.
	 ','line_number':3660,'multiline':True]
['text':'
		     * We can't physically delete a cluster without changing
		     * the IDs of other clusters, so we do the next best thing
		     * and make it empty.
		     ','line_number':3676,'multiline':True]
['text':' Need to recompute all syntax.','line_number':3701,'multiline':False]
['text':'
 * Clear one syntax group for the current buffer.
 ','line_number':3704,'multiline':True]
['text':' Clear keywords only when not ":syn sync clear group-name"','line_number':3713,'multiline':False]
['text':' clear the patterns for "id"','line_number':3720,'multiline':False]
['text':'
 * Handle ":syntax on" command.
 ','line_number':3730,'multiline':True]
['text':'
 * Handle ":syntax enable" command.
 ','line_number':3739,'multiline':True]
['text':'
 * Handle ":syntax reset" command.
 * It actually resets highlighting, not syntax.
 ','line_number':3750,'multiline':True]
['text':'
 * Handle ":syntax manual" command.
 ','line_number':3766,'multiline':True]
['text':'
 * Handle ":syntax off" command.
 ','line_number':3775,'multiline':True]
['text':'
 * Handle ":syntax [list]" command: list current syntax words.
 ','line_number':3798,'multiline':True]
['text':' when TRUE: list syncing items','line_number':3804,'multiline':False]
['text':'
	 * No argument: List all group IDs and all syntax clusters.
	 ','line_number':3861,'multiline':True]
['text':'
	 * List the group IDs and syntax clusters that are in the argument.
	 ','line_number':3871,'multiline':True]
['text':'
 * List one syntax item, for ":syntax" or "syntax list syntax_name".
 ','line_number':3948,'multiline':True]
['text':' when TRUE: list syncing items','line_number':3954,'multiline':False]
['text':' when TRUE; list link-only too','line_number':3955,'multiline':False]
['text':' highlight like directories','line_number':3985,'multiline':False]
['text':' list the keywords for "id"','line_number':3987,'multiline':False]
['text':' list the patterns for "id"','line_number':3995,'multiline':False]
['text':' list the link, if there is one','line_number':4052,'multiline':False]
['text':'
 * List one syntax cluster, for ":syntax" or "syntax list syntax_name".
 ','line_number':4075,'multiline':True]
['text':' slight hack:  roughly duplicate the guts of syn_list_header()','line_number':4083,'multiline':False]
['text':' output at least one space','line_number':4087,'multiline':False]
['text':' avoid hang for tiny window','line_number':4089,'multiline':False]
['text':' May have to write "matchgroup=group"','line_number':4157,'multiline':False]
['text':' output the name of the pattern and an '=' or ' '','line_number':4170,'multiline':False]
['text':' output the pattern, in between a char that is not in the pattern','line_number':4174,'multiline':False]
['text':' no good char found, just use the first one','line_number':4178,'multiline':False]
['text':' output any pattern options','line_number':4185,'multiline':False]
['text':' separate with commas','line_number':4193,'multiline':False]
['text':'
 * List or clear the keywords for one syntax group.
 * Return TRUE if the header has been printed.
 ','line_number':4213,'multiline':True]
['text':' header has already been printed','line_number':4221,'multiline':False]
['text':'
     * Unfortunately, this list of keywords is not sorted on alphabet but on
     * hash value...
     ','line_number':4235,'multiline':True]
['text':' output "contained" and "nextgroup" on each line','line_number':4258,'multiline':False]
['text':'
 * Clear a whole keyword table.
 ','line_number':4362,'multiline':True]
['text':'
 * Add a keyword to the list of keywords.
 ','line_number':4392,'multiline':True]
['text':' name of keyword','line_number':4397,'multiline':False]
['text':' group ID for this keyword','line_number':4398,'multiline':False]
['text':' flags for this keyword','line_number':4399,'multiline':False]
['text':' containedin for this keyword','line_number':4400,'multiline':False]
['text':' nextgroup for this keyword','line_number':4401,'multiline':False]
['text':' new keyword, add to hashtable','line_number':4438,'multiline':False]
['text':' keyword already exists, prepend to list','line_number':4444,'multiline':False]
['text':'
 * Get the start and end of the group name argument.
 * Return a pointer to the first argument.
 * Return NULL if the end of the command was found instead of further args.
 ','line_number':4450,'multiline':True]
['text':' start of the argument','line_number':4457,'multiline':False]
['text':' pointer to end of the name','line_number':4458,'multiline':False]
['text':'
     * Check if there are enough arguments.  The first argument may be a
     * pattern, where '|' is allowed, so only check for NUL.
     ','line_number':4465,'multiline':True]
['text':'
 * Check for syntax command option arguments.
 * This can be called at any place in the list of arguments, and just picks
 * out the arguments that are known.  Can be called several times in a row to
 * collect all options in between other arguments.
 * Return a pointer to the next argument (which isn't an option).
 * Return NULL for any error;
 ','line_number':4474,'multiline':True]
['text':' next argument to be checked','line_number':4484,'multiline':False]
['text':' various things','line_number':4485,'multiline':False]
['text':' TRUE if skipping over command','line_number':4487,'multiline':False]
['text':' already detected error','line_number':4523,'multiline':False]
['text':'
	 * This is used very often when a large number of keywords is defined.
	 * Need to skip quickly when no option name is found.
	 * Also avoid tolower(), it's slow.
	 ','line_number':4533,'multiline':True]
['text':' treat "display", "fold" and "extend" as a keyword','line_number':4556,'multiline':False]
['text':' no match found','line_number':4561,'multiline':False]
['text':' cchar=?','line_number':4586,'multiline':False]
['text':' Need to update folds later.','line_number':4658,'multiline':False]
['text':'
 * Adjustments to syntax item when declared in a ":syn include"'d file.
 * Set the contained flag, and if the item is not already contained, add it
 * to the specified top-level group, if any.
 ','line_number':4667,'multiline':True]
['text':' We have to alloc this, because syn_combine_list() will free it.','line_number':4680,'multiline':False]
['text':'
 * Handle ":syntax include [@{group-name}] filename" command.
 ','line_number':4694,'multiline':True]
['text':' separate_nextcmd() and expand_filename() depend on this','line_number':4725,'multiline':False]
['text':'
     * Everything that's left, up to the next command, should be the
     * filename to include.
     ','line_number':4729,'multiline':True]
['text':' For an absolute path, "$VIM/..." or "<sfile>.." we ":source" the','line_number':4737,'multiline':False]
['text':' file.  Need to expand the file name first.  In other cases','line_number':4738,'multiline':False]
['text':' ":runtime!" is used.','line_number':4739,'multiline':False]
['text':'
     * Save and restore the existing top-level grouplist id and ":syn
     * include" tag around the actual inclusion.
     ','line_number':4749,'multiline':True]
['text':'
 * Handle ":syntax keyword {group-name} [{option}] keyword .." command.
 ','line_number':4769,'multiline':True]
['text':' allocate a buffer, for removing backslashes in the keyword','line_number':4795,'multiline':False]
['text':'
	     * The options given apply to ALL keywords, so all options must be
	     * found before keywords can be created.
	     * 1: collect the options and copy the keywords to keyword_copy.
	     ','line_number':4806,'multiline':True]
['text':' Copy the keyword, removing backslashes, and add a NUL.','line_number':4820,'multiline':False]
['text':' Adjust flags for use of ":syn include".','line_number':4833,'multiline':False]
['text':'
		 * 2: Add an entry for each keyword.
		 ','line_number':4836,'multiline':True]
['text':' skip over the "]"','line_number':4863,'multiline':False]
['text':' Need to recompute all syntax.','line_number':4894,'multiline':False]
['text':'
 * Handle ":syntax match {name} [{options}] {pattern} [{options}]".
 *
 * Also ":syntax sync match {name} [[grouphere | groupthere] {group-name}] .."
 ','line_number':4897,'multiline':True]
['text':' TRUE for ":syntax sync match .. "','line_number':4905,'multiline':False]
['text':' the item found in the line','line_number':4910,'multiline':False]
['text':' Isolate the group name, check for validity','line_number':4918,'multiline':False]
['text':' Get options before the pattern','line_number':4921,'multiline':False]
['text':' get the pattern.','line_number':4931,'multiline':False]
['text':' Get options after the pattern','line_number':4938,'multiline':False]
['text':' all arguments are valid','line_number':4941,'multiline':False]
['text':'
	 * Check for trailing command and illegal trailing arguments.
	 ','line_number':4943,'multiline':True]
['text':'
	     * Store the pattern in the syn_items list
	     ','line_number':4954,'multiline':True]
['text':' remember that we found a match for syncing on','line_number':4976,'multiline':False]
['text':' Need to recompute all syntax.','line_number':4985,'multiline':False]
['text':' don't free the progs and patterns now','line_number':4986,'multiline':False]
['text':'
     * Something failed, free the allocated memory.
     ','line_number':4990,'multiline':True]
['text':'
 * Handle ":syntax region {group-name} [matchgroup={group-name}]
 *		start {start} .. [skip {skip}] end {end} .. [{options}]".
 ','line_number':5003,'multiline':True]
['text':' TRUE for ":syntax sync region .."','line_number':5010,'multiline':False]
['text':' next arg, NULL on error','line_number':5014,'multiline':False]
['text':' pointer to syn_pattern','line_number':5025,'multiline':False]
['text':' matchgroup ID','line_number':5026,'multiline':False]
['text':' pointer to next pat_ptr','line_number':5027,'multiline':False]
['text':' patterns found in the line','line_number':5029,'multiline':False]
['text':' nr of syn_patterns found','line_number':5032,'multiline':False]
['text':' not enough arguments','line_number':5035,'multiline':False]
['text':' illegal arguments','line_number':5036,'multiline':False]
['text':' Isolate the group name, check for validity','line_number':5042,'multiline':False]
['text':'
     * get the options, patterns and matchgroup.
     ','line_number':5059,'multiline':True]
['text':' Check for option arguments','line_number':5064,'multiline':False]
['text':' must be a pattern or matchgroup then','line_number':5069,'multiline':False]
['text':' out of memory','line_number':5075,'multiline':False]
['text':' one skip pattern allowed','line_number':5088,'multiline':False]
['text':'
	     * Allocate room for a syn_pattern, and link it in the list of
	     * syn_patterns for this item, at the start (because the list is
	     * used from end to start).
	     ','line_number':5129,'multiline':True]
['text':'
	     * Get the syntax pattern and the following offset(s).
	     ','line_number':5149,'multiline':True]
['text':' Enable the appropriate \z specials.','line_number':5152,'multiline':False]
['text':'
     * Must have a "start" and "end" pattern.
     ','line_number':5170,'multiline':True]
['text':'
	 * Check for trailing garbage or command.
	 * If OK, add the item.
	 ','line_number':5182,'multiline':True]
['text':'
	     * Store the start/skip/end in the syn_items list
	     ','line_number':5194,'multiline':True]
['text':' Need to recompute all syntax.','line_number':5237,'multiline':False]
['text':' don't free the progs and patterns now','line_number':5238,'multiline':False]
['text':'
     * Free the allocated memory.
     ','line_number':5242,'multiline':True]
['text':'
 * A simple syntax group ID comparison function suitable for use in qsort()
 ','line_number':5270,'multiline':True]
['text':'
 * Combines lists of syntax clusters.
 * *clstr1 and *clstr2 must both be allocated memory; they will be consumed.
 ','line_number':5282,'multiline':True]
['text':'
     * Handle degenerate cases.
     ','line_number':5297,'multiline':True]
['text':'
     * For speed purposes, sort both lists.
     ','line_number':5318,'multiline':True]
['text':'
     * We proceed in two passes; in round 1, we count the elements to place
     * in the new list, and in round 2, we allocate and populate the new
     * list.  For speed, we use a mergesort-like method, adding the smaller
     * of the current elements in each list to the new list.
     ','line_number':5324,'multiline':True]
['text':'
	 * First, loop through the lists until one of them is empty.
	 ','line_number':5336,'multiline':True]
['text':'
	     * We always want to add from the first list.
	     ','line_number':5341,'multiline':True]
['text':'
	     * We only want to add from the second list if we're adding the
	     * lists.
	     ','line_number':5352,'multiline':True]
['text':'
	 * Now add the leftovers from whichever list didn't get finished
	 * first.  As before, we only want to add from the second list if
	 * we're adding the lists.
	 ','line_number':5367,'multiline':True]
['text':'
	     * If the group ended up empty, we don't need to allocate any
	     * space for it.
	     ','line_number':5382,'multiline':True]
['text':'
     * Finally, put the new list in place.
     ','line_number':5398,'multiline':True]
['text':'
 * Lookup a syntax cluster name and return its ID.
 * If it is not found, 0 is returned.
 ','line_number':5406,'multiline':True]
['text':' Avoid using stricmp() too much, it's slow on some systems','line_number':5416,'multiline':False]
['text':'
 * Like syn_scl_name2id(), but take a pointer + length argument.
 ','line_number':5428,'multiline':True]
['text':'
 * Find syntax cluster name in the table and return its ID.
 * The argument is a pointer to the name and the length of the name.
 * If it doesn't exist yet, a new entry is created.
 * Return 0 for failure.
 ','line_number':5446,'multiline':True]
['text':' doesn't exist yet','line_number':5463,'multiline':False]
['text':'
 * Add new syntax cluster and return its ID.
 * "name" must be an allocated string, it will be consumed.
 * Return 0 for failure.
 ','line_number':5470,'multiline':True]
['text':'
     * First call for this growarray: init growing array.
     ','line_number':5480,'multiline':True]
['text':'
     * Make room for at least one other cluster entry.
     ','line_number':5497,'multiline':True]
['text':'
 * Handle ":syntax cluster {cluster-name} [contains={groupname},..]
 *		[add={groupname},..] [remove={groupname},..]".
 ','line_number':5520,'multiline':True]
['text':' Need to recompute all.','line_number':5589,'multiline':False]
['text':'
 * On first call for current buffer: Init growing array.
 ','line_number':5599,'multiline':True]
['text':'
 * Get one pattern for a ":syntax match" or ":syntax region" command.
 * Stores the pattern and program in a synpat_T.
 * Returns a pointer to the next argument, or NULL in case of an error.
 ','line_number':5609,'multiline':True]
['text':' need at least three chars','line_number':5622,'multiline':False]
['text':' end delimiter not found','line_number':5627,'multiline':False]
['text':' store the pattern and compiled regexp program','line_number':5632,'multiline':False]
['text':' Make 'cpoptions' empty, to avoid the 'l' flag','line_number':5636,'multiline':False]
['text':'
     * Check for a match, highlight or region offset.
     ','line_number':5649,'multiline':True]
['text':' lc=99','line_number':5672,'multiline':False]
['text':' "lc=" offset automatically sets "ms=" offset','line_number':5677,'multiline':False]
['text':' yy=x+99','line_number':5684,'multiline':False]
['text':' positive offset','line_number':5690,'multiline':False]
['text':' negative offset','line_number':5695,'multiline':False]
['text':'
 * Handle ":syntax sync .." command.
 ','line_number':5713,'multiline':True]
['text':' missing pattern','line_number':5794,'multiline':False]
['text':' end delimiter not found','line_number':5806,'multiline':False]
['text':' store the pattern and compiled regexp program','line_number':5814,'multiline':False]
['text':' Make 'cpoptions' empty, to avoid the 'l' flag','line_number':5824,'multiline':False]
['text':' Need to recompute all syntax.','line_number':5866,'multiline':False]
['text':'
 * Convert a line of highlight group names into a list of group ID numbers.
 * "arg" should point to the "contains" or "nextgroup" keyword.
 * "arg" is advanced to after the last group name.
 * Careful: the argument is modified (NULs added).
 * returns FAIL for some error, OK for success.
 ','line_number':5870,'multiline':True]
['text':' length of keyword','line_number':5880,'multiline':False]
['text':' where to store the resulting list, if not','line_number':5881,'multiline':False]
['text':' NULL, the list is silently skipped!','line_number':5882,'multiline':False]
['text':'
     * We parse the list twice:
     * round == 1: count the number of items, allocate the array.
     * round == 2: fill the array with the items.
     * In round 1 new groups may be added, causing the number of items to
     * grow when a regexp is used.  In that case round 1 is done once again.
     ','line_number':5897,'multiline':True]
['text':'
	 * skip "contains"
	 ','line_number':5906,'multiline':True]
['text':'
	 * parse the arguments after "contains"
	 ','line_number':5922,'multiline':True]
['text':' leave room for "^$"','line_number':5930,'multiline':False]
['text':'
		 * Handle full group name.
		 ','line_number':5978,'multiline':True]
['text':'
		     * Handle match of regexp with group names.
		     ','line_number':5985,'multiline':True]
['text':' Got more items than expected; can happen','line_number':6007,'multiline':False]
['text':' when adding items that match:','line_number':6008,'multiline':False]
['text':' "contains=a.*b,axb".','line_number':6009,'multiline':False]
['text':' Go back to first round','line_number':6010,'multiline':False]
['text':' remember that we found one','line_number':6020,'multiline':False]
['text':' Got more items than expected, go back to first round','line_number':6037,'multiline':False]
['text':' skip comma in between arguments','line_number':6051,'multiline':False]
['text':' zero means end of the list','line_number':6060,'multiline':False]
['text':' list already found, don't overwrite it','line_number':6075,'multiline':False]
['text':'
 * Make a copy of an ID list.
 ','line_number':6080,'multiline':True]
['text':'
 * Check if syntax group "ssp" is in the ID list "list" of "cur_si".
 * "cur_si" can be NULL if not checking the "containedin" list.
 * Used to check if a syntax item is in the "contains" or "nextgroup" list of
 * the current item.
 * This function is called very often, keep it fast!!
 ','line_number':6103,'multiline':True]
['text':' current item or NULL','line_number':6112,'multiline':False]
['text':' id list','line_number':6113,'multiline':False]
['text':' group id and ":syn include" tag of group','line_number':6114,'multiline':False]
['text':' group id is contained','line_number':6115,'multiline':False]
['text':' If ssp has a "containedin" list and "cur_si" is in it, return TRUE.','line_number':6124,'multiline':False]
['text':' Ignore transparent items without a contains argument.  Double check','line_number':6128,'multiline':False]
['text':' that we don't go back past the first one.','line_number':6129,'multiline':False]
['text':' cur_si->si_idx is -1 for keywords, these never contain anything.','line_number':6133,'multiline':False]
['text':'
     * If list is ID_LIST_ALL, we are in a transparent item that isn't
     * inside anything.  Only allow not-contained groups.
     ','line_number':6143,'multiline':True]
['text':'
     * If the first item is "ALLBUT", return TRUE if "id" is NOT in the
     * contains list.  We also require that "id" is at the same ":syn include"
     * level as the list.
     ','line_number':6150,'multiline':True]
['text':' ALL or ALLBUT: accept all groups in the same file','line_number':6160,'multiline':False]
['text':' TOP: accept all not-contained groups in the same file','line_number':6166,'multiline':False]
['text':' CONTAINED: accept all contained groups in the same file','line_number':6172,'multiline':False]
['text':'
     * Return "retval" if id is in the contains list.
     ','line_number':6182,'multiline':True]
['text':' restrict recursiveness to 30 to avoid an endless loop for a','line_number':6192,'multiline':False]
['text':' cluster that includes itself (indirectly)','line_number':6193,'multiline':False]
['text':' subcommand name','line_number':6210,'multiline':False]
['text':' function to call','line_number':6211,'multiline':False]
['text':'
 * ":syntax".
 * This searches the subcommands[] table for the subcommand name, and calls a
 * syntax_subcommand() function to do the rest.
 ','line_number':6238,'multiline':True]
['text':' isolate subcommand name','line_number':6253,'multiline':False]
['text':' skip error messages for all subcommands','line_number':6260,'multiline':False]
['text':' TODO: keep the spell checking as it was.','line_number':6294,'multiline':False]
['text':' No spell checking','line_number':6295,'multiline':False]
['text':' make sure option values are "empty_option" instead of NULL','line_number':6296,'multiline':False]
['text':' save value of b:current_syntax','line_number':6305,'multiline':False]
['text':' Apply the "syntax" autocommand event, this finds and loads the syntax','line_number':6310,'multiline':False]
['text':' file.','line_number':6311,'multiline':False]
['text':' move value of b:current_syntax to w:current_syntax','line_number':6314,'multiline':False]
['text':' restore value of b:current_syntax','line_number':6319,'multiline':False]
['text':' expand ":syn" sub-commands','line_number':6341,'multiline':False]
['text':' expand ":syn case" arguments','line_number':6342,'multiline':False]
['text':' expand ":syn spell" arguments','line_number':6343,'multiline':False]
['text':' expand ":syn sync" arguments','line_number':6344,'multiline':False]
['text':' expand ":syn list @cluster" arguments','line_number':6345,'multiline':False]
['text':'
 * Reset include_link, include_default, include_none to 0.
 * Called when we are done expanding.
 ','line_number':6348,'multiline':True]
['text':'
 * Handle command line completion for :match and :echohl command: Add "None"
 * as highlight group.
 ','line_number':6358,'multiline':True]
['text':'
 * Handle command line completion for :syntax command.
 ','line_number':6370,'multiline':True]
['text':' Default: expand subcommands','line_number':6378,'multiline':False]
['text':' (part of) subcommand already typed','line_number':6388,'multiline':False]
['text':' past first word','line_number':6393,'multiline':False]
['text':'
 * Function given to ExpandGeneric() to obtain the list syntax names for
 * expansion.
 ','line_number':6419,'multiline':True]
['text':'
 * Function called for expression evaluation: get syntax ID at file position.
 ','line_number':6465,'multiline':True]
['text':' remove transparency','line_number':6473,'multiline':False]
['text':' return: can do spell checking','line_number':6474,'multiline':False]
['text':' keep state of char at "col"','line_number':6475,'multiline':False]
['text':' When the position is not after the current position and in the same','line_number':6477,'multiline':False]
['text':' line of the same window with the same buffer, need to restart parsing.','line_number':6478,'multiline':False]
['text':' next_match may not be correct when moving around, e.g. with the','line_number':6487,'multiline':False]
['text':' "skip" expression in searchpair()','line_number':6488,'multiline':False]
['text':'
 * Get extra information about the syntax item.  Must be called right after
 * get_syntax_attr().
 * Stores the current item sequence nr in "*seqnrp".
 * Returns the current flags.
 ','line_number':6497,'multiline':True]
['text':'
 * Return conceal substitution character
 ','line_number':6510,'multiline':True]
['text':'
 * Return the syntax ID at position "i" in the current stack.
 * The caller must have called syn_get_id() before to fill the stack.
 * Returns -1 when "i" is out of range.
 ','line_number':6521,'multiline':True]
['text':' Need to invalidate the state, because we didn't properly finish it','line_number':6531,'multiline':False]
['text':' for the last character, "keep_state" was TRUE.','line_number':6532,'multiline':False]
['text':'
 * Function called to get folding level for line "lnum" in window "wp".
 ','line_number':6554,'multiline':True]
['text':' Return quickly when there are no fold items at all.','line_number':6564,'multiline':False]
['text':' Start with the fold level at the start of the line.','line_number':6574,'multiline':False]
['text':' Find the lowest fold level that is followed by a higher one.','line_number':6579,'multiline':False]
['text':'
 * ":syntime".
 ','line_number':6605,'multiline':True]
['text':'
 * Clear the syntax timing for the current buffer.
 ','line_number':6632,'multiline':True]
['text':'
 * Function given to ExpandGeneric() to obtain the possible arguments of the
 * ":syntime {on,off,clear,report}" command.
 ','line_number':6653,'multiline':True]
['text':'
 * Clear the syntax timing for the current buffer.
 ','line_number':6690,'multiline':True]
['text':' Sort on total time. Skip if there are no items to avoid passing NULL','line_number':6738,'multiline':False]
['text':' pointer to qsort().','line_number':6739,'multiline':False]
['text':' make sure there is always a separating space','line_number':6751,'multiline':False]
['text':' will wrap anyway','line_number':6770,'multiline':False]
['text':' FEAT_SYN_HL','line_number':6790,'multiline':False]
