['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *	      OS/2 port by Paul Slootman
 *	      VMS merge by Zoltan Arpadffy
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]
['text':'
 * os_unix.c -- code for all flavors of Unix (BSD, SYSV, SVR4, POSIX, ...)
 *	     Also for OS/2, using the excellent EMX package!!!
 *	     Also for Atari MiNT.
 *
 * A lot of this file was originally written by Juergen Weigert and later
 * changed beyond recognition.
 ','line_number':12,'multiline':True]
['text':' unix includes for os_unix.c only','line_number':27,'multiline':False]
['text':' for cygwin_conv_to_posix_path() and/or','line_number':52,'multiline':False]
['text':' for cygwin_conv_path()','line_number':53,'multiline':False]
['text':' <linux/keyboard.h> contains defines conflicting with "keymap.h",','line_number':81,'multiline':False]
['text':' I just copied relevant defines here. A cleaner solution would be to put gpm','line_number':82,'multiline':False]
['text':' code into separate file and include there linux/keyboard.h','line_number':83,'multiline':False]
['text':' #include <linux/keyboard.h>','line_number':84,'multiline':False]
['text':'
 * end of autoconf section. To be extended...
 ','line_number':109,'multiline':True]
['text':' Are the following #ifdefs still required? And why? Is that for X11?','line_number':113,'multiline':False]
['text':' hpux 9.01 has it','line_number':124,'multiline':False]
['text':' delay for xterm tracing','line_number':172,'multiline':False]
['text':' volatile because it is used in signal handler sig_tstp() and','line_number':182,'multiline':False]
['text':' sigcont_handler().','line_number':183,'multiline':False]
['text':' volatile because it is used in signal handler sig_alarm().','line_number':198,'multiline':False]
['text':'','line_number':212,'multiline':True]
['text':'','line_number':213,'multiline':True]
['text':' volatile because it is used in signal handler sig_winch().','line_number':227,'multiline':False]
['text':' volatile because it is used in signal handler sig_tstp().','line_number':229,'multiline':False]
['text':' volatile because it is used in signal handler deathtrap().','line_number':233,'multiline':False]
['text':' The signal we caught','line_number':234,'multiline':False]
['text':' volatile because it is used in signal handler deathtrap().','line_number':235,'multiline':False]
['text':' sleeping in mch_delay()','line_number':236,'multiline':False]
['text':' Current terminal mode from mch_settmode().  Can differ from cur_tmode.','line_number':242,'multiline':False]
['text':' The SM connection ID','line_number':248,'multiline':False]
['text':' The ICE connection ID','line_number':249,'multiline':False]
['text':' The client ID for the current smc session','line_number':250,'multiline':False]
['text':' If we're in the middle of a save_yourself','line_number':251,'multiline':False]
['text':' If we're in shutdown mode','line_number':252,'multiline':False]
['text':'
 * I have seen
 *  extern char *_sys_siglist[NSIG];
 * on Linux, NetBSD and Solaris. It contains a nice list of strings
 * that describe the signals. That is nearly what we want here.  But
 * autoconf does only check for sys_siglist (without the underscore), I
 * do not want to change everything today.... jw.
 * This is why AC_DECL_SYS_SIGLIST is commented out in configure.ac.
 ','line_number':259,'multiline':True]
['text':' Signal number, eg. SIGSEGV etc','line_number':272,'multiline':False]
['text':' Signal name (not char_u!).','line_number':273,'multiline':False]
['text':' Catch as a deadly signal?','line_number':274,'multiline':False]
['text':' MzScheme uses SEGV in its garbage collector','line_number':302,'multiline':False]
['text':' Perl's alarm() can trigger it','line_number':309,'multiline':False]
['text':' MzScheme uses SIGPROF for its own needs; On Linux with profiling','line_number':318,'multiline':False]
['text':' this makes Vim exit.  WE_ARE_PROFILING is defined in Makefile.','line_number':319,'multiline':False]
['text':' Used for sysmouse handling','line_number':332,'multiline':False]
['text':' Modern implementation: use sigaction().','line_number':354,'multiline':False]
['text':' Using sigset() is preferred above signal().','line_number':398,'multiline':False]
['text':' Oldest and most compatible solution.','line_number':401,'multiline':False]
['text':' Why is NeXT excluded here (and not in os_unixx.h)?','line_number':422,'multiline':False]
['text':'
 * Write s[len] to the screen (stdout).
 ','line_number':429,'multiline':True]
['text':' Unix is too fast, slow down a bit more','line_number':436,'multiline':False]
['text':'
 * Function passed to inchar_loop() to handle window resizing.
 * If "check_only" is TRUE: Return whether there was a resize.
 * If "check_only" is FALSE: Deal with the window resized.
 ','line_number':440,'multiline':True]
['text':'
 * mch_inchar(): low level input function.
 * Get a characters from the keyboard.
 * Return the number of characters that are available.
 * If wtime == 0 do not wait for characters.
 * If wtime == n wait a short time for characters.
 * If wtime == -1 wait forever for characters.
 ','line_number':460,'multiline':True]
['text':' don't use "time", MIPS cannot handle it','line_number':472,'multiline':False]
['text':'
 * Return non-zero if a character is available.
 ','line_number':486,'multiline':True]
['text':'
 * Check for any pending input or messages.
 ','line_number':496,'multiline':True]
['text':'
 * Return total amount of memory available in Kbyte.
 * Doesn't change when memory has been allocated.
 ','line_number':521,'multiline':True]
['text':' how much to shift "mem" right for Kbyte','line_number':529,'multiline':False]
['text':' Mac (Darwin) way of getting the amount of RAM available','line_number':533,'multiline':False]
['text':' get the amount of user memory by summing each usage','line_number':550,'multiline':False]
['text':' BSD way of getting the amount of RAM available.','line_number':564,'multiline':False]
['text':' sysctl() may return 32 bit or 64 bit, accept both','line_number':570,'multiline':False]
['text':' Linux way of getting amount of RAM available','line_number':602,'multiline':False]
['text':' avoid overflow as much as possible','line_number':606,'multiline':False]
['text':' Solaris way of getting amount of RAM available','line_number':625,'multiline':False]
['text':' avoid overflow as much as possible','line_number':630,'multiline':False]
['text':' Return the minimum of the physical memory and the user limit, because','line_number':641,'multiline':False]
['text':' using more than the user limit may cause Vim to be terminated.','line_number':642,'multiline':False]
['text':'
 * "flags": MCH_DELAY_IGNOREINPUT - don't read input
 *	    MCH_DELAY_SETTMODE - use settmode() even for short delays
 ','line_number':667,'multiline':True]
['text':' remember original value','line_number':677,'multiline':False]
['text':' Go to cooked mode without echo, to allow SIGINT interrupting us','line_number':682,'multiline':False]
['text':' here.  But we don't want QUIT to kill us (CTRL-\ used in a','line_number':683,'multiline':False]
['text':' shell may produce SIGQUIT).','line_number':684,'multiline':False]
['text':' Only do this if sleeping for more than half a second.','line_number':685,'multiline':False]
['text':'
	 * Everybody sleeps in a different way...
	 * Prefer nanosleep(), some versions of usleep() can only sleep up to
	 * one second.
	 ','line_number':695,'multiline':True]
['text':' if total is large enough, wait by portions in p_mzq','line_number':703,'multiline':False]
['text':' NOTE: Solaris 2.6 has a bug that makes select() hang here.  Get','line_number':735,'multiline':False]
['text':' a patch from Sun to fix this.  Reported by Gunnar Pedersen.','line_number':736,'multiline':False]
['text':'
 * Support for checking for an almost-out-of-stack-space situation.
 ','line_number':758,'multiline':True]
['text':'
 * Return a pointer to an item on the stack.  Used to find out if the stack
 * grows up or down.
 ','line_number':762,'multiline':True]
['text':'
 * Find out if the stack grows upwards or downwards.
 * "p" points to a variable on the stack of the caller.
 ','line_number':768,'multiline':True]
['text':'
 * Find out until how var the stack can grow without getting into trouble.
 * Called when starting up and when switching to the signal stack in
 * deathtrap().
 ','line_number':789,'multiline':True]
['text':' Set the stack limit to 15/16 of the allowable size.  Skip this when the','line_number':801,'multiline':False]
['text':' limit doesn't fit in a long (rlim_cur might be "long long").','line_number':802,'multiline':False]
['text':' On FreeBSD the initial thread always has a fixed stack size, no','line_number':816,'multiline':False]
['text':' matter what the limits are set to.  Normally it's 1 Mbyte.','line_number':817,'multiline':False]
['text':' overflow, set to 1/16 of current stack position','line_number':832,'multiline':False]
['text':' overflow','line_number':839,'multiline':False]
['text':'
 * Return FAIL when running out of stack space.
 * "p" must point to any variable local to the caller that's on the stack.
 ','line_number':844,'multiline':True]
['text':'
 * Support for using the signal stack.
 * This helps when we run out of stack space, which causes a SIGSEGV.  The
 * signal handler then must run on another stack, since the normal stack is
 * completely full.
 ','line_number':866,'multiline':True]
['text':' for sigaltstack()','line_number':874,'multiline':False]
['text':' for sigstack()','line_number':876,'multiline':False]
['text':'
 * Get a size of signal stack.
 * Preference (if available): sysconf > SIGSTKSZ > guessed size
 ','line_number':879,'multiline':True]
['text':' return size only if sysconf doesn't return an error','line_number':888,'multiline':False]
['text':' if sysconf() isn't available or gives error, return SIGSTKSZ','line_number':894,'multiline':False]
['text':' if defined','line_number':895,'multiline':False]
['text':' otherwise guess the size','line_number':899,'multiline':False]
['text':'
 * We need correct prototypes for a signal function, otherwise mean compilers
 * will barf when the second argument to signal() is ``wrong''.
 * Let me try it with a few tricky defines from my own osdef.h	(jw).
 ','line_number':930,'multiline':True]
['text':' this is not required on all systems, but it doesn't hurt anybody','line_number':939,'multiline':False]
['text':' Second time we get called we actually need to suspend','line_number':949,'multiline':False]
['text':' This is not required on all systems.  On some systems (at least Android,','line_number':959,'multiline':False]
['text':' OpenBSD, and DragonFlyBSD) this breaks suspending with CTRL-Z.','line_number':960,'multiline':False]
['text':' this is not required on all systems, but it doesn't hurt anybody','line_number':970,'multiline':False]
['text':' this is not required on all systems, but it doesn't hurt anybody','line_number':980,'multiline':False]
['text':' this is not required on all systems, but it doesn't hurt anybody','line_number':990,'multiline':False]
['text':'
     * I'm not sure we get the SIGPWR signal when the system is really going
     * down or when the batteries are almost empty.  Just preserve the swap
     * files and don't exit, that can't do any harm.
     ','line_number':992,'multiline':True]
['text':'
 * signal function for alarm().
 ','line_number':1002,'multiline':True]
['text':' doesn't do anything, just to break a system call','line_number':1008,'multiline':False]
['text':' argument to SETJMP()','line_number':1019,'multiline':False]
['text':' Caught signal number, 0 when no signal was caught; used for mch_libcall().','line_number':1023,'multiline':False]
['text':' Volatile because it is used in signal handlers.','line_number':1024,'multiline':False]
['text':' TRUE when lc_jump_env is valid.','line_number':1028,'multiline':False]
['text':' Volatile because it is used in signal handler deathtrap().','line_number':1029,'multiline':False]
['text':'
 * A simplistic version of setjmp() that only allows one level of using.
 * Used to protect areas where we could crash.
 * Don't call twice before calling mch_endjmp()!.
 *
 * Usage:
 *	mch_startjmp();
 *	if (SETJMP(lc_jump_env) != 0)
 *	{
 *	    mch_didjmp();
 *	    emsg("crash!");
 *	}
 *	else
 *	{
 *	    do_the_work;
 *	    mch_endjmp();
 *	}
 * Note: Can't move SETJMP() here, because a function calling setjmp() must
 * not return before the saved environment is used.
 * Returns OK for normal return, FAIL when the protected code caused a
 * problem and LONGJMP() was used.
 ','line_number':1032,'multiline':True]
['text':' On FreeBSD the signal stack has to be reset after using siglongjmp(),','line_number':1073,'multiline':False]
['text':' otherwise catching the signal only works once.','line_number':1074,'multiline':False]
['text':'
 * This function handles deadly signals.
 * It tries to preserve any swap files and exit properly.
 * (partly from Elvis).
 * NOTE: Avoid unsafe functions, such as allocating memory, they can result in
 * a deadlock.
 ','line_number':1080,'multiline':True]
['text':' count the number of times we got here.','line_number':1090,'multiline':False]
['text':' Note: when memory has been corrupted','line_number':1091,'multiline':False]
['text':' this may get an arbitrary value!','line_number':1092,'multiline':False]
['text':'
     * Catch a crash in protected code.
     * Restores the environment saved in lc_jump_env, which looks like
     * SETJMP() returns 1.
     ','line_number':1098,'multiline':True]
['text':' don't jump again','line_number':1108,'multiline':False]
['text':' NOTREACHED','line_number':1110,'multiline':False]
['text':' While in mch_delay() we go to cooked mode to allow a CTRL-C to','line_number':1116,'multiline':False]
['text':' interrupt us.  But in cooked mode we may also get SIGQUIT, e.g., when','line_number':1117,'multiline':False]
['text':' pressing CTRL-\, but we don't want Vim to exit then.','line_number':1118,'multiline':False]
['text':' When SIGHUP, SIGQUIT, etc. are blocked: postpone the effect and return','line_number':1123,'multiline':False]
['text':' here.  This avoids that a non-reentrant function is interrupted, e.g.,','line_number':1124,'multiline':False]
['text':' free().  Calling free() again may then cause a crash.','line_number':1125,'multiline':False]
['text':' Remember how often we have been called.','line_number':1151,'multiline':False]
['text':' Executing autocommands is likely to use more stack space than we have','line_number':1154,'multiline':False]
['text':' available in the signal stack.','line_number':1155,'multiline':False]
['text':' Set the v:dying variable.','line_number':1159,'multiline':False]
['text':' Since we are now using the signal stack, need to reset the stack','line_number':1165,'multiline':False]
['text':' limit.  Otherwise using a regexp will fail.','line_number':1166,'multiline':False]
['text':' This is for opening gdb the moment Vim crashes.','line_number':1171,'multiline':False]
['text':' You need to manually adjust the file name and Vim executable name.','line_number':1172,'multiline':False]
['text':' Suggested by SungHyun Nam.','line_number':1173,'multiline':False]
['text':' try to find the name of this signal','line_number':1194,'multiline':False]
['text':' don't write message to the GUI, it might be','line_number':1201,'multiline':False]
['text':' part of the problem...','line_number':1202,'multiline':False]
['text':'
     * If something goes wrong after entering here, we may get here again.
     * When this happens, give a message and try to exit nicely (resetting the
     * terminal mode, etc.)
     * When this happens twice, just exit, don't even try to give a message,
     * stack may be corrupt or something weird.
     * When this still happens again (or memory was corrupted in such a way
     * that "entered" was clobbered) use _exit(), don't try freeing resources.
     ','line_number':1203,'multiline':True]
['text':' don't catch any signals anymore','line_number':1214,'multiline':False]
['text':' No translation, it may call malloc().','line_number':1222,'multiline':False]
['text':' No translation, it may call malloc().','line_number':1228,'multiline':False]
['text':' Preserve files and exit.  This sets the really_exiting flag to prevent','line_number':1236,'multiline':False]
['text':' calling free().','line_number':1237,'multiline':False]
['text':' NOTREACHED','line_number':1240,'multiline':False]
['text':'
 * Invoked after receiving SIGCONT.  We don't know what happened while
 * sleeping, deal with part of that.
 ','line_number':1249,'multiline':True]
['text':' Don't change "oldtitle" in a signal handler, set a flag to obtain it','line_number':1256,'multiline':False]
['text':' again later.','line_number':1257,'multiline':False]
['text':'
 * With multi-threading, suspending might not work immediately.  Catch the
 * SIGCONT signal, which will be used as an indication whether the suspending
 * has been done or not.
 *
 * On Linux, signal is not always handled immediately either.
 * See https://bugs.launchpad.net/bugs/291373
 * Probably because the signal is handled in another thread.
 *
 * volatile because it is used in signal handler sigcont_handler().
 ','line_number':1268,'multiline':True]
['text':'
 * signal handler for SIGCONT
 ','line_number':1282,'multiline':True]
['text':' We didn't suspend ourselves, assume we were stopped by a SIGSTOP','line_number':1294,'multiline':False]
['text':' signal (which can't be intercepted) and get a SIGCONT.  Need to get','line_number':1295,'multiline':False]
['text':' back to a sane mode. We should redraw, but we can't really do that','line_number':1296,'multiline':False]
['text':' in a signal handler, do a redraw later.','line_number':1297,'multiline':False]
['text':'
 * Called when Vim is going to sleep or execute a shell command.
 * We can't respond to requests for the X selections.  Lose them, otherwise
 * other applications will hang.  But first copy the text to cut buffer 0.
 ','line_number':1312,'multiline':True]
['text':'
 * Save clipboard text to restore later.
 ','line_number':1333,'multiline':True]
['text':'
 * Restore clipboard text if no one own the X selection.
 ','line_number':1345,'multiline':True]
['text':'
 * If the machine has job control, use it to suspend the program,
 * otherwise fake it by starting a new shell.
 ','line_number':1371,'multiline':True]
['text':' needed to make cursor visible on some systems','line_number':1384,'multiline':False]
['text':' needed to disable mouse on some systems','line_number':1386,'multiline':False]
['text':' send ourselves a STOP signal','line_number':1395,'multiline':False]
['text':'
     * Wait for the SIGCONT signal to be handled. It generally happens
     * immediately, but somehow not all the time, probably because it's handled
     * in another thread. Do not call pause() because there would be race
     * condition which would hang Vim if signal happened in between the test of
     * sigcont_received and the call to pause(). If signal is not yet received,
     * sleep 0, 1, 2, 3 ms. Don't bother waiting further if signal is not
     * received after 1+2+3 ms (not expected to happen).
     ','line_number':1398,'multiline':True]
['text':' Check whether we were invoked with SIGTSTP set to be ignored. If it is','line_number':1431,'multiline':False]
['text':' that indicates the shell (or program) that launched us does not support','line_number':1432,'multiline':False]
['text':' tty job control and thus we should ignore that signal. If invoked as a','line_number':1433,'multiline':False]
['text':' restricted editor (e.g., as "rvim") SIGTSTP is always ignored.','line_number':1434,'multiline':False]
['text':'
     * WINDOW CHANGE signal is handled with sig_winch().
     ','line_number':1451,'multiline':True]
['text':' See mch_init() for the conditions under which we ignore SIGTSTP.','line_number':1458,'multiline':False]
['text':' In the GUI default TSTP processing is OK.','line_number':1459,'multiline':False]
['text':' Checking both gui.in_use and gui.starting because gui.in_use is not set','line_number':1460,'multiline':False]
['text':' at this point (set after menus are displayed), but gui.starting is set.','line_number':1461,'multiline':False]
['text':'
     * We want to ignore breaking of PIPEs.
     ','line_number':1472,'multiline':True]
['text':'
     * Call user's handler on SIGUSR1
     ','line_number':1483,'multiline':True]
['text':'
     * Ignore alarm signals (Perl's alarm() generates it).
     ','line_number':1489,'multiline':True]
['text':'
     * Catch SIGPWR (power failure?) to preserve the swap files, so that no
     * work will be lost.
     ','line_number':1497,'multiline':True]
['text':'
     * Arrange for other signals to gracefully shutdown Vim.
     ','line_number':1504,'multiline':True]
['text':'
     * When the GUI is running, ignore the hangup signal.
     ','line_number':1510,'multiline':True]
['text':'
 * Catch CTRL-C (only works while in Cooked mode).
 ','line_number':1519,'multiline':True]
['text':' SIGCONT isn't in the list, because its default action is ignore','line_number':1534,'multiline':False]
['text':' Setup to use the alternate stack for the signal function.','line_number':1553,'multiline':False]
['text':' On Linux, with glibc compiled for kernel 2.2, there is a bug in','line_number':1557,'multiline':False]
['text':' thread handling in combination with using the alternate stack:','line_number':1558,'multiline':False]
['text':' pthread library functions try to use the stack pointer to','line_number':1559,'multiline':False]
['text':' identify the current thread, causing a SEGV signal, which','line_number':1560,'multiline':False]
['text':' recursively calls deathtrap() and hangs.','line_number':1561,'multiline':False]
['text':' Setup to use the alternate stack for the signal function.','line_number':1571,'multiline':False]
['text':' Deal with non-deadly signals.','line_number':1583,'multiline':False]
['text':' SIGCONT isn't in the list, because its default action is ignore','line_number':1608,'multiline':False]
['text':'
 * Handling of SIGHUP, SIGQUIT and SIGTERM:
 * "when" == a signal:       when busy, postpone and return FALSE, otherwise
 *			     return TRUE
 * "when" == SIGNAL_BLOCK:   Going to be busy, block signals
 * "when" == SIGNAL_UNBLOCK: Going to wait, unblock signals, use postponed
 *			     signal
 * Returns TRUE when Vim should exit.
 ','line_number':1622,'multiline':True]
['text':' exit!','line_number':1651,'multiline':False]
['text':' break any loops','line_number':1656,'multiline':False]
['text':'
 * Check_win checks whether we have an interactive stdout.
 ','line_number':1662,'multiline':True]
['text':'
 * Return TRUE if the input comes from a terminal, FALSE otherwise.
 ','line_number':1673,'multiline':True]
['text':'
 * Give a message about the elapsed time for opening the X window.
 ','line_number':1688,'multiline':True]
['text':'
 * A few functions shared by X11 title and clipboard code.
 ','line_number':1700,'multiline':True]
['text':'
 * X Error handler, otherwise X just exits!  (very rude) -- webb
 ','line_number':1706,'multiline':True]
['text':' In the GUI we cannot print a message and continue, because no X calls','line_number':1715,'multiline':False]
['text':' are allowed here (causes my system to hang).  Silently continuing seems','line_number':1716,'multiline':False]
['text':' like the best alternative.  Do preserve files, in case we crash.','line_number':1717,'multiline':False]
['text':' NOTREACHED','line_number':1725,'multiline':False]
['text':'
 * Another X Error handler, just used to check for errors.
 ','line_number':1728,'multiline':True]
['text':'
 * Return TRUE when connection to the X server is desired.
 ','line_number':1738,'multiline':True]
['text':' No point in connecting if we are exiting or dying.','line_number':1744,'multiline':False]
['text':' Check for a match with "exclude:" from 'clipboard'.','line_number':1755,'multiline':False]
['text':' Just in case we get called recursively, return FALSE.  This could','line_number':1758,'multiline':False]
['text':' happen if vpeekc() is used while executing the prog and it causes a','line_number':1759,'multiline':False]
['text':' related callback to be invoked.','line_number':1760,'multiline':False]
['text':'
 * An X IO Error handler, used to catch error while opening the display.
 ','line_number':1772,'multiline':True]
['text':' This function should not return, it causes exit().  Longjump instead.','line_number':1778,'multiline':False]
['text':' avoid the compiler complains about missing return value','line_number':1781,'multiline':False]
['text':'
 * An X IO Error handler, used to catch terminal errors.
 ','line_number':1786,'multiline':True]
['text':' Try reconnecting five times','line_number':1795,'multiline':False]
['text':' This function should not return, it causes exit().  Longjump instead.','line_number':1800,'multiline':False]
['text':' avoid the compiler complains about missing return value','line_number':1803,'multiline':False]
['text':'
 * If the X11 connection was lost try to restore it.
 * Helps when the X11 server was stopped and restarted while Vim was inactive
 * (e.g. through tmux).
 ','line_number':1807,'multiline':True]
['text':' No point in restoring the connecting if we are exiting or dying.','line_number':1815,'multiline':False]
['text':' This has been reported to avoid Vim getting stuck.','line_number':1821,'multiline':False]
['text':' freed by XtDestroyApplicationContext()','line_number':1826,'multiline':False]
['text':' Try reconnecting five times','line_number':1850,'multiline':False]
['text':'
 * Test if "dpy" and x11_window are valid by getting the window title.
 * I don't actually want it yet, so there may be a simpler call to use, but
 * this will cause the error handler x_error_check() to be called if anything
 * is wrong, such as the window pointer being invalid (as can happen when the
 * user changes his DISPLAY, but not his WINDOWID) -- webb
 ','line_number':1855,'multiline':True]
['text':'
 * try to get x11 window and display
 *
 * return FAIL for failure, OK otherwise
 ','line_number':1887,'multiline':True]
['text':' x11_display not set here','line_number':1897,'multiline':False]
['text':' x11_display opened here','line_number':1898,'multiline':False]
['text':' x11_display used from gui.dpy','line_number':1899,'multiline':False]
['text':' x11_display used from xterm_dpy','line_number':1900,'multiline':False]
['text':' X just exits if it finds an error otherwise!','line_number':1906,'multiline':False]
['text':'
	 * If the X11 display was opened here before, for the window where Vim
	 * was started, close that one now to avoid a memory leak.
	 ','line_number':1914,'multiline':True]
['text':' GUI must have stopped somehow, clear x11_display','line_number':1933,'multiline':False]
['text':' When started with the "-X" argument, don't try connecting.','line_number':1940,'multiline':False]
['text':'
     * If WINDOWID not set, should try another method to find out
     * what the current window number is. The only code I know for
     * this is very complicated.
     * We assume that zero is invalid for WINDOWID.
     ','line_number':1944,'multiline':True]
['text':' x11_display may have been set to xterm_dpy elsewhere','line_number':1955,'multiline':False]
['text':' We may have checked it already, but Gnome terminal can move us to','line_number':1960,'multiline':False]
['text':' another window, so we need to check every time.','line_number':1961,'multiline':False]
['text':'
	     * If the X11 display was opened here before, for the window where
	     * Vim was started, close that one now to avoid a memory leak.
	     ','line_number':1964,'multiline':True]
['text':' probably bad $WINDOWID','line_number':1975,'multiline':False]
['text':' Have already been here and set this','line_number':1988,'multiline':False]
['text':' Don't do all these X calls again','line_number':1989,'multiline':False]
['text':'
	 * Opening the Display may hang if the DISPLAY setting is wrong, or
	 * the network connection is bad.  Set an alarm timer to get out.
	 ','line_number':2004,'multiline':True]
['text':' Maybe window id is bad','line_number':2032,'multiline':False]
['text':'
 * Determine original x11 Window Title
 ','line_number':2051,'multiline':True]
['text':'
 * Determine original x11 Window icon
 ','line_number':2060,'multiline':True]
['text':' could not get old icon, use terminal name','line_number':2070,'multiline':False]
['text':' get title string','line_number':2084,'multiline':False]
['text':' Get window/icon name if any','line_number':2094,'multiline':False]
['text':'
     * If terminal is xterm, then x11_window may be a child window of the
     * outer xterm window that actually contains the window/icon name, so
     * keep traversing up the tree until a window with a title/icon is
     * found.
     ','line_number':2100,'multiline':True]
['text':' Previously this was only done for xterm and alike.  I don't see a','line_number':2106,'multiline':False]
['text':' reason why it would fail for other terminal emulators.','line_number':2107,'multiline':False]
['text':' if (term_is_xterm)','line_number':2108,'multiline':False]
['text':' Xutf8 functions are not available on older systems. Note that on some','line_number':2179,'multiline':False]
['text':' systems X_HAVE_UTF8_STRING may be defined in a header file but','line_number':2180,'multiline':False]
['text':' Xutf8SetWMProperties() is not in the X11 library.  Configure checks for','line_number':2181,'multiline':False]
['text':' that and defines HAVE_XUTF8SETWMPROPERTIES.','line_number':2182,'multiline':False]
['text':'
 * Set x11 Window Title
 *
 * get_x11_windis() must be called before this and have returned OK
 ','line_number':2189,'multiline':True]
['text':' XmbSetWMProperties() and Xutf8SetWMProperties() should use a STRING','line_number':2197,'multiline':False]
['text':' when possible, COMPOUND_TEXT otherwise.  COMPOUND_TEXT isn't','line_number':2198,'multiline':False]
['text':' supported everywhere and STRING doesn't work for multi-byte titles.','line_number':2199,'multiline':False]
['text':' directly from example 3-18 "basicwin" of Xlib Programming Manual','line_number':2215,'multiline':False]
['text':'
 * Set x11 Window icon
 *
 * get_x11_windis() must be called before this and have returned OK
 ','line_number':2227,'multiline':True]
['text':' See above for comments about using X*SetWMProperties().','line_number':2235,'multiline':False]
['text':' FEAT_X11','line_number':2262,'multiline':False]
['text':' FEAT_X11','line_number':2283,'multiline':False]
['text':'
 * Set the window title and icon.
 ','line_number':2297,'multiline':True]
['text':' no terminal name (yet)','line_number':2306,'multiline':False]
['text':' nothing to do','line_number':2308,'multiline':False]
['text':' When one of the X11 functions causes a deadly signal, we get here again','line_number':2311,'multiline':False]
['text':' recursively.  Avoid hanging then (something is probably locked).','line_number':2312,'multiline':False]
['text':'
     * if the window ID and the display is known, we may use X11 calls
     ','line_number':2317,'multiline':True]
['text':'
     * Note: if "t_ts" is set, title is set with escape sequence rather
     *	     than x11 calls, because the x11 calls don't always work
     ','line_number':2331,'multiline':True]
['text':' first call but not in GUI, save title','line_number':2346,'multiline':False]
['text':' it's OK if t_fs is empty','line_number':2349,'multiline':False]
['text':' don't do this if GTK+ is running','line_number':2354,'multiline':False]
['text':' x11','line_number':2356,'multiline':False]
['text':' first call, save icon','line_number':2372,'multiline':False]
['text':' set icon start','line_number':2377,'multiline':False]
['text':' set icon end','line_number':2379,'multiline':False]
['text':' don't do this if GTK+ is running','line_number':2385,'multiline':False]
['text':' x11','line_number':2387,'multiline':False]
['text':'
 * Restore the window/icon title.
 * "which" is one of:
 *  SAVE_RESTORE_TITLE only restore title
 *  SAVE_RESTORE_ICON  only restore icon
 *  SAVE_RESTORE_BOTH  restore title and icon
 ','line_number':2394,'multiline':True]
['text':' Only restore the title or icon when it has been set.','line_number':2406,'multiline':False]
['text':' When using "oldtitle" make a copy, it might be freed halfway.','line_number':2407,'multiline':False]
['text':' pop and push from/to the stack','line_number':2423,'multiline':False]
['text':'
 * Return TRUE if "name" looks like some xterm name.
 * This matches "xterm.*", thus "xterm-256color", "xterm-kitty", etc.
 * Do not consider "xterm-kitty" an xterm, it is not fully xterm compatible,
 * using the "xterm-kitty" terminfo entry should work better.
 * Seiichi Sato mentioned that "mlterm" works like xterm.
 ','line_number':2430,'multiline':True]
['text':'
 * Return TRUE if "name" appears to be that of a terminal
 * known to support the xterm-style mouse protocol.
 * Relies on term_is_xterm having been set to its correct value.
 ','line_number':2453,'multiline':True]
['text':'
 * Return non-zero when using an xterm mouse, according to 'ttymouse'.
 * Return 1 for "xterm".
 * Return 2 for "xterm2".
 * Return 3 for "urxvt".
 * Return 4 for "sgr".
 ','line_number':2472,'multiline':True]
['text':'
 * Return TRUE if "name" is an iris-ansi terminal name.
 ','line_number':2493,'multiline':True]
['text':'
 * Return TRUE if "name" is a vt300-like terminal name.
 ','line_number':2506,'multiline':True]
['text':' Actually all ANSI compatible terminals should be here.','line_number':2514,'multiline':False]
['text':' Catch at least VT1xx - VT5xx','line_number':2515,'multiline':False]
['text':'
 * Insert user name in s[len].
 * Return OK if a name found.
 ','line_number':2522,'multiline':True]
['text':'
 * Insert user name for "uid" in s[len].
 * Return OK if a name found.
 ','line_number':2537,'multiline':True]
['text':' assumes s is long enough','line_number':2554,'multiline':False]
['text':' a number is not a name','line_number':2555,'multiline':False]
['text':'
 * Insert host name is s[len].
 ','line_number':2558,'multiline':True]
['text':' HAVE_SYS_UTSNAME_H','line_number':2573,'multiline':False]
['text':' make sure it's terminated','line_number':2587,'multiline':False]
['text':' HAVE_SYS_UTSNAME_H','line_number':2589,'multiline':False]
['text':'
 * return process ID
 ','line_number':2591,'multiline':True]
['text':'
 * return TRUE if process "pid" is still running
 ','line_number':2600,'multiline':True]
['text':' If there is no error the process must be running.','line_number':2606,'multiline':False]
['text':' If the error is ESRCH then the process is not running.','line_number':2610,'multiline':False]
['text':' If the process is running and owned by another user we get EPERM.  With','line_number':2614,'multiline':False]
['text':' other errors the process might be running, assuming it is then.','line_number':2615,'multiline':False]
['text':'
 * Get name of current directory into buffer "buf" of length "len" bytes.
 * "len" must be at least PATH_MAX.
 * Return OK for success, FAIL for failure.
 ','line_number':2634,'multiline':True]
['text':'
 * Get absolute file name into "buf[len]".
 *
 * return FAIL for failure, OK for success
 ','line_number':2654,'multiline':True]
['text':' also expand when already absolute path','line_number':2664,'multiline':False]
['text':' TRUE when fchdir() doesn't work','line_number':2669,'multiline':False]
['text':' Cygwin docs mention MAX_PATH, but','line_number':2675,'multiline':False]
['text':' it's not always defined','line_number':2676,'multiline':False]
['text':'
     * This helps for when "/etc/hosts" is a symlink to "c:/something/hosts".
     ','line_number':2684,'multiline':True]
['text':' Use CCP_RELATIVE to avoid that it sometimes returns a path that ends in','line_number':2688,'multiline':False]
['text':' a forward slash.','line_number':2689,'multiline':False]
['text':' Expand it if forced or not an absolute path.','line_number':2698,'multiline':False]
['text':' Do not do it for "/file", the result is always "/".','line_number':2699,'multiline':False]
['text':'
	 * If the file name has a path, change to that directory for a moment,
	 * and then get the directory (and get back to where we were).
	 * This will get the correct path name with "../" things.
	 ','line_number':2703,'multiline':True]
['text':' for "/path/dir/.." include the "/.."','line_number':2711,'multiline':False]
['text':'
	     * Use fchdir() if possible, it's said to be faster and more
	     * reliable.  But on SunOS 4 it might not work.  Check this by
	     * doing a fchdir() right now.
	     ','line_number':2715,'multiline':True]
['text':' don't try again','line_number':2727,'multiline':False]
['text':' Only change directory when we are sure we can return to where','line_number':2732,'multiline':False]
['text':' we are now.  After doing "su" chdir(".") might not work.','line_number':2733,'multiline':False]
['text':' can't get current dir: don't chdir','line_number':2741,'multiline':False]
['text':' The directory is copied into buf[], to be able to remove','line_number':2746,'multiline':False]
['text':' the file name without changing it (could be a string in','line_number':2747,'multiline':False]
['text':' read-only memory)','line_number':2748,'multiline':False]
['text':' Path does not exist (yet).  For a full path fail,','line_number':2756,'multiline':False]
['text':' will use the path as-is.  For a relative path use','line_number':2757,'multiline':False]
['text':' the current directory and append the file name.','line_number':2758,'multiline':False]
['text':' no space for trailing "/"','line_number':2803,'multiline':False]
['text':' Catch file names which are too long.','line_number':2811,'multiline':False]
['text':' Do not append ".", "/dir/." is equal to "/dir".','line_number':2815,'multiline':False]
['text':'
 * Return TRUE if "fname" does not depend on the current directory.
 ','line_number':2822,'multiline':True]
['text':'
 * Set the case of the file name, if it already exists.  This will cause the
 * file name to remain exactly the same.
 * Only required for file systems where case is ignored and preserved.
 ','line_number':2839,'multiline':True]
['text':' buffer size, only used when name gets longer','line_number':2847,'multiline':False]
['text':' Open the directory where the file is located.','line_number':2857,'multiline':False]
['text':' Only accept names that differ in case and are the same byte','line_number':2877,'multiline':False]
['text':' length. TODO: accept different length name.','line_number':2878,'multiline':False]
['text':' Verify the inode is equal.','line_number':2885,'multiline':False]
['text':'
 * Get file permissions for 'name'.
 * Returns -1 when it doesn't exist.
 ','line_number':2903,'multiline':True]
['text':' Keep the #ifdef outside of stat(), it may be a macro.','line_number':2912,'multiline':False]
['text':' The top bit makes the value negative, which means the file doesn't','line_number':2920,'multiline':False]
['text':' exist.  Remove the bit, we don't use it.','line_number':2921,'multiline':False]
['text':'
 * Set file permission for "name" to "perm".
 * Return FAIL for failure, OK otherwise.
 ','line_number':2928,'multiline':True]
['text':'
 * Set file permission for open file "fd" to "perm".
 * Return FAIL for failure, OK otherwise.
 ','line_number':2945,'multiline':True]
['text':'
 * Copy security info from "from_file" to "to_file".
 ','line_number':2972,'multiline':True]
['text':' Use "char *" instead of "security_context_t" to avoid a deprecation','line_number':2987,'multiline':False]
['text':' warning.','line_number':2988,'multiline':False]
['text':' If the filesystem doesn't support extended attributes,','line_number':2994,'multiline':False]
['text':' the original had no special security context and the','line_number':2995,'multiline':False]
['text':' target cannot have one either.','line_number':2996,'multiline':False]
['text':' HAVE_SELINUX','line_number':3025,'multiline':False]
['text':'
 * Copy security info from "from_file" to "to_file".
 ','line_number':3028,'multiline':True]
['text':' not supported or no attributes to copy','line_number':3051,'multiline':False]
['text':' get the name of the attribute to copy','line_number':3058,'multiline':False]
['text':' get the value of the attribute in buffer','line_number':3061,'multiline':False]
['text':' copy the attribute value of buffer','line_number':3065,'multiline':False]
['text':' what reason of not having the attribute value?','line_number':3078,'multiline':False]
['text':' extended attributes aren't supported or enabled','line_number':3082,'multiline':False]
['text':' should a message be echoed? not sure...','line_number':3083,'multiline':False]
['text':' leave because it isn't useful to continue','line_number':3084,'multiline':False]
['text':' no enough size OR unexpected error','line_number':3088,'multiline':False]
['text':' FALLTHROUGH to remove the attribute','line_number':3094,'multiline':False]
['text':' no attribute of this name','line_number':3097,'multiline':False]
['text':' Silently ignore errors, apparently this happens when','line_number':3099,'multiline':False]
['text':' smack is not actually being used.','line_number':3100,'multiline':False]
['text':' HAVE_SMACK','line_number':3106,'multiline':False]
['text':'
 * Copy extended attributes from_file to to_file
 ','line_number':3109,'multiline':True]
['text':' get the length of the extended attributes','line_number':3126,'multiline':False]
['text':' not supported or no attributes to copy','line_number':3128,'multiline':False]
['text':' only set the attribute in the second round','line_number':3150,'multiline':False]
['text':' add one for terminating null','line_number':3177,'multiline':False]
['text':'
 * Return a pointer to the ACL of file "fname" in allocated memory.
 * Return NULL if the ACL is not available for whatever reason.
 ','line_number':3199,'multiline':True]
['text':' HAVE_AIX_ACL','line_number':3260,'multiline':False]
['text':' HAVE_SOLARIS_ACL','line_number':3261,'multiline':False]
['text':' HAVE_SOLARIS_ZFS_ACL','line_number':3262,'multiline':False]
['text':' HAVE_POSIX_ACL','line_number':3263,'multiline':False]
['text':'
 * Set the ACL of file "fname" to "acl" (unless it's NULL).
 ','line_number':3267,'multiline':True]
['text':' HAVE_AIX_ACL','line_number':3287,'multiline':False]
['text':' HAVE_SOLARIS_ACL','line_number':3288,'multiline':False]
['text':' HAVE_SOLARIS_ZFS_ACL','line_number':3289,'multiline':False]
['text':' HAVE_POSIX_ACL','line_number':3290,'multiline':False]
['text':' HAVE_AIX_ACL','line_number':3310,'multiline':False]
['text':' HAVE_SOLARIS_ACL','line_number':3311,'multiline':False]
['text':' HAVE_SOLARIS_ZFS_ACL','line_number':3312,'multiline':False]
['text':' HAVE_POSIX_ACL','line_number':3313,'multiline':False]
['text':'
 * Set hidden flag for "name".
 ','line_number':3317,'multiline':True]
['text':' can't hide a file','line_number':3323,'multiline':False]
['text':'
 * return TRUE if "name" is a directory or a symlink to a directory
 * return FALSE if "name" is not a directory
 * return FALSE for error
 ','line_number':3326,'multiline':True]
['text':' Some stat()s don't flag "" as an error.','line_number':3336,'multiline':False]
['text':'
 * return TRUE if "name" is a directory, NOT a symlink to a directory
 * return FALSE if "name" is not a directory
 * return FALSE for error
 ','line_number':3343,'multiline':True]
['text':' Some stat()s don't flag "" as an error.','line_number':3353,'multiline':False]
['text':'
 * Return 1 if "name" is an executable file, 0 if not or it doesn't exist.
 ','line_number':3360,'multiline':True]
['text':' Like on Unix system file can have executable rights but not necessarily','line_number':3371,'multiline':False]
['text':' be an executable, but on Unix is not a default for an ordinary file to','line_number':3372,'multiline':False]
['text':' have an executable flag - on VMS it is in most cases.','line_number':3373,'multiline':False]
['text':' Therefore, this check does not have any sense - let keep us to the','line_number':3374,'multiline':False]
['text':' conventions instead:','line_number':3375,'multiline':False]
['text':' *.COM and *.EXE files are the executables - the rest are not. This is','line_number':3376,'multiline':False]
['text':' not ideal but better than it was.','line_number':3377,'multiline':False]
['text':'
 * Return TRUE if "name" can be found in $PATH and executed, FALSE if not.
 * If "use_path" is FALSE only check if "name" is executable.
 * Return -1 if unknown.
 ','line_number':3391,'multiline':True]
['text':' When "use_path" is false and if it's an absolute or relative path don't','line_number':3403,'multiline':False]
['text':' need to use $PATH.','line_number':3404,'multiline':False]
['text':' There must be a path separator, files in the current directory','line_number':3407,'multiline':False]
['text':' can't be executed.','line_number':3408,'multiline':False]
['text':'
     * Walk through all entries in $PATH to check if "name" exists there and
     * is an executable file.
     ','line_number':3430,'multiline':True]
['text':' empty entry means current dir','line_number':3439,'multiline':False]
['text':'
 * Check what "name" is:
 * NODE_NORMAL: file or directory (or doesn't exist)
 * NODE_WRITABLE: writable device, socket, fifo, etc.
 * NODE_OTHER: non-writable things
 ','line_number':3469,'multiline':True]
['text':' block device isn't writable','line_number':3484,'multiline':False]
['text':' Everything else is writable?','line_number':3486,'multiline':False]
['text':'
     * Setup an alternative stack for signals.  Helps to catch signals when
     * running out of stack space.
     * Use of sigaltstack() is preferred, it's more portable.
     * Ignore any errors.
     ','line_number':3504,'multiline':True]
['text':' Lesstif crashes here, lose some memory','line_number':3530,'multiline':False]
['text':' freed by XtDestroyApplicationContext()','line_number':3537,'multiline':False]
['text':'
 * Output a newline when exiting.
 * Make sure the newline goes to the same stream as the text.
 ','line_number':3558,'multiline':True]
['text':' get original colors back','line_number':3581,'multiline':False]
['text':' clear the rest of the display','line_number':3582,'multiline':False]
['text':' may have moved the cursor','line_number':3583,'multiline':False]
['text':' restore xterm title and icon name','line_number':3615,'multiline':False]
['text':'
	 * When t_ti is not empty but it doesn't cause swapping terminal
	 * pages, need to output a newline when msg_didout is set.  But when
	 * t_ti does swap pages it should not go to the shell page.  Do this
	 * before stoptermcap().
	 ','line_number':3620,'multiline':True]
['text':' Stop termcap: May need to check for T_CRV response, which','line_number':3629,'multiline':False]
['text':' requires RAW mode.','line_number':3630,'multiline':False]
['text':'
	 * A newline is only required after a message in the alternate screen.
	 * This is set to TRUE by wait_return().
	 ','line_number':3633,'multiline':True]
['text':' Cursor may have been switched off without calling starttermcap()','line_number':3640,'multiline':False]
['text':' when doing "vim -u vimrc" and vimrc contains ":q".','line_number':3641,'multiline':False]
['text':' remove all memfiles','line_number':3646,'multiline':False]
['text':' Flush coverage info before possibly being killed by a deadly signal.','line_number':3649,'multiline':False]
['text':' A core dump won't be created if the signal handler','line_number':3664,'multiline':False]
['text':' doesn't return, so we can't call exit()','line_number':3665,'multiline':False]
['text':' Die using the signal we caught','line_number':3687,'multiline':False]
['text':'
 * Get the file descriptor to use for tty operations.
 ','line_number':3693,'multiline':True]
['text':' On SunOS: Get the terminal parameters from "fd", or the slave device of','line_number':3702,'multiline':False]
['text':' "fd" when it is a master device.','line_number':3703,'multiline':False]
['text':' for "old" tty systems','line_number':3737,'multiline':False]
['text':' ~ICRNL enables typing ^V^M','line_number':3768,'multiline':False]
['text':' ~IXON disables CTRL-S stopping output, so that it can be mapped.','line_number':3769,'multiline':False]
['text':' IEXTEN enables typing ^V on SOLARIS','line_number':3773,'multiline':False]
['text':' Don't map NL -> CR NL, we do it ourselves.','line_number':3777,'multiline':False]
['text':' Also disable expanding tabs if possible.','line_number':3778,'multiline':False]
['text':' return after 1 char','line_number':3789,'multiline':False]
['text':' don't wait','line_number':3790,'multiline':False]
['text':' Also reset ICANON here, otherwise on Solaris select() won't see','line_number':3794,'multiline':False]
['text':' typeahead characters.','line_number':3795,'multiline':False]
['text':' return after 1 char','line_number':3797,'multiline':False]
['text':' don't wait','line_number':3798,'multiline':False]
['text':' A signal may cause tcsetattr() to fail (e.g., SIGCONT).  Retry a','line_number':3805,'multiline':False]
['text':' few times.','line_number':3806,'multiline':False]
['text':'
     * for "old" tty systems
     ','line_number':3816,'multiline':True]
['text':' for hpux 9.0','line_number':3820,'multiline':False]
['text':'
 * Try to get the code for "t_kb" from the stty setting
 *
 * Even if termcap claims a backspace key, the user's setting *should*
 * prevail.  stty knows more about reality than termcap does, and if
 * somebody's usual erase key is DEL (which, for most BSD users, it will
 * be), they're going to get really annoyed if their erase key starts
 * doing forward deletes for no reason. (Eric Fischer)
 ','line_number':3844,'multiline':True]
['text':' If <BS> and <DEL> are now the same, redefine <DEL>.','line_number':3868,'multiline':False]
['text':'
 * Obtain the characters that Backspace and Enter produce on "fd".
 * Returns OK or FAIL.
 ','line_number':3874,'multiline':True]
['text':' for "old" tty systems','line_number':3903,'multiline':False]
['text':' VMS','line_number':3918,'multiline':False]
['text':'
 * Set mouse clicks on or off and possible enable mouse movement events.
 ','line_number':3922,'multiline':True]
['text':' Make sure not tracing mouse movements.  Important when a button-down','line_number':3935,'multiline':False]
['text':' was received but no release yet.','line_number':3936,'multiline':False]
['text':' return quickly if nothing to do','line_number':3945,'multiline':False]
['text':' SGR mode supports columns above 223','line_number':3964,'multiline':False]
['text':' disable mouse movement events, enabling is below','line_number':3974,'multiline':False]
['text':' enable mouse events, use mouse tracking if available','line_number':3981,'multiline':False]
['text':' disable mouse events, could probably always send the same','line_number':3990,'multiline':False]
['text':' enable mouse events','line_number':3999,'multiline':False]
['text':' disable mouse events','line_number':4001,'multiline':False]
['text':' D - Enable Mouse up/down messages','line_number':4044,'multiline':False]
['text':' L - Enable Left Button Reporting','line_number':4045,'multiline':False]
['text':' M - Enable Middle Button Reporting','line_number':4046,'multiline':False]
['text':' R - Enable Right Button Reporting','line_number':4047,'multiline':False]
['text':' K - Enable SHIFT and CTRL key Reporting','line_number':4048,'multiline':False]
['text':' + - Enable Advanced messaging of mouse moves and up/down messages','line_number':4049,'multiline':False]
['text':' Q - Quiet No Ack','line_number':4050,'multiline':False]
['text':' # - Numeric value of mouse pointer required','line_number':4051,'multiline':False]
['text':'	  0 = Multiview 2000 cursor, used as standard','line_number':4052,'multiline':False]
['text':'	  1 = Windows Arrow','line_number':4053,'multiline':False]
['text':'	  2 = Windows I Beam','line_number':4054,'multiline':False]
['text':'	  3 = Windows Hour Glass','line_number':4055,'multiline':False]
['text':'	  4 = Windows Cross Hair','line_number':4056,'multiline':False]
['text':'	  5 = Windows UP Arrow','line_number':4057,'multiline':False]
['text':' Disables full feedback of pointer movements','line_number':4059,'multiline':False]
['text':' 1 = button press, 6 = release, 7 = drag, 1h...9l = right button','line_number':4076,'multiline':False]
['text':'
 * Called when 'balloonevalterm' changed.
 ','line_number':4087,'multiline':True]
['text':'
 * Set the mouse termcode, depending on the 'term' and 'ttymouse' options.
 ','line_number':4097,'multiline':True]
['text':' force mouse off and maybe on to send possibly new mouse','line_number':4117,'multiline':False]
['text':' activation sequence to the xterm, with(out) drag tracing.','line_number':4118,'multiline':False]
['text':' Conflicts with xterm mouse: "\033[" and "\033[M" ???','line_number':4148,'multiline':False]
['text':' There is no conflict, but one may type "ESC }" from Insert mode.  Don't','line_number':4160,'multiline':False]
['text':' define it in the GUI or when using an xterm.','line_number':4161,'multiline':False]
['text':' Conflicts with xterm mouse: "\033[" and "\033[M"','line_number':4173,'multiline':False]
['text':' same conflict as the dec mouse','line_number':4185,'multiline':False]
['text':'
 * Try to get the current window size:
 * 1. with an ioctl(), most accurate method
 * 2. from the environment variables LINES and COLUMNS
 * 3. from the termcap
 * 4. keep using the old values
 * Return OK when size could be determined, FAIL otherwise.
 ','line_number':4241,'multiline':True]
['text':'
     * 1. try using an ioctl. It is the most accurate method.
     *
     * Try using TIOCGWINSZ first, some systems that have it also define
     * TIOCGSIZE but don't have a struct ttysize.
     ','line_number':4256,'multiline':True]
['text':' When stdout is not a tty, use stdin for the ioctl().','line_number':4267,'multiline':False]
['text':' TIOCGWINSZ','line_number':4279,'multiline':False]
['text':' When stdout is not a tty, use stdin for the ioctl().','line_number':4285,'multiline':False]
['text':' TIOCGSIZE','line_number':4297,'multiline':False]
['text':' TIOCGWINSZ','line_number':4298,'multiline':False]
['text':'
     * 2. get size from environment
     *    When being POSIX compliant ('|' flag in 'cpoptions') this overrules
     *    the ioctl() values!
     ','line_number':4300,'multiline':True]
['text':'
     * 3. try reading "co" and "li" entries from termcap
     ','line_number':4324,'multiline':True]
['text':'
     * 4. If everything fails, use the old values
     ','line_number':4336,'multiline':True]
['text':'
 * Report the windows size "rows" and "cols" to tty "fd".
 ','line_number':4349,'multiline':True]
['text':'
 * Try to set the window size to Rows and Columns.
 ','line_number':4385,'multiline':True]
['text':'
	 * NOTE: if you get an error here that term_set_winsize() is
	 * undefined, check the output of configure.  It could probably not
	 * find a ncurses, termcap or termlib library.
	 ','line_number':4393,'multiline':True]
['text':' don't know where cursor is now','line_number':4400,'multiline':False]
['text':' VMS','line_number':4404,'multiline':False]
['text':'
 * Rows and/or Columns has changed.
 ','line_number':4406,'multiline':True]
['text':' Nothing to do.','line_number':4412,'multiline':False]
['text':'
 * Wait for process "child" to end.
 * Return "child" if it exited properly, <= 0 on error.
 ','line_number':4415,'multiline':True]
['text':' When compiled with Python threads are probably used, in which case','line_number':4427,'multiline':False]
['text':' wait() sometimes hangs for no obvious reason.  Use waitpid()','line_number':4428,'multiline':False]
['text':' instead and loop (like the GUI). Also needed for other interfaces,','line_number':4429,'multiline':False]
['text':' they might call system().','line_number':4430,'multiline':False]
['text':' Wait for 1 to 10 msec before trying again.','line_number':4438,'multiline':False]
['text':'
 * Set the environment for a child process.
 ','line_number':4455,'multiline':True]
['text':'
     * Putenv does not copy the string, it has to remain valid.
     * Use a static array to avoid losing allocated memory.
     * This won't work well when running multiple children...
     ','line_number':4502,'multiline':True]
['text':'
 * Open a PTY, with FD for the master and slave side.
 * When failing "pty_master_fd" and "pty_slave_fd" are -1.
 * When successful both file descriptors are stored and the allocated pty name
 * is stored in both "*name1" and "*name2".
 ','line_number':4542,'multiline':True]
['text':' open pty','line_number':4558,'multiline':False]
['text':' Leaving out O_NOCTTY may lead to waitpid() always returning','line_number':4562,'multiline':False]
['text':' 0 on Mac OS X 10.7 thereby causing freezes. Let's assume','line_number':4563,'multiline':False]
['text':' adding O_NOCTTY always works when defined.','line_number':4564,'multiline':False]
['text':'
 * Send SIGINT to a child process if "c" is an interrupt character.
 ','line_number':4585,'multiline':True]
['text':'
 * Parse "cmd" and return the result in "argvp" which is an allocated array of
 * pointers, the last one is NULL.
 * The "sh_tofree" and "shcf_tofree" must be later freed by the caller.
 ','line_number':4607,'multiline':True]
['text':' out of memory','line_number':4623,'multiline':False]
['text':' Break 'shellcmdflag' into white separated parts.  This doesn't','line_number':4638,'multiline':False]
['text':' handle quoted strings, they are very unlikely to appear.','line_number':4639,'multiline':False]
['text':' out of memory','line_number':4641,'multiline':False]
['text':'
 * Use a terminal window to run a shell command in.
 ','line_number':4662,'multiline':True]
['text':' SHELL_*, see vim.h','line_number':4668,'multiline':False]
['text':' operator arguments','line_number':4678,'multiline':False]
['text':' Find a window to make "buf" curbuf.','line_number':4692,'multiline':False]
['text':' Only when managed to find a window for "buf",','line_number':4696,'multiline':False]
['text':' If terminal_loop() returns OK we got a key that is handled','line_number':4702,'multiline':False]
['text':' in Normal model. We don't do redrawing anyway.','line_number':4703,'multiline':False]
['text':' restore curwin/curbuf and a few other things','line_number':4715,'multiline':False]
['text':' Only require pressing Enter when redrawing, to avoid that system() gets','line_number':4719,'multiline':False]
['text':' the hit-enter prompt even though it didn't output anything.','line_number':4720,'multiline':False]
['text':'
 * Use system() to start the shell: simple but slow.
 ','line_number':4734,'multiline':True]
['text':' SHELL_*, see vim.h','line_number':4740,'multiline':False]
['text':' only needed for unix','line_number':4747,'multiline':False]
['text':' set to normal mode','line_number':4753,'multiline':False]
['text':' chop off any trailing spaces','line_number':4772,'multiline':False]
['text':' The shell may have messed with the mode, always set it.','line_number':4813,'multiline':False]
['text':' set to raw mode','line_number':4815,'multiline':False]
['text':' USE_SYSTEM','line_number':4824,'multiline':False]
['text':' Exit code when shell didn't execute.  Don't use','line_number':4826,'multiline':False]
['text':' 127, some shells use that already','line_number':4827,'multiline':False]
['text':' Exit code if /dev/null can't be opened','line_number':4828,'multiline':False]
['text':'
 * Don't use system(), use fork()/exec().
 ','line_number':4830,'multiline':True]
['text':' SHELL_*, see vim.h','line_number':4836,'multiline':False]
['text':' for pty's','line_number':4852,'multiline':False]
['text':' for pipes','line_number':4856,'multiline':False]
['text':' settmode(TMODE_RAW) called','line_number':4859,'multiline':False]
['text':' set to normal mode','line_number':4863,'multiline':False]
['text':' The shell may have messed with the mode, always set it later.','line_number':4865,'multiline':False]
['text':'
     * For the GUI, when writing the output into the buffer and when reading
     * input from the buffer: Try using a pseudo-tty to get the stdin/stdout
     * of the executed command into the Vim window.  Or use a pipe.
     ','line_number':4871,'multiline':True]
['text':'
	 * Try to open a master pty.
	 * If this works, open the slave pty.
	 * If the slave can't be opened, close the master pty.
	 ','line_number':4883,'multiline':True]
['text':'
	 * If not opening a pty or it didn't work, try using pipes.
	 ','line_number':4890,'multiline':True]
['text':' pipe create OK','line_number':4897,'multiline':False]
['text':' pipe create failed','line_number':4900,'multiline':False]
['text':' pty or pipe opened or not used','line_number':4914,'multiline':False]
['text':' maybe we should use vfork()','line_number':4918,'multiline':False]
['text':' close the pseudo tty','line_number':4931,'multiline':False]
['text':' close the pipes','line_number':4936,'multiline':False]
['text':' child','line_number':4946,'multiline':False]
['text':' handle signals normally','line_number':4948,'multiline':False]
['text':'
		 * Don't want to show any message from the shell.  Can't just
		 * close stdout and stderr though, because some systems will
		 * break if you try to write to them after that, so we must
		 * use dup() to replace them with something else -- webb
		 * Connect stdin to /dev/null too, so ":n `cat`" doesn't hang,
		 * waiting for input.
		 ','line_number':4963,'multiline':True]
['text':'
		 * If any of these open()'s and dup()'s fail, we just continue
		 * anyway.  It's not fatal, and on most systems it will make
		 * no difference at all.  On a few it will cause the execvp()
		 * to exit with a non-zero status even when the completion
		 * could be done, which is nothing too serious.  If the open()
		 * or dup() failed we'd just do the same thing ourselves
		 * anyway -- webb
		 ','line_number':4976,'multiline':True]
['text':' To replace stdin  (fd 0)','line_number':4987,'multiline':False]
['text':' To replace stdout (fd 1)','line_number':4988,'multiline':False]
['text':' To replace stderr (fd 2)','line_number':4989,'multiline':False]
['text':' Don't need this now that we've duplicated it','line_number':4991,'multiline':False]
['text':' Create our own process group, so that the child and all its','line_number':5003,'multiline':False]
['text':' children can be kill()ed.  Don't do this when using pipes,','line_number':5004,'multiline':False]
['text':' because stdin is not a tty, we would lose /dev/tty.','line_number':5005,'multiline':False]
['text':' When doing "!xterm&" and 'shell' is bash: the shell','line_number':5010,'multiline':False]
['text':' will exit and send SIGHUP to all processes in its','line_number':5011,'multiline':False]
['text':' group, killing the just started process.  Ignore SIGHUP','line_number':5012,'multiline':False]
['text':' to avoid that. (suggested by Simon Schubert)','line_number':5013,'multiline':False]
['text':' push stream discipline modules','line_number':5021,'multiline':False]
['text':' Try to become controlling tty (probably doesn't work,','line_number':5025,'multiline':False]
['text':' unless run by root)','line_number':5026,'multiline':False]
['text':'
		 * stderr is only redirected when using the GUI, so that a
		 * program like gpg can still access the terminal to get a
		 * passphrase using stderr.
		 ','line_number':5033,'multiline':True]
['text':' close master side of pty','line_number':5041,'multiline':False]
['text':' set up stdin/stdout/stderr for the child','line_number':5043,'multiline':False]
['text':' has been dupped, close it now','line_number':5054,'multiline':False]
['text':' set up stdin for the child','line_number':5059,'multiline':False]
['text':' set up stdout for the child','line_number':5065,'multiline':False]
['text':' set up stderr for the child','line_number':5074,'multiline':False]
['text':'
	     * There is no type cast for the argv, because the type may be
	     * different on different machines. This may cause a warning
	     * message with strict compilers, don't worry about it.
	     * Call _exit() instead of exit() to avoid closing the connection
	     * to the X server (esp. with GTK, which uses atexit()).
	     ','line_number':5082,'multiline':True]
['text':' exec failed, return failure code','line_number':5090,'multiline':False]
['text':' parent','line_number':5092,'multiline':False]
['text':'
	     * While child is running, ignore terminating signals.
	     * Do catch CTRL-C, so that "got_int" is set.
	     ','line_number':5094,'multiline':True]
['text':'
	     * For the GUI we redirect stdin, stdout and stderr to our window.
	     * This is also used to pipe stdin/stdout to/from the external
	     * command.
	     ','line_number':5104,'multiline':True]
['text':' length for buffer, pseudo tty limit is 128','line_number':5115,'multiline':False]
['text':' valid bytes in buffer[]','line_number':5117,'multiline':False]
['text':' TypeAHead','line_number':5118,'multiline':False]
['text':' valid bytes in ta_buf[]','line_number':5119,'multiline':False]
['text':'
		 * Write to the child if there are typed characters.
		 * Read from the child if there are characters available.
		 *   Repeat the reading a few times if more characters are
		 *   available. Need to check for typed keys now and then, but
		 *   not too often (delays when no chars are available).
		 * This loop is quit if no characters can be read from the pty
		 * (WaitForChar detected special condition), or there are no
		 * characters available and the child has exited.
		 * Only check if the child has exited when there is no more
		 * output. The child may exit before all the output has
		 * been printed.
		 *
		 * Currently this busy loops!
		 * This can probably dead-lock when the write blocks!
		 ','line_number':5147,'multiline':True]
['text':' don't redraw at window resize','line_number':5166,'multiline':False]
['text':' Fork a process that will write the lines to the','line_number':5170,'multiline':False]
['text':' external program.','line_number':5171,'multiline':False]
['text':' child','line_number':5176,'multiline':False]
['text':' NL -> NUL translation','line_number':5190,'multiline':False]
['text':' Finished a line, add a NL, unless this line','line_number':5202,'multiline':False]
['text':' should not have one.','line_number':5203,'multiline':False]
['text':' finished all the lines, close pipe','line_number':5215,'multiline':False]
['text':' parent','line_number':5227,'multiline':False]
['text':'
		     * Check if keys have been typed, write them to the child
		     * if there are any.
		     * Don't do this if we are expanding wild cards (would eat
		     * typeahead).
		     * Don't do this when filtering and terminal is in cooked
		     * mode, the shell command will handle the I/O.  Avoids
		     * that a typed password is echoed for ssh or gpg command.
		     * Don't get characters when the child has already
		     * finished (wait_pid == 0).
		     * Don't read characters unless we didn't get output for a
		     * while (noread_cnt > 4), avoids that ":r !ls" eats
		     * typeahead.
		     ','line_number':5243,'multiline':True]
['text':' Get extra characters when we don't have any.','line_number':5271,'multiline':False]
['text':' Reset the counter and timer.','line_number':5272,'multiline':False]
['text':'
			 * For pipes:
			 * Check for CTRL-C: send interrupt signal to child.
			 * Check for CTRL-D: EOF, close pipe to child.
			 ','line_number':5281,'multiline':True]
['text':'
			     * Send SIGINT to the child's group or all
			     * processes in our group.
			     ','line_number':5288,'multiline':True]
['text':' Remove Vim-specific codes from the input.','line_number':5302,'multiline':False]
['text':'
			 * For pipes: echo the typed characters.
			 * For a pty this does not seem to work.
			 ','line_number':5305,'multiline':True]
['text':'
			 * Write the characters to the child, unless EOF has
			 * been typed for pipes.  Write one character at a
			 * time, to avoid losing too much typeahead.
			 * When writing buffer lines, drop the typed
			 * characters (only check for CTRL-C).
			 ','line_number':5331,'multiline':True]
['text':' CTRL-C sends a signal to the child, we ignore it','line_number':5354,'multiline':False]
['text':' ourselves','line_number':5355,'multiline':False]
['text':'
		     * Check if the child has any characters to be printed.
		     * Read them and write them to our window.	Repeat this as
		     * long as there is something to do, avoid the 10ms wait
		     * for mch_inchar(), or sending typeahead characters to
		     * the external process.
		     * TODO: This should handle escape sequences, compatible
		     * to some terminal (vt52?).
		     ','line_number':5366,'multiline':True]
['text':' end of file or error','line_number':5381,'multiline':False]
['text':' Do NUL -> NL translation, append NL separated','line_number':5387,'multiline':False]
['text':' lines to the current buffer.','line_number':5388,'multiline':False]
['text':' Check if the last character in buffer[] is','line_number':5407,'multiline':False]
['text':' incomplete, keep these bytes for the next','line_number':5408,'multiline':False]
['text':' round.','line_number':5409,'multiline':False]
['text':' NUL byte?','line_number':5414,'multiline':False]
['text':' no complete character','line_number':5418,'multiline':False]
['text':' avoid getting stuck at an illegal byte','line_number':5420,'multiline':False]
['text':' Avoid that we keep looping here without','line_number':5458,'multiline':False]
['text':' checking for a CTRL-C for a long time.  Don't','line_number':5459,'multiline':False]
['text':' break out too often to avoid losing typeahead.','line_number':5460,'multiline':False]
['text':' If we already detected the child has finished, continue','line_number':5470,'multiline':False]
['text':' reading output for a short while.  Some text may be','line_number':5471,'multiline':False]
['text':' buffered.','line_number':5472,'multiline':False]
['text':'
		     * Check if the child still exists, before checking for
		     * typed characters (otherwise we would lose typeahead).
		     ','line_number':5480,'multiline':True]
['text':' Don't break the loop yet, try reading more','line_number':5492,'multiline':False]
['text':' characters from "fromshell_fd" first.  When using','line_number':5493,'multiline':False]
['text':' pipes there might still be something to read and','line_number':5494,'multiline':False]
['text':' then we'll break the loop at the "break" above.','line_number':5495,'multiline':False]
['text':' Handle any X events, e.g. serving the clipboard.','line_number':5502,'multiline':False]
['text':' remember that the NL was missing','line_number':5513,'multiline':False]
['text':'
		 * Give all typeahead that wasn't used back to ui_inchar().
		 ','line_number':5521,'multiline':True]
['text':' Possibly disables modifyOtherKeys, so that the system','line_number':5537,'multiline':False]
['text':' can recognize CTRL-C.','line_number':5538,'multiline':False]
['text':'
		 * Similar to the loop above, but only handle X events, no
		 * I/O.
		 ','line_number':5541,'multiline':True]
['text':' CTRL-C sends a signal to the child, we ignore it','line_number':5549,'multiline':False]
['text':' ourselves','line_number':5550,'multiline':False]
['text':' Handle any X events, e.g. serving the clipboard.','line_number':5570,'multiline':False]
['text':' Wait for 1 to 10 msec. 1 is faster but gives the child','line_number':5573,'multiline':False]
['text':' less time, gradually wait longer.','line_number':5574,'multiline':False]
['text':' possibly enables modifyOtherKeys again','line_number':5582,'multiline':False]
['text':'
	     * Wait until our child has exited.
	     * Ignore wait() returning pids of other children and returning
	     * because of some signal like SIGWINCH.
	     * Don't wait if wait_pid was already set above, indicating the
	     * child already exited.
	     ','line_number':5587,'multiline':True]
['text':' Close slave side of pty.  Only do this after the child has','line_number':5598,'multiline':False]
['text':' exited, otherwise the child may hang when it tries to write on','line_number':5599,'multiline':False]
['text':' the pty.','line_number':5600,'multiline':False]
['text':' Make sure the child that writes to the external program is','line_number':5605,'multiline':False]
['text':' dead.','line_number':5606,'multiline':False]
['text':'
	     * Set to raw mode right now, otherwise a CTRL-C after
	     * catch_signals() will kill Vim.
	     ','line_number':5617,'multiline':True]
['text':' LINTED avoid "bitwise operation on signed value"','line_number':5628,'multiline':False]
['text':' set to raw mode','line_number':5654,'multiline':False]
['text':' USE_SYSTEM','line_number':5662,'multiline':False]
['text':' SHELL_*, see vim.h','line_number':5667,'multiline':False]
['text':' for stdin','line_number':5689,'multiline':False]
['text':' for stdout','line_number':5690,'multiline':False]
['text':' for stderr','line_number':5691,'multiline':False]
['text':' default is to fail','line_number':5708,'multiline':False]
['text':' TODO: without the channel feature connect the child to /dev/null?','line_number':5718,'multiline':False]
['text':' Open pipes for stdin, stdout, stderr.','line_number':5719,'multiline':False]
['text':' When writing buffer lines to the input don't use the pty, so that','line_number':5732,'multiline':False]
['text':' the pipe can be closed when all lines were written.','line_number':5733,'multiline':False]
['text':' maybe we should use vfork()','line_number':5785,'multiline':False]
['text':' failed to fork','line_number':5788,'multiline':False]
['text':' child','line_number':5797,'multiline':False]
['text':' handle signals normally','line_number':5798,'multiline':False]
['text':' close the log file in the child','line_number':5803,'multiline':False]
['text':' Create our own process group, so that the child and all its','line_number':5808,'multiline':False]
['text':' children can be kill()ed.  Don't do this when using pipes,','line_number':5809,'multiline':False]
['text':' because stdin is not a tty, we would lose /dev/tty.','line_number':5810,'multiline':False]
['text':' In the GUI 'term' is not what we want, use $TERM.','line_number':5821,'multiline':False]
['text':' Use 'term' or $TERM if it starts with "xterm", otherwise fall','line_number':5824,'multiline':False]
['text':' back to "xterm" or "xterm-color".','line_number':5825,'multiline':False]
['text':' TODO: should we check this name is supported?','line_number':5829,'multiline':False]
['text':' push stream discipline modules','line_number':5874,'multiline':False]
['text':' Try to become controlling tty (probably doesn't work,','line_number':5877,'multiline':False]
['text':' unless run by root)','line_number':5878,'multiline':False]
['text':' set up stdin for the child','line_number':5883,'multiline':False]
['text':' set up stderr for the child','line_number':5892,'multiline':False]
['text':' set up stdout for the child','line_number':5906,'multiline':False]
['text':' not used in the child','line_number':5929,'multiline':False]
['text':' was duped above','line_number':5930,'multiline':False]
['text':' See above for type of argv.','line_number':5939,'multiline':False]
['text':' calling free_all_mem() here causes problems. Ignore valgrind','line_number':5945,'multiline':False]
['text':' reporting possibly leaked memory.','line_number':5946,'multiline':False]
['text':' exec failed, return failure code','line_number':5948,'multiline':False]
['text':' parent','line_number':5951,'multiline':False]
['text':' ch_refcount was set above','line_number':5956,'multiline':False]
['text':' not used in the parent','line_number':5959,'multiline':False]
['text':' close child stdin, stdout and stderr','line_number':5960,'multiline':False]
['text':' When using pty_master_fd only set it for stdout, do not duplicate','line_number':5979,'multiline':False]
['text':' it for stderr, it only needs to be read once.','line_number':5980,'multiline':False]
['text':' success!','line_number':6004,'multiline':False]
['text':' The process is alive, but it was probably reparented (for','line_number':6063,'multiline':False]
['text':' example by ptrace called by a debugger like lldb or gdb).','line_number':6064,'multiline':False]
['text':' Note: This assumes that process IDs are not reused.','line_number':6065,'multiline':False]
['text':' process must have exited','line_number':6068,'multiline':False]
['text':' LINTED avoid "bitwise operation on signed value"','line_number':6078,'multiline':False]
['text':' Do not do this when waiting for a shell command to finish, we would get','line_number':6113,'multiline':False]
['text':' the exit value here (and discard it), the exit value obtained there','line_number':6114,'multiline':False]
['text':' would then be wrong.','line_number':6115,'multiline':False]
['text':' no process ended','line_number':6126,'multiline':False]
['text':' LINTED avoid "bitwise operation on signed value"','line_number':6133,'multiline':False]
['text':'
 * Send a (deadly) signal to "job".
 * Return FAIL if "how" is not a valid name.
 ','line_number':6151,'multiline':True]
['text':' Never kill ourselves!','line_number':6179,'multiline':False]
['text':' TODO: have an option to only kill the process, not the group?','line_number':6182,'multiline':False]
['text':'
 * Clear the data related to "job".
 ','line_number':6190,'multiline':True]
['text':' call waitpid because child process may become zombie','line_number':6196,'multiline':False]
['text':' ch_refcount was set by add_channel()','line_number':6227,'multiline':False]
['text':' Only set the pty_master_fd for stdout, do not duplicate it for stderr,','line_number':6230,'multiline':False]
['text':' it only needs to be read once.','line_number':6231,'multiline':False]
['text':'
 * Check for CTRL-C typed by reading all available characters.
 * In cooked mode we should get SIGINT, no need to check.
 ','line_number':6238,'multiline':True]
['text':'
 * Wait "msec" msec until a character is available from the mouse, keyboard,
 * from inbuf[].
 * "msec" == -1 will block forever.
 * Invokes timer callbacks when needed.
 * When "ignore_input" is TRUE even check for pending input when input is
 * already available.
 * "interrupted" (if not NULL) is set to TRUE when no character is available
 * but something else needs to be done.
 * Returns TRUE when a character is available.
 * When a GUI is being used, this will never get called -- webb
 ','line_number':6250,'multiline':True]
['text':'
 * Wait "msec" msec until a character is available from the mouse or keyboard
 * or from inbuf[].
 * "msec" == -1 will block forever.
 * for "ignore_input" see WaitForCharOr().
 * "interrupted" (if not NULL) is set to TRUE when no character is available
 * but something else needs to be done.
 * When a GUI is being used, this will never get called -- webb
 ','line_number':6273,'multiline':True]
['text':' something in inbuf[]','line_number':6293,'multiline':False]
['text':' May need to query the mouse position.','line_number':6297,'multiline':False]
['text':'
     * For FEAT_MOUSE_GPM and FEAT_XCLIPBOARD we loop here to process mouse
     * events.  This is a bit complicated, because they might both be defined.
     ','line_number':6306,'multiline':True]
['text':' Invoke any pending sound callbacks.','line_number':6329,'multiline':False]
['text':' Invoke any pending sound callbacks.','line_number':6333,'multiline':False]
['text':'
 * Wait "msec" msec until a character is available from file descriptor "fd".
 * "msec" == 0 will check for characters once.
 * "msec" == -1 will block until a character is available.
 * When a GUI is being used, this will not be used for input -- webb
 * Or when a Linux GPM mouse event is waiting.
 * Or when a clientserver message is on the queue.
 * "interrupted" (if not NULL) is set to TRUE when no character is available
 * but something else needs to be done.
 ','line_number':6372,'multiline':True]
['text':' May retry getting characters after an event was handled.','line_number':6390,'multiline':False]
['text':' Remember at what time we started, so that we know how much longer we','line_number':6394,'multiline':False]
['text':' should wait after being interrupted.','line_number':6395,'multiline':False]
['text':' Handle being called recursively.  This may happen for the session','line_number':6403,'multiline':False]
['text':' manager stuff, it may save the file, which does a breakcheck.','line_number':6404,'multiline':False]
['text':' default is to 'loop' just once','line_number':6414,'multiline':False]
['text':' each channel may use in, out and err','line_number':6420,'multiline':False]
['text':' don't wait longer than 'mzquantum'','line_number':6438,'multiline':False]
['text':' MzThreads scheduling is required and timeout occurred','line_number':6488,'multiline':False]
['text':' Maybe we should hand out clipboard','line_number':6495,'multiline':False]
['text':' Try again','line_number':6497,'multiline':False]
['text':' Try again','line_number':6521,'multiline':False]
['text':' also call when ret == 0, we may be polling a keep-open channel','line_number':6525,'multiline':False]
['text':' HAVE_SELECT','line_number':6530,'multiline':False]
['text':' These are static because they can take 8 Kbyte each and cause the','line_number':6534,'multiline':False]
['text':' signal stack to run out with -O3.','line_number':6535,'multiline':False]
['text':' don't wait longer than 'mzquantum'','line_number':6544,'multiline':False]
['text':'
	 * Select on ready for reading and exceptional condition (end of file).
	 ','line_number':6558,'multiline':True]
['text':' For QNX select() always returns 1 if this is set.  Why?','line_number':6567,'multiline':False]
['text':' An event may have already been read but not handled.  In','line_number':6580,'multiline':False]
['text':' particularly, XFlush may cause this.','line_number':6581,'multiline':False]
['text':' Check whether the EINTR is caused by SIGTSTP','line_number':6620,'multiline':False]
['text':' Check whether window has been resized, EINTR may be caused by','line_number':6630,'multiline':False]
['text':' SIGWINCH.','line_number':6631,'multiline':False]
['text':' Interrupted by a signal, need to try again.  We ignore msec','line_number':6640,'multiline':False]
['text':' here, because we do want to check even after a timeout if','line_number':6641,'multiline':False]
['text':' characters are available.  Needed for reading output of an','line_number':6642,'multiline':False]
['text':' external command after the process has finished.','line_number':6643,'multiline':False]
['text':' loop if MzThreads must be scheduled and timeout occurred','line_number':6657,'multiline':False]
['text':' Maybe we should hand out clipboard','line_number':6665,'multiline':False]
['text':' continue looping when we only got the X event and the input','line_number':6666,'multiline':False]
['text':' buffer is empty','line_number':6667,'multiline':False]
['text':' Try again','line_number':6670,'multiline':False]
['text':' keep going if event was only one','line_number':6693,'multiline':False]
['text':' keep going if event was only one','line_number':6701,'multiline':False]
['text':' also call when ret == 0, we may be polling a keep-open channel','line_number':6706,'multiline':False]
['text':' HAVE_SELECT','line_number':6711,'multiline':False]
['text':' We're going to loop around again, find out for how long','line_number':6722,'multiline':False]
['text':' Compute remaining wait time.','line_number':6726,'multiline':False]
['text':' Guess we got interrupted halfway.','line_number':6729,'multiline':False]
['text':' waited long enough','line_number':6733,'multiline':False]
['text':'
 * Expand a path into all matching files and/or directories.  Handles "*",
 * "?", "[a-z]", "**", etc.
 * "path" has backslashes before chars that are not to be expanded.
 * Returns the number of matches found.
 ','line_number':6741,'multiline':True]
['text':' EW_* flags','line_number':6751,'multiline':False]
['text':'
 * mch_expand_wildcards() - this code does wild-card pattern matching using
 * the shell
 *
 * return OK for success, FAIL for error (you may lose some memory) and put
 * an error message in *file.
 *
 * num_pat is number of input patterns
 * pat is array of pointers to input patterns
 * num_file is pointer to number of matched file names
 * file is pointer to array of pointers to matched file names
 ','line_number':6756,'multiline':True]
['text':' EW_* flags','line_number':6784,'multiline':False]
['text':'
     * This is the non-OS/2 implementation (really Unix).
     ','line_number':6792,'multiline':True]
['text':' use "echo", the default','line_number':6800,'multiline':False]
['text':' use "glob", for csh','line_number':6801,'multiline':False]
['text':' use "vimglob", for Posix sh','line_number':6802,'multiline':False]
['text':' use "print -N", for zsh','line_number':6803,'multiline':False]
['text':' `cmd` expansion, execute the pattern directly','line_number':6804,'multiline':False]
['text':' use extended shell glob for bash (this uses extended','line_number':6805,'multiline':False]
['text':' globbing functionality using globstar, needs bash > 4)','line_number':6806,'multiline':False]
['text':' vimglob() function to define for Posix shell','line_number':6811,'multiline':False]
['text':' vimglob() function with globstar setting enabled, only for bash >= 4.X','line_number':6813,'multiline':False]
['text':' default: no files found','line_number':6816,'multiline':False]
['text':'
     * If there are no wildcards, just copy the names to allocated memory.
     * Saves a lot of time, because we don't have to start a new shell.
     ','line_number':6819,'multiline':True]
['text':' Don't allow any shell command in the sandbox.','line_number':6827,'multiline':False]
['text':'
     * Don't allow the use of backticks in secure and restricted mode.
     ','line_number':6832,'multiline':True]
['text':'
     * get a name for the temp file
     ','line_number':6841,'multiline':True]
['text':'
     * Let the shell expand the patterns and write the result into the temp
     * file.
     * STYLE_BT:	NL separated
     *	    If expanding `cmd` execute it directly.
     * STYLE_GLOB:	NUL separated
     *	    If we use *csh, "glob" will work better than "echo".
     * STYLE_PRINT:	NL or NUL separated
     *	    If we use *zsh, "print -N" will work better than "glob".
     * STYLE_VIMGLOB:	NL separated
     *	    If we use *sh*, we define "vimglob()".
     * STYLE_GLOBSTAR:	NL separated
     *	    If we use *bash*, we define "vimglob() and enable globstar option".
     * STYLE_ECHO:	space separated.
     *	    A shell we don't know, stay safe and use "echo".
     ','line_number':6850,'multiline':True]
['text':' Compute the length of the command.  We need 2 extra bytes: for the','line_number':6885,'multiline':False]
['text':' optional '&' and for the NUL.','line_number':6886,'multiline':False]
['text':' Worst case: "unset nonomatch; print -N >" plus two is 29','line_number':6887,'multiline':False]
['text':' Count the length of the patterns in the same way as they are put in','line_number':6897,'multiline':False]
['text':' "command" below.','line_number':6898,'multiline':False]
['text':' add space and two quotes','line_number':6900,'multiline':False]
['text':' add space','line_number':6902,'multiline':False]
['text':' may add a backslash','line_number':6906,'multiline':False]
['text':' out of memory','line_number':6914,'multiline':False]
['text':'
     * Build the shell command:
     * - Set $nonomatch depending on EW_NOTFOUND (hopefully the shell
     *	 recognizes this).
     * - Add the shell command to print the expanded names.
     * - Add the temp file name.
     * - Add the file name patterns.
     ','line_number':6919,'multiline':True]
['text':' change `command; command& ` to (command; command )','line_number':6929,'multiline':False]
['text':' exclude first backtick','line_number':6931,'multiline':False]
['text':' remove last backtick','line_number':6933,'multiline':False]
['text':' remove trailing '&'','line_number':6936,'multiline':False]
['text':' Assume the nonomatch option is valid only for csh like shells,','line_number':6948,'multiline':False]
['text':' otherwise, this may set the positional parameters for the shell,','line_number':6949,'multiline':False]
['text':' e.g. "$*".','line_number':6950,'multiline':False]
['text':' When using system() always add extra quotes, because the shell','line_number':6976,'multiline':False]
['text':' is started twice.  Otherwise put a backslash before special','line_number':6977,'multiline':False]
['text':' characters, except inside ``.','line_number':6978,'multiline':False]
['text':' Remove a backslash, take char literally.  But keep','line_number':6994,'multiline':False]
['text':' backslash inside backticks, before a special character','line_number':6995,'multiline':False]
['text':' and before a backtick.','line_number':6996,'multiline':False]
['text':' Put a backslash before a special character, but not','line_number':7006,'multiline':False]
['text':' when inside ``. And not for $var when EW_KEEPDOLLAR is','line_number':7007,'multiline':False]
['text':' set.','line_number':7008,'multiline':False]
['text':' Copy one character.','line_number':7011,'multiline':False]
['text':' put the '&' after the redirection','line_number':7020,'multiline':False]
['text':'
     * Using zsh -G: If a pattern has no matches, it is just deleted from
     * the argument list, otherwise zsh gives an error message and doesn't
     * expand any other pattern.
     ','line_number':7022,'multiline':True]
['text':' Use zsh NULL_GLOB option','line_number':7028,'multiline':False]
['text':'
     * If we use -f then shell variables set in .cshrc won't get expanded.
     * vi can do it, so we will too, but it is only necessary if there is a "$"
     * in one of the patterns, otherwise we can still use the fast option.
     ','line_number':7030,'multiline':True]
['text':' Use csh fast option','line_number':7036,'multiline':False]
['text':'
     * execute the shell command
     ','line_number':7038,'multiline':True]
['text':' When running in the background, give it some time to create the temp','line_number':7043,'multiline':False]
['text':' file, but don't wait for it to finish.','line_number':7044,'multiline':False]
['text':' cleanup','line_number':7048,'multiline':False]
['text':' mch_call_shell() failed','line_number':7052,'multiline':False]
['text':'
	 * With interactive completion, the error message is not printed.
	 * However with USE_SYSTEM, I don't know how to turn off error messages
	 * from the shell, so screen may still get messed up -- webb.
	 ','line_number':7056,'multiline':True]
['text':' probably messed up screen','line_number':7065,'multiline':False]
['text':' clear bottom line quickly','line_number':7066,'multiline':False]
['text':' continue on last line','line_number':7067,'multiline':False]
['text':' don't overwrite this message','line_number':7073,'multiline':False]
['text':' If a `cmd` expansion failed, don't list `cmd` as a match, even when','line_number':7076,'multiline':False]
['text':' EW_NOTFOUND is given','line_number':7077,'multiline':False]
['text':'
     * read the names from the file into memory
     ','line_number':7083,'multiline':True]
['text':' Something went wrong, perhaps a file name with a special char.','line_number':7089,'multiline':False]
['text':' don't overwrite this message','line_number':7093,'multiline':False]
['text':' get size of temp file','line_number':7099,'multiline':False]
['text':' just in case ftell() would fail','line_number':7102,'multiline':False]
['text':' out of memory','line_number':7108,'multiline':False]
['text':' unexpected read error','line_number':7120,'multiline':False]
['text':' Translate <CR><NL> into <NL>.  Caution, buffer may contain NUL.','line_number':7129,'multiline':False]
['text':' file names are separated with Space','line_number':7138,'multiline':False]
['text':' make sure the buffer ends in NL','line_number':7141,'multiline':False]
['text':' count number of entries','line_number':7143,'multiline':False]
['text':' skip to next entry','line_number':7147,'multiline':False]
['text':' file names are separated with NL','line_number':7150,'multiline':False]
['text':' make sure the buffer ends in NUL','line_number':7155,'multiline':False]
['text':' count number of entries','line_number':7157,'multiline':False]
['text':' skip leading white space','line_number':7163,'multiline':False]
['text':' file names are separated with NUL','line_number':7166,'multiline':False]
['text':'
	 * Some versions of zsh use spaces instead of NULs to separate
	 * results.  Only do this when there is no NUL before the end of the
	 * buffer, otherwise we would never be able to use file names with
	 * embedded spaces when zsh does use NULs.
	 * When we found a NUL once, we know zsh is OK, set did_find_nul and
	 * don't check for spaces again.
	 ','line_number':7169,'multiline':True]
['text':' If there is a NUL, set did_find_nul, else set check_spaces','line_number':7180,'multiline':False]
['text':'
	 * Make sure the buffer ends with a NUL.  For STYLE_PRINT there
	 * already is one, for STYLE_GLOB it needs to be added.
	 ','line_number':7188,'multiline':True]
['text':' count entry','line_number':7198,'multiline':False]
['text':' count last entry','line_number':7204,'multiline':False]
['text':'
	 * Can happen when using /bin/sh and typing ":e $NO_SUCH_VAR^I".
	 * /bin/sh will happily expand it to nothing rather than returning an
	 * error; and hey, it's good to check anyway -- webb.
	 ','line_number':7208,'multiline':True]
['text':' out of memory','line_number':7220,'multiline':False]
['text':'
     * Isolate the individual file names.
     ','line_number':7225,'multiline':True]
['text':' Space or NL separates','line_number':7232,'multiline':False]
['text':' last entry','line_number':7239,'multiline':False]
['text':' skip to next entry','line_number':7244,'multiline':False]
['text':' NUL separates','line_number':7247,'multiline':False]
['text':' skip entry','line_number':7249,'multiline':False]
['text':' skip NUL','line_number':7251,'multiline':False]
['text':'
     * Move the file names to allocated memory.
     ','line_number':7255,'multiline':True]
['text':' Require the files to exist.	Helps when using /bin/sh','line_number':7260,'multiline':False]
['text':' check if this entry should be included','line_number':7264,'multiline':False]
['text':' Skip files that are not executable if we check for that.','line_number':7269,'multiline':False]
['text':' add '/' to a directory name','line_number':7279,'multiline':False]
['text':' rejected all entries','line_number':7286,'multiline':False]
['text':' VMS','line_number':7300,'multiline':False]
['text':' Be compatible with expand_filename(): halve the number of','line_number':7319,'multiline':False]
['text':' backslashes.','line_number':7320,'multiline':False]
['text':'
 * Return TRUE if the string "p" contains a wildcard that mch_expandpath() can
 * expand.
 ','line_number':7328,'multiline':True]
['text':'
 * Return TRUE if the string "p" contains a wildcard.
 * Don't recognize '~' at the end as a wildcard.
 ','line_number':7352,'multiline':True]
['text':'
 * Scaled-down version of rename(), which is missing in Xenix.
 * This version can only move regular files and will fail if the
 * destination exists.
 ','line_number':7400,'multiline':True]
['text':' fail if destination exists','line_number':7410,'multiline':False]
['text':' link file to new name','line_number':7412,'multiline':False]
['text':' delete link to old name','line_number':7414,'multiline':False]
['text':' !HAVE_RENAME','line_number':7418,'multiline':False]
['text':'
 * Initialize Gpm's symbols for dynamic linking.
 * Must be called only if libgpm_hinst is NULL.
 ','line_number':7422,'multiline':True]
['text':' DYNAMIC_GPM','line_number':7462,'multiline':False]
['text':'
 * Initializes connection with gpm (if it isn't already opened)
 * Return 1 if succeeded (or connection already opened), 0 if failed
 ','line_number':7464,'multiline':True]
['text':' Must it be kept till closing ?','line_number':7471,'multiline':False]
['text':' already open','line_number':7479,'multiline':False]
['text':' Default handling for mouse move','line_number':7483,'multiline':False]
['text':' Handle any modifier keys','line_number':7484,'multiline':False]
['text':' gpm library tries to handling TSTP causes','line_number':7488,'multiline':False]
['text':' problems. Anyways, we close connection to Gpm whenever','line_number':7489,'multiline':False]
['text':' we are going to suspend or starting an external process','line_number':7490,'multiline':False]
['text':' so we shouldn't  have problem with this','line_number':7491,'multiline':False]
['text':' succeed','line_number':7495,'multiline':False]
['text':' We don't want to talk to xterm via gpm','line_number':7498,'multiline':False]
['text':'
 * Returns TRUE if the GPM mouse is enabled.
 ','line_number':7502,'multiline':True]
['text':'
 * Closes connection to gpm
 ','line_number':7511,'multiline':True]
['text':'
 * Reads gpm event and adds special keys to input buf. Returns length of
 * generated key sequence.
 * This function is styled after gui_send_mouse_event().
 ','line_number':7521,'multiline':True]
['text':' Don't put events in the input queue now.','line_number':7541,'multiline':False]
['text':' Our termcode','line_number':7549,'multiline':False]
['text':' Don't know what to do. Can more than one button be','line_number':7573,'multiline':False]
['text':' reported in one event?','line_number':7574,'multiline':False]
['text':' This code is based on gui_x11_mouse_cb in gui_x11.c','line_number':7586,'multiline':False]
['text':' I ignore capslock stats. Aren't we all just hate capslock mixing with','line_number':7589,'multiline':False]
['text':' Vim commands ? Besides, gpm_event.modifiers is unsigned char, and','line_number':7590,'multiline':False]
['text':' K_CAPSSHIFT is defined 8, so it probably isn't even reported','line_number':7591,'multiline':False]
['text':' FEAT_MOUSE_GPM','line_number':7605,'multiline':False]
['text':'
 * Initialize connection with sysmouse.
 * Let virtual console inform us with SIGUSR2 for pending sysmouse
 * output, any sysmouse output than will be processed via sig_sysmouse().
 * Return OK if succeeded, FAIL if failed.
 ','line_number':7608,'multiline':True]
['text':'
 * Stop processing SIGUSR2 signals, and also make sure that
 * virtual console do not send us any sysmouse related signal.
 ','line_number':7631,'multiline':True]
['text':'
 * Gets info from sysmouse and adds special keys to input buf.
 ','line_number':7647,'multiline':True]
['text':' Don't put events in the input queue now.','line_number':7662,'multiline':False]
['text':' Our termcode','line_number':7676,'multiline':False]
['text':' FEAT_SYSMOUSE','line_number':7711,'multiline':False]
['text':'
 * Call a DLL routine which takes either a string or int param
 * and returns an allocated string.
 ','line_number':7719,'multiline':True]
['text':' NULL when using a argint','line_number':7727,'multiline':False]
['text':' NULL when using number_result','line_number':7729,'multiline':False]
['text':'
     * Get a handle to the DLL module.
     ','line_number':7744,'multiline':True]
['text':' First clear any error, it's not cleared by the dlopen() call.','line_number':7748,'multiline':False]
['text':' "dlerr" must be used before dlclose()','line_number':7758,'multiline':False]
['text':' If the handle is valid, try to get the function address.','line_number':7767,'multiline':False]
['text':'
	 * Catch a crash when calling the library function.  For example when
	 * using a number where a string pointer is expected.
	 ','line_number':7771,'multiline':True]
['text':' Save the string before we free the library.','line_number':7835,'multiline':False]
['text':' Assume that a "1" or "-1" result is an illegal pointer.','line_number':7836,'multiline':False]
['text':' try to find the name of this signal','line_number':7852,'multiline':False]
['text':' "dlerr" must be used before dlclose()','line_number':7862,'multiline':False]
['text':' Free the DLL module.','line_number':7866,'multiline':False]
['text':' default: disabled','line_number':7884,'multiline':False]
['text':'
 * Setup a dummy window for X selections in a terminal.
 ','line_number':7887,'multiline':True]
['text':' Ignore X errors while opening the display','line_number':7914,'multiline':False]
['text':' Ignore X IO errors while opening the display','line_number':7918,'multiline':False]
['text':' Now handle X IO errors normally.','line_number':7939,'multiline':False]
['text':' Now handle X errors normally.','line_number':7942,'multiline':False]
['text':' Catch terminating error of the X server connection.','line_number':7952,'multiline':False]
['text':' Create a Shell to make converters work.','line_number':7964,'multiline':False]
['text':' Check if $WINDOWID is valid.','line_number':7993,'multiline':False]
['text':'
 * Query the xterm pointer and generate mouse termcodes if necessary
 * return TRUE if dragging is active, else FALSE
 ','line_number':8020,'multiline':True]
['text':' Get the hints just before tracking starts.  The font size might','line_number':8045,'multiline':False]
['text':' have changed recently.','line_number':8046,'multiline':False]
['text':' Not enough data -- disable tracing','line_number':8052,'multiline':False]
['text':' Rely on the same mouse code for the duration of this','line_number':8056,'multiline':False]
['text':' Find the offset of the chars, there might be a scrollbar on the','line_number':8062,'multiline':False]
['text':' left of the window and/or a menu on the top (eterm etc.)','line_number':8063,'multiline':False]
['text':'
 * Destroy the display, window and app_context.  Required for GTK.
 ','line_number':8104,'multiline':True]
['text':' Lesstif and Solaris crash here, lose some memory','line_number':8118,'multiline':False]
['text':' Lesstif and Solaris crash here, lose some memory','line_number':8128,'multiline':False]
['text':'
 * Catch up with GUI or X events.
 ','line_number':8136,'multiline':True]
['text':'
 * Catch up with any queued X events.  This may put keyboard input into the
 * input buffer, call resize call-backs, trigger timers etc.  If there is
 * nothing in the X event queue (& no timers pending), then we return
 * immediately.
 ','line_number':8151,'multiline':True]
['text':' There is an event to process.','line_number':8171,'multiline':False]
['text':' There is something else than an event to process.','line_number':8186,'multiline':False]
['text':'
 * Code for X Session Management Protocol.
 ','line_number':8223,'multiline':True]
['text':'
 * This is our chance to ask the user if they want to save,
 * or abort the logout
 ','line_number':8228,'multiline':True]
['text':' Mustn't logout','line_number':8241,'multiline':False]
['text':' position cursor','line_number':8244,'multiline':False]
['text':' Done interaction','line_number':8247,'multiline':False]
['text':' Finish off','line_number':8250,'multiline':False]
['text':' Only end save-yourself here if we're not cancelling shutdown;','line_number':8251,'multiline':False]
['text':' we'll get a cancelled callback later in which we'll end it.','line_number':8252,'multiline':False]
['text':' Hopefully get around glitchy SMs (like GNOME-1)','line_number':8253,'multiline':False]
['text':'
 * Callback that starts save-yourself.
 ','line_number':8262,'multiline':True]
['text':' Handle already being in saveyourself','line_number':8274,'multiline':False]
['text':' First up, preserve all files','line_number':8280,'multiline':False]
['text':' preserve all swap files','line_number':8282,'multiline':False]
['text':' Now see if we can ask about unsaved files','line_number':8288,'multiline':False]
['text':' Need to interact with user, but need SM's permission','line_number':8290,'multiline':False]
['text':' Can stop the cycle here','line_number':8296,'multiline':False]
['text':'
 * Callback to warn us of imminent death.
 ','line_number':8303,'multiline':True]
['text':' quit quickly leaving swapfiles for modified buffers behind','line_number':8311,'multiline':False]
['text':'
 * Callback to tell us that save-yourself has completed.
 ','line_number':8316,'multiline':True]
['text':'
 * Callback to tell us that an instigated shutdown was cancelled
 * (maybe even by us)
 ','line_number':8328,'multiline':True]
['text':'
 * Callback to tell us that a new ICE connection has been established.
 ','line_number':8344,'multiline':True]
['text':' Intercept creation of ICE connection fd','line_number':8354,'multiline':False]
['text':' Handle any ICE processing that's required; return FAIL if SM lost','line_number':8363,'multiline':False]
['text':' Lost ICE','line_number':8372,'multiline':False]
['text':' Set up X Session Management Protocol','line_number':8384,'multiline':False]
['text':' Set up SM callbacks - must have all, even if they're not used','line_number':8401,'multiline':False]
['text':' Set up a watch on ICE connection creations.  The "dummy" argument is','line_number':8411,'multiline':False]
['text':' apparently required for FreeBSD (we get a BUS error when using NULL).','line_number':8412,'multiline':False]
['text':' Create an SM connection','line_number':8420,'multiline':False]
['text':' If the message is too long it might not be NUL terminated.  Add','line_number':8439,'multiline':False]
['text':' a NUL at the end to make sure we don't go over the end.','line_number':8440,'multiline':False]
['text':' ID ourselves','line_number':8451,'multiline':False]
['text':' Shut down XSMP comms.','line_number':8465,'multiline':False]
['text':' USE_XSMP','line_number':8478,'multiline':False]
['text':'
 * Implement timeout with timer_create() and timer_settime().
 ','line_number':8482,'multiline':True]
['text':'
 * Callback for when the timer expires.
 ','line_number':8489,'multiline':True]
['text':'
 * Stop any active timeout.
 ','line_number':8498,'multiline':True]
['text':' Clear the current timeout flag; any previous timeout should be','line_number':8514,'multiline':False]
['text':' considered _not_ triggered.','line_number':8515,'multiline':False]
['text':'
 * Start the timeout timer.
 *
 * The return value is a pointer to a flag that is initialised to FALSE. If the
 * timeout expires, the flag is set to TRUE. This will only return pointers to
 * static memory; i.e. any pointer returned by this function may always be
 * safely dereferenced.
 *
 * This function is not expected to fail, but if it does it will still return a
 * valid flag pointer; the flag will remain stuck as FALSE .
 ','line_number':8519,'multiline':True]
['text':' Do not repeat.','line_number':8534,'multiline':False]
['text':' Timeout interval','line_number':8535,'multiline':False]
['text':' This is really the caller's responsibility, but let's make sure the','line_number':8538,'multiline':False]
['text':' previous timer has been stopped.','line_number':8539,'multiline':False]
['text':'
 * To be used before fork/exec: delete any created timer.
 ','line_number':8568,'multiline':True]
['text':' PROF_NSEC','line_number':8581,'multiline':False]
['text':'
 * Implement timeout with setitimer()
 ','line_number':8583,'multiline':True]
['text':'
 * Handle SIGALRM for a timeout.
 ','line_number':8592,'multiline':True]
['text':'
 * Stop any active timeout.
 ','line_number':8604,'multiline':True]
['text':' Should only get here as a result of coding errors.','line_number':8618,'multiline':False]
['text':' Should only get here as a result of coding errors.','line_number':8627,'multiline':False]
['text':'
 * Start the timeout timer.
 *
 * The return value is a pointer to a flag that is initialised to FALSE. If the
 * timeout expires, the flag is set to TRUE. This will only return pointers to
 * static memory; i.e. any pointer returned by this function may always be
 * safely dereferenced.
 *
 * This function is not expected to fail, but if it does it will still return a
 * valid flag pointer; the flag will remain stuck as FALSE .
 ','line_number':8634,'multiline':True]
['text':' Do not repeat.','line_number':8649,'multiline':False]
['text':' Timeout interval','line_number':8650,'multiline':False]
['text':' This is really the caller's responsibility, but let's make sure the','line_number':8656,'multiline':False]
['text':' previous timer has been stopped.','line_number':8657,'multiline':False]
['text':' There is a small chance that SIGALRM is pending and so the handler must','line_number':8660,'multiline':False]
['text':' ignore it on the first call.','line_number':8661,'multiline':False]
['text':' Just catching coding errors. Write an error message, but carry on.','line_number':8675,'multiline':False]
['text':' Set up the alarm handler first.','line_number':8680,'multiline':False]
['text':' Should only get here as a result of coding errors.','line_number':8687,'multiline':False]
['text':' Set up the interval timer once the alarm handler is in place.','line_number':8693,'multiline':False]
['text':' Should only get here as a result of coding errors.','line_number':8697,'multiline':False]
['text':' PROF_NSEC','line_number':8706,'multiline':False]
['text':' FEAT_RELTIME','line_number':8707,'multiline':False]
