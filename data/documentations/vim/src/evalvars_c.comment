['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]
['text':'
 * evalvars.c: functions for dealing with variables
 ','line_number':10,'multiline':True]
['text':' variable used for g:','line_number':18,'multiline':False]
['text':' Dictionary with g: variables','line_number':19,'multiline':False]
['text':'
 * Old Vim variables such as "v:version" are also available without the "v:".
 * Also in functions.  We need a special hashtable for them.
 ','line_number':22,'multiline':True]
['text':'
 * Array to hold the value of v: variables.
 * The value is in a dictitem, so that it can also be used in the v: scope.
 * The reason to use this table anyway is for very quick access to the
 * variables with the VV_ defines.
 ','line_number':28,'multiline':True]
['text':' values for vv_flags:','line_number':35,'multiline':False]
['text':' compatible, also used without "v:"','line_number':36,'multiline':False]
['text':' read-only','line_number':37,'multiline':False]
['text':' read-only in the sandbox','line_number':38,'multiline':False]
['text':' name of variable, without v:','line_number':46,'multiline':False]
['text':' value and name for key (max 16 chars!)','line_number':47,'multiline':False]
['text':' type or NULL','line_number':48,'multiline':False]
['text':' VV_COMPAT, VV_RO, VV_RO_SBX','line_number':49,'multiline':False]
['text':' The order here must match the VV_ defines in vim.h!','line_number':52,'multiline':False]
['text':' Initializing a union does not work, leave tv.vval empty to get zero's.','line_number':53,'multiline':False]
['text':' shorthand','line_number':164,'multiline':False]
['text':' variable used for v:','line_number':174,'multiline':False]
['text':' Dictionary with v: variables','line_number':175,'multiline':False]
['text':' for VIM_VERSION_ defines','line_number':178,'multiline':False]
['text':'
 * Initialize global and vim special variables
 ','line_number':192,'multiline':True]
['text':' add to v: scope dict, unless the value is not always available','line_number':222,'multiline':False]
['text':' add to compat scope dict','line_number':226,'multiline':False]
['text':' Default for v:register is not 0 but '"'.  This is adjusted once the','line_number':274,'multiline':False]
['text':' clipboard has been setup by calling reset_reg_var().','line_number':275,'multiline':False]
['text':'
 * Free all vim variables information on exit
 ','line_number':280,'multiline':True]
['text':' garbage_collect() will access it','line_number':301,'multiline':False]
['text':' global variables','line_number':304,'multiline':False]
['text':' Script-local variables. Clear all the variables here.','line_number':307,'multiline':False]
['text':' The scriptvar_T is cleared later in free_scriptnames(), because a','line_number':308,'multiline':False]
['text':' variable in one script might hold a reference to the whole scope of','line_number':309,'multiline':False]
['text':' another script.','line_number':310,'multiline':False]
['text':'
 * Set an internal variable to a string value. Creates the variable if it does
 * not already exist.
 ','line_number':353,'multiline':True]
['text':' errors are ignored','line_number':457,'multiline':False]
['text':' errors are ignored','line_number':485,'multiline':False]
['text':'
 * Evaluate an expression to a list with suggestions.
 * For the "expr:" part of 'spellsuggest'.
 * Returns NULL when there is an error.
 ','line_number':497,'multiline':True]
['text':' Set "v:val" to the bad word.','line_number':513,'multiline':False]
['text':'
 * "list" is supposed to contain two items: a word and a number.  Return the
 * word in "pp" and the number as the return value.
 * Return -1 if anything isn't right.
 * Used to get the good word and score from the eval_spell_expr() result.
 ','line_number':542,'multiline':True]
['text':'
 * Prepare v: variable "idx" to be used.
 * Save the current typeval in "save_tv" and clear it.
 * When not used yet add the variable to the v: hashtable.
 ','line_number':565,'multiline':True]
['text':' don't free it now','line_number':574,'multiline':False]
['text':'
 * Restore v: variable "idx" to typeval "save_tv".
 * Note that the v: variable must have been cleared already.
 * When no longer defined, remove the variable from the v: hashtable.
 ','line_number':579,'multiline':True]
['text':'
 * List Vim variables.
 ','line_number':600,'multiline':True]
['text':'
 * List script-local variables, if there is a script.
 ','line_number':609,'multiline':True]
['text':'
 * Return TRUE if "name" starts with "g:", "w:", "t:" or "b:".
 * But only when an identifier character follows.
 ','line_number':620,'multiline':True]
['text':'
 * Evaluate one Vim expression {expr} in string "p" and append the
 * resulting string to "gap".  "p" points to the opening "{".
 * When "evaluate" is FALSE only skip over the expression.
 * Return a pointer to the character after "}", NULL for an error.
 ','line_number':632,'multiline':True]
['text':' skip the opening {','line_number':641,'multiline':False]
['text':'
 * Evaluate all the Vim expressions {expr} in "str" and return the resulting
 * string in allocated memory.  "{{" is reduced to "{" and "}}" to "}".
 * Used for a heredoc assignment.
 * Returns NULL for an error.
 ','line_number':672,'multiline':True]
['text':' Look for a block start.','line_number':692,'multiline':False]
['text':' Escaped brace, unescape and continue.','line_number':699,'multiline':False]
['text':' Include the brace in the literal string.','line_number':700,'multiline':False]
['text':' Append the literal part.','line_number':711,'multiline':False]
['text':' Skip the second brace.','line_number':719,'multiline':False]
['text':' Evaluate the expression and append the result.','line_number':724,'multiline':False]
['text':'
 * Get a list of lines from a HERE document. The here document is a list of
 * lines surrounded by a marker.
 *	cmd << {marker}
 *	  {line1}
 *	  {line2}
 *	  ....
 *	{marker}
 *
 * The {marker} is a string. If the optional 'trim' word is supplied before the
 * marker, then the leading indentation before the lines (matching the
 * indentation in the "cmd" line) is stripped.
 *
 * When getting lines for an embedded script (e.g. python, lua, perl, ruby,
 * tcl, mzscheme), "script_get" is set to TRUE. In this case, if the marker is
 * missing, then '.' is accepted as a marker.
 *
 * When compiling a heredoc assignment to a variable in a Vim9 def function,
 * "vim9compile" is set to TRUE. In this case, instead of generating a list of
 * string values from the heredoc, vim9 instructions are generated.  On success
 * the returned list will be empty.
 *
 * Returns a List with {lines} or NULL on failure.
 ','line_number':737,'multiline':True]
['text':' Check for the optional 'trim' word before the marker','line_number':785,'multiline':False]
['text':' Trim the indentation from all the lines in the here document.','line_number':795,'multiline':False]
['text':' The amount of indentation trimmed is the same as the indentation','line_number':796,'multiline':False]
['text':' of the first line after the :let command line.  To find the end','line_number':797,'multiline':False]
['text':' marker the indent of the :let command line is trimmed.','line_number':798,'multiline':False]
['text':' The marker is the next word.','line_number':819,'multiline':False]
['text':' When getting lines for an embedded script, if the marker is missing,','line_number':838,'multiline':False]
['text':' accept '.' as the marker.','line_number':839,'multiline':False]
['text':' with "trim": skip the indent matching the :let line to find the','line_number':866,'multiline':False]
['text':' marker','line_number':867,'multiline':False]
['text':' If expression evaluation failed in the heredoc, then skip till the','line_number':874,'multiline':False]
['text':' end marker.','line_number':875,'multiline':False]
['text':' set the text indent from the first line.','line_number':881,'multiline':False]
['text':' with "trim": skip the indent matching the first line','line_number':891,'multiline':False]
['text':' expression evaluation failed','line_number':915,'multiline':False]
['text':' expression evaluation in the heredoc failed','line_number':935,'multiline':False]
['text':'
 * Vim9 variable declaration:
 * ":var name"
 * ":var name: type"
 * ":var name = expr"
 * ":var name: type = expr"
 * etc.
 ','line_number':942,'multiline':True]
['text':'
 * ":let"			list all variable values
 * ":let var1 var2"		list variable values
 * ":let var = expr"		assignment command.
 * ":let var += expr"		assignment command.
 * ":let var -= expr"		assignment command.
 * ":let var *= expr"		assignment command.
 * ":let var /= expr"		assignment command.
 * ":let var %= expr"		assignment command.
 * ":let var .= expr"		assignment command.
 * ":let var ..= expr"		assignment command.
 * ":let [var1, var2] = expr"	unpack list.
 * ":let var =<< ..."		heredoc
 * ":let var: string"		Vim9 declaration
 *
 * ":final var = expr"		assignment command.
 * ":final [var1, var2] = expr"	unpack list.
 *
 * ":const"			list all variable values
 * ":const var1 var2"		list variable values
 * ":const var = expr"		assignment command.
 * ":const [var1, var2] = expr"	unpack list.
 ','line_number':970,'multiline':True]
['text':' In legacy Vim script ":final" is short for ":finally".','line_number':1011,'multiline':False]
['text':' Vim9 assignment without ":let", ":const" or ":final"','line_number':1026,'multiline':False]
['text':' for var.='str'','line_number':1033,'multiline':False]
['text':' ":let" without "=": list variables','line_number':1043,'multiline':False]
['text':' Vim9 declaration ":var name: type"','line_number':1055,'multiline':False]
['text':' ":let var1 var2" - list values','line_number':1060,'multiline':False]
['text':' ":let"','line_number':1066,'multiline':False]
['text':' :let text =<< [trim] [eval] END','line_number':1084,'multiline':False]
['text':' :var text =<< [trim] [eval] END','line_number':1085,'multiline':False]
['text':' errors are for the assignment, not the end marker','line_number':1098,'multiline':False]
['text':' +=, /=, etc. require an existing variable','line_number':1123,'multiline':False]
['text':' +=, -=, *=, /=, %= or .=','line_number':1128,'multiline':False]
['text':' ..=','line_number':1130,'multiline':False]
['text':' Restore the line number so that any type error is given for the','line_number':1159,'multiline':False]
['text':' declaration, not the expression.','line_number':1160,'multiline':False]
['text':'
 * Assign the typeval "tv" to the variable or variables at "arg_start".
 * Handles both "var" with any type and "[var, var; var]" with a list type.
 * When "op" is not NULL it points to a string with characters that
 * must appear after the variable(s).  Use "+", "-" or "." for add, subtract
 * or concatenate.
 * Returns OK or FAIL;
 ','line_number':1170,'multiline':True]
['text':' copy values from "tv", don't move','line_number':1182,'multiline':False]
['text':' from skip_var_list()','line_number':1183,'multiline':False]
['text':' from skip_var_list()','line_number':1184,'multiline':False]
['text':' ASSIGN_FINAL, ASSIGN_CONST, etc.','line_number':1185,'multiline':False]
['text':' ":let var = expr" or ":for var in list"','line_number':1202,'multiline':False]
['text':' ":let [v1, v2] = list" or ":for [v1, v2] in listlist"','line_number':1208,'multiline':False]
['text':' Put the rest of the list (may be empty) in the var after ';'.','line_number':1242,'multiline':False]
['text':' Create a new list for this.','line_number':1243,'multiline':False]
['text':'
 * Skip over assignable variable "var" or list of variables "[var, var]".
 * Used for ":let varvar = expr" and ":for varvar in expr".
 * For "[var, var]" increment "*var_count" for each variable.
 * for "[var, var; var]" set "semicolon" to 1.
 * If "silent" is TRUE do not give an "invalid argument" error message.
 * Return NULL for an error.
 ','line_number':1276,'multiline':True]
['text':' "[var, var]": find the matching ']'.','line_number':1296,'multiline':False]
['text':' skip whites after '[', ';' or ','','line_number':1300,'multiline':False]
['text':'
 * Skip one (assignable) variable name, including @r, $VAR, &option, d.key,
 * l[idx].
 * In Vim9 script also skip over ": type" if "include_type" is TRUE.
 ','line_number':1336,'multiline':True]
['text':' termcap option name may have non-alpha characters','line_number':1350,'multiline':False]
['text':' "a: type" is declaring variable "a" with a type, not "a:".','line_number':1357,'multiline':False]
['text':' Same for "s: type".','line_number':1358,'multiline':False]
['text':'
 * List variables for hashtab "ht" with prefix "prefix".
 * If "empty" is TRUE also list NULL strings as empty strings.
 ','line_number':1370,'multiline':True]
['text':' apply :filter /pat/ to variable name','line_number':1397,'multiline':False]
['text':'
 * List global variables.
 ','line_number':1412,'multiline':True]
['text':'
 * List buffer variables.
 ','line_number':1421,'multiline':True]
['text':'
 * List window variables.
 ','line_number':1430,'multiline':True]
['text':'
 * List tab page variables.
 ','line_number':1439,'multiline':True]
['text':'
 * List variables in "arg".
 ','line_number':1448,'multiline':True]
['text':' get_name_len() takes care of expanding curly braces','line_number':1477,'multiline':False]
['text':' This is mainly to keep test 49 working: when expanding','line_number':1482,'multiline':False]
['text':' curly braces fails overrule the exception error message.','line_number':1483,'multiline':False]
['text':' handle d.key, l[idx], f(expr)','line_number':1502,'multiline':False]
['text':'
 * Set an environment variable, part of ex_let_one().
 ','line_number':1556,'multiline':True]
['text':' Find the end of the name.','line_number':1578,'multiline':False]
['text':'
 * Set an option, part of ex_let_one().
 ','line_number':1623,'multiline':True]
['text':' Find the end of the name.','line_number':1645,'multiline':False]
['text':' bool, possibly hidden','line_number':1689,'multiline':False]
['text':' number, possibly hidden','line_number':1692,'multiline':False]
['text':' If the option can be set to a function reference or a lambda','line_number':1701,'multiline':False]
['text':' and the passed value is a function reference, then convert it to','line_number':1702,'multiline':False]
['text':' the name (string) of the function reference.','line_number':1703,'multiline':False]
['text':' Avoid setting a string option to the text "v:false" or similar.','line_number':1708,'multiline':False]
['text':' In Vim9 script also don't convert a number to string.','line_number':1709,'multiline':False]
['text':' number, in legacy script also bool','line_number':1725,'multiline':False]
['text':' string','line_number':1743,'multiline':False]
['text':'
 * Set a register, part of ex_let_one().
 ','line_number':1762,'multiline':True]
['text':'
 * Set one item of ":let var = expr" or ":let [v1, v2] = list" to its value.
 * Returns a pointer to the char just after the var name.
 * Returns NULL if there is an error.
 ','line_number':1814,'multiline':True]
['text':' points to variable name','line_number':1821,'multiline':False]
['text':' value to assign to variable','line_number':1822,'multiline':False]
['text':' copy value from "tv"','line_number':1823,'multiline':False]
['text':' ASSIGN_CONST, ASSIGN_FINAL, etc.','line_number':1824,'multiline':False]
['text':' valid chars after variable name  or NULL','line_number':1825,'multiline':False]
['text':' "+", "-", "."  or NULL','line_number':1826,'multiline':False]
['text':' variable index for "let [a, b] = list"','line_number':1827,'multiline':False]
['text':' ":let $VAR = expr": Set environment variable.','line_number':1844,'multiline':False]
['text':' ":let &option = expr": Set option value.','line_number':1849,'multiline':False]
['text':' ":let &l:option = expr": Set local option value.','line_number':1850,'multiline':False]
['text':' ":let &g:option = expr": Set global option value.','line_number':1851,'multiline':False]
['text':' ":for &ts in range(8)": Set option value for for loop','line_number':1852,'multiline':False]
['text':' ":let @r = expr": Set register contents.','line_number':1857,'multiline':False]
['text':' ":let var = expr": Set internal variable.','line_number':1870,'multiline':False]
['text':' ":let var: type = expr": Set internal variable with type.','line_number':1871,'multiline':False]
['text':' ":let {expr} = expr": Idem, name made with curly braces','line_number':1872,'multiline':False]
['text':'
 * ":unlet[!] var1 ... " command.
 ','line_number':1895,'multiline':True]
['text':'
 * ":lockvar" and ":unlockvar" commands
 ','line_number':1904,'multiline':True]
['text':'
 * ":unlet", ":lockvar" and ":unlockvar" are quite similar.
 * Also used for Vim9 script.  "callback" is invoked as:
 *	callback(&lv, name_end, eap, deep, cookie)
 ','line_number':1924,'multiline':True]
['text':' Parse the name and find the end.','line_number':1962,'multiline':False]
['text':' error but continue parsing','line_number':1966,'multiline':False]
['text':' Environment variable, normal name or expanded name.','line_number':2011,'multiline':False]
['text':' unlet a List item.','line_number':2027,'multiline':False]
['text':' unlet a Dictionary item.','line_number':2030,'multiline':False]
['text':'
 * Unlet one item or a range of items from a list.
 * Return OK or FAIL.
 ','line_number':2036,'multiline':True]
['text':' Delete a range of List items.','line_number':2051,'multiline':False]
['text':'
 * "unlet" a variable.  Return OK if it existed, FAIL if not.
 * When "forceit" is TRUE don't complain if the variable doesn't exist.
 ','line_number':2063,'multiline':True]
['text':' init to shut up gcc','line_number':2072,'multiline':False]
['text':' can't :unlet a script variable in Vim9 script','line_number':2076,'multiline':False]
['text':' can't :unlet a script variable in Vim9 script from a function','line_number':2082,'multiline':False]
['text':'
 * Lock or unlock variable indicated by "lp".
 * "deep" is the levels to go (-1 for unlimited);
 * "lock" is TRUE for ":lockvar", FALSE for ":unlockvar".
 ','line_number':2156,'multiline':True]
['text':' Normal name or expanded name.','line_number':2189,'multiline':False]
['text':' For historic reasons this error is not given for a list','line_number':2204,'multiline':False]
['text':' or dict.  E.g., the b: dict could be locked/unlocked.','line_number':2205,'multiline':False]
['text':' nothing to do','line_number':2240,'multiline':False]
['text':' (un)lock the item.','line_number':2243,'multiline':False]
['text':' (un)lock a range of List items.','line_number':2249,'multiline':False]
['text':' (un)lock a List item.','line_number':2258,'multiline':False]
['text':' This check must be before ll_class.','line_number':2260,'multiline':False]
['text':' (un)lock an object variable.','line_number':2262,'multiline':False]
['text':' (un)lock a class variable.','line_number':2268,'multiline':False]
['text':' (un)lock a Dictionary item.','line_number':2274,'multiline':False]
['text':'
 * Lock or unlock an item.  "deep" is nr of levels to go.
 * When "check_refcount" is TRUE do not lock a list or dict with a reference
 * count larger than 1.
 ','line_number':2287,'multiline':True]
['text':' lock/unlock the item itself','line_number':2316,'multiline':False]
['text':' recursive: lock/unlock the items the List contains','line_number':2366,'multiline':False]
['text':' recursive: lock/unlock the items the List contains','line_number':2384,'multiline':False]
['text':'
 * Delete all "menutrans_" variables.
 ','line_number':2402,'multiline':True]
['text':'
 * Local string buffer for the next two functions to store a variable name
 * with its prefix. Allocated in cat_prefix_varname(), freed later in
 * get_user_var_name().
 ','line_number':2426,'multiline':True]
['text':'
 * Function to concatenate a prefix and a variable name.
 ','line_number':2435,'multiline':True]
['text':' some additional space','line_number':2447,'multiline':False]
['text':'
 * Function given to ExpandGeneric() to obtain the list of user defined
 * (global/buffer/window/built-in) variable names.
 ','line_number':2462,'multiline':True]
['text':' Global variables','line_number':2483,'multiline':False]
['text':' b: variables','line_number':2497,'multiline':False]
['text':' w: variables','line_number':2510,'multiline':False]
['text':' t: variables','line_number':2523,'multiline':False]
['text':' v: variables','line_number':2536,'multiline':False]
['text':'
 * Returns the global variable dictionary
 ','line_number':2559,'multiline':True]
['text':'
 * Returns the global variable hash table
 ','line_number':2568,'multiline':True]
['text':'
 * Returns the v: variable dictionary
 ','line_number':2577,'multiline':True]
['text':'
 * Returns the index of a v:variable.  Negative if not found.
 * Returns DI_ flags in "di_flags".
 ','line_number':2586,'multiline':True]
['text':'
 * Set type of v: variable to "type".
 ','line_number':2604,'multiline':True]
['text':'
 * Set number v: variable to "val".
 * Note that this does not set the type, use set_vim_var_type() for that.
 ','line_number':2613,'multiline':True]
['text':'
 * Get typval_T v: variable value.
 ','line_number':2629,'multiline':True]
['text':'
 * Set v: variable to "tv".  Only accepts the same type.
 * Takes over the value of "tv".
 ','line_number':2646,'multiline':True]
['text':' VV_RO is also checked when compiling, but let's check here as well.','line_number':2659,'multiline':False]
['text':'
 * Get number v: variable value.
 ','line_number':2675,'multiline':True]
['text':'
 * Get string v: variable value.  Uses a static buffer, can only be used once.
 * If the String variable has never been set, return an empty string.
 * Never returns NULL;
 ','line_number':2684,'multiline':True]
['text':'
 * Get List v: variable value.  Caller must take care of reference count when
 * needed.
 ','line_number':2695,'multiline':True]
['text':'
 * Get Dict v: variable value.  Caller must take care of reference count when
 * needed.
 ','line_number':2705,'multiline':True]
['text':'
 * Set v:char to character "c".
 ','line_number':2715,'multiline':True]
['text':'
 * Set v:count to "count" and v:count1 to "count1".
 * When "set_prevcount" is TRUE first set v:prevcount from v:count.
 ','line_number':2733,'multiline':True]
['text':'
 * Save variables that might be changed as a side effect.  Used when executing
 * a timer callback.
 ','line_number':2749,'multiline':True]
['text':'
 * Restore variables saved by save_vimvars().
 ','line_number':2761,'multiline':True]
['text':'
 * Set string v: variable to a copy of "val". If 'copy' is FALSE, then set the
 * value.
 ','line_number':2772,'multiline':True]
['text':' length of "val" to use or -1 (whole string)','line_number':2780,'multiline':False]
['text':'
 * Set List v: variable to "val".
 ','line_number':2792,'multiline':True]
['text':'
 * Set Dictionary v: variable to "val".
 ','line_number':2805,'multiline':True]
['text':'
 * Set the v:argv list.
 ','line_number':2821,'multiline':True]
['text':'
 * Reset v:register, taking the 'clipboard' setting into account.
 ','line_number':2842,'multiline':True]
['text':' Adjust the register according to 'clipboard', so that when','line_number':2850,'multiline':False]
['text':' "unnamed" is present it becomes '*' or '+' instead of '"'.','line_number':2851,'multiline':False]
['text':'
 * Set v:register if needed.
 ','line_number':2858,'multiline':True]
['text':' Avoid free/alloc when the value is already right.','line_number':2870,'multiline':False]
['text':'
 * Get or set v:exception.  If "oldval" == NULL, return the current value.
 * Otherwise, restore the value to "oldval" and return NULL.
 * Must always be called in pairs to save and restore v:exception!  Does not
 * take care of memory allocations.
 ','line_number':2875,'multiline':True]
['text':'
 * Get or set v:throwpoint.  If "oldval" == NULL, return the current value.
 * Otherwise, restore the value to "oldval" and return NULL.
 * Must always be called in pairs to save and restore v:throwpoint!  Does not
 * take care of memory allocations.
 ','line_number':2891,'multiline':True]
['text':'
 * Set v:cmdarg.
 * If "eap" != NULL, use "eap" to generate the value and return the old value.
 * If "oldarg" != NULL, restore the value to "oldarg" and return NULL.
 * Must always be called in pairs!
 ','line_number':2907,'multiline':True]
['text':' " ++ff=unix"','line_number':2939,'multiline':False]
['text':' " ++bad=" + "keep" or "drop"','line_number':2943,'multiline':False]
['text':'
 * Get the value of internal variable "name".
 * If "flags" has EVAL_VAR_IMPORT may return a VAR_ANY with v_number set to the
 * imported script ID.
 * Return OK or FAIL.  If OK is returned "rettv" must be cleared.
 ','line_number':2977,'multiline':True]
['text':' length of "name" or zero','line_number':2986,'multiline':False]
['text':' script ID for imported item or zero','line_number':2987,'multiline':False]
['text':' NULL when only checking existence','line_number':2988,'multiline':False]
['text':' non-NULL when typval's dict item is needed','line_number':2989,'multiline':False]
['text':' EVAL_VAR_ flags','line_number':2990,'multiline':False]
['text':' truncate the name, so that we can use strcmp()','line_number':3001,'multiline':False]
['text':' Check for local variable when debugging.','line_number':3006,'multiline':False]
['text':' Check for user-defined variables.','line_number':3009,'multiline':False]
['text':' imported variable from another script','line_number':3030,'multiline':False]
['text':' special value that is used in handle_subscript()','line_number':3064,'multiline':False]
['text':' In Vim9 script we can get a function reference by using the','line_number':3076,'multiline':False]
['text':' function name.  For a global non-autoload function "g:" is','line_number':3077,'multiline':False]
['text':' required.','line_number':3078,'multiline':False]
['text':' Keep the "g:", otherwise script-local may be','line_number':3087,'multiline':False]
['text':' assumed.','line_number':3088,'multiline':False]
['text':' type alias or class imported from another script.  Check','line_number':3126,'multiline':False]
['text':' whether it is exported from the other script.','line_number':3127,'multiline':False]
['text':' If a list or dict variable wasn't initialized and has meaningful','line_number':3142,'multiline':False]
['text':' type, do it now.  Not for global variables, they are not','line_number':3143,'multiline':False]
['text':' declared.','line_number':3144,'multiline':False]
['text':'
 * Get the value of internal variable "name", also handling "import.name".
 * Return OK or FAIL.  If OK is returned "rettv" must be cleared.
 ','line_number':3197,'multiline':True]
['text':'
 * Check if variable "name[len]" is a local variable or an argument.
 * If so, "*eval_lavars_used" is set to TRUE.
 ','line_number':3226,'multiline':True]
['text':' truncate the name, so that we can use strcmp()','line_number':3240,'multiline':False]
['text':'
 * Find variable "name" in the list of variables.
 * Return a pointer to it if found, NULL if not found.
 * Careful: "a:0" variables don't have a name.
 * When "htp" is not NULL  set "htp" to the hashtab_T used.
 ','line_number':3254,'multiline':True]
['text':' Search in parent scope for lambda','line_number':3276,'multiline':False]
['text':' in Vim9 script items without a scope can be script-local','line_number':3281,'multiline':False]
['text':' When using "vim9script autoload" script-local items are prefixed but can','line_number':3297,'multiline':False]
['text':' be used with s:name.','line_number':3298,'multiline':False]
['text':'
 * Like find_var() but if the name starts with <SNR>99_ then look in the
 * referenced script (used for a funcref).
 ','line_number':3328,'multiline':True]
['text':'
 * Find variable "varname" in hashtab "ht" with name "htname".
 * When "varname" is empty returns curwin/curtab/etc vars dictionary.
 * Returns NULL if not found.
 ','line_number':3361,'multiline':True]
['text':' Must be something like "s:", otherwise "ht" would be NULL.','line_number':3377,'multiline':False]
['text':' For global variables we may try auto-loading the script.  If it','line_number':3395,'multiline':False]
['text':' worked find the variable again.  Don't auto-load a script if it was','line_number':3396,'multiline':False]
['text':' loaded already, otherwise it would be loaded every time when','line_number':3397,'multiline':False]
['text':' checking if a function name is a Funcref variable.','line_number':3398,'multiline':False]
['text':' Note: script_autoload() may make "hi" invalid. It must either','line_number':3401,'multiline':False]
['text':' be obtained again or not used.','line_number':3402,'multiline':False]
['text':'
 * Get the script-local hashtab.  NULL if not in a script context.
 ','line_number':3413,'multiline':True]
['text':'
 * Look for "name[len]" in script-local variables and functions.
 * When "cmd" is TRUE it must look like a command, a function must be followed
 * by "(" or "->".
 * Return OK when found, FAIL when not found.
 ','line_number':3426,'multiline':True]
['text':' avoid an alloc/free for short names','line_number':3451,'multiline':False]
['text':' if not script-local, then perhaps imported','line_number':3465,'multiline':False]
['text':' Find a function, so that a following "->" works.','line_number':3471,'multiline':False]
['text':' When used as a command require "(" or "->" to follow, "Cmd" is a user','line_number':3472,'multiline':False]
['text':' command while "Cmd()" is a function call.','line_number':3473,'multiline':False]
['text':' Do not check for an internal function, since it might also be a','line_number':3480,'multiline':False]
['text':' valid command, such as ":split" versus "split()".','line_number':3481,'multiline':False]
['text':' Skip "g:" before a function name.','line_number':3482,'multiline':False]
['text':'
 * Find the hashtab used for a variable name.
 * Return NULL if the name is not valid.
 * Set "varname" to the start of name without ':'.
 ','line_number':3496,'multiline':True]
['text':' The name must not start with a colon or #.','line_number':3511,'multiline':False]
['text':' "version" is "v:version" in all scopes if scriptversion < 3.','line_number':3516,'multiline':False]
['text':' Same for a few other variables marked with VV_COMPAT.','line_number':3517,'multiline':False]
['text':' local variable','line_number':3527,'multiline':False]
['text':' In Vim9 script items at the script level are script-local, except','line_number':3529,'multiline':False]
['text':' for autoload names.','line_number':3530,'multiline':False]
['text':' global variable','line_number':3538,'multiline':False]
['text':' global variable','line_number':3541,'multiline':False]
['text':' There must be no ':' or '#' in the rest of the name, unless g: is used','line_number':3543,'multiline':False]
['text':' buffer variable','line_number':3547,'multiline':False]
['text':' window variable','line_number':3549,'multiline':False]
['text':' tab page variable','line_number':3551,'multiline':False]
['text':' v: variable','line_number':3553,'multiline':False]
['text':' a: and l: are only used in functions defined with ":function"','line_number':3559,'multiline':False]
['text':' a: function argument','line_number':3560,'multiline':False]
['text':' l: local function variable','line_number':3562,'multiline':False]
['text':' script variable','line_number':3565,'multiline':False]
['text':'
 * Get the string value of a (global/local) variable.
 * Note: see tv_get_string() for how long the pointer remains valid.
 * Returns NULL when it doesn't exist.
 ','line_number':3574,'multiline':True]
['text':'
 * Allocate a new hashtab for a sourced script.  It will be used while
 * sourcing this script and when executing functions defined in the script.
 ','line_number':3590,'multiline':True]
['text':'
 * Initialize dictionary "dict" as a scope and set variable "dict_var" to
 * point to it.
 ','line_number':3606,'multiline':True]
['text':'
 * Unreference a dictionary initialized by init_var_dict().
 ','line_number':3625,'multiline':True]
['text':' Now the dict needs to be freed if no one else is using it, go back to','line_number':3631,'multiline':False]
['text':' normal reference counting.','line_number':3632,'multiline':False]
['text':'
 * Clean up a list of internal variables.
 * Frees all allocated variables and the value they contain.
 * Clears hashtab "ht", does not free it.
 ','line_number':3637,'multiline':True]
['text':'
 * Like vars_clear(), but only free the value if "free_val" is TRUE.
 ','line_number':3648,'multiline':True]
['text':' Free the variable.  Don't remove it from the hashtab,','line_number':3666,'multiline':False]
['text':' ht_array might change then.  hash_clear() takes care of it','line_number':3667,'multiline':False]
['text':' later.','line_number':3668,'multiline':False]
['text':'
 * Delete a variable from hashtab "ht" at item "hi".
 * Clear the variable value and free the dictitem.
 ','line_number':3680,'multiline':True]
['text':'
 * List the value of one internal variable.
 ','line_number':3696,'multiline':True]
['text':' when TRUE clear rest of screen and set to FALSE','line_number':3718,'multiline':False]
['text':' don't use msg() or msg_attr() to avoid overwriting "v:statusmsg"','line_number':3720,'multiline':False]
['text':' "a:" vars don't have a name stored','line_number':3723,'multiline':False]
['text':'
 * Addition handling for setting a v: variable.
 * Return TRUE if the variable should be set normally,
 *        FALSE if nothing else needs to be done.
 ','line_number':3757,'multiline':True]
['text':' Careful: when assigning to v:errmsg and','line_number':3777,'multiline':False]
['text':' tv_get_string() causes an error message the variable','line_number':3778,'multiline':False]
['text':' will already be set.','line_number':3779,'multiline':False]
['text':' Take over the string to avoid an extra alloc/free.','line_number':3785,'multiline':False]
['text':'
 * Set variable "name" to value in "tv".
 * If the variable already exists, the value is updated.
 * Otherwise the variable is created.
 ','line_number':3813,'multiline':True]
['text':' make copy of value in "tv"','line_number':3822,'multiline':False]
['text':'
 * Set variable "name" to value in "tv_arg".
 * When "sid" is non-zero "name" is in the script with this ID.
 * If the variable already exists and "is_const" is FALSE the value is updated.
 * Otherwise the variable is created.
 ','line_number':3827,'multiline':True]
['text':' make copy of value in "tv"','line_number':3839,'multiline':False]
['text':' ASSIGN_CONST, ASSIGN_FINAL, etc.','line_number':3840,'multiline':False]
['text':' index for ":let [a, b] = list"','line_number':3841,'multiline':False]
['text':' free tv_arg if not used','line_number':3856,'multiline':False]
['text':' In a vim9 autoload script an exported variable is put in the','line_number':3873,'multiline':False]
['text':' global namespace with the autoload prefix.','line_number':3874,'multiline':False]
['text':' Do not make g:var, w:var, b:var or t:var final.','line_number':3903,'multiline':False]
['text':' For "[a, _] = list" the underscore is ignored.','line_number':3909,'multiline':False]
['text':' imported name space cannot be used','line_number':3923,'multiline':False]
['text':' Search in parent scope which is possible to reference from lambda','line_number':3940,'multiline':False]
['text':' Destination is a bool and the value is not, but it can be','line_number':3950,'multiline':False]
['text':' converted.','line_number':3951,'multiline':False]
['text':' Item already exists.  Allowed to replace when reloading.','line_number':3960,'multiline':False]
['text':' check the type and adjust to bool if needed','line_number':3992,'multiline':False]
['text':' can only redefine once','line_number':4013,'multiline':False]
['text':' A Vim9 script-local variable is also present in sn_all_vars','line_number':4016,'multiline':False]
['text':' and sn_var_vals.  It may set "type" from "tv".','line_number':4017,'multiline':False]
['text':' existing variable, need to clear the value','line_number':4024,'multiline':False]
['text':' Handle setting internal v: variables separately where needed to','line_number':4026,'multiline':False]
['text':' prevent changing the type.','line_number':4027,'multiline':False]
['text':' Item not found, check if a function already exists.','line_number':4049,'multiline':False]
['text':' add a new variable','line_number':4057,'multiline':False]
['text':' Can't add "v:" or "a:" variable.','line_number':4067,'multiline':False]
['text':' Make sure the variable name is valid.  In Vim9 script an','line_number':4074,'multiline':False]
['text':' autoload variable must be prefixed with "g:" unless in an','line_number':4075,'multiline':False]
['text':' autoload script.','line_number':4076,'multiline':False]
['text':' A Vim9 script-local variable is also added to sn_all_vars and','line_number':4094,'multiline':False]
['text':' sn_var_vals. It may set "type" from "tv".','line_number':4095,'multiline':False]
['text':' ":const var = value" locks the value','line_number':4116,'multiline':False]
['text':' ":final var = value" locks "var"','line_number':4117,'multiline':False]
['text':' Like :lockvar! name: lock the value and what it contains, but only','line_number':4119,'multiline':False]
['text':' if the reference count is up to one.  That locks only literal','line_number':4120,'multiline':False]
['text':' values.','line_number':4121,'multiline':False]
['text':'
 * Check in this order for backwards compatibility:
 * - Whether the variable is read-only
 * - Whether the variable value is locked
 * - Whether the variable is locked
 ','line_number':4130,'multiline':True]
['text':'
 * Return TRUE if di_flags "flags" indicates variable "name" is read-only.
 * Also give an error message.
 ','line_number':4146,'multiline':True]
['text':'
 * Return TRUE if di_flags "flags" indicates variable "name" is locked.
 * Also give an error message.
 ','line_number':4174,'multiline':True]
['text':'
 * Return TRUE if di_flags "flags" indicates variable "name" is fixed.
 * Also give an error message.
 ','line_number':4190,'multiline':True]
['text':'
 * Check if a funcref is assigned to a valid variable name.
 * Return TRUE and give an error if not.
 ','line_number':4209,'multiline':True]
['text':' points to start of variable name','line_number':4215,'multiline':False]
['text':' TRUE when creating the variable','line_number':4216,'multiline':False]
['text':' Allow for w: b: s: and t:.  In Vim9 script s: is not allowed, because','line_number':4218,'multiline':False]
['text':' the name can be used without the s: prefix.','line_number':4219,'multiline':False]
['text':' Allow autoload variable.','line_number':4220,'multiline':False]
['text':' Don't allow hiding a function.  When "v" is not NULL we might be','line_number':4230,'multiline':False]
['text':' assigning another function to the same var, the type is checked','line_number':4231,'multiline':False]
['text':' below.','line_number':4232,'multiline':False]
['text':'
 * Return TRUE if "flags" indicates variable "name" has a locked (immutable)
 * value.  Also give an error message, using "name" or _("name") when
 * "use_gettext" is TRUE.
 ','line_number':4242,'multiline':True]
['text':'
 * Check if a variable name is valid.  When "autoload" is true "#" is allowed.
 * If "len" is -1 use all of "varname", otherwise up to "varname[len]".
 * Return FALSE and give an error if not.
 ','line_number':4271,'multiline':True]
['text':'
 * Implements the logic to retrieve local variable and option values.
 * Used by "getwinvar()" "gettabvar()" "gettabwinvar()" "getbufvar()".
 ','line_number':4291,'multiline':True]
['text':' Default value if not found.','line_number':4299,'multiline':False]
['text':' 't'ab, 'w'indow or 'b'uffer local.','line_number':4300,'multiline':False]
['text':' can be NULL','line_number':4301,'multiline':False]
['text':' Ignored if htname is not 'b'.','line_number':4303,'multiline':False]
['text':' Set curwin to be our win, temporarily.  Also set the tabpage,','line_number':4319,'multiline':False]
['text':' otherwise the window is not valid. Only do this when needed,','line_number':4320,'multiline':False]
['text':' autocommands get blocked.','line_number':4321,'multiline':False]
['text':' If we have a buffer reference avoid the switching, we're saving and','line_number':4322,'multiline':False]
['text':' restoring curbuf directly.','line_number':4323,'multiline':False]
['text':' Handle options. There are no tab-local options.','line_number':4327,'multiline':False]
['text':' Change curbuf so the option is read from the correct buffer.','line_number':4332,'multiline':False]
['text':' get all window-local or buffer-local options in a dict','line_number':4338,'multiline':False]
['text':' Local option','line_number':4348,'multiline':False]
['text':' Empty string: return a dict with all the local variables.','line_number':4355,'multiline':False]
['text':' Look up the variable.','line_number':4376,'multiline':False]
['text':' restore previous notion of curwin','line_number':4387,'multiline':False]
['text':' use the default value','line_number':4392,'multiline':False]
['text':'
 * getwinvar() and gettabwinvar()
 ','line_number':4398,'multiline':True]
['text':' 1 for gettabwinvar()','line_number':4405,'multiline':False]
['text':'
 * Set option "varname" to the value of "varp" for the current buffer/window.
 ','line_number':4421,'multiline':True]
['text':' avoid using "false"','line_number':4448,'multiline':False]
['text':'
 * "setwinvar()" and "settabwinvar()" functions
 ','line_number':4462,'multiline':True]
['text':'
 * reset v:option_new, v:option_old, v:option_oldlocal, v:option_oldglobal,
 * v:option_type, and v:option_command.
 ','line_number':4511,'multiline':True]
['text':'
 * Add an assert error to v:errors.
 ','line_number':4526,'multiline':True]
['text':' Make sure v:errors is a list.','line_number':4535,'multiline':False]
['text':' get_name_len() takes care of expanding curly braces','line_number':4550,'multiline':False]
['text':' handle d.key, l[idx], f(expr)','line_number':4561,'multiline':False]
['text':' only valid when redir_lval is not NULL','line_number':4578,'multiline':False]
['text':'
 * Start recording command output to a variable
 * When "append" is TRUE append to an existing variable.
 * Returns OK if successfully completed the setup.  FAIL otherwise.
 ','line_number':4603,'multiline':True]
['text':' Catch a bad name early.','line_number':4614,'multiline':False]
['text':' Make a copy of the name, it is used in redir_lval until redir ends.','line_number':4621,'multiline':False]
['text':' The output is stored in growarray "redir_ga" until redirection ends.','line_number':4632,'multiline':False]
['text':' Parse the variable name (can be a dict or list entry).','line_number':4635,'multiline':False]
['text':' Trailing characters are present after the variable name','line_number':4642,'multiline':False]
['text':' don't store a value, only cleanup','line_number':4646,'multiline':False]
['text':' check if we can write to the variable: set it to or append an empty','line_number':4651,'multiline':False]
['text':' string','line_number':4652,'multiline':False]
['text':' don't store a value, only cleanup','line_number':4665,'multiline':False]
['text':'
 * Append "value[value_len]" to the variable set by var_redir_start().
 * The actual appending is postponed until redirection ends, because the value
 * appended may in fact be the string we write to, changing it may cause freed
 * memory to be used:
 *   :redir => foo
 *   :let foo
 *   :redir END
 ','line_number':4673,'multiline':True]
['text':' Append the entire string','line_number':4691,'multiline':False]
['text':' Append only "value_len" characters','line_number':4693,'multiline':False]
['text':'
 * Stop redirecting command output to a variable.
 * Frees the allocated memory.
 ','line_number':4704,'multiline':True]
['text':' If there was no error: assign the text to the variable.','line_number':4721,'multiline':False]
['text':' Append the trailing NUL.','line_number':4724,'multiline':False]
['text':' Call get_lval() again, if it's inside a Dict or List it may','line_number':4727,'multiline':False]
['text':' have changed.','line_number':4728,'multiline':False]
['text':' free the collected output','line_number':4737,'multiline':False]
['text':'
 * Get the collected redirected text and clear redir_ga.
 ','line_number':4745,'multiline':True]
['text':' Append the trailing NUL.','line_number':4753,'multiline':False]
['text':'
 * "gettabvar()" function
 ','line_number':4759,'multiline':True]
['text':'
 * "gettabwinvar()" function
 ','line_number':4783,'multiline':True]
['text':'
 * "getwinvar()" function
 ','line_number':4798,'multiline':True]
['text':'
 * "getbufvar()" function
 ','line_number':4812,'multiline':True]
['text':'
 * "settabvar()" function
 ','line_number':4832,'multiline':True]
['text':' Restore current tabpage','line_number':4870,'multiline':False]
['text':'
 * "settabwinvar()" function
 ','line_number':4875,'multiline':True]
['text':'
 * "setwinvar()" function
 ','line_number':4890,'multiline':True]
['text':'
 * "setbufvar()" function
 ','line_number':4904,'multiline':True]
['text':' Set curbuf to be our buf, temporarily.','line_number':4933,'multiline':False]
['text':' Only when it worked to set "curbuf".','line_number':4937,'multiline':False]
['text':' reset notion of buffer','line_number':4940,'multiline':False]
['text':'
 * Get a callback from "arg".  It can be a Funcref or a function name.
 * When "arg" is zero "res.cb_name" is set to an empty string.
 * If "res.cb_name" is allocated then "res.cb_free_name" is set to TRUE.
 * "res.cb_name" is set to NULL for an invalid argument.
 ','line_number':4961,'multiline':True]
['text':'
 * Copy a callback into a typval_T.
 ','line_number':5013,'multiline':True]
['text':'
 * Make a copy of "src" into "dest", allocating the function name if needed,
 * without incrementing the refcount.
 ','line_number':5033,'multiline':True]
['text':' just a function name, make a copy','line_number':5042,'multiline':False]
['text':' cb_name is a pointer into cb_partial','line_number':5048,'multiline':False]
['text':'
 * Copy callback from "src" to "dest", incrementing the refcounts.
 ','line_number':5055,'multiline':True]
['text':'
 * When a callback refers to an autoload import, change the function name to
 * the "path#name" form.  Uses the current script context.
 * Only works when the name is allocated.
 ','line_number':5076,'multiline':True]
['text':'
 * Unref/free "callback" returned by get_callback() or set_callback().
 ','line_number':5126,'multiline':True]
['text':' FEAT_EVAL','line_number':5147,'multiline':False]
