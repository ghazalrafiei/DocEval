['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]
['text':'
 * spell.c: code for spell checking
 *
 * See spellfile.c for the Vim spell file format.
 *
 * The spell checking mechanism uses a tree (aka trie).  Each node in the tree
 * has a list of bytes that can appear (siblings).  For each byte there is a
 * pointer to the node with the byte that follows in the word (child).
 *
 * A NUL byte is used where the word may end.  The bytes are sorted, so that
 * binary searching can be used and the NUL bytes are at the start.  The
 * number of possible bytes is stored before the list of bytes.
 *
 * The tree uses two arrays: "byts" stores the characters, "idxs" stores
 * either the next index or flags.  The tree starts at index 0.  For example,
 * to lookup "vi" this sequence is followed:
 *	i = 0
 *	len = byts[i]
 *	n = where "v" appears in byts[i + 1] to byts[i + len]
 *	i = idxs[n]
 *	len = byts[i]
 *	n = where "i" appears in byts[i + 1] to byts[i + len]
 *	i = idxs[n]
 *	len = byts[i]
 *	find that byts[i + 1] is 0, idxs[i + 1] has flags for "vi".
 *
 * There are two word trees: one with case-folded words and one with words in
 * original case.  The second one is only used for keep-case words and is
 * usually small.
 *
 * There is one additional tree for when not all prefixes are applied when
 * generating the .spl file.  This tree stores all the possible prefixes, as
 * if they were words.  At each word (prefix) end the prefix nr is stored, the
 * following word must support this prefix nr.  And the condition nr is
 * stored, used to lookup the condition that the word must match with.
 *
 * Thanks to Olaf Seibert for providing an example implementation of this tree
 * and the compression mechanism.
 * LZ trie ideas:
 *	http://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf
 * More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html
 *
 * Matching involves checking the caps type: Onecap ALLCAP KeepCap.
 *
 * Why doesn't Vim use aspell/ispell/myspell/etc.?
 * See ":help develop-spell".
 ','line_number':10,'multiline':True]
['text':' it's in os_unix.h for Unix','line_number':63,'multiline':False]
['text':' for time_t','line_number':64,'multiline':False]
['text':' word valid in all regions','line_number':67,'multiline':False]
['text':' Result values.  Lower number is accepted over higher one.','line_number':69,'multiline':False]
['text':'
 * Structure to store info for word matching.
 ','line_number':76,'multiline':True]
['text':' info for language and region','line_number':81,'multiline':False]
['text':' pointers to original text to be checked','line_number':83,'multiline':False]
['text':' start of word being checked','line_number':84,'multiline':False]
['text':' end of matching word so far','line_number':85,'multiline':False]
['text':' next char to be added to mi_fword','line_number':86,'multiline':False]
['text':' char after what was used for','line_number':87,'multiline':False]
['text':' mi_capflags','line_number':88,'multiline':False]
['text':' case-folded text','line_number':90,'multiline':False]
['text':' mi_word case-folded','line_number':91,'multiline':False]
['text':' nr of valid bytes in mi_fword','line_number':92,'multiline':False]
['text':' for when checking word after a prefix','line_number':94,'multiline':False]
['text':' index in sl_pidxs with list of','line_number':95,'multiline':False]
['text':' affixID/condition','line_number':96,'multiline':False]
['text':' number of entries at mi_prefarridx','line_number':97,'multiline':False]
['text':' byte length of prefix','line_number':98,'multiline':False]
['text':' byte length of prefix in original','line_number':99,'multiline':False]
['text':' case','line_number':100,'multiline':False]
['text':' for when checking a compound word','line_number':102,'multiline':False]
['text':' start of following word offset','line_number':103,'multiline':False]
['text':' flags for compound words used','line_number':104,'multiline':False]
['text':' nr of compound words used','line_number':105,'multiline':False]
['text':' nr of COMPOUNDROOT words','line_number':106,'multiline':False]
['text':' others','line_number':108,'multiline':False]
['text':' result so far: SP_BAD, SP_OK, etc.','line_number':109,'multiline':False]
['text':' WF_ONECAP WF_ALLCAP WF_KEEPCAP','line_number':110,'multiline':False]
['text':' buffer being checked','line_number':111,'multiline':False]
['text':' for NOBREAK','line_number':113,'multiline':False]
['text':' "mi_result" without following word','line_number':114,'multiline':False]
['text':' "mi_end" without following word','line_number':115,'multiline':False]
['text':' mode values for find_word','line_number':121,'multiline':False]
['text':' find word case-folded','line_number':122,'multiline':False]
['text':' find keep-case word','line_number':123,'multiline':False]
['text':' find word after prefix','line_number':124,'multiline':False]
['text':' find case-folded compound word','line_number':125,'multiline':False]
['text':' find keep-case compound word','line_number':126,'multiline':False]
['text':' type values for get_char_type','line_number':128,'multiline':False]
['text':'
 * Main spell-checking function.
 * "ptr" points to a character that could be the start of a word.
 * "*attrp" is set to the highlight index for a badly spelled word.  For a
 * non-word or when it's OK it remains unchanged.
 * This must only be called when 'spelllang' is not empty.
 *
 * "capcol" is used to check for a Capitalised word after the end of a
 * sentence.  If it's zero then perform the check.  Return the column where to
 * check next, or -1 when no sentence end was found.  If it's NULL then don't
 * worry.
 *
 * Returns the length of the word in bytes, also when it's OK, so that the
 * caller can skip over the word.
 ','line_number':148,'multiline':True]
['text':' current window','line_number':165,'multiline':False]
['text':' column to check for Capital','line_number':168,'multiline':False]
['text':' count good words','line_number':169,'multiline':False]
['text':' Most things are put in "mi" so that it can','line_number':171,'multiline':False]
['text':' be passed to functions quickly.','line_number':172,'multiline':False]
['text':' found a number first','line_number':173,'multiline':False]
['text':' A word never starts at a space or a control character.  Return quickly','line_number':181,'multiline':False]
['text':' then, skipping over the character.','line_number':182,'multiline':False]
['text':' Return here when loading language files failed.','line_number':186,'multiline':False]
['text':' A number is always OK.  Also skip hexadecimal numbers 0xFF99 and','line_number':192,'multiline':False]
['text':' 0X99FF.  But always do check spelling to find "3GPP" and "11','line_number':193,'multiline':False]
['text':' julifeest".','line_number':194,'multiline':False]
['text':' Find the normal end of the word (until the next non-word character).','line_number':206,'multiline':False]
['text':' Check word starting with capital letter.','line_number':223,'multiline':False]
['text':' We always use the characters up to the next non-word character,','line_number':232,'multiline':False]
['text':' also for bad words.','line_number':233,'multiline':False]
['text':' Check caps type later.','line_number':236,'multiline':False]
['text':' case-fold the word with one non-word character, so that we can check','line_number':241,'multiline':False]
['text':' for the word end.','line_number':242,'multiline':False]
['text':' Introduce a fake word end space into the folded word.','line_number':251,'multiline':False]
['text':' The word is bad unless we recognize it.','line_number':254,'multiline':False]
['text':'
     * Loop over the languages specified in 'spelllang'.
     * We check them all, because a word may be matched longer in another
     * language.
     ','line_number':258,'multiline':True]
['text':' If reloading fails the language is still in the list but everything','line_number':267,'multiline':False]
['text':' has been cleared.','line_number':268,'multiline':False]
['text':' Check for a matching word in case-folded words.','line_number':272,'multiline':False]
['text':' Check for a matching word in keep-case words.','line_number':275,'multiline':False]
['text':' Check for matching prefixes.','line_number':278,'multiline':False]
['text':' For a NOBREAK language, may want to use a word without a following','line_number':281,'multiline':False]
['text':' word as a backup.','line_number':282,'multiline':False]
['text':' Count the word in the first language where it's found to be OK.','line_number':290,'multiline':False]
['text':' If we found a number skip over it.  Allows for "42nd".  Do flag','line_number':301,'multiline':False]
['text':' rare and local words, e.g., "3GPP".','line_number':302,'multiline':False]
['text':' When we are at a non-word character there is no error, just','line_number':309,'multiline':False]
['text':' skip over the character (try looking for a word after it).','line_number':310,'multiline':False]
['text':' Check for end of sentence.','line_number':318,'multiline':False]
['text':' Always include at least one character.  Required for when there','line_number':332,'multiline':False]
['text':' is a mixup in "midword".','line_number':333,'multiline':False]
['text':' First language in 'spelllang' is NOBREAK.  Find first position','line_number':341,'multiline':False]
['text':' at which any word would be valid.','line_number':342,'multiline':False]
['text':' Report SpellCap only when the word isn't badly spelled.','line_number':376,'multiline':False]
['text':'
 * Determine the type of character 'c'.
 ','line_number':384,'multiline':True]
['text':'
 * Returns a pointer to the end of the word starting at "str".
 * Supports camelCase words.
 ','line_number':397,'multiline':True]
['text':' We need at most the types of the type of the last two chars.','line_number':415,'multiline':False]
['text':' Handle the following cases:','line_number':427,'multiline':False]
['text':' UpperUpperLower','line_number':428,'multiline':False]
['text':' Back up by one char.','line_number':430,'multiline':False]
['text':' Handle the following cases:','line_number':438,'multiline':False]
['text':' LowerUpper LowerDigit UpperDigit DigitUpper DigitLower','line_number':439,'multiline':False]
['text':'
 * Check if the word at "mip->mi_word" is in the tree.
 * When "mode" is FIND_FOLDWORD check in fold-case word tree.
 * When "mode" is FIND_KEEPWORD check in keep-case word tree.
 * When "mode" is FIND_PREFIX check for word after prefix in fold-case word
 * tree.
 *
 * For a match mip->mi_result is updated.
 ','line_number':453,'multiline':True]
['text':' length at possible word endings','line_number':466,'multiline':False]
['text':' possible word endings','line_number':467,'multiline':False]
['text':' Check for word with matching case in keep-case tree.','line_number':488,'multiline':False]
['text':' no case folding, always enough bytes','line_number':490,'multiline':False]
['text':' Skip over the previously found word(s).','line_number':495,'multiline':False]
['text':' Check for case-folded in case-folded tree.','line_number':500,'multiline':False]
['text':' available case-folded bytes','line_number':502,'multiline':False]
['text':' Skip over the prefix.','line_number':508,'multiline':False]
['text':' Skip over the previously found word(s).','line_number':514,'multiline':False]
['text':' array is empty','line_number':522,'multiline':False]
['text':'
     * Repeat advancing in the tree until:
     * - there is a byte that doesn't match,
     * - we reach the end of the tree,
     * - or we reach the end of the line.
     ','line_number':524,'multiline':True]
['text':' If the first possible byte is a zero the word could end here.','line_number':537,'multiline':False]
['text':' Remember this index, we first check for the longest word.','line_number':538,'multiline':False]
['text':' Must be a corrupted spell file.','line_number':543,'multiline':False]
['text':' Skip over the zeros, there can be several flag/region','line_number':551,'multiline':False]
['text':' combinations.','line_number':552,'multiline':False]
['text':' no children, word must end here','line_number':559,'multiline':False]
['text':' Stop looking at end of the line.','line_number':562,'multiline':False]
['text':' Perform a binary search in the list of accepted bytes.','line_number':566,'multiline':False]
['text':' <Tab> is handled like <Space>','line_number':568,'multiline':False]
['text':' Stop if there is no matching byte.','line_number':586,'multiline':False]
['text':' Continue at the child (if there is one).','line_number':590,'multiline':False]
['text':' One space in the good word may stand for several spaces in the','line_number':595,'multiline':False]
['text':' checked word.','line_number':596,'multiline':False]
['text':'
     * Verify that one of the possible endings is valid.  Try the longest
     * first.
     ','line_number':611,'multiline':True]
['text':' not at first byte of character','line_number':622,'multiline':False]
['text':' next char is a word character','line_number':626,'multiline':False]
['text':' The prefix flag is before compound flags.  Once a valid prefix flag','line_number':631,'multiline':False]
['text':' has been found we try compound flags.','line_number':632,'multiline':False]
['text':' Compute byte length in original word, length may change','line_number':637,'multiline':False]
['text':' when folding case.  This can be slow, take a shortcut when the','line_number':638,'multiline':False]
['text':' case-folded word is equal to the keep-case word.','line_number':639,'multiline':False]
['text':' Check flags and region.  For FIND_PREFIX check the condition and','line_number':649,'multiline':False]
['text':' prefix ID.','line_number':650,'multiline':False]
['text':' Repeat this if there are more flags/region alternatives until there','line_number':651,'multiline':False]
['text':' is a match.','line_number':652,'multiline':False]
['text':' For the fold-case tree check that the case of the checked word','line_number':659,'multiline':False]
['text':' matches with what the word in the tree requires.','line_number':660,'multiline':False]
['text':' For keep-case tree the case is always right.  For prefixes we','line_number':661,'multiline':False]
['text':' don't bother to check.','line_number':662,'multiline':False]
['text':' mi_capflags was set for a different word length, need','line_number':667,'multiline':False]
['text':' to do it again.','line_number':668,'multiline':False]
['text':' When mode is FIND_PREFIX the word must support the prefix:','line_number':678,'multiline':False]
['text':' check the prefix ID and the condition.  Do that for the list at','line_number':679,'multiline':False]
['text':' mip->mi_prefarridx that find_prefix() filled.','line_number':680,'multiline':False]
['text':' Use the WF_RARE flag for a rare prefix.','line_number':690,'multiline':False]
['text':' NOBREAK: found a valid following word.  That's all we','line_number':701,'multiline':False]
['text':' need to know, so return.','line_number':702,'multiline':False]
['text':' If there is no compound flag or the word is shorter than','line_number':711,'multiline':False]
['text':' COMPOUNDMIN reject it quickly.','line_number':712,'multiline':False]
['text':' Makes you wonder why someone puts a compound flag on a word','line_number':713,'multiline':False]
['text':' that's too short...  Myspell compatibility requires this','line_number':714,'multiline':False]
['text':' anyway.','line_number':715,'multiline':False]
['text':' For multi-byte chars check character length against','line_number':719,'multiline':False]
['text':' COMPOUNDMIN.','line_number':720,'multiline':False]
['text':' Limit the number of compound words to COMPOUNDWORDMAX if no','line_number':727,'multiline':False]
['text':' maximum for syllables is specified.','line_number':728,'multiline':False]
['text':' Don't allow compounding on a side where an affix was added,','line_number':734,'multiline':False]
['text':' unless COMPOUNDPERMITFLAG was used.','line_number':735,'multiline':False]
['text':' Quickly check if compounding is possible with this flag.','line_number':741,'multiline':False]
['text':' If there is a match with a CHECKCOMPOUNDPATTERN rule','line_number':748,'multiline':False]
['text':' discard the compound word.','line_number':749,'multiline':False]
['text':' Need to check the caps type of the appended compound','line_number':757,'multiline':False]
['text':' word.','line_number':758,'multiline':False]
['text':' case folding may have changed the length','line_number':762,'multiline':False]
['text':' When the character before the word is a word','line_number':776,'multiline':False]
['text':' character we do not accept a Onecap word.  We do','line_number':777,'multiline':False]
['text':' accept a no-caps word, even when the dictionary','line_number':778,'multiline':False]
['text':' word specifies ONECAP.','line_number':779,'multiline':False]
['text':' If the word ends the sequence of compound flags of the','line_number':789,'multiline':False]
['text':' words must match with one of the COMPOUNDRULE items and','line_number':790,'multiline':False]
['text':' the number of syllables must not be too large.','line_number':791,'multiline':False]
['text':' "fword" is only needed for checking syllables.','line_number':800,'multiline':False]
['text':' The compound flags collected so far do not match any','line_number':812,'multiline':False]
['text':' COMPOUNDRULE, discard the compounded word.','line_number':813,'multiline':False]
['text':' Check NEEDCOMPOUND: can't use word without compounding.','line_number':817,'multiline':False]
['text':' Check that a valid word follows.  If there is one and we','line_number':830,'multiline':False]
['text':' are compounding, it will set "mi_result", thus we are','line_number':831,'multiline':False]
['text':' always finished here.  For NOBREAK we only check that a','line_number':832,'multiline':False]
['text':' valid word follows.','line_number':833,'multiline':False]
['text':' Recursive!','line_number':834,'multiline':False]
['text':' Find following word in case-folded tree.','line_number':838,'multiline':False]
['text':' Compute byte length in case-folded word from "wlen":','line_number':842,'multiline':False]
['text':' byte length in keep-case word.  Length may change when','line_number':843,'multiline':False]
['text':' folding case.  This can be slow, take a shortcut when','line_number':844,'multiline':False]
['text':' the case-folded word is equal to the keep-case word.','line_number':845,'multiline':False]
['text':' Disabled, see below','line_number':854,'multiline':False]
['text':' For NOBREAK we need to try all NOBREAK languages, at least','line_number':861,'multiline':False]
['text':' to find the ".add" file(s).','line_number':862,'multiline':False]
['text':' When NOBREAK any word that matches is OK.  Otherwise we','line_number':875,'multiline':False]
['text':' need to find the longest match, thus try with keep-case','line_number':876,'multiline':False]
['text':' and prefix too.','line_number':877,'multiline':False]
['text':' Find following word in keep-case tree.','line_number':880,'multiline':False]
['text':' Disabled, a prefix must not appear halfway a compound word,','line_number':884,'multiline':False]
['text':' unless the COMPOUNDPERMITFLAG is used and then it can't be a','line_number':885,'multiline':False]
['text':' postponed prefix.','line_number':886,'multiline':False]
['text':' Check for following word with prefix.','line_number':889,'multiline':False]
['text':' Check region.','line_number':922,'multiline':False]
['text':' Always use the longest match and the best result.  For NOBREAK','line_number':933,'multiline':False]
['text':' we separately keep the longest match without a following good','line_number':934,'multiline':False]
['text':' word as a fall-back.','line_number':935,'multiline':False]
['text':'
 * Return TRUE if there is a match between the word ptr[wlen] and
 * CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another
 * word.
 * A match means that the first part of CHECKCOMPOUNDPATTERN matches at the
 * end of ptr[wlen] and the second part matches after it.
 ','line_number':964,'multiline':True]
['text':' &sl_comppat','line_number':975,'multiline':False]
['text':' Second part matches at start of following compound word, now','line_number':986,'multiline':False]
['text':' check if first part matches at end of previous word.','line_number':987,'multiline':False]
['text':'
 * Return TRUE if "flags" is a valid sequence of compound flags and "word"
 * does not have too many syllables.
 ','line_number':997,'multiline':True]
['text':' Need to convert the single byte flags to utf8 characters.','line_number':1012,'multiline':False]
['text':' Count the number of syllables.  This may be slow, do it last.  If there','line_number':1024,'multiline':False]
['text':' are too many syllables AND the number of compound words is above','line_number':1025,'multiline':False]
['text':' COMPOUNDWORDMAX then compounding is not allowed.','line_number':1026,'multiline':False]
['text':'
 * Return TRUE if the compound flags in compflags[] match the start of any
 * compound rule.  This is used to stop trying a compound if the flags
 * collected so far can't possibly match any compound rule.
 * Caller must check that slang->sl_comprules is not NULL.
 ','line_number':1033,'multiline':True]
['text':' loop over all the COMPOUNDRULE entries','line_number':1046,'multiline':False]
['text':' loop over the flags in the compound word we have made, match','line_number':1049,'multiline':False]
['text':' them against the current rule entry','line_number':1050,'multiline':False]
['text':' found a rule that matches for the flags we have so far','line_number':1055,'multiline':False]
['text':' end of rule, it's too short','line_number':1058,'multiline':False]
['text':' compare against all the flags in []','line_number':1063,'multiline':False]
['text':' none matches','line_number':1069,'multiline':False]
['text':' flag of word doesn't match flag in pattern','line_number':1072,'multiline':False]
['text':' Skip to the next "/", where the next pattern starts.','line_number':1076,'multiline':False]
['text':' Checked all the rules and none of them match the flags, so there','line_number':1082,'multiline':False]
['text':' can't possibly be a compound starting with these flags.','line_number':1083,'multiline':False]
['text':'
 * Return non-zero if the prefix indicated by "arridx" matches with the prefix
 * ID in "flags" for the word "word".
 * The WF_RAREPFX flag is included in the return value for a rare prefix.
 ','line_number':1087,'multiline':True]
['text':' nr of prefix IDs','line_number':1094,'multiline':False]
['text':' idx in sl_pidxs[]','line_number':1095,'multiline':False]
['text':' only use prefixes with a condition','line_number':1099,'multiline':False]
['text':' Check the prefix ID.','line_number':1111,'multiline':False]
['text':' Check if the prefix doesn't combine and the word already has a','line_number':1115,'multiline':False]
['text':' suffix.','line_number':1116,'multiline':False]
['text':' Check the condition, if there is one.  The condition index is','line_number':1120,'multiline':False]
['text':' stored in the two bytes above the prefix ID byte.','line_number':1121,'multiline':False]
['text':' It's a match!  Return the WF_ flags.','line_number':1131,'multiline':False]
['text':'
 * Check if the word at "mip->mi_word" has a matching prefix.
 * If it does, then check the following word.
 *
 * If "mode" is "FIND_COMPOUND" then do the same after another word, find a
 * prefix in a compound word.
 *
 * For a match mip->mi_result is updated.
 ','line_number':1137,'multiline':True]
['text':' array is empty','line_number':1162,'multiline':False]
['text':' We use the case-folded word here, since prefixes are always','line_number':1164,'multiline':False]
['text':' case-folded.','line_number':1165,'multiline':False]
['text':' available case-folded bytes','line_number':1167,'multiline':False]
['text':' Skip over the previously found word(s).','line_number':1170,'multiline':False]
['text':'
     * Repeat advancing in the tree until:
     * - there is a byte that doesn't match,
     * - we reach the end of the tree,
     * - or we reach the end of the line.
     ','line_number':1176,'multiline':True]
['text':' If the first possible byte is a zero the prefix could end here.','line_number':1189,'multiline':False]
['text':' Check if the following word matches and supports the prefix.','line_number':1190,'multiline':False]
['text':' There can be several prefixes with different conditions.  We','line_number':1193,'multiline':False]
['text':' try them all, since we don't know which one will give the','line_number':1194,'multiline':False]
['text':' longest match.  The word is the same each time, pass the list','line_number':1195,'multiline':False]
['text':' of possible prefixes to find_word().','line_number':1196,'multiline':False]
['text':' Find the word that comes after the prefix.','line_number':1206,'multiline':False]
['text':' Skip over the previously found word(s).','line_number':1209,'multiline':False]
['text':' Case-folded length may differ from original length.','line_number':1214,'multiline':False]
['text':' no children, word must end here','line_number':1224,'multiline':False]
['text':' Stop looking at end of the line.','line_number':1227,'multiline':False]
['text':' Perform a binary search in the list of accepted bytes.','line_number':1231,'multiline':False]
['text':' Stop if there is no matching byte.','line_number':1249,'multiline':False]
['text':' Continue at the child (if there is one).','line_number':1253,'multiline':False]
['text':'
 * Need to fold at least one more character.  Do until next non-word character
 * for efficiency.  Include the non-word character too.
 * Return the length of the folded chars in bytes.
 ','line_number':1260,'multiline':True]
['text':' Include the non-word character so that we can check for the word end.','line_number':1276,'multiline':False]
['text':'
 * Check case flags for a word.  Return TRUE if the word has the requested
 * case.
 ','line_number':1288,'multiline':True]
['text':' flags for the checked word.','line_number':1294,'multiline':False]
['text':' flags for the word in the spell tree','line_number':1295,'multiline':False]
['text':'
 * Return TRUE if spell checking is enabled for "wp".
 ','line_number':1303,'multiline':True]
['text':'
 * Return TRUE and give an error if spell checking is not enabled.
 ','line_number':1315,'multiline':True]
['text':'
 * Move to next spell error.
 * "curline" is FALSE for "[s", "]s", "[S" and "]S".
 * "curline" is TRUE to find word under/after cursor in the same line.
 * For Insert mode completion "dir" is BACKWARD and "curline" is TRUE: move
 * to after badly spelled word before the cursor.
 * Return 0 if not found, length of the badly spelled word otherwise.
 ','line_number':1327,'multiline':True]
['text':' FORWARD or BACKWARD','line_number':1338,'multiline':False]
['text':' TRUE for "[s"/"]s", FALSE for "[S"/"]S"','line_number':1339,'multiline':False]
['text':' return: attributes of bad word or NULL','line_number':1341,'multiline':False]
['text':' (only when "dir" is FORWARD)','line_number':1342,'multiline':False]
['text':'
     * Start looking for bad word at the start of the line, because we can't
     * start halfway a word, we don't know where it starts or ends.
     *
     * When searching backwards, we continue in the line to find the last
     * bad word (in the cursor line: before the cursor).
     *
     * We concatenate the start of the next line, so that wrapped words work
     * (e.g. "et<line-break>cetera").  Doesn't work when searching backwards
     * though...
     ','line_number':1367,'multiline':True]
['text':' In first line check first word for Capital.','line_number':1397,'multiline':False]
['text':' For checking first word with a capital skip white space.','line_number':1401,'multiline':False]
['text':' For spellbadword(): check if first word needs a capital.','line_number':1406,'multiline':False]
['text':' Need to get the line again, may have looked at the previous','line_number':1411,'multiline':False]
['text':' one.','line_number':1412,'multiline':False]
['text':' Copy the line into "buf" and append the start of the next line if','line_number':1416,'multiline':False]
['text':' possible.  Note: this ml_get_buf() may make "line" invalid, check','line_number':1417,'multiline':False]
['text':' for empty line first.','line_number':1418,'multiline':False]
['text':' When searching backward don't search after the cursor.  Unless','line_number':1429,'multiline':False]
['text':' we wrapped around the end of the buffer.','line_number':1430,'multiline':False]
['text':' start of word','line_number':1437,'multiline':False]
['text':' We found a bad word.  Check the attribute.','line_number':1443,'multiline':False]
['text':' When searching forward only accept a bad word after','line_number':1446,'multiline':False]
['text':' the cursor.','line_number':1447,'multiline':False]
['text':' No need to search further.','line_number':1476,'multiline':False]
['text':' Insert mode completion: put cursor after','line_number':1484,'multiline':False]
['text':' the bad word.','line_number':1485,'multiline':False]
['text':' advance to character after the word','line_number':1495,'multiline':False]
['text':' Use the last match in the line (before the cursor).','line_number':1502,'multiline':False]
['text':' only check cursor line','line_number':1509,'multiline':False]
['text':' If we are back at the starting line and searched it again there','line_number':1511,'multiline':False]
['text':' is no match, give up.','line_number':1512,'multiline':False]
['text':' Advance to next line.','line_number':1516,'multiline':False]
['text':' at first line and 'nowrapscan'','line_number':1522,'multiline':False]
['text':' Wrap around to the end of the buffer.  May search the','line_number':1525,'multiline':False]
['text':' starting line again and accept the last match.','line_number':1526,'multiline':False]
['text':' at first line and 'nowrapscan'','line_number':1539,'multiline':False]
['text':' Wrap around to the start of the buffer.  May search the','line_number':1542,'multiline':False]
['text':' starting line again and accept the first match.','line_number':1543,'multiline':False]
['text':' If we are back at the starting line and there is no match then','line_number':1550,'multiline':False]
['text':' give up.','line_number':1551,'multiline':False]
['text':' Skip the characters at the start of the next line that were','line_number':1555,'multiline':False]
['text':' included in a match crossing line boundaries.','line_number':1556,'multiline':False]
['text':' Capcol skips over the inserted space.','line_number':1562,'multiline':False]
['text':' But after empty line check first word in next line','line_number':1565,'multiline':False]
['text':'
 * For spell checking: concatenate the start of the following line "line" into
 * "buf", blanking-out special characters.  Copy less than "maxlen" bytes.
 * Keep the blanks at the start of the next line, this is used in win_line()
 * to skip those bytes if the word was OK.
 ','line_number':1577,'multiline':True]
['text':' Only worth concatenating if there is something else than spaces to','line_number':1596,'multiline':False]
['text':' concatenate.','line_number':1597,'multiline':False]
['text':'
 * Structure used for the cookie argument of do_in_runtimepath().
 ','line_number':1606,'multiline':True]
['text':' language name','line_number':1611,'multiline':False]
['text':' resulting slang_T struct','line_number':1612,'multiline':False]
['text':' NOBREAK language found','line_number':1613,'multiline':False]
['text':'
 * Load word list(s) for "lang" from Vim spell file(s).
 * "lang" must be the language without the region: e.g., "en".
 ','line_number':1616,'multiline':True]
['text':' Copy the language name to pass it to spell_load_cb() as a cookie.','line_number':1628,'multiline':False]
['text':' It's truncated when an error is detected.','line_number':1629,'multiline':False]
['text':' Disallow deleting the current buffer.  Autocommands can do weird things','line_number':1634,'multiline':False]
['text':' and cause "lang" to be freed.','line_number':1635,'multiline':False]
['text':' We may retry when no spell file is found for the language, an','line_number':1638,'multiline':False]
['text':' autocommand may load it then.','line_number':1639,'multiline':False]
['text':'
	 * Find the first spell file for "lang" in 'runtimepath' and load it.
	 ','line_number':1642,'multiline':True]
['text':' Try loading the ASCII version.','line_number':1656,'multiline':False]
['text':' At least one file was loaded, now load ALL the additions.','line_number':1687,'multiline':False]
['text':'
 * Return the encoding used for spell checking: Use 'encoding', except that we
 * use "latin1" for "latin9".  And limit to 60 characters (just in case).
 ','line_number':1695,'multiline':True]
['text':'
 * Get the name of the .spl file for the internal wordlist into
 * "fname[MAXPATHL]".
 ','line_number':1708,'multiline':True]
['text':'
 * Allocate a new slang_T for language "lang".  "lang" can be NULL.
 * Caller must fill "sl_next".
 ','line_number':1719,'multiline':True]
['text':'
 * Free the contents of an slang_T and the structure itself.
 ','line_number':1743,'multiline':True]
['text':'
 * Clear an slang_T so that the file can be reloaded.
 ','line_number':1755,'multiline':True]
['text':' "ga_len" is set to 1 without adding an item for latin1','line_number':1790,'multiline':False]
['text':' SOFOFROM and SOFOTO items: free lists of wide characters.','line_number':1792,'multiline':False]
['text':' SAL items: free salitem_T items','line_number':1797,'multiline':False]
['text':' Don't free sm_oneof and sm_rules, they point into sm_lead.','line_number':1802,'multiline':False]
['text':' Clear info from .sug file.','line_number':1835,'multiline':False]
['text':'
 * Clear the info from the .sug file in "lp".
 ','line_number':1844,'multiline':True]
['text':'
 * Load one spell file and store the info into a slang_T.
 * Invoked through do_in_runtimepath().
 ','line_number':1858,'multiline':True]
['text':' When a previously loaded file has NOBREAK also use it for the','line_number':1872,'multiline':False]
['text':' ".add" files.','line_number':1873,'multiline':False]
['text':'
 * Add a word to the hashtable of common words.
 * If it's already there then the counter is increased.
 ','line_number':1883,'multiline':True]
['text':' word length, -1 for up to NUL','line_number':1891,'multiline':False]
['text':' 1 to count once, 10 to init','line_number':1892,'multiline':False]
['text':' check for overflow','line_number':1924,'multiline':False]
['text':'
 * Return TRUE if byte "n" appears in "str".
 * Like strchr() but independent of locale.
 ','line_number':1929,'multiline':True]
['text':' the sequence of chars','line_number':1947,'multiline':False]
['text':'
 * Truncate "slang->sl_syllable" at the first slash and put the following items
 * in "slang->sl_syl_items".
 ','line_number':1951,'multiline':True]
['text':' trailing slash','line_number':1968,'multiline':False]
['text':'
 * Count the number of syllables in "word".
 * When "word" contains spaces the syllables after the last space are counted.
 * Returns zero if syllables are not defines.
 ','line_number':1988,'multiline':True]
['text':' When running into a space reset counter.','line_number':2009,'multiline':False]
['text':' Find longest match of syllable items.','line_number':2017,'multiline':False]
['text':' found a match, count syllable','line_number':2026,'multiline':False]
['text':' No recognized syllable item, at least a syllable char then?','line_number':2033,'multiline':False]
['text':' No, search for next syllable','line_number':2037,'multiline':False]
['text':' Yes, count it','line_number':2040,'multiline':False]
['text':' don't count following syllable chars','line_number':2041,'multiline':False]
['text':'
 * Parse 'spelllang' and set w_s->b_langp accordingly.
 * Returns NULL if it's OK, an untranslated error message otherwise.
 ','line_number':2048,'multiline':True]
['text':' We don't want to do this recursively.  May happen when a language is','line_number':2081,'multiline':False]
['text':' not available and the SpellFileMissing autocommand opens a new buffer','line_number':2082,'multiline':False]
['text':' in which 'spell' is set.','line_number':2083,'multiline':False]
['text':' Make a copy of 'spelllang', the SpellFileMissing autocommands may change','line_number':2091,'multiline':False]
['text':' it under our fingers.','line_number':2092,'multiline':False]
['text':' Loop over comma separated language names.','line_number':2099,'multiline':False]
['text':' Get one language name.','line_number':2102,'multiline':False]
['text':' If the name ends in ".spl" use it as the name of the spell file.','line_number':2116,'multiline':False]
['text':' If there is a region name let "region" point to it and remove it','line_number':2117,'multiline':False]
['text':' from the name.','line_number':2118,'multiline':False]
['text':' Locate a region and remove it from the file name.','line_number':2123,'multiline':False]
['text':' Check if we loaded this language before.','line_number':2135,'multiline':False]
['text':' Check if we loaded this language before.','line_number':2152,'multiline':False]
['text':' If the region differs from what was used before then don't','line_number':2160,'multiline':False]
['text':' use it for 'spellfile'.','line_number':2161,'multiline':False]
['text':' If not found try loading the language now.','line_number':2167,'multiline':False]
['text':' SpellFileMissing autocommands may do anything, including','line_number':2175,'multiline':False]
['text':' destroying the buffer we are using or closing the window.','line_number':2176,'multiline':False]
['text':'
	 * Loop over the languages, there can be several files for "lang".
	 ','line_number':2185,'multiline':True]
['text':' find region in sl_regions','line_number':2196,'multiline':False]
['text':' This addition file is for other regions.','line_number':2203,'multiline':False]
['text':' This is probably an error.  Give a warning and','line_number':2207,'multiline':False]
['text':' accept the words anyway.','line_number':2208,'multiline':False]
['text':' round 0: load int_wordlist, if possible.','line_number':2234,'multiline':False]
['text':' round 1: load first name in 'spellfile'.','line_number':2235,'multiline':False]
['text':' round 2: load second name in 'spellfile.','line_number':2236,'multiline':False]
['text':' etc.','line_number':2237,'multiline':False]
['text':' Internal wordlist, if there is one.','line_number':2243,'multiline':False]
['text':' One entry in 'spellfile'.','line_number':2250,'multiline':False]
['text':' If it was already found above then skip it.','line_number':2254,'multiline':False]
['text':' Check if it was loaded already.','line_number':2266,'multiline':False]
['text':' Not loaded, try loading it now.  The language name includes the','line_number':2273,'multiline':False]
['text':' region name, the region is ignored otherwise.  for int_wordlist','line_number':2274,'multiline':False]
['text':' use an arbitrary name.','line_number':2275,'multiline':False]
['text':' truncate at ".encoding.add"','line_number':2283,'multiline':False]
['text':' If one of the languages has NOBREAK we assume the addition','line_number':2287,'multiline':False]
['text':' files also have this.','line_number':2288,'multiline':False]
['text':' find region in sl_regions','line_number':2297,'multiline':False]
['text':' This spell file is for other regions.','line_number':2302,'multiline':False]
['text':' Everything is fine, store the new b_langp value.','line_number':2318,'multiline':False]
['text':' For each language figure out what language to use for sound folding and','line_number':2322,'multiline':False]
['text':' REP items.  If the language doesn't support it itself use another one','line_number':2323,'multiline':False]
['text':' with the same name.  E.g. for "en-math" use "en".','line_number':2324,'multiline':False]
['text':' sound folding','line_number':2329,'multiline':False]
['text':' language does sound folding itself','line_number':2331,'multiline':False]
['text':' find first similar language that does sound folding','line_number':2334,'multiline':False]
['text':' REP items','line_number':2347,'multiline':False]
['text':' language has REP items itself','line_number':2349,'multiline':False]
['text':' find first similar language that has REP items','line_number':2352,'multiline':False]
['text':'
 * Clear the midword characters for buffer "buf".
 ','line_number':2373,'multiline':True]
['text':'
 * Use the "sl_midword" field of language "lp" for buffer "buf".
 * They add up to any currently used midword characters.
 ','line_number':2383,'multiline':True]
['text':' there aren't any','line_number':2392,'multiline':False]
['text':' First multi-byte char in "b_spell_ismw_mb".','line_number':2406,'multiline':False]
['text':' Append multi-byte chars to "b_spell_ismw_mb".','line_number':2410,'multiline':False]
['text':'
 * Find the region "region[2]" in "rp" (points to "sl_regions").
 * Each region is simply stored as the two characters of its name.
 * Returns the index if found (first is 0), REGION_ALL if not found.
 ','line_number':2426,'multiline':True]
['text':'
 * Return case type of word:
 * w word	0
 * Word		WF_ONECAP
 * W WORD	WF_ALLCAP
 * WoRd	wOrd	WF_KEEPCAP
 ','line_number':2446,'multiline':True]
['text':' When NULL use up to NUL byte.','line_number':2456,'multiline':False]
['text':' past second word char','line_number':2462,'multiline':False]
['text':' find first letter','line_number':2464,'multiline':False]
['text':' only non-word characters, illegal word','line_number':2467,'multiline':False]
['text':'
     * Need to check all letters to find a word with mixed upper/lower.
     * But a word with an upper char only at start is a ONECAP.
     ','line_number':2474,'multiline':True]
['text':' UUl -> KEEPCAP','line_number':2484,'multiline':False]
['text':' UlU -> KEEPCAP','line_number':2490,'multiline':False]
['text':'
 * Delete the internal wordlist and its .spl file.
 ','line_number':2502,'multiline':True]
['text':'
 * Free all languages.
 ','line_number':2519,'multiline':True]
['text':' Go through all buffers and handle 'spelllang'. <VN>','line_number':2528,'multiline':False]
['text':'
 * Clear all spelling tables and reload them.
 * Used after 'encoding' is set and when ":mkspell" was used.
 ','line_number':2545,'multiline':True]
['text':' Initialize the table for spell_iswordp().','line_number':2554,'multiline':False]
['text':' Unload all allocated memory.','line_number':2557,'multiline':False]
['text':' Go through all buffers and handle 'spelllang'.','line_number':2560,'multiline':False]
['text':' Only load the wordlists when 'spelllang' is set and there is a','line_number':2563,'multiline':False]
['text':' window for this buffer in which 'spell' is set.','line_number':2564,'multiline':False]
['text':'
 * Open a spell buffer.  This is a nameless buffer that is not in the buffer
 * list and only contains text lines.  Can use a swapfile to reduce memory
 * use.
 * Most other fields are invalid!  Esp. watch out for string options being
 * NULL and there is no undo info.
 * Returns NULL when out of memory.
 ','line_number':2576,'multiline':True]
['text':' may create a swap file','line_number':2594,'multiline':False]
['text':' create swap file now','line_number':2599,'multiline':False]
['text':'
 * Close the buffer used for spell info.
 ','line_number':2603,'multiline':True]
['text':'
 * Init the chartab used for spelling for ASCII.
 ','line_number':2616,'multiline':True]
['text':' Init everything to FALSE (zero).','line_number':2624,'multiline':False]
['text':' We include digits.  A word shouldn't start with a digit, but handling','line_number':2633,'multiline':False]
['text':' that is done separately.','line_number':2634,'multiline':False]
['text':'
 * Init the chartab used for spelling.  Only depends on 'encoding'.
 * Called once while starting up and when 'encoding' changes.
 * The default is to use isalpha(), but the spell file should define the word
 * characters to make it possible that 'encoding' differs from the current
 * locale.  For utf-8 we don't use isalpha() but our own functions.
 ','line_number':2650,'multiline':True]
['text':' DBCS: assume double-wide characters are word characters.','line_number':2666,'multiline':False]
['text':' The folded/upper-cased value is different between latin1 and','line_number':2680,'multiline':False]
['text':' utf8 for 0xb5, causing E763 for no good reason.  Use the latin1','line_number':2681,'multiline':False]
['text':' value for utf-8 to avoid this.','line_number':2682,'multiline':False]
['text':' Rough guess: use locale-dependent library functions.','line_number':2689,'multiline':False]
['text':'
 * Return TRUE if "p" points to a word character.
 * As a special case we see "midword" characters as word character when it is
 * followed by a word character.  This finds they'there but not 'they there'.
 * Thus this only works properly when past the first character of the word.
 ','line_number':2708,'multiline':True]
['text':' buffer used','line_number':2717,'multiline':False]
['text':' be quick for ASCII','line_number':2729,'multiline':False]
['text':' skip a mid-word character','line_number':2731,'multiline':False]
['text':'
 * Return TRUE if "p" points to a word character.
 * Unlike spell_iswordp() this doesn't check for "midword" characters.
 ','line_number':2751,'multiline':True]
['text':'
 * Return TRUE if word class indicates a word character.
 * Only for characters above 255.
 * Unicode subscript and superscript are not considered word characters.
 * See also dbcs_class() and utf_class() in mbyte.c.
 ','line_number':2770,'multiline':True]
['text':' East Asian characters are not considered word characters.','line_number':2780,'multiline':False]
['text':'
 * Return TRUE if "p" points to a word character.
 * Wide version of spell_iswordp().
 ','line_number':2785,'multiline':True]
['text':'
 * Case-fold "str[len]" into "buf[buflen]".  The result is NUL terminated.
 * Uses the character definitions from the .spl file.
 * When using a multi-byte 'encoding' the length may change!
 * Returns FAIL when something wrong.
 ','line_number':2813,'multiline':True]
['text':' result will not fit','line_number':2832,'multiline':False]
['text':' Fold one character at a time.','line_number':2841,'multiline':False]
['text':' Exception: greek capital sigma 0x03A3 folds to 0x03C3, except','line_number':2851,'multiline':False]
['text':' when it is the last character in a word, then it folds to','line_number':2852,'multiline':False]
['text':' 0x03C2.','line_number':2853,'multiline':False]
['text':' Be quick for non-multibyte encodings.','line_number':2870,'multiline':False]
['text':'
 * Check if the word at line "lnum" column "col" is required to start with a
 * capital.  This uses 'spellcapcheck' of the buffer in window "wp".
 ','line_number':2879,'multiline':True]
['text':' At start of line, check if previous line is empty or sentence','line_number':2896,'multiline':False]
['text':' ends there.','line_number':2897,'multiline':False]
['text':' Append a space in place of the line break.','line_number':2907,'multiline':False]
['text':' Check if sentence ends before the bad word.','line_number':2922,'multiline':False]
['text':'
 * ":spellrepall"
 ','line_number':2948,'multiline':True]
['text':' Only replace when the right word isn't there yet.  This happens','line_number':2985,'multiline':False]
['text':' when changing "etc" to "etc.".','line_number':2986,'multiline':False]
['text':'
 * Make a copy of "word", with the first letter upper or lower cased, to
 * "wcopy[MAXWLEN]".  "word" must not be empty.
 * The result is NUL terminated.
 ','line_number':3025,'multiline':True]
['text':' TRUE: first letter made upper case','line_number':3034,'multiline':False]
['text':'
 * Make a copy of "word" with all the letters upper cased into
 * "wcopy[MAXWLEN]".  The result is NUL terminated.
 ','line_number':3059,'multiline':True]
['text':' We only change 0xdf to SS when we are certain latin1 is used.  It','line_number':3078,'multiline':False]
['text':' would cause weird errors in other 8-bit encodings.','line_number':3079,'multiline':False]
['text':'
 * Case-folding may change the number of bytes: Count nr of chars in
 * fword[flen] and return the byte length of that many chars in "word".
 ','line_number':3106,'multiline':True]
['text':'
 * Copy "fword" to "cword", fixing case according to "flags".
 ','line_number':3123,'multiline':True]
['text':' Make it all upper-case','line_number':3130,'multiline':False]
['text':' Make the first letter upper-case','line_number':3133,'multiline':False]
['text':' Use goodword as-is.','line_number':3136,'multiline':False]
['text':'
 * Soundfold a string, for soundfold().
 * Result is in allocated memory, NULL for an error.
 ','line_number':3141,'multiline':True]
['text':' Use the sound-folding of the first language that supports it.','line_number':3153,'multiline':False]
['text':' soundfold the word','line_number':3159,'multiline':False]
['text':' No language with sound folding, return word as-is.','line_number':3165,'multiline':False]
['text':'
 * Turn "inword" into its sound-a-like equivalent in "res[MAXWLEN]".
 *
 * There are many ways to turn a word into a sound-a-like representation.  The
 * oldest is Soundex (1918!).   A nice overview can be found in "Approximate
 * swedish name matching - survey and test of different algorithms" by Klas
 * Erikson.
 *
 * We support two methods:
 * 1. SOFOFROM/SOFOTO do a simple character mapping.
 * 2. SAL items define a more advanced sound-folding (and much slower).
 ','line_number':3170,'multiline':True]
['text':' "inword" is already case-folded','line_number':3186,'multiline':False]
['text':' SOFOFROM and SOFOTO used','line_number':3193,'multiline':False]
['text':' SAL items used.  Requires the word to be case-folded.','line_number':3197,'multiline':False]
['text':'
 * Perform sound folding of "inword" into "res" according to SOFOFROM and
 * SOFOTO lines.
 ','line_number':3214,'multiline':True]
['text':' The sl_sal_first[] table contains the translation for chars up to','line_number':3230,'multiline':False]
['text':' 255, sl_sal the rest.','line_number':3231,'multiline':False]
['text':' empty list, can't match','line_number':3242,'multiline':False]
['text':' find "c" in the list','line_number':3245,'multiline':False]
['text':' not found','line_number':3247,'multiline':False]
['text':' match!','line_number':3252,'multiline':False]
['text':' The sl_sal_first[] table contains the translation.','line_number':3272,'multiline':False]
['text':' Remove accents, if wanted.  We actually remove all non-word characters.','line_number':3306,'multiline':False]
['text':' But keep white space.  We need a copy, the word may be changed here.','line_number':3307,'multiline':False]
['text':'
     * This comes from Aspell phonet.cpp.  Converted from C++ to C.
     * Changed to keep spaces.
     ','line_number':3332,'multiline':True]
['text':' Start with the first rule that has the character in the word.','line_number':3339,'multiline':False]
['text':' check all rules for the same letter','line_number':3345,'multiline':False]
['text':' Quickly skip entries that don't match the word.  Most','line_number':3348,'multiline':False]
['text':' entries are less than three chars, optimize for that.','line_number':3349,'multiline':False]
['text':' Check for match with one of the chars in "sm_oneof".','line_number':3367,'multiline':False]
['text':' default priority','line_number':3375,'multiline':False]
['text':' determine priority','line_number':3388,'multiline':False]
['text':' search for followup rules, if:','line_number':3405,'multiline':False]
['text':' followup and k > 1  and  NO '-' in searchstring','line_number':3406,'multiline':False]
['text':' test follow-up rule for "word[i + k]"','line_number':3413,'multiline':False]
['text':' Quickly skip entries that don't match the word.','line_number':3416,'multiline':False]
['text':'','line_number':3417,'multiline':False]
['text':' Check for match with one of the chars in','line_number':3437,'multiline':False]
['text':' "sm_oneof".','line_number':3438,'multiline':False]
['text':' "k0" gets NOT reduced because','line_number':3450,'multiline':False]
['text':' "if (k0 == k)"','line_number':3451,'multiline':False]
['text':' *s == '^' cuts','line_number':3463,'multiline':False]
['text':' this is just a piece of the string','line_number':3469,'multiline':False]
['text':' priority too low','line_number':3473,'multiline':False]
['text':' rule fits; stop search','line_number':3475,'multiline':False]
['text':' replace string','line_number':3484,'multiline':False]
['text':' rule with '<' is used','line_number':3492,'multiline':False]
['text':' new "actual letter"','line_number':3508,'multiline':False]
['text':' no '<' rule used','line_number':3513,'multiline':False]
['text':' new "actual letter"','line_number':3522,'multiline':False]
['text':' condense only double letters','line_number':3548,'multiline':False]
['text':'
 * Turn "inword" into its sound-a-like equivalent in "res[MAXWLEN]".
 * Multi-byte version of spell_soundfold().
 ','line_number':3560,'multiline':True]
['text':'
     * Convert the multi-byte string to a wide-character string.
     * Remove accents, if wanted.  We actually remove all non-word characters.
     * But keep white space.
     ','line_number':3589,'multiline':True]
['text':'
     * This algorithm comes from Aspell phonet.cpp.
     * Converted from C++ to C.  Added support for multi-byte chars.
     * Changed to keep spaces.
     ','line_number':3619,'multiline':True]
['text':' Start with the first rule that has the character in the word.','line_number':3627,'multiline':False]
['text':' Check all rules for the same index byte.','line_number':3633,'multiline':False]
['text':' If c is 0x300 need extra check for the end of the array, as','line_number':3634,'multiline':False]
['text':' (c & 0xff) is NUL.','line_number':3635,'multiline':False]
['text':' Quickly skip entries that don't match the word.  Most','line_number':3639,'multiline':False]
['text':' entries are less than three chars, optimize for that.','line_number':3640,'multiline':False]
['text':' Check for match with one of the chars in "sm_oneof".','line_number':3660,'multiline':False]
['text':' default priority','line_number':3668,'multiline':False]
['text':' determine priority','line_number':3681,'multiline':False]
['text':' search for followup rules, if:','line_number':3698,'multiline':False]
['text':' followup and k > 1  and  NO '-' in searchstring','line_number':3699,'multiline':False]
['text':' Test follow-up rule for "word[i + k]"; loop over','line_number':3706,'multiline':False]
['text':' all entries with the same index byte.','line_number':3707,'multiline':False]
['text':' Quickly skip entries that don't match the word.','line_number':3711,'multiline':False]
['text':' Check for match with one of the chars in','line_number':3733,'multiline':False]
['text':' "sm_oneof".','line_number':3734,'multiline':False]
['text':' "k0" gets NOT reduced because','line_number':3746,'multiline':False]
['text':' "if (k0 == k)"','line_number':3747,'multiline':False]
['text':' *s == '^' cuts','line_number':3759,'multiline':False]
['text':' this is just a piece of the string','line_number':3765,'multiline':False]
['text':' priority too low','line_number':3769,'multiline':False]
['text':' rule fits; stop search','line_number':3771,'multiline':False]
['text':' replace string','line_number':3781,'multiline':False]
['text':' rule with '<' is used','line_number':3787,'multiline':False]
['text':' new "actual letter"','line_number':3806,'multiline':False]
['text':' no '<' rule used','line_number':3811,'multiline':False]
['text':' new "actual letter"','line_number':3822,'multiline':False]
['text':' condense only double letters','line_number':3852,'multiline':False]
['text':' Convert wide characters in "wres" to a multi-byte string in "res".','line_number':3861,'multiline':False]
['text':'
 * ":spellinfo"
 ','line_number':3872,'multiline':True]
['text':' round 2: keep-case tree','line_number':3902,'multiline':False]
['text':' include word count','line_number':3903,'multiline':False]
['text':' ignore case when finding matches','line_number':3904,'multiline':False]
['text':' pattern starts with capital','line_number':3905,'multiline':False]
['text':' pattern is all capitals','line_number':3906,'multiline':False]
['text':'
 * ":spelldump"
 ','line_number':3908,'multiline':True]
['text':' Create a new empty buffer in a new window.','line_number':3921,'multiline':False]
['text':' enable spelling locally in the new window','line_number':3924,'multiline':False]
['text':' Delete the empty line that we started with.','line_number':3934,'multiline':False]
['text':'
 * Go through all possible words and:
 * 1. When "pat" is NULL: dump a list of all words in the current buffer.
 *	"ic" and "dir" are not used.
 * 2. When "pat" is not NULL: add matching words to insert mode completion.
 ','line_number':3941,'multiline':True]
['text':' leading part of the word','line_number':3949,'multiline':False]
['text':' ignore case','line_number':3950,'multiline':False]
['text':' direction for adding matches','line_number':3951,'multiline':False]
['text':' DUMPFLAG_*','line_number':3952,'multiline':False]
['text':' region names being used','line_number':3967,'multiline':False]
['text':' dump region names and numbers','line_number':3968,'multiline':False]
['text':' When ignoring case or when the pattern starts with capital pass this on','line_number':3974,'multiline':False]
['text':' to dump_word().','line_number':3975,'multiline':False]
['text':' Find out if we can support regions: All languages must support the same','line_number':3990,'multiline':False]
['text':' regions or none at all.','line_number':3991,'multiline':False]
['text':' first language with regions','line_number':3998,'multiline':False]
['text':' region names are different','line_number':4002,'multiline':False]
['text':'
     * Loop over all files loaded for the entries in 'spelllang'.
     ','line_number':4016,'multiline':True]
['text':' reloading failed','line_number':4023,'multiline':False]
['text':' When matching with a pattern and there are no prefixes only use','line_number':4032,'multiline':False]
['text':' parts of the tree that match "pat".','line_number':4033,'multiline':False]
['text':' round 1: case-folded tree','line_number':4039,'multiline':False]
['text':' round 2: keep-case tree','line_number':4040,'multiline':False]
['text':' array is empty','line_number':4056,'multiline':False]
['text':' Done all bytes at this node, go up one level.','line_number':4066,'multiline':False]
['text':' Do one more byte at this node.','line_number':4073,'multiline':False]
['text':' End of word or reached maximum length, deal with the','line_number':4079,'multiline':False]
['text':' word.','line_number':4080,'multiline':False]
['text':' Don't use keep-case words in the fold-case tree,','line_number':4081,'multiline':False]
['text':' they will appear in the keep-case tree.','line_number':4082,'multiline':False]
['text':' Only use the word when the region matches.','line_number':4083,'multiline':False]
['text':' Dump the basic word if there is no prefix or','line_number':4096,'multiline':False]
['text':' when it's the first one.','line_number':4097,'multiline':False]
['text':' Apply the prefix, if there is one.','line_number':4107,'multiline':False]
['text':' Normal char, go one level deeper.','line_number':4115,'multiline':False]
['text':' Check if this character matches with the pattern.','line_number':4120,'multiline':False]
['text':' If not skip the whole tree below it.','line_number':4121,'multiline':False]
['text':' Always ignore case here, dump_word() will check','line_number':4122,'multiline':False]
['text':' proper case later.  This isn't exactly right when','line_number':4123,'multiline':False]
['text':' length changes for multi-byte characters with','line_number':4124,'multiline':False]
['text':' ignore case...','line_number':4125,'multiline':False]
['text':'
 * Dump one word: apply case modifications and append a line to the buffer.
 * When "lnum" is zero add insert mode completion.
 ','line_number':4136,'multiline':True]
['text':' Need to fix case according to "flags".','line_number':4165,'multiline':False]
['text':' Add flags and regions after a slash.','line_number':4181,'multiline':False]
['text':' Include the word count for ":spelldump!".','line_number':4203,'multiline':False]
['text':' if dir was BACKWARD then honor it just once','line_number':4220,'multiline':False]
['text':'
 * For ":spelldump": Find matching prefixes for "word".  Prepend each to
 * "word" and append a line to the buffer.
 * When "lnum" is zero add insert mode completion.
 * Return the updated line number.
 ','line_number':4224,'multiline':True]
['text':' case-folded word','line_number':4233,'multiline':False]
['text':' flags with prefix ID','line_number':4237,'multiline':False]
['text':' If the word starts with a lower-case letter make the word with an','line_number':4254,'multiline':False]
['text':' upper-case letter in word_up[].','line_number':4255,'multiline':False]
['text':' array not is empty','line_number':4265,'multiline':False]
['text':'
	 * Loop over all prefixes, building them byte-by-byte in prefix[].
	 * When at the end of a prefix check that it supports "flags".
	 ','line_number':4267,'multiline':True]
['text':' Done all bytes at this node, go up one level.','line_number':4280,'multiline':False]
['text':' Do one more byte at this node.','line_number':4286,'multiline':False]
['text':' End of prefix, find out how many IDs there are.','line_number':4292,'multiline':False]
['text':' Check for prefix that matches the word when the','line_number':4309,'multiline':False]
['text':' first letter is upper-case, but only if the prefix has','line_number':4310,'multiline':False]
['text':' a condition.','line_number':4311,'multiline':False]
['text':' Normal char, go one level deeper.','line_number':4330,'multiline':False]
['text':'
 * Move "p" to the end of word "start".
 * Uses the spell-checking word characters.
 ','line_number':4342,'multiline':True]
['text':'
 * For Insert mode completion CTRL-X s:
 * Find start of the word in front of column "startcol".
 * We don't check if it is badly spelled, with completion we can only change
 * the word in front of the cursor.
 * Returns the column number of the word.
 ','line_number':4356,'multiline':True]
['text':' Find a word character before "startcol".','line_number':4373,'multiline':False]
['text':' Go back to start of the word.','line_number':4382,'multiline':False]
['text':'
 * Need to check for 'spellcapcheck' now, the word is removed before
 * expand_spelling() is called.  Therefore the ugly global variable.
 ','line_number':4395,'multiline':True]
['text':'
 * Get list of spelling suggestions.
 * Used for Insert mode completion CTRL-X ?.
 * Returns the number of matches.  The matches are in "matchp[]", array of
 * allocated strings.
 ','line_number':4407,'multiline':True]
['text':'
 * Return TRUE if "val" is a valid 'spelllang' value.
 ','line_number':4426,'multiline':True]
['text':'
 * Return TRUE if "val" is a valid 'spellfile' value.
 ','line_number':4435,'multiline':True]
['text':'
 * Handle side effects of setting 'spell' or 'spellfile'
 * Return an error message or NULL for success.
 ','line_number':4449,'multiline':True]
['text':'
 * Set curbuf->b_cap_prog to the regexp program for 'spellcapcheck'.
 * Return error message when failed, NULL when OK.
 ','line_number':4480,'multiline':True]
['text':' Prepend a ^ so that we only match at one column','line_number':4494,'multiline':False]
['text':' restore the previous program','line_number':4502,'multiline':False]
['text':' FEAT_SPELL','line_number':4512,'multiline':False]
