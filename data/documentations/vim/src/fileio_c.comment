['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]
['text':'
 * fileio.c: read from and write to a file
 ','line_number':10,'multiline':True]
['text':' for SSIZE_MAX','line_number':17,'multiline':False]
['text':' Is there any system that doesn't have access()?','line_number':27,'multiline':False]
['text':' put file name in IObuff with quotes','line_number':61,'multiline':False]
['text':' If it's extremely long, truncate it.','line_number':63,'multiline':False]
['text':' Avoid an over-long translation to cause trouble.','line_number':67,'multiline':False]
['text':'
     * For the first message may have to start a new line.
     * For further ones overwrite the previous one, reset msg_scroll before
     * calling filemess().
     ','line_number':70,'multiline':True]
['text':' wait a bit when overwriting an error msg','line_number':78,'multiline':False]
['text':' overwrite any previous message.','line_number':82,'multiline':False]
['text':' may truncate the message to avoid a hit-return prompt','line_number':85,'multiline':False]
['text':'
 * Read lines from file "fname" into the buffer after line "from".
 *
 * 1. We allocate blocks with lalloc, as big as possible.
 * 2. Each block is filled with characters from the file with a single read().
 * 3. The lines are inserted in the buffer with ml_append().
 *
 * (caller must check that fname != NULL, unless READ_STDIN is used)
 *
 * "lines_to_skip" is the number of lines that must be skipped
 * "lines_to_read" is the number of lines that are appended
 * When not recovering lines_to_skip is 0 and lines_to_read MAXLNUM.
 *
 * flags:
 * READ_NEW	starting to edit a new buffer
 * READ_FILTER	reading filter output
 * READ_STDIN	read from stdin instead of a file
 * READ_BUFFER	read from curbuf instead of a file (converting after reading
 *		stdin)
 * READ_NOFILE	do not read a file, only trigger BufReadCmd
 * READ_DUMMY	read into a dummy buffer (to check if file contents changed)
 * READ_KEEP_UNDO  don't clear undo info or read it from a file
 * READ_FIFO	read from fifo/socket instead of a file
 *
 * return FAIL for failure, NOTDONE for directory (failure), or OK
 ','line_number':92,'multiline':True]
['text':' can be NULL!','line_number':125,'multiline':False]
['text':' jump to "theend" instead of returning','line_number':128,'multiline':False]
['text':' next line to read from curbuf','line_number':138,'multiline':False]
['text':' next char to read from this line','line_number':139,'multiline':False]
['text':' pointer into read buffer','line_number':142,'multiline':False]
['text':' read buffer','line_number':143,'multiline':False]
['text':' init to shut up gcc','line_number':144,'multiline':False]
['text':' init to shut up gcc','line_number':145,'multiline':False]
['text':' buffer was empty before reading','line_number':146,'multiline':False]
['text':' file size read from disk','line_number':153,'multiline':False]
['text':' counter','line_number':154,'multiline':False]
['text':' number of split lines','line_number':162,'multiline':False]
['text':' file size is unknown','line_number':163,'multiline':False]
['text':' errors encountered','line_number':165,'multiline':False]
['text':' file format with errors','line_number':166,'multiline':False]
['text':' remaining chars in line','line_number':167,'multiline':False]
['text':' protection bits for swap file','line_number':170,'multiline':False]
['text':' end-of-line format','line_number':174,'multiline':False]
['text':' non-zero lnum when last line of','line_number':181,'multiline':False]
['text':' last read was missing the eol','line_number':182,'multiline':False]
['text':' line nr with conversion error','line_number':188,'multiline':False]
['text':' line nr with illegal byte','line_number':189,'multiline':False]
['text':' don't retry when char doesn't fit','line_number':190,'multiline':False]
['text':' in destination encoding','line_number':191,'multiline':False]
['text':' BAD_KEEP, BAD_DROP or character to','line_number':193,'multiline':False]
['text':' replace with','line_number':194,'multiline':False]
['text':' name of 'charconvert' output file','line_number':195,'multiline':False]
['text':' fileencoding to use','line_number':197,'multiline':False]
['text':' fenc_next is in allocated memory','line_number':198,'multiline':False]
['text':' next item in 'fencs' or NULL','line_number':199,'multiline':False]
['text':' descriptor for iconv() or -1','line_number':203,'multiline':False]
['text':' TRUE when iconv() failed and trying','line_number':205,'multiline':False]
['text':' 'charconvert' next','line_number':206,'multiline':False]
['text':' TRUE if conversion done','line_number':209,'multiline':False]
['text':' TRUE if conversion wanted but it','line_number':210,'multiline':False]
['text':' wasn't possible','line_number':211,'multiline':False]
['text':' nr of bytes in conv_rest[]','line_number':213,'multiline':False]
['text':' reset before triggering any autocommands','line_number':228,'multiline':False]
['text':' in case it was set by the previous read','line_number':230,'multiline':False]
['text':'
     * If there is no file name yet, use the one for the read file.
     * BF_NOTEDITED is set to reflect this.
     * Don't do this for a read from a filter.
     * Only do this when 'cpoptions' contains the 'f' flag.
     ','line_number':232,'multiline':True]
['text':' Remember the initial values of curbuf, curbuf->b_ffname and','line_number':248,'multiline':False]
['text':' curbuf->b_fname to detect whether they are altered as a result of','line_number':249,'multiline':False]
['text':' executing nasty autocommands.  Also check if "fname" and "sfname"','line_number':250,'multiline':False]
['text':' point to one of these values.','line_number':251,'multiline':False]
['text':' After reading a file the cursor line changes but we don't want to','line_number':259,'multiline':False]
['text':' display the line.','line_number':260,'multiline':False]
['text':' don't display the file info for another buffer now','line_number':263,'multiline':False]
['text':'
     * For Unix: Use the short file name whenever possible.
     * Avoids problems with networks and when directory names are changed.
     * Don't do this for MS-DOS, a "cd" in a sub-shell may have moved us to
     * another directory, which we don't detect.
     ','line_number':266,'multiline':True]
['text':'
     * The BufReadCmd and FileReadCmd events intercept the reading process by
     * executing the associated commands instead.
     ','line_number':278,'multiline':True]
['text':' Set '[ mark to the line above where the lines go (line 1 if zero).','line_number':286,'multiline':False]
['text':' The BufReadCmd code usually uses ":read" to get the text and','line_number':300,'multiline':False]
['text':' perhaps ":file" to change the buffer name. But we should','line_number':301,'multiline':False]
['text':' consider this to work like ":edit", thus reset the','line_number':302,'multiline':False]
['text':' BF_NOTEDITED flag.  Then ":write" will work to overwrite the','line_number':303,'multiline':False]
['text':' same file.','line_number':304,'multiline':False]
['text':' Return NOTDONE instead of FAIL so that BufEnter can be triggered','line_number':325,'multiline':False]
['text':' and other operations don't fail.','line_number':326,'multiline':False]
['text':' overwrite previous file message','line_number':333,'multiline':False]
['text':' don't overwrite previous file message','line_number':335,'multiline':False]
['text':' If the name is too long we might crash further on, quit here.','line_number':341,'multiline':False]
['text':' If the name ends in a path separator, we can't open it.  Check here,','line_number':350,'multiline':False]
['text':' because reading the file may actually work, but then creating the','line_number':351,'multiline':False]
['text':' swap file may destroy it!  Reported on MS-DOS and Win 95.','line_number':352,'multiline':False]
['text':'
	 * On Unix it is possible to read a directory, so we have to
	 * check for it before the mch_open().
	 ','line_number':366,'multiline':True]
['text':' not a regular file ...','line_number':371,'multiline':False]
['text':' ... or fifo','line_number':372,'multiline':False]
['text':' ... or socket','line_number':373,'multiline':False]
['text':' ... or a character special file named /dev/fd/<n>','line_number':376,'multiline':False]
['text':'
	 * MS-Windows allows opening a device, but we will probably get stuck
	 * trying to read it.
	 ','line_number':393,'multiline':True]
['text':' Set default or forced 'fileformat' and 'binary'.','line_number':407,'multiline':False]
['text':'
     * When opening a new file we take the readonly flag from the file.
     * Default is r/w, can be set to r/o below.
     * Don't reset it when in readonly mode
     * Only set/reset b_p_ro when BF_CHECK_RO is set.
     ','line_number':410,'multiline':True]
['text':' Remember time of file.','line_number':422,'multiline':False]
['text':'
	     * Use the protection bits of the original file for the swap file.
	     * This makes it possible for others to read the name of the
	     * edited file from the swapfile, but only if they can read the
	     * edited file.
	     * Remove the "write" and "execute" bits for group and others
	     * (they must not write the swapfile).
	     * Add the "read" and "write" bits for the user, otherwise we may
	     * not be able to write to the file ourselves.
	     * Setting the bits is done below, after creating the swap file.
	     ','line_number':432,'multiline':True]
['text':' Reset the "new file" flag.  It will be set again below when the','line_number':461,'multiline':False]
['text':' file doesn't exist.','line_number':462,'multiline':False]
['text':'
 * for UNIX: check readonly with perm and mch_access()
 * for Amiga: check readonly by trying to open the file for writing
 ','line_number':466,'multiline':True]
['text':' Force binary I/O on stdin to avoid CR-LF -> LF conversion.','line_number':474,'multiline':False]
['text':' try to open ro','line_number':494,'multiline':False]
['text':' cannot open at all','line_number':500,'multiline':False]
['text':'
	 * On Amiga we can't open a directory, check here.
	 ','line_number':507,'multiline':True]
['text':' check if the file exists','line_number':511,'multiline':False]
['text':' must use "w!" now','line_number':515,'multiline':False]
['text':'
		     * Set the 'new-file' flag, so that when the file has
		     * been created by someone else, a ":w" will complain.
		     ','line_number':527,'multiline':True]
['text':' Create a swap file now, so that other Vims are warned','line_number':533,'multiline':False]
['text':' that we are editing this file.  Don't do this for a','line_number':534,'multiline':False]
['text':' "nofile" or "nowrite" buffer type.','line_number':535,'multiline':False]
['text':' SwapExists autocommand may mess things up','line_number':539,'multiline':False]
['text':' Even though this is a new file, it might have been','line_number':557,'multiline':False]
['text':' edited before and deleted.  Get the old marks.','line_number':558,'multiline':False]
['text':' Set forced 'fileencoding'.','line_number':561,'multiline':False]
['text':' remember the current fileformat','line_number':566,'multiline':False]
['text':' autocmds may abort script processing','line_number':570,'multiline':False]
['text':' a new file is not an error','line_number':572,'multiline':False]
['text':' must use "w!" now','line_number':585,'multiline':False]
['text':'
     * Only set the 'ro' flag for readonly files the first time they are
     * loaded.	Help files always get readonly mode
     ','line_number':592,'multiline':True]
['text':' Don't change 'eol' if reading from buffer as it will already be','line_number':601,'multiline':False]
['text':' correctly set when reading stdin.','line_number':602,'multiline':False]
['text':' Create a swap file now, so that other Vims are warned that we are','line_number':614,'multiline':False]
['text':' editing this file.','line_number':615,'multiline':False]
['text':' Don't do this for a "nofile" or "nowrite" buffer type.','line_number':616,'multiline':False]
['text':' Set swap file protection bits after creating it.','line_number':630,'multiline':False]
['text':'
	     * If the group-read bit is set but not the world-read bit, then
	     * the group must be equal to the group of the original file.  If
	     * we can't make that happen then reset the group-read bit.  This
	     * avoids making the swap file readable to more users when the
	     * primary group of the user is too permissive.
	     ','line_number':636,'multiline':True]
['text':' If "Quit" selected at ATTENTION dialog, don't load the file','line_number':662,'multiline':False]
['text':' don't wait for return yet','line_number':670,'multiline':False]
['text':'
     * Set '[ mark to the line above where the lines go (line 1 if zero).
     ','line_number':672,'multiline':True]
['text':'
	 * The file must be closed again, the autocommands may want to change
	 * the file before reading it.
	 ','line_number':688,'multiline':True]
['text':' ignore errors','line_number':693,'multiline':False]
['text':'
	 * The output from the autocommands should not overwrite anything and
	 * should not be overwritten: Set msg_scroll, restore its value if no
	 * output was done.
	 ','line_number':695,'multiline':True]
['text':' autocommands may have changed it','line_number':713,'multiline':False]
['text':' autocmds may abort script processing','line_number':723,'multiline':False]
['text':' must use "w!" now','line_number':727,'multiline':False]
['text':'
	 * Don't allow the autocommands to change the current buffer.
	 * Try to re-open the file.
	 *
	 * Don't allow the autocommands to change the buffer name either
	 * (cd for example) if it invalidates fname or sfname.
	 ','line_number':731,'multiline':True]
['text':' must use "w!" now','line_number':749,'multiline':False]
['text':' Autocommands may add lines to the file, need to check if it is empty','line_number':754,'multiline':False]
['text':'
	 * Show the user that we are busy reading the input.  Sometimes this
	 * may take a while.  When reading from stdin another program may
	 * still be running, don't move the cursor to the last line, unless
	 * always using the GUI.
	 ','line_number':759,'multiline':True]
['text':' Also write a message in the GUI window, if there is one.','line_number':776,'multiline':False]
['text':' make a copy, gui_write() may try to change it','line_number':779,'multiline':False]
['text':' overwrite the file message','line_number':794,'multiline':False]
['text':'
     * Set linecnt now, before the "retry" caused by a wrong guess for
     * fileformat, and after the autocommands, which may change them.
     ','line_number':796,'multiline':True]
['text':' "++bad=" argument.','line_number':802,'multiline':False]
['text':'
     * Decide which 'encoding' to use or use first.
     ','line_number':812,'multiline':True]
['text':' binary: don't convert','line_number':823,'multiline':False]
['text':' Help files are either utf-8 or latin1.  Try utf-8 first, if this','line_number':831,'multiline':False]
['text':' fails it must be latin1.','line_number':832,'multiline':False]
['text':' Always do this when 'encoding' is "utf-8".  Otherwise only do','line_number':833,'multiline':False]
['text':' this when needed to avoid [converted] remarks all the time.','line_number':834,'multiline':False]
['text':' It is needed when the first line contains non-ASCII characters.','line_number':835,'multiline':False]
['text':' That is only in *.??x files.','line_number':836,'multiline':False]
['text':' Read the first line (and a bit more).  Immediately rewind to','line_number':844,'multiline':False]
['text':' the start of the file.  If the read() fails "len" is -1.','line_number':845,'multiline':False]
['text':' When the file is utf-8 but a character doesn't fit in','line_number':862,'multiline':False]
['text':' 'encoding' don't retry.  In help text editing utf-8 bytes','line_number':863,'multiline':False]
['text':' doesn't make sense.','line_number':864,'multiline':False]
['text':' use format from buffer','line_number':872,'multiline':False]
['text':' try items in 'fileencodings'','line_number':877,'multiline':False]
['text':'
     * Jump back here to retry reading the file in different ways.
     * Reasons to retry:
     * - encoding conversion failed: try another one from "fenc_next"
     * - BOM detected and fenc was set, need to setup conversion
     * - "fileformat" check failed: try another
     *
     * Variables set for special retry actions:
     * "file_rewind"	Rewind the file to start reading it again.
     * "advance_fenc"	Advance "fenc" using "fenc_next".
     * "skip_read"	Re-use already read bytes (BOM detected).
     * "did_iconv"	iconv() conversion failed, try 'charconvert'.
     * "keep_fileformat" Don't reset "fileformat".
     *
     * Other status indicators:
     * "tmpname"	When != NULL did conversion with 'charconvert'.
     *			Output file has to be deleted afterwards.
     * "iconv_fd"	When != -1 did conversion with iconv().
     ','line_number':881,'multiline':True]
['text':' Can't rewind the file, give up.','line_number':911,'multiline':False]
['text':' Delete the previously read lines.','line_number':915,'multiline':False]
['text':'
     * When retrying with another "fenc" and the first time "fileformat"
     * will be reset.
     ','line_number':927,'multiline':True]
['text':' binary: use Unix format','line_number':941,'multiline':False]
['text':' use format from buffer','line_number':943,'multiline':False]
['text':' detect from file','line_number':945,'multiline':False]
['text':' aborted conversion with iconv(), close the descriptor','line_number':951,'multiline':False]
['text':'
	 * Try the next entry in 'fileencodings'.
	 ','line_number':959,'multiline':True]
['text':' Conversion given with "++cc=" wasn't possible, read','line_number':966,'multiline':False]
['text':' without conversion.','line_number':967,'multiline':False]
['text':' delete converted file','line_number':991,'multiline':False]
['text':'
     * Conversion may be required when the encoding of the file is different
     * from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.
     ','line_number':996,'multiline':True]
['text':' "ucs-bom" means we need to check the first bytes of the file','line_number':1005,'multiline':False]
['text':' for a BOM.','line_number':1006,'multiline':False]
['text':'
	 * Check if UCS-2/4 or Latin1 to UTF-8 conversion needs to be
	 * done.  This is handled below after read().  Prepare the
	 * fio_flags to avoid having to parse the string each time.
	 * Also check for Unicode to Latin1 conversion, because iconv()
	 * appears not to handle this correctly.  This works just like
	 * conversion to UTF-8 except how the resulting character is put in
	 * the buffer.
	 ','line_number':1010,'multiline':True]
['text':'
	 * Conversion from an MS-Windows codepage to UTF-8 or another codepage
	 * is handled with MultiByteToWideChar().
	 ','line_number':1023,'multiline':True]
['text':' Conversion from Apple MacRoman to latin1 or UTF-8','line_number':1032,'multiline':False]
['text':'
	 * Try using iconv() if we can't convert internally.
	 ','line_number':1038,'multiline':True]
['text':'
	 * Use the 'charconvert' expression when conversion is required
	 * and we can't do it internally or with iconv().
	 ','line_number':1051,'multiline':True]
['text':' Skip conversion when it's already done (retry for wrong','line_number':1065,'multiline':False]
['text':' "fileformat").','line_number':1066,'multiline':False]
['text':' Conversion failed.  Try another one.','line_number':1072,'multiline':False]
['text':' Re-opening the original file failed!','line_number':1076,'multiline':False]
['text':' Conversion wanted but we can't.','line_number':1094,'multiline':False]
['text':' Try the next conversion in 'fileencodings'','line_number':1095,'multiline':False]
['text':' Set "can_retry" when it's possible to rewind the file and try with','line_number':1102,'multiline':False]
['text':' another "fenc" value.  It's FALSE when no other "fenc" to try, reading','line_number':1103,'multiline':False]
['text':' stdin or fixed at a specific encoding.','line_number':1104,'multiline':False]
['text':' Need to free the state, but keep the key, don't want to ask for','line_number':1131,'multiline':False]
['text':' it again.','line_number':1132,'multiline':False]
['text':'
	 * We allocate as much space for the file as we can get, plus
	 * space for the old line plus room for one terminating NUL.
	 * The amount is limited by the fact that read() only can read
	 * up to max_unsigned characters (and other things).
	 ','line_number':1141,'multiline':True]
['text':' use max I/O size, 52K','line_number':1150,'multiline':False]
['text':' Use buffer >= 64K.  Add linerest to double the size if the','line_number':1152,'multiline':False]
['text':' line gets very long, to avoid a lot of copying. But don't','line_number':1153,'multiline':False]
['text':' read more than 1 Mbyte at a time, so we can be interrupted.','line_number':1154,'multiline':False]
['text':' Protect against the argument of lalloc() going negative.','line_number':1161,'multiline':False]
['text':' split line by inserting a NL','line_number':1165,'multiline':False]
['text':' copy characters from the previous buffer','line_number':1184,'multiline':False]
['text':' May need room to translate into.','line_number':1191,'multiline':False]
['text':' For iconv() we don't really know the required space, use a','line_number':1192,'multiline':False]
['text':' factor ICONV_MULT.','line_number':1193,'multiline':False]
['text':' latin1 to utf-8: 1 byte becomes up to 2 bytes','line_number':1194,'multiline':False]
['text':' utf-16 to utf-8: 2 bytes become up to 3 bytes, 4 bytes','line_number':1195,'multiline':False]
['text':' become up to 4 bytes, size must be multiple of 2','line_number':1196,'multiline':False]
['text':' ucs-2 to utf-8: 2 bytes become up to 3 bytes, size must be','line_number':1197,'multiline':False]
['text':' multiple of 2','line_number':1198,'multiline':False]
['text':' ucs-4 to utf-8: 4 bytes become up to 6 bytes, size must be','line_number':1199,'multiline':False]
['text':' multiple of 4','line_number':1200,'multiline':False]
['text':' worst case','line_number':1214,'multiline':False]
['text':' also worst case','line_number':1217,'multiline':False]
['text':' also worst case','line_number':1221,'multiline':False]
['text':' Insert unconverted bytes from previous line.','line_number':1226,'multiline':False]
['text':'
		     * Read bytes from curbuf.  Used for converting text read
		     * from stdin.
		     ','line_number':1234,'multiline':True]
['text':' Filled up to "size", append partial line.','line_number':1252,'multiline':False]
['text':' Change NL to NUL to reverse the effect done','line_number':1253,'multiline':False]
['text':' below.','line_number':1254,'multiline':False]
['text':' Append whole line and new-line.  Change NL','line_number':1267,'multiline':False]
['text':' to NUL to reverse the effect done below.','line_number':1268,'multiline':False]
['text':' When the last line didn't have an','line_number':1280,'multiline':False]
['text':' end-of-line don't add it now either.','line_number':1281,'multiline':False]
['text':'
		     * Read bytes from the file.
		     ','line_number':1295,'multiline':True]
['text':' Let the crypt layer work with a buffer size of 8192','line_number':1299,'multiline':False]
['text':'','line_number':1300,'multiline':False]
['text':' Sodium encryption requires a fixed block size to','line_number':1301,'multiline':False]
['text':' successfully decrypt. However, unfortunately the file','line_number':1302,'multiline':False]
['text':' header size changes between xchacha20 and xchacha20v2 by','line_number':1303,'multiline':False]
['text':' 'add_len' bytes.','line_number':1304,'multiline':False]
['text':' So we will now read the maximum header size + encryption','line_number':1305,'multiline':False]
['text':' metadata, but after determining to read an xchacha20','line_number':1306,'multiline':False]
['text':' encrypted file, we have to rewind the file descriptor by','line_number':1307,'multiline':False]
['text':' 'add_len' bytes in the second round.','line_number':1308,'multiline':False]
['text':'','line_number':1309,'multiline':False]
['text':' Be careful with changing it, it needs to stay the same','line_number':1310,'multiline':False]
['text':' for reading back previously encrypted files!','line_number':1311,'multiline':False]
['text':' set size to 8K + Sodium Crypt Metadata','line_number':1314,'multiline':False]
['text':' need to rewind by - add_len from CRYPT_M_SOD2 (see','line_number':1326,'multiline':False]
['text':' description above)','line_number':1327,'multiline':False]
['text':' Did we reach end of file?','line_number':1341,'multiline':False]
['text':'
		 * At start of file: Check for magic number of encryption.
		 ','line_number':1348,'multiline':True]
['text':' reading undo file requires crypt_decode_inplace()','line_number':1359,'multiline':False]
['text':'
		 * Decrypt the read bytes.  This is done before checking for
		 * EOF because the crypt layer may be buffering.
		 ','line_number':1363,'multiline':True]
['text':' error message already given','line_number':1389,'multiline':False]
['text':' If the crypt layer is buffering, not producing','line_number':1394,'multiline':False]
['text':' anything yet, need to read more.','line_number':1395,'multiline':False]
['text':' Simple case: reuse returned buffer (may be','line_number':1401,'multiline':False]
['text':' NULL, checked later).','line_number':1402,'multiline':False]
['text':' Need new buffer to add bytes carried over.','line_number':1409,'multiline':False]
['text':' read error','line_number':1443,'multiline':False]
['text':'
			 * Reached end-of-file but some trailing bytes could
			 * not be converted.  Truncated file?
			 ','line_number':1447,'multiline':True]
['text':' When we did a conversion report an error.','line_number':1452,'multiline':False]
['text':' Remember the first linenr with an illegal byte','line_number':1465,'multiline':False]
['text':' Replace the trailing bytes with the replacement','line_number':1476,'multiline':False]
['text':' character if we were converting; if we weren't,','line_number':1477,'multiline':False]
['text':' leave the UTF8 checking code to do it, as it','line_number':1478,'multiline':False]
['text':' works slightly differently.','line_number':1479,'multiline':False]
['text':' don't convert this','line_number':1492,'multiline':False]
['text':'
	     * At start of file (or after crypt magic number): Check for BOM.
	     * Also check for a BOM for other Unicode encodings, but not after
	     * converting with 'charconvert' or when a BOM has already been
	     * found.
	     ','line_number':1506,'multiline':True]
['text':' no BOM detection in a short file or in binary mode','line_number':1527,'multiline':False]
['text':' Remove BOM from the text','line_number':1535,'multiline':False]
['text':' No BOM detected: retry with next encoding.','line_number':1550,'multiline':False]
['text':' BOM detected: set "fenc" and jump back','line_number':1555,'multiline':False]
['text':' retry reading without getting new bytes or rewinding','line_number':1561,'multiline':False]
['text':' Include not converted bytes.','line_number':1567,'multiline':False]
['text':'
	     * Break here for a read error or end-of-file.
	     ','line_number':1571,'multiline':True]
['text':'
		 * Attempt conversion of the read bytes to 'encoding' using
		 * iconv().
		 ','line_number':1581,'multiline':True]
['text':'
		 * If there is conversion error or not enough room try using
		 * another conversion.  Except for when there is no
		 * alternative (help files).
		 ','line_number':1596,'multiline':True]
['text':' Deal with a bad byte and continue with the next.','line_number':1612,'multiline':False]
['text':' Some remaining characters, keep them for the next','line_number':1629,'multiline':False]
['text':' round.','line_number':1630,'multiline':False]
['text':' move the linerest to before the converted characters','line_number':1635,'multiline':False]
['text':'
		 * Conversion from an MS-Windows codepage or UTF-8 to UTF-8 or
		 * a codepage, using standard MS-Windows functions.  This
		 * requires two steps:
		 * 1. convert from 'fileencoding' to ucs-2
		 * 2. convert from ucs-2 to 'encoding'
		 *
		 * Because there may be illegal bytes AND an incomplete byte
		 * sequence at the end, we may have to do the conversion one
		 * character at a time to get it right.
		 ','line_number':1653,'multiline':True]
['text':' Replacement string for WideCharToMultiByte().','line_number':1665,'multiline':False]
['text':'
		 * Move the bytes to the end of the buffer, so that we have
		 * room to put the result at the start.
		 ','line_number':1672,'multiline':True]
['text':'
		 * Do the conversion.
		 ','line_number':1679,'multiline':True]
['text':' VC 4.1 doesn't define CP_UTF8','line_number':1687,'multiline':False]
['text':' Handle CP_UTF8 input ourselves to be able to handle','line_number':1690,'multiline':False]
['text':' trailing bytes properly.','line_number':1691,'multiline':False]
['text':' Get one UTF-8 character from src.','line_number':1692,'multiline':False]
['text':' Only got some bytes of a character.  Normally','line_number':1696,'multiline':False]
['text':' it's put in "conv_rest", but if it's too long','line_number':1697,'multiline':False]
['text':' deal with it as if they were illegal bytes.','line_number':1698,'multiline':False]
['text':' weird overlong byte sequence','line_number':1702,'multiline':False]
['text':' We don't know how long the byte sequence is, try','line_number':1719,'multiline':False]
['text':' from one to three bytes.','line_number':1720,'multiline':False]
['text':' If we have only one byte then it's probably an','line_number':1733,'multiline':False]
['text':' incomplete byte sequence.  Otherwise discard','line_number':1734,'multiline':False]
['text':' one byte as a bad character.','line_number':1735,'multiline':False]
['text':' Convert "ucs2buf[ucs2len]" to 'enc' in "dst".','line_number':1747,'multiline':False]
['text':' From UCS-2 to UTF-8.  Cannot fail.','line_number':1750,'multiline':False]
['text':' From UCS-2 to "enc_codepage".  If the','line_number':1759,'multiline':False]
['text':' conversion uses the default character "?",','line_number':1760,'multiline':False]
['text':' the data doesn't fit in this encoding.','line_number':1761,'multiline':False]
['text':' Deal with bytes we can't convert.','line_number':1775,'multiline':False]
['text':' An incomplete byte sequence remaining.','line_number':1798,'multiline':False]
['text':' The new size is equal to how much "dst" was advanced.','line_number':1803,'multiline':False]
['text':'
		 * Conversion from Apple MacRoman char encoding to UTF-8 or
		 * latin1.  This is in os_mac_conv.c.
		 ','line_number':1811,'multiline':True]
['text':'
		 * "enc_utf8" set: Convert Unicode or Latin1 to UTF-8.
		 * "enc_utf8" not set: Convert Unicode to Latin1.
		 * Go from end to start through the buffer, because the number
		 * of bytes may increase.
		 * "dest" points to after where the UTF-8 bytes go, "p" points
		 * to after the next character to convert.
		 ','line_number':1826,'multiline':True]
['text':' Check for a trailing incomplete UTF-8 sequence','line_number':1840,'multiline':False]
['text':' Check for a trailing byte','line_number':1852,'multiline':False]
['text':' Check for a trailing leading word','line_number':1858,'multiline':False]
['text':'  FIO_UCS4','line_number':1875,'multiline':False]
['text':' Check for trailing 1, 2 or 3 bytes','line_number':1877,'multiline':False]
['text':' If there is a trailing incomplete sequence move it to','line_number':1883,'multiline':False]
['text':' conv_rest[].','line_number':1884,'multiline':False]
['text':' Missing leading word.','line_number':1916,'multiline':False]
['text':' found second word of double-word, get the first','line_number':1928,'multiline':False]
['text':' word and compute the resulting character','line_number':1929,'multiline':False]
['text':' Check if the word is indeed a leading word.','line_number':1943,'multiline':False]
['text':' big endian','line_number':1967,'multiline':False]
['text':' UTF-8','line_number':1975,'multiline':False]
['text':' Not a valid UTF-8 character, retry with','line_number':1986,'multiline':False]
['text':' another fenc when possible, otherwise just','line_number':1987,'multiline':False]
['text':' report the error.','line_number':1988,'multiline':False]
['text':' produce UTF-8','line_number':2001,'multiline':False]
['text':' produce Latin1','line_number':2006,'multiline':False]
['text':' character doesn't fit in latin1, retry with','line_number':2011,'multiline':False]
['text':' another fenc when possible, otherwise just','line_number':2012,'multiline':False]
['text':' report the error.','line_number':2013,'multiline':False]
['text':' move the linerest to before the converted characters','line_number':2032,'multiline':False]
['text':' Reading UTF-8: Check if the bytes are valid UTF-8.','line_number':2042,'multiline':False]
['text':' A length of 1 means it's an illegal byte.  Accept','line_number':2052,'multiline':False]
['text':' an incomplete character at the end though, the next','line_number':2053,'multiline':False]
['text':' read() will get the next bytes, we'll check it','line_number':2054,'multiline':False]
['text':' then.','line_number':2055,'multiline':False]
['text':' Avoid retrying with a different encoding when','line_number':2059,'multiline':False]
['text':' a truncated file is more likely, or attempting','line_number':2060,'multiline':False]
['text':' to read the rest of an incomplete sequence when','line_number':2061,'multiline':False]
['text':' we have already done so.','line_number':2062,'multiline':False]
['text':' Incomplete byte sequence, move it to conv_rest[]','line_number':2065,'multiline':False]
['text':' and try to read the rest of it, unless we've','line_number':2066,'multiline':False]
['text':' already done so.','line_number':2067,'multiline':False]
['text':' Illegal byte.  If we can try another encoding','line_number':2078,'multiline':False]
['text':' do that, unless at EOF where a truncated','line_number':2079,'multiline':False]
['text':' file is more likely than a conversion error.','line_number':2080,'multiline':False]
['text':' When we did a conversion report an error.','line_number':2084,'multiline':False]
['text':' Remember the first linenr with an illegal byte','line_number':2088,'multiline':False]
['text':' Drop, keep or replace the bad byte.','line_number':2092,'multiline':False]
['text':' Detected a UTF-8 error.','line_number':2108,'multiline':False]
['text':' Retry reading with another conversion.','line_number':2110,'multiline':False]
['text':' iconv() failed, try 'charconvert'','line_number':2113,'multiline':False]
['text':' use next item from 'fileencodings'','line_number':2117,'multiline':False]
['text':' count the number of characters (after conversion!)','line_number':2124,'multiline':False]
['text':'
	     * when reading the first part of a file: guess EOL type
	     ','line_number':2127,'multiline':True]
['text':' First try finding a NL, for Dos and Unix','line_number':2132,'multiline':False]
['text':' Reset the carriage return counter.','line_number':2135,'multiline':False]
['text':' Don't give in to EOL_UNIX if EOL_MAC is more likely','line_number':2154,'multiline':False]
['text':' Need to reset the counters when retrying fenc.','line_number':2157,'multiline':False]
['text':' Looking for CR but found no end-of-line markers at','line_number':2176,'multiline':False]
['text':' all: use the default format.','line_number':2177,'multiline':False]
['text':' No NL found: may use Mac format','line_number':2181,'multiline':False]
['text':' Still nothing found?  Use first format in 'ffs'','line_number':2185,'multiline':False]
['text':' if editing a new file: may set p_tx and p_ff','line_number':2189,'multiline':False]
['text':'
	 * This loop is executed once for every character read.
	 * Keep it fast!
	 ','line_number':2195,'multiline':True]
['text':' catch most common case first','line_number':2204,'multiline':False]
['text':' NULs are replaced by newlines!','line_number':2208,'multiline':False]
['text':' NLs are replaced by CRs!','line_number':2210,'multiline':False]
['text':' end of line','line_number':2215,'multiline':False]
['text':' break loop','line_number':2229,'multiline':False]
['text':' nothing left to write','line_number':2230,'multiline':False]
['text':' catch most common case','line_number':2245,'multiline':False]
['text':' NULs are replaced by newlines!','line_number':2248,'multiline':False]
['text':' end of line','line_number':2253,'multiline':False]
['text':' remove CR before NL','line_number':2259,'multiline':False]
['text':'
			     * Reading in Dos format, but no CR-LF found!
			     * When 'fileformats' includes "unix", delete all
			     * the lines read so far and start all over again.
			     * Otherwise give an error message later.
			     ','line_number':2263,'multiline':True]
['text':' break loop','line_number':2299,'multiline':False]
['text':' nothing left to write','line_number':2300,'multiline':False]
['text':' not an error, max. number of lines reached','line_number':2315,'multiline':False]
['text':' In Dos format ignore a trailing CTRL-Z, unless 'binary' is set.','line_number':2319,'multiline':False]
['text':' In old days the file length was in sector count and the CTRL-Z the','line_number':2320,'multiline':False]
['text':' marker where the file really ended.  Assuming we write it to a file','line_number':2321,'multiline':False]
['text':' system that keeps file length properly the CTRL-Z should be dropped.','line_number':2322,'multiline':False]
['text':' Set the 'endoffile' option so the user can decide what to write later.','line_number':2323,'multiline':False]
['text':' In Unix format the CTRL-Z is just another character.','line_number':2324,'multiline':False]
['text':' If we get EOF in the middle of a line, note the fact by resetting','line_number':2336,'multiline':False]
['text':' 'endofline' and add the line normally.','line_number':2337,'multiline':False]
['text':' remember for when writing','line_number':2342,'multiline':False]
['text':' remember the current file format','line_number':2360,'multiline':False]
['text':' Don't set cryptkey to NULL, it's used below as a flag that','line_number':2370,'multiline':False]
['text':' encryption was used.','line_number':2371,'multiline':False]
['text':' If editing a new file: set 'fenc' for the current buffer.','line_number':2374,'multiline':False]
['text':' Also for ":read ++edit file".','line_number':2375,'multiline':False]
['text':' errors are ignored','line_number':2387,'multiline':False]
['text':' Use stderr for stdin, makes shell commands work.','line_number':2402,'multiline':False]
['text':' delete converted file','line_number':2410,'multiline':False]
['text':' may wait for return now','line_number':2413,'multiline':False]
['text':'
     * In recovery mode everything but autocommands is skipped.
     ','line_number':2415,'multiline':True]
['text':' need to delete the last line, which comes from the empty buffer','line_number':2420,'multiline':False]
['text':' After reading the text into the buffer the diff info needs to','line_number':2439,'multiline':False]
['text':' be updated.','line_number':2440,'multiline':False]
['text':' All folds in the window are invalid now.  Mark them for update','line_number':2444,'multiline':False]
['text':' before triggering autocommands.','line_number':2445,'multiline':False]
['text':' appended at least one line','line_number':2449,'multiline':False]
['text':'
	 * If we were reading from the same terminal as where messages go,
	 * the screen will have been messed up.
	 * Switch on raw mode now and clear the screen.
	 ','line_number':2453,'multiline':True]
['text':' set to raw mode','line_number':2460,'multiline':False]
['text':' must use "w!" now','line_number':2472,'multiline':False]
['text':' an interrupt isn't really an error','line_number':2478,'multiline':False]
['text':' fname in IObuff with quotes','line_number':2484,'multiline':False]
['text':' fifo','line_number':2488,'multiline':False]
['text':' or socket','line_number':2493,'multiline':False]
['text':' or character special','line_number':2499,'multiline':False]
['text':' Don't show the message when reading stdin, it would end up in a','line_number':2573,'multiline':False]
['text':' message box (which might be shown when exiting!)','line_number':2574,'multiline':False]
['text':' overwrite previous message','line_number':2581,'multiline':False]
['text':' Need to repeat the message after redrawing when:','line_number':2586,'multiline':False]
['text':' - When reading from stdin (the screen will be cleared next).','line_number':2587,'multiline':False]
['text':' - When restart_edit is set (otherwise there will be a delay','line_number':2588,'multiline':False]
['text':'   before redrawing).','line_number':2589,'multiline':False]
['text':' - When the screen was scrolled but there is no wait-return','line_number':2590,'multiline':False]
['text':'   prompt.','line_number':2591,'multiline':False]
['text':' with errors writing the file requires ":w!"','line_number':2596,'multiline':False]
['text':' cannot use "U" command after adding lines','line_number':2602,'multiline':False]
['text':'
	 * In Ex mode: cursor at last new line.
	 * Otherwise: cursor at first new line.
	 ','line_number':2604,'multiline':True]
['text':' on first non-blank','line_number':2613,'multiline':False]
['text':' Set '[ and '] marks to the newly read lines.','line_number':2617,'multiline':False]
['text':'
	 * Work around a weird problem: When a file has two links (only
	 * possible on NTFS) and we write through one link, then stat() it
	 * through the other link, the timestamp information may be wrong.
	 * It's correct again after reading the file, thus reset the timestamp
	 * here.
	 ','line_number':2625,'multiline':True]
['text':'
     * Get the marks before executing autocommands, so they can be used there.
     ','line_number':2644,'multiline':True]
['text':'
     * We remember if the last line of the read didn't have
     * an eol even when 'binary' is off, to support turning 'fixeol' off,
     * or writing the read again with 'binary' on.  The latter is required
     * for ":autocmd FileReadPost *.gz set bin|'[,']!gunzip" to work.
     ','line_number':2650,'multiline':True]
['text':' When reloading a buffer put the cursor at the first line that is','line_number':2658,'multiline':False]
['text':' different.','line_number':2659,'multiline':False]
['text':'
     * When opening a new file locate undo info and read it.
     ','line_number':2664,'multiline':True]
['text':' Save the fileformat now, otherwise the buffer will be considered','line_number':2681,'multiline':False]
['text':' modified if the format/encoding was automatically detected.','line_number':2682,'multiline':False]
['text':'
	 * The output from the autocommands should not overwrite anything and
	 * should not be overwritten: Set msg_scroll, restore its value if no
	 * output was done.
	 ','line_number':2686,'multiline':True]
['text':'
		 * EVENT_FILETYPE was not triggered but the buffer already has a
		 * filetype. Trigger EVENT_FILETYPE using the existing filetype.
		 ','line_number':2700,'multiline':True]
['text':' autocmds may abort script processing','line_number':2713,'multiline':False]
['text':' OK to sync the swap file now','line_number':2724,'multiline':False]
['text':'
 * Returns TRUE if the file name argument is of the form "/dev/fd/\d\+",
 * which is the name of files used for process substitution output by
 * some shells on some operating systems, e.g., bash on SunOS.
 * Do not accept "/dev/fd/[012]", opening these may hang Vim.
 ','line_number':2731,'multiline':True]
['text':'
 * From the current line count and characters read after that, estimate the
 * line number where we are now.
 * Used for error messages that include a line number.
 ','line_number':2748,'multiline':True]
['text':' line count before reading more bytes','line_number':2755,'multiline':False]
['text':' start of more bytes read','line_number':2756,'multiline':False]
['text':' end of more bytes read','line_number':2757,'multiline':False]
['text':'
 * Fill "*eap" to force the 'fileencoding', 'fileformat' and 'binary' to be
 * equal to the buffer "buf".  Used for calling readfile().
 * Returns OK or FAIL.
 ','line_number':2769,'multiline':True]
['text':'
 * Set default or forced 'fileformat' and 'binary'.
 ','line_number':2792,'multiline':True]
['text':' set default 'fileformat'','line_number':2798,'multiline':False]
['text':' set or reset 'binary'','line_number':2807,'multiline':False]
['text':'
 * Set forced 'fileencoding'.
 ','line_number':2817,'multiline':True]
['text':'
 * Find next fileencoding to use from 'fileencodings'.
 * "pp" points to fenc_next.  It's advanced to the next item.
 * When there are no more items, an empty string is returned and *pp is set to
 * NULL.
 * When *pp is not set to NULL, the result is in allocated memory and "alloced"
 * is set to TRUE.
 ','line_number':2834,'multiline':True]
['text':' out of memory','line_number':2875,'multiline':False]
['text':'
 * Convert a file with the 'charconvert' expression.
 * This closes the file which is to be read, converts it and opens the
 * resulting file for reading.
 * Returns name of the resulting converted file (the caller should delete it
 * after reading it).
 * Returns NULL if the conversion failed ("*fdp" is not set) .
 ','line_number':2883,'multiline':True]
['text':' name of input file','line_number':2893,'multiline':False]
['text':' converted from','line_number':2894,'multiline':False]
['text':' in/out: file descriptor of file','line_number':2895,'multiline':False]
['text':' close the input file, ignore errors','line_number':2905,'multiline':False]
['text':' Don't use emsg(), it breaks mappings, the retry with','line_number':2917,'multiline':False]
['text':' another type of conversion might still work.','line_number':2918,'multiline':False]
['text':' delete converted file','line_number':2922,'multiline':False]
['text':' If the input file is closed, open it (caller should check for error).','line_number':2927,'multiline':False]
['text':'
 * Check for magic number used for encryption.  Applies to the current buffer.
 * If found, the magic number is removed from ptr[*sizep] and *sizep and
 * *filesizep are updated.
 * Return the (new) encryption key, NULL for no encryption.
 ','line_number':2936,'multiline':True]
['text':' previous encryption key or NULL','line_number':2944,'multiline':False]
['text':' pointer to read bytes','line_number':2945,'multiline':False]
['text':' length of read bytes','line_number':2946,'multiline':False]
['text':' nr of bytes used from file','line_number':2947,'multiline':False]
['text':' editing a new buffer','line_number':2948,'multiline':False]
['text':' file name to display','line_number':2949,'multiline':False]
['text':' flag: whether already asked for key','line_number':2950,'multiline':False]
['text':' Mark the buffer as read-only until the decryption has taken place.','line_number':2957,'multiline':False]
['text':' Avoids accidentally overwriting the file with garbage.','line_number':2958,'multiline':False]
['text':' Set the cryptmethod local to the buffer.','line_number':2961,'multiline':False]
['text':' When newfile is TRUE, store the typed key in the 'key'','line_number':2972,'multiline':False]
['text':' option and don't free it.  bf needs hash of the key saved.','line_number':2973,'multiline':False]
['text':' Don't ask for the key again when first time Enter was hit.','line_number':2974,'multiline':False]
['text':' Happens when retrying to detect encoding.','line_number':2975,'multiline':False]
['text':' check if empty key entered','line_number':2982,'multiline':False]
['text':' invalid header, buffer can't be encrypted','line_number':2998,'multiline':False]
['text':' Remove cryptmethod specific header from the text.','line_number':3005,'multiline':False]
['text':' Restore the read-only flag.','line_number':3010,'multiline':False]
['text':' When starting to edit a new file which does not have encryption, clear','line_number':3014,'multiline':False]
['text':' the 'key' option, except when starting up (called with -x argument)','line_number':3015,'multiline':False]
['text':' FEAT_CRYPT','line_number':3021,'multiline':False]
['text':'
 * Return TRUE if a file appears to be read-only from the file permissions.
 ','line_number':3023,'multiline':True]
['text':' full path to file','line_number':3028,'multiline':False]
['text':' known permissions on file','line_number':3029,'multiline':False]
['text':'
 * Call fsync() with Mac-specific exception.
 * Return fsync() result: zero for success.
 ','line_number':3049,'multiline':True]
['text':' F_FULLFSYNC not working or not supported','line_number':3060,'multiline':False]
['text':'
 * Set the name of the current buffer.  Use when the buffer doesn't have a
 * name and a ":r" or ":w" command with a file name is used.
 ','line_number':3067,'multiline':True]
['text':' It's like the unnamed buffer is deleted....','line_number':3076,'multiline':False]
['text':' autocmds may abort script processing','line_number':3081,'multiline':False]
['text':' We are in another buffer now, don't do the renaming.','line_number':3086,'multiline':False]
['text':' ....and a new named one is created','line_number':3094,'multiline':False]
['text':' autocmds may abort script processing','line_number':3099,'multiline':False]
['text':' Do filetype detection now if 'filetype' is empty.','line_number':3103,'multiline':False]
['text':'
 * Put file name into IObuff with quotes.
 ','line_number':3114,'multiline':True]
['text':'
 * Append message for text mode to IObuff.
 * Return TRUE if something appended.
 ','line_number':3127,'multiline':True]
['text':'
 * Append line and character count to IObuff.
 ','line_number':3156,'multiline':True]
['text':'
 * Append message for missing line separator to IObuff.
 ','line_number':3184,'multiline':True]
['text':' On a FAT filesystem, esp. under Linux, there are only 5 bits to store','line_number':3201,'multiline':False]
['text':' the seconds.  Since the roundoff is done when flushing the inode, the','line_number':3202,'multiline':False]
['text':' time may change unexpectedly by one second!!!','line_number':3203,'multiline':False]
['text':'
 * Return TRUE if file encoding "fenc" requires conversion from or to
 * 'encoding'.
 ','line_number':3211,'multiline':True]
['text':' Ignore difference between "ansi" and "latin1", "ucs-4" and','line_number':3229,'multiline':False]
['text':' "ucs-4be", etc.','line_number':3230,'multiline':False]
['text':' Specified encoding matches with 'encoding'.  This requires','line_number':3237,'multiline':False]
['text':' conversion when 'encoding' is Unicode but not UTF-8.','line_number':3238,'multiline':False]
['text':' Encodings differ.  However, conversion is not needed when 'enc' is any','line_number':3242,'multiline':False]
['text':' Unicode encoding and the file is UTF-8.','line_number':3243,'multiline':False]
['text':'
 * Check "ptr" for a unicode encoding and return the FIO_ flags needed for the
 * internal conversion.
 * if "ptr" is an empty string, use 'encoding'.
 ','line_number':3247,'multiline':True]
['text':' must be ENC_DBCS, requires iconv()','line_number':3285,'multiline':False]
['text':'
 * Check "ptr" for a MS-Windows codepage name and return the FIO_ flags needed
 * for the conversion MS-Windows can do for us.  Also accept "utf-8".
 * Used for conversion between 'encoding' and 'fileencoding'.
 ','line_number':3290,'multiline':True]
['text':' Cannot do this when 'encoding' is not utf-8 and not a codepage.','line_number':3300,'multiline':False]
['text':' VC 4.1 doesn't define CP_UTF8','line_number':3307,'multiline':False]
['text':'
 * Check "ptr" for a Carbon supported encoding and return the FIO_ flags
 * needed for the internal conversion to/from utf-8 or latin1.
 ','line_number':3319,'multiline':True]
['text':'
 * Check for a Unicode BOM (Byte Order Mark) at the start of p[size].
 * "size" must be at least 2.
 * Return the name of the encoding and set "*lenp" to the length.
 * Returns NULL when no BOM found.
 ','line_number':3333,'multiline':True]
['text':' EF BB BF','line_number':3352,'multiline':False]
['text':' FF FE 00 00','line_number':3360,'multiline':False]
['text':' FF FE','line_number':3364,'multiline':False]
['text':' utf-16le is preferred, it also works for ucs-2le text','line_number':3366,'multiline':False]
['text':' FF FE','line_number':3367,'multiline':False]
['text':' Default to utf-16, it works also for ucs-2 text.','line_number':3372,'multiline':False]
['text':' FE FF','line_number':3374,'multiline':False]
['text':' FE FF','line_number':3376,'multiline':False]
['text':' 00 00 FE FF','line_number':3381,'multiline':False]
['text':'
 * Try to find a shortname by comparing the fullname with the current
 * directory.
 * Returns "full_path" or pointer into "full_path" if shortened.
 ','line_number':3389,'multiline':True]
['text':'
 * Try to find a shortname by comparing the fullname with the current
 * directory.
 * Returns NULL if not shorter name possible, pointer into "full_path"
 * otherwise.
 ','line_number':3413,'multiline':True]
['text':'
	 * MS-Windows: when a file is in the root directory, dir_name will end
	 * in a slash, since C: by itself does not define a specific dir. In
	 * this case p may already be correct. <negri>
	 ','line_number':3432,'multiline':True]
['text':' the path separator is always part of the path','line_number':3442,'multiline':False]
['text':'
     * When using a file in the current drive, remove the drive name:
     * "A:\dir\file" -> "\dir\file".  This helps when moving a session file on
     * a floppy from "A:\dir" to "B:\dir".
     ','line_number':3449,'multiline':True]
['text':'
 * Shorten filename of a buffer.
 * When "force" is TRUE: Use full path from now on for files currently being
 * edited, both for file name and swap file name.  Try to shorten the file
 * names a bit, if safe to do so.
 * When "force" is FALSE: Only try to shorten absolute file names.
 * For buffers that have buftype "nofile" or "scratch": never change the file
 * name.
 ','line_number':3465,'multiline':True]
['text':'
 * Shorten filenames for all buffers.
 ','line_number':3499,'multiline':True]
['text':' Always make the swap file name a full path, a "nofile" buffer may','line_number':3513,'multiline':False]
['text':' also have a swap file.','line_number':3514,'multiline':False]
['text':'
 * Shorten all filenames in "fnames[count]" by current directory.
 ','line_number':3528,'multiline':True]
['text':' shorten_fname() returns pointer in given "fnames[i]".  If free','line_number':3545,'multiline':False]
['text':' "fnames[i]" first, "p" becomes invalid.  So we need to copy','line_number':3546,'multiline':False]
['text':' "p" first then free fnames[i].','line_number':3547,'multiline':False]
['text':'
 * Add extension to file name - change path/fo.o.h to path/fo.o.h.ext or
 * fo_o_h.ext for MSDOS or when shortname option set.
 *
 * Assumed that fname is a valid name found in the filesystem we assure that
 * the return value is a different name and ends in 'ext'.
 * "ext" MUST be at most 4 characters long if it starts with a dot, 3
 * characters otherwise.
 * Space for the returned name is allocated, must be freed later.
 * Returns NULL when out of memory.
 ','line_number':3556,'multiline':True]
['text':' may prepend a '.' to file name','line_number':3571,'multiline':False]
['text':' use 8.3 file name','line_number':3579,'multiline':False]
['text':' may prepend a '.' to file name','line_number':3582,'multiline':False]
['text':'
     * If there is no file name we must get the name of the current directory
     * (we need the full path in case :cd is used).
     ','line_number':3592,'multiline':True]
['text':' nothing to prepend a dot to','line_number':3612,'multiline':False]
['text':' we do not need versions here','line_number':3622,'multiline':False]
['text':'
     * search backwards until we hit a '/', '\' or ':' replacing all '.'
     * by '_' for MSDOS or when shortname option set and ext starts with a dot.
     * Then truncate what is after the '/', '\' or ':' to 8 characters for
     * MSDOS and 26 characters for AMIGA, a lot more for UNIX.
     ','line_number':3626,'multiline':True]
['text':' replace '.' by '_'','line_number':3635,'multiline':False]
['text':' the file name has at most BASENAMELEN characters.','line_number':3644,'multiline':False]
['text':'
     * For 8.3 file names we may have to reduce the length.
     ','line_number':3650,'multiline':True]
['text':'
	 * If there is no file name, or the file name ends in '/', and the
	 * extension starts with '.', put a '_' before the dot, because just
	 * ".ext" is invalid.
	 ','line_number':3655,'multiline':True]
['text':'
	 * If the extension starts with '.', truncate the base name at 8
	 * characters
	 ','line_number':3666,'multiline':True]
['text':'
	 * If the extension doesn't start with '.', and the file name
	 * doesn't have an extension yet, append a '.'
	 ','line_number':3678,'multiline':True]
['text':'
	 * If the extension doesn't start with '.', and there already is an
	 * extension, it may need to be truncated
	 ','line_number':3684,'multiline':True]
['text':'
     * If there is no file name, and the extension starts with '.', put a
     * '_' before the dot, because just ".ext" may be invalid if it's on a
     * FAT partition, and on HPFS it doesn't matter.
     ','line_number':3692,'multiline':True]
['text':'
     * Append the extension.
     * ext can start with '.' and cannot exceed 3 more characters.
     ','line_number':3701,'multiline':True]
['text':'
     * Prepend the dot.
     ','line_number':3707,'multiline':True]
['text':'
     * Check that, after appending the extension, the file name is really
     * different.
     ','line_number':3716,'multiline':True]
['text':' we search for a character that can be replaced by '_'','line_number':3722,'multiline':False]
['text':' fname was "________.<ext>", how tricky!','line_number':3731,'multiline':False]
['text':'
 * Like fgets(), but if the file line is too long, it is truncated and the
 * rest of the line is thrown away.  Returns TRUE for end-of-file.
 * If the line is truncated then buf[size - 2] will not be NUL.
 ','line_number':3737,'multiline':True]
['text':' Truncate the line','line_number':3753,'multiline':False]
['text':' Now throw away the rest of the line:','line_number':3755,'multiline':False]
['text':'
 * rename() only works if both files are on the same file system, this
 * function will (attempts to?) copy the file across if rename fails -- webb
 * Return -1 for failure, 0 for success.
 ','line_number':3765,'multiline':True]
['text':' ACL from original file','line_number':3784,'multiline':False]
['text':'
     * When the names are identical, there is nothing to do.  When they refer
     * to the same file (ignoring case and slash/backslash differences) but
     * the file name differs we need to go through a temp file.
     ','line_number':3788,'multiline':True]
['text':'
     * Fail if the "from" file doesn't exist.  Avoids that "to" is deleted.
     ','line_number':3801,'multiline':True]
['text':' It's possible for the source and destination to be the same file.','line_number':3811,'multiline':False]
['text':' This happens when "from" and "to" differ in case and are on a FAT32','line_number':3812,'multiline':False]
['text':' filesystem.  In that case go through a temp file name.','line_number':3813,'multiline':False]
['text':' It's possible for the source and destination to be the same file.','line_number':3824,'multiline':False]
['text':' In that case go through a temp file name.  This makes rename("foo",','line_number':3825,'multiline':False]
['text':' "./foo") a no-op (in a complicated way).','line_number':3826,'multiline':False]
['text':'
	 * Find a name that doesn't exist and is in the same directory.
	 * Rename "from" to "tempname" and then rename "tempname" to "to".
	 ','line_number':3840,'multiline':True]
['text':' Strange, the second step failed.  Try moving the','line_number':3856,'multiline':False]
['text':' file back and return failure.','line_number':3857,'multiline':False]
['text':' If it fails for one temp name it will most likely fail','line_number':3861,'multiline':False]
['text':' for any temp name, give up.','line_number':3862,'multiline':False]
['text':'
     * Delete the "to" file, this is required on some systems to make the
     * mch_rename() work, on other systems it makes sure that we don't have
     * two files when the mch_rename() fails.
     ','line_number':3869,'multiline':True]
['text':'
     * With MSDOS-compatible filesystems (crossdos, messydos) it is possible
     * that the name of the "to" file is the same as the "from" file, even
     * though the names are different. To avoid the chance of accidentally
     * deleting the "from" file (horror!) we lock it during the remove.
     *
     * When used for making a backup before writing the file: This should not
     * happen with ":w", because startscript() should detect this problem and
     * set buf->b_shortname, causing modname() to return a correct ".bak" file
     * name.  This problem does exist with ":w filename", but then the
     * original file will be somewhere else so the backup isn't really
     * important. If autoscripting is off the rename may fail.
     ','line_number':3876,'multiline':True]
['text':'
     * First try a normal rename, return if it works.
     ','line_number':3897,'multiline':True]
['text':'
     * Rename() failed, try copying the file.
     ','line_number':3903,'multiline':True]
['text':' For systems that support ACL: get the ACL from the original file.','line_number':3908,'multiline':False]
['text':' Create the new file with same permissions as the original.','line_number':3920,'multiline':False]
['text':' for Unix mch_open() already set the permission','line_number':3959,'multiline':False]
['text':'
 * Check if any not hidden buffer has been changed.
 * Postpone the check if there are characters in the stuff buffer, a global
 * command is being executed, a mapping is being executed or an autocommand is
 * busy.
 * Returns TRUE if some message was written (screen should be redrawn and
 * cursor positioned).
 ','line_number':3980,'multiline':True]
['text':' called for GUI focus event','line_number':3990,'multiline':False]
['text':' Don't check timestamps while system() or another low-level function may','line_number':3996,'multiline':False]
['text':' cause us to lose and gain focus.','line_number':3997,'multiline':False]
['text':' Avoid doing a check twice.  The OK/Reload dialog can cause a focus','line_number':4001,'multiline':False]
['text':' event and we would keep on checking if the file is steadily growing.','line_number':4002,'multiline':False]
['text':' Do check again after typing something.','line_number':4003,'multiline':False]
['text':' check later','line_number':4012,'multiline':False]
['text':' Only check buffers in a window.','line_number':4020,'multiline':False]
['text':' Autocommands have removed the buffer, start at the','line_number':4031,'multiline':False]
['text':' first one again.','line_number':4032,'multiline':False]
['text':' make sure msg isn't overwritten','line_number':4042,'multiline':False]
['text':'
 * Move all the lines from buffer "frombuf" to buffer "tobuf".
 * Return OK or FAIL.  When FAIL "tobuf" is incomplete and/or "frombuf" is not
 * empty.
 ','line_number':4050,'multiline':True]
['text':' Copy the lines in "frombuf" to "tobuf".','line_number':4063,'multiline':False]
['text':' Delete all the lines in "frombuf".','line_number':4077,'multiline':False]
['text':' Oops!  We could try putting back the saved lines, but that','line_number':4084,'multiline':False]
['text':' might fail again...','line_number':4085,'multiline':False]
['text':'
 * Check if buffer "buf" has been changed.
 * Also check if the file for a new buffer unexpectedly appeared.
 * return 1 if a changed buffer was found.
 * return 2 if a message has been displayed.
 * return 0 otherwise.
 ','line_number':4095,'multiline':True]
['text':' called for GUI focus event','line_number':4105,'multiline':False]
['text':' If there is no file name, the buffer is not loaded, 'buftype' is','line_number':4138,'multiline':False]
['text':' set, we are in the middle of a save or being called recursively: ignore','line_number':4139,'multiline':False]
['text':' this buffer.','line_number':4140,'multiline':False]
['text':' set b_mtime to stop further warnings (e.g., when executing','line_number':4171,'multiline':False]
['text':' FileChangedShell autocmd)','line_number':4172,'multiline':False]
['text':' Check the file again later to see if it re-appears.','line_number':4175,'multiline':False]
['text':' Don't do anything for a directory.  Might contain the file','line_number':4183,'multiline':False]
['text':' explorer.','line_number':4184,'multiline':False]
['text':'
	 * If 'autoread' is set, the buffer has no changes and the file still
	 * exists, reload the buffer.  Use the buffer-local option value if it
	 * was set, the global option value otherwise.
	 ','line_number':4188,'multiline':True]
['text':'
	     * Check if the file contents really changed to avoid giving a
	     * warning when only the timestamp was set (e.g., checked out of
	     * CVS).  Always warn when the buffer was changed.
	     ','line_number':4202,'multiline':True]
['text':'
	     * Only give the warning if there are no FileChangedShell
	     * autocommands.
	     * Avoid being called recursively by setting "busy".
	     ','line_number':4214,'multiline':True]
['text':' Only give the message once.','line_number':4249,'multiline':False]
['text':' Only timestamp changed, store it to avoid a warning','line_number':4276,'multiline':False]
['text':' in check_mtime() later.','line_number':4277,'multiline':False]
['text':' Set warningmsg here, before the unimportant and output-specific','line_number':4307,'multiline':False]
['text':' mesg2 has been appended.','line_number':4308,'multiline':False]
['text':' give the user some time to think about it','line_number':4361,'multiline':False]
['text':' don't redraw and erase the message','line_number':4364,'multiline':False]
['text':' Reload the buffer.','line_number':4378,'multiline':False]
['text':' Any existing undo file is unusable, write it now.','line_number':4386,'multiline':False]
['text':' Trigger FileChangedShell when the file was changed in any way.','line_number':4395,'multiline':False]
['text':' restore this in case an autocommand has set it; it would break','line_number':4400,'multiline':False]
['text':' 'mousefocus'','line_number':4401,'multiline':False]
['text':'
 * Reload a buffer that is already loaded.
 * Used when the file was changed outside of Vim.
 * "orig_mode" is buf->b_orig_mode before the need for reloading was detected.
 * buf->b_orig_mode may have been reset already.
 ','line_number':4408,'multiline':True]
['text':' Set curwin/curbuf for "buf" and save some things.','line_number':4428,'multiline':False]
['text':' Failed to find a window for "buf", it is dangerous to continue,','line_number':4432,'multiline':False]
['text':' better bail out.','line_number':4433,'multiline':False]
['text':' Unless reload_options is set, we only want to read the text from the','line_number':4437,'multiline':False]
['text':' file, not reset the syntax highlighting, clear marks, diff status, etc.','line_number':4438,'multiline':False]
['text':' Force the fileformat and encoding to be the same.','line_number':4439,'multiline':False]
['text':' Save all the text, so that the reload can be undone.','line_number':4452,'multiline':False]
['text':' Sync first so that this is a separate undo-able action.','line_number':4453,'multiline':False]
['text':'
	 * To behave like when a new file is edited (matters for
	 * BufReadPost autocommands) we first need to delete the current
	 * buffer contents.  But if reading the file fails we should keep
	 * the old contents.  Can't use memory only, the file might be
	 * too big.  Use a hidden buffer to move the buffer contents to.
	 ','line_number':4459,'multiline':True]
['text':' Allocate a buffer without putting it in the buffer list.','line_number':4470,'multiline':False]
['text':' Open the memline.','line_number':4475,'multiline':False]
['text':' check for RO again','line_number':4492,'multiline':False]
['text':' don't detect 'filetype'','line_number':4493,'multiline':False]
['text':' Put the text back from the save buffer.  First','line_number':4504,'multiline':False]
['text':' delete any lines that readfile() added.','line_number':4505,'multiline':False]
['text':' "buf" still valid','line_number':4512,'multiline':False]
['text':' Mark the buffer as unmodified and free undo info.','line_number':4514,'multiline':False]
['text':' Mark all undo states as changed.','line_number':4523,'multiline':False]
['text':' Invalidate diff info if necessary.','line_number':4534,'multiline':False]
['text':' Restore the topline and cursor position and check it (lines may','line_number':4538,'multiline':False]
['text':' have been removed).','line_number':4539,'multiline':False]
['text':' Update folds unless they are defined manually.','line_number':4553,'multiline':False]
['text':' If the mode didn't change and 'readonly' was set, keep the old','line_number':4560,'multiline':False]
['text':' value; the user probably used the ":view" command.  But don't','line_number':4561,'multiline':False]
['text':' reset it, might have had a read error.','line_number':4562,'multiline':False]
['text':' Modelines must override settings done by autocommands.','line_number':4566,'multiline':False]
['text':' restore curwin/curbuf and a few other things','line_number':4570,'multiline':False]
['text':' Careful: autocommands may have made "buf" invalid!','line_number':4572,'multiline':False]
['text':'
 * Adjust the line with missing eol, used for the next write.
 * Used for do_filter(), when the input lines for the filter are deleted.
 ','line_number':4592,'multiline':True]
['text':' only if there is a missing eol','line_number':4599,'multiline':False]
['text':' Subfuncions for readdirex()','line_number':4603,'multiline':False]
['text':' Copy user bits to group/other.','line_number':4629,'multiline':False]
['text':' unknown reparse point type','line_number':4654,'multiline':False]
['text':' Convert FILETIME to unix time.','line_number':4689,'multiline':False]
['text':' non-perfect check for overflow','line_number':4756,'multiline':False]
['text':'
 * Core part of "readdir()" and "readdirex()" function.
 * Retrieve the list of files/directories of "path" into "gap".
 * If "withattr" is TRUE, retrieve the names and their attributes.
 * If "withattr" is FALSE, retrieve the names only.
 * Return OK for success, FAIL for failure.
 ','line_number':4846,'multiline':True]
['text':' UTF-16 name, NULL when not used.','line_number':4869,'multiline':False]
['text':' MSWIN','line_number':4973,'multiline':False]
['text':' MSWIN','line_number':5039,'multiline':False]
['text':'
 * Delete "name" and everything in it, recursively.
 * return 0 for success, -1 if some file was not deleted.
 ','line_number':5061,'multiline':True]
['text':' A symbolic link to a directory itself is deleted, not the directory it','line_number':5073,'multiline':False]
['text':' points to.','line_number':5074,'multiline':False]
['text':' Remember the failure but continue deleting any further','line_number':5093,'multiline':False]
['text':' entries.','line_number':5094,'multiline':False]
['text':' Temp filename counter.','line_number':5113,'multiline':False]
['text':'
 * Open temporary directory and take file lock to prevent
 * to be auto-cleaned.
 ','line_number':5116,'multiline':True]
['text':'
 * Close temporary directory - it automatically release file lock.
 ','line_number':5136,'multiline':True]
['text':'
 * Delete the temp directory and all files it contains.
 ','line_number':5150,'multiline':True]
['text':' remove the trailing path separator','line_number':5162,'multiline':False]
['text':'
 * Directory "tempdir" was created.  Expand this name to a full path and put
 * it in "vim_tempdir".  This avoids that using ":cd" would confuse us.
 * "tempdir" must be no longer than MAXPATHL.
 ','line_number':5168,'multiline':True]
['text':'
 * vim_tempname(): Return a unique name that can be used for a temp file.
 *
 * The temp file is NOT guaranteed to be created.  If "keep" is FALSE it is
 * guaranteed to NOT be created.
 *
 * The returned pointer is to allocated memory.
 * The returned pointer is NULL if no valid name was found.
 ','line_number':5193,'multiline':True]
['text':' char to use in the name instead of '?'','line_number':5204,'multiline':False]
['text':' use tmpnam()','line_number':5208,'multiline':False]
['text':'
     * This will create a directory for private use by this instance of Vim.
     * This is done once, and the same directory is used for all temp files.
     * This method avoids security problems because of symlink attacks et al.
     * It's also a bit faster, because we only need to check for an existing
     * file when creating the directory and not for each temp file.
     ','line_number':5222,'multiline':True]
['text':'
	 * Try the entries in TEMPDIRNAMES to create the temp directory.
	 ','line_number':5231,'multiline':True]
['text':' Expand $TMP, leave room for "/v1100000/999999999".','line_number':5242,'multiline':False]
['text':' Skip the directory check if the expansion fails.','line_number':5243,'multiline':False]
['text':' directory exists','line_number':5247,'multiline':False]
['text':' Make sure the umask doesn't remove the executable bit.','line_number':5253,'multiline':False]
['text':' "repl" has been reported to use "177".','line_number':5254,'multiline':False]
['text':' Leave room for filename','line_number':5257,'multiline':False]
['text':' Get an arbitrary number of up to 6 digits.  When it's','line_number':5266,'multiline':False]
['text':' unlikely that it already exists it will be faster,','line_number':5267,'multiline':False]
['text':' otherwise it doesn't matter.  The use of mkdir() avoids any','line_number':5268,'multiline':False]
['text':' security problems because of the predictable number.','line_number':5269,'multiline':False]
['text':' Try up to 10000 different values until we find a name that','line_number':5273,'multiline':False]
['text':' doesn't exist.','line_number':5274,'multiline':False]
['text':' If mkdir() does not set errno to EEXIST, check for','line_number':5284,'multiline':False]
['text':' existing file here.  There is a race condition then,','line_number':5285,'multiline':False]
['text':' although it's fail-safe.','line_number':5286,'multiline':False]
['text':' Make sure the umask doesn't remove the executable bit.','line_number':5291,'multiline':False]
['text':' "repl" has been reported to use "177".','line_number':5292,'multiline':False]
['text':' If the mkdir() didn't fail because the file/dir exists,','line_number':5305,'multiline':False]
['text':' we probably can't create any dir here, try another','line_number':5306,'multiline':False]
['text':' place.','line_number':5307,'multiline':False]
['text':' HAVE_MKDTEMP','line_number':5312,'multiline':False]
['text':' There is no need to check if the file exists, because we own the','line_number':5321,'multiline':False]
['text':' directory and nobody else creates a file in it.','line_number':5322,'multiline':False]
['text':' TEMPDIRNAMES','line_number':5329,'multiline':False]
['text':' GetTempPathW() failed, use current dir','line_number':5343,'multiline':False]
['text':' randomize the name to avoid collisions','line_number':5349,'multiline':False]
['text':' GetTempFileName() will create the file, we don't want that','line_number':5356,'multiline':False]
['text':' Backslashes in a temp file name cause problems when filtering with','line_number':5359,'multiline':False]
['text':' "sh".  NOTE: This also checks 'shellcmdflag' to help those people who','line_number':5360,'multiline':False]
['text':' didn't set 'shellslash' but only if not using PowerShell.','line_number':5361,'multiline':False]
['text':' MSWIN','line_number':5372,'multiline':False]
['text':' tmpnam() will make its own name','line_number':5377,'multiline':False]
['text':' mktemp() is not working on VMS.  It seems to be','line_number':5385,'multiline':False]
['text':' a do-nothing function. Therefore we use tempnam().','line_number':5386,'multiline':False]
['text':' VMS will use '.LIS' if we don't explicitly specify an extension,','line_number':5391,'multiline':False]
['text':' and VIM will then be unable to find the file later','line_number':5392,'multiline':False]
['text':' MSWIN','line_number':5409,'multiline':False]
['text':' TEMPDIRNAMES','line_number':5410,'multiline':False]
['text':'
 * Convert all backslashes in fname to forward slashes in-place, unless when
 * it looks like a URL.
 ','line_number':5414,'multiline':True]
['text':' The Big5 encoding can have '\' in the trail byte.','line_number':5426,'multiline':False]
['text':'
 * Try matching a filename with a "pattern" ("prog" is NULL), or use the
 * precompiled regprog "prog" ("pattern" is NULL).  That avoids calling
 * vim_regcomp() often.
 * Used for autocommands and 'wildignore'.
 * Returns TRUE if there is a match, FALSE otherwise.
 ','line_number':5434,'multiline':True]
['text':' pattern to match with','line_number':5443,'multiline':False]
['text':' pre-compiled regprog or NULL','line_number':5444,'multiline':False]
['text':' full path of file name','line_number':5445,'multiline':False]
['text':' short file name or NULL','line_number':5446,'multiline':False]
['text':' tail of path','line_number':5447,'multiline':False]
['text':' allow matching with dir','line_number':5448,'multiline':False]
['text':' ignore case if 'fileignorecase' is set','line_number':5453,'multiline':False]
['text':'
     * Try for a match with the pattern with:
     * 1. the full file name, when the pattern has a '/'.
     * 2. the short file name, when the pattern has a '/'.
     * 3. the tail of the file name, when the pattern has no '/'.
     ','line_number':5459,'multiline':True]
['text':'
 * Return TRUE if a file matches with a pattern in "list".
 * "list" is a comma-separated list of patterns, like 'wildignore'.
 * "sfname" is the short file name or NULL, "ffname" the long file name.
 ','line_number':5480,'multiline':True]
['text':' try all patterns in 'wildignore'','line_number':5497,'multiline':False]
['text':'
 * Convert the given pattern "pat" which has shell style wildcards in it, into
 * a regular expression, and return the result in allocated memory.  If there
 * is a directory path separator to be matched, then TRUE is put in
 * allow_dirs, otherwise FALSE is put there -- webb.
 * Handle backslashes before special characters, like "\*" and "\ ".
 *
 * Returns NULL when out of memory.
 ','line_number':5514,'multiline':True]
['text':' first char after pattern or NULL','line_number':5526,'multiline':False]
['text':' Result passed back out in here','line_number':5527,'multiline':False]
['text':' Don't use a backward slash as pathsep','line_number':5528,'multiline':False]
['text':' '^' at start, '$' at end','line_number':5530,'multiline':False]
['text':' extra backslash','line_number':5553,'multiline':False]
['text':' could become "[\/]"','line_number':5558,'multiline':False]
['text':' "**" matches like "*"','line_number':5596,'multiline':False]
['text':' translate:','line_number':5613,'multiline':False]
['text':' "\x" to "\\x"  e.g., "dir\file"','line_number':5614,'multiline':False]
['text':' "\*" to "\\.*" e.g., "dir\*.c"','line_number':5615,'multiline':False]
['text':' "\?" to "\\."  e.g., "dir\??.c"','line_number':5616,'multiline':False]
['text':' "\+" to "\+"   e.g., "fileX\+.c"','line_number':5617,'multiline':False]
['text':' Undo escaping from ExpandEscape():','line_number':5631,'multiline':False]
['text':' foo\?bar -> foo?bar','line_number':5632,'multiline':False]
['text':' foo\%bar -> foo%bar','line_number':5633,'multiline':False]
['text':' foo\,bar -> foo,bar','line_number':5634,'multiline':False]
['text':' foo\ bar -> foo bar','line_number':5635,'multiline':False]
['text':' Don't unescape \, * and others that are also special in a','line_number':5636,'multiline':False]
['text':' regexp.','line_number':5637,'multiline':False]
['text':' An escaped { must be unescaped since we use magic not','line_number':5638,'multiline':False]
['text':' verymagic.  Use "\\\{n,m\}"" to get "\{n,m}".','line_number':5639,'multiline':False]
['text':'
 * Version of read() that retries when interrupted by EINTR (possibly
 * by a SIGWINCH).
 ','line_number':5721,'multiline':True]
['text':'
 * Version of write() that retries when interrupted by EINTR (possibly
 * by a SIGWINCH).
 ','line_number':5739,'multiline':True]
['text':' Repeat the write() so long it didn't fail, other than being interrupted','line_number':5749,'multiline':False]
['text':' by a signal.','line_number':5750,'multiline':False]
