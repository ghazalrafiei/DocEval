['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]
['text':'
 * findfile.c: Search for files in directories listed in 'path'
 ','line_number':10,'multiline':True]
['text':'
 * File searching functions for 'path', 'tags' and 'cdpath' options.
 * External visible functions:
 * vim_findfile_init()		creates/initialises the search context
 * vim_findfile_free_visited()	free list of visited files/dirs of search
 *				context
 * vim_findfile()		find a file in the search context
 * vim_findfile_cleanup()	cleanup/free search context created by
 *				vim_findfile_init()
 *
 * All static functions and variables start with 'ff_'
 *
 * In general it works like this:
 * First you create yourself a search context by calling vim_findfile_init().
 * It is possible to give a search context from a previous call to
 * vim_findfile_init(), so it can be reused. After this you call vim_findfile()
 * until you are satisfied with the result or it returns NULL. On every call it
 * returns the next file which matches the conditions given to
 * vim_findfile_init(). If it doesn't find a next file it returns NULL.
 *
 * It is possible to call vim_findfile_init() again to reinitialise your search
 * with some new parameters. Don't forget to pass your old search context to
 * it, so it can reuse it and especially reuse the list of already visited
 * directories. If you want to delete the list of already visited directories
 * simply call vim_findfile_free_visited().
 *
 * When you are done call vim_findfile_cleanup() to free the search context.
 *
 * The function vim_findfile_init() has a long comment, which describes the
 * needed parameters.
 *
 *
 *
 * ATTENTION:
 * ==========
 *	Also we use an allocated search context here, these functions are NOT
 *	thread-safe!
 *
 *	To minimize parameter passing (or because I'm to lazy), only the
 *	external visible functions get a search context as a parameter. This is
 *	then assigned to a static global, which is used throughout the local
 *	functions.
 ','line_number':16,'multiline':True]
['text':'
 * type for the directory search stack
 ','line_number':60,'multiline':True]
['text':' the fix part (no wildcards) and the part containing the wildcards','line_number':67,'multiline':False]
['text':' of the search path','line_number':68,'multiline':False]
['text':' files/dirs found in the above directory, matched by the first wildcard','line_number':72,'multiline':False]
['text':' of wc_part','line_number':73,'multiline':False]
['text':' needed for partly handled dirs','line_number':76,'multiline':False]
['text':' to store status of partly handled directories','line_number':78,'multiline':False]
['text':' 0: we work on this directory for the first time','line_number':79,'multiline':False]
['text':' 1: this directory was partly searched in an earlier step','line_number':80,'multiline':False]
['text':' How deep are we in the directory tree?','line_number':83,'multiline':False]
['text':' Counts backward from value of level parameter to vim_findfile_init','line_number':84,'multiline':False]
['text':' Did we already expand '**' to an empty string?','line_number':87,'multiline':False]
['text':'
 * type for already visited directories or files.
 ','line_number':91,'multiline':True]
['text':' Visited directories are different if the wildcard string are','line_number':98,'multiline':False]
['text':' different. So we have to save it.','line_number':99,'multiline':False]
['text':' for unix use inode etc for comparison (needed because of links), else','line_number':102,'multiline':False]
['text':' use filename.','line_number':103,'multiline':False]
['text':' ffv_dev and ffv_ino were set','line_number':105,'multiline':False]
['text':' device number','line_number':106,'multiline':False]
['text':' inode number','line_number':107,'multiline':False]
['text':' The memory for this struct is allocated according to the length of','line_number':109,'multiline':False]
['text':' ffv_fname.','line_number':110,'multiline':False]
['text':' actually longer','line_number':111,'multiline':False]
['text':'
 * We might have to manage several visited lists during a search.
 * This is especially needed for the tags option. If tags is set to:
 *      "./++/tags,./++/TAGS,++/tags"  (replace + with *)
 * So we have to do 3 searches:
 *   1) search from the current files directory downward for the file "tags"
 *   2) search from the current files directory downward for the file "TAGS"
 *   3) search from Vims current directory downwards for the file "tags"
 * As you can see, the first and the third search are for the same file, so for
 * the third search we can use the visited list of the first search. For the
 * second search we must start from a empty visited list.
 * The struct ff_visited_list_hdr is used to manage a linked list of already
 * visited lists.
 ','line_number':114,'multiline':True]
['text':' the filename the attached visited list is for','line_number':132,'multiline':False]
['text':'
 * '**' can be expanded to several directory levels.
 * Set the default maximum depth.
 ','line_number':140,'multiline':True]
['text':'
 * The search context:
 *   ffsc_stack_ptr:	the stack for the dirs to search
 *   ffsc_visited_list: the currently active visited list
 *   ffsc_dir_visited_list: the currently active visited list for search dirs
 *   ffsc_visited_lists_list: the list of all visited lists
 *   ffsc_dir_visited_lists_list: the list of all visited lists for search dirs
 *   ffsc_file_to_search:     the file to search for
 *   ffsc_start_dir:	the starting directory, if search path was relative
 *   ffsc_fix_path:	the fix part of the given path (without wildcards)
 *			Needed for upward search.
 *   ffsc_wc_path:	the part of the given path containing wildcards
 *   ffsc_level:	how many levels of dirs to search downwards
 *   ffsc_stopdirs_v:	array of stop directories for upward search
 *   ffsc_find_what:	FINDFILE_BOTH, FINDFILE_DIR or FINDFILE_FILE
 *   ffsc_tagfile:	searching for tags file, don't use 'suffixesadd'
 ','line_number':146,'multiline':True]
['text':' locally needed functions','line_number':180,'multiline':False]
['text':' used for expanding filenames','line_number':194,'multiline':False]
['text':'
 * if someone likes findfirst/findnext, here are the functions
 * NOT TESTED!!
 ','line_number':197,'multiline':True]
['text':'
 * Initialization routine for vim_findfile().
 *
 * Returns the newly allocated search context or NULL if an error occurred.
 *
 * Don't forget to clean up by calling vim_findfile_cleanup() if you are done
 * with the search context.
 *
 * Find the file 'filename' in the directory 'path'.
 * The parameter 'path' may contain wildcards. If so only search 'level'
 * directories deep. The parameter 'level' is the absolute maximum and is
 * not related to restricts given to the '**' wildcard. If 'level' is 100
 * and you use '**200' vim_findfile() will stop after 100 levels.
 *
 * 'filename' cannot contain wildcards!  It is used as-is, no backslashes to
 * escape special characters.
 *
 * If 'stopdirs' is not NULL and nothing is found downward, the search is
 * restarted on the next higher directory level. This is repeated until the
 * start-directory of a search is contained in 'stopdirs'. 'stopdirs' has the
 * format ";*<dirname>*\(;<dirname>\)*;\=$".
 *
 * If the 'path' is relative, the starting dir for the search is either VIM's
 * current dir or if the path starts with "./" the current files dir.
 * If the 'path' is absolute, the starting dir is that part of the path before
 * the first wildcard.
 *
 * Upward search is only done on the starting dir.
 *
 * If 'free_visited' is TRUE the list of already visited files/directories is
 * cleared. Set this to FALSE if you just want to search from another
 * directory, but want to be sure that no directory from a previous search is
 * searched again. This is useful if you search for a file at different places.
 * The list of visited files/dirs can also be cleared with the function
 * vim_findfile_free_visited().
 *
 * Set the parameter 'find_what' to FINDFILE_DIR if you want to search for
 * directories only, FINDFILE_FILE for files only, FINDFILE_BOTH for both.
 *
 * A search context returned by a previous call to vim_findfile_init() can be
 * passed in the parameter "search_ctx_arg".  This context is reused and
 * reinitialized with the new parameters.  The list of already visited
 * directories from this context is only deleted if the parameter
 * "free_visited" is true.  Be aware that the passed "search_ctx_arg" is freed
 * if the reinitialization fails.
 *
 * If you don't have a search context from a previous call "search_ctx_arg"
 * must be NULL.
 *
 * This function silently ignores a few errors, vim_findfile() will have
 * limited functionality then.
 ','line_number':230,'multiline':True]
['text':' expanding names of tags files','line_number':291,'multiline':False]
['text':' file name to use for "."','line_number':292,'multiline':False]
['text':' If a search context is given by the caller, reuse it, else allocate a','line_number':298,'multiline':False]
['text':' new one.','line_number':299,'multiline':False]
['text':' clear the search context, but NOT the visited lists','line_number':311,'multiline':False]
['text':' clear visited list if wanted','line_number':314,'multiline':False]
['text':' Reuse old visited lists. Get the visited list for the given','line_number':319,'multiline':False]
['text':' filename. If no list for the current filename exists, creates a new','line_number':320,'multiline':False]
['text':' one.','line_number':321,'multiline':False]
['text':' Store information on starting dir now if path is relative.','line_number':339,'multiline':False]
['text':' If path is absolute, we do that later.','line_number':340,'multiline':False]
['text':' Make the start dir an absolute path name.','line_number':350,'multiline':False]
['text':' "c:dir" needs "c:" to be expanded, otherwise use current dir','line_number':364,'multiline':False]
['text':' A path that starts with "/dir" is relative to the drive, not to the','line_number':386,'multiline':False]
['text':' directory (but not for "//machine/dir").  Only use the drive name.','line_number':387,'multiline':False]
['text':'
     * If stopdirs are given, split them into an array of pointers.
     * If this fails (mem allocation), there is no upward search at all or a
     * stop directory is not recognized -> continue silently.
     * If stopdirs just contains a ";" or is empty,
     * search_ctx->ffsc_stopdirs_v will only contain a  NULL pointer. This
     * is handled as unlimited upward search.  See function
     * ff_path_in_stoplist() for details.
     ','line_number':395,'multiline':True]
['text':' ignore, keep what we have and continue','line_number':428,'multiline':False]
['text':' this might be "", which means ascent till top','line_number':438,'multiline':False]
['text':' of directory tree.','line_number':439,'multiline':False]
['text':'
     * split into:
     *  -fix path
     *  -wildcard_stuff (might be NULL)
     ','line_number':452,'multiline':True]
['text':' save the fix part of the path','line_number':464,'multiline':False]
['text':'
	 * copy wc_path and add restricts to the '**' wildcard.
	 * The octet after a '**' is used as a (binary) counter.
	 * So '**3' is transposed to '**^C' ('^C' is ASCII value 3)
	 * or '**76' is transposed to '**N'( 'N' is ASCII value 76).
	 * If no restrict is given after '**' the default is used.
	 * Due to this technique the path looks awful if you print it as a
	 * string.
	 ','line_number':467,'multiline':True]
['text':' restrict is 0 -> remove already added '**'','line_number':493,'multiline':False]
['text':' store the fix part as startdir.','line_number':518,'multiline':False]
['text':' This is needed if the parameter path is fully qualified.','line_number':519,'multiline':False]
['text':' create an absolute path','line_number':526,'multiline':False]
['text':' do not add '..' to the path and start upwards searching','line_number':556,'multiline':False]
['text':'
     * We clear the search context now!
     * Even when the caller gave us a (perhaps valid) context we free it here,
     * as we might have already destroyed it.
     ','line_number':611,'multiline':True]
['text':'
 * Get the stopdir string.  Check that ';' is not escaped.
 ','line_number':620,'multiline':True]
['text':' Overwrite the escape char,','line_number':632,'multiline':False]
['text':' use STRLEN(r_ptr) to move the trailing '\0'.','line_number':633,'multiline':False]
['text':'
 * Clean up the given search context. Can handle a NULL pointer.
 ','line_number':649,'multiline':True]
['text':'
 * Find a file in a search context.
 * The search context was created with vim_findfile_init() above.
 * Return a pointer to an allocated file name or NULL if nothing found.
 * To get all matching files call this function until you get NULL.
 *
 * If the passed search_context is NULL, NULL is returned.
 *
 * The search algorithm is depth first. To change this replace the
 * stack with a list (don't forget to leave partly searched directories on the
 * top of the list).
 ','line_number':663,'multiline':True]
['text':'
     * filepath is used as buffer for various actions and as the storage to
     * return a found filename.
     ','line_number':693,'multiline':True]
['text':' store the end of the start dir -- needed for upward search','line_number':700,'multiline':False]
['text':' upward search loop','line_number':705,'multiline':False]
['text':' downward search loop','line_number':708,'multiline':False]
['text':' check if user wants to stop the search','line_number':711,'multiline':False]
['text':' get directory to work on from stack','line_number':716,'multiline':False]
['text':'
	     * TODO: decide if we leave this test in
	     *
	     * GOOD: don't search a directory(-tree) twice.
	     * BAD:  - check linked list for every new directory entered.
	     *       - check for double files also done below
	     *
	     * Here we check if we already searched this directory.
	     * We already searched a directory if:
	     * 1) The directory is the same.
	     * 2) We would use the same wildcard string.
	     *
	     * Good if you have links on same directory via several ways
	     *  or you have selfreferences in directories (e.g. SuSE Linux 6.3:
	     *  /etc/rc.d/init.d is linked to /etc/rc.d -> endless loop)
	     *
	     * This check is only needed for directories we work on for the
	     * first time (hence stackp->ff_filearray == NULL)
	     ','line_number':721,'multiline':True]
['text':' don't overwrite this either','line_number':751,'multiline':False]
['text':' don't overwrite this either','line_number':765,'multiline':False]
['text':' check depth','line_number':771,'multiline':False]
['text':'
	     * If no filearray till now expand wildcards
	     * The function expand_wildcards() can handle an array of paths
	     * and all possible expands are returned in one array. We use this
	     * to handle the expansion of '**' into an empty string.
	     ','line_number':780,'multiline':True]
['text':' we use filepath to build the path expand_wildcards() should','line_number':790,'multiline':False]
['text':' expand.','line_number':791,'multiline':False]
['text':' if we have a start dir copy it in','line_number':795,'multiline':False]
['text':' append the fix part of the search path','line_number':811,'multiline':False]
['text':' pointer to the restrict byte','line_number':830,'multiline':False]
['text':' The restrict byte is not a character!','line_number':831,'multiline':False]
['text':' remove '**<numb> from wildcards','line_number':848,'multiline':False]
['text':' if not done before, expand '**' to empty','line_number':856,'multiline':False]
['text':'
		     * Here we copy until the next path separator or the end of
		     * the path. If we stop at a path separator, there is
		     * still something else left. This is handled below by
		     * pushing every directory returned from expand_wildcards()
		     * on the stack again for further search.
		     ','line_number':862,'multiline':True]
['text':'
		 * Expand wildcards like "*" and "$VAR".
		 * If the path is a URL don't try this.
		 ','line_number':884,'multiline':True]
['text':' Add EW_NOTWILD because the expanded path may contain','line_number':899,'multiline':False]
['text':' wildcard characters that are to be taken literally.','line_number':900,'multiline':False]
['text':' This is a bit of a hack.','line_number':901,'multiline':False]
['text':' this is the first time we work on this directory','line_number':916,'multiline':False]
['text':'
		     * We don't have further wildcards to expand, so we have to
		     * check for the final file now.
		     ','line_number':919,'multiline':True]
['text':' not a directory','line_number':928,'multiline':False]
['text':' prepare the filename to be checked for existence','line_number':930,'multiline':False]
['text':' below','line_number':931,'multiline':False]
['text':'
			 * Try without extra suffix and then with suffixes
			 * from 'suffixesadd'.
			 ','line_number':946,'multiline':True]
['text':' if file exists and we didn't already find it','line_number':957,'multiline':False]
['text':' don't overwrite this either','line_number':984,'multiline':False]
['text':' push dir to examine rest of subdirs later','line_number':992,'multiline':False]
['text':' don't overwrite this either','line_number':1011,'multiline':False]
['text':' Not found or found already, try next suffix.','line_number':1019,'multiline':False]
['text':'
		     * still wildcards left, push the directories for further
		     * search
		     ','line_number':1029,'multiline':True]
['text':' not a directory','line_number':1037,'multiline':False]
['text':'
	     * if wildcards contains '**' we have to descent till we reach the
	     * leaves of the directory tree.
	     ','line_number':1050,'multiline':True]
['text':' don't repush same directory','line_number':1061,'multiline':False]
['text':' not a directory','line_number':1063,'multiline':False]
['text':' we are done with the current directory','line_number':1070,'multiline':False]
['text':' If we reached this, we didn't find anything downwards.','line_number':1075,'multiline':False]
['text':' Let's check if we should do an upward search.','line_number':1076,'multiline':False]
['text':' is the last starting directory in the stop list?','line_number':1082,'multiline':False]
['text':' cut of last dir','line_number':1088,'multiline':False]
['text':' create a new stack entry','line_number':1111,'multiline':False]
['text':'
 * Free the list of lists of visited files and directories
 * Can handle it if the passed search_context is NULL;
 ','line_number':1127,'multiline':True]
['text':'
 * Returns the already visited list for the given filename. If none is found it
 * allocates a new one.
 ','line_number':1176,'multiline':True]
['text':' check if a visited list for the given filename exists','line_number':1187,'multiline':False]
['text':' don't overwrite this either','line_number':1201,'multiline':False]
['text':' don't overwrite this either','line_number':1217,'multiline':False]
['text':'
     * if we reach this we didn't find a list and we have to allocate new list
     ','line_number':1223,'multiline':True]
['text':'
 * check if two wildcard paths are equal. Returns TRUE or FALSE.
 * They are equal if:
 *  - both paths are NULL
 *  - they have the same length
 *  - char by char comparison is OK
 *  - the only differences are in the counters behind a '**', so
 *    '**\20' is equal to '**\24'
 ','line_number':1243,'multiline':True]
['text':'
 * maintains the list of already visited files and dirs
 * returns FAIL if the given file/dir is already in the list
 * returns OK if it is newly added
 *
 * TODO: What to do on memory allocation problems?
 *	 -> return TRUE - Better the file is found several times instead of
 *	    never.
 ','line_number':1284,'multiline':True]
['text':' For a URL we only compare the name, otherwise we compare the','line_number':1305,'multiline':False]
['text':' device/inode (unix) or the full path name (not Unix).','line_number':1306,'multiline':False]
['text':' check against list of already visited files','line_number':1325,'multiline':False]
['text':' are the wildcard parts equal','line_number':1337,'multiline':False]
['text':' already visited','line_number':1339,'multiline':False]
['text':'
     * New file/dir.  Add it to the list of visited files/dirs.
     ','line_number':1344,'multiline':True]
['text':'
 * create stack element from given path pieces
 ','line_number':1379,'multiline':True]
['text':' the following saves NULL pointer checks in vim_findfile','line_number':1403,'multiline':False]
['text':'
 * Push a dir on the directory stack.
 ','line_number':1421,'multiline':True]
['text':' check for NULL pointer, not to return an error to the user, but','line_number':1427,'multiline':False]
['text':' to prevent a crash','line_number':1428,'multiline':False]
['text':'
 * Pop a dir from the directory stack.
 * Returns NULL if stack is empty.
 ','line_number':1436,'multiline':True]
['text':'
 * free the given stack element
 ','line_number':1452,'multiline':True]
['text':' vim_free handles possible NULL pointers','line_number':1458,'multiline':False]
['text':'
 * Clear the search context, but NOT the visited list.
 ','line_number':1468,'multiline':True]
['text':' clear up stack','line_number':1476,'multiline':False]
['text':' reset everything','line_number':1498,'multiline':False]
['text':'
 * check if the given path is in the stopdirs
 * returns TRUE if yes else FALSE
 ','line_number':1506,'multiline':True]
['text':' eat up trailing path separators, except the first','line_number':1515,'multiline':False]
['text':' if no path consider it as match','line_number':1519,'multiline':False]
['text':' match for parent directory. So '/home' also matches','line_number':1527,'multiline':False]
['text':' '/home/rks'. Check for PATHSEP in stopdirs_v[i], else','line_number':1528,'multiline':False]
['text':' '/home/r' would also match '/home/rks'','line_number':1529,'multiline':False]
['text':'
 * Find the file name "ptr[len]" in the path.  Also finds directory names.
 *
 * On the first call set the parameter 'first' to TRUE to initialize
 * the search.  For repeating calls to FALSE.
 *
 * Repeating calls will return other files called 'ptr[len]' from the path.
 *
 * Only on the first call 'ptr' and 'len' are used.  For repeating calls they
 * don't need valid values.
 *
 * If nothing found on the first call the option FNAME_MESS will issue the
 * message:
 *	    'Can't find file "<file>" in path'
 * On repeating calls:
 *	    'No more file "<file>" found in path'
 *
 * options:
 * FNAME_MESS	    give error message when not found
 *
 * Uses NameBuff[]!
 *
 * Returns an allocated string for the file name.  NULL for error.
 *
 ','line_number':1543,'multiline':True]
['text':' file name','line_number':1570,'multiline':False]
['text':' length of file name','line_number':1571,'multiline':False]
['text':' use count'th matching file name','line_number':1573,'multiline':False]
['text':' file name searching relative to','line_number':1574,'multiline':False]
['text':' in/out: modified copy of file name','line_number':1575,'multiline':False]
['text':' in/out: state of the search','line_number':1576,'multiline':False]
['text':'
 * Find the directory name "ptr[len]" in the path.
 *
 * options:
 * FNAME_MESS	    give error message when not found
 * FNAME_UNESC	    unescape backslashes.
 *
 * Uses NameBuff[]!
 *
 * Returns an allocated string for the file name.  NULL for error.
 ','line_number':1592,'multiline':True]
['text':' file name','line_number':1605,'multiline':False]
['text':' length of file name','line_number':1606,'multiline':False]
['text':' file name searching relative to','line_number':1608,'multiline':False]
['text':' in/out: modified copy of file name','line_number':1609,'multiline':False]
['text':' in/out: state of the search','line_number':1610,'multiline':False]
['text':' file name','line_number':1619,'multiline':False]
['text':' length of file name','line_number':1620,'multiline':False]
['text':' use count'th matching file name','line_number':1622,'multiline':False]
['text':' p_path or p_cdpath','line_number':1623,'multiline':False]
['text':' FINDFILE_FILE, _DIR or _BOTH','line_number':1624,'multiline':False]
['text':' file name we are looking relative to.','line_number':1625,'multiline':False]
['text':' list of suffixes, 'suffixesadd' option','line_number':1626,'multiline':False]
['text':' in/out: modified copy of file name','line_number':1627,'multiline':False]
['text':' in/out: state of the search','line_number':1628,'multiline':False]
['text':' Avoid a requester here for a volume that doesn't exist.','line_number':1641,'multiline':False]
['text':' copy file name into NameBuff, expanding environment variables','line_number':1650,'multiline':False]
['text':' out of memory','line_number':1658,'multiline':False]
['text':' Change all "\ " to " ".','line_number':1665,'multiline':False]
['text':' "..", "../path", "." and "./path": don't use the path_option','line_number':1679,'multiline':False]
['text':' handle "\tmp" as absolute path','line_number':1682,'multiline':False]
['text':' handle "c:name" as absolute path','line_number':1684,'multiline':False]
['text':' handle ":tmp" as absolute path','line_number':1688,'multiline':False]
['text':'
	 * Absolute path, no need to use "path_option".
	 * If this is not a first call, return NULL.  We already returned a
	 * filename on the first call.
	 ','line_number':1693,'multiline':True]
['text':' When FNAME_REL flag given first use the directory of the file.','line_number':1709,'multiline':False]
['text':' Otherwise or when this fails use the current directory.','line_number':1710,'multiline':False]
['text':' When the file doesn't exist, try adding parts of','line_number':1730,'multiline':False]
['text':' 'suffixesadd'.','line_number':1731,'multiline':False]
['text':'
	 * Loop over all paths in the 'path' or 'cdpath' option.
	 * When "first" is set, first setup to the start of the option.
	 * Otherwise continue to find the next match.
	 ','line_number':1752,'multiline':True]
['text':' vim_findfile_free_visited can handle a possible NULL pointer','line_number':1759,'multiline':False]
['text':' We searched all paths of the option, now we can','line_number':1781,'multiline':False]
['text':' free the search context.','line_number':1782,'multiline':False]
['text':' copy next path','line_number':1791,'multiline':False]
['text':' get the stopdir string','line_number':1795,'multiline':False]
['text':'
 * Get the file name at the cursor.
 * If Visual mode is active, use the selected text if it's in one line.
 * Returns the name in allocated memory, NULL for failure.
 ','line_number':1832,'multiline':True]
['text':' Only recognize ":123" here','line_number':1849,'multiline':False]
['text':'
 * Return the file name under or after the cursor.
 *
 * The 'path' option is searched if the file name is not absolute.
 * The string returned has been alloc'ed and should be freed by the caller.
 * NULL is returned if the file name or file is not found.
 *
 * options:
 * FNAME_MESS	    give error messages
 * FNAME_EXP	    expand to path
 * FNAME_HYP	    check for hypertext link
 * FNAME_INCL	    apply "includeexpr"
 ','line_number':1862,'multiline':True]
['text':'
 * Return the name of the file under or after ptr[col].
 * Otherwise like file_name_at_cursor().
 ','line_number':1883,'multiline':True]
['text':' file we are searching relative to','line_number':1893,'multiline':False]
['text':' line number after the file name','line_number':1894,'multiline':False]
['text':'
     * search forward for what could be the start of a file name
     ','line_number':1901,'multiline':True]
['text':' nothing found','line_number':1907,'multiline':False]
['text':'
     * Search backward for first char of the file name.
     * Go one char back to ":" before "//" even when ':' is not in 'isfname'.
     ','line_number':1914,'multiline':True]
['text':'
     * Search forward for the last char of the file name.
     * Also allow "://" when ':' is not in 'isfname'.
     ','line_number':1929,'multiline':True]
['text':' After type:// we also include :, ?, & and = as valid characters, so','line_number':1938,'multiline':False]
['text':' that http://google.com:8080?q=this&that=ok works.','line_number':1939,'multiline':False]
['text':' Skip over the "\" in "\ ".','line_number':1950,'multiline':False]
['text':'
     * If there is trailing punctuation, remove it.
     * But don't remove "..", could be a directory name.
     ','line_number':1958,'multiline':True]
['text':' Get the number after the file name and a separator character.','line_number':1972,'multiline':False]
['text':' Also accept " line 999" with and without the same translation as','line_number':1973,'multiline':False]
['text':' used in last_set_msg().','line_number':1974,'multiline':False]
['text':' skip the separator','line_number':1985,'multiline':False]
['text':'
 * Return the name of the file ptr[len] in 'path'.
 * Otherwise like file_name_at_cursor().
 ','line_number':2015,'multiline':True]
['text':' file we are searching relative to','line_number':2025,'multiline':False]
['text':'
	 * If the file could not be found in a normal way, try applying
	 * 'includeexpr' (unless done already).
	 ','line_number':2057,'multiline':True]
['text':' Repeat finding the file "count" times.  This matters when it','line_number':2082,'multiline':False]
['text':' appears several times in the path.','line_number':2083,'multiline':False]
['text':'
 * Return the end of the directory name, on the first path
 * separator:
 * "/path/file", "/path/dir/", "/path//dir", "/file"
 *	 ^	       ^	     ^	      ^
 ','line_number':2104,'multiline':True]
['text':'
 * return TRUE if 'c' is a path list separator.
 ','line_number':2139,'multiline':True]
['text':' might not be right for every system...','line_number':2148,'multiline':False]
['text':'
 * Moves "*psep" back to the previous path separator in "path".
 * Returns FAIL is "*psep" ends up at the beginning of "path".
 ','line_number':2152,'multiline':True]
['text':' skip the current separator','line_number':2159,'multiline':False]
['text':' find the previous separator','line_number':2163,'multiline':False]
['text':'
 * Returns TRUE if "maybe_unique" is unique wrt other_paths in "gap".
 * "maybe_unique" is the end portion of "((char_u **)gap->ga_data)[i]".
 ','line_number':2174,'multiline':True]
['text':' don't compare it with itself','line_number':2190,'multiline':False]
['text':' it's different when it's shorter','line_number':2195,'multiline':False]
['text':' match','line_number':2200,'multiline':False]
['text':' no match found','line_number':2203,'multiline':False]
['text':'
 * Split the 'path' option into an array of strings in garray_T.  Relative
 * paths are expanded to their equivalent fullpath.  This includes the "."
 * (relative to current buffer directory) and empty path (relative to current
 * directory) notations.
 *
 * TODO: handle upward search (;) and path limiter (**N) notations by
 * expanding each into their equivalent path(s).
 ','line_number':2206,'multiline':True]
['text':' Relative to current buffer:','line_number':2233,'multiline':False]
['text':' "/path/file" + "." -> "/path/"','line_number':2234,'multiline':False]
['text':' "/path/file"  + "./subdir" -> "/path/subdir"','line_number':2235,'multiline':False]
['text':' relative to current directory','line_number':2250,'multiline':False]
['text':' URL can't be used here','line_number':2253,'multiline':False]
['text':' Expand relative path to their full path equivalent','line_number':2257,'multiline':False]
['text':' Avoid the path ending in a backslash, it fails when a comma is','line_number':2271,'multiline':False]
['text':' appended.','line_number':2272,'multiline':False]
['text':'
 * Returns a pointer to the file or directory name in "fname" that matches the
 * longest path in "ga"p, or NULL if there is no match. For example:
 *
 *    path: /foo/bar/baz
 *   fname: /foo/bar/baz/quux.txt
 * returns:		 ^this
 ','line_number':2287,'multiline':True]
['text':' skip to the file or directory name','line_number':2320,'multiline':False]
['text':'
 * Sorts, removes duplicates and modifies all the fullpath names in "gap" so
 * that they are unique with respect to each other while conserving the part
 * that matches the pattern. Beware, this is at least O(n^2) wrt "gap->ga_len".
 ','line_number':2328,'multiline':True]
['text':'
     * We need to prepend a '*' at the beginning of file_pattern so that the
     * regex matches anywhere in the path. FIXME: is this valid for all
     * possible patterns?
     ','line_number':2351,'multiline':True]
['text':' always ignore case','line_number':2368,'multiline':False]
['text':' Shorten the filename while maintaining its uniqueness','line_number':2397,'multiline':False]
['text':' Don't assume all files can be reached without path when search','line_number':2400,'multiline':False]
['text':' pattern starts with star star slash, so only remove path_cutoff','line_number':2401,'multiline':False]
['text':' when possible.','line_number':2402,'multiline':False]
['text':' Here all files can be reached without path, so get shortest','line_number':2414,'multiline':False]
['text':' unique path.  We start at the end of the path.','line_number':2415,'multiline':False]
['text':'
	     * Last resort: shorten relative to curdir if possible.
	     * 'possible' means:
	     * 1. It is under the current directory.
	     * 2. The result is actually shorter than the original.
	     *
	     *	    Before		  curdir	After
	     *	    /foo/bar/file.txt	  /foo/bar	./file.txt
	     *	    c:\foo\bar\file.txt   c:\foo\bar	.\file.txt
	     *	    /file.txt		  /		/file.txt
	     *	    c:\file.txt		  c:\		.\file.txt
	     ','line_number':2431,'multiline':True]
['text':' On windows,','line_number':2446,'multiline':False]
['text':'	    shorten_fname("c:\a\a.txt", "c:\a\b")','line_number':2447,'multiline':False]
['text':' returns "\a\a.txt", which is not really the short','line_number':2448,'multiline':False]
['text':' name, hence:','line_number':2449,'multiline':False]
['text':' Shorten filenames in /in/current/directory/{filename}','line_number':2462,'multiline':False]
['text':' If the {filename} is not unique, change it to ./{filename}.','line_number':2471,'multiline':False]
['text':' Else reduce it to {filename}','line_number':2472,'multiline':False]
['text':'
 * Calls globpath() with 'path' values for the given pattern and stores the
 * result in "gap".
 * Returns the total number of matches.
 ','line_number':2510,'multiline':True]
['text':' EW_* flags','line_number':2519,'multiline':False]
['text':'
 * Converts a file name into a canonical form. It simplifies a file name into
 * its simplest form by stripping out unneeded components, if any.  The
 * resulting file name is simplified in place and will either be the same
 * length as that supplied, or shorter.
 ','line_number':2552,'multiline':True]
['text':' Amiga doesn't have "..", it uses "/"','line_number':2561,'multiline':False]
['text':' skip "x:"','line_number':2569,'multiline':False]
['text':' remember start after "c:/" or "/" or "///"','line_number':2580,'multiline':False]
['text':' Posix says that "//path" is unchanged but "///path" is "/path".','line_number':2582,'multiline':False]
['text':' At this point "p" is pointing to the char following a single "/"','line_number':2592,'multiline':False]
['text':' or "p" is at the "start" of the (absolute or relative) path name.','line_number':2593,'multiline':False]
['text':' VMS allows device:[path] - don't strip the [ in directory','line_number':2595,'multiline':False]
['text':' :[ or :< composition: vms directory component','line_number':2598,'multiline':False]
['text':' allow remote calls as host"user passwd"::device:[path]','line_number':2602,'multiline':False]
['text':' ":: composition: vms host/passwd component','line_number':2605,'multiline':False]
['text':' remove duplicate "/"','line_number':2612,'multiline':False]
['text':' keep single "." or leading "./"','line_number':2616,'multiline':False]
['text':' Strip "./" or ".///".  If we are at the end of the file name','line_number':2619,'multiline':False]
['text':' and there is no trailing path separator, either strip "/." if','line_number':2620,'multiline':False]
['text':' we are after "start", or strip "." if we are at the beginning','line_number':2621,'multiline':False]
['text':' of an absolute path name .','line_number':2622,'multiline':False]
['text':' strip preceding path separator','line_number':2628,'multiline':False]
['text':' Skip to after ".." or "../" or "..///".','line_number':2635,'multiline':False]
['text':' strip one preceding component','line_number':2640,'multiline':False]
['text':' Don't strip for an erroneous file name.','line_number':2646,'multiline':False]
['text':' If the preceding component does not exist in the file','line_number':2649,'multiline':False]
['text':' system, we strip it.  On Unix, we don't accept a symbolic','line_number':2650,'multiline':False]
['text':' link that refers to a non-existent file.','line_number':2651,'multiline':False]
['text':' Skip back to after previous '/'.','line_number':2663,'multiline':False]
['text':' If the component exists in the file system, check','line_number':2669,'multiline':False]
['text':' that stripping it won't change the meaning of the','line_number':2670,'multiline':False]
['text':' file name.  First get information about the','line_number':2671,'multiline':False]
['text':' unstripped file name.  This may fail if the component','line_number':2672,'multiline':False]
['text':' to strip is not a searchable directory (but a regular','line_number':2673,'multiline':False]
['text':' file, for instance), since the trailing "/.." cannot','line_number':2674,'multiline':False]
['text':' be applied then.  We don't strip it then since we','line_number':2675,'multiline':False]
['text':' don't want to replace an erroneous file name by','line_number':2676,'multiline':False]
['text':' a valid one, and we disable stripping of later','line_number':2677,'multiline':False]
['text':' components.','line_number':2678,'multiline':False]
['text':' On Unix, the check for the unstripped file name','line_number':2691,'multiline':False]
['text':' above works also for a symbolic link pointing to','line_number':2692,'multiline':False]
['text':' a searchable directory.  But then the parent of','line_number':2693,'multiline':False]
['text':' the directory pointed to by the link must be the','line_number':2694,'multiline':False]
['text':' same as the stripped file name.  (The latter','line_number':2695,'multiline':False]
['text':' exists in the file system since it is the','line_number':2696,'multiline':False]
['text':' component's parent directory.)','line_number':2697,'multiline':False]
['text':' We don't disable stripping of later','line_number':2712,'multiline':False]
['text':' components since the unstripped path name is','line_number':2713,'multiline':False]
['text':' still valid.','line_number':2714,'multiline':False]
['text':' Skip the ".." or "../" and reset the counter for the','line_number':2723,'multiline':False]
['text':' components that might be stripped later on.','line_number':2724,'multiline':False]
['text':' Strip previous component.  If the result would get empty','line_number':2730,'multiline':False]
['text':' and there is no trailing path separator, leave a single','line_number':2731,'multiline':False]
['text':' "." instead.  If we are at the end of the file name and','line_number':2732,'multiline':False]
['text':' there is no trailing path separator and a preceding','line_number':2733,'multiline':False]
['text':' component is left after stripping, strip its trailing','line_number':2734,'multiline':False]
['text':' path separator as well.','line_number':2735,'multiline':False]
['text':' strip previous component','line_number':2745,'multiline':False]
['text':' leading "/.." or "/../"','line_number':2751,'multiline':False]
['text':' strip ".." or "../"','line_number':2752,'multiline':False]
['text':' leading "./../"','line_number':2755,'multiline':False]
['text':' strip leading "./"','line_number':2757,'multiline':False]
['text':' skip to char after ".." or "../"','line_number':2760,'multiline':False]
['text':' simple path component','line_number':2765,'multiline':False]
['text':' !AMIGA','line_number':2769,'multiline':False]
['text':'
 * "simplify()" function
 ','line_number':2773,'multiline':True]
['text':' simplify in place','line_number':2786,'multiline':False]
['text':' FEAT_EVAL','line_number':2789,'multiline':False]
