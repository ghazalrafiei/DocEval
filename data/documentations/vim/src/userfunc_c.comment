['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]
['text':'
 * userfunc.c: User defined function support
 ','line_number':10,'multiline':True]
['text':'
 * All user-defined functions are found in this hashtable.
 ','line_number':20,'multiline':True]
['text':' Used by get_func_tv()','line_number':25,'multiline':False]
['text':' pointer to funccal for currently active function','line_number':28,'multiline':False]
['text':' Pointer to list of previously used funccal, still around because some','line_number':31,'multiline':False]
['text':' item in it is still being used.','line_number':32,'multiline':False]
['text':'
 * Return the function hash table
 ','line_number':47,'multiline':True]
['text':'
 * Get one function argument.
 * If "argtypes" is not NULL also get the type: "arg: type" (:def function).
 * If "types_optional" is TRUE a missing type is OK, use "any".
 * If "evalarg" is not NULL use it to check for an already declared name.
 * If "eap" is not NULL use it to check for an already declared name.
 * Return a pointer to after the type.
 * When something is wrong return "arg".
 ','line_number':56,'multiline':True]
['text':' Extra checks in Vim9 script.','line_number':93,'multiline':False]
['text':' Cannot use script var name for argument. In function: also check','line_number':103,'multiline':False]
['text':' local vars and arguments.','line_number':104,'multiline':False]
['text':' Check for duplicate argument name.','line_number':128,'multiline':False]
['text':' get any type from "arg: type"','line_number':142,'multiline':False]
['text':' lambda arguments default to "any" type','line_number':176,'multiline':False]
['text':'
 * Handle line continuation in function arguments or body.
 * Get a next line, store it in "eap" if appropriate and put the line in
 * "lines_to_free" to free the line later.
 ','line_number':187,'multiline':True]
['text':'
 * Get function arguments.
 * "argp" should point to just after the "(", possibly to white space.
 * "argp" is advanced just after "endchar".
 ','line_number':218,'multiline':True]
['text':' NULL unless using :def','line_number':228,'multiline':False]
['text':' types optional if "argtypes" is not NULL','line_number':229,'multiline':False]
['text':' NULL unless using :def','line_number':230,'multiline':False]
['text':' context or NULL','line_number':231,'multiline':False]
['text':' can be NULL','line_number':235,'multiline':False]
['text':' non-zero when inside a class or interface','line_number':236,'multiline':False]
['text':' function body lines','line_number':237,'multiline':False]
['text':'
     * Isolate the arguments: "arg1, arg2, ...)"
     ','line_number':260,'multiline':True]
['text':' End of the line, get the next one.','line_number':270,'multiline':False]
['text':' ...name: list<type>','line_number':298,'multiline':False]
['text':' this.memberName','line_number':320,'multiline':False]
['text':' object variable this. can be used only in a constructor','line_number':327,'multiline':False]
['text':' TODO: check the argument is indeed a member','line_number':364,'multiline':False]
['text':' TODO: use the actual type','line_number':376,'multiline':False]
['text':' Add a line to the function body for the assignment.','line_number':381,'multiline':False]
['text':' "this.name = name"','line_number':384,'multiline':False]
['text':' Recognize " = expr" but not " == expr".  A lambda can have','line_number':420,'multiline':False]
['text':' "(a = expr" but "(a == expr" and "(a =~ expr" are not a lambda.','line_number':421,'multiline':False]
['text':' find the end of the expression (doesn't evaluate it)','line_number':428,'multiline':False]
['text':' trim trailing whitespace','line_number':441,'multiline':False]
['text':' Be tolerant when skipping','line_number':473,'multiline':False]
['text':' Don't give this error when skipping, it makes the "->" not','line_number':484,'multiline':False]
['text':' found in "{k,v -> x}" and give a confusing error.','line_number':485,'multiline':False]
['text':' Allow missing space after comma in legacy functions.','line_number':486,'multiline':False]
['text':' skip "endchar"','line_number':503,'multiline':False]
['text':'
 * Parse the argument types, filling "fp->uf_arg_types".
 * Return OK or FAIL.
 ','line_number':516,'multiline':True]
['text':' When "varargs" is set the last name/type goes into uf_va_name','line_number':534,'multiline':False]
['text':' and uf_va_type.','line_number':535,'multiline':False]
['text':' will get the type from the default value','line_number':550,'multiline':False]
['text':' Move the last argument "...name: type" to uf_va_name and','line_number':588,'multiline':False]
['text':' uf_va_type.','line_number':589,'multiline':False]
['text':' TODO: get type from default value','line_number':595,'multiline':False]
['text':'
 * Register function "fp" as using "current_funccal" as its scope.
 ','line_number':633,'multiline':True]
['text':' no change','line_number':640,'multiline':False]
['text':' Add a type cast to avoid a warning for an overflow, the uf_name[] array','line_number':656,'multiline':False]
['text':' actually extends beyond the struct.','line_number':657,'multiline':False]
['text':'
 * If "name" starts with K_SPECIAL and "buf[bufsize]" is big enough
 * return "buf" filled with a readable function name.
 * Otherwise just return "name", thus the return value can always be used.
 * "name" and "buf" may be equal.
 ','line_number':671,'multiline':True]
['text':' Include trailing NUL','line_number':688,'multiline':False]
['text':'
 * Get a name for a lambda.  Returned in static memory.
 ','line_number':693,'multiline':True]
['text':'
 * Allocate a "ufunc_T" for a function called "name".
 * Makes sure the size is right.
 ','line_number':706,'multiline':True]
['text':' When the name is short we need to make sure we allocate enough bytes for','line_number':713,'multiline':False]
['text':' the whole struct, including any padding.','line_number':714,'multiline':False]
['text':'
 * Registers a native C callback which can be called from Vim script.
 * Returns the name of the Vim script function.
 ','line_number':720,'multiline':True]
['text':'
 * Skip over "->" or "=>" after the arguments of a lambda.
 * If ": type" is found make "ret_type" point to "type".
 * If "white_error" is not NULL check for correct use of white space and set
 * "white_error" to TRUE if there is an error.
 * Return NULL if no valid arrow found.
 ','line_number':751,'multiline':True]
['text':' "start" points to > of ->','line_number':766,'multiline':False]
['text':'
 * Check if "*cmd" points to a function command and if so advance "*cmd" and
 * return TRUE.
 * Otherwise return FALSE;
 * Do not consider "function(" to be a command.
 ','line_number':806,'multiline':True]
['text':'
 * Called when defining a function: The context may be needed for script
 * variables declared in a block that is visible now but not when the function
 * is compiled or called later.
 ','line_number':827,'multiline':True]
['text':' Set flag in each block to indicate a function was defined.  This','line_number':849,'multiline':False]
['text':' is used to keep the variable when leaving the block, see','line_number':850,'multiline':False]
['text':' hide_script_var().','line_number':851,'multiline':False]
['text':'
 * Read the body of a function, put every line in "newlines".
 * This stops at "}", "endfunction" or "enddef".
 * "newlines" must already have been initialized.
 * "eap->cmdidx" is CMD_function, CMD_def or CMD_block;
 ','line_number':856,'multiline':True]
['text':' Detect having skipped over comment lines to find the return','line_number':890,'multiline':False]
['text':' type.  Add NULL lines to keep the line count correct.','line_number':891,'multiline':False]
['text':' Use eap->arg, split up in parts by line breaks.','line_number':921,'multiline':False]
['text':' Use the start of the function for the line number.','line_number':941,'multiline':False]
['text':' Detect line continuation: SOURCING_LNUM increased more than one.','line_number':954,'multiline':False]
['text':' Don't check for ":endfunc"/":enddef" between','line_number':963,'multiline':False]
['text':' * ":append" and "."','line_number':964,'multiline':False]
['text':' * ":python <<EOF" and "EOF"','line_number':965,'multiline':False]
['text':' * ":let {var-name} =<< [trim] {marker}" and "{marker}"','line_number':966,'multiline':False]
['text':' Replace the starting line with all the concatenated','line_number':989,'multiline':False]
['text':' lines.','line_number':990,'multiline':False]
['text':' skip the "EOF"','line_number':998,'multiline':False]
['text':' skip ':' and blanks','line_number':1009,'multiline':False]
['text':' Check for "endfunction", "enddef" or "}".','line_number':1013,'multiline':False]
['text':' When a ":" follows it must be a dict key; "enddef: value,"','line_number':1014,'multiline':False]
['text':' Another command follows. If the line came from "eap"','line_number':1047,'multiline':False]
['text':' we can simply point into it, otherwise we need to','line_number':1048,'multiline':False]
['text':' change "eap->cmdlinep" to point to the last fetched','line_number':1049,'multiline':False]
['text':' line.','line_number':1050,'multiline':False]
['text':' *cmdlinep will be freed later, thus remove the','line_number':1057,'multiline':False]
['text':' line from lines_to_free.','line_number':1058,'multiline':False]
['text':' Check for mismatched "endfunc" or "enddef".','line_number':1069,'multiline':False]
['text':' We don't check for "def" inside "func" thus we also can't check','line_number':1070,'multiline':False]
['text':' for "enddef".','line_number':1071,'multiline':False]
['text':' We continue to find the end of the function, although we might','line_number':1072,'multiline':False]
['text':' not find it.','line_number':1073,'multiline':False]
['text':' Increase indent inside "if", "while", "for" and "try", decrease','line_number':1082,'multiline':False]
['text':' at "end".','line_number':1083,'multiline':False]
['text':' Check for defining a function inside this function.','line_number':1092,'multiline':False]
['text':' Only recognize "def" inside "def", not inside "function",','line_number':1093,'multiline':False]
['text':' For backwards compatibility, see Test_function_python().','line_number':1094,'multiline':False]
['text':' Not a comment line: check for nested inline function.','line_number':1119,'multiline':False]
['text':' check for trailing "=> {": start of an inline function','line_number':1127,'multiline':False]
['text':' check for line starting with "au" for :autocmd or','line_number':1136,'multiline':False]
['text':' "com" for :command, these can use a {} block','line_number':1137,'multiline':False]
['text':' Check for ":append", ":change", ":insert".  Not for :def.','line_number':1157,'multiline':False]
['text':' Check for ":python <<EOF", ":tcl <<EOF", etc.','line_number':1174,'multiline':False]
['text':' ":python <<" continues until a dot, like ":append"','line_number':1193,'multiline':False]
['text':' Ignore leading white space.','line_number':1197,'multiline':False]
['text':' Check for ":cmd v =<< [trim] EOF"','line_number':1214,'multiline':False]
['text':'       and ":cmd [a, b] =<< [trim] EOF"','line_number':1215,'multiline':False]
['text':'       and "lines =<< [trim] EOF" for Vim9','line_number':1216,'multiline':False]
['text':' Where "cmd" can be "let", "var", "final" or "const".','line_number':1217,'multiline':False]
['text':' Ignore leading white space.','line_number':1238,'multiline':False]
['text':' Ignore leading white space.','line_number':1246,'multiline':False]
['text':' Add the line to the function.','line_number':1260,'multiline':False]
['text':' For a :def function "python << EOF" concatenates all the lines,','line_number':1266,'multiline':False]
['text':' to be used for the instruction later.','line_number':1267,'multiline':False]
['text':' Copy the line to newly allocated memory.  get_one_sourceline()','line_number':1274,'multiline':False]
['text':' allocates 250 bytes per line, this saves 80% on average.  The','line_number':1275,'multiline':False]
['text':' cost is an extra alloc/free.','line_number':1276,'multiline':False]
['text':' Add NULL lines for continuation lines, so that the line count is','line_number':1283,'multiline':False]
['text':' equal to the index in the growarray.','line_number':1284,'multiline':False]
['text':' Check for end of eap->arg.','line_number':1288,'multiline':False]
['text':' Return OK when no error was detected.','line_number':1293,'multiline':False]
['text':'
 * Handle the body of a lambda.  *arg points to the "{", process statements
 * until the matching "}".
 * When not evaluating "newargs" is NULL.
 * When successful "rettv" is set to a funcref.
 ','line_number':1305,'multiline':True]
['text':' When inside a lambda must add the function lines to evalarg.eval_ga.','line_number':1361,'multiline':False]
['text':' Going to concatenate the lines after parsing.  For an empty or','line_number':1377,'multiline':False]
['text':' comment line use an empty string.','line_number':1378,'multiline':False]
['text':' Insert NL characters at the start of each line, the string will','line_number':1379,'multiline':False]
['text':' be split again later in .get_lambda_tv().','line_number':1380,'multiline':False]
['text':' more is following after the "}", which was skipped','line_number':1393,'multiline':False]
['text':' nothing is following the "}"','line_number':1396,'multiline':False]
['text':' Something comes after the "}".','line_number':1410,'multiline':False]
['text':' "arg" points into cmdline, need to keep the line and free it later.','line_number':1413,'multiline':False]
['text':' error messages are for the first function line','line_number':1444,'multiline':False]
['text':' parse argument types','line_number':1448,'multiline':False]
['text':' parse the return type, if any','line_number':1455,'multiline':False]
['text':'
 * Parse a lambda expression and get a Funcref from "*arg" into "rettv".
 * "arg" points to the { in "{arg -> expr}" or the ( in "(arg) => expr"
 * When "types_optional" is TRUE optionally take argument types.
 * Return OK or FAIL.  Returns NOTDONE for dict or {expr}.
 ','line_number':1498,'multiline':True]
['text':' First, check if this is really a lambda expression. "->" or "=>" must','line_number':1541,'multiline':False]
['text':' be found after the arguments.','line_number':1542,'multiline':False]
['text':' Parse the arguments for real.','line_number':1558,'multiline':False]
['text':' Skipping over linebreaks may make "ret_type" invalid, make a copy.','line_number':1583,'multiline':False]
['text':' Set up a flag for checking local variables and arguments.','line_number':1590,'multiline':False]
['text':' Recognize "{" as the start of a function body.','line_number':1596,'multiline':False]
['text':' cannot happen?','line_number':1600,'multiline':False]
['text':' used for where lambda is defined','line_number':1602,'multiline':False]
['text':' Get the start and the end of the expression.','line_number':1615,'multiline':False]
['text':' If there are line breaks, we need to split up the string.','line_number':1652,'multiline':False]
['text':' Add "return " before the expression (or the first line).','line_number':1657,'multiline':False]
['text':' Add more lines, split by line breaks.  Thus is used when a','line_number':1668,'multiline':False]
['text':' lambda with { cmds } is encountered.','line_number':1669,'multiline':False]
['text':' No a: variables are used for sure.','line_number':1684,'multiline':False]
['text':' In legacy script a lambda can be called with more args than','line_number':1721,'multiline':False]
['text':' uf_args.ga_len.  In Vim9 script "...name" has to be used.','line_number':1722,'multiline':False]
['text':' Use the line number of the arguments.','line_number':1727,'multiline':False]
['text':'
 * Check if "name" is a variable of type VAR_FUNC.  If so, return the function
 * name it contains, otherwise return "name".
 * If "partialp" is not NULL, and "name" is of type VAR_PARTIAL also set
 * "partialp".
 * If "type" is not NULL and a Vim9 script-local variable is found look up the
 * type of the variable.
 * If "new_function" is TRUE the name is for a new function.
 * If "found_var" is not NULL and a variable was found set it to TRUE.
 ','line_number':1769,'multiline':True]
['text':' imported function from another script','line_number':1821,'multiline':False]
['text':' just in case','line_number':1831,'multiline':False]
['text':' just in case','line_number':1844,'multiline':False]
['text':' just in case','line_number':1857,'multiline':False]
['text':'
 * Give an error message with a function name.  Handle <SNR> things.
 * "ermsg" is to be passed without translation, use N_() instead of _().
 ','line_number':1881,'multiline':True]
['text':'
 * Get function arguments at "*arg" and advance it.
 * Return them in "*argvars[MAX_FUNC_ARGS + 1]" and the count in "argcount".
 * On failure FAIL is returned but the "argvars[argcount]" are still set.
 ','line_number':1897,'multiline':True]
['text':' skip the '(' or ',' and possibly line breaks','line_number':1918,'multiline':False]
['text':' The comma should come right after the argument, but this wasn't','line_number':1929,'multiline':False]
['text':' checked previously, thus only enforce it in Vim9 script.','line_number':1930,'multiline':False]
['text':'
 * Call a function and put the result in "rettv".
 * Return OK or FAIL.
 ','line_number':1964,'multiline':True]
['text':' name of the function','line_number':1970,'multiline':False]
['text':' length of "name" or -1 to use strlen()','line_number':1971,'multiline':False]
['text':' argument, pointing to the '('','line_number':1973,'multiline':False]
['text':' for line continuation','line_number':1974,'multiline':False]
['text':' various values','line_number':1975,'multiline':False]
['text':' vars for arguments','line_number':1979,'multiline':False]
['text':' number of arguments found','line_number':1980,'multiline':False]
['text':' Prepare for calling test_garbagecollect_now(), need to know','line_number':1997,'multiline':False]
['text':' what variables are used on the call stack.','line_number':1998,'multiline':False]
['text':' An error in a builtin function does not return FAIL, but we do','line_number':2010,'multiline':False]
['text':' want to abort further processing if an error was given.','line_number':2011,'multiline':False]
['text':'
 * Return TRUE if "p" starts with "<SID>" or "s:".
 * Only works if eval_fname_script() returned non-zero for "p"!
 ','line_number':2036,'multiline':True]
['text':'
 * In a script change <SID>name() and s:name() to K_SNR 123_name().
 * Change <SNR>123_name() to K_SNR 123_name().
 * Use "fname_buf[FLEN_FIXED + 1]" when it fits, otherwise allocate memory
 * and set "tofree".
 ','line_number':2046,'multiline':True]
['text':' no prefix','line_number':2065,'multiline':False]
['text':' "<SID>" or "s:"','line_number':2071,'multiline':False]
['text':'
 * Concatenate the script ID and function name into  "<SNR>99_name".
 * "buffer" must have size MAX_FUNC_NAME_LEN.
 ','line_number':2102,'multiline':True]
['text':' A script-local function is stored as "<SNR>99_name".','line_number':2109,'multiline':False]
['text':'
 * Find a function "name" in script "sid".
 ','line_number':2117,'multiline':True]
['text':' not in a script','line_number':2127,'multiline':False]
['text':'
 * Find a function "name" in script "sid" prefixing the autoload prefix.
 ','line_number':2136,'multiline':True]
['text':' already has the prefix','line_number':2147,'multiline':False]
['text':' not in a script','line_number':2149,'multiline':False]
['text':' skip a "<SNR>99_" prefix','line_number':2157,'multiline':False]
['text':' An exported function in an autoload script is stored as','line_number':2162,'multiline':False]
['text':' "dir#path#name".','line_number':2163,'multiline':False]
['text':'
 * Find a function by name, return pointer to it in ufuncs.
 * When "flags" has FFED_IS_GLOBAL don't find script-local or imported
 * functions.
 * When "flags" has "FFED_NO_GLOBAL" don't find global functions.
 * Return NULL for unknown function.
 ','line_number':2183,'multiline':True]
['text':' Find script-local function before global one.','line_number':2198,'multiline':False]
['text':' printable "<SNR>123_Name" form','line_number':2212,'multiline':False]
['text':' Find autoload function if this is an autoload script.','line_number':2231,'multiline':False]
['text':'
 * Find a function by name, return pointer to it in ufuncs.
 * "cctx" is passed in a :def function to find imported functions.
 * Return NULL for unknown or dead function.
 ','line_number':2236,'multiline':True]
['text':'
 * Return TRUE if "ufunc" is a global function.
 ','line_number':2251,'multiline':True]
['text':'
 * Return TRUE if "ufunc" must be called with a g: prefix in Vim9 script.
 ','line_number':2260,'multiline':True]
['text':'
 * Copy the function name of "fp" to buffer "buf".
 * "buf" must be able to hold the function name plus three bytes.
 * Takes care of script-local function names.
 ','line_number':2272,'multiline':True]
['text':'
 * Add a number variable "name" to dict "dp" with value "nr".
 ','line_number':2289,'multiline':True]
['text':'
 * Free "fc".
 ','line_number':2307,'multiline':True]
['text':' When garbage collecting a funccall_T may be freed before the','line_number':2319,'multiline':False]
['text':' function that references it, clear its uf_scoped field.','line_number':2320,'multiline':False]
['text':' The function may have been redefined and point to another','line_number':2321,'multiline':False]
['text':' funccall_T, don't clear it then.','line_number':2322,'multiline':False]
['text':'
 * Free "fc" and what it contains.
 * Can be called only when "fc" is kept beyond the period of it called,
 * i.e. after cleanup_function_call(fc).
 ','line_number':2332,'multiline':True]
['text':' Free all l: variables.','line_number':2342,'multiline':False]
['text':' Free all a: variables.','line_number':2345,'multiline':False]
['text':' Free the a:000 variables.','line_number':2348,'multiline':False]
['text':'
 * Handle the last part of returning from a function: free the local hashtable.
 * Unless it is still in use by a closure.
 ','line_number':2355,'multiline':True]
['text':' Free all l: variables if not referred.','line_number':2367,'multiline':False]
['text':' If the a:000 list and the l: and a: dicts are not referenced and','line_number':2373,'multiline':False]
['text':' there is no closure using it, we can free the funccall_T and what's','line_number':2374,'multiline':False]
['text':' in it.','line_number':2375,'multiline':False]
['text':' Make a copy of the a: variables, since we didn't do that above.','line_number':2386,'multiline':False]
['text':' Make a copy of the a:000 items, since we didn't do that above.','line_number':2407,'multiline':False]
['text':' "fc" is still in use.  This can happen when returning "a:000",','line_number':2418,'multiline':False]
['text':' assigning "l:" to a global variable or defining a closure.','line_number':2419,'multiline':False]
['text':' Link "fc" in the list for garbage collection later.','line_number':2420,'multiline':False]
['text':' If garbage collector is ready, clear count.','line_number':2425,'multiline':False]
['text':' We have made a lot of copies, worth 4 Mbyte.  This can happen','line_number':2429,'multiline':False]
['text':' when repetitively calling a function that creates a reference to','line_number':2430,'multiline':False]
['text':' itself somehow.  Call the garbage collector soon to avoid using','line_number':2431,'multiline':False]
['text':' too much memory.','line_number':2432,'multiline':False]
['text':'
 * Return TRUE if "name" is a numbered function, ignoring a "g:" prefix.
 ','line_number':2439,'multiline':True]
['text':'
 * There are two kinds of function names:
 * 1. ordinary names, function defined with :function or :def;
 *    can start with "<SNR>123_" literally or with K_SPECIAL.
 * 2. Numbered functions and lambdas: "<lambda>123"
 * For the first we only count the name stored in func_hashtab as a reference,
 * using function() does not count as a reference, because the function is
 * looked up by name.
 ','line_number':2449,'multiline':True]
['text':'
 * Unreference "fc": decrement the reference count and free it when it
 * becomes zero.  "fp" is detached from "fc".
 * When "force" is TRUE we are exiting.
 ','line_number':2464,'multiline':True]
['text':'
 * Remove the function from the function hashtable.  If the function was
 * deleted while it still has references this was already done.
 * Return TRUE if the entry was deleted, FALSE if it wasn't found.
 ','line_number':2496,'multiline':True]
['text':' Return if it was already virtually deleted.','line_number':2506,'multiline':False]
['text':' When there is a def-function index do not actually remove the','line_number':2514,'multiline':False]
['text':' function, so we can find the index when defining the function again.','line_number':2515,'multiline':False]
['text':' Do remove it when it's a copy.','line_number':2516,'multiline':False]
['text':' Increment the refcount of this function to avoid it being freed','line_number':2538,'multiline':False]
['text':' recursively when the partial is freed.','line_number':2539,'multiline':False]
['text':'
 * Free all things that a function contains.  Does not free the function
 * itself, use func_free() for that.
 * When "force" is TRUE we are exiting.
 ','line_number':2562,'multiline':True]
['text':' clear this function','line_number':2574,'multiline':False]
['text':'
 * Free a function and remove it from the list of functions.  Does not free
 * what a function contains, call func_clear() first.
 * When "force" is TRUE we are exiting.
 * Returns OK when the function was actually freed.
 ','line_number':2580,'multiline':True]
['text':' Only remove it when not done already, otherwise we would remove a newer','line_number':2589,'multiline':False]
['text':' version of the function with the same name.','line_number':2590,'multiline':False]
['text':'
 * Free all things that a function contains and free the function itself.
 * When "force" is TRUE we are exiting.
 ','line_number':2605,'multiline':True]
['text':'
 * Copy already defined function "lambda" to a new function with name "global".
 * This is for when a compiled function defines a global function.
 ','line_number':2620,'multiline':True]
['text':' TODO: handle ! to overwrite','line_number':2643,'multiline':False]
['text':' the referenced dfunc_T is now used one more time','line_number':2685,'multiline':False]
['text':' Create a partial to store the context of the function where it was','line_number':2688,'multiline':False]
['text':' instantiated.  Only needs to be done once.  Do this on the original','line_number':2689,'multiline':False]
['text':' function, "dfunc->df_ufunc" will point to it.','line_number':2690,'multiline':False]
['text':'
 * Increment the function call depth count.
 * Return FAIL when going over 'maxfuncdepth'.
 * Otherwise return OK, must call funcdepth_decrement() later!
 ','line_number':2714,'multiline':True]
['text':'
 * Get the current function call depth.
 ','line_number':2737,'multiline':True]
['text':'
 * Restore the function call depth.  This is for cases where there is no
 * guarantee funcdepth_decrement() can be called exactly the same number of
 * times as funcdepth_increment().
 ','line_number':2746,'multiline':True]
['text':'
 * Allocate a funccall_T, link it in current_funccal and fill in "fp" and
 * "rettv".
 * Must be followed by one call to remove_funccal() or cleanup_function_call().
 * Returns NULL when allocation fails.
 ','line_number':2757,'multiline':True]
['text':'
 * To be called when returning from a compiled function; restores
 * current_funccal.
 ','line_number':2778,'multiline':True]
['text':'
 * Call a user function.
 ','line_number':2791,'multiline':True]
['text':' pointer to function','line_number':2796,'multiline':False]
['text':' nr of args','line_number':2797,'multiline':False]
['text':' arguments','line_number':2798,'multiline':False]
['text':' return value','line_number':2799,'multiline':False]
['text':' context','line_number':2800,'multiline':False]
['text':' Dictionary for "self"','line_number':2801,'multiline':False]
['text':' index in fc_fixvar[]','line_number':2812,'multiline':False]
['text':' If depth of calling is getting too high, don't execute the function.','line_number':2829,'multiline':False]
['text':' check for CTRL-C hit','line_number':2837,'multiline':False]
['text':' Check if this function has a breakpoint.','line_number':2843,'multiline':False]
['text':' Set up fields for closure.','line_number':2846,'multiline':False]
['text':' Execute the function, possibly compiling it first.','line_number':2854,'multiline':False]
['text':'
     * Note about using fc->fc_fixvar[]: This is an array of FIXVAR_CNT
     * variables with names up to VAR_SHORT_LEN long.  This avoids having to
     * alloc/free each argument variable and saves a lot of time.
     ','line_number':2876,'multiline':True]
['text':'
     * Init l: variables.
     ','line_number':2881,'multiline':True]
['text':' Set l:self to "selfdict".  Use "name" to avoid a warning from','line_number':2887,'multiline':False]
['text':' some compiler that checks the destination size.','line_number':2888,'multiline':False]
['text':'
     * Init a: variables, unless none found (in lambda).
     * Set a:0 to "argcount" less number of named arguments, if >= 0.
     * Set a:000 to a list with room for the "..." arguments.
     ','line_number':2900,'multiline':True]
['text':' Use "name" to avoid a warning from some compiler that checks the','line_number':2913,'multiline':False]
['text':' destination size.','line_number':2914,'multiline':False]
['text':'
     * Set a:firstline to "firstline" and a:lastline to "lastline".
     * Set a:name to named arguments.
     * Set a:N to the "..." arguments.
     * Skipped when no a: variables used (in lambda).
     ','line_number':2928,'multiline':True]
['text':' named argument a:name','line_number':2950,'multiline':False]
['text':' evaluate named argument default expression','line_number':2955,'multiline':False]
['text':' Bail out if no a: arguments used (in lambda).','line_number':2978,'multiline':False]
['text':' "..." argument a:1, a:2, etc.','line_number':2981,'multiline':False]
['text':' Note: the values are copied directly to avoid alloc/free.','line_number':2999,'multiline':False]
['text':' "argvars" must have VAR_FIXED for v_lock.','line_number':3000,'multiline':False]
['text':' Need to free this later, no matter where it's stored.','line_number':3005,'multiline':False]
['text':' Named arguments should be accessed without the "a:" prefix in','line_number':3010,'multiline':False]
['text':' lambda expressions.  Add to the l: dict.','line_number':3011,'multiline':False]
['text':' Don't redraw while executing the function.','line_number':3028,'multiline':False]
['text':' Do not want errors such as E724 here.','line_number':3061,'multiline':False]
['text':' don't overwrite this either','line_number':3079,'multiline':False]
['text':' "legacy" does not apply to commands in the function','line_number':3090,'multiline':False]
['text':' If called from a compiled :def function the execution context must be','line_number':3093,'multiline':False]
['text':' hidden, any deferred functions need to be added to the function being','line_number':3094,'multiline':False]
['text':' executed here.','line_number':3095,'multiline':False]
['text':' A Lambda always has the command "return {expr}".  It is much faster','line_number':3112,'multiline':False]
['text':' to evaluate {expr} directly.','line_number':3113,'multiline':False]
['text':' call do_cmdline() to execute the lines','line_number':3119,'multiline':False]
['text':' Invoke functions added with ":defer".','line_number':3123,'multiline':False]
['text':' when the function was aborted because of an error, return -1','line_number':3129,'multiline':False]
['text':' In corner cases returning a "failed" value is not backwards','line_number':3136,'multiline':False]
['text':' compatible.  Only do this for Vim9 script.','line_number':3137,'multiline':False]
['text':' when being verbose, mention the return value','line_number':3152,'multiline':False]
['text':' The value may be very long.  Skip the middle part, so that we','line_number':3170,'multiline':False]
['text':' have some idea how it starts and ends. smsg() would always','line_number':3171,'multiline':False]
['text':' truncate it at the end. Don't want errors such as E724 here.','line_number':3172,'multiline':False]
['text':' don't overwrite this either','line_number':3187,'multiline':False]
['text':' don't overwrite this either','line_number':3212,'multiline':False]
['text':'
 * Check the argument count for user function "fp".
 * Return FCERR_UNKNOWN if OK, FCERR_TOOFEW or FCERR_TOOMANY otherwise.
 ','line_number':3227,'multiline':True]
['text':'
 * Call a user function after checking the arguments.
 ','line_number':3243,'multiline':True]
['text':'
	 * Call the user function.
	 * Save and restore search patterns, script variables and
	 * redo buffer.
	 ','line_number':3281,'multiline':True]
['text':' Function was unreferenced while being used, free it now.','line_number':3296,'multiline':False]
['text':'
 * Save the current function call pointer, and set it to NULL.
 * Used when executing autocommands and for ":source".
 ','line_number':3308,'multiline':True]
['text':'
 * Return TRUE when currently at the script level:
 * - not in a function
 * - not executing an autocommand
 * Note that when an autocommand sources a script the result is FALSE;
 ','line_number':3339,'multiline':True]
['text':'
 * Mark all functions of script "sid" as deleted.
 ','line_number':3351,'multiline':True]
['text':' Function is executing, don't free it but do remove','line_number':3384,'multiline':False]
['text':' it from the hashtable.','line_number':3385,'multiline':False]
['text':' When clearing a function another function can be','line_number':3392,'multiline':False]
['text':' cleared as a side effect.  When that happens start','line_number':3393,'multiline':False]
['text':' over.','line_number':3394,'multiline':False]
['text':' Clean up the current_funccal chain and the funccal stack.','line_number':3414,'multiline':False]
['text':' First clear what the functions contain.  Since this may lower the','line_number':3423,'multiline':False]
['text':' reference count of a function, it may also free a function and change','line_number':3424,'multiline':False]
['text':' the hash table. Restart if that happens.','line_number':3425,'multiline':False]
['text':' clear the def function index now','line_number':3432,'multiline':False]
['text':' Only free functions that are not refcounted, those are','line_number':3437,'multiline':False]
['text':' supposed to be freed when no longer referenced.','line_number':3438,'multiline':False]
['text':' Now actually free the functions.  Need to start all over every time,','line_number':3455,'multiline':False]
['text':' because func_free() may change the hash table.','line_number':3456,'multiline':False]
['text':' Only free functions that are not refcounted, those are','line_number':3465,'multiline':False]
['text':' supposed to be freed when no longer referenced.','line_number':3466,'multiline':False]
['text':' did not actually free it','line_number':3477,'multiline':False]
['text':'
 * Return TRUE if "name" looks like a builtin function name: starts with a
 * lower case letter, doesn't contain AUTOLOAD_CHAR or ':', no "." after the
 * name.
 * "len" is the length of "name", or -1 for NUL terminated.
 ','line_number':3489,'multiline':True]
['text':' "name.something" is not a builtin function','line_number':3508,'multiline':False]
['text':' Make a copy of each argument.  This is needed to be able to set','line_number':3539,'multiline':False]
['text':' v_lock to VAR_FIXED in the copy without changing the original list.','line_number':3540,'multiline':False]
['text':' Free the arguments.','line_number':3563,'multiline':False]
['text':'
 * Invoke call_func() with a callback.
 * Returns FAIL if the callback could not be called.
 ','line_number':3578,'multiline':True]
['text':' length of "name" or -1 to use strlen()','line_number':3585,'multiline':False]
['text':' return value goes here','line_number':3586,'multiline':False]
['text':' number of "argvars"','line_number':3587,'multiline':False]
['text':' vars for arguments, must have "argcount"','line_number':3588,'multiline':False]
['text':' PLUS ONE elements!','line_number':3589,'multiline':False]
['text':' When a :def function was called that uses :try an error would be turned','line_number':3616,'multiline':False]
['text':' into an exception.  Need to give the error here.','line_number':3617,'multiline':False]
['text':'
 * call the 'callback' function and return the result as a number.
 * Returns -2 when calling the function fails.  Uses argv[0] to argv[argc - 1]
 * for the function arguments. argv[argc] should have type VAR_UNKNOWN.
 ','line_number':3627,'multiline':True]
['text':' number of "argvars"','line_number':3635,'multiline':False]
['text':' vars for arguments, must have "argcount"','line_number':3636,'multiline':False]
['text':' PLUS ONE elements!','line_number':3637,'multiline':False]
['text':'
 * Give an error message for the result of a function.
 * Nothing if "error" is FCERR_NONE.
 ','line_number':3650,'multiline':True]
['text':' assume the error message was already given','line_number':3686,'multiline':False]
['text':'
 * Check the argument types "argvars[argcount]" for "name" using the
 * information in "funcexe".  When "base_included" then "funcexe->fe_basetv"
 * is already included in "argvars[]".
 * Will do nothing if "funcexe->fe_check_type" is NULL or
 * "funcexe->fe_evaluate" is FALSE;
 * Returns an FCERR_ value.
 ','line_number':3693,'multiline':True]
['text':' Check that the argument types are OK for the types of the funcref.','line_number':3711,'multiline':False]
['text':'
 * Call a function with its resolved parameters
 *
 * Return FAIL when the function can't be called,  OK otherwise.
 * Also returns OK when an error was encountered while executing the function.
 ','line_number':3721,'multiline':True]
['text':' name of the function','line_number':3729,'multiline':False]
['text':' length of "name" or -1 to use strlen()','line_number':3730,'multiline':False]
['text':' return value goes here','line_number':3731,'multiline':False]
['text':' number of "argvars"','line_number':3732,'multiline':False]
['text':' vars for arguments, must have "argcount"','line_number':3733,'multiline':False]
['text':' PLUS ONE elements!','line_number':3734,'multiline':False]
['text':' more arguments','line_number':3735,'multiline':False]
['text':' used when "partial" or','line_number':3748,'multiline':False]
['text':' "funcexe->fe_basetv" is not NULL','line_number':3749,'multiline':False]
['text':' Initialize rettv so that it is safe for caller to invoke clear_tv(rettv)','line_number':3756,'multiline':False]
['text':' even when call_func() returns FAIL.','line_number':3757,'multiline':False]
['text':' Make a copy of the name, if it comes from a funcref variable it','line_number':3767,'multiline':False]
['text':' could be changed or deleted in the called function.','line_number':3768,'multiline':False]
['text':' When the function has a partial with a dict and there is a dict','line_number':3781,'multiline':False]
['text':' argument, use the dict argument.  That is backwards compatible.','line_number':3782,'multiline':False]
['text':' When the dict was bound explicitly use the one from the partial.','line_number':3783,'multiline':False]
['text':' Now funcexe->fe_check_type is missing the added arguments,','line_number':3805,'multiline':False]
['text':' make a copy of the type with the correction.','line_number':3806,'multiline':False]
['text':' check the argument types if possible','line_number':3821,'multiline':False]
['text':' Skip "g:" before a function name.','line_number':3830,'multiline':False]
['text':' default rettv is number zero','line_number':3837,'multiline':False]
['text':'
	     * User defined function.
	     ','line_number':3843,'multiline':True]
['text':' In Vim9 script g: is required to find a global','line_number':3851,'multiline':False]
['text':' non-autoload function.','line_number':3852,'multiline':False]
['text':' Trigger FuncUndefined event, may load the function.','line_number':3856,'multiline':False]
['text':' executed an autocommand, search for the function again','line_number':3862,'multiline':False]
['text':' Try loading a package.','line_number':3865,'multiline':False]
['text':' loaded a package, search for the function again','line_number':3868,'multiline':False]
['text':' If using Vim9 script try not local to the script.','line_number':3875,'multiline':False]
['text':' Don't do this if the name starts with "s:".','line_number':3876,'multiline':False]
['text':' postponed filling in the arguments, do it now','line_number':3894,'multiline':False]
['text':' Method call: base->Method()','line_number':3902,'multiline':False]
['text':' Check the argument types now that the function type and all','line_number':3911,'multiline':False]
['text':' argument values are known, if not done above.','line_number':3912,'multiline':False]
['text':'
	     * expr->method(): Find the method name in the table, call its
	     * implementation with the base as one of the arguments.
	     ','line_number':3923,'multiline':True]
['text':'
	     * Find the function name in the table, call its implementation.
	     ','line_number':3932,'multiline':True]
['text':'
	 * The function call (or "FuncUndefined" autocommand sequence) might
	 * have been aborted by an error, an interrupt, or an explicitly thrown
	 * exception that has not been caught so far.  This situation can be
	 * tested for by calling aborting().  For an error in an internal
	 * function or for the "E132" error in call_user_func(), however, the
	 * throw point at which the "force_abort" flag (temporarily reset by
	 * emsg()) is normally updated has not been reached yet. We need to
	 * update that flag first to make aborting() reliable.
	 ','line_number':3938,'multiline':True]
['text':'
     * Report an error unless the argument evaluation or function call has been
     * cancelled due to an aborting error, an interrupt, or an exception.
     ','line_number':3954,'multiline':True]
['text':' clear the copies made from the partial','line_number':3962,'multiline':False]
['text':'
 * Call a function without arguments, partial or dict.
 * This is like call_func() when the call is only "FuncName()".
 * To be used by "expr" options.
 * Returns NOTDONE when the function could not be found.
 ','line_number':3972,'multiline':True]
['text':' name of the function','line_number':3980,'multiline':False]
['text':' length of "name" or -1 to use strlen()','line_number':3981,'multiline':False]
['text':' return value goes here','line_number':3982,'multiline':False]
['text':' default rettv is number zero','line_number':3994,'multiline':False]
['text':' Make a copy of the name, an option can be changed in the function.','line_number':3997,'multiline':False]
['text':' Skip "g:" before a function name.','line_number':4004,'multiline':False]
['text':' In Vim9 script g: is required to find a global non-autoload','line_number':4015,'multiline':False]
['text':' function.','line_number':4016,'multiline':False]
['text':'
 * When "prev_ht_changed" does not equal "ht_changed" give an error and return
 * TRUE.  Otherwise return FALSE.
 ','line_number':4049,'multiline':True]
['text':'
 * List the head of the function: "function name(arg1, arg2)".
 ','line_number':4064,'multiline':True]
['text':' a timer at the more prompt may have deleted the function','line_number':4075,'multiline':False]
['text':'
 * Get a function name, translating "<SID>" and "<SNR>".
 * Also handles a Funcref in a List or Dictionary.
 * Returns the function name in allocated memory, or NULL for failure.
 * Set "*is_global" to TRUE when the function must be global, unless
 * "is_global" is NULL.
 * flags:
 * TFN_INT:	    internal function name OK
 * TFN_IN_CLASS:    function in a class
 * TFN_QUIET:	    be quiet
 * TFN_NO_AUTOLOAD: do not use script autoloading
 * TFN_NO_DEREF:    do not dereference a Funcref
 * Advances "pp" to just after the function name (if no error).
 ','line_number':4159,'multiline':True]
['text':' only find the end, don't evaluate','line_number':4177,'multiline':False]
['text':'
 * trans_function_name() with extra arguments.
 * "fdp", "partial", "type" and "ufunc" can be NULL.
 ','line_number':4184,'multiline':True]
['text':' only find the end, don't evaluate','line_number':4192,'multiline':False]
['text':' return: info about dictionary used','line_number':4194,'multiline':False]
['text':' return: partial of a FuncRef','line_number':4195,'multiline':False]
['text':' return: type of funcref','line_number':4196,'multiline':False]
['text':' return: function','line_number':4197,'multiline':False]
['text':' Check for hard coded <SNR>: already translated function ID (from a user','line_number':4215,'multiline':False]
['text':' command).','line_number':4216,'multiline':False]
['text':' A name starting with "<SID>" or "<SNR>" is local to a script.  But','line_number':4225,'multiline':False]
['text':' don't skip over "s:", get_lval() needs it for "s:dict.func".','line_number':4226,'multiline':False]
['text':' Note that TFN_ flags use the same values as GLV_ flags.','line_number':4231,'multiline':False]
['text':'
	 * Report an invalid expression in braces, unless the expression
	 * evaluation has been cancelled due to an aborting error, an
	 * interrupt, or an exception.
	 ','line_number':4244,'multiline':True]
['text':' Error found, but continue after the function name.','line_number':4310,'multiline':False]
['text':' Check if the name is a Funcref.  If so, use the value.','line_number':4315,'multiline':False]
['text':' function in another script.  Prefix <SNR>99_ or the autoload prefix.','line_number':4329,'multiline':False]
['text':' Change "<SNR>" to the byte sequence.','line_number':4362,'multiline':False]
['text':' When there was "s:" already or the name expanded to get a','line_number':4377,'multiline':False]
['text':' leading "s:" then remove it.','line_number':4378,'multiline':False]
['text':' skip over "s:" and "g:"','line_number':4386,'multiline':False]
['text':' dropping "g:" without setting "is_global" won't work in','line_number':4397,'multiline':False]
['text':' Vim9script, put it back later','line_number':4398,'multiline':False]
['text':' In Vim9 script a user function is script-local by default, unless it','line_number':4414,'multiline':False]
['text':' starts with a lower case character: dict.func().  Or when in a class.','line_number':4415,'multiline':False]
['text':'
     * Copy the function name to allocated memory.
     * Accept <SID>name() inside a script, translate into <SNR>123_name().
     * Accept <SNR>123_name() outside a script.
     ','line_number':4419,'multiline':True]
['text':' do nothing','line_number':4425,'multiline':False]
['text':' It's script-local, "s:" or "<SID>"','line_number':4442,'multiline':False]
['text':' The function name must start with an upper case letter (unless it is a','line_number':4455,'multiline':False]
['text':' Vim9 class new() function or a Vim9 class private method)','line_number':4456,'multiline':False]
['text':' If it's "<SID>"','line_number':4488,'multiline':False]
['text':'
 * Assuming "name" is the result of trans_function_name() and it was prefixed
 * to use the script-local name, return the unmodified name (points into
 * "name").  Otherwise return NULL.
 * This can be used to first search for a script-local function and fall back
 * to the global function if not found.
 ','line_number':4506,'multiline':True]
['text':'
 * If the 'funcname' starts with "s:" or "<SID>", then expands it to the
 * current script ID and returns the expanded function name. The caller should
 * free the returned name. If not called from a script context or the function
 * name doesn't start with these prefixes, then returns NULL.
 * This doesn't check whether the script-local function exists or not.
 ','line_number':4527,'multiline':True]
['text':' The function name does not have a script-local prefix.  Try finding','line_number':4550,'multiline':False]
['text':' it when in a Vim9 script and there is no "g:" prefix.','line_number':4551,'multiline':False]
['text':' Expand s: prefix into <SNR>nr_<name>','line_number':4569,'multiline':False]
['text':'
 * Return script-local "fname" with the 3-byte sequence replaced by
 * printable <SNR> in allocated memory.
 ','line_number':4581,'multiline':True]
['text':'
 * Call trans_function_name(), except that a lambda is returned as-is.
 * Returns the name in allocated memory.
 ','line_number':4598,'multiline':True]
['text':'
 * List functions.  When "regmatch" is NULL all of then.
 * Otherwise functions matching "regmatch".
 ','line_number':4628,'multiline':True]
['text':'
 * ":function" also supporting nested ":def".
 * When "name_arg" is not NULL this is a nested function, using "name_arg" for
 * the function name.
 * "lines_to_free" is a list of strings to be freed later.
 * If "class_flags" has CF_CLASS then the function is defined inside a class.
 * With CF_INTERFACE the function is define inside an interface, only the
 * ":def"/":function" line is expected, no function body.
 * Returns a pointer to the function or NULL if no function defined.
 ','line_number':4662,'multiline':True]
['text':' number for nameless function','line_number':4704,'multiline':False]
['text':'
     * ":function" without argument: list functions.
     ','line_number':4711,'multiline':True]
['text':'
     * ":function /pat": list functions matching pattern.
     ','line_number':4722,'multiline':True]
['text':'
     * Get the function name.  There are these situations:
     * func	    normal function name, also when "class_flags" is non-zero
     *		    "name" == func, "fudi.fd_dict" == NULL
     * dict.func    new dictionary entry
     *		    "name" == NULL, "fudi.fd_dict" set,
     *		    "fudi.fd_di" == NULL, "fudi.fd_newkey" == func
     * dict.func    existing dict entry with a Funcref
     *		    "name" == func, "fudi.fd_dict" set,
     *		    "fudi.fd_di" set, "fudi.fd_newkey" == NULL
     * dict.func    existing dict entry that's not a Funcref
     *		    "name" == NULL, "fudi.fd_dict" set,
     *		    "fudi.fd_di" set, "fudi.fd_newkey" == NULL
     * s:func	    script-local function name
     * g:func	    global function name, same as "func"
     ','line_number':4754,'multiline':True]
['text':' nested function, argument is (args).','line_number':4773,'multiline':False]
['text':'
	     * Return on an invalid expression in braces, unless the expression
	     * evaluation has been cancelled due to an aborting error, an
	     * interrupt, or an exception.
	     ','line_number':4802,'multiline':True]
['text':' For "export def FuncName()" in an autoload script the function name','line_number':4819,'multiline':False]
['text':' is stored with the legacy autoload name "dir#script#FuncName" so','line_number':4820,'multiline':False]
['text':' that it can also be found in legacy script.','line_number':4821,'multiline':False]
['text':' An error in a function call during evaluation of an expression in magic','line_number':4840,'multiline':False]
['text':' braces should not cause the function not to be defined.','line_number':4841,'multiline':False]
['text':'
     * ":function func" with only function name: list function.
     ','line_number':4845,'multiline':True]
['text':' With Vim9 script the name was made script-local, if not','line_number':4865,'multiline':False]
['text':' found try again with the original name.','line_number':4866,'multiline':False]
['text':' Check no function was added or removed from a timer, e.g. at','line_number':4873,'multiline':False]
['text':' the more prompt.  "fp" may then be invalid.','line_number':4874,'multiline':False]
['text':' show a line at a time','line_number':4892,'multiline':False]
['text':'
     * ":function name(arg1, arg2)" Define function.
     ','line_number':4914,'multiline':True]
['text':' attempt to continue by skipping some text','line_number':4925,'multiline':False]
['text':' In Vim9 script only global functions can be redefined.','line_number':4936,'multiline':False]
['text':' Check the name of the function.  Unless it's a dictionary function','line_number':4947,'multiline':False]
['text':' (that we are overwriting).','line_number':4948,'multiline':False]
['text':' In Vim9 script a function cannot have the same name as a','line_number':4975,'multiline':False]
['text':' variable.','line_number':4976,'multiline':False]
['text':' Disallow using the g: dict.','line_number':4986,'multiline':False]
['text':' This may get more lines and make the pointers into the first line','line_number':4994,'multiline':False]
['text':' invalid.','line_number':4995,'multiline':False]
['text':' find the return type: :def Func(): type','line_number':5007,'multiline':False]
['text':' find extra arguments "range", "dict", "abort" and "closure"','line_number':5034,'multiline':False]
['text':' When there is a line break use what follows for the function body.','line_number':5069,'multiline':False]
['text':' Makes 'exe "func Test()\n...\nendfunc"' work.','line_number':5070,'multiline':False]
['text':'
     * Read the body of the function, until "}", ":endfunction" or ":enddef" is
     * found.
     ','line_number':5082,'multiline':True]
['text':' Check if the function already exists, don't let the user type the','line_number':5088,'multiline':False]
['text':' whole function before telling him it doesn't work!  For a script we','line_number':5089,'multiline':False]
['text':' need to skip the body to be able to find what follows.','line_number':5090,'multiline':False]
['text':' don't overwrite the function name','line_number':5102,'multiline':False]
['text':' Save the starting line number.','line_number':5106,'multiline':False]
['text':' Do not define the function when getting the body fails and when','line_number':5109,'multiline':False]
['text':' skipping.','line_number':5110,'multiline':False]
['text':'
     * If there are no errors, add the function
     ','line_number':5118,'multiline':True]
['text':' Can't add a function to a locked dictionary','line_number':5133,'multiline':False]
['text':' Can't change an existing function if it is locked','line_number':5137,'multiline':False]
['text':' Give the function a sequential number.  Can only be used with a','line_number':5141,'multiline':False]
['text':' Funcref!','line_number':5142,'multiline':False]
['text':' Only check if the function already exists in the script,','line_number':5172,'multiline':False]
['text':' global functions can be shadowed.','line_number':5173,'multiline':False]
['text':' Function can be replaced with "function!" and when sourcing the','line_number':5208,'multiline':False]
['text':' same script again, but only once.','line_number':5209,'multiline':False]
['text':' A name that is used by an import can not be overruled.','line_number':5210,'multiline':False]
['text':' This function is referenced somewhere, don't redefine it but','line_number':5231,'multiline':False]
['text':' create a new one.','line_number':5232,'multiline':False]
['text':' redefine existing function, keep the expanded name','line_number':5242,'multiline':False]
['text':' Check that the autoload name matches the script name.','line_number':5264,'multiline':False]
['text':' add new dict entry','line_number':5301,'multiline':False]
['text':' overwrite existing dict entry','line_number':5316,'multiline':False]
['text':' behave like "dict" was used','line_number':5321,'multiline':False]
['text':' error messages are for the first function line','line_number':5337,'multiline':False]
['text':' The function may use script variables from the context.','line_number':5340,'multiline':False]
['text':' parse the return type, if any','line_number':5352,'multiline':False]
['text':' insert the new function in the function list','line_number':5366,'multiline':False]
['text':' let do_one_cmd() know the export worked.','line_number':5410,'multiline':False]
['text':' :func does not use Vim9 script syntax, even in a Vim9 script file','line_number':5417,'multiline':False]
['text':' these were set to "newargs" and "default_args", which are cleared','line_number':5425,'multiline':False]
['text':' below','line_number':5426,'multiline':False]
['text':'
 * ":function"
 ','line_number':5454,'multiline':True]
['text':'
 * Find a function by name, including "<lambda>123".
 * Check for "profile" and "debug" arguments and set"compile_type".
 * Caller should initialize "compile_type" to CT_NONE.
 * Return NULL if not found.
 ','line_number':5467,'multiline':True]
['text':' First try finding a method in a class, trans_function_name() will','line_number':5500,'multiline':False]
['text':' give an error if the function is not found.','line_number':5501,'multiline':False]
['text':' Try again without making it script-local.','line_number':5533,'multiline':False]
['text':'
 * :defcompile - compile all :def functions in the current script that need to
 * be compiled or the one specified by the argument.
 * Skips dead functions.  Doesn't do profiling.
 ','line_number':5542,'multiline':True]
['text':' a function has been added or removed, need to start','line_number':5582,'multiline':False]
['text':' over','line_number':5583,'multiline':False]
['text':'
 * Return 5 if "p" starts with "<SID>" or "<SNR>" (ignoring case).
 * Return 2 if "p" starts with "s:".
 * Return 0 otherwise.
 ','line_number':5595,'multiline':True]
['text':' Use MB_STRICMP() because in Turkish comparing the "I" may not work with','line_number':5603,'multiline':False]
['text':' the standard library function.','line_number':5604,'multiline':False]
['text':'
 * Return TRUE when "ufunc" has old-style "..." varargs
 * or named varargs "...name: type".
 ','line_number':5621,'multiline':True]
['text':'
 * Return TRUE if a function "name" exists.
 * If "no_defef" is TRUE, do not dereference a Funcref.
 ','line_number':5631,'multiline':True]
['text':' Only accept "funcname", "funcname ", "funcname (..." and','line_number':5650,'multiline':False]
['text':' "funcname(...", not "funcname!...".','line_number':5651,'multiline':False]
['text':'
 * Function given to ExpandGeneric() to obtain the list of user defined
 * function names.
 ','line_number':5677,'multiline':True]
['text':' don't show dead, dict and lambda functions','line_number':5703,'multiline':False]
['text':' prevents overflow','line_number':5709,'multiline':False]
['text':'
 * Make a copy of a function.
 * Intended to be used for a function defined on a base class that has a copy
 * on the child class.
 * The copy has uf_refcount set to one.
 * Returns NULL when out of memory.
 ','line_number':5724,'multiline':True]
['text':' Most things can just be copied.','line_number':5738,'multiline':False]
['text':' "uf_arg_types" is an allocated array, make a copy.','line_number':5750,'multiline':False]
['text':' TODO: how about the types themselves? they can be freed when the','line_number':5760,'multiline':False]
['text':' original function is freed:','line_number':5761,'multiline':False]
['text':'    type_T	**uf_arg_types;','line_number':5762,'multiline':False]
['text':'    type_T	*uf_ret_type;','line_number':5763,'multiline':False]
['text':' make uf_type_list empty','line_number':5765,'multiline':False]
['text':' TODO:   partial_T	*uf_partial;','line_number':5768,'multiline':False]
['text':' TODO:','line_number':5773,'multiline':False]
['text':'    type_T	*uf_va_type;','line_number':5774,'multiline':False]
['text':'    type_T	*uf_func_type;','line_number':5775,'multiline':False]
['text':'
 * ":delfunction {name}"
 ','line_number':5789,'multiline':True]
['text':' Delete the dict item that refers to the function, it will','line_number':5853,'multiline':False]
['text':' invoke func_unref() and possibly delete the function.','line_number':5854,'multiline':False]
['text':' A normal function (not a numbered function or lambda) has a','line_number':5859,'multiline':False]
['text':' refcount of 1 for the entry in the hashtable.  When deleting','line_number':5860,'multiline':False]
['text':' it and the refcount is more than one, it should be kept.','line_number':5861,'multiline':False]
['text':' A numbered function and lambda should be kept if the refcount is','line_number':5862,'multiline':False]
['text':' one or more.','line_number':5863,'multiline':False]
['text':' Function is still referenced somewhere.  Don't free it but','line_number':5866,'multiline':False]
['text':' do remove it from the hashtable.','line_number':5867,'multiline':False]
['text':'
 * Unreference a Function: decrement the reference count and free it when it
 * becomes zero.
 ','line_number':5877,'multiline':True]
['text':'
 * Unreference a Function: decrement the reference count and free it when it
 * becomes zero.
 * Also when it becomes one and uf_partial points to the function.
 ','line_number':5899,'multiline':True]
['text':' Only delete it when it's not being used.  Otherwise it's done','line_number':5912,'multiline':False]
['text':' when "uf_calls" becomes zero.','line_number':5913,'multiline':False]
['text':'
 * Count a reference to a Function.
 ','line_number':5919,'multiline':True]
['text':' Only give an error for a numbered function.','line_number':5933,'multiline':False]
['text':' Fail silently, when named or lambda function isn't found.','line_number':5934,'multiline':False]
['text':'
 * Count a reference to a Function.
 ','line_number':5938,'multiline':True]
['text':'
 * Return TRUE if items in "fc" do not have "copyID".  That means they are not
 * referenced from anywhere that is in use.
 ','line_number':5948,'multiline':True]
['text':'
 * ":return [expr]"
 ','line_number':5961,'multiline':True]
['text':' It's safer to return also on error.','line_number':5993,'multiline':False]
['text':' In return statement, cause_abort should be force_abort.','line_number':5996,'multiline':False]
['text':'
	 * Return unless the expression evaluation has been cancelled due to an
	 * aborting error, an interrupt, or an exception.
	 ','line_number':5999,'multiline':True]
['text':' When skipping or the return gets pending, advance to the next command','line_number':6007,'multiline':False]
['text':' in this line (!returning).  Otherwise, ignore the rest of the line.','line_number':6008,'multiline':False]
['text':' Following lines will be ignored by get_func_line().','line_number':6009,'multiline':False]
['text':' no argument','line_number':6012,'multiline':False]
['text':'
 * Lower level implementation of "call".  Only called when not skipping.
 ','line_number':6020,'multiline':True]
['text':' If the function deleted lines or switched to another buffer','line_number':6046,'multiline':False]
['text':' the line number may become invalid.','line_number':6047,'multiline':False]
['text':' clear_tv() uses this','line_number':6059,'multiline':False]
['text':' Handle a function returning a Funcref, Dictionary or List.','line_number':6068,'multiline':False]
['text':' Stop when immediately aborting on error, or when an interrupt','line_number':6080,'multiline':False]
['text':' occurred or an exception was thrown but not caught.','line_number':6081,'multiline':False]
['text':' get_func_tv() returned OK, so that the check for trailing','line_number':6082,'multiline':False]
['text':' characters below is executed.','line_number':6083,'multiline':False]
['text':'
 * Core part of ":defer func(arg)".  "arg" points to the "(" and is advanced.
 * Returns FAIL or OK.
 ','line_number':6090,'multiline':True]
['text':' vars for arguments','line_number':6102,'multiline':False]
['text':' number of partial arguments','line_number':6103,'multiline':False]
['text':' number of arguments found','line_number':6104,'multiline':False]
['text':' Check that the arguments are OK for the types of the funcref.','line_number':6136,'multiline':False]
['text':' we tolerate an unknown function here, it might be defined later','line_number':6155,'multiline':False]
['text':'
 * Return TRUE if currently inside a function call.
 * Give an error message and return FALSE when not.
 ','line_number':6177,'multiline':True]
['text':'
 * Add a deferred call for "name" with arguments "argvars[argcount]".
 * Consumes "argvars[]".
 * Caller must check that in_def_function() returns TRUE or current_funccal is
 * not NULL.
 * Returns OK or FAIL.
 ','line_number':6192,'multiline':True]
['text':'
 * Invoked after a functions has finished: invoke ":defer" functions.
 ','line_number':6238,'multiline':True]
['text':' already being called, can happen if function does ":qa"','line_number':6251,'multiline':False]
['text':' clear_tv() uses this','line_number':6259,'multiline':False]
['text':' If the deferred function is called after an exception, then only the','line_number':6264,'multiline':False]
['text':' first statement in the function will be executed (because of the','line_number':6265,'multiline':False]
['text':' exception).  So save and restore the try/catch/throw exception','line_number':6266,'multiline':False]
['text':' state.','line_number':6267,'multiline':False]
['text':' :def function','line_number':6289,'multiline':False]
['text':' legacy function','line_number':6295,'multiline':False]
['text':'
 * Called when exiting: call all defer functions.
 ','line_number':6300,'multiline':True]
['text':'
 * ":1,25call func(arg1, arg2)"	function call.
 * ":defer func(arg1, arg2)"    deferred function call.
 ','line_number':6314,'multiline':True]
['text':' trans_function_name() doesn't work well when skipping, use eval0()','line_number':6340,'multiline':False]
['text':' instead to skip to any following command, e.g. for:','line_number':6341,'multiline':False]
['text':'   :if 0 | call dict.foo().bar() | endif','line_number':6342,'multiline':False]
['text':' Still need to give an error message for missing key.','line_number':6355,'multiline':False]
['text':' Increase refcount on dictionary, it could get deleted when evaluating','line_number':6362,'multiline':False]
['text':' the arguments.','line_number':6363,'multiline':False]
['text':' If it is the name of a variable of type VAR_FUNC or VAR_PARTIAL use its','line_number':6367,'multiline':False]
['text':' contents.  For VAR_PARTIAL get its partial, unless we already have one','line_number':6368,'multiline':False]
['text':' from trans_function_name().','line_number':6369,'multiline':False]
['text':' Skip white space to allow ":call func ()".  Not good, but required for','line_number':6375,'multiline':False]
['text':' backward compatibility.','line_number':6376,'multiline':False]
['text':' When inside :try we need to check for following "| catch" or "| endtry".','line_number':6410,'multiline':False]
['text':' Not when there was an error, but do check if an exception was thrown.','line_number':6411,'multiline':False]
['text':' Check for trailing illegal characters and a following command.','line_number':6414,'multiline':False]
['text':' Must be after using "arg", it may point into memory cleared here.','line_number':6427,'multiline':False]
['text':'
 * Return from a function.  Possibly makes the return pending.  Also called
 * for a pending return at the ":endtry" or after returning from an extra
 * do_cmdline().  "reanimate" is used in the latter case.  "is_cmd" is set
 * when called due to a ":return" command.  "rettv" may point to a typval_T
 * with the return rettv.  Returns TRUE when the return can be carried out,
 * FALSE when the return gets pending.
 ','line_number':6435,'multiline':True]
['text':' Undo the return.','line_number':6454,'multiline':False]
['text':'
     * Cleanup (and inactivate) conditionals, but stop when a try conditional
     * not in its finally clause (which then is to be executed next) is found.
     * In this case, make the ":return" pending for execution at the ":endtry".
     * Otherwise, return normally.
     ','line_number':6457,'multiline':True]
['text':' A pending return again gets pending.  "rettv" points to an','line_number':6469,'multiline':False]
['text':' allocated variable with the rettv of the original ":return"'s','line_number':6470,'multiline':False]
['text':' argument if present or is NULL else.','line_number':6471,'multiline':False]
['text':' When undoing a return in order to make it pending, get the stored','line_number':6475,'multiline':False]
['text':' return rettv.','line_number':6476,'multiline':False]
['text':' Store the value of the pending return.','line_number':6482,'multiline':False]
['text':' The pending return value could be overwritten by a ":return"','line_number':6493,'multiline':False]
['text':' without argument in a finally clause; reset the default','line_number':6494,'multiline':False]
['text':' return value.','line_number':6495,'multiline':False]
['text':' If the return is carried out now, store the return value.  For','line_number':6506,'multiline':False]
['text':' a return immediately after reanimation, the value is already','line_number':6507,'multiline':False]
['text':' there.','line_number':6508,'multiline':False]
['text':'
 * Free the variable with a pending return value.
 ','line_number':6521,'multiline':True]
['text':'
 * Generate a return command for producing the value of "rettv".  The result
 * is an allocated string.  Used by report_pending() for verbose messages.
 ','line_number':6530,'multiline':True]
['text':'
 * Get next function line.
 * Called by do_cmdline() to get the next line.
 * Returns allocated string, or NULL for end of function.
 ','line_number':6554,'multiline':True]
['text':' growarray with function lines','line_number':6569,'multiline':False]
['text':' If breakpoints have been added/deleted need to check for it.','line_number':6571,'multiline':False]
['text':' Skip NULL lines (continuation lines).','line_number':6589,'multiline':False]
['text':' Did we encounter a breakpoint?','line_number':6606,'multiline':False]
['text':' Find next breakpoint.','line_number':6610,'multiline':False]
['text':'
 * Return TRUE if the currently active function should be ended, because a
 * return was encountered or an error occurred.  Used inside a ":while".
 ','line_number':6619,'multiline':True]
['text':' Ignore the "abort" flag if the abortion behavior has been changed due to','line_number':6628,'multiline':False]
['text':' an error inside a try conditional.','line_number':6629,'multiline':False]
['text':'
 * return TRUE if cookie indicates a function which "abort"s on errors.
 ','line_number':6635,'multiline':True]
['text':'
 * Turn "dict.Func" into a partial for "Func" bound to "dict".
 * Don't do this when "Func" is already a partial that was bound
 * explicitly (pt_auto is FALSE).
 * Changes "rettv" in-place.
 * Returns the updated "selfdict_in".
 ','line_number':6646,'multiline':True]
['text':' There is no point binding a dict to a NULL function, just create','line_number':6671,'multiline':False]
['text':' a function reference.','line_number':6672,'multiline':False]
['text':' Translate "s:func" to the stored function name.','line_number':6681,'multiline':False]
['text':' Just a function: Take over the function name and use','line_number':6700,'multiline':False]
['text':' selfdict.','line_number':6701,'multiline':False]
['text':' Partial: copy the function name, use selfdict and copy','line_number':6709,'multiline':False]
['text':' args.  Can't take over name or args, the partial might','line_number':6710,'multiline':False]
['text':' be referenced elsewhere.','line_number':6711,'multiline':False]
['text':' out of memory: drop the arguments','line_number':6726,'multiline':False]
['text':'
 * Return the name of the executed function.
 ','line_number':6744,'multiline':True]
['text':'
 * Return the address holding the next breakpoint line for a funccall cookie.
 ','line_number':6753,'multiline':True]
['text':'
 * Return the address holding the debug tick for a funccall cookie.
 ','line_number':6762,'multiline':True]
['text':'
 * Return the nesting level for a funccall cookie.
 ','line_number':6771,'multiline':True]
['text':'
 * Return TRUE when a function was ended by a ":return" command.
 ','line_number':6780,'multiline':True]
['text':' When a funccal was freed some more items might be garbage','line_number':6810,'multiline':False]
['text':' collected, so run again.','line_number':6811,'multiline':False]
['text':'
 * Get function call environment based on backtrace debug level
 ','line_number':6817,'multiline':True]
['text':' backtrace level overflow. reset to max','line_number':6836,'multiline':False]
['text':'
 * Return the hashtable used for local variables in the current funccal.
 * Return NULL if there is no current funccal.
 ','line_number':6843,'multiline':True]
['text':'
 * Return the l: scope variable.
 * Return NULL if there is no current funccal.
 ','line_number':6855,'multiline':True]
['text':'
 * Return the hashtable used for argument in the current funccal.
 * Return NULL if there is no current funccal.
 ','line_number':6867,'multiline':True]
['text':'
 * Return the a: scope variable.
 * Return NULL if there is no current funccal.
 ','line_number':6879,'multiline':True]
['text':'
 * List function variables, if there is a function.
 ','line_number':6891,'multiline':True]
['text':'
 * If "ht" is the hashtable for local variables in the current funccal, return
 * the dict that contains it.
 * Otherwise return NULL.
 ','line_number':6902,'multiline':True]
['text':'
 * Search hashitem in parent scope.
 ','line_number':6916,'multiline':True]
['text':' Search in parent scope, which can be referenced from a lambda.','line_number':6930,'multiline':False]
['text':'
 * Search variable in parent scope.
 ','line_number':6953,'multiline':True]
['text':' Search in parent scope which is possible to reference from lambda','line_number':6967,'multiline':False]
['text':'
 * Set "copyID + 1" in previous_funccal and callers.
 ','line_number':6987,'multiline':True]
['text':'
 * Set "copyID" in all local vars and arguments in the call stack.
 ','line_number':7021,'multiline':True]
['text':' Also go through the funccal_stack.','line_number':7034,'multiline':False]
['text':'
 * Set "copyID" in all functions available by name.
 ','line_number':7042,'multiline':True]
['text':'
 * Set "copyID" in all function arguments.
 ','line_number':7067,'multiline':True]
['text':'
 * Mark all lists and dicts referenced through function "name" with "copyID".
 * Returns TRUE if setting references failed somehow.
 ','line_number':7082,'multiline':True]
['text':' FEAT_EVAL','line_number':7115,'multiline':False]
