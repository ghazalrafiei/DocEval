['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]
['text':'
 * filepath.c: dealing with file names and paths.
 ','line_number':10,'multiline':True]
['text':'
 * Functions for ":8" filename modifier: get 8.3 version of a filename.
 ','line_number':17,'multiline':True]
['text':'
 * Get the short path (8.3) for the filename in "fnamep".
 * Only works for a valid file name.
 * When the path gets longer "fnamep" is changed and the allocated buffer
 * is put in "bufp".
 * *fnamelen is the length of "fnamep" and set to 0 for a nonexistent path.
 * Returns OK on success, FAIL on failure.
 ','line_number':21,'multiline':True]
['text':' If that doesn't work (not enough space), then save the string','line_number':51,'multiline':False]
['text':' and try again with a new buffer big enough.','line_number':52,'multiline':False]
['text':' Really should always succeed, as the buffer is big enough.','line_number':61,'multiline':False]
['text':'
 * Get the short path (8.3) for the filename in "fname". The converted
 * path is returned in "bufp".
 *
 * Some of the directories specified in "fname" may not exist. This function
 * will shorten the existing directories at the beginning of the path and then
 * append the remaining non-existing path.
 *
 * fname - Pointer to the filename to shorten.  On return, contains the
 *	   pointer to the shortened pathname
 * bufp -  Pointer to an allocated buffer for the filename.
 * fnamelen - Length of the filename pointed to by fname
 *
 * Returns OK on success (or nothing done) and FAIL on failure (out of memory).
 ','line_number':87,'multiline':True]
['text':' Make a copy','line_number':115,'multiline':False]
['text':' Find the end of the copy','line_number':121,'multiline':False]
['text':'
     * Try shortening the supplied path till it succeeds by removing one
     * directory at a time from the tail of the path.
     ','line_number':124,'multiline':True]
['text':' go back one path-separator','line_number':131,'multiline':False]
['text':' processed the complete path','line_number':135,'multiline':False]
['text':'
	 * Replace the path separator with a NUL and try to shorten the
	 * resulting path.
	 ','line_number':137,'multiline':True]
['text':' preserve the string','line_number':150,'multiline':False]
['text':' successfully shortened the path','line_number':153,'multiline':False]
['text':' failed to shorten the path. Skip the path separator','line_number':155,'multiline':False]
['text':'
	 * Succeeded in shortening the path. Now concatenate the shortened
	 * path with the remaining path at the tail.
	 ','line_number':161,'multiline':True]
['text':' Compute the length of the new path.','line_number':166,'multiline':False]
['text':' There is not enough space in the currently allocated string,','line_number':174,'multiline':False]
['text':' copy it to a buffer big enough.','line_number':175,'multiline':False]
['text':' Transfer short_fname to the main buffer (it's big enough),','line_number':185,'multiline':False]
['text':' unless get_short_pathname() did its work in-place.','line_number':186,'multiline':False]
['text':' concat the not-shortened part of the path','line_number':193,'multiline':False]
['text':'
 * Get a pathname for a partial path.
 * Returns OK for success, FAIL for failure.
 ','line_number':206,'multiline':True]
['text':' Count up the path separators from the RHS.. so we know which part','line_number':221,'multiline':False]
['text':' of the path to return.','line_number':222,'multiline':False]
['text':' Need full path first (use expand_env() to remove a "~/")','line_number':228,'multiline':False]
['text':' Don't have a valid filename, so shorten the rest of the','line_number':242,'multiline':False]
['text':' path if we can. This CAN give us invalid 8.3 filenames, but','line_number':243,'multiline':False]
['text':' there's not a lot of point in guessing what it might be.','line_number':244,'multiline':False]
['text':' Count the paths backward to find the beginning of the desired string.','line_number':250,'multiline':False]
['text':' Copy in the string - p indexes into tfname - allocated at pbuf','line_number':274,'multiline':False]
['text':' MSWIN','line_number':282,'multiline':False]
['text':'
 * Adjust a filename, according to a string of modifiers.
 * *fnamep must be NUL terminated when called.  When returning, the length is
 * determined by *fnamelen.
 * Returns VALID_ flags or -1 for failure.
 * When there is an error, *fnamep is set to NULL.
 ','line_number':284,'multiline':True]
['text':' string with modifiers','line_number':293,'multiline':False]
['text':' "~" is a file name, not $HOME','line_number':294,'multiline':False]
['text':' characters after src that are used','line_number':295,'multiline':False]
['text':' file name so far','line_number':296,'multiline':False]
['text':' buffer for allocated file name or NULL','line_number':297,'multiline':False]
['text':' length of fnamep','line_number':298,'multiline':False]
['text':' ":p" - full path/file_name','line_number':313,'multiline':False]
['text':' Expand "~/path" for all systems and "~user/path" for Unix and VMS','line_number':321,'multiline':False]
['text':' free any allocated file name','line_number':334,'multiline':False]
['text':' When "/." or "/.." is used: force expansion to get rid of it.','line_number':340,'multiline':False]
['text':' FullName_save() is slow, don't use it when not needed.','line_number':352,'multiline':False]
['text':' free any allocated file name','line_number':356,'multiline':False]
['text':' Expand 8.3 filename to full path.  Needed to make sure the same','line_number':366,'multiline':False]
['text':' file does not have two different names.','line_number':367,'multiline':False]
['text':' Note: problem does not occur if _WIN32_WINNT < 0x0500.','line_number':368,'multiline':False]
['text':' free any allocated file name','line_number':380,'multiline':False]
['text':' Append a path separator to a directory.','line_number':389,'multiline':False]
['text':' Make room for one or two extra characters.','line_number':392,'multiline':False]
['text':' free any allocated file name','line_number':394,'multiline':False]
['text':' ":." - path relative to the current directory','line_number':402,'multiline':False]
['text':' ":~" - path relative to the home directory','line_number':403,'multiline':False]
['text':' ":8" - shortname path - postponed till after','line_number':404,'multiline':False]
['text':' Postpone this.','line_number':412,'multiline':False]
['text':' Need full path first (use expand_env() to remove a "~/")','line_number':417,'multiline':False]
['text':' Do not call shorten_fname() here since it removes the prefix','line_number':448,'multiline':False]
['text':' even though the path does not have a prefix.','line_number':449,'multiline':False]
['text':' free any allocated file name','line_number':460,'multiline':False]
['text':' Only replace it when it starts with '~'','line_number':471,'multiline':False]
['text':' ":h" - head, remove "/file_name", can be repeated','line_number':491,'multiline':False]
['text':' Don't remove the first "/" or "c:\"','line_number':492,'multiline':False]
['text':' the path separator is part of the path','line_number':503,'multiline':False]
['text':' Result is empty.  Turn it into "." to make ":cd %:h" work.','line_number':507,'multiline':False]
['text':' ":8" - shortname','line_number':522,'multiline':False]
['text':'
     * Handle ":8" after we have done 'heads' and before we do 'tails'.
     ','line_number':532,'multiline':True]
['text':' Copy the string if it is shortened by :h and when it wasn't copied','line_number':537,'multiline':False]
['text':' yet, because we are going to change it in place.  Avoids changing','line_number':538,'multiline':False]
['text':' the buffer name for "%:8".','line_number':539,'multiline':False]
['text':' Split into two implementations - makes it easier.  First is where','line_number':549,'multiline':False]
['text':' there isn't a full name already, second is where there is.','line_number':550,'multiline':False]
['text':' Simple case, already have the full-name.','line_number':560,'multiline':False]
['text':' Nearly always shorter, so try first time.','line_number':561,'multiline':False]
['text':' Couldn't find the filename, search the paths.','line_number':567,'multiline':False]
['text':' MSWIN','line_number':575,'multiline':False]
['text':' ":t" - tail, just the basename','line_number':577,'multiline':False]
['text':' ":e" - extension, can be repeated','line_number':585,'multiline':False]
['text':' ":r" - root, without extension, can be repeated','line_number':586,'multiline':False]
['text':' find a '.' in the tail:','line_number':590,'multiline':False]
['text':' - for second :e: before the current fname','line_number':591,'multiline':False]
['text':' - otherwise: The last '.'','line_number':592,'multiline':False]
['text':' :e','line_number':600,'multiline':False]
['text':' cut version from the extension','line_number':607,'multiline':False]
['text':' :r','line_number':619,'multiline':False]
['text':' remove one extension','line_number':625,'multiline':False]
['text':' ":s?pat?foo?" - substitute','line_number':631,'multiline':False]
['text':' ":gs?pat?foo?" - global substitute','line_number':632,'multiline':False]
['text':' find end of pattern','line_number':655,'multiline':False]
['text':' find end of substitution','line_number':663,'multiline':False]
['text':' after using ":s", repeat all the modifiers','line_number':688,'multiline':False]
['text':' vim_strsave_shellescape() needs a NUL terminated string.','line_number':696,'multiline':False]
['text':'
 * Shorten the path of a file from "~/foo/../.bar/fname" to "~/f/../.b/fname"
 * "trim_len" specifies how many characters to keep for each directory.
 * Must be 1 or more.
 * It's done in-place.
 ','line_number':714,'multiline':True]
['text':' copy the whole tail','line_number':731,'multiline':False]
['text':' copy '/' and next char','line_number':737,'multiline':False]
['text':' copy next char','line_number':745,'multiline':False]
['text':' and leading "~" and "."','line_number':746,'multiline':False]
['text':' only count word chars for the size','line_number':748,'multiline':False]
['text':' keep copying chars until we have our preferred length (or','line_number':750,'multiline':False]
['text':' until the above if/else branches move us along)','line_number':751,'multiline':False]
['text':'
 * Shorten the path of a file from "~/foo/../.bar/fname" to "~/f/../.b/fname"
 * It's done in-place.
 ','line_number':767,'multiline':True]
['text':'
 * Return TRUE if "fname" is a readable file.
 ','line_number':777,'multiline':True]
['text':'
 * "chdir(dir)" function
 ','line_number':799,'multiline':True]
['text':' Returning an empty string means it failed.','line_number':813,'multiline':False]
['text':' No error message, for historic reasons.','line_number':814,'multiline':False]
['text':' Return the current directory','line_number':820,'multiline':False]
['text':' Directory change failed','line_number':840,'multiline':False]
['text':'
 * "delete()" function
 ','line_number':844,'multiline':True]
['text':' delete a file','line_number':876,'multiline':False]
['text':' delete an empty directory','line_number':879,'multiline':False]
['text':' delete a directory recursively','line_number':882,'multiline':False]
['text':'
 * "executable()" function
 ','line_number':888,'multiline':True]
['text':' Check in $PATH and also check directly if there is a directory name.','line_number':897,'multiline':False]
['text':'
 * "exepath()" function
 ','line_number':901,'multiline':True]
['text':'
 * "filereadable()" function
 ','line_number':916,'multiline':True]
['text':'
 * Return 0 for not writable, 1 for writable file, 2 for a dir which we have
 * rights to write into.
 ','line_number':927,'multiline':True]
['text':'
 * "finddir({fname}[, {path}[, {count}]])" function
 ','line_number':1015,'multiline':True]
['text':'
 * "findfile({fname}[, {path}[, {count}]])" function
 ','line_number':1024,'multiline':True]
['text':'
 * "fnamemodify({fname}, {mods})" function
 ','line_number':1033,'multiline':True]
['text':'
 * "getcwd()" function
 *
 * Return the current working directory of a window in a tab page.
 * First optional argument 'winnr' is the window number or -1 and the second
 * optional argument 'tabnr' is the tab page number.
 *
 * If no arguments are supplied, then return the directory of the current
 * window.
 * If only 'winnr' is specified and is not -1 or 0 then return the directory of
 * the specified window.
 * If 'winnr' is 0 then return the directory of the current window.
 * If both 'winnr and 'tabnr' are specified and 'winnr' is -1 then return the
 * directory of the specified tab page.  Otherwise return the directory of the
 * specified window in the specified tab page.
 * If the window or the tab page doesn't exist then return NULL.
 ','line_number':1070,'multiline':True]
['text':'
 * Convert "st" to file permission string.
 ','line_number':1138,'multiline':True]
['text':'
 * "getfperm({fname})" function
 ','line_number':1157,'multiline':True]
['text':'
 * "getfsize({fname})" function
 ','line_number':1179,'multiline':True]
['text':' non-perfect check for overflow','line_number':1200,'multiline':False]
['text':'
 * "getftime({fname})" function
 ','line_number':1209,'multiline':True]
['text':'
 * Convert "st" to file type string.
 ','line_number':1228,'multiline':True]
['text':'
 * "getftype({fname})" function
 ','line_number':1255,'multiline':True]
['text':'
 * "glob()" function
 ','line_number':1276,'multiline':True]
['text':' When the optional second argument is non-zero, don't remove matches','line_number':1295,'multiline':False]
['text':' for 'wildignore' and don't put matches for 'suffixes' at the end.','line_number':1296,'multiline':False]
['text':'
 * "glob2regpat()" function
 ','line_number':1336,'multiline':True]
['text':'
 * "globpath()" function
 ','line_number':1354,'multiline':True]
['text':' When the optional second argument is non-zero, don't remove matches','line_number':1379,'multiline':False]
['text':' for 'wildignore' and don't put matches for 'suffixes' at the end.','line_number':1380,'multiline':False]
['text':'
 * "isdirectory()" function
 ','line_number':1411,'multiline':True]
['text':'
 * "isabsolutepath()" function
 ','line_number':1423,'multiline':True]
['text':'
 * Create the directory in which "dir" is located, and higher levels when
 * needed.
 * Set "created" to the full name of the first created directory.  It will be
 * NULL until that happens.
 * Return OK or FAIL.
 ','line_number':1435,'multiline':True]
['text':' Get end of directory name in "dir".','line_number':1449,'multiline':False]
['text':' We're done when it's "/" or "c:/".','line_number':1450,'multiline':False]
['text':' If the directory exists we're done.  Otherwise: create it.','line_number':1455,'multiline':False]
['text':'
 * "mkdir()" function
 ','line_number':1471,'multiline':True]
['text':' remove trailing slashes','line_number':1500,'multiline':False]
['text':' With the "p" flag it's OK if the dir already exists.','line_number':1523,'multiline':False]
['text':' Handle "D" and "R": deferred deletion of the created directory.','line_number':1532,'multiline':False]
['text':'
 * "pathshorten()" function
 ','line_number':1556,'multiline':True]
['text':'
 * Common code for readdir_checkitem() and readdirex_checkitem().
 * Either "name" or "dict" is NULL.
 ','line_number':1591,'multiline':True]
['text':' We want to use -1, but also true/false should be allowed.','line_number':1622,'multiline':False]
['text':'
 * Evaluate "expr" (= "context") for readdir().
 ','line_number':1642,'multiline':True]
['text':'
 * Process the keys in the Dict argument to the readdir() and readdirex()
 * functions.  Assumes the Dict argument is the 3rd argument.
 ','line_number':1653,'multiline':True]
['text':'
 * "readdir()" function
 ','line_number':1684,'multiline':True]
['text':'
 * Evaluate "expr" (= "context") for readdirex().
 ','line_number':1727,'multiline':True]
['text':'
 * "readdirex()" function
 ','line_number':1738,'multiline':True]
['text':'
 * "readfile()" function
 ','line_number':1781,'multiline':True]
['text':' rounded to avoid odd + 1','line_number':1792,'multiline':False]
['text':' size of last fread()','line_number':1794,'multiline':False]
['text':' previously read bytes, if any','line_number':1795,'multiline':False]
['text':' length of data in prev','line_number':1796,'multiline':False]
['text':' size of prev buffer','line_number':1797,'multiline':False]
['text':' position in buf','line_number':1800,'multiline':False]
['text':' start of current line','line_number':1801,'multiline':False]
['text':' Always open the file in binary mode, library functions have a mind of','line_number':1828,'multiline':False]
['text':' their own about CR-LF conversion.','line_number':1829,'multiline':False]
['text':' This for loop processes what was read, but is also entered at end','line_number':1856,'multiline':False]
['text':' of file so that either:','line_number':1857,'multiline':False]
['text':' - an incomplete line gets written','line_number':1858,'multiline':False]
['text':' - a "binary" file gets an empty line at the end if it ends in a','line_number':1859,'multiline':False]
['text':'   newline.','line_number':1860,'multiline':False]
['text':' Finished a line.  Remove CRs before NL.','line_number':1871,'multiline':False]
['text':' removal may cross back to the "prev" string','line_number':1876,'multiline':False]
['text':' Change "prev" buffer to be the right size.  This way','line_number':1885,'multiline':False]
['text':' the bytes are only copied once, and very long lines are','line_number':1886,'multiline':False]
['text':' allocated only once.','line_number':1887,'multiline':False]
['text':' the list will own the string','line_number':1892,'multiline':False]
['text':' step over newline','line_number':1914,'multiline':False]
['text':' Check for utf8 "bom"; U+FEFF is encoded as EF BB BF.  Do this','line_number':1920,'multiline':False]
['text':' when finding the BF and check the previous two bytes.','line_number':1921,'multiline':False]
['text':' Find the two bytes before the 0xbf.	If p is at buf, or buf','line_number':1924,'multiline':False]
['text':' + 1, these may be in the "prev" string.','line_number':1925,'multiline':False]
['text':' Usually a BOM is at the beginning of a file, and so at','line_number':1936,'multiline':False]
['text':' the beginning of a line; then we can just step over it.','line_number':1937,'multiline':False]
['text':' have to shuffle buf to close gap','line_number':1942,'multiline':False]
['text':' must be 1 or 2','line_number':1947,'multiline':False]
['text':' for','line_number':1959,'multiline':False]
['text':' There's part of a line in buf, store it in "prev".','line_number':1965,'multiline':False]
['text':' need bigger "prev" buffer','line_number':1968,'multiline':False]
['text':' A common use case is ordinary text files and "prev" gets a','line_number':1971,'multiline':False]
['text':' fragment of a line, so the first allocation is made','line_number':1972,'multiline':False]
['text':' small, to avoid repeatedly 'allocing' large and','line_number':1973,'multiline':False]
['text':' 'reallocing' small.','line_number':1974,'multiline':False]
['text':' Add the line part to end of "prev".','line_number':1992,'multiline':False]
['text':' while','line_number':1996,'multiline':False]
['text':' For a negative line count use only the lines at the end of the file,','line_number':1998,'multiline':False]
['text':' free the rest.','line_number':1999,'multiline':False]
['text':' an empty list is returned on error','line_number':2009,'multiline':False]
['text':'
 * "readblob()" function
 ','line_number':2018,'multiline':True]
['text':'
 * "readfile()" function
 ','line_number':2034,'multiline':True]
['text':'
 * "resolve()" function
 ','line_number':2050,'multiline':True]
['text':' the trailing slash breaks readlink()','line_number':2097,'multiline':False]
['text':' Separate the first path component in "p", and keep the','line_number':2103,'multiline':False]
['text':' remainder (beginning with the path separator).','line_number':2104,'multiline':False]
['text':' Ensure that the result will have a trailing path separator','line_number':2134,'multiline':False]
['text':' if the argument has one.','line_number':2135,'multiline':False]
['text':' Separate the first path component in the link value and','line_number':2139,'multiline':False]
['text':' concatenate the remainders.','line_number':2140,'multiline':False]
['text':' Ignore trailing path separator.','line_number':2161,'multiline':False]
['text':' symlink is relative to directory of argument','line_number':2167,'multiline':False]
['text':' Append the first path component of "remain" to "p".','line_number':2187,'multiline':False]
['text':' Shorten "remain".','line_number':2197,'multiline':False]
['text':' If the result is a relative path name, make it explicitly relative to','line_number':2204,'multiline':False]
['text':' the current directory if and only if the argument had this form.','line_number':2205,'multiline':False]
['text':' Prepend "./".','line_number':2217,'multiline':False]
['text':' Strip leading "./".','line_number':2227,'multiline':False]
['text':' Ensure that the result will have no trailing path separator','line_number':2236,'multiline':False]
['text':' if the argument had none.  But keep "/" or "//".','line_number':2237,'multiline':False]
['text':'
 * "tempname()" function
 ','line_number':2261,'multiline':True]
['text':' Advance 'x' to use A-Z and 0-9, so that there are at least 34 different','line_number':2272,'multiline':False]
['text':' names.  Skip 'I' and 'O', they are used for shell redirection.','line_number':2273,'multiline':False]
['text':'
 * "writefile()" function
 ','line_number':2285,'multiline':True]
['text':' Always open the file in binary mode, library functions have a mind of','line_number':2364,'multiline':False]
['text':' their own about CR-LF conversion.','line_number':2365,'multiline':False]
['text':' Ignore the error, the user wouldn't know what to do about','line_number':2405,'multiline':False]
['text':' it.  May happen for a device.','line_number':2406,'multiline':False]
['text':' FEAT_EVAL','line_number':2416,'multiline':False]
['text':'
 * Generic browse function.  Calls gui_mch_browse() when possible.
 * Later this may pop-up a non-GUI file selector (external command?).
 ','line_number':2419,'multiline':True]
['text':' BROWSE_SAVE and BROWSE_DIR','line_number':2425,'multiline':False]
['text':' title for the window','line_number':2426,'multiline':False]
['text':' default file name (may include directory)','line_number':2427,'multiline':False]
['text':' extension added','line_number':2428,'multiline':False]
['text':' initial directory, NULL for current dir or','line_number':2429,'multiline':False]
['text':' when using path from "dflt"','line_number':2430,'multiline':False]
['text':' file name filter','line_number':2431,'multiline':False]
['text':' buffer to read/write for','line_number':2432,'multiline':False]
['text':' last used directory','line_number':2435,'multiline':False]
['text':' Must turn off browse to avoid that autocommands will get the','line_number':2439,'multiline':False]
['text':' flag too!','line_number':2440,'multiline':False]
['text':' When no directory specified, use default file name, default dir, buffer','line_number':2453,'multiline':False]
['text':' dir, last dir or current dir','line_number':2454,'multiline':False]
['text':' default file name is a directory','line_number':2457,'multiline':False]
['text':' default file name includes a path','line_number':2462,'multiline':False]
['text':' When 'browsedir' is a directory, use it','line_number':2476,'multiline':False]
['text':' When saving or 'browsedir' is "buffer", use buffer fname','line_number':2482,'multiline':False]
['text':' When 'browsedir' is "last", use dir from last browse','line_number':2495,'multiline':False]
['text':' When 'browsedir is "current", use current directory.  This is the','line_number':2498,'multiline':False]
['text':' default already, leave initdir empty.','line_number':2499,'multiline':False]
['text':' when this changes, also adjust f_has()!','line_number':2503,'multiline':False]
['text':' For systems that have a directory dialog.','line_number':2515,'multiline':False]
['text':' Generic solution for selecting a directory: select a file and','line_number':2518,'multiline':False]
['text':' remove the file name.','line_number':2519,'multiline':False]
['text':' Win32 adds a dummy file name, others return an arbitrary file','line_number':2523,'multiline':False]
['text':' name.  GTK+ 2 returns only the directory,','line_number':2524,'multiline':False]
['text':' Remove the file name.','line_number':2527,'multiline':False]
['text':' use current dir','line_number':2531,'multiline':False]
['text':' We hang around in the dialog for a while, the user might do some','line_number':2540,'multiline':False]
['text':' things to our files.  The Win32 dialog allows deleting or renaming','line_number':2541,'multiline':False]
['text':' a file, check timestamps.','line_number':2542,'multiline':False]
['text':' TODO: non-GUI file selector here','line_number':2549,'multiline':False]
['text':' keep the directory for next time','line_number':2554,'multiline':False]
['text':' filename only returned, must be in current dir','line_number':2564,'multiline':False]
['text':'
 * "browse(save, title, initdir, default)" function
 ','line_number':2582,'multiline':True]
['text':'
 * "browsedir(title, initdir)" function
 ','line_number':2621,'multiline':True]
['text':' FEAT_EVAL','line_number':2651,'multiline':False]
['text':'
 * Replace home directory by "~" in each space or comma separated file name in
 * 'src'.
 * If anything fails (except when out of space) dst equals src.
 ','line_number':2653,'multiline':True]
['text':' when not NULL, check for help files','line_number':2660,'multiline':False]
['text':' input file name','line_number':2661,'multiline':False]
['text':' where to put the result','line_number':2662,'multiline':False]
['text':' maximum length of the result','line_number':2663,'multiline':False]
['text':' if TRUE, only replace one file name, include','line_number':2664,'multiline':False]
['text':' spaces and commas in the file name.','line_number':2665,'multiline':False]
['text':'
     * If the file is a help file, remove the path completely.
     ','line_number':2678,'multiline':True]
['text':'
     * We check both the value of the $HOME environment variable and the
     * "real" home directory.
     ','line_number':2687,'multiline':True]
['text':' Empty is the same as not set.','line_number':2703,'multiline':False]
['text':' Remove the trailing / that is added to a directory.','line_number':2718,'multiline':False]
['text':'
	 * Here we are at the beginning of a file name.
	 * First, check to see if the beginning of the file name matches
	 * $HOME or the "real" home directory. Check that there is a '/'
	 * after the match (so that if e.g. the file is "/home/pieter/bla",
	 * and the home directory is "/home/piet", the file does not end up
	 * as "~er/bla" (which would seem to indicate the file "bla" in user
	 * er's home directory)).
	 ','line_number':2729,'multiline':True]
['text':' Do not add directory separator into dst, because dst is','line_number':2752,'multiline':False]
['text':' expected to just return the directory name without the','line_number':2753,'multiline':False]
['text':' directory separator '/'.','line_number':2754,'multiline':False]
['text':' if (!one) skip to separator: space or comma','line_number':2763,'multiline':False]
['text':' skip separator','line_number':2766,'multiline':False]
['text':' if (dstlen == 0) out of space, what to do???','line_number':2770,'multiline':False]
['text':'
 * Like home_replace, store the replaced string in allocated memory.
 * When something fails, NULL is returned.
 ','line_number':2778,'multiline':True]
['text':' when not NULL, check for help files','line_number':2784,'multiline':False]
['text':' input file name','line_number':2785,'multiline':False]
['text':' space for "~/" and trailing NUL','line_number':2790,'multiline':False]
['text':' just in case','line_number':2791,'multiline':False]
['text':'
 * Compare two file names and return:
 * FPC_SAME   if they both exist and are the same file.
 * FPC_SAMEX  if they both don't exist and have the same file name.
 * FPC_DIFF   if they both exist and are different files.
 * FPC_NOTX   if they both don't exist.
 * FPC_DIFFX  if one of them doesn't exist.
 * For the first name environment variables are expanded if "expandenv" is
 * TRUE.
 ','line_number':2799,'multiline':True]
['text':' when both don't exist, check file names','line_number':2813,'multiline':False]
['text':' if mch_stat() doesn't work, may compare the names','line_number':2831,'multiline':False]
['text':' expanded s1','line_number':2849,'multiline':False]
['text':' full path of s1','line_number':2850,'multiline':False]
['text':' full path of s2','line_number':2851,'multiline':False]
['text':' allocate one buffer to store three paths (alloc()/free() is slow!)','line_number':2855,'multiline':False]
['text':' If vim_FullName() fails, the file probably doesn't exist.','line_number':2868,'multiline':False]
['text':'
 * Get the tail of a path: the file name.
 * When the path ends in a path separator the tail is the NUL after it.
 * Fail safe: never returns NULL.
 ','line_number':2888,'multiline':True]
['text':' find last part of path','line_number':2900,'multiline':False]
['text':'
 * Get pointer to tail of "fname", including path separators.  Putting a NUL
 * here leaves the directory name.  Takes care of "c:/" and "//".
 * Always returns a valid pointer.
 ','line_number':2909,'multiline':True]
['text':' don't remove the '/' from "c:/file"','line_number':2920,'multiline':False]
['text':' path separator is part of the path','line_number':2925,'multiline':False]
['text':'
 * get the next path component (just after the next path separator).
 ','line_number':2931,'multiline':True]
['text':'
 * Get a pointer to one character past the head of a path name.
 * Unix: after "/"; DOS: after "c:\"; Amiga: after "disk:/"; Mac: no head.
 * If there is no head, path is returned.
 ','line_number':2944,'multiline':True]
['text':' may skip "c:"','line_number':2955,'multiline':False]
['text':' may skip "label:"','line_number':2962,'multiline':False]
['text':' Unix','line_number':2966,'multiline':False]
['text':'
 * Return TRUE if 'c' is a path separator.
 * Note that for MS-Windows this includes the colon.
 ','line_number':2977,'multiline':True]
['text':' UNIX has ':' inside file names','line_number':2985,'multiline':False]
['text':' server"user passwd"::device:[full.path.name]fname.extension;version"','line_number':2991,'multiline':False]
['text':' VMS','line_number':2996,'multiline':False]
['text':'
 * Like vim_ispathsep(c), but exclude the colon for MS-Windows.
 ','line_number':3001,'multiline':True]
['text':'
 * Return TRUE if the directory of "fname" exists, FALSE otherwise.
 * Also returns TRUE if there is no directory name.
 * "fname" must be writable!.
 ','line_number':3014,'multiline':True]
['text':'
 * Versions of fnamecmp() and fnamencmp() that handle '/' and '\' equally
 * and deal with 'fileignorecase'.
 ','line_number':3036,'multiline':True]
['text':'
 * Concatenate file names fname1 and fname2 into allocated memory.
 * Only add a '/' or '\\' when 'sep' is TRUE and it is necessary.
 ','line_number':3084,'multiline':True]
['text':'
 * Add a path separator to a file name, unless it already ends in a path
 * separator.
 ','line_number':3104,'multiline':True]
['text':'
 * FullName_save - Make an allocated copy of a full file name.
 * Returns NULL when out of memory.
 ','line_number':3115,'multiline':True]
['text':' force expansion, even when it already looks','line_number':3122,'multiline':False]
['text':' like a full path name','line_number':3123,'multiline':False]
['text':'
 * return TRUE if "fname" exists.
 ','line_number':3143,'multiline':True]
['text':'
 * Invoke expand_wildcards() for one pattern.
 * Expand items like "%:h" before the expansion.
 * Returns OK or FAIL.
 ','line_number':3156,'multiline':True]
['text':' pointer to input pattern','line_number':3163,'multiline':False]
['text':' resulting number of files','line_number':3164,'multiline':False]
['text':' array of resulting files','line_number':3165,'multiline':False]
['text':' EW_DIR, etc.','line_number':3166,'multiline':False]
['text':' Expanding "%" or "#" and the file does not exist: Add the','line_number':3196,'multiline':False]
['text':' pattern anyway (without the star) so that this works for remote','line_number':3197,'multiline':False]
['text':' files and non-file buffer names.','line_number':3198,'multiline':False]
['text':'
 * Expand wildcards.  Calls gen_expand_wildcards() and removes files matching
 * 'wildignore'.
 * Returns OK or FAIL.  When FAIL then "num_files" won't be set.
 ','line_number':3215,'multiline':True]
['text':' number of input patterns','line_number':3222,'multiline':False]
['text':' array of input patterns','line_number':3223,'multiline':False]
['text':' resulting number of files','line_number':3224,'multiline':False]
['text':' array of resulting files','line_number':3225,'multiline':False]
['text':' EW_DIR, etc.','line_number':3226,'multiline':False]
['text':' number without matching suffix','line_number':3231,'multiline':False]
['text':' When keeping all matches, return here','line_number':3235,'multiline':False]
['text':'
     * Remove names that match 'wildignore'.
     ','line_number':3239,'multiline':True]
['text':' check all files in (*files)[]','line_number':3246,'multiline':False]
['text':' out of memory','line_number':3250,'multiline':False]
['text':' remove this matching file from the list','line_number':3257,'multiline':False]
['text':' If the number of matches is now zero, we fail.','line_number':3267,'multiline':False]
['text':'
     * Move the names where 'suffixes' match to the end.
     * Skip when interrupted, the result probably won't be used.
     ','line_number':3275,'multiline':True]
['text':'
		 * Move the name without matching suffix to the front
		 * of the list.
		 ','line_number':3286,'multiline':True]
['text':'
 * Return TRUE if "fname" matches with an entry in 'suffixes'.
 ','line_number':3301,'multiline':True]
['text':' maximum length of a file suffix','line_number':3309,'multiline':False]
['text':' empty entry: match name without a '.'','line_number':3321,'multiline':False]
['text':'
 * Return TRUE if we can expand this backtick thing here.
 ','line_number':3342,'multiline':True]
['text':'
 * Expand an item in `backticks` by executing it as a command.
 * Currently only works when pat[] starts and ends with a `.
 * Returns number of file names found, -1 if an error is encountered.
 ','line_number':3351,'multiline':True]
['text':' EW_* flags','line_number':3360,'multiline':False]
['text':' Create the command: lop off the backticks.','line_number':3368,'multiline':False]
['text':' `={expr}`: Expand expression','line_number':3374,'multiline':False]
['text':' skip over white space','line_number':3387,'multiline':False]
['text':' skip over entry','line_number':3389,'multiline':False]
['text':' add an entry if it is not empty','line_number':3391,'multiline':False]
['text':' VIM_BACKTICK','line_number':3408,'multiline':False]
['text':'
 * File name expansion code for MS-DOS, Win16 and Win32.  It's here because
 * it's shared between these systems.
 ','line_number':3411,'multiline':True]
['text':'
 * comparison function for qsort in dos_expandpath()
 ','line_number':3416,'multiline':True]
['text':'
 * Recursively expand one path component into all matching files and/or
 * directories.  Adds matches to "gap".  Handles "*", "?", "[a-z]", "**", etc.
 * Return the number of matches found.
 * "path" has backslashes before chars that are not to be expanded, starting
 * at "path[wildoff]".
 * Return the number of matches found.
 * NOTE: much of this is identical to unix_expandpath(), keep in sync!
 ','line_number':3425,'multiline':True]
['text':' EW_* flags','line_number':3439,'multiline':False]
['text':' expanded "**" once already','line_number':3440,'multiline':False]
['text':' depth for "**" expansion','line_number':3452,'multiline':False]
['text':' UCS-2 name, NULL when not used.','line_number':3455,'multiline':False]
['text':' Expanding "**" may take a long time, check for CTRL-C.','line_number':3460,'multiline':False]
['text':' Make room for file name.  When doing encoding conversion the actual','line_number':3468,'multiline':False]
['text':' length may be quite a bit longer, thus use the maximum possible length.','line_number':3469,'multiline':False]
['text':'
     * Find the first part in the path name that contains a wildcard or a ~1.
     * Copy it into buf, including the preceding characters.
     ','line_number':3474,'multiline':True]
['text':' May ignore a wildcard that has a backslash before it; it will','line_number':3484,'multiline':False]
['text':' be removed by rem_backslash() or file_pat_to_reg_pat() below.','line_number':3485,'multiline':False]
['text':' now we have one wildcard component between s and e','line_number':3510,'multiline':False]
['text':' Remove backslashes between "wildoff" and the start of the wildcard','line_number':3511,'multiline':False]
['text':' component.','line_number':3512,'multiline':False]
['text':' Check for "**" between "s" and "e".','line_number':3521,'multiline':False]
['text':' compile the regexp into a program','line_number':3534,'multiline':False]
['text':' Always ignore case','line_number':3537,'multiline':False]
['text':' remember the pattern or file name being looked for','line_number':3549,'multiline':False]
['text':' If "**" is by itself, this is the first time we encounter it and more','line_number':3552,'multiline':False]
['text':' is following then find matches without any directory.','line_number':3553,'multiline':False]
['text':' Scan all files in the directory with "dir/ *.*"','line_number':3563,'multiline':False]
['text':' p is allocated here','line_number':3572,'multiline':False]
['text':' out of memory','line_number':3575,'multiline':False]
['text':' Do not use the alternate filename when the file name ends in '~',','line_number':3577,'multiline':False]
['text':' because it picks up backup files: short name for "foo.vim~" is','line_number':3578,'multiline':False]
['text':' "foo~1.vim", which matches "*.vim".','line_number':3579,'multiline':False]
['text':' Ignore entries starting with a dot, unless when asked for.  Accept','line_number':3585,'multiline':False]
['text':' all entries found with "matchname".','line_number':3586,'multiline':False]
['text':' For "**" in the pattern first go deeper in the tree to','line_number':3604,'multiline':False]
['text':' find matches.','line_number':3605,'multiline':False]
['text':' need to expand another component of the path','line_number':3616,'multiline':False]
['text':' remove backslashes for the remaining components only','line_number':3617,'multiline':False]
['text':' no more wildcards, check if there is a match','line_number':3622,'multiline':False]
['text':' remove backslashes for the remaining components only','line_number':3623,'multiline':False]
['text':' add existing file','line_number':3626,'multiline':False]
['text':' EW_* flags','line_number':3653,'multiline':False]
['text':' MSWIN','line_number':3657,'multiline':False]
['text':'
 * Unix style wildcard expansion code.
 * It's here because it's used both for Unix and Mac.
 ','line_number':3661,'multiline':True]
['text':'
 * Recursively expand one path component into all matching files and/or
 * directories.  Adds matches to "gap".  Handles "*", "?", "[a-z]", "**", etc.
 * "path" has backslashes before chars that are not to be expanded, starting
 * at "path + wildoff".
 * Return the number of matches found.
 * NOTE: much of this is identical to dos_expandpath(), keep in sync!
 ','line_number':3671,'multiline':True]
['text':' EW_* flags','line_number':3684,'multiline':False]
['text':' expanded "**" once already','line_number':3685,'multiline':False]
['text':' depth for "**" expansion','line_number':3697,'multiline':False]
['text':' Expanding "**" may take a long time, check for CTRL-C.','line_number':3702,'multiline':False]
['text':' make room for file name (a bit too much to stay on the safe side)','line_number':3710,'multiline':False]
['text':'
     * Find the first part in the path name that contains a wildcard.
     * When EW_ICASE is set every letter is considered to be a wildcard.
     * Copy it into "buf", including the preceding characters.
     ','line_number':3716,'multiline':True]
['text':' May ignore a wildcard that has a backslash before it; it will','line_number':3727,'multiline':False]
['text':' be removed by rem_backslash() or file_pat_to_reg_pat() below.','line_number':3728,'multiline':False]
['text':' Now we have one wildcard component between "s" and "e".','line_number':3755,'multiline':False]
['text':' Remove backslashes between "wildoff" and the start of the wildcard','line_number':3756,'multiline':False]
['text':' component.','line_number':3757,'multiline':False]
['text':' Check for "**" between "s" and "e".','line_number':3766,'multiline':False]
['text':' convert the file pattern to a regexp pattern','line_number':3771,'multiline':False]
['text':' compile the regexp into a program','line_number':3780,'multiline':False]
['text':' 'wildignorecase' set','line_number':3782,'multiline':False]
['text':' ignore case when 'fileignorecase' is set','line_number':3784,'multiline':False]
['text':' If "**" is by itself, this is the first time we encounter it and more','line_number':3798,'multiline':False]
['text':' is following then find matches without any directory.','line_number':3799,'multiline':False]
['text':' open the directory for scanning','line_number':3809,'multiline':False]
['text':' Find all matching entries','line_number':3813,'multiline':False]
['text':' For "**" in the pattern first go deeper in the tree to','line_number':3835,'multiline':False]
['text':' find matches.','line_number':3836,'multiline':False]
['text':' handle more wildcards','line_number':3845,'multiline':False]
['text':' need to expand another component of the path','line_number':3847,'multiline':False]
['text':' remove backslashes for the remaining components only','line_number':3848,'multiline':False]
['text':' no more wildcards, check if there is a match','line_number':3855,'multiline':False]
['text':' remove backslashes for the remaining components only','line_number':3856,'multiline':False]
['text':' add existing file or symbolic link','line_number':3859,'multiline':False]
['text':' When interrupted the matches probably won't be used and sorting can be','line_number':3886,'multiline':False]
['text':' slow, thus skip it.','line_number':3887,'multiline':False]
['text':'
 * Return TRUE if "p" contains what looks like an environment variable.
 * Allowing for escaping.
 ','line_number':3896,'multiline':True]
['text':'
 * Return TRUE if "p" contains a special wildcard character, one that Vim
 * cannot expand, requires using a shell.
 ','line_number':3920,'multiline':True]
['text':' Disallow line break characters.','line_number':3929,'multiline':False]
['text':' Allow for escaping.','line_number':3932,'multiline':False]
['text':' A { must be followed by a matching }.','line_number':3937,'multiline':False]
['text':' A quote and backtick must be followed by another one.','line_number':3940,'multiline':False]
['text':'
 * Generic wildcard expansion code.
 *
 * Characters in "pat" that should not be expanded must be preceded with a
 * backslash. E.g., "/path\ with\ spaces/my\*star*"
 *
 * Return FAIL when no single file was found.  In this case "num_file" is not
 * set, and "file" may contain an error message.
 * Return OK when some files found.  "num_file" is set to the number of
 * matches, "file" to the array of matches.  Call FreeWild() later.
 ','line_number':3950,'multiline':True]
['text':' number of input patterns','line_number':3963,'multiline':False]
['text':' array of input patterns','line_number':3964,'multiline':False]
['text':' resulting number of files','line_number':3965,'multiline':False]
['text':' array of resulting files','line_number':3966,'multiline':False]
['text':' EW_* flags','line_number':3967,'multiline':False]
['text':'
     * expand_env() is called to expand things like "~user".  If this fails,
     * it calls ExpandOne(), which brings us back here.  In this case, always
     * call the machine specific expansion function, if possible.  Otherwise,
     * return FAIL.
     ','line_number':3977,'multiline':True]
['text':'
     * If there are any special wildcard characters which we cannot handle
     * here, call machine specific function for all the expansion.  This
     * avoids starting the shell for each argument separately.
     * For `=expr` do use the internal function.
     ','line_number':3991,'multiline':True]
['text':'
     * The matching file names are stored in a growarray.  Init it empty.
     ','line_number':4010,'multiline':True]
['text':'
	     * First expand environment variables, "~/" and "~user/".
	     ','line_number':4030,'multiline':True]
['text':'
		 * On Unix, if expand_env() can't expand an environment
		 * variable, use the shell to do that.  Discard previously
		 * found file names and start all over again.
		 ','line_number':4039,'multiline':True]
['text':'
	     * If there are wildcards or case-insensitive expansion is
	     * required: Expand file names and add each match to the list.  If
	     * there is no match, and EW_NOTFOUND is given, add the pattern.
	     * Otherwise: Add the file name if it exists or when EW_NOTFOUND is
	     * given.
	     ','line_number':4056,'multiline':True]
['text':' :find completion where 'path' is used.','line_number':4072,'multiline':False]
['text':' Recursiveness is OK here.','line_number':4073,'multiline':False]
['text':' When EW_NOTFOUND is used, always add files and dirs.  Makes','line_number':4088,'multiline':False]
['text':' "vim c:/" work.','line_number':4089,'multiline':False]
['text':' When returning FAIL the array must be freed here.','line_number':4105,'multiline':False]
['text':'
 * Add a file to a file list.  Accepted flags:
 * EW_DIR	add directories
 * EW_FILE	add files
 * EW_EXEC	add executable files
 * EW_NOTFOUND	add even when it doesn't exist
 * EW_ADDSLASH	add slash after directory name
 * EW_ALLLINKS	add symlink also when the referred file does not exist
 ','line_number':4118,'multiline':True]
['text':' filename','line_number':4130,'multiline':False]
['text':' if the file/dir/link doesn't exist, may not add it','line_number':4137,'multiline':False]
['text':' if the file/dir contains illegal characters, don't add it','line_number':4143,'multiline':False]
['text':' If the file isn't executable, may not add it.  Do accept directories.','line_number':4152,'multiline':False]
['text':' When invoked from expand_shellcmd() do not use $PATH.','line_number':4153,'multiline':False]
['text':' Make room for another item in the file list.','line_number':4158,'multiline':False]
['text':'
     * Append a slash or backslash after directory names if none is present.
     ','line_number':4170,'multiline':True]
['text':'
 * Free the list of files returned by expand_wildcards() or other expansion
 * functions.
 ','line_number':4178,'multiline':True]
['text':'
 * Compare path "p[]" to "q[]".
 * If "maxlen" >= 0 compare "p[maxlen]" to "q[maxlen]"
 * Return value like strcmp(p, q), but consider path separators.
 ','line_number':4192,'multiline':True]
['text':' End of "p": check if "q" also ends or just has a slash.','line_number':4209,'multiline':False]
['text':' full match','line_number':4212,'multiline':False]
['text':' End of "q": check if "p" just has a slash.','line_number':4219,'multiline':False]
['text':' consider '/' and '\\' to be equal','line_number':4228,'multiline':False]
['text':' no match','line_number':4239,'multiline':False]
['text':' "i" or "j" ran into "maxlen"','line_number':4245,'multiline':False]
['text':' ignore a trailing slash, but not "//" or ":/"','line_number':4250,'multiline':False]
['text':' match with trailing slash','line_number':4260,'multiline':False]
['text':' no match','line_number':4262,'multiline':False]
['text':'
 * Return TRUE if "name" is a full (absolute) path name or URL.
 ','line_number':4266,'multiline':True]
['text':'
 * Get absolute file name into buffer "buf[len]".
 *
 * return FAIL for failure, OK otherwise
 ','line_number':4275,'multiline':True]
['text':' force expansion even when already absolute','line_number':4285,'multiline':False]
['text':' something failed; use the file name (truncate when too long)','line_number':4299,'multiline':False]
