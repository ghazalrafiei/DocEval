['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]
['text':'
 * search.c: code for normal mode searching commands
 ','line_number':9,'multiline':True]
['text':' current position of found words','line_number':26,'multiline':False]
['text':' total count of found words','line_number':27,'multiline':False]
['text':' TRUE if matched exactly on specified position','line_number':28,'multiline':False]
['text':' 0: search was fully completed','line_number':29,'multiline':False]
['text':' 1: recomputing was timed out','line_number':30,'multiline':False]
['text':' 2: max count exceeded','line_number':31,'multiline':False]
['text':' the max count of the last search','line_number':32,'multiline':False]
['text':'
 * This file contains various searching-related routines. These fall into
 * three groups:
 * 1. string searches (for /, ?, n, and N)
 * 2. character searches within a single line (for f, F, t, T, etc)
 * 3. "other" kinds of searches like the '%' command, and 'word' searches.
 ','line_number':42,'multiline':True]
['text':'
 * String searches
 *
 * The string search functions are divided into two levels:
 * lowest:  searchit(); uses an pos_T for starting position and found match.
 * Highest: do_search(); uses curwin->w_cursor; calls searchit().
 *
 * The last search pattern is remembered for repeating the same search.
 * This pattern is shared between the :g, :s, ? and / commands.
 * This is in search_regcomp().
 *
 * The actual string matching is done using a heavily modified version of
 * Henry Spencer's regular expression library.  See regexp.c.
 ','line_number':50,'multiline':True]
['text':'
 * Two search patterns are remembered: One for the :substitute command and
 * one for other searches.  last_idx points to the one that was used the last
 * time.
 ','line_number':65,'multiline':True]
['text':' last used search pat','line_number':72,'multiline':False]
['text':' last used substitute pat','line_number':73,'multiline':False]
['text':' index in spats[] for RE_LAST','line_number':76,'multiline':False]
['text':' last character searched for','line_number':78,'multiline':False]
['text':' last direction of character search','line_number':79,'multiline':False]
['text':' last search t_cmd','line_number':80,'multiline':False]
['text':' >1 for multi-byte char','line_number':82,'multiline':False]
['text':' copy of spats[], for keeping the search patterns while executing autocmds','line_number':84,'multiline':False]
['text':' allocated copy of pattern used by search_regcomp()','line_number':92,'multiline':False]
['text':'
 * Type used by find_pattern_in_path() to remember which included files have
 * been searched already.
 ','line_number':96,'multiline':True]
['text':' File pointer','line_number':102,'multiline':False]
['text':' Full name of file','line_number':103,'multiline':False]
['text':' Line we were up to in file','line_number':104,'multiline':False]
['text':' Found a match in this file','line_number':105,'multiline':False]
['text':'
 * translate search pattern for vim_regcomp()
 *
 * pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)
 * pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)
 * pat_save == RE_BOTH: save pat in both patterns (:global command)
 * pat_use  == RE_SEARCH: use previous search pattern if "pat" is NULL
 * pat_use  == RE_SUBST: use previous substitute pattern if "pat" is NULL
 * pat_use  == RE_LAST: use last used pattern if "pat" is NULL
 * options & SEARCH_HIS: put search string in history
 * options & SEARCH_KEEP: keep previous search pattern
 *
 * returns FAIL if failed, OK otherwise.
 ','line_number':109,'multiline':True]
['text':' return: pattern and ignore-case flag','line_number':130,'multiline':False]
['text':'
     * If no pattern given, use a previously defined pattern.
     ','line_number':138,'multiline':True]
['text':' pattern was never defined','line_number':147,'multiline':False]
['text':' put new pattern in history','line_number':160,'multiline':False]
['text':'
     * Save the currently used pattern in the appropriate place,
     * unless the pattern should not be remembered.
     ','line_number':174,'multiline':True]
['text':' search or global command','line_number':181,'multiline':False]
['text':' substitute or global command','line_number':184,'multiline':False]
['text':'
 * Get search pattern used by search_regcomp().
 ','line_number':197,'multiline':True]
['text':' If 'hlsearch' set and search pat changed: need redraw.','line_number':218,'multiline':False]
['text':'
 * Save the search patterns, so they can be restored later.
 * Used before/after executing autocommands and user functions.
 ','line_number':225,'multiline':True]
['text':' copy of spats[RE_SEARCH], for keeping the search patterns while incremental','line_number':285,'multiline':False]
['text':' searching','line_number':286,'multiline':False]
['text':'
 * Save and restore the search pattern for incremental highlight search
 * feature.
 *
 * It's similar to but different from save_search_patterns() and
 * restore_search_patterns(), because the search pattern must be restored when
 * canceling incremental searching even if it's called inside user functions.
 ','line_number':294,'multiline':True]
['text':' nested call, nothing to do','line_number':306,'multiline':False]
['text':' nested call, nothing to do','line_number':320,'multiline':False]
['text':'
 * Save and restore the incsearch highlighting variables.
 * This is required so that calling searchcount() at does not invalidate the
 * incsearch highlighting.
 ','line_number':338,'multiline':True]
['text':'
 * Return TRUE when case should be ignored for search pattern "pat".
 * Uses the 'ignorecase' and 'smartcase' options.
 ','line_number':364,'multiline':True]
['text':'
 * As ignorecase() put pass the "ic" and "scs" flags.
 ','line_number':374,'multiline':True]
['text':'
 * Return TRUE if pattern "pat" has an uppercase character.
 ','line_number':390,'multiline':True]
['text':' get the magicness of the pattern','line_number':399,'multiline':False]
['text':' skip "\_X"','line_number':414,'multiline':False]
['text':' skip "\%X"','line_number':416,'multiline':False]
['text':' skip "\X"','line_number':418,'multiline':False]
['text':' skip "_X" and %X','line_number':425,'multiline':False]
['text':'
 * Reset search direction to forward.  For "gd" and "gD" commands.
 ','line_number':487,'multiline':True]
['text':'
 * Set the last search pattern.  For ":let @/ =" and viminfo.
 * Also set the saved search pattern, so that this works in an autocommand.
 ','line_number':500,'multiline':True]
['text':' An empty string means that nothing should be matched.','line_number':512,'multiline':False]
['text':' If 'hlsearch' set and search pat changed: need redraw.','line_number':541,'multiline':False]
['text':'
 * Get a regexp program for the last used search pattern.
 * This is used for highlighting all matches in a window.
 * Values returned in regmatch->regprog and regmatch->rmm_ic.
 ','line_number':549,'multiline':True]
['text':' So it doesn't beep if bad expr','line_number':562,'multiline':False]
['text':'
 * Lowest level search function.
 * Search for 'count'th occurrence of pattern "pat" in direction "dir".
 * Start at position "pos" and return the found position in "pos".
 *
 * if (options & SEARCH_MSG) == 0 don't give any messages
 * if (options & SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages
 * if (options & SEARCH_MSG) == SEARCH_MSG give all messages
 * if (options & SEARCH_HIS) put search pattern in history
 * if (options & SEARCH_END) return position at end of match
 * if (options & SEARCH_START) accept match at pos itself
 * if (options & SEARCH_KEEP) keep previous search pattern
 * if (options & SEARCH_FOLD) match only once in a closed fold
 * if (options & SEARCH_PEEK) check for typed char, cancel search
 * if (options & SEARCH_COL) start at pos->col instead of zero
 *
 * Return FAIL (zero) for failure, non-zero for success.
 * When FEAT_EVAL is defined, returns the index of the first matching
 * subpattern plus one; one if there was none.
 ','line_number':568,'multiline':True]
['text':' window to search in; can be NULL for a','line_number':590,'multiline':False]
['text':' buffer without a window!','line_number':591,'multiline':False]
['text':' set to end of the match, unless NULL','line_number':594,'multiline':False]
['text':' which pattern to use when "pat" is empty','line_number':599,'multiline':False]
['text':' optional extra arguments, can be NULL','line_number':600,'multiline':False]
['text':' no init to shut up Apollo cc','line_number':603,'multiline':False]
['text':' stop after this line number when != 0','line_number':623,'multiline':False]
['text':' set when timed out.','line_number':625,'multiline':False]
['text':' Also set the pointer when sa_tm is zero, the caller may have set the','line_number':641,'multiline':False]
['text':' timeout.','line_number':642,'multiline':False]
['text':'
     * find the string
     ','line_number':647,'multiline':True]
['text':' loop for count','line_number':650,'multiline':False]
['text':' When not accepting a match at the start position set "extra_col" to','line_number':652,'multiline':False]
['text':' a non-zero value.  Don't do that when starting at MAXCOL, since','line_number':653,'multiline':False]
['text':' MAXCOL + 1 is zero.','line_number':654,'multiline':False]
['text':' Watch out for the "col" being MAXCOL - 2, used in a closed fold.','line_number':657,'multiline':False]
['text':' remember start pos for detecting no match','line_number':685,'multiline':False]
['text':' default: not found','line_number':686,'multiline':False]
['text':' default: start in first line','line_number':687,'multiline':False]
['text':' correct lnum for when starting in line 0','line_number':688,'multiline':False]
['text':' not in first line now','line_number':692,'multiline':False]
['text':'
	 * Start searching in current line, unless searching backwards and
	 * we're in column 0.
	 * If we are searching backwards, in column 0, and not including the
	 * current position, gain some efficiency by skipping back a line.
	 * Otherwise begin the search in the current line.
	 ','line_number':695,'multiline':True]
['text':' loop twice if 'wrapscan' set','line_number':711,'multiline':False]
['text':' Stop after checking "stop_lnum", if it's set.','line_number':716,'multiline':False]
['text':' Stop after passing the time limit.','line_number':720,'multiline':False]
['text':'
		 * Look for a match somewhere in line "lnum".
		 ','line_number':724,'multiline':True]
['text':' vim_regexec_multi() may clear "regprog"','line_number':731,'multiline':False]
['text':' Abort searching on an error (e.g., out of stack).','line_number':734,'multiline':False]
['text':' match may actually be in another line when using \zs','line_number':739,'multiline':False]
['text':' "lnum" may be past end of buffer for "\n\zs".','line_number':745,'multiline':False]
['text':'
		     * Forward search in the first line: match should be after
		     * the start position. If not, continue at the end of the
		     * match (this is vi compatible) or on the next char.
		     ','line_number':751,'multiline':True]
['text':'
			 * When the match starts in a next line it's certainly
			 * past the start position.
			 * When match lands on a NUL the cursor will be put
			 * one back afterwards, compare with that position,
			 * otherwise "/$" will get stuck on end of line.
			 ','line_number':760,'multiline':True]
['text':'
			     * If vi-compatible searching, continue at the end
			     * of the match, otherwise continue one position
			     * forward.
			     ','line_number':776,'multiline':True]
['text':' end is in next line, thus no match in','line_number':785,'multiline':False]
['text':' this line','line_number':786,'multiline':False]
['text':' for empty match: advance one char','line_number':791,'multiline':False]
['text':' Advance "matchcol" to the next character.','line_number':804,'multiline':False]
['text':' This uses rmm_matchcol, the actual start of','line_number':805,'multiline':False]
['text':' the match, ignoring "\zs".','line_number':806,'multiline':False]
['text':' vim_regexec_multi() may clear "regprog"','line_number':827,'multiline':False]
['text':' Need to get the line pointer again, a','line_number':836,'multiline':False]
['text':' multi-line search may have made it invalid.','line_number':837,'multiline':False]
['text':'
			 * Now, if there are multiple matches on this line,
			 * we have to get the last one. Or the last one before
			 * the cursor, if we're on that line.
			 * When putting the new cursor at the end, compare
			 * relative to the end of the match.
			 ','line_number':845,'multiline':True]
['text':' Remember a position that is before the start','line_number':855,'multiline':False]
['text':' position, we use it if it's the last match in','line_number':856,'multiline':False]
['text':' the line.  Always accept a position after','line_number':857,'multiline':False]
['text':' wrapping around.','line_number':858,'multiline':False]
['text':'
			     * We found a valid match, now check if there is
			     * another one after it.
			     * If vi-compatible searching, continue at the end
			     * of the match, otherwise continue one position
			     * forward.
			     ','line_number':886,'multiline':True]
['text':' for empty match: advance one char','line_number':898,'multiline':False]
['text':' Stop when the match is in a next line.','line_number':911,'multiline':False]
['text':' If the search timed out, we did find a match','line_number':929,'multiline':False]
['text':' but it might be the wrong one, so that's not','line_number':930,'multiline':False]
['text':' OK.','line_number':931,'multiline':False]
['text':' vim_regexec_multi() may clear "regprog"','line_number':936,'multiline':False]
['text':' Need to get the line pointer again, a','line_number':940,'multiline':False]
['text':' multi-line search may have made it invalid.','line_number':941,'multiline':False]
['text':'
			 * If there is only a match after the cursor, skip
			 * this match.
			 ','line_number':945,'multiline':True]
['text':' With the SEARCH_END option move to the last character','line_number':953,'multiline':False]
['text':' of the match.  Don't do it for an empty match, end','line_number':954,'multiline':False]
['text':' should be same as start then.','line_number':955,'multiline':False]
['text':' For a match in the first column, set the position','line_number':960,'multiline':False]
['text':' on the NUL in the previous line.','line_number':961,'multiline':False]
['text':' just in case','line_number':966,'multiline':False]
['text':' Set variables used for 'incsearch' highlighting.','line_number':1005,'multiline':False]
['text':' stop if ctrl-C typed','line_number':1010,'multiline':False]
['text':' Cancel searching if a character was typed.  Used for','line_number':1015,'multiline':False]
['text':' 'incsearch'.  Don't check too often, that would slowdown','line_number':1016,'multiline':False]
['text':' searching too much.','line_number':1017,'multiline':False]
['text':' if second loop, stop where started','line_number':1028,'multiline':False]
['text':' vim_regexec_multi() may clear "regprog"','line_number':1032,'multiline':False]
['text':'
	     * Stop the search if wrapscan isn't set, "stop_lnum" is
	     * specified, after an interrupt, after a match and after looping
	     * twice.
	     ','line_number':1036,'multiline':True]
['text':'
	     * If 'wrapscan' is set we continue at the other end of the file.
	     * If 'shortmess' does not contain 's', we give a message, but
	     * only, if we won't show the search stat later anyhow,
	     * (so SEARCH_COUNT must be absent).
	     * This message is also remembered in keep_msg for when the screen
	     * is redrawn. The keep_msg is cleared whenever another message is
	     * written.
	     ','line_number':1049,'multiline':True]
['text':' start second loop at the other end','line_number':1058,'multiline':False]
['text':' stop after count matches or no match','line_number':1077,'multiline':False]
['text':' did not find it','line_number':1085,'multiline':False]
['text':' A pattern like "\n\zs" may go past the last line.','line_number':1101,'multiline':False]
['text':'
 * Return the number of the first subpat that matched.
 * Return zero if none of them matched.
 ','line_number':1126,'multiline':True]
['text':'
 * Highest level string search function.
 * Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'
 *		  If 'dirc' is 0: use previous dir.
 *    If 'pat' is NULL or empty : use previous string.
 *    If 'options & SEARCH_REV' : go in reverse of previous dir.
 *    If 'options & SEARCH_ECHO': echo the search command and handle options
 *    If 'options & SEARCH_MSG' : may give error message
 *    If 'options & SEARCH_OPT' : interpret optional flags
 *    If 'options & SEARCH_HIS' : put search pattern in history
 *    If 'options & SEARCH_NOOF': don't add offset to position
 *    If 'options & SEARCH_MARK': set previous context mark
 *    If 'options & SEARCH_KEEP': keep previous search pattern
 *    If 'options & SEARCH_START': accept match at curpos itself
 *    If 'options & SEARCH_PEEK': check for typed char, cancel search
 *
 * Careful: If spats[0].off.line == TRUE and spats[0].off.off == 0 this
 * makes the movement linewise without moving the match position.
 *
 * Return 0 for failure, 1 for found, 2 for found and line offset added.
 ','line_number':1149,'multiline':True]
['text':' can be NULL','line_number':1172,'multiline':False]
['text':' '/' or '?'','line_number':1173,'multiline':False]
['text':' the delimiter for the search, e.g. '%' in','line_number':1174,'multiline':False]
['text':' s%regex%replacement%','line_number':1175,'multiline':False]
['text':' optional arguments or NULL','line_number':1179,'multiline':False]
['text':' position of the last match','line_number':1181,'multiline':False]
['text':' Return value','line_number':1184,'multiline':False]
['text':'
     * A line offset is not remembered, this is vi compatible.
     ','line_number':1194,'multiline':True]
['text':'
     * Save the values for when (options & SEARCH_KEEP) is used.
     * (there is no "if ()" around this because gcc wants them initialized)
     ','line_number':1203,'multiline':True]
['text':' start searching at the cursor position','line_number':1209,'multiline':False]
['text':'
     * Find out the direction of the search.
     ','line_number':1211,'multiline':True]
['text':' There is a bug in the Visual C++ 2.2 compiler which means that','line_number':1226,'multiline':False]
['text':' dirc always ends up being '/'','line_number':1227,'multiline':False]
['text':' If the cursor is in a closed fold, don't find another match in the same','line_number':1238,'multiline':False]
['text':' fold.','line_number':1239,'multiline':False]
['text':' avoid overflow when adding 1','line_number':1243,'multiline':False]
['text':'
     * Turn 'hlsearch' highlighting back on.
     ','line_number':1253,'multiline':True]
['text':'
     * Repeat the search when pattern followed by ';', e.g. "/foo/;?bar".
     ','line_number':1263,'multiline':True]
['text':' use previous pattern','line_number':1272,'multiline':False]
['text':' no previous pattern','line_number':1275,'multiline':False]
['text':' make search_regcomp() use spats[RE_SEARCH].pat','line_number':1287,'multiline':False]
['text':' look for (new) offset','line_number':1292,'multiline':False]
['text':'
	     * Find end of regular expression.
	     * If there is a matching '/' or '?', toss it.
	     ','line_number':1294,'multiline':True]
['text':' made a copy of "pat" to change "\?" to "?"','line_number':1303,'multiline':False]
['text':' remember where we put the NUL','line_number':1310,'multiline':False]
['text':'
	     * Check for a line offset or a character offset.
	     * For get_address (echo off) we don't check for a character
	     * offset, because it is meaningless and the 's' could be a
	     * substitute command.
	     ','line_number':1316,'multiline':True]
['text':' end','line_number':1327,'multiline':False]
['text':' got an offset','line_number':1331,'multiline':False]
['text':' 'nr' or '+nr' or '-nr'','line_number':1333,'multiline':False]
['text':' single '-'','line_number':1336,'multiline':False]
['text':' single '+'','line_number':1338,'multiline':False]
['text':' skip number','line_number':1341,'multiline':False]
['text':' compute length of search command for get_address()','line_number':1345,'multiline':False]
['text':' put pat after search command','line_number':1348,'multiline':False]
['text':' Compute msg_row early.','line_number':1359,'multiline':False]
['text':' Get the offset, so we know how long it is.','line_number':1362,'multiline':False]
['text':' Reserve enough space for the search pattern + offset +','line_number':1387,'multiline':False]
['text':' search stat.  Use all the space available, so that the','line_number':1388,'multiline':False]
['text':' search state is right aligned.  If there is not enough space','line_number':1389,'multiline':False]
['text':' msg_strtrunc() will shorten in the middle.','line_number':1390,'multiline':False]
['text':' Use all the columns.','line_number':1392,'multiline':False]
['text':' Use up to 'showcmd' column.','line_number':1395,'multiline':False]
['text':' Reserve enough space for the search pattern + offset.','line_number':1401,'multiline':False]
['text':' do not fill the msgbuf buffer, if cmd_silent is set, leave it','line_number':1410,'multiline':False]
['text':' empty for the search_stat feature.','line_number':1411,'multiline':False]
['text':' Use a space to draw the composing char on.','line_number':1418,'multiline':False]
['text':' The search pattern could be shown on the right in','line_number':1435,'multiline':False]
['text':' rightleft mode, but the 'ruler' and 'showcmd' area use','line_number':1436,'multiline':False]
['text':' it too, thus it would be blanked out again very soon.','line_number':1437,'multiline':False]
['text':' Show it on the left, but do reverse the text.','line_number':1438,'multiline':False]
['text':' move reversed text to beginning of buffer','line_number':1449,'multiline':False]
['text':' overwrite old text','line_number':1454,'multiline':False]
['text':' don't wait for this message','line_number':1468,'multiline':False]
['text':'
	 * If there is a character offset, subtract it from the current
	 * position, so we don't get stuck at "?pat?e+2" or "/pat/s-2".
	 * Skip this if pos.col is near MAXCOL (closed fold).
	 * This is not done for a line offset, because then we would not be vi
	 * compatible.
	 ','line_number':1473,'multiline':True]
['text':' at start of buffer','line_number':1487,'multiline':False]
['text':' allow lnum == 0 here','line_number':1489,'multiline':False]
['text':' at end of buffer','line_number':1498,'multiline':False]
['text':'
	 * The actual search.
	 ','line_number':1506,'multiline':True]
['text':' restore second '/' or '?' for normal_cmd()','line_number':1518,'multiline':False]
['text':' 'e' includes last character','line_number':1531,'multiline':False]
['text':' pattern found','line_number':1533,'multiline':False]
['text':'
	 * Add character and/or line offset
	 ','line_number':1535,'multiline':True]
['text':' Add the offset to the line number.','line_number':1542,'multiline':False]
['text':' pattern found, line offset added','line_number':1553,'multiline':False]
['text':' just in case','line_number':1555,'multiline':False]
['text':' to the right, check for end of file','line_number':1557,'multiline':False]
['text':' to the left, check for start of file','line_number':1565,'multiline':False]
['text':' Show [1/15] if 'S' is not in 'shortmess'.','line_number':1577,'multiline':False]
['text':'
	 * The search command can be followed by a ';' to do another search.
	 * For example: "/pat/;/foo/+3;?bar"
	 * This is like doing another search command, except:
	 * - The remembered direction '/' or '?' is from the first search.
	 * - When an error happens the cursor isn't moved at all.
	 * Don't do this when called by get_address() (it handles ';' itself).
	 ','line_number':1596,'multiline':True]
['text':'
 * search_for_exact_line(buf, pos, dir, pat)
 *
 * Search for a line starting with the given pattern (ignoring leading
 * white-space), starting from pos and going in direction "dir". "pos" will
 * contain the position of the match found.    Blank lines match only if
 * ADDING is set.  If p_ic is set then the pattern must be in lowercase.
 * Return OK for success, or FAIL if no line found.
 ','line_number':1632,'multiline':True]
['text':' when adding lines the matching line may be empty but it is not','line_number':1693,'multiline':False]
['text':' ignored because we are interested in the next line -- Acevedo','line_number':1694,'multiline':False]
['text':' ignore empty lines','line_number':1700,'multiline':False]
['text':' expanding lines or words','line_number':1701,'multiline':False]
['text':'
 * Character Searches
 ','line_number':1710,'multiline':True]
['text':'
 * Search for a character in a line.  If "t_cmd" is FALSE, move to the
 * position of the character, otherwise move to just before the char.
 * Do this "cap->count1" times.
 * Return FAIL or OK.
 ','line_number':1714,'multiline':True]
['text':' char to search for','line_number':1723,'multiline':False]
['text':' TRUE for searching forward','line_number':1724,'multiline':False]
['text':' repeat count','line_number':1725,'multiline':False]
['text':' normal search: remember args for repeat','line_number':1731,'multiline':False]
['text':' don't remember when redoing','line_number':1733,'multiline':False]
['text':' repeat previous search','line_number':1749,'multiline':False]
['text':' repeat in opposite direction','line_number':1753,'multiline':False]
['text':' For multi-byte re-use last lastc_bytes[] and lastc_bytelen.','line_number':1759,'multiline':False]
['text':' Force a move of at least one char, so ";" and "," will move the','line_number':1761,'multiline':False]
['text':' cursor, even if the cursor is right in front of char we are looking','line_number':1762,'multiline':False]
['text':' at.','line_number':1763,'multiline':False]
['text':' backup to before the character (possibly double-byte)','line_number':1821,'multiline':False]
['text':' Landed on the search char which is lastc_bytelen long','line_number':1826,'multiline':False]
['text':' To previous char, which may be multi-byte.','line_number':1829,'multiline':False]
['text':'
 * "Other" Searches
 ','line_number':1838,'multiline':True]
['text':'
 * findmatch - find the matching paren or brace
 *
 * Improvement over vi: Braces inside quotes are ignored.
 ','line_number':1842,'multiline':True]
['text':'
 * Return TRUE if the character before "linep[col]" equals "ch".
 * Return FALSE if "col" is zero.
 * Update "*prevcol" to the column of the previous character, unless "prevcol"
 * is NULL.
 * Handles multibyte string correctly.
 ','line_number':1853,'multiline':True]
['text':'
 * Raw string start is found at linep[startpos.col - 1].
 * Return TRUE if the matching end can be found between startpos and endpos.
 ','line_number':1875,'multiline':True]
['text':'
 * Check matchpairs option for "*initc".
 * If there is a match set "*initc" to the matching character and "*findc" to
 * the opposite character.  Set "*backwards" to the direction.
 * When "switchit" is TRUE swap the direction.
 ','line_number':1917,'multiline':True]
['text':'
 * findmatchlimit -- find the matching paren or brace, if it exists within
 * maxtravel lines of the cursor.  A maxtravel of 0 means search until falling
 * off the edge of the file.
 *
 * "initc" is the character to find a match for.  NUL means to find the
 * character at or after the cursor. Special values:
 * '*'  look for C-style comment / *
 * '/'  look for C-style comment / *, ignoring comment-end
 * '#'  look for preprocessor directives
 * 'R'  look for raw string start: R"delim(text)delim" (only backwards)
 *
 * flags: FM_BACKWARD	search backwards (when initc is '/', '*' or '#')
 *	  FM_FORWARD	search forwards (when initc is '/', '*' or '#')
 *	  FM_BLOCKSTOP	stop at start/end of block ({ or } in column 0)
 *	  FM_SKIPCOMM	skip comments (not implemented yet!)
 *
 * "oap" is only used to set oap->motion_type for a linewise motion, it can be
 * NULL
 ','line_number':2013,'multiline':True]
['text':' current search position','line_number':2040,'multiline':False]
['text':' matching brace','line_number':2041,'multiline':False]
['text':' cumulative number of braces','line_number':2043,'multiline':False]
['text':' init for gcc','line_number':2044,'multiline':False]
['text':' search for raw string','line_number':2045,'multiline':False]
['text':' TRUE when inside quotes','line_number':2046,'multiline':False]
['text':' pointer to current line','line_number':2047,'multiline':False]
['text':' check for quotes in current line','line_number':2049,'multiline':False]
['text':' do_quotes value at start position','line_number':2050,'multiline':False]
['text':' Direction searched for # things','line_number':2051,'multiline':False]
['text':' Direction searched for comments','line_number':2052,'multiline':False]
['text':' Where last slash-star was found','line_number':2053,'multiline':False]
['text':' start position is in quotes','line_number':2054,'multiline':False]
['text':' how far we've searched so far','line_number':2055,'multiline':False]
['text':' ignore comment end','line_number':2056,'multiline':False]
['text':' vi compatible matching','line_number':2057,'multiline':False]
['text':' don't recognize backslashes','line_number':2058,'multiline':False]
['text':' search for escaped match','line_number':2059,'multiline':False]
['text':' Direction to search','line_number':2060,'multiline':False]
['text':' start of / / comment','line_number':2061,'multiline':False]
['text':' inside of Lisp-style comment','line_number':2062,'multiline':False]
['text':' engage Lisp-specific hacks ;)','line_number':2063,'multiline':False]
['text':' Direction to search when initc is '/', '*' or '#'','line_number':2072,'multiline':False]
['text':'
     * if initc given, look in the table for the matching character
     * '/' and '*' are special cases: look for start or end of comment.
     * When '/' is used, we ignore running backwards into an star-slash, for
     * "[*" command, we just want to find any comment.
     ','line_number':2080,'multiline':True]
['text':'
	 * Either initc is '#', or no initc was given and we need to look
	 * under the cursor.
	 ','line_number':2105,'multiline':True]
['text':'
	     * initc was not given, must look for something to match under
	     * or near the cursor.
	     * Only check for special things when 'cpo' doesn't have '%'.
	     ','line_number':2115,'multiline':True]
['text':' Are we before or at #if, #else etc.?','line_number':2122,'multiline':False]
['text':' Are we on a comment?','line_number':2133,'multiline':False]
['text':'
	     * If we are not on a comment or the # at the start of a line, then
	     * look for brace anywhere on this line after the cursor.
	     ','line_number':2164,'multiline':True]
['text':'
		 * Find the brace under or after the cursor.
		 * If beyond the end of the line, use the last character in
		 * the line.
		 ','line_number':2170,'multiline':True]
['text':' no brace in the line, maybe use "  #if" then','line_number':2190,'multiline':False]
['text':' Set "match_escaped" if there are an odd number of','line_number':2200,'multiline':False]
['text':' backslashes.','line_number':2201,'multiline':False]
['text':'
	     * Look for matching #if, #else, #elif, or #endif
	     ','line_number':2210,'multiline':True]
['text':' Linewise for this case only','line_number':2214,'multiline':False]
['text':' check for CTRL-C typed','line_number':2237,'multiline':False]
['text':' This is just guessing: when 'rightleft' is set, search for a matching','line_number':2281,'multiline':False]
['text':' paren/brace in the other direction.','line_number':2282,'multiline':False]
['text':' backward search: Check if this line contains a single-line comment','line_number':2291,'multiline':False]
['text':' find match inside this comment','line_number':2295,'multiline':False]
['text':'
	 * Go to the next position, forward or backward. We could use
	 * inc() and dec() here, but that is much slower
	 ','line_number':2299,'multiline':True]
['text':' char to match is inside of comment, don't search outside','line_number':2305,'multiline':False]
['text':' at start of line, go to prev. one','line_number':2308,'multiline':False]
['text':' start of file','line_number':2310,'multiline':False]
['text':' pos.col on trailing NUL','line_number':2318,'multiline':False]
['text':' Check if this line contains a single-line comment','line_number':2322,'multiline':False]
['text':' skip comment','line_number':2325,'multiline':False]
['text':' forward search','line_number':2336,'multiline':False]
['text':' at end of line, go to next one','line_number':2339,'multiline':False]
['text':' For lisp don't search for match in comment','line_number':2340,'multiline':False]
['text':' end of file','line_number':2344,'multiline':False]
['text':' line is exhausted and comment with it,','line_number':2345,'multiline':False]
['text':' don't search for match in code','line_number':2346,'multiline':False]
['text':' find comment pos in new line','line_number':2358,'multiline':False]
['text':'
	 * If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.
	 ','line_number':2370,'multiline':True]
['text':' match!','line_number':2376,'multiline':False]
['text':' out of scope','line_number':2378,'multiline':False]
['text':' Note: comments do not nest, and we ignore quotes in them','line_number':2383,'multiline':False]
['text':' TODO: ignore comment brackets inside strings','line_number':2384,'multiline':False]
['text':' Searching backwards','line_number':2393,'multiline':False]
['text':'
		 * A comment may contain / * or / /, it may also start or end
		 * with / * /.	Ignore a / * after / / and after *.
		 ','line_number':2395,'multiline':True]
['text':' Possible start of raw string. Now that we have the','line_number':2407,'multiline':False]
['text':' delimiter we can check if it ends before where we','line_number':2408,'multiline':False]
['text':' started searching, or before the previously found','line_number':2409,'multiline':False]
['text':' raw string start.','line_number':2410,'multiline':False]
['text':' may have been released','line_number':2418,'multiline':False]
['text':'
	 * If smart matching ('cpoptions' does not contain '%'), braces inside
	 * of quotes are ignored, but only if there is an even number of
	 * quotes in the line.
	 ','line_number':2447,'multiline':True]
['text':'
	     * Count the number of quotes in the line, skipping \" and '"'.
	     * Watch out for "\\".
	     ','line_number':2456,'multiline':True]
['text':' result is 1 with even number of quotes','line_number':2471,'multiline':False]
['text':'
	     * If we find an uneven count, check current line and previous
	     * one for a '\' at the end.
	     ','line_number':2473,'multiline':True]
['text':' Do we need to use at_start here?','line_number':2485,'multiline':False]
['text':' ml_get() only keeps one line, need to get linep again','line_number':2508,'multiline':False]
['text':'
	 * If 'smartmatch' is set:
	 *   Things inside quotes are ignored by setting 'inquote'.  If we
	 *   find a quote without a preceding '\' invert 'inquote'.  At the
	 *   end of a line not ending in '\' we reset 'inquote'.
	 *
	 *   In lines with an uneven number of quotes (without preceding '\')
	 *   we do not know which part to ignore. Therefore we only set
	 *   inquote if the number of quotes in a line is even, unless this
	 *   line or the previous one ends in a '\'.  Complicated, isn't it?
	 ','line_number':2516,'multiline':True]
['text':' at end of line without trailing backslash, reset inquote','line_number':2531,'multiline':False]
['text':' a quote that is preceded with an odd number of backslashes is','line_number':2540,'multiline':False]
['text':' ignored','line_number':2541,'multiline':False]
['text':'
	 * If smart matching ('cpoptions' does not contain '%'):
	 *   Skip things in single quotes: 'x' or '\x'.  Be careful for single
	 *   single quotes, eg jon's.  Things like '\233' or '\x3f' are not
	 *   skipped, there is never a brace in them.
	 *   Ignore this when finding matches for `'.
	 ','line_number':2557,'multiline':True]
['text':' forward search','line_number':2584,'multiline':False]
['text':' FALLTHROUGH','line_number':2599,'multiline':False]
['text':'
	     * For Lisp skip over backslashed (), {} and [].
	     * (actually, we skip #\( et al)
	     ','line_number':2602,'multiline':True]
['text':' Check for match outside of quotes, and inside of','line_number':2613,'multiline':False]
['text':' quotes when the start is also inside of quotes.','line_number':2614,'multiline':False]
['text':' Only accept a match when 'M' is in 'cpo' or when escaping','line_number':2625,'multiline':False]
['text':' is what we expect.','line_number':2626,'multiline':False]
['text':' never found it','line_number':2647,'multiline':False]
['text':'
 * Check if line[] contains a / / comment.
 * Return MAXCOL if not, otherwise return the column.
 ','line_number':2650,'multiline':True]
['text':' skip Lispish one-line comments','line_number':2660,'multiline':False]
['text':' there may be comments','line_number':2663,'multiline':False]
['text':' inside of string','line_number':2665,'multiline':False]
['text':' scan from start','line_number':2667,'multiline':False]
['text':' skip escaped quote','line_number':2674,'multiline':False]
['text':' skip #\" form','line_number':2678,'multiline':False]
['text':' found!','line_number':2685,'multiline':False]
['text':' Accept a double /, unless it's preceded with * and followed by','line_number':2695,'multiline':False]
['text':' *, because * / / * is an end and start of a C comment.  Only','line_number':2696,'multiline':False]
['text':' accept the position if it is not inside a string.','line_number':2697,'multiline':False]
['text':'
 * Move cursor briefly to character matching the one under the cursor.
 * Used for Insert mode and "r" command.
 * Show the match only if it is visible on the screen.
 * If there isn't a match, then beep.
 ','line_number':2709,'multiline':True]
['text':' char to show match for','line_number':2717,'multiline':False]
['text':'
     * Only show match for chars in the 'matchpairs' option.
     ','line_number':2732,'multiline':True]
['text':' 'matchpairs' is "x:y,x:y"','line_number':2735,'multiline':False]
['text':' no match, so beep','line_number':2756,'multiline':False]
['text':' save the pos, update_screen() may change it','line_number':2774,'multiline':False]
['text':' Handle "$" in 'cpo': If the ')' is typed on top of the "$",','line_number':2778,'multiline':False]
['text':' stop displaying the "$".','line_number':2779,'multiline':False]
['text':' do display ')' just before "$"','line_number':2782,'multiline':False]
['text':' show the new char first','line_number':2783,'multiline':False]
['text':' may show different cursor shape','line_number':2789,'multiline':False]
['text':' move to matching char','line_number':2791,'multiline':False]
['text':' don't use 'scrolloff' here','line_number':2792,'multiline':False]
['text':' don't use 'sidescrolloff' here','line_number':2793,'multiline':False]
['text':' make sure that the cursor is shown','line_number':2796,'multiline':False]
['text':' Restore dollar_vcol(), because setcursor() may call curs_rows()','line_number':2799,'multiline':False]
['text':' which resets it if the matching position is in a previous line','line_number':2800,'multiline':False]
['text':' and has a higher column number.','line_number':2801,'multiline':False]
['text':'
     * brief pause, unless 'm' is present in 'cpo' and a character is
     * available.
     ','line_number':2804,'multiline':True]
['text':' restore cursor position','line_number':2812,'multiline':False]
['text':' may show different cursor shape','line_number':2817,'multiline':False]
['text':'
 * Check if the pattern is zero-width.
 * If move is TRUE, check from the beginning of the buffer, else from position
 * "cur".
 * "direction" is FORWARD or BACKWARD.
 * Returns TRUE, FALSE or -1 for failure.
 ','line_number':2821,'multiline':True]
['text':' init startcol correctly','line_number':2845,'multiline':False]
['text':' move to match','line_number':2847,'multiline':False]
['text':' accept a match at the cursor position','line_number':2855,'multiline':False]
['text':' Zero-width pattern should match somewhere, then we can check if','line_number':2862,'multiline':False]
['text':' start and end are in the same position.','line_number':2863,'multiline':False]
['text':'
 * Find next search match under cursor, cursor at end.
 * Used while an operator is pending, and in Visual mode.
 ','line_number':2888,'multiline':True]
['text':' TRUE for forward, FALSE for backward','line_number':2895,'multiline':False]
['text':' start position of the pattern match','line_number':2897,'multiline':False]
['text':' end position of the pattern match','line_number':2898,'multiline':False]
['text':' position of the cursor at beginning','line_number':2899,'multiline':False]
['text':' position after the pattern','line_number':2900,'multiline':False]
['text':' result of various function calls','line_number':2903,'multiline':False]
['text':' Correct cursor when 'selection' is exclusive','line_number':2910,'multiline':False]
['text':' When searching forward and the cursor is at the start of the Visual','line_number':2914,'multiline':False]
['text':' area, skip the first search backward, otherwise it doesn't move.','line_number':2915,'multiline':False]
['text':' Is the pattern is zero-width?, this time, don't care about the direction','line_number':2928,'multiline':False]
['text':' pattern not found','line_number':2932,'multiline':False]
['text':'
     * The trick is to first search backwards and then search forward again,
     * so that a match at the current cursor position will be correctly
     * captured.  When "forward" is false do it the other way around.
     ','line_number':2934,'multiline':True]
['text':' wrapping should not occur in the first round','line_number':2955,'multiline':False]
['text':' First search may fail, but then start searching from the','line_number':2966,'multiline':False]
['text':' beginning of the file (cursor might be on the search match)','line_number':2967,'multiline':False]
['text':' except when Visual mode is active, so that extending the visual','line_number':2968,'multiline':False]
['text':' selection works.','line_number':2969,'multiline':False]
['text':' not found, abort','line_number':2970,'multiline':False]
['text':' try again from start of buffer','line_number':2981,'multiline':False]
['text':' try again from end of buffer','line_number':2986,'multiline':False]
['text':' searching backwards, so set pos to last line and col','line_number':2987,'multiline':False]
['text':' put the cursor after the match','line_number':3000,'multiline':False]
['text':' put the cursor on the start of the match','line_number':3005,'multiline':False]
['text':' put the cursor on last character of match','line_number':3008,'multiline':False]
['text':' put the cursor on the start of the match','line_number':3012,'multiline':False]
['text':' Correction for exclusive selection depends on the direction.','line_number':3018,'multiline':False]
['text':' Make sure the clipboard gets updated.  Needed because start and','line_number':3033,'multiline':False]
['text':' end are still the same, and the selection needs to be owned','line_number':3034,'multiline':False]
['text':'
 * return TRUE if line 'lnum' is empty or has white chars only.
 ','line_number':3043,'multiline':True]
['text':'
 * Add the search count "[3/19]" to "msgbuf".
 * See update_search_stat() for other arguments.
 ','line_number':3055,'multiline':True]
['text':' keep the message even after redraw, but don't put in history','line_number':3128,'multiline':False]
['text':'
 * Add the search count information to "stat".
 * "stat" must not be NULL.
 * When "recompute" is TRUE always recompute the numbers.
 * dirc == 0: don't find the next/previous match (only set the result to "stat")
 * dirc == '/': find the next match
 * dirc == '?': find the previous match
 ','line_number':3134,'multiline':True]
['text':' If anything relevant changed the count has to be recomputed.','line_number':3184,'multiline':False]
['text':' MB_STRNICMP ignores case, but we should not ignore case.','line_number':3185,'multiline':False]
['text':' Unfortunately, there is no MB_STRNICMP function.','line_number':3186,'multiline':False]
['text':' XXX: above comment should be "no MB_STRCMP function" ?','line_number':3187,'multiline':False]
['text':' when searching backwards and having jumped to the first occurrence,','line_number':3203,'multiline':False]
['text':' cur must remain greater than 1','line_number':3204,'multiline':False]
['text':' Stop after passing the time limit.','line_number':3223,'multiline':False]
['text':' max count exceeded','line_number':3240,'multiline':False]
['text':' abort','line_number':3245,'multiline':False]
['text':'
 * Get line "lnum" and copy it into "buf[LSIZE]".
 * The copy is made because the regexp may make the line invalid when using a
 * mark.
 ','line_number':3265,'multiline':True]
['text':'
 * Find identifiers or defines in included files.
 * If p_ic && compl_status_sol() then ptr must be in lowercase.
 ','line_number':3279,'multiline':True]
['text':' pointer to search pattern','line_number':3285,'multiline':False]
['text':' direction of expansion','line_number':3286,'multiline':False]
['text':' length of search pattern','line_number':3287,'multiline':False]
['text':' match whole words only','line_number':3288,'multiline':False]
['text':' don't match inside comments','line_number':3289,'multiline':False]
['text':' Type of search; are we looking for a type?','line_number':3290,'multiline':False]
['text':' a macro?','line_number':3291,'multiline':False]
['text':' What to do when we find it','line_number':3293,'multiline':False]
['text':' first line to start searching','line_number':3294,'multiline':False]
['text':' last line for searching','line_number':3295,'multiline':False]
['text':' Stack of included files','line_number':3297,'multiline':False]
['text':' When we need more space','line_number':3298,'multiline':False]
['text':' For type==CHECK_PATH','line_number':3308,'multiline':False]
['text':' when CONT_SOL is set compare "ptr" with the beginning of the','line_number':3339,'multiline':False]
['text':' line is faster than quote_meta/regcomp/regexec "ptr" -- Acevedo','line_number':3340,'multiline':False]
['text':' ignore case according to p_ic, p_scs and pat','line_number':3347,'multiline':False]
['text':' don't ignore case in incl. pat.','line_number':3361,'multiline':False]
['text':' don't ignore case in define pat.','line_number':3370,'multiline':False]
['text':' do at least one line','line_number':3381,'multiline':False]
['text':' Use text from '\zs' to '\ze' (or end) of 'include'.','line_number':3394,'multiline':False]
['text':' Use text after match with 'include'.','line_number':3399,'multiline':False]
['text':' Check whether we have already searched in this file','line_number':3405,'multiline':False]
['text':' cursor below last one','line_number':3419,'multiline':False]
['text':' don't display if 'q'','line_number':3420,'multiline':False]
['text':' typed at "--more--"','line_number':3421,'multiline':False]
['text':' message','line_number':3422,'multiline':False]
['text':' cursor below last one','line_number':3440,'multiline':False]
['text':' cursor at status line','line_number':3443,'multiline':False]
['text':' don't display if 'q' typed','line_number':3458,'multiline':False]
['text':' for "--more--" message','line_number':3459,'multiline':False]
['text':' using "new_fname" is more reliable, e.g., when','line_number':3465,'multiline':False]
['text':' 'includeexpr' is set.','line_number':3466,'multiline':False]
['text':'
			 * Isolate the file name.
			 * Include the surrounding "" or <> if present.
			 ','line_number':3471,'multiline':True]
['text':' pattern contains \zs, use the match','line_number':3478,'multiline':False]
['text':' find the file name after the end of the match','line_number':3485,'multiline':False]
['text':' Nothing found, use the rest of the line.','line_number':3495,'multiline':False]
['text':' Avoid checking before the start of the line, can','line_number':3499,'multiline':False]
['text':' happen if \zs appears in the regexp.','line_number':3500,'multiline':False]
['text':' output each line directly','line_number':3525,'multiline':False]
['text':' Push the new file onto the file stack','line_number':3530,'multiline':False]
['text':'
			 * lalloc() for 'bigger' must have failed above.  We
			 * will forget one of our already visited files now.
			 ','line_number':3560,'multiline':True]
['text':' reset in msg_trunc_attr()','line_number':3572,'multiline':False]
['text':'
	     * Check if the line is a define (type == FIND_DEFINE)
	     ','line_number':3591,'multiline':True]
['text':'
		 * Pattern must be first identifier after 'define', so skip
		 * to that position before checking for match of pattern.  Also
		 * don't let it match beyond the end of this identifier.
		 ','line_number':3600,'multiline':True]
['text':'
	     * Look for a match.  Don't do this if we are looking for a
	     * define and this line didn't match define_prog above.
	     ','line_number':3611,'multiline':True]
['text':' compare the first "len" chars from "ptr"','line_number':3619,'multiline':False]
['text':'
		     * Check if the line is not a comment line (unless we are
		     * looking for a define).  A line starting with "# define"
		     * is not considered to be a comment line.
		     ','line_number':3634,'multiline':True]
['text':'
			 * Also check for a "/ *" or "/ /" before the match.
			 * Skips lines like "int backwards;  / * normal index
			 * * /" when looking for "normal".
			 * Note: Doesn't skip "/ *" in comments.
			 ','line_number':3646,'multiline':True]
['text':' After "//" all text is comment','line_number':3662,'multiline':False]
['text':' Can find match after "* /".','line_number':3669,'multiline':False]
['text':' IOSIZE > compl_length, so the STRNCPY works','line_number':3702,'multiline':False]
['text':' Get the next line: when "depth" < 0  from the current','line_number':3705,'multiline':False]
['text':' buffer, otherwise from the included file.  Jump to','line_number':3706,'multiline':False]
['text':' exit_matched when past the last line.','line_number':3707,'multiline':False]
['text':' we read a line, set "already" to check this "line" later','line_number':3718,'multiline':False]
['text':' if depth >= 0 we'll increase files[depth].lnum far','line_number':3719,'multiline':False]
['text':' below  -- Acevedo','line_number':3720,'multiline':False]
['text':' IObuf =~ "\(\k\|\i\).* ", thus i >= 2','line_number':3730,'multiline':False]
['text':' copy as much as possible of the new word','line_number':3738,'multiline':False]
['text':' if dir was BACKWARD then honor it just once','line_number':3756,'multiline':False]
['text':' cursor at status line','line_number':3765,'multiline':False]
['text':' cursor below last one','line_number':3769,'multiline':False]
['text':' don't display if 'q' typed','line_number':3770,'multiline':False]
['text':' at "--more--" message','line_number':3771,'multiline':False]
['text':' Set matched flag for this file and all the ones that','line_number':3782,'multiline':False]
['text':' include it','line_number':3783,'multiline':False]
['text':' ":psearch" uses the preview window','line_number':3809,'multiline':False]
['text':' match in current file','line_number':3824,'multiline':False]
['text':' failed to jump to file','line_number':3833,'multiline':False]
['text':' failed to jump to file','line_number':3846,'multiline':False]
['text':' autocommands may have changed the lnum, we don't','line_number':3847,'multiline':False]
['text':' want that here','line_number':3848,'multiline':False]
['text':' Return cursor to where we were','line_number':3862,'multiline':False]
['text':' can't keep focus in popup window','line_number':3869,'multiline':False]
['text':' look for other matches in the rest of the line if we','line_number':3877,'multiline':False]
['text':' are not at the end of it already','line_number':3878,'multiline':False]
['text':'
	 * Read the next line.  When reading an included file and encountering
	 * end-of-file, close the file and continue in the file that included
	 * it.
	 ','line_number':3892,'multiline':True]
['text':' we could read the line','line_number':3910,'multiline':False]
['text':' Remove any CR and LF from the line.','line_number':3913,'multiline':False]
['text':' End of big for (;;) loop.','line_number':3928,'multiline':False]
['text':' Close any files that are still open.','line_number':3930,'multiline':False]
['text':' cursor below last one','line_number':3982,'multiline':False]
['text':' cursor at status line','line_number':3984,'multiline':False]
['text':' 'q' typed at "--more--" message','line_number':3985,'multiline':False]
['text':' We used fgets(), so get rid of newline at end','line_number':3992,'multiline':False]
['text':' show match nr','line_number':4001,'multiline':False]
['text':' show line nr','line_number':4003,'multiline':False]
['text':' Highlight line numbers','line_number':4004,'multiline':False]
['text':' show one line at a time','line_number':4009,'multiline':False]
['text':' Definition continues until line that doesn't end with '\'','line_number':4011,'multiline':False]
['text':' end of file','line_number':4017,'multiline':False]
['text':'
 * Return the last used search pattern at "idx".
 ','line_number':4033,'multiline':True]
['text':'
 * Return the last used search pattern index.
 ','line_number':4042,'multiline':True]
['text':'
 * "searchcount()" function
 ','line_number':4053,'multiline':True]
['text':' 'shortmess' contains 'S' flag','line_number':4072,'multiline':False]
['text':' the previous pattern was never defined','line_number':4156,'multiline':False]
['text':'
 * Fuzzy string matching
 *
 * Ported from the lib_fts library authored by Forrest Smith.
 * https://github.com/forrestthewoods/lib_fts/tree/master/code
 *
 * The following blog describes the fuzzy matching algorithm:
 * https://www.forrestthewoods.com/blog/reverse_engineering_sublime_texts_fuzzy_match/
 *
 * Each matching string is assigned a score. The following factors are checked:
 *   - Matched letter
 *   - Unmatched letter
 *   - Consecutively matched letters
 *   - Proximity to start
 *   - Letter following a separator (space, underscore)
 *   - Uppercase letter following lowercase (aka CamelCase)
 *
 * Matched letters are good. Unmatched letters are bad. Matching near the start
 * is good. Matching the first letter in the middle of a phrase is good.
 * Matching the uppercase letters in camel case entries is good.
 *
 * The score assigned for each factor is explained below.
 * File paths are different from file names. File extensions may be ignorable.
 * Single words care about consecutive matches but not separators or camel
 * case.
 *   Score starts at 100
 *   Matched letter: +0 points
 *   Unmatched letter: -1 point
 *   Consecutive match bonus: +15 points
 *   First letter bonus: +15 points
 *   Separator bonus: +30 points
 *   Camel case bonus: +30 points
 *   Unmatched leading letter: -5 points (max: -15)
 *
 * There is some nuance to this. Scores don’t have an intrinsic meaning. The
 * score range isn’t 0 to 100. It’s roughly [50, 150]. Longer words have a
 * lower minimum score due to unmatched letter penalty. Longer search patterns
 * have a higher maximum score due to match bonuses.
 *
 * Separator and camel case bonus is worth a LOT. Consecutive matches are worth
 * quite a bit.
 *
 * There is a penalty if you DON’T match the first three letters. Which
 * effectively rewards matching near the start. However there’s no difference
 * in matching between the middle and end.
 *
 * There is not an explicit bonus for an exact match. Unmatched letters receive
 * a penalty. So shorter strings and closer matches are worth more.
 ','line_number':4174,'multiline':True]
['text':' used for stable sort','line_number':4225,'multiline':False]
['text':' bonus for adjacent matches; this is higher than SEPARATOR_BONUS so that','line_number':4231,'multiline':False]
['text':' matching a whole word is preferred.','line_number':4232,'multiline':False]
['text':' bonus if match occurs after a path separator','line_number':4234,'multiline':False]
['text':' bonus if match occurs after a word separator','line_number':4236,'multiline':False]
['text':' bonus if match is uppercase and prev is lower','line_number':4238,'multiline':False]
['text':' bonus if the first letter is matched','line_number':4240,'multiline':False]
['text':' penalty applied for every letter in str before the first match','line_number':4242,'multiline':False]
['text':' maximum penalty for leading letters','line_number':4244,'multiline':False]
['text':' penalty for every letter that doesn't match','line_number':4246,'multiline':False]
['text':' penalty for gap in matching positions (-2 * k)','line_number':4248,'multiline':False]
['text':' Score for a string that doesn't fuzzy match the pattern','line_number':4250,'multiline':False]
['text':'
 * Compute a score for a fuzzy matched string. The matching character locations
 * are in 'matches'.
 ','line_number':4255,'multiline':True]
['text':' Initialize score','line_number':4273,'multiline':False]
['text':' Apply leading letter penalty','line_number':4276,'multiline':False]
['text':' Apply unmatched penalty','line_number':4282,'multiline':False]
['text':' Apply ordering bonuses','line_number':4286,'multiline':False]
['text':' Sequential','line_number':4295,'multiline':False]
['text':' Check for bonuses based on neighbor character value','line_number':4302,'multiline':False]
['text':' Camel case','line_number':4305,'multiline':False]
['text':' Bonus if the match follows a separator character','line_number':4328,'multiline':False]
['text':' First letter','line_number':4336,'multiline':False]
['text':'
 * Perform a recursive search for fuzzy matching 'fuzpat' in 'str'.
 * Return the number of matching characters.
 ','line_number':4343,'multiline':True]
['text':' Recursion params','line_number':4361,'multiline':False]
['text':' Count recursions','line_number':4368,'multiline':False]
['text':' Detect end of strings','line_number':4373,'multiline':False]
['text':' Loop through fuzpat and str looking for a match','line_number':4377,'multiline':False]
['text':' Found match','line_number':4387,'multiline':False]
['text':' Supplied matches buffer was too short','line_number':4390,'multiline':False]
['text':' "Copy-on-Write" srcMatches into matches','line_number':4398,'multiline':False]
['text':' Recursive call that "skips" this match','line_number':4405,'multiline':False]
['text':' Pick best recursive score','line_number':4413,'multiline':False]
['text':' Advance','line_number':4423,'multiline':False]
['text':' Determine if full fuzpat was matched','line_number':4437,'multiline':False]
['text':' Calculate score','line_number':4440,'multiline':False]
['text':' Return best result','line_number':4445,'multiline':False]
['text':' Recursive score is better than "this"','line_number':4448,'multiline':False]
['text':' "this" score is better than recursive','line_number':4454,'multiline':False]
['text':' no match','line_number':4456,'multiline':False]
['text':'
 * fuzzy_match()
 *
 * Performs exhaustive search via recursion to find all possible matches and
 * match with highest score.
 * Scores values have no intrinsic meaning.  Possible score range is not
 * normalized and varies with pattern.
 * Recursion is limited internally (default=10) to prevent degenerate cases
 * (pat_arg="aaaaaa" str="aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa").
 * Uses char_u for match indices. Therefore patterns are limited to
 * MAX_FUZZY_MATCHES characters.
 *
 * Returns TRUE if "pat_arg" matches "str". Also returns the match score in
 * "outScore" and the matching character positions in "matches".
 ','line_number':4459,'multiline':True]
['text':' Try matching each word in 'pat_arg' in 'str'','line_number':4501,'multiline':False]
['text':' Extract one word from the pattern (separated by space)','line_number':4508,'multiline':False]
['text':' processed all the words','line_number':4520,'multiline':False]
['text':' Accumulate the match score and the number of matches','line_number':4536,'multiline':False]
['text':' try matching the next word','line_number':4543,'multiline':False]
['text':'
 * Sort the fuzzy matches in the descending order of the match score.
 * For items with same score, retain the order using the index (stable sort)
 ','line_number':4552,'multiline':True]
['text':'
 * Fuzzy search the string 'str' in a list of 'items' and return the matching
 * strings in 'fmatchlist'.
 * If 'matchseq' is TRUE, then for multi-word search strings, match all the
 * words in sequence.
 * If 'items' is a list of strings, then search for 'str' in the list.
 * If 'items' is a list of dicts, then either use 'key' to lookup the string
 * for each item or use 'item_cb' Funcref function to get the string.
 * If 'retmatchpos' is TRUE, then return a list of positions where 'str'
 * matches for each item.
 ','line_number':4567,'multiline':True]
['text':' For all the string items in items, get the fuzzy matching score','line_number':4606,'multiline':False]
['text':' list of strings','line_number':4618,'multiline':False]
['text':' For a dict, either use the specified key to lookup the string or','line_number':4623,'multiline':False]
['text':' use the specified callback function to get the string.','line_number':4624,'multiline':False]
['text':' Invoke the supplied callback (if any) to get the dict item','line_number':4632,'multiline':False]
['text':' Copy the list of matching positions in itemstr to a list, if','line_number':4654,'multiline':False]
['text':' 'retmatchpos' is set.','line_number':4655,'multiline':False]
['text':' Sort the list by the descending order of the match score','line_number':4690,'multiline':False]
['text':' For matchfuzzy(), return a list of matched strings.','line_number':4694,'multiline':False]
['text':'	    ['str1', 'str2', 'str3']','line_number':4695,'multiline':False]
['text':' For matchfuzzypos(), return a list with three items.','line_number':4696,'multiline':False]
['text':' The first item is a list of matched strings. The second item','line_number':4697,'multiline':False]
['text':' is a list of lists where each list item is a list of matched','line_number':4698,'multiline':False]
['text':' character positions. The third item is a list of matching scores.','line_number':4699,'multiline':False]
['text':'	[['str1', 'str2', 'str3'], [[1, 3], [1, 3], [1, 3]]]','line_number':4700,'multiline':False]
['text':' Copy the matching strings with a valid score to the return list','line_number':4711,'multiline':False]
['text':' next copy the list of matching positions','line_number':4719,'multiline':False]
['text':' copy the matching scores','line_number':4736,'multiline':False]
['text':'
 * Do fuzzy matching. Returns the list of matched strings in 'rettv'.
 * If 'retmatchpos' is TRUE, also returns the matching character positions.
 ','line_number':4755,'multiline':True]
['text':' validate and get the arguments','line_number':4776,'multiline':False]
['text':' To search a dict, either a callback function or a key can be','line_number':4798,'multiline':False]
['text':' specified.','line_number':4799,'multiline':False]
['text':' get the fuzzy matches','line_number':4836,'multiline':False]
['text':' For matchfuzzypos(), a list with three items are returned. First','line_number':4844,'multiline':False]
['text':' item is a list of matching strings, the second item is a list of','line_number':4845,'multiline':False]
['text':' lists with matching positions within each string and the third item','line_number':4846,'multiline':False]
['text':' is the list of scores of the matches.','line_number':4847,'multiline':False]
['text':'
 * "matchfuzzy()" function
 ','line_number':4881,'multiline':True]
['text':'
 * "matchfuzzypos()" function
 ','line_number':4890,'multiline':True]
['text':'
 * Same as fuzzy_match_item_compare() except for use with a string match
 ','line_number':4900,'multiline':True]
['text':'
 * Sort fuzzy matches by score
 ','line_number':4914,'multiline':True]
['text':' Sort the list by the descending order of the match score','line_number':4920,'multiline':False]
['text':'
 * Same as fuzzy_match_item_compare() except for use with a function name
 * string match. <SNR> functions should be sorted to the end.
 ','line_number':4925,'multiline':True]
['text':'
 * Sort fuzzy matches of function names by score.
 * <SNR> functions should be sorted to the end.
 ','line_number':4944,'multiline':True]
['text':' Sort the list by the descending order of the match score','line_number':4951,'multiline':False]
['text':'
 * Fuzzy match 'pat' in 'str'. Returns 0 if there is no match. Otherwise,
 * returns the match score.
 ','line_number':4956,'multiline':True]
['text':'
 * Free an array of fuzzy string matches "fuzmatch[count]".
 ','line_number':4975,'multiline':True]
['text':'
 * Copy a list of fuzzy matches into a string list after sorting the matches by
 * the fuzzy score. Frees the memory allocated for 'fuzmatch'.
 * Returns OK on success and FAIL on memory allocation failure.
 ','line_number':4990,'multiline':True]
['text':' Sort the list by the descending order of the match score','line_number':5014,'multiline':False]
