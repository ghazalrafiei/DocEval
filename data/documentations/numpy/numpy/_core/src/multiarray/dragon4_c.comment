['text':'
 * Copyright (c) 2014 Ryan Juckett
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 ','line_number':1,'multiline':True]
['text':'
 * This file contains a modified version of Ryan Juckett's Dragon4
 * implementation, obtained from https://www.ryanjuckett.com,
 * which has been ported from C++ to C and which has
 * modifications specific to printing floats in numpy.
 *
 * Ryan Juckett's original code was under the Zlib license; he gave numpy
 * permission to include it under the MIT license instead.
 ','line_number':23,'multiline':True]
['text':'
 *  Get the log base 2 of a 32-bit unsigned integer.
 *  https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogLookup
 ','line_number':59,'multiline':True]
['text':' HAVE_LDOUBLE_IEEE_QUAD_LE ','line_number':129,'multiline':True]
['text':'
 * Maximum number of 32 bit blocks needed in high precision arithmetic to print
 * out 128 bit IEEE floating point values. 1023 chosen to be large enough for
 * 128 bit floats, and BigInt is exactly 4kb (nice for page/cache?)
 ','line_number':131,'multiline':True]
['text':'
 * This structure stores a high precision unsigned integer. It uses a buffer of
 * 32 bit integer blocks along with a length. The lowest bits of the integer
 * are stored at the start of the buffer and the length is set to the minimum
 * value that contains the integer. Thus, there are never any zero blocks at
 * the end of the buffer.
 ','line_number':138,'multiline':True]
['text':'
 * Dummy implementation of a memory manager for BigInts. Currently, only
 * supports a single call to Dragon4, but that is OK because Dragon4
 * does not release the GIL.
 *
 * We try to raise an error anyway if dragon4 re-enters, and this code serves
 * as a placeholder if we want to make it re-entrant in the future.
 *
 * Each call to dragon4 uses 7 BigInts.
 ','line_number':150,'multiline':True]
['text':' this test+set is not threadsafe, but no matter because we have GIL ','line_number':171,'multiline':True]
['text':' in this dummy implementation we only return the static allocation ','line_number':180,'multiline':True]
['text':' Copy integer ','line_number':189,'multiline':True]
['text':' Basic type accessors ','line_number':202,'multiline':True]
['text':' Note deliberate fallthrough in this switch ','line_number':243,'multiline':True]
['text':' DOUBLE_DOUBLE and QUAD ','line_number':255,'multiline':True]
['text':'
 * Returns 1 if the value is zero
 ','line_number':269,'multiline':True]
['text':'
 * Returns 1 if the value is even
 ','line_number':278,'multiline':True]
['text':'
 * Returns 0 if (lhs = rhs), negative if (lhs < rhs), positive if (lhs > rhs)
 ','line_number':287,'multiline':True]
['text':' A bigger length implies a bigger number. ','line_number':295,'multiline':True]
['text':' Compare blocks one by one from high to low. ','line_number':301,'multiline':True]
['text':' no blocks differed ','line_number':314,'multiline':True]
['text':' result = lhs + rhs ','line_number':318,'multiline':True]
['text':' determine which operand has the smaller length ','line_number':322,'multiline':True]
['text':' The output will be at least as long as the largest input ','line_number':337,'multiline':True]
['text':' Add each block and add carry the overflow to the next block ','line_number':340,'multiline':True]
['text':' Add the carry to any blocks that only exist in the large operand ','line_number':356,'multiline':True]
['text':' If there's still a carry, append a new block ','line_number':365,'multiline':True]
['text':'
 * result = lhs * rhs
 ','line_number':378,'multiline':True]
['text':' determine which operand has the smaller length ','line_number':392,'multiline':True]
['text':' set the maximum possible result length ','line_number':402,'multiline':True]
['text':' clear the result data ','line_number':406,'multiline':True]
['text':' perform standard long multiplication for each small block ','line_number':411,'multiline':True]
['text':'
         * if non-zero, multiply against all the large blocks and add into the
         * result
         ','line_number':416,'multiline':True]
['text':' check if the terminating block has no set bits ','line_number':439,'multiline':True]
['text':' result = lhs * rhs ','line_number':448,'multiline':True]
['text':' perform long multiplication ','line_number':452,'multiline':True]
['text':' if there is a remaining carry, grow the array ','line_number':463,'multiline':True]
['text':' grow the array ','line_number':465,'multiline':True]
['text':' result = in * 2 ','line_number':475,'multiline':True]
['text':' shift all the blocks by one ','line_number':479,'multiline':True]
['text':' grow the array ','line_number':492,'multiline':True]
['text':' result = result * 2 ','line_number':502,'multiline':True]
['text':' shift all the blocks by one ','line_number':506,'multiline':True]
['text':' grow the array ','line_number':518,'multiline':True]
['text':' result = result * 10 ','line_number':525,'multiline':True]
['text':' multiply all the blocks ','line_number':529,'multiline':True]
['text':' grow the array ','line_number':541,'multiline':True]
['text':' 10 ^ 0 ','line_number':550,'multiline':True]
['text':' 10 ^ 1 ','line_number':551,'multiline':True]
['text':' 10 ^ 2 ','line_number':552,'multiline':True]
['text':' 10 ^ 3 ','line_number':553,'multiline':True]
['text':' 10 ^ 4 ','line_number':554,'multiline':True]
['text':' 10 ^ 5 ','line_number':555,'multiline':True]
['text':' 10 ^ 6 ','line_number':556,'multiline':True]
['text':' 10 ^ 7 ','line_number':557,'multiline':True]
['text':'
 * Note: This has a lot of wasted space in the big integer structures of the
 *       early table entries. It wouldn't be terribly hard to make the multiply
 *       function work on integer pointers with an array length instead of
 *       the BigInt struct which would allow us to store a minimal amount of
 *       data here.
 ','line_number':560,'multiline':True]
['text':' 10 ^ 8 ','line_number':569,'multiline':True]
['text':' 10 ^ 16 ','line_number':571,'multiline':True]
['text':' 10 ^ 32 ','line_number':573,'multiline':True]
['text':' 10 ^ 64 ','line_number':575,'multiline':True]
['text':' 10 ^ 128 ','line_number':578,'multiline':True]
['text':' 10 ^ 256 ','line_number':582,'multiline':True]
['text':' 10 ^ 512 ','line_number':589,'multiline':True]
['text':' 10 ^ 1024 ','line_number':601,'multiline':True]
['text':' 10 ^ 2048 ','line_number':624,'multiline':True]
['text':' 10 ^ 4096 ','line_number':668,'multiline':True]
['text':' result = 10^exponent ','line_number':757,'multiline':True]
['text':' use two temporary values to reduce large integer copy operations ','line_number':761,'multiline':True]
['text':' make sure the exponent is within the bounds of the lookup table data ','line_number':767,'multiline':True]
['text':'
     * initialize the result by looking up a 32-bit power of 10 corresponding to
     * the first 3 bits
     ','line_number':770,'multiline':True]
['text':' remove the low bits that we used for the 32-bit lookup table ','line_number':777,'multiline':True]
['text':' while there are remaining bits in the exponent to be processed ','line_number':780,'multiline':True]
['text':' if the current bit is set, multiply by this power of 10 ','line_number':782,'multiline':True]
['text':' multiply into the next temporary ','line_number':786,'multiline':True]
['text':' swap to the next temporary ','line_number':789,'multiline':True]
['text':' advance to the next bit ','line_number':795,'multiline':True]
['text':' output the result ','line_number':800,'multiline':True]
['text':' in = in * 10^exponent ','line_number':806,'multiline':True]
['text':' use two temporary values to reduce large integer copy operations ','line_number':810,'multiline':True]
['text':' make sure the exponent is within the bounds of the lookup table data ','line_number':815,'multiline':True]
['text':'
     * initialize the result by looking up a 32-bit power of 10 corresponding to
     * the first 3 bits
     ','line_number':818,'multiline':True]
['text':' remove the low bits that we used for the 32-bit lookup table ','line_number':833,'multiline':True]
['text':' while there are remaining bits in the exponent to be processed ','line_number':836,'multiline':True]
['text':' if the current bit is set, multiply by this power of 10 ','line_number':838,'multiline':True]
['text':' multiply into the next temporary ','line_number':842,'multiline':True]
['text':' swap to the next temporary ','line_number':845,'multiline':True]
['text':' advance to the next bit ','line_number':851,'multiline':True]
['text':' output the result ','line_number':856,'multiline':True]
['text':' result = 2^exponent ','line_number':862,'multiline':True]
['text':'
 * This function will divide two large numbers under the assumption that the
 * result is within the range [0,10) and the input numbers have been shifted
 * to satisfy:
 * - The highest block of the divisor is greater than or equal to 8 such that
 *   there is enough precision to make an accurate first guess at the quotient.
 * - The highest block of the divisor is less than the maximum value on an
 *   unsigned 32-bit integer such that we can safely increment without overflow.
 * - The dividend does not contain more blocks than the divisor such that we
 *   can estimate the quotient by dividing the equivalently placed high blocks.
 *
 * quotient  = floor(dividend / divisor)
 * remainder = dividend - quotient*divisor
 *
 * dividend is updated to be the remainder and the quotient is returned.
 ','line_number':882,'multiline':True]
['text':'
     * Check that the divisor has been correctly shifted into range and that it
     * is not smaller than the dividend in length.
     ','line_number':905,'multiline':True]
['text':'
     * If the dividend is smaller than the divisor, the quotient is zero and the
     * divisor is already the remainder.
     ','line_number':914,'multiline':True]
['text':'
     * Compute an estimated quotient based on the high block value. This will
     * either match the actual quotient or undershoot by one.
     ','line_number':926,'multiline':True]
['text':' Divide out the estimated quotient ','line_number':933,'multiline':True]
['text':' dividend = dividend - divisor*quotient ','line_number':935,'multiline':True]
['text':' remove all leading zero blocks from dividend ','line_number':957,'multiline':True]
['text':'
     * If the dividend is still larger than the divisor, we overshot our
     * estimate quotient. To correct, we increment the quotient and subtract one
     * more divisor from the dividend.
     ','line_number':965,'multiline':True]
['text':' dividend = dividend - divisor ','line_number':971,'multiline':True]
['text':' remove all leading zero blocks from dividend ','line_number':989,'multiline':True]
['text':' result = result << shift ','line_number':1000,'multiline':True]
['text':' process blocks high to low so that we can safely process in place ','line_number':1007,'multiline':True]
['text':' check if the shift is block aligned ','line_number':1015,'multiline':True]
['text':' copy blocks from high to low ','line_number':1019,'multiline':True]
['text':' zero the remaining low blocks ','line_number':1027,'multiline':True]
['text':' else we need to shift partial blocks ','line_number':1034,'multiline':True]
['text':' output the initial blocks ','line_number':1040,'multiline':True]
['text':' set the length to hold the shifted blocks ','line_number':1046,'multiline':True]
['text':' output the final blocks ','line_number':1061,'multiline':True]
['text':' zero the remaining low blocks ','line_number':1066,'multiline':True]
['text':' check if the terminating block has no set bits ','line_number':1071,'multiline':True]
['text':'
 * This is an implementation the Dragon4 algorithm to convert a binary number in
 * floating point format to a decimal number in string format. The function
 * returns the number of digits written to the output buffer and the output is
 * not NUL terminated.
 *
 * The floating point input value is (mantissa * 2^exponent).
 *
 * See the following papers for more information on the algorithm:
 *  "How to Print Floating-Point Numbers Accurately"
 *    Steele and White
 *    https://kurtstephens.com/files/p372-steele.pdf
 *  "Printing Floating-Point Numbers Quickly and Accurately"
 *    Burger and Dybvig
 *    https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.4656
 *
 * This implementation is essentially a port of the "Figure 3" Scheme code from
 * Burger and Dybvig, but with the following additional differences:
 *   1. Instead of finding the highest k such that high < B**k, we search
 *      for the one where v < B**k. This has a downside that if a power
 *      of 10 exists between v and high, we will output a 9 instead of a 1 as
 *      first digit, violating the "no-carry" guarantee of the paper. This is
 *      accounted for in a new post-processing loop which implements a carry
 *      operation. The upside is one less BigInt multiplication.
 *   2. The approximate value of k found is offset by a different amount
 *      (0.69), in order to hit the "fast" branch more often. This is
 *      extensively described on Ryan Juckett's website.
 *   3. The fixed precision mode is much simpler than proposed in the paper.
 *      It simply outputs digits by repeatedly dividing by 10. The new "carry"
 *      loop at the end rounds this output nicely.
 *  There is also some new code to account for details of the BigInt
 *  implementation, which are not present in the paper since it does not specify
 *  details of the integer calculations.
 *
 * There is some more documentation of these changes on Ryan Juckett's website
 * at https://www.ryanjuckett.com/printing-floating-point-numbers/
 *
 * This code also has a few implementation differences from Ryan Juckett's
 * version:
 *  1. fixed overflow problems when mantissa was 64 bits (in float128 types),
 *     by replacing multiplication by 2 or 4 by BigInt_ShiftLeft calls.
 *  2. Increased c_BigInt_MaxBlocks, for 128-bit floats
 *  3. Added more entries to the g_PowerOf10_Big table, for 128-bit floats.
 *  4. Added unbiased rounding calculation with isEven. Ryan Juckett's
 *     implementation did not implement "IEEE unbiased rounding", except in the
 *     last digit. This has been added back, following the Burger & Dybvig
 *     code, using the isEven variable.
 *
 * Arguments:
 *   * bigints - memory to store all bigints needed (7) for dragon4 computation.
 *               The first BigInt should be filled in with the mantissa.
 *   * exponent - value exponent in base 2
 *   * mantissaBit - index of the highest set mantissa bit
 *   * hasUnequalMargins - is the high margin twice as large as the low margin
 *   * cutoffMode - how to interpret cutoff_*: fractional or total digits?
 *   * cutoff_max - cut off printing after this many digits. -1 for no cutoff
 *   * cutoff_min - print at least this many digits. -1 for no cutoff
 *   * pOutBuffer - buffer to output into
 *   * bufferSize - maximum characters that can be printed to pOutBuffer
 *   * pOutExponent - the base 10 exponent of the first digit
 *
 * Returns the number of digits written to the output buffer.
 ','line_number':1079,'multiline':True]
['text':'
     * We compute values in integer format by rescaling as
     *   mantissa = scaledValue / scale
     *   marginLow = scaledMarginLow / scale
     *   marginHigh = scaledMarginHigh / scale
     * Here, marginLow and marginHigh represent 1/2 of the distance to the next
     * floating point value above/below the mantissa.
     *
     * scaledMarginHigh will point to scaledMarginLow in the case they must be
     * equal to each other, otherwise it will point to optionalMarginHigh.
     ','line_number':1151,'multiline':True]
['text':' the only initialized bigint ','line_number':1162,'multiline':True]
['text':' current digit being output ','line_number':1175,'multiline':True]
['text':' values used to determine how to round ','line_number':1180,'multiline':True]
['text':' if the mantissa is zero, the value is zero regardless of the exponent ','line_number':1185,'multiline':True]
['text':' if we have no fractional component ','line_number':1195,'multiline':True]
['text':'
             * 1) Expand the input value by multiplying out the mantissa and
             *    exponent. This represents the input value in its whole number
             *    representation.
             * 2) Apply an additional scale of 2 such that later comparisons
             *    against the margin values are simplified.
             * 3) Set the margin value to the lowest mantissa bit's scale.
             ','line_number':1197,'multiline':True]
['text':' scaledValue      = 2 * 2 * mantissa*2^exponent ','line_number':1206,'multiline':True]
['text':' scale            = 2 * 2 * 1 ','line_number':1208,'multiline':True]
['text':' scaledMarginLow  = 2 * 2^(exponent-1) ','line_number':1210,'multiline':True]
['text':' scaledMarginHigh = 2 * 2 * 2^(exponent-1) ','line_number':1212,'multiline':True]
['text':' else we have a fractional exponent ','line_number':1215,'multiline':True]
['text':'
             * In order to track the mantissa data as an integer, we store it as
             * is with a large scale
             ','line_number':1217,'multiline':True]
['text':' scaledValue      = 2 * 2 * mantissa ','line_number':1222,'multiline':True]
['text':' scale            = 2 * 2 * 2^(-exponent) ','line_number':1224,'multiline':True]
['text':' scaledMarginLow  = 2 * 2^(-1) ','line_number':1226,'multiline':True]
['text':' scaledMarginHigh = 2 * 2 * 2^(-1) ','line_number':1228,'multiline':True]
['text':' the high and low margins are different ','line_number':1232,'multiline':True]
['text':' if we have no fractional component ','line_number':1236,'multiline':True]
['text':' scaledValue     = 2 * mantissa*2^exponent ','line_number':1238,'multiline':True]
['text':' scale           = 2 * 1 ','line_number':1240,'multiline':True]
['text':' scaledMarginLow = 2 * 2^(exponent-1) ','line_number':1242,'multiline':True]
['text':' else we have a fractional exponent ','line_number':1245,'multiline':True]
['text':'
             * In order to track the mantissa data as an integer, we store it as
             * is with a large scale
             ','line_number':1247,'multiline':True]
['text':' scaledValue     = 2 * mantissa ','line_number':1252,'multiline':True]
['text':' scale           = 2 * 2^(-exponent) ','line_number':1254,'multiline':True]
['text':' scaledMarginLow = 2 * 2^(-1) ','line_number':1256,'multiline':True]
['text':' the high and low margins are equal ','line_number':1260,'multiline':True]
['text':'
     * Compute an estimate for digitExponent that will be correct or undershoot
     * by one.  This optimization is based on the paper "Printing Floating-Point
     * Numbers Quickly and Accurately" by Burger and Dybvig
     * https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.72.4656
     * We perform an additional subtraction of 0.69 to increase the frequency of
     * a failed estimate because that lets us take a faster branch in the code.
     * 0.69 is chosen because 0.69 + log10(2) is less than one by a reasonable
     * epsilon that will account for any floating point error.
     *
     * We want to set digitExponent to floor(log10(v)) + 1
     *  v = mantissa*2^exponent
     *  log2(v) = log2(mantissa) + exponent;
     *  log10(v) = log2(v) * log10(2)
     *  floor(log2(v)) = mantissaBit + exponent;
     *  log10(v) - log10(2) < (mantissaBit + exponent) * log10(2) <= log10(v)
     *  log10(v) < (mantissaBit + exponent) * log10(2) + log10(2)
     *                                                 <= log10(v) + log10(2)
     *  floor(log10(v)) < ceil((mantissaBit + exponent) * log10(2))
     *                                                 <= floor(log10(v)) + 1
     *
     *  Warning: This calculation assumes npy_float64 is an IEEE-binary64
     *  float. This line may need to be updated if this is not the case.
     ','line_number':1264,'multiline':True]
['text':'
     * if the digit exponent is smaller than the smallest desired digit for
     * fractional cutoff, pull the digit back into legal range at which point we
     * will round to the appropriate value.  Note that while our value for
     * digitExponent is still an estimate, this is safe because it only
     * increases the number. This will either correct digitExponent to an
     * accurate value or it will clamp it above the accurate value.
     ','line_number':1291,'multiline':True]
['text':' Divide value by 10^digitExponent. ','line_number':1305,'multiline':True]
['text':' A positive exponent creates a division so we multiply the scale. ','line_number':1307,'multiline':True]
['text':'
         * A negative exponent creates a multiplication so we multiply up the
         * scaledValue, scaledMarginLow and scaledMarginHigh.
         ','line_number':1311,'multiline':True]
['text':' If (value >= 1), our estimate for digitExponent was too low ','line_number':1329,'multiline':True]
['text':'
         * The exponent estimate was incorrect.
         * Increment the exponent and don't perform the premultiply needed
         * for the first loop iteration.
         ','line_number':1331,'multiline':True]
['text':'
         * The exponent estimate was correct.
         * Multiply larger by the output base to prepare for the first loop
         * iteration.
         ','line_number':1339,'multiline':True]
['text':'
     * Compute the cutoff_max exponent (the exponent of the final digit to
     * print).  Default to the maximum size of the output buffer.
     ','line_number':1351,'multiline':True]
['text':' Otherwise it's CutoffMode_FractionLength. Print cutoff_max digits
         * past the decimal point or until we reach the buffer size
         ','line_number':1365,'multiline':True]
['text':' Also compute the cutoff_min exponent. ','line_number':1375,'multiline':True]
['text':' Output the exponent of the first digit we will print ','line_number':1394,'multiline':True]
['text':'
     * In preparation for calling BigInt_DivideWithRemainder_MaxQuotient9(), we
     * need to scale up our values such that the highest block of the
     * denominator is greater than or equal to 8. We also need to guarantee that
     * the numerator can never have a length greater than the denominator after
     * each loop iteration.  This requires the highest block of the denominator
     * to be less than or equal to 429496729 which is the highest number that
     * can be multiplied by 10 without overflowing to a new block.
     ','line_number':1397,'multiline':True]
['text':'
         * Perform a bit shift on all values to get the highest block of the
         * denominator into the range [8,429496729]. We are more likely to make
         * accurate quotient estimations in
         * BigInt_DivideWithRemainder_MaxQuotient9() with higher denominator
         * values so we shift the denominator to place the highest bit at index
         * 27 of the highest block.  This is safe because (2^28 - 1) = 268435455
         * which is less than 429496729. This means that all values with a
         * highest bit at index 27 are within range.
         ','line_number':1411,'multiline':True]
['text':'
         * For the unique cutoff mode, we will try to print until we have
         * reached a level of precision that uniquely distinguishes this value
         * from its neighbors. If we run out of space in the output buffer, we
         * terminate early.
         ','line_number':1434,'multiline':True]
['text':' divide out the scale to extract the digit ','line_number':1445,'multiline':True]
['text':' update the high end of the value ','line_number':1450,'multiline':True]
['text':'
             * stop looping if we are far enough away from our neighboring
             * values (and we have printed at least the requested minimum
             * digits) or if we have reached the cutoff digit
             ','line_number':1453,'multiline':True]
['text':' store the output digit ','line_number':1467,'multiline':True]
['text':' multiply larger by the output base ','line_number':1471,'multiline':True]
['text':'
         * For exact digit mode, we will try to print until we
         * have exhausted all precision (i.e. all remaining digits are zeros) or
         * until we reach the desired cutoff digit.
         ','line_number':1480,'multiline':True]
['text':' divide out the scale to extract the digit ','line_number':1491,'multiline':True]
['text':' store the output digit ','line_number':1501,'multiline':True]
['text':' multiply larger by the output base ','line_number':1505,'multiline':True]
['text':' default to rounding down the final digit if value got too close to 0 ','line_number':1510,'multiline':True]
['text':' if it is legal to round up and down ','line_number':1513,'multiline':True]
['text':'
         * round to the closest digit by comparing value with 0.5. To do this we
         * need to convert the inequality to large integer values.
         *  compare( value, 0.5 )
         *  compare( scale * value, scale * 0.5 )
         *  compare( 2 * scale * value, scale )
         ','line_number':1517,'multiline':True]
['text':'
         * if we are directly in the middle, round towards the even digit (i.e.
         * IEEE rounding rules)
         ','line_number':1528,'multiline':True]
['text':' print the rounded digit ','line_number':1537,'multiline':True]
['text':' handle rounding up ','line_number':1543,'multiline':True]
['text':' find the first non-nine prior digit ','line_number':1545,'multiline':True]
['text':' if we are at the first digit ','line_number':1547,'multiline':True]
['text':' output 1 at the next highest exponent ','line_number':1549,'multiline':True]
['text':' increment the digit ','line_number':1558,'multiline':True]
['text':' values in the range [0,8] can perform a simple round up ','line_number':1566,'multiline':True]
['text':' return the number of digits output ','line_number':1572,'multiline':True]
['text':'
 * The FormatPositional and FormatScientific functions have been more
 * significantly rewritten relative to Ryan Juckett's code.
 *
 * The binary16 and the various 128-bit float functions are new, and adapted
 * from the 64 bit version. The python interface functions are new.
 ','line_number':1579,'multiline':True]
['text':' Options struct for easy passing of Dragon4 options.
 *
 *   scientific - boolean controlling whether scientific notation is used
 *   digit_mode - whether to use unique or fixed fractional output
 *   cutoff_mode - whether 'precision' refers to all digits, or digits past
 *                 the decimal point.
 *   precision - When negative, prints as many digits as needed for a unique
 *               number. When positive specifies the maximum number of
 *               significant digits to print.
 *   sign - whether to always show sign
 *   trim_mode - how to treat trailing 0s and '.'. See TrimMode comments.
 *   digits_left - pad characters to left of decimal point. -1 for no padding
 *   digits_right - pad characters to right of decimal point. -1 for no padding.
 *                  Padding adds whitespace until there are the specified
 *                  number characters to sides of decimal point. Applies after
 *                  trim_mode characters were removed. If digits_right is
 *                  positive and the decimal point was trimmed, decimal point
 *                  will be replaced by a whitespace character.
 *   exp_digits - Only affects scientific output. If positive, pads the
 *                exponent with 0s until there are this many digits. If
 *                negative, only use sufficient digits.
 ','line_number':1588,'multiline':True]
['text':'
 * Outputs the positive number with positional notation: ddddd.dddd
 * The output is always NUL terminated and the output length (not including the
 * NUL) is returned.
 *
 * Arguments:
 *    buffer - buffer to output into
 *    bufferSize - maximum characters that can be printed to buffer
 *    mantissa - value significand
 *    exponent - value exponent in base 2
 *    signbit - value of the sign position. Should be '+', '-' or ''
 *    mantissaBit - index of the highest set mantissa bit
 *    hasUnequalMargins - is the high margin twice as large as the low margin
 *
 * See Dragon4_Options for description of remaining arguments.
 ','line_number':1623,'multiline':True]
['text':' track the # of digits past the decimal point that have been printed ','line_number':1653,'multiline':True]
['text':' if output has a whole number ','line_number':1679,'multiline':True]
['text':' leave the whole number at the start of the buffer ','line_number':1681,'multiline':True]
['text':' don't overflow the buffer ','line_number':1687,'multiline':True]
['text':' add trailing zeros up to the decimal point ','line_number':1692,'multiline':True]
['text':' insert the decimal point prior to the fraction ','line_number':1698,'multiline':True]
['text':' shift out the fraction to make room for the leading zeros ','line_number':1717,'multiline':True]
['text':'
             * shift the significant digits right such that there is room for
             * leading zeros
             ','line_number':1730,'multiline':True]
['text':' insert the leading zeros ','line_number':1743,'multiline':True]
['text':' update the counts ','line_number':1748,'multiline':True]
['text':' add the decimal point ','line_number':1753,'multiline':True]
['text':' add the initial zero ','line_number':1758,'multiline':True]
['text':' always add decimal point, except for DprZeros mode ','line_number':1767,'multiline':True]
['text':' if we didn't print any fractional digits, add a trailing 0 ','line_number':1780,'multiline':True]
['text':' add trailing zeros up to add_digits length ','line_number':1789,'multiline':True]
['text':' compute the number of trailing zeros needed ','line_number':1790,'multiline':True]
['text':' else, for trim_mode Zeros or DptZeros, there is nothing more to add ','line_number':1801,'multiline':True]
['text':'
     * when rounding, we may still end up with trailing zeros. Remove them
     * depending on trim settings.
     ','line_number':1803,'multiline':True]
['text':' in TrimMode_LeaveOneZero, add trailing 0 back ','line_number':1813,'multiline':True]
['text':' in TrimMode_DptZeros, remove trailing decimal point ','line_number':1818,'multiline':True]
['text':' add any whitespace padding to right side ','line_number':1825,'multiline':True]
['text':' in trim_mode DptZeros, if right padding, add a space for the . ','line_number':1829,'multiline':True]
['text':' add any whitespace padding to left side ','line_number':1843,'multiline':True]
['text':' terminate the buffer ','line_number':1861,'multiline':True]
['text':'
 * Outputs the positive number with scientific notation: d.dddde[sign]ddd
 * The output is always NUL terminated and the output length (not including the
 * NUL) is returned.
 *
 * Arguments:
 *    buffer - buffer to output into
 *    bufferSize - maximum characters that can be printed to buffer
 *    mantissa - value significand
 *    exponent - value exponent in base 2
 *    signbit - value of the sign position. Should be '+', '-' or ''
 *    mantissaBit - index of the highest set mantissa bit
 *    hasUnequalMargins - is the high margin twice as large as the low margin
 *
 * See Dragon4_Options for description of remaining arguments.
 ','line_number':1868,'multiline':True]
['text':' add any whitespace padding to left side ','line_number':1906,'multiline':True]
['text':' keep the whole number as the first digit ','line_number':1937,'multiline':True]
['text':' insert the decimal point prior to the fractional number ','line_number':1943,'multiline':True]
['text':' always add decimal point, except for DprZeros mode ','line_number':1958,'multiline':True]
['text':' if we didn't print any fractional digits, add the 0 ','line_number':1969,'multiline':True]
['text':' add trailing zeros up to add_digits length ','line_number':1978,'multiline':True]
['text':' compute the number of trailing zeros needed ','line_number':1981,'multiline':True]
['text':' else, for trim_mode Zeros or DptZeros, there is nothing more to add ','line_number':1994,'multiline':True]
['text':'
     * when rounding, we may still end up with trailing zeros. Remove them
     * depending on trim settings.
     ','line_number':1996,'multiline':True]
['text':' print the exponent into a local buffer and copy into output buffer ','line_number':2016,'multiline':True]
['text':' get exp digits ','line_number':2040,'multiline':True]
['text':' count back over leading zeros ','line_number':2045,'multiline':True]
['text':' write remaining digits to tmp buf ','line_number':2049,'multiline':True]
['text':' copy the exponent buffer into the output ','line_number':2054,'multiline':True]
['text':'
 * Print a hexadecimal value with a given width.
 * The output string is always NUL terminated and the string length (not
 * including the NUL) is returned.
 ','line_number':2071,'multiline':True]
['text':'  Unused for now
static npy_uint32
PrintHex(char * buffer, npy_uint32 bufferSize, npy_uint64 value,
         npy_uint32 width)
{
    const char digits[] = "0123456789abcdef";
    char *pCurOut;

    DEBUG_ASSERT(bufferSize > 0);

    npy_uint32 maxPrintLen = bufferSize-1;
    if (width > maxPrintLen) {
        width = maxPrintLen;
    }

    pCurOut = buffer;
    while (width > 0) {
        --width;

        npy_uint8 digit = (npy_uint8)((value >> 4ull*(npy_uint64)width) & 0xF);
        *pCurOut = digits[digit];

        ++pCurOut;
    }

    *pCurOut = '\0';
    return pCurOut - buffer;
}
','line_number':2076,'multiline':True]
['text':'
 * Print special case values for infinities and NaNs.
 * The output string is always NUL terminated and the string length (not
 * including the NUL) is returned.
 ','line_number':2106,'multiline':True]
['text':' Check for infinity ','line_number':2120,'multiline':True]
['text':' only print sign for inf values (though nan can have a sign set) ','line_number':2124,'multiline':True]
['text':' copy and make sure the buffer is terminated ','line_number':2136,'multiline':True]
['text':' copy and make sure the buffer is terminated ','line_number':2143,'multiline':True]
['text':'
         *  For numpy we ignore unusual mantissa values for nan, but keep this
         *  code in case we change our mind later.
         *
         * // append HEX value
         * if (maxPrintLen > 3) {
         *     printLen += PrintHex(buffer+3, bufferSize-3, mantissa,
         *                          mantissaHexWidth);
         * }
         ','line_number':2148,'multiline':True]
['text':'
 * The functions below format a floating-point numbers stored in particular
 * formats,  as a decimal string.  The output string is always NUL terminated
 * and the string length (not including the NUL) is returned.
 *
 * For 16, 32 and 64 bit floats we assume they are the IEEE 754 type.
 * For 128 bit floats we account for different definitions.
 *
 * Arguments are:
 *   buffer - buffer to output into
 *   bufferSize - maximum characters that can be printed to buffer
 *   value - value to print
 *   opt - Dragon4 options, see above
 ','line_number':2163,'multiline':True]
['text':'
 * Helper function that takes Dragon4 parameters and options and
 * calls Dragon4.
 ','line_number':2178,'multiline':True]
['text':' format the value ','line_number':2187,'multiline':True]
['text':'
 * IEEE binary16 floating-point format
 *
 * sign:      1 bit
 * exponent:  5 bits
 * mantissa: 10 bits
 ','line_number':2204,'multiline':True]
['text':' deconstruct the floating point value ','line_number':2228,'multiline':True]
['text':' output the sign ','line_number':2233,'multiline':True]
['text':' if this is a special value ','line_number':2241,'multiline':True]
['text':' else this is a number ','line_number':2245,'multiline':True]
['text':' factor the value into its parts ','line_number':2247,'multiline':True]
['text':'
         * normalized
         * The floating point equation is:
         *  value = (1 + mantissa/2^10) * 2 ^ (exponent-15)
         * We convert the integer equation by factoring a 2^10 out of the
         * exponent
         *  value = (1 + mantissa/2^10) * 2^10 * 2 ^ (exponent-15-10)
         *  value = (2^10 + mantissa) * 2 ^ (exponent-15-10)
         * Because of the implied 1 in front of the mantissa we have 10 bits of
         * precision.
         *   m = (2^10 + mantissa)
         *   e = (exponent-15-10)
         ','line_number':2249,'multiline':True]
['text':'
         * denormalized
         * The floating point equation is:
         *  value = (mantissa/2^10) * 2 ^ (1-15)
         * We convert the integer equation by factoring a 2^23 out of the
         * exponent
         *  value = (mantissa/2^10) * 2^10 * 2 ^ (1-15-10)
         *  value = mantissa * 2 ^ (1-15-10)
         * We have up to 10 bits of precision.
         *   m = (mantissa)
         *   e = (1-15-10)
         ','line_number':2268,'multiline':True]
['text':'
 * IEEE binary32 floating-point format
 *
 * sign:      1 bit
 * exponent:  8 bits
 * mantissa: 23 bits
 ','line_number':2291,'multiline':True]
['text':' deconstruct the floating point value ','line_number':2320,'multiline':True]
['text':' output the sign ','line_number':2326,'multiline':True]
['text':' if this is a special value ','line_number':2334,'multiline':True]
['text':' else this is a number ','line_number':2338,'multiline':True]
['text':' factor the value into its parts ','line_number':2340,'multiline':True]
['text':'
         * normalized
         * The floating point equation is:
         *  value = (1 + mantissa/2^23) * 2 ^ (exponent-127)
         * We convert the integer equation by factoring a 2^23 out of the
         * exponent
         *  value = (1 + mantissa/2^23) * 2^23 * 2 ^ (exponent-127-23)
         *  value = (2^23 + mantissa) * 2 ^ (exponent-127-23)
         * Because of the implied 1 in front of the mantissa we have 24 bits of
         * precision.
         *   m = (2^23 + mantissa)
         *   e = (exponent-127-23)
         ','line_number':2342,'multiline':True]
['text':'
         * denormalized
         * The floating point equation is:
         *  value = (mantissa/2^23) * 2 ^ (1-127)
         * We convert the integer equation by factoring a 2^23 out of the
         * exponent
         *  value = (mantissa/2^23) * 2^23 * 2 ^ (1-127-23)
         *  value = mantissa * 2 ^ (1-127-23)
         * We have up to 23 bits of precision.
         *   m = (mantissa)
         *   e = (1-127-23)
         ','line_number':2361,'multiline':True]
['text':'
 * IEEE binary64 floating-point format
 *
 * sign:      1 bit
 * exponent: 11 bits
 * mantissa: 52 bits
 ','line_number':2384,'multiline':True]
['text':' deconstruct the floating point value ','line_number':2414,'multiline':True]
['text':' output the sign ','line_number':2420,'multiline':True]
['text':' if this is a special value ','line_number':2428,'multiline':True]
['text':' else this is a number ','line_number':2432,'multiline':True]
['text':' factor the value into its parts ','line_number':2434,'multiline':True]
['text':'
         * normal
         * The floating point equation is:
         *  value = (1 + mantissa/2^52) * 2 ^ (exponent-1023)
         * We convert the integer equation by factoring a 2^52 out of the
         * exponent
         *  value = (1 + mantissa/2^52) * 2^52 * 2 ^ (exponent-1023-52)
         *  value = (2^52 + mantissa) * 2 ^ (exponent-1023-52)
         * Because of the implied 1 in front of the mantissa we have 53 bits of
         * precision.
         *   m = (2^52 + mantissa)
         *   e = (exponent-1023+1-53)
         ','line_number':2436,'multiline':True]
['text':'
         * subnormal
         * The floating point equation is:
         *  value = (mantissa/2^52) * 2 ^ (1-1023)
         * We convert the integer equation by factoring a 2^52 out of the
         * exponent
         *  value = (mantissa/2^52) * 2^52 * 2 ^ (1-1023-52)
         *  value = mantissa * 2 ^ (1-1023-52)
         * We have up to 52 bits of precision.
         *   m = (mantissa)
         *   e = (1-1023-52)
         ','line_number':2455,'multiline':True]
['text':'
 * Since systems have different types of long doubles, and may not necessarily
 * have a 128-byte format we can use to pass values around, here we create
 * our own 128-bit storage type for convenience.
 ','line_number':2479,'multiline':True]
['text':'
 * Intel's 80-bit IEEE extended precision floating-point format
 *
 * "long doubles" with this format are stored as 96 or 128 bits, but
 * are equivalent to the 80 bit type with some zero padding on the high bits.
 * This method expects the user to pass in the value using a 128-bit
 * FloatVal128, so can support 80, 96, or 128 bit storage formats,
 * and is endian-independent.
 *
 * sign:      1 bit,  second u64
 * exponent: 15 bits, second u64
 * intbit     1 bit,  first u64
 * mantissa: 63 bits, first u64
 ','line_number':2492,'multiline':True]
['text':' deconstruct the floating point value (we ignore the intbit) ','line_number':2523,'multiline':True]
['text':' output the sign ','line_number':2528,'multiline':True]
['text':' if this is a special value ','line_number':2536,'multiline':True]
['text':'
         * Note: Technically there are other special extended values defined if
         * the intbit is 0, like Pseudo-Infinity, Pseudo-Nan, Quiet-NaN. We
         * ignore all of these since they are not generated on modern
         * processors. We treat Quiet-Nan as simply Nan.
         ','line_number':2538,'multiline':True]
['text':' else this is a number ','line_number':2546,'multiline':True]
['text':' factor the value into its parts ','line_number':2548,'multiline':True]
['text':'
         * normal
         * The floating point equation is:
         *  value = (1 + mantissa/2^63) * 2 ^ (exponent-16383)
         * We convert the integer equation by factoring a 2^63 out of the
         * exponent
         *  value = (1 + mantissa/2^63) * 2^63 * 2 ^ (exponent-16383-63)
         *  value = (2^63 + mantissa) * 2 ^ (exponent-16383-63)
         * Because of the implied 1 in front of the mantissa we have 64 bits of
         * precision.
         *   m = (2^63 + mantissa)
         *   e = (exponent-16383+1-64)
         ','line_number':2550,'multiline':True]
['text':'
         * subnormal
         * The floating point equation is:
         *  value = (mantissa/2^63) * 2 ^ (1-16383)
         * We convert the integer equation by factoring a 2^52 out of the
         * exponent
         *  value = (mantissa/2^63) * 2^52 * 2 ^ (1-16383-63)
         *  value = mantissa * 2 ^ (1-16383-63)
         * We have up to 63 bits of precision.
         *   m = (mantissa)
         *   e = (1-16383-63)
         ','line_number':2569,'multiline':True]
['text':' INTEL_EXTENDED group ','line_number':2593,'multiline':True]
['text':'
 * Intel's 80-bit IEEE extended precision format, 80-bit storage
 *
 * Note: It is not clear if a long double with 10-byte storage exists on any
 * system. But numpy defines NPY_FLOAT80, so if we come across it, assume it is
 * an Intel extended format.
 ','line_number':2597,'multiline':True]
['text':' Intel is little-endian ','line_number':2618,'multiline':True]
['text':' HAVE_LDOUBLE_INTEL_EXTENDED_10_BYTES_LE ','line_number':2624,'multiline':True]
['text':' Intel's 80-bit IEEE extended precision format, 96-bit storage ','line_number':2627,'multiline':True]
['text':' Intel is little-endian ','line_number':2642,'multiline':True]
['text':' HAVE_LDOUBLE_INTEL_EXTENDED_12_BYTES_LE ','line_number':2648,'multiline':True]
['text':' Motorola Big-endian equivalent of the Intel-extended 96 fp format ','line_number':2651,'multiline':True]
['text':' Motorola is big-endian ','line_number':2666,'multiline':True]
['text':' once again we assume the int has same endianness as the float ','line_number':2669,'multiline':True]
['text':' HAVE_LDOUBLE_MOTOROLA_EXTENDED_12_BYTES_BE ','line_number':2673,'multiline':True]
['text':' Intel's 80-bit IEEE extended precision format, 128-bit storage ','line_number':2688,'multiline':True]
['text':' Intel is little-endian ','line_number':2697,'multiline':True]
['text':' HAVE_LDOUBLE_INTEL_EXTENDED_16_BYTES_LE ','line_number':2703,'multiline':True]
['text':'
 * IEEE binary128 floating-point format
 *
 * sign:       1 bit
 * exponent:  15 bits
 * mantissa: 112 bits
 *
 * Currently binary128 format exists on only a few CPUs, such as on the POWER9
 * arch or aarch64. Because of this, this code has not been extensively tested.
 * I am not sure if the arch also supports uint128, and C does not seem to
 * support int128 literals. So we use uint64 to do manipulation.
 ','line_number':2706,'multiline':True]
['text':' output the sign ','line_number':2739,'multiline':True]
['text':' if this is a special value ','line_number':2747,'multiline':True]
['text':' else this is a number ','line_number':2752,'multiline':True]
['text':' factor the value into its parts ','line_number':2754,'multiline':True]
['text':'
         * normal
         * The floating point equation is:
         *  value = (1 + mantissa/2^112) * 2 ^ (exponent-16383)
         * We convert the integer equation by factoring a 2^112 out of the
         * exponent
         *  value = (1 + mantissa/2^112) * 2^112 * 2 ^ (exponent-16383-112)
         *  value = (2^112 + mantissa) * 2 ^ (exponent-16383-112)
         * Because of the implied 1 in front of the mantissa we have 112 bits of
         * precision.
         *   m = (2^112 + mantissa)
         *   e = (exponent-16383+1-112)
         *
         *   Adding 2^112 to the mantissa is the same as adding 2^48 to the hi
         *   64 bit part.
         ','line_number':2756,'multiline':True]
['text':' mantissa_lo is unchanged ','line_number':2773,'multiline':True]
['text':'
         * subnormal
         * The floating point equation is:
         *  value = (mantissa/2^112) * 2 ^ (1-16383)
         * We convert the integer equation by factoring a 2^112 out of the
         * exponent
         *  value = (mantissa/2^112) * 2^112 * 2 ^ (1-16383-112)
         *  value = mantissa * 2 ^ (1-16383-112)
         * We have up to 112 bits of precision.
         *   m = (mantissa)
         *   e = (1-16383-112)
         ','line_number':2780,'multiline':True]
['text':' HAVE_LDOUBLE_IEEE_QUAD_LE ','line_number':2816,'multiline':True]
['text':'
 * This function is untested, very few, if any, architectures implement
 * big endian IEEE binary128 floating point.
 ','line_number':2819,'multiline':True]
['text':' HAVE_LDOUBLE_IEEE_QUAD_BE ','line_number':2836,'multiline':True]
['text':' HAVE_LDOUBLE_IEEE_QUAD_LE | HAVE_LDOUBLE_IEEE_BE','line_number':2838,'multiline':True]
['text':'
 * IBM extended precision 128-bit floating-point format, aka IBM double-double
 *
 * IBM's double-double type is a pair of IEEE binary64 values, which you add
 * together to get a total value. The exponents are arranged so that the lower
 * double is about 2^52 times smaller than the high one, and the nearest
 * float64 value is simply the upper double, in which case the pair is
 * considered "normalized" (not to confuse with "normal" and "subnormal"
 * binary64 values). We assume normalized values. You can see the glibc's
 * printf on ppc does so too by constructing un-normalized values to get
 * strange behavior from the OS printf:
 *
 *     >>> from numpy._core._multiarray_tests import format_float_OSprintf_g
 *     >>> x = np.array([0.3,0.3], dtype='f8').view('f16')[0]
 *     >>> format_float_OSprintf_g(x, 2)
 *     0.30
 *     >>> format_float_OSprintf_g(2*x, 2)
 *     1.20
 *
 * If we don't assume normalization, x should really print as 0.6.
 *
 * For normalized values gcc assumes that the total mantissa is no
 * more than 106 bits (53+53), so we can drop bits from the second double which
 * would be pushed past 106 when left-shifting by its exponent, as happens
 * sometimes. (There has been debate about this, see
 * https://gcc.gnu.org/bugzilla/show_bug.cgi?format=multiple&id=70117,
 * https://sourceware.org/bugzilla/show_bug.cgi?id=22752 )
 *
 * Note: This function is for the IBM-double-double which is a pair of IEEE
 * binary64 floats, like on ppc64 systems. This is *not* the hexadecimal
 * IBM-double-double type, which is a pair of IBM hexadecimal64 floats.
 *
 * See also:
 * https://gcc.gnu.org/wiki/Ieee128PowerPCA
 * https://www.ibm.com/support/knowledgecenter/en/ssw_aix_71/com.ibm.aix.genprogc/128bit_long_double_floating-point_datatype.htm
 ','line_number':2842,'multiline':True]
['text':' The high part always comes before the low part, regardless of the
     * endianness of the system. ','line_number':2900,'multiline':True]
['text':' deconstruct the floating point values ','line_number':2906,'multiline':True]
['text':' output the sign using 1st float's sign ','line_number':2915,'multiline':True]
['text':' we only need to look at the first float for inf/nan ','line_number':2923,'multiline':True]
['text':' else this is a number ','line_number':2928,'multiline':True]
['text':' Factor the 1st value into its parts, see binary64 for comments. ','line_number':2930,'multiline':True]
['text':'
         * If the first number is a subnormal value, the 2nd has to be 0 for
         * the float128 to be normalized, so we can ignore it. In this case
         * the float128 only has the precision of a single binary64 value.
         ','line_number':2932,'multiline':True]
['text':'
         * Computing hasUnequalMargins and mantissaBit:
         * This is a little trickier than for IEEE formats.
         *
         * When both doubles are "normal" it is clearer since we can think of
         * it as an IEEE type with a 106 bit mantissa. This value can never
         * have "unequal" margins because of the implied 1 bit in the 2nd
         * value.  (unequal margins only happen when the mantissa has a value
         * like "10000000000...", all zeros except the implied bit at the
         * start, since the next lowest number has a different exponent).
         * mantissaBits will always be 52+53 in this case.
         *
         * If the 1st number is a very small normal, and the 2nd is subnormal
         * and not 2^52 times smaller, the number behaves like a subnormal
         * overall, where the upper number just adds some bits on the left.
         * Like usual subnormals, it has "equal" margins. The slightly tricky
         * thing is that the number of mantissaBits varies. It will be 52
         * (from lower double) plus a variable number depending on the upper
         * number's exponent. We recompute the number of bits in the shift
         * calculation below, because the shift will be equal to the number of
         * lost bits.
         *
         * We can get unequal margins only if the first value has all-0
         * mantissa (except implied bit), and the second value is exactly 0. As
         * a special exception the smallest normal value (smallest exponent, 0
         * mantissa) should have equal margins, since it is "next to" a
         * subnormal value.
         ','line_number':2949,'multiline':True]
['text':' factor the 2nd value into its parts ','line_number':2978,'multiline':True]
['text':' shift exp by one so that leading mantissa bit is still bit 53 ','line_number':2985,'multiline':True]
['text':'
         * The 2nd val's exponent might not be exactly 52 smaller than the 1st,
         * it can vary a little bit. So do some shifting of the low mantissa,
         * so that the total mantissa is equivalent to bits 53 to 0 of the
         * first double immediately followed by bits 53 to 0 of the second.
         ','line_number':2992,'multiline':True]
['text':' shift more than 64 is undefined behavior ','line_number':3000,'multiline':True]
['text':'
             * This only happens if the 2nd value is subnormal.
             * We expect that shift > -64, but check it anyway
             ','line_number':3004,'multiline':True]
['text':'
         * If the low double is a different sign from the high double,
         * rearrange so that the total mantissa is the sum of the two
         * mantissas, instead of a subtraction.
         * hi - lo  ->  (hi-1) + (1-lo),   where lo < 1
         ','line_number':3011,'multiline':True]
['text':'
         * Compute the number of bits if we are in the subnormal range.
         * The value "shift" happens to be exactly the number of lost bits.
         * Also, shift the bits so that the least significant bit is at
         * bit position 0, like a typical subnormal. After this exponent1
         * should always be 2^-1022
         ','line_number':3022,'multiline':True]
['text':'
         * set up the BigInt mantissa, by shifting the parts as needed
         * We can use | instead of + since the mantissas should not overlap
         ','line_number':3037,'multiline':True]
['text':' HAVE_LDOUBLE_IBM_DOUBLE_DOUBLE_LE | HAVE_LDOUBLE_IBM_DOUBLE_DOUBLE_BE ','line_number':3050,'multiline':True]
['text':' NPY_FLOAT128 ','line_number':3052,'multiline':True]
['text':'
 * Here we define two Dragon4 entry functions for each type. One of them
 * accepts the args in a Dragon4_Options struct for convenience, the
 * other enumerates only the necessary parameters.
 *
 * Use a very large string buffer in case anyone tries to output a large number.
 * 16384 should be enough to exactly print the integer part of any float128,
 * which goes up to about 10^4932. The Dragon4_scratch struct provides a string
 * buffer of this size.
 ','line_number':3055,'multiline':True]
