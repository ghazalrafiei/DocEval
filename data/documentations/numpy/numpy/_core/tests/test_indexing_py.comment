['text':' start as float.','line_number':48,'multiline':False]
['text':' stop as float.','line_number':54,'multiline':False]
['text':' step as float.','line_number':60,'multiline':False]
['text':' mixed.','line_number':66,'multiline':False]
['text':' should still get the DeprecationWarning if step = 0.','line_number':73,'multiline':False]
['text':' No non-scalar arrays.','line_number':77,'multiline':False]
['text':' `None` index adds newaxis','line_number':83,'multiline':False]
['text':' Empty tuple index creates a view','line_number':89,'multiline':False]
['text':' Indexes should be cast with same-kind and not safe, even if that','line_number':103,'multiline':False]
['text':' is somewhat unsafe. So test various different code paths.','line_number':104,'multiline':False]
['text':' Empty list index creates an empty array','line_number':123,'multiline':False]
['text':' with the same dtype (but with weird shape)','line_number':124,'multiline':False]
['text':' `a[...]` was `a` in numpy <1.9.','line_number':142,'multiline':False]
['text':' Slicing with ellipsis can skip an','line_number':145,'multiline':False]
['text':' arbitrary number of dimensions','line_number':146,'multiline':False]
['text':' Slicing with ellipsis always results','line_number':151,'multiline':False]
['text':' in an array, not a scalar','line_number':152,'multiline':False]
['text':' Assignment with `(Ellipsis,)` on 0-d arrays','line_number':155,'multiline':False]
['text':' Single integer index selects one row','line_number':161,'multiline':False]
['text':' Index out of bounds produces IndexError','line_number':169,'multiline':False]
['text':' Index overflow produces IndexError','line_number':171,'multiline':False]
['text':' Single boolean index','line_number':175,'multiline':False]
['text':' Indexing a 2-dimensional array with','line_number':198,'multiline':False]
['text':' boolean array of length one','line_number':199,'multiline':False]
['text':' boolean assignment','line_number':203,'multiline':False]
['text':' A boolean assignment should fail when the shape of the values','line_number':208,'multiline':False]
['text':' cannot be broadcast to the subscription. (see also gh-3458)','line_number':209,'multiline':False]
['text':' See also gh-7666','line_number':220,'multiline':False]
['text':' This caused a segfault on Python 2 due to the GIL not being','line_number':221,'multiline':False]
['text':' held when the iterator does not need it, but the transfer function','line_number':222,'multiline':False]
['text':' does','line_number':223,'multiline':False]
['text':' Indexing a 2-dimensional array with','line_number':234,'multiline':False]
['text':' 2-dimensional boolean array','line_number':235,'multiline':False]
['text':' boolean assignment','line_number':246,'multiline':False]
['text':' Regression test for #13715. It's a use-after-free bug which the','line_number':253,'multiline':False]
['text':' test won't directly catch, but it will show up in valgrind.','line_number':254,'multiline':False]
['text':' Two variants of the test because the first takes a fast path','line_number':257,'multiline':False]
['text':' This tests that the strides are not reversed for simple and','line_number':262,'multiline':False]
['text':' subspace fancy indexing.','line_number':263,'multiline':False]
['text':' If the strides are not reversed, the 0 in the arange comes last.','line_number':269,'multiline':False]
['text':' This also tests that the subspace buffer is initialized:','line_number':272,'multiline':False]
['text':' Test a bug when calculating the output strides for a result array','line_number':279,'multiline':False]
['text':' when the subspace size was 1 (and test other cases as well)','line_number':280,'multiline':False]
['text':' During development there was a bug activating a skip logic','line_number':288,'multiline':False]
['text':' based on ndim instead of size.','line_number':289,'multiline':False]
['text':' Just documents behaviour, this is a small limitation.','line_number':299,'multiline':False]
['text':' 64 is NPY_MAXDIMS','line_number':300,'multiline':False]
['text':' NumPy bools can be used as boolean index (python ones as of yet not)','line_number':304,'multiline':False]
['text':' After deprecating bools as integers:','line_number':309,'multiline':False]
['text':'a = np.array([0,1,2])','line_number':310,'multiline':False]
['text':'assert_equal(a[True, :], a[None, :])','line_number':311,'multiline':False]
['text':'assert_equal(a[:, True], a[:, None])','line_number':312,'multiline':False]
['text':'','line_number':313,'multiline':False]
['text':'assert_(not np.may_share_memory(a, a[True, :]))','line_number':314,'multiline':False]
['text':' Before `...` would return a itself.','line_number':317,'multiline':False]
['text':' Test that the fast path for trivial assignment is not incorrectly','line_number':341,'multiline':False]
['text':' used when the index is not contiguous or 1D, see also gh-11467.','line_number':342,'multiline':False]
['text':' this case must not go into the fast path, note that idx is','line_number':347,'multiline':False]
['text':' a non-contiuguous none 1D array here.','line_number':348,'multiline':False]
['text':' Have array finalize do funny things','line_number':358,'multiline':False]
['text':' Subspace is last, so transposing might want to finalize','line_number':368,'multiline':False]
['text':' Similar to the above test, but use a memoryview instead','line_number':377,'multiline':False]
['text':' This is not necessary to preserve. Memory layouts for','line_number':401,'multiline':False]
['text':' more complex indices are not as simple.','line_number':402,'multiline':False]
['text':' Takes a different implementation branch:','line_number':407,'multiline':False]
['text':' Full scalar indices should return scalars and object','line_number':412,'multiline':False]
['text':' arrays should not call PyArray_Return on their items','line_number':413,'multiline':False]
['text':' The most basic valid indexing','line_number':415,'multiline':False]
['text':' Simple array, should behave like the array','line_number':422,'multiline':False]
['text':' And object arrays do not call it too often:','line_number':434,'multiline':False]
['text':' Reference count of intp for index checks','line_number':446,'multiline':False]
['text':' item setting always checks indices in separate function:','line_number':450,'multiline':False]
['text':' unaligned source','line_number':464,'multiline':False]
['text':'trivial','line_number':469,'multiline':False]
['text':' nontrivial','line_number':472,'multiline':False]
['text':' unaligned index array','line_number':473,'multiline':False]
['text':' boolean','line_number':479,'multiline':False]
['text':' A tuple subclass should also be an nd-index','line_number':486,'multiline':False]
['text':' Unlike the non nd-index:','line_number':492,'multiline':False]
['text':' See gh-5063:','line_number':496,'multiline':False]
['text':' If we have an object which claims to be a sequence, but fails','line_number':497,'multiline':False]
['text':' on item getting, this should not be converted to an nd-index (tuple)','line_number':498,'multiline':False]
['text':' If this object happens to be a valid index otherwise, it should work','line_number':499,'multiline':False]
['text':' This object here is very dubious and probably bad though:','line_number':500,'multiline':False]
['text':' also test that field indexing does not segfault','line_number':514,'multiline':False]
['text':' for a similar reason, by indexing a structured array','line_number':515,'multiline':False]
['text':' See also gh-6221','line_number':520,'multiline':False]
['text':' the shapes used here come from the issue and create the correct','line_number':521,'multiline':False]
['text':' size for the iterator buffering size.','line_number':522,'multiline':False]
['text':' single advanced index case','line_number':528,'multiline':False]
['text':' higher dimensional advanced index','line_number':530,'multiline':False]
['text':' From gh-8264,','line_number':535,'multiline':False]
['text':' core dumps if negative strides are used in iteration','line_number':536,'multiline':False]
['text':' This is an example a function going through CopyObject which','line_number':545,'multiline':False]
['text':' used to have an untested special path for scalars','line_number':546,'multiline':False]
['text':' (the character special dtype case, should be deprecated probably)','line_number':547,'multiline':False]
['text':' must assign as a sequence','line_number':549,'multiline':False]
['text':' make sure not all were set to "a" for both','line_number':551,'multiline':False]
['text':' These are limitations based on the number of arguments we can process.','line_number':558,'multiline':False]
['text':' For `num=32` (and all boolean cases), the result is actually define;','line_number':559,'multiline':False]
['text':' but the use of NpyIter (NPY_MAXARGS) limits it for technical reasons.','line_number':560,'multiline':False]
['text':' Test that copyswap(n) used by integer array indexing is threadsafe','line_number':569,'multiline':False]
['text':' for structured datatypes, see gh-15387. This test can behave randomly.','line_number':570,'multiline':False]
['text':' Create a deeply nested dtype to make a failure more likely:','line_number':573,'multiline':False]
['text':' The array should be large enough to likely run into threading issues','line_number':577,'multiline':False]
['text':' Field access on an array should return an array, even if it','line_number':601,'multiline':False]
['text':' is 0-d.','line_number':602,'multiline':False]
['text':' Fancy with subspace with and without transpose','line_number':617,'multiline':False]
['text':' Fancy without subspace (with broadcasting)','line_number':620,'multiline':False]
['text':' Too large and not only ones.','line_number':628,'multiline':False]
['text':' will never broadcast below  ','line_number':649,'multiline':False]
['text':' We currently report without any spaces (could be changed)','line_number':652,'multiline':False]
['text':' Simple case of fancy index broadcasting of the index.','line_number':661,'multiline':False]
['text':' Test that indexing in various ways produces SubClass instances,','line_number':677,'multiline':False]
['text':' and that the base is set up correctly: the original subclass','line_number':678,'multiline':False]
['text':' instance for views, and a new ndarray for advanced/boolean indexing','line_number':679,'multiline':False]
['text':' where a copy was made (latter a regression test for gh-11983).','line_number':680,'multiline':False]
['text':' Test that fancy indexing on read-only SubClass does not make a','line_number':706,'multiline':False]
['text':' read-only copy (gh-14132)','line_number':707,'multiline':False]
['text':' Array finalize should be called on the filled array.','line_number':719,'multiline':False]
['text':' Setup the boolean index and float arrays.','line_number':741,'multiline':False]
['text':' Assigning float is fine.','line_number':747,'multiline':False]
['text':' Fancy indexing works, although we get a cast warning.','line_number':751,'multiline':False]
['text':' No complex part','line_number':754,'multiline':False]
['text':' Cast complex to float, throwing away the imaginary portion.','line_number':756,'multiline':False]
['text':' Check that the field and object special case using copyto is active.','line_number':763,'multiline':False]
['text':' The right hand side cannot be converted to an array here.','line_number':764,'multiline':False]
['text':' test same for subspace fancy indexing','line_number':771,'multiline':False]
['text':' Check that swapping of axes works.','line_number':776,'multiline':False]
['text':' There was a bug that made the later assignment throw a ValueError','line_number':777,'multiline':False]
['text':' do to an incorrectly transposed temporary right hand side (gh-5714)','line_number':778,'multiline':False]
['text':' Another test for the memory order of the subspace','line_number':783,'multiline':False]
['text':' Equivalent slicing assignment for comparison','line_number':785,'multiline':False]
['text':' Yes, normal slicing uses unsafe casting.','line_number':795,'multiline':False]
['text':' test the same for subspace fancy indexing','line_number':803,'multiline':False]
['text':' Boolean indices, up to 3-d for some special cases of eating up','line_number':836,'multiline':False]
['text':' dimensions, also need to test all False','line_number':837,'multiline':False]
['text':' Some slices:','line_number':841,'multiline':False]
['text':' Some Fancy indexes:','line_number':846,'multiline':False]
['text':' empty and can be broadcast','line_number':847,'multiline':False]
['text':' trigger too large array.','line_number':852,'multiline':False]
['text':' invalid datatype','line_number':853,'multiline':False]
['text':' Some simpler indices that still cover a bit more','line_number':854,'multiline':False]
['text':' Very simple ones to fill the rest:','line_number':857,'multiline':False]
['text':' if False, this is a fancy or boolean index','line_number':886,'multiline':False]
['text':' number of fancy/scalar indexes that are not consecutive','line_number':888,'multiline':False]
['text':' number of dimensions indexed by a "fancy" index','line_number':890,'multiline':False]
['text':' NOTE: This is a funny twist (and probably OK to change).','line_number':892,'multiline':False]
['text':' The boolean array has illegal indexes, but this is','line_number':893,'multiline':False]
['text':' allowed if the broadcast fancy-indices are 0-sized.','line_number':894,'multiline':False]
['text':' This variable is to catch that case.','line_number':895,'multiline':False]
['text':' We need to handle Ellipsis and make arrays from indices, also','line_number':898,'multiline':False]
['text':' check if this is fancy indexing (set no_copy).','line_number':899,'multiline':False]
['text':' define here mostly to replace all but first.','line_number':901,'multiline':False]
['text':' boolean indices can have higher dimensions','line_number':909,'multiline':False]
['text':' do not increment ndim counter','line_number':916,'multiline':False]
['text':' This could be open for changes in numpy.','line_number':922,'multiline':False]
['text':' numpy should maybe raise an error if casting to intp','line_number':923,'multiline':False]
['text':' is not safe. It rejects np.array([1., 2.]) but not','line_number':924,'multiline':False]
['text':' [1., 2.] as index (same for ie. np.take).','line_number':925,'multiline':False]
['text':' (Note the importance of empty lists if changing this here)','line_number':926,'multiline':False]
['text':' we can't take more dimensions then we have, not even for 0-d','line_number':941,'multiline':False]
['text':' arrays.  since a[()] makes sense, but not a[(),]. We will','line_number':942,'multiline':False]
['text':' raise an error later on, unless a broadcasting error occurs','line_number':943,'multiline':False]
['text':' first.','line_number':944,'multiline':False]
['text':' Well we have no indexes or one Ellipsis. This is legal.','line_number':948,'multiline':False]
['text':' convert to an index array','line_number':957,'multiline':False]
['text':' this is like taking a slice with one element from a new axis:','line_number':962,'multiline':False]
['text':' fill with 0s instead, and raise error later','line_number':975,'multiline':False]
['text':' concatenate axis into a single one:','line_number':977,'multiline':False]
['text':' This could be changed, a 0-d boolean index can','line_number':984,'multiline':False]
['text':' make sense (even outside the 0-d indexed array case)','line_number':985,'multiline':False]
['text':' Note that originally this is could be interpreted as','line_number':986,'multiline':False]
['text':' integer in the full integer special case.','line_number':987,'multiline':False]
['text':' If the index is a singleton, the bounds check is done','line_number':990,'multiline':False]
['text':' before the broadcasting. This used to be different in <1.9','line_number':991,'multiline':False]
['text':' The index is a scalar. This used to be two fold, but if','line_number':996,'multiline':False]
['text':' fancy indexing was active, the check was done later,','line_number':997,'multiline':False]
['text':' possibly after broadcasting it away (1.7. or earlier).','line_number':998,'multiline':False]
['text':' Now it is always done.','line_number':999,'multiline':False]
['text':' NOTE: There could still have been a 0-sized Ellipsis','line_number':1005,'multiline':False]
['text':' between them. Checked that with ellipsis_pos.','line_number':1006,'multiline':False]
['text':' We have a fancy index that is not after an existing one.','line_number':1009,'multiline':False]
['text':' NOTE: A 0-d array triggers this as well, while one may','line_number':1010,'multiline':False]
['text':' expect it to not trigger it, since a scalar would not be','line_number':1011,'multiline':False]
['text':' considered fancy indexing.','line_number':1012,'multiline':False]
['text':' We have to flush the fancy indexes left','line_number':1017,'multiline':False]
['text':' axis we are at','line_number':1033,'multiline':False]
['text':' and now we need to transpose arr:','line_number':1035,'multiline':False]
['text':' We only have one 'f' index now and arr is transposed accordingly.','line_number':1038,'multiline':False]
['text':' Now handle newaxis by reshaping...','line_number':1039,'multiline':False]
['text':' First of all, reshape arr to combine fancy axes into one:','line_number':1045,'multiline':False]
['text':' Check if broadcasting works','line_number':1052,'multiline':False]
['text':' unfortunately the indices might be out of bounds. So check','line_number':1054,'multiline':False]
['text':' that first, and use mode='wrap' then. However only if','line_number':1055,'multiline':False]
['text':' there are any indices...','line_number':1056,'multiline':False]
['text':' Work around for a crash or IndexError with 'wrap'','line_number':1067,'multiline':False]
['text':' in some 0-sized cases.','line_number':1068,'multiline':False]
['text':' This happens with 0-sized orig_slice (sometimes?)','line_number':1073,'multiline':False]
['text':' here it is a ValueError, but indexing gives a:','line_number':1074,'multiline':False]
['text':' Maybe never happens...','line_number':1080,'multiline':False]
['text':' too many dimensions, probably','line_number':1088,'multiline':False]
['text':' If we are here, we have a 1D array for take:','line_number':1093,'multiline':False]
['text':' Test item getting','line_number':1109,'multiline':False]
['text':' Check if we got a view, unless its a 0-sized or 0-d array.','line_number':1153,'multiline':False]
['text':' (then its not a view, and that does not matter)','line_number':1154,'multiline':False]
['text':' Check reference count of the original array','line_number':1157,'multiline':False]
['text':' refcount increases by one:','line_number':1160,'multiline':False]
['text':' Test non-broadcast setitem:','line_number':1165,'multiline':False]
['text':' nothing to compare here...','line_number':1169,'multiline':False]
['text':' change indexed_arr in-place to manipulate original:','line_number':1171,'multiline':False]
['text':' Use the fact that the array is originally an arange:','line_number':1175,'multiline':False]
['text':' NOTE: This is different from normal broadcasting, as','line_number':1184,'multiline':False]
['text':' arr[boolean_array] works like in a multi index. Which means','line_number':1185,'multiline':False]
['text':' it is aligned to the left. This is probably correct for','line_number':1186,'multiline':False]
['text':' consistency with arr[boolean_array,] also no broadcasting','line_number':1187,'multiline':False]
['text':' is done at all','line_number':1188,'multiline':False]
['text':' Automatically test combinations with complex indexes on 2nd (or 1st)','line_number':1197,'multiline':False]
['text':' spot and the simple ones in one other spot.','line_number':1198,'multiline':False]
['text':' This is so that np.array(True) is not accepted in a full integer','line_number':1200,'multiline':False]
['text':' index, when running the file separately.','line_number':1201,'multiline':False]
['text':' Check very simple item getting:','line_number':1217,'multiline':False]
['text':' Also check (simple cases of) too many indices:','line_number':1220,'multiline':False]
['text':' These should raise no errors.','line_number':1239,'multiline':False]
['text':' These should raise no errors.','line_number':1249,'multiline':False]
['text':' NumPy scalar sequence multiply should not work with non-integers','line_number':1270,'multiline':False]
['text':' following should be OK','line_number':1275,'multiline':False]
['text':' Using a boolean as integer argument/indexing is an error.','line_number':1287,'multiline':False]
['text':' Note that operator.index(np.array(True)) does not work, a boolean','line_number':1293,'multiline':False]
['text':' array is thus also deprecated, but not with the same message:','line_number':1294,'multiline':False]
['text':' Weird boolean indexing things','line_number':1300,'multiline':False]
['text':' These used to either give the wrong error, or incorrectly give no','line_number':1307,'multiline':False]
['text':' error.','line_number':1308,'multiline':False]
['text':' This used to incorrectly work (and give an array of shape (0,))','line_number':1311,'multiline':False]
['text':' This used to incorrectly give a ValueError: operands could not be broadcast together','line_number':1318,'multiline':False]
['text':' This is the same as it used to be. The above two should work like this.','line_number':1325,'multiline':False]
['text':' This used to give ValueError: non-broadcastable operand','line_number':1332,'multiline':False]
['text':' so no exception is expected. The raising is effectively tested above.','line_number':1346,'multiline':False]
['text':' The following is valid','line_number':1367,'multiline':False]
['text':' 0-d arrays don't work:','line_number':1386,'multiline':False]
['text':' Out of bound values:','line_number':1388,'multiline':False]
['text':' Deletion is impossible:','line_number':1402,'multiline':False]
['text':' 0-d arrays don't work:','line_number':1404,'multiline':False]
['text':' Out of bound values:','line_number':1406,'multiline':False]
