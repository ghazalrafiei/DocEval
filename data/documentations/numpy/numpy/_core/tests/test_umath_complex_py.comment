['text':' import the c-extension module directly since _arg is not exported via umath','line_number':6,'multiline':False]
['text':' TODO: branch cuts (use Pauli code)','line_number':12,'multiline':False]
['text':' TODO: conj 'symmetry'','line_number':13,'multiline':False]
['text':' TODO: FPU exceptions','line_number':14,'multiline':False]
['text':' At least on Windows the results of many complex functions are not conforming','line_number':16,'multiline':False]
['text':' to the C99 standard. See ticket 1574.','line_number':17,'multiline':False]
['text':' Ditto for Solaris (ticket 1642) and OS X on PowerPC.','line_number':18,'multiline':False]
['text':'FIXME: this will probably change when we require full C99 compatibility','line_number':19,'multiline':False]
['text':' TODO: replace with a check on whether platform-provided C99 funcs are used','line_number':23,'multiline':False]
['text':' TODO This can be xfail when the generator functions are got rid of.','line_number':26,'multiline':False]
['text':' C99: Section G 6.3.1','line_number':45,'multiline':False]
['text':' cexp(+-0 + 0i) is 1 + 0i','line_number':50,'multiline':False]
['text':' cexp(x + infi) is nan + nani for finite x and raises 'invalid' FPU','line_number':54,'multiline':False]
['text':' exception','line_number':55,'multiline':False]
['text':' cexp(inf + 0i) is inf + 0i','line_number':60,'multiline':False]
['text':' cexp(-inf + yi) is +0 * (cos(y) + i sin(y)) for finite y','line_number':63,'multiline':False]
['text':' cexp(inf + yi) is +inf * (cos(y) + i sin(y)) for finite y','line_number':67,'multiline':False]
['text':' cexp(-inf + inf i) is +-0 +- 0i (signs unspecified)','line_number':71,'multiline':False]
['text':' cexp(inf + inf i) is +-inf + NaNi and raised invalid FPU ex.','line_number':81,'multiline':False]
['text':' cexp(-inf + nan i) is +-0 +- 0i','line_number':91,'multiline':False]
['text':' cexp(inf + nan i) is +-inf + nan','line_number':101,'multiline':False]
['text':' cexp(nan + yi) is nan + nani for y != 0 (optional: raises invalid FPU','line_number':111,'multiline':False]
['text':' ex)','line_number':112,'multiline':False]
['text':' cexp(nan + nani) is nan + nani','line_number':119,'multiline':False]
['text':' TODO This can be xfail when the generator functions are got rid of.','line_number':122,'multiline':False]
['text':' XXX: most implementations get it wrong here (including glibc <= 2.10)','line_number':125,'multiline':False]
['text':' cexp(nan + 0i) is nan + 0i','line_number':126,'multiline':False]
['text':' From C99 std (Sec 6.3.2)','line_number':145,'multiline':False]
['text':' XXX: check exceptions raised','line_number':146,'multiline':False]
['text':' --- raise for invalid fails.','line_number':147,'multiline':False]
['text':' clog(-0 + i0) returns -inf + i pi and raises the 'divide-by-zero'','line_number':149,'multiline':False]
['text':' floating-point exception.','line_number':150,'multiline':False]
['text':' clog(+0 + i0) returns -inf + i0 and raises the 'divide-by-zero'','line_number':161,'multiline':False]
['text':' floating-point exception.','line_number':162,'multiline':False]
['text':' clog(x + i inf returns +inf + i pi /2, for finite x.','line_number':173,'multiline':False]
['text':' clog(x + iNaN) returns NaN + iNaN and optionally raises the','line_number':185,'multiline':False]
['text':' 'invalid' floating- point exception, for finite x.','line_number':186,'multiline':False]
['text':'assert_raises(FloatingPointError, np.log, x)','line_number':190,'multiline':False]
['text':'assert_raises(FloatingPointError, np.log, x)','line_number':199,'multiline':False]
['text':' clog(- inf + iy) returns +inf + ipi , for finite positive-signed y.','line_number':206,'multiline':False]
['text':' clog(+ inf + iy) returns +inf + i0, for finite positive-signed y.','line_number':213,'multiline':False]
['text':' clog(- inf + i inf) returns +inf + i3pi /4.','line_number':220,'multiline':False]
['text':' clog(+ inf + i inf) returns +inf + ipi /4.','line_number':227,'multiline':False]
['text':' clog(+/- inf + iNaN) returns +inf + iNaN.','line_number':234,'multiline':False]
['text':' clog(NaN + iy) returns NaN + iNaN and optionally raises the','line_number':246,'multiline':False]
['text':' 'invalid' floating-point exception, for finite y.','line_number':247,'multiline':False]
['text':' clog(NaN + i inf) returns +inf + iNaN.','line_number':254,'multiline':False]
['text':' clog(NaN + iNaN) returns NaN + iNaN.','line_number':261,'multiline':False]
['text':' clog(conj(z)) = conj(clog(z)).','line_number':268,'multiline':False]
['text':' sqrt(1)','line_number':279,'multiline':False]
['text':' sqrt(1i)','line_number':282,'multiline':False]
['text':' sqrt(-1)','line_number':287,'multiline':False]
['text':'def test_branch_cut(self):','line_number':298,'multiline':False]
['text':'    _check_branch_cut(f, -1, 0, 1, -1)','line_number':299,'multiline':False]
['text':' C99: Sec G 6.4.2','line_number':303,'multiline':False]
['text':' csqrt(+-0 + 0i) is 0 + 0i','line_number':308,'multiline':False]
['text':' csqrt(x + infi) is inf + infi for any x (including NaN)','line_number':312,'multiline':False]
['text':' csqrt(x + nani) is nan + nani for any finite x','line_number':322,'multiline':False]
['text':' csqrt(-inf + yi) is +0 + infi for any finite y > 0','line_number':327,'multiline':False]
['text':' csqrt(inf + yi) is +inf + 0i for any finite y > 0','line_number':330,'multiline':False]
['text':' csqrt(-inf + nani) is nan +- infi (both +i infi are valid)','line_number':333,'multiline':False]
['text':'Fixme: ugly workaround for isinf bug.','line_number':337,'multiline':False]
['text':' csqrt(+inf + nani) is inf + nani','line_number':344,'multiline':False]
['text':' csqrt(nan + yi) is nan + nani for any finite y (infinite handled in x','line_number':347,'multiline':False]
['text':' + nani)','line_number':348,'multiline':False]
['text':' XXX: check for conj(csqrt(z)) == csqrt(conj(z)) (need to fix branch','line_number':353,'multiline':False]
['text':' cuts first)','line_number':354,'multiline':False]
['text':' Hardcode the expected `builtins.complex` values,','line_number':374,'multiline':False]
['text':' as complex exponentiation is broken as of bpo-44698','line_number':375,'multiline':False]
['text':' Hardcode the expected `builtins.complex` values,','line_number':394,'multiline':False]
['text':' as complex exponentiation is broken as of bpo-44698','line_number':395,'multiline':False]
['text':' Test that np.abs(x +- 0j) == np.abs(x) (as mandated by C99 for cabs)','line_number':423,'multiline':False]
['text':' cabs(+-nan + nani) returns nan','line_number':439,'multiline':False]
['text':' According to C99 standard, if exactly one of the real/part is inf and','line_number':448,'multiline':False]
['text':' the other nan, then cabs should return inf','line_number':449,'multiline':False]
['text':' cabs(conj(z)) == conj(cabs(z)) (= cabs(z))','line_number':458,'multiline':False]
['text':' TODO This can be xfail when the generator functions are got rid of.','line_number':479,'multiline':False]
['text':' carg(-0 +- 0i) returns +- pi','line_number':483,'multiline':False]
['text':' carg(+0 +- 0i) returns +- 0','line_number':487,'multiline':False]
['text':' carg(x +- 0i) returns +- 0 for x > 0','line_number':491,'multiline':False]
['text':' carg(x +- 0i) returns +- pi for x < 0','line_number':495,'multiline':False]
['text':' carg(+- 0 + yi) returns pi/2 for y > 0','line_number':499,'multiline':False]
['text':' carg(+- 0 + yi) returns -pi/2 for y < 0','line_number':503,'multiline':False]
['text':'def test_branch_cuts(self):','line_number':507,'multiline':False]
['text':'    _check_branch_cut(ncu._arg, -1, 1j, -1, 1)','line_number':508,'multiline':False]
['text':' carg(-np.inf +- yi) returns +-pi for finite y > 0','line_number':511,'multiline':False]
['text':' carg(np.inf +- yi) returns +-0 for finite y > 0','line_number':515,'multiline':False]
['text':' carg(x +- np.infi) returns +-pi/2 for finite x','line_number':519,'multiline':False]
['text':' carg(-np.inf +- np.infi) returns +-3pi/4','line_number':523,'multiline':False]
['text':' carg(np.inf +- np.infi) returns +-pi/4','line_number':527,'multiline':False]
['text':' carg(x + yi) returns np.nan if x or y is nan','line_number':531,'multiline':False]
['text':' test to ensure masking and strides work as intended in the AVX implementation','line_number':587,'multiline':False]
['text':' Testcase taken as is from https://github.com/numpy/numpy/issues/16660','line_number':593,'multiline':False]
