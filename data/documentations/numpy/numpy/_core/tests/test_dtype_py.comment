['text':' Make sure equivalent byte order char hash the same (e.g. < and = on','line_number':44,'multiline':False]
['text':' little endian)','line_number':45,'multiline':False]
['text':' Make sure equivalent dtypes with different type num hash equal','line_number':57,'multiline':False]
['text':' Make sure invalid type strings raise an error','line_number':69,'multiline':False]
['text':' Make sure objects that cannot be converted to valid','line_number':100,'multiline':False]
['text':' dtypes results in False/True when compared to valid dtypes.','line_number':101,'multiline':False]
['text':' Here 7 cannot be converted to dtype. No exceptions should be raised','line_number':102,'multiline':False]
['text':' Make sure TypeError is raised for comparison operators','line_number':111,'multiline':False]
['text':' for invalid dtypes. Here 7 is an invalid dtype.','line_number':112,'multiline':False]
['text':' Empty bytes object','line_number':159,'multiline':False]
['text':' Byte order indicator, but no type','line_number':161,'multiline':False]
['text':' Single character with ordinal < NPY_NTYPES returns','line_number':164,'multiline':False]
['text':' type by index into _builtin_descrs','line_number':165,'multiline':False]
['text':' Single character where value is a valid type code','line_number':169,'multiline':False]
['text':' Bytes with non-ascii values raise errors','line_number':172,'multiline':False]
['text':' Can't give a size that's too small','line_number':177,'multiline':False]
['text':' If alignment is enabled, the alignment (4) must divide the itemsize','line_number':183,'multiline':False]
['text':' If alignment is enabled, the individual fields must be aligned','line_number':189,'multiline':False]
['text':' This is an safe cast (not equiv) due to the different names:','line_number':203,'multiline':False]
['text':' Code coverage for very large numbers:','line_number':224,'multiline':False]
['text':' In theory, they may hash the same (collision) ?','line_number':243,'multiline':False]
['text':' In theory, they may hash the same (collision) ?','line_number':249,'multiline':False]
['text':' Mutating a dtype should reset the cached hash value.','line_number':271,'multiline':False]
['text':' NOTE: Mutating should be deprecated, but new API added to replace it.','line_number':272,'multiline':False]
['text':' NOTE: Mutating should be deprecated, but new API added to replace it.','line_number':287,'multiline':False]
['text':' Check that structured dtypes get padded to an aligned size','line_number':306,'multiline':False]
['text':' Nesting should preserve that alignment','line_number':317,'multiline':False]
['text':' Nesting should preserve packing','line_number':334,'multiline':False]
['text':' Array of subtype should preserve alignment','line_number':351,'multiline':False]
['text':' Empty dtypes should have an alignment of 1','line_number':360,'multiline':False]
['text':' Should be able to create union dtypes','line_number':375,'multiline':False]
['text':' Should be able to specify fields out of order','line_number':383,'multiline':False]
['text':' field name should not matter: assignment is by position','line_number':387,'multiline':False]
['text':' Should not be able to overlap objects with other types','line_number':399,'multiline':False]
['text':' Out of order should still be ok, however','line_number':416,'multiline':False]
['text':' iterate the 1-d list to fill the array','line_number':432,'multiline':False]
['text':' Tests for PR #5920','line_number':446,'multiline':False]
['text':' Regression test for #6430 / #2196','line_number':453,'multiline':False]
['text':' raises?','line_number':463,'multiline':False]
['text':' gh-8059','line_number':469,'multiline':False]
['text':' no errors here:','line_number':479,'multiline':False]
['text':' indexing with a list produces subfields','line_number':497,'multiline':False]
['text':' the align flag should be preserved','line_number':498,'multiline':False]
['text':' 'names' is missing','line_number':548,'multiline':False]
['text':' See gh-23277, the dtype here thinks it contain objects, if the','line_number':578,'multiline':False]
['text':' assert about that fails, the test becomes meaningless (which is OK)','line_number':579,'multiline':False]
['text':' no fields','line_number':581,'multiline':False]
['text':' but claims to contain objects','line_number':582,'multiline':False]
['text':' the deletion failed previously.','line_number':583,'multiline':False]
['text':' FutureWarning during deprecation period; after it is passed this','line_number':618,'multiline':False]
['text':' should instead check that "(1)f8" == "1f8" == ("f8", 1).','line_number':619,'multiline':False]
['text':' Any sequence of integers should work as shape, but the result','line_number':649,'multiline':False]
['text':' should be a tuple (immutable) of base type integers.','line_number':650,'multiline':False]
['text':' Array gets converted','line_number':653,'multiline':False]
['text':' List gets converted','line_number':657,'multiline':False]
['text':'','line_number':660,'multiline':False]
['text':' (a PyNumber_Check fails without __int__)','line_number':667,'multiline':False]
['text':' Check that the shape is valid.','line_number':695,'multiline':False]
['text':' Too large values (the datatype is part of this)','line_number':698,'multiline':False]
['text':' Takes a different code path (fails earlier:','line_number':702,'multiline':False]
['text':' Negative values','line_number':704,'multiline':False]
['text':'Check that subarrays are aligned','line_number':709,'multiline':False]
['text':' Mainly regression test for gh-19696: construction failed completely','line_number':715,'multiline':False]
['text':' Extracting the field "absorbs" the subarray into a view:','line_number':723,'multiline':False]
['text':' Extract the structured item, and then check the tuple component:','line_number':725,'multiline':False]
['text':' Older versions of NumPy did NOT copy, but they got the ownership','line_number':731,'multiline':False]
['text':' wrong (not actually knowing the correct base!).  Versions since 1.21','line_number':732,'multiline':False]
['text':' (I think) crashed fairly reliable.  This defines the correct behavior','line_number':733,'multiline':False]
['text':' as a copy.  Keeping the ownership would be possible (but harder)','line_number':734,'multiline':False]
['text':' None is probably used for too many things','line_number':795,'multiline':False]
['text':' The test assumes that 0, 1, and None are singletons.','line_number':802,'multiline':False]
['text':' Fill with `1` and check that it was replaced correctly:','line_number':823,'multiline':False]
['text':' Use two small negative values (should be singletons, but less likely','line_number':844,'multiline':False]
['text':' to run into race-conditions).  This failed in some threaded envs','line_number':845,'multiline':False]
['text':' When using 0 and 1.  If it fails again, should remove all explicit','line_number':846,'multiline':False]
['text':' checks, and rely on `pytest-leaks` reference count checker only.','line_number':847,'multiline':False]
['text':' Test item getting:','line_number':856,'multiline':False]
['text':' Test item setting:','line_number':861,'multiline':False]
['text':' dtype is reduced when accessing the field, so shape is (3, 2, 3):','line_number':905,'multiline':False]
['text':' Fancy assignment goes to the copyswap function for complex types:','line_number':909,'multiline':False]
['text':' dtype is reduced when accessing the field, so shape is (3, 2, 3):','line_number':914,'multiline':False]
['text':' If the sticky aligned flag is set to True, it makes the','line_number':993,'multiline':False]
['text':' str() function use a dict representation with an 'aligned' flag','line_number':994,'multiline':False]
['text':' Issue gh-2798, should not error.','line_number':1113,'multiline':False]
['text':' Pull request #4722','line_number':1117,'multiline':False]
['text':' see gh-6359','line_number':1159,'multiline':False]
['text':' Ticket #4357','line_number':1169,'multiline':False]
['text':' a canonical DType should always have equivalent casting (both ways)','line_number':1192,'multiline':False]
['text':' a canonical dtype (and its fields) is always native (checks fields):','line_number':1195,'multiline':False]
['text':' Check that canonical of canonical is the same (no casting):','line_number':1198,'multiline':False]
['text':' The flags currently never change for unstructured dtypes','line_number':1202,'multiline':False]
['text':' Must have all the needs API flag set:','line_number':1206,'multiline':False]
['text':' Check that the fields are identical (including titles):','line_number':1209,'multiline':False]
['text':' round up offset:','line_number':1213,'multiline':False]
['text':' each field is also canonical:','line_number':1219,'multiline':False]
['text':' Must have the "inherited" object related flags:','line_number':1223,'multiline':False]
['text':' if a title exists, they must match (otherwise empty tuple):','line_number':1232,'multiline':False]
['text':' dtype with empty space:','line_number':1247,'multiline':False]
['text':' aligned struct dtype with empty space:','line_number':1253,'multiline':False]
['text':' The following dtype still indicates "object", because its included','line_number':1261,'multiline':False]
['text':' in the unaccessible space (maybe this could change at some point):','line_number':1262,'multiline':False]
['text':' result_type with two arguments should always give identical results:','line_number':1273,'multiline':False]
['text':' Pick 4 of the fields at random.  This will leave empty space in the','line_number':1283,'multiline':False]
['text':' dtype (since we do not canonicalize it here).','line_number':1284,'multiline':False]
['text':' promotion with two arguments should always give identical results:','line_number':1290,'multiline':False]
['text':' Ensure that we also check aligned struct (check the opposite, in','line_number':1295,'multiline':False]
['text':' case hypothesis grows support for `align`.  Then repeat the test:','line_number':1296,'multiline':False]
['text':' promotion with two arguments should always give identical results:','line_number':1302,'multiline':False]
['text':' The dtype pickling itself pickles `np.dtype` if it is pickled','line_number':1313,'multiline':False]
['text':' as a singleton `dtype` should be stored in the buffer:','line_number':1314,'multiline':False]
['text':' Check the reconstructed dtype is functional','line_number':1322,'multiline':False]
['text':' Check that DTypes (the classes/types) roundtrip when pickling','line_number':1377,'multiline':False]
['text':' Check that dtype instances roundtrip when pickling and that pickling','line_number':1386,'multiline':False]
['text':' doesn't change the hash value','line_number':1387,'multiline':False]
['text':' Base of the double value to sidestep any rounding issues:','line_number':1406,'multiline':False]
['text':' Additionally use "nextafter" so the cast can't round down:','line_number':1409,'multiline':False]
['text':' repeat for complex scalars:','line_number':1412,'multiline':False]
['text':' Base of the double value to sidestep any rounding issues:','line_number':1415,'multiline':False]
['text':' Additionally use "nextafter" so the cast can't round down:','line_number':1418,'multiline':False]
['text':' This would change if we modify the value based promotion','line_number':1427,'multiline':False]
['text':' Check the same for a simple ufunc call that uses the same logic:','line_number':1432,'multiline':False]
['text':' This would change if we modify the value based promotion','line_number':1448,'multiline':False]
['text':' Check the same for a simple ufunc call that uses the same logic:','line_number':1453,'multiline':False]
['text':' If we only pass scalars (mainly python ones!), NEP 50 means','line_number':1468,'multiline':False]
['text':' that we get the default integer','line_number':1469,'multiline':False]
['text':' the default integer','line_number':1470,'multiline':False]
['text':' With NEP 50, the NumPy scalar wins though:','line_number':1472,'multiline':False]
['text':' Note that rationals are a bit akward as they promote with float64','line_number':1480,'multiline':False]
['text':' or default ints, but not float16 or uint8/int8 (which looks','line_number':1481,'multiline':False]
['text':' inconsistent here).  The new promotion fixes this (partially?)','line_number':1482,'multiline':False]
['text':' The float version, checks float16 in the legacy path, which fails','line_number':1484,'multiline':False]
['text':' the integer version seems to check int8 (also), so it can','line_number':1485,'multiline':False]
['text':' pass.','line_number':1486,'multiline':False]
['text':' These promotions are not associative/commutative:','line_number':1496,'multiline':False]
['text':' The following promotions are not ambiguous, but cover code','line_number':1500,'multiline':False]
['text':' paths of abstract promotion (no particular logic being tested)','line_number':1501,'multiline':False]
['text':' Tests that most permutations do not influence the result.  In the','line_number':1511,'multiline':False]
['text':' above some uint and int combintations promote to a larger integer','line_number':1512,'multiline':False]
['text':' type, which would then promote to a larger than necessary float.','line_number':1513,'multiline':False]
['text':' test for bug gh-5719','line_number':1519,'multiline':False]
['text':' test that dtype detection finds user-defined types','line_number':1523,'multiline':False]
['text':' test for gh-6294','line_number':1529,'multiline':False]
['text':' test for gh-10440','line_number':1536,'multiline':False]
['text':' test for https://github.com/numpy/numpy/pull/16574#issuecomment-642660971','line_number':1542,'multiline':False]
['text':' This code path is fully untested before, so it is unclear','line_number':1570,'multiline':False]
['text':' what this should be useful for. Note that if np.void is used','line_number':1571,'multiline':False]
['text':' numpy will think we are deallocating a base type [1.17, 2019-02].','line_number':1572,'multiline':False]
['text':' Note: Except for the isinstance and type checks, these attributes','line_number':1595,'multiline':False]
['text':'       are considered currently private and may change.','line_number':1596,'multiline':False]
['text':' The scalar names has a `c` attached because "int" is Python','line_number':1603,'multiline':False]
['text':' int and that is long...','line_number':1604,'multiline':False]
['text':' the flexible dtypes and datetime/timedelta have additional parameters','line_number':1617,'multiline':False]
['text':' which are more than just storage information, these would need to be','line_number':1618,'multiline':False]
['text':' given when creating a dtype:','line_number':1619,'multiline':False]
['text':' gh-5645: check that np.dtype('i,L') can be used','line_number':1864,'multiline':False]
['text':' We cannot (currently) *create* this dtype with `np.dtype` because','line_number':1879,'multiline':False]
['text':' mytype does not inherit from `np.generic`.  This seems like an','line_number':1880,'multiline':False]
['text':' unnecessary restriction, but one that has been around forever:','line_number':1881,'multiline':False]
['text':' Tests what happens if fields are unset during creation','line_number':1891,'multiline':False]
['text':' which is currently rejected due to the containing object','line_number':1892,'multiline':False]
['text':' (see PyArray_RegisterDataType).','line_number':1893,'multiline':False]
['text':' Tests that a dtype must have its type field set up to np.dtype','line_number':1897,'multiline':False]
['text':' or in this case a builtin instance.','line_number':1898,'multiline':False]
['text':' Regression test for gh-20077.  The following call of `result_type`','line_number':1929,'multiline':False]
['text':' would cause a seg. fault.','line_number':1930,'multiline':False]
['text':' Regression test for #25031, calling `np.dtype` with itself segfaulted.','line_number':1937,'multiline':False]
