['text':' Make sure the iterator doesn't leak','line_number':40,'multiline':False]
['text':' Basic','line_number':42,'multiline':False]
['text':' del 'it'','line_number':54,'multiline':False]
['text':' With a copy','line_number':59,'multiline':False]
['text':' avoid pyflakes unused variable warning','line_number':79,'multiline':False]
['text':' The iterator should always find the iteration order','line_number':82,'multiline':False]
['text':' with increasing memory addresses','line_number':83,'multiline':False]
['text':' Test the ordering for 1-D to 5-D shapes','line_number':85,'multiline':False]
['text':' Test each combination of positive and negative strides','line_number':88,'multiline':False]
['text':' C-order','line_number':97,'multiline':False]
['text':' Fortran-order','line_number':100,'multiline':False]
['text':' Other order','line_number':103,'multiline':False]
['text':' Test forcing C order','line_number':109,'multiline':False]
['text':' Test the ordering for 1-D to 5-D shapes','line_number':111,'multiline':False]
['text':' Test each combination of positive and negative strides','line_number':114,'multiline':False]
['text':' C-order','line_number':123,'multiline':False]
['text':' Fortran-order','line_number':126,'multiline':False]
['text':' Other order','line_number':129,'multiline':False]
['text':' Test forcing F order','line_number':136,'multiline':False]
['text':' Test the ordering for 1-D to 5-D shapes','line_number':138,'multiline':False]
['text':' Test each combination of positive and negative strides','line_number':141,'multiline':False]
['text':' C-order','line_number':150,'multiline':False]
['text':' Fortran-order','line_number':153,'multiline':False]
['text':' Other order','line_number':156,'multiline':False]
['text':' Test forcing any contiguous (C or F) order','line_number':163,'multiline':False]
['text':' Test the ordering for 1-D to 5-D shapes','line_number':165,'multiline':False]
['text':' Test each combination of positive and negative strides','line_number':168,'multiline':False]
['text':' C-order','line_number':177,'multiline':False]
['text':' Fortran-order','line_number':180,'multiline':False]
['text':' Other order','line_number':183,'multiline':False]
['text':' Test the multi_index set','line_number':190,'multiline':False]
['text':' Removes the iteration on two first elements of a[0]','line_number':194,'multiline':False]
['text':' Test if the reference count on index variable is decreased','line_number':201,'multiline':False]
['text':' The multi-indices should be correct with any reordering','line_number':213,'multiline':False]
['text':' 1D order','line_number':216,'multiline':False]
['text':' 1D reversed order','line_number':219,'multiline':False]
['text':' The multi-indices should be correct with any reordering','line_number':224,'multiline':False]
['text':' 2D C-order','line_number':227,'multiline':False]
['text':' 2D Fortran-order','line_number':230,'multiline':False]
['text':' 2D reversed C-order','line_number':233,'multiline':False]
['text':' 2D reversed Fortran-order','line_number':240,'multiline':False]
['text':' The multi-indices should be correct with any reordering','line_number':251,'multiline':False]
['text':' 3D C-order','line_number':254,'multiline':False]
['text':' 3D Fortran-order','line_number':259,'multiline':False]
['text':' 3D reversed C-order','line_number':264,'multiline':False]
['text':' 3D reversed Fortran-order','line_number':277,'multiline':False]
['text':' The C index should be correct with any reordering','line_number':295,'multiline':False]
['text':' 1D order','line_number':298,'multiline':False]
['text':' 1D reversed order','line_number':301,'multiline':False]
['text':' The C index should be correct with any reordering','line_number':306,'multiline':False]
['text':' 2D C-order','line_number':309,'multiline':False]
['text':' 2D Fortran-order','line_number':312,'multiline':False]
['text':' 2D reversed C-order','line_number':316,'multiline':False]
['text':' 2D reversed Fortran-order','line_number':323,'multiline':False]
['text':' The C index should be correct with any reordering','line_number':335,'multiline':False]
['text':' 3D C-order','line_number':338,'multiline':False]
['text':' 3D Fortran-order','line_number':342,'multiline':False]
['text':' 3D reversed C-order','line_number':347,'multiline':False]
['text':' 3D reversed Fortran-order','line_number':357,'multiline':False]
['text':' The Fortran index should be correct with any reordering','line_number':372,'multiline':False]
['text':' 1D order','line_number':375,'multiline':False]
['text':' 1D reversed order','line_number':378,'multiline':False]
['text':' The Fortran index should be correct with any reordering','line_number':383,'multiline':False]
['text':' 2D C-order','line_number':386,'multiline':False]
['text':' 2D Fortran-order','line_number':389,'multiline':False]
['text':' 2D reversed C-order','line_number':393,'multiline':False]
['text':' 2D reversed Fortran-order','line_number':400,'multiline':False]
['text':' The Fortran index should be correct with any reordering','line_number':412,'multiline':False]
['text':' 3D C-order','line_number':415,'multiline':False]
['text':' 3D Fortran-order','line_number':419,'multiline':False]
['text':' 3D reversed C-order','line_number':424,'multiline':False]
['text':' 3D reversed Fortran-order','line_number':434,'multiline':False]
['text':' Check no_inner iterators which coalesce into a single inner loop','line_number':449,'multiline':False]
['text':' Test each combination of forward and backwards indexing','line_number':454,'multiline':False]
['text':' C-order','line_number':463,'multiline':False]
['text':' Fortran-order','line_number':467,'multiline':False]
['text':' Other order','line_number':471,'multiline':False]
['text':' Check no_inner iterators whose dimensions may not coalesce completely','line_number':479,'multiline':False]
['text':' Skipping the last element in a dimension prevents coalescing','line_number':481,'multiline':False]
['text':' with the next-bigger dimension','line_number':482,'multiline':False]
['text':' Even with lots of 1-sized dimensions, should still coalesce','line_number':496,'multiline':False]
['text':' Check that the correct number of dimensions are coalesced','line_number':503,'multiline':False]
['text':' Tracking a multi-index disables coalescing','line_number':505,'multiline':False]
['text':' A tracked index can allow coalescing if it's compatible with the array','line_number':510,'multiline':False]
['text':' When C or F order is forced, coalescing may still occur','line_number':523,'multiline':False]
['text':' Standard NumPy broadcasting rules','line_number':539,'multiline':False]
['text':' 1D with scalar','line_number':541,'multiline':False]
['text':' 2D with scalar','line_number':546,'multiline':False]
['text':' 2D with 1D','line_number':551,'multiline':False]
['text':' 2D with 2D','line_number':560,'multiline':False]
['text':' 3D with scalar','line_number':566,'multiline':False]
['text':' 3D with 1D','line_number':571,'multiline':False]
['text':' 3D with 2D','line_number':580,'multiline':False]
['text':' 3D with 3D','line_number':593,'multiline':False]
['text':' Check that allocated outputs work with a specified shape','line_number':609,'multiline':False]
['text':' If we specify 1 in the itershape, it shouldn't allow broadcasting','line_number':630,'multiline':False]
['text':' of that dimension to a bigger value','line_number':631,'multiline':False]
['text':' Test bug that for no op_axes but itershape, they are NULLed correctly','line_number':636,'multiline':False]
['text':' Check that errors are thrown for bad broadcasting shapes','line_number':640,'multiline':False]
['text':' 1D with 1D','line_number':642,'multiline':False]
['text':' 2D with 1D','line_number':645,'multiline':False]
['text':' 2D with 2D','line_number':649,'multiline':False]
['text':' 3D with 3D','line_number':656,'multiline':False]
['text':' Verify that the error message mentions the right shapes','line_number':664,'multiline':False]
['text':' The message should contain the shape of the 3rd operand','line_number':674,'multiline':False]
['text':' The message should contain the broadcast shape','line_number':677,'multiline':False]
['text':' The message should contain "shape->remappedshape" for each operand','line_number':690,'multiline':False]
['text':' The message should contain the itershape parameter','line_number':696,'multiline':False]
['text':' The message should contain the shape of the bad operand','line_number':707,'multiline':False]
['text':' The message should contain the broadcast shape','line_number':710,'multiline':False]
['text':' Check that bad combinations of flags produce errors','line_number':715,'multiline':False]
['text':' Not enough operands','line_number':719,'multiline':False]
['text':' Too many operands','line_number':721,'multiline':False]
['text':' Bad global flag','line_number':723,'multiline':False]
['text':' Bad op flag','line_number':725,'multiline':False]
['text':' Bad order parameter','line_number':727,'multiline':False]
['text':' Bad casting parameter','line_number':729,'multiline':False]
['text':' op_flags must match ops','line_number':731,'multiline':False]
['text':' Cannot track both a C and an F index','line_number':733,'multiline':False]
['text':' Inner iteration and multi-indices/indices are incompatible','line_number':736,'multiline':False]
['text':' Must specify exactly one of readwrite/readonly/writeonly per operand','line_number':743,'multiline':False]
['text':' Python scalars are always readonly','line_number':750,'multiline':False]
['text':' Array scalars are always readonly','line_number':753,'multiline':False]
['text':' Check readonly array','line_number':756,'multiline':False]
['text':' Multi-indices available only with the multi_index flag','line_number':761,'multiline':False]
['text':' Index available only with an index flag','line_number':764,'multiline':False]
['text':' GotoCoords and GotoIndex incompatible with buffering or no_inner','line_number':766,'multiline':False]
['text':' Can't iterate if size is zero','line_number':788,'multiline':False]
['text':' check for no warnings on dealloc','line_number':817,'multiline':False]
['text':' Check that byte order, alignment, and contig changes work','line_number':822,'multiline':False]
['text':' Byte order change by requesting a specific dtype','line_number':824,'multiline':False]
['text':' context manager triggers WRITEBACKIFCOPY on i at exit','line_number':833,'multiline':False]
['text':' should not raise a warning','line_number':839,'multiline':False]
['text':' Byte order change by requesting NBO','line_number':840,'multiline':False]
['text':' context manager triggers UPDATEIFCOPY on i at exit','line_number':847,'multiline':False]
['text':' Unaligned input','line_number':855,'multiline':False]
['text':' Without 'aligned', shouldn't copy','line_number':860,'multiline':False]
['text':' With 'aligned', should make a copy','line_number':864,'multiline':False]
['text':' context manager triggers UPDATEIFCOPY on i at exit','line_number':867,'multiline':False]
['text':' Discontiguous input','line_number':872,'multiline':False]
['text':' If it is contiguous, shouldn't copy','line_number':874,'multiline':False]
['text':' If it isn't contiguous, should buffer','line_number':878,'multiline':False]
['text':' Check that arrays are cast as requested','line_number':886,'multiline':False]
['text':' No cast 'f4' -> 'f4'','line_number':888,'multiline':False]
['text':' Byte-order cast '<f4' -> '>f4'','line_number':895,'multiline':False]
['text':' Safe case 'f4' -> 'f8'','line_number':903,'multiline':False]
['text':' The memory layout of the temporary should match a (a is (48,4,16))','line_number':910,'multiline':False]
['text':' except negative strides get flipped to positive strides.','line_number':911,'multiline':False]
['text':' Same-kind cast 'f8' -> 'f4' -> 'f8'','line_number':921,'multiline':False]
['text':' Check that WRITEBACKIFCOPY is activated at exit','line_number':930,'multiline':False]
['text':' Even though the stride was negative in 'a', it','line_number':941,'multiline':False]
['text':' becomes positive in the temporary','line_number':942,'multiline':False]
['text':' Check that invalid casts are caught','line_number':948,'multiline':False]
['text':' Need to enable copying for casts to occur','line_number':950,'multiline':False]
['text':' Also need to allow casting for casts to occur','line_number':953,'multiline':False]
['text':' '<f4' -> '>f4' should not work with casting='no'','line_number':968,'multiline':False]
['text':' 'f4' -> 'f8' is a safe cast, but 'f8' -> 'f4' isn't','line_number':972,'multiline':False]
['text':' 'f4' -> 'i4' is neither a safe nor a same-kind cast','line_number':981,'multiline':False]
['text':' Check that scalars are cast as requested','line_number':992,'multiline':False]
['text':' No cast 'f4' -> 'f4'','line_number':994,'multiline':False]
['text':' Safe cast 'f4' -> 'f8'','line_number':1000,'multiline':False]
['text':' Same-kind cast 'f8' -> 'f4'','line_number':1008,'multiline':False]
['text':' Unsafe cast 'f8' -> 'i4'','line_number':1016,'multiline':False]
['text':' Readonly scalars may be cast even without setting COPY or BUFFERED','line_number':1024,'multiline':False]
['text':' Check that invalid casts are caught','line_number':1030,'multiline':False]
['text':' Need to allow copying/buffering for write casts of scalars to occur','line_number':1032,'multiline':False]
['text':' 'f8' -> 'f4' isn't a safe cast if the value would overflow','line_number':1037,'multiline':False]
['text':' 'f4' -> 'i4' is neither a safe nor a same-kind cast','line_number':1042,'multiline':False]
['text':' Check that object arrays work','line_number':1049,'multiline':False]
['text':' Need to allow references for object arrays','line_number':1056,'multiline':False]
['text':' Conversions to/from objects','line_number':1088,'multiline':False]
['text':' Non-contiguous object array','line_number':1105,'multiline':False]
['text':'Non-contiguous value array','line_number':1116,'multiline':False]
['text':' Check that the iterator finds a common data type correctly','line_number':1133,'multiline':False]
['text':' (some checks are somewhat duplicate after adopting NEP 50)','line_number':1134,'multiline':False]
['text':' When allocating outputs, other outputs aren't factored in','line_number':1177,'multiline':False]
['text':' But, if common data types are requested, they are','line_number':1186,'multiline':False]
['text':' Ensure the iterator makes copies on read/write overlap, if requested','line_number':1198,'multiline':False]
['text':' Copy not needed, 1 op','line_number':1200,'multiline':False]
['text':' Copy needed, 2 ops, read-write overlap','line_number':1207,'multiline':False]
['text':' Copy not needed with elementwise, 2 ops, exactly same arrays','line_number':1214,'multiline':False]
['text':' Copy not needed, 2 ops, no overlap','line_number':1225,'multiline':False]
['text':' Copy needed, 2 ops, read-write overlap','line_number':1232,'multiline':False]
['text':' Copy needed, 3 ops, read-write overlap','line_number':1239,'multiline':False]
['text':' Copy not needed, 3 ops, read-only overlap','line_number':1251,'multiline':False]
['text':' Copy not needed, 3 ops, read-only overlap','line_number':1263,'multiline':False]
['text':' Copy not needed, 3 ops, write-only overlap','line_number':1275,'multiline':False]
['text':' Check that custom axes work','line_number':1288,'multiline':False]
['text':' Reverse the axes','line_number':1290,'multiline':False]
['text':' Broadcast 1D to any dimension','line_number':1298,'multiline':False]
['text':' Inner product-style broadcasting','line_number':1311,'multiline':False]
['text':' Matrix product-style broadcasting','line_number':1318,'multiline':False]
['text':' Check that custom axes throws errors for bad inputs','line_number':1326,'multiline':False]
['text':' Wrong number of items in op_axes','line_number':1328,'multiline':False]
['text':' Out of bounds items in op_axes','line_number':1332,'multiline':False]
['text':' Duplicate items in op_axes','line_number':1337,'multiline':False]
['text':' Different sized arrays in op_axes','line_number':1343,'multiline':False]
['text':' Non-broadcastable dimensions in the result','line_number':1347,'multiline':False]
['text':' Check that copying the iterator works correctly','line_number':1352,'multiline':False]
['text':' Simple iterator','line_number':1355,'multiline':False]
['text':' Buffered iterator','line_number':1364,'multiline':False]
['text':' Casting iterator','line_number':1383,'multiline':False]
['text':' Ensure the dtype is never flexible:','line_number':1400,'multiline':False]
['text':' Make things a bit more interesting by requiring a byte-swap as well:','line_number':1406,'multiline':False]
['text':' Some casts are not possible, do not worry about them','line_number':1411,'multiline':False]
['text':' Casting to strings may be strange, but for simple dtypes do not rely','line_number':1418,'multiline':False]
['text':' on the cast being correct:','line_number':1419,'multiline':False]
['text':' Test a complicated structured dtype for casting, as it requires','line_number':1433,'multiline':False]
['text':' both multiple steps and a more complex casting setup.','line_number':1434,'multiline':False]
['text':' Includes a structured -> unstructured (any to object), and many other','line_number':1435,'multiline':False]
['text':' casts, which cause this to require all steps in the casting machinery','line_number':1436,'multiline':False]
['text':' one level down as well as the iterator copy (which uses NpyAuxData clone)','line_number':1437,'multiline':False]
['text':' Note that the .base avoids the subarray field','line_number':1458,'multiline':False]
['text':' Similar to the above, this is a fairly arcane test to cover internals','line_number':1465,'multiline':False]
['text':' Array of two structured scalars:','line_number':1481,'multiline':False]
['text':' Cast to tuple by getitem, which may be weird and changeable?:','line_number':1483,'multiline':False]
['text':' Check that the iterator will properly allocate outputs','line_number':1497,'multiline':False]
['text':' Simple case','line_number':1499,'multiline':False]
['text':' Allocated output with buffering + delay_bufalloc','line_number':1507,'multiline':False]
['text':' The allocated output should match the iteration order','line_number':1520,'multiline':False]
['text':' C-order input, best iteration order','line_number':1522,'multiline':False]
['text':' F-order input, best iteration order','line_number':1529,'multiline':False]
['text':' Non-contiguous input, C iteration order','line_number':1536,'multiline':False]
['text':' Specifying op_axes should work','line_number':1547,'multiline':False]
['text':' Check type promotion of automatic outputs (this was more interesting','line_number':1558,'multiline':False]
['text':' before NEP 50...)','line_number':1559,'multiline':False]
['text':' Verify the rules for byte order changes','line_number':1578,'multiline':False]
['text':' When there's just one input, the output type exactly matches','line_number':1580,'multiline':False]
['text':' With two or more inputs, the output type is in native byte order','line_number':1586,'multiline':False]
['text':' If the inputs are all scalars, the output should be a scalar','line_number':1593,'multiline':False]
['text':' Make sure that the subtype with priority wins','line_number':1601,'multiline':False]
['text':' subclass vs ndarray','line_number':1605,'multiline':False]
['text':' If subtypes are disabled, we should get back an ndarray.','line_number':1614,'multiline':False]
['text':' Check that the iterator will throw errors for bad output allocations','line_number':1623,'multiline':False]
['text':' Need an input if no output data type is specified','line_number':1625,'multiline':False]
['text':' Allocated output should be flagged for writing','line_number':1629,'multiline':False]
['text':' Allocated output can't have buffering without delayed bufalloc','line_number':1632,'multiline':False]
['text':' Must specify dtype if there are no inputs (cannot promote existing ones;','line_number':1635,'multiline':False]
['text':' maybe this should use the 'f4' here, but it does not historically.)','line_number':1636,'multiline':False]
['text':' If using op_axes, must specify all the axes','line_number':1641,'multiline':False]
['text':' If using op_axes, the axes must be within bounds','line_number':1647,'multiline':False]
['text':' If using op_axes, there can't be duplicates','line_number':1652,'multiline':False]
['text':' Not all axes may be specified if a reduction. If there is a hole','line_number':1657,'multiline':False]
['text':' in op_axes, this is an error.','line_number':1658,'multiline':False]
['text':' When no output and no shape is given, `()` is used as shape.','line_number':1666,'multiline':False]
['text':' Check that removing multi-index support works','line_number':1687,'multiline':False]
['text':' Removing the multi-index tracking causes all dimensions to coalesce','line_number':1696,'multiline':False]
['text':' Removing the inner loop means there's just one iteration','line_number':1706,'multiline':False]
['text':' Make sure iterindex works','line_number':1716,'multiline':False]
['text':' Make sure getting and resetting the iterrange works','line_number':1750,'multiline':False]
['text':' Test buffering with several buffer sizes and types','line_number':1791,'multiline':False]
['text':' F-order swapped array','line_number':1793,'multiline':False]
['text':' Contiguous 1-dimensional array','line_number':1797,'multiline':False]
['text':' Unaligned array','line_number':1799,'multiline':False]
['text':' 4-D F-order array','line_number':1804,'multiline':False]
['text':' Test that buffering of writes is working','line_number':1821,'multiline':False]
['text':' F-order swapped array','line_number':1823,'multiline':False]
['text':' Test that delaying buffer allocation works','line_number':1840,'multiline':False]
['text':' Test that buffering can handle a simple cast','line_number':1867,'multiline':False]
['text':' Test that buffering can handle a cast which requires swap->cast->swap','line_number':1882,'multiline':False]
['text':' Test that buffering can handle a cast which requires swap->cast->copy','line_number':1914,'multiline':False]
['text':' Tests buffering of structured types','line_number':1967,'multiline':False]
['text':' simple -> struct type (duplicates the value)','line_number':1969,'multiline':False]
['text':' object -> struct type','line_number':1986,'multiline':False]
['text':' single-field struct type -> simple','line_number':2011,'multiline':False]
['text':' make sure multi-field struct type -> simple doesn't work','line_number':2019,'multiline':False]
['text':' struct type -> struct type (field-wise copy)','line_number':2027,'multiline':False]
['text':' make sure struct type -> struct type with different','line_number':2041,'multiline':False]
['text':' number of fields fails','line_number':2042,'multiline':False]
['text':' This test was initially designed to test an error at a different','line_number':2048,'multiline':False]
['text':' place, but will now raise earlier to to the cast not being possible:','line_number':2049,'multiline':False]
['text':' `assert np.can_cast(a.dtype, sdt2, casting="unsafe")` fails.','line_number':2050,'multiline':False]
['text':' Without a faulty DType, there is probably no reliable','line_number':2051,'multiline':False]
['text':' way to get the initial tested behaviour.','line_number':2052,'multiline':False]
['text':' requires clean up','line_number':2053,'multiline':False]
['text':' The input is cast into an `S3` buffer','line_number':2061,'multiline':False]
['text':' The `M8[ns]` is cast into the `S3` output','line_number':2065,'multiline':False]
['text':' cannot be converted to int.','line_number':2071,'multiline':False]
['text':' The following gives an unraisable error. Pytest sometimes captures that','line_number':2076,'multiline':False]
['text':' (depending python and/or pytest version). So with Python>=3.8 this can','line_number':2077,'multiline':False]
['text':' probably be cleaned out in the future to check for','line_number':2078,'multiline':False]
['text':' pytest.PytestUnraisableExceptionWarning:','line_number':2079,'multiline':False]
['text':' Tests buffering of subarrays','line_number':2095,'multiline':False]
['text':' one element -> many (copies it to all)','line_number':2097,'multiline':False]
['text':' one element -> many -> back (copies it to all)','line_number':2109,'multiline':False]
['text':' many -> one element -> back (copies just element 0)','line_number':2126,'multiline':False]
['text':' many -> one element -> back (copies just element 0)','line_number':2143,'multiline':False]
['text':' many -> one element (copies just element 0)','line_number':2157,'multiline':False]
['text':' many -> matching shape (straightforward copy)','line_number':2171,'multiline':False]
['text':' vector -> smaller vector (truncates)','line_number':2185,'multiline':False]
['text':' vector -> bigger vector (pads with zeros)','line_number':2199,'multiline':False]
['text':' vector -> matrix (broadcasts)','line_number':2214,'multiline':False]
['text':' vector -> matrix (broadcasts and zero-pads)','line_number':2229,'multiline':False]
['text':' matrix -> matrix (truncates and zero-pads)','line_number':2245,'multiline':False]
['text':' Writing back from a buffer cannot combine elements','line_number':2262,'multiline':False]
['text':' a needs write buffering, but had a broadcast dimension','line_number':2264,'multiline':False]
['text':' But if a is readonly, it's fine','line_number':2272,'multiline':False]
['text':' If a has just one element, it's fine too (constant 0 stride, a reduction)','line_number':2277,'multiline':False]
['text':' check that it fails on other dimensions too','line_number':2283,'multiline':False]
['text':' Safe casting disallows shrinking strings','line_number':2296,'multiline':False]
['text':' Test that the inner loop grows when no buffering is needed','line_number':2314,'multiline':False]
['text':' Should end up with just one inner loop here','line_number':2318,'multiline':False]
['text':' large enough array for all views, including negative strides.','line_number':2324,'multiline':False]
['text':' wrong dtype to force buffering','line_number':2329,'multiline':False]
['text':' last stride is reduced and because of that not','line_number':2336,'multiline':False]
['text':' important for this test, as it is the inner stride.','line_number':2337,'multiline':False]
['text':' Test that the no_broadcast flag works','line_number':2375,'multiline':False]
['text':' Test nested iteration basic usage','line_number':2392,'multiline':False]
['text':' Test nested iteration basic usage','line_number':2408,'multiline':False]
['text':' In 'K' order (default), it gets reordered','line_number':2411,'multiline':False]
['text':' In 'C' order, it doesn't','line_number':2424,'multiline':False]
['text':' Test nested iteration with negative axes','line_number':2438,'multiline':False]
['text':' In 'K' order (default), the axes all get flipped','line_number':2441,'multiline':False]
['text':' In 'C' order, flipping axes is disabled','line_number':2454,'multiline':False]
['text':' Test nested iteration with broadcasting','line_number':2468,'multiline':False]
['text':' Test nested iteration with a copy to change dtype','line_number':2481,'multiline':False]
['text':' copy','line_number':2483,'multiline':False]
['text':' writebackifcopy - using context manager','line_number':2493,'multiline':False]
['text':' writebackifcopy - using close()','line_number':2507,'multiline':False]
['text':' Test nested iteration with buffering to change dtype','line_number':2523,'multiline':False]
['text':' Test nested iteration with buffering to change dtype','line_number':2555,'multiline':False]
['text':' Test doing reductions with the iterator','line_number':2583,'multiline':False]
['text':' Need to initialize the output operand to the addition unit','line_number':2589,'multiline':False]
['text':' Do the reduction','line_number':2592,'multiline':False]
['text':' Since no axes were specified, should have allocated a scalar','line_number':2595,'multiline':False]
['text':' Need to initialize the output operand to the addition unit','line_number':2603,'multiline':False]
['text':' Reduction shape/strides for the output','line_number':2606,'multiline':False]
['text':' Do the reduction','line_number':2609,'multiline':False]
['text':' Use a for loop instead of ``y[...] += x``','line_number':2611,'multiline':False]
['text':' (equivalent to ``y[...] = y[...].copy() + x``),','line_number':2612,'multiline':False]
['text':' because y has zero strides we use for the reduction','line_number':2613,'multiline':False]
['text':' Since no axes were specified, should have allocated a scalar','line_number':2616,'multiline':False]
['text':' This is a tricky reduction case for the buffering double loop','line_number':2620,'multiline':False]
['text':' to handle','line_number':2621,'multiline':False]
['text':' Test doing buffered reductions with the iterator','line_number':2642,'multiline':False]
['text':' Do the reduction','line_number':2653,'multiline':False]
['text':' Since no axes were specified, should have allocated a scalar','line_number':2656,'multiline':False]
['text':' Reduction shape/strides for the output','line_number':2665,'multiline':False]
['text':' Do the reduction','line_number':2669,'multiline':False]
['text':' Use a for loop instead of ``y[...] += x``','line_number':2671,'multiline':False]
['text':' (equivalent to ``y[...] = y[...].copy() + x``),','line_number':2672,'multiline':False]
['text':' because y has zero strides we use for the reduction','line_number':2673,'multiline':False]
['text':' Iterator inner double loop was wrong on this one','line_number':2678,'multiline':False]
['text':' Iterator inner loop should take argument contiguity into account','line_number':2690,'multiline':False]
['text':' There was a bug triggering reuse of the reduce loop inappropriately,','line_number':2708,'multiline':False]
['text':' which caused processing to happen in unnecessarily small chunks','line_number':2709,'multiline':False]
['text':' and overran the buffer.','line_number':2710,'multiline':False]
['text':' Need an 'arraymask' if any operand is 'writemasked'','line_number':2732,'multiline':False]
['text':' A 'writemasked' operand must not be readonly','line_number':2736,'multiline':False]
['text':' 'writemasked' and 'arraymask' may not be used together','line_number':2740,'multiline':False]
['text':' 'arraymask' may only be specified once','line_number':2744,'multiline':False]
['text':' An 'arraymask' with nothing 'writemasked' also doesn't make sense','line_number':2750,'multiline':False]
['text':' A writemasked reduction requires a similarly smaller mask','line_number':2754,'multiline':False]
['text':' But this should work with a smaller/equal mask to the reduction operand','line_number':2759,'multiline':False]
['text':' The arraymask itself cannot be a reduction','line_number':2764,'multiline':False]
['text':' A uint8 mask is ok too','line_number':2770,'multiline':False]
['text':' An int8 mask isn't ok','line_number':2776,'multiline':False]
['text':' A float32 mask isn't ok','line_number':2782,'multiline':False]
['text':' Also test with the last dimension strided (so it does not fit if','line_number':2801,'multiline':False]
['text':' there is repeated access)','line_number':2802,'multiline':False]
['text':' Note, the slicing above is to ensure that nditer cannot combine multiple','line_number':2807,'multiline':False]
['text':' axes into one.  The repetition is just to make things a bit more','line_number':2808,'multiline':False]
['text':' interesting.','line_number':2809,'multiline':False]
['text':' When buffering is unused, 'writemasked' effectively does nothing.','line_number':2815,'multiline':False]
['text':' It's up to the user of the iterator to obey the requested semantics.','line_number':2816,'multiline':False]
['text':' Because we violated the semantics, all the values became 1','line_number':2823,'multiline':False]
['text':' Even if buffering is enabled, we still may be accessing the array','line_number':2826,'multiline':False]
['text':' directly.','line_number':2827,'multiline':False]
['text':' @seberg: I honestly don't currently understand why a "buffered" iterator','line_number':2831,'multiline':False]
['text':' would end up not using a buffer for the small array here at least when','line_number':2832,'multiline':False]
['text':' "writemasked" is used, that seems confusing...  Check by testing for','line_number':2833,'multiline':False]
['text':' actual memory overlap!','line_number':2834,'multiline':False]
['text':' Because we violated the semantics, all the values became 2.5','line_number':2843,'multiline':False]
['text':' For large sizes, the iterator may be buffered:','line_number':2846,'multiline':False]
['text':' If buffering will definitely happening, for instance because of','line_number':2850,'multiline':False]
['text':' a cast, only the items selected by the mask will be copied back from','line_number':2851,'multiline':False]
['text':' the buffer.','line_number':2852,'multiline':False]
['text':' Even though we violated the semantics, only the selected values','line_number':2861,'multiline':False]
['text':' were copied back','line_number':2862,'multiline':False]
['text':' Allocated operand (only broadcasts with -1)','line_number':2867,'multiline':False]
['text':' Reduction along the first dimension (with and without op_axes)','line_number':2869,'multiline':False]
['text':' Test 0-D and -1 op_axes','line_number':2872,'multiline':False]
['text':' This assumes that a readwrite mask makes sense. This is likely not the','line_number':2877,'multiline':False]
['text':' case and should simply be deprecated.','line_number':2878,'multiline':False]
['text':' force casting (to make it interesting) by using a structured dtype.','line_number':2894,'multiline':False]
['text':' delete everything to ensure correct cleanup','line_number':2909,'multiline':False]
['text':' The buffer would have included additional items, they must be','line_number':2912,'multiline':False]
['text':' cleared correctly:','line_number':2913,'multiline':False]
['text':' If the dtype of an allocated output has a shape, the shape gets','line_number':2952,'multiline':False]
['text':' tacked onto the end of the result.','line_number':2953,'multiline':False]
['text':' Check the same (less sensitive) thing when `op_axes` with -1 is given.','line_number':2960,'multiline':False]
['text':' Make sure this works for scalars too','line_number':2968,'multiline':False]
['text':' Basic test for iteration of 0-d arrays:','line_number':2979,'multiline':False]
['text':' test reset:','line_number':2986,'multiline':False]
['text':' test forcing to 0-d','line_number':2991,'multiline':False]
['text':' passing an itershape alone is not enough, the op_axes are also needed','line_number':3001,'multiline':False]
['text':' Test a more complex buffered casting case (same as another test above)','line_number':3005,'multiline':False]
['text':' see gh-18450','line_number':3017,'multiline':False]
['text':' object arrays can raise a python exception in ufunc inner loops using','line_number':3018,'multiline':False]
['text':' nditer, which should cause iteration to stop & cleanup. There were bugs','line_number':3019,'multiline':False]
['text':' in the nditer cleanup when decref'ing object arrays.','line_number':3020,'multiline':False]
['text':' This test would trigger valgrind "uninitialized read" before the bugfix.','line_number':3021,'multiline':False]
['text':' this more explicit code also triggers the invalid access','line_number':3024,'multiline':False]
['text':' followup: this tests for a bug introduced in the first pass of gh-18450,','line_number':3030,'multiline':False]
['text':' caused by an incorrect fallthrough of the TypeError','line_number':3031,'multiline':False]
['text':' Similar as above, but a complex reduction case that was previously','line_number':3039,'multiline':False]
['text':' missed (see gh-18810).','line_number':3040,'multiline':False]
['text':' The following array is special in that it cannot be flattened:','line_number':3041,'multiline':False]
['text':' More complicated calls are possible for large arrays:','line_number':3051,'multiline':False]
['text':' force casting with `dtype=object`','line_number':3053,'multiline':False]
['text':' The total size of the iterator must not exceed the maximum intp due','line_number':3058,'multiline':False]
['text':' to broadcasting. Dividing by 1024 will keep it small enough to','line_number':3059,'multiline':False]
['text':' give a legal array.','line_number':3060,'multiline':False]
['text':' test the same for multiindex. That may get more interesting when','line_number':3064,'multiline':False]
['text':' removing 0 dimensional axis is allowed (since an iterator can grow then)','line_number':3065,'multiline':False]
['text':' When a multi index is being tracked, the error is delayed this','line_number':3071,'multiline':False]
['text':' checks the delayed error messages and getting below that by','line_number':3072,'multiline':False]
['text':' removing an axis.','line_number':3073,'multiline':False]
['text':' arrays are now too large to be broadcast. The different modes test','line_number':3087,'multiline':False]
['text':' different nditer functionality with or without GIL.','line_number':3088,'multiline':False]
['text':' but if we do nothing with the nditer, it can be constructed:','line_number':3092,'multiline':False]
['text':' When an axis is removed, things should work again (half the time):','line_number':3095,'multiline':False]
['text':' an axis with size 1024 is removed:','line_number':3098,'multiline':False]
['text':' an axis with size 1 is removed:','line_number':3100,'multiline':False]
['text':' do it again, this time raise an error,','line_number':3114,'multiline':False]
['text':' cannot reuse i outside context manager','line_number':3126,'multiline':False]
['text':' x.data still valid','line_number':3137,'multiline':False]
['text':' but not connected to au','line_number':3138,'multiline':False]
['text':' reentering works','line_number':3143,'multiline':False]
['text':' make sure exiting the inner context manager closes the iterator','line_number':3152,'multiline':False]
['text':' do not crash if original data array is decrefed','line_number':3158,'multiline':False]
['text':' make sure we cannot reenter the closed iterator','line_number':3166,'multiline':False]
['text':' most simple cases','line_number':3223,'multiline':False]
['text':' structured partially only copying O','line_number':3224,'multiline':False]
['text':' structured casting to and from O','line_number':3225,'multiline':False]
['text':' just a random value that Python won't intern','line_number':3235,'multiline':False]
['text':' The iteration finishes in 3 steps, the first two are partial','line_number':3241,'multiline':False]
['text':' not necessary, but we test the cleanup','line_number':3244,'multiline':False]
['text':' Repeat the test with `iternext`','line_number':3246,'multiline':False]
['text':' not necessary, but we test the cleanup','line_number':3252,'multiline':False]
['text':' most simple cases','line_number':3256,'multiline':False]
['text':' structured casting to and from O','line_number':3257,'multiline':False]
['text':' relies on python cache (leak-check will still find it)','line_number':3260,'multiline':False]
['text':' pytest.raises seems to have issues with the error originating','line_number':3272,'multiline':False]
['text':' in the for loop, so manually unravel:','line_number':3273,'multiline':False]
['text':' raises TypeError','line_number':3275,'multiline':False]
['text':' Repeat the test with `iternext` after resetting, the buffers should','line_number':3277,'multiline':False]
['text':' already be cleared from any references, so resetting is sufficient.','line_number':3278,'multiline':False]
['text':' the expected output with all addresses and sizes stripped (they vary','line_number':3295,'multiline':False]
['text':' and/or are platform dependent).','line_number':3296,'multiline':False]
['text':' The actual output may have additional pointers listed that are','line_number':3363,'multiline':False]
['text':' stripped from the example output:','line_number':3364,'multiline':False]
