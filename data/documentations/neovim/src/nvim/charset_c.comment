['text':'/ @file charset.c','line_number':1,'multiline':False]
['text':'/','line_number':2,'multiline':False]
['text':'/ Code related to character sets.','line_number':3,'multiline':False]
['text':' b_chartab[] is an array with 256 bits, each bit representing one of the','line_number':38,'multiline':False]
['text':' characters 0-255.','line_number':39,'multiline':False]
['text':' Table used below, see init_chartab() for an explanation','line_number':47,'multiline':False]
['text':' Flags for g_chartab[].','line_number':50,'multiline':False]
['text':'/< mask: nr of display cells (1, 2 or 4)','line_number':51,'multiline':False]
['text':'/< flag: set for printable chars','line_number':52,'multiline':False]
['text':'/< flag: set for ID chars','line_number':53,'multiline':False]
['text':'/< flag: set for file name chars','line_number':54,'multiline':False]
['text':'/ Fill g_chartab[].  Also fills curbuf->b_chartab[] with flags for keyword','line_number':56,'multiline':False]
['text':'/ characters for current buffer.','line_number':57,'multiline':False]
['text':'/','line_number':58,'multiline':False]
['text':'/ Depends on the option settings 'iskeyword', 'isident', 'isfname',','line_number':59,'multiline':False]
['text':'/ 'isprint' and 'encoding'.','line_number':60,'multiline':False]
['text':'/','line_number':61,'multiline':False]
['text':'/ The index in g_chartab[] is the character when first byte is up to 0x80,','line_number':62,'multiline':False]
['text':'/ if the first byte is 0x80 and above it depends on further bytes.','line_number':63,'multiline':False]
['text':'/','line_number':64,'multiline':False]
['text':'/ The contents of g_chartab[]:','line_number':65,'multiline':False]
['text':'/ - The lower two bits, masked by CT_CELL_MASK, give the number of display','line_number':66,'multiline':False]
['text':'/   cells the character occupies (1 or 2).  Not valid for UTF-8 above 0x80.','line_number':67,'multiline':False]
['text':'/ - CT_PRINT_CHAR bit is set when the character is printable (no need to','line_number':68,'multiline':False]
['text':'/   translate the character before displaying it).  Note that only DBCS','line_number':69,'multiline':False]
['text':'/   characters can have 2 display cells and still be printable.','line_number':70,'multiline':False]
['text':'/ - CT_FNAME_CHAR bit is set when the character can be in a file name.','line_number':71,'multiline':False]
['text':'/ - CT_ID_CHAR bit is set when the character can be in an identifier.','line_number':72,'multiline':False]
['text':'/','line_number':73,'multiline':False]
['text':'/ @return FAIL if 'iskeyword', 'isident', 'isfname' or 'isprint' option has','line_number':74,'multiline':False]
['text':'/ an error, OK otherwise.','line_number':75,'multiline':False]
['text':'/ Helper for init_chartab','line_number':81,'multiline':False]
['text':'/','line_number':82,'multiline':False]
['text':'/ @param global false: only set buf->b_chartab[]','line_number':83,'multiline':False]
['text':'/','line_number':84,'multiline':False]
['text':'/ @return FAIL if 'iskeyword', 'isident', 'isfname' or 'isprint' option has','line_number':85,'multiline':False]
['text':'/ an error, OK otherwise.','line_number':86,'multiline':False]
['text':' Set the default size for printable characters:','line_number':92,'multiline':False]
['text':' From <Space> to '~' is 1 (printable), others are 2 (not printable).','line_number':93,'multiline':False]
['text':' This also inits all 'isident' and 'isfname' flags to false.','line_number':94,'multiline':False]
['text':' UTF-8: bytes 0xa0 - 0xff are printable (latin1)','line_number':107,'multiline':False]
['text':' Also assume that every multi-byte char is a filename character.','line_number':108,'multiline':False]
['text':' the rest is unprintable by default','line_number':111,'multiline':False]
['text':' Init word char flags all to false','line_number':117,'multiline':False]
['text':' In lisp mode the '-' character is included in keywords.','line_number':120,'multiline':False]
['text':' Walk through the 'isident', 'iskeyword', 'isfname' and 'isprint'','line_number':125,'multiline':False]
['text':' options Each option is a list of characters, character numbers or','line_number':126,'multiline':False]
['text':' ranges, separated by commas, e.g.: "200-210,x,#-178,-"','line_number':127,'multiline':False]
['text':' first round: 'isident'','line_number':131,'multiline':False]
['text':' second round: 'isprint'','line_number':134,'multiline':False]
['text':' third round: 'isfname'','line_number':137,'multiline':False]
['text':' i == 3','line_number':139,'multiline':False]
['text':' fourth round: 'iskeyword'','line_number':140,'multiline':False]
['text':' not a range','line_number':178,'multiline':False]
['text':' A single '@' (not "@-@"):','line_number':179,'multiline':False]
['text':' Decide on letters being ID/printable/keyword chars with','line_number':180,'multiline':False]
['text':' standard function isalpha(). This takes care of locale for','line_number':181,'multiline':False]
['text':' single-byte characters).','line_number':182,'multiline':False]
['text':' Use the MB_ functions here, because isalpha() doesn't','line_number':193,'multiline':False]
['text':' work properly when 'encoding' is "latin1" and the locale is','line_number':194,'multiline':False]
['text':' "C".','line_number':195,'multiline':False]
['text':' (re)set ID flag','line_number':200,'multiline':False]
['text':' (re)set printable','line_number':207,'multiline':False]
['text':' (re)set fname flag','line_number':219,'multiline':False]
['text':' i == 3','line_number':225,'multiline':False]
['text':' (re)set keyword flag','line_number':226,'multiline':False]
['text':' Trailing comma is not allowed.','line_number':241,'multiline':False]
['text':'/ Translate any special characters in buf[bufsize] in-place.','line_number':250,'multiline':False]
['text':'/','line_number':251,'multiline':False]
['text':'/ The result is a string with only printable characters, but if there is not','line_number':252,'multiline':False]
['text':'/ enough room, not all characters will be translated.','line_number':253,'multiline':False]
['text':'/','line_number':254,'multiline':False]
['text':'/ @param buf','line_number':255,'multiline':False]
['text':'/ @param bufsize','line_number':256,'multiline':False]
['text':' translated character','line_number':259,'multiline':False]
['text':' length of string needing translation','line_number':260,'multiline':False]
['text':' room in buffer after string','line_number':261,'multiline':False]
['text':' length of trs[]','line_number':264,'multiline':False]
['text':' Assume a multi-byte character doesn't need translation.','line_number':265,'multiline':False]
['text':'/ Find length of a string capable of holding s with all specials replaced','line_number':286,'multiline':False]
['text':'/','line_number':287,'multiline':False]
['text':'/ Assumes replacing special characters with printable ones just like','line_number':288,'multiline':False]
['text':'/ strtrans() does.','line_number':289,'multiline':False]
['text':'/','line_number':290,'multiline':False]
['text':'/ @param[in]  s  String to check.','line_number':291,'multiline':False]
['text':'/','line_number':292,'multiline':False]
['text':'/ @return number of bytes needed to hold a translation of `s`, NUL byte not','line_number':293,'multiline':False]
['text':'/         included.','line_number':294,'multiline':False]
['text':' Illegal byte sequence may occupy up to 4 characters.','line_number':319,'multiline':False]
['text':'/ Replace special characters with printable ones','line_number':326,'multiline':False]
['text':'/','line_number':327,'multiline':False]
['text':'/ @param[in]  s  String to replace characters from.','line_number':328,'multiline':False]
['text':'/ @param[out]  buf  Buffer to which result should be saved.','line_number':329,'multiline':False]
['text':'/ @param[in]  len  Buffer length. Resulting string may not occupy more then','line_number':330,'multiline':False]
['text':'/                  len - 1 bytes (one for trailing NUL byte).','line_number':331,'multiline':False]
['text':'/ @param[in]  untab  remove tab characters','line_number':332,'multiline':False]
['text':'/','line_number':333,'multiline':False]
['text':'/ @return length of the resulting string, without the NUL byte.','line_number':334,'multiline':False]
['text':' Exceeded `buf` size.','line_number':347,'multiline':False]
['text':' <up to 6 bytes>NUL','line_number':356,'multiline':False]
['text':' Exceeded `buf` size.','line_number':372,'multiline':False]
['text':'/ Copy string and replace special characters with printable characters','line_number':383,'multiline':False]
['text':'/','line_number':384,'multiline':False]
['text':'/ Works like `strtrans()` does, used for that and in some other places.','line_number':385,'multiline':False]
['text':'/','line_number':386,'multiline':False]
['text':'/ @param[in]  s  String to replace characters from.','line_number':387,'multiline':False]
['text':'/','line_number':388,'multiline':False]
['text':'/ @return [allocated] translated string','line_number':389,'multiline':False]
['text':' Compute the length of the result, taking account of unprintable','line_number':393,'multiline':False]
['text':' multi-byte characters.','line_number':394,'multiline':False]
['text':' Compute the length of the result, taking account of unprintable','line_number':408,'multiline':False]
['text':' multi-byte characters.','line_number':409,'multiline':False]
['text':' do not include NUL byte','line_number':413,'multiline':False]
['text':'/ Convert the string "str[orglen]" to do ignore-case comparing.','line_number':417,'multiline':False]
['text':'/ Use the current locale.','line_number':418,'multiline':False]
['text':'/','line_number':419,'multiline':False]
['text':'/ When "buf" is NULL, return an allocated string.','line_number':420,'multiline':False]
['text':'/ Otherwise, put the result in buf, limited by buflen, and return buf.','line_number':421,'multiline':False]
['text':' Copy "str" into "buf" or allocated memory, unmodified.','line_number':433,'multiline':False]
['text':' Ugly!','line_number':442,'multiline':False]
['text':' Make each character lower case.','line_number':454,'multiline':False]
['text':' Only replace the character when it is not an invalid','line_number':461,'multiline':False]
['text':' sequence (ASCII character or more than one byte) and','line_number':462,'multiline':False]
['text':' mb_tolower() doesn't return the original character.','line_number':463,'multiline':False]
['text':' If the byte length changes need to shift the following','line_number':467,'multiline':False]
['text':' characters forward or backward.','line_number':468,'multiline':False]
['text':' out of memory, keep old char','line_number':475,'multiline':False]
['text':' skip to next multi-byte char','line_number':495,'multiline':False]
['text':' Catch 22: g_chartab[] can't be initialized before the options are','line_number':505,'multiline':False]
['text':' initialized, and initializing options may cause transchar() to be called!','line_number':506,'multiline':False]
['text':' When chartab_initialized == false don't use g_chartab[].','line_number':507,'multiline':False]
['text':' Does NOT work for multi-byte characters, c must be <= 255.','line_number':508,'multiline':False]
['text':' Also doesn't work for the first byte of a multi-byte, "c" must be a','line_number':509,'multiline':False]
['text':' character!','line_number':510,'multiline':False]
['text':'/ Translate a character into a printable one, leaving printable ASCII intact','line_number':513,'multiline':False]
['text':'/','line_number':514,'multiline':False]
['text':'/ All unicode characters are considered non-printable in this function.','line_number':515,'multiline':False]
['text':'/','line_number':516,'multiline':False]
['text':'/ @param[in]  c  Character to translate.','line_number':517,'multiline':False]
['text':'/','line_number':518,'multiline':False]
['text':'/ @return translated character into a static buffer.','line_number':519,'multiline':False]
['text':' special key code, display as ~@ char','line_number':529,'multiline':False]
['text':' printable character','line_number':538,'multiline':False]
['text':'/ Like transchar(), but called with a byte instead of a character.','line_number':549,'multiline':False]
['text':'/','line_number':550,'multiline':False]
['text':'/ Checks for an illegal UTF-8 byte.  Uses 'fileformat' of the current buffer.','line_number':551,'multiline':False]
['text':'/','line_number':552,'multiline':False]
['text':'/ @param[in]  c  Byte to translate.','line_number':553,'multiline':False]
['text':'/','line_number':554,'multiline':False]
['text':'/ @return pointer to translated character in transchar_charbuf.','line_number':555,'multiline':False]
['text':'/ Like transchar_buf(), but called with a byte instead of a character.','line_number':562,'multiline':False]
['text':'/','line_number':563,'multiline':False]
['text':'/ Checks for an illegal UTF-8 byte.  Uses 'fileformat' of "buf", unless it is NULL.','line_number':564,'multiline':False]
['text':'/','line_number':565,'multiline':False]
['text':'/ @param[in]  c  Byte to translate.','line_number':566,'multiline':False]
['text':'/','line_number':567,'multiline':False]
['text':'/ @return pointer to translated character in transchar_charbuf.','line_number':568,'multiline':False]
['text':'/ Convert non-printable characters to 2..4 printable ones','line_number':579,'multiline':False]
['text':'/','line_number':580,'multiline':False]
['text':'/ @warning Does not work for multi-byte characters, c must be <= 255.','line_number':581,'multiline':False]
['text':'/','line_number':582,'multiline':False]
['text':'/ @param[in]  buf  Required to check the file format','line_number':583,'multiline':False]
['text':'/ @param[out]  charbuf  Buffer to store result in, must be able to hold','line_number':584,'multiline':False]
['text':'/                       at least 5 bytes (conversion result + NUL).','line_number':585,'multiline':False]
['text':'/ @param[in]  c  Character to convert. NUL is assumed to be NL according to','line_number':586,'multiline':False]
['text':'/                `:h NL-used-for-NUL`.','line_number':587,'multiline':False]
['text':' we use newline in place of a NUL','line_number':591,'multiline':False]
['text':' we use CR in place of  NL in this case','line_number':594,'multiline':False]
['text':' 'display' has "uhex"','line_number':600,'multiline':False]
['text':' 0x00 - 0x1f and 0x7f','line_number':603,'multiline':False]
['text':' DEL displayed as ^?','line_number':605,'multiline':False]
['text':'/ Convert a non-printable character to hex C string like "<FFFF>"','line_number':612,'multiline':False]
['text':'/','line_number':613,'multiline':False]
['text':'/ @param[out]  buf  Buffer to store result in.','line_number':614,'multiline':False]
['text':'/ @param[in]  c  Character to convert.','line_number':615,'multiline':False]
['text':'/','line_number':616,'multiline':False]
['text':'/ @return Number of bytes stored in buffer, excluding trailing NUL byte.','line_number':617,'multiline':False]
['text':'/ Mirror text "str" for right-left displaying.','line_number':639,'multiline':False]
['text':'/ Only works for single-byte characters (e.g., numbers).','line_number':640,'multiline':False]
['text':'/ Convert the lower 4 bits of byte "c" to its hex character','line_number':650,'multiline':False]
['text':'/','line_number':651,'multiline':False]
['text':'/ Lower case letters are used to avoid the confusion of <F1> being 0xf1 or','line_number':652,'multiline':False]
['text':'/ function key 1.','line_number':653,'multiline':False]
['text':'/','line_number':654,'multiline':False]
['text':'/ @param[in]  n  Number to convert.','line_number':655,'multiline':False]
['text':'/','line_number':656,'multiline':False]
['text':'/ @return the hex character.','line_number':657,'multiline':False]
['text':'/ Return number of display cells occupied by byte "b".','line_number':667,'multiline':False]
['text':'/','line_number':668,'multiline':False]
['text':'/ Caller must make sure 0 <= b <= 255.','line_number':669,'multiline':False]
['text':'/ For multi-byte mode "b" must be the first byte of a character.','line_number':670,'multiline':False]
['text':'/ A TAB is counted as two cells: "^I".','line_number':671,'multiline':False]
['text':'/ This will return 0 for bytes >= 0x80, because the number of','line_number':672,'multiline':False]
['text':'/ cells depends on further bytes in UTF-8.','line_number':673,'multiline':False]
['text':'/','line_number':674,'multiline':False]
['text':'/ @param b','line_number':675,'multiline':False]
['text':'/','line_number':676,'multiline':False]
['text':'/ @return Number of display cells.','line_number':677,'multiline':False]
['text':'/ Return number of display cells occupied by character "c".','line_number':687,'multiline':False]
['text':'/','line_number':688,'multiline':False]
['text':'/ "c" can be a special key (negative number) in which case 3 or 4 is returned.','line_number':689,'multiline':False]
['text':'/ A TAB is counted as two cells: "^I" or four: "<09>".','line_number':690,'multiline':False]
['text':'/','line_number':691,'multiline':False]
['text':'/ @param c','line_number':692,'multiline':False]
['text':'/','line_number':693,'multiline':False]
['text':'/ @return Number of display cells.','line_number':694,'multiline':False]
['text':' UTF-8: above 0x80 need to check the value','line_number':702,'multiline':False]
['text':'/ Return number of display cells occupied by character at "*p".','line_number':708,'multiline':False]
['text':'/ A TAB is counted as two cells: "^I" or four: "<09>".','line_number':709,'multiline':False]
['text':'/','line_number':710,'multiline':False]
['text':'/ @param p','line_number':711,'multiline':False]
['text':'/','line_number':712,'multiline':False]
['text':'/ @return number of display cells.','line_number':713,'multiline':False]
['text':' For UTF-8 we need to look at more bytes if the first byte is >= 0x80.','line_number':717,'multiline':False]
['text':' For DBCS we can tell the cell count from the first byte.','line_number':722,'multiline':False]
['text':'/ Return the number of character cells string "s" will take on the screen,','line_number':726,'multiline':False]
['text':'/ counting TABs as two characters: "^I".','line_number':727,'multiline':False]
['text':'/','line_number':728,'multiline':False]
['text':'/ 's' must be non-null.','line_number':729,'multiline':False]
['text':'/','line_number':730,'multiline':False]
['text':'/ @param s','line_number':731,'multiline':False]
['text':'/','line_number':732,'multiline':False]
['text':'/ @return number of character cells.','line_number':733,'multiline':False]
['text':'/ Return the number of character cells string "s[len]" will take on the','line_number':739,'multiline':False]
['text':'/ screen, counting TABs as two characters: "^I".','line_number':740,'multiline':False]
['text':'/','line_number':741,'multiline':False]
['text':'/ 's' must be non-null.','line_number':742,'multiline':False]
['text':'/','line_number':743,'multiline':False]
['text':'/ @param s','line_number':744,'multiline':False]
['text':'/ @param len','line_number':745,'multiline':False]
['text':'/','line_number':746,'multiline':False]
['text':'/ @return Number of character cells.','line_number':747,'multiline':False]
['text':'/ Check that "c" is a normal identifier character:','line_number':761,'multiline':False]
['text':'/ Letters and characters from the 'isident' option.','line_number':762,'multiline':False]
['text':'/','line_number':763,'multiline':False]
['text':'/ @param  c  character to check','line_number':764,'multiline':False]
['text':'/ Check that "c" is a keyword character:','line_number':771,'multiline':False]
['text':'/ Letters and characters from 'iskeyword' option for the current buffer.','line_number':772,'multiline':False]
['text':'/ For multi-byte characters mb_get_class() is used (builtin rules).','line_number':773,'multiline':False]
['text':'/','line_number':774,'multiline':False]
['text':'/ @param  c  character to check','line_number':775,'multiline':False]
['text':'/ Check that "c" is a keyword character','line_number':782,'multiline':False]
['text':'/ Letters and characters from 'iskeyword' option for given buffer.','line_number':783,'multiline':False]
['text':'/ For multi-byte characters mb_get_class() is used (builtin rules).','line_number':784,'multiline':False]
['text':'/','line_number':785,'multiline':False]
['text':'/ @param[in]  c  Character to check.','line_number':786,'multiline':False]
['text':'/ @param[in]  chartab  Buffer chartab.','line_number':787,'multiline':False]
['text':'/ Check that "c" is a keyword character:','line_number':796,'multiline':False]
['text':'/ Letters and characters from 'iskeyword' option for given buffer.','line_number':797,'multiline':False]
['text':'/ For multi-byte characters mb_get_class() is used (builtin rules).','line_number':798,'multiline':False]
['text':'/','line_number':799,'multiline':False]
['text':'/ @param  c    character to check','line_number':800,'multiline':False]
['text':'/ @param  buf  buffer whose keywords to use','line_number':801,'multiline':False]
['text':'/ Just like vim_iswordc() but uses a pointer to the (multi-byte) character.','line_number':808,'multiline':False]
['text':'/','line_number':809,'multiline':False]
['text':'/ @param  p  pointer to the multi-byte character','line_number':810,'multiline':False]
['text':'/','line_number':811,'multiline':False]
['text':'/ @return true if "p" points to a keyword character.','line_number':812,'multiline':False]
['text':'/ Just like vim_iswordc_buf() but uses a pointer to the (multi-byte)','line_number':819,'multiline':False]
['text':'/ character.','line_number':820,'multiline':False]
['text':'/','line_number':821,'multiline':False]
['text':'/ @param  p    pointer to the multi-byte character','line_number':822,'multiline':False]
['text':'/ @param  buf  buffer whose keywords to use','line_number':823,'multiline':False]
['text':'/','line_number':824,'multiline':False]
['text':'/ @return true if "p" points to a keyword character.','line_number':825,'multiline':False]
['text':'/ Check that "c" is a valid file-name character as specified with the','line_number':837,'multiline':False]
['text':'/ 'isfname' option.','line_number':838,'multiline':False]
['text':'/ Assume characters above 0x100 are valid (multi-byte).','line_number':839,'multiline':False]
['text':'/ To be used for commands like "gf".','line_number':840,'multiline':False]
['text':'/','line_number':841,'multiline':False]
['text':'/ @param  c  character to check','line_number':842,'multiline':False]
['text':'/ Check if "c" is a valid file-name character, including characters left','line_number':849,'multiline':False]
['text':'/ out of 'isfname' to make "gf" work, such as comma, space, '@', etc.','line_number':850,'multiline':False]
['text':'/ Check that "c" is a valid file-name character or a wildcard character','line_number':857,'multiline':False]
['text':'/ Assume characters above 0x100 are valid (multi-byte).','line_number':858,'multiline':False]
['text':'/ Explicitly interpret ']' as a wildcard character as path_has_wildcard("]")','line_number':859,'multiline':False]
['text':'/ returns false.','line_number':860,'multiline':False]
['text':'/','line_number':861,'multiline':False]
['text':'/ @param  c  character to check','line_number':862,'multiline':False]
['text':'/ Check that "c" is a printable character.','line_number':872,'multiline':False]
['text':'/','line_number':873,'multiline':False]
['text':'/ @param  c  character to check','line_number':874,'multiline':False]
['text':'/ skipwhite: skip over ' ' and '\t'.','line_number':884,'multiline':False]
['text':'/','line_number':885,'multiline':False]
['text':'/ @param[in]  p  String to skip in.','line_number':886,'multiline':False]
['text':'/','line_number':887,'multiline':False]
['text':'/ @return Pointer to character after the skipped whitespace.','line_number':888,'multiline':False]
['text':'/ Like `skipwhite`, but skip up to `len` characters.','line_number':899,'multiline':False]
['text':'/ @see skipwhite','line_number':900,'multiline':False]
['text':'/','line_number':901,'multiline':False]
['text':'/ @param[in]  p    String to skip in.','line_number':902,'multiline':False]
['text':'/ @param[in]  len  Max length to skip.','line_number':903,'multiline':False]
['text':'/','line_number':904,'multiline':False]
['text':'/ @return Pointer to character after the skipped whitespace, or the `len`-th','line_number':905,'multiline':False]
['text':'/         character in the string.','line_number':906,'multiline':False]
['text':' getwhitecols: return the number of whitespace','line_number':917,'multiline':False]
['text':' columns (bytes) at the start of a given line','line_number':918,'multiline':False]
['text':'/ Skip over digits','line_number':930,'multiline':False]
['text':'/','line_number':931,'multiline':False]
['text':'/ @param[in]  q  String to skip digits in.','line_number':932,'multiline':False]
['text':'/','line_number':933,'multiline':False]
['text':'/ @return Pointer to the character after the skipped digits.','line_number':934,'multiline':False]
['text':' skip to next non-digit','line_number':941,'multiline':False]
['text':'/ skip over binary digits','line_number':947,'multiline':False]
['text':'/','line_number':948,'multiline':False]
['text':'/ @param q pointer to string','line_number':949,'multiline':False]
['text':'/','line_number':950,'multiline':False]
['text':'/ @return Pointer to the character after the skipped digits.','line_number':951,'multiline':False]
['text':' skip to next non-digit','line_number':959,'multiline':False]
['text':'/ skip over digits and hex characters','line_number':965,'multiline':False]
['text':'/','line_number':966,'multiline':False]
['text':'/ @param q','line_number':967,'multiline':False]
['text':'/','line_number':968,'multiline':False]
['text':'/ @return Pointer to the character after the skipped digits and hex','line_number':969,'multiline':False]
['text':'/         characters.','line_number':970,'multiline':False]
['text':' skip to next non-digit','line_number':976,'multiline':False]
['text':'/ skip to digit (or NUL after the string)','line_number':982,'multiline':False]
['text':'/','line_number':983,'multiline':False]
['text':'/ @param q','line_number':984,'multiline':False]
['text':'/','line_number':985,'multiline':False]
['text':'/ @return Pointer to the digit or (NUL after the string).','line_number':986,'multiline':False]
['text':' skip to next digit','line_number':992,'multiline':False]
['text':'/ skip to binary character (or NUL after the string)','line_number':998,'multiline':False]
['text':'/','line_number':999,'multiline':False]
['text':'/ @param q pointer to string','line_number':1000,'multiline':False]
['text':'/','line_number':1001,'multiline':False]
['text':'/ @return Pointer to the binary character or (NUL after the string).','line_number':1002,'multiline':False]
['text':' skip to next digit','line_number':1010,'multiline':False]
['text':'/ skip to hex character (or NUL after the string)','line_number':1016,'multiline':False]
['text':'/','line_number':1017,'multiline':False]
['text':'/ @param q','line_number':1018,'multiline':False]
['text':'/','line_number':1019,'multiline':False]
['text':'/ @return Pointer to the hex character or (NUL after the string).','line_number':1020,'multiline':False]
['text':' skip to next digit','line_number':1026,'multiline':False]
['text':'/ Skip over text until ' ' or '\t' or NUL','line_number':1032,'multiline':False]
['text':'/','line_number':1033,'multiline':False]
['text':'/ @param[in]  p  Text to skip over.','line_number':1034,'multiline':False]
['text':'/','line_number':1035,'multiline':False]
['text':'/ @return Pointer to the next whitespace or NUL character.','line_number':1036,'multiline':False]
['text':'/ skiptowhite_esc: Like skiptowhite(), but also skip escaped chars','line_number':1046,'multiline':False]
['text':'/','line_number':1047,'multiline':False]
['text':'/ @param p','line_number':1048,'multiline':False]
['text':'/','line_number':1049,'multiline':False]
['text':'/ @return Pointer to the next whitespace character.','line_number':1050,'multiline':False]
['text':'/ Skip over text until '\n' or NUL.','line_number':1063,'multiline':False]
['text':'/','line_number':1064,'multiline':False]
['text':'/ @param[in]  p  Text to skip over.','line_number':1065,'multiline':False]
['text':'/','line_number':1066,'multiline':False]
['text':'/ @return Pointer to the next '\n' or NUL character.','line_number':1067,'multiline':False]
['text':'/ Gets a number from a string and skips over it, signalling overflow.','line_number':1075,'multiline':False]
['text':'/','line_number':1076,'multiline':False]
['text':'/ @param[out]  pp  A pointer to a pointer to char.','line_number':1077,'multiline':False]
['text':'/                  It will be advanced past the read number.','line_number':1078,'multiline':False]
['text':'/ @param[out]  nr  Number read from the string.','line_number':1079,'multiline':False]
['text':'/','line_number':1080,'multiline':False]
['text':'/ @return true on success, false on error/overflow','line_number':1081,'multiline':False]
['text':'/ Gets a number from a string and skips over it.','line_number':1092,'multiline':False]
['text':'/','line_number':1093,'multiline':False]
['text':'/ @param[out]  pp  Pointer to a pointer to char.','line_number':1094,'multiline':False]
['text':'/                  It will be advanced past the read number.','line_number':1095,'multiline':False]
['text':'/ @param strict    Abort on overflow.','line_number':1096,'multiline':False]
['text':'/ @param def       Default value, if parsing fails or overflow occurs.','line_number':1097,'multiline':False]
['text':'/','line_number':1098,'multiline':False]
['text':'/ @return Number read from the string, or `def` on parse failure or overflow.','line_number':1099,'multiline':False]
['text':'/ Gets an int number from a string.','line_number':1110,'multiline':False]
['text':'/','line_number':1111,'multiline':False]
['text':'/ @see getdigits','line_number':1112,'multiline':False]
['text':'/ Gets a long number from a string.','line_number':1126,'multiline':False]
['text':'/','line_number':1127,'multiline':False]
['text':'/ @see getdigits','line_number':1128,'multiline':False]
['text':'/ Gets a int32_t number from a string.','line_number':1142,'multiline':False]
['text':'/','line_number':1143,'multiline':False]
['text':'/ @see getdigits','line_number':1144,'multiline':False]
['text':'/ Check that "lbuf" is empty or only contains blanks.','line_number':1158,'multiline':False]
['text':'/','line_number':1159,'multiline':False]
['text':'/ @param  lbuf  line buffer to check','line_number':1160,'multiline':False]
['text':'/ Convert a string into a long and/or unsigned long, taking care of','line_number':1168,'multiline':False]
['text':'/ hexadecimal, octal and binary numbers.  Accepts a '-' sign.','line_number':1169,'multiline':False]
['text':'/ If "prep" is not NULL, returns a flag to indicate the type of the number:','line_number':1170,'multiline':False]
['text':'/   0      decimal','line_number':1171,'multiline':False]
['text':'/   '0'    octal','line_number':1172,'multiline':False]
['text':'/   'O'    octal','line_number':1173,'multiline':False]
['text':'/   'o'    octal','line_number':1174,'multiline':False]
['text':'/   'B'    bin','line_number':1175,'multiline':False]
['text':'/   'b'    bin','line_number':1176,'multiline':False]
['text':'/   'X'    hex','line_number':1177,'multiline':False]
['text':'/   'x'    hex','line_number':1178,'multiline':False]
['text':'/ If "len" is not NULL, the length of the number in characters is returned.','line_number':1179,'multiline':False]
['text':'/ If "nptr" is not NULL, the signed result is returned in it.','line_number':1180,'multiline':False]
['text':'/ If "unptr" is not NULL, the unsigned result is returned in it.','line_number':1181,'multiline':False]
['text':'/ If "what" contains STR2NR_BIN recognize binary numbers.','line_number':1182,'multiline':False]
['text':'/ If "what" contains STR2NR_OCT recognize octal numbers.','line_number':1183,'multiline':False]
['text':'/ If "what" contains STR2NR_HEX recognize hex numbers.','line_number':1184,'multiline':False]
['text':'/ If "what" contains STR2NR_FORCE always assume bin/oct/hex.','line_number':1185,'multiline':False]
['text':'/ If "what" contains STR2NR_QUOTE ignore embedded single quotes','line_number':1186,'multiline':False]
['text':'/ If maxlen > 0, check at a maximum maxlen chars.','line_number':1187,'multiline':False]
['text':'/ If strict is true, check the number strictly. return *len = 0 if fail.','line_number':1188,'multiline':False]
['text':'/','line_number':1189,'multiline':False]
['text':'/ @param start','line_number':1190,'multiline':False]
['text':'/ @param prep Returns guessed type of number 0 = decimal, 'x' or 'X' is','line_number':1191,'multiline':False]
['text':'/             hexadecimal, '0', 'o' or 'O' is octal, 'b' or 'B' is binary.','line_number':1192,'multiline':False]
['text':'/             When using STR2NR_FORCE is always zero.','line_number':1193,'multiline':False]
['text':'/ @param len Returns the detected length of number.','line_number':1194,'multiline':False]
['text':'/ @param what Recognizes what number passed, @see ChStr2NrFlags.','line_number':1195,'multiline':False]
['text':'/ @param nptr Returns the signed result.','line_number':1196,'multiline':False]
['text':'/ @param unptr Returns the unsigned result.','line_number':1197,'multiline':False]
['text':'/ @param maxlen Max length of string to check.','line_number':1198,'multiline':False]
['text':'/ @param strict If true, fail if the number has unexpected trailing','line_number':1199,'multiline':False]
['text':'/               alphanumeric chars: *len is set to 0 and nothing else is','line_number':1200,'multiline':False]
['text':'/               returned.','line_number':1201,'multiline':False]
['text':'/ @param overflow When not NULL, set to true for overflow.','line_number':1202,'multiline':False]
['text':' default is decimal','line_number':1211,'multiline':False]
['text':' When forcing main consideration is skipping the prefix. Decimal numbers','line_number':1224,'multiline':False]
['text':' have no prefixes to skip. pre is not set.','line_number':1225,'multiline':False]
['text':' Make STR2NR_OOCT work the same as STR2NR_OCT when forcing.','line_number':1243,'multiline':False]
['text':' Detect hexadecimal: 0x or 0X followed by hex digit.','line_number':1263,'multiline':False]
['text':' Detect binary: 0b or 0B followed by 0 or 1.','line_number':1271,'multiline':False]
['text':' Detect octal: 0o or 0O followed by octal digits (without '8' or '9').','line_number':1279,'multiline':False]
['text':' Detect old octal format: 0 followed by octal digits.','line_number':1287,'multiline':False]
['text':' Do the conversion manually to avoid sscanf() quirks.','line_number':1304,'multiline':False]
['text':' Should’ve used goto earlier.','line_number':1305,'multiline':False]
['text':' avoid ubsan error for overflow ','line_number':1321,'multiline':True]
['text':' Check for an alphanumeric character immediately following, that is','line_number':1350,'multiline':False]
['text':' most likely a typo.','line_number':1351,'multiline':False]
['text':' account for leading '-' for decimal numbers','line_number':1365,'multiline':False]
['text':' avoid ubsan error for overflow','line_number':1366,'multiline':False]
['text':'/ Return the value of a single hex character.','line_number':1392,'multiline':False]
['text':'/ Only valid when the argument is '0' - '9', 'A' - 'F' or 'a' - 'f'.','line_number':1393,'multiline':False]
['text':'/','line_number':1394,'multiline':False]
['text':'/ @param c','line_number':1395,'multiline':False]
['text':'/','line_number':1396,'multiline':False]
['text':'/ @return The value of the hex character.','line_number':1397,'multiline':False]
['text':'/ Convert two hex characters to a byte.','line_number':1411,'multiline':False]
['text':'/','line_number':1412,'multiline':False]
['text':'/ @return  -1 if one of the characters is not hex.','line_number':1413,'multiline':False]
['text':'/ Check that "str" starts with a backslash that should be removed.','line_number':1423,'multiline':False]
['text':'/ For Windows this is only done when the character after the','line_number':1424,'multiline':False]
['text':'/ backslash is not a normal file name character.','line_number':1425,'multiline':False]
['text':'/ '$' is a valid file name character, we don't remove the backslash before','line_number':1426,'multiline':False]
['text':'/ it.  This means it is not possible to use an environment variable after a','line_number':1427,'multiline':False]
['text':'/ backslash.  "C:\$VIM\doc" is taken literally, only "$VIM\doc" works.','line_number':1428,'multiline':False]
['text':'/ Although "\ name" is valid, the backslash in "Program\ files" must be','line_number':1429,'multiline':False]
['text':'/ removed.  Assume a file name doesn't start with a space.','line_number':1430,'multiline':False]
['text':'/ For multi-byte names, never remove a backslash before a non-ascii','line_number':1431,'multiline':False]
['text':'/ character, assume that all multi-byte characters are valid file name','line_number':1432,'multiline':False]
['text':'/ characters.','line_number':1433,'multiline':False]
['text':'/','line_number':1434,'multiline':False]
['text':'/ @param  str  file path string to check','line_number':1435,'multiline':False]
['text':' ifdef BACKSLASH_IN_FILENAME','line_number':1448,'multiline':False]
['text':' ifdef BACKSLASH_IN_FILENAME','line_number':1450,'multiline':False]
['text':'/ Halve the number of backslashes in a file name argument.','line_number':1453,'multiline':False]
['text':'/','line_number':1454,'multiline':False]
['text':'/ @param p','line_number':1455,'multiline':False]
['text':'/ backslash_halve() plus save the result in allocated memory.','line_number':1465,'multiline':False]
['text':'/','line_number':1466,'multiline':False]
['text':'/ @param p','line_number':1467,'multiline':False]
['text':'/','line_number':1468,'multiline':False]
['text':'/ @return String with the number of backslashes halved.','line_number':1469,'multiline':False]
['text':' TODO(philix): simplify and improve backslash_halve_save algorithm','line_number':1473,'multiline':False]
