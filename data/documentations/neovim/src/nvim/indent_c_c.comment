['text':' Find result cache for cpp_baseclass','line_number':28,'multiline':False]
['text':' Find the start of a comment, not knowing if we are in a comment right now.','line_number':37,'multiline':False]
['text':' Search starts at w_cursor.lnum and goes backwards.','line_number':38,'multiline':False]
['text':' Return NULL when not inside a comment.','line_number':39,'multiline':False]
['text':' XXX','line_number':40,'multiline':False]
['text':' XXX','line_number':45,'multiline':False]
['text':' Check if the comment start we found is inside a string.','line_number':56,'multiline':False]
['text':' If it is then restrict the search to below this line and try again.','line_number':57,'multiline':False]
['text':'/ Find the start of a comment or raw string, not knowing if we are in a','line_number':70,'multiline':False]
['text':'/ comment or raw string right now.','line_number':71,'multiline':False]
['text':'/ Search starts at w_cursor.lnum and goes backwards.','line_number':72,'multiline':False]
['text':'/ If is_raw is given and returns start of raw_string, sets it to true.','line_number':73,'multiline':False]
['text':'/','line_number':74,'multiline':False]
['text':'/ @returns NULL when not inside a comment or raw string.','line_number':75,'multiline':False]
['text':'/','line_number':76,'multiline':False]
['text':'/ @note "CORS" -> Comment Or Raw String','line_number':77,'multiline':False]
['text':' XXX','line_number':80,'multiline':False]
['text':' Need to make a copy of the static pos in findmatchlimit(),','line_number':85,'multiline':False]
['text':' calling find_start_rawstring() may change it.','line_number':86,'multiline':False]
['text':' If comment_pos is before rs_pos the raw string is inside the comment.','line_number':92,'multiline':False]
['text':' If rs_pos is before comment_pos the comment is inside the raw string.','line_number':93,'multiline':False]
['text':' Find the start of a raw string, not knowing if we are in one right now.','line_number':103,'multiline':False]
['text':' Search starts at w_cursor.lnum and goes backwards.','line_number':104,'multiline':False]
['text':' Return NULL when not inside a raw string.','line_number':105,'multiline':False]
['text':' XXX','line_number':106,'multiline':False]
['text':' Check if the raw string start we found is inside a string.','line_number':117,'multiline':False]
['text':' If it is then restrict the search to below this line and try again.','line_number':118,'multiline':False]
['text':' Skip to the end of a "string" and a 'c' character.','line_number':131,'multiline':False]
['text':' If there is no string or character, return argument unmodified.','line_number':132,'multiline':False]
['text':' We loop, because strings may be concatenated: "date""time".','line_number':137,'multiline':False]
['text':' 'c' or '\n' or '\000'','line_number':139,'multiline':False]
['text':' ' at end of line','line_number':140,'multiline':False]
['text':' '\n' or '\000'','line_number':144,'multiline':False]
['text':' '\000'','line_number':146,'multiline':False]
['text':' check for trailing '','line_number':150,'multiline':False]
['text':' start of string','line_number':154,'multiline':False]
['text':' end of string','line_number':158,'multiline':False]
['text':' continue for another string','line_number':163,'multiline':False]
['text':' Raw string: R"[delim](...)[delim]"','line_number':166,'multiline':False]
['text':' continue for another string','line_number':181,'multiline':False]
['text':' no string found','line_number':185,'multiline':False]
['text':' backup from NUL','line_number':188,'multiline':False]
['text':'/ @returns true if "line[col]" is inside a C string.','line_number':193,'multiline':False]
['text':' Functions for C-indenting.','line_number':204,'multiline':False]
['text':' Most of this originally comes from Eric Fischer.','line_number':205,'multiline':False]
['text':' Below "XXX" means that this function may unlock the current line.','line_number':207,'multiline':False]
['text':'/ @return  true if the string "line" starts with a word from 'cinwords'.','line_number':209,'multiline':False]
['text':' Skip over white space and C comments within the line.','line_number':232,'multiline':False]
['text':' Also skip over Perl/shell comments if desired.','line_number':233,'multiline':False]
['text':' Perl/shell # comment comment continues until eol.  Require a space','line_number':241,'multiline':False]
['text':' before # to avoid recognizing $#array.','line_number':242,'multiline':False]
['text':' slash-slash comment continues till eol','line_number':251,'multiline':False]
['text':' skip slash-star comment','line_number':258,'multiline':False]
['text':'/ Return true if there is no code at *s.  White space and comments are','line_number':268,'multiline':False]
['text':'/ not considered code.','line_number':269,'multiline':False]
['text':' Check previous lines for a "//" line comment, skipping over blank lines.','line_number':275,'multiline':False]
['text':' XXX','line_number':276,'multiline':False]
['text':'/ Checks if `text` starts with "key:".','line_number':297,'multiline':False]
['text':' can be 'key': or "key":','line_number':304,'multiline':False]
['text':' need at least one ID character','line_number':308,'multiline':False]
['text':' "::" is not a label, it's C++','line_number':321,'multiline':False]
['text':'/ Checks if string matches "label:"; move to character after ':' if true.','line_number':325,'multiline':False]
['text':'/ "*s" must point to the start of the label, if there is one.','line_number':326,'multiline':False]
['text':' need at least one ID character','line_number':330,'multiline':False]
['text':' "::" is not a label, it's C++','line_number':340,'multiline':False]
['text':' Recognize a label: "label:".','line_number':344,'multiline':False]
['text':' Note: curwin->w_cursor must be where we are looking for the label.','line_number':345,'multiline':False]
['text':' XXX','line_number':346,'multiline':False]
['text':' Exclude "default" from labels, since it should be indented','line_number':350,'multiline':False]
['text':' like a switch label.  Same for C++ scope declarations.','line_number':351,'multiline':False]
['text':' Only accept a label if the previous line is terminated or is a case','line_number':363,'multiline':False]
['text':' label.','line_number':364,'multiline':False]
['text':' If we're in a comment or raw string now, skip to the start of','line_number':373,'multiline':False]
['text':' it.','line_number':374,'multiline':False]
['text':' XXX','line_number':376,'multiline':False]
['text':' ignore #defines, #if, etc.','line_number':381,'multiline':False]
['text':' label at start of file???','line_number':398,'multiline':False]
['text':' Recognize structure initialization and enumerations:','line_number':401,'multiline':False]
['text':' "[typedef] [static|public|protected|private] enum"','line_number':402,'multiline':False]
['text':' "[typedef] [static|public|protected|private] = {"','line_number':403,'multiline':False]
['text':'/ Recognize a switch label: "case .*:" or "default:".','line_number':442,'multiline':False]
['text':'/','line_number':443,'multiline':False]
['text':'/ @param strict  Allow relaxed check of case statement for JS','line_number':444,'multiline':False]
['text':' skip over "::" for C++','line_number':455,'multiline':False]
['text':' skip over ':'','line_number':462,'multiline':False]
['text':' stop at comment','line_number':464,'multiline':False]
['text':' JS etc.','line_number':466,'multiline':False]
['text':' stop at string','line_number':468,'multiline':False]
['text':' Recognize a "default" switch label.','line_number':482,'multiline':False]
['text':'/ Recognize a scope declaration label set in 'cinscopedecls'.','line_number':490,'multiline':False]
['text':' Maximum number of lines to search back for a "namespace" line.','line_number':516,'multiline':False]
['text':' Recognize a "namespace" scope declaration.','line_number':519,'multiline':False]
['text':' skip over "inline" and "export" in any order','line_number':528,'multiline':False]
['text':' found end of a name','line_number':538,'multiline':False]
['text':' word character after skipping past name','line_number':545,'multiline':False]
['text':' C++ 17 nested namespace','line_number':552,'multiline':False]
['text':' Return a pointer to the first non-empty non-comment character after a ':'.','line_number':563,'multiline':False]
['text':' Return NULL if not found.','line_number':564,'multiline':False]
['text':'        case 234:    a = b;','line_number':565,'multiline':False]
['text':'                     ^','line_number':566,'multiline':False]
['text':' skip over "::" for C++','line_number':571,'multiline':False]
['text':' skip over 'x'','line_number':577,'multiline':False]
['text':' Get indent of line "lnum", skipping a label.','line_number':590,'multiline':False]
['text':' Return 0 if there is nothing after the label.','line_number':591,'multiline':False]
['text':' XXX','line_number':592,'multiline':False]
['text':' Find indent for line "lnum", ignoring any case or jump label.','line_number':611,'multiline':False]
['text':' Also return a pointer to the text (after the label) in "pp".','line_number':612,'multiline':False]
['text':'   label:     if (asdf && asdfasdf)','line_number':613,'multiline':False]
['text':'              ^','line_number':614,'multiline':False]
['text':' XXX','line_number':624,'multiline':False]
['text':' just in case','line_number':628,'multiline':False]
['text':' Return the indent of the first variable name after a type in a declaration.','line_number':641,'multiline':False]
['text':'  int     a,                  indent of "a"','line_number':642,'multiline':False]
['text':'  static struct foo    b,     indent of "b"','line_number':643,'multiline':False]
['text':'  enum bla    c,              indent of "c"','line_number':644,'multiline':False]
['text':' Returns zero when it doesn't look like a declaration.','line_number':645,'multiline':False]
['text':' Return the indent of the first non-blank after an equal sign.','line_number':686,'multiline':False]
['text':'       char *foo = "here";','line_number':687,'multiline':False]
['text':' Return zero if no (useful) equal sign found.','line_number':688,'multiline':False]
['text':' Return -1 if the line above "lnum" ends in a backslash.','line_number':689,'multiline':False]
['text':'      foo = "asdf{backslash}','line_number':690,'multiline':False]
['text':'             asdf{backslash}','line_number':691,'multiline':False]
['text':'             here";','line_number':692,'multiline':False]
['text':' ignore comments','line_number':710,'multiline':False]
['text':' nice alignment for continued strings','line_number':725,'multiline':False]
['text':' Recognize a preprocessor statement: Any line that starts with '#'.','line_number':735,'multiline':False]
['text':'/ Return true if line "*pp" at "*lnump" is a preprocessor statement or a','line_number':744,'multiline':False]
['text':'/ continuation line of a preprocessor statement.  Decrease "*lnump" to the','line_number':745,'multiline':False]
['text':'/ start and return the line in "*pp".','line_number':746,'multiline':False]
['text':'/ Put the amount of indent in "*amount".','line_number':747,'multiline':False]
['text':' Recognize the start of a C or C++ comment.','line_number':783,'multiline':False]
['text':' Recognize the start of a "//" comment.','line_number':789,'multiline':False]
['text':'/ Recognize a line that starts with '{' or '}', or ends with ';', ',', '{' or','line_number':795,'multiline':False]
['text':'/ '}'.','line_number':796,'multiline':False]
['text':'/ Don't consider "} else" a terminated line.','line_number':797,'multiline':False]
['text':'/ If a line begins with an "else", only consider it terminated if no unmatched','line_number':798,'multiline':False]
['text':'/ opening braces follow (handle "else { foo();" correctly).','line_number':799,'multiline':False]
['text':'/','line_number':800,'multiline':False]
['text':'/ @param incl_open   include '{' at the end as terminator','line_number':801,'multiline':False]
['text':'/ @param incl_comma  recognize a trailing comma','line_number':802,'multiline':False]
['text':'/','line_number':803,'multiline':False]
['text':'/ @return  the character terminating the line (ending char's have precedence if','line_number':804,'multiline':False]
['text':'/          both apply in order to determine initializations).','line_number':805,'multiline':False]
['text':' skip over comments, "" strings and 'c'haracters','line_number':823,'multiline':False]
['text':'/ Recognizes the basic picture of a function declaration -- it needs to','line_number':847,'multiline':False]
['text':'/ have an open paren somewhere and a close paren at the end of the line and','line_number':848,'multiline':False]
['text':'/ no semicolons anywhere.','line_number':849,'multiline':False]
['text':'/ When a line ends in a comma we continue looking in the next line.','line_number':850,'multiline':False]
['text':'/','line_number':851,'multiline':False]
['text':'/ @param[in]  sp  Points to a string with the line. When looking at other','line_number':852,'multiline':False]
['text':'/                 lines it must be restored to the line. When it's NULL fetch','line_number':853,'multiline':False]
['text':'/                 lines here.','line_number':854,'multiline':False]
['text':'/ @param[in]  first_lnum Where to start looking.','line_number':855,'multiline':False]
['text':'/ @param[in]  min_lnum The line before which we will not be looking.','line_number':856,'multiline':False]
['text':' Ignore line starting with #.','line_number':884,'multiline':False]
['text':' ignore comments','line_number':890,'multiline':False]
['text':' To avoid a mistake in the following situation:','line_number':897,'multiline':False]
['text':' A::A(int a, int b)','line_number':898,'multiline':False]
['text':'     : a(0)  // <--not a function decl','line_number':899,'multiline':False]
['text':'     , b(0)','line_number':900,'multiline':False]
['text':' {...','line_number':901,'multiline':False]
['text':' ';', ' or "  before any () or no '('','line_number':909,'multiline':False]
['text':' ')' at the end: may have found a match','line_number':914,'multiline':False]
['text':' Check for the previous line not to end in a backslash:','line_number':915,'multiline':False]
['text':'       #if defined(x) && {backslash}','line_number':916,'multiline':False]
['text':'           defined(y)','line_number':917,'multiline':False]
['text':' ',' at the end: continue looking in the next line.','line_number':928,'multiline':False]
['text':' At the end: check for ',' in the next line, for this style:','line_number':929,'multiline':False]
['text':' func(arg1','line_number':930,'multiline':False]
['text':'       , arg2)','line_number':931,'multiline':False]
['text':' Require a comma at end of the line or a comma or ')' at the','line_number':944,'multiline':False]
['text':' start of next line.','line_number':945,'multiline':False]
['text':' ignore comments','line_number':951,'multiline':False]
['text':' accept "} else"','line_number':974,'multiline':False]
['text':' Check if this is a "while" that should have a matching "do".','line_number':985,'multiline':False]
['text':' We only accept a "while (condition) ;", with only white space between the','line_number':986,'multiline':False]
['text':' ')' and ';'. The condition may be spread over several lines.','line_number':987,'multiline':False]
['text':' XXX','line_number':988,'multiline':False]
['text':' accept "} while (cond);"','line_number':995,'multiline':False]
['text':' skip any '}', until the 'w' of the "while"','line_number':1003,'multiline':False]
['text':' Check whether in "p" there is an "if", "for" or "while" before "*poffset".','line_number':1016,'multiline':False]
['text':' Return 0 if there is none.','line_number':1017,'multiline':False]
['text':' Otherwise return !0 and update "*poffset" to point to the place where the','line_number':1018,'multiline':False]
['text':' string was found.','line_number':1019,'multiline':False]
['text':'/ Return true if we are at the end of a do-while.','line_number':1059,'multiline':False]
['text':'/    do','line_number':1060,'multiline':False]
['text':'/       nothing;','line_number':1061,'multiline':False]
['text':'/    while (foo','line_number':1062,'multiline':False]
['text':'/             && bar);  <-- here','line_number':1063,'multiline':False]
['text':'/ Adjust the cursor to the line with "while".','line_number':1064,'multiline':False]
['text':' there must be a ';' at the end','line_number':1073,'multiline':False]
['text':' Found ");" at end of the line, now check there is "while"','line_number':1083,'multiline':False]
['text':' before the matching '('.  XXX','line_number':1084,'multiline':False]
['text':' accept "} while (cond);"','line_number':1090,'multiline':False]
['text':' Searching may have made "line" invalid, get it again.','line_number':1099,'multiline':False]
['text':' Find the position of a C++ base-class declaration or','line_number':1116,'multiline':False]
['text':' constructor-initialization. eg:','line_number':1117,'multiline':False]
['text':'','line_number':1118,'multiline':False]
['text':' class MyClass :','line_number':1119,'multiline':False]
['text':'      baseClass               <-- here','line_number':1120,'multiline':False]
['text':' class MyClass : public baseClass,','line_number':1121,'multiline':False]
['text':'      anotherBaseClass        <-- here (should probably lineup ??)','line_number':1122,'multiline':False]
['text':' MyClass::MyClass(...) :','line_number':1123,'multiline':False]
['text':'      baseClass(...)          <-- here (constructor-initialization)','line_number':1124,'multiline':False]
['text':'','line_number':1125,'multiline':False]
['text':' This is a lot of guessing.  Watch out for "cond ? func() : foo".','line_number':1126,'multiline':False]
['text':' find position','line_number':1129,'multiline':False]
['text':' Use the cached result','line_number':1136,'multiline':False]
['text':' skip #define FOO x ? (x) : x','line_number':1142,'multiline':False]
['text':' Search for a line starting with '#', empty, ending in ';' or containing','line_number':1152,'multiline':False]
['text':' '{' or '}' and start below it.  This handles the following situations:','line_number':1153,'multiline':False]
['text':'    a = cond ?','line_number':1154,'multiline':False]
['text':'          func() :','line_number':1155,'multiline':False]
['text':'               asdf;','line_number':1156,'multiline':False]
['text':'    func::foo()','line_number':1157,'multiline':False]
['text':'          : something','line_number':1158,'multiline':False]
['text':'    {}','line_number':1159,'multiline':False]
['text':'    Foo::Foo (int one, int two)','line_number':1160,'multiline':False]
['text':'            : something(4),','line_number':1161,'multiline':False]
['text':'            somethingelse(3)','line_number':1162,'multiline':False]
['text':'    {}','line_number':1163,'multiline':False]
['text':' Continue in the cursor line.','line_number':1194,'multiline':False]
['text':' don't recognize "case (foo):" as a baseclass */','line_number':1199,'multiline':False]
['text':' skip double colon. It can't be a constructor','line_number':1213,'multiline':False]
['text':' initialization any more','line_number':1214,'multiline':False]
['text':' we have something found, that looks like the start of','line_number':1218,'multiline':False]
['text':' cpp-base-class-declaration or constructor-initialization','line_number':1219,'multiline':False]
['text':' Constructor-initialization is assumed if we come across','line_number':1241,'multiline':False]
['text':' something like "):"','line_number':1242,'multiline':False]
['text':' Avoid seeing '() :' after '?' as constructor init.','line_number':1246,'multiline':False]
['text':' if it is not an identifier, we are wrong','line_number':1249,'multiline':False]
['text':' it can't be a constructor-initialization any more','line_number':1253,'multiline':False]
['text':' the first statement starts here: lineup with this one...','line_number':1256,'multiline':False]
['text':' When the line ends in a comma don't align with it.','line_number':1262,'multiline':False]
['text':' XXX','line_number':1288,'multiline':False]
['text':'/ Return true if string "s" ends with the string "find", possibly followed by','line_number':1304,'multiline':False]
['text':'/ white space and comments.  Skip strings and comments.','line_number':1305,'multiline':False]
['text':'/ Ignore "ignore" after "find" if it's not NULL.','line_number':1306,'multiline':False]
['text':'/ Return true when "s" starts with "word" and then a non-ID character.','line_number':1331,'multiline':False]
['text':'/ Recognize a `extern "C"` or `extern "C++"` linkage specifications.','line_number':1339,'multiline':False]
['text':' Skip strings, chars and comments until at or past "trypos".','line_number':1375,'multiline':False]
['text':' Return the column found.','line_number':1376,'multiline':False]
['text':' Find the '{' at the start of the block we are in.','line_number':1400,'multiline':False]
['text':' Return NULL if no match found.','line_number':1401,'multiline':False]
['text':' Ignore a '{' that is in a comment, makes indenting the next three lines','line_number':1402,'multiline':False]
['text':' work.','line_number':1403,'multiline':False]
['text':' foo()','line_number':1404,'multiline':False]
['text':' {','line_number':1405,'multiline':False]
['text':' }','line_number':1406,'multiline':False]
['text':' XXX','line_number':1408,'multiline':False]
['text':' copy pos_T, next findmatch will change it','line_number':1417,'multiline':False]
['text':' ignore the { if it's in a // or / *  * / comment','line_number':1421,'multiline':False]
['text':' XXX','line_number':1423,'multiline':False]
['text':'/ Find the matching '(', ignoring it if it is in a comment.','line_number':1434,'multiline':False]
['text':'/ @returns NULL or the found match.','line_number':1435,'multiline':False]
['text':' check if the ( is in a // comment','line_number':1452,'multiline':False]
['text':' XXX','line_number':1457,'multiline':False]
['text':' copy trypos, findmatch will change it','line_number':1464,'multiline':False]
['text':' XXX','line_number':1467,'multiline':False]
['text':'/ Find the matching '(', ignoring it if it is in a comment or before an','line_number':1481,'multiline':False]
['text':'/ unmatched {.','line_number':1482,'multiline':False]
['text':'/ @returns NULL or the found match.','line_number':1483,'multiline':False]
['text':' If both an unmatched '(' and '{' is found.  Ignore the '('','line_number':1492,'multiline':False]
['text':' position if the '{' is further down.','line_number':1493,'multiline':False]
['text':' Return ind_maxparen corrected for the difference in line number between the','line_number':1503,'multiline':False]
['text':' cursor position and "startpos".  This makes sure that searching for a','line_number':1504,'multiline':False]
['text':' matching paren above the cursor line doesn't find a match because of','line_number':1505,'multiline':False]
['text':' looking a few lines further.','line_number':1506,'multiline':False]
['text':' Set w_cursor.col to the column number of the last unmatched ')' or '{' in','line_number':1517,'multiline':False]
['text':' line "l".  "l" must point to the start of the line.','line_number':1518,'multiline':False]
['text':' default is start of line','line_number':1525,'multiline':False]
['text':' ignore parens in comments','line_number':1528,'multiline':False]
['text':' ignore parens in quotes','line_number':1529,'multiline':False]
['text':' Parse 'cinoptions' and set the values in "curbuf".','line_number':1544,'multiline':False]
['text':' Must be called when 'cinoptions', 'shiftwidth' and/or 'tabstop' changes.','line_number':1545,'multiline':False]
['text':' Set the default values.','line_number':1554,'multiline':False]
['text':' Spaces from a block's opening brace the prevailing indent for that','line_number':1555,'multiline':False]
['text':' block should be.','line_number':1556,'multiline':False]
['text':' Spaces from the edge of the line an open brace that's at the end of a','line_number':1559,'multiline':False]
['text':' line is imagined to be.','line_number':1560,'multiline':False]
['text':' Spaces from the prevailing indent for a line that is not preceded by','line_number':1563,'multiline':False]
['text':' an opening brace.','line_number':1564,'multiline':False]
['text':' Column where the first { of a function should be located }.','line_number':1567,'multiline':False]
['text':' Spaces from the prevailing indent a leftmost open brace should be','line_number':1570,'multiline':False]
['text':' located.','line_number':1571,'multiline':False]
['text':' Spaces from the matching open brace (real location for one at the left','line_number':1574,'multiline':False]
['text':' edge; imaginary location from one that ends a line) the matching close','line_number':1575,'multiline':False]
['text':' brace should be located.','line_number':1576,'multiline':False]
['text':' Spaces from the edge of the line an open brace sitting in the leftmost','line_number':1579,'multiline':False]
['text':' column is imagined to be.','line_number':1580,'multiline':False]
['text':' Spaces jump labels should be shifted to the left if N is non-negative,','line_number':1583,'multiline':False]
['text':' otherwise the jump label will be put to column 1.','line_number':1584,'multiline':False]
['text':' Spaces from the switch() indent a "case xx" label should be located.','line_number':1587,'multiline':False]
['text':' Spaces from the "case xx:" code after a switch() should be located.','line_number':1590,'multiline':False]
['text':' Lineup break at end of case in switch() with case label.','line_number':1593,'multiline':False]
['text':' Spaces from the class declaration indent a scope declaration label','line_number':1596,'multiline':False]
['text':' should be located.','line_number':1597,'multiline':False]
['text':' Spaces from the scope declaration label code should be located.','line_number':1600,'multiline':False]
['text':' Amount K&R-style parameters should be indented.','line_number':1603,'multiline':False]
['text':' Amount a function type spec should be indented.','line_number':1606,'multiline':False]
['text':' Amount a cpp base class declaration or constructor initialization','line_number':1609,'multiline':False]
['text':' should be indented.','line_number':1610,'multiline':False]
['text':' additional spaces beyond the prevailing indent a continuation line','line_number':1613,'multiline':False]
['text':' should be located.','line_number':1614,'multiline':False]
['text':' Spaces from the indent of the line with an unclosed parentheses.','line_number':1617,'multiline':False]
['text':' Spaces from the indent of the line with an unclosed parentheses, which','line_number':1620,'multiline':False]
['text':' itself is also unclosed.','line_number':1621,'multiline':False]
['text':' Suppress ignoring spaces from the indent of a line starting with an','line_number':1624,'multiline':False]
['text':' unclosed parenthesis.','line_number':1625,'multiline':False]
['text':' If the opening paren is the last nonwhite character on the line, and','line_number':1628,'multiline':False]
['text':' b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer','line_number':1629,'multiline':False]
['text':' context (for very long lines).','line_number':1630,'multiline':False]
['text':' Suppress ignoring white space when lining up with the character after','line_number':1633,'multiline':False]
['text':' an unclosed parentheses.','line_number':1634,'multiline':False]
['text':' Indent a closing parenthesis under the line start of the matching','line_number':1637,'multiline':False]
['text':' opening parenthesis.','line_number':1638,'multiline':False]
['text':' Indent a closing parenthesis under the previous line.','line_number':1641,'multiline':False]
['text':' Extra indent for comments.','line_number':1644,'multiline':False]
['text':' Spaces from the comment opener when there is nothing after it.','line_number':1647,'multiline':False]
['text':' Boolean: if non-zero, use b_ind_in_comment even if there is something','line_number':1650,'multiline':False]
['text':' after the comment opener.','line_number':1651,'multiline':False]
['text':' Max lines to search for an open paren.','line_number':1654,'multiline':False]
['text':' Max lines to search for an open comment.','line_number':1657,'multiline':False]
['text':' Handle braces for java code.','line_number':1660,'multiline':False]
['text':' Not to confuse JS object properties with labels.','line_number':1663,'multiline':False]
['text':' Handle blocked cases correctly.','line_number':1666,'multiline':False]
['text':' Handle C++ namespace.','line_number':1669,'multiline':False]
['text':' Handle continuation lines containing conditions of if(), for() and','line_number':1672,'multiline':False]
['text':' while().','line_number':1673,'multiline':False]
['text':' indentation for # comments','line_number':1676,'multiline':False]
['text':' Handle C++ extern "C" or "C++"','line_number':1679,'multiline':False]
['text':' Handle C #pragma directives','line_number':1682,'multiline':False]
['text':' remember where the digits start','line_number':1690,'multiline':False]
['text':' ".5s" means a fraction.','line_number':1693,'multiline':False]
['text':' "2s" means two times 'shiftwidth'.','line_number':1704,'multiline':False]
['text':' just "s" is one 'shiftwidth'.','line_number':1706,'multiline':False]
['text':' When adding an entry here, also update the default 'cinoptions' in','line_number':1719,'multiline':False]
['text':' doc/indent.txt, and add explanation for it!','line_number':1720,'multiline':False]
['text':' Return the desired indent for C code.','line_number':1840,'multiline':False]
['text':' Return -1 if the indent should be left alone (inside a raw string).','line_number':1841,'multiline':False]
['text':' '{' is in column 0','line_number':1858,'multiline':False]
['text':' '{' is at start of line','line_number':1859,'multiline':False]
['text':' '{' is at end of line','line_number':1860,'multiline':False]
['text':' amount for continuation line','line_number':1885,'multiline':False]
['text':' make a copy, value is changed below','line_number':1891,'multiline':False]
['text':' remember where the cursor was when we started','line_number':1894,'multiline':False]
['text':' if we are at line 1 zero indent is fine, right?','line_number':1897,'multiline':False]
['text':' Get a copy of the current contents of the line.','line_number':1902,'multiline':False]
['text':' This is required, because only the most recent line obtained with','line_number':1903,'multiline':False]
['text':' ml_get is valid!','line_number':1904,'multiline':False]
['text':' In insert mode and the cursor is on a ')' truncate the line at the','line_number':1907,'multiline':False]
['text':' cursor position.  We don't want to line up with the matching '(' when','line_number':1908,'multiline':False]
['text':' inserting new stuff.','line_number':1909,'multiline':False]
['text':' For unknown reasons the cursor might be past the end of the line, thus','line_number':1910,'multiline':False]
['text':' check for that.','line_number':1911,'multiline':False]
['text':' move the cursor to the start of the line','line_number':1920,'multiline':False]
['text':' XXX','line_number':1924,'multiline':False]
['text':' If we are inside a raw string don't change the indent.','line_number':1926,'multiline':False]
['text':' Ignore a raw string inside a comment.','line_number':1927,'multiline':False]
['text':' findmatchlimit() static pos is overwritten, make a copy','line_number':1930,'multiline':False]
['text':' #defines and so on go at the left when included in 'cinkeys',','line_number':1940,'multiline':False]
['text':' excluding pragmas when customized in 'cinoptions'','line_number':1941,'multiline':False]
['text':' Is it a non-case label? Then that goes at the left margin too unless:','line_number':1950,'multiline':False]
['text':'  - JS flag is set.','line_number':1951,'multiline':False]
['text':'  - 'L' item has a positive value.','line_number':1952,'multiline':False]
['text':' If we're inside a "//" comment and there is a "//" comment in a','line_number':1957,'multiline':False]
['text':' previous line, lineup with that one.','line_number':1958,'multiline':False]
['text':' XXX','line_number':1962,'multiline':False]
['text':' There may be a statement before the comment, search from the end','line_number':1964,'multiline':False]
['text':' of the line for a comment start.','line_number':1965,'multiline':False]
['text':' find how indented the line beginning the comment is','line_number':1973,'multiline':False]
['text':' If we're inside a comment and not looking at the start of the','line_number':1979,'multiline':False]
['text':' comment, try using the 'comments' option.','line_number':1980,'multiline':False]
['text':' XXX','line_number':1981,'multiline':False]
['text':' start-comment string','line_number':1984,'multiline':False]
['text':' middle-comment string','line_number':1985,'multiline':False]
['text':' end-comment string','line_number':1986,'multiline':False]
['text':' find how indented the line beginning the comment is','line_number':1992,'multiline':False]
['text':' If our line starts with the middle comment string, line it','line_number':2029,'multiline':False]
['text':' up with the comment opener per the 'comments' option.','line_number':2030,'multiline':False]
['text':' If the start comment string matches in the previous','line_number':2035,'multiline':False]
['text':' line, use the indent of that line plus offset.  If','line_number':2036,'multiline':False]
['text':' the middle comment string matches in the previous','line_number':2037,'multiline':False]
['text':' line, use the indent of that line.  XXX','line_number':2038,'multiline':False]
['text':' If the start comment string doesn't match with the','line_number':2047,'multiline':False]
['text':' start of the comment, skip this entry. XXX','line_number':2048,'multiline':False]
['text':' If our line starts with the end comment string, line it up','line_number':2060,'multiline':False]
['text':' with the middle comment','line_number':2061,'multiline':False]
['text':' XXX','line_number':2065,'multiline':False]
['text':' If our line starts with an asterisk, line up with the','line_number':2077,'multiline':False]
['text':' asterisk in the comment opener; otherwise, line up','line_number':2078,'multiline':False]
['text':' with the first character of the comment text.','line_number':2079,'multiline':False]
['text':' skip','line_number':2081,'multiline':False]
['text':' If we are more than one line away from the comment opener, take','line_number':2085,'multiline':False]
['text':' the indent of the previous non-empty line.  If 'cino' has "CO"','line_number':2086,'multiline':False]
['text':' and we are just below the comment opener and there are any','line_number':2087,'multiline':False]
['text':' white characters after it line up with the text after it;','line_number':2088,'multiline':False]
['text':' otherwise, add the amount specified by "c" in 'cino'','line_number':2089,'multiline':False]
['text':' skip blank lines','line_number':2092,'multiline':False]
['text':' XXX','line_number':2095,'multiline':False]
['text':' use the comment opener','line_number':2098,'multiline':False]
['text':' skip / and *','line_number':2101,'multiline':False]
['text':' if something after it','line_number':2102,'multiline':False]
['text':' Are we looking at a ']' that has a match?','line_number':2115,'multiline':False]
['text':' align with the line containing the '['.','line_number':2118,'multiline':False]
['text':' Are we inside parentheses or braces?','line_number':2122,'multiline':False]
['text':' XXX','line_number':2123,'multiline':False]
['text':' Both an unmatched '(' and '{' is found.  Use the one which is','line_number':2129,'multiline':False]
['text':' closer to the current cursor position, set the other to NULL.','line_number':2130,'multiline':False]
['text':' If the matching paren is more than one line away, use the indent of','line_number':2142,'multiline':False]
['text':' a previous non-empty line that matches the same paren.','line_number':2143,'multiline':False]
['text':' Line up with the start of the matching paren line.','line_number':2145,'multiline':False]
['text':' XXX','line_number':2146,'multiline':False]
['text':' skip comment lines','line_number':2151,'multiline':False]
['text':' ignore #define, #if, etc.','line_number':2155,'multiline':False]
['text':' Skip a comment or raw string. XXX','line_number':2159,'multiline':False]
['text':' XXX','line_number':2165,'multiline':False]
['text':' XXX','line_number':2169,'multiline':False]
['text':' Line up with line where the matching paren is. XXX','line_number':2183,'multiline':False]
['text':' If the line starts with a '(' or the indent for unclosed','line_number':2184,'multiline':False]
['text':' parentheses is zero, line up with the unclosed parentheses.','line_number':2185,'multiline':False]
['text':' Look for the outermost opening parenthesis on this line','line_number':2191,'multiline':False]
['text':' and check whether it belongs to an "if", "for" or "while".','line_number':2192,'multiline':False]
['text':' Ignore a '(' in front of the line that has a match before','line_number':2222,'multiline':False]
['text':' our matching '('.','line_number':2223,'multiline':False]
['text':' If we're looking at a close paren, line up right there;','line_number':2243,'multiline':False]
['text':' otherwise, line up with the next (non-white) character.','line_number':2244,'multiline':False]
['text':' When b_ind_unclosed_wrapped is set and the matching paren is','line_number':2245,'multiline':False]
['text':' the last nonwhite character of the line, use either the','line_number':2246,'multiline':False]
['text':' indent of the current line or the indentation of the next','line_number':2247,'multiline':False]
['text':' outer paren and add b_ind_unclosed_wrapped (for very long','line_number':2248,'multiline':False]
['text':' lines).','line_number':2249,'multiline':False]
['text':' look for opening unmatched paren, indent one level','line_number':2255,'multiline':False]
['text':' for each additional level','line_number':2256,'multiline':False]
['text':' In case of trailing space','line_number':2283,'multiline':False]
['text':' Find how indented the paren is, or the character after it','line_number':2291,'multiline':False]
['text':' if we did the above "if".','line_number':2292,'multiline':False]
['text':' Line up with the start of the matching paren line.','line_number':2302,'multiline':False]
['text':' Add b_ind_unclosed2 for each '(' before our matching one,','line_number':2310,'multiline':False]
['text':' but ignore (void) before the line (ignore_paren_col).','line_number':2311,'multiline':False]
['text':' Use b_ind_unclosed once, when the first '(' is not inside','line_number':2327,'multiline':False]
['text':' braces','line_number':2328,'multiline':False]
['text':' For a line starting with ')' use the minimum of the two','line_number':2344,'multiline':False]
['text':' positions, to avoid giving it more indent than the previous','line_number':2345,'multiline':False]
['text':' lines:','line_number':2346,'multiline':False]
['text':'  func_long_name(               if (x','line_number':2347,'multiline':False]
['text':'    arg                                 && yy','line_number':2348,'multiline':False]
['text':'    )         ^ not here           )    ^ not here','line_number':2349,'multiline':False]
['text':' add extra indent for a comment','line_number':2356,'multiline':False]
['text':' We are inside braces, there is a { before this line at the position','line_number':2361,'multiline':False]
['text':' stored in tryposBrace.','line_number':2362,'multiline':False]
['text':' Make a copy of tryposBrace, it may point to pos_copy inside','line_number':2363,'multiline':False]
['text':' find_start_brace(), which may be changed somewhere.','line_number':2364,'multiline':False]
['text':' Now figure out how indented the line is in general.','line_number':2371,'multiline':False]
['text':' If the brace was at the start of the line, we use that;','line_number':2372,'multiline':False]
['text':' otherwise, check out the indentation of the line as','line_number':2373,'multiline':False]
['text':' a whole and then add the "imaginary indent" to that.','line_number':2374,'multiline':False]
['text':' That opening brace might have been on a continuation','line_number':2385,'multiline':False]
['text':' line.  If so, find the start of the line.','line_number':2386,'multiline':False]
['text':' Position the cursor over the rightmost paren, so that','line_number':2389,'multiline':False]
['text':' matching it will take us back to the start of the line.','line_number':2390,'multiline':False]
['text':' It could have been something like','line_number':2397,'multiline':False]
['text':'         case 1: if (asdf &&','line_number':2398,'multiline':False]
['text':'                      ldfd) {','line_number':2399,'multiline':False]
['text':'                  }','line_number':2400,'multiline':False]
['text':' For Javascript check if the line starts with "key:".','line_number':2413,'multiline':False]
['text':' If we're looking at a closing brace, that's where','line_number':2416,'multiline':False]
['text':' we want to be.  Otherwise, add the amount of room','line_number':2417,'multiline':False]
['text':' that an indent is supposed to be.','line_number':2418,'multiline':False]
['text':' they may want closing braces to line up with something','line_number':2420,'multiline':False]
['text':' other than the open brace.  indulge them, if so.','line_number':2421,'multiline':False]
['text':' If we're looking at an "else", try to find an "if"','line_number':2424,'multiline':False]
['text':' to match it with.','line_number':2425,'multiline':False]
['text':' If we're looking at a "while", try to find a "do"','line_number':2426,'multiline':False]
['text':' to match it with.','line_number':2427,'multiline':False]
['text':' XXX','line_number':2431,'multiline':False]
['text':' XXX','line_number':2437,'multiline':False]
['text':' We get here if we are not on an "while-of-do" or "else" (or','line_number':2442,'multiline':False]
['text':' failed to find a matching "if").','line_number':2443,'multiline':False]
['text':' Search backwards for something to line up with.','line_number':2444,'multiline':False]
['text':' First set amount for when we don't find anything.','line_number':2445,'multiline':False]
['text':' if the '{' is  _really_ at the left margin, use the imaginary','line_number':2447,'multiline':False]
['text':' location of a left-margin brace.  Otherwise, correct the','line_number':2448,'multiline':False]
['text':' location for b_ind_open_extra.','line_number':2449,'multiline':False]
['text':' '{' is in column 0','line_number':2451,'multiline':False]
['text':' '{' is at start','line_number':2455,'multiline':False]
['text':' '{' is at end of line','line_number':2458,'multiline':False]
['text':' Compensate for adding b_ind_open_extra later.','line_number':2468,'multiline':False]
['text':' it's a switch() label','line_number':2478,'multiline':False]
['text':' find a previous switch() label','line_number':2479,'multiline':False]
['text':' private:, ...','line_number':2481,'multiline':False]
['text':' class decl is this block','line_number':2482,'multiline':False]
['text':' break; ...','line_number':2486,'multiline':False]
['text':' b_ind_level from start of block','line_number':2491,'multiline':False]
['text':' Search backwards.  If we find something we recognize, line up','line_number':2497,'multiline':False]
['text':' with that.','line_number':2498,'multiline':False]
['text':'','line_number':2499,'multiline':False]
['text':' If we're looking at an open brace, indent','line_number':2500,'multiline':False]
['text':' the usual amount relative to the conditional','line_number':2501,'multiline':False]
['text':' that opens the block.','line_number':2502,'multiline':False]
['text':' If we went all the way back to the start of our scope, line','line_number':2508,'multiline':False]
['text':' up with it.','line_number':2509,'multiline':False]
['text':' We reached end of scope:','line_number':2511,'multiline':False]
['text':' If looking for a enum or structure initialization','line_number':2512,'multiline':False]
['text':' go further back:','line_number':2513,'multiline':False]
['text':' If it is an initializer (enum xxx or xxx =), then','line_number':2514,'multiline':False]
['text':' don't add ind_continuation, otherwise it is a variable','line_number':2515,'multiline':False]
['text':' declaration:','line_number':2516,'multiline':False]
['text':' int x,','line_number':2517,'multiline':False]
['text':'     here; <-- add ind_continuation','line_number':2518,'multiline':False]
['text':' nothing found (abuse curbuf->b_ind_maxparen as','line_number':2523,'multiline':False]
['text':' limit) assume terminated line (i.e. a variable','line_number':2524,'multiline':False]
['text':' initialization)','line_number':2525,'multiline':False]
['text':' If we're in a comment or raw string now, skip to','line_number':2534,'multiline':False]
['text':' the start of it.','line_number':2535,'multiline':False]
['text':' Skip preprocessor directives and blank lines.','line_number':2545,'multiline':False]
['text':' If we are at top level and the line looks like a','line_number':2556,'multiline':False]
['text':' function declaration, we are done','line_number':2557,'multiline':False]
['text':' (it's a variable declaration).','line_number':2558,'multiline':False]
['text':' if the line is terminated with another ','','line_number':2561,'multiline':False]
['text':' it is a continued variable initialization.','line_number':2562,'multiline':False]
['text':' don't add extra indent.','line_number':2563,'multiline':False]
['text':' TODO(vim): does not work, if  a function','line_number':2564,'multiline':False]
['text':' declaration is split over multiple lines:','line_number':2565,'multiline':False]
['text':' cin_isfuncdecl returns false then.','line_number':2566,'multiline':False]
['text':' if it is an enum declaration or an assignment,','line_number':2571,'multiline':False]
['text':' we are done.','line_number':2572,'multiline':False]
['text':' nothing useful found','line_number':2577,'multiline':False]
['text':' Skip parens and braces. Position the cursor','line_number':2584,'multiline':False]
['text':' over the rightmost paren, so that matching it','line_number':2585,'multiline':False]
['text':' will take us back to the start of the line.','line_number':2586,'multiline':False]
['text':' XXX','line_number':2587,'multiline':False]
['text':' it's a variable declaration, add indentation','line_number':2604,'multiline':False]
['text':' like in','line_number':2605,'multiline':False]
['text':' int a,','line_number':2606,'multiline':False]
['text':'    b;','line_number':2607,'multiline':False]
['text':' Looking for C++ namespace, need to look further','line_number':2631,'multiline':False]
['text':' back.','line_number':2632,'multiline':False]
['text':' If we're in a comment or raw string now, skip','line_number':2643,'multiline':False]
['text':' to the start of it.','line_number':2644,'multiline':False]
['text':' Skip preprocessor directives and blank lines.','line_number':2654,'multiline':False]
['text':' Finally the actual check for "namespace".','line_number':2659,'multiline':False]
['text':' If we're in a comment or raw string now, skip to the start','line_number':2677,'multiline':False]
['text':' of it.','line_number':2678,'multiline':False]
['text':' XXX','line_number':2679,'multiline':False]
['text':' If this is a switch() label, may line up relative to that.','line_number':2688,'multiline':False]
['text':' If this is a C++ scope declaration, do the same.','line_number':2689,'multiline':False]
['text':' we are only looking for cpp base class','line_number':2692,'multiline':False]
['text':' declaration/initialization any longer','line_number':2693,'multiline':False]
['text':' When looking for a "do" we are not interested in','line_number':2698,'multiline':False]
['text':' labels.','line_number':2699,'multiline':False]
['text':'  case xx:','line_number':2704,'multiline':False]
['text':'      c = 99 +        <- this indent plus continuation','line_number':2705,'multiline':False]
['text':' ->          here;','line_number':2706,'multiline':False]
['text':' case xx: <- line up with this case','line_number':2716,'multiline':False]
['text':'     x = 333;','line_number':2717,'multiline':False]
['text':' case yy:','line_number':2718,'multiline':False]
['text':' Check that this case label is not for another','line_number':2722,'multiline':False]
['text':' switch()','line_number':2723,'multiline':False]
['text':' XXX','line_number':2724,'multiline':False]
['text':' XXX','line_number':2727,'multiline':False]
['text':' XXX','line_number':2733,'multiline':False]
['text':'   case xx: if (cond)         <- line up with this if','line_number':2735,'multiline':False]
['text':'                y = y + 1;','line_number':2736,'multiline':False]
['text':' ->         s = 99;','line_number':2737,'multiline':False]
['text':'','line_number':2738,'multiline':False]
['text':'   case xx:','line_number':2739,'multiline':False]
['text':'       if (cond)          <- line up with this line','line_number':2740,'multiline':False]
['text':'           y = y + 1;','line_number':2741,'multiline':False]
['text':' ->    s = 99;','line_number':2742,'multiline':False]
['text':'   case xx: x = x + 1;        <- line up with this x','line_number':2753,'multiline':False]
['text':' ->         y = y + 1;','line_number':2754,'multiline':False]
['text':'','line_number':2755,'multiline':False]
['text':'   case xx: if (cond)         <- line up with this if','line_number':2756,'multiline':False]
['text':' ->              y = y + 1;','line_number':2757,'multiline':False]
['text':' Try to get the indent of a statement before the switch','line_number':2772,'multiline':False]
['text':' label.  If nothing is found, line up relative to the','line_number':2773,'multiline':False]
['text':' switch label.','line_number':2774,'multiline':False]
['text':'      break;              <- may line up with this line','line_number':2775,'multiline':False]
['text':'   case xx:','line_number':2776,'multiline':False]
['text':' ->   y = 1;','line_number':2777,'multiline':False]
['text':' XXX','line_number':2778,'multiline':False]
['text':' Looking for a switch() label or C++ scope declaration,','line_number':2786,'multiline':False]
['text':' ignore other lines, skip {}-blocks.','line_number':2787,'multiline':False]
['text':' Ignore jump labels with nothing after them.','line_number':2797,'multiline':False]
['text':' Ignore #defines, #if, etc.','line_number':2805,'multiline':False]
['text':' Ignore comment and empty lines.','line_number':2806,'multiline':False]
['text':' (need to get the line again, cin_islabel() may have','line_number':2807,'multiline':False]
['text':' unlocked it)','line_number':2808,'multiline':False]
['text':' Are we at the start of a cpp base class declaration or','line_number':2815,'multiline':False]
['text':' constructor initialization?','line_number':2816,'multiline':False]
['text':' XXX','line_number':2817,'multiline':False]
['text':' Need to find start of the declaration.','line_number':2831,'multiline':False]
['text':' XXX','line_number':2836,'multiline':False]
['text':' only look, whether there is a cpp base class','line_number':2841,'multiline':False]
['text':' declaration or initialization before the opening brace.','line_number':2842,'multiline':False]
['text':' What happens next depends on the line being terminated.','line_number':2850,'multiline':False]
['text':' If terminated with a ',' only consider it terminating if','line_number':2851,'multiline':False]
['text':' there is another unterminated statement behind, eg:','line_number':2852,'multiline':False]
['text':'   123,','line_number':2853,'multiline':False]
['text':'   sizeof','line_number':2854,'multiline':False]
['text':'      here','line_number':2855,'multiline':False]
['text':' Otherwise check whether it is an enumeration or structure','line_number':2856,'multiline':False]
['text':' initialisation (not indented) or a variable declaration','line_number':2857,'multiline':False]
['text':' (indented).','line_number':2858,'multiline':False]
['text':' only check the first line','line_number':2862,'multiline':False]
['text':' For Javascript we might be inside an object:','line_number':2864,'multiline':False]
['text':'   key: something,  <- align with this','line_number':2865,'multiline':False]
['text':'   key: something','line_number':2866,'multiline':False]
['text':' or:','line_number':2867,'multiline':False]
['text':'   key: something +  <- align with this','line_number':2868,'multiline':False]
['text':'       something,','line_number':2869,'multiline':False]
['text':'   key: something','line_number':2870,'multiline':False]
['text':' Line below current line is the one that starts a','line_number':2884,'multiline':False]
['text':' (possibly broken) line ending in a comma.','line_number':2885,'multiline':False]
['text':' line above is start of the scope, thus current','line_number':2890,'multiline':False]
['text':' line is the one that stars a (possibly broken)','line_number':2891,'multiline':False]
['text':' line ending in a comma.','line_number':2892,'multiline':False]
['text':' If we're in the middle of a paren thing, Go back to the line','line_number':2903,'multiline':False]
['text':' that starts it so we can get the right prevailing indent','line_number':2904,'multiline':False]
['text':'     if ( foo &&','line_number':2905,'multiline':False]
['text':'              bar )','line_number':2906,'multiline':False]
['text':' Position the cursor over the rightmost paren, so that','line_number':2908,'multiline':False]
['text':' matching it will take us back to the start of the line.','line_number':2909,'multiline':False]
['text':' Ignore a match before the start of the block.','line_number':2910,'multiline':False]
['text':' If we are looking for ',', we also look for matching','line_number':2921,'multiline':False]
['text':' braces.','line_number':2922,'multiline':False]
['text':' Check if we are on a case label now.  This is','line_number':2931,'multiline':False]
['text':' handled above.','line_number':2932,'multiline':False]
['text':'     case xx:  if ( asdf &&','line_number':2933,'multiline':False]
['text':'                        asdf)','line_number':2934,'multiline':False]
['text':' Skip over continuation lines to find the one to get the','line_number':2944,'multiline':False]
['text':' indent from','line_number':2945,'multiline':False]
['text':' char *usethis = "bla{backslash}','line_number':2946,'multiline':False]
['text':'           bla",','line_number':2947,'multiline':False]
['text':'      here;','line_number':2948,'multiline':False]
['text':' Get indent and pointer to text for current line,','line_number':2961,'multiline':False]
['text':' ignoring any jump label.     XXX','line_number':2962,'multiline':False]
['text':' If this is just above the line we are indenting, and it','line_number':2968,'multiline':False]
['text':' starts with a '{', line it up with this line.','line_number':2969,'multiline':False]
['text':'          while (not)','line_number':2970,'multiline':False]
['text':' ->       {','line_number':2971,'multiline':False]
['text':'          }','line_number':2972,'multiline':False]
['text':' Only add b_ind_open_extra when the current line','line_number':2976,'multiline':False]
['text':' doesn't start with a '{', which must have a match','line_number':2977,'multiline':False]
['text':' in the same line (scope is the same).  Probably:','line_number':2978,'multiline':False]
['text':'        { 1, 2 },','line_number':2979,'multiline':False]
['text':' ->     { 3, 4 }','line_number':2980,'multiline':False]
['text':' have to look back, whether it is a cpp base','line_number':2986,'multiline':False]
['text':' class declaration or initialization','line_number':2987,'multiline':False]
['text':' Check if we are after an "if", "while", etc.','line_number':2994,'multiline':False]
['text':' Also allow "   } else".','line_number':2995,'multiline':False]
['text':' Found an unterminated line after an if (), line up','line_number':2997,'multiline':False]
['text':' with the last one.','line_number':2998,'multiline':False]
['text':'   if (cond)','line_number':2999,'multiline':False]
['text':'             100 +','line_number':3000,'multiline':False]
['text':' ->              here;','line_number':3001,'multiline':False]
['text':' If this is just above the line we are indenting, we','line_number':3012,'multiline':False]
['text':' are finished.','line_number':3013,'multiline':False]
['text':'            while (not)','line_number':3014,'multiline':False]
['text':' ->             here;','line_number':3015,'multiline':False]
['text':' Otherwise this indent can be used when the line','line_number':3016,'multiline':False]
['text':' before this is terminated.','line_number':3017,'multiline':False]
['text':'        yyy;','line_number':3018,'multiline':False]
['text':'        if (stat)','line_number':3019,'multiline':False]
['text':'            while (not)','line_number':3020,'multiline':False]
['text':'                xxx;','line_number':3021,'multiline':False]
['text':' ->     here;','line_number':3022,'multiline':False]
['text':' Special trick: when expecting the while () after a','line_number':3033,'multiline':False]
['text':' do, line up with the while()','line_number':3034,'multiline':False]
['text':'     do','line_number':3035,'multiline':False]
['text':'            x = 1;','line_number':3036,'multiline':False]
['text':' ->  here','line_number':3037,'multiline':False]
['text':' When searching for a terminated line, don't use the','line_number':3046,'multiline':False]
['text':' one between the "if" and the matching "else".','line_number':3047,'multiline':False]
['text':' Need to use the scope of this "else".  XXX','line_number':3048,'multiline':False]
['text':' If whilelevel != 0 continue looking for a "do {".','line_number':3049,'multiline':False]
['text':' If we're looking at "} else", let's make sure we','line_number':3051,'multiline':False]
['text':' find the opening brace of the enclosing scope,','line_number':3052,'multiline':False]
['text':' not the one from "if () {".','line_number':3053,'multiline':False]
['text':' If we're below an unterminated line that is not an','line_number':3066,'multiline':False]
['text':' "if" or something, we may line up with this line or','line_number':3067,'multiline':False]
['text':' add something for a continuation line, depending on','line_number':3068,'multiline':False]
['text':' the line before this one.','line_number':3069,'multiline':False]
['text':' Found two unterminated lines on a row, line up with','line_number':3071,'multiline':False]
['text':' the last one.','line_number':3072,'multiline':False]
['text':'   c = 99 +','line_number':3073,'multiline':False]
['text':'            100 +','line_number':3074,'multiline':False]
['text':' ->         here;','line_number':3075,'multiline':False]
['text':' When line ends in a comma add extra indent','line_number':3077,'multiline':False]
['text':' Found two lines ending in ',', lineup with the','line_number':3085,'multiline':False]
['text':' lowest one, but check for cpp base class','line_number':3086,'multiline':False]
['text':' declaration/initialization, if it is an','line_number':3087,'multiline':False]
['text':' opening brace or we are looking just for','line_number':3088,'multiline':False]
['text':' enumerations/initializations.','line_number':3089,'multiline':False]
['text':' Ignore unterminated lines in between, but','line_number':3099,'multiline':False]
['text':' reduce indent.','line_number':3100,'multiline':False]
['text':' Found first unterminated line on a row, may','line_number':3105,'multiline':False]
['text':' line up with this line, remember its indent','line_number':3106,'multiline':False]
['text':'          100 +  //  NOLINT(whitespace/tab)','line_number':3107,'multiline':False]
['text':' ->       here;  //  NOLINT(whitespace/tab)','line_number':3108,'multiline':False]
['text':' If previous line ends in ',', check whether we','line_number':3119,'multiline':False]
['text':' are in an initialization or enum','line_number':3120,'multiline':False]
['text':' struct xxx =','line_number':3121,'multiline':False]
['text':' {','line_number':3122,'multiline':False]
['text':'      sizeof a,','line_number':3123,'multiline':False]
['text':'      124 };','line_number':3124,'multiline':False]
['text':' or a normal possible continuation line.','line_number':3125,'multiline':False]
['text':' but only, of no other statement has been found','line_number':3126,'multiline':False]
['text':' yet.','line_number':3127,'multiline':False]
['text':' Search for a line ending in a comma','line_number':3130,'multiline':False]
['text':' and line up with the line below it','line_number':3131,'multiline':False]
['text':' (could be the current line).','line_number':3132,'multiline':False]
['text':' some = [','line_number':3133,'multiline':False]
['text':'     1,     <- line up here','line_number':3134,'multiline':False]
['text':'     2,','line_number':3135,'multiline':False]
['text':' some = [','line_number':3136,'multiline':False]
['text':'     3 +    <- line up here','line_number':3137,'multiline':False]
['text':'       4 *','line_number':3138,'multiline':False]
['text':'        5,','line_number':3139,'multiline':False]
['text':'     6,','line_number':3140,'multiline':False]
['text':' Current line is first inside','line_number':3148,'multiline':False]
['text':' [], line up with it.','line_number':3149,'multiline':False]
['text':' XXX','line_number':3162,'multiline':False]
['text':' Check if we are after a while (cond);','line_number':3174,'multiline':False]
['text':' If so: Ignore until the matching "do".','line_number':3175,'multiline':False]
['text':' XXX','line_number':3176,'multiline':False]
['text':' Found an unterminated line after a while ();, line up','line_number':3177,'multiline':False]
['text':' with the last one.','line_number':3178,'multiline':False]
['text':'      while (cond);','line_number':3179,'multiline':False]
['text':'      100 +               <- line up with this one','line_number':3180,'multiline':False]
['text':' ->           here;','line_number':3181,'multiline':False]
['text':' XXX','line_number':3194,'multiline':False]
['text':' We are after a "normal" statement.','line_number':3201,'multiline':False]
['text':' If we had another statement we can stop now and use the','line_number':3202,'multiline':False]
['text':' indent of that other statement.','line_number':3203,'multiline':False]
['text':' Otherwise the indent of the current statement may be used,','line_number':3204,'multiline':False]
['text':' search backwards for the next "normal" statement.','line_number':3205,'multiline':False]
['text':' Skip single break line, if before a switch label. It','line_number':3207,'multiline':False]
['text':' may be lined up with the case label.','line_number':3208,'multiline':False]
['text':' Handle "do {" line.','line_number':3215,'multiline':False]
['text':' XXX','line_number':3219,'multiline':False]
['text':' Found a terminated line above an unterminated line. Add','line_number':3225,'multiline':False]
['text':' the amount for a continuation line.','line_number':3226,'multiline':False]
['text':'   x = 1;','line_number':3227,'multiline':False]
['text':'   y = foo +','line_number':3228,'multiline':False]
['text':' ->       here;','line_number':3229,'multiline':False]
['text':' or','line_number':3230,'multiline':False]
['text':'   int x = 1;','line_number':3231,'multiline':False]
['text':'   int foo,','line_number':3232,'multiline':False]
['text':' ->       here;','line_number':3233,'multiline':False]
['text':' Found a terminated line above a terminated line or "if"','line_number':3244,'multiline':False]
['text':' etc. line. Use the amount of the line below us.','line_number':3245,'multiline':False]
['text':'   x = 1;                         x = 1;','line_number':3246,'multiline':False]
['text':'   if (asdf)                  y = 2;','line_number':3247,'multiline':False]
['text':'       while (asdf)         ->here;','line_number':3248,'multiline':False]
['text':'          here;','line_number':3249,'multiline':False]
['text':' ->foo;','line_number':3250,'multiline':False]
['text':' First line above the one we're indenting is terminated.','line_number':3256,'multiline':False]
['text':' To know what needs to be done look further backward for','line_number':3257,'multiline':False]
['text':' a terminated line.','line_number':3258,'multiline':False]
['text':' position the cursor over the rightmost paren, so','line_number':3260,'multiline':False]
['text':' that matching it will take us back to the start of','line_number':3261,'multiline':False]
['text':' the line.  Helps for:','line_number':3262,'multiline':False]
['text':'     func(asdr,','line_number':3263,'multiline':False]
['text':'              asdfasdf);','line_number':3264,'multiline':False]
['text':'     here;','line_number':3265,'multiline':False]
['text':' Check if we are on a case label now.  This is','line_number':3270,'multiline':False]
['text':' handled above.','line_number':3271,'multiline':False]
['text':'         case xx:  if ( asdf &&','line_number':3272,'multiline':False]
['text':'                          asdf)','line_number':3273,'multiline':False]
['text':' When aligning with the case statement, don't align','line_number':3283,'multiline':False]
['text':' with a statement after it.','line_number':3284,'multiline':False]
['text':'  case 1: {   <-- don't use this { position','line_number':3285,'multiline':False]
['text':'        stat;','line_number':3286,'multiline':False]
['text':'  }','line_number':3287,'multiline':False]
['text':'  case 2:','line_number':3288,'multiline':False]
['text':'        stat;','line_number':3289,'multiline':False]
['text':' }','line_number':3290,'multiline':False]
['text':' Get indent and pointer to text for current line,','line_number':3293,'multiline':False]
['text':' ignoring any jump label.','line_number':3294,'multiline':False]
['text':' See remark above: "Only add b_ind_open_extra.."','line_number':3300,'multiline':False]
['text':' When a terminated line starts with "else" skip to','line_number':3307,'multiline':False]
['text':' the matching "if":','line_number':3308,'multiline':False]
['text':'       else 3;','line_number':3309,'multiline':False]
['text':'             indent this;','line_number':3310,'multiline':False]
['text':' Need to use the scope of this "else".  XXX','line_number':3311,'multiline':False]
['text':' If whilelevel != 0 continue looking for a "do {".','line_number':3312,'multiline':False]
['text':' If we're at the end of a block, skip to the start of','line_number':3325,'multiline':False]
['text':' that block.','line_number':3326,'multiline':False]
['text':' XXX','line_number':3328,'multiline':False]
['text':' if not "else {" check for terminated again','line_number':3331,'multiline':False]
['text':' but skip block for "} else {"','line_number':3332,'multiline':False]
['text':' add extra indent for a comment','line_number':3346,'multiline':False]
['text':' subtract extra left-shift for jump labels','line_number':3350,'multiline':False]
['text':' Ok -- we're not inside any sort of structure at all!','line_number':3358,'multiline':False]
['text':'','line_number':3359,'multiline':False]
['text':' this means we're at the top level, and everything should','line_number':3360,'multiline':False]
['text':' basically just match where the previous line is, except','line_number':3361,'multiline':False]
['text':' for the lines immediately following a function declaration,','line_number':3362,'multiline':False]
['text':' which are K&R-style parameters and need to be indented.','line_number':3363,'multiline':False]
['text':' if our line starts with an open brace, forget about any','line_number':3365,'multiline':False]
['text':' prevailing indent and make sure it looks like the start','line_number':3366,'multiline':False]
['text':' of a function','line_number':3367,'multiline':False]
['text':' If the NEXT line is a function declaration, the current','line_number':3373,'multiline':False]
['text':' line needs to be indented as a function type spec.','line_number':3374,'multiline':False]
['text':' Don't do this if the current line looks like a comment or if the','line_number':3375,'multiline':False]
['text':' current line is terminated, ie. ends in ';', or if the current line','line_number':3376,'multiline':False]
['text':' contains { or }: "void f() {\n if (1)"','line_number':3377,'multiline':False]
['text':' search backwards until we find something we recognize','line_number':3390,'multiline':False]
['text':' If we're in a comment or raw string now, skip to the start','line_number':3399,'multiline':False]
['text':' of it.','line_number':3400,'multiline':False]
['text':' XXX','line_number':3401,'multiline':False]
['text':' Are we at the start of a cpp base class declaration or','line_number':3408,'multiline':False]
['text':' constructor initialization?  XXX','line_number':3409,'multiline':False]
['text':' XXX','line_number':3416,'multiline':False]
['text':'','line_number':3421,'multiline':False]
['text':' Skip preprocessor directives and blank lines.','line_number':3422,'multiline':False]
['text':'','line_number':3423,'multiline':False]
['text':' If the previous line ends in ',', use one level of','line_number':3432,'multiline':False]
['text':' indentation:','line_number':3433,'multiline':False]
['text':' int foo,','line_number':3434,'multiline':False]
['text':'     bar;','line_number':3435,'multiline':False]
['text':' do this before checking for '}' in case of eg.','line_number':3436,'multiline':False]
['text':' enum foobar','line_number':3437,'multiline':False]
['text':' {','line_number':3438,'multiline':False]
['text':'   ...','line_number':3439,'multiline':False]
['text':' } foo,','line_number':3440,'multiline':False]
['text':'   bar;','line_number':3441,'multiline':False]
['text':' take us back to opening paren','line_number':3444,'multiline':False]
['text':' For a line ending in ',' that is a continuation line go','line_number':3450,'multiline':False]
['text':' back to the first line with a backslash:','line_number':3451,'multiline':False]
['text':' char *foo = "bla{backslash}','line_number':3452,'multiline':False]
['text':'           bla",','line_number':3453,'multiline':False]
['text':'      here;','line_number':3454,'multiline':False]
['text':' XXX','line_number':3464,'multiline':False]
['text':' If the line looks like a function declaration, and we're','line_number':3475,'multiline':False]
['text':' not in a comment, put it the left margin.','line_number':3476,'multiline':False]
['text':' XXX','line_number':3477,'multiline':False]
['text':' Finding the closing '}' of a previous function.  Put','line_number':3482,'multiline':False]
['text':' current line at the left margin.  For when 'cino' has "fs".','line_number':3483,'multiline':False]
['text':'                      (matching {)','line_number':3488,'multiline':False]
['text':' If the previous line ends on '};' (maybe followed by','line_number':3489,'multiline':False]
['text':' comments) align at column 0.  For example:','line_number':3490,'multiline':False]
['text':' char *string_array[] = { "foo",','line_number':3491,'multiline':False]
['text':'     / * x * / "b};ar" }; / * foobar * /','line_number':3492,'multiline':False]
['text':' If the previous line ends on '[' we are probably in an','line_number':3497,'multiline':False]
['text':' array constant:','line_number':3498,'multiline':False]
['text':' something = [','line_number':3499,'multiline':False]
['text':'     234,  <- extra indent','line_number':3500,'multiline':False]
['text':' Find a line only has a semicolon that belongs to a previous','line_number':3506,'multiline':False]
['text':' line ending in '}', e.g. before an #endif.  Don't increase','line_number':3507,'multiline':False]
['text':' indent then.','line_number':3508,'multiline':False]
['text':' If the PREVIOUS line is a function declaration, the current','line_number':3527,'multiline':False]
['text':' line (and the ones that follow) needs to be indented as','line_number':3528,'multiline':False]
['text':' parameters.','line_number':3529,'multiline':False]
['text':' If the previous line ends in ';' and the line before the','line_number':3535,'multiline':False]
['text':' previous line ends in ',' or '\', ident to column zero:','line_number':3536,'multiline':False]
['text':' int foo,','line_number':3537,'multiline':False]
['text':'     bar;','line_number':3538,'multiline':False]
['text':' indent_to_0 here;','line_number':3539,'multiline':False]
['text':' Doesn't look like anything interesting -- so just','line_number':3549,'multiline':False]
['text':' use the indent of this line.','line_number':3550,'multiline':False]
['text':'','line_number':3551,'multiline':False]
['text':' Position the cursor over the rightmost paren, so that','line_number':3552,'multiline':False]
['text':' matching it will take us back to the start of the line.','line_number':3553,'multiline':False]
['text':' XXX','line_number':3559,'multiline':False]
['text':' add extra indent for a comment','line_number':3563,'multiline':False]
['text':' add extra indent if the previous line ended in a backslash:','line_number':3568,'multiline':False]
['text':'          "asdfasdf{backslash}','line_number':3569,'multiline':False]
['text':'              here";','line_number':3570,'multiline':False]
['text':'        char *foo = "asdf{backslash}','line_number':3571,'multiline':False]
['text':'                     here";','line_number':3572,'multiline':False]
['text':' put the cursor back where it belongs','line_number':3591,'multiline':False]
['text':' XXX','line_number':3624,'multiline':False]
['text':' if we've gone outside the braces entirely,','line_number':3629,'multiline':False]
['text':' we must be out of scope...','line_number':3630,'multiline':False]
['text':' XXX','line_number':3631,'multiline':False]
['text':' and if the brace enclosing this is further','line_number':3636,'multiline':False]
['text':' back than the one enclosing the else, we're','line_number':3637,'multiline':False]
['text':' out of luck too.','line_number':3638,'multiline':False]
['text':' and if they're enclosed in a *deeper* brace,','line_number':3643,'multiline':False]
['text':' then we can ignore it because it's in a','line_number':3644,'multiline':False]
['text':' different scope...','line_number':3645,'multiline':False]
['text':' if it was an "else" (that's not an "else if")','line_number':3650,'multiline':False]
['text':' then we need to go back to another if, so','line_number':3651,'multiline':False]
['text':' increment elselevel','line_number':3652,'multiline':False]
['text':' NOLINT(readability/braces)','line_number':3657,'multiline':False]
['text':' if it was a "while" then we need to go back to','line_number':3662,'multiline':False]
['text':' another "do", so increment whilelevel.  XXX','line_number':3663,'multiline':False]
['text':' If it's an "if" decrement elselevel','line_number':3669,'multiline':False]
['text':' NOLINT(readability/braces)','line_number':3672,'multiline':False]
['text':' When looking for an "if" ignore "while"s that','line_number':3673,'multiline':False]
['text':' get in the way.','line_number':3674,'multiline':False]
['text':' If it's a "do" decrement whilelevel','line_number':3680,'multiline':False]
['text':' if we've used up all the elses, then','line_number':3685,'multiline':False]
['text':' this must be the if that we want!','line_number':3686,'multiline':False]
['text':' match the indent level of that if.','line_number':3687,'multiline':False]
['text':' Do C or expression indenting on the current line.','line_number':3695,'multiline':False]
