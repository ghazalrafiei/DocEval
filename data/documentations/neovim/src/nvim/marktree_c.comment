['text':' Tree data structure for storing marks at (row, col) positions and updating','line_number':1,'multiline':False]
['text':' them to arbitrary text changes. Derivative work of kbtree in klib, whose','line_number':2,'multiline':False]
['text':' copyright notice is reproduced below. Also inspired by the design of the','line_number':3,'multiline':False]
['text':' marker tree data structure of the Atom editor, regarding efficient updates','line_number':4,'multiline':False]
['text':' to text changes.','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':' Marks are inserted using marktree_put. Text changes are processed using','line_number':7,'multiline':False]
['text':' marktree_splice. All read and delete operations use the iterator.','line_number':8,'multiline':False]
['text':' use marktree_itr_get to put an iterator at a given position or','line_number':9,'multiline':False]
['text':' marktree_lookup to lookup a mark by its id (iterator optional in this case).','line_number':10,'multiline':False]
['text':' Use marktree_itr_current and marktree_itr_next/prev to read marks in a loop.','line_number':11,'multiline':False]
['text':' marktree_del_itr deletes the current mark of the iterator and implicitly','line_number':12,'multiline':False]
['text':' moves the iterator to the next mark.','line_number':13,'multiline':False]
['text':' Copyright notice for kbtree (included in heavily modified form):','line_number':15,'multiline':False]
['text':'','line_number':16,'multiline':False]
['text':' Copyright 1997-1999, 2001, John-Mark Gurney.','line_number':17,'multiline':False]
['text':'           2008-2009, Attractive Chaos <attractor@live.co.uk>','line_number':18,'multiline':False]
['text':'','line_number':19,'multiline':False]
['text':' Redistribution and use in source and binary forms, with or without','line_number':20,'multiline':False]
['text':' modification, are permitted provided that the following conditions','line_number':21,'multiline':False]
['text':' are met:','line_number':22,'multiline':False]
['text':'','line_number':23,'multiline':False]
['text':' 1. Redistributions of source code must retain the above copyright','line_number':24,'multiline':False]
['text':'    notice, this list of conditions and the following disclaimer.','line_number':25,'multiline':False]
['text':' 2. Redistributions in binary form must reproduce the above copyright','line_number':26,'multiline':False]
['text':'    notice, this list of conditions and the following disclaimer in the','line_number':27,'multiline':False]
['text':'    documentation and/or other materials provided with the distribution.','line_number':28,'multiline':False]
['text':'','line_number':29,'multiline':False]
['text':' THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND','line_number':30,'multiline':False]
['text':' ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE','line_number':31,'multiline':False]
['text':' IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE','line_number':32,'multiline':False]
['text':' ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE','line_number':33,'multiline':False]
['text':' FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL','line_number':34,'multiline':False]
['text':' DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS','line_number':35,'multiline':False]
['text':' OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)','line_number':36,'multiline':False]
['text':' HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT','line_number':37,'multiline':False]
['text':' LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY','line_number':38,'multiline':False]
['text':' OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF','line_number':39,'multiline':False]
['text':' SUCH DAMAGE.','line_number':40,'multiline':False]
['text':'','line_number':41,'multiline':False]
['text':' Changes done by by the neovim project follow the Apache v2 license available','line_number':42,'multiline':False]
['text':' at the repo root.','line_number':43,'multiline':False]
['text':' only for debug functions','line_number':58,'multiline':False]
['text':' Used by `marktree_splice`. Need to keep track of marks which moved','line_number':111,'multiline':False]
['text':' in order to repair intersections.','line_number':112,'multiline':False]
['text':' TODO(bfredl): MT_FLAG_REAL could go away if we fix marktree_getp_aux for real','line_number':136,'multiline':False]
['text':'/ @return position of k if it exists in the node, otherwise the position','line_number':141,'multiline':False]
['text':'/ it should be inserted, which ranges from 0 to x->n _inclusively_','line_number':142,'multiline':False]
['text':'/ @param match (optional) set to TRUE if match (pos, gravity) was found','line_number':143,'multiline':False]
['text':' put functions','line_number':182,'multiline':False]
['text':' x must be an internal node, which is not full','line_number':184,'multiline':False]
['text':' x->ptr[i] should be a full node, i e x->ptr[i]->n == 2*T-1','line_number':185,'multiline':False]
['text':' tricky: we might split a node in between inserting the start node and the end','line_number':193,'multiline':False]
['text':' node of the same pair. Then we must not intersect this id yet (done later','line_number':194,'multiline':False]
['text':' in marktree_intersect_pair).','line_number':195,'multiline':False]
['text':' no alloc in the common case (less than 4 intersects)','line_number':198,'multiline':False]
['text':' note: sloppy pseudo-index','line_number':202,'multiline':False]
['text':' note: y->key[T-1] is moved up and thus checked for both','line_number':211,'multiline':False]
['text':' == y->parent','line_number':236,'multiline':False]
['text':' move key to internal layer:','line_number':242,'multiline':False]
['text':' code above goose here','line_number':258,'multiline':False]
['text':' x must not be a full node (even if there might be internal space)','line_number':262,'multiline':False]
['text':' TODO(bfredl): ugh, make sure this is the _last_ valid (pos, gravity) position,','line_number':265,'multiline':False]
['text':' to minimize movement','line_number':266,'multiline':False]
['text':' this is currently not used very often, but if it was it should use binary search','line_number':314,'multiline':False]
['text':' optimized for the common case: new key is always in the end','line_number':331,'multiline':False]
['text':' (kv_A(x->intersect, i) > id)','line_number':353,'multiline':False]
['text':'/ @param itr mutated','line_number':370,'multiline':False]
['text':'/ @param end_itr not mutated','line_number':371,'multiline':False]
['text':' empty range','line_number':379,'multiline':False]
['text':' work to do','line_number':381,'multiline':False]
['text':' empty range','line_number':385,'multiline':False]
['text':' let's be real.','line_number':431,'multiline':False]
['text':'/ INITIATING DELETION PROTOCOL:','line_number':449,'multiline':False]
['text':'/','line_number':450,'multiline':False]
['text':'/ 1. Construct a valid iterator to the node to delete (argument)','line_number':451,'multiline':False]
['text':'/ 2. If an "internal" key. Iterate one step to the left or right,','line_number':452,'multiline':False]
['text':'/     which gives an internal key "auxiliary key".','line_number':453,'multiline':False]
['text':'/ 3. Now delete this internal key (intended or auxiliary).','line_number':454,'multiline':False]
['text':'/    The leaf node X might become undersized.','line_number':455,'multiline':False]
['text':'/ 4. If step two was done: now replace the key that _should_ be','line_number':456,'multiline':False]
['text':'/    deleted with the auxiliary key. Adjust relative','line_number':457,'multiline':False]
['text':'/ 5. Now "repair" the tree as needed. We always start at a leaf node X.','line_number':458,'multiline':False]
['text':'/     - if the node is big enough, terminate','line_number':459,'multiline':False]
['text':'/     - if we can steal from the left, steal','line_number':460,'multiline':False]
['text':'/     - if we can steal from the right, steal','line_number':461,'multiline':False]
['text':'/     - otherwise merge this node with a neighbour. This might make our','line_number':462,'multiline':False]
['text':'/       parent undersized. So repeat 5 for the parent.','line_number':463,'multiline':False]
['text':'/ 6. If 4 went all the way to the root node. The root node','line_number':464,'multiline':False]
['text':'/    might have ended up with size 0. Delete it then.','line_number':465,'multiline':False]
['text':'/','line_number':466,'multiline':False]
['text':'/ The iterator remains valid, and now points at the key _after_ the deleted','line_number':467,'multiline':False]
['text':'/ one.','line_number':468,'multiline':False]
['text':'/','line_number':469,'multiline':False]
['text':'/ @param rev should be true if we plan to iterate _backwards_ and delete','line_number':470,'multiline':False]
['text':'/            stuff before this key. Most of the time this is false (the','line_number':471,'multiline':False]
['text':'/            recommended strategy is to always iterate forward)','line_number':472,'multiline':False]
['text':' Remove intersect markers. NB: must match exactly!','line_number':489,'multiline':False]
['text':' mutated copy','line_number':491,'multiline':False]
['text':' steal previous node','line_number':502,'multiline':False]
['text':' 3.','line_number':508,'multiline':False]
['text':' 4.','line_number':521,'multiline':False]
['text':' if (adjustment == 1) {','line_number':522,'multiline':False]
['text':'   abort();','line_number':523,'multiline':False]
['text':' }','line_number':524,'multiline':False]
['text':' if not the first time, we need to undo the addition in the','line_number':546,'multiline':False]
['text':' previous step (`intersect_node` just below)','line_number':547,'multiline':False]
['text':' one less as p->ptr[n] is the last','line_number':549,'multiline':False]
['text':' if `did_bubble` then we already added `start_id` to some parent','line_number':564,'multiline':False]
['text':' note: sloppy pseudo-index','line_number':566,'multiline':False]
['text':' 5.','line_number':586,'multiline':False]
['text':' we are done, if this node is fine the rest of the tree will be','line_number':595,'multiline':False]
['text':' ppos is now the pos of p','line_number':604,'multiline':False]
['text':' steal one key from the left neighbour','line_number':609,'multiline':False]
['text':' steal one key from right neighbour','line_number':613,'multiline':False]
['text':' merge with left neighbour','line_number':618,'multiline':False]
['text':' TRICKY: we merged the node the iterator was on','line_number':622,'multiline':False]
['text':' no iter adjustment needed','line_number':630,'multiline':False]
['text':' 6.','line_number':637,'multiline':False]
['text':' no items, nothing for iterator to point to','line_number':649,'multiline':False]
['text':' not strictly needed, should handle delete right-most mark anyway','line_number':650,'multiline':False]
['text':' BONUS STEP: fix the iterator, so that it points to the key afterwards','line_number':659,'multiline':False]
['text':' TODO(bfredl): with "rev" should point before','line_number':660,'multiline':False]
['text':' if (adjustment == 1) {','line_number':661,'multiline':False]
['text':'   abort();','line_number':662,'multiline':False]
['text':' }','line_number':663,'multiline':False]
['text':' tricky: we stand at the deleted space in the previous leaf node.','line_number':665,'multiline':False]
['text':' But the inner key is now the previous key we stole, so we need','line_number':666,'multiline':False]
['text':' to skip that one as well.','line_number':667,'multiline':False]
['text':' we deleted the last key of a leaf node','line_number':672,'multiline':False]
['text':' go to the inner key after that.','line_number':673,'multiline':False]
['text':'/ similar to intersect_common but modify x and y in place to retain','line_number':682,'multiline':False]
['text':'/ only the items which are NOT in common','line_number':683,'multiline':False]
['text':' TODO(bfredl): kvi_pushp is actually quite complex, break out kvi_resize() to a function?','line_number':691,'multiline':False]
['text':' w used to be a child of x but it is now a child of y, adjust intersections accordingly','line_number':715,'multiline':False]
['text':' @param[out] d are intersections which should be added to the old children of y','line_number':716,'multiline':False]
['text':' now w < x strictly','line_number':728,'multiline':False]
['text':' x < w strictly','line_number':740,'multiline':False]
['text':' add kv_A(x, xi) at kv_A(w, wn), pushing up wi if wi == wn','line_number':749,'multiline':False]
['text':' no need to consider the added element again','line_number':758,'multiline':False]
['text':' move remaining items to d','line_number':768,'multiline':False]
['text':' at least one','line_number':769,'multiline':False]
['text':' x is immutable in the context of intersect_mov. y might shrink, but we','line_number':782,'multiline':False]
['text':' don't care about it (we get it the deleted ones in d)','line_number':783,'multiline':False]
['text':'/ intersection: i = x & y','line_number':810,'multiline':False]
['text':' inplace union: x |= y','line_number':827,'multiline':False]
['text':' at least one','line_number':836,'multiline':False]
['text':' newly added element','line_number':840,'multiline':False]
['text':' at least one','line_number':847,'multiline':False]
['text':' inplace asymmetric difference: x &= ~y','line_number':854,'multiline':False]
['text':' otherwise xn == xi','line_number':871,'multiline':False]
['text':'/ x is a node which shrunk, or the half of a split','line_number':879,'multiline':False]
['text':'/','line_number':880,'multiline':False]
['text':'/ this means that intervals which previously intersected all the (current)','line_number':881,'multiline':False]
['text':'/ child nodes, now instead intersects `x` itself.','line_number':882,'multiline':False]
['text':' due to invariants, the largest subset of _all_ subnodes is the intersection','line_number':887,'multiline':False]
['text':' between the first and the last','line_number':888,'multiline':False]
['text':' bubble down: ranges that intersected old-x but not old-y or vice versa','line_number':919,'multiline':False]
['text':' must be moved to their respective children','line_number':920,'multiline':False]
['text':' TODO(bfredl): dedicated impl for "Z |= Y"','line_number':923,'multiline':False]
['text':' nodes that used to be in y, now the second half of x','line_number':930,'multiline':False]
['text':' TODO(bfredl): dedicated impl for "Z |= X"','line_number':933,'multiline':False]
['text':' note: one has been deleted','line_number':943,'multiline':False]
['text':' move of a kvec_withinit_t, messy!','line_number':951,'multiline':False]
['text':' TODO(bfredl): special case version of intersect_merge(x_out, x_in_m_out, y) to avoid this','line_number':952,'multiline':False]
['text':'/ @param dest is overwritten (assumed to already been freed/moved)','line_number':958,'multiline':False]
['text':'/ @param src consumed (don't free or use)','line_number':959,'multiline':False]
['text':' TODO(bfredl): as a potential "micro" optimization, pivoting should balance','line_number':972,'multiline':False]
['text':' the two nodes instead of stealing just one key','line_number':973,'multiline':False]
['text':' x_pos is the absolute position of the key just before x (or a dummy key strictly less than any','line_number':974,'multiline':False]
['text':' key inside x, if x is the first leaf)','line_number':975,'multiline':False]
['text':' repair intersections of x','line_number':1005,'multiline':False]
['text':' handle y and first new y->ptr[0]','line_number':1007,'multiline':False]
['text':' y->ptr[0] was moved from x to y','line_number':1010,'multiline':False]
['text':' adjust y->ptr[0] for a difference between the parents','line_number':1011,'multiline':False]
['text':' in addition, this might cause some intersection of the old y','line_number':1012,'multiline':False]
['text':' to bubble down to the old children of y (if y->ptr[0] wasn't intersected)','line_number':1013,'multiline':False]
['text':' if the last element of x used to be an end node, check if it now covers all of x','line_number':1024,'multiline':False]
['text':' note: sloppy pseudo-index','line_number':1026,'multiline':False]
['text':' no need for a check, just delet it if it was there','line_number':1035,'multiline':False]
['text':' reverse from how we "always" do it. but pivot_left','line_number':1045,'multiline':False]
['text':' is just the inverse of pivot_right, so reverse it literally.','line_number':1046,'multiline':False]
['text':' note: last item deleted','line_number':1067,'multiline':False]
['text':' repair intersections of x,y','line_number':1074,'multiline':False]
['text':' handle y and first new y->ptr[0]','line_number':1076,'multiline':False]
['text':' x->ptr[x->n] was moved from y to x','line_number':1079,'multiline':False]
['text':' adjust x->ptr[x->n] for a difference between the parents','line_number':1080,'multiline':False]
['text':' in addition, this might cause some intersection of the old x','line_number':1081,'multiline':False]
['text':' to bubble down to the old children of x (if x->ptr[n] wasn't intersected)','line_number':1082,'multiline':False]
['text':' ptr[x->n| deliberately skipped','line_number':1085,'multiline':False]
['text':' if the first element of y used to be an start node, check if it now covers all of y','line_number':1093,'multiline':False]
['text':' note: sloppy pseudo-index','line_number':1095,'multiline':False]
['text':' no need for a check, just delet it if it was there','line_number':1106,'multiline':False]
['text':'/ frees all mem, resets tree to valid empty state','line_number':1112,'multiline':False]
['text':'/ @param itr iterator is invalid after call','line_number':1141,'multiline':False]
['text':' strictly _after_ key before `x`','line_number':1150,'multiline':False]
['text':' (not optimal when x is very first leaf of the entire tree, but that's fine)','line_number':1151,'multiline':False]
['text':' strictly before the end of x. (this could be made sharper by','line_number':1155,'multiline':False]
['text':' finding the internal key just after x, but meh)','line_number':1156,'multiline':False]
['text':' tree is one node. newpos thus is already "relative" itr->pos','line_number':1162,'multiline':False]
['text':' tricky: could minimize movement in either direction better','line_number':1172,'multiline':False]
['text':' itr might become invalid by put','line_number':1197,'multiline':False]
['text':' this could happen if the other end is waiting to be restored later','line_number':1207,'multiline':False]
['text':' this function will be called again for the other end.','line_number':1208,'multiline':False]
['text':' itr functions','line_number':1217,'multiline':False]
['text':' gives the first key that is greater or equal to p','line_number':1291,'multiline':False]
['text':' skip rest of this leaf node','line_number':1335,'multiline':False]
['text':' TODO(bfredl): this is the common case,','line_number':1338,'multiline':False]
['text':' and could be handled by inline wrapper','line_number':1339,'multiline':False]
['text':' we ran out of non-internal keys. Go up until we find an internal key','line_number':1342,'multiline':False]
['text':' we stood at an "internal" key. Go down to the first non-internal','line_number':1356,'multiline':False]
['text':' key after it.','line_number':1357,'multiline':False]
['text':' internal key, there is always a child after','line_number':1359,'multiline':False]
['text':' TODO(bfredl): this is the common case,','line_number':1390,'multiline':False]
['text':' and could be handled by inline wrapper','line_number':1391,'multiline':False]
['text':' we ran out of non-internal keys. Go up until we find a non-internal key','line_number':1394,'multiline':False]
['text':' we stood at an "internal" key. Go down to the last non-internal','line_number':1408,'multiline':False]
['text':' key before it.','line_number':1409,'multiline':False]
['text':' internal key, there is always a child before','line_number':1411,'multiline':False]
['text':'/ Get all marks which overlaps the position (row,col)','line_number':1454,'multiline':False]
['text':'/','line_number':1455,'multiline':False]
['text':'/ After calling this function, use marktree_itr_step_overlap to step through','line_number':1456,'multiline':False]
['text':'/ one overlapping mark at a time, until it returns false','line_number':1457,'multiline':False]
['text':'/','line_number':1458,'multiline':False]
['text':'/ NOTE: It's possible to get all marks which overlaps a region (row,col) to (row_end,col_end)','line_number':1459,'multiline':False]
['text':'/ To do this, first call marktree_itr_get_overlap with the start position and','line_number':1460,'multiline':False]
['text':'/ keep calling marktree_itr_step_overlap until it returns false.','line_number':1461,'multiline':False]
['text':'/ After this, as a second loop, keep calling the marktree_itr_next() until','line_number':1462,'multiline':False]
['text':'/ the iterator is invalid or reaches past (row_end, col_end). In this loop,','line_number':1463,'multiline':False]
['text':'/ consider all "start" marks (and unpaired marks if relevant), but skip over','line_number':1464,'multiline':False]
['text':'/ all "end" marks, using mt_end(mark).','line_number':1465,'multiline':False]
['text':'/','line_number':1466,'multiline':False]
['text':'/ @return false if we already know no marks can be found','line_number':1467,'multiline':False]
['text':'/               even if "true" the first call to marktree_itr_step_overlap','line_number':1468,'multiline':False]
['text':'/               could return false','line_number':1469,'multiline':False]
['text':' intersect_pos but will be adjusted relative itr->x','line_number':1482,'multiline':False]
['text':'/ Step through all overlapping pairs at a position.','line_number':1488,'multiline':False]
['text':'/','line_number':1489,'multiline':False]
['text':'/ This function must only be used with an iterator from |marktree_itr_step_overlap|','line_number':1490,'multiline':False]
['text':'/','line_number':1491,'multiline':False]
['text':'/ @return true if a valid pair was found (returned as `pair`)','line_number':1492,'multiline':False]
['text':'/ When all overlapping mark pairs have been found, false will be returned. `itr`','line_number':1493,'multiline':False]
['text':'/ is then valid as an ordinary iterator at the (row, col) position specified in','line_number':1494,'multiline':False]
['text':'/ marktree_itr_step_overlap','line_number':1495,'multiline':False]
['text':' phase one: we start at the root node and step inwards towards itr->intersect_pos','line_number':1498,'multiline':False]
['text':' (the position queried in marktree_itr_get_overlap)','line_number':1499,'multiline':False]
['text':'','line_number':1500,'multiline':False]
['text':' For each node (ancestor node to the node containing the sought position)','line_number':1501,'multiline':False]
['text':' we return all intersecting intervals, one at a time','line_number':1502,'multiline':False]
['text':' phase two: we now need to handle the node found at itr->intersect_pos','line_number':1532,'multiline':False]
['text':' first consider all start nodes in the node before this position.','line_number':1533,'multiline':False]
['text':' it's a start!','line_number':1545,'multiline':False]
['text':' phase 2B: We also need to step to the end of this node and consider all end marks, which','line_number':1549,'multiline':False]
['text':' might end an interval overlapping itr->intersect_pos','line_number':1550,'multiline':False]
['text':' end of a range which began before us!','line_number':1564,'multiline':False]
['text':' when returning false, get back to the queried position, to ensure the caller','line_number':1568,'multiline':False]
['text':' can keep using it as an ordinary iterator at the queried position. The docstring','line_number':1569,'multiline':False]
['text':' for marktree_itr_get_overlap explains how this is useful.','line_number':1570,'multiline':False]
['text':' either on or after the intersected position, bail out','line_number':1577,'multiline':False]
['text':' den e FÄRDIG','line_number':1628,'multiline':False]
['text':' "assert" (itr <= enditr)','line_number':1641,'multiline':False]
['text':' Follow the general strategy of messing things up and fix them later','line_number':1652,'multiline':False]
['text':' "oldbase" carries the information needed to calculate old position of','line_number':1653,'multiline':False]
['text':' children.','line_number':1654,'multiline':False]
['text':' NB: strictly should be less than the right gravity of loc_old, but','line_number':1664,'multiline':False]
['text':' the iter comparison below will already break on that.','line_number':1665,'multiline':False]
['text':' NOLINT','line_number':1678,'multiline':False]
['text':' actually, will be past_right after this key','line_number':1685,'multiline':False]
['text':' optimization: column only adjustment can skip remaining rows','line_number':1750,'multiline':False]
['text':' TODO(bfredl): a full sort is not really needed. we just need a "start" node to find','line_number':1766,'multiline':False]
['text':' its corresponding "end" node. Set up some dedicated hash for this later (c.f. the','line_number':1767,'multiline':False]
['text':' "grow only" variant of khash_t branch)','line_number':1768,'multiline':False]
['text':' start','line_number':1775,'multiline':False]
['text':' pair','line_number':1779,'multiline':False]
['text':' consume two items','line_number':1787,'multiline':False]
['text':' d is lone start, end didn't move','line_number':1791,'multiline':False]
['text':' d is lone end, start didn't move','line_number':1803,'multiline':False]
['text':' other end might be later in `saved`, this will safely bail out then','line_number':1854,'multiline':False]
['text':'/ @param itr OPTIONAL. set itr to pos.','line_number':1861,'multiline':False]
['text':'/ @param itr OPTIONAL. set itr to pos.','line_number':1882,'multiline':False]
['text':'/ if sloppy, two keys at the same _leaf_ node has the same index','line_number':1883,'multiline':False]
['text':' a valid pseudo-index is never zero!','line_number':1888,'multiline':False]
['text':' internal key i comes after ptr[i]','line_number':1900,'multiline':False]
['text':'/ @param itr OPTIONAL. set itr to pos.','line_number':1907,'multiline':False]
['text':' for unit test','line_number':1984,'multiline':False]
['text':' for unit test','line_number':1993,'multiline':False]
['text':' for unit test','line_number':1999,'multiline':False]
['text':' Do nothing, as assertions are required','line_number':2027,'multiline':False]
['text':' TODO(bfredl): too strict if checking "in repair" post-delete tree.','line_number':2036,'multiline':False]
['text':' PARANOIA: check no double node ref','line_number':2066,'multiline':False]
['text':' 1. move x->intersect to checked[x] and reinit x->intersect','line_number':2084,'multiline':False]
['text':' 2. iterate over all marks. for each START mark of a pair,','line_number':2087,'multiline':False]
['text':' intersect the nodes between the pair','line_number':2088,'multiline':False]
['text':' 3. for each node check if the recreated intersection','line_number':2111,'multiline':False]
['text':' matches the old checked[x] intersection.','line_number':2112,'multiline':False]
['text':' sentinel','line_number':2127,'multiline':False]
['text':' TODO(bfredl): kv_print','line_number':2181,'multiline':False]
['text':' GA_PRINT("%"PRIu64, kv_A(n->intersect, i));','line_number':2215,'multiline':False]
['text':' GA_PRINT("%"PRIu64, mt_lookup_id(key.ns, key.id, false));','line_number':2233,'multiline':False]
