['text':' Time for a process to exit cleanly before we send KILL.','line_number':24,'multiline':False]
['text':' For PTY processes SIGTERM is sent first (in case SIGHUP was not enough).','line_number':25,'multiline':False]
['text':'/ Externally defined with gcov.','line_number':28,'multiline':False]
['text':' Delay exit until handles are closed, to avoid deadlocks','line_number':35,'multiline':False]
['text':'/ @returns zero on success, or negative error code','line_number':38,'multiline':False]
['text':' forwarding stderr contradicts with processing it internally','line_number':42,'multiline':False]
['text':' Flush coverage data before forking, to avoid "Merge mismatch" errors.','line_number':64,'multiline':False]
['text':' Close handles to process without killing it.','line_number':134,'multiline':False]
['text':' Wait until all children exit and all close events are processed.','line_number':141,'multiline':False]
['text':'/ Synchronously wait for a process to finish','line_number':154,'multiline':False]
['text':'/','line_number':155,'multiline':False]
['text':'/ @param process  Process instance','line_number':156,'multiline':False]
['text':'/ @param ms       Time in milliseconds to wait for the process.','line_number':157,'multiline':False]
['text':'/                 0 for no wait. -1 to wait until the process quits.','line_number':158,'multiline':False]
['text':'/ @return Exit code of the process. proc->status will have the same value.','line_number':159,'multiline':False]
['text':'/         -1 if the timeout expired while the process is still running.','line_number':160,'multiline':False]
['text':'/         -2 if the user interrupted the wait.','line_number':161,'multiline':False]
['text':' Increase refcount to stop the exit callback from being called (and possibly','line_number':175,'multiline':False]
['text':' freed) before we have a chance to get the status.','line_number':176,'multiline':False]
['text':' Until...','line_number':179,'multiline':False]
['text':' interrupted by the user','line_number':180,'multiline':False]
['text':' job exited','line_number':181,'multiline':False]
['text':' Assume that a user hitting CTRL-C does not like the current job.  Kill it.','line_number':183,'multiline':False]
['text':' We can only return if all streams/handles are closed and the job','line_number':188,'multiline':False]
['text':' exited.','line_number':189,'multiline':False]
['text':' Job exited, free its resources.','line_number':200,'multiline':False]
['text':' decref() created an exit event, process it now.','line_number':203,'multiline':False]
['text':'/ Ask a process to terminate and eventually kill if it doesn't respond','line_number':213,'multiline':False]
['text':' close all streams for pty processes to send SIGHUP to the process','line_number':228,'multiline':False]
['text':' (Re)start timer to verify that stopped process(es) died.','line_number':234,'multiline':False]
['text':'/ Frees process-owned resources.','line_number':239,'multiline':False]
['text':'/ Sends SIGKILL (or SIGTERM..SIGKILL for PTY jobs) to processes that did','line_number':248,'multiline':False]
['text':'/ not terminate after process_stop().','line_number':249,'multiline':False]
['text':' Flag: SIGTERM was sent.','line_number':267,'multiline':False]
['text':' Restart timer.','line_number':268,'multiline':False]
['text':' User (hint: channel_job_start) is responsible for calling','line_number':279,'multiline':False]
['text':' process_free().','line_number':280,'multiline':False]
['text':' If a detached/pty process dies while tearing down it might get closed','line_number':311,'multiline':False]
['text':' twice.','line_number':312,'multiline':False]
['text':'/ Flush output stream.','line_number':334,'multiline':False]
['text':'/','line_number':335,'multiline':False]
['text':'/ @param proc     Process, for which an output stream should be flushed.','line_number':336,'multiline':False]
['text':'/ @param stream   Stream to flush.','line_number':337,'multiline':False]
['text':' Maximal remaining data size of terminated process is system','line_number':345,'multiline':False]
['text':' buffer size.','line_number':346,'multiline':False]
['text':' Also helps with a child process that keeps the output streams open. If it','line_number':347,'multiline':False]
['text':' keeps sending data, we only accept as much data as the system buffer size.','line_number':348,'multiline':False]
['text':' Otherwise this would block cleanup/teardown.','line_number':349,'multiline':False]
['text':' Read remaining data.','line_number':359,'multiline':False]
['text':' Remember number of bytes before polling','line_number':361,'multiline':False]
['text':' Poll for data and process the generated events.','line_number':364,'multiline':False]
['text':' Stream can be closed if it is empty.','line_number':370,'multiline':False]
['text':' Stream callback could miss EOF handling if a child keeps the stream','line_number':373,'multiline':False]
['text':' open. But only send EOF if we haven't already.','line_number':374,'multiline':False]
['text':' Called from rpc_close(), which passes 0 as status.','line_number':415,'multiline':False]
['text':' Process has terminated, but there could still be data to be read from the','line_number':436,'multiline':False]
['text':' OS. We are still in the libuv loop, so we cannot call code that polls for','line_number':437,'multiline':False]
['text':' more data directly. Instead delay the reading after the libuv loop by','line_number':438,'multiline':False]
['text':' queueing process_close_handles() as an event.','line_number':439,'multiline':False]
