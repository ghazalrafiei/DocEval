['text':'/ next free id for a job or rpc channel','line_number':44,'multiline':False]
['text':'/ 1 is reserved for stdio channel','line_number':45,'multiline':False]
['text':'/ 2 is reserved for stderr channel','line_number':46,'multiline':False]
['text':'/ Teardown the module','line_number':53,'multiline':False]
['text':'/ Closes a channel','line_number':75,'multiline':False]
['text':'/','line_number':76,'multiline':False]
['text':'/ @param id The channel id','line_number':77,'multiline':False]
['text':'/ @return true if successful, false otherwise','line_number':78,'multiline':False]
['text':' allow double close, even though we can't say what parts was valid.','line_number':91,'multiline':False]
['text':' Don't close on exit, in case late error messages','line_number':159,'multiline':False]
['text':'/ Initializes the module','line_number':186,'multiline':False]
['text':'/ Allocates a channel.','line_number':193,'multiline':False]
['text':'/','line_number':194,'multiline':False]
['text':'/ Channel is allocated with refcount 1, which should be decreased','line_number':195,'multiline':False]
['text':'/ when the underlying stream closes.','line_number':196,'multiline':False]
['text':' TODO(bfredl): in a future improved traceback solution,','line_number':223,'multiline':False]
['text':' external events should be included.','line_number':224,'multiline':False]
['text':' TODO(bfredl): do the conversion in one step. Also would be nice','line_number':234,'multiline':False]
['text':' to pretty print top level dict in defined order','line_number':235,'multiline':False]
['text':' delay free, so that libuv is done with the handles','line_number':258,'multiline':False]
['text':' uv will keep a reference to handles until next loop tick, so delay free','line_number':312,'multiline':False]
['text':'/ Starts a job and returns the associated channel','line_number':321,'multiline':False]
['text':'/','line_number':322,'multiline':False]
['text':'/ @param[in]  argv  Arguments vector specifying the command to run,','line_number':323,'multiline':False]
['text':'/                   NULL-terminated','line_number':324,'multiline':False]
['text':'/ @param[in]  exepath  The path to the executable. If NULL, use `argv[0]`.','line_number':325,'multiline':False]
['text':'/ @param[in]  on_stdout  Callback to read the job's stdout','line_number':326,'multiline':False]
['text':'/ @param[in]  on_stderr  Callback to read the job's stderr','line_number':327,'multiline':False]
['text':'/ @param[in]  on_exit  Callback to receive the job's exit status','line_number':328,'multiline':False]
['text':'/ @param[in]  pty  True if the job should run attached to a pty','line_number':329,'multiline':False]
['text':'/ @param[in]  rpc  True to communicate with the job using msgpack-rpc,','line_number':330,'multiline':False]
['text':'/                  `on_stdout` is ignored','line_number':331,'multiline':False]
['text':'/ @param[in]  detach  True if the job should not be killed when nvim exits,','line_number':332,'multiline':False]
['text':'/                     ignored if `pty` is true','line_number':333,'multiline':False]
['text':'/ @param[in]  stdin_mode  Stdin mode. Either kChannelStdinPipe to open a','line_number':334,'multiline':False]
['text':'/                         channel for stdin or kChannelStdinNull to leave','line_number':335,'multiline':False]
['text':'/                         stdin disconnected.','line_number':336,'multiline':False]
['text':'/ @param[in]  cwd  Initial working directory for the job.  Nvim's working','line_number':337,'multiline':False]
['text':'/                  directory if `cwd` is NULL','line_number':338,'multiline':False]
['text':'/ @param[in]  pty_width  Width of the pty, ignored if `pty` is false','line_number':339,'multiline':False]
['text':'/ @param[in]  pty_height  Height of the pty, ignored if `pty` is false','line_number':340,'multiline':False]
['text':'/ @param[in]  env  Nvim's configured environment is used if this is NULL,','line_number':341,'multiline':False]
['text':'/                  otherwise defines all environment variables','line_number':342,'multiline':False]
['text':'/ @param[out]  status_out  0 for invalid arguments, > 0 for the channel id,','line_number':343,'multiline':False]
['text':'/                          < 0 if the job can't start','line_number':344,'multiline':False]
['text':'/','line_number':345,'multiline':False]
['text':'/ @returns [allocated] channel','line_number':346,'multiline':False]
['text':' the rpc takes over the in and out streams','line_number':427,'multiline':False]
['text':' Create a loopback channel. This avoids deadlock if nvim connects to','line_number':456,'multiline':False]
['text':' its own named pipe.','line_number':457,'multiline':False]
['text':'/ Creates an RPC channel from a tcp/pipe socket connection','line_number':490,'multiline':False]
['text':'/','line_number':491,'multiline':False]
['text':'/ @param watcher The SocketWatcher ready to accept the connection','line_number':492,'multiline':False]
['text':'/ Creates an API channel from stdin/stdout. This is used when embedding','line_number':505,'multiline':False]
['text':'/ Neovim','line_number':506,'multiline':False]
['text':' Strangely, ConPTY doesn't work if stdin and stdout are pipes. So replace','line_number':526,'multiline':False]
['text':' stdin and stdout with CONIN$ and CONOUT$, respectively.','line_number':527,'multiline':False]
['text':'/ @param data will be consumed','line_number':556,'multiline':False]
['text':' unbuffered write','line_number':572,'multiline':False]
['text':' write can be delayed indefinitely, so always use an allocated buffer','line_number':602,'multiline':False]
['text':'/ Convert binary byte array to a readfile()-style list','line_number':614,'multiline':False]
['text':'/','line_number':615,'multiline':False]
['text':'/ @param[in]  buf  Array to convert.','line_number':616,'multiline':False]
['text':'/ @param[in]  len  Array length.','line_number':617,'multiline':False]
['text':'/','line_number':618,'multiline':False]
['text':'/ @return [allocated] Converted list.','line_number':619,'multiline':False]
['text':' Empty buffer should be represented by [''], encode_list_write() thinks','line_number':624,'multiline':False]
['text':' empty list is fine for the case.','line_number':625,'multiline':False]
['text':' stub variable, to keep reading consistent with the order of events, only','line_number':648,'multiline':False]
['text':' consider the count parameter.','line_number':649,'multiline':False]
['text':'/ schedule the necessary callbacks to be invoked as a deferred event','line_number':672,'multiline':False]
['text':' further callback was deferred to avoid recursion.','line_number':701,'multiline':False]
['text':' if the stream reached eof, invoke extra callback with no data','line_number':732,'multiline':False]
['text':' If process did not exit, we only closed the handle of a detached process.','line_number':747,'multiline':False]
['text':'/ Open terminal for channel','line_number':791,'multiline':False]
['text':'/','line_number':792,'multiline':False]
['text':'/ Channel `chan` is assumed to be an open pty channel,','line_number':793,'multiline':False]
['text':'/ and `buf` is assumed to be a new, unmodified buffer.','line_number':794,'multiline':False]
['text':' 'channel' option','line_number':806,'multiline':False]
['text':' If the backing stream was closed abruptly, there may be write events','line_number':815,'multiline':False]
['text':' ahead of the terminal close event. Just ignore the writes.','line_number':816,'multiline':False]
['text':'/ Simple int64_t comparison function for use with qsort()','line_number':952,'multiline':False]
['text':' order the items in the array by channel number, for Determinismâ„¢','line_number':961,'multiline':False]
