['text':' for debugging','line_number':1,'multiline':False]
['text':' #define CHECK(c, s) do { if (c) emsg(s); } while (0)','line_number':2,'multiline':False]
['text':' memline.c: Contains the functions for appending, deleting and changing the','line_number':5,'multiline':False]
['text':' text lines. The memfile functions are used to store the information in','line_number':6,'multiline':False]
['text':' blocks of memory, backed up by a file. The structure of the information is','line_number':7,'multiline':False]
['text':' a tree.  The root of the tree is a pointer block. The leaves of the tree','line_number':8,'multiline':False]
['text':' are data blocks. In between may be several layers of pointer blocks,','line_number':9,'multiline':False]
['text':' forming branches.','line_number':10,'multiline':False]
['text':'','line_number':11,'multiline':False]
['text':' Three types of blocks are used:','line_number':12,'multiline':False]
['text':' - Block nr 0 contains information for recovery','line_number':13,'multiline':False]
['text':' - Pointer blocks contain list of pointers to other blocks.','line_number':14,'multiline':False]
['text':' - Data blocks contain the actual text.','line_number':15,'multiline':False]
['text':'','line_number':16,'multiline':False]
['text':' Block nr 0 contains the block0 structure (see below).','line_number':17,'multiline':False]
['text':'','line_number':18,'multiline':False]
['text':' Block nr 1 is the first pointer block. It is the root of the tree.','line_number':19,'multiline':False]
['text':' Other pointer blocks are branches.','line_number':20,'multiline':False]
['text':'','line_number':21,'multiline':False]
['text':'  If a line is too big to fit in a single page, the block containing that','line_number':22,'multiline':False]
['text':'  line is made big enough to hold the line. It may span several pages.','line_number':23,'multiline':False]
['text':'  Otherwise all blocks are one page.','line_number':24,'multiline':False]
['text':'','line_number':25,'multiline':False]
['text':'  A data block that was filled when starting to edit a file and was not','line_number':26,'multiline':False]
['text':'  changed since then, can have a negative block number. This means that it','line_number':27,'multiline':False]
['text':'  has not yet been assigned a place in the file. When recovering, the lines','line_number':28,'multiline':False]
['text':'  in this data block can be read from the original file. When the block is','line_number':29,'multiline':False]
['text':'  changed (lines appended/deleted/changed) or when it is flushed it gets a','line_number':30,'multiline':False]
['text':'  positive number. Use mf_trans_del() to get the new number, before calling','line_number':31,'multiline':False]
['text':'  mf_get().','line_number':32,'multiline':False]
['text':' it's in os/unix_defs.h for Unix','line_number':90,'multiline':False]
['text':' data block id','line_number':95,'multiline':False]
['text':' pointer block id','line_number':96,'multiline':False]
['text':' block 0 id 0','line_number':97,'multiline':False]
['text':' block 0 id 1','line_number':98,'multiline':False]
['text':' pointer to a block, used in a pointer block','line_number':101,'multiline':False]
['text':' block number','line_number':103,'multiline':False]
['text':' number of lines in this branch','line_number':104,'multiline':False]
['text':' lnum for this block (for recovery)','line_number':105,'multiline':False]
['text':' number of pages in block pe_bnum','line_number':106,'multiline':False]
['text':' A pointer block contains a list of branches in the tree.','line_number':109,'multiline':False]
['text':' ID for pointer block: PTR_ID','line_number':111,'multiline':False]
['text':' number of pointers in this block','line_number':112,'multiline':False]
['text':' maximum value for pb_count','line_number':113,'multiline':False]
['text':' list of pointers to blocks','line_number':114,'multiline':False]
['text':' followed by empty space until end of page','line_number':115,'multiline':False]
['text':' Value for pb_count_max.','line_number':118,'multiline':False]
['text':' A data block is a leaf in the tree.','line_number':122,'multiline':False]
['text':'','line_number':123,'multiline':False]
['text':' The text of the lines is at the end of the block. The text of the first line','line_number':124,'multiline':False]
['text':' in the block is put at the end, the text of the second line in front of it,','line_number':125,'multiline':False]
['text':' etc. Thus the order of the lines is the opposite of the line number.','line_number':126,'multiline':False]
['text':' ID for data block: DATA_ID','line_number':128,'multiline':False]
['text':' free space available','line_number':129,'multiline':False]
['text':' byte where text starts','line_number':130,'multiline':False]
['text':' byte just after data block','line_number':131,'multiline':False]
['text':' linenr_T db_line_count;','line_number':132,'multiline':False]
['text':' number of lines in this block','line_number':133,'multiline':False]
['text':' index for start of line','line_number':134,'multiline':False]
['text':' followed by empty space up to db_txt_start','line_number':135,'multiline':False]
['text':' followed by the text in the lines until','line_number':136,'multiline':False]
['text':' end of page','line_number':137,'multiline':False]
['text':' The low bits of db_index hold the actual index. The topmost bit is','line_number':140,'multiline':False]
['text':' used for the global command to be able to mark a line.','line_number':141,'multiline':False]
['text':' This method is not clean, but otherwise there would be at least one extra','line_number':142,'multiline':False]
['text':' byte used for each line.','line_number':143,'multiline':False]
['text':' The mark has to be in this place to keep it with the correct line when other','line_number':144,'multiline':False]
['text':' lines are inserted or deleted.','line_number':145,'multiline':False]
['text':' size of one db_index entry','line_number':149,'multiline':False]
['text':' size of data block header','line_number':150,'multiline':False]
['text':' what it was in older versions','line_number':153,'multiline':False]
['text':' 2 bytes used for other things','line_number':154,'multiline':False]
['text':' 10 bytes used for other things','line_number':155,'multiline':False]
['text':' Restrict the numbers to 32 bits, otherwise most compilers will complain.','line_number':159,'multiline':False]
['text':' This won't detect a 64 bit machine that only swaps a byte in the top 32','line_number':160,'multiline':False]
['text':' bits, but that is crazy anyway.','line_number':161,'multiline':False]
['text':'/ Block zero holds all info about the swapfile. This is the first block in the file.','line_number':169,'multiline':False]
['text':'/','line_number':170,'multiline':False]
['text':'/ NOTE: DEFINITION OF BLOCK 0 SHOULD NOT CHANGE! It would make all existing swapfiles unusable!','line_number':171,'multiline':False]
['text':'/','line_number':172,'multiline':False]
['text':'/ If size of block0 changes anyway, adjust MIN_SWAP_PAGE_SIZE in memfile.h!!','line_number':173,'multiline':False]
['text':'/','line_number':174,'multiline':False]
['text':'/ This block is built up of single bytes, to make it portable across','line_number':175,'multiline':False]
['text':'/ different machines. b0_magic_* is used to check the byte order and size of','line_number':176,'multiline':False]
['text':'/ variables, because the rest of the swapfile is not portable.','line_number':177,'multiline':False]
['text':'/< ID for block 0: BLOCK0_ID0 and BLOCK0_ID1.','line_number':179,'multiline':False]
['text':'/< Vim version string','line_number':180,'multiline':False]
['text':'/< number of bytes per page','line_number':181,'multiline':False]
['text':'/< last modification time of file','line_number':182,'multiline':False]
['text':'/< inode of b0_fname','line_number':183,'multiline':False]
['text':'/< process id of creator (or 0)','line_number':184,'multiline':False]
['text':'/< name of user (uid if no name)','line_number':185,'multiline':False]
['text':'/< host name (if it has a name)','line_number':186,'multiline':False]
['text':'/< name of file being edited','line_number':187,'multiline':False]
['text':'/< check for byte order of long','line_number':188,'multiline':False]
['text':'/< check for byte order of int','line_number':189,'multiline':False]
['text':'/< check for byte order of short','line_number':190,'multiline':False]
['text':'/< check for last char','line_number':191,'multiline':False]
['text':' Note: b0_dirty and b0_flags are put at the end of the file name.  For very','line_number':194,'multiline':False]
['text':' long file names in older versions of Vim they are invalid.','line_number':195,'multiline':False]
['text':' The 'fileencoding' comes before b0_flags, with a NUL in front.  But only','line_number':196,'multiline':False]
['text':' when there is room, for very long file names it's omitted.','line_number':197,'multiline':False]
['text':' The b0_flags field is new in Vim 7.0.','line_number':201,'multiline':False]
['text':' The lowest two bits contain the fileformat.  Zero means it's not set','line_number':204,'multiline':False]
['text':' (compatible with Vim 6.x), otherwise it's EOL_UNIX + 1, EOL_DOS + 1 or','line_number':205,'multiline':False]
['text':' EOL_MAC + 1.','line_number':206,'multiline':False]
['text':' Swapfile is in directory of edited file.  Used to find the file from different mount points.','line_number':209,'multiline':False]
['text':' The 'fileencoding' is at the end of b0_fname[], with a NUL in front of it.','line_number':212,'multiline':False]
['text':' When empty there is only the NUL.','line_number':213,'multiline':False]
['text':' nr of entries added to ml_stack at a time','line_number':216,'multiline':False]
['text':' The line number where the first mark may be is remembered.','line_number':218,'multiline':False]
['text':' If it is 0 there are no marks at all.','line_number':219,'multiline':False]
['text':' (always used for the current buffer only, no buffer change possible while','line_number':220,'multiline':False]
['text':' executing a global command).','line_number':221,'multiline':False]
['text':' arguments for ml_find_line()','line_number':224,'multiline':False]
['text':' delete line','line_number':226,'multiline':False]
['text':' insert line','line_number':227,'multiline':False]
['text':' just find the line','line_number':228,'multiline':False]
['text':' flush locked block','line_number':229,'multiline':False]
['text':' DEL, INS or FIND','line_number':231,'multiline':False]
['text':' argument for ml_upd_block0()','line_number':233,'multiline':False]
['text':' update timestamp and filename','line_number':235,'multiline':False]
['text':' update the B0_SAME_DIR flag','line_number':236,'multiline':False]
['text':'/ Open a new memline for "buf".','line_number':276,'multiline':False]
['text':'/','line_number':277,'multiline':False]
['text':'/ @return  FAIL for failure, OK otherwise.','line_number':278,'multiline':False]
['text':' init fields in memline struct','line_number':281,'multiline':False]
['text':' no stack yet','line_number':282,'multiline':False]
['text':' no stack yet','line_number':283,'multiline':False]
['text':' nothing in the stack','line_number':284,'multiline':False]
['text':' no cached block','line_number':285,'multiline':False]
['text':' no cached line','line_number':286,'multiline':False]
['text':' When 'updatecount' is non-zero swapfile may be opened later.','line_number':295,'multiline':False]
['text':' Open the memfile.  No swapfile is created yet.','line_number':302,'multiline':False]
['text':' fill block0 struct and write page 0','line_number':312,'multiline':False]
['text':' Always sync block number 0 to disk, so we can check the file name in','line_number':340,'multiline':False]
['text':' the swapfile in findswapname(). Don't do this for a help files or','line_number':341,'multiline':False]
['text':' a spell buffer though.','line_number':342,'multiline':False]
['text':' Only works when there's a swapfile, otherwise it's done when the file','line_number':343,'multiline':False]
['text':' is created.','line_number':344,'multiline':False]
['text':' Fill in root pointer block and write page 1.','line_number':350,'multiline':False]
['text':' line count after insertion','line_number':362,'multiline':False]
['text':' Allocate first data block and create an empty line 1.','line_number':365,'multiline':False]
['text':' at end of block','line_number':373,'multiline':False]
['text':' empty line','line_number':376,'multiline':False]
['text':' will also xfree(mfp->mf_fname)','line_number':385,'multiline':False]
['text':'/ ml_setname() is called when the file name of "buf" has been changed.','line_number':391,'multiline':False]
['text':'/ It may rename the swapfile.','line_number':392,'multiline':False]
['text':' there is no swapfile yet','line_number':398,'multiline':False]
['text':' When 'updatecount' is 0 and 'noswapfile' there is no swapfile.','line_number':399,'multiline':False]
['text':' For help files we will make a swapfile now.','line_number':400,'multiline':False]
['text':' create a swapfile','line_number':402,'multiline':False]
['text':' Try all directories in the 'directory' option.','line_number':407,'multiline':False]
['text':' tried all directories, fail','line_number':411,'multiline':False]
['text':' alloc's fname','line_number':415,'multiline':False]
['text':' out of memory','line_number':416,'multiline':False]
['text':' no file name found for this dir','line_number':419,'multiline':False]
['text':' if the file name is the same we don't have to do anything','line_number':423,'multiline':False]
['text':' need to close the swapfile before renaming','line_number':429,'multiline':False]
['text':' try to rename the swapfile','line_number':435,'multiline':False]
['text':' this fname didn't work, try another','line_number':443,'multiline':False]
['text':' need to (re)open the swapfile','line_number':446,'multiline':False]
['text':' could not (re)open the swapfile, what can we do????','line_number':449,'multiline':False]
['text':'/ Open a file for the memfile for all buffers that are not readonly or have','line_number':460,'multiline':False]
['text':'/ been modified.','line_number':461,'multiline':False]
['text':'/ Used when 'updatecount' changes from zero to non-zero.','line_number':462,'multiline':False]
['text':'/ Open a swapfile for an existing memfile, if there is no swapfile yet.','line_number':472,'multiline':False]
['text':'/ If we are unable to find a file name, mf_fname will be NULL','line_number':473,'multiline':False]
['text':'/ and the memfile will be in memory only (no recovery possible).','line_number':474,'multiline':False]
['text':' nothing to do','line_number':481,'multiline':False]
['text':' For a spell buffer use a temp file name.','line_number':484,'multiline':False]
['text':' consumes fname!','line_number':488,'multiline':False]
['text':' Try all directories in 'directory' option.','line_number':494,'multiline':False]
['text':' There is a small chance that between choosing the swapfile name','line_number':501,'multiline':False]
['text':' and creating it, another Vim creates the file.  In that case the','line_number':502,'multiline':False]
['text':' creation will fail and we will use another directory.','line_number':503,'multiline':False]
['text':' out of memory','line_number':506,'multiline':False]
['text':' consumes fname!','line_number':511,'multiline':False]
['text':' don't sync yet in ml_sync_all()','line_number':512,'multiline':False]
['text':' Flush block zero, so others can read it','line_number':516,'multiline':False]
['text':' Mark all blocks that should be in the swapfile as dirty.','line_number':518,'multiline':False]
['text':' Needed for when the 'swapfile' option was reset, so that','line_number':519,'multiline':False]
['text':' the swapfile was deleted, and then on again.','line_number':520,'multiline':False]
['text':' Writing block 0 failed: close the file and try another dir','line_number':524,'multiline':False]
['text':' call wait_return() later','line_number':530,'multiline':False]
['text':' don't try to open a swapfile again','line_number':537,'multiline':False]
['text':'/ If still need to create a swapfile, and starting to edit a not-readonly','line_number':541,'multiline':False]
['text':'/ file, or reading into an existing buffer, create a swapfile now.','line_number':542,'multiline':False]
['text':'/','line_number':543,'multiline':False]
['text':'/ @param newfile reading file into new buffer','line_number':544,'multiline':False]
['text':' might be reset by an E325 message','line_number':547,'multiline':False]
['text':' If swap dialog prompts for input, user needs to see it!','line_number':548,'multiline':False]
['text':'/ Close memline for buffer 'buf'.','line_number':557,'multiline':False]
['text':'/','line_number':558,'multiline':False]
['text':'/ @param del_file  if true, delete the swapfile','line_number':559,'multiline':False]
['text':' not open','line_number':562,'multiline':False]
['text':' close the .swp file','line_number':565,'multiline':False]
['text':' Reset the "recovered" flag, give the ATTENTION prompt the next time','line_number':574,'multiline':False]
['text':' this buffer is loaded.','line_number':575,'multiline':False]
['text':'/ Close all existing memlines and memfiles.','line_number':579,'multiline':False]
['text':'/ Only used when exiting.','line_number':580,'multiline':False]
['text':'/','line_number':581,'multiline':False]
['text':'/ @param del_file  if true, delete the memfiles.','line_number':582,'multiline':False]
['text':' delete the internal wordlist','line_number':588,'multiline':False]
['text':' delete created temp directory','line_number':589,'multiline':False]
['text':'/ Close all memfiles for not modified buffers.','line_number':592,'multiline':False]
['text':'/ Only use just before exiting!','line_number':593,'multiline':False]
['text':' close all not-modified buffers','line_number':598,'multiline':False]
['text':'/ Update the timestamp in the .swp file.','line_number':603,'multiline':False]
['text':'/ Used when the file has been written.','line_number':604,'multiline':False]
['text':'/ Checks whether the IDs in b0 are valid.','line_number':610,'multiline':False]
['text':'/ Checks whether all strings in b0 are valid (i.e. nul-terminated).','line_number':617,'multiline':False]
['text':'/ Update the timestamp or the B0_SAME_DIR flag of the .swp file.','line_number':627,'multiline':False]
['text':' what == UB_SAME_DIR','line_number':642,'multiline':False]
['text':'/ Write file name and timestamp into block 0 of a swapfile.','line_number':649,'multiline':False]
['text':'/ Also set buf->b_mtime.','line_number':650,'multiline':False]
['text':'/ Don't use NameBuff[]!!!','line_number':651,'multiline':False]
['text':' For a file under the home directory of the current user, we try to','line_number':659,'multiline':False]
['text':' replace the home directory path with "~user". This helps when','line_number':660,'multiline':False]
['text':' editing the same file on different machines over a network.','line_number':661,'multiline':False]
['text':' First replace home dir path with "~/" with home_replace().','line_number':662,'multiline':False]
['text':' Then insert the user name to get "~user/".','line_number':663,'multiline':False]
['text':' If there is no user name or it is too long, don't use "~/"','line_number':667,'multiline':False]
['text':' Also add the 'fileencoding' if there is room.','line_number':697,'multiline':False]
['text':'/ Update the B0_SAME_DIR flag of the swapfile.  It's set if the file and the','line_number':701,'multiline':False]
['text':'/ swapfile for "buf" are in the same directory.','line_number':702,'multiline':False]
['text':'/ This is fail safe: if we are not sure the directories are equal the flag is','line_number':703,'multiline':False]
['text':'/ not set.','line_number':704,'multiline':False]
['text':'/ When there is room, add the 'fileencoding' to block zero.','line_number':714,'multiline':False]
['text':'/ Returns the PID of the process that owns the swapfile, if it is running.','line_number':730,'multiline':False]
['text':'/','line_number':731,'multiline':False]
['text':'/ @param b0p swapfile data','line_number':732,'multiline':False]
['text':'/ @param swap_fname Name of the swapfile. If it's from before a reboot, the result is 0.','line_number':733,'multiline':False]
['text':'/','line_number':734,'multiline':False]
['text':'/ @return PID, or 0 if process is not running or the swapfile is from before a reboot.','line_number':735,'multiline':False]
['text':' If the system rebooted after when the swapfile was written then the','line_number':740,'multiline':False]
['text':' process can't be running now.','line_number':741,'multiline':False]
['text':'/ Try to recover curbuf from the .swp file.','line_number':751,'multiline':False]
['text':'/','line_number':752,'multiline':False]
['text':'/ @param checkext  if true, check the extension and detect whether it is a swapfile.','line_number':753,'multiline':False]
['text':' If the file name ends in ".s[a-w][a-z]" we assume this is the swapfile.','line_number':770,'multiline':False]
['text':' Otherwise a search is done to find the swapfile(s).','line_number':771,'multiline':False]
['text':' When there is no file name','line_number':773,'multiline':False]
['text':' make a copy for mf_open()','line_number':782,'multiline':False]
['text':' count the number of matching swapfiles','line_number':786,'multiline':False]
['text':' no swapfiles found','line_number':788,'multiline':False]
['text':' one swapfile found, use it','line_number':793,'multiline':False]
['text':' several swapfiles found, choose','line_number':795,'multiline':False]
['text':' list the names of the swapfiles','line_number':796,'multiline':False]
['text':' get the swapfile name that will be used','line_number':805,'multiline':False]
['text':' user chose invalid number.','line_number':809,'multiline':False]
['text':' When called from main() still need to initialize storage structure','line_number':811,'multiline':False]
['text':' Allocate a buffer structure for the swapfile that is used for recovery.','line_number':816,'multiline':False]
['text':' Only the memline in it is really used.','line_number':817,'multiline':False]
['text':' init fields in memline struct','line_number':820,'multiline':False]
['text':' no stack yet','line_number':821,'multiline':False]
['text':' no stack yet','line_number':822,'multiline':False]
['text':' nothing in the stack','line_number':823,'multiline':False]
['text':' no cached line','line_number':824,'multiline':False]
['text':' no locked block','line_number':826,'multiline':False]
['text':' open the memfile from the old swapfile','line_number':829,'multiline':False]
['text':' save "fname_used" for the message:','line_number':830,'multiline':False]
['text':' mf_open() will consume "fname_used"!','line_number':831,'multiline':False]
['text':' The page size set in mf_open() might be different from the page size','line_number':840,'multiline':False]
['text':' used in the swapfile, we must get it from block 0.  But to read block','line_number':841,'multiline':False]
['text':' 0 we need a page size.  Use the minimal size for block 0 here, it will','line_number':842,'multiline':False]
['text':' be set to the real value below.','line_number':843,'multiline':False]
['text':' try to read block 0','line_number':846,'multiline':False]
['text':' avoid going past the end of a corrupted hostname','line_number':876,'multiline':False]
['text':' If we guessed the wrong page size, we have to recalculate the','line_number':884,'multiline':False]
['text':' highest block number in the file.','line_number':885,'multiline':False]
['text':' no file or empty file','line_number':900,'multiline':False]
['text':' need to reallocate the memory used to store the data','line_number':906,'multiline':False]
['text':' If .swp file name given directly, use name from swapfile for buffer.','line_number':914,'multiline':False]
['text':' check date of swapfile and original file','line_number':933,'multiline':False]
['text':' Get the 'fileformat' and 'fileencoding' from block zero.','line_number':947,'multiline':False]
['text':' release block 0','line_number':956,'multiline':False]
['text':' Now that we are sure that the file is going to be recovered, clear the','line_number':959,'multiline':False]
['text':' contents of the current buffer.','line_number':960,'multiline':False]
['text':' Try reading the original file to obtain the values of 'fileformat',','line_number':965,'multiline':False]
['text':' 'fileencoding', etc.  Ignore errors.  The text itself is not used.','line_number':966,'multiline':False]
['text':' Use the 'fileformat' and 'fileencoding' as stored in the swapfile.','line_number':972,'multiline':False]
['text':' start with block 1','line_number':982,'multiline':False]
['text':' which is 1 page','line_number':983,'multiline':False]
['text':' append after line 0 in curbuf','line_number':984,'multiline':False]
['text':' start with first index in block 1','line_number':986,'multiline':False]
['text':' release previous block','line_number':997,'multiline':False]
['text':' get block','line_number':999,'multiline':False]
['text':' there is a block','line_number':1007,'multiline':False]
['text':' it is a pointer block','line_number':1009,'multiline':False]
['text':' check line count when using pointer block first time','line_number':1023,'multiline':False]
['text':' go a block deeper','line_number':1037,'multiline':False]
['text':' Data block with negative block number.','line_number':1039,'multiline':False]
['text':' Try to read lines from the original file.','line_number':1040,'multiline':False]
['text':' This is slow, but it works.','line_number':1041,'multiline':False]
['text':' get same block again for next index','line_number':1056,'multiline':False]
['text':' going one block deeper in the tree','line_number':1060,'multiline':False]
['text':' new entry in stack','line_number':1061,'multiline':False]
['text':' not a pointer block','line_number':1072,'multiline':False]
['text':' block id wrong','line_number':1074,'multiline':False]
['text':' It is a data block.','line_number':1083,'multiline':False]
['text':' Append all the lines in this block.','line_number':1084,'multiline':False]
['text':' Check the length of the block.','line_number':1087,'multiline':False]
['text':' If wrong, use the length given in the pointer block.','line_number':1088,'multiline':False]
['text':' Make sure there is a NUL at the end of the block so we','line_number':1098,'multiline':False]
['text':' don't go over the end when copying text.','line_number':1099,'multiline':False]
['text':' Check the number of lines in the block.','line_number':1102,'multiline':False]
['text':' If wrong, use the count in the data block.','line_number':1103,'multiline':False]
['text':' line count must be wrong','line_number':1116,'multiline':False]
['text':' avoid lots of lines with "???"','line_number':1126,'multiline':False]
['text':' finished','line_number':1145,'multiline':False]
['text':' go one block up in the tree','line_number':1149,'multiline':False]
['text':' go to next index','line_number':1152,'multiline':False]
['text':' Compare the buffer contents with the original file.  When they differ','line_number':1156,'multiline':False]
['text':' set the 'modified' flag.','line_number':1157,'multiline':False]
['text':' Lines 1 - lnum are the new contents.','line_number':1158,'multiline':False]
['text':' Lines lnum + 1 to ml_line_count are the original contents.','line_number':1159,'multiline':False]
['text':' Line ml_line_count + 1 in the dummy empty line.','line_number':1160,'multiline':False]
['text':' Recovering an empty file results in two lines and the first line is','line_number':1162,'multiline':False]
['text':' empty.  Don't set the modified flag then.','line_number':1163,'multiline':False]
['text':' Need to copy one line, fetching the other one may flush it.','line_number':1170,'multiline':False]
['text':' Delete the lines from the original file and the dummy line from the','line_number':1182,'multiline':False]
['text':' empty buffer.  These will now be after the last line in the buffer.','line_number':1183,'multiline':False]
['text':' Warn there could be an active Vim on the same file, the user may','line_number':1211,'multiline':False]
['text':' want to kill it.','line_number':1212,'multiline':False]
['text':' will also xfree(mfp->mf_fname)','line_number':1228,'multiline':False]
['text':' may be NULL if swapfile not found.','line_number':1230,'multiline':False]
['text':'/ Find the names of swapfiles in current directory and the directory given','line_number':1242,'multiline':False]
['text':'/ with the 'directory' option.','line_number':1243,'multiline':False]
['text':'/','line_number':1244,'multiline':False]
['text':'/ Used to:','line_number':1245,'multiline':False]
['text':'/ - list the swapfiles for "vim -r"','line_number':1246,'multiline':False]
['text':'/ - count the number of swapfiles when recovering','line_number':1247,'multiline':False]
['text':'/ - list the swapfiles when recovering','line_number':1248,'multiline':False]
['text':'/ - list the swapfiles for swapfilelist()','line_number':1249,'multiline':False]
['text':'/ - find the name of the n'th swapfile when recovering','line_number':1250,'multiline':False]
['text':'/','line_number':1251,'multiline':False]
['text':'/ @param fname  base for swapfile name','line_number':1252,'multiline':False]
['text':'/ @param do_list  when true, list the swapfile names','line_number':1253,'multiline':False]
['text':'/ @param ret_list  when not NULL add file names to it','line_number':1254,'multiline':False]
['text':'/ @param nr  when non-zero, return nr'th swapfile name','line_number':1255,'multiline':False]
['text':'/ @param fname_out  result when "nr" > 0','line_number':1256,'multiline':False]
['text':' Expand symlink in the file name, because the swapfile is created','line_number':1272,'multiline':False]
['text':' with the actual file instead of with the symlink.','line_number':1273,'multiline':False]
['text':' use msg() to start the scrolling properly','line_number':1281,'multiline':False]
['text':' Do the loop for every directory in 'directory'.','line_number':1286,'multiline':False]
['text':' First allocate some memory to put the directory name in.','line_number':1287,'multiline':False]
['text':' Isolate a directory name from *dirp and put it in dir_name (we know','line_number':1291,'multiline':False]
['text':' it is large enough, so use 31000 for length).','line_number':1292,'multiline':False]
['text':' Advance dirp to next directory name.','line_number':1293,'multiline':False]
['text':' check current dir','line_number':1296,'multiline':False]
['text':' For Unix names starting with a dot are special.  MS-Windows','line_number':1299,'multiline':False]
['text':' supports this too, on some file systems.','line_number':1300,'multiline':False]
['text':' check directory dir_name','line_number':1307,'multiline':False]
['text':' For Unix names starting with a dot are special.  MS-Windows','line_number':1310,'multiline':False]
['text':' supports this too, on some file systems.','line_number':1311,'multiline':False]
['text':' Ends with '//', Use Full path for swap name','line_number':1321,'multiline':False]
['text':' When no swapfile found, wildcard expansion might have failed (e.g.','line_number':1340,'multiline':False]
['text':' not able to execute the shell).','line_number':1341,'multiline':False]
['text':' Try finding a swapfile by simply adding ".swp" to the file name.','line_number':1342,'multiline':False]
['text':' Remove swapfile name of the current buffer, it must be ignored.','line_number':1356,'multiline':False]
['text':' But keep it for swapfilelist().','line_number':1357,'multiline':False]
['text':' Do not expand wildcards, on Windows would try to expand','line_number':1362,'multiline':False]
['text':' "%tmp%" in "%tmp%file"','line_number':1363,'multiline':False]
['text':' Remove the name from files[i].  Move further entries','line_number':1365,'multiline':False]
['text':' down.  When the array becomes empty free it here, since','line_number':1366,'multiline':False]
['text':' FreeWild() won't be called below.','line_number':1367,'multiline':False]
['text':' stop searching','line_number':1383,'multiline':False]
['text':' print the swapfile name','line_number':1400,'multiline':False]
['text':'/ Append the full path to name with path separators made into percent','line_number':1431,'multiline':False]
['text':'/ signs, to dir. An unnamed buffer is handled as "" (<currentdir>/"")','line_number':1432,'multiline':False]
['text':' PID of swapfile owner, or zero if not running.','line_number':1454,'multiline':False]
['text':'/ For Vimscript "swapinfo()".','line_number':1457,'multiline':False]
['text':'/','line_number':1458,'multiline':False]
['text':'/ @return  information found in swapfile "fname" in dictionary "d".','line_number':1459,'multiline':False]
['text':' We have swap information.','line_number':1472,'multiline':False]
['text':'/ Loads info from swapfile `fname`, and displays it to the user.','line_number':1495,'multiline':False]
['text':'/','line_number':1496,'multiline':False]
['text':'/ @return  timestamp (0 when unknown).','line_number':1497,'multiline':False]
['text':' print the swapfile date','line_number':1507,'multiline':False]
['text':' print name of owner of the file','line_number':1511,'multiline':False]
['text':' hopefully enough for every language','line_number':1523,'multiline':False]
['text':' print the original file name','line_number':1527,'multiline':False]
['text':'/ @return  true if the swapfile looks OK and there are no changes, thus it can be safely deleted.','line_number':1586,'multiline':False]
['text':' Swapfile must exist.','line_number':1591,'multiline':False]
['text':' must be able to read the first block','line_number':1596,'multiline':False]
['text':' the ID and magic number must be correct','line_number':1608,'multiline':False]
['text':' must be unchanged','line_number':1613,'multiline':False]
['text':' Host name must be known and must equal the current host name, otherwise','line_number':1618,'multiline':False]
['text':' comparing pid is meaningless.','line_number':1619,'multiline':False]
['text':' in case of corruption','line_number':1626,'multiline':False]
['text':' process must be known and not running.','line_number':1632,'multiline':False]
['text':' We do not check the user, it should be irrelevant for whether the swap','line_number':1637,'multiline':False]
['text':' file is still useful.','line_number':1638,'multiline':False]
['text':' May also add the file name with a dot prepended, for swapfile in same','line_number':1649,'multiline':False]
['text':' dir as original file.','line_number':1650,'multiline':False]
['text':' Form the normal swapfile name pattern by appending ".sw?".','line_number':1659,'multiline':False]
['text':' check if we have the same name twice','line_number':1661,'multiline':False]
['text':' file name has been expanded to full path','line_number':1665,'multiline':False]
['text':'/ sync all memlines','line_number':1679,'multiline':False]
['text':'/','line_number':1680,'multiline':False]
['text':'/ @param check_file  if true, check if original file exists and was not changed.','line_number':1681,'multiline':False]
['text':'/ @param check_char  if true, stop syncing when character becomes available, but','line_number':1682,'multiline':False]
['text':'/','line_number':1683,'multiline':False]
['text':'/ always sync at least one block.','line_number':1684,'multiline':False]
['text':' no file','line_number':1689,'multiline':False]
['text':' flush buffered line','line_number':1691,'multiline':False]
['text':' flush locked block','line_number':1692,'multiline':False]
['text':' If the original file does not exist anymore or has been changed','line_number':1696,'multiline':False]
['text':' call ml_preserve() to get rid of all negative numbered blocks.','line_number':1697,'multiline':False]
['text':' give message later','line_number':1705,'multiline':False]
['text':' character available now','line_number':1711,'multiline':False]
['text':'/ sync one buffer, including negative blocks','line_number':1718,'multiline':False]
['text':'/','line_number':1719,'multiline':False]
['text':'/ after this all the blocks are in the swapfile','line_number':1720,'multiline':False]
['text':'/','line_number':1721,'multiline':False]
['text':'/ Used for the :preserve command and when the original file has been','line_number':1722,'multiline':False]
['text':'/ changed or deleted.','line_number':1723,'multiline':False]
['text':'/','line_number':1724,'multiline':False]
['text':'/ @param message  if true, the success of preserving is reported.','line_number':1725,'multiline':False]
['text':' We only want to stop when interrupted here, not when interrupted','line_number':1738,'multiline':False]
['text':' before.','line_number':1739,'multiline':False]
['text':' flush buffered line','line_number':1742,'multiline':False]
['text':' flush locked block','line_number':1743,'multiline':False]
['text':' stack is invalid after mf_sync(.., MFS_ALL)','line_number':1746,'multiline':False]
['text':' Some of the data blocks may have been changed from negative to','line_number':1749,'multiline':False]
['text':' positive block number. In that case the pointer blocks need to be','line_number':1750,'multiline':False]
['text':' updated.','line_number':1751,'multiline':False]
['text':'','line_number':1752,'multiline':False]
['text':' We don't know in which pointer block the references are, so we visit','line_number':1753,'multiline':False]
['text':' all data blocks until there are no more translations to be done (or','line_number':1754,'multiline':False]
['text':' we hit the end of the file, which can only happen in case a write fails,','line_number':1755,'multiline':False]
['text':' e.g. when file system if full).','line_number':1756,'multiline':False]
['text':' ml_find_line() does the work by translating the negative block numbers','line_number':1757,'multiline':False]
['text':' when getting the first line of each data block.','line_number':1758,'multiline':False]
['text':' flush locked block','line_number':1770,'multiline':False]
['text':' sync the updated pointer blocks','line_number':1771,'multiline':False]
['text':' stack is invalid now','line_number':1775,'multiline':False]
['text':' NOTE: The pointer returned by the ml_get_*() functions only remains valid','line_number':1789,'multiline':False]
['text':' until the next call!','line_number':1790,'multiline':False]
['text':'  line1 = ml_get(1);','line_number':1791,'multiline':False]
['text':'  line2 = ml_get(2);  // line1 is now invalid!','line_number':1792,'multiline':False]
['text':' Make a copy of the line if necessary.','line_number':1793,'multiline':False]
['text':'/ @return  a pointer to a (read-only copy of a) line in curbuf.','line_number':1795,'multiline':False]
['text':'/','line_number':1796,'multiline':False]
['text':'/ On failure an error message is given and IObuff is returned (to avoid','line_number':1797,'multiline':False]
['text':'/ having to check for error everywhere).','line_number':1798,'multiline':False]
['text':'/ @return  a pointer to a (read-only copy of a) line.','line_number':1804,'multiline':False]
['text':'/','line_number':1805,'multiline':False]
['text':'/ This is the same as ml_get(), but taking in the buffer','line_number':1806,'multiline':False]
['text':'/ as an argument.','line_number':1807,'multiline':False]
['text':'/ Like `ml_get_buf`, but allow the line to be mutated in place.','line_number':1813,'multiline':False]
['text':'/','line_number':1814,'multiline':False]
['text':'/ This is very limited. Generally ml_replace_buf()','line_number':1815,'multiline':False]
['text':'/ should be used to modify a line.','line_number':1816,'multiline':False]
['text':'/','line_number':1817,'multiline':False]
['text':'/ @return a pointer to a line in the buffer','line_number':1818,'multiline':False]
['text':'/ @return  pointer to position "pos".','line_number':1824,'multiline':False]
['text':'/ @return  codepoint at pos. pos must be either valid or have col set to MAXCOL!','line_number':1831,'multiline':False]
['text':' When searching columns is sometimes put at the end of a line.','line_number':1835,'multiline':False]
['text':'/ @param will_change  true mark the buffer dirty (chars in the line will be changed)','line_number':1842,'multiline':False]
['text':'/','line_number':1843,'multiline':False]
['text':'/ @return  a pointer to a line in a specific buffer','line_number':1844,'multiline':False]
['text':' invalid line number','line_number':1851,'multiline':False]
['text':' Avoid giving this message for a recursive call, may happen when','line_number':1853,'multiline':False]
['text':' the GUI redraws part of the text.','line_number':1854,'multiline':False]
['text':' pretend line 0 is line 1','line_number':1865,'multiline':False]
['text':' there are no lines','line_number':1869,'multiline':False]
['text':' See if it is the same line as requested last time.','line_number':1873,'multiline':False]
['text':' Otherwise may need to flush last used line.','line_number':1874,'multiline':False]
['text':' Don't use the last used line when 'swapfile' is reset, need to load all','line_number':1875,'multiline':False]
['text':' blocks.','line_number':1876,'multiline':False]
['text':' Find the data block containing the line.','line_number':1880,'multiline':False]
['text':' This also fills the stack with the blocks from the root to the data','line_number':1881,'multiline':False]
['text':' block and releases any locked block.','line_number':1882,'multiline':False]
['text':' Avoid giving this message for a recursive call, may happen','line_number':1886,'multiline':False]
['text':' when the GUI redraws part of the text.','line_number':1887,'multiline':False]
['text':' can't make the change in the data block','line_number':1909,'multiline':False]
['text':' make sure the text is in allocated memory','line_number':1918,'multiline':False]
['text':' can't make the change in the data block','line_number':1922,'multiline':False]
['text':'/ Check if a line that was just obtained by a call to ml_get','line_number':1930,'multiline':False]
['text':'/ is in allocated memory.','line_number':1931,'multiline':False]
['text':'/ This ignores ML_ALLOCATED to get the same behavior as without ML_GET_ALLOC_LINES.','line_number':1932,'multiline':False]
['text':'/ Append a line after lnum (may be 0 to insert a line in front of the file).','line_number':1938,'multiline':False]
['text':'/ "line" does not need to be allocated, but can't be another line in a','line_number':1939,'multiline':False]
['text':'/ buffer, unlocking may make it invalid.','line_number':1940,'multiline':False]
['text':'/','line_number':1941,'multiline':False]
['text':'/   newfile: true when starting to edit a new file, meaning that pe_old_lnum','line_number':1942,'multiline':False]
['text':'/              will be set for recovery','line_number':1943,'multiline':False]
['text':'/ Check: The caller of this function should probably also call','line_number':1944,'multiline':False]
['text':'/ appended_lines().','line_number':1945,'multiline':False]
['text':'/','line_number':1946,'multiline':False]
['text':'/ @param lnum  append after this line (can be 0)','line_number':1947,'multiline':False]
['text':'/ @param line  text of the new line','line_number':1948,'multiline':False]
['text':'/ @param len  length of new line, including NUL, or 0','line_number':1949,'multiline':False]
['text':'/ @param newfile  flag, see above','line_number':1950,'multiline':False]
['text':'/','line_number':1951,'multiline':False]
['text':'/ @return  FAIL for failure, OK otherwise','line_number':1952,'multiline':False]
['text':' When starting up, we might still need to create the memfile','line_number':1955,'multiline':False]
['text':'/ Like ml_append() but for an arbitrary buffer.  The buffer must already have','line_number':1966,'multiline':False]
['text':'/ a memline.','line_number':1967,'multiline':False]
['text':'/','line_number':1968,'multiline':False]
['text':'/ @param lnum  append after this line (can be 0)','line_number':1969,'multiline':False]
['text':'/ @param line  text of the new line','line_number':1970,'multiline':False]
['text':'/ @param len  length of new line, including NUL, or 0','line_number':1971,'multiline':False]
['text':'/ @param newfile  flag, see above','line_number':1972,'multiline':False]
['text':'/ @param lnum  append after this line (can be 0)','line_number':1986,'multiline':False]
['text':'/ @param line  text of the new line','line_number':1987,'multiline':False]
['text':'/ @param len  length of line, including NUL, or 0','line_number':1988,'multiline':False]
['text':'/ @param newfile  flag, see above','line_number':1989,'multiline':False]
['text':'/ @param mark  mark the new line','line_number':1990,'multiline':False]
['text':' lnum out of range','line_number':1993,'multiline':False]
['text':' space needed for the text','line_number':2003,'multiline':False]
['text':' space needed for text + index','line_number':2005,'multiline':False]
['text':' find the data block containing the previous line','line_number':2010,'multiline':False]
['text':' This also fills the stack with the blocks from the root to the data block','line_number':2011,'multiline':False]
['text':' This also releases any locked block.','line_number':2012,'multiline':False]
['text':' index for lnum in data block','line_number':2021,'multiline':False]
['text':' got line one instead, correct db_idx','line_number':2022,'multiline':False]
['text':' careful, it is negative!','line_number':2023,'multiline':False]
['text':' get line count (number of indexes in current block) before the insertion','line_number':2027,'multiline':False]
['text':' If','line_number':2032,'multiline':False]
['text':' - there is not enough room in the current block','line_number':2033,'multiline':False]
['text':' - appending to the last line in the block','line_number':2034,'multiline':False]
['text':' - not appending to the last line in the file','line_number':2035,'multiline':False]
['text':' insert in front of the next block.','line_number':2036,'multiline':False]
['text':' Now that the line is not going to be inserted in the block that we','line_number':2039,'multiline':False]
['text':' expected, the line count has to be adjusted in the pointer blocks','line_number':2040,'multiline':False]
['text':' by using ml_locked_lineadd.','line_number':2041,'multiline':False]
['text':' careful, it is negative!','line_number':2048,'multiline':False]
['text':' get line count before the insertion','line_number':2049,'multiline':False]
['text':' enough room in data block','line_number':2058,'multiline':False]
['text':' Insert new line in existing data block, or in data block allocated above.','line_number':2059,'multiline':False]
['text':' move the text of the lines that follow to the front','line_number':2064,'multiline':False]
['text':' adjust the indexes of the lines that follow','line_number':2065,'multiline':False]
['text':' if there are following lines','line_number':2066,'multiline':False]
['text':' Offset is the start of the previous line.','line_number':2067,'multiline':False]
['text':' This will become the character just after the new line.','line_number':2068,'multiline':False]
['text':' add line at the end','line_number':2082,'multiline':False]
['text':' copy the text into the block','line_number':2086,'multiline':False]
['text':' Mark the block dirty.','line_number':2092,'multiline':False]
['text':' not enough space in data block','line_number':2097,'multiline':False]
['text':' If there is not enough room we have to create a new data block and copy some','line_number':2098,'multiline':False]
['text':' lines into it.','line_number':2099,'multiline':False]
['text':' Then we have to insert an entry in the pointer block.','line_number':2100,'multiline':False]
['text':' If this pointer block also is full, we go up another block, and so on, up','line_number':2101,'multiline':False]
['text':' to the root if necessary.','line_number':2102,'multiline':False]
['text':' The line counts in the pointer blocks have already been adjusted by','line_number':2103,'multiline':False]
['text':' ml_find_line().','line_number':2104,'multiline':False]
['text':' init to shut up gcc','line_number':2111,'multiline':False]
['text':' init to shut up gcc','line_number':2112,'multiline':False]
['text':' We are going to allocate a new data block. Depending on the','line_number':2118,'multiline':False]
['text':' situation it will be put to the left or right of the existing','line_number':2119,'multiline':False]
['text':' block.  If possible we put the new line in the left block and move','line_number':2120,'multiline':False]
['text':' the lines after it to the right block. Otherwise the new line is','line_number':2121,'multiline':False]
['text':' also put in the right block. This method is more efficient when','line_number':2122,'multiline':False]
['text':' inserting a lot of lines at one place.','line_number':2123,'multiline':False]
['text':' left block is new, right block is existing','line_number':2124,'multiline':False]
['text':' space_needed does not change','line_number':2127,'multiline':False]
['text':' left block is existing, right block is new','line_number':2128,'multiline':False]
['text':' put new line in right block','line_number':2131,'multiline':False]
['text':' space_needed does not change','line_number':2132,'multiline':False]
['text':' put new line in left block','line_number':2138,'multiline':False]
['text':' put new line in right block','line_number':2141,'multiline':False]
['text':' left block is new','line_number':2149,'multiline':False]
['text':' right block is new','line_number':2154,'multiline':False]
['text':' May move the new line into the right/new block.','line_number':2167,'multiline':False]
['text':' may move lines from the left/old block to the right/new one.','line_number':2180,'multiline':False]
['text':' update indexes in the new block','line_number':2191,'multiline':False]
['text':' May move the new line into the left (old or new) block.','line_number':2200,'multiline':False]
['text':' left block is new','line_number':2213,'multiline':False]
['text':' right block is new','line_number':2216,'multiline':False]
['text':' release the two data blocks','line_number':2227,'multiline':False]
['text':' The new one (hp_new) already has a correct blocknumber.','line_number':2228,'multiline':False]
['text':' The old one (hp, in ml_locked) gets a positive blocknumber if','line_number':2229,'multiline':False]
['text':' we changed it and we are not editing a new file.','line_number':2230,'multiline':False]
['text':' flush the old data block','line_number':2239,'multiline':False]
['text':' set ml_locked_lineadd to 0, because the updating of the','line_number':2240,'multiline':False]
['text':' pointer blocks is done below','line_number':2241,'multiline':False]
['text':' flush data block','line_number':2244,'multiline':False]
['text':' update pointer blocks for the new data block','line_number':2246,'multiline':False]
['text':' must be pointer block','line_number':2253,'multiline':False]
['text':' TODO(vim): If the pointer block is full and we are adding at the end','line_number':2259,'multiline':False]
['text':' try to insert in front of the next block','line_number':2260,'multiline':False]
['text':' block not full, add one entry','line_number':2261,'multiline':False]
['text':' truncate stack','line_number':2284,'multiline':False]
['text':' fix line count for rest of blocks in the stack','line_number':2288,'multiline':False]
['text':' fix stack itself','line_number':2290,'multiline':False]
['text':' We are finished, break the loop here.','line_number':2296,'multiline':False]
['text':' pointer block full','line_number':2299,'multiline':False]
['text':'','line_number':2300,'multiline':False]
['text':' split the pointer block','line_number':2301,'multiline':False]
['text':' allocate a new pointer block','line_number':2302,'multiline':False]
['text':' move some of the pointer into the new block','line_number':2303,'multiline':False]
['text':' prepare for updating the parent block','line_number':2304,'multiline':False]
['text':' do this twice when splitting block 1','line_number':2305,'multiline':False]
['text':' TODO(vim): try to fix tree','line_number':2307,'multiline':False]
['text':' if block 1 becomes full the tree is given an extra level','line_number':2316,'multiline':False]
['text':' The pointers from block 1 are moved into the new block.','line_number':2317,'multiline':False]
['text':' block 1 is updated to point to the new block','line_number':2318,'multiline':False]
['text':' then continue to split the new block','line_number':2319,'multiline':False]
['text':' release block 1','line_number':2326,'multiline':False]
['text':' new block is to be split','line_number':2327,'multiline':False]
['text':' do block 1 again later','line_number':2331,'multiline':False]
['text':' move the pointers after the current one to the new block','line_number':2333,'multiline':False]
['text':' If there are none, the new entry will be in the new block.','line_number':2334,'multiline':False]
['text':' recompute line counts','line_number':2364,'multiline':False]
['text':' Safety check: fallen out of for loop?','line_number':2382,'multiline':False]
['text':' invalidate stack','line_number':2385,'multiline':False]
['text':' The line was inserted below 'lnum'','line_number':2389,'multiline':False]
['text':' NL char','line_number':2413,'multiline':False]
['text':'/ Replace line "lnum", with buffering, in current buffer.','line_number':2423,'multiline':False]
['text':'/','line_number':2424,'multiline':False]
['text':'/ @param copy  if true, make a copy of the line, otherwise the line has been','line_number':2425,'multiline':False]
['text':'/              copied to allocated memory already.','line_number':2426,'multiline':False]
['text':'/              if false, the "line" may be freed to add text properties!','line_number':2427,'multiline':False]
['text':'/','line_number':2428,'multiline':False]
['text':'/ Do not use it after calling ml_replace().','line_number':2429,'multiline':False]
['text':'/','line_number':2430,'multiline':False]
['text':'/ Check: The caller of this function should probably also call','line_number':2431,'multiline':False]
['text':'/ changed_lines(), unless update_screen(UPD_NOT_VALID) is used.','line_number':2432,'multiline':False]
['text':'/','line_number':2433,'multiline':False]
['text':'/ @return  FAIL for failure, OK otherwise','line_number':2434,'multiline':False]
['text':' just checking...','line_number':2437,'multiline':False]
['text':' When starting up, we might still need to create the memfile','line_number':2441,'multiline':False]
['text':' another line is buffered, flush it','line_number':2451,'multiline':False]
['text':' free allocated line','line_number':2460,'multiline':False]
['text':'/ Delete line `lnum` in the current buffer.','line_number':2470,'multiline':False]
['text':'/','line_number':2471,'multiline':False]
['text':'/ @note The caller of this function should probably also call','line_number':2472,'multiline':False]
['text':'/ deleted_lines() after this.','line_number':2473,'multiline':False]
['text':'/','line_number':2474,'multiline':False]
['text':'/ @param message  Show "--No lines in buffer--" message.','line_number':2475,'multiline':False]
['text':'/','line_number':2476,'multiline':False]
['text':'/ @return  FAIL for failure, OK otherwise','line_number':2477,'multiline':False]
['text':'/ Delete line `lnum` in buffer','line_number':2484,'multiline':False]
['text':'/','line_number':2485,'multiline':False]
['text':'/ @note The caller of this function should probably also call changed_lines() after this.','line_number':2486,'multiline':False]
['text':'/','line_number':2487,'multiline':False]
['text':'/ @param message  Show "--No lines in buffer--" message.','line_number':2488,'multiline':False]
['text':'/','line_number':2489,'multiline':False]
['text':'/ @return  FAIL for failure, OK otherwise','line_number':2490,'multiline':False]
['text':' If the file becomes empty the last line is replaced by an empty line.','line_number':2507,'multiline':False]
['text':' file becomes empty','line_number':2508,'multiline':False]
['text':' find the data block containing the line','line_number':2519,'multiline':False]
['text':' This also fills the stack with the blocks from the root to the data block','line_number':2520,'multiline':False]
['text':' This also releases any locked block.','line_number':2521,'multiline':False]
['text':' compute line count (number of entries in block) before the delete','line_number':2533,'multiline':False]
['text':' first line in block, text at the end','line_number':2541,'multiline':False]
['text':' Line should always have an NL char internally (represented as NUL),','line_number':2547,'multiline':False]
['text':' even if 'noeol' is set.','line_number':2548,'multiline':False]
['text':' special case: If there is only one line in the data block it becomes empty.','line_number':2552,'multiline':False]
['text':' Then we have to remove the entry, pointing to this data block, from the','line_number':2553,'multiline':False]
['text':' pointer block. If this pointer block also becomes empty, we go up another','line_number':2554,'multiline':False]
['text':' block, and so on, up to the root if necessary.','line_number':2555,'multiline':False]
['text':' The line counts in the pointer blocks have already been adjusted by','line_number':2556,'multiline':False]
['text':' ml_find_line().','line_number':2557,'multiline':False]
['text':' free the data block','line_number':2559,'multiline':False]
['text':' stack is invalid when failing','line_number':2563,'multiline':False]
['text':' must be pointer block','line_number':2569,'multiline':False]
['text':' the pointer block becomes empty!','line_number':2576,'multiline':False]
['text':' move entries after the deleted one','line_number':2579,'multiline':False]
['text':' truncate stack','line_number':2585,'multiline':False]
['text':' fix line count for rest of blocks in the stack','line_number':2586,'multiline':False]
['text':' delete the text by moving the next lines forwards','line_number':2599,'multiline':False]
['text':' delete the index by moving the next indexes backwards','line_number':2604,'multiline':False]
['text':' Adjust the indexes for the text movement.','line_number':2605,'multiline':False]
['text':' mark the block dirty and make sure it is in the file (for recovery)','line_number':2614,'multiline':False]
['text':'/ set the B_MARKED flag for line 'lnum'','line_number':2622,'multiline':False]
['text':' invalid line number','line_number':2625,'multiline':False]
['text':' give error message?','line_number':2628,'multiline':False]
['text':' find the data block containing the line','line_number':2634,'multiline':False]
['text':' This also fills the stack with the blocks from the root to the data block','line_number':2635,'multiline':False]
['text':' This also releases any locked block.','line_number':2636,'multiline':False]
['text':' give error message?','line_number':2639,'multiline':False]
['text':'/ find the first line with its B_MARKED flag set','line_number':2646,'multiline':False]
['text':' The search starts with lowest_marked line. This is the last line where','line_number':2653,'multiline':False]
['text':' a mark was found, adjusted by inserting/deleting lines.','line_number':2654,'multiline':False]
['text':' Find the data block containing the line.','line_number':2656,'multiline':False]
['text':' This also fills the stack with the blocks from the root to the data','line_number':2657,'multiline':False]
['text':' block This also releases any locked block.','line_number':2658,'multiline':False]
['text':' give error message?','line_number':2661,'multiline':False]
['text':'/ clear all DB_MARKED flags','line_number':2679,'multiline':False]
['text':' nothing to do','line_number':2682,'multiline':False]
['text':' The search starts with line lowest_marked.','line_number':2686,'multiline':False]
['text':' Find the data block containing the line.','line_number':2688,'multiline':False]
['text':' This also fills the stack with the blocks from the root to the data','line_number':2689,'multiline':False]
['text':' block and releases any locked block.','line_number':2690,'multiline':False]
['text':' give error message?','line_number':2693,'multiline':False]
['text':'/ flush ml_line if necessary','line_number':2720,'multiline':False]
['text':' nothing to do','line_number':2726,'multiline':False]
['text':' This code doesn't work recursively.','line_number':2729,'multiline':False]
['text':' line is last in block','line_number':2749,'multiline':False]
['text':' text of previous line follows','line_number':2751,'multiline':False]
['text':' negative if lines gets smaller','line_number':2755,'multiline':False]
['text':' if new line fits in data block, replace directly','line_number':2757,'multiline':False]
['text':' if the length changes and there are following lines','line_number':2759,'multiline':False]
['text':' move text of following lines','line_number':2762,'multiline':False]
['text':' adjust pointers of this and following lines','line_number':2767,'multiline':False]
['text':' adjust free space','line_number':2774,'multiline':False]
['text':' copy new line into the data block','line_number':2778,'multiline':False]
['text':' The else case is already covered by the insert and delete','line_number':2781,'multiline':False]
['text':' Cannot do it in one data block: Delete and append.','line_number':2784,'multiline':False]
['text':' Append first, because ml_delete_int() cannot delete the','line_number':2785,'multiline':False]
['text':' last line in a buffer, which causes trouble for a buffer','line_number':2786,'multiline':False]
['text':' that has only one line.','line_number':2787,'multiline':False]
['text':' Don't forget to copy the mark!','line_number':2788,'multiline':False]
['text':' How about handling errors???','line_number':2789,'multiline':False]
['text':'/ create a new, empty, data block','line_number':2807,'multiline':False]
['text':'/ create a new, empty, pointer block','line_number':2821,'multiline':False]
['text':'/ lookup line 'lnum' in a memline','line_number':2833,'multiline':False]
['text':'/','line_number':2834,'multiline':False]
['text':'/ @param action: if ML_DELETE or ML_INSERT the line count is updated while searching','line_number':2835,'multiline':False]
['text':'/                if ML_FLUSH only flush a locked block','line_number':2836,'multiline':False]
['text':'/                if ML_FIND just find the line','line_number':2837,'multiline':False]
['text':'/','line_number':2838,'multiline':False]
['text':'/ If the block was found it is locked and put in ml_locked.','line_number':2839,'multiline':False]
['text':'/ The stack is updated to lead to the locked block. The ip_high field in','line_number':2840,'multiline':False]
['text':'/ the stack is updated to reflect the last line in the block AFTER the','line_number':2841,'multiline':False]
['text':'/ insert or delete, also if the pointer block has not been updated yet. But','line_number':2842,'multiline':False]
['text':'/ if ml_locked != NULL ml_locked_lineadd must be added to ip_high.','line_number':2843,'multiline':False]
['text':'/','line_number':2844,'multiline':False]
['text':'/ @return  NULL for failure, pointer to block header otherwise','line_number':2845,'multiline':False]
['text':' If there is a locked block check if the wanted line is in it.','line_number':2853,'multiline':False]
['text':' If not, flush and release the locked block.','line_number':2854,'multiline':False]
['text':' Don't do this for ML_INSERT_SAME, because the stack need to be updated.','line_number':2855,'multiline':False]
['text':' Don't do this for ML_FLUSH, because we want to flush the locked block.','line_number':2856,'multiline':False]
['text':' Don't do this when 'swapfile' is reset, we want to load all the blocks.','line_number':2857,'multiline':False]
['text':' remember to update pointer blocks and stack later','line_number':2862,'multiline':False]
['text':' If lines have been added or deleted in the locked block, need to','line_number':2877,'multiline':False]
['text':' update the line count in pointer blocks.','line_number':2878,'multiline':False]
['text':' nothing else to do','line_number':2884,'multiline':False]
['text':' start at the root of the tree','line_number':2888,'multiline':False]
['text':' first try stack entries','line_number':2894,'multiline':False]
['text':' truncate stack at prev entry','line_number':2901,'multiline':False]
['text':' not found, start at the root','line_number':2906,'multiline':False]
['text':' ML_DELETE or ML_INSERT','line_number':2908,'multiline':False]
['text':' start at the root','line_number':2909,'multiline':False]
['text':' search downwards in the tree until a data block is found','line_number':2911,'multiline':False]
['text':' update high for insert/delete','line_number':2917,'multiline':False]
['text':' data block','line_number':2925,'multiline':False]
['text':' must be pointer block','line_number':2934,'multiline':False]
['text':' add new entry to stack','line_number':2940,'multiline':False]
['text':' index not known yet','line_number':2945,'multiline':False]
['text':' a negative block number may have been changed','line_number':2959,'multiline':False]
['text':' past the end: something wrong!','line_number':2972,'multiline':False]
['text':' If action is ML_DELETE or ML_INSERT we have to correct the tree for','line_number':2994,'multiline':False]
['text':' the incremented/decremented line counts, because there won't be a line','line_number':2995,'multiline':False]
['text':' inserted/deleted after all.','line_number':2996,'multiline':False]
['text':'/ add an entry to the info pointer stack','line_number':3006,'multiline':False]
['text':'/','line_number':3007,'multiline':False]
['text':'/ @return  number of the new entry','line_number':3008,'multiline':False]
['text':' may have to increase the stack size','line_number':3013,'multiline':False]
['text':' more than 5 levels???','line_number':3015,'multiline':False]
['text':'/ Update the pointer blocks on the stack for inserted/deleted lines.','line_number':3026,'multiline':False]
['text':'/ The stack itself is also updated.','line_number':3027,'multiline':False]
['text':'/','line_number':3028,'multiline':False]
['text':'/ When an insert/delete line action fails, the line is not inserted/deleted,','line_number':3029,'multiline':False]
['text':'/ but the pointer blocks have already been updated. That is fixed here by','line_number':3030,'multiline':False]
['text':'/ walking through the stack.','line_number':3031,'multiline':False]
['text':'/','line_number':3032,'multiline':False]
['text':'/ Count is the number of lines added, negative if lines have been deleted.','line_number':3033,'multiline':False]
['text':' must be pointer block','line_number':3044,'multiline':False]
['text':'/ Resolve a symlink in the last component of a file name.','line_number':3058,'multiline':False]
['text':'/ Note that f_resolve() does it for every part of the path, we don't do that','line_number':3059,'multiline':False]
['text':'/ here.','line_number':3060,'multiline':False]
['text':'/','line_number':3061,'multiline':False]
['text':'/ @return  OK if it worked and the resolved link in "buf[MAXPATHL]",','line_number':3062,'multiline':False]
['text':'/          FAIL otherwise','line_number':3063,'multiline':False]
['text':' Put the result so far in tmp[], starting with the original name.','line_number':3073,'multiline':False]
['text':' Limit symlink depth to 100, catch recursive loops.','line_number':3077,'multiline':False]
['text':' Found non-symlink or not existing file, stop here.','line_number':3086,'multiline':False]
['text':' When at the first level use the unmodified name, skip the','line_number':3087,'multiline':False]
['text':' call to vim_FullName().','line_number':3088,'multiline':False]
['text':' Use the resolved name in tmp[].','line_number':3093,'multiline':False]
['text':' There must be some error reading links, use original name.','line_number':3097,'multiline':False]
['text':' Check whether the symlink is relative or absolute.','line_number':3102,'multiline':False]
['text':' If it's relative, build a new path based on the directory','line_number':3103,'multiline':False]
['text':' portion of the filename (if any) and the path the symlink','line_number':3104,'multiline':False]
['text':' points to.','line_number':3105,'multiline':False]
['text':' Try to resolve the full name of the file so that the swapfile name will','line_number':3117,'multiline':False]
['text':' be consistent even when opening a relative symlink from different','line_number':3118,'multiline':False]
['text':' working directories.','line_number':3119,'multiline':False]
['text':'/ Make swapfile name out of the file name and a directory name.','line_number':3124,'multiline':False]
['text':'/','line_number':3125,'multiline':False]
['text':'/ @return  pointer to allocated memory or NULL.','line_number':3126,'multiline':False]
['text':' Expand symlink in the file name, so that we put the swapfile with the','line_number':3133,'multiline':False]
['text':' actual file instead of with the symlink.','line_number':3134,'multiline':False]
['text':' Ends with '//', Use Full path','line_number':3144,'multiline':False]
['text':' Prepend a '.' to the swapfile name for the current directory.','line_number':3154,'multiline':False]
['text':' out of memory','line_number':3157,'multiline':False]
['text':'/ Get file name to use for swapfile or backup file.','line_number':3166,'multiline':False]
['text':'/ Use the name of the edited file "fname" and an entry in the 'dir' or 'bdir' option "dname".','line_number':3167,'multiline':False]
['text':'/ - If "dname" is ".", return "fname" (swapfile in dir of file).','line_number':3168,'multiline':False]
['text':'/ - If "dname" starts with "./", insert "dname" in "fname" (swapfile relative to dir of file).','line_number':3169,'multiline':False]
['text':'/ - Otherwise, prepend "dname" to the tail of "fname" (swapfile in specific dir).','line_number':3170,'multiline':False]
['text':'/','line_number':3171,'multiline':False]
['text':'/ The return value is an allocated string and can be NULL.','line_number':3172,'multiline':False]
['text':'/','line_number':3173,'multiline':False]
['text':'/ @param dname  don't use "dirname", it is a global for Alpha','line_number':3174,'multiline':False]
['text':' no path before file name','line_number':3184,'multiline':False]
['text':'/ Print the ATTENTION message: info about an existing swapfile.','line_number':3201,'multiline':False]
['text':'/','line_number':3202,'multiline':False]
['text':'/ @param buf  buffer being edited','line_number':3203,'multiline':False]
['text':'/ @param fname  swapfile name','line_number':3204,'multiline':False]
['text':' Some of these messages are long to allow translation to','line_number':3230,'multiline':False]
['text':' other languages.','line_number':3231,'multiline':False]
['text':'/ Trigger the SwapExists autocommands.','line_number':3247,'multiline':False]
['text':'/','line_number':3248,'multiline':False]
['text':'/ @return  a value for equivalent to do_dialog().','line_number':3249,'multiline':False]
['text':' Trigger SwapExists autocommands with <afile> set to the file being','line_number':3255,'multiline':False]
['text':' edited.  Disallow changing directory here.','line_number':3256,'multiline':False]
['text':'/ Find out what name to use for the swapfile for buffer 'buf'.','line_number':3281,'multiline':False]
['text':'/','line_number':3282,'multiline':False]
['text':'/ Several names are tried to find one that does not exist. Last directory in','line_number':3283,'multiline':False]
['text':'/ option is automatically created.','line_number':3284,'multiline':False]
['text':'/','line_number':3285,'multiline':False]
['text':'/ @note If BASENAMELEN is not correct, you will get error messages for','line_number':3286,'multiline':False]
['text':'/   not being able to open the swap or undo file.','line_number':3287,'multiline':False]
['text':'/ @note May trigger SwapExists autocmd, pointers may change!','line_number':3288,'multiline':False]
['text':'/','line_number':3289,'multiline':False]
['text':'/ @param[in]  buf  Buffer for which swapfile names needs to be found.','line_number':3290,'multiline':False]
['text':'/ @param[in,out]  dirp  Pointer to a list of directories. When out of memory,','line_number':3291,'multiline':False]
['text':'/                       is set to NULL. Is advanced to the next directory in','line_number':3292,'multiline':False]
['text':'/                       the list otherwise.','line_number':3293,'multiline':False]
['text':'/ @param[in]  old_fname  Allowed existing swapfile name. Except for this','line_number':3294,'multiline':False]
['text':'/                        case, name of the non-existing file is used.','line_number':3295,'multiline':False]
['text':'/ @param[in,out]  found_existing_dir  If points to true, then new directory','line_number':3296,'multiline':False]
['text':'/                                     for swapfile is not created. At first','line_number':3297,'multiline':False]
['text':'/                                     findswapname() call this argument must','line_number':3298,'multiline':False]
['text':'/                                     point to false. This parameter may only','line_number':3299,'multiline':False]
['text':'/                                     be set to true by this function, it is','line_number':3300,'multiline':False]
['text':'/                                     never set to false.','line_number':3301,'multiline':False]
['text':'/','line_number':3302,'multiline':False]
['text':'/ @return [allocated] Name of the swapfile.','line_number':3303,'multiline':False]
['text':' Isolate a directory name from *dirp and put it in dir_name.','line_number':3309,'multiline':False]
['text':' First allocate some memory to put the directory name in.','line_number':3310,'multiline':False]
['text':' We try different swapfile names until we find one that does not exist yet.','line_number':3315,'multiline':False]
['text':' must be out of memory','line_number':3320,'multiline':False]
['text':' safety check','line_number':3323,'multiline':False]
['text':' check if the swapfile already exists','line_number':3327,'multiline':False]
['text':' Extra security check: When a swapfile is a symbolic link, this','line_number':3328,'multiline':False]
['text':' is most likely a symlink attack.','line_number':3329,'multiline':False]
['text':' A file name equal to old_fname is OK to use.','line_number':3336,'multiline':False]
['text':' get here when file already exists','line_number':3341,'multiline':False]
['text':' first try','line_number':3342,'multiline':False]
['text':' If we get here the ".swp" file really exists.','line_number':3343,'multiline':False]
['text':' Give an error message, unless recovering, no file name, we are','line_number':3344,'multiline':False]
['text':' viewing a help file or when the path of the file is different','line_number':3345,'multiline':False]
['text':' (happens when all .swp files are in one directory).','line_number':3346,'multiline':False]
['text':' Try to read block 0 from the swapfile to get the original file name (and inode number).','line_number':3352,'multiline':False]
['text':' If the swapfile has the same directory as the','line_number':3358,'multiline':False]
['text':' buffer don't compare the directory names, they can','line_number':3359,'multiline':False]
['text':' have a different mountpoint.','line_number':3360,'multiline':False]
['text':' Symlinks may point to the same file even','line_number':3365,'multiline':False]
['text':' when the name differs, need to check the','line_number':3366,'multiline':False]
['text':' inode too.','line_number':3367,'multiline':False]
['text':' The name in the swapfile may be "~user/path/file".  Expand it first.','line_number':3375,'multiline':False]
['text':' Show the ATTENTION message when:','line_number':3386,'multiline':False]
['text':'  - there is an old swapfile for the current file','line_number':3387,'multiline':False]
['text':'  - the buffer was not recovered','line_number':3388,'multiline':False]
['text':' It's safe to delete the swapfile if all these are true:','line_number':3393,'multiline':False]
['text':' - the edited file exists','line_number':3394,'multiline':False]
['text':' - the swapfile has no changes and looks OK','line_number':3395,'multiline':False]
['text':' If there is a SwapExists autocommand and we can handle the','line_number':3403,'multiline':False]
['text':' response, trigger it.  It may return 0 to ask the user anyway.','line_number':3404,'multiline':False]
['text':' always open readonly.','line_number':3412,'multiline':False]
['text':' Set by attention_message..swapfile_info.','line_number':3416,'multiline':False]
['text':' Show info about the existing swapfile.','line_number':3418,'multiline':False]
['text':' We don't want a 'q' typed at the more-prompt','line_number':3421,'multiline':False]
['text':' interrupt loading a file.','line_number':3422,'multiline':False]
['text':' If vimrc has "simalt ~x" we don't want it to','line_number':3425,'multiline':False]
['text':' interfere with the prompt here.','line_number':3426,'multiline':False]
['text':' compensate for missing "Delete it" button','line_number':3454,'multiline':False]
['text':' pretend screen didn't scroll, need redraw anyway','line_number':3460,'multiline':False]
['text':' "Open Read-Only"','line_number':3465,'multiline':False]
['text':' "Edit anyway"','line_number':3468,'multiline':False]
['text':' "Recover"','line_number':3470,'multiline':False]
['text':' "Delete it"','line_number':3473,'multiline':False]
['text':' "Quit"','line_number':3476,'multiline':False]
['text':' "Abort"','line_number':3479,'multiline':False]
['text':' call wait_return() later','line_number':3486,'multiline':False]
['text':' If the swapfile was deleted this `fname` can be used.','line_number':3492,'multiline':False]
['text':' Permute the ".swp" extension to find a unique swapfile name.','line_number':3500,'multiline':False]
['text':' First decrement the last char: ".swo", ".swn", etc.','line_number':3501,'multiline':False]
['text':' If that still isn't enough decrement the last but one char: ".svz"','line_number':3502,'multiline':False]
['text':' Can happen when many Nvim instances are editing the same file (including "No Name" buffers).','line_number':3503,'multiline':False]
['text':' ".s?a"','line_number':3504,'multiline':False]
['text':' ".saa": tried enough, give up','line_number':3505,'multiline':False]
['text':' ".svz", ".suz", etc.','line_number':3510,'multiline':False]
['text':' ".swo", ".swn", etc.','line_number':3513,'multiline':False]
['text':'/ Compare current file name with file name from swapfile.','line_number':3541,'multiline':False]
['text':'/ Try to use inode numbers when possible.','line_number':3542,'multiline':False]
['text':'/ Return non-zero when files are different.','line_number':3543,'multiline':False]
['text':'/','line_number':3544,'multiline':False]
['text':'/ When comparing file names a few things have to be taken into consideration:','line_number':3545,'multiline':False]
['text':'/ - When working over a network the full path of a file depends on the host.','line_number':3546,'multiline':False]
['text':'/   We check the inode number if possible.  It is not 100% reliable though,','line_number':3547,'multiline':False]
['text':'/   because the device number cannot be used over a network.','line_number':3548,'multiline':False]
['text':'/ - When a file does not exist yet (editing a new file) there is no inode','line_number':3549,'multiline':False]
['text':'/   number.','line_number':3550,'multiline':False]
['text':'/ - The file name in a swapfile may not be valid on the current host.  The','line_number':3551,'multiline':False]
['text':'/   "~user" form is used whenever possible to avoid this.','line_number':3552,'multiline':False]
['text':'/','line_number':3553,'multiline':False]
['text':'/ This is getting complicated, let's make a table:','line_number':3554,'multiline':False]
['text':'/','line_number':3555,'multiline':False]
['text':'/              ino_c  ino_s  fname_c  fname_s  differ =','line_number':3556,'multiline':False]
['text':'/','line_number':3557,'multiline':False]
['text':'/ both files exist -> compare inode numbers:','line_number':3558,'multiline':False]
['text':'/              != 0   != 0     X        X      ino_c != ino_s','line_number':3559,'multiline':False]
['text':'/','line_number':3560,'multiline':False]
['text':'/ inode number(s) unknown, file names available -> compare file names','line_number':3561,'multiline':False]
['text':'/              == 0    X       OK       OK     fname_c != fname_s','line_number':3562,'multiline':False]
['text':'/               X     == 0     OK       OK     fname_c != fname_s','line_number':3563,'multiline':False]
['text':'/','line_number':3564,'multiline':False]
['text':'/ current file doesn't exist, file for swapfile exist, file name(s) not','line_number':3565,'multiline':False]
['text':'/ available -> probably different','line_number':3566,'multiline':False]
['text':'/              == 0   != 0    FAIL      X      true','line_number':3567,'multiline':False]
['text':'/              == 0   != 0     X       FAIL    true','line_number':3568,'multiline':False]
['text':'/','line_number':3569,'multiline':False]
['text':'/ current file exists, inode for swap unknown, file name(s) not','line_number':3570,'multiline':False]
['text':'/ available -> probably different','line_number':3571,'multiline':False]
['text':'/              != 0   == 0    FAIL      X      true','line_number':3572,'multiline':False]
['text':'/              != 0   == 0     X       FAIL    true','line_number':3573,'multiline':False]
['text':'/','line_number':3574,'multiline':False]
['text':'/ current file doesn't exist, inode for swap unknown, one file name not','line_number':3575,'multiline':False]
['text':'/ available -> probably different','line_number':3576,'multiline':False]
['text':'/              == 0   == 0    FAIL      OK     true','line_number':3577,'multiline':False]
['text':'/              == 0   == 0     OK      FAIL    true','line_number':3578,'multiline':False]
['text':'/','line_number':3579,'multiline':False]
['text':'/ current file doesn't exist, inode for swap unknown, both file names not','line_number':3580,'multiline':False]
['text':'/ available -> compare file names','line_number':3581,'multiline':False]
['text':'/              == 0   == 0    FAIL     FAIL    fname_c != fname_s','line_number':3582,'multiline':False]
['text':'/','line_number':3583,'multiline':False]
['text':'/ Only the last 32 bits of the inode will be used. This can't be changed','line_number':3584,'multiline':False]
['text':'/ without making the block 0 incompatible with 32 bit versions.','line_number':3585,'multiline':False]
['text':'/','line_number':3586,'multiline':False]
['text':'/ @param fname_c  current file name','line_number':3587,'multiline':False]
['text':'/ @param fname_s  file name from swapfile','line_number':3588,'multiline':False]
['text':' ino of current file','line_number':3591,'multiline':False]
['text':' ino of file from swapfile','line_number':3592,'multiline':False]
['text':' full path of fname_c','line_number':3593,'multiline':False]
['text':' full path of fname_s','line_number':3594,'multiline':False]
['text':' flag: buf_c valid','line_number':3595,'multiline':False]
['text':' flag: buf_s valid','line_number':3596,'multiline':False]
['text':' First we try to get the inode from the file name, because the inode in','line_number':3603,'multiline':False]
['text':' the swapfile may be outdated.  If that fails (e.g. this path is not','line_number':3604,'multiline':False]
['text':' valid on this machine), use the inode from block 0.','line_number':3605,'multiline':False]
['text':' One of the inode numbers is unknown, try a forced vim_FullName() and','line_number':3616,'multiline':False]
['text':' compare the file names.','line_number':3617,'multiline':False]
['text':' Can't compare inodes or file names, guess that the files are different,','line_number':3624,'multiline':False]
['text':' unless both appear not to exist at all, then compare with the file name','line_number':3625,'multiline':False]
['text':' in the swapfile.','line_number':3626,'multiline':False]
['text':'/ Move a long integer into a four byte character array.','line_number':3633,'multiline':False]
['text':'/ Used for machine independency in block zero.','line_number':3634,'multiline':False]
['text':'/ Set the flags in the first block of the swapfile:','line_number':3662,'multiline':False]
['text':'/ - file is modified or not: buf->b_changed','line_number':3663,'multiline':False]
['text':'/ - 'fileformat'','line_number':3664,'multiline':False]
['text':'/ - 'fileencoding'','line_number':3665,'multiline':False]
['text':' max no of lines in chunk','line_number':3683,'multiline':False]
['text':' should be half of MLCS_MAXL','line_number':3684,'multiline':False]
['text':'/ Keep information for finding byte offset of a line','line_number':3687,'multiline':False]
['text':'/','line_number':3688,'multiline':False]
['text':'/ @param updtype  may be one of:','line_number':3689,'multiline':False]
['text':'/                 ML_CHNK_ADDLINE: Add len to parent chunk, possibly splitting it','line_number':3690,'multiline':False]
['text':'/                         Careful: ML_CHNK_ADDLINE may cause ml_find_line() to be called.','line_number':3691,'multiline':False]
['text':'/                 ML_CHNK_DELLINE: Subtract len from parent chunk, possibly deleting it','line_number':3692,'multiline':False]
['text':'/                 ML_CHNK_UPDLINE: Add len to parent chunk, as a signed entity.','line_number':3693,'multiline':False]
['text':' First line in empty buffer from ml_flush_line() -- reset','line_number':3717,'multiline':False]
['text':' Find chunk that our line belongs to, curline will be at start of the','line_number':3724,'multiline':False]
['text':' chunk.','line_number':3725,'multiline':False]
['text':' Adjust cached curix & curline','line_number':3737,'multiline':False]
['text':' May resize here so we don't have to do it in both cases below','line_number':3752,'multiline':False]
['text':' Compute length of first half of lines in the split chunk','line_number':3765,'multiline':False]
['text':' number of entries in block','line_number':3776,'multiline':False]
['text':' first line in block, text at the end','line_number':3779,'multiline':False]
['text':' Compute index of last line to use in this MEMLINE','line_number':3784,'multiline':False]
['text':' Force recalc of curix & curline','line_number':3800,'multiline':False]
['text':' We are in the last chunk and it is cheap to create a new one','line_number':3805,'multiline':False]
['text':' after this. Do it now to avoid the loop above later on','line_number':3806,'multiline':False]
['text':' Line is just prior to last, move count for last','line_number':3813,'multiline':False]
['text':' This is the common case  when loading a new file','line_number':3814,'multiline':False]
['text':' Force recalc of curix & curline','line_number':3835,'multiline':False]
['text':' Collapse chunks','line_number':3853,'multiline':False]
['text':'/ Find offset for line or line with offset.','line_number':3870,'multiline':False]
['text':'/','line_number':3871,'multiline':False]
['text':'/ @param buf buffer to use','line_number':3872,'multiline':False]
['text':'/ @param lnum if > 0, find offset of lnum, return offset','line_number':3873,'multiline':False]
['text':'/             if == 0, return line with offset *offp','line_number':3874,'multiline':False]
['text':'/ @param offp offset to use to find line, store remaining column offset','line_number':3875,'multiline':False]
['text':'/             Should be NULL when getting offset of line','line_number':3876,'multiline':False]
['text':'/ @param no_ff ignore 'fileformat' option, always use one byte for NL.','line_number':3877,'multiline':False]
['text':'/','line_number':3878,'multiline':False]
['text':'/ @return  -1 if information is not available','line_number':3879,'multiline':False]
['text':' take care of cached line first. Only needed if the cached line is before','line_number':3888,'multiline':False]
['text':' the requested line. Additionally cache the value for the cached line.','line_number':3889,'multiline':False]
['text':' This is used by the extmark code which needs the byte offset of the edited','line_number':3890,'multiline':False]
['text':' line. So when doing multiple small edits on the same line the value is','line_number':3891,'multiline':False]
['text':' only calculated once.','line_number':3892,'multiline':False]
['text':'','line_number':3893,'multiline':False]
['text':' NB: caching doesn't work with 'fileformat'. This is not a problem for','line_number':3894,'multiline':False]
['text':' bytetracking, as bytetracking ignores 'fileformat' option. But calling','line_number':3895,'multiline':False]
['text':' line2byte() will invalidate the cache for the time being (this function','line_number':3896,'multiline':False]
['text':' was never cached to start with anyway).','line_number':3897,'multiline':False]
['text':' memline is currently empty. Although if it is loaded,','line_number':3908,'multiline':False]
['text':' it behaves like there is one empty line.','line_number':3909,'multiline':False]
['text':' Not a "find offset" and offset 0 _must_ be in line 1','line_number':3922,'multiline':False]
['text':' Find the last chunk before the one containing our line. Last chunk is','line_number':3924,'multiline':False]
['text':' special because it will never qualify','line_number':3925,'multiline':False]
['text':' number of entries in block','line_number':3951,'multiline':False]
['text':' first line in block, text at the end','line_number':3954,'multiline':False]
['text':' Compute index of last line to use in this MEMLINE','line_number':3959,'multiline':False]
['text':' exactly one byte beyond the end','line_number':3994,'multiline':False]
['text':' Count extra CR characters.','line_number':4002,'multiline':False]
['text':' Don't count the last line break if 'noeol' and ('bin' or','line_number':4007,'multiline':False]
['text':' 'nofixeol').','line_number':4008,'multiline':False]
['text':'/ Goto byte in buffer with offset 'cnt'.','line_number':4022,'multiline':False]
['text':' cached line may be dirty','line_number':4027,'multiline':False]
['text':' past the end','line_number':4033,'multiline':False]
['text':' Make sure the cursor is on the first byte of a multi-byte char.','line_number':4045,'multiline':False]
['text':'/ Increment the line pointer "lp" crossing line boundaries as necessary.','line_number':4049,'multiline':False]
['text':'/','line_number':4050,'multiline':False]
['text':'/ @return   1 when going to the next line.','line_number':4051,'multiline':False]
['text':'/           2 when moving forward onto a NUL at the end of the line).','line_number':4052,'multiline':False]
['text':'/          -1 when at the end of file.','line_number':4053,'multiline':False]
['text':'/           0 otherwise.','line_number':4054,'multiline':False]
['text':' when searching position may be set to end of a line','line_number':4057,'multiline':False]
['text':' still within line, move to next char (may be NUL)','line_number':4060,'multiline':False]
['text':' there is a next line','line_number':4067,'multiline':False]
['text':'/ Same as inc(), but skip NUL at the end of non-empty lines.','line_number':4076,'multiline':False]
['text':' past end of line','line_number':4091,'multiline':False]
['text':' still within line','line_number':4099,'multiline':False]
['text':' there is a prior line','line_number':4106,'multiline':False]
['text':' at start of file','line_number':4114,'multiline':False]
['text':'/ Same as dec(), but skip NUL at the end of non-empty lines.','line_number':4118,'multiline':False]
