['text':' Input before UI starts.','line_number':40,'multiline':False]
['text':'/< time waiting for CursorHold event','line_number':44,'multiline':False]
['text':'/< tb_change_cnt when waiting started','line_number':45,'multiline':False]
['text':' If events are enabled and the queue has any items, this function should not','line_number':93,'multiline':False]
['text':' have been called(inbuf_poll would return kInputAvail)','line_number':94,'multiline':False]
['text':' TODO(tarruda): Cursorhold should be implemented as a timer set during the','line_number':95,'multiline':False]
['text':' `state_check` callback for the states where it can be triggered.','line_number':96,'multiline':False]
['text':'/ Low level input function','line_number':107,'multiline':False]
['text':'/','line_number':108,'multiline':False]
['text':'/ wait until either the input buffer is non-empty or, if `events` is not NULL','line_number':109,'multiline':False]
['text':'/ until `events` is non-empty.','line_number':110,'multiline':False]
['text':' This check is needed so that feeding typeahead from RPC can prevent CursorHold.','line_number':113,'multiline':False]
['text':' No risk of a UI flood, so disable CTRL-C "interrupt" behavior if it's mapped.','line_number':123,'multiline':False]
['text':' Drained eventloop & initial input; exit silent/batch-mode (-es/-Es).','line_number':138,'multiline':False]
['text':' If input was put directly in typeahead buffer bail out here.','line_number':155,'multiline':False]
['text':' Safe to convert rbuffer_read to int, it will never overflow since we use','line_number':162,'multiline':False]
['text':' relatively small buffers.','line_number':163,'multiline':False]
['text':' If there are events, return the keys directly','line_number':167,'multiline':False]
['text':' Check if a character is available for reading','line_number':179,'multiline':False]
['text':'/ Poll for fast events. `got_int` will be set to `true` if CTRL-C was typed.','line_number':185,'multiline':False]
['text':'/','line_number':186,'multiline':False]
['text':'/ This invokes a full libuv loop iteration which can be quite costly.','line_number':187,'multiline':False]
['text':'/ Prefer `line_breakcheck()` if called in a busy inner loop.','line_number':188,'multiline':False]
['text':'/','line_number':189,'multiline':False]
['text':'/ Caller must at least check `got_int` before calling this function again.','line_number':190,'multiline':False]
['text':'/ checking for other low-level input state like `input_available()` might','line_number':191,'multiline':False]
['text':'/ also be relevant (i e to throttle idle processing when user input is','line_number':192,'multiline':False]
['text':'/ available)','line_number':193,'multiline':False]
['text':'/ Check for CTRL-C pressed, but only once in a while.','line_number':206,'multiline':False]
['text':'/','line_number':207,'multiline':False]
['text':'/ Should be used instead of os_breakcheck() for functions that check for','line_number':208,'multiline':False]
['text':'/ each line in the file.  Calling os_breakcheck() each time takes too much','line_number':209,'multiline':False]
['text':'/ time, because it will use system calls to check for input.','line_number':210,'multiline':False]
['text':'/ Like line_breakcheck() but check 10 times less often.','line_number':219,'multiline':False]
['text':'/ Like line_breakcheck() but check 100 times less often.','line_number':228,'multiline':False]
['text':'/ Test whether a file descriptor refers to a terminal.','line_number':237,'multiline':False]
['text':'/','line_number':238,'multiline':False]
['text':'/ @param fd File descriptor.','line_number':239,'multiline':False]
['text':'/ @return `true` if file descriptor refers to a terminal.','line_number':240,'multiline':False]
['text':' A "<x>" form occupies at least 1 characters, and produces up','line_number':252,'multiline':False]
['text':' to 19 characters (1 + 5 * 3 for the char and 3 for a modifier).','line_number':253,'multiline':False]
['text':' In the case of K_SPECIAL(0x80), 3 bytes are escaped and needed,','line_number':254,'multiline':False]
['text':' but since the keys are UTF-8, so the first byte cannot be','line_number':255,'multiline':False]
['text':' K_SPECIAL(0x80).','line_number':256,'multiline':False]
['text':' Do not simplify the keys here. Simplification will be done later.','line_number':258,'multiline':False]
['text':' Invalid or incomplete key sequence, skip until the next '>' or *end.','line_number':270,'multiline':False]
['text':' Incomplete key sequence, return without consuming.','line_number':275,'multiline':False]
['text':' copy the character, escaping K_SPECIAL','line_number':283,'multiline':False]
['text':' time of previous mouse click','line_number':306,'multiline':False]
['text':' For click events the number of clicks is updated.','line_number':312,'multiline':False]
['text':' time of current mouse click (ns)','line_number':314,'multiline':False]
['text':' compute the time elapsed since the previous mouse click and','line_number':315,'multiline':False]
['text':' convert p_mouse from ms to ns','line_number':316,'multiline':False]
['text':' For drag and release events the number of clicks is kept.','line_number':332,'multiline':False]
['text':' Mouse event handling code(Extract row/col if available and detect multiple','line_number':349,'multiline':False]
['text':' clicks)','line_number':350,'multiline':False]
['text':' prefixed with K_SPECIAL KS_MODIFIER mod','line_number':360,'multiline':False]
['text':' a <[COL],[ROW]> sequence can follow and will set the mouse_row/mouse_col','line_number':372,'multiline':False]
['text':' global variables. This is ugly but its how the rest of the code expects to','line_number':373,'multiline':False]
['text':' find mouse coordinates, and it would be too expensive to refactor this','line_number':374,'multiline':False]
['text':' now.','line_number':375,'multiline':False]
['text':' Make sure the mouse position is valid.  Some terminals may','line_number':379,'multiline':False]
['text':' return weird values.','line_number':380,'multiline':False]
['text':' no modifiers in the buffer yet, shift the bytes 3 positions','line_number':399,'multiline':False]
['text':' add the modifier sequence','line_number':401,'multiline':False]
['text':'/ @return true if the main loop is blocked and waiting for input.','line_number':437,'multiline':False]
['text':' This is a replacement for the old `WaitForChar` function in os_unix.c','line_number':443,'multiline':False]
['text':' The pending input provoked a blocking wait. Do special events now. #6247','line_number':455,'multiline':False]
['text':' Remove all unprocessed input (typeahead) before the CTRL-C.','line_number':514,'multiline':False]
['text':' Helper function used to push bytes from the 'event' key sequence partially','line_number':519,'multiline':False]
['text':' between calls to os_inchar when maxlen < 3','line_number':520,'multiline':False]
['text':'/ Check if there's pending input already in typebuf or `events`','line_number':535,'multiline':False]
['text':' API call filled typeahead','line_number':538,'multiline':False]
['text':' Input buffer filled','line_number':539,'multiline':False]
['text':' Events must be processed','line_number':540,'multiline':False]
['text':' Exit because of an input read error.','line_number':543,'multiline':False]
['text':' Normal way to exit for "nvim -es".','line_number':547,'multiline':False]
