['text':' fileio.c: read from and write to a file','line_number':1,'multiline':False]
['text':' For compatibility with libuv < 1.20.0 (tested on 1.18.0)','line_number':82,'multiline':False]
['text':' Avoid an over-long translation to cause trouble.','line_number':103,'multiline':False]
['text':' For the first message may have to start a new line.','line_number':106,'multiline':False]
['text':' For further ones overwrite the previous one, reset msg_scroll before','line_number':107,'multiline':False]
['text':' calling filemess().','line_number':108,'multiline':False]
['text':' wait a bit when overwriting an error msg','line_number':113,'multiline':False]
['text':' overwrite any previous message.','line_number':118,'multiline':False]
['text':' may truncate the message to avoid a hit-return prompt','line_number':122,'multiline':False]
['text':'/ Read lines from file "fname" into the buffer after line "from".','line_number':129,'multiline':False]
['text':'/','line_number':130,'multiline':False]
['text':'/ 1. We allocate blocks with try_malloc, as big as possible.','line_number':131,'multiline':False]
['text':'/ 2. Each block is filled with characters from the file with a single read().','line_number':132,'multiline':False]
['text':'/ 3. The lines are inserted in the buffer with ml_append().','line_number':133,'multiline':False]
['text':'/','line_number':134,'multiline':False]
['text':'/ (caller must check that fname != NULL, unless READ_STDIN is used)','line_number':135,'multiline':False]
['text':'/','line_number':136,'multiline':False]
['text':'/ "lines_to_skip" is the number of lines that must be skipped','line_number':137,'multiline':False]
['text':'/ "lines_to_read" is the number of lines that are appended','line_number':138,'multiline':False]
['text':'/ When not recovering lines_to_skip is 0 and lines_to_read MAXLNUM.','line_number':139,'multiline':False]
['text':'/','line_number':140,'multiline':False]
['text':'/ flags:','line_number':141,'multiline':False]
['text':'/ READ_NEW     starting to edit a new buffer','line_number':142,'multiline':False]
['text':'/ READ_FILTER  reading filter output','line_number':143,'multiline':False]
['text':'/ READ_STDIN   read from stdin instead of a file','line_number':144,'multiline':False]
['text':'/ READ_BUFFER  read from curbuf instead of a file (converting after reading','line_number':145,'multiline':False]
['text':'/              stdin)','line_number':146,'multiline':False]
['text':'/ READ_NOFILE  do not read a file, only trigger BufReadCmd','line_number':147,'multiline':False]
['text':'/ READ_DUMMY   read into a dummy buffer (to check if file contents changed)','line_number':148,'multiline':False]
['text':'/ READ_KEEP_UNDO  don't clear undo info or read it from a file','line_number':149,'multiline':False]
['text':'/ READ_FIFO    read from fifo/socket instead of a file','line_number':150,'multiline':False]
['text':'/','line_number':151,'multiline':False]
['text':'/ @param eap  can be NULL!','line_number':152,'multiline':False]
['text':'/','line_number':153,'multiline':False]
['text':'/ @return     FAIL for failure, NOTDONE for directory (failure), or OK','line_number':154,'multiline':False]
['text':' jump to "theend" instead of returning','line_number':158,'multiline':False]
['text':' next line to read from curbuf','line_number':168,'multiline':False]
['text':' next char to read from this line','line_number':169,'multiline':False]
['text':' pointer into read buffer','line_number':172,'multiline':False]
['text':' read buffer','line_number':173,'multiline':False]
['text':' init to shut up gcc','line_number':174,'multiline':False]
['text':' init to shut up gcc','line_number':175,'multiline':False]
['text':' buffer was empty before reading','line_number':176,'multiline':False]
['text':' number of split lines','line_number':184,'multiline':False]
['text':' errors encountered','line_number':186,'multiline':False]
['text':' file format with errors','line_number':187,'multiline':False]
['text':' remaining chars in line','line_number':188,'multiline':False]
['text':' protection bits for swap file','line_number':191,'multiline':False]
['text':' end-of-line format','line_number':193,'multiline':False]
['text':' non-zero lnum when last line of','line_number':199,'multiline':False]
['text':' last read was missing the eol','line_number':200,'multiline':False]
['text':' line nr with conversion error','line_number':203,'multiline':False]
['text':' line nr with illegal byte','line_number':204,'multiline':False]
['text':' don't retry when char doesn't fit','line_number':205,'multiline':False]
['text':' in destination encoding','line_number':206,'multiline':False]
['text':' BAD_KEEP, BAD_DROP or character to','line_number':208,'multiline':False]
['text':' replace with','line_number':209,'multiline':False]
['text':' name of 'charconvert' output file','line_number':210,'multiline':False]
['text':' fileencoding to use','line_number':212,'multiline':False]
['text':' fenc_next is in allocated memory','line_number':213,'multiline':False]
['text':' next item in 'fencs' or NULL','line_number':214,'multiline':False]
['text':' descriptor for iconv() or -1','line_number':217,'multiline':False]
['text':' true when iconv() failed and trying','line_number':218,'multiline':False]
['text':' 'charconvert' next','line_number':219,'multiline':False]
['text':' true if conversion done','line_number':220,'multiline':False]
['text':' true if conversion wanted but it wasn't possible','line_number':221,'multiline':False]
['text':' nr of bytes in conv_rest[]','line_number':223,'multiline':False]
['text':' reset before triggering any autocommands','line_number':232,'multiline':False]
['text':' in case it was set by the previous read','line_number':234,'multiline':False]
['text':' If there is no file name yet, use the one for the read file.','line_number':236,'multiline':False]
['text':' BF_NOTEDITED is set to reflect this.','line_number':237,'multiline':False]
['text':' Don't do this for a read from a filter.','line_number':238,'multiline':False]
['text':' Only do this when 'cpoptions' contains the 'f' flag.','line_number':239,'multiline':False]
['text':' Remember the initial values of curbuf, curbuf->b_ffname and','line_number':250,'multiline':False]
['text':' curbuf->b_fname to detect whether they are altered as a result of','line_number':251,'multiline':False]
['text':' executing nasty autocommands.  Also check if "fname" and "sfname"','line_number':252,'multiline':False]
['text':' point to one of these values.','line_number':253,'multiline':False]
['text':' After reading a file the cursor line changes but we don't want to','line_number':260,'multiline':False]
['text':' display the line.','line_number':261,'multiline':False]
['text':' don't display the file info for another buffer now','line_number':264,'multiline':False]
['text':' For Unix: Use the short file name whenever possible.','line_number':267,'multiline':False]
['text':' Avoids problems with networks and when directory names are changed.','line_number':268,'multiline':False]
['text':' Don't do this for Windows, a "cd" in a sub-shell may have moved us to','line_number':269,'multiline':False]
['text':' another directory, which we don't detect.','line_number':270,'multiline':False]
['text':' The BufReadCmd and FileReadCmd events intercept the reading process by','line_number':278,'multiline':False]
['text':' executing the associated commands instead.','line_number':279,'multiline':False]
['text':' Set '[ mark to the line above where the lines go (line 1 if zero).','line_number':283,'multiline':False]
['text':' The BufReadCmd code usually uses ":read" to get the text and','line_number':295,'multiline':False]
['text':' perhaps ":file" to change the buffer name. But we should','line_number':296,'multiline':False]
['text':' consider this to work like ":edit", thus reset the','line_number':297,'multiline':False]
['text':' BF_NOTEDITED flag.  Then ":write" will work to overwrite the','line_number':298,'multiline':False]
['text':' same file.','line_number':299,'multiline':False]
['text':' Return NOTDONE instead of FAIL so that BufEnter can be triggered','line_number':314,'multiline':False]
['text':' and other operations don't fail.','line_number':315,'multiline':False]
['text':' overwrite previous file message','line_number':322,'multiline':False]
['text':' don't overwrite previous file message','line_number':324,'multiline':False]
['text':' If the name is too long we might crash further on, quit here.','line_number':326,'multiline':False]
['text':' If the name is too long we might crash further on, quit here.','line_number':330,'multiline':False]
['text':' If the name ends in a path separator, we can't open it.  Check here,','line_number':338,'multiline':False]
['text':' because reading the file may actually work, but then creating the','line_number':339,'multiline':False]
['text':' swap file may destroy it!  Reported on MS-DOS and Win 95.','line_number':340,'multiline':False]
['text':' On Unix it is possible to read a directory, so we have to','line_number':354,'multiline':False]
['text':' check for it before os_open().','line_number':355,'multiline':False]
['text':' not a regular file ...','line_number':363,'multiline':False]
['text':' ... or fifo','line_number':364,'multiline':False]
['text':' ... or socket','line_number':365,'multiline':False]
['text':' ... or a character special file named /dev/fd/<n>','line_number':367,'multiline':False]
['text':' Set default or forced 'fileformat' and 'binary'.','line_number':383,'multiline':False]
['text':' When opening a new file we take the readonly flag from the file.','line_number':386,'multiline':False]
['text':' Default is r/w, can be set to r/o below.','line_number':387,'multiline':False]
['text':' Don't reset it when in readonly mode','line_number':388,'multiline':False]
['text':' Only set/reset b_p_ro when BF_CHECK_RO is set.','line_number':389,'multiline':False]
['text':' Remember time of file.','line_number':396,'multiline':False]
['text':' Use the protection bits of the original file for the swap file.','line_number':402,'multiline':False]
['text':' This makes it possible for others to read the name of the','line_number':403,'multiline':False]
['text':' edited file from the swapfile, but only if they can read the','line_number':404,'multiline':False]
['text':' edited file.','line_number':405,'multiline':False]
['text':' Remove the "write" and "execute" bits for group and others','line_number':406,'multiline':False]
['text':' (they must not write the swapfile).','line_number':407,'multiline':False]
['text':' Add the "read" and "write" bits for the user, otherwise we may','line_number':408,'multiline':False]
['text':' not be able to write to the file ourselves.','line_number':409,'multiline':False]
['text':' Setting the bits is done below, after creating the swap file.','line_number':410,'multiline':False]
['text':' Reset the "new file" flag.  It will be set again below when the','line_number':422,'multiline':False]
['text':' file doesn't exist.','line_number':423,'multiline':False]
['text':' Check readonly.','line_number':427,'multiline':False]
['text':' cannot open at all','line_number':437,'multiline':False]
['text':' check if the file exists','line_number':442,'multiline':False]
['text':' Set the 'new-file' flag, so that when the file has','line_number':443,'multiline':False]
['text':' been created by someone else, a ":w" will complain.','line_number':444,'multiline':False]
['text':' Create a swap file now, so that other Vims are warned','line_number':447,'multiline':False]
['text':' that we are editing this file.  Don't do this for a','line_number':448,'multiline':False]
['text':' "nofile" or "nowrite" buffer type.','line_number':449,'multiline':False]
['text':' SwapExists autocommand may mess things up','line_number':452,'multiline':False]
['text':' Even though this is a new file, it might have been','line_number':469,'multiline':False]
['text':' edited before and deleted.  Get the old marks.','line_number':470,'multiline':False]
['text':' Set forced 'fileencoding'.','line_number':472,'multiline':False]
['text':' remember the current fileformat','line_number':478,'multiline':False]
['text':' autocmds may abort script processing','line_number':481,'multiline':False]
['text':' a new file is not an error','line_number':482,'multiline':False]
['text':' libuv only returns -errno','line_number':489,'multiline':False]
['text':' in Unix and in Windows','line_number':490,'multiline':False]
['text':' open() does not set','line_number':491,'multiline':False]
['text':' EOVERFLOW','line_number':492,'multiline':False]
['text':' must use "w!" now','line_number':499,'multiline':False]
['text':' Only set the 'ro' flag for readonly files the first time they are','line_number':504,'multiline':False]
['text':' loaded.    Help files always get readonly mode','line_number':505,'multiline':False]
['text':' Don't change 'eol' if reading from buffer as it will already be','line_number':511,'multiline':False]
['text':' correctly set when reading stdin.','line_number':512,'multiline':False]
['text':' Create a swap file now, so that other Vims are warned that we are','line_number':523,'multiline':False]
['text':' editing this file.','line_number':524,'multiline':False]
['text':' Don't do this for a "nofile" or "nowrite" buffer type.','line_number':525,'multiline':False]
['text':' Set swap file protection bits after creating it.','line_number':539,'multiline':False]
['text':' If the group-read bit is set but not the world-read bit, then','line_number':544,'multiline':False]
['text':' the group must be equal to the group of the original file.  If','line_number':545,'multiline':False]
['text':' we can't make that happen then reset the group-read bit.  This','line_number':546,'multiline':False]
['text':' avoids making the swap file readable to more users when the','line_number':547,'multiline':False]
['text':' primary group of the user is too permissive.','line_number':548,'multiline':False]
['text':' If "Quit" selected at ATTENTION dialog, don't load the file.','line_number':566,'multiline':False]
['text':' don't wait for return yet','line_number':574,'multiline':False]
['text':' Set '[ mark to the line above where the lines go (line 1 if zero).','line_number':576,'multiline':False]
['text':' The file must be closed again, the autocommands may want to change','line_number':589,'multiline':False]
['text':' the file before reading it.','line_number':590,'multiline':False]
['text':' ignore errors','line_number':592,'multiline':False]
['text':' The output from the autocommands should not overwrite anything and','line_number':595,'multiline':False]
['text':' should not be overwritten: Set msg_scroll, restore its value if no','line_number':596,'multiline':False]
['text':' output was done.','line_number':597,'multiline':False]
['text':' autocommands may have changed it','line_number':613,'multiline':False]
['text':' autocmds may abort script processing','line_number':623,'multiline':False]
['text':' must use "w!" now','line_number':626,'multiline':False]
['text':' Don't allow the autocommands to change the current buffer.','line_number':629,'multiline':False]
['text':' Try to re-open the file.','line_number':630,'multiline':False]
['text':'','line_number':631,'multiline':False]
['text':' Don't allow the autocommands to change the buffer name either','line_number':632,'multiline':False]
['text':' (cd for example) if it invalidates fname or sfname.','line_number':633,'multiline':False]
['text':' must use "w!" now','line_number':645,'multiline':False]
['text':' Autocommands may add lines to the file, need to check if it is empty','line_number':650,'multiline':False]
['text':' overwrite the file message','line_number':659,'multiline':False]
['text':' Set linecnt now, before the "retry" caused by a wrong guess for','line_number':661,'multiline':False]
['text':' fileformat, and after the autocommands, which may change them.','line_number':662,'multiline':False]
['text':' "++bad=" argument.','line_number':665,'multiline':False]
['text':' Decide which 'encoding' to use or use first.','line_number':675,'multiline':False]
['text':' binary: don't convert','line_number':681,'multiline':False]
['text':' Help files are either utf-8 or latin1.  Try utf-8 first, if this','line_number':684,'multiline':False]
['text':' fails it must be latin1.','line_number':685,'multiline':False]
['text':' It is needed when the first line contains non-ASCII characters.','line_number':686,'multiline':False]
['text':' That is only in *.??x files.','line_number':687,'multiline':False]
['text':' use format from buffer','line_number':693,'multiline':False]
['text':' try items in 'fileencodings'','line_number':696,'multiline':False]
['text':' Jump back here to retry reading the file in different ways.','line_number':700,'multiline':False]
['text':' Reasons to retry:','line_number':701,'multiline':False]
['text':' - encoding conversion failed: try another one from "fenc_next"','line_number':702,'multiline':False]
['text':' - BOM detected and fenc was set, need to setup conversion','line_number':703,'multiline':False]
['text':' - "fileformat" check failed: try another','line_number':704,'multiline':False]
['text':'','line_number':705,'multiline':False]
['text':' Variables set for special retry actions:','line_number':706,'multiline':False]
['text':' "file_rewind"      Rewind the file to start reading it again.','line_number':707,'multiline':False]
['text':' "advance_fenc"     Advance "fenc" using "fenc_next".','line_number':708,'multiline':False]
['text':' "skip_read"        Re-use already read bytes (BOM detected).','line_number':709,'multiline':False]
['text':' "did_iconv"        iconv() conversion failed, try 'charconvert'.','line_number':710,'multiline':False]
['text':' "keep_fileformat" Don't reset "fileformat".','line_number':711,'multiline':False]
['text':'','line_number':712,'multiline':False]
['text':' Other status indicators:','line_number':713,'multiline':False]
['text':' "tmpname"  When != NULL did conversion with 'charconvert'.','line_number':714,'multiline':False]
['text':'                    Output file has to be deleted afterwards.','line_number':715,'multiline':False]
['text':' "iconv_fd" When != -1 did conversion with iconv().','line_number':716,'multiline':False]
['text':' Can't rewind the file, give up.','line_number':724,'multiline':False]
['text':' Delete the previously read lines.','line_number':728,'multiline':False]
['text':' When retrying with another "fenc" and the first time "fileformat"','line_number':740,'multiline':False]
['text':' will be reset.','line_number':741,'multiline':False]
['text':' binary: use Unix format','line_number':749,'multiline':False]
['text':' use format from buffer','line_number':752,'multiline':False]
['text':' detect from file','line_number':754,'multiline':False]
['text':' aborted conversion with iconv(), close the descriptor','line_number':759,'multiline':False]
['text':' Try the next entry in 'fileencodings'.','line_number':765,'multiline':False]
['text':' Conversion given with "++cc=" wasn't possible, read','line_number':769,'multiline':False]
['text':' without conversion.','line_number':770,'multiline':False]
['text':' delete converted file','line_number':790,'multiline':False]
['text':' Conversion may be required when the encoding of the file is different','line_number':795,'multiline':False]
['text':' from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.','line_number':796,'multiline':False]
['text':' "ucs-bom" means we need to check the first bytes of the file','line_number':800,'multiline':False]
['text':' for a BOM.','line_number':801,'multiline':False]
['text':' Check if UCS-2/4 or Latin1 to UTF-8 conversion needs to be','line_number':805,'multiline':False]
['text':' done.  This is handled below after read().  Prepare the','line_number':806,'multiline':False]
['text':' fio_flags to avoid having to parse the string each time.','line_number':807,'multiline':False]
['text':' Also check for Unicode to Latin1 conversion, because iconv()','line_number':808,'multiline':False]
['text':' appears not to handle this correctly.  This works just like','line_number':809,'multiline':False]
['text':' conversion to UTF-8 except how the resulting character is put in','line_number':810,'multiline':False]
['text':' the buffer.','line_number':811,'multiline':False]
['text':' Try using iconv() if we can't convert internally.','line_number':815,'multiline':False]
['text':' Use the 'charconvert' expression when conversion is required','line_number':821,'multiline':False]
['text':' and we can't do it internally or with iconv().','line_number':822,'multiline':False]
['text':' Skip conversion when it's already done (retry for wrong','line_number':826,'multiline':False]
['text':' "fileformat").','line_number':827,'multiline':False]
['text':' Conversion failed.  Try another one.','line_number':831,'multiline':False]
['text':' Re-opening the original file failed!','line_number':834,'multiline':False]
['text':' Conversion wanted but we can't.','line_number':844,'multiline':False]
['text':' Try the next conversion in 'fileencodings'','line_number':845,'multiline':False]
['text':' Set "can_retry" when it's possible to rewind the file and try with','line_number':852,'multiline':False]
['text':' another "fenc" value.  It's false when no other "fenc" to try, reading','line_number':853,'multiline':False]
['text':' stdin or fixed at a specific encoding.','line_number':854,'multiline':False]
['text':' We allocate as much space for the file as we can get, plus','line_number':876,'multiline':False]
['text':' space for the old line plus room for one terminating NUL.','line_number':877,'multiline':False]
['text':' The amount is limited by the fact that read() only can read','line_number':878,'multiline':False]
['text':' up to max_unsigned characters (and other things).','line_number':879,'multiline':False]
['text':' Use buffer >= 64K.  Add linerest to double the size if the','line_number':882,'multiline':False]
['text':' line gets very long, to avoid a lot of copying. But don't','line_number':883,'multiline':False]
['text':' read more than 1 Mbyte at a time, so we can be interrupted.','line_number':884,'multiline':False]
['text':' Protect against the argument of lalloc() going negative.','line_number':891,'multiline':False]
['text':' split line by inserting a NL','line_number':894,'multiline':False]
['text':' copy characters from the previous buffer','line_number':907,'multiline':False]
['text':' May need room to translate into.','line_number':915,'multiline':False]
['text':' For iconv() we don't really know the required space, use a','line_number':916,'multiline':False]
['text':' factor ICONV_MULT.','line_number':917,'multiline':False]
['text':' latin1 to utf-8: 1 byte becomes up to 2 bytes','line_number':918,'multiline':False]
['text':' utf-16 to utf-8: 2 bytes become up to 3 bytes, 4 bytes','line_number':919,'multiline':False]
['text':' become up to 4 bytes, size must be multiple of 2','line_number':920,'multiline':False]
['text':' ucs-2 to utf-8: 2 bytes become up to 3 bytes, size must be','line_number':921,'multiline':False]
['text':' multiple of 2','line_number':922,'multiline':False]
['text':' ucs-4 to utf-8: 4 bytes become up to 6 bytes, size must be','line_number':923,'multiline':False]
['text':' multiple of 4','line_number':924,'multiline':False]
['text':' worst case','line_number':935,'multiline':False]
['text':' Insert unconverted bytes from previous line.','line_number':939,'multiline':False]
['text':' Read bytes from curbuf.  Used for converting text read','line_number':946,'multiline':False]
['text':' from stdin.','line_number':947,'multiline':False]
['text':' Filled up to "size", append partial line.','line_number':957,'multiline':False]
['text':' Change NL to NUL to reverse the effect done','line_number':958,'multiline':False]
['text':' below.','line_number':959,'multiline':False]
['text':' Append whole line and new-line.  Change NL','line_number':972,'multiline':False]
['text':' to NUL to reverse the effect done below.','line_number':973,'multiline':False]
['text':' When the last line didn't have an','line_number':984,'multiline':False]
['text':' end-of-line don't add it now either.','line_number':985,'multiline':False]
['text':' Read bytes from the file.','line_number':995,'multiline':False]
['text':' read error','line_number':1001,'multiline':False]
['text':' Reached end-of-file but some trailing bytes could','line_number':1004,'multiline':False]
['text':' not be converted.  Truncated file?','line_number':1005,'multiline':False]
['text':' When we did a conversion report an error.','line_number':1007,'multiline':False]
['text':' Remember the first linenr with an illegal byte','line_number':1017,'multiline':False]
['text':' Replace the trailing bytes with the replacement','line_number':1025,'multiline':False]
['text':' character if we were converting; if we weren't,','line_number':1026,'multiline':False]
['text':' leave the UTF8 checking code to do it, as it','line_number':1027,'multiline':False]
['text':' works slightly differently.','line_number':1028,'multiline':False]
['text':' don't convert this','line_number':1035,'multiline':False]
['text':' At start of file: Check for BOM.','line_number':1047,'multiline':False]
['text':' Also check for a BOM for other Unicode encodings, but not after','line_number':1048,'multiline':False]
['text':' converting with 'charconvert' or when a BOM has already been','line_number':1049,'multiline':False]
['text':' found.','line_number':1050,'multiline':False]
['text':' no BOM detection in a short file or in binary mode','line_number':1059,'multiline':False]
['text':' Remove BOM from the text','line_number':1067,'multiline':False]
['text':' No BOM detected: retry with next encoding.','line_number':1079,'multiline':False]
['text':' BOM detected: set "fenc" and jump back','line_number':1082,'multiline':False]
['text':' retry reading without getting new bytes or rewinding','line_number':1089,'multiline':False]
['text':' Include not converted bytes.','line_number':1095,'multiline':False]
['text':' Break here for a read error or end-of-file.','line_number':1099,'multiline':False]
['text':' Attempt conversion of the read bytes to 'encoding' using iconv().','line_number':1105,'multiline':False]
['text':' If there is conversion error or not enough room try using','line_number':1112,'multiline':False]
['text':' another conversion.  Except for when there is no','line_number':1113,'multiline':False]
['text':' alternative (help files).','line_number':1114,'multiline':False]
['text':' Deal with a bad byte and continue with the next.','line_number':1126,'multiline':False]
['text':' Some remaining characters, keep them for the next','line_number':1139,'multiline':False]
['text':' round.','line_number':1140,'multiline':False]
['text':' move the linerest to before the converted characters','line_number':1145,'multiline':False]
['text':' Convert Unicode or Latin1 to UTF-8.','line_number':1156,'multiline':False]
['text':' Go from end to start through the buffer, because the number','line_number':1157,'multiline':False]
['text':' of bytes may increase.','line_number':1158,'multiline':False]
['text':' "dest" points to after where the UTF-8 bytes go, "p" points','line_number':1159,'multiline':False]
['text':' to after the next character to convert.','line_number':1160,'multiline':False]
['text':' Check for a trailing incomplete UTF-8 sequence','line_number':1165,'multiline':False]
['text':' Check for a trailing byte','line_number':1177,'multiline':False]
['text':' Check for a trailing leading word','line_number':1183,'multiline':False]
['text':'  FIO_UCS4','line_number':1197,'multiline':False]
['text':' Check for trailing 1, 2 or 3 bytes','line_number':1198,'multiline':False]
['text':' If there is a trailing incomplete sequence move it to','line_number':1205,'multiline':False]
['text':' conv_rest[].','line_number':1206,'multiline':False]
['text':' Missing leading word.','line_number':1229,'multiline':False]
['text':' found second word of double-word, get the first','line_number':1244,'multiline':False]
['text':' word and compute the resulting character','line_number':1245,'multiline':False]
['text':' Check if the word is indeed a leading word.','line_number':1256,'multiline':False]
['text':' big endian','line_number':1278,'multiline':False]
['text':' Replace characters over INT_MAX with Unicode replacement character','line_number':1284,'multiline':False]
['text':' UTF-8','line_number':1288,'multiline':False]
['text':' Not a valid UTF-8 character, retry with','line_number':1296,'multiline':False]
['text':' another fenc when possible, otherwise just','line_number':1297,'multiline':False]
['text':' report the error.','line_number':1298,'multiline':False]
['text':' produce UTF-8','line_number':1315,'multiline':False]
['text':' move the linerest to before the converted characters','line_number':1320,'multiline':False]
['text':' Reading UTF-8: Check if the bytes are valid UTF-8.','line_number':1328,'multiline':False]
['text':' A length of 1 means it's an illegal byte.  Accept','line_number':1336,'multiline':False]
['text':' an incomplete character at the end though, the next','line_number':1337,'multiline':False]
['text':' read() will get the next bytes, we'll check it','line_number':1338,'multiline':False]
['text':' then.','line_number':1339,'multiline':False]
['text':' Avoid retrying with a different encoding when','line_number':1342,'multiline':False]
['text':' a truncated file is more likely, or attempting','line_number':1343,'multiline':False]
['text':' to read the rest of an incomplete sequence when','line_number':1344,'multiline':False]
['text':' we have already done so.','line_number':1345,'multiline':False]
['text':' Incomplete byte sequence, move it to conv_rest[]','line_number':1349,'multiline':False]
['text':' and try to read the rest of it, unless we've','line_number':1350,'multiline':False]
['text':' already done so.','line_number':1351,'multiline':False]
['text':' Illegal byte.  If we can try another encoding','line_number':1360,'multiline':False]
['text':' do that, unless at EOF where a truncated','line_number':1361,'multiline':False]
['text':' file is more likely than a conversion error.','line_number':1362,'multiline':False]
['text':' When we did a conversion report an error.','line_number':1367,'multiline':False]
['text':' Remember the first linenr with an illegal byte','line_number':1372,'multiline':False]
['text':' Drop, keep or replace the bad byte.','line_number':1377,'multiline':False]
['text':' Detected a UTF-8 error.','line_number':1391,'multiline':False]
['text':' Retry reading with another conversion.','line_number':1393,'multiline':False]
['text':' iconv() failed, try 'charconvert'','line_number':1395,'multiline':False]
['text':' use next item from 'fileencodings'','line_number':1398,'multiline':False]
['text':' count the number of characters (after conversion!)','line_number':1406,'multiline':False]
['text':' when reading the first part of a file: guess EOL type','line_number':1409,'multiline':False]
['text':' First try finding a NL, for Dos and Unix','line_number':1411,'multiline':False]
['text':' Reset the carriage return counter.','line_number':1413,'multiline':False]
['text':' Don't give in to EOL_UNIX if EOL_MAC is more likely','line_number':1432,'multiline':False]
['text':' Need to reset the counters when retrying fenc.','line_number':1434,'multiline':False]
['text':' Looking for CR but found no end-of-line markers at all:','line_number':1451,'multiline':False]
['text':' use the default format.','line_number':1452,'multiline':False]
['text':' No NL found: may use Mac format','line_number':1457,'multiline':False]
['text':' Still nothing found?  Use first format in 'ffs'','line_number':1462,'multiline':False]
['text':' May set 'p_ff' if editing a new file.','line_number':1467,'multiline':False]
['text':' This loop is executed once for every character read.','line_number':1474,'multiline':False]
['text':' Keep it fast!','line_number':1475,'multiline':False]
['text':' catch most common case first','line_number':1479,'multiline':False]
['text':' NULs are replaced by newlines!','line_number':1484,'multiline':False]
['text':' NLs are replaced by CRs!','line_number':1486,'multiline':False]
['text':' end of line','line_number':1489,'multiline':False]
['text':' break loop','line_number':1500,'multiline':False]
['text':' nothing left to write','line_number':1501,'multiline':False]
['text':' catch most common case','line_number':1513,'multiline':False]
['text':' NULs are replaced by newlines!','line_number':1517,'multiline':False]
['text':' end of line','line_number':1520,'multiline':False]
['text':' remove CR before NL','line_number':1524,'multiline':False]
['text':' Reading in Dos format, but no CR-LF found!','line_number':1528,'multiline':False]
['text':' When 'fileformats' includes "unix", delete all','line_number':1529,'multiline':False]
['text':' the lines read so far and start all over again.','line_number':1530,'multiline':False]
['text':' Otherwise give an error message later.','line_number':1531,'multiline':False]
['text':' break loop','line_number':1556,'multiline':False]
['text':' nothing left to write','line_number':1557,'multiline':False]
['text':' not an error, max. number of lines reached','line_number':1572,'multiline':False]
['text':' In Dos format ignore a trailing CTRL-Z, unless 'binary' is set.','line_number':1577,'multiline':False]
['text':' In old days the file length was in sector count and the CTRL-Z the','line_number':1578,'multiline':False]
['text':' marker where the file really ended.  Assuming we write it to a file','line_number':1579,'multiline':False]
['text':' system that keeps file length properly the CTRL-Z should be dropped.','line_number':1580,'multiline':False]
['text':' Set the 'endoffile' option so the user can decide what to write later.','line_number':1581,'multiline':False]
['text':' In Unix format the CTRL-Z is just another character.','line_number':1582,'multiline':False]
['text':' If we get EOF in the middle of a line, note the fact and','line_number':1594,'multiline':False]
['text':' complete the line ourselves.','line_number':1595,'multiline':False]
['text':' remember for when writing','line_number':1599,'multiline':False]
['text':' Remember the current file format.','line_number':1616,'multiline':False]
['text':' If editing a new file: set 'fenc' for the current buffer.','line_number':1618,'multiline':False]
['text':' Also for ":read ++edit file".','line_number':1619,'multiline':False]
['text':' errors are ignored','line_number':1630,'multiline':False]
['text':' On Unix, use stderr for stdin, makes shell commands work.','line_number':1640,'multiline':False]
['text':' On Windows, use the console input handle for stdin.','line_number':1643,'multiline':False]
['text':' delete converted file','line_number':1653,'multiline':False]
['text':' may wait for return now','line_number':1656,'multiline':False]
['text':' In recovery mode everything but autocommands is skipped.','line_number':1658,'multiline':False]
['text':' need to delete the last line, which comes from the empty buffer','line_number':1660,'multiline':False]
['text':' After reading the text into the buffer the diff info needs to','line_number':1675,'multiline':False]
['text':' be updated.','line_number':1676,'multiline':False]
['text':' All folds in the window are invalid now.  Mark them for update','line_number':1678,'multiline':False]
['text':' before triggering autocommands.','line_number':1679,'multiline':False]
['text':' appended at least one line','line_number':1681,'multiline':False]
['text':' must use "w!" now','line_number':1689,'multiline':False]
['text':' an interrupt isn't really an error','line_number':1694,'multiline':False]
['text':' fifo','line_number':1703,'multiline':False]
['text':' or socket','line_number':1707,'multiline':False]
['text':' or character special','line_number':1712,'multiline':False]
['text':' overwrite previous message','line_number':1765,'multiline':False]
['text':' Need to repeat the message after redrawing when:','line_number':1772,'multiline':False]
['text':' - When reading from stdin (the screen will be cleared next).','line_number':1773,'multiline':False]
['text':' - When restart_edit is set (otherwise there will be a delay before','line_number':1774,'multiline':False]
['text':'   redrawing).','line_number':1775,'multiline':False]
['text':' - When the screen was scrolled but there is no wait-return prompt.','line_number':1776,'multiline':False]
['text':' with errors writing the file requires ":w!"','line_number':1782,'multiline':False]
['text':' cannot use "U" command after adding lines','line_number':1789,'multiline':False]
['text':' In Ex mode: cursor at last new line.','line_number':1791,'multiline':False]
['text':' Otherwise: cursor at first new line.','line_number':1792,'multiline':False]
['text':' on first non-blank','line_number':1799,'multiline':False]
['text':' Set '[ and '] marks to the newly read lines.','line_number':1802,'multiline':False]
['text':' Get the marks before executing autocommands, so they can be used there.','line_number':1811,'multiline':False]
['text':' We remember if the last line of the read didn't have','line_number':1814,'multiline':False]
['text':' an eol even when 'binary' is off, to support turning 'fixeol' off,','line_number':1815,'multiline':False]
['text':' or writing the read again with 'binary' on.  The latter is required','line_number':1816,'multiline':False]
['text':' for ":autocmd FileReadPost *.gz set bin|'[,']!gunzip" to work.','line_number':1817,'multiline':False]
['text':' When reloading a buffer put the cursor at the first line that is','line_number':1820,'multiline':False]
['text':' different.','line_number':1821,'multiline':False]
['text':' When opening a new file locate undo info and read it.','line_number':1826,'multiline':False]
['text':' Save the fileformat now, otherwise the buffer will be considered','line_number':1838,'multiline':False]
['text':' modified if the format/encoding was automatically detected.','line_number':1839,'multiline':False]
['text':' The output from the autocommands should not overwrite anything and','line_number':1844,'multiline':False]
['text':' should not be overwritten: Set msg_scroll, restore its value if no','line_number':1845,'multiline':False]
['text':' output was done.','line_number':1846,'multiline':False]
['text':' EVENT_FILETYPE was not triggered but the buffer already has a','line_number':1855,'multiline':False]
['text':' filetype.  Trigger EVENT_FILETYPE using the existing filetype.','line_number':1856,'multiline':False]
['text':' autocmds may abort script processing','line_number':1866,'multiline':False]
['text':' OK to sync the swap file now','line_number':1878,'multiline':False]
['text':'/ Returns true if the file name argument is of the form "/dev/fd/\d\+",','line_number':1886,'multiline':False]
['text':'/ which is the name of files used for process substitution output by','line_number':1887,'multiline':False]
['text':'/ some shells on some operating systems, e.g., bash on SunOS.','line_number':1888,'multiline':False]
['text':'/ Do not accept "/dev/fd/[012]", opening these may hang Vim.','line_number':1889,'multiline':False]
['text':'/','line_number':1890,'multiline':False]
['text':'/ @param fname file name to check','line_number':1891,'multiline':False]
['text':'/ From the current line count and characters read after that, estimate the','line_number':1903,'multiline':False]
['text':'/ line number where we are now.','line_number':1904,'multiline':False]
['text':'/ Used for error messages that include a line number.','line_number':1905,'multiline':False]
['text':'/','line_number':1906,'multiline':False]
['text':'/ @param linecnt  line count before reading more bytes','line_number':1907,'multiline':False]
['text':'/ @param p        start of more bytes read','line_number':1908,'multiline':False]
['text':'/ @param endp     end of more bytes read','line_number':1909,'multiline':False]
['text':'/ Fill "*eap" to force the 'fileencoding', 'fileformat' and 'binary' to be','line_number':1921,'multiline':False]
['text':'/ equal to the buffer "buf".  Used for calling readfile().','line_number':1922,'multiline':False]
['text':'/ Set default or forced 'fileformat' and 'binary'.','line_number':1939,'multiline':False]
['text':' set default 'fileformat'','line_number':1942,'multiline':False]
['text':' set or reset 'binary'','line_number':1951,'multiline':False]
['text':'/ Set forced 'fileencoding'.','line_number':1960,'multiline':False]
['text':'/ Find next fileencoding to use from 'fileencodings'.','line_number':1972,'multiline':False]
['text':'/ "pp" points to fenc_next.  It's advanced to the next item.','line_number':1973,'multiline':False]
['text':'/ When there are no more items, an empty string is returned and *pp is set to','line_number':1974,'multiline':False]
['text':'/ NULL.','line_number':1975,'multiline':False]
['text':'/ When *pp is not set to NULL, the result is in allocated memory and "alloced"','line_number':1976,'multiline':False]
['text':'/ is set to true.','line_number':1977,'multiline':False]
['text':'/ Convert a file with the 'charconvert' expression.','line_number':2003,'multiline':False]
['text':'/ This closes the file which is to be read, converts it and opens the','line_number':2004,'multiline':False]
['text':'/ resulting file for reading.','line_number':2005,'multiline':False]
['text':'/','line_number':2006,'multiline':False]
['text':'/ @param fname  name of input file','line_number':2007,'multiline':False]
['text':'/ @param fenc   converted from','line_number':2008,'multiline':False]
['text':'/ @param fdp    in/out: file descriptor of file','line_number':2009,'multiline':False]
['text':'/','line_number':2010,'multiline':False]
['text':'/ @return       name of the resulting converted file (the caller should delete it after reading it).','line_number':2011,'multiline':False]
['text':'/               Returns NULL if the conversion failed ("*fdp" is not set) .','line_number':2012,'multiline':False]
['text':' close the input file, ignore errors','line_number':2021,'multiline':False]
['text':' Don't use emsg(), it breaks mappings, the retry with','line_number':2033,'multiline':False]
['text':' another type of conversion might still work.','line_number':2034,'multiline':False]
['text':' delete converted file','line_number':2037,'multiline':False]
['text':' If the input file is closed, open it (caller should check for error).','line_number':2042,'multiline':False]
['text':'/ Read marks for the current buffer from the ShaDa file, when we support','line_number':2050,'multiline':False]
['text':'/ buffer marks and the buffer has a name.','line_number':2051,'multiline':False]
['text':' Always set b_marks_read; needed when 'shada' is changed to include','line_number':2059,'multiline':False]
['text':' the ' parameter after opening a buffer.','line_number':2060,'multiline':False]
['text':'/ Set the name of the current buffer.  Use when the buffer doesn't have a','line_number':2064,'multiline':False]
['text':'/ name and a ":r" or ":w" command with a file name is used.','line_number':2065,'multiline':False]
['text':' It's like the unnamed buffer is deleted....','line_number':2070,'multiline':False]
['text':' autocmds may abort script processing','line_number':2075,'multiline':False]
['text':' We are in another buffer now, don't do the renaming.','line_number':2079,'multiline':False]
['text':' ....and a new named one is created','line_number':2088,'multiline':False]
['text':' autocmds may abort script processing','line_number':2093,'multiline':False]
['text':' Do filetype detection now if 'filetype' is empty.','line_number':2097,'multiline':False]
['text':'/ Put file name into the specified buffer with quotes','line_number':2108,'multiline':False]
['text':'/','line_number':2109,'multiline':False]
['text':'/ Replaces home directory at the start with `~`.','line_number':2110,'multiline':False]
['text':'/','line_number':2111,'multiline':False]
['text':'/ @param[out]  ret_buf  Buffer to save results to.','line_number':2112,'multiline':False]
['text':'/ @param[in]  buf_len  ret_buf length.','line_number':2113,'multiline':False]
['text':'/ @param[in]  buf  buf_T file name is coming from.','line_number':2114,'multiline':False]
['text':'/ @param[in]  fname  File name to write.','line_number':2115,'multiline':False]
['text':'/ Append message for text mode to IObuff.','line_number':2128,'multiline':False]
['text':'/','line_number':2129,'multiline':False]
['text':'/ @param eol_type line ending type','line_number':2130,'multiline':False]
['text':'/','line_number':2131,'multiline':False]
['text':'/ @return true if something was appended.','line_number':2132,'multiline':False]
['text':'/ Append line and character count to IObuff.','line_number':2154,'multiline':False]
['text':' On a FAT filesystem, esp. under Linux, there are only 5 bits to store','line_number':2181,'multiline':False]
['text':' the seconds.  Since the roundoff is done when flushing the inode, the','line_number':2182,'multiline':False]
['text':' time may change unexpectedly by one second!!!','line_number':2183,'multiline':False]
['text':'/ Return true if file encoding "fenc" requires conversion from or to','line_number':2192,'multiline':False]
['text':'/ 'encoding'.','line_number':2193,'multiline':False]
['text':'/','line_number':2194,'multiline':False]
['text':'/ @param fenc file encoding to check','line_number':2195,'multiline':False]
['text':'/','line_number':2196,'multiline':False]
['text':'/ @return true if conversion is required','line_number':2197,'multiline':False]
['text':' Ignore difference between "ansi" and "latin1", "ucs-4" and','line_number':2208,'multiline':False]
['text':' "ucs-4be", etc.','line_number':2209,'multiline':False]
['text':' Specified file encoding matches UTF-8.','line_number':2215,'multiline':False]
['text':' Encodings differ.  However, conversion is not needed when 'enc' is any','line_number':2219,'multiline':False]
['text':' Unicode encoding and the file is UTF-8.','line_number':2220,'multiline':False]
['text':'/ Return the FIO_ flags needed for the internal conversion if 'name' was','line_number':2224,'multiline':False]
['text':'/ unicode or latin1, otherwise 0. If "name" is an empty string,','line_number':2225,'multiline':False]
['text':'/ use 'encoding'.','line_number':2226,'multiline':False]
['text':'/','line_number':2227,'multiline':False]
['text':'/ @param name string to check for encoding','line_number':2228,'multiline':False]
['text':' must be ENC_DBCS, requires iconv()','line_number':2259,'multiline':False]
['text':'/ Check for a Unicode BOM (Byte Order Mark) at the start of p[size].','line_number':2263,'multiline':False]
['text':'/ "size" must be at least 2.','line_number':2264,'multiline':False]
['text':'/','line_number':2265,'multiline':False]
['text':'/ @return  the name of the encoding and set "*lenp" to the length or,','line_number':2266,'multiline':False]
['text':'/          NULL when no BOM found.','line_number':2267,'multiline':False]
['text':' EF BB BF','line_number':2276,'multiline':False]
['text':' FF FE 00 00','line_number':2281,'multiline':False]
['text':' FF FE','line_number':2284,'multiline':False]
['text':' utf-16le is preferred, it also works for ucs-2le text','line_number':2287,'multiline':False]
['text':' FF FE','line_number':2288,'multiline':False]
['text':' Default to utf-16, it works also for ucs-2 text.','line_number':2293,'multiline':False]
['text':' FE FF','line_number':2295,'multiline':False]
['text':' FE FF','line_number':2297,'multiline':False]
['text':' 00 00 FE FF','line_number':2301,'multiline':False]
['text':'/ Shorten filename of a buffer.','line_number':2309,'multiline':False]
['text':'/','line_number':2310,'multiline':False]
['text':'/ @param force  when true: Use full path from now on for files currently being','line_number':2311,'multiline':False]
['text':'/               edited, both for file name and swap file name.  Try to shorten the file','line_number':2312,'multiline':False]
['text':'/               names a bit, if safe to do so.','line_number':2313,'multiline':False]
['text':'/               when false: Only try to shorten absolute file names.','line_number':2314,'multiline':False]
['text':'/','line_number':2315,'multiline':False]
['text':'/ For buffers that have buftype "nofile" or "scratch": never change the file','line_number':2316,'multiline':False]
['text':'/ name.','line_number':2317,'multiline':False]
['text':'/ Shorten filenames for all buffers.','line_number':2340,'multiline':False]
['text':' Always make the swap file name a full path, a "nofile" buffer may','line_number':2349,'multiline':False]
['text':' also have a swap file.','line_number':2350,'multiline':False]
['text':'/ Get new filename ended by given extension.','line_number':2357,'multiline':False]
['text':'/','line_number':2358,'multiline':False]
['text':'/ @param fname        The original filename.','line_number':2359,'multiline':False]
['text':'/                     If NULL, use current directory name and ext to','line_number':2360,'multiline':False]
['text':'/                     compute new filename.','line_number':2361,'multiline':False]
['text':'/ @param ext          The extension to add to the filename.','line_number':2362,'multiline':False]
['text':'/                     4 chars max if prefixed with a dot, 3 otherwise.','line_number':2363,'multiline':False]
['text':'/ @param prepend_dot  If true, prefix ext with a dot.','line_number':2364,'multiline':False]
['text':'/                     Does nothing if ext already starts with a dot, or','line_number':2365,'multiline':False]
['text':'/                     if fname is NULL.','line_number':2366,'multiline':False]
['text':'/','line_number':2367,'multiline':False]
['text':'/ @return [allocated] - A new filename, made up from:','line_number':2368,'multiline':False]
['text':'/                       * fname + ext, if fname not NULL.','line_number':2369,'multiline':False]
['text':'/                       * current dir + ext, if fname is NULL.','line_number':2370,'multiline':False]
['text':'/                       Result is guaranteed to:','line_number':2371,'multiline':False]
['text':'/                       * be ended by <ext>.','line_number':2372,'multiline':False]
['text':'/                       * have a basename with at most BASENAMELEN chars:','line_number':2373,'multiline':False]
['text':'/                         original basename is truncated if necessary.','line_number':2374,'multiline':False]
['text':'/                       * be different than original: basename chars are','line_number':2375,'multiline':False]
['text':'/                         replaced by "_" if necessary. If that can't be done','line_number':2376,'multiline':False]
['text':'/                         because truncated value of original filename was','line_number':2377,'multiline':False]
['text':'/                         made of all underscores, replace first "_" by "v".','line_number':2378,'multiline':False]
['text':'/                     - NULL, if fname is NULL and there was a problem trying','line_number':2379,'multiline':False]
['text':'/                       to get current directory.','line_number':2380,'multiline':False]
['text':' If there is no file name we must get the name of the current directory','line_number':2388,'multiline':False]
['text':' (we need the full path in case :cd is used).','line_number':2389,'multiline':False]
['text':' +3 for PATHSEP, "_" (Win), NUL','line_number':2391,'multiline':False]
['text':' nothing to prepend a dot to','line_number':2399,'multiline':False]
['text':' NOLINT(runtime/printf)','line_number':2403,'multiline':False]
['text':' Search backwards until we hit a '/', '\' or ':'.','line_number':2406,'multiline':False]
['text':' Then truncate what is after the '/', '\' or ':' to BASENAMELEN characters.','line_number':2407,'multiline':False]
['text':' the file name has at most BASENAMELEN characters.','line_number':2416,'multiline':False]
['text':' Append the extension.','line_number':2423,'multiline':False]
['text':' ext can start with '.' and cannot exceed 3 more characters.','line_number':2424,'multiline':False]
['text':' NOLINT(runtime/printf)','line_number':2425,'multiline':False]
['text':' Prepend the dot if needed.','line_number':2428,'multiline':False]
['text':' Check that, after appending the extension, the file name is really','line_number':2434,'multiline':False]
['text':' different.','line_number':2435,'multiline':False]
['text':' we search for a character that can be replaced by '_'','line_number':2437,'multiline':False]
['text':' fname was "________.<ext>", how tricky!','line_number':2444,'multiline':False]
['text':'/ Like fgets(), but if the file line is too long, it is truncated and the','line_number':2451,'multiline':False]
['text':'/ rest of the line is thrown away.','line_number':2452,'multiline':False]
['text':'/','line_number':2453,'multiline':False]
['text':'/ @param[out] buf buffer to fill','line_number':2454,'multiline':False]
['text':'/ @param size size of the buffer','line_number':2455,'multiline':False]
['text':'/ @param fp file to read from','line_number':2456,'multiline':False]
['text':'/','line_number':2457,'multiline':False]
['text':'/ @return true for EOF or error','line_number':2458,'multiline':False]
['text':' Truncate the line.','line_number':2475,'multiline':False]
['text':' Now throw away the rest of the line:','line_number':2477,'multiline':False]
['text':'/ Read 2 bytes from "fd" and turn them into an int, MSB first.','line_number':2490,'multiline':False]
['text':'/','line_number':2491,'multiline':False]
['text':'/ @return  -1 when encountering EOF.','line_number':2492,'multiline':False]
['text':'/ Read 3 bytes from "fd" and turn them into an int, MSB first.','line_number':2506,'multiline':False]
['text':'/','line_number':2507,'multiline':False]
['text':'/ @return  -1 when encountering EOF.','line_number':2508,'multiline':False]
['text':'/ Read 4 bytes from "fd" and turn them into an int, MSB first.','line_number':2527,'multiline':False]
['text':'/','line_number':2528,'multiline':False]
['text':'/ @return  -1 when encountering EOF.','line_number':2529,'multiline':False]
['text':' Use unsigned rather than int otherwise result is undefined','line_number':2532,'multiline':False]
['text':' when left-shift sets the MSB.','line_number':2533,'multiline':False]
['text':'/ Read 8 bytes from `fd` and turn them into a time_t, MSB first.','line_number':2559,'multiline':False]
['text':'/','line_number':2560,'multiline':False]
['text':'/ @return  -1 when encountering EOF.','line_number':2561,'multiline':False]
['text':'/ Reads a string of length "cnt" from "fd" into allocated memory.','line_number':2576,'multiline':False]
['text':'/','line_number':2577,'multiline':False]
['text':'/ @return  pointer to the string or NULL when unable to read that many bytes.','line_number':2578,'multiline':False]
['text':'/ Writes a number to file "fd", most significant bit first, in "len" bytes.','line_number':2593,'multiline':False]
['text':'/','line_number':2594,'multiline':False]
['text':'/ @return  false in case of an error.','line_number':2595,'multiline':False]
['text':'/ Writes time_t to file "fd" in 8 bytes.','line_number':2607,'multiline':False]
['text':'/','line_number':2608,'multiline':False]
['text':'/ @return  FAIL when the write failed.','line_number':2609,'multiline':False]
['text':' Find a name that doesn't exist and is in the same directory.','line_number':2619,'multiline':False]
['text':' Rename "from" to "tempname" and then rename "tempname" to "to".','line_number':2620,'multiline':False]
['text':' Strange, the second step failed.  Try moving the','line_number':2636,'multiline':False]
['text':' file back and return failure.','line_number':2637,'multiline':False]
['text':' If it fails for one temp name it will most likely fail','line_number':2641,'multiline':False]
['text':' for any temp name, give up.','line_number':2642,'multiline':False]
['text':'/ os_rename() only works if both files are on the same file system, this','line_number':2649,'multiline':False]
['text':'/ function will (attempts to?) copy the file across if rename fails -- webb','line_number':2650,'multiline':False]
['text':'/','line_number':2651,'multiline':False]
['text':'/ @return  -1 for failure, 0 for success','line_number':2652,'multiline':False]
['text':' When the names are identical, there is nothing to do.  When they refer','line_number':2659,'multiline':False]
['text':' to the same file (ignoring case and slash/backslash differences) but','line_number':2660,'multiline':False]
['text':' the file name differs we need to go through a temp file.','line_number':2661,'multiline':False]
['text':' Fail if the "from" file doesn't exist. Avoids that "to" is deleted.','line_number':2670,'multiline':False]
['text':' It's possible for the source and destination to be the same file.','line_number':2676,'multiline':False]
['text':' This happens when "from" and "to" differ in case and are on a FAT32','line_number':2677,'multiline':False]
['text':' filesystem. In that case go through a temp file name.','line_number':2678,'multiline':False]
['text':' Delete the "to" file, this is required on some systems to make the','line_number':2688,'multiline':False]
['text':' os_rename() work, on other systems it makes sure that we don't have','line_number':2689,'multiline':False]
['text':' two files when the os_rename() fails.','line_number':2690,'multiline':False]
['text':' First try a normal rename, return if it works.','line_number':2694,'multiline':False]
['text':' Rename() failed, try copying the file.','line_number':2699,'multiline':False]
['text':' For systems that support ACL: get the ACL from the original file.','line_number':2701,'multiline':False]
['text':' Create the new file with same permissions as the original.','line_number':2709,'multiline':False]
['text':' Avoid xmalloc() here as vim_rename() is called by buf_write() when nvim','line_number':2717,'multiline':False]
['text':' is `preserve_exit()`ing.','line_number':2718,'multiline':False]
['text':' For Unix os_open() already set the permission.','line_number':2744,'multiline':False]
['text':'/ Check if any not hidden buffer has been changed.','line_number':2759,'multiline':False]
['text':'/ Postpone the check if there are characters in the stuff buffer, a global','line_number':2760,'multiline':False]
['text':'/ command is being executed, a mapping is being executed or an autocommand is','line_number':2761,'multiline':False]
['text':'/ busy.','line_number':2762,'multiline':False]
['text':'/','line_number':2763,'multiline':False]
['text':'/ @param focus  called for GUI focus event','line_number':2764,'multiline':False]
['text':'/','line_number':2765,'multiline':False]
['text':'/ @return       true if some message was written (screen should be redrawn and cursor positioned).','line_number':2766,'multiline':False]
['text':' Don't check timestamps while system() or another low-level function may','line_number':2769,'multiline':False]
['text':' cause us to lose and gain focus.','line_number':2770,'multiline':False]
['text':' Avoid doing a check twice.  The OK/Reload dialog can cause a focus','line_number':2775,'multiline':False]
['text':' event and we would keep on checking if the file is steadily growing.','line_number':2776,'multiline':False]
['text':' Do check again after typing something.','line_number':2777,'multiline':False]
['text':' check later','line_number':2788,'multiline':False]
['text':' Only check buffers in a window.','line_number':2794,'multiline':False]
['text':' Autocommands have removed the buffer, start at the first one again.','line_number':2803,'multiline':False]
['text':' make sure msg isn't overwritten','line_number':2812,'multiline':False]
['text':'/ Move all the lines from buffer "frombuf" to buffer "tobuf".','line_number':2820,'multiline':False]
['text':'/','line_number':2821,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':2822,'multiline':False]
['text':'/          When FAIL "tobuf" is incomplete and/or "frombuf" is not empty.','line_number':2823,'multiline':False]
['text':' Copy the lines in "frombuf" to "tobuf".','line_number':2829,'multiline':False]
['text':' Delete all the lines in "frombuf".','line_number':2841,'multiline':False]
['text':' Oops!  We could try putting back the saved lines, but that','line_number':2846,'multiline':False]
['text':' might fail again...','line_number':2847,'multiline':False]
['text':'/ Check if buffer "buf" has been changed.','line_number':2858,'multiline':False]
['text':'/ Also check if the file for a new buffer unexpectedly appeared.','line_number':2859,'multiline':False]
['text':'/','line_number':2860,'multiline':False]
['text':'/ @return  1 if a changed buffer was found or,','line_number':2861,'multiline':False]
['text':'/          2 if a message has been displayed or,','line_number':2862,'multiline':False]
['text':'/          0 otherwise.','line_number':2863,'multiline':False]
['text':' If its a terminal, there is no file name, the buffer is not loaded,','line_number':2886,'multiline':False]
['text':' 'buftype' is set, we are in the middle of a save or being called','line_number':2887,'multiline':False]
['text':' recursively: ignore this buffer.','line_number':2888,'multiline':False]
['text':' set b_mtime to stop further warnings (e.g., when executing','line_number':2909,'multiline':False]
['text':' FileChangedShell autocmd)','line_number':2910,'multiline':False]
['text':' Check the file again later to see if it re-appears.','line_number':2912,'multiline':False]
['text':' Don't do anything for a directory.  Might contain the file explorer.','line_number':2921,'multiline':False]
['text':' If 'autoread' is set, the buffer has no changes and the file still','line_number':2924,'multiline':False]
['text':' exists, reload the buffer.  Use the buffer-local option value if it','line_number':2925,'multiline':False]
['text':' was set, the global option value otherwise.','line_number':2926,'multiline':False]
['text':' Only give the warning if there are no FileChangedShell','line_number':2942,'multiline':False]
['text':' autocommands.','line_number':2943,'multiline':False]
['text':' Avoid being called recursively by setting "busy".','line_number':2944,'multiline':False]
['text':' Only give the message once.','line_number':2969,'multiline':False]
['text':' Check if the file contents really changed to avoid','line_number':2977,'multiline':False]
['text':' giving a warning when only the timestamp was set (e.g.,','line_number':2978,'multiline':False]
['text':' checked out of CVS).  Always warn when the buffer was','line_number':2979,'multiline':False]
['text':' changed.','line_number':2980,'multiline':False]
['text':' Only timestamp changed, store it to avoid a warning','line_number':2992,'multiline':False]
['text':' in check_mtime() later.','line_number':2993,'multiline':False]
['text':' Set warningmsg here, before the unimportant and output-specific','line_number':3016,'multiline':False]
['text':' mesg2 has been appended.','line_number':3017,'multiline':False]
['text':' give the user some time to think about it','line_number':3052,'multiline':False]
['text':' don't redraw and erase the message','line_number':3055,'multiline':False]
['text':' Reload the buffer.','line_number':3067,'multiline':False]
['text':' Any existing undo file is unusable, write it now.','line_number':3072,'multiline':False]
['text':' Trigger FileChangedShell when the file was changed in any way.','line_number':3078,'multiline':False]
['text':'/ Reload a buffer that is already loaded.','line_number':3085,'multiline':False]
['text':'/ Used when the file was changed outside of Vim.','line_number':3086,'multiline':False]
['text':'/ "orig_mode" is buf->b_orig_mode before the need for reloading was detected.','line_number':3087,'multiline':False]
['text':'/ buf->b_orig_mode may have been reset already.','line_number':3088,'multiline':False]
['text':' Set curwin/curbuf for "buf" and save some things.','line_number':3099,'multiline':False]
['text':' Unless reload_options is set, we only want to read the text from the','line_number':3102,'multiline':False]
['text':' file, not reset the syntax highlighting, clear marks, diff status, etc.','line_number':3103,'multiline':False]
['text':' Force the fileformat and encoding to be the same.','line_number':3104,'multiline':False]
['text':' Save all the text, so that the reload can be undone.','line_number':3115,'multiline':False]
['text':' Sync first so that this is a separate undo-able action.','line_number':3116,'multiline':False]
['text':' To behave like when a new file is edited (matters for','line_number':3122,'multiline':False]
['text':' BufReadPost autocommands) we first need to delete the current','line_number':3123,'multiline':False]
['text':' buffer contents.  But if reading the file fails we should keep','line_number':3124,'multiline':False]
['text':' the old contents.  Can't use memory only, the file might be','line_number':3125,'multiline':False]
['text':' too big.  Use a hidden buffer to move the buffer contents to.','line_number':3126,'multiline':False]
['text':' Allocate a buffer without putting it in the buffer list.','line_number':3130,'multiline':False]
['text':' Open the memline.','line_number':3134,'multiline':False]
['text':' check for RO again','line_number':3150,'multiline':False]
['text':' don't detect 'filetype'','line_number':3151,'multiline':False]
['text':' Put the text back from the save buffer.  First','line_number':3158,'multiline':False]
['text':' delete any lines that readfile() added.','line_number':3159,'multiline':False]
['text':' "buf" still valid.','line_number':3167,'multiline':False]
['text':' Mark the buffer as unmodified and free undo info.','line_number':3168,'multiline':False]
['text':' Mark all undo states as changed.','line_number':3174,'multiline':False]
['text':' Invalidate diff info if necessary.','line_number':3187,'multiline':False]
['text':' Restore the topline and cursor position and check it (lines may','line_number':3190,'multiline':False]
['text':' have been removed).','line_number':3191,'multiline':False]
['text':' Update folds unless they are defined manually.','line_number':3202,'multiline':False]
['text':' If the mode didn't change and 'readonly' was set, keep the old','line_number':3210,'multiline':False]
['text':' value; the user probably used the ":view" command.  But don't','line_number':3211,'multiline':False]
['text':' reset it, might have had a read error.','line_number':3212,'multiline':False]
['text':' Modelines must override settings done by autocommands.','line_number':3217,'multiline':False]
['text':' restore curwin/curbuf and a few other things','line_number':3220,'multiline':False]
['text':' Careful: autocommands may have made "buf" invalid!','line_number':3222,'multiline':False]
['text':'/ Adjust the line with missing eol, used for the next write.','line_number':3234,'multiline':False]
['text':'/ Used for do_filter(), when the input lines for the filter are deleted.','line_number':3235,'multiline':False]
['text':' only if there is a missing eol','line_number':3238,'multiline':False]
['text':'/ Convert all backslashes in fname to forward slashes in-place,','line_number':3244,'multiline':False]
['text':'/ unless when it looks like a URL.','line_number':3245,'multiline':False]
['text':'/ Path to Nvim's own temp dir. Ends in a slash.','line_number':3259,'multiline':False]
['text':'/< File descriptor of temp dir','line_number':3262,'multiline':False]
['text':'/ Creates a directory for private use by this instance of Nvim, trying each of','line_number':3265,'multiline':False]
['text':'/ `TEMP_DIR_NAMES` until one succeeds.','line_number':3266,'multiline':False]
['text':'/','line_number':3267,'multiline':False]
['text':'/ Only done once, the same directory is used for all temp files.','line_number':3268,'multiline':False]
['text':'/ This method avoids security problems because of symlink attacks et al.','line_number':3269,'multiline':False]
['text':'/ It's also a bit faster, because we only need to check for an existing','line_number':3270,'multiline':False]
['text':'/ file when creating the directory and not for each temp file.','line_number':3271,'multiline':False]
['text':' Try each of these until one succeeds.','line_number':3274,'multiline':False]
['text':' Usernames may contain slashes! #19240','line_number':3281,'multiline':False]
['text':' Appname may be a relative path, replace slashes to make it name-like.','line_number':3285,'multiline':False]
['text':' Make sure the umask doesn't remove the executable bit.','line_number':3290,'multiline':False]
['text':' "repl" has been reported to use "0177".','line_number':3291,'multiline':False]
['text':' Expand environment variables, leave room for "/tmp/nvim.<user>/XXXXXX/999999999".','line_number':3294,'multiline':False]
['text':' "/tmp/" exists, now try to create "/tmp/nvim.<user>/".','line_number':3300,'multiline':False]
['text':' Always create, to avoid a race.','line_number':3306,'multiline':False]
['text':' XDG_RUNTIME_DIR must be owned by the user, mode 0700.','line_number':3310,'multiline':False]
['text':' TODO(justinmk): Windows ACL?','line_number':3313,'multiline':False]
['text':' If our "root" tempdir is invalid or fails, proceed without "<user>/".','line_number':3328,'multiline':False]
['text':' Else user1 could break user2 by creating "/tmp/nvim.user2/".','line_number':3329,'multiline':False]
['text':' Now try to create "/tmp/nvim.<user>/XXXXXX".','line_number':3333,'multiline':False]
['text':' mkdtemp "template", will be replaced with random alphanumeric chars.','line_number':3334,'multiline':False]
['text':' Successfully created and set temporary directory so stop trying.','line_number':3342,'multiline':False]
['text':' Couldn't set `vim_tempdir` to `path` so remove created directory.','line_number':3345,'multiline':False]
['text':'/ Core part of "readdir()" function.','line_number':3351,'multiline':False]
['text':'/ Retrieve the list of files/directories of "path" into "gap".','line_number':3352,'multiline':False]
['text':'/','line_number':3353,'multiline':False]
['text':'/ @return  OK for success, FAIL for failure.','line_number':3354,'multiline':False]
['text':'/ Delete "name" and everything in it, recursively.','line_number':3398,'multiline':False]
['text':'/','line_number':3399,'multiline':False]
['text':'/ @param name  The path which should be deleted.','line_number':3400,'multiline':False]
['text':'/','line_number':3401,'multiline':False]
['text':'/ @return  0 for success, -1 if some file was not deleted.','line_number':3402,'multiline':False]
['text':' Remember the failure but continue deleting any further','line_number':3415,'multiline':False]
['text':' entries.','line_number':3416,'multiline':False]
['text':' Delete symlink only.','line_number':3429,'multiline':False]
['text':'/ Open temporary directory and take file lock to prevent','line_number':3437,'multiline':False]
['text':'/ to be auto-cleaned.','line_number':3438,'multiline':False]
['text':'/ Close temporary directory - it automatically release file lock.','line_number':3454,'multiline':False]
['text':'/ Delete the temp directory and all files it contains.','line_number':3466,'multiline':False]
['text':' remove the trailing path separator','line_number':3476,'multiline':False]
['text':'/ Gets path to Nvim's own temp dir (ending with slash).','line_number':3482,'multiline':False]
['text':'/','line_number':3483,'multiline':False]
['text':'/ Creates the directory on the first call.','line_number':3484,'multiline':False]
['text':'/ Sets Nvim's own temporary directory name to `tempdir`. This directory must','line_number':3504,'multiline':False]
['text':'/ already exist. Expands the name to a full path and put it in `vim_tempdir`.','line_number':3505,'multiline':False]
['text':'/ This avoids that using `:cd` would confuse us.','line_number':3506,'multiline':False]
['text':'/','line_number':3507,'multiline':False]
['text':'/ @param tempdir must be no longer than MAXPATHL.','line_number':3508,'multiline':False]
['text':'/','line_number':3509,'multiline':False]
['text':'/ @return false if we run out of memory.','line_number':3510,'multiline':False]
['text':'/ Return a unique name that can be used for a temp file.','line_number':3528,'multiline':False]
['text':'/','line_number':3529,'multiline':False]
['text':'/ @note The temp file is NOT created.','line_number':3530,'multiline':False]
['text':'/','line_number':3531,'multiline':False]
['text':'/ @return  pointer to the temp file name or NULL if Nvim can't create','line_number':3532,'multiline':False]
['text':'/          temporary directory for its own temporary files.','line_number':3533,'multiline':False]
['text':' Temp filename counter.','line_number':3536,'multiline':False]
['text':' There is no need to check if the file exists, because we own the directory','line_number':3544,'multiline':False]
['text':' and nobody else creates a file in it.','line_number':3545,'multiline':False]
['text':'/ Tries matching a filename with a "pattern" ("prog" is NULL), or use the','line_number':3551,'multiline':False]
['text':'/ precompiled regprog "prog" ("pattern" is NULL).  That avoids calling','line_number':3552,'multiline':False]
['text':'/ vim_regcomp() often.','line_number':3553,'multiline':False]
['text':'/','line_number':3554,'multiline':False]
['text':'/ Used for autocommands and 'wildignore'.','line_number':3555,'multiline':False]
['text':'/','line_number':3556,'multiline':False]
['text':'/ @param pattern pattern to match with','line_number':3557,'multiline':False]
['text':'/ @param prog pre-compiled regprog or NULL','line_number':3558,'multiline':False]
['text':'/ @param fname full path of the file name','line_number':3559,'multiline':False]
['text':'/ @param sfname short file name or NULL','line_number':3560,'multiline':False]
['text':'/ @param tail tail of the path','line_number':3561,'multiline':False]
['text':'/ @param allow_dirs Allow matching with dir','line_number':3562,'multiline':False]
['text':'/','line_number':3563,'multiline':False]
['text':'/ @return true if there is a match, false otherwise','line_number':3564,'multiline':False]
['text':' ignore case if 'fileignorecase' is set','line_number':3571,'multiline':False]
['text':' Try for a match with the pattern with:','line_number':3574,'multiline':False]
['text':' 1. the full file name, when the pattern has a '/'.','line_number':3575,'multiline':False]
['text':' 2. the short file name, when the pattern has a '/'.','line_number':3576,'multiline':False]
['text':' 3. the tail of the file name, when the pattern has no '/'.','line_number':3577,'multiline':False]
['text':'/ Check if a file matches with a pattern in "list".','line_number':3595,'multiline':False]
['text':'/ "list" is a comma-separated list of patterns, like 'wildignore'.','line_number':3596,'multiline':False]
['text':'/ "sfname" is the short file name or NULL, "ffname" the long file name.','line_number':3597,'multiline':False]
['text':'/','line_number':3598,'multiline':False]
['text':'/ @param list list of patterns to match','line_number':3599,'multiline':False]
['text':'/ @param sfname short file name','line_number':3600,'multiline':False]
['text':'/ @param ffname full file name','line_number':3601,'multiline':False]
['text':'/','line_number':3602,'multiline':False]
['text':'/ @return true if there was a match','line_number':3603,'multiline':False]
['text':' try all patterns in 'wildignore'','line_number':3609,'multiline':False]
['text':'/ Convert the given pattern "pat" which has shell style wildcards in it, into','line_number':3628,'multiline':False]
['text':'/ a regular expression, and return the result in allocated memory.  If there','line_number':3629,'multiline':False]
['text':'/ is a directory path separator to be matched, then true is put in','line_number':3630,'multiline':False]
['text':'/ allow_dirs, otherwise false is put there -- webb.','line_number':3631,'multiline':False]
['text':'/ Handle backslashes before special characters, like "\*" and "\ ".','line_number':3632,'multiline':False]
['text':'/','line_number':3633,'multiline':False]
['text':'/ @param pat_end     first char after pattern or NULL','line_number':3634,'multiline':False]
['text':'/ @param allow_dirs  Result passed back out in here','line_number':3635,'multiline':False]
['text':'/ @param no_bslash   Don't use a backward slash as pathsep','line_number':3636,'multiline':False]
['text':'/','line_number':3637,'multiline':False]
['text':'/ @return            NULL on failure.','line_number':3638,'multiline':False]
['text':' '^' at start, '$' at end.','line_number':3654,'multiline':False]
['text':' extra backslash','line_number':3664,'multiline':False]
['text':' could become "[\/]"','line_number':3669,'multiline':False]
['text':' "**" matches like "*"','line_number':3702,'multiline':False]
['text':' translate:','line_number':3720,'multiline':False]
['text':' "\x" to "\\x"  e.g., "dir\file"','line_number':3721,'multiline':False]
['text':' "\*" to "\\.*" e.g., "dir\*.c"','line_number':3722,'multiline':False]
['text':' "\?" to "\\."  e.g., "dir\??.c"','line_number':3723,'multiline':False]
['text':' "\+" to "\+"   e.g., "fileX\+.c"','line_number':3724,'multiline':False]
['text':' Undo escaping from ExpandEscape():','line_number':3738,'multiline':False]
['text':' foo\?bar -> foo?bar','line_number':3739,'multiline':False]
['text':' foo\%bar -> foo%bar','line_number':3740,'multiline':False]
['text':' foo\,bar -> foo,bar','line_number':3741,'multiline':False]
['text':' foo\ bar -> foo bar','line_number':3742,'multiline':False]
['text':' Don't unescape \, * and others that are also special in a','line_number':3743,'multiline':False]
['text':' regexp.','line_number':3744,'multiline':False]
['text':' An escaped { must be unescaped since we use magic not','line_number':3745,'multiline':False]
['text':' verymagic.  Use "\\\{n,m\}"" to get "\{n,m}".','line_number':3746,'multiline':False]
['text':'/ Version of read() that retries when interrupted by EINTR (possibly','line_number':3819,'multiline':False]
['text':'/ by a SIGWINCH).','line_number':3820,'multiline':False]
['text':'/ Version of write() that retries when interrupted by EINTR (possibly','line_number':3834,'multiline':False]
['text':'/ by a SIGWINCH).','line_number':3835,'multiline':False]
['text':' Repeat the write() so long it didn't fail, other than being interrupted','line_number':3840,'multiline':False]
['text':' by a signal.','line_number':3841,'multiline':False]
