['text':' Terminate this state.','line_number':39,'multiline':False]
['text':' check() again.','line_number':41,'multiline':False]
['text':' Execute this state.','line_number':43,'multiline':False]
['text':' Apply mappings first by calling vpeekc() directly.','line_number':48,'multiline':False]
['text':' - If vpeekc() returns non-NUL, there is a character already available for processing, so','line_number':49,'multiline':False]
['text':'   don't block for events. vgetc() may still block, in case of an incomplete UTF-8 sequence.','line_number':50,'multiline':False]
['text':' - If vpeekc() returns NUL, vgetc() will block, and there are three cases:','line_number':51,'multiline':False]
['text':'   - There is no input available.','line_number':52,'multiline':False]
['text':'   - All of available input maps to an empty string.','line_number':53,'multiline':False]
['text':'   - There is an incomplete mapping.','line_number':54,'multiline':False]
['text':'   A blocking wait for a character should only be done in the third case, which is the only','line_number':55,'multiline':False]
['text':'   case of the three where typebuf.tb_len > 0 after vpeekc() returns NUL.','line_number':56,'multiline':False]
['text':' No input available and processing events may take time, flush now.','line_number':60,'multiline':False]
['text':' Event was made available after the last multiqueue_process_events call','line_number':62,'multiline':False]
['text':' Duplicate display updating logic in vgetorpeek()','line_number':65,'multiline':False]
['text':' put cursor back where it belongs','line_number':69,'multiline':False]
['text':' Flush screen updates before blocking.','line_number':71,'multiline':False]
['text':' Call `os_inchar` directly to block for events or user input without','line_number':73,'multiline':False]
['text':' consuming anything from `input_buffer`(os/input.c) or calling the','line_number':74,'multiline':False]
['text':' mapping engine.','line_number':75,'multiline':False]
['text':' If an event was put into the queue, we send K_EVENT directly.','line_number':77,'multiline':False]
['text':' An event handler may use the value of reg_executing.','line_number':86,'multiline':False]
['text':' Clear it if it should be cleared when getting the next character.','line_number':87,'multiline':False]
['text':'/ process events on main_loop, but interrupt if input is available','line_number':106,'multiline':False]
['text':'/','line_number':107,'multiline':False]
['text':'/ This should be used to handle K_EVENT in states accepting input','line_number':108,'multiline':False]
['text':'/ otherwise bursts of events can block break checking indefinitely.','line_number':109,'multiline':False]
['text':' don't breakcheck before return, caller should return to main-loop','line_number':119,'multiline':False]
['text':' and handle input already.','line_number':120,'multiline':False]
['text':' TODO(bfredl): as an further micro-optimization, we could check whether','line_number':124,'multiline':False]
['text':' event.handler already checked input.','line_number':125,'multiline':False]
['text':'/ Return true if in the current mode we need to use virtual.','line_number':133,'multiline':False]
['text':' While an operator is being executed we return "virtual_op", because','line_number':138,'multiline':False]
['text':' VIsual_active has already been reset, thus we can't check for "block"','line_number':139,'multiline':False]
['text':' being used.','line_number':140,'multiline':False]
['text':'/ MODE_VISUAL, MODE_SELECT and MODE_OP_PENDING State are never set, they are','line_number':149,'multiline':False]
['text':'/ equal to MODE_NORMAL State with a condition.  This function returns the real','line_number':150,'multiline':False]
['text':'/ State.','line_number':151,'multiline':False]
['text':'/ Returns the current mode as a string in "buf[MODE_MAX_LENGTH]", NUL','line_number':167,'multiline':False]
['text':'/ terminated.','line_number':168,'multiline':False]
['text':'/ The first character represents the major mode, the following ones the minor','line_number':169,'multiline':False]
['text':'/ ones.','line_number':170,'multiline':False]
['text':' to be able to detect force-linewise/blockwise/charwise operations','line_number':225,'multiline':False]
['text':'/ Fires a ModeChanged autocmd if appropriate.','line_number':242,'multiline':False]
['text':' Skip this when got_int is set, the autocommand will not be executed.','line_number':245,'multiline':False]
['text':' Better trigger it next time.','line_number':246,'multiline':False]
['text':' concatenate modes in format "old_mode:new_mode"','line_number':265,'multiline':False]
['text':'/ When true in a safe state when starting to wait for a character.','line_number':274,'multiline':False]
['text':'/ Return whether currently it is safe, assuming it was safe before (high level','line_number':277,'multiline':False]
['text':'/ state didn't change).','line_number':278,'multiline':False]
['text':'/ Trigger SafeState if currently in s safe state, that is "safe" is TRUE and','line_number':288,'multiline':False]
['text':'/ there is no typeahead.','line_number':289,'multiline':False]
['text':' Only log when the state changes, otherwise it happens at nearly','line_number':295,'multiline':False]
['text':' every key stroke.','line_number':296,'multiline':False]
['text':'/ Something changed which causes the state possibly to be unsafe, e.g. a','line_number':305,'multiline':False]
['text':'/ character was typed.  It will remain unsafe until the next call to','line_number':306,'multiline':False]
['text':'/ may_trigger_safestate().','line_number':307,'multiline':False]
