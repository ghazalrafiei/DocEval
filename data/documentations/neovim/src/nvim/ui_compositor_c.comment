['text':' Compositor: merge floating grids with the main grid for display in','line_number':1,'multiline':False]
['text':' TUI and non-multigrid UIs.','line_number':2,'multiline':False]
['text':'','line_number':3,'multiline':False]
['text':' Layer-based compositing: https://en.wikipedia.org/wiki/Digital_compositing','line_number':4,'multiline':False]
['text':'/ Places `grid` at (col,row) position with (width * height) size.','line_number':102,'multiline':False]
['text':'/ Adds `grid` as the top layer if it is a new layer.','line_number':103,'multiline':False]
['text':'/','line_number':104,'multiline':False]
['text':'/ TODO(bfredl): later on the compositor should just use win_float_pos events,','line_number':105,'multiline':False]
['text':'/ though that will require slight event order adjustment: emit the win_pos','line_number':106,'multiline':False]
['text':'/ events in the beginning of update_screen(), rather than in ui_flush()','line_number':107,'multiline':False]
['text':' Redraw the area covered by the old position, and is not covered','line_number':118,'multiline':False]
['text':' by the new position. Disable the grid so that compose_area() will not','line_number':119,'multiline':False]
['text':' use it.','line_number':120,'multiline':False]
['text':' not found: new grid','line_number':160,'multiline':False]
['text':' grid wasn't present','line_number':183,'multiline':False]
['text':' recompose the area under the grid','line_number':198,'multiline':False]
['text':' inefficient when being overlapped: only draw up to grid->comp_index','line_number':199,'multiline':False]
['text':' TODO(bfredl): maybe not the best time to do this, for efficiency we','line_number':250,'multiline':False]
['text':' should configure all grids before entering win_update()','line_number':251,'multiline':False]
['text':' TODO(bfredl): this happens with 'writedelay', refactor?','line_number':265,'multiline':False]
['text':' abort();','line_number':266,'multiline':False]
['text':'/ Compute which grid is on top at supplied screen coordinates','line_number':285,'multiline':False]
['text':'/ Baseline implementation. This is always correct, but we can sometimes','line_number':298,'multiline':False]
['text':'/ do something more efficient (where efficiency means smaller deltas to','line_number':299,'multiline':False]
['text':'/ the downstream UI.)','line_number':300,'multiline':False]
['text':' If rightleft is set, startcol may be -1. In such cases, the assertions','line_number':303,'multiline':False]
['text':' will fail because no overlap is found. Adjust startcol to prevent it.','line_number':304,'multiline':False]
['text':' in case we start on the right half of a double-width char, we need to','line_number':306,'multiline':False]
['text':' check the left half. But skip it in output if it wasn't doublewidth.','line_number':307,'multiline':False]
['text':' compose_line may have been called after a shrinking operation but','line_number':329,'multiline':False]
['text':' before the resize has actually been applied. Therefore, we need to','line_number':330,'multiline':False]
['text':' first check to see if any grids have pending updates to width/height,','line_number':331,'multiline':False]
['text':' to ensure that we don't accidentally put any characters into `linebuf`','line_number':332,'multiline':False]
['text':' that have been invalidated.','line_number':333,'multiline':False]
['text':' TODO(bfredl): when we implement borders around floating windows, then','line_number':355,'multiline':False]
['text':' msgsep can just be a border "around" the message grid.','line_number':356,'multiline':False]
['text':' 'pumblend' and 'winblend'','line_number':377,'multiline':False]
['text':' negative space','line_number':382,'multiline':False]
['text':' Tricky: if overlap caused a doublewidth char to get cut-off, must','line_number':399,'multiline':False]
['text':' replace the visible half with a space.','line_number':400,'multiline':False]
['text':'/ compose the area under the grid.','line_number':485,'multiline':False]
['text':'/','line_number':486,'multiline':False]
['text':'/ This is needed when some option affecting composition is changed,','line_number':487,'multiline':False]
['text':'/ such as 'pumblend' for popupmenu grid.','line_number':488,'multiline':False]
['text':' TODO(bfredl): this should not really be necessary. But on some condition','line_number':515,'multiline':False]
['text':' when resizing nvim, a window will be attempted to be drawn on the older','line_number':516,'multiline':False]
['text':' and possibly larger global screen size.','line_number':517,'multiline':False]
['text':' TODO(bfredl): eventually should just fix compose_line to respect clearing','line_number':533,'multiline':False]
['text':' and optimize it for uncovered lines.','line_number':534,'multiline':False]
['text':'/ The screen is invalid and will soon be cleared','line_number':551,'multiline':False]
['text':'/','line_number':552,'multiline':False]
['text':'/ Don't redraw floats until screen is cleared','line_number':553,'multiline':False]
['text':' scroll separator together with message text','line_number':585,'multiline':False]
['text':'/ check if curgrid is covered on row or above','line_number':598,'multiline':False]
['text':'/','line_number':599,'multiline':False]
['text':'/ TODO(bfredl): currently this only handles message row','line_number':600,'multiline':False]
['text':' TODO(bfredl):','line_number':621,'multiline':False]
['text':' 1. check if rectangles actually overlap','line_number':622,'multiline':False]
['text':' 2. calculate subareas that can scroll.','line_number':623,'multiline':False]
['text':' TODO(bfredl): workaround for win_update() performing two scrolls in a','line_number':626,'multiline':False]
['text':' row, where the latter might scroll invalid space created by the first.','line_number':627,'multiline':False]
['text':' ideally win_update() should keep track of this itself and not scroll','line_number':628,'multiline':False]
['text':' the invalid space.','line_number':629,'multiline':False]
