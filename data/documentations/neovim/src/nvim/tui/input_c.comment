['text':'/ Size of libtermkey's internal input buffer. The buffer may grow larger than','line_number':31,'multiline':False]
['text':'/ this when processing very long escape sequences, but will shrink back to','line_number':32,'multiline':False]
['text':'/ this size afterward','line_number':33,'multiline':False]
['text':' termkey_new_abstract assumes non-null (#2745)','line_number':143,'multiline':False]
['text':' setup input handle','line_number':155,'multiline':False]
['text':' initialize a timer handle for handling ESC with libtermkey','line_number':158,'multiline':False]
['text':'/ Send all pending input in key buffer to Nvim server.','line_number':189,'multiline':False]
['text':' produce exactly one paste event','line_number':192,'multiline':False]
['text':' 'data'','line_number':197,'multiline':False]
['text':' 'crlf'','line_number':198,'multiline':False]
['text':' 'phase'','line_number':199,'multiline':False]
['text':' Paste phase: "continue"','line_number':203,'multiline':False]
['text':' enqueue input','line_number':207,'multiline':False]
['text':' NOTE: This is non-blocking and won't check partially processed input,','line_number':212,'multiline':False]
['text':' but should be fine as all big sends are handled with nvim_paste, not nvim_input','line_number':213,'multiline':False]
['text':' don't ever let the buffer get too full or we risk putting incomplete keys','line_number':225,'multiline':False]
['text':' into it','line_number':226,'multiline':False]
['text':'/ Handle TERMKEY_KEYMOD_* modifiers, i.e. Shift, Alt and Ctrl.','line_number':232,'multiline':False]
['text':'/','line_number':233,'multiline':False]
['text':'/ @return  The number of bytes written into "buf", excluding the final NUL.','line_number':234,'multiline':False]
['text':' Shift','line_number':239,'multiline':False]
['text':' Alt','line_number':242,'multiline':False]
['text':' Ctrl','line_number':245,'multiline':False]
['text':'/ Handle modifiers not handled by libtermkey.','line_number':252,'multiline':False]
['text':'/ Currently only Super ("D-") and Meta ("T-") are supported in Nvim.','line_number':253,'multiline':False]
['text':'/','line_number':254,'multiline':False]
['text':'/ @return  The number of bytes written into "buf", excluding the final NUL.','line_number':255,'multiline':False]
['text':' Super','line_number':260,'multiline':False]
['text':' Meta','line_number':263,'multiline':False]
['text':' Termkey doesn't include the S- modifier for ASCII characters (e.g.,','line_number':326,'multiline':False]
['text':' ctrl-shift-l is <C-L> instead of <C-S-L>.  Vim, on the other hand,','line_number':327,'multiline':False]
['text':' treats <C-L> and <C-l> the same, requiring the S- modifier.','line_number':328,'multiline':False]
['text':' Make room for the S-','line_number':334,'multiline':False]
['text':' Some terminals (like urxvt) don't report which button was released.','line_number':366,'multiline':False]
['text':' libtermkey reports button 0 in this case.','line_number':367,'multiline':False]
['text':' For drag and release, we can reasonably infer the button to be the last','line_number':368,'multiline':False]
['text':' pressed one.','line_number':369,'multiline':False]
['text':' https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Other-buttons','line_number':375,'multiline':False]
['text':' Termkey uses 1-based coordinates','line_number':387,'multiline':False]
['text':' Doesn't actually work because there are only 3 bits (0x1c) for modifiers.','line_number':391,'multiline':False]
['text':' len += handle_more_modifiers(key, buf + len, sizeof(buf) - len);','line_number':392,'multiline':False]
['text':' else: Partial keypress event was found in the buffer, but it does not','line_number':464,'multiline':False]
['text':' yet contain all the bytes required. `key` structure indicates what','line_number':465,'multiline':False]
['text':' termkey_getkey_force() would return.','line_number':466,'multiline':False]
['text':' Stop the current timer if already running','line_number':469,'multiline':False]
['text':' If the raw buffer is not empty, process the raw buffer first because it is','line_number':480,'multiline':False]
['text':' processing an incomplete bracketed paster sequence.','line_number':481,'multiline':False]
['text':'/ Handle focus events.','line_number':489,'multiline':False]
['text':'/','line_number':490,'multiline':False]
['text':'/ If the upcoming sequence of bytes in the input stream matches the termcode','line_number':491,'multiline':False]
['text':'/ for "focus gained" or "focus lost", consume that sequence and send an event','line_number':492,'multiline':False]
['text':'/ to Nvim server.','line_number':493,'multiline':False]
['text':'/','line_number':494,'multiline':False]
['text':'/ @param input the input stream','line_number':495,'multiline':False]
['text':'/ @return true iff handle_focus_event consumed some input','line_number':496,'multiline':False]
['text':' Advance past the sequence','line_number':503,'multiline':False]
['text':' Pasting "start paste" code literally.','line_number':524,'multiline':False]
['text':' Advance past the sequence','line_number':526,'multiline':False]
['text':' Spurious "disable paste" code.','line_number':529,'multiline':False]
['text':' Flush before starting paste.','line_number':533,'multiline':False]
['text':' Paste phase: "first-chunk".','line_number':535,'multiline':False]
['text':' Paste phase: "last-chunk".','line_number':538,'multiline':False]
['text':' Paste phase: "disabled".','line_number':541,'multiline':False]
['text':' Wait for further input, as the sequence may be split.','line_number':549,'multiline':False]
['text':'/ Handle an OSC or DCS response sequence from the terminal.','line_number':555,'multiline':False]
['text':' Send an event to nvim core. This will update the v:termresponse variable','line_number':563,'multiline':False]
['text':' and fire the TermResponse event','line_number':564,'multiline':False]
['text':' libtermkey strips the OSC/DCS bytes from the response. We add it back in','line_number':568,'multiline':False]
['text':' so that downstream consumers of v:termresponse can differentiate between','line_number':569,'multiline':False]
['text':' the two.','line_number':570,'multiline':False]
['text':' Key type already checked for OSC/DCS in termkey_interpret_string','line_number':580,'multiline':False]
['text':'/ Handle a mode report (DECRPM) sequence from the terminal.','line_number':590,'multiline':False]
['text':' Unused','line_number':598,'multiline':False]
['text':'/ Handle a CSI sequence from the terminal that is unrecognized by libtermkey.','line_number':603,'multiline':False]
['text':' There is no specified limit on the number of parameters a CSI sequence can','line_number':607,'multiline':False]
['text':' contain, so just allocate enough space for a large upper bound','line_number':608,'multiline':False]
['text':' Currently unused','line_number':620,'multiline':False]
['text':' Kitty keyboard protocol query response.','line_number':627,'multiline':False]
['text':' Primary Device Attributes response','line_number':640,'multiline':False]
['text':' Enable the fallback key encoding (if any)','line_number':644,'multiline':False]
['text':' Wait for the next input, leaving it in the raw buffer due to an','line_number':665,'multiline':False]
['text':' incomplete sequence.','line_number':666,'multiline':False]
['text':'','line_number':672,'multiline':False]
['text':' Find the next ESC and push everything up to it (excluding), so it will','line_number':673,'multiline':False]
['text':' be the first thing encountered on the next iteration. The `handle_*`','line_number':674,'multiline':False]
['text':' calls (above) depend on this.','line_number':675,'multiline':False]
['text':'','line_number':676,'multiline':False]
['text':' Push bytes directly (paste).','line_number':685,'multiline':False]
['text':' Push through libtermkey (translates to "<keycode>" strings, etc.).','line_number':698,'multiline':False]
['text':' We are processing a very long escape sequence. Increase termkey's','line_number':702,'multiline':False]
['text':' internal buffer size. We don't handle out of memory situations so','line_number':703,'multiline':False]
['text':' abort if it fails','line_number':704,'multiline':False]
['text':' We resize termkey's buffer when it runs out of space, so this should','line_number':714,'multiline':False]
['text':' never happen','line_number':715,'multiline':False]
['text':' Process the input buffer now for any keys','line_number':719,'multiline':False]
['text':' If the termkey buffer was resized to handle a large input sequence then','line_number':732,'multiline':False]
['text':' shrink it back down to its original size.','line_number':733,'multiline':False]
['text':' An incomplete sequence was found. Leave it in the raw buffer and wait for','line_number':752,'multiline':False]
['text':' the next input.','line_number':753,'multiline':False]
['text':' If 'ttimeout' is not set, start the timer with a timeout of 0 to process','line_number':755,'multiline':False]
['text':' the next input.','line_number':756,'multiline':False]
['text':' Stop the current timer if already running','line_number':759,'multiline':False]
['text':' Make sure the next input escape sequence fits into the ring buffer without','line_number':765,'multiline':False]
['text':' wraparound, else it could be misinterpreted (because rbuffer_read_ptr()','line_number':766,'multiline':False]
['text':' exposes the underlying buffer to callers unaware of the wraparound).','line_number':767,'multiline':False]
