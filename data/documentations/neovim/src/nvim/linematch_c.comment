['text':' pow(2, LN_MAX_BUFS(8)) - 1 = 255','line_number':14,'multiline':False]
['text':' struct for running the diff linematch algorithm','line_number':16,'multiline':False]
['text':' to keep track of the total score of this path','line_number':19,'multiline':False]
['text':' current index of this path','line_number':20,'multiline':False]
['text':' to keep track of this path traveled','line_number':23,'multiline':False]
['text':'/ Same as matching_chars but ignore whitespace','line_number':40,'multiline':False]
['text':'/','line_number':41,'multiline':False]
['text':'/ @param s1','line_number':42,'multiline':False]
['text':'/ @param s2','line_number':43,'multiline':False]
['text':' the newly processed strings that will be compared','line_number':46,'multiline':False]
['text':' delete the white space characters, and/or replace all upper case with lower','line_number':47,'multiline':False]
['text':'/ Return matching characters between "s1" and "s2" whilst respecting sequence order.','line_number':74,'multiline':False]
['text':'/ Consider the case of two strings 'AAACCC' and 'CCCAAA', the','line_number':75,'multiline':False]
['text':'/ return value from this function will be 3, either to match','line_number':76,'multiline':False]
['text':'/ the 3 C's, or the 3 A's.','line_number':77,'multiline':False]
['text':'/','line_number':78,'multiline':False]
['text':'/ Examples:','line_number':79,'multiline':False]
['text':'/   matching_chars("aabc", "acba")               -> 2  // 'a' and 'b' in common','line_number':80,'multiline':False]
['text':'/   matching_chars("123hello567", "he123ll567o") -> 8  // '123', 'll' and '567' in common','line_number':81,'multiline':False]
['text':'/   matching_chars("abcdefg", "gfedcba")         -> 1  // all characters in common,','line_number':82,'multiline':False]
['text':'/                                                      // but only at most 1 in sequence','line_number':83,'multiline':False]
['text':'/','line_number':84,'multiline':False]
['text':'/ @param s1','line_number':85,'multiline':False]
['text':'/ @param s2','line_number':86,'multiline':False]
['text':' save space by storing only two rows for i axis','line_number':92,'multiline':False]
['text':' skip char in s1','line_number':98,'multiline':False]
['text':' skip char in s2','line_number':102,'multiline':False]
['text':' compare char in s1 and s2','line_number':106,'multiline':False]
['text':'/ count the matching characters between a variable number of strings "sp"','line_number':115,'multiline':False]
['text':'/ mark the strings that have already been compared to extract them later','line_number':116,'multiline':False]
['text':'/ without re-running the character match counting.','line_number':117,'multiline':False]
['text':'/ @param sp','line_number':118,'multiline':False]
['text':'/ @param fomvals','line_number':119,'multiline':False]
['text':'/ @param n','line_number':120,'multiline':False]
['text':' TODO(lewis6991): handle whitespace ignoring higher up in the stack','line_number':129,'multiline':False]
['text':' prioritize a match of 3 (or more lines) equally to a match of 2 lines','line_number':136,'multiline':False]
['text':'/ try all the different ways to compare these lines and use the one that','line_number':156,'multiline':False]
['text':'/ results in the most matching characters','line_number':157,'multiline':False]
['text':'/ @param df_iters','line_number':158,'multiline':False]
['text':'/ @param paths','line_number':159,'multiline':False]
['text':'/ @param npaths','line_number':160,'multiline':False]
['text':'/ @param path_idx','line_number':161,'multiline':False]
['text':'/ @param choice','line_number':162,'multiline':False]
['text':'/ @param diffcmppath','line_number':163,'multiline':False]
['text':'/ @param diff_len','line_number':164,'multiline':False]
['text':'/ @param ndiffs','line_number':165,'multiline':False]
['text':'/ @param diff_blk','line_number':166,'multiline':False]
['text':' get the index at all of the places','line_number':179,'multiline':False]
['text':' set it to 1','line_number':207,'multiline':False]
['text':' set it to 0','line_number':210,'multiline':False]
['text':'/ unwrap indexes to access n dimensional tensor','line_number':215,'multiline':False]
['text':'/ @param values','line_number':216,'multiline':False]
['text':'/ @param diff_len','line_number':217,'multiline':False]
['text':'/ @param ndiffs','line_number':218,'multiline':False]
['text':'/ populate the values of the linematch algorithm tensor, and find the best','line_number':236,'multiline':False]
['text':'/ decision for how to compare the relevant lines from each of the buffers at','line_number':237,'multiline':False]
['text':'/ each point in the tensor','line_number':238,'multiline':False]
['text':'/ @param df_iters','line_number':239,'multiline':False]
['text':'/ @param ch_dim','line_number':240,'multiline':False]
['text':'/ @param diffcmppath','line_number':241,'multiline':False]
['text':'/ @param diff_len','line_number':242,'multiline':False]
['text':'/ @param ndiffs','line_number':243,'multiline':False]
['text':'/ @param diff_blk','line_number':244,'multiline':False]
['text':'/ algorithm to find an optimal alignment of lines of a diff block with 2 or','line_number':274,'multiline':False]
['text':'/ more files. The algorithm is generalized to work for any number of files','line_number':275,'multiline':False]
['text':'/ which corresponds to another dimension added to the tensor used in the','line_number':276,'multiline':False]
['text':'/ algorithm','line_number':277,'multiline':False]
['text':'/','line_number':278,'multiline':False]
['text':'/ for questions and information about the linematch algorithm please contact','line_number':279,'multiline':False]
['text':'/ Jonathon White (jonathonwhite@protonmail.com)','line_number':280,'multiline':False]
['text':'/','line_number':281,'multiline':False]
['text':'/ for explanation, a summary of the algorithm in 3 dimensions (3 files','line_number':282,'multiline':False]
['text':'/     compared) follows','line_number':283,'multiline':False]
['text':'/','line_number':284,'multiline':False]
['text':'/ The 3d case (for 3 buffers) of the algorithm implemented when diffopt','line_number':285,'multiline':False]
['text':'/ 'linematch' is enabled. The algorithm constructs a 3d tensor to','line_number':286,'multiline':False]
['text':'/ compare a diff between 3 buffers. The dimensions of the tensor are','line_number':287,'multiline':False]
['text':'/ the length of the diff in each buffer plus 1 A path is constructed by','line_number':288,'multiline':False]
['text':'/ moving from one edge of the cube/3d tensor to the opposite edge.','line_number':289,'multiline':False]
['text':'/ Motions from one cell of the cube to the next represent decisions. In','line_number':290,'multiline':False]
['text':'/ a 3d cube, there are a total of 7 decisions that can be made,','line_number':291,'multiline':False]
['text':'/ represented by the enum df_path3_choice which is defined in','line_number':292,'multiline':False]
['text':'/ buffer_defs.h a comparison of buffer 0 and 1 represents a motion','line_number':293,'multiline':False]
['text':'/ toward the opposite edge of the cube with components along the 0 and','line_number':294,'multiline':False]
['text':'/ 1 axes.  a comparison of buffer 0, 1, and 2 represents a motion','line_number':295,'multiline':False]
['text':'/ toward the opposite edge of the cube with components along the 0, 1,','line_number':296,'multiline':False]
['text':'/ and 2 axes. A skip of buffer 0 represents a motion along only the 0','line_number':297,'multiline':False]
['text':'/ axis. For each action, a point value is awarded, and the path is','line_number':298,'multiline':False]
['text':'/ saved for reference later, if it is found to have been the optimal','line_number':299,'multiline':False]
['text':'/ path. The optimal path has the highest score.  The score is','line_number':300,'multiline':False]
['text':'/ calculated as the summation of the total characters matching between','line_number':301,'multiline':False]
['text':'/ all of the lines which were compared. The structure of the algorithm','line_number':302,'multiline':False]
['text':'/ is that of a dynamic programming problem.  We can calculate a point','line_number':303,'multiline':False]
['text':'/ i,j,k in the cube as a function of i-1, j-1, and k-1. To find the','line_number':304,'multiline':False]
['text':'/ score and path at point i,j,k, we must determine which path we want','line_number':305,'multiline':False]
['text':'/ to use, this is done by looking at the possibilities and choosing','line_number':306,'multiline':False]
['text':'/ the one which results in the local highest score.  The total highest','line_number':307,'multiline':False]
['text':'/ scored path is, then in the end represented by the cell in the','line_number':308,'multiline':False]
['text':'/ opposite corner from the start location.  The entire algorithm','line_number':309,'multiline':False]
['text':'/ consists of populating the 3d cube with the optimal paths from which','line_number':310,'multiline':False]
['text':'/ it may have came.','line_number':311,'multiline':False]
['text':'/','line_number':312,'multiline':False]
['text':'/ Optimizations:','line_number':313,'multiline':False]
['text':'/ As the function to calculate the cell of a tensor at point i,j,k is a','line_number':314,'multiline':False]
['text':'/ function of the cells at i-1, j-1, k-1, the whole tensor doesn't need','line_number':315,'multiline':False]
['text':'/ to be stored in memory at once. In the case of the 3d cube, only two','line_number':316,'multiline':False]
['text':'/ slices (along k and j axis) are stored in memory. For the 2d matrix','line_number':317,'multiline':False]
['text':'/ (for 2 files), only two rows are stored at a time. The next/previous','line_number':318,'multiline':False]
['text':'/ slice (or row) is always calculated from the other, and they alternate','line_number':319,'multiline':False]
['text':'/ at each iteration.','line_number':320,'multiline':False]
['text':'/ In the 3d case, 3 arrays are populated to memorize the score (matched','line_number':321,'multiline':False]
['text':'/ characters) of the 3 buffers, so a redundant calculation of the','line_number':322,'multiline':False]
['text':'/ scores does not occur','line_number':323,'multiline':False]
['text':'/ @param diff_blk','line_number':324,'multiline':False]
['text':'/ @param diff_len','line_number':325,'multiline':False]
['text':'/ @param ndiffs','line_number':326,'multiline':False]
['text':'/ @param [out] [allocated] decisions','line_number':327,'multiline':False]
['text':'/ @return the length of decisions','line_number':328,'multiline':False]
['text':' create the flattened path matrix','line_number':342,'multiline':False]
['text':' allocate memory here','line_number':344,'multiline':False]
['text':' memory for avoiding repetitive calculations of score','line_number':353,'multiline':False]
['text':' reverse array','line_number':368,'multiline':False]
['text':' returns the minimum amount of path changes from start to end','line_number':380,'multiline':False]
['text':' memoization','line_number':383,'multiline':False]
['text':' we have reached the end of the tree','line_number':386,'multiline':False]
['text':' the minimum amount of turns required to reach the end','line_number':389,'multiline':False]
['text':' recurse','line_number':391,'multiline':False]
