['text':' ieee754 single-precision limits to determine if "v" can be fully
   * represented in 4 bytes ','line_number':60,'multiline':True]
['text':' ieee754 single-precision limits to determine if "v" can be fully
   * represented in 4 bytes ','line_number':78,'multiline':True]
['text':' Compute the two's complement ','line_number':118,'multiline':True]
['text':' unpack signed integer without relying on two's complement as internal
 * representation ','line_number':203,'multiline':True]
['text':' reverse the two's complement so that lo/hi contain the absolute value.
   * note that we have to mask ~rv so that it reflects the two's complement
   * of the appropriate byte length ','line_number':215,'multiline':True]
['text':' negate and return the absolute value, making sure mpack_sintmax_t can
   * represent the positive cast. ','line_number':219,'multiline':True]
['text':' nothing to do ','line_number':233,'multiline':True]
['text':' restore sign/exponent/mantissa ','line_number':240,'multiline':True]
['text':' restore leading 1 ','line_number':253,'multiline':True]
['text':' subnormal ','line_number':254,'multiline':True]
['text':' restore original value ','line_number':257,'multiline':True]
['text':' same idea as mpack_unpack_sint, except here we shouldn't rely on
     * mpack_uintmax_t having 64-bits, operating on the 32-bit words separately.
     ','line_number':296,'multiline':True]
['text':' subnormal value ','line_number':339,'multiline':True]
['text':' remove leading 1 ','line_number':340,'multiline':True]
['text':' this simplified version of `fmod` that returns the remainder of double
 * division by 0xffffffff, which is enough for our purposes ','line_number':369,'multiline':True]
