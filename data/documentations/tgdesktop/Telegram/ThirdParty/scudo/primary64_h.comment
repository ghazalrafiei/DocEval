['text':'===-- primary64.h ---------------------------------------------*- C++ -*-===//','line_number':1,'multiline':False]
['text':'','line_number':2,'multiline':False]
['text':' Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.','line_number':3,'multiline':False]
['text':' See https://llvm.org/LICENSE.txt for license information.','line_number':4,'multiline':False]
['text':' SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception','line_number':5,'multiline':False]
['text':'','line_number':6,'multiline':False]
['text':'===----------------------------------------------------------------------===//','line_number':7,'multiline':False]
['text':' SizeClassAllocator64 is an allocator tuned for 64-bit address space.','line_number':26,'multiline':False]
['text':'','line_number':27,'multiline':False]
['text':' It starts by reserving NumClasses * 2^RegionSizeLog bytes, equally divided in','line_number':28,'multiline':False]
['text':' Regions, specific to each size class. Note that the base of that mapping is','line_number':29,'multiline':False]
['text':' random (based to the platform specific map() capabilities). If','line_number':30,'multiline':False]
['text':' PrimaryEnableRandomOffset is set, each Region actually starts at a random','line_number':31,'multiline':False]
['text':' offset from its base.','line_number':32,'multiline':False]
['text':'','line_number':33,'multiline':False]
['text':' Regions are mapped incrementally on demand to fulfill allocation requests,','line_number':34,'multiline':False]
['text':' those mappings being split into equally sized Blocks based on the size class','line_number':35,'multiline':False]
['text':' they belong to. The Blocks created are shuffled to prevent predictable','line_number':36,'multiline':False]
['text':' address patterns (the predictability increases with the size of the Blocks).','line_number':37,'multiline':False]
['text':'','line_number':38,'multiline':False]
['text':' The 1st Region (for size class 0) holds the TransferBatches. This is a','line_number':39,'multiline':False]
['text':' structure used to transfer arrays of available pointers from the class size','line_number':40,'multiline':False]
['text':' freelist to the thread specific freelist, and back.','line_number':41,'multiline':False]
['text':'','line_number':42,'multiline':False]
['text':' The memory used by this allocator is never unmapped, but can be partially','line_number':43,'multiline':False]
['text':' released if the platform allows for it.','line_number':44,'multiline':False]
['text':' When trying to release pages back to memory, visiting smaller size','line_number':73,'multiline':False]
['text':' classes is expensive. Therefore, we only try to release smaller size','line_number':74,'multiline':False]
['text':' classes when the amount of free blocks goes over a certain threshold (See','line_number':75,'multiline':False]
['text':' the comment in releaseToOSMaybe() for more details). For example, for','line_number':76,'multiline':False]
['text':' size class 32, we only do the release when the size of free blocks is','line_number':77,'multiline':False]
['text':' greater than 97% of pages in a group. However, this may introduce another','line_number':78,'multiline':False]
['text':' issue that if the number of free blocks is bouncing between 97% ~ 100%.','line_number':79,'multiline':False]
['text':' Which means we may try many page releases but only release very few of','line_number':80,'multiline':False]
['text':' them (less than 3% in a group). Even though we have','line_number':81,'multiline':False]
['text':' `&ReleaseToOsIntervalMs` which slightly reduce the frequency of these','line_number':82,'multiline':False]
['text':' calls but it will be better to have another guard to mitigate this issue.','line_number':83,'multiline':False]
['text':'','line_number':84,'multiline':False]
['text':' Here we add another constraint on the minimum size requirement. The','line_number':85,'multiline':False]
['text':' constraint is determined by the size of in-use blocks in the minimal size','line_number':86,'multiline':False]
['text':' class. Take size class 32 as an example,','line_number':87,'multiline':False]
['text':'','line_number':88,'multiline':False]
['text':'   +-     one memory group      -+','line_number':89,'multiline':False]
['text':'   +----------------------+------+','line_number':90,'multiline':False]
['text':'   |  97% of free blocks  |      |','line_number':91,'multiline':False]
['text':'   +----------------------+------+','line_number':92,'multiline':False]
['text':'                           \    /','line_number':93,'multiline':False]
['text':'                      3% in-use blocks','line_number':94,'multiline':False]
['text':'','line_number':95,'multiline':False]
['text':'   * The release size threshold is 97%.','line_number':96,'multiline':False]
['text':'','line_number':97,'multiline':False]
['text':' The 3% size in a group is about 7 pages. For two consecutive','line_number':98,'multiline':False]
['text':' releaseToOSMaybe(), we require the difference between `PushedBlocks`','line_number':99,'multiline':False]
['text':' should be greater than 7 pages. This mitigates the page releasing','line_number':100,'multiline':False]
['text':' thrashing which is caused by memory usage bouncing around the threshold.','line_number':101,'multiline':False]
['text':' The smallest size class takes longest time to do the page release so we','line_number':102,'multiline':False]
['text':' use its size of in-use blocks as a heuristic.','line_number':103,'multiline':False]
['text':' Reserve the space required for the Primary.','line_number':107,'multiline':False]
['text':'Addr=','line_number':108,'multiline':True]
['text':' The actual start of a region is offset by a random number of pages','line_number':120,'multiline':False]
['text':' when PrimaryEnableRandomOffset is set.','line_number':121,'multiline':False]
['text':' Releasing small blocks is expensive, set a higher threshold to avoid','line_number':128,'multiline':False]
['text':' frequent page releases.','line_number':129,'multiline':False]
['text':' When all blocks are freed, it has to be the same size as `AllocatedUser`.','line_number':155,'multiline':False]
['text':' `BatchGroup` and `TransferBatch` also use the blocks from BatchClass.','line_number':157,'multiline':False]
['text':' We have to count BatchClassUsedInFreeLists in other regions first.','line_number':160,'multiline':False]
['text':' `BG::Batches` are `TransferBatches`. +1 for `BatchGroup`.','line_number':169,'multiline':False]
['text':' `BatchGroup` with empty freelist doesn't have `TransferBatch` record','line_number':190,'multiline':False]
['text':' itself.','line_number':191,'multiline':False]
['text':' When two threads compete for `Region->MMLock`, we only want one of them','line_number':219,'multiline':False]
['text':' does the populateFreeListAndPopBatch(). To avoid both of them doing','line_number':220,'multiline':False]
['text':' that, always check the freelist before mapping new pages.','line_number':221,'multiline':False]
['text':'','line_number':222,'multiline':False]
['text':' TODO(chiahungduan): Use a condition variable so that we don't need to','line_number':223,'multiline':False]
['text':' hold `Region->MMLock` here.','line_number':224,'multiline':False]
['text':' Note that `getStats()` requires locking each region so we can't call it','line_number':240,'multiline':False]
['text':' while locking the Region->Mutex in the above.','line_number':241,'multiline':False]
['text':' Theoretically, BatchClass shouldn't be used up. Abort immediately  when','line_number':250,'multiline':False]
['text':' it happens.','line_number':251,'multiline':False]
['text':' Push the array of free blocks to the designated batch group.','line_number':259,'multiline':False]
['text':' TODO(chiahungduan): Consider not doing grouping if the group size is not','line_number':271,'multiline':False]
['text':' greater than the block size with a certain scale.','line_number':272,'multiline':False]
['text':' Sort the blocks so that blocks belonging to the same group can be pushed','line_number':274,'multiline':False]
['text':' together.','line_number':275,'multiline':False]
['text':' The BatchClassId must be locked last since other classes can use it.','line_number':296,'multiline':False]
['text':' TODO: The call of `iterateOverBlocks` requires disabling','line_number':323,'multiline':False]
['text':' SizeClassAllocator64. We may consider locking each region on demand','line_number':324,'multiline':False]
['text':' only.','line_number':325,'multiline':False]
['text':' TODO(kostyak): get the RSS per region.','line_number':337,'multiline':False]
['text':' Not supported by the Primary, but not an error either.','line_number':374,'multiline':False]
['text':' Note that the tryLock() may fail spuriously, given that it should rarely','line_number':380,'multiline':False]
['text':' happen and page releasing is fine to skip, we don't take certain','line_number':381,'multiline':False]
['text':' approaches to ensure one page release is done.','line_number':382,'multiline':False]
['text':' TODO(chiahungduan): In fact, We need to lock the RegionInfo::MMLock.','line_number':435,'multiline':False]
['text':' However, the RegionInfoData is passed with const qualifier and lock the','line_number':436,'multiline':False]
['text':' mutex requires modifying RegionInfoData, which means we need to remove','line_number':437,'multiline':False]
['text':' the const qualifier. This may lead to another undefined behavior (The','line_number':438,'multiline':False]
['text':' first one is accessing `AllocatedUser` without locking. It's better to','line_number':439,'multiline':False]
['text':' pass `RegionInfoData` as `void *` then we can lock the mutex properly.','line_number':440,'multiline':False]
['text':' Fill at most this number of batches from the newly map'd memory.','line_number':485,'multiline':False]
['text':' Bytes mapped for user memory.','line_number':503,'multiline':False]
['text':' Bytes allocated for user memory.','line_number':505,'multiline':False]
['text':' Mutex for operations on freelist','line_number':510,'multiline':False]
['text':' Mutex for memmap operations','line_number':512,'multiline':False]
['text':' `RegionBeg` is initialized before thread creation and won't be changed.','line_number':514,'multiline':False]
['text':' The minimum size of pushed blocks to trigger page release.','line_number':519,'multiline':False]
['text':' Free blocks are recorded by TransferBatch in freelist for all','line_number':572,'multiline':False]
['text':' size-classes. In addition, TransferBatch is allocated from BatchClassId.','line_number':573,'multiline':False]
['text':' In order not to use additional block to record the free blocks in','line_number':574,'multiline':False]
['text':' BatchClassId, they are self-contained. I.e., A TransferBatch records the','line_number':575,'multiline':False]
['text':' block address of itself. See the figure below:','line_number':576,'multiline':False]
['text':'','line_number':577,'multiline':False]
['text':' TransferBatch at 0xABCD','line_number':578,'multiline':False]
['text':' +----------------------------+','line_number':579,'multiline':False]
['text':' | Free blocks' addr          |','line_number':580,'multiline':False]
['text':' | +------+------+------+     |','line_number':581,'multiline':False]
['text':' | |0xABCD|...   |...   |     |','line_number':582,'multiline':False]
['text':' | +------+------+------+     |','line_number':583,'multiline':False]
['text':' +----------------------------+','line_number':584,'multiline':False]
['text':'','line_number':585,'multiline':False]
['text':' When we allocate all the free blocks in the TransferBatch, the block used','line_number':586,'multiline':False]
['text':' by TransferBatch is also free for use. We don't need to recycle the','line_number':587,'multiline':False]
['text':' TransferBatch. Note that the correctness is maintained by the invariant,','line_number':588,'multiline':False]
['text':'','line_number':589,'multiline':False]
['text':'   The unit of each popBatch() request is entire TransferBatch. Return','line_number':590,'multiline':False]
['text':'   part of the blocks in a TransferBatch is invalid.','line_number':591,'multiline':False]
['text':'','line_number':592,'multiline':False]
['text':' This ensures that TransferBatch won't leak the address itself while it's','line_number':593,'multiline':False]
['text':' still holding other valid data.','line_number':594,'multiline':False]
['text':'','line_number':595,'multiline':False]
['text':' Besides, BatchGroup is also allocated from BatchClassId and has its','line_number':596,'multiline':False]
['text':' address recorded in the TransferBatch too. To maintain the correctness,','line_number':597,'multiline':False]
['text':'','line_number':598,'multiline':False]
['text':'   The address of BatchGroup is always recorded in the last TransferBatch','line_number':599,'multiline':False]
['text':'   in the freelist (also imply that the freelist should only be','line_number':600,'multiline':False]
['text':'   updated with push_front). Once the last TransferBatch is popped,','line_number':601,'multiline':False]
['text':'   the block used by BatchGroup is also free for use.','line_number':602,'multiline':False]
['text':'','line_number':603,'multiline':False]
['text':' With this approach, the blocks used by BatchGroup and TransferBatch are','line_number':604,'multiline':False]
['text':' reusable and don't need additional space for them.','line_number':605,'multiline':False]
['text':' Construct `BatchGroup` on the last element.','line_number':611,'multiline':False]
['text':' BatchClass hasn't enabled memory group. Use `0` to indicate there's no','line_number':616,'multiline':False]
['text':' memory group here.','line_number':617,'multiline':False]
['text':' `BG` is also the block of BatchClassId. Note that this is different','line_number':619,'multiline':False]
['text':' from `CreateGroup` in `pushBlocksImpl`','line_number':620,'multiline':False]
['text':' This happens under 2 cases.','line_number':632,'multiline':False]
['text':'   1. just allocated a new `BatchGroup`.','line_number':633,'multiline':False]
['text':'   2. Only 1 block is pushed when the freelist is empty.','line_number':634,'multiline':False]
['text':' Construct the `TransferBatch` on the last element.','line_number':636,'multiline':False]
['text':' As mentioned above, addresses of `TransferBatch` and `BatchGroup` are','line_number':640,'multiline':False]
['text':' recorded in the TransferBatch.','line_number':641,'multiline':False]
['text':' `TB` is also the block of BatchClassId.','line_number':647,'multiline':False]
['text':' Self-contained','line_number':662,'multiline':False]
['text':' TODO(chiahungduan): Avoid the use of push_back() in `Batches` of','line_number':665,'multiline':False]
['text':' BatchClassId.','line_number':666,'multiline':False]
['text':' `UnusedSlots` is u16 so the result will be also fit in u16.','line_number':670,'multiline':False]
['text':' Push the blocks to their batch group. The layout will be like,','line_number':679,'multiline':False]
['text':'','line_number':680,'multiline':False]
['text':' FreeListInfo.BlockList - > BG -> BG -> BG','line_number':681,'multiline':False]
['text':'                            |     |     |','line_number':682,'multiline':False]
['text':'                            v     v     v','line_number':683,'multiline':False]
['text':'                            TB    TB    TB','line_number':684,'multiline':False]
['text':'                            |','line_number':685,'multiline':False]
['text':'                            v','line_number':686,'multiline':False]
['text':'                            TB','line_number':687,'multiline':False]
['text':'','line_number':688,'multiline':False]
['text':' Each BlockGroup(BG) will associate with unique group id and the free blocks','line_number':689,'multiline':False]
['text':' are managed by a list of TransferBatch(TB). To reduce the time of inserting','line_number':690,'multiline':False]
['text':' blocks, BGs are sorted and the input `Array` are supposed to be sorted so','line_number':691,'multiline':False]
['text':' that we can get better performance of maintaining sorted property.','line_number':692,'multiline':False]
['text':' Use `SameGroup=true` to indicate that all blocks in the array are from the','line_number':693,'multiline':False]
['text':' same group then we will skip checking the group id of each block.','line_number':694,'multiline':False]
['text':' `UnusedSlots` is u16 so the result will be also fit in u16.','line_number':734,'multiline':False]
['text':' Don't need to classify BatchClassId.','line_number':748,'multiline':False]
['text':'CompactPtrGroupBase=','line_number':749,'multiline':True]
['text':' In the following, `Cur` always points to the BatchGroup for blocks that','line_number':756,'multiline':False]
['text':' will be pushed next. `Prev` is the element right before `Cur`.','line_number':757,'multiline':False]
['text':' All the blocks are from the same group, just push without checking group','line_number':775,'multiline':False]
['text':' id.','line_number':776,'multiline':False]
['text':' The blocks are sorted by group id. Determine the segment of group and','line_number':785,'multiline':False]
['text':' push them to their group together.','line_number':786,'multiline':False]
['text':' Pop one TransferBatch from a BatchGroup. The BatchGroup with the smallest','line_number':815,'multiline':False]
['text':' group id will be considered first.','line_number':816,'multiline':False]
['text':'','line_number':817,'multiline':False]
['text':' The region mutex needs to be held while calling this method.','line_number':818,'multiline':False]
['text':' Block used by `BatchGroup` is from BatchClassId. Turn the block into','line_number':832,'multiline':False]
['text':' `TransferBatch` with single block.','line_number':833,'multiline':False]
['text':' We don't keep BatchGroup with zero blocks to avoid empty-checking while','line_number':851,'multiline':False]
['text':' allocating. Note that block used by constructing BatchGroup is recorded','line_number':852,'multiline':False]
['text':' as free blocks in the last element of BatchGroup::Batches. Which means,','line_number':853,'multiline':False]
['text':' once we pop the last TransferBatch, the block is implicitly','line_number':854,'multiline':False]
['text':' deallocated.','line_number':855,'multiline':False]
['text':' Refill the freelist and return one batch.','line_number':865,'multiline':False]
['text':' Map more space for blocks, if necessary.','line_number':876,'multiline':False]
['text':' Do the mmap for the user memory.','line_number':878,'multiline':False]
['text':'SameGroup=','line_number':924,'multiline':True]
['text':'SameGroup=','line_number':934,'multiline':True]
['text':' Note that `PushedBlocks` and `PoppedBlocks` are supposed to only record','line_number':942,'multiline':False]
['text':' the requests from `PushBlocks` and `PopBatch` which are external','line_number':943,'multiline':False]
['text':' interfaces. `populateFreeListAndPopBatch` is the internal interface so we','line_number':944,'multiline':False]
['text':' should set the values back to avoid incorrectly setting the stats.','line_number':945,'multiline':False]
['text':' ====================================================================== //','line_number':1001,'multiline':False]
['text':' 1. Check if we have enough free blocks and if it's worth doing a page','line_number':1002,'multiline':False]
['text':'    release.','line_number':1003,'multiline':False]
['text':' ====================================================================== //','line_number':1004,'multiline':False]
['text':' ====================================================================== //','line_number':1011,'multiline':False]
['text':' 2. Determine which groups can release the pages. Use a heuristic to','line_number':1012,'multiline':False]
['text':'    gather groups that are candidates for doing a release.','line_number':1013,'multiline':False]
['text':' ====================================================================== //','line_number':1014,'multiline':False]
['text':' Ideally, we should use a class like `ScopedUnlock`. However, this form of','line_number':1026,'multiline':False]
['text':' unlocking is not supported by the thread-safety analysis. See','line_number':1027,'multiline':False]
['text':' https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#no-alias-analysis','line_number':1028,'multiline':False]
['text':' for more details.','line_number':1029,'multiline':False]
['text':' Put it as local class so that we can mark the ctor/dtor with proper','line_number':1030,'multiline':False]
['text':' annotations associated to the target lock. Note that accessing the','line_number':1031,'multiline':False]
['text':' function variable in local class only works in thread-safety annotations.','line_number':1032,'multiline':False]
['text':' TODO: Implement general `ScopedUnlock` when it's supported.','line_number':1033,'multiline':False]
['text':' Note that we have extracted the `GroupsToRelease` from region freelist.','line_number':1047,'multiline':False]
['text':' It's safe to let pushBlocks()/popBatches() access the remaining region','line_number':1048,'multiline':False]
['text':' freelist. In the steps 3 and 4, we will temporarily release the FLLock','line_number':1049,'multiline':False]
['text':' and lock it again before step 5.','line_number':1050,'multiline':False]
['text':' ==================================================================== //','line_number':1055,'multiline':False]
['text':' 3. Mark the free blocks in `GroupsToRelease` in the','line_number':1056,'multiline':False]
['text':'    `PageReleaseContext`. Then we can tell which pages are in-use by','line_number':1057,'multiline':False]
['text':'    querying `PageReleaseContext`.','line_number':1058,'multiline':False]
['text':' ==================================================================== //','line_number':1059,'multiline':False]
['text':' ==================================================================== //','line_number':1068,'multiline':False]
['text':' 4. Release the unused physical pages back to the OS.','line_number':1069,'multiline':False]
['text':' ==================================================================== //','line_number':1070,'multiline':False]
['text':' ====================================================================== //','line_number':1085,'multiline':False]
['text':' 5. Merge the `GroupsToRelease` back to the freelist.','line_number':1086,'multiline':False]
['text':' ====================================================================== //','line_number':1087,'multiline':False]
['text':' Always update `BytesInFreeListAtLastCheckpoint` with the smallest value','line_number':1100,'multiline':False]
['text':' so that we won't underestimate the releasable pages. For example, the','line_number':1101,'multiline':False]
['text':' following is the region usage,','line_number':1102,'multiline':False]
['text':'','line_number':1103,'multiline':False]
['text':'  BytesInFreeListAtLastCheckpoint   AllocatedUser','line_number':1104,'multiline':False]
['text':'                v                         v','line_number':1105,'multiline':False]
['text':'  |--------------------------------------->','line_number':1106,'multiline':False]
['text':'         ^                   ^','line_number':1107,'multiline':False]
['text':'  BytesInFreeList     ReleaseThreshold','line_number':1108,'multiline':False]
['text':'','line_number':1109,'multiline':False]
['text':' In general, if we have collected enough bytes and the amount of free','line_number':1110,'multiline':False]
['text':' bytes meets the ReleaseThreshold, we will try to do page release. If we','line_number':1111,'multiline':False]
['text':' don't update `BytesInFreeListAtLastCheckpoint` when the current','line_number':1112,'multiline':False]
['text':' `BytesInFreeList` is smaller, we may take longer time to wait for enough','line_number':1113,'multiline':False]
['text':' freed blocks because we miss the bytes between','line_number':1114,'multiline':False]
['text':' (BytesInFreeListAtLastCheckpoint - BytesInFreeList).','line_number':1115,'multiline':False]
['text':' Releasing smaller blocks is expensive, so we want to make sure that a','line_number':1126,'multiline':False]
['text':' significant amount of bytes are free, and that there has been a good','line_number':1127,'multiline':False]
['text':' amount of batches pushed to the freelist before attempting to release.','line_number':1128,'multiline':False]
['text':' The constant 8 here is selected from profiling some apps and the number','line_number':1138,'multiline':False]
['text':' of unreleased pages in the large size classes is around 16 pages or','line_number':1139,'multiline':False]
['text':' more. Choose half of it as a heuristic and which also avoids page','line_number':1140,'multiline':False]
['text':' release every time for every pushBlocks() attempt by large blocks.','line_number':1141,'multiline':False]
['text':' Memory was returned recently.','line_number':1148,'multiline':False]
['text':' if (ReleaseType == ReleaseToOS::Normal)','line_number':1152,'multiline':False]
['text':' We are examining each group and will take the minimum distance to the','line_number':1165,'multiline':False]
['text':' release threshold as the next Region::TryReleaseThreshold(). Note that if','line_number':1166,'multiline':False]
['text':' the size of free blocks has reached the release threshold, the distance','line_number':1167,'multiline':False]
['text':' to the next release will be PageSize * SmallerBlockReleasePageDelta. See','line_number':1168,'multiline':False]
['text':' the comment on `SmallerBlockReleasePageDelta` for more details.','line_number':1169,'multiline':False]
['text':' Group boundary is always GroupSize-aligned from CompactPtr base. The','line_number':1175,'multiline':False]
['text':' layout of memory groups is like,','line_number':1176,'multiline':False]
['text':'','line_number':1177,'multiline':False]
['text':'     (CompactPtrBase)','line_number':1178,'multiline':False]
['text':' #1 CompactPtrGroupBase   #2 CompactPtrGroupBase            ...','line_number':1179,'multiline':False]
['text':'           |                       |                       |','line_number':1180,'multiline':False]
['text':'           v                       v                       v','line_number':1181,'multiline':False]
['text':'           +-----------------------+-----------------------+','line_number':1182,'multiline':False]
['text':'            \                     / \                     /','line_number':1183,'multiline':False]
['text':'             ---   GroupSize   ---   ---   GroupSize   ---','line_number':1184,'multiline':False]
['text':'','line_number':1185,'multiline':False]
['text':' After decompacting the CompactPtrGroupBase, we expect the alignment','line_number':1186,'multiline':False]
['text':' property is held as well.','line_number':1187,'multiline':False]
['text':' TransferBatches are pushed in front of BG.Batches. The first one may','line_number':1193,'multiline':False]
['text':' not have all caches used.','line_number':1194,'multiline':False]
['text':' Given the randomness property, we try to release the pages only if the','line_number':1208,'multiline':False]
['text':' bytes used by free blocks exceed certain proportion of group size. Note','line_number':1209,'multiline':False]
['text':' that this heuristic only applies when all the spaces in a BatchGroup','line_number':1210,'multiline':False]
['text':' are allocated.','line_number':1211,'multiline':False]
['text':' If all blocks in the group are released, we will do range marking','line_number':1221,'multiline':False]
['text':' which is fast. Otherwise, we will wait until we have accumulated','line_number':1222,'multiline':False]
['text':' a certain amount of free memory.','line_number':1223,'multiline':False]
['text':' The following is the usage of a memroy group,','line_number':1231,'multiline':False]
['text':'','line_number':1232,'multiline':False]
['text':'     BytesInBG             ReleaseThreshold','line_number':1233,'multiline':False]
['text':'  /             \                 v','line_number':1234,'multiline':False]
['text':'  +---+---------------------------+-----+','line_number':1235,'multiline':False]
['text':'  |   |         |                 |     |','line_number':1236,'multiline':False]
['text':'  +---+---------------------------+-----+','line_number':1237,'multiline':False]
['text':'       \        /                       ^','line_number':1238,'multiline':False]
['text':'    PushedBytesDelta                 GroupEnd','line_number':1239,'multiline':False]
['text':' If it reaches high density at this round, the next time we will try','line_number':1244,'multiline':False]
['text':' to release is based on SmallerBlockReleasePageDelta','line_number':1245,'multiline':False]
['text':' If `BG` is the first BatchGroup in the list, we only need to advance','line_number':1257,'multiline':False]
['text':' `BG` and call FreeListInfo.BlockList::pop_front(). No update is needed','line_number':1258,'multiline':False]
['text':' for `Prev`.','line_number':1259,'multiline':False]
['text':'','line_number':1260,'multiline':False]
['text':'         (BG)   (BG->Next)','line_number':1261,'multiline':False]
['text':' Prev     Cur      BG','line_number':1262,'multiline':False]
['text':'   |       |       |','line_number':1263,'multiline':False]
['text':'   v       v       v','line_number':1264,'multiline':False]
['text':'  nil     +--+    +--+','line_number':1265,'multiline':False]
['text':'          |X | -> |  | -> ...','line_number':1266,'multiline':False]
['text':'          +--+    +--+','line_number':1267,'multiline':False]
['text':'','line_number':1268,'multiline':False]
['text':' Otherwise, `Prev` will be used to extract the `Cur` from the','line_number':1269,'multiline':False]
['text':' `FreeListInfo.BlockList`.','line_number':1270,'multiline':False]
['text':'','line_number':1271,'multiline':False]
['text':'         (BG)   (BG->Next)','line_number':1272,'multiline':False]
['text':' Prev     Cur      BG','line_number':1273,'multiline':False]
['text':'   |       |       |','line_number':1274,'multiline':False]
['text':'   v       v       v','line_number':1275,'multiline':False]
['text':'  +--+    +--+    +--+','line_number':1276,'multiline':False]
['text':'  |  | -> |X | -> |  | -> ...','line_number':1277,'multiline':False]
['text':'  +--+    +--+    +--+','line_number':1278,'multiline':False]
['text':'','line_number':1279,'multiline':False]
['text':' After FreeListInfo.BlockList::extract(),','line_number':1280,'multiline':False]
['text':'','line_number':1281,'multiline':False]
['text':' Prev     Cur       BG','line_number':1282,'multiline':False]
['text':'   |       |        |','line_number':1283,'multiline':False]
['text':'   v       v        v','line_number':1284,'multiline':False]
['text':'  +--+    +--+     +--+','line_number':1285,'multiline':False]
['text':'  |  |-+  |X |  +->|  | -> ...','line_number':1286,'multiline':False]
['text':'  +--+ |  +--+  |  +--+','line_number':1287,'multiline':False]
['text':'       +--------+','line_number':1288,'multiline':False]
['text':'','line_number':1289,'multiline':False]
['text':' Note that we need to advance before pushing this BatchGroup to','line_number':1290,'multiline':False]
['text':' GroupsToRelease because it's a destructive operation.','line_number':1291,'multiline':False]
['text':' Ideally, we may want to update this only after successful release.','line_number':1296,'multiline':False]
['text':' However, for smaller blocks, each block marking is a costly operation.','line_number':1297,'multiline':False]
['text':' Therefore, we update it earlier.','line_number':1298,'multiline':False]
['text':' TODO: Consider updating this after releasing pages if `ReleaseRecorder`','line_number':1299,'multiline':False]
['text':' can tell the released bytes in each group.','line_number':1300,'multiline':False]
['text':' Only small blocks have the adaptive `TryReleaseThreshold`.','line_number':1310,'multiline':False]
['text':' If the MinDistToThreshold is not updated, that means each memory group','line_number':1312,'multiline':False]
['text':' may have only pushed less than a page size. In that case, just set it','line_number':1313,'multiline':False]
['text':' back to normal.','line_number':1314,'multiline':False]
['text':' The last block may straddle the group boundary. Rounding up to BlockSize','line_number':1340,'multiline':False]
['text':' to get the exact range.','line_number':1341,'multiline':False]
['text':'NumberOfRegions=','line_number':1348,'multiline':True]
['text':' We may not be able to do the page release in a rare case that we may','line_number':1350,'multiline':False]
['text':' fail on PageMap allocation.','line_number':1351,'multiline':False]
['text':'RegionIndex=','line_number':1384,'multiline':True]
['text':' Note that we don't always visit blocks in each BatchGroup so that we','line_number':1388,'multiline':False]
['text':' may miss the chance of releasing certain pages that cross','line_number':1389,'multiline':False]
['text':' BatchGroups.','line_number':1390,'multiline':False]
['text':'RegionIndex=','line_number':1392,'multiline':True]
['text':' After merging two freelists, we may have redundant `BatchGroup`s that','line_number':1405,'multiline':False]
['text':' need to be recycled. The number of unused `BatchGroup`s is expected to be','line_number':1406,'multiline':False]
['text':' small. Pick a constant which is inferred from real programs.','line_number':1407,'multiline':False]
['text':' We can't call pushBatchClassBlocks() to recycle the unused `BatchGroup`s','line_number':1412,'multiline':False]
['text':' when we are manipulating the freelist of `BatchClassRegion`. Instead, we','line_number':1413,'multiline':False]
['text':' should just push it back to the freelist when we merge two `BatchGroup`s.','line_number':1414,'multiline':False]
['text':' This logic hasn't been implemented because we haven't supported releasing','line_number':1415,'multiline':False]
['text':' pages in `BatchClassRegion`.','line_number':1416,'multiline':False]
['text':' Merge GroupsToRelease back to the Region::FreeListInfo.BlockList. Note','line_number':1419,'multiline':False]
['text':' that both `Region->FreeListInfo.BlockList` and `GroupsToRelease` are','line_number':1420,'multiline':False]
['text':' sorted.','line_number':1421,'multiline':False]
['text':' We have updated `BatchGroup::BytesInBGAtLastCheckpoint` while','line_number':1446,'multiline':False]
['text':' collecting the `GroupsToRelease`.','line_number':1447,'multiline':False]
['text':' Note that the first TransferBatches in both `Batches` may not be','line_number':1451,'multiline':False]
['text':' full and only the first TransferBatch can have non-full blocks. Thus','line_number':1452,'multiline':False]
['text':' we have to merge them before appending one to another.','line_number':1453,'multiline':False]
['text':' The remaining Batches in `Cur` are full.','line_number':1460,'multiline':False]
['text':' Only 1 non-full TransferBatch, push it to the front.','line_number':1464,'multiline':False]
['text':' At here, the `BG` is the first BatchGroup with CompactPtrGroupBase','line_number':1498,'multiline':False]
['text':' larger than the first element in `GroupsToRelease`. We need to insert','line_number':1499,'multiline':False]
['text':' `GroupsToRelease::front()` (which is `Cur` below)  before `BG`.','line_number':1500,'multiline':False]
['text':'','line_number':1501,'multiline':False]
['text':'   1. If `Prev` is nullptr, we simply push `Cur` to the front of','line_number':1502,'multiline':False]
['text':'      FreeListInfo.BlockList.','line_number':1503,'multiline':False]
['text':'   2. Otherwise, use `insert()` which inserts an element next to `Prev`.','line_number':1504,'multiline':False]
['text':'','line_number':1505,'multiline':False]
['text':' Afterwards, we don't need to advance `BG` because the order between','line_number':1506,'multiline':False]
['text':' `BG` and the new `GroupsToRelease::front()` hasn't been checked.','line_number':1507,'multiline':False]
['text':' TODO: `PrimaryBase` can be obtained from ReservedMemory. This needs to be','line_number':1530,'multiline':False]
['text':' deprecated.','line_number':1531,'multiline':False]
['text':' The minimum size of pushed blocks that we will try to release the pages in','line_number':1534,'multiline':False]
['text':' that size class.','line_number':1535,'multiline':False]
['text':' namespace scudo','line_number':1541,'multiline':False]
['text':' SCUDO_PRIMARY64_H_','line_number':1543,'multiline':False]
