['text':' SPDX-License-Identifier: MPL-2.0 ','line_number':1,'multiline':True]
['text':' ----------------------------------------------------------------------','line_number':156,'multiline':False]
['text':' Node we're currently at in the traversal and its predecessors.','line_number':197,'multiline':False]
['text':' Index of the next byte to match in the key.','line_number':201,'multiline':False]
['text':' Index of the next byte to match in the current node's prefix.','line_number':203,'multiline':False]
['text':' Index of the edge from parent to current node.','line_number':205,'multiline':False]
['text':' Index of the edge from grandparent to parent.','line_number':207,'multiline':False]
['text':' Even if a prefix of the key matches and we're doing a','line_number':221,'multiline':False]
['text':' lookup, this means we've found a matching subscription.','line_number':222,'multiline':False]
['text':' There was a mismatch or we've matched the whole key, so','line_number':229,'multiline':False]
['text':' there's nothing more to do.','line_number':230,'multiline':False]
['text':' We need to match the rest of the key. Check if there's an','line_number':234,'multiline':False]
['text':' outgoing edge from this node.','line_number':235,'multiline':False]
['text':' No outgoing edge.','line_number':248,'multiline':False]
['text':' Not all characters match, we might have to split the node.','line_number':269,'multiline':False]
['text':' The mismatch is at one of the outgoing edges, so we','line_number':271,'multiline':False]
['text':' create an edge from the current node to a new leaf node','line_number':272,'multiline':False]
['text':' that has the rest of the key as the prefix.','line_number':273,'multiline':False]
['text':' Reallocate for one more edge.','line_number':277,'multiline':False]
['text':' Make room for the new edge. We need to shift the chunk','line_number':281,'multiline':False]
['text':' of node pointers one byte to the right. Since resize()','line_number':282,'multiline':False]
['text':' increments the edgecount by 1, node_pointers() tells us the','line_number':283,'multiline':False]
['text':' destination address. The chunk of node pointers starts','line_number':284,'multiline':False]
['text':' at one byte to the left of this destination.','line_number':285,'multiline':False]
['text':'','line_number':286,'multiline':False]
['text':' Since the regions can overlap, we use memmove.','line_number':287,'multiline':False]
['text':' Add an edge to the new node.','line_number':292,'multiline':False]
['text':' We need to update all pointers to the current node','line_number':296,'multiline':False]
['text':' after the call to resize().','line_number':297,'multiline':False]
['text':' There was a mismatch, so we need to split this node.','line_number':306,'multiline':False]
['text':'','line_number':307,'multiline':False]
['text':' Create two nodes that will be reachable from the parent.','line_number':308,'multiline':False]
['text':' One node will have the rest of the characters from the key,','line_number':309,'multiline':False]
['text':' and the other node will have the rest of the characters','line_number':310,'multiline':False]
['text':' from the current node's prefix.','line_number':311,'multiline':False]
['text':' Copy the prefix chunks to the new nodes.','line_number':318,'multiline':False]
['text':' Copy the current node's edges to the new node.','line_number':322,'multiline':False]
['text':' Resize the current node to accommodate a prefix comprising','line_number':326,'multiline':False]
['text':' the matched characters and 2 outgoing edges to the above','line_number':327,'multiline':False]
['text':' nodes. Set the refcount to 0 since this node doesn't hold a','line_number':328,'multiline':False]
['text':' key.','line_number':329,'multiline':False]
['text':' Add links to the new nodes. We don't need to copy the','line_number':333,'multiline':False]
['text':' prefix since resize() retains it in the current node.','line_number':334,'multiline':False]
['text':' All characters in the key match, but we still might need to split.','line_number':343,'multiline':False]
['text':' All characters in the key match, but not all characters','line_number':345,'multiline':False]
['text':' from the current node's prefix match.','line_number':346,'multiline':False]
['text':' Create a node that contains the rest of the characters from','line_number':348,'multiline':False]
['text':' the current node's prefix and the outgoing edges from the','line_number':349,'multiline':False]
['text':' current node.','line_number':350,'multiline':False]
['text':' Resize the current node to hold only the matched characters','line_number':359,'multiline':False]
['text':' from its prefix and one edge to the new node.','line_number':360,'multiline':False]
['text':' Add an edge to the split node and set the refcount to 1','line_number':363,'multiline':False]
['text':' since this key wasn't inserted earlier. We don't need to','line_number':364,'multiline':False]
['text':' set the prefix because the first `prefix_bytes_matched` bytes','line_number':365,'multiline':False]
['text':' in the prefix are preserved by resize().','line_number':366,'multiline':False]
['text':' Don't delete the root node.','line_number':404,'multiline':False]
['text':' This node can't be merged with any other node, so there's','line_number':410,'multiline':False]
['text':' nothing more to do.','line_number':411,'multiline':False]
['text':' Merge this node with the single child node.','line_number':415,'multiline':False]
['text':' Make room for the child node's prefix and edges. We need to','line_number':418,'multiline':False]
['text':' keep the old prefix length since resize() will overwrite','line_number':419,'multiline':False]
['text':' it.','line_number':420,'multiline':False]
['text':' Append the child node's prefix to the current node.','line_number':425,'multiline':False]
['text':' Copy the rest of child node's data to the current node.','line_number':429,'multiline':False]
['text':' Removing this node leaves the parent with one child.','line_number':441,'multiline':False]
['text':' If the parent doesn't hold a key or if it isn't the root,','line_number':442,'multiline':False]
['text':' we can merge it with its single child node.','line_number':443,'multiline':False]
['text':' Make room for the child node's prefix and edges. We need to','line_number':447,'multiline':False]
['text':' keep the old prefix length since resize() will overwrite','line_number':448,'multiline':False]
['text':' it.','line_number':449,'multiline':False]
['text':' Append the child node's prefix to the current node.','line_number':454,'multiline':False]
['text':' Copy the rest of child node's data to the current node.','line_number':458,'multiline':False]
['text':' This is a leaf node that doesn't leave its parent with one','line_number':469,'multiline':False]
['text':' outgoing edge. Remove the outgoing edge to this node from the','line_number':470,'multiline':False]
['text':' parent.','line_number':471,'multiline':False]
['text':' Replace the edge to the current node with the last edge. An','line_number':474,'multiline':False]
['text':' edge consists of a byte and a pointer to the next node. First','line_number':475,'multiline':False]
['text':' replace the byte.','line_number':476,'multiline':False]
['text':' Move the chunk of pointers one byte to the left, effectively','line_number':482,'multiline':False]
['text':' deleting the last byte in the region of first bytes by','line_number':483,'multiline':False]
['text':' overwriting it.','line_number':484,'multiline':False]
['text':' Shrink the parent node to the new size, which "deletes" the','line_number':488,'multiline':False]
['text':' last pointer in the chunk of node pointers.','line_number':489,'multiline':False]
['text':' Nothing points to this node now, so we can reclaim it.','line_number':493,'multiline':False]
['text':' Root node is always empty.','line_number':541,'multiline':False]
