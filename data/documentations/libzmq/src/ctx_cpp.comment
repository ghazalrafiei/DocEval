['text':' SPDX-License-Identifier: MPL-2.0 ','line_number':1,'multiline':True]
['text':' -1 because we need room for the reaper mailbox.','line_number':43,'multiline':False]
['text':'  Initialise crypto library, if needed.','line_number':69,'multiline':False]
['text':'  Check that there are no remaining _sockets.','line_number':88,'multiline':False]
['text':'  Ask I/O threads to terminate. If stop signal wasn't sent to I/O','line_number':91,'multiline':False]
['text':'  thread subsequent invocation of destructor would hang-up.','line_number':92,'multiline':False]
['text':'  Wait till I/O threads actually terminate.','line_number':98,'multiline':False]
['text':'  Deallocate the reaper thread object.','line_number':103,'multiline':False]
['text':'  The mailboxes in _slots themselves were deallocated with their','line_number':106,'multiline':False]
['text':'  corresponding io_thread/socket objects.','line_number':107,'multiline':False]
['text':'  De-initialise crypto library, if needed.','line_number':109,'multiline':False]
['text':'  Remove the tag, so that the object is considered dead.','line_number':120,'multiline':False]
['text':' Connect up any pending inproc connections, otherwise we will hang','line_number':136,'multiline':False]
['text':' create_socket might fail eg: out of memory/sockets limit reached','line_number':141,'multiline':False]
['text':' we are a forked child process. Close all file descriptors','line_number':151,'multiline':False]
['text':' inherited from the parent.','line_number':152,'multiline':False]
['text':'  Check whether termination was already underway, but interrupted and now','line_number':161,'multiline':False]
['text':'  restarted.','line_number':162,'multiline':False]
['text':'  First attempt to terminate the context.','line_number':166,'multiline':False]
['text':'  First send stop command to sockets so that any blocking calls','line_number':168,'multiline':False]
['text':'  can be interrupted. If there are no sockets we can ask reaper','line_number':169,'multiline':False]
['text':'  thread to stop.','line_number':170,'multiline':False]
['text':'  Wait till reaper thread closes all the sockets.','line_number':180,'multiline':False]
['text':'  Deallocate the resources.','line_number':202,'multiline':False]
['text':'  Send stop command to sockets so that any blocking calls','line_number':216,'multiline':False]
['text':'  can be interrupted. If there are no sockets we can ask reaper','line_number':217,'multiline':False]
['text':'  thread to stop.','line_number':218,'multiline':False]
['text':'  Initialise the array of mailboxes. Additional two slots are for','line_number':388,'multiline':False]
['text':'  zmq_ctx_term thread and reaper thread.','line_number':389,'multiline':False]
['text':'  Initialise the infrastructure for zmq_ctx_term thread.','line_number':406,'multiline':False]
['text':'  Create the reaper thread.','line_number':409,'multiline':False]
['text':'  Create I/O thread objects and launch them.','line_number':420,'multiline':False]
['text':'  In the unused part of the slot array, create a list of empty slots.','line_number':439,'multiline':False]
['text':'  Once zmq_ctx_term() or zmq_ctx_shutdown() was called, we can't create','line_number':462,'multiline':False]
['text':'  new sockets.','line_number':463,'multiline':False]
['text':'  If max_sockets limit was reached, return error.','line_number':474,'multiline':False]
['text':'  Choose a slot for the socket.','line_number':480,'multiline':False]
['text':'  Generate new unique socket ID.','line_number':484,'multiline':False]
['text':'  Create the socket and register its mailbox.','line_number':487,'multiline':False]
['text':'  Free the associated thread slot.','line_number':503,'multiline':False]
['text':'  Remove the socket from the list of sockets.','line_number':508,'multiline':False]
['text':'  If zmq_ctx_term() was already called and there are no more socket','line_number':511,'multiline':False]
['text':'  we can ask reaper thread to terminate.','line_number':512,'multiline':False]
['text':' start_thread() allows max 16 chars for thread name','line_number':588,'multiline':False]
['text':'  Find the I/O thread with minimum load.','line_number':652,'multiline':False]
['text':'  Remove endpoint.','line_number':694,'multiline':False]
['text':'  Increment the command sequence number of the peer so that it won't','line_number':730,'multiline':False]
['text':'  get deallocated until "bind" command is issued by the caller.','line_number':731,'multiline':False]
['text':'  The subsequent 'bind' has to be called with inc_seqnum parameter','line_number':732,'multiline':False]
['text':'  set to false, so that the seqnum isn't incremented twice.','line_number':733,'multiline':False]
['text':'  Still no bind.','line_number':750,'multiline':False]
['text':'  Bind has happened in the mean time, connect directly','line_number':755,'multiline':False]
['text':' When a ctx is terminated all pending inproc connection will be','line_number':829,'multiline':False]
['text':' connected, but the socket will already be closed and the pipe will be','line_number':830,'multiline':False]
['text':' in waiting_for_delimiter state, which means no more writes can be done','line_number':831,'multiline':False]
['text':' and the routing id write fails and causes an assert. Check if the socket','line_number':832,'multiline':False]
['text':' is open before sending.','line_number':833,'multiline':False]
['text':'  If set, send the hello msg of the bind socket to the pending connection.','line_number':840,'multiline':False]
['text':'  The last used socket ID, or 0 if no socket was used so far. Note that this','line_number':870,'multiline':False]
['text':'  is a global variable. Thus, even sockets created in different contexts have','line_number':871,'multiline':False]
['text':'  unique IDs.','line_number':872,'multiline':False]
