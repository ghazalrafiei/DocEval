['text':' in case it was not already called','line_number':54,'multiline':False]
['text':' Parse the "network_" address int "iface", "addr", and "port"','line_number':60,'multiline':False]
['text':' norm endpoint format: [id,][<iface>;]<addr>:<port>','line_number':61,'multiline':False]
['text':' First, look for optional local NormNodeId','line_number':62,'multiline':False]
['text':' (default NORM_NODE_ANY causes NORM to use host IP addr for NormNodeId)','line_number':63,'multiline':False]
['text':' Second, look for optional multicast ifaceName','line_number':79,'multiline':False]
['text':' return error instead?','line_number':85,'multiline':False]
['text':' Finally, parse IP address and port number','line_number':95,'multiline':False]
['text':' errno set by whatever caused NormCreateInstance() to fail','line_number':113,'multiline':False]
['text':' TBD - What do we use for our local NormNodeId?','line_number':118,'multiline':False]
['text':'       (for now we use automatic, IP addr based assignment or passed in 'id')','line_number':119,'multiline':False]
['text':'       a) Use ZMQ Identity somehow?','line_number':120,'multiline':False]
['text':'       b) Add function to use iface addr','line_number':121,'multiline':False]
['text':'       c) Randomize and implement a NORM session layer','line_number':122,'multiline':False]
['text':'          conflict detection/resolution protocol','line_number':123,'multiline':False]
['text':' There's many other useful NORM options that could be applied here','line_number':133,'multiline':False]
['text':' These only apply for multicast sessions','line_number':135,'multiline':False]
['text':' port reuse doesn't work for non-connected unicast','line_number':139,'multiline':False]
['text':' needed when multicast users on same machine','line_number':141,'multiline':False]
['text':' Note a bad interface may not be caught until sender or receiver start','line_number':143,'multiline':False]
['text':' (Since sender/receiver is not yet started, this always succeeds here)','line_number':144,'multiline':False]
['text':' Set TOS but check TOS ECN bit for CCE modes','line_number':151,'multiline':False]
['text':' ECN Capable Transport not set, so set it','line_number':155,'multiline':False]
['text':' Congestion Experienced is an invalid setting, remove one of the bits','line_number':160,'multiline':False]
['text':' The alternative NORM_SYNC_CURRENT here would provide "instant"','line_number':167,'multiline':False]
['text':' receiver sync to the sender's _current_ message transmission.','line_number':168,'multiline':False]
['text':' NORM_SYNC_STREAM tries to get everything the sender has cached/buffered','line_number':169,'multiline':False]
['text':' errno set by whatever failed','line_number':173,'multiline':False]
['text':' session gets closed, too','line_number':175,'multiline':False]
['text':' Handle invalid settings -- num_parity must be >= num_autoparity (which has a default of 0)','line_number':185,'multiline':False]
['text':' Handle invalid settings -- block size must be > effective num_parity (which is <255)','line_number':190,'multiline':False]
['text':' Pick a random sender instance id (aka norm sender session id)','line_number':194,'multiline':False]
['text':' TBD - provide "options" for some NORM sender parameters','line_number':196,'multiline':False]
['text':' errno set by whatever failed','line_number':201,'multiline':False]
['text':' session gets closed, too','line_number':203,'multiline':False]
['text':' Handle NORM mode','line_number':209,'multiline':False]
['text':' errno set by whatever failed','line_number':232,'multiline':False]
['text':' session gets closed, too','line_number':234,'multiline':False]
['text':' NORM Stream options','line_number':240,'multiline':False]
['text':'NormSetMessageTrace(norm_session, true);','line_number':244,'multiline':False]
['text':'NormSetDebugLevel(3);','line_number':245,'multiline':False]
['text':'NormOpenDebugLog(norm_instance, "normLog.txt");','line_number':246,'multiline':False]
['text':' no error','line_number':248,'multiline':False]
['text':' end zmq::norm_engine_t::init()','line_number':249,'multiline':False]
['text':' TBD - implement a more graceful shutdown option','line_number':253,'multiline':False]
['text':' delete any active NormRxStreamState','line_number':257,'multiline':False]
['text':' end zmq::norm_engine_t::shutdown()','line_number':277,'multiline':False]
['text':' Set POLLIN for notification of pending NormEvents','line_number':294,'multiline':False]
['text':' TBD - we may assign the NORM engine to an io_thread in the future???','line_number':296,'multiline':False]
['text':' end zmq::norm_engine_t::init()','line_number':312,'multiline':False]
['text':' end zmq::norm_engine_t::unplug()','line_number':328,'multiline':False]
['text':' There's new message data available from the session','line_number':339,'multiline':False]
['text':' end zmq::norm_engine_t::restart_output()','line_number':344,'multiline':False]
['text':' Here we write as much as is available or we can','line_number':348,'multiline':False]
['text':' Our tx_buffer needs data to send','line_number':351,'multiline':False]
['text':' Get more data from encoder','line_number':352,'multiline':False]
['text':' We don't need to mark eom/flush until a message is sent','line_number':358,'multiline':False]
['text':' A prior message was completely written to stream, so','line_number':361,'multiline':False]
['text':' mark end-of-message and possibly flush (to force packet transmission,','line_number':362,'multiline':False]
['text':' even if it's not a full segment so message gets delivered quickly)','line_number':363,'multiline':False]
['text':' NormStreamMarkEom(norm_tx_stream);  // the flush below marks eom','line_number':364,'multiline':False]
['text':' Note NORM_FLUSH_ACTIVE makes NORM fairly chatty for low duty cycle messaging','line_number':365,'multiline':False]
['text':' but makes sure content is delivered quickly.  Positive acknowledgements','line_number':366,'multiline':False]
['text':' with flush override would make NORM more succinct here','line_number':367,'multiline':False]
['text':' Need to pull and load a new message to send','line_number':370,'multiline':False]
['text':' We need to wait for "restart_output()" to be called by ZMQ','line_number':372,'multiline':False]
['text':' Should we write message size header for NORM to use? Or expect NORM','line_number':377,'multiline':False]
['text':' receiver to decode ZMQ message framing format(s)?','line_number':378,'multiline':False]
['text':' OK - we need to use a byte to denote when the ZMQ frame is the _first_','line_number':379,'multiline':False]
['text':'      frame of a message so it can be decoded properly when a receiver','line_number':380,'multiline':False]
['text':'      'syncs' mid-stream.  We key off the the state of the 'more_flag'','line_number':381,'multiline':False]
['text':'      I.e.,If  more_flag _was_ false previously, this is the first','line_number':382,'multiline':False]
['text':'      frame of a ZMQ message.','line_number':383,'multiline':False]
['text':' this is not first frame of message','line_number':386,'multiline':False]
['text':' this is first frame of message','line_number':388,'multiline':False]
['text':' Go ahead an get a first chunk of the message','line_number':390,'multiline':False]
['text':' Do we have data in our tx_buffer pending','line_number':397,'multiline':False]
['text':' We have data in our tx_buffer to send, so write it to the stream','line_number':399,'multiline':False]
['text':' NORM stream buffer full, wait for NORM_TX_QUEUE_VACANCY','line_number':403,'multiline':False]
['text':' all buffered data was written','line_number':407,'multiline':False]
['text':' end while (zmq_output_ready && norm_tx_ready)','line_number':409,'multiline':False]
['text':' end zmq::norm_engine_t::send_data()','line_number':410,'multiline':False]
['text':' This means a NormEvent is pending, so call NormGetNextEvent() and handle','line_number':414,'multiline':False]
['text':' NORM has died before we unplugged?!','line_number':422,'multiline':False]
['text':'break;','line_number':438,'multiline':False]
['text':' Remove the state from the list it's in','line_number':447,'multiline':False]
['text':' This is now unnecessary since deletion takes care of list removal','line_number':448,'multiline':False]
['text':' but in the interest of being clear ...','line_number':449,'multiline':False]
['text':' Here we free resources used for this formerly active sender.','line_number':458,'multiline':False]
['text':' Note w/ NORM_SYNC_STREAM, if sender reactivates, we may','line_number':459,'multiline':False]
['text':'  get some messages delivered twice.  NORM_SYNC_CURRENT would','line_number':460,'multiline':False]
['text':' mitigate that but might miss data at startup. Always tradeoffs.','line_number':461,'multiline':False]
['text':' Instead of immediately deleting, we could instead initiate a','line_number':462,'multiline':False]
['text':' user configurable timeout here to wait some amount of time','line_number':463,'multiline':False]
['text':' after this event to declare the remote sender truly dead','line_number':464,'multiline':False]
['text':' and delete its state???','line_number':465,'multiline':False]
['text':' We ignore some NORM events','line_number':470,'multiline':False]
['text':' zmq::norm_engine_t::in_event()','line_number':473,'multiline':False]
['text':' TBD - should we check/assert that zmq_input_ready was false???','line_number':477,'multiline':False]
['text':' Process any pending received messages','line_number':479,'multiline':False]
['text':' end zmq::norm_engine_t::restart_input()','line_number':484,'multiline':False]
['text':' Call result of NORM_RX_OBJECT_UPDATED notification','line_number':489,'multiline':False]
['text':' This is a rx_ready indication for a new or existing rx stream','line_number':490,'multiline':False]
['text':' First, determine if this is a stream we already know','line_number':491,'multiline':False]
['text':' Since there can be multiple senders (publishers), we keep','line_number':493,'multiline':False]
['text':' state for each separate rx stream.','line_number':494,'multiline':False]
['text':' This is a new stream, so create rxState with zmq decoder, etc','line_number':498,'multiline':False]
['text':' Existing non-ready stream, so remove from pending','line_number':511,'multiline':False]
['text':' list to be promoted to rx_ready_list ...','line_number':512,'multiline':False]
['text':' TBD - prepend up front for immediate service?','line_number':516,'multiline':False]
['text':' This loop repeats until we've read all data available from "rx ready" inbound streams','line_number':521,'multiline':False]
['text':' and pushed any accumulated messages we can up to the zmq session.','line_number':522,'multiline':False]
['text':' Iterate through our rx_ready streams, reading data into the decoder','line_number':525,'multiline':False]
['text':' (This services incoming "rx ready" streams in a round-robin fashion)','line_number':526,'multiline':False]
['text':' msg completed','line_number':531,'multiline':False]
['text':' Complete message decoded, move this stream to msg_ready_list','line_number':532,'multiline':False]
['text':' to push the message up to the session below.  Note the stream','line_number':533,'multiline':False]
['text':' will be returned to the "rx_ready_list" after that's done','line_number':534,'multiline':False]
['text':' decoding error (shouldn't happen w/ NORM, but ...)','line_number':539,'multiline':False]
['text':' We need to re-sync this stream (decoder buffer was reset)','line_number':540,'multiline':False]
['text':' 0 - need more data','line_number':544,'multiline':False]
['text':' Get more data from this stream','line_number':547,'multiline':False]
['text':' First, make sure we're in sync ...','line_number':549,'multiline':False]
['text':' seek NORM message start','line_number':551,'multiline':False]
['text':' Need to wait for more data','line_number':553,'multiline':False]
['text':' read message 'flag' byte to see if this it's a 'final' frame','line_number':556,'multiline':False]
['text':' broken stream (can happen on late-joining subscriber)','line_number':560,'multiline':False]
['text':' This probably shouldn't happen either since we found msg start','line_number':564,'multiline':False]
['text':' Need to wait for more data','line_number':565,'multiline':False]
['text':' else keep seeking ...','line_number':570,'multiline':False]
['text':' end while(!rxState->InSync())','line_number':571,'multiline':False]
['text':' Need more data for this stream, so remove from "rx ready"','line_number':573,'multiline':False]
['text':' list and iterate to next "rx ready" stream','line_number':574,'multiline':False]
['text':' Move from rx_ready_list to rx_pending_list','line_number':576,'multiline':False]
['text':' Now we're actually ready to read data from the NORM stream to the zmq_decoder','line_number':581,'multiline':False]
['text':' the underlying zmq_decoder->get_buffer() call sets how much is needed.','line_number':582,'multiline':False]
['text':' broken NORM stream, so re-sync','line_number':585,'multiline':False]
['text':' TBD - check result','line_number':586,'multiline':False]
['text':' This will retry syncing, and getting data from this stream','line_number':587,'multiline':False]
['text':' since we don't increment the "it" iterator','line_number':588,'multiline':False]
['text':' All the data available has been read','line_number':593,'multiline':False]
['text':' Need to wait for NORM_RX_OBJECT_UPDATED for this stream','line_number':594,'multiline':False]
['text':' Move from rx_ready_list to rx_pending_list','line_number':596,'multiline':False]
['text':' end while(NULL != (rxState = iterator.GetNextItem()))','line_number':600,'multiline':False]
['text':' At this point, we've made a pass through the "rx_ready" stream list','line_number':603,'multiline':False]
['text':' Now make a pass through the "msg_pending" list (if the zmq session','line_number':604,'multiline':False]
['text':' ready for more input).  This may possibly return streams back to','line_number':605,'multiline':False]
['text':' the "rx ready" stream list after their pending message is handled','line_number':606,'multiline':False]
['text':' need to wait until session calls "restart_input()"','line_number':614,'multiline':False]
['text':' session rejected message?','line_number':618,'multiline':False]
['text':' TBD - handle this better','line_number':619,'multiline':False]
['text':' else message was accepted.','line_number':623,'multiline':False]
['text':' Move back to "rx_ready" list to read more data','line_number':627,'multiline':False]
['text':' Move back to "rx_pending" list until NORM_RX_OBJECT_UPDATED','line_number':629,'multiline':False]
['text':' end while(NULL != (rxState = iterator.GetNextItem()))','line_number':631,'multiline':False]
['text':' end if (zmq_input_ready)','line_number':632,'multiline':False]
['text':' end while ((!rx_ready_list.empty() || (zmq_input_ready && !msg_ready_list.empty()))','line_number':633,'multiline':False]
['text':' Alert zmq of the messages we have pushed up','line_number':635,'multiline':False]
['text':' end zmq::norm_engine_t::recv_data()','line_number':638,'multiline':False]
['text':' end zmq::norm_engine_t::NormRxStreamState::Init()','line_number':691,'multiline':False]
['text':' This decodes any pending data sitting in our stream decoder buffer','line_number':693,'multiline':False]
['text':' It returns 1 upon message completion, -1 on error, 1 on msg completion','line_number':694,'multiline':False]
['text':' If we have pending bytes to decode, process those first','line_number':697,'multiline':False]
['text':' There's pending data for the decoder to decode','line_number':699,'multiline':False]
['text':' This a bit of a kludgy approach used to weed','line_number':702,'multiline':False]
['text':' out the NORM ZMQ message transport "syncFlag" byte','line_number':703,'multiline':False]
['text':' from the ZMQ message stream being decoded (but it works!)','line_number':704,'multiline':False]
['text':' msg completed','line_number':716,'multiline':False]
['text':' decoder error (reset decoder and state variables)','line_number':724,'multiline':False]
['text':' will get consumed by norm sync check','line_number':726,'multiline':False]
['text':' need more data, keep decoding until buffer exhausted','line_number':731,'multiline':False]
['text':' Reset buffer pointer/count for next read','line_number':735,'multiline':False]
['text':'  need more data','line_number':739,'multiline':False]
['text':' end zmq::norm_engine_t::NormRxStreamState::Decode()','line_number':741,'multiline':False]
['text':' end zmq::norm_engine_t::NormRxStreamState::List::Destroy()','line_number':760,'multiline':False]
['text':' end zmq::norm_engine_t::NormRxStreamState::List::Append()','line_number':773,'multiline':False]
['text':' end zmq::norm_engine_t::NormRxStreamState::List::Remove()','line_number':788,'multiline':False]
['text':' end zmq::norm_engine_t::NormRxStreamState::List::Iterator::GetNextItem()','line_number':803,'multiline':False]
['text':' wait for norm event or message','line_number':823,'multiline':False]
['text':' Check if norm event','line_number':828,'multiline':False]
['text':' Process norm event','line_number':830,'multiline':False]
['text':' Check if message','line_number':840,'multiline':False]
['text':' Exit if WM_QUIT is received otherwise do nothing','line_number':842,'multiline':False]
['text':' do nothing','line_number':848,'multiline':False]
['text':' Otherwise an error occurred','line_number':850,'multiline':False]
['text':' Free resources','line_number':856,'multiline':False]
['text':' ZMQ_HAVE_NORM','line_number':866,'multiline':False]
