['text':' SPDX-License-Identifier: MPL-2.0 ','line_number':3,'multiline':True]
['text':' Internal helper functions that are not intended to be directly called from','line_number':11,'multiline':False]
['text':' tests. They must be declared in the header since they are used by macros.','line_number':12,'multiline':False]
['text':'///////////////////////////////////////////////////////////////////////////','line_number':30,'multiline':False]
['text':' Macros extending Unity's TEST_ASSERT_* macros in a similar fashion.','line_number':31,'multiline':False]
['text':'///////////////////////////////////////////////////////////////////////////','line_number':32,'multiline':False]
['text':' For TEST_ASSERT_SUCCESS_ERRNO, TEST_ASSERT_SUCCESS_MESSAGE_ERRNO and','line_number':34,'multiline':False]
['text':' TEST_ASSERT_FAILURE_ERRNO, 'expr' must be an expression evaluating','line_number':35,'multiline':False]
['text':' to a result in the style of a libzmq API function, i.e. an integer which','line_number':36,'multiline':False]
['text':' is non-negative in case of success, and -1 in case of a failure, and sets','line_number':37,'multiline':False]
['text':' the value returned by zmq_errno () to the error code.','line_number':38,'multiline':False]
['text':' TEST_ASSERT_SUCCESS_RAW_ERRNO and TEST_ASSERT_FAILURE_RAW_ERRNO are similar,','line_number':39,'multiline':False]
['text':' but used with the native socket API functions, and expect that the error','line_number':40,'multiline':False]
['text':' code can be retrieved in the native way (i.e. WSAGetLastError on Windows,','line_number':41,'multiline':False]
['text':' and errno otherwise).','line_number':42,'multiline':False]
['text':' Asserts that the libzmq API 'expr' is successful. In case of a failure, the','line_number':44,'multiline':False]
['text':' assertion message includes the literal 'expr', the error number as','line_number':45,'multiline':False]
['text':' determined by zmq_errno(), and the additional 'msg'.','line_number':46,'multiline':False]
['text':' In case of success, the result of the macro is the result of 'expr'.','line_number':47,'multiline':False]
['text':' Asserts that the libzmq API 'expr' is successful. In case of a failure, the','line_number':51,'multiline':False]
['text':' assertion message includes the literal 'expr' and the error code.','line_number':52,'multiline':False]
['text':' A typical use would be:','line_number':53,'multiline':False]
['text':'   TEST_ASSERT_SUCCESS_ERRNO (zmq_connect (socket, endpoint));','line_number':54,'multiline':False]
['text':' In case of success, the result of the macro is the result of 'expr'.','line_number':55,'multiline':False]
['text':'','line_number':56,'multiline':False]
['text':' If an additional message should be displayed in case of a failure, use','line_number':57,'multiline':False]
['text':' TEST_ASSERT_SUCCESS_MESSAGE_ERRNO.','line_number':58,'multiline':False]
['text':' Asserts that the socket API 'expr' is successful. In case of a failure, the','line_number':62,'multiline':False]
['text':' assertion message includes the literal 'expr' and the error code.','line_number':63,'multiline':False]
['text':' A typical use would be:','line_number':64,'multiline':False]
['text':'   TEST_ASSERT_SUCCESS_RAW_ERRNO (send (fd, buffer, 64, 0));','line_number':65,'multiline':False]
['text':' In case of success, the result of the macro is the result of 'expr'.','line_number':66,'multiline':False]
['text':' Success is strictly defined by a return value different from -1, as opposed','line_number':67,'multiline':False]
['text':' to checking that it is 0, like TEST_ASSERT_FAILURE_RAW_ZERO_ERRNO does.','line_number':68,'multiline':False]
['text':' Asserts that the socket API 'expr' is successful. In case of a failure, the','line_number':72,'multiline':False]
['text':' assertion message includes the literal 'expr' and the error code.','line_number':73,'multiline':False]
['text':' A typical use would be:','line_number':74,'multiline':False]
['text':'   TEST_ASSERT_SUCCESS_RAW_ZERO_ERRNO (send (fd, buffer, 64, 0));','line_number':75,'multiline':False]
['text':' In case of success, the result of the macro is the result of 'expr'.','line_number':76,'multiline':False]
['text':' Success is strictly defined by a return value of 0, as opposed to checking','line_number':77,'multiline':False]
['text':' that it is not -1, like TEST_ASSERT_FAILURE_RAW_ERRNO does.','line_number':78,'multiline':False]
['text':' Asserts that the socket API 'expr' is not successful, and the error code is','line_number':83,'multiline':False]
['text':' 'error_code'. In case of an unexpected succces, or a failure with an','line_number':84,'multiline':False]
['text':' unexpected error code, the assertion message includes the literal 'expr'','line_number':85,'multiline':False]
['text':' and, in case of a failure, the actual error code.','line_number':86,'multiline':False]
['text':' Asserts that the libzmq API 'expr' is not successful, and the error code is','line_number':91,'multiline':False]
['text':' 'error_code'. In case of an unexpected succces, or a failure with an','line_number':92,'multiline':False]
['text':' unexpected error code, the assertion message includes the literal 'expr'','line_number':93,'multiline':False]
['text':' and, in case of a failure, the actual error code.','line_number':94,'multiline':False]
['text':'///////////////////////////////////////////////////////////////////////////','line_number':102,'multiline':False]
['text':' Utility functions for testing sending and receiving.','line_number':103,'multiline':False]
['text':'///////////////////////////////////////////////////////////////////////////','line_number':104,'multiline':False]
['text':' Sends a string via a libzmq socket, and expects the operation to be','line_number':106,'multiline':False]
['text':' successful (the meaning of which depends on the socket type and configured','line_number':107,'multiline':False]
['text':' options, and might include dropping the message). Otherwise, a Unity test','line_number':108,'multiline':False]
['text':' assertion is triggered.','line_number':109,'multiline':False]
['text':' 'socket_' must be the libzmq socket to use for sending.','line_number':110,'multiline':False]
['text':' 'str_' must be a 0-terminated string.','line_number':111,'multiline':False]
['text':' 'flags_' are as documented by the zmq_send function.','line_number':112,'multiline':False]
['text':' Receives a message via a libzmq socket, and expects the operation to be','line_number':115,'multiline':False]
['text':' successful, and the message to be a given string. Otherwise, a Unity test','line_number':116,'multiline':False]
['text':' assertion is triggered.','line_number':117,'multiline':False]
['text':' 'socket_' must be the libzmq socket to use for receiving.','line_number':118,'multiline':False]
['text':' 'str_' must be a 0-terminated string.','line_number':119,'multiline':False]
['text':' 'flags_' are as documented by the zmq_recv function.','line_number':120,'multiline':False]
['text':' Sends a byte array via a libzmq socket, and expects the operation to be','line_number':123,'multiline':False]
['text':' successful (the meaning of which depends on the socket type and configured','line_number':124,'multiline':False]
['text':' options, and might include dropping the message). Otherwise, a Unity test','line_number':125,'multiline':False]
['text':' assertion is triggered.','line_number':126,'multiline':False]
['text':' 'socket_' must be the libzmq socket to use for sending.','line_number':127,'multiline':False]
['text':' 'array_' must be a C uint8_t array. The array size is automatically','line_number':128,'multiline':False]
['text':' determined via template argument deduction.','line_number':129,'multiline':False]
['text':' 'flags_' are as documented by the zmq_send function.','line_number':130,'multiline':False]
['text':' Receives a message via a libzmq socket, and expects the operation to be','line_number':140,'multiline':False]
['text':' successful, and the message to be a given byte array. Otherwise, a Unity','line_number':141,'multiline':False]
['text':' test assertion is triggered.','line_number':142,'multiline':False]
['text':' 'socket_' must be the libzmq socket to use for receiving.','line_number':143,'multiline':False]
['text':' 'array_' must be a C uint8_t array. The array size is automatically','line_number':144,'multiline':False]
['text':' determined via template argument deduction.','line_number':145,'multiline':False]
['text':' 'flags_' are as documented by the zmq_recv function.','line_number':146,'multiline':False]
['text':'///////////////////////////////////////////////////////////////////////////','line_number':164,'multiline':False]
['text':' Utility function for handling a test libzmq context, that is set up and','line_number':165,'multiline':False]
['text':' torn down for each Unity test case, such that a clean context is available','line_number':166,'multiline':False]
['text':' for each test case, and some consistency checks can be performed.','line_number':167,'multiline':False]
['text':'///////////////////////////////////////////////////////////////////////////','line_number':168,'multiline':False]
['text':' Use this is an test executable to perform a default setup and teardown of','line_number':170,'multiline':False]
['text':' the test context, which is appropriate for many libzmq test cases.','line_number':171,'multiline':False]
['text':' The maximum number of sockets that can be managed by the test context.','line_number':182,'multiline':False]
['text':' Expected to be called during Unity's setUp function.','line_number':185,'multiline':False]
['text':' Returns the test context, e.g. to create sockets in another thread using','line_number':188,'multiline':False]
['text':' zmq_socket, or set context options.','line_number':189,'multiline':False]
['text':' Expected to be called during Unity's tearDown function. Checks that all','line_number':192,'multiline':False]
['text':' sockets created via test_context_socket have been properly closed using','line_number':193,'multiline':False]
['text':' test_context_socket_close or test_context_socket_close_zero_linger, and generates a warning otherwise.','line_number':194,'multiline':False]
['text':' Creates a libzmq socket on the test context, and tracks its lifecycle.','line_number':197,'multiline':False]
['text':' You MUST use test_context_socket_close or test_context_socket_close_zero_linger','line_number':198,'multiline':False]
['text':' to close a socket created via this function, otherwise undefined behaviour','line_number':199,'multiline':False]
['text':' will result.','line_number':200,'multiline':False]
['text':' CAUTION: this function is not thread-safe, and may only be used from the','line_number':201,'multiline':False]
['text':' main thread.','line_number':202,'multiline':False]
['text':' Closes a socket created via test_context_socket.','line_number':205,'multiline':False]
['text':' CAUTION: this function is not thread-safe, and may only be used from the','line_number':206,'multiline':False]
['text':' main thread.','line_number':207,'multiline':False]
['text':' Closes a socket created via test_context_socket after setting its linger','line_number':210,'multiline':False]
['text':' timeout to 0.','line_number':211,'multiline':False]
['text':' CAUTION: this function is not thread-safe, and may only be used from the','line_number':212,'multiline':False]
['text':' main thread.','line_number':213,'multiline':False]
['text':'///////////////////////////////////////////////////////////////////////////','line_number':216,'multiline':False]
['text':' Utility function for handling wildcard binds.','line_number':217,'multiline':False]
['text':'///////////////////////////////////////////////////////////////////////////','line_number':218,'multiline':False]
['text':' All function binds a socket to some wildcard address, and retrieve the bound','line_number':220,'multiline':False]
['text':' endpoint via the ZMQ_LAST_ENDPOINT socket option to a given buffer.','line_number':221,'multiline':False]
['text':' Triggers a Unity test assertion in case of a failure (including the buffer','line_number':222,'multiline':False]
['text':' being too small for the resulting endpoint string).','line_number':223,'multiline':False]
['text':' Binds to an explicitly given (wildcard) address.','line_number':225,'multiline':False]
['text':' TODO redesign such that this function is not necessary to be exposed, but','line_number':226,'multiline':False]
['text':' the protocol to use is rather specified via an enum value','line_number':227,'multiline':False]
['text':' Binds to a tcp endpoint using the ipv4 or ipv6 loopback wildcard address.','line_number':233,'multiline':False]
['text':' Binds to a tcp endpoint using the ipv4 loopback wildcard address.','line_number':240,'multiline':False]
['text':' Binds to a tcp endpoint using the ipv6 loopback wildcard address.','line_number':243,'multiline':False]
['text':' Binds to an ipc endpoint using the ipc wildcard address.','line_number':246,'multiline':False]
['text':' Note that the returned address cannot be reused to bind a second socket.','line_number':247,'multiline':False]
['text':' If you need to do this, use make_random_ipc_endpoint instead.','line_number':248,'multiline':False]
['text':' Binds to an ipc endpoint using the tipc wildcard address.','line_number':251,'multiline':False]
['text':' utility function to create a random IPC endpoint, similar to what a ipc://*','line_number':255,'multiline':False]
['text':' wildcard binding does, but in a way it can be reused for multiple binds','line_number':256,'multiline':False]
['text':' TODO also add a len parameter here','line_number':257,'multiline':False]
