['text':' Copyright 2016 The Bazel Authors. All Rights Reserved.','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' Licensed under the Apache License, Version 2.0 (the "License");','line_number':3,'multiline':False]['text':' you may not use this file except in compliance with the License.','line_number':4,'multiline':False]['text':' You may obtain a copy of the License at','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'    http://www.apache.org/licenses/LICENSE-2.0','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':' Unless required by applicable law or agreed to in writing, software','line_number':9,'multiline':False]['text':' distributed under the License is distributed on an "AS IS" BASIS,','line_number':10,'multiline':False]['text':' WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.','line_number':11,'multiline':False]['text':' See the License for the specific language governing permissions and','line_number':12,'multiline':False]['text':' limitations under the License.','line_number':13,'multiline':False]['text':'*
 * The mapper is a probes visitor that will cache control flow information as well as keeping track
 * of the probes as the main driver generates the probe ids. Upon finishing the method it uses the
 * information collected to generate the mapping information between probes and the instructions.
 ','line_number':39,'multiline':True]['text':'
   * The implementation roughly follows the same pattern of the Analyzer class of Jacoco.
   *
   * The mapper has a few states:
   *
   * - lineMappings: a mapping between line number and labels
   *
   * - a sequence of "instructions", where each instruction has one or more predecessors. The
   * predecessor field has a sole purpose of propagating probe id. The 'merge' nodes in the CFG has
   * no predecessors, since the branch stops at theses points.
   *
   * - The instructions each has states that keep track of the probes that are associated with the
   * instruction.
   *
   * Initially the probe ids are assigned to the instructions that immediately precede the probe. At
   * the end of visiting the methods, the probe ids are propagated through the predecessor chains.
   ','line_number':45,'multiline':True]['text':' States','line_number':63,'multiline':False]['text':'','line_number':64,'multiline':False]['text':' These are state variables that needs to be updated in the visitor methods.','line_number':65,'multiline':False]['text':' The values usually changes as we traverse the byte code.','line_number':66,'multiline':False]['text':' Filtering','line_number':75,'multiline':False]['text':' Result','line_number':82,'multiline':False]['text':' Intermediate results','line_number':88,'multiline':False]['text':'','line_number':89,'multiline':False]['text':' These values are built up during the visitor methods. They will be used to compute','line_number':90,'multiline':False]['text':' the final results.','line_number':91,'multiline':False]['text':' A map which associates intructions with their coverage expressions.','line_number':96,'multiline':False]['text':' A map which associates a instruction to the branch index in its predecessor','line_number':99,'multiline':False]['text':' e.g., the instruction that follows a conditional jump instruction must exists in','line_number':100,'multiline':False]['text':' this map.','line_number':101,'multiline':False]['text':' Local cache','line_number':104,'multiline':False]['text':'','line_number':105,'multiline':False]['text':' These are maps corresponding to data structures available in JaCoCo in other form.','line_number':106,'multiline':False]['text':' We use local data structure to avoid need to change the JaCoCo internal code.','line_number':107,'multiline':False]['text':'* Visitor method to append a new Instruction ','line_number':127,'multiline':True]['text':' the first branch from last instruction','line_number':132,'multiline':False]['text':' Update local cache','line_number':133,'multiline':False]['text':' Update states','line_number':139,'multiline':False]['text':' Plain visitors: called from adapter when no probe is needed','line_number':146,'multiline':False]['text':' Methods that need to update the states','line_number':198,'multiline':False]['text':'* Visit a switch instruction with no probes ','line_number':218,'multiline':True]['text':' Handle default transition','line_number':222,'multiline':False]['text':' Handle other transitions','line_number':228,'multiline':False]['text':' We do not add probes to the flow graph, but we need to update','line_number':249,'multiline':False]['text':' the branch count of the predecessor of the probe','line_number':250,'multiline':False]['text':' Probe visit methods','line_number':255,'multiline':False]['text':' This function is only called when visiting a merge node which','line_number':258,'multiline':False]['text':' is a successor.','line_number':259,'multiline':False]['text':' It adds an probe point to the last instruction','line_number':260,'multiline':False]['text':' Merge point should have no predecessor.','line_number':264,'multiline':False]['text':' Note, in this case the instrumenter should insert intermediate labels','line_number':308,'multiline':False]['text':' for the probes. These probes will be added for the switch instruction.','line_number':309,'multiline':False]['text':'','line_number':310,'multiline':False]['text':' There is no direct jump between lastInstruction and the label either.','line_number':311,'multiline':False]['text':' If a CovExp of pred is ProbeExp, create a single-branch BranchExp and put it in the map.','line_number':318,'multiline':False]['text':' Also update the index of insn.','line_number':319,'multiline':False]['text':' Change ProbeExp to BranchExp','line_number':324,'multiline':False]['text':' This can only happen if the internal data of Jacoco is inconsistent:','line_number':326,'multiline':False]['text':' the instruction is the predecessor of more than one instructions,','line_number':327,'multiline':False]['text':' but its branch count is not > 1.','line_number':328,'multiline':False]['text':' Update a branch predecessor and returns whether the BranchExp of the predecessor is new.','line_number':335,'multiline':False]['text':' current insn is the first branch','line_number':341,'multiline':False]['text':' Keep track of the instructions in the branches that are already added','line_number':348,'multiline':False]['text':' If the branch where the instruction is on is already added, no need to do anything as','line_number':352,'multiline':False]['text':' branchExp has a reference to exp already.','line_number':353,'multiline':False]['text':'* Finishing the method ','line_number':357,'multiline':True]['text':' Compute CovExp for every instruction.','line_number':366,'multiline':False]['text':' Compute CovExp for the probed instruction.','line_number':374,'multiline':False]['text':' The instruction already has a branch, add the probeExp as','line_number':377,'multiline':False]['text':' a new branch.','line_number':378,'multiline':False]['text':' This can only happen if the internal data is inconsistent.','line_number':383,'multiline':False]['text':' The instruction is a predecessor of another instruction and also','line_number':384,'multiline':False]['text':' has a probe, but the branch count is not > 1.','line_number':385,'multiline':False]['text':' If the branch already exists, no need to visit predecessors any more.','line_number':399,'multiline':False]['text':' No branch at predecessor, use the same CovExp','line_number':403,'multiline':False]['text':' Handle merged instructions','line_number':412,'multiline':False]['text':' Handle branch replacements','line_number':423,'multiline':False]['text':' The replacement set is not ordered deterministically and we require it to be so to be able','line_number':425,'multiline':False]['text':' to merge multiple coverage reports later on. We use the order in which we encountered','line_number':426,'multiline':False]['text':' nodes to determine the order of branches for the new BranchExp','line_number':427,'multiline':False]['text':' Merging of coverage reports down the line only makes sense now if replacements is iterated','line_number':431,'multiline':False]['text':' in a deterministic order, which is a false assumption.','line_number':432,'multiline':False]['text':' Merge branches in the instructions on the same line','line_number':446,'multiline':False]['text':' If we reach here, the internal data of the mapping is inconsistent, either','line_number':462,'multiline':False]['text':' 1) An instruction has branches but we do not create BranchExp for it.','line_number':463,'multiline':False]['text':' 2) An instruction has branches but it does not have an associated CovExp.','line_number':464,'multiline':False]['text':'* IFilterOutput ','line_number':470,'multiline':True]['text':' Handle only ignore for now; most filters only use this.','line_number':471,'multiline':False]['text':' Track nodes to be merged using a union-find algorithm.','line_number':482,'multiline':False]['text':' The "find" part of union-find. Walk the chain of nodes to find the representative node','line_number':496,'multiline':False]['text':' (at the root), flattening the tree a little as we go.','line_number':497,'multiline':False]['text':'* Jumps between instructions and labels ','line_number':509,'multiline':True]