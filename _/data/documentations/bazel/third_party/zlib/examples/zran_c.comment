['text':' zran.c -- example of deflate stream indexing and random access
 * Copyright (C) 2005, 2012, 2018, 2023 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 * Version 1.4  13 Apr 2023  Mark Adler ','line_number':1,'multiline':True]['text':' Version History:
 1.0  29 May 2005  First version
 1.1  29 Sep 2012  Fix memory reallocation error
 1.2  14 Oct 2018  Handle gzip streams with multiple members
                   Add a header file to facilitate usage in applications
 1.3  18 Feb 2023  Permit raw deflate streams as well as zlib and gzip
                   Permit crossing gzip member boundaries when extracting
                   Support a size_t size when extracting (was an int)
                   Do a binary search over the index for an access point
                   Expose the access point type to enable save and load
 1.4  13 Apr 2023  Add a NOPRIME define to not use inflatePrime()
 ','line_number':6,'multiline':True]['text':' Illustrate the use of Z_BLOCK, inflatePrime(), and inflateSetDictionary()','line_number':19,'multiline':False]['text':' for random access of a compressed file. A file containing a raw deflate','line_number':20,'multiline':False]['text':' stream is provided on the command line. The compressed stream is decoded in','line_number':21,'multiline':False]['text':' its entirety, and an index built with access points about every SPAN bytes','line_number':22,'multiline':False]['text':' in the uncompressed output. The compressed file is left open, and can then','line_number':23,'multiline':False]['text':' be read randomly, having to decompress on the average SPAN/2 uncompressed','line_number':24,'multiline':False]['text':' bytes before getting to the desired block of data.','line_number':25,'multiline':False]['text':'','line_number':26,'multiline':False]['text':' An access point can be created at the start of any deflate block, by saving','line_number':27,'multiline':False]['text':' the starting file offset and bit of that block, and the 32K bytes of','line_number':28,'multiline':False]['text':' uncompressed data that precede that block. Also the uncompressed offset of','line_number':29,'multiline':False]['text':' that block is saved to provide a reference for locating a desired starting','line_number':30,'multiline':False]['text':' point in the uncompressed stream. deflate_index_build() decompresses the','line_number':31,'multiline':False]['text':' input raw deflate stream a block at a time, and at the end of each block','line_number':32,'multiline':False]['text':' decides if enough uncompressed data has gone by to justify the creation of a','line_number':33,'multiline':False]['text':' new access point. If so, that point is saved in a data structure that grows','line_number':34,'multiline':False]['text':' as needed to accommodate the points.','line_number':35,'multiline':False]['text':'','line_number':36,'multiline':False]['text':' To use the index, an offset in the uncompressed data is provided, for which','line_number':37,'multiline':False]['text':' the latest access point at or preceding that offset is located in the index.','line_number':38,'multiline':False]['text':' The input file is positioned to the specified location in the index, and if','line_number':39,'multiline':False]['text':' necessary the first few bits of the compressed data is read from the file.','line_number':40,'multiline':False]['text':' inflate is initialized with those bits and the 32K of uncompressed data, and','line_number':41,'multiline':False]['text':' decompression then proceeds until the desired offset in the file is reached.','line_number':42,'multiline':False]['text':' Then decompression continues to read the requested uncompressed data from','line_number':43,'multiline':False]['text':' the file.','line_number':44,'multiline':False]['text':'','line_number':45,'multiline':False]['text':' There is some fair bit of overhead to starting inflation for the random','line_number':46,'multiline':False]['text':' access, mainly copying the 32K byte dictionary. If small pieces of the file','line_number':47,'multiline':False]['text':' are being accessed, it would make sense to implement a cache to hold some','line_number':48,'multiline':False]['text':' lookahead to avoid many calls to deflate_index_extract() for small lengths.','line_number':49,'multiline':False]['text':'','line_number':50,'multiline':False]['text':' Another way to build an index would be to use inflateCopy(). That would not','line_number':51,'multiline':False]['text':' be constrained to have access points at block boundaries, but would require','line_number':52,'multiline':False]['text':' more memory per access point, and could not be saved to a file due to the','line_number':53,'multiline':False]['text':' use of pointers in the state. The approach here allows for storage of the','line_number':54,'multiline':False]['text':' index in a file.','line_number':55,'multiline':False]['text':' sliding window size','line_number':64,'multiline':False]['text':' file input buffer size','line_number':65,'multiline':False]['text':' See comments in zran.h.','line_number':67,'multiline':False]['text':' Add an access point to the list. If out of memory, deallocate the existing','line_number':75,'multiline':False]['text':' list and return NULL. index->mode is temporarily the allocated number of','line_number':76,'multiline':False]['text':' access points, until it is time for deflate_index_build() to return. Then','line_number':77,'multiline':False]['text':' index->mode is set to the mode of inflation.','line_number':78,'multiline':False]['text':' The list is empty. Create it, starting with eight access points.','line_number':83,'multiline':False]['text':' The list is full. Make it bigger.','line_number':97,'multiline':False]['text':' Fill in the access point and increment how many we have.','line_number':107,'multiline':False]['text':' Overflowed the int!','line_number':110,'multiline':False]['text':' Return the index, which may have been newly allocated or destroyed.','line_number':122,'multiline':False]['text':' Decompression modes. These are the inflateInit2() windowBits parameter.','line_number':126,'multiline':False]['text':' See comments in zran.h.','line_number':131,'multiline':False]['text':' Set up inflation state.','line_number':133,'multiline':False]['text':' inflate engine (gets fired up later)','line_number':134,'multiline':False]['text':' input buffer','line_number':135,'multiline':False]['text':' output sliding window','line_number':136,'multiline':False]['text':' total bytes read from input','line_number':137,'multiline':False]['text':' total bytes uncompressed','line_number':138,'multiline':False]['text':' mode: RAW, ZLIB, or GZIP (0 => not set yet)','line_number':139,'multiline':False]['text':' Decompress from in, generating access points along the way.','line_number':141,'multiline':False]['text':' the return value from zlib, or Z_ERRNO','line_number':142,'multiline':False]['text':' last access point uncompressed offset','line_number':143,'multiline':False]['text':' list of access points','line_number':144,'multiline':False]['text':' Assure available input, at least until reaching EOF.','line_number':146,'multiline':False]['text':' At the start of the input -- determine the type. Assume raw','line_number':157,'multiline':False]['text':' if it is neither zlib nor gzip. This could in theory result','line_number':158,'multiline':False]['text':' in a false positive for zlib, but in practice the fill bits','line_number':159,'multiline':False]['text':' after a stored block are always zeros, so a raw stream won't','line_number':160,'multiline':False]['text':' start with an 8 in the low nybble.','line_number':161,'multiline':False]['text':' empty -- will fail','line_number':162,'multiline':False]['text':' else ','line_number':165,'multiline':True]['text':' Assure available output. This rotates the output through, for use as','line_number':172,'multiline':False]['text':' a sliding window on the uncompressed data.','line_number':173,'multiline':False]['text':' We skip the inflate() call at the start of raw deflate data in','line_number':180,'multiline':False]['text':' order generate an access point there. Set data_type to imitate','line_number':181,'multiline':False]['text':' the end of a header.','line_number':182,'multiline':False]['text':' Inflate and update the number of uncompressed bytes.','line_number':185,'multiline':False]['text':' We are at the end of a header or a non-last deflate block, so we','line_number':193,'multiline':False]['text':' can add an access point here. Furthermore, we are either at the','line_number':194,'multiline':False]['text':' very start for the first access point, or there has been span or','line_number':195,'multiline':False]['text':' more uncompressed bytes since the last access point, so we want','line_number':196,'multiline':False]['text':' to add an access point here.','line_number':197,'multiline':False]['text':' There is more input after the end of a gzip member. Reset the','line_number':209,'multiline':False]['text':' inflate state to read another gzip member. On success, this will','line_number':210,'multiline':False]['text':' set ret to Z_OK to continue decompressing.','line_number':211,'multiline':False]['text':' Keep going until Z_STREAM_END or error. If the compressed data ends','line_number':214,'multiline':False]['text':' prematurely without a file read error, Z_BUF_ERROR is returned.','line_number':215,'multiline':False]['text':' An error was encountered. Discard the index and return a negative','line_number':220,'multiline':False]['text':' error code.','line_number':221,'multiline':False]['text':' Shrink the index to only the occupied access points and return it.','line_number':226,'multiline':False]['text':' Seems like a realloc() to make something smaller should always work,','line_number':231,'multiline':False]['text':' but just in case.','line_number':232,'multiline':False]['text':' Support zlib versions before 1.2.3 (July 2005), or incomplete zlib clones','line_number':242,'multiline':False]['text':' that do not have inflatePrime().','line_number':243,'multiline':False]['text':' Append the low bits bits of value to in[] at bit position *have, updating','line_number':247,'multiline':False]['text':' *have. value must be zero above its low bits bits. bits must be positive.','line_number':248,'multiline':False]['text':' This assumes that any bits above the *have bits in the last byte are zeros.','line_number':249,'multiline':False]['text':' That assumption is preserved on return, as any bits above *have + bits in','line_number':250,'multiline':False]['text':' the last byte written will be set to zeros.','line_number':251,'multiline':False]['text':' where the first bits from value will go','line_number':254,'multiline':False]['text':' the number of bits already there','line_number':255,'multiline':False]['text':' write value above the low k bits','line_number':258,'multiline':False]['text':' the number of bits just appended','line_number':261,'multiline':False]['text':' drop the bits appended','line_number':263,'multiline':False]['text':' now at a byte boundary','line_number':265,'multiline':False]['text':' Insert enough bits in the form of empty deflate blocks in front of the the','line_number':270,'multiline':False]['text':' low bits bits of value, in order to bring the sequence to a byte boundary.','line_number':271,'multiline':False]['text':' Then feed that to inflate(). This does what inflatePrime() does, except that','line_number':272,'multiline':False]['text':' a negative value of bits is not supported. bits must be in 0..16. If the','line_number':273,'multiline':False]['text':' arguments are invalid, Z_STREAM_ERROR is returned. Otherwise the return','line_number':274,'multiline':False]['text':' value from inflate() is returned.','line_number':275,'multiline':False]['text':' Check input.','line_number':277,'multiline':False]['text':' An empty dynamic block with an odd number of bits (95). The high bit of','line_number':284,'multiline':False]['text':' the last byte is unused.','line_number':285,'multiline':False]['text':' number of bits in the block','line_number':289,'multiline':False]['text':' Build an input buffer for inflate that is a multiple of eight bits in','line_number':291,'multiline':False]['text':' length, and that ends with the low bits bits of value.','line_number':292,'multiline':False]['text':' Insert an empty dynamic block to get to an odd number of bits, so','line_number':296,'multiline':False]['text':' when bits bits from value are appended, we are at an even number of','line_number':297,'multiline':False]['text':' bits.','line_number':298,'multiline':False]['text':' Insert empty fixed blocks until appending bits bits would put us on','line_number':303,'multiline':False]['text':' a byte boundary. This will insert at most three fixed blocks.','line_number':304,'multiline':False]['text':' Append the bits bits from value, which takes us to a byte boundary.','line_number':307,'multiline':False]['text':' Deliver the input to inflate(). There is no output space provided, but','line_number':310,'multiline':False]['text':' inflate() can't get stuck waiting on output not ingesting all of the','line_number':311,'multiline':False]['text':' provided input. The reason is that there will be at most 16 bits of','line_number':312,'multiline':False]['text':' input from value after the empty deflate blocks (which themselves','line_number':313,'multiline':False]['text':' generate no output). At least ten bits are needed to generate the first','line_number':314,'multiline':False]['text':' output byte from a fixed block. The last two bytes of the buffer have to','line_number':315,'multiline':False]['text':' be ingested in order to get ten bits, which is the most that value can','line_number':316,'multiline':False]['text':' occupy.','line_number':317,'multiline':False]['text':' not used, but can't be NULL','line_number':321,'multiline':False]['text':' See comments in zran.h.','line_number':329,'multiline':False]['text':' Do a quick sanity check on the index.','line_number':332,'multiline':False]['text':' If nothing to extract, return zero bytes extracted.','line_number':336,'multiline':False]['text':' Find the access point closest to but not after offset.','line_number':340,'multiline':False]['text':' Initialize the input file and prime the inflate engine to start there.','line_number':352,'multiline':False]['text':' Skip uncompressed bytes until offset reached, then satisfy request.','line_number':367,'multiline':False]['text':' number of bytes to skip to get to offset','line_number':370,'multiline':False]['text':' number of bytes left to read after offset','line_number':371,'multiline':False]['text':' Discard up to offset uncompressed bytes.','line_number':374,'multiline':False]['text':' Uncompress up to left bytes into buf.','line_number':379,'multiline':False]['text':' Uncompress, setting got to the number of bytes uncompressed.','line_number':384,'multiline':False]['text':' Assure available input.','line_number':386,'multiline':False]['text':' Update the appropriate count.','line_number':398,'multiline':False]['text':' If we're at the end of a gzip member and there's more to read,','line_number':404,'multiline':False]['text':' continue to the next gzip member.','line_number':405,'multiline':False]['text':' Discard the gzip trailer.','line_number':407,'multiline':False]['text':' length of gzip trailer','line_number':408,'multiline':False]['text':' Read and discard the remainder of the gzip trailer.','line_number':414,'multiline':False]['text':' The input does not have a complete trailer.','line_number':419,'multiline':False]['text':' There's more after the gzip trailer. Use inflate to skip the','line_number':425,'multiline':False]['text':' gzip header and resume the raw inflate there.','line_number':426,'multiline':False]['text':' stop at end of header','line_number':439,'multiline':False]['text':' Continue until we have the requested data, the deflate data has','line_number':447,'multiline':False]['text':' ended, or an error is encountered.','line_number':448,'multiline':False]['text':' Return the number of uncompressed bytes read into buf, or the error.','line_number':452,'multiline':False]['text':' desired distance between access points','line_number':458,'multiline':False]['text':' number of bytes to extract','line_number':459,'multiline':False]['text':' Demonstrate the use of deflate_index_build() and deflate_index_extract() by','line_number':461,'multiline':False]['text':' processing the file provided on the command line, and extracting LEN bytes','line_number':462,'multiline':False]['text':' from 2/3rds of the way through the uncompressed output, writing that to','line_number':463,'multiline':False]['text':' stdout. An offset can be provided as the second argument, in which case the','line_number':464,'multiline':False]['text':' data is extracted from there instead.','line_number':465,'multiline':False]['text':' Open the input file.','line_number':467,'multiline':False]['text':' Get optional offset.','line_number':478,'multiline':False]['text':' Build index.','line_number':489,'multiline':False]['text':' Use index by reading some bytes from an arbitrary offset.','line_number':514,'multiline':False]['text':' Clean up and exit.','line_number':527,'multiline':False]