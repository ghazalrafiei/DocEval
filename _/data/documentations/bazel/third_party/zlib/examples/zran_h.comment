['text':' zran.h -- example of deflated stream indexing and random access
 * Copyright (C) 2005, 2012, 2018, 2023 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 * Version 1.3  18 Feb 2023  Mark Adler ','line_number':1,'multiline':True]['text':' Access point.','line_number':9,'multiline':False]['text':' offset in uncompressed data','line_number':11,'multiline':False]['text':' offset in compressed file of first full byte','line_number':12,'multiline':False]['text':' 0, or number of bits (1-7) from byte at in-1','line_number':13,'multiline':False]['text':' preceding 32K of uncompressed data','line_number':14,'multiline':False]['text':' Access point list.','line_number':17,'multiline':False]['text':' number of access points in list','line_number':19,'multiline':False]['text':' -15 for raw, 15 for zlib, or 31 for gzip','line_number':20,'multiline':False]['text':' total length of uncompressed data','line_number':21,'multiline':False]['text':' allocated list of access points','line_number':22,'multiline':False]['text':' Make one pass through a zlib, gzip, or raw deflate compressed stream and','line_number':25,'multiline':False]['text':' build an index, with access points about every span bytes of uncompressed','line_number':26,'multiline':False]['text':' output. gzip files with multiple members are fully indexed. span should be','line_number':27,'multiline':False]['text':' chosen to balance the speed of random access against the memory requirements','line_number':28,'multiline':False]['text':' of the list, which is about 32K bytes per access point. The return value is','line_number':29,'multiline':False]['text':' the number of access points on success (>= 1), Z_MEM_ERROR for out of','line_number':30,'multiline':False]['text':' memory, Z_BUF_ERROR for a premature end of input, Z_DATA_ERROR for a format','line_number':31,'multiline':False]['text':' or verification error in the input file, or Z_ERRNO for a file read error.','line_number':32,'multiline':False]['text':' On success, *built points to the resulting index.','line_number':33,'multiline':False]['text':' Use the index to read len bytes from offset into buf. Return the number of','line_number':36,'multiline':False]['text':' bytes read or a negative error code. If data is requested past the end of','line_number':37,'multiline':False]['text':' the uncompressed data, then deflate_index_extract() will return a value less','line_number':38,'multiline':False]['text':' than len, indicating how much was actually read into buf. If given a valid','line_number':39,'multiline':False]['text':' index, this function should not return an error unless the file was modified','line_number':40,'multiline':False]['text':' somehow since the index was generated, given that deflate_index_build() had','line_number':41,'multiline':False]['text':' validated all of the input. If nevertheless there is a failure, Z_BUF_ERROR','line_number':42,'multiline':False]['text':' is returned if the compressed data ends prematurely, Z_DATA_ERROR if the','line_number':43,'multiline':False]['text':' deflate compressed data is not valid, Z_MEM_ERROR if out of memory,','line_number':44,'multiline':False]['text':' Z_STREAM_ERROR if the index is not valid, or Z_ERRNO if there is an error','line_number':45,'multiline':False]['text':' reading or seeking on the input file.','line_number':46,'multiline':False]['text':' Deallocate an index built by deflate_index_build().','line_number':50,'multiline':False]