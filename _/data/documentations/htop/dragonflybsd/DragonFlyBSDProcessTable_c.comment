['text':'
htop - DragonFlyBSDProcessTable.c
(C) 2014 Hisham H. Muhammad
(C) 2017 Diederik de Groot
Released under the GNU GPLv2+, see the COPYING file
in the source distribution for its full text.
','line_number':1,'multiline':True]['text':'static void DragonFlyBSDProcessTable_updateExe(const struct kinfo_proc* kproc, Process* proc) {','line_number':45,'multiline':False]['text':'   const int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, kproc->kp_pid };','line_number':46,'multiline':False]['text':'   char buffer[2048];','line_number':47,'multiline':False]['text':'   size_t size = sizeof(buffer);','line_number':48,'multiline':False]['text':'   if (sysctl(mib, 4, buffer, &size, NULL, 0) != 0) {','line_number':49,'multiline':False]['text':'      Process_updateExe(proc, NULL);','line_number':50,'multiline':False]['text':'      return;','line_number':51,'multiline':False]['text':'   }','line_number':52,'multiline':False]['text':'','line_number':53,'multiline':False]['text':'   /* Kernel threads return an empty buffer */','line_number':54,'multiline':False]['text':'   if (buffer[0] == '\0') {','line_number':55,'multiline':False]['text':'      Process_updateExe(proc, NULL);','line_number':56,'multiline':False]['text':'      return;','line_number':57,'multiline':False]['text':'   }','line_number':58,'multiline':False]['text':'','line_number':59,'multiline':False]['text':'   Process_updateExe(proc, buffer);','line_number':60,'multiline':False]['text':'}','line_number':61,'multiline':False]['text':' Kernel threads return an empty buffer ','line_number':89,'multiline':True]['text':' note: dragonflybsd kernel processes all have the same pid, so we misuse the kernel thread address to give them a unique identifier','line_number':149,'multiline':False]['text':' dfb kernel threads all have the same pid, so we misuse the kernel thread address to give them a unique identifier','line_number':156,'multiline':False]['text':' process ID','line_number':160,'multiline':False]['text':' parent process id','line_number':164,'multiline':False]['text':' tty process group id','line_number':165,'multiline':False]['text':'Process_setThreadGroup(proc, kproc->kp_lwp.kl_tid);	// thread group id','line_number':166,'multiline':False]['text':' process group id','line_number':168,'multiline':False]['text':' user ID','line_number':170,'multiline':False]['text':' control terminal device number','line_number':176,'multiline':False]['text':' process can enter jail anytime','line_number':197,'multiline':False]['text':' if there are reapers in the system, process can get reparented anytime','line_number':202,'multiline':False]['text':' some processes change users (eg. to lower privs)','line_number':204,'multiline':False]['text':' number of lwp thread','line_number':215,'multiline':False]['text':' system idle process should own all CPU time left regardless of CPU count','line_number':223,'multiline':False]['text':' would be nice if we could store multiple states in proc->state (as enum) and have writeField render them','line_number':249,'multiline':False]['text':' Taken from: https://github.com/DragonFlyBSD/DragonFlyBSD/blob/c163a4d7ee9c6857ee4e04a3a2cbb50c3de29da1/sys/sys/proc_common.h ','line_number':250,'multiline':True]['text':' interruptible wait short/long','line_number':256,'multiline':False]['text':' interruptible lwkt wait','line_number':263,'multiline':False]['text':' uninterruptible wait','line_number':265,'multiline':False]['text':' uninterruptible lwkt wait','line_number':267,'multiline':False]