['text':' Copyright 2018 The Go Authors. All rights reserved.','line_number':1,'multiline':False]['text':' Use of this source code is governed by a BSD-style','line_number':2,'multiline':False]['text':' license that can be found in the LICENSE file.','line_number':3,'multiline':False]['text':'go:build gc && !purego','line_number':5,'multiline':False]['text':' +build gc,!purego','line_number':6,'multiline':False]['text':' This implementation of Poly1305 uses the vector facility (vx)','line_number':10,'multiline':False]['text':' to process up to 2 blocks (32 bytes) per iteration using an','line_number':11,'multiline':False]['text':' algorithm based on the one described in:','line_number':12,'multiline':False]['text':'','line_number':13,'multiline':False]['text':' NEON crypto, Daniel J. Bernstein & Peter Schwabe','line_number':14,'multiline':False]['text':' https://cryptojedi.org/papers/neoncrypto-20120320.pdf','line_number':15,'multiline':False]['text':'','line_number':16,'multiline':False]['text':' This algorithm uses 5 26-bit limbs to represent a 130-bit','line_number':17,'multiline':False]['text':' value. These limbs are, for the most part, zero extended and','line_number':18,'multiline':False]['text':' placed into 64-bit vector register elements. Each vector','line_number':19,'multiline':False]['text':' register is 128-bits wide and so holds 2 of these elements.','line_number':20,'multiline':False]['text':' Using 26-bit limbs allows us plenty of headroom to accommodate','line_number':21,'multiline':False]['text':' accumulations before and after multiplication without','line_number':22,'multiline':False]['text':' overflowing either 32-bits (before multiplication) or 64-bits','line_number':23,'multiline':False]['text':' (after multiplication).','line_number':24,'multiline':False]['text':'','line_number':25,'multiline':False]['text':' In order to parallelise the operations required to calculate','line_number':26,'multiline':False]['text':' the sum we use two separate accumulators and then sum those','line_number':27,'multiline':False]['text':' in an extra final step. For compatibility with the generic','line_number':28,'multiline':False]['text':' implementation we perform this summation at the end of every','line_number':29,'multiline':False]['text':' updateVX call.','line_number':30,'multiline':False]['text':'','line_number':31,'multiline':False]['text':' To use two accumulators we must multiply the message blocks','line_number':32,'multiline':False]['text':' by r² rather than r. Only the final message block should be','line_number':33,'multiline':False]['text':' multiplied by r.','line_number':34,'multiline':False]['text':'','line_number':35,'multiline':False]['text':' Example:','line_number':36,'multiline':False]['text':'','line_number':37,'multiline':False]['text':' We want to calculate the sum (h) for a 64 byte message (m):','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':'   h = m[0:16]r⁴ + m[16:32]r³ + m[32:48]r² + m[48:64]r','line_number':40,'multiline':False]['text':'','line_number':41,'multiline':False]['text':' To do this we split the calculation into the even indices','line_number':42,'multiline':False]['text':' and odd indices of the message. These form our SIMD 'lanes':','line_number':43,'multiline':False]['text':'','line_number':44,'multiline':False]['text':'   h = m[ 0:16]r⁴ + m[32:48]r² +   <- lane 0','line_number':45,'multiline':False]['text':'       m[16:32]r³ + m[48:64]r      <- lane 1','line_number':46,'multiline':False]['text':'','line_number':47,'multiline':False]['text':' To calculate this iteratively we refactor so that both lanes','line_number':48,'multiline':False]['text':' are written in terms of r² and r:','line_number':49,'multiline':False]['text':'','line_number':50,'multiline':False]['text':'   h = (m[ 0:16]r² + m[32:48])r² + <- lane 0','line_number':51,'multiline':False]['text':'       (m[16:32]r² + m[48:64])r    <- lane 1','line_number':52,'multiline':False]['text':'                ^             ^','line_number':53,'multiline':False]['text':'                |             coefficients for second iteration','line_number':54,'multiline':False]['text':'                coefficients for first iteration','line_number':55,'multiline':False]['text':'','line_number':56,'multiline':False]['text':' So in this case we would have two iterations. In the first','line_number':57,'multiline':False]['text':' both lanes are multiplied by r². In the second only the','line_number':58,'multiline':False]['text':' first lane is multiplied by r² and the second lane is','line_number':59,'multiline':False]['text':' instead multiplied by r. This gives use the odd and even','line_number':60,'multiline':False]['text':' powers of r that we need from the original equation.','line_number':61,'multiline':False]['text':'','line_number':62,'multiline':False]['text':' Notation:','line_number':63,'multiline':False]['text':'','line_number':64,'multiline':False]['text':'   h - accumulator','line_number':65,'multiline':False]['text':'   r - key','line_number':66,'multiline':False]['text':'   m - message','line_number':67,'multiline':False]['text':'','line_number':68,'multiline':False]['text':'   [a, b]       - SIMD register holding two 64-bit values','line_number':69,'multiline':False]['text':'   [a, b, c, d] - SIMD register holding four 32-bit values','line_number':70,'multiline':False]['text':'   xᵢ[n]        - limb n of variable x with bit width i','line_number':71,'multiline':False]['text':'','line_number':72,'multiline':False]['text':' Limbs are expressed in little endian order, so for 26-bit','line_number':73,'multiline':False]['text':' limbs x₂₆[4] will be the most significant limb and x₂₆[0]','line_number':74,'multiline':False]['text':' will be the least significant limb.','line_number':75,'multiline':False]['text':' masking constants','line_number':77,'multiline':False]['text':' [0x0000000000ffffff, 0x0000000000ffffff] - mask low 24-bits','line_number':78,'multiline':False]['text':' [0x0000000003ffffff, 0x0000000003ffffff] - mask low 26-bits','line_number':79,'multiline':False]['text':' expansion constants (see EXPAND macro)','line_number':81,'multiline':False]['text':' key (r², r or 1 depending on context)','line_number':86,'multiline':False]['text':' precalculated coefficients (5r², 5r or 0 depending on context)','line_number':93,'multiline':False]['text':' message block (m)','line_number':99,'multiline':False]['text':' accumulator (h)','line_number':106,'multiline':False]['text':' temporary registers (for short-lived values)','line_number':113,'multiline':False]['text':' EX0','line_number':121,'multiline':False]['text':' EX1','line_number':124,'multiline':False]['text':' EX2','line_number':127,'multiline':False]['text':' MULTIPLY multiplies each lane of f and g, partially reduced','line_number':131,'multiline':False]['text':' modulo 2¹³⁰ - 5. The result, h, consists of partial products','line_number':132,'multiline':False]['text':' in each lane that need to be reduced further to produce the','line_number':133,'multiline':False]['text':' final result.','line_number':134,'multiline':False]['text':'','line_number':135,'multiline':False]['text':'   h₁₃₀ = (f₁₃₀g₁₃₀) % 2¹³⁰ + (5f₁₃₀g₁₃₀) / 2¹³⁰','line_number':136,'multiline':False]['text':'','line_number':137,'multiline':False]['text':' Note that the multiplication by 5 of the high bits is','line_number':138,'multiline':False]['text':' achieved by precalculating the multiplication of four of the','line_number':139,'multiline':False]['text':' g coefficients by 5. These are g51-g54.','line_number':140,'multiline':False]['text':' REDUCE performs the following carry operations in four','line_number':173,'multiline':False]['text':' stages, as specified in Bernstein & Schwabe:','line_number':174,'multiline':False]['text':'','line_number':175,'multiline':False]['text':'   1: h₂₆[0]->h₂₆[1] h₂₆[3]->h₂₆[4]','line_number':176,'multiline':False]['text':'   2: h₂₆[1]->h₂₆[2] h₂₆[4]->h₂₆[0]','line_number':177,'multiline':False]['text':'   3: h₂₆[0]->h₂₆[1] h₂₆[2]->h₂₆[3]','line_number':178,'multiline':False]['text':'   4: h₂₆[3]->h₂₆[4]','line_number':179,'multiline':False]['text':'','line_number':180,'multiline':False]['text':' The result is that all of the limbs are limited to 26-bits','line_number':181,'multiline':False]['text':' except for h₂₆[1] and h₂₆[4] which are limited to 27-bits.','line_number':182,'multiline':False]['text':'','line_number':183,'multiline':False]['text':' Note that although each limb is aligned at 26-bit intervals','line_number':184,'multiline':False]['text':' they may contain values that exceed 2²⁶ - 1, hence the need','line_number':185,'multiline':False]['text':' to carry the excess bits in each limb.','line_number':186,'multiline':False]['text':' EXPAND splits the 128-bit little-endian values in0 and in1','line_number':212,'multiline':False]['text':' into 26-bit big-endian limbs and places the results into','line_number':213,'multiline':False]['text':' the first and second lane of d₂₆[0:4] respectively.','line_number':214,'multiline':False]['text':'','line_number':215,'multiline':False]['text':' The EX0, EX1 and EX2 constants are arrays of byte indices','line_number':216,'multiline':False]['text':' for permutation. The permutation both reverses the bytes','line_number':217,'multiline':False]['text':' in the input and ensures the bytes are copied into the','line_number':218,'multiline':False]['text':' destination limb ready to be shifted into their final','line_number':219,'multiline':False]['text':' position.','line_number':220,'multiline':False]['text':' [in0₂₆[0], in1₂₆[0]]','line_number':228,'multiline':False]['text':' [in0₂₆[3], in1₂₆[3]]','line_number':229,'multiline':False]['text':' [in0₂₆[1], in1₂₆[1]]','line_number':230,'multiline':False]['text':' [in0₂₆[4], in1₂₆[4]]','line_number':231,'multiline':False]['text':' [in0₂₆[2], in1₂₆[2]]','line_number':232,'multiline':False]['text':' func updateVX(state *macState, msg []byte)','line_number':234,'multiline':False]['text':' R2=msg_base, R3=msg_len','line_number':237,'multiline':False]['text':' load EX0, EX1 and EX2','line_number':239,'multiline':False]['text':' generate masks','line_number':243,'multiline':False]['text':' [0x00ffffff, 0x00ffffff]','line_number':244,'multiline':False]['text':' [0x03ffffff, 0x03ffffff]','line_number':245,'multiline':False]['text':' load h (accumulator) and r (key) from state','line_number':247,'multiline':False]['text':' [0, 0]','line_number':248,'multiline':False]['text':' [h₆₄[0], h₆₄[1]]','line_number':249,'multiline':False]['text':' [h₆₄[2], 0]','line_number':250,'multiline':False]['text':' [r₆₄[0], r₆₄[1]]','line_number':251,'multiline':False]['text':' [h₆₄[0], r₆₄[0]]','line_number':252,'multiline':False]['text':' [h₆₄[1], r₆₄[1]]','line_number':253,'multiline':False]['text':' unpack h and r into 26-bit limbs','line_number':255,'multiline':False]['text':' note: h₆₄[2] may have the low 3 bits set, so h₂₆[4] is a 27-bit value','line_number':256,'multiline':False]['text':' [h₂₆[0], r₂₆[0]]','line_number':257,'multiline':False]['text':' [0, 0]','line_number':258,'multiline':False]['text':' [0, 0]','line_number':259,'multiline':False]['text':' [0x03fff000, 0x03fff000] - 26-bit mask with low 12 bits masked out','line_number':260,'multiline':False]['text':' [h₆₄[2]<<24, 0]','line_number':261,'multiline':False]['text':' [h₂₆[1], r₂₆[1]]','line_number':262,'multiline':False]['text':' [h₂₆[2], r₂₆[2]] - low 12 bits only','line_number':263,'multiline':False]['text':' [h₂₆[1], r₂₆[1]]','line_number':264,'multiline':False]['text':' [h₂₆[4], r₂₆[4]] - low 24 bits only','line_number':265,'multiline':False]['text':' [h₂₆[2], r₂₆[2]] - complete','line_number':266,'multiline':False]['text':' [h₂₆[4], r₂₆[4]] - complete','line_number':267,'multiline':False]['text':' replicate r across all 4 vector elements','line_number':269,'multiline':False]['text':' [r₂₆[0], r₂₆[0], r₂₆[0], r₂₆[0]]','line_number':270,'multiline':False]['text':' [r₂₆[1], r₂₆[1], r₂₆[1], r₂₆[1]]','line_number':271,'multiline':False]['text':' [r₂₆[2], r₂₆[2], r₂₆[2], r₂₆[2]]','line_number':272,'multiline':False]['text':' [r₂₆[3], r₂₆[3], r₂₆[3], r₂₆[3]]','line_number':273,'multiline':False]['text':' [r₂₆[4], r₂₆[4], r₂₆[4], r₂₆[4]]','line_number':274,'multiline':False]['text':' zero out lane 1 of h','line_number':276,'multiline':False]['text':' [h₂₆[0], 0]','line_number':277,'multiline':False]['text':' [h₂₆[1], 0]','line_number':278,'multiline':False]['text':' [h₂₆[2], 0]','line_number':279,'multiline':False]['text':' [h₂₆[3], 0]','line_number':280,'multiline':False]['text':' [h₂₆[4], 0]','line_number':281,'multiline':False]['text':' calculate 5r (ignore least significant limb)','line_number':283,'multiline':False]['text':' [5r₂₆[1], 5r₂₆[1], 5r₂₆[1], 5r₂₆[1]]','line_number':285,'multiline':False]['text':' [5r₂₆[2], 5r₂₆[2], 5r₂₆[2], 5r₂₆[2]]','line_number':286,'multiline':False]['text':' [5r₂₆[3], 5r₂₆[3], 5r₂₆[3], 5r₂₆[3]]','line_number':287,'multiline':False]['text':' [5r₂₆[4], 5r₂₆[4], 5r₂₆[4], 5r₂₆[4]]','line_number':288,'multiline':False]['text':' skip r² calculation if we are only calculating one block','line_number':290,'multiline':False]['text':' calculate r²','line_number':293,'multiline':False]['text':' [r₂₆[0], r²₂₆[0], r₂₆[0], r²₂₆[0]]','line_number':297,'multiline':False]['text':' [r₂₆[1], r²₂₆[1], r₂₆[1], r²₂₆[1]]','line_number':298,'multiline':False]['text':' [r₂₆[2], r²₂₆[2], r₂₆[2], r²₂₆[2]]','line_number':299,'multiline':False]['text':' [r₂₆[3], r²₂₆[3], r₂₆[3], r²₂₆[3]]','line_number':300,'multiline':False]['text':' [r₂₆[4], r²₂₆[4], r₂₆[4], r²₂₆[4]]','line_number':301,'multiline':False]['text':' calculate 5r² (ignore least significant limb)','line_number':303,'multiline':False]['text':' [5r₂₆[1], 5r²₂₆[1], 5r₂₆[1], 5r²₂₆[1]]','line_number':305,'multiline':False]['text':' [5r₂₆[2], 5r²₂₆[2], 5r₂₆[2], 5r²₂₆[2]]','line_number':306,'multiline':False]['text':' [5r₂₆[3], 5r²₂₆[3], 5r₂₆[3], 5r²₂₆[3]]','line_number':307,'multiline':False]['text':' [5r₂₆[4], 5r²₂₆[4], 5r₂₆[4], 5r²₂₆[4]]','line_number':308,'multiline':False]['text':' 2 or fewer blocks remaining, need to change key coefficients','line_number':311,'multiline':False]['text':' load next 2 blocks from message','line_number':313,'multiline':False]['text':' update message slice','line_number':316,'multiline':False]['text':' unpack message blocks into 26-bit big-endian limbs','line_number':320,'multiline':False]['text':' add 2¹²⁸ to each message block value','line_number':323,'multiline':False]['text':' accumulate the incoming message','line_number':328,'multiline':False]['text':' multiply the accumulator by the key coefficient','line_number':335,'multiline':False]['text':' carry and partially reduce the partial products','line_number':338,'multiline':False]['text':' sum lane 0 and lane 1 and put the result in lane 1','line_number':344,'multiline':False]['text':' reduce again after summation','line_number':352,'multiline':False]['text':' TODO(mundaym): there might be a more efficient way to do this','line_number':353,'multiline':False]['text':' now that we only have 1 active lane. For example, we could','line_number':354,'multiline':False]['text':' simultaneously pack the values as we reduce them.','line_number':355,'multiline':False]['text':' carry h[1] through to h[4] so that only h[4] can exceed 2²⁶ - 1','line_number':358,'multiline':False]['text':' TODO(mundaym): in testing this final carry was unnecessary.','line_number':359,'multiline':False]['text':' Needs a proof before it can be removed though.','line_number':360,'multiline':False]['text':' h is now < 2(2¹³⁰ - 5)','line_number':371,'multiline':False]['text':' Pack each lane in h₂₆[0:4] into h₁₂₈[0:1].','line_number':372,'multiline':False]['text':' update state','line_number':387,'multiline':False]['text':' 2 or fewer blocks remaining','line_number':393,'multiline':False]['text':' Load the 2 remaining blocks (17-32 bytes remaining).','line_number':396,'multiline':False]['text':' index of final byte to load modulo 16','line_number':397,'multiline':False]['text':' load full 16 byte block','line_number':398,'multiline':False]['text':' load final (possibly partial) block and pad with zeros to 16 bytes','line_number':399,'multiline':False]['text':' The Poly1305 algorithm requires that a 1 bit be appended to','line_number':401,'multiline':False]['text':' each message block. If the final block is less than 16 bytes','line_number':402,'multiline':False]['text':' long then it is easiest to insert the 1 before the message','line_number':403,'multiline':False]['text':' block is split into 26-bit limbs. If, on the other hand, the','line_number':404,'multiline':False]['text':' final message block is 16 bytes long then we append the 1 bit','line_number':405,'multiline':False]['text':' after expansion as normal.','line_number':406,'multiline':False]['text':' index of byte in last block to insert 1 at (could be 16)','line_number':408,'multiline':False]['text':' skip the insertion if the final block is 16 bytes long','line_number':409,'multiline':False]['text':' insert 1 into the byte at index R3','line_number':410,'multiline':False]['text':' Split both blocks into 26-bit limbs in the appropriate lanes.','line_number':412,'multiline':False]['text':' Append a 1 byte to the end of the second to last block.','line_number':415,'multiline':False]['text':' Append a 1 byte to the end of the last block only if it is a','line_number':418,'multiline':False]['text':' full 16 byte block.','line_number':419,'multiline':False]['text':' Finally, set up the coefficients for the final multiplication.','line_number':423,'multiline':False]['text':' We have previously saved r and 5r in the 32-bit even indexes','line_number':424,'multiline':False]['text':' of the R_[0-4] and R5_[1-4] coefficient registers.','line_number':425,'multiline':False]['text':'','line_number':426,'multiline':False]['text':' We want lane 0 to be multiplied by r² so that can be kept the','line_number':427,'multiline':False]['text':' same. We want lane 1 to be multiplied by r so we need to move','line_number':428,'multiline':False]['text':' the saved r value into the 32-bit odd index in lane 1 by','line_number':429,'multiline':False]['text':' rotating the 64-bit lane by 32.','line_number':430,'multiline':False]['text':' [0, 0xffffffffffffffff] - mask lane 1 only','line_number':431,'multiline':False]['text':' [_,  r²₂₆[0], _,  r₂₆[0]]','line_number':432,'multiline':False]['text':' [_,  r²₂₆[1], _,  r₂₆[1]]','line_number':433,'multiline':False]['text':' [_,  r²₂₆[2], _,  r₂₆[2]]','line_number':434,'multiline':False]['text':' [_,  r²₂₆[3], _,  r₂₆[3]]','line_number':435,'multiline':False]['text':' [_,  r²₂₆[4], _,  r₂₆[4]]','line_number':436,'multiline':False]['text':' [_, 5r²₂₆[1], _, 5r₂₆[1]]','line_number':437,'multiline':False]['text':' [_, 5r²₂₆[2], _, 5r₂₆[2]]','line_number':438,'multiline':False]['text':' [_, 5r²₂₆[3], _, 5r₂₆[3]]','line_number':439,'multiline':False]['text':' [_, 5r²₂₆[4], _, 5r₂₆[4]]','line_number':440,'multiline':False]['text':' 1 block remaining','line_number':448,'multiline':False]['text':' Load the final block (1-16 bytes). This will be placed into','line_number':450,'multiline':False]['text':' lane 0.','line_number':451,'multiline':False]['text':' pad to 16 bytes with zeros','line_number':453,'multiline':False]['text':' The Poly1305 algorithm requires that a 1 bit be appended to','line_number':455,'multiline':False]['text':' each message block. If the final block is less than 16 bytes','line_number':456,'multiline':False]['text':' long then it is easiest to insert the 1 before the message','line_number':457,'multiline':False]['text':' block is split into 26-bit limbs. If, on the other hand, the','line_number':458,'multiline':False]['text':' final message block is 16 bytes long then we append the 1 bit','line_number':459,'multiline':False]['text':' after expansion as normal.','line_number':460,'multiline':False]['text':' Set the message block in lane 1 to the value 0 so that it','line_number':465,'multiline':False]['text':' can be accumulated without affecting the final result.','line_number':466,'multiline':False]['text':' Split the final message block into 26-bit limbs in lane 0.','line_number':469,'multiline':False]['text':' Lane 1 will be contain 0.','line_number':470,'multiline':False]['text':' Append a 1 byte to the end of the last block only if it is a','line_number':473,'multiline':False]['text':' full 16 byte block.','line_number':474,'multiline':False]['text':' We have previously saved r and 5r in the 32-bit even indexes','line_number':478,'multiline':False]['text':' of the R_[0-4] and R5_[1-4] coefficient registers.','line_number':479,'multiline':False]['text':'','line_number':480,'multiline':False]['text':' We want lane 0 to be multiplied by r so we need to move the','line_number':481,'multiline':False]['text':' saved r value into the 32-bit odd index in lane 0. We want','line_number':482,'multiline':False]['text':' lane 1 to be set to the value 1. This makes multiplication','line_number':483,'multiline':False]['text':' a no-op. We do this by setting lane 1 in every register to 0','line_number':484,'multiline':False]['text':' and then just setting the 32-bit index 3 in R_0 to 1.','line_number':485,'multiline':False]['text':' [_, 0x10111213, _, 0x00000000]','line_number':489,'multiline':False]['text':' [_,  r₂₆[0], _, 0]','line_number':490,'multiline':False]['text':' [_,  r₂₆[1], _, 0]','line_number':491,'multiline':False]['text':' [_,  r₂₆[2], _, 0]','line_number':492,'multiline':False]['text':' [_,  r₂₆[3], _, 0]','line_number':493,'multiline':False]['text':' [_,  r₂₆[4], _, 0]','line_number':494,'multiline':False]['text':' [_, 5r₂₆[1], _, 0]','line_number':495,'multiline':False]['text':' [_, 5r₂₆[2], _, 0]','line_number':496,'multiline':False]['text':' [_, 5r₂₆[3], _, 0]','line_number':497,'multiline':False]['text':' [_, 5r₂₆[4], _, 0]','line_number':498,'multiline':False]['text':' Set the value of lane 1 to be 1.','line_number':500,'multiline':False]['text':' [_,  r₂₆[0], _, 1]','line_number':501,'multiline':False]