['text':' SPDX-License-Identifier: MPL-2.0 ','line_number':1,'multiline':True]['text':'  yqueue is an efficient queue implementation. The main goal is','line_number':15,'multiline':False]['text':'  to minimise number of allocations/deallocations needed. Thus yqueue','line_number':16,'multiline':False]['text':'  allocates/deallocates elements in batches of N.','line_number':17,'multiline':False]['text':'','line_number':18,'multiline':False]['text':'  yqueue allows one thread to use push/back function and another one','line_number':19,'multiline':False]['text':'  to use pop/front functions. However, user must ensure that there's no','line_number':20,'multiline':False]['text':'  pop on the empty queue and that both threads don't access the same','line_number':21,'multiline':False]['text':'  element in unsynchronised manner.','line_number':22,'multiline':False]['text':'','line_number':23,'multiline':False]['text':'  T is the type of the object in the queue.','line_number':24,'multiline':False]['text':'  N is granularity of the queue (how many pushes have to be done till','line_number':25,'multiline':False]['text':'  actual memory allocation is required).','line_number':26,'multiline':False]['text':' ALIGN is the memory alignment size to use in the case where we have','line_number':28,'multiline':False]['text':' posix_memalign available. Default value is 64, this alignment will','line_number':29,'multiline':False]['text':' prevent two queue chunks from occupying the same CPU cache line on','line_number':30,'multiline':False]['text':' architectures where cache lines are <= 64 bytes (e.g. most things','line_number':31,'multiline':False]['text':' except POWER). It is detected at build time to try to account for other','line_number':32,'multiline':False]['text':' platforms like POWER and s390x.','line_number':33,'multiline':False]['text':'  Create the queue.','line_number':40,'multiline':False]['text':'  Destroy the queue.','line_number':52,'multiline':False]['text':'  Returns reference to the front element of the queue.','line_number':69,'multiline':False]['text':'  If the queue is empty, behaviour is undefined.','line_number':70,'multiline':False]['text':'  Returns reference to the back element of the queue.','line_number':73,'multiline':False]['text':'  If the queue is empty, behaviour is undefined.','line_number':74,'multiline':False]['text':'  Adds an element to the back end of the queue.','line_number':77,'multiline':False]['text':'  Removes element from the back end of the queue. In other words','line_number':99,'multiline':False]['text':'  it rollbacks last push to the queue. Take care: Caller is','line_number':100,'multiline':False]['text':'  responsible for destroying the object being unpushed.','line_number':101,'multiline':False]['text':'  The caller must also guarantee that the queue isn't empty when','line_number':102,'multiline':False]['text':'  unpush is called. It cannot be done automatically as the read','line_number':103,'multiline':False]['text':'  side of the queue can be managed by different, completely','line_number':104,'multiline':False]['text':'  unsynchronised thread.','line_number':105,'multiline':False]['text':'  First, move 'back' one position backwards.','line_number':108,'multiline':False]['text':'  Now, move 'end' position backwards. Note that obsolete end chunk','line_number':116,'multiline':False]['text':'  is not used as a spare chunk. The analysis shows that doing so','line_number':117,'multiline':False]['text':'  would require free and atomic operation per chunk deallocated','line_number':118,'multiline':False]['text':'  instead of a simple free.','line_number':119,'multiline':False]['text':'  Removes an element from the front end of the queue.','line_number':130,'multiline':False]['text':'  'o' has been more recently used than _spare_chunk,','line_number':139,'multiline':False]['text':'  so for cache reasons we'll get rid of the spare and','line_number':140,'multiline':False]['text':'  use 'o' as the spare.','line_number':141,'multiline':False]['text':'  Individual memory chunk to hold N elements.','line_number':148,'multiline':False]['text':'  Back position may point to invalid memory if the queue is empty,','line_number':168,'multiline':False]['text':'  while begin & end positions are always valid. Begin position is','line_number':169,'multiline':False]['text':'  accessed exclusively be queue reader (front/pop), while back and','line_number':170,'multiline':False]['text':'  end positions are accessed exclusively by queue writer (back/push).','line_number':171,'multiline':False]['text':'  People are likely to produce and consume at similar rates.  In','line_number':179,'multiline':False]['text':'  this scenario holding onto the most recently freed chunk saves','line_number':180,'multiline':False]['text':'  us from having to call malloc/free.','line_number':181,'multiline':False]