['text':'===-- release.h -----------------------------------------------*- C++ -*-===//','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.','line_number':3,'multiline':False]['text':' See https://llvm.org/LICENSE.txt for license information.','line_number':4,'multiline':False]['text':' SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'===----------------------------------------------------------------------===//','line_number':7,'multiline':False]['text':' Releases [From, To) range of pages back to OS. Note that `From` and `To`','line_number':31,'multiline':False]['text':' are offseted from `Base` + Offset.','line_number':32,'multiline':False]['text':' The release offset from Base. This is used when we know a given range after','line_number':45,'multiline':False]['text':' Base will not be released.','line_number':46,'multiline':False]['text':' Releases [From, To) range of pages back to OS.','line_number':61,'multiline':False]['text':' The starting address to release. Note that we may want to combine (Base +','line_number':72,'multiline':False]['text':' Offset) as a new Base. However, the Base is retrieved from','line_number':73,'multiline':False]['text':' `MapPlatformData` on Fuchsia, which means the offset won't be aware.','line_number':74,'multiline':False]['text':' Therefore, store them separately to make it work on all the platforms.','line_number':75,'multiline':False]['text':' The release offset from Base. This is used when we know a given range after','line_number':77,'multiline':False]['text':' Base will not be released.','line_number':78,'multiline':False]['text':' A buffer pool which holds a fixed number of static buffers for fast buffer','line_number':83,'multiline':False]['text':' allocation. If the request size is greater than `StaticBufferSize`, it'll','line_number':84,'multiline':False]['text':' delegate the allocation to map().','line_number':85,'multiline':False]['text':' Preserve 1 bit in the `Mask` so that we don't need to do zero-check while','line_number':88,'multiline':False]['text':' extracting the least significant bit from the `Mask`.','line_number':89,'multiline':False]['text':' Return a buffer which is at least `BufferSize`.','line_number':93,'multiline':False]['text':' TODO: In general, we expect this operation should be fast so the','line_number':100,'multiline':False]['text':' waiting thread won't be put into sleep. The HybridMutex does implement','line_number':101,'multiline':False]['text':' the busy-waiting but we may want to review the performance and see if','line_number':102,'multiline':False]['text':' we need an explict spin lock here.','line_number':103,'multiline':False]['text':' When using a heap-based buffer, precommit the pages backing the','line_number':158,'multiline':False]['text':' Vmar by passing |MAP_PRECOMMIT| flag. This allows an optimization','line_number':159,'multiline':False]['text':' where page fault exceptions are skipped as the allocated memory','line_number':160,'multiline':False]['text':' is accessed. So far, this is only enabled on Fuchsia. It hasn't proven a','line_number':161,'multiline':False]['text':' performance benefit on other platforms.','line_number':162,'multiline':False]['text':' '1' means that buffer index is not used. '0' means the buffer is in use.','line_number':170,'multiline':False]['text':' A Region page map is used to record the usage of pages in the regions. It','line_number':176,'multiline':False]['text':' implements a packed array of Counters. Each counter occupies 2^N bits, enough','line_number':177,'multiline':False]['text':' to store counter's MaxValue. Ctor will try to use a static buffer first, and','line_number':178,'multiline':False]['text':' if that fails (the buffer is too small or already locked), will allocate the','line_number':179,'multiline':False]['text':' required Buffer via map(). The caller is expected to check whether the','line_number':180,'multiline':False]['text':' initialization was successful by checking isAllocated() result. For','line_number':181,'multiline':False]['text':' performance sake, none of the accessors check the validity of the arguments,','line_number':182,'multiline':False]['text':' It is assumed that Index is always in [0, N) range and the value is not','line_number':183,'multiline':False]['text':' incremented past MaxValue.','line_number':184,'multiline':False]['text':' Lock of `StaticBuffer` is acquired conditionally and there's no easy way to','line_number':207,'multiline':False]['text':' specify the thread-safety attribute properly in current code structure.','line_number':208,'multiline':False]['text':' Besides, it's the only place we may want to check thread safety. Therefore,','line_number':209,'multiline':False]['text':' it's fine to bypass the thread-safety analysis now.','line_number':210,'multiline':False]['text':' Rounding counter storage size up to the power of two allows for using','line_number':220,'multiline':False]['text':' bit shifts calculating particular counter's Index and offset.','line_number':221,'multiline':False]['text':' Set the counter to the max value. Note that the max number of blocks in a','line_number':280,'multiline':False]['text':' page may vary. To provide an easier way to tell if all the blocks are','line_number':281,'multiline':False]['text':' counted for different pages, set to the same max value to denote the','line_number':282,'multiline':False]['text':' all-counted status.','line_number':283,'multiline':False]['text':' We may consider making this configurable if there are cases which may','line_number':326,'multiline':False]['text':' benefit from this.','line_number':327,'multiline':False]['text':' Same number of chunks per page, no cross overs.','line_number':380,'multiline':False]['text':' Some chunks are crossing page boundaries, which means that the page','line_number':384,'multiline':False]['text':' contains one or two partial chunks, but all pages contain the same','line_number':385,'multiline':False]['text':' number of chunks.','line_number':386,'multiline':False]['text':' Some chunks are crossing page boundaries, which means that the page','line_number':390,'multiline':False]['text':' contains one or two partial chunks.','line_number':391,'multiline':False]['text':' One chunk covers multiple pages, no cross overs.','line_number':397,'multiline':False]['text':' One chunk covers multiple pages, Some chunks are crossing page','line_number':401,'multiline':False]['text':' boundaries. Some pages contain one chunk, some contain two.','line_number':402,'multiline':False]['text':' TODO: For multiple regions, it's more complicated to support partial','line_number':408,'multiline':False]['text':' region marking (which includes the complexity of how to handle the last','line_number':409,'multiline':False]['text':' block in a region). We may consider this after markFreeBlocks() accepts','line_number':410,'multiline':False]['text':' only free blocks from the same region.','line_number':411,'multiline':False]['text':' PageMap is lazily allocated when markFreeBlocks() is invoked.','line_number':420,'multiline':False]['text':' TODO: Log some message when we fail on PageMap allocation.','line_number':429,'multiline':False]['text':' Mark all the blocks in the given range [From, to). Instead of visiting all','line_number':433,'multiline':False]['text':' the blocks, we will just mark the page as all counted. Note the `From` and','line_number':434,'multiline':False]['text':' `To` has to be page aligned but with one exception, if `To` is equal to the','line_number':435,'multiline':False]['text':' RegionSize, it's not necessary to be aligned with page size.','line_number':436,'multiline':False]['text':' The straddling block sits across entire range.','line_number':451,'multiline':False]['text':' First block may not sit at the first pape in the range, move','line_number':455,'multiline':False]['text':' `FromInRegion` to the first block page.','line_number':456,'multiline':False]['text':' When The first block is not aligned to the range boundary, which means','line_number':459,'multiline':False]['text':' there is a block sitting acorss `From`, that looks like,','line_number':460,'multiline':False]['text':'','line_number':461,'multiline':False]['text':'   From                                             To','line_number':462,'multiline':False]['text':'     V                                               V','line_number':463,'multiline':False]['text':'     +-----------------------------------------------+','line_number':464,'multiline':False]['text':'  +-----+-----+-----+-----+','line_number':465,'multiline':False]['text':'  |     |     |     |     | ...','line_number':466,'multiline':False]['text':'  +-----+-----+-----+-----+','line_number':467,'multiline':False]['text':'     |-    first page     -||-    second page    -||- ...','line_number':468,'multiline':False]['text':'','line_number':469,'multiline':False]['text':' Therefore, we can't just mark the first page as all counted. Instead, we','line_number':470,'multiline':False]['text':' increment the number of blocks in the first page in the page map and','line_number':471,'multiline':False]['text':' then round up the `From` to the next page.','line_number':472,'multiline':False]['text':' Note that LastBlockInRange may be smaller than `FromInRegion` at this','line_number':485,'multiline':False]['text':' point because it may contain only one block in the range.','line_number':486,'multiline':False]['text':' When the last block sits across `To`, we can't just mark the pages','line_number':488,'multiline':False]['text':' occupied by the last block as all counted. Instead, we increment the','line_number':489,'multiline':False]['text':' counters of those pages by 1. The exception is that if it's the last','line_number':490,'multiline':False]['text':' block in the region, it's fine to mark those pages as all counted.','line_number':491,'multiline':False]['text':' The case below is like,','line_number':494,'multiline':False]['text':'','line_number':495,'multiline':False]['text':'   From                                      To','line_number':496,'multiline':False]['text':'     V                                        V','line_number':497,'multiline':False]['text':'     +----------------------------------------+','line_number':498,'multiline':False]['text':'                          +-----+-----+-----+-----+','line_number':499,'multiline':False]['text':'                          |     |     |     |     | ...','line_number':500,'multiline':False]['text':'                          +-----+-----+-----+-----+','line_number':501,'multiline':False]['text':'                    ... -||-    last page    -||-    next page    -|','line_number':502,'multiline':False]['text':'','line_number':503,'multiline':False]['text':' The last block is not aligned to `To`, we need to increment the','line_number':504,'multiline':False]['text':' counter of `next page` by 1.','line_number':505,'multiline':False]['text':' After handling the first page and the last block, it's safe to mark any','line_number':514,'multiline':False]['text':' page in between the range [From, To).','line_number':515,'multiline':False]['text':' The last block in a region may not use the entire page, we mark the','line_number':535,'multiline':False]['text':' following "pretend" memory block(s) as free in advance.','line_number':536,'multiline':False]['text':'','line_number':537,'multiline':False]['text':'     Region Boundary','line_number':538,'multiline':False]['text':'         v','line_number':539,'multiline':False]['text':'  -----+-----------------------+','line_number':540,'multiline':False]['text':'       |      Last Page        | <- Rounded Region Boundary','line_number':541,'multiline':False]['text':'  -----+-----------------------+','line_number':542,'multiline':False]['text':'   |-----||- trailing blocks  -|','line_number':543,'multiline':False]['text':'      ^','line_number':544,'multiline':False]['text':'   last block','line_number':545,'multiline':False]['text':' If the difference between `RoundedRegionSize` and','line_number':548,'multiline':False]['text':' `TrailingBlockBase` is larger than a page, that implies the reported','line_number':549,'multiline':False]['text':' `RegionSize` may not be accurate.','line_number':550,'multiline':False]['text':' Only the last page touched by the last block needs to mark the trailing','line_number':553,'multiline':False]['text':' blocks. Note that if the last "pretend" block straddles the boundary,','line_number':554,'multiline':False]['text':' we still have to count it in so that the logic of counting the number','line_number':555,'multiline':False]['text':' of blocks on a page is consistent.','line_number':556,'multiline':False]['text':' Iterate over free chunks and count how many free chunks affect each','line_number':567,'multiline':False]['text':' allocated page.','line_number':568,'multiline':False]['text':' Each chunk affects one page only.','line_number':570,'multiline':False]['text':' In all other cases chunks might affect more than one page.','line_number':579,'multiline':False]['text':' For partial region marking, some pages in front are not needed to be','line_number':598,'multiline':False]['text':' counted.','line_number':599,'multiline':False]['text':' Try to release the page which doesn't have any in-used block, i.e., they are','line_number':609,'multiline':False]['text':' all free blocks. The `PageMap` will record the number of free blocks in each','line_number':610,'multiline':False]['text':' page.','line_number':611,'multiline':False]['text':' Iterate over pages detecting ranges of pages with chunk Counters equal','line_number':625,'multiline':False]['text':' to the expected number of chunks for the particular page.','line_number':626,'multiline':False]['text':' Fast path, every page has the same number of chunks affecting it.','line_number':629,'multiline':False]['text':' Slow path, go through the pages keeping count how many chunks affect','line_number':642,'multiline':False]['text':' each page.','line_number':643,'multiline':False]['text':' The idea is to increment the current page pointer by the first chunk','line_number':646,'multiline':False]['text':' size, middle portion size (the portion of the page covered by chunks','line_number':647,'multiline':False]['text':' except the first and the last one) and then the last chunk size, adding','line_number':648,'multiline':False]['text':' up the number of chunks on the current page and checking on every step','line_number':649,'multiline':False]['text':' whether the page boundary was crossed.','line_number':650,'multiline':False]['text':' namespace scudo','line_number':684,'multiline':False]['text':' SCUDO_RELEASE_H_','line_number':686,'multiline':False]