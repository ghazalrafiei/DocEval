['text':'===-- combined.h ----------------------------------------------*- C++ -*-===//','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.','line_number':3,'multiline':False]['text':' See https://llvm.org/LICENSE.txt for license information.','line_number':4,'multiline':False]['text':' SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'===----------------------------------------------------------------------===//','line_number':7,'multiline':False]['text':' GWP_ASAN_HOOKS','line_number':33,'multiline':False]['text':' This function is not part of the NDK so it does not appear in any public','line_number':38,'multiline':False]['text':' header files. We only declare/use it when targeting the platform.','line_number':39,'multiline':False]['text':' Chunk recycling function, returns a quarantined chunk to the backend,','line_number':63,'multiline':False]['text':' first making sure it hasn't been tampered with.','line_number':64,'multiline':False]['text':' We take a shortcut when allocating a quarantine batch by working with the','line_number':81,'multiline':False]['text':' appropriate class ID instead of using Size. The compiler should optimize','line_number':82,'multiline':False]['text':' the class ID computation and work with the associated cache directly.','line_number':83,'multiline':False]['text':' Quarantine batch allocation failure is fatal.','line_number':88,'multiline':False]['text':' Reset tag to 0 as this chunk may have been previously used for a tagged','line_number':100,'multiline':False]['text':' user allocation.','line_number':101,'multiline':False]['text':' Check if hardware CRC32 is supported in the binary and by the platform,','line_number':140,'multiline':False]['text':' if so, opt for the CRC32 hardware version of the checksum.','line_number':141,'multiline':False]['text':' Store some flags locally.','line_number':155,'multiline':False]['text':' Initialize the embedded GWP-ASan instance. Requires the main allocator to','line_number':184,'multiline':False]['text':' be functional, best called from PostInitCallback.','line_number':185,'multiline':False]['text':' Embedded GWP-ASan is locked through the Scudo atfork handler (via','line_number':195,'multiline':False]['text':' Allocator::disable calling GWPASan.disable). Disable GWP-ASan's atfork','line_number':196,'multiline':False]['text':' handler.','line_number':197,'multiline':False]['text':' GWP_ASAN_HOOKS','line_number':213,'multiline':False]['text':' GWP_ASAN_HOOKS','line_number':224,'multiline':False]['text':' GWP_ASAN_HOOKS','line_number':239,'multiline':False]['text':' The Cache must be provided zero-initialized.','line_number':245,'multiline':False]['text':' Release the resources used by a TSD, which involves:','line_number':248,'multiline':False]['text':' - draining the local quarantine cache to the global quarantine;','line_number':249,'multiline':False]['text':' - releasing the cached pointers back to the Primary;','line_number':250,'multiline':False]['text':' - unlinking the local stats from the global ones (destroying the cache does','line_number':251,'multiline':False]['text':'   the last two items).','line_number':252,'multiline':False]['text':' Secondary, or pointer allocated while memory tagging is unsupported or','line_number':272,'multiline':False]['text':' disabled. The tag mismatch is okay in the latter case because tags will','line_number':273,'multiline':False]['text':' not be checked.','line_number':274,'multiline':False]['text':' Discard collectStackTrace() frame and allocator function frame.','line_number':290,'multiline':False]['text':' If a chunk's tag is odd, we want the tags of the surrounding blocks to be','line_number':307,'multiline':False]['text':' even, and vice versa. Blocks are laid out Size bytes apart, and adding','line_number':308,'multiline':False]['text':' Size to Ptr will flip the least significant set bit of Size in Ptr, so','line_number':309,'multiline':False]['text':' that bit will have the pattern 010101... for consecutive blocks, which we','line_number':310,'multiline':False]['text':' can use to determine which tag mask to use.','line_number':311,'multiline':False]['text':' GWP_ASAN_HOOKS','line_number':341,'multiline':False]['text':' If the requested size happens to be 0 (more common than you might think),','line_number':348,'multiline':False]['text':' allocate MinAlignment bytes on top of the header. Then add the extra','line_number':349,'multiline':False]['text':' bytes required to fulfill the alignment requirements: we allocate enough','line_number':350,'multiline':False]['text':' to be sure that there will be an address in the block that will satisfy','line_number':351,'multiline':False]['text':' the alignment.','line_number':352,'multiline':False]['text':' Takes care of extravagantly large sizes as well as integer overflows.','line_number':357,'multiline':False]['text':' If the allocation failed, the most likely reason with a 32-bit primary','line_number':388,'multiline':False]['text':' is the region being full. In that event, retry in each successively','line_number':389,'multiline':False]['text':' larger class until it fits. If it fails to fit in the largest class,','line_number':390,'multiline':False]['text':' fallback to the Secondary.','line_number':391,'multiline':False]['text':' We only need to zero or tag the contents for Primary backed','line_number':419,'multiline':False]['text':' allocations. We only set tags for primary allocations in order to avoid','line_number':420,'multiline':False]['text':' faulting potentially large numbers of pages for large secondary','line_number':421,'multiline':False]['text':' allocations. We assume that guard pages are enough to protect these','line_number':422,'multiline':False]['text':' allocations.','line_number':423,'multiline':False]['text':'','line_number':424,'multiline':False]['text':' FIXME: When the kernel provides a way to set the background tag of a','line_number':425,'multiline':False]['text':' mapping, we should be able to tag secondary allocations as well.','line_number':426,'multiline':False]['text':'','line_number':427,'multiline':False]['text':' When memory tagging is enabled, zeroing the contents is done as part of','line_number':428,'multiline':False]['text':' setting the tag.','line_number':429,'multiline':False]['text':' If possible, try to reuse the UAF tag that was set by deallocate().','line_number':435,'multiline':False]['text':' For simplicity, only reuse tags if we have the same start address as','line_number':436,'multiline':False]['text':' the previous allocation. This handles the majority of cases since','line_number':437,'multiline':False]['text':' most allocations will not be more aligned than the minimum alignment.','line_number':438,'multiline':False]['text':'','line_number':439,'multiline':False]['text':' We need to handle situations involving reclaimed chunks, and retag','line_number':440,'multiline':False]['text':' the reclaimed portions if necessary. In the case where the chunk is','line_number':441,'multiline':False]['text':' fully reclaimed, the chunk's header will be zero, which will trigger','line_number':442,'multiline':False]['text':' the code path for new mappings and invalid chunks that prepares the','line_number':443,'multiline':False]['text':' chunk from scratch. There are three possibilities for partial','line_number':444,'multiline':False]['text':' reclaiming:','line_number':445,'multiline':False]['text':'','line_number':446,'multiline':False]['text':' (1) Header was reclaimed, data was partially reclaimed.','line_number':447,'multiline':False]['text':' (2) Header was not reclaimed, all data was reclaimed (e.g. because','line_number':448,'multiline':False]['text':'     data started on a page boundary).','line_number':449,'multiline':False]['text':' (3) Header was not reclaimed, data was partially reclaimed.','line_number':450,'multiline':False]['text':'','line_number':451,'multiline':False]['text':' Case (1) will be handled in the same way as for full reclaiming,','line_number':452,'multiline':False]['text':' since the header will be zero.','line_number':453,'multiline':False]['text':'','line_number':454,'multiline':False]['text':' We can detect case (2) by loading the tag from the start','line_number':455,'multiline':False]['text':' of the chunk. If it is zero, it means that either all data was','line_number':456,'multiline':False]['text':' reclaimed (since we never use zero as the chunk tag), or that the','line_number':457,'multiline':False]['text':' previous allocation was of size zero. Either way, we need to prepare','line_number':458,'multiline':False]['text':' a new chunk from scratch.','line_number':459,'multiline':False]['text':'','line_number':460,'multiline':False]['text':' We can detect case (3) by moving to the next page (if covered by the','line_number':461,'multiline':False]['text':' chunk) and loading the tag of its first granule. If it is zero, it','line_number':462,'multiline':False]['text':' means that all following pages may need to be retagged. On the other','line_number':463,'multiline':False]['text':' hand, if it is nonzero, we can assume that all following pages are','line_number':464,'multiline':False]['text':' still tagged, according to the logic that if any of the pages','line_number':465,'multiline':False]['text':' following the next page were reclaimed, the next page would have been','line_number':466,'multiline':False]['text':' reclaimed as well.','line_number':467,'multiline':False]['text':' If an allocation needs to be zeroed (i.e. calloc) we can normally','line_number':479,'multiline':False]['text':' avoid zeroing the memory now since we can rely on memory having','line_number':480,'multiline':False]['text':' been zeroed on free, as this is normally done while setting the','line_number':481,'multiline':False]['text':' UAF tag. But if tagging was disabled per-thread when the memory','line_number':482,'multiline':False]['text':' was freed, it would not have been retagged and thus zeroed, and','line_number':483,'multiline':False]['text':' therefore it needs to be zeroed now.','line_number':484,'multiline':False]['text':' Clear any stack metadata that may have previously been stored in','line_number':489,'multiline':False]['text':' the chunk data.','line_number':490,'multiline':False]['text':' This condition is not necessarily unlikely, but since memset is','line_number':503,'multiline':False]['text':' costly, we might as well mark it as such.','line_number':504,'multiline':False]['text':' The BlockMarker has no security purpose, but is specifically meant for','line_number':522,'multiline':False]['text':' the chunk iteration function that can be used in debugging situations.','line_number':523,'multiline':False]['text':' It is the only situation where we have to locate the start of a chunk','line_number':524,'multiline':False]['text':' based on its block address.','line_number':525,'multiline':False]['text':' For a deallocation, we only ensure minimal initialization, meaning thread','line_number':546,'multiline':False]['text':' local data will be left uninitialized for now (when using ELF TLS). The','line_number':547,'multiline':False]['text':' fallback cache will be used instead. This is a workaround for a situation','line_number':548,'multiline':False]['text':' where the only heap operation performed in a thread would be a free past','line_number':549,'multiline':False]['text':' the TLS destructors, ending up in initialized thread specific data never','line_number':550,'multiline':False]['text':' being destroyed properly. Any other heap operation will do a full init.','line_number':551,'multiline':False]['text':'MinimalInit=','line_number':552,'multiline':True]['text':' GWP_ASAN_HOOKS','line_number':569,'multiline':False]['text':' With the exception of memalign'd chunks, that can be still be free'd.','line_number':586,'multiline':False]['text':' The following cases are handled by the C wrappers.','line_number':613,'multiline':False]['text':' GWP_ASAN_HOOKS','line_number':630,'multiline':False]['text':' Pointer has to be allocated with a malloc-type function. Some','line_number':644,'multiline':False]['text':' applications think that it is OK to realloc a memalign'ed pointer, which','line_number':645,'multiline':False]['text':' will trigger this check. It really isn't.','line_number':646,'multiline':False]['text':' If the new chunk still fits in the previously allocated block (with a','line_number':667,'multiline':False]['text':' reasonable delta), we just keep the old block, and update the chunk','line_number':668,'multiline':False]['text':' header to reflect the size change.','line_number':669,'multiline':False]['text':' Otherwise we allocate a new one, and deallocate the old one. Some','line_number':693,'multiline':False]['text':' allocators will allocate an even larger chunk (by a fixed factor) to','line_number':694,'multiline':False]['text':' allow for potential further in-place realloc. The gains of such a trick','line_number':695,'multiline':False]['text':' are currently unclear.','line_number':696,'multiline':False]['text':' TODO(kostyak): disable() is currently best-effort. There are some small','line_number':707,'multiline':False]['text':'                windows of time when an allocation could still succeed after','line_number':708,'multiline':False]['text':'                this function finishes. We will revisit that later.','line_number':709,'multiline':False]['text':' The function returns the amount of bytes required to store the statistics,','line_number':734,'multiline':False]['text':' which might be larger than the amount of bytes provided. Note that the','line_number':735,'multiline':False]['text':' statistics buffer is not necessarily constant between calls to this','line_number':736,'multiline':False]['text':' function. This can be called with a null buffer or zero size for buffer','line_number':737,'multiline':False]['text':' sizing purposes.','line_number':738,'multiline':False]['text':' Iterate over all chunks and call a callback for all busy chunks located','line_number':765,'multiline':False]['text':' within the provided memory range. Said callback must not use this allocator','line_number':766,'multiline':False]['text':' or a deadlock can ensue. This fits Android's malloc_iterate() needs.','line_number':767,'multiline':False]['text':' A chunk header can either have a zero tag (tagged primary) or the','line_number':784,'multiline':False]['text':' header tag (secondary, or untagged primary). We don't know which so','line_number':785,'multiline':False]['text':' try both.','line_number':786,'multiline':False]['text':' Enabling odd/even tags involves a tradeoff between use-after-free','line_number':820,'multiline':False]['text':' detection and buffer overflow detection. Odd/even tags make it more','line_number':821,'multiline':False]['text':' likely for buffer overflows to be detected by increasing the size of','line_number':822,'multiline':False]['text':' the guaranteed "red zone" around the allocation, but on the other hand','line_number':823,'multiline':False]['text':' use-after-free is less likely to be detected because the tag space for','line_number':824,'multiline':False]['text':' any particular chunk is cut in half. Therefore we use this tuning','line_number':825,'multiline':False]['text':' setting to control whether odd/even tags are enabled.','line_number':826,'multiline':False]['text':' We leave it to the various sub-components to decide whether or not they','line_number':833,'multiline':False]['text':' want to handle the option, but we do not want to short-circuit','line_number':834,'multiline':False]['text':' execution if one of the setOption was to return false.','line_number':835,'multiline':False]['text':' Return the usable size for a given chunk. Technically we lie, as we just','line_number':844,'multiline':False]['text':' report the actual size of a chunk. This is done to counteract code actively','line_number':845,'multiline':False]['text':' writing past the end of a chunk (like sqlite3) when the usable size allows','line_number':846,'multiline':False]['text':' for it, which then forces realloc to copy the usable size of a chunk as','line_number':847,'multiline':False]['text':' opposed to its actual size.','line_number':848,'multiline':False]['text':' GWP_ASAN_HOOKS','line_number':857,'multiline':False]['text':' Getting the usable size of a chunk only makes sense if it's allocated.','line_number':862,'multiline':False]['text':' Returns true if the pointer provided was allocated by the current','line_number':873,'multiline':False]['text':' allocator instance, which is compliant with tcmalloc's ownership concept.','line_number':874,'multiline':False]['text':' A corrupted chunk will not be reported as owned, which is WAI.','line_number':875,'multiline':False]['text':' GWP_ASAN_HOOKS','line_number':881,'multiline':False]['text':' If we haven't been initialized yet, we need to initialize now in order to','line_number':901,'multiline':False]['text':' prevent a future call to initThreadMaybe() from enabling memory tagging','line_number':902,'multiline':False]['text':' based on feature detection. But don't call initThreadMaybe() because it','line_number':903,'multiline':False]['text':' may end up calling the allocator (via pthread_atfork, via the post-init','line_number':904,'multiline':False]['text':' callback), which may cause mappings to be created with memory tagging','line_number':905,'multiline':False]['text':' enabled.','line_number':906,'multiline':False]['text':' Need at least one entry.','line_number':963,'multiline':False]['text':' Check for OOB in the current block and the two surrounding blocks. Beyond','line_number':999,'multiline':False]['text':' that, UAF is more likely.','line_number':1000,'multiline':False]['text':' Check the ring buffer. For primary allocations this will only find UAF;','line_number':1006,'multiline':False]['text':' for secondary allocations we can find either UAF or OOB.','line_number':1007,'multiline':False]['text':' Check for OOB in the 28 blocks surrounding the 3 we checked earlier.','line_number':1011,'multiline':False]['text':' Beyond that we are likely to hit false positives.','line_number':1012,'multiline':False]['text':' 16 MB seems reasonable.','line_number':1023,'multiline':False]['text':' These are indexes into an "array" of 32-bit values that store information','line_number':1037,'multiline':False]['text':' inline with a chunk that is relevant to diagnosing memory tag faults, where','line_number':1038,'multiline':False]['text':' 0 corresponds to the address of the user memory. This means that only','line_number':1039,'multiline':False]['text':' negative indexes may be used. The smallest index that may be used is -2,','line_number':1040,'multiline':False]['text':' which corresponds to 8 bytes before the user memory, because the chunk','line_number':1041,'multiline':False]['text':' header size is 8 bytes and in allocators that support memory tagging the','line_number':1042,'multiline':False]['text':' minimum alignment is at least the tag granule size (16 on aarch64).','line_number':1043,'multiline':False]['text':' GWP_ASAN_HOOKS','line_number':1061,'multiline':False]['text':' An array of Size (at least one) elements of type Entry is immediately','line_number':1077,'multiline':False]['text':' following to this struct.','line_number':1078,'multiline':False]['text':' Pointer to memory mapped area starting with AllocationRingBuffer struct,','line_number':1080,'multiline':False]['text':' and immediately followed by Size elements of type Entry.','line_number':1081,'multiline':False]['text':' The following might get optimized out by the compiler.','line_number':1084,'multiline':False]['text':' Verify that the header offset field can hold the maximum offset. In the','line_number':1086,'multiline':False]['text':' case of the Secondary allocator, it takes care of alignment and the','line_number':1087,'multiline':False]['text':' offset will always be small. In the case of the Primary, the worst case','line_number':1088,'multiline':False]['text':' scenario happens in the last size class, when the backend allocation','line_number':1089,'multiline':False]['text':' would already be aligned on the requested alignment, which would happen','line_number':1090,'multiline':False]['text':' to be the maximum alignment that would fit in that size class. As a','line_number':1091,'multiline':False]['text':' result, the maximum offset will be at most the maximum alignment for the','line_number':1092,'multiline':False]['text':' last size class minus the header size, in multiples of MinAlignment.','line_number':1093,'multiline':False]['text':' Verify that we can fit the maximum size or amount of unused bytes in the','line_number':1103,'multiline':False]['text':' header. Given that the Secondary fits the allocation to a page, the worst','line_number':1104,'multiline':False]['text':' case scenario happens in the Primary. It will depend on the second to','line_number':1105,'multiline':False]['text':' last and last class sizes, as well as the dynamic base for the Primary.','line_number':1106,'multiline':False]['text':' The following is an over-approximation that works for our needs.','line_number':1107,'multiline':False]['text':' Return the size of a chunk as requested during its allocation.','line_number':1126,'multiline':False]['text':' If the quarantine is disabled, the actual size of a chunk is 0 or larger','line_number':1142,'multiline':False]['text':' than the maximum allowed, we return a chunk directly to the backend.','line_number':1143,'multiline':False]['text':' This purposefully underflows for Size == 0.','line_number':1144,'multiline':False]['text':' Exclude the previous tag so that immediate use after free is','line_number':1166,'multiline':False]['text':' detected 100% of the time.','line_number':1167,'multiline':False]['text':' When we have drained some blocks back to the Primary from TSD, that','line_number':1185,'multiline':False]['text':' implies that we may have the chance to release some pages as well.','line_number':1186,'multiline':False]['text':' Note that in order not to block other thread's accessing the TSD,','line_number':1187,'multiline':False]['text':' release the TSD first then try the page release.','line_number':1188,'multiline':False]['text':' Set the tag of the granule past the end of the allocation to 0, to catch','line_number':1221,'multiline':False]['text':' linear overflows even if a previous larger allocation used the same block','line_number':1222,'multiline':False]['text':' and tag. Only do this if the granule past the end is in our block, because','line_number':1223,'multiline':False]['text':' this would otherwise lead to a SEGV if the allocation covers the entire','line_number':1224,'multiline':False]['text':' block and our block is at the end of a mapping. The tag of the next block's','line_number':1225,'multiline':False]['text':' header granule will be set to 0, so it will serve the purpose of catching','line_number':1226,'multiline':False]['text':' linear overflows in this case.','line_number':1227,'multiline':False]['text':'','line_number':1228,'multiline':False]['text':' For allocations of size 0 we do not end up storing the address tag to the','line_number':1229,'multiline':False]['text':' memory tag space, which getInlineErrorInfo() normally relies on to match','line_number':1230,'multiline':False]['text':' address tags against chunks. To allow matching in this case we store the','line_number':1231,'multiline':False]['text':' address tag in the first byte of the chunk.','line_number':1232,'multiline':False]['text':' Prepare the granule before the chunk to store the chunk header by setting','line_number':1245,'multiline':False]['text':' its tag to 0. Normally its tag will already be 0, but in the case where a','line_number':1246,'multiline':False]['text':' chunk holding a low alignment allocation is reused for a higher alignment','line_number':1247,'multiline':False]['text':' allocation, the chunk may already have a non-zero tag from the previous','line_number':1248,'multiline':False]['text':' allocation.','line_number':1249,'multiline':False]['text':' If the allocation is shrinking we just need to set the tag past the end','line_number':1264,'multiline':False]['text':' of the allocation to 0. See explanation in storeEndMarker() above.','line_number':1265,'multiline':False]['text':' Set the memory tag of the region','line_number':1268,'multiline':False]['text':' [RoundOldPtr, roundUp(NewPtr, archMemoryTagGranuleSize()))','line_number':1269,'multiline':False]['text':' to the pointer tag stored in OldPtr.','line_number':1270,'multiline':False]['text':' First invalidate our entry so that we don't attempt to interpret a','line_number':1291,'multiline':False]['text':' partially written state in getSecondaryErrorInfo(). The fences below','line_number':1292,'multiline':False]['text':' ensure that the compiler does not move the stores to Ptr in between the','line_number':1293,'multiline':False]['text':' stores to the other fields.','line_number':1294,'multiline':False]['text':' Allocations of size 0 will have stashed the tag in the first byte of','line_number':1383,'multiline':False]['text':' the chunk, see storeEndMarker().','line_number':1384,'multiline':False]['text':' For UAF we only consider in-bounds fault addresses because','line_number':1453,'multiline':False]['text':' out-of-bounds UAF is rare and attempting to detect it is very likely','line_number':1454,'multiline':False]['text':' to result in false positives.','line_number':1455,'multiline':False]['text':' Ring buffer OOB is only possible with secondary allocations. In this','line_number':1459,'multiline':False]['text':' case we are guaranteed a guard region of at least a page on either','line_number':1460,'multiline':False]['text':' side of the allocation (guard page on the right, guard page + tagged','line_number':1461,'multiline':False]['text':' region on the left), so ignore any faults outside of that range.','line_number':1462,'multiline':False]['text':' For UAF the ring buffer will contain two entries, one for the','line_number':1467,'multiline':False]['text':' allocation and another for the deallocation. Don't report buffer','line_number':1468,'multiline':False]['text':' overflow/underflow using the allocation entry if we have already','line_number':1469,'multiline':False]['text':' collected a report from the deallocation entry.','line_number':1470,'multiline':False]['text':'Addr=','line_number':1524,'multiline':True]['text':' namespace scudo','line_number':1552,'multiline':False]['text':' SCUDO_COMBINED_H_','line_number':1554,'multiline':False]