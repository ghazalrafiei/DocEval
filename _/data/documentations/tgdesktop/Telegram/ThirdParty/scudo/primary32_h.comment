['text':'===-- primary32.h ---------------------------------------------*- C++ -*-===//','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.','line_number':3,'multiline':False]['text':' See https://llvm.org/LICENSE.txt for license information.','line_number':4,'multiline':False]['text':' SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'===----------------------------------------------------------------------===//','line_number':7,'multiline':False]['text':' SizeClassAllocator32 is an allocator for 32 or 64-bit address space.','line_number':25,'multiline':False]['text':'','line_number':26,'multiline':False]['text':' It maps Regions of 2^RegionSizeLog bytes aligned on a 2^RegionSizeLog bytes','line_number':27,'multiline':False]['text':' boundary, and keeps a bytemap of the mappable address space to track the size','line_number':28,'multiline':False]['text':' class they are associated with.','line_number':29,'multiline':False]['text':'','line_number':30,'multiline':False]['text':' Mapped regions are split into equally sized Blocks according to the size','line_number':31,'multiline':False]['text':' class they belong to, and the associated pointers are shuffled to prevent any','line_number':32,'multiline':False]['text':' predictable address pattern (the predictability increases with the block','line_number':33,'multiline':False]['text':' size).','line_number':34,'multiline':False]['text':'','line_number':35,'multiline':False]['text':' Regions for size class 0 are special and used to hold TransferBatches, which','line_number':36,'multiline':False]['text':' allow to transfer arrays of pointers from the global size class freelist to','line_number':37,'multiline':False]['text':' the thread specific freelist for said class, and back.','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':' Memory used by this allocator is never unmapped but can be partially','line_number':40,'multiline':False]['text':' reclaimed if the platform allows for it.','line_number':41,'multiline':False]['text':' The bytemap can only track UINT8_MAX - 1 classes.','line_number':48,'multiline':False]['text':' Regions should be large enough to hold the largest Block.','line_number':50,'multiline':False]['text':' Sci->MaxRegionIndex is already initialized to 0.','line_number':84,'multiline':False]['text':' When all blocks are freed, it has to be the same size as `AllocatedUser`.','line_number':118,'multiline':False]['text':' `BatchGroup` and `TransferBatch` also use the blocks from BatchClass.','line_number':120,'multiline':False]['text':' We have to count BatchClassUsedInFreeLists in other regions first.','line_number':123,'multiline':False]['text':' `BG::Batches` are `TransferBatches`. +1 for `BatchGroup`.','line_number':130,'multiline':False]['text':' `BatchGroup` with empty freelist doesn't have `TransferBatch` record','line_number':149,'multiline':False]['text':' itself.','line_number':150,'multiline':False]['text':' if `populateFreeList` succeeded, we are supposed to get free blocks.','line_number':199,'multiline':False]['text':' Push the array of free blocks to the designated batch group.','line_number':205,'multiline':False]['text':' TODO(chiahungduan): Consider not doing grouping if the group size is not','line_number':217,'multiline':False]['text':' greater than the block size with a certain scale.','line_number':218,'multiline':False]['text':' Sort the blocks so that blocks belonging to the same group can be pushed','line_number':220,'multiline':False]['text':' together.','line_number':221,'multiline':False]['text':' The BatchClassId must be locked last since other classes can use it.','line_number':241,'multiline':False]['text':' TODO: The call of `iterateOverBlocks` requires disabling','line_number':267,'multiline':False]['text':' SizeClassAllocator32. We may consider locking each region on demand','line_number':268,'multiline':False]['text':' only.','line_number':269,'multiline':False]['text':' SizeClassAllocator32 is disabled, i.e., ByteMapMutex is held.','line_number':277,'multiline':False]['text':' TODO(kostyak): get the RSS per region.','line_number':293,'multiline':False]['text':' Not supported by the Primary, but not an error either.','line_number':322,'multiline':False]['text':' TODO: Once we have separate locks like primary64, we may consider using','line_number':328,'multiline':False]['text':' tryLock() as well.','line_number':329,'multiline':False]['text':' Lowest & highest region index allocated for this size class, to avoid','line_number':384,'multiline':False]['text':' looping through the whole NumRegions.','line_number':385,'multiline':False]['text':' Sci->Mutex is held by the caller, updating the Min/Max is safe.','line_number':439,'multiline':False]['text':' Free blocks are recorded by TransferBatch in freelist for all','line_number':460,'multiline':False]['text':' size-classes. In addition, TransferBatch is allocated from BatchClassId.','line_number':461,'multiline':False]['text':' In order not to use additional block to record the free blocks in','line_number':462,'multiline':False]['text':' BatchClassId, they are self-contained. I.e., A TransferBatch records the','line_number':463,'multiline':False]['text':' block address of itself. See the figure below:','line_number':464,'multiline':False]['text':'','line_number':465,'multiline':False]['text':' TransferBatch at 0xABCD','line_number':466,'multiline':False]['text':' +----------------------------+','line_number':467,'multiline':False]['text':' | Free blocks' addr          |','line_number':468,'multiline':False]['text':' | +------+------+------+     |','line_number':469,'multiline':False]['text':' | |0xABCD|...   |...   |     |','line_number':470,'multiline':False]['text':' | +------+------+------+     |','line_number':471,'multiline':False]['text':' +----------------------------+','line_number':472,'multiline':False]['text':'','line_number':473,'multiline':False]['text':' When we allocate all the free blocks in the TransferBatch, the block used','line_number':474,'multiline':False]['text':' by TransferBatch is also free for use. We don't need to recycle the','line_number':475,'multiline':False]['text':' TransferBatch. Note that the correctness is maintained by the invariant,','line_number':476,'multiline':False]['text':'','line_number':477,'multiline':False]['text':'   The unit of each popBatch() request is entire TransferBatch. Return','line_number':478,'multiline':False]['text':'   part of the blocks in a TransferBatch is invalid.','line_number':479,'multiline':False]['text':'','line_number':480,'multiline':False]['text':' This ensures that TransferBatch won't leak the address itself while it's','line_number':481,'multiline':False]['text':' still holding other valid data.','line_number':482,'multiline':False]['text':'','line_number':483,'multiline':False]['text':' Besides, BatchGroup is also allocated from BatchClassId and has its','line_number':484,'multiline':False]['text':' address recorded in the TransferBatch too. To maintain the correctness,','line_number':485,'multiline':False]['text':'','line_number':486,'multiline':False]['text':'   The address of BatchGroup is always recorded in the last TransferBatch','line_number':487,'multiline':False]['text':'   in the freelist (also imply that the freelist should only be','line_number':488,'multiline':False]['text':'   updated with push_front). Once the last TransferBatch is popped,','line_number':489,'multiline':False]['text':'   the block used by BatchGroup is also free for use.','line_number':490,'multiline':False]['text':'','line_number':491,'multiline':False]['text':' With this approach, the blocks used by BatchGroup and TransferBatch are','line_number':492,'multiline':False]['text':' reusable and don't need additional space for them.','line_number':493,'multiline':False]['text':' Construct `BatchGroup` on the last element.','line_number':499,'multiline':False]['text':' BatchClass hasn't enabled memory group. Use `0` to indicate there's no','line_number':504,'multiline':False]['text':' memory group here.','line_number':505,'multiline':False]['text':' `BG` is also the block of BatchClassId. Note that this is different','line_number':507,'multiline':False]['text':' from `CreateGroup` in `pushBlocksImpl`','line_number':508,'multiline':False]['text':' This happens under 2 cases.','line_number':520,'multiline':False]['text':'   1. just allocated a new `BatchGroup`.','line_number':521,'multiline':False]['text':'   2. Only 1 block is pushed when the freelist is empty.','line_number':522,'multiline':False]['text':' Construct the `TransferBatch` on the last element.','line_number':524,'multiline':False]['text':' As mentioned above, addresses of `TransferBatch` and `BatchGroup` are','line_number':528,'multiline':False]['text':' recorded in the TransferBatch.','line_number':529,'multiline':False]['text':' `TB` is also the block of BatchClassId.','line_number':535,'multiline':False]['text':' Self-contained','line_number':550,'multiline':False]['text':' TODO(chiahungduan): Avoid the use of push_back() in `Batches` of','line_number':553,'multiline':False]['text':' BatchClassId.','line_number':554,'multiline':False]['text':' `UnusedSlots` is u16 so the result will be also fit in u16.','line_number':558,'multiline':False]['text':' Push the blocks to their batch group. The layout will be like,','line_number':566,'multiline':False]['text':'','line_number':567,'multiline':False]['text':' FreeListInfo.BlockList - > BG -> BG -> BG','line_number':568,'multiline':False]['text':'                            |     |     |','line_number':569,'multiline':False]['text':'                            v     v     v','line_number':570,'multiline':False]['text':'                            TB    TB    TB','line_number':571,'multiline':False]['text':'                            |','line_number':572,'multiline':False]['text':'                            v','line_number':573,'multiline':False]['text':'                            TB','line_number':574,'multiline':False]['text':'','line_number':575,'multiline':False]['text':' Each BlockGroup(BG) will associate with unique group id and the free blocks','line_number':576,'multiline':False]['text':' are managed by a list of TransferBatch(TB). To reduce the time of inserting','line_number':577,'multiline':False]['text':' blocks, BGs are sorted and the input `Array` are supposed to be sorted so','line_number':578,'multiline':False]['text':' that we can get better performance of maintaining sorted property.','line_number':579,'multiline':False]['text':' Use `SameGroup=true` to indicate that all blocks in the array are from the','line_number':580,'multiline':False]['text':' same group then we will skip checking the group id of each block.','line_number':581,'multiline':False]['text':'','line_number':582,'multiline':False]['text':' The region mutex needs to be held while calling this method.','line_number':583,'multiline':False]['text':' `UnusedSlots` is u16 so the result will be also fit in u16.','line_number':623,'multiline':False]['text':' In the following, `Cur` always points to the BatchGroup for blocks that','line_number':635,'multiline':False]['text':' will be pushed next. `Prev` is the element right before `Cur`.','line_number':636,'multiline':False]['text':' All the blocks are from the same group, just push without checking group','line_number':654,'multiline':False]['text':' id.','line_number':655,'multiline':False]['text':' The blocks are sorted by group id. Determine the segment of group and','line_number':664,'multiline':False]['text':' push them to their group together.','line_number':665,'multiline':False]['text':' Pop one TransferBatch from a BatchGroup. The BatchGroup with the smallest','line_number':694,'multiline':False]['text':' group id will be considered first.','line_number':695,'multiline':False]['text':'','line_number':696,'multiline':False]['text':' The region mutex needs to be held while calling this method.','line_number':697,'multiline':False]['text':' Block used by `BatchGroup` is from BatchClassId. Turn the block into','line_number':711,'multiline':False]['text':' `TransferBatch` with single block.','line_number':712,'multiline':False]['text':' We don't keep BatchGroup with zero blocks to avoid empty-checking while','line_number':730,'multiline':False]['text':' allocating. Note that block used by constructing BatchGroup is recorded','line_number':731,'multiline':False]['text':' as free blocks in the last element of BatchGroup::Batches. Which means,','line_number':732,'multiline':False]['text':' once we pop the last TransferBatch, the block is implicitly','line_number':733,'multiline':False]['text':' deallocated.','line_number':734,'multiline':False]['text':' If the size-class currently has a region associated to it, use it. The','line_number':747,'multiline':False]['text':' newly created blocks will be located after the currently allocated memory','line_number':748,'multiline':False]['text':' for that region (up to RegionSize). Otherwise, create a new region, where','line_number':749,'multiline':False]['text':' the new blocks will be carved from the beginning.','line_number':750,'multiline':False]['text':' The maximum number of blocks we should carve in the region is dictated','line_number':768,'multiline':False]['text':' by the maximum number of batches we want to fill, and the amount of','line_number':769,'multiline':False]['text':' memory left in the current region (we use the lowest of the two). This','line_number':770,'multiline':False]['text':' will not be 0 as we ensure that a region can at least hold one block (via','line_number':771,'multiline':False]['text':' static_assert and at the end of this function).','line_number':772,'multiline':False]['text':' Fill the transfer batches and put them in the size-class freelist. We','line_number':780,'multiline':False]['text':' need to randomize the blocks for security purposes, so we first fill a','line_number':781,'multiline':False]['text':' local array that we then shuffle before populating the batches.','line_number':782,'multiline':False]['text':'SameGroup=','line_number':797,'multiline':True]['text':'SameGroup=','line_number':807,'multiline':True]['text':' Note that `PushedBlocks` and `PoppedBlocks` are supposed to only record','line_number':812,'multiline':False]['text':' the requests from `PushBlocks` and `PopBatch` which are external','line_number':813,'multiline':False]['text':' interfaces. `populateFreeList` is the internal interface so we should set','line_number':814,'multiline':False]['text':' the values back to avoid incorrectly setting the stats.','line_number':815,'multiline':False]['text':' If there is not enough room in the region currently associated to fit','line_number':821,'multiline':False]['text':' more blocks, we deassociate the region by resetting CurrentRegion and','line_number':822,'multiline':False]['text':' CurrentRegionAllocated. Otherwise, update the allocated amount.','line_number':823,'multiline':False]['text':' Always update `BytesInFreeListAtLastCheckpoint` with the smallest value','line_number':877,'multiline':False]['text':' so that we won't underestimate the releasable pages. For example, the','line_number':878,'multiline':False]['text':' following is the region usage,','line_number':879,'multiline':False]['text':'','line_number':880,'multiline':False]['text':'  BytesInFreeListAtLastCheckpoint   AllocatedUser','line_number':881,'multiline':False]['text':'                v                         v','line_number':882,'multiline':False]['text':'  |--------------------------------------->','line_number':883,'multiline':False]['text':'         ^                   ^','line_number':884,'multiline':False]['text':'  BytesInFreeList     ReleaseThreshold','line_number':885,'multiline':False]['text':'','line_number':886,'multiline':False]['text':' In general, if we have collected enough bytes and the amount of free','line_number':887,'multiline':False]['text':' bytes meets the ReleaseThreshold, we will try to do page release. If we','line_number':888,'multiline':False]['text':' don't update `BytesInFreeListAtLastCheckpoint` when the current','line_number':889,'multiline':False]['text':' `BytesInFreeList` is smaller, we may take longer time to wait for enough','line_number':890,'multiline':False]['text':' freed blocks because we miss the bytes between','line_number':891,'multiline':False]['text':' (BytesInFreeListAtLastCheckpoint - BytesInFreeList).','line_number':892,'multiline':False]['text':' Releasing smaller blocks is expensive, so we want to make sure that a','line_number':900,'multiline':False]['text':' significant amount of bytes are free, and that there has been a good','line_number':901,'multiline':False]['text':' amount of batches pushed to the freelist before attempting to release.','line_number':902,'multiline':False]['text':' The constant 8 here is selected from profiling some apps and the number','line_number':912,'multiline':False]['text':' of unreleased pages in the large size classes is around 16 pages or','line_number':913,'multiline':False]['text':' more. Choose half of it as a heuristic and which also avoids page','line_number':914,'multiline':False]['text':' release every time for every pushBlocks() attempt by large blocks.','line_number':915,'multiline':False]['text':' Memory was returned recently.','line_number':922,'multiline':False]['text':' if (ReleaseType == ReleaseToOS::Normal)','line_number':926,'multiline':False]['text':'ReleaseSize=','line_number':941,'multiline':True]['text':' The `GroupSize` may not be divided by `BlockSize`, which means there is','line_number':948,'multiline':False]['text':' an unused space at the end of Region. Exclude that space to avoid','line_number':949,'multiline':False]['text':' unused page map entry.','line_number':950,'multiline':False]['text':' TransferBatches are pushed in front of BG.Batches. The first one may','line_number':957,'multiline':False]['text':' not have all caches used.','line_number':958,'multiline':False]['text':' Given the randomness property, we try to release the pages only if the','line_number':972,'multiline':False]['text':' bytes used by free blocks exceed certain proportion of allocated','line_number':973,'multiline':False]['text':' spaces.','line_number':974,'multiline':False]['text':' TODO: Consider updating this after page release if `ReleaseRecorder`','line_number':980,'multiline':False]['text':' can tell the releasd bytes in each group.','line_number':981,'multiline':False]['text':' Note that we don't always visit blocks in each BatchGroup so that we','line_number':998,'multiline':False]['text':' may miss the chance of releasing certain pages that cross','line_number':999,'multiline':False]['text':' BatchGroups.','line_number':1000,'multiline':False]['text':'MayContainLastBlockInRegion=','line_number':1003,'multiline':True]['text':' We may not be able to do the page release In a rare case that we may','line_number':1006,'multiline':False]['text':' fail on PageMap allocation.','line_number':1007,'multiline':False]['text':' Track the regions in use, 0 is unused, otherwise store ClassId + 1.','line_number':1035,'multiline':False]['text':' Unless several threads request regions simultaneously from different size','line_number':1038,'multiline':False]['text':' classes, the stash rarely contains more than 1 entry.','line_number':1039,'multiline':False]['text':' namespace scudo','line_number':1046,'multiline':False]['text':' SCUDO_PRIMARY32_H_','line_number':1048,'multiline':False]