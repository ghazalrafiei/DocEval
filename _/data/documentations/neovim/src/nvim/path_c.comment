['text':' path_is_url() has found ":/"','line_number':38,'multiline':False]['text':' path_is_url() has found ":\\"','line_number':39,'multiline':False]['text':'/ Compare two file names.','line_number':50,'multiline':False]['text':'/','line_number':51,'multiline':False]['text':'/ @param s1 First file name. Environment variables in this name will be','line_number':52,'multiline':False]['text':'/   expanded.','line_number':53,'multiline':False]['text':'/ @param s2 Second file name.','line_number':54,'multiline':False]['text':'/ @param checkname When both files don't exist, only compare their names.','line_number':55,'multiline':False]['text':'/ @param expandenv Whether to expand environment variables in file names.','line_number':56,'multiline':False]['text':'/ @return Enum of type FileComparison. @see FileComparison.','line_number':57,'multiline':False]['text':' If os_fileid() doesn't work, may compare the names.','line_number':75,'multiline':False]['text':'/ Gets the tail (filename segment) of path `fname`.','line_number':94,'multiline':False]['text':'/','line_number':95,'multiline':False]['text':'/ Examples:','line_number':96,'multiline':False]['text':'/ - "dir/file.txt" => "file.txt"','line_number':97,'multiline':False]['text':'/ - "file.txt" => "file.txt"','line_number':98,'multiline':False]['text':'/ - "dir/" => ""','line_number':99,'multiline':False]['text':'/','line_number':100,'multiline':False]['text':'/ @return pointer just past the last path separator (empty string, if fname','line_number':101,'multiline':False]['text':'/         ends in a slash), or empty string if fname is NULL.','line_number':102,'multiline':False]['text':' Find last part of path.','line_number':112,'multiline':False]['text':'/ Get pointer to tail of "fname", including path separators.','line_number':122,'multiline':False]['text':'/','line_number':123,'multiline':False]['text':'/ Takes care of "c:/" and "//". That means `path_tail_with_sep("dir///file.txt")`','line_number':124,'multiline':False]['text':'/ will return a pointer to `"///file.txt"`.','line_number':125,'multiline':False]['text':'/ @param fname A file path. (Must be != NULL.)','line_number':126,'multiline':False]['text':'/ @return','line_number':127,'multiline':False]['text':'/   - Pointer to the last path separator of `fname`, if there is any.','line_number':128,'multiline':False]['text':'/   - `fname` if it contains no path separator.','line_number':129,'multiline':False]['text':'/   - Never NULL.','line_number':130,'multiline':False]['text':' Don't remove the '/' from "c:/file".','line_number':135,'multiline':False]['text':'/ Finds the path tail (or executable) in an invocation.','line_number':144,'multiline':False]['text':'/','line_number':145,'multiline':False]['text':'/ @param[in]  invocation A program invocation in the form:','line_number':146,'multiline':False]['text':'/                        "path/to/exe [args]".','line_number':147,'multiline':False]['text':'/ @param[out] len Stores the length of the executable name.','line_number':148,'multiline':False]['text':'/','line_number':149,'multiline':False]['text':'/ @post if `len` is not null, stores the length of the executable name.','line_number':150,'multiline':False]['text':'/','line_number':151,'multiline':False]['text':'/ @return The position of the last path separator + 1.','line_number':152,'multiline':False]['text':' Now tail points one past the separator.','line_number':162,'multiline':False]['text':'/ Get the next path component of a path name.','line_number':173,'multiline':False]['text':'/','line_number':174,'multiline':False]['text':'/ @param fname A file path. (Must be != NULL.)','line_number':175,'multiline':False]['text':'/ @return Pointer to first found path separator + 1.','line_number':176,'multiline':False]['text':'/ An empty string, if `fname` doesn't contain a path separator,','line_number':177,'multiline':False]['text':'/ Returns the length of the path head on the current platform.','line_number':190,'multiline':False]['text':'/ @return','line_number':191,'multiline':False]['text':'/   - 3 on windows','line_number':192,'multiline':False]['text':'/   - 1 otherwise','line_number':193,'multiline':False]['text':'/ Returns true if path begins with characters denoting the head of a path','line_number':203,'multiline':False]['text':'/ (e.g. '/' on linux and 'D:' on windows).','line_number':204,'multiline':False]['text':'/ @param path The path to be checked.','line_number':205,'multiline':False]['text':'/ @return','line_number':206,'multiline':False]['text':'/   - True if path begins with a path head','line_number':207,'multiline':False]['text':'/   - False otherwise','line_number':208,'multiline':False]['text':'/ Get a pointer to one character past the head of a path name.','line_number':218,'multiline':False]['text':'/ Unix: after "/"; Win: after "c:\"','line_number':219,'multiline':False]['text':'/ If there is no head, path is returned.','line_number':220,'multiline':False]['text':' May skip "c:"','line_number':226,'multiline':False]['text':'/ Return true if 'c' is a path separator.','line_number':239,'multiline':False]['text':'/ Note that for MS-Windows this includes the colon.','line_number':240,'multiline':False]['text':' Unix has ':' inside file names','line_number':244,'multiline':False]['text':' Like vim_ispathsep(c), but exclude the colon for MS-Windows.','line_number':254,'multiline':False]['text':'/ return true if 'c' is a path list separator.','line_number':264,'multiline':False]['text':' might not be right for every system...','line_number':270,'multiline':False]['text':'/ Shorten the path of a file from "~/foo/../.bar/fname" to "~/f/../.b/fname"','line_number':274,'multiline':False]['text':'/ "trim_len" specifies how many characters to keep for each directory.','line_number':275,'multiline':False]['text':'/ Must be 1 or more.','line_number':276,'multiline':False]['text':'/ It's done in-place.','line_number':277,'multiline':False]['text':' copy the whole tail','line_number':285,'multiline':False]['text':' copy '/' and next char','line_number':290,'multiline':False]['text':' copy next char','line_number':295,'multiline':False]['text':' and leading "~" and "."','line_number':296,'multiline':False]['text':' only count word chars for the size','line_number':297,'multiline':False]['text':' keep copying chars until we have our preferred length (or','line_number':298,'multiline':False]['text':' until the above if/else branches move us along)','line_number':299,'multiline':False]['text':'/ Shorten the path of a file from "~/foo/../.bar/fname" to "~/f/../.b/fname"','line_number':312,'multiline':False]['text':'/ It's done in-place.','line_number':313,'multiline':False]['text':'/ Return true if the directory of "fname" exists, false otherwise.','line_number':319,'multiline':False]['text':'/ Also returns true if there is no directory name.','line_number':320,'multiline':False]['text':'/ "fname" must be writable!.','line_number':321,'multiline':False]['text':'/ Compare two file names','line_number':335,'multiline':False]['text':'/','line_number':336,'multiline':False]['text':'/ On some systems case in a file name does not matter, on others it does.','line_number':337,'multiline':False]['text':'/','line_number':338,'multiline':False]['text':'/ @note Does not account for maximum name lengths and things like "../dir",','line_number':339,'multiline':False]['text':'/       thus it is not 100% accurate. OS may also use different algorithm for','line_number':340,'multiline':False]['text':'/       case-insensitive comparison.','line_number':341,'multiline':False]['text':'/','line_number':342,'multiline':False]['text':'/ Handles '/' and '\\' correctly and deals with &fileignorecase option.','line_number':343,'multiline':False]['text':'/','line_number':344,'multiline':False]['text':'/ @param[in]  fname1  First file name.','line_number':345,'multiline':False]['text':'/ @param[in]  fname2  Second file name.','line_number':346,'multiline':False]['text':'/','line_number':347,'multiline':False]['text':'/ @return 0 if they are equal, non-zero otherwise.','line_number':348,'multiline':False]['text':'/ Compare two file names','line_number':361,'multiline':False]['text':'/','line_number':362,'multiline':False]['text':'/ Handles '/' and '\\' correctly and deals with &fileignorecase option.','line_number':363,'multiline':False]['text':'/','line_number':364,'multiline':False]['text':'/ @param[in]  fname1  First file name.','line_number':365,'multiline':False]['text':'/ @param[in]  fname2  Second file name.','line_number':366,'multiline':False]['text':'/ @param[in]  len  Compare at most len bytes.','line_number':367,'multiline':False]['text':'/','line_number':368,'multiline':False]['text':'/ @return 0 if they are equal, non-zero otherwise.','line_number':369,'multiline':False]['text':'/ Append fname2 to fname1','line_number':400,'multiline':False]['text':'/','line_number':401,'multiline':False]['text':'/ @param[in]  fname1  First fname to append to.','line_number':402,'multiline':False]['text':'/ @param[in]  len1    Length of fname1.','line_number':403,'multiline':False]['text':'/ @param[in]  fname2  Second part of the file name.','line_number':404,'multiline':False]['text':'/ @param[in]  len2    Length of fname2.','line_number':405,'multiline':False]['text':'/ @param[in]  sep     If true and fname1 does not end with a path separator,','line_number':406,'multiline':False]['text':'/                     add a path separator before fname2.','line_number':407,'multiline':False]['text':'/','line_number':408,'multiline':False]['text':'/ @return fname1','line_number':409,'multiline':False]['text':'/ Concatenate file names fname1 and fname2 into allocated memory.','line_number':424,'multiline':False]['text':'/','line_number':425,'multiline':False]['text':'/ Only add a '/' or '\\' when 'sep' is true and it is necessary.','line_number':426,'multiline':False]['text':'/','line_number':427,'multiline':False]['text':'/ @param fname1 is the first part of the path or filename','line_number':428,'multiline':False]['text':'/ @param fname2 is the second half of the path or filename','line_number':429,'multiline':False]['text':'/ @param sep    is a flag to indicate a path separator should be added','line_number':430,'multiline':False]['text':'/               if necessary','line_number':431,'multiline':False]['text':'/ @return [allocated] Concatenation of fname1 and fname2.','line_number':432,'multiline':False]['text':'/ Concatenate file names fname1 and fname2','line_number':443,'multiline':False]['text':'/','line_number':444,'multiline':False]['text':'/ Like concat_fnames(), but in place of allocating new memory it reallocates','line_number':445,'multiline':False]['text':'/ fname1. For this reason fname1 must be allocated with xmalloc, and can no','line_number':446,'multiline':False]['text':'/ longer be used after running concat_fnames_realloc.','line_number':447,'multiline':False]['text':'/','line_number':448,'multiline':False]['text':'/ @param fname1 is the first part of the path or filename','line_number':449,'multiline':False]['text':'/ @param fname2 is the second half of the path or filename','line_number':450,'multiline':False]['text':'/ @param sep    is a flag to indicate a path separator should be added','line_number':451,'multiline':False]['text':'/               if necessary','line_number':452,'multiline':False]['text':'/ @return [allocated] Concatenation of fname1 and fname2.','line_number':453,'multiline':False]['text':'/ Adds a path separator to a filename, unless it already ends in one.','line_number':463,'multiline':False]['text':'/','line_number':464,'multiline':False]['text':'/ @return `true` if the path separator was added or already existed.','line_number':465,'multiline':False]['text':'/         `false` if the filename is too long.','line_number':466,'multiline':False]['text':'/ Get an allocated copy of the full path to a file.','line_number':481,'multiline':False]['text':'/','line_number':482,'multiline':False]['text':'/ @param fname is the filename to save','line_number':483,'multiline':False]['text':'/ @param force is a flag to expand `fname` even if it looks absolute','line_number':484,'multiline':False]['text':'/','line_number':485,'multiline':False]['text':'/ @return [allocated] Copy of absolute path to `fname` or NULL when','line_number':486,'multiline':False]['text':'/                     `fname` is NULL.','line_number':487,'multiline':False]['text':'/ Saves the absolute path.','line_number':503,'multiline':False]['text':'/ @param name An absolute or relative path.','line_number':504,'multiline':False]['text':'/ @return The absolute path of `name`.','line_number':505,'multiline':False]['text':'/ Checks if a path has a wildcard character including '~', unless at the end.','line_number':515,'multiline':False]['text':'/ @param p  The path to expand.','line_number':516,'multiline':False]['text':'/ @returns Unix: True if it contains one of "?[{`'$".','line_number':517,'multiline':False]['text':'/ @returns Windows: True if it contains one of "*?$[".','line_number':518,'multiline':False]['text':' Windows:','line_number':531,'multiline':False]['text':' Unix style wildcard expansion code.','line_number':542,'multiline':False]['text':'/ Checks if a path has a character path_expand can expand.','line_number':548,'multiline':False]['text':'/ @param p  The path to expand.','line_number':549,'multiline':False]['text':'/ @returns Unix: True if it contains one of *?[{.','line_number':550,'multiline':False]['text':'/ @returns Windows: True if it contains one of *?[.','line_number':551,'multiline':False]['text':' Windows.','line_number':564,'multiline':False]['text':'/ Recursively expands one path component into all matching files and/or','line_number':573,'multiline':False]['text':'/ directories. Handles "*", "?", "[a-z]", "**", etc.','line_number':574,'multiline':False]['text':'/ @remark "**" in `path` requests recursive expansion.','line_number':575,'multiline':False]['text':'/','line_number':576,'multiline':False]['text':'/ @param[out] gap  The matches found.','line_number':577,'multiline':False]['text':'/ @param path     The path to search.','line_number':578,'multiline':False]['text':'/ @param flags    Flags for regexp expansion.','line_number':579,'multiline':False]['text':'/   - EW_ICASE: Ignore case.','line_number':580,'multiline':False]['text':'/   - EW_NOERROR: Silence error messages.','line_number':581,'multiline':False]['text':'/   - EW_NOTWILD: Add matches literally.','line_number':582,'multiline':False]['text':'/ @returns the number of matches found.','line_number':583,'multiline':False]['text':' initialize','line_number':593,'multiline':False]['text':'/ Implementation of path_expand().','line_number':605,'multiline':False]['text':'/','line_number':606,'multiline':False]['text':'/ Chars before `path + wildoff` do not get expanded.','line_number':607,'multiline':False]['text':' depth for "**" expansion','line_number':615,'multiline':False]['text':' Expanding "**" may take a long time, check for CTRL-C.','line_number':617,'multiline':False]['text':' Make room for file name.  When doing encoding conversion the actual','line_number':625,'multiline':False]['text':' length may be quite a bit longer, thus use the maximum possible length.','line_number':626,'multiline':False]['text':' Find the first part in the path name that contains a wildcard.','line_number':629,'multiline':False]['text':' When EW_ICASE is set every letter is considered to be a wildcard.','line_number':630,'multiline':False]['text':' Copy it into "buf", including the preceding characters.','line_number':631,'multiline':False]['text':' May ignore a wildcard that has a backslash before it; it will','line_number':637,'multiline':False]['text':' be removed by rem_backslash() or file_pat_to_reg_pat() below.','line_number':638,'multiline':False]['text':' NOLINT(whitespace/parens)','line_number':653,'multiline':False]['text':' Now we have one wildcard component between "s" and "e".','line_number':664,'multiline':False]['text':' Remove backslashes between "wildoff" and the start of the wildcard','line_number':665,'multiline':False]['text':' component.','line_number':666,'multiline':False]['text':' Check for "**" between "s" and "e".','line_number':675,'multiline':False]['text':' convert the file pattern to a regexp pattern','line_number':682,'multiline':False]['text':' compile the regexp into a program','line_number':690,'multiline':False]['text':' Ignore case if given 'wildignorecase', else respect 'fileignorecase'.','line_number':693,'multiline':False]['text':' Always ignore case on Windows.','line_number':696,'multiline':False]['text':' If "**" is by itself, this is the first time we encounter it and more','line_number':713,'multiline':False]['text':' is following then find matches without any directory.','line_number':714,'multiline':False]['text':' Find all matching entries.','line_number':727,'multiline':False]['text':' initialize','line_number':729,'multiline':False]['text':' For "**" in the pattern first go deeper in the tree to','line_number':743,'multiline':False]['text':' find matches.','line_number':744,'multiline':False]['text':' NOLINT','line_number':745,'multiline':False]['text':' handle more wildcards','line_number':753,'multiline':False]['text':' need to expand another component of the path','line_number':754,'multiline':False]['text':' remove backslashes for the remaining components only','line_number':755,'multiline':False]['text':' no more wildcards, check if there is a match','line_number':760,'multiline':False]['text':' remove backslashes for the remaining components only','line_number':761,'multiline':False]['text':' add existing file or symbolic link','line_number':765,'multiline':False]['text':' When interrupted the matches probably won't be used and sorting can be','line_number':780,'multiline':False]['text':' slow, thus skip it.','line_number':781,'multiline':False]['text':' Moves "*psep" back to the previous path separator in "path".','line_number':790,'multiline':False]['text':' Returns FAIL is "*psep" ends up at the beginning of "path".','line_number':791,'multiline':False]['text':' skip the current separator','line_number':794,'multiline':False]['text':' find the previous separator','line_number':799,'multiline':False]['text':'/ Returns true if "maybe_unique" is unique wrt other_paths in "gap".','line_number':810,'multiline':False]['text':'/ "maybe_unique" is the end portion of "((char **)gap->ga_data)[i]".','line_number':811,'multiline':False]['text':' don't compare it with itself','line_number':818,'multiline':False]['text':' it's different when it's shorter','line_number':823,'multiline':False]['text':' match','line_number':828,'multiline':False]['text':' no match found','line_number':831,'multiline':False]['text':' Split the 'path' option into an array of strings in garray_T.  Relative','line_number':834,'multiline':False]['text':' paths are expanded to their equivalent fullpath.  This includes the "."','line_number':835,'multiline':False]['text':' (relative to current buffer directory) and empty path (relative to current','line_number':836,'multiline':False]['text':' directory) notations.','line_number':837,'multiline':False]['text':'','line_number':838,'multiline':False]['text':' TODO(vim): handle upward search (;) and path limiter (**N) notations by','line_number':839,'multiline':False]['text':' expanding each into their equivalent path(s).','line_number':840,'multiline':False]['text':' Relative to current buffer:','line_number':850,'multiline':False]['text':' "/path/file" + "." -> "/path/"','line_number':851,'multiline':False]['text':' "/path/file"  + "./subdir" -> "/path/subdir"','line_number':852,'multiline':False]['text':' relative to current directory','line_number':869,'multiline':False]['text':' URL can't be used here','line_number':871,'multiline':False]['text':' Expand relative path to their full path equivalent','line_number':873,'multiline':False]['text':' Returns a pointer to the file or directory name in "fname" that matches the','line_number':890,'multiline':False]['text':' longest path in "ga"p, or NULL if there is no match. For example:','line_number':891,'multiline':False]['text':'','line_number':892,'multiline':False]['text':'    path: /foo/bar/baz','line_number':893,'multiline':False]['text':'   fname: /foo/bar/baz/quux.txt','line_number':894,'multiline':False]['text':' returns:              ^this','line_number':895,'multiline':False]['text':' NOLINT(whitespace/parens)','line_number':909,'multiline':False]['text':' skip to the file or directory name','line_number':919,'multiline':False]['text':'/ Sorts, removes duplicates and modifies all the fullpath names in "gap" so','line_number':929,'multiline':False]['text':'/ that they are unique with respect to each other while conserving the part','line_number':930,'multiline':False]['text':'/ that matches the pattern. Beware, this is at least O(n^2) wrt "gap->ga_len".','line_number':931,'multiline':False]['text':' We need to prepend a '*' at the beginning of file_pattern so that the','line_number':944,'multiline':False]['text':' regex matches anywhere in the path. FIXME: is this valid for all','line_number':945,'multiline':False]['text':' possible patterns?','line_number':946,'multiline':False]['text':' always ignore case','line_number':958,'multiline':False]['text':' Shorten the filename while maintaining its uniqueness','line_number':985,'multiline':False]['text':' Don't assume all files can be reached without path when search','line_number':988,'multiline':False]['text':' pattern starts with **/, so only remove path_cutoff','line_number':989,'multiline':False]['text':' when possible.','line_number':990,'multiline':False]['text':' Here all files can be reached without path, so get shortest','line_number':999,'multiline':False]['text':' unique path.  We start at the end of the path. */','line_number':1000,'multiline':False]['text':' Last resort: shorten relative to curdir if possible.','line_number':1014,'multiline':False]['text':' 'possible' means:','line_number':1015,'multiline':False]['text':' 1. It is under the current directory.','line_number':1016,'multiline':False]['text':' 2. The result is actually shorter than the original.','line_number':1017,'multiline':False]['text':'','line_number':1018,'multiline':False]['text':'     Before                curdir        After','line_number':1019,'multiline':False]['text':'     /foo/bar/file.txt     /foo/bar      ./file.txt','line_number':1020,'multiline':False]['text':'     c:\foo\bar\file.txt   c:\foo\bar    .\file.txt','line_number':1021,'multiline':False]['text':'     /file.txt             /             /file.txt','line_number':1022,'multiline':False]['text':'     c:\file.txt           c:\           .\file.txt','line_number':1023,'multiline':False]['text':' Shorten filenames in /in/current/directory/{filename}','line_number':1034,'multiline':False]['text':' If the {filename} is not unique, change it to ./{filename}.','line_number':1043,'multiline':False]['text':' Else reduce it to {filename}','line_number':1044,'multiline':False]['text':'/ Find end of the directory name','line_number':1078,'multiline':False]['text':'/','line_number':1079,'multiline':False]['text':'/ @param[in]  fname  File name to process.','line_number':1080,'multiline':False]['text':'/','line_number':1081,'multiline':False]['text':'/ @return end of the directory name, on the first path separator:','line_number':1082,'multiline':False]['text':'/','line_number':1083,'multiline':False]['text':'/            "/path/file", "/path/dir/", "/path//dir", "/file"','line_number':1084,'multiline':False]['text':'/                  ^             ^             ^        ^','line_number':1085,'multiline':False]['text':'/ Calls globpath() with 'path' values for the given pattern and stores the','line_number':1110,'multiline':False]['text':'/ result in "gap".','line_number':1111,'multiline':False]['text':'/ Returns the total number of matches.','line_number':1112,'multiline':False]['text':'/','line_number':1113,'multiline':False]['text':'/ @param flags  EW_* flags','line_number':1114,'multiline':False]['text':'/ Return true if "p" contains what looks like an environment variable.','line_number':1145,'multiline':False]['text':'/ Allowing for escaping.','line_number':1146,'multiline':False]['text':' Return true if "p" contains a special wildcard character, one that Vim','line_number':1161,'multiline':False]['text':' cannot expand, requires using a shell.','line_number':1162,'multiline':False]['text':' Disallow line break characters.','line_number':1166,'multiline':False]['text':' Allow for escaping.','line_number':1170,'multiline':False]['text':' Need a shell for curly braces only when including non-existing files.','line_number':1174,'multiline':False]['text':' A { must be followed by a matching }.','line_number':1178,'multiline':False]['text':' A quote and backtick must be followed by another one.','line_number':1182,'multiline':False]['text':'/ Generic wildcard expansion code.','line_number':1193,'multiline':False]['text':'/','line_number':1194,'multiline':False]['text':'/ Characters in pat that should not be expanded must be preceded with a','line_number':1195,'multiline':False]['text':'/ backslash. E.g., "/path\ with\ spaces/my\*star*".','line_number':1196,'multiline':False]['text':'/','line_number':1197,'multiline':False]['text':'/ @param      num_pat  is number of input patterns.','line_number':1198,'multiline':False]['text':'/ @param      pat      is an array of pointers to input patterns.','line_number':1199,'multiline':False]['text':'/ @param[out] num_file is pointer to number of matched file names.','line_number':1200,'multiline':False]['text':'/ @param[out] file     is pointer to array of pointers to matched file names.','line_number':1201,'multiline':False]['text':'/ @param      flags    is a combination of EW_* flags used in','line_number':1202,'multiline':False]['text':'/                      expand_wildcards().','line_number':1203,'multiline':False]['text':'/','line_number':1204,'multiline':False]['text':'/ @returns             OK when some files were found. *num_file is set to the','line_number':1205,'multiline':False]['text':'/                      number of matches, *file to the allocated array of','line_number':1206,'multiline':False]['text':'/                      matches. Call FreeWild() later.','line_number':1207,'multiline':False]['text':'/                      If FAIL is returned, *num_file and *file are either','line_number':1208,'multiline':False]['text':'/                      unchanged or *num_file is set to 0 and *file is set','line_number':1209,'multiline':False]['text':'/                      to NULL or points to "".','line_number':1210,'multiline':False]['text':' expand_env() is called to expand things like "~user".  If this fails,','line_number':1219,'multiline':False]['text':' it calls ExpandOne(), which brings us back here.  In this case, always','line_number':1220,'multiline':False]['text':' call the machine specific expansion function, if possible.  Otherwise,','line_number':1221,'multiline':False]['text':' return FAIL.','line_number':1222,'multiline':False]['text':' If there are any special wildcard characters which we cannot handle','line_number':1232,'multiline':False]['text':' here, call machine specific function for all the expansion.  This','line_number':1233,'multiline':False]['text':' avoids starting the shell for each argument separately.','line_number':1234,'multiline':False]['text':' For `=expr` do use the internal function.','line_number':1235,'multiline':False]['text':' The matching file names are stored in a growarray.  Init it empty.','line_number':1246,'multiline':False]['text':' First expand environment variables, "~/" and "~user/".','line_number':1263,'multiline':False]['text':' On Unix, if expand_env() can't expand an environment','line_number':1270,'multiline':False]['text':' variable, use the shell to do that.  Discard previously','line_number':1271,'multiline':False]['text':' found file names and start all over again.','line_number':1272,'multiline':False]['text':' If there are wildcards or case-insensitive expansion is','line_number':1285,'multiline':False]['text':' required: Expand file names and add each match to the list.  If','line_number':1286,'multiline':False]['text':' there is no match, and EW_NOTFOUND is given, add the pattern.','line_number':1287,'multiline':False]['text':' Otherwise: Add the file name if it exists or when EW_NOTFOUND is','line_number':1288,'multiline':False]['text':' given.','line_number':1289,'multiline':False]['text':' :find completion where 'path' is used.','line_number':1297,'multiline':False]['text':' Recursiveness is OK here.','line_number':1298,'multiline':False]['text':' When EW_NOTFOUND is used, always add files and dirs.  Makes','line_number':1314,'multiline':False]['text':' "vim c:/" work.','line_number':1315,'multiline':False]['text':'/ Free the list of files returned by expand_wildcards() or other expansion functions.','line_number':1343,'multiline':False]['text':'/ @return  true if we can expand this backtick thing here.','line_number':1355,'multiline':False]['text':'/ Expand an item in `backticks` by executing it as a command.','line_number':1361,'multiline':False]['text':'/ Currently only works when pat[] starts and ends with a `.','line_number':1362,'multiline':False]['text':'/ Returns number of file names found, -1 if an error is encountered.','line_number':1363,'multiline':False]['text':'/','line_number':1364,'multiline':False]['text':'/ @param flags  EW_* flags','line_number':1365,'multiline':False]['text':' Create the command: lop off the backticks.','line_number':1372,'multiline':False]['text':' `={expr}`: Expand expression','line_number':1375,'multiline':False]['text':' skip over white space','line_number':1387,'multiline':False]['text':' skip over entry','line_number':1389,'multiline':False]['text':' add an entry if it is not empty','line_number':1392,'multiline':False]['text':'/ Replace all slashes by backslashes.','line_number':1411,'multiline':False]['text':'/ This used to be the other way around, but MS-DOS sometimes has problems','line_number':1412,'multiline':False]['text':'/ with slashes (e.g. in a command name).  We can't have mixed slashes and','line_number':1413,'multiline':False]['text':'/ backslashes, because comparing file names will not work correctly.  The','line_number':1414,'multiline':False]['text':'/ commands that use a file name should try to avoid the need to type a','line_number':1415,'multiline':False]['text':'/ backslash twice.','line_number':1416,'multiline':False]['text':'/ When 'shellslash' set do it the other way around.','line_number':1417,'multiline':False]['text':'/ When the path looks like a URL leave it unmodified.','line_number':1418,'multiline':False]['text':' don't replace backslash in backtick quoted strings','line_number':1426,'multiline':False]['text':'/ Add a file to a file list.  Accepted flags:','line_number':1442,'multiline':False]['text':'/ EW_DIR      add directories','line_number':1443,'multiline':False]['text':'/ EW_FILE     add files','line_number':1444,'multiline':False]['text':'/ EW_EXEC     add executable files','line_number':1445,'multiline':False]['text':'/ EW_NOTFOUND add even when it doesn't exist','line_number':1446,'multiline':False]['text':'/ EW_ADDSLASH add slash after directory name','line_number':1447,'multiline':False]['text':'/ EW_ALLLINKS add symlink also when the referred file does not exist','line_number':1448,'multiline':False]['text':'/','line_number':1449,'multiline':False]['text':'/ @param f  filename','line_number':1450,'multiline':False]['text':' if the file/dir/link doesn't exist, may not add it','line_number':1456,'multiline':False]['text':' if the file/dir contains illegal characters, don't add it','line_number':1465,'multiline':False]['text':' If the file isn't executable, may not add it.  Do accept directories.','line_number':1476,'multiline':False]['text':' When invoked from expand_shellcmd() do not use $PATH.','line_number':1477,'multiline':False]['text':' Append a slash or backslash after directory names if none is present.','line_number':1489,'multiline':False]['text':' Converts a file name into a canonical form. It simplifies a file name into','line_number':1496,'multiline':False]['text':' its simplest form by stripping out unneeded components, if any.  The','line_number':1497,'multiline':False]['text':' resulting file name is simplified in place and will either be the same','line_number':1498,'multiline':False]['text':' length as that supplied, or shorter.','line_number':1499,'multiline':False]['text':' skip "x:"','line_number':1508,'multiline':False]['text':' remember start after "c:/" or "/" or "///"','line_number':1519,'multiline':False]['text':' At this point "p" is pointing to the char following a single "/"','line_number':1522,'multiline':False]['text':' or "p" is at the "start" of the (absolute or relative) path name.','line_number':1523,'multiline':False]['text':' remove duplicate "/"','line_number':1525,'multiline':False]['text':' keep single "." or leading "./"','line_number':1529,'multiline':False]['text':' Strip "./" or ".///".  If we are at the end of the file name','line_number':1531,'multiline':False]['text':' and there is no trailing path separator, either strip "/." if','line_number':1532,'multiline':False]['text':' we are after "start", or strip "." if we are at the beginning','line_number':1533,'multiline':False]['text':' of an absolute path name.','line_number':1534,'multiline':False]['text':' strip preceding path separator','line_number':1541,'multiline':False]['text':' Skip to after ".." or "../" or "..///".','line_number':1547,'multiline':False]['text':' strip one preceding component','line_number':1553,'multiline':False]['text':' Don't strip for an erroneous file name.','line_number':1556,'multiline':False]['text':' If the preceding component does not exist in the file','line_number':1558,'multiline':False]['text':' system, we strip it.  On Unix, we don't accept a symbolic','line_number':1559,'multiline':False]['text':' link that refers to a non-existent file.','line_number':1560,'multiline':False]['text':' Skip back to after previous '/'.','line_number':1570,'multiline':False]['text':' If the component exists in the file system, check','line_number':1576,'multiline':False]['text':' that stripping it won't change the meaning of the','line_number':1577,'multiline':False]['text':' file name.  First get information about the','line_number':1578,'multiline':False]['text':' unstripped file name.  This may fail if the component','line_number':1579,'multiline':False]['text':' to strip is not a searchable directory (but a regular','line_number':1580,'multiline':False]['text':' file, for instance), since the trailing "/.." cannot','line_number':1581,'multiline':False]['text':' be applied then.  We don't strip it then since we','line_number':1582,'multiline':False]['text':' don't want to replace an erroneous file name by','line_number':1583,'multiline':False]['text':' a valid one, and we disable stripping of later','line_number':1584,'multiline':False]['text':' components.','line_number':1585,'multiline':False]['text':' The check for the unstripped file name','line_number':1595,'multiline':False]['text':' above works also for a symbolic link pointing to','line_number':1596,'multiline':False]['text':' a searchable directory.  But then the parent of','line_number':1597,'multiline':False]['text':' the directory pointed to by the link must be the','line_number':1598,'multiline':False]['text':' same as the stripped file name.  (The latter','line_number':1599,'multiline':False]['text':' exists in the file system since it is the','line_number':1600,'multiline':False]['text':' component's parent directory.)','line_number':1601,'multiline':False]['text':' We don't disable stripping of later','line_number':1614,'multiline':False]['text':' components since the unstripped path name is','line_number':1615,'multiline':False]['text':' still valid.','line_number':1616,'multiline':False]['text':' Skip the ".." or "../" and reset the counter for the','line_number':1623,'multiline':False]['text':' components that might be stripped later on.','line_number':1624,'multiline':False]['text':' Strip previous component.  If the result would get empty','line_number':1628,'multiline':False]['text':' and there is no trailing path separator, leave a single','line_number':1629,'multiline':False]['text':' "." instead.  If we are at the end of the file name and','line_number':1630,'multiline':False]['text':' there is no trailing path separator and a preceding','line_number':1631,'multiline':False]['text':' component is left after stripping, strip its trailing','line_number':1632,'multiline':False]['text':' path separator as well.','line_number':1633,'multiline':False]['text':' strip previous component','line_number':1641,'multiline':False]['text':' leading "/.." or "/../"','line_number':1646,'multiline':False]['text':' strip ".." or "../"','line_number':1647,'multiline':False]['text':' leading "./../"','line_number':1649,'multiline':False]['text':' strip leading "./"','line_number':1650,'multiline':False]['text':' skip to char after ".." or "../"','line_number':1653,'multiline':False]['text':' Simple path component.','line_number':1656,'multiline':False]['text':'/ Return the name of the file ptr[len] in 'path'.','line_number':1676,'multiline':False]['text':'/ Otherwise like file_name_at_cursor().','line_number':1677,'multiline':False]['text':'/','line_number':1678,'multiline':False]['text':'/ @param rel_fname  file we are searching relative to','line_number':1679,'multiline':False]['text':' If the file could not be found in a normal way, try applying','line_number':1704,'multiline':False]['text':' 'includeexpr' (unless done already).','line_number':1705,'multiline':False]['text':' Repeat finding the file "count" times.  This matters when it','line_number':1723,'multiline':False]['text':' appears several times in the path.','line_number':1724,'multiline':False]['text':'/ Checks for a Windows drive letter ("C:/") at the start of the path.','line_number':1742,'multiline':False]['text':'/','line_number':1743,'multiline':False]['text':'/ @see https://url.spec.whatwg.org/#start-with-a-windows-drive-letter','line_number':1744,'multiline':False]['text':' Check if the ":/" of a URL is at the pointer, return URL_SLASH.','line_number':1754,'multiline':False]['text':' Also check for ":\\", which MS Internet Explorer accepts, return','line_number':1755,'multiline':False]['text':' URL_BACKSLASH.','line_number':1756,'multiline':False]['text':' In the spec ':' is enough to recognize a scheme','line_number':1759,'multiline':False]['text':' https://url.spec.whatwg.org/#scheme-state','line_number':1760,'multiline':False]['text':'/ Check if "fname" starts with "name://" or "name:\\".','line_number':1769,'multiline':False]['text':'/','line_number':1770,'multiline':False]['text':'/ @param  fname         is the filename to test','line_number':1771,'multiline':False]['text':'/ @return URL_SLASH for "name://", URL_BACKSLASH for "name:\\", zero otherwise.','line_number':1772,'multiline':False]['text':' We accept alphabetic characters and a dash in scheme part.','line_number':1777,'multiline':False]['text':' RFC 3986 allows for more, but it increases the risk of matching','line_number':1778,'multiline':False]['text':' non-URL text.','line_number':1779,'multiline':False]['text':' first character must be alpha','line_number':1781,'multiline':False]['text':' check body: alpha or dash','line_number':1790,'multiline':False]['text':' check last char is not a dash','line_number':1793,'multiline':False]['text':' ":/" or ":\\" must follow','line_number':1798,'multiline':False]['text':'/ Return true if "name" is a full (absolute) path name or URL.','line_number':1811,'multiline':False]['text':'/ Save absolute file name to "buf[len]".','line_number':1817,'multiline':False]['text':'/','line_number':1818,'multiline':False]['text':'/ @param      fname filename to evaluate','line_number':1819,'multiline':False]['text':'/ @param[out] buf   contains `fname` absolute path, or:','line_number':1820,'multiline':False]['text':'/                   - truncated `fname` if longer than `len`','line_number':1821,'multiline':False]['text':'/                   - unmodified `fname` if absolute path fails or is a URL','line_number':1822,'multiline':False]['text':'/ @param      len   length of `buf`','line_number':1823,'multiline':False]['text':'/ @param      force flag to force expanding even if the path is absolute','line_number':1824,'multiline':False]['text':'/','line_number':1825,'multiline':False]['text':'/ @return           FAIL for failure, OK otherwise','line_number':1826,'multiline':False]['text':' truncate','line_number':1836,'multiline':False]['text':' something failed; use the filename','line_number':1850,'multiline':False]['text':'/ Get the full resolved path for `fname`','line_number':1858,'multiline':False]['text':'/','line_number':1859,'multiline':False]['text':'/ Even filenames that appear to be absolute based on starting from','line_number':1860,'multiline':False]['text':'/ the root may have relative paths (like dir/../subdir) or symlinks','line_number':1861,'multiline':False]['text':'/ embedded, or even extra separators (//).  This function addresses','line_number':1862,'multiline':False]['text':'/ those possibilities, returning a resolved absolute path.','line_number':1863,'multiline':False]['text':'/ For MS-Windows, this also expands names like "longna~1".','line_number':1864,'multiline':False]['text':'/','line_number':1865,'multiline':False]['text':'/ @param fname is the filename to expand','line_number':1866,'multiline':False]['text':'/ @return [allocated] Full path (NULL for failure).','line_number':1867,'multiline':False]['text':' set correct case for file name','line_number':1886,'multiline':False]['text':'/ Set the case of the file name, if it already exists.  This will cause the','line_number':1893,'multiline':False]['text':'/ file name to remain exactly the same.','line_number':1894,'multiline':False]['text':'/ Only required for file systems where case is ignored and preserved.','line_number':1895,'multiline':False]['text':' TODO(SplinterOfChaos): Could also be used when mounting case-insensitive','line_number':1896,'multiline':False]['text':' file systems.','line_number':1897,'multiline':False]['text':' Open the directory where the file is located.','line_number':1906,'multiline':False]['text':' Only accept names that differ in case and are the same byte','line_number':1927,'multiline':False]['text':' length. TODO: accept different length name.','line_number':1928,'multiline':False]['text':' Verify the inode is equal.','line_number':1932,'multiline':False]['text':'/ Return true if "p" points to just after a path separator.','line_number':1948,'multiline':False]['text':'/ Takes care of multi-byte characters.','line_number':1949,'multiline':False]['text':'/ "b" must point to the start of the file name','line_number':1950,'multiline':False]['text':'/ Return true if file names "f1" and "f2" are in the same directory.','line_number':1957,'multiline':False]['text':'/ "f1" may be a short name, "f2" must be a full path.','line_number':1958,'multiline':False]['text':' safety check','line_number':1965,'multiline':False]['text':' Compare path "p[]" to "q[]".','line_number':1977,'multiline':False]['text':' If "maxlen" >= 0 compare "p[maxlen]" to "q[maxlen]"','line_number':1978,'multiline':False]['text':' Return value like strcmp(p, q), but consider path separators.','line_number':1979,'multiline':False]['text':' End of "p": check if "q" also ends or just has a slash.','line_number':1989,'multiline':False]['text':' full match','line_number':1991,'multiline':False]['text':' End of "q": check if "p" just has a slash.','line_number':1999,'multiline':False]['text':' consider '/' and '\\' to be equal','line_number':2007,'multiline':False]['text':' no match','line_number':2019,'multiline':False]['text':' "i" or "j" ran into "maxlen"','line_number':2025,'multiline':False]['text':' ignore a trailing slash, but not "//" or ":/"','line_number':2031,'multiline':False]['text':' match with trailing slash','line_number':2041,'multiline':False]['text':' no match','line_number':2044,'multiline':False]['text':'/ Try to find a shortname by comparing the fullname with the current','line_number':2049,'multiline':False]['text':'/ directory.','line_number':2050,'multiline':False]['text':'/','line_number':2051,'multiline':False]['text':'/ @param full_path The full path of the file.','line_number':2052,'multiline':False]['text':'/ @return','line_number':2053,'multiline':False]['text':'/   - Pointer into `full_path` if shortened.','line_number':2054,'multiline':False]['text':'/   - `full_path` unchanged if no shorter name is possible.','line_number':2055,'multiline':False]['text':'/   - NULL if `full_path` is NULL.','line_number':2056,'multiline':False]['text':'/ Try to find a shortname by comparing the fullname with `dir_name`.','line_number':2072,'multiline':False]['text':'/','line_number':2073,'multiline':False]['text':'/ @param full_path The full path of the file.','line_number':2074,'multiline':False]['text':'/ @param dir_name The directory to shorten relative to.','line_number':2075,'multiline':False]['text':'/ @return','line_number':2076,'multiline':False]['text':'/   - Pointer into `full_path` if shortened.','line_number':2077,'multiline':False]['text':'/   - NULL if no shorter name is possible.','line_number':2078,'multiline':False]['text':' If full_path and dir_name do not match, it's impossible to make one','line_number':2088,'multiline':False]['text':' relative to the other.','line_number':2089,'multiline':False]['text':' If dir_name is a path head, full_path can always be made relative.','line_number':2094,'multiline':False]['text':' If *p is not pointing to a path separator, this means that full_path's','line_number':2101,'multiline':False]['text':' last directory name is longer than *dir_name's last directory, so they','line_number':2102,'multiline':False]['text':' don't actually match.','line_number':2103,'multiline':False]['text':'/ Invoke expand_wildcards() for one pattern','line_number':2111,'multiline':False]['text':'/','line_number':2112,'multiline':False]['text':'/ One should expand items like "%:h" before the expansion.','line_number':2113,'multiline':False]['text':'/','line_number':2114,'multiline':False]['text':'/ @param[in]   pat       Pointer to the input pattern.','line_number':2115,'multiline':False]['text':'/ @param[out]  num_file  Resulting number of files.','line_number':2116,'multiline':False]['text':'/ @param[out]  file      Array of resulting files.','line_number':2117,'multiline':False]['text':'/ @param[in]   flags     Flags passed to expand_wildcards().','line_number':2118,'multiline':False]['text':'/','line_number':2119,'multiline':False]['text':'/ @returns               OK when *file is set to allocated array of matches','line_number':2120,'multiline':False]['text':'/                        and *num_file(can be zero) to the number of matches.','line_number':2121,'multiline':False]['text':'/                        If FAIL is returned, *num_file and *file are either','line_number':2122,'multiline':False]['text':'/                        unchanged or *num_file is set to 0 and *file is set','line_number':2123,'multiline':False]['text':'/                        to NULL or points to "".','line_number':2124,'multiline':False]['text':' Expanding "%" or "#" and the file does not exist: Add the','line_number':2153,'multiline':False]['text':' pattern anyway (without the star) so that this works for remote','line_number':2154,'multiline':False]['text':' files and non-file buffer names.','line_number':2155,'multiline':False]['text':'/ Expand wildcards. Calls gen_expand_wildcards() and removes files matching','line_number':2169,'multiline':False]['text':'/ 'wildignore'.','line_number':2170,'multiline':False]['text':'/','line_number':2171,'multiline':False]['text':'/ @param      num_pat  is number of input patterns.','line_number':2172,'multiline':False]['text':'/ @param      pat      is an array of pointers to input patterns.','line_number':2173,'multiline':False]['text':'/ @param[out] num_file is pointer to number of matched file names.','line_number':2174,'multiline':False]['text':'/ @param[out] file     is pointer to array of pointers to matched file names.','line_number':2175,'multiline':False]['text':'/ @param      flags    is a combination of EW_* flags.','line_number':2176,'multiline':False]['text':'/','line_number':2177,'multiline':False]['text':'/ @returns             OK when *file is set to allocated array of matches','line_number':2178,'multiline':False]['text':'/                      and *num_file (can be zero) to the number of matches.','line_number':2179,'multiline':False]['text':'/                      If FAIL is returned, *num_file and *file are either','line_number':2180,'multiline':False]['text':'/                      unchanged or *num_file is set to 0 and *file is set to','line_number':2181,'multiline':False]['text':'/                      NULL or points to "".','line_number':2182,'multiline':False]['text':' When keeping all matches, return here','line_number':2187,'multiline':False]['text':' Remove names that match 'wildignore'.','line_number':2192,'multiline':False]['text':' check all files in (*files)[]','line_number':2194,'multiline':False]['text':' remove this matching file from the list','line_number':2201,'multiline':False]['text':' Move the names where 'suffixes' match to the end.','line_number':2213,'multiline':False]['text':' Skip when interrupted, the result probably won't be used.','line_number':2214,'multiline':False]['text':' number without matching suffix','line_number':2217,'multiline':False]['text':' Move the name without matching suffix to the front of the list.','line_number':2220,'multiline':False]['text':' Free empty array of matches','line_number':2230,'multiline':False]['text':'/ @return  true if "fname" matches with an entry in 'suffixes'.','line_number':2239,'multiline':False]['text':' maximum length of a file suffix','line_number':2242,'multiline':False]['text':' empty entry: match name without a '.'','line_number':2252,'multiline':False]['text':'/ Get the absolute name of the given relative directory.','line_number':2268,'multiline':False]['text':'/','line_number':2269,'multiline':False]['text':'/ @param directory Directory name, relative to current directory.','line_number':2270,'multiline':False]['text':'/ @return `FAIL` for failure, `OK` for success.','line_number':2271,'multiline':False]['text':' Get current directory name.','line_number':2283,'multiline':False]['text':' We have to get back to the current dir at the end, check if that works.','line_number':2288,'multiline':False]['text':' Path does not exist (yet).  For a full path fail,','line_number':2294,'multiline':False]['text':' will use the path as-is.  For a relative path use','line_number':2295,'multiline':False]['text':' the current directory and append the file name.','line_number':2296,'multiline':False]['text':' Do not return immediately since we may be in the wrong directory.','line_number':2298,'multiline':False]['text':' Do not return immediately since we are in the wrong directory.','line_number':2305,'multiline':False]['text':' That shouldn't happen, since we've tested if it works.','line_number':2310,'multiline':False]['text':' Append to_append to path with a slash in between.','line_number':2318,'multiline':False]['text':' Do not append empty string or a dot.','line_number':2324,'multiline':False]['text':' Combine the path segments, separated by a slash.','line_number':2329,'multiline':False]['text':' Count the trailing slash.','line_number':2331,'multiline':False]['text':' +1 for the NUL at the end.','line_number':2333,'multiline':False]['text':' +1 for the NUL at the end.','line_number':2341,'multiline':False]['text':'/ Expand a given file to its absolute path.','line_number':2350,'multiline':False]['text':'/','line_number':2351,'multiline':False]['text':'/ @param  fname  filename which should be expanded.','line_number':2352,'multiline':False]['text':'/ @param  buf    buffer to store the absolute path of "fname".','line_number':2353,'multiline':False]['text':'/ @param  len    length of "buf".','line_number':2354,'multiline':False]['text':'/ @param  force  also expand when "fname" is already absolute.','line_number':2355,'multiline':False]['text':'/','line_number':2356,'multiline':False]['text':'/ @return FAIL for failure, OK for success.','line_number':2357,'multiline':False]['text':' expand it if forced or not an absolute path','line_number':2366,'multiline':False]['text':'/ Check if file `fname` is a full (absolute) path.','line_number':2392,'multiline':False]['text':'/','line_number':2393,'multiline':False]['text':'/ @return `true` if "fname" is absolute.','line_number':2394,'multiline':False]['text':' A name like "d:/foo" and "//server/share" is absolute','line_number':2401,'multiline':False]['text':' UNIX: This just checks if the file name starts with '/' or '~'.','line_number':2405,'multiline':False]['text':'/ Builds a full path from an invocation name `argv0`, based on heuristics.','line_number':2410,'multiline':False]['text':'/','line_number':2411,'multiline':False]['text':'/ @param[in]  argv0     Name by which Nvim was invoked.','line_number':2412,'multiline':False]['text':'/ @param[out] buf       Guessed full path to `argv0`.','line_number':2413,'multiline':False]['text':'/ @param[in]  bufsize   Size of `buf`.','line_number':2414,'multiline':False]['text':'/','line_number':2415,'multiline':False]['text':'/ @see os_exepath','line_number':2416,'multiline':False]['text':' Relative to CWD.','line_number':2425,'multiline':False]['text':' Search $PATH for plausible location.','line_number':2432,'multiline':False]['text':' Not found in $PATH, fall back to argv0.','line_number':2452,'multiline':False]