['text':'/ Creates a new `RBuffer` instance.','line_number':14,'multiline':False]['text':'/ Return a pointer to a raw buffer containing the first empty slot available','line_number':38,'multiline':False]['text':'/ for writing. The second argument is a pointer to the maximum number of','line_number':39,'multiline':False]['text':'/ bytes that could be written.','line_number':40,'multiline':False]['text':'/','line_number':41,'multiline':False]['text':'/ It is necessary to call this function twice to ensure all empty space was','line_number':42,'multiline':False]['text':'/ used. See RBUFFER_UNTIL_FULL for a macro that simplifies this task.','line_number':43,'multiline':False]['text':' Reset an RBuffer so read_ptr is at the beginning of the memory. If','line_number':60,'multiline':False]['text':' necessary, this moves existing data by allocating temporary memory.','line_number':61,'multiline':False]['text':'/ Adjust `rbuffer` write pointer to reflect produced data. This is called','line_number':77,'multiline':False]['text':'/ automatically by `rbuffer_write`, but when using `rbuffer_write_ptr`','line_number':78,'multiline':False]['text':'/ directly, this needs to called after the data was copied to the internal','line_number':79,'multiline':False]['text':'/ buffer. The write pointer will be wrapped if required.','line_number':80,'multiline':False]['text':' wrap around','line_number':87,'multiline':False]['text':'/ Return a pointer to a raw buffer containing the first byte available','line_number':97,'multiline':False]['text':'/ for reading. The second argument is a pointer to the maximum number of','line_number':98,'multiline':False]['text':'/ bytes that could be read.','line_number':99,'multiline':False]['text':'/','line_number':100,'multiline':False]['text':'/ It is necessary to call this function twice to ensure all available bytes','line_number':101,'multiline':False]['text':'/ were read. See RBUFFER_UNTIL_EMPTY for a macro that simplifies this task.','line_number':102,'multiline':False]['text':'/ Adjust `rbuffer` read pointer to reflect consumed data. This is called','line_number':119,'multiline':False]['text':'/ automatically by `rbuffer_read`, but when using `rbuffer_read_ptr`','line_number':120,'multiline':False]['text':'/ directly, this needs to called after the data was copied from the internal','line_number':121,'multiline':False]['text':'/ buffer. The read pointer will be wrapped if required.','line_number':122,'multiline':False]['text':'/ Use instead of rbuffer_consumed to use rbuffer in a linear, non-cyclic fashion.','line_number':140,'multiline':False]['text':'/','line_number':141,'multiline':False]['text':'/ This is generally useful if we can guarantee to parse all input','line_number':142,'multiline':False]['text':'/ except some small incomplete token, like when parsing msgpack.','line_number':143,'multiline':False]['text':' Higher level functions for copying from/to RBuffer instances and data','line_number':158,'multiline':False]['text':' pointers','line_number':159,'multiline':False]