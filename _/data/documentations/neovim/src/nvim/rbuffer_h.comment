['text':' Specialized ring buffer. This is basically an array that wraps read/write','line_number':1,'multiline':False]['text':' pointers around the memory region. It should be more efficient than the old','line_number':2,'multiline':False]['text':' RBuffer which required memmove() calls to relocate read/write positions.','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':' The main purpose of RBuffer is simplify memory management when reading from','line_number':5,'multiline':False]['text':' uv_stream_t instances:','line_number':6,'multiline':False]['text':'','line_number':7,'multiline':False]['text':' - The event loop writes data to a RBuffer, advancing the write pointer','line_number':8,'multiline':False]['text':' - The main loop reads data, advancing the read pointer','line_number':9,'multiline':False]['text':' - If the buffer becomes full(size == capacity) the rstream is temporarily','line_number':10,'multiline':False]['text':'   stopped(automatic backpressure handling)','line_number':11,'multiline':False]['text':'','line_number':12,'multiline':False]['text':' Reference: http://en.wikipedia.org/wiki/Circular_buffer','line_number':13,'multiline':False]['text':' IWYU pragma: export','line_number':19,'multiline':False]['text':' Macros that simplify working with the read/write pointers directly by hiding','line_number':21,'multiline':False]['text':' ring buffer wrap logic. Some examples:','line_number':22,'multiline':False]['text':'','line_number':23,'multiline':False]['text':' - Pass the write pointer to a function(write_data) that incrementally','line_number':24,'multiline':False]['text':'   produces data, returning the number of bytes actually written to the','line_number':25,'multiline':False]['text':'   ring buffer:','line_number':26,'multiline':False]['text':'','line_number':27,'multiline':False]['text':'       RBUFFER_UNTIL_FULL(rbuf, ptr, cnt)','line_number':28,'multiline':False]['text':'         rbuffer_produced(rbuf, write_data(state, ptr, cnt));','line_number':29,'multiline':False]['text':'','line_number':30,'multiline':False]['text':' - Pass the read pointer to a function(read_data) that incrementally','line_number':31,'multiline':False]['text':'   consumes data, returning the number of bytes actually read from the','line_number':32,'multiline':False]['text':'   ring buffer:','line_number':33,'multiline':False]['text':'','line_number':34,'multiline':False]['text':'       RBUFFER_UNTIL_EMPTY(rbuf, ptr, cnt)','line_number':35,'multiline':False]['text':'         rbuffer_consumed(rbuf, read_data(state, ptr, cnt));','line_number':36,'multiline':False]['text':'','line_number':37,'multiline':False]['text':' Note that the rbuffer_{produced,consumed} calls are necessary or these macros','line_number':38,'multiline':False]['text':' create infinite loops','line_number':39,'multiline':False]['text':' NOLINT(readability/braces) ','line_number':41,'multiline':True]['text':' NOLINT(readability/braces) ','line_number':42,'multiline':True]['text':' NOLINT(readability/braces) ','line_number':47,'multiline':True]['text':' NOLINT(readability/braces) ','line_number':48,'multiline':True]['text':' Iteration','line_number':52,'multiline':False]['text':' NOLINT(readability/braces) ','line_number':54,'multiline':True]['text':' NOLINT(readability/braces) ','line_number':57,'multiline':True]['text':' NOLINT(readability/braces) ','line_number':62,'multiline':True]['text':' NOLINT(readability/braces) ','line_number':65,'multiline':True]