['text':'/ @file ex_eval.c','line_number':1,'multiline':False]['text':'/','line_number':2,'multiline':False]['text':'/ Functions for Ex command line for the +eval feature.','line_number':3,'multiline':False]['text':' Exception handling terms:','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':'      :try            ":try" command         ─┐','line_number':40,'multiline':False]['text':'          ...         try block               │','line_number':41,'multiline':False]['text':'      :catch RE       ":catch" command        │','line_number':42,'multiline':False]['text':'          ...         catch clause            ├─ try conditional','line_number':43,'multiline':False]['text':'      :finally        ":finally" command      │','line_number':44,'multiline':False]['text':'          ...         finally clause          │','line_number':45,'multiline':False]['text':'      :endtry         ":endtry" command      ─┘','line_number':46,'multiline':False]['text':'','line_number':47,'multiline':False]['text':' The try conditional may have any number of catch clauses and at most one','line_number':48,'multiline':False]['text':' finally clause.  A ":throw" command can be inside the try block, a catch','line_number':49,'multiline':False]['text':' clause, the finally clause, or in a function called or script sourced from','line_number':50,'multiline':False]['text':' there or even outside the try conditional.  Try conditionals may be nested.','line_number':51,'multiline':False]['text':' Configuration whether an exception is thrown on error or interrupt.  When','line_number':53,'multiline':False]['text':' the preprocessor macros below evaluate to false, an error (did_emsg) or','line_number':54,'multiline':False]['text':' interrupt (got_int) under an active try conditional terminates the script','line_number':55,'multiline':False]['text':' after the non-active finally clauses of all active try conditionals have been','line_number':56,'multiline':False]['text':' executed.  Otherwise, errors and/or interrupts are converted into catchable','line_number':57,'multiline':False]['text':' exceptions (did_throw additionally set), which terminate the script only if','line_number':58,'multiline':False]['text':' not caught.  For user exceptions, only did_throw is set.  (Note: got_int can','line_number':59,'multiline':False]['text':' be set asynchronously afterwards by a SIGINT, so did_throw && got_int is not','line_number':60,'multiline':False]['text':' a reliant test that the exception currently being thrown is an interrupt','line_number':61,'multiline':False]['text':' exception.  Similarly, did_emsg can be set afterwards on an error in an','line_number':62,'multiline':False]['text':' (unskipped) conditional command inside an inactive conditional, so did_throw','line_number':63,'multiline':False]['text':' && did_emsg is not a reliant test that the exception currently being thrown','line_number':64,'multiline':False]['text':' is an error exception.)  -  The macros can be defined as expressions checking','line_number':65,'multiline':False]['text':' for a variable that is allowed to be changed during execution of a script.','line_number':66,'multiline':False]['text':' Values used for the Vim release.','line_number':68,'multiline':False]['text':' Don't do something after an error, interrupt, or throw, or when','line_number':74,'multiline':False]['text':' there is a surrounding conditional and it was not active.','line_number':75,'multiline':False]['text':' When several errors appear in a row, setting "force_abort" is delayed until','line_number':88,'multiline':False]['text':' the failing command returned.  "cause_abort" is set to true meanwhile, in','line_number':89,'multiline':False]['text':' order to indicate that situation.  This is useful when "force_abort" was set','line_number':90,'multiline':False]['text':' during execution of a function call from an expression: the aborting of the','line_number':91,'multiline':False]['text':' expression evaluation is done without producing any error messages, but all','line_number':92,'multiline':False]['text':' error messages on parsing errors during the expression evaluation are given','line_number':93,'multiline':False]['text':' (even if a try conditional is active).','line_number':94,'multiline':False]['text':'/ @return  true when immediately aborting on error, or when an interrupt','line_number':97,'multiline':False]['text':'/          occurred or an exception was thrown but not caught.','line_number':98,'multiline':False]['text':'/','line_number':99,'multiline':False]['text':'/ Use for ":{range}call" to check whether an aborted function that does not','line_number':100,'multiline':False]['text':'/ handle a range itself should be called again for the next line in the range.','line_number':101,'multiline':False]['text':'/ Also used for cancelling expression evaluation after a function call caused','line_number':102,'multiline':False]['text':'/ an immediate abort.  Note that the first emsg() call temporarily resets','line_number':103,'multiline':False]['text':'/ "force_abort" until the throw point for error messages has been reached.','line_number':104,'multiline':False]['text':'/ That is, during cancellation of an expression evaluation after an aborting','line_number':105,'multiline':False]['text':'/ function call or due to a parsing error, aborting() always returns the same','line_number':106,'multiline':False]['text':'/ value. "got_int" is also set by calling interrupt().','line_number':107,'multiline':False]['text':'/ The value of "force_abort" is temporarily reset by the first emsg() call','line_number':113,'multiline':False]['text':'/ during an expression evaluation, and "cause_abort" is used instead.  It might','line_number':114,'multiline':False]['text':'/ be necessary to restore "force_abort" even before the throw point for the','line_number':115,'multiline':False]['text':'/ error message has been reached.  update_force_abort() should be called then.','line_number':116,'multiline':False]['text':'/ @return  true if a command with a subcommand resulting in "retcode" should','line_number':124,'multiline':False]['text':'/ abort the script processing.  Can be used to suppress an autocommand after','line_number':125,'multiline':False]['text':'/ execution of a failing subcommand as long as the error message has not been','line_number':126,'multiline':False]['text':'/ displayed and actually caused the abortion.','line_number':127,'multiline':False]['text':'/ @return  true if a function with the "abort" flag should not be considered','line_number':133,'multiline':False]['text':'/ ended on an error.  This means that parsing commands is continued in order','line_number':134,'multiline':False]['text':'/ to find finally clauses to be executed, and that some errors in skipped','line_number':135,'multiline':False]['text':'/ commands are still reported.','line_number':136,'multiline':False]['text':' This function is only called after an error.  In this case, "force_abort"','line_number':140,'multiline':False]['text':' determines whether searching for finally clauses is necessary.','line_number':141,'multiline':False]['text':'/ cause_errthrow(): Cause a throw of an error exception if appropriate.','line_number':145,'multiline':False]['text':'/','line_number':146,'multiline':False]['text':'/ @return  true if the error message should not be displayed by emsg().','line_number':147,'multiline':False]['text':'/','line_number':148,'multiline':False]['text':'/ Sets "ignore", if the emsg() call should be ignored completely.','line_number':149,'multiline':False]['text':'/','line_number':150,'multiline':False]['text':'/ When several messages appear in the same command, the first is usually the','line_number':151,'multiline':False]['text':'/ most specific one and used as the exception value.  The "severe" flag can be','line_number':152,'multiline':False]['text':'/ set to true, if a later but severer message should be used instead.','line_number':153,'multiline':False]['text':' Do nothing when displaying the interrupt message or reporting an','line_number':159,'multiline':False]['text':' uncaught exception (which has already been discarded then) at the top','line_number':160,'multiline':False]['text':' level.  Also when no exception can be thrown.  The message will be','line_number':161,'multiline':False]['text':' displayed by emsg().','line_number':162,'multiline':False]['text':' If emsg() has not been called previously, temporarily reset','line_number':167,'multiline':False]['text':' "force_abort" until the throw point for error messages has been','line_number':168,'multiline':False]['text':' reached.  This ensures that aborting() returns the same value for all','line_number':169,'multiline':False]['text':' errors that appear in the same command.  This means particularly that','line_number':170,'multiline':False]['text':' for parsing errors during expression evaluation emsg() will be called','line_number':171,'multiline':False]['text':' multiply, even when the expression is evaluated from a finally clause','line_number':172,'multiline':False]['text':' that was activated due to an aborting error, interrupt, or exception.','line_number':173,'multiline':False]['text':' If no try conditional is active and no exception is being thrown and','line_number':179,'multiline':False]['text':' there has not been an error in a try conditional or a throw so far, do','line_number':180,'multiline':False]['text':' nothing (for compatibility of non-EH scripts).  The message will then','line_number':181,'multiline':False]['text':' be displayed by emsg().  When ":silent!" was used and we are not','line_number':182,'multiline':False]['text':' currently throwing an exception, do nothing.  The message text will','line_number':183,'multiline':False]['text':' then be stored to v:errmsg by emsg() without displaying it.','line_number':184,'multiline':False]['text':' Ignore an interrupt message when inside a try conditional or when an','line_number':189,'multiline':False]['text':' exception is being thrown or when an error in a try conditional or','line_number':190,'multiline':False]['text':' throw has been detected previously.  This is important in order that an','line_number':191,'multiline':False]['text':' interrupt exception is catchable by the innermost try conditional and','line_number':192,'multiline':False]['text':' not replaced by an interrupt message error exception.','line_number':193,'multiline':False]['text':' Ensure that all commands in nested function calls and sourced files','line_number':199,'multiline':False]['text':' are aborted immediately.','line_number':200,'multiline':False]['text':' When an exception is being thrown, some commands (like conditionals) are','line_number':203,'multiline':False]['text':' not skipped.  Errors in those commands may affect what of the subsequent','line_number':204,'multiline':False]['text':' commands are regarded part of catch and finally clauses.  Catching the','line_number':205,'multiline':False]['text':' exception would then cause execution of commands not intended by the','line_number':206,'multiline':False]['text':' user, who wouldn't even get aware of the problem.  Therefore, discard the','line_number':207,'multiline':False]['text':' exception currently being thrown to prevent it from being caught.  Just','line_number':208,'multiline':False]['text':' execute finally clauses and terminate.','line_number':209,'multiline':False]['text':' When discarding an interrupt exception, reset got_int to prevent the','line_number':211,'multiline':False]['text':' same interrupt being converted to an exception again and discarding','line_number':212,'multiline':False]['text':' the error exception we are about to throw here.','line_number':213,'multiline':False]['text':' Print error message immediately without searching for a matching','line_number':222,'multiline':False]['text':' catch clause; just finally clauses are executed before the script','line_number':223,'multiline':False]['text':' is terminated.','line_number':224,'multiline':False]['text':' NOLINT(readability/braces)','line_number':226,'multiline':False]['text':' Prepare the throw of an error exception, so that everything will','line_number':229,'multiline':False]['text':' be aborted (except for executing finally clauses), until the error','line_number':230,'multiline':False]['text':' exception is caught; if still uncaught at the top level, the error','line_number':231,'multiline':False]['text':' message will be displayed and the script processing terminated','line_number':232,'multiline':False]['text':' then.  -  This function has no access to the conditional stack.','line_number':233,'multiline':False]['text':' Thus, the actual throw is made after the failing command has','line_number':234,'multiline':False]['text':' returned.  -  Throw only the first of several errors in a row, except','line_number':235,'multiline':False]['text':' a severe error is following.','line_number':236,'multiline':False]['text':' Skip the extra "Vim " prefix for message "E458".','line_number':250,'multiline':False]['text':' Get the source name and lnum now, it may change before','line_number':264,'multiline':False]['text':' reaching do_errthrow().','line_number':265,'multiline':False]['text':'/ Free a "msg_list" and the messages it contains.','line_number':273,'multiline':False]['text':'/ Free global "*msg_list" and the messages it contains, then set "*msg_list"','line_number':286,'multiline':False]['text':'/ to NULL.','line_number':287,'multiline':False]['text':'/ Throw the message specified in the call to cause_errthrow() above as an','line_number':294,'multiline':False]['text':'/ error exception.  If cstack is NULL, postpone the throw until do_cmdline()','line_number':295,'multiline':False]['text':'/ has returned (see do_one_cmd()).','line_number':296,'multiline':False]['text':' Ensure that all commands in nested function calls and sourced files','line_number':299,'multiline':False]['text':' are aborted immediately.','line_number':300,'multiline':False]['text':' If no exception is to be thrown or the conversion should be done after','line_number':306,'multiline':False]['text':' returning to a previous invocation of do_one_cmd(), do nothing.','line_number':307,'multiline':False]['text':'/ do_intthrow(): Replace the current exception by an interrupt or interrupt','line_number':324,'multiline':False]['text':'/ exception if appropriate.','line_number':325,'multiline':False]['text':'/','line_number':326,'multiline':False]['text':'/ @return  true if the current exception is discarded or,','line_number':327,'multiline':False]['text':'/          false otherwise.','line_number':328,'multiline':False]['text':' If no interrupt occurred or no try conditional is active and no exception','line_number':331,'multiline':False]['text':' is being thrown, do nothing (for compatibility of non-EH scripts).','line_number':332,'multiline':False]['text':' avoid warning for condition always true','line_number':337,'multiline':False]['text':' The interrupt aborts everything except for executing finally clauses.','line_number':339,'multiline':False]['text':' Discard any user or error or interrupt exception currently being','line_number':340,'multiline':False]['text':' thrown.','line_number':341,'multiline':False]['text':' Throw an interrupt exception, so that everything will be aborted','line_number':347,'multiline':False]['text':' (except for executing finally clauses), until the interrupt exception','line_number':348,'multiline':False]['text':' is caught; if still uncaught at the top level, the script processing','line_number':349,'multiline':False]['text':' will be terminated then.  -  If an interrupt exception is already','line_number':350,'multiline':False]['text':' being thrown, do nothing.','line_number':351,'multiline':False]['text':' An interrupt exception replaces any user or error exception.','line_number':358,'multiline':False]['text':'/ Get an exception message that is to be stored in current_exception->value.','line_number':371,'multiline':False]['text':' msg_add_fname may have been used to prefix the message with a file','line_number':391,'multiline':False]['text':' name in quotes.  In the exception value, put the file name in','line_number':392,'multiline':False]['text':' parentheses and move it to the end.','line_number':393,'multiline':False]['text':' 'E123' missing or at beginning','line_number':404,'multiline':False]['text':' '"filename" E123: message text'','line_number':406,'multiline':False]['text':' "E123:" is part of the file name.','line_number':409,'multiline':False]['text':'/ Throw a new exception.  "value" is the exception string for a','line_number':429,'multiline':False]['text':'/ user or interrupt exception, or points to a message list in case of an','line_number':430,'multiline':False]['text':'/ error exception.','line_number':431,'multiline':False]['text':'/','line_number':432,'multiline':False]['text':'/ @return  FAIL when out of memory or it was tried to throw an illegal user','line_number':433,'multiline':False]['text':'/          exception.','line_number':434,'multiline':False]['text':' Disallow faking Interrupt or error exceptions as user exceptions.  They','line_number':437,'multiline':False]['text':' would be treated differently from real interrupt or error exceptions','line_number':438,'multiline':False]['text':' when no active try block is found, see do_cmdline().','line_number':439,'multiline':False]['text':' Store the original message and prefix the exception value with','line_number':452,'multiline':False]['text':' "Vim:" or, if a command name is given, "Vim(cmdname):".','line_number':453,'multiline':False]['text':' display messages','line_number':481,'multiline':False]['text':' always scroll up, don't overwrite','line_number':487,'multiline':False]['text':' don't overwrite this either','line_number':490,'multiline':False]['text':'/ Discard an exception.  "was_finished" is set when the exception has been','line_number':515,'multiline':False]['text':'/ caught and the catch clause has been ended normally.','line_number':516,'multiline':False]['text':' display messages','line_number':532,'multiline':False]['text':' always scroll up, don't overwrite','line_number':538,'multiline':False]['text':' don't overwrite this either','line_number':541,'multiline':False]['text':'/ Discard the exception currently being thrown.','line_number':564,'multiline':False]['text':' Note: all globals manipulated here should be saved/restored in','line_number':570,'multiline':False]['text':' try_enter/try_leave.','line_number':571,'multiline':False]['text':'/ Put an exception on the caught stack.','line_number':576,'multiline':False]['text':' throw_name not set on an exception from a command that was typed.','line_number':591,'multiline':False]['text':' display messages','line_number':599,'multiline':False]['text':' always scroll up, don't overwrite','line_number':605,'multiline':False]['text':' don't overwrite this either','line_number':608,'multiline':False]['text':'/ Remove an exception from the caught stack.','line_number':622,'multiline':False]['text':' throw_name not set on an exception from a command that was','line_number':642,'multiline':False]['text':' typed.','line_number':643,'multiline':False]['text':' Discard the exception, but use the finish message for 'verbose'.','line_number':651,'multiline':False]['text':'/ Save the current exception state in "estate"','line_number':655,'multiline':False]['text':'/ Restore the current exception state from "estate"','line_number':665,'multiline':False]['text':' Handle any outstanding exceptions before restoring the state','line_number':668,'multiline':False]['text':'/ Clear the current exception state','line_number':679,'multiline':False]['text':' Flags specifying the message displayed by report_pending.','line_number':689,'multiline':False]['text':'/ Report information about something pending in a finally clause if required by','line_number':694,'multiline':False]['text':'/ the 'verbose' option or when debugging.  "action" tells whether something is','line_number':695,'multiline':False]['text':'/ made pending or something pending is resumed or discarded.  "pending" tells','line_number':696,'multiline':False]['text':'/ what is pending.  "value" specifies the return value for a pending ":return"','line_number':697,'multiline':False]['text':'/ or the exception value for a pending exception.','line_number':698,'multiline':False]['text':' case RP_DISCARD:','line_number':713,'multiline':False]['text':' ":return" command producing value, allocated','line_number':733,'multiline':False]['text':' if (pending & CSTP_INTERRUPT)','line_number':747,'multiline':False]['text':' display messages','line_number':754,'multiline':False]['text':' always scroll up, don't overwrite','line_number':757,'multiline':False]['text':' don't overwrite this either','line_number':759,'multiline':False]['text':'/ If something is made pending in a finally clause, report it if required by','line_number':773,'multiline':False]['text':'/ the 'verbose' option or when debugging.','line_number':774,'multiline':False]['text':'/ If something pending in a finally clause is resumed at the ":endtry", report','line_number':788,'multiline':False]['text':'/ it if required by the 'verbose' option or when debugging.','line_number':789,'multiline':False]['text':'/ If something pending in a finally clause is discarded, report it if required','line_number':803,'multiline':False]['text':'/ by the 'verbose' option or when debugging.','line_number':804,'multiline':False]['text':'/ Handle ":eval".','line_number':818,'multiline':False]['text':'/ Handle ":if".','line_number':833,'multiline':False]['text':' set TRUE, so this conditional will never get active','line_number':854,'multiline':False]['text':'/ Handle ":endif".','line_number':860,'multiline':False]['text':' When debugging or a breakpoint was encountered, display the debug','line_number':869,'multiline':False]['text':' prompt (if not already done).  This shows the user that an ":endif"','line_number':870,'multiline':False]['text':' is executed when the ":if" or a previous ":elseif" was not TRUE.','line_number':871,'multiline':False]['text':' Handle a ">quit" debug command as if an interrupt had occurred before','line_number':872,'multiline':False]['text':' the ":endif".  That is, throw an interrupt exception if appropriate.','line_number':873,'multiline':False]['text':' Doing this here prevents an exception for a parsing error being','line_number':874,'multiline':False]['text':' discarded by throwing the interrupt exception later on.','line_number':875,'multiline':False]['text':'/ Handle ":else" and ":elseif".','line_number':885,'multiline':False]['text':' if skipping or the ":if" was TRUE, reset ACTIVE, otherwise set it','line_number':910,'multiline':False]['text':' don't evaluate an ":elseif"','line_number':915,'multiline':False]['text':' When debugging or a breakpoint was encountered, display the debug prompt','line_number':920,'multiline':False]['text':' (if not already done).  This shows the user that an ":else" or ":elseif"','line_number':921,'multiline':False]['text':' is executed when the ":if" or previous ":elseif" was not TRUE.  Handle','line_number':922,'multiline':False]['text':' a ">quit" debug command as if an interrupt had occurred before the','line_number':923,'multiline':False]['text':' ":else" or ":elseif".  That is, set "skip" and throw an interrupt','line_number':924,'multiline':False]['text':' exception if appropriate.  Doing this here prevents that an exception','line_number':925,'multiline':False]['text':' for a parsing errors is discarded when throwing the interrupt exception','line_number':926,'multiline':False]['text':' later on.','line_number':927,'multiline':False]['text':' When skipping we ignore most errors, but a missing expression is','line_number':936,'multiline':False]['text':' wrong, perhaps it should have been "else".','line_number':937,'multiline':False]['text':' A double quote here is the start of a string, not a comment.','line_number':938,'multiline':False]['text':' When throwing error exceptions, we want to throw always the first','line_number':945,'multiline':False]['text':' of several errors in a row.  This is what actually happens when','line_number':946,'multiline':False]['text':' a conditional error was detected above and there is another failure','line_number':947,'multiline':False]['text':' when parsing the expression.  Since the skip flag is set in this','line_number':948,'multiline':False]['text':' case, the parsing error will be ignored by emsg().','line_number':949,'multiline':False]['text':' set TRUE, so this conditional will never get active','line_number':957,'multiline':False]['text':'/ Handle ":while" and ":for".','line_number':965,'multiline':False]['text':' The loop flag is set when we have jumped back from the matching','line_number':975,'multiline':False]['text':' ":endwhile" or ":endfor".  When not set, need to initialise this','line_number':976,'multiline':False]['text':' cstack entry.','line_number':977,'multiline':False]['text':' ":while bool-expr"','line_number':987,'multiline':False]['text':' ":for var in list-expr"','line_number':989,'multiline':False]['text':' Jumping here from a ":continue" or ":endfor": use the','line_number':994,'multiline':False]['text':' previously evaluated list.','line_number':995,'multiline':False]['text':' Evaluate the argument and get the info in a structure.','line_number':999,'multiline':False]['text':' use the element at the start of the list and advance','line_number':1004,'multiline':False]['text':' If this cstack entry was just initialised and is active, set the','line_number':1018,'multiline':False]['text':' loop flag, so do_cmdline() will set the line number in cs_line[].','line_number':1019,'multiline':False]['text':' If executing the command a second time, clear the loop flag.','line_number':1020,'multiline':False]['text':' If the ":while" evaluates to FALSE or ":for" is past the end of','line_number':1026,'multiline':False]['text':' the list, show the debug prompt at the ":endwhile"/":endfor" as','line_number':1027,'multiline':False]['text':' if there was a ":break" in a ":while"/":for" evaluating to','line_number':1028,'multiline':False]['text':' TRUE.','line_number':1029,'multiline':False]['text':'/ Handle ":continue"','line_number':1037,'multiline':False]['text':' Try to find the matching ":while".  This might stop at a try','line_number':1045,'multiline':False]['text':' conditional not in its finally clause (which is then to be executed','line_number':1046,'multiline':False]['text':' next).  Therefore, deactivate all conditionals except the ":while"','line_number':1047,'multiline':False]['text':' itself (if reached).','line_number':1048,'multiline':False]['text':' Set CSL_HAD_CONT, so do_cmdline() will jump back to the','line_number':1054,'multiline':False]['text':' matching ":while".','line_number':1055,'multiline':False]['text':' let do_cmdline() handle it','line_number':1056,'multiline':False]['text':' If a try conditional not in its finally clause is reached first,','line_number':1058,'multiline':False]['text':' make the ":continue" pending for execution at the ":endtry".','line_number':1059,'multiline':False]['text':'/ Handle ":break"','line_number':1066,'multiline':False]['text':' Deactivate conditionals until the matching ":while" or a try','line_number':1074,'multiline':False]['text':' conditional not in its finally clause (which is then to be','line_number':1075,'multiline':False]['text':' executed next) is found.  In the latter case, make the ":break"','line_number':1076,'multiline':False]['text':' pending for execution at the ":endtry".','line_number':1077,'multiline':False]['text':'/ Handle ":endwhile" and ":endfor"','line_number':1086,'multiline':False]['text':' If we are in a ":while" or ":for" but used the wrong endloop','line_number':1106,'multiline':False]['text':' command, do not rewind to the next enclosing ":for"/":while".','line_number':1107,'multiline':False]['text':' Try to find the matching ":while" and report what's missing.','line_number':1120,'multiline':False]['text':' Give up at a try conditional not in its finally clause.','line_number':1125,'multiline':False]['text':' Ignore the ":endwhile"/":endfor".','line_number':1126,'multiline':False]['text':' Cleanup and rewind all contained (and unclosed) conditionals.','line_number':1134,'multiline':False]['text':' When debugging or a breakpoint was encountered, display the debug','line_number':1140,'multiline':False]['text':' prompt (if not already done).  This shows the user that an','line_number':1141,'multiline':False]['text':' ":endwhile"/":endfor" is executed when the ":while" was not TRUE or','line_number':1142,'multiline':False]['text':' after a ":break".  Handle a ">quit" debug command as if an','line_number':1143,'multiline':False]['text':' interrupt had occurred before the ":endwhile"/":endfor".  That is,','line_number':1144,'multiline':False]['text':' throw an interrupt exception if appropriate.  Doing this here','line_number':1145,'multiline':False]['text':' prevents that an exception for a parsing error is discarded when','line_number':1146,'multiline':False]['text':' throwing the interrupt exception later on.','line_number':1147,'multiline':False]['text':' Set loop flag, so do_cmdline() will jump back to the matching','line_number':1151,'multiline':False]['text':' ":while" or ":for".','line_number':1152,'multiline':False]['text':'/ Handle ":throw expr"','line_number':1157,'multiline':False]['text':' On error or when an exception is thrown during argument evaluation, do','line_number':1170,'multiline':False]['text':' not throw.','line_number':1171,'multiline':False]['text':'/ Throw the current exception through the specified cstack.  Common routine','line_number':1181,'multiline':False]['text':'/ for ":throw" (user exception) and error and interrupt exceptions.  Also','line_number':1182,'multiline':False]['text':'/ used for rethrowing an uncaught exception.','line_number':1183,'multiline':False]['text':' Cleanup and deactivate up to the next surrounding try conditional that','line_number':1188,'multiline':False]['text':' is not in its finally clause.  Normally, do not deactivate the try','line_number':1189,'multiline':False]['text':' conditional itself, so that its ACTIVE flag can be tested below.  But','line_number':1190,'multiline':False]['text':' if a previous error or interrupt has not been converted to an exception,','line_number':1191,'multiline':False]['text':' deactivate the try conditional, too, as if the conversion had been done,','line_number':1192,'multiline':False]['text':' and reset the did_emsg or got_int flag, so this won't happen again at','line_number':1193,'multiline':False]['text':' the next surrounding try conditional.','line_number':1194,'multiline':False]['text':' If this try conditional is active and we are before its first','line_number':1210,'multiline':False]['text':' ":catch", set THROWN so that the ":catch" commands will check','line_number':1211,'multiline':False]['text':' whether the exception matches.  When the exception came from any of','line_number':1212,'multiline':False]['text':' the catch clauses, it will be made pending at the ":finally" (if','line_number':1213,'multiline':False]['text':' present) and rethrown at the ":endtry".  This will also happen if','line_number':1214,'multiline':False]['text':' the try conditional is inactive.  This is the case when we are','line_number':1215,'multiline':False]['text':' throwing an exception due to an error or interrupt on the way from','line_number':1216,'multiline':False]['text':' a preceding ":continue", ":break", ":return", ":finish", error or','line_number':1217,'multiline':False]['text':' interrupt (not converted to an exception) to the finally clause or','line_number':1218,'multiline':False]['text':' from a preceding throw of a user or error or interrupt exception to','line_number':1219,'multiline':False]['text':' the matching catch clause or the finally clause.','line_number':1220,'multiline':False]['text':' THROWN may have already been set for a catchable exception','line_number':1225,'multiline':False]['text':' that has been discarded.  Ensure it is reset for the new','line_number':1226,'multiline':False]['text':' exception.','line_number':1227,'multiline':False]['text':'/ Handle ":try"','line_number':1238,'multiline':False]['text':' Set ACTIVE and TRUE.  TRUE means that the corresponding ":catch"','line_number':1254,'multiline':False]['text':' commands should check for a match if an exception is thrown and','line_number':1255,'multiline':False]['text':' that the finally clause needs to be executed.','line_number':1256,'multiline':False]['text':' ":silent!", even when used in a try conditional, disables','line_number':1259,'multiline':False]['text':' displaying of error messages and conversion of errors to','line_number':1260,'multiline':False]['text':' exceptions.  When the silent commands again open a try','line_number':1261,'multiline':False]['text':' conditional, save "emsg_silent" and reset it so that errors are','line_number':1262,'multiline':False]['text':' again converted to exceptions.  The value is restored when that','line_number':1263,'multiline':False]['text':' try conditional is left.  If it is left normally, the commands','line_number':1264,'multiline':False]['text':' following the ":endtry" are again silent.  If it is left by','line_number':1265,'multiline':False]['text':' a ":continue", ":break", ":return", or ":finish", the commands','line_number':1266,'multiline':False]['text':' executed next are again silent.  If it is left due to an','line_number':1267,'multiline':False]['text':' aborting error, an interrupt, or an exception, restoring','line_number':1268,'multiline':False]['text':' "emsg_silent" does not matter since we are already in the','line_number':1269,'multiline':False]['text':' aborting state and/or the exception has already been thrown.','line_number':1270,'multiline':False]['text':' The effect is then just freeing the memory that was allocated','line_number':1271,'multiline':False]['text':' to save the value.','line_number':1272,'multiline':False]['text':'/ Handle ":catch /{pattern}/" and ":catch"','line_number':1285,'multiline':False]['text':' Report what's missing if the matching ":try" is not in its','line_number':1302,'multiline':False]['text':' finally clause.','line_number':1303,'multiline':False]['text':' Give up for a ":catch" after ":finally" and ignore it.','line_number':1313,'multiline':False]['text':' Just parse.','line_number':1314,'multiline':False]['text':' no argument, catch all errors','line_number':1323,'multiline':False]['text':' Don't do something when no exception has been thrown or when the','line_number':1337,'multiline':False]['text':' corresponding try block never got active (because of an inactive','line_number':1338,'multiline':False]['text':' surrounding conditional or after an error or interrupt or throw).','line_number':1339,'multiline':False]['text':' Check for a match only if an exception is thrown but not caught by','line_number':1344,'multiline':False]['text':' a previous ":catch".  An exception that has replaced a discarded','line_number':1345,'multiline':False]['text':' exception is not checked (THROWN is not set then).','line_number':1346,'multiline':False]['text':' When debugging or a breakpoint was encountered, display the','line_number':1354,'multiline':False]['text':' debug prompt (if not already done) before checking for a match.','line_number':1355,'multiline':False]['text':' This is a helpful hint for the user when the regular expression','line_number':1356,'multiline':False]['text':' matching fails.  Handle a ">quit" debug command as if an','line_number':1357,'multiline':False]['text':' interrupt had occurred before the ":catch".  That is, discard','line_number':1358,'multiline':False]['text':' the original exception, replace it by an interrupt exception,','line_number':1359,'multiline':False]['text':' and don't catch it in this try block.','line_number':1360,'multiline':False]['text':' Terminate the pattern and avoid the 'l' flag in 'cpoptions'','line_number':1363,'multiline':False]['text':' while compiling it.','line_number':1364,'multiline':False]['text':' Disable error messages, it will make current exception','line_number':1371,'multiline':False]['text':' invalid','line_number':1372,'multiline':False]['text':' Save the value of got_int and reset it.  We don't want','line_number':1384,'multiline':False]['text':' a previous interruption cancel matching, only hitting','line_number':1385,'multiline':False]['text':' CTRL-C while matching should abort it.','line_number':1386,'multiline':False]['text':' Make this ":catch" clause active and reset did_emsg, got_int,','line_number':1398,'multiline':False]['text':' and did_throw.  Put the exception on the caught stack.','line_number':1399,'multiline':False]['text':' It's mandatory that the current exception is stored in the cstack','line_number':1403,'multiline':False]['text':' so that it can be discarded at the next ":catch", ":finally", or','line_number':1404,'multiline':False]['text':' ":endtry" or when the catch clause is left by a ":continue",','line_number':1405,'multiline':False]['text':' ":break", ":return", ":finish", error, interrupt, or another','line_number':1406,'multiline':False]['text':' exception.','line_number':1407,'multiline':False]['text':' If there is a preceding catch clause and it caught the exception,','line_number':1412,'multiline':False]['text':' finish the exception now.  This happens also after errors except','line_number':1413,'multiline':False]['text':' when this ":catch" was after the ":finally" or not within','line_number':1414,'multiline':False]['text':' a ":try".  Make the try conditional inactive so that the','line_number':1415,'multiline':False]['text':' following catch clauses are skipped.  On an error or interrupt','line_number':1416,'multiline':False]['text':' after the preceding try block or catch clause was left by','line_number':1417,'multiline':False]['text':' a ":continue", ":break", ":return", or ":finish", discard the','line_number':1418,'multiline':False]['text':' pending action.','line_number':1419,'multiline':False]['text':'/ Handle ":finally"','line_number':1429,'multiline':False]['text':' Make this error pending, so that the commands in the following','line_number':1448,'multiline':False]['text':' finally clause can be executed.  This overrules also a pending','line_number':1449,'multiline':False]['text':' ":continue", ":break", ":return", or ":finish".','line_number':1450,'multiline':False]['text':' Give up for a multiple ":finally" and ignore it.','line_number':1455,'multiline':False]['text':' Don't do something when the corresponding try block never got active','line_number':1462,'multiline':False]['text':' (because of an inactive surrounding conditional or after an error or','line_number':1463,'multiline':False]['text':' interrupt or throw) or for a ":finally" without ":try" or a multiple','line_number':1464,'multiline':False]['text':' ":finally".  After every other error (did_emsg or the conditional','line_number':1465,'multiline':False]['text':' errors detected above) or after an interrupt (got_int) or an','line_number':1466,'multiline':False]['text':' exception (did_throw), the finally clause must be executed.','line_number':1467,'multiline':False]['text':' When debugging or a breakpoint was encountered, display the','line_number':1471,'multiline':False]['text':' debug prompt (if not already done).  The user then knows that the','line_number':1472,'multiline':False]['text':' finally clause is executed.','line_number':1473,'multiline':False]['text':' Handle a ">quit" debug command as if an interrupt had','line_number':1475,'multiline':False]['text':' occurred before the ":finally".  That is, discard the','line_number':1476,'multiline':False]['text':' original exception and replace it by an interrupt','line_number':1477,'multiline':False]['text':' exception.','line_number':1478,'multiline':False]['text':' If there is a preceding catch clause and it caught the exception,','line_number':1482,'multiline':False]['text':' finish the exception now.  This happens also after errors except','line_number':1483,'multiline':False]['text':' when this is a multiple ":finally" or one not within a ":try".','line_number':1484,'multiline':False]['text':' After an error or interrupt, this also discards a pending','line_number':1485,'multiline':False]['text':' ":continue", ":break", ":finish", or ":return" from the preceding','line_number':1486,'multiline':False]['text':' try block or catch clause.','line_number':1487,'multiline':False]['text':' Make did_emsg, got_int, did_throw pending.  If set, they overrule','line_number':1490,'multiline':False]['text':' a pending ":continue", ":break", ":return", or ":finish".  Then','line_number':1491,'multiline':False]['text':' we have particularly to discard a pending return value (as done','line_number':1492,'multiline':False]['text':' by the call to cleanup_conditionals() above when did_emsg or','line_number':1493,'multiline':False]['text':' got_int is set).  The pending values are restored by the','line_number':1494,'multiline':False]['text':' ":endtry", except if there is a new error, interrupt, exception,','line_number':1495,'multiline':False]['text':' ":continue", ":break", ":return", or ":finish" in the following','line_number':1496,'multiline':False]['text':' finally clause.  A missing ":endwhile", ":endfor" or ":endif"','line_number':1497,'multiline':False]['text':' detected here is treated as if did_emsg and did_throw had','line_number':1498,'multiline':False]['text':' already been set, respectively in case that the error is not','line_number':1499,'multiline':False]['text':' converted to an exception, did_throw had already been unset.','line_number':1500,'multiline':False]['text':' We must not set did_emsg here since that would suppress the','line_number':1501,'multiline':False]['text':' error message.','line_number':1502,'multiline':False]['text':' It's mandatory that the current exception is stored in the','line_number':1519,'multiline':False]['text':' cstack so that it can be rethrown at the ":endtry" or be','line_number':1520,'multiline':False]['text':' discarded if the finally clause is left by a ":continue",','line_number':1521,'multiline':False]['text':' ":break", ":return", ":finish", error, interrupt, or another','line_number':1522,'multiline':False]['text':' exception.  When emsg() is called for a missing ":endif" or','line_number':1523,'multiline':False]['text':' a missing ":endwhile"/":endfor" detected here, the','line_number':1524,'multiline':False]['text':' exception will be discarded.','line_number':1525,'multiline':False]['text':' Set CSL_HAD_FINA, so do_cmdline() will reset did_emsg,','line_number':1531,'multiline':False]['text':' got_int, and did_throw and make the finally clause active.','line_number':1532,'multiline':False]['text':' This will happen after emsg() has been called for a missing','line_number':1533,'multiline':False]['text':' ":endif" or a missing ":endwhile"/":endfor" detected here, so','line_number':1534,'multiline':False]['text':' that the following finally clause will be executed even then.','line_number':1535,'multiline':False]['text':'/ Handle ":endtry"','line_number':1540,'multiline':False]['text':' Don't do something after an error, interrupt or throw in the try','line_number':1559,'multiline':False]['text':' block, catch clause, or finally clause preceding this ":endtry" or','line_number':1560,'multiline':False]['text':' when an error or interrupt occurred after a ":continue", ":break",','line_number':1561,'multiline':False]['text':' ":return", or ":finish" in a try block or catch clause preceding this','line_number':1562,'multiline':False]['text':' ":endtry" or when the try block never got active (because of an','line_number':1563,'multiline':False]['text':' inactive surrounding conditional or after an error or interrupt or','line_number':1564,'multiline':False]['text':' throw) or when there is a surrounding conditional and it has been','line_number':1565,'multiline':False]['text':' made inactive by a ":continue", ":break", ":return", or ":finish" in','line_number':1566,'multiline':False]['text':' the finally clause.  The latter case need not be tested since then','line_number':1567,'multiline':False]['text':' anything pending has already been discarded.','line_number':1568,'multiline':False]['text':' Find the matching ":try" and report what's missing.','line_number':1574,'multiline':False]['text':' If an exception is being thrown, discard it to prevent it from','line_number':1579,'multiline':False]['text':' being rethrown at the end of this function.  It would be','line_number':1580,'multiline':False]['text':' discarded by the error message, anyway.  Resets did_throw.','line_number':1581,'multiline':False]['text':' This does not affect the script termination due to the error','line_number':1582,'multiline':False]['text':' since "trylevel" is decremented after emsg() has been called.','line_number':1583,'multiline':False]['text':' report eap->errmsg, also when there already was an error','line_number':1588,'multiline':False]['text':' If we stopped with the exception currently being thrown at this','line_number':1593,'multiline':False]['text':' try conditional since we didn't know that it doesn't have','line_number':1594,'multiline':False]['text':' a finally clause, we need to rethrow it after closing the try','line_number':1595,'multiline':False]['text':' conditional.','line_number':1596,'multiline':False]['text':' If there was no finally clause, show the user when debugging or','line_number':1604,'multiline':False]['text':' a breakpoint was encountered that the end of the try conditional has','line_number':1605,'multiline':False]['text':' been reached: display the debug prompt (if not already done).  Do','line_number':1606,'multiline':False]['text':' this on normal control flow or when an exception was thrown, but not','line_number':1607,'multiline':False]['text':' on an interrupt or error not converted to an exception or when','line_number':1608,'multiline':False]['text':' a ":break", ":continue", ":return", or ":finish" is pending.  These','line_number':1609,'multiline':False]['text':' actions are carried out immediately.','line_number':1610,'multiline':False]['text':' Handle a ">quit" debug command as if an interrupt had occurred','line_number':1615,'multiline':False]['text':' before the ":endtry".  That is, throw an interrupt exception and','line_number':1616,'multiline':False]['text':' set "skip" and "rethrow".','line_number':1617,'multiline':False]['text':' The do_intthrow() call may have reset did_throw or','line_number':1621,'multiline':False]['text':' cstack->cs_pending[idx].','line_number':1622,'multiline':False]['text':' If a ":return" is pending, we need to resume it after closing the','line_number':1630,'multiline':False]['text':' try conditional; remember the return value.  If there was a finally','line_number':1631,'multiline':False]['text':' clause making an exception pending, we need to rethrow it.  Make it','line_number':1632,'multiline':False]['text':' the exception currently being thrown.','line_number':1633,'multiline':False]['text':' Discard anything pending on an error, interrupt, or throw in the','line_number':1644,'multiline':False]['text':' finally clause.  If there was no ":finally", discard a pending','line_number':1645,'multiline':False]['text':' ":continue", ":break", ":return", or ":finish" if an error or','line_number':1646,'multiline':False]['text':' interrupt occurred afterwards, but before the ":endtry" was reached.','line_number':1647,'multiline':False]['text':' If an exception was caught by the last of the catch clauses and there','line_number':1648,'multiline':False]['text':' was no finally clause, finish the exception now.  This happens also','line_number':1649,'multiline':False]['text':' after errors except when this ":endtry" is not within a ":try".','line_number':1650,'multiline':False]['text':' Restore "emsg_silent" if it has been reset by this try conditional.','line_number':1651,'multiline':False]['text':' Reactivate a pending ":continue", ":break", ":return",','line_number':1668,'multiline':False]['text':' ":finish" from the try block or a catch clause of this try','line_number':1669,'multiline':False]['text':' conditional.  This is skipped, if there was an error in an','line_number':1670,'multiline':False]['text':' (unskipped) conditional command or an interrupt afterwards','line_number':1671,'multiline':False]['text':' or if the finally clause is present and executed a new error,','line_number':1672,'multiline':False]['text':' interrupt, throw, ":continue", ":break", ":return", or','line_number':1673,'multiline':False]['text':' ":finish".','line_number':1674,'multiline':False]['text':' When the finally clause was entered due to an error,','line_number':1688,'multiline':False]['text':' interrupt or throw (as opposed to a ":continue", ":break",','line_number':1689,'multiline':False]['text':' ":return", or ":finish"), restore the pending values of','line_number':1690,'multiline':False]['text':' did_emsg, got_int, and did_throw.  This is skipped, if there','line_number':1691,'multiline':False]['text':' was a new error, interrupt, throw, ":continue", ":break",','line_number':1692,'multiline':False]['text':' ":return", or ":finish".  in the finally clause.','line_number':1693,'multiline':False]['text':' Rethrow the current exception (within this cstack).','line_number':1709,'multiline':False]['text':' enter_cleanup() and leave_cleanup()','line_number':1714,'multiline':False]['text':'','line_number':1715,'multiline':False]['text':' Functions to be called before/after invoking a sequence of autocommands for','line_number':1716,'multiline':False]['text':' cleanup for a failed command.  (Failure means here that a call to emsg()','line_number':1717,'multiline':False]['text':' has been made, an interrupt occurred, or there is an uncaught exception','line_number':1718,'multiline':False]['text':' from a previous autocommand execution of the same command.)','line_number':1719,'multiline':False]['text':'','line_number':1720,'multiline':False]['text':' Call enter_cleanup() with a pointer to a cleanup_T and pass the same','line_number':1721,'multiline':False]['text':' pointer to leave_cleanup().  The cleanup_T structure stores the pending','line_number':1722,'multiline':False]['text':' error/interrupt/exception state.','line_number':1723,'multiline':False]['text':'/ This function works a bit like ex_finally() except that there was not','line_number':1725,'multiline':False]['text':'/ actually an extra try block around the part that failed and an error or','line_number':1726,'multiline':False]['text':'/ interrupt has not (yet) been converted to an exception.  This function','line_number':1727,'multiline':False]['text':'/ saves the error/interrupt/ exception state and prepares for the call to','line_number':1728,'multiline':False]['text':'/ do_cmdline() that is going to be made for the cleanup autocommand','line_number':1729,'multiline':False]['text':'/ execution.','line_number':1730,'multiline':False]['text':' Postpone did_emsg, got_int, did_throw.  The pending values will be','line_number':1735,'multiline':False]['text':' restored by leave_cleanup() except if there was an aborting error,','line_number':1736,'multiline':False]['text':' interrupt, or uncaught exception after this function ends.','line_number':1737,'multiline':False]['text':' If we are currently throwing an exception (did_throw), save it as','line_number':1744,'multiline':False]['text':' well.  On an error not yet converted to an exception, update','line_number':1745,'multiline':False]['text':' "force_abort" and reset "cause_abort" (as do_errthrow() would do).','line_number':1746,'multiline':False]['text':' This is needed for the do_cmdline() call that is going to be made','line_number':1747,'multiline':False]['text':' for autocommand execution.  We need not save *msg_list because','line_number':1748,'multiline':False]['text':' there is an extra instance for every call of do_cmdline(), anyway.','line_number':1749,'multiline':False]['text':' Report if required by the 'verbose' option or when debugging.','line_number':1762,'multiline':False]['text':'/ This function is a bit like ex_endtry() except that there was not actually','line_number':1770,'multiline':False]['text':'/ an extra try block around the part that failed and an error or interrupt','line_number':1771,'multiline':False]['text':'/ had not (yet) been converted to an exception when the cleanup autocommand','line_number':1772,'multiline':False]['text':'/ sequence was invoked.','line_number':1773,'multiline':False]['text':'/','line_number':1774,'multiline':False]['text':'/ See comment above enter_cleanup() for how this function is used.','line_number':1775,'multiline':False]['text':'/','line_number':1776,'multiline':False]['text':'/ This function has to be called with the address of the cleanup_T structure','line_number':1777,'multiline':False]['text':'/ filled by enter_cleanup() as an argument; it restores the error/interrupt/','line_number':1778,'multiline':False]['text':'/ exception state saved by that function - except there was an aborting','line_number':1779,'multiline':False]['text':'/ error, an interrupt or an uncaught exception during execution of the','line_number':1780,'multiline':False]['text':'/ cleanup autocommands.  In the latter case, the saved error/interrupt/','line_number':1781,'multiline':False]['text':'/ exception state is discarded.','line_number':1782,'multiline':False]['text':' nothing to do','line_number':1787,'multiline':False]['text':' If there was an aborting error, an interrupt, or an uncaught exception','line_number':1791,'multiline':False]['text':' after the corresponding call to enter_cleanup(), discard what has been','line_number':1792,'multiline':False]['text':' made pending by it.  Report this to the user if required by the','line_number':1793,'multiline':False]['text':' 'verbose' option or when debugging.','line_number':1794,'multiline':False]['text':' Cancel the pending exception (includes report).','line_number':1797,'multiline':False]['text':' If an error was about to be converted to an exception when','line_number':1803,'multiline':False]['text':' enter_cleanup() was called, free the message list.','line_number':1804,'multiline':False]['text':' If there was no new error, interrupt, or throw between the calls','line_number':1809,'multiline':False]['text':' to enter_cleanup() and leave_cleanup(), restore the pending','line_number':1810,'multiline':False]['text':' error/interrupt/exception state.','line_number':1811,'multiline':False]['text':' If there was an exception being thrown when enter_cleanup() was','line_number':1813,'multiline':False]['text':' called, we need to rethrow it.  Make it the exception currently','line_number':1814,'multiline':False]['text':' being thrown.','line_number':1815,'multiline':False]['text':' If an error was about to be converted to an exception when','line_number':1819,'multiline':False]['text':' enter_cleanup() was called, let "cause_abort" take the part of','line_number':1820,'multiline':False]['text':' "force_abort" (as done by cause_errthrow()).','line_number':1821,'multiline':False]['text':' Restore the pending values of did_emsg, got_int, and did_throw.','line_number':1826,'multiline':False]['text':' did_throw will be set by do_one_cmd()','line_number':1834,'multiline':False]['text':' Report if required by the 'verbose' option or when debugging.','line_number':1837,'multiline':False]['text':'/ Make conditionals inactive and discard what's pending in finally clauses','line_number':1842,'multiline':False]['text':'/ until the conditional type searched for or a try conditional not in its','line_number':1843,'multiline':False]['text':'/ finally clause is reached.  If this is in an active catch clause, finish','line_number':1844,'multiline':False]['text':'/ the caught exception.','line_number':1845,'multiline':False]['text':'/','line_number':1846,'multiline':False]['text':'/','line_number':1847,'multiline':False]['text':'/ @param searched_cond  Possible values are (CSF_WHILE | CSF_FOR) or CSF_TRY or 0,','line_number':1848,'multiline':False]['text':'/                       the latter meaning the innermost try conditional not','line_number':1849,'multiline':False]['text':'/                       in its finally clause.','line_number':1850,'multiline':False]['text':'/ @param inclusive      tells whether the conditional searched for should be made','line_number':1851,'multiline':False]['text':'/                       inactive itself (a try conditional not in its finally','line_number':1852,'multiline':False]['text':'/                       clause possibly find before is always made inactive).','line_number':1853,'multiline':False]['text':'/','line_number':1854,'multiline':False]['text':'/ If "inclusive" is true and "searched_cond" is CSF_TRY|CSF_SILENT, the saved','line_number':1855,'multiline':False]['text':'/ former value of "emsg_silent", if reset when the try conditional finally','line_number':1856,'multiline':False]['text':'/ reached was entered, is restored (used by ex_endtry()).  This is normally','line_number':1857,'multiline':False]['text':'/ done only when such a try conditional is left.','line_number':1858,'multiline':False]['text':'/','line_number':1859,'multiline':False]['text':'/ @return  the cstack index where the search stopped.','line_number':1860,'multiline':False]['text':' Discard anything pending in a finally clause and continue the','line_number':1868,'multiline':False]['text':' search.  There may also be a pending ":continue", ":break",','line_number':1869,'multiline':False]['text':' ":return", or ":finish" before the finally clause.  We must not','line_number':1870,'multiline':False]['text':' discard it, unless an error or interrupt occurred afterwards.','line_number':1871,'multiline':False]['text':' Cancel the pending exception.  This is in the','line_number':1894,'multiline':False]['text':' finally clause, so that the stack of the','line_number':1895,'multiline':False]['text':' caught exceptions is not involved.','line_number':1896,'multiline':False]['text':' Stop at a try conditional not in its finally clause.  If this try','line_number':1907,'multiline':False]['text':' conditional is in an active catch clause, finish the caught','line_number':1908,'multiline':False]['text':' exception.','line_number':1909,'multiline':False]['text':' Stop at this try conditional - except the try block never','line_number':1916,'multiline':False]['text':' got active (because of an inactive surrounding conditional','line_number':1917,'multiline':False]['text':' or when the ":try" appeared after an error or interrupt or','line_number':1918,'multiline':False]['text':' throw).','line_number':1919,'multiline':False]['text':' Stop on the searched conditional type (even when the surrounding','line_number':1929,'multiline':False]['text':' conditional is not active or something has been made pending).','line_number':1930,'multiline':False]['text':' If "inclusive" is true and "searched_cond" is CSF_TRY|CSF_SILENT,','line_number':1931,'multiline':False]['text':' check first whether "emsg_silent" needs to be restored.','line_number':1932,'multiline':False]['text':' When leaving a try conditional that reset "emsg_silent" on its','line_number':1944,'multiline':False]['text':' entry after saving the original value, restore that value here and','line_number':1945,'multiline':False]['text':' free the memory used to store it.','line_number':1946,'multiline':False]['text':'/ @return  an appropriate error message for a missing endwhile/endfor/endif.','line_number':1964,'multiline':False]['text':'/ Rewind conditionals until index "idx" is reached.  "cond_type" and','line_number':1976,'multiline':False]['text':'/ "cond_level" specify a conditional type and the address of a level variable','line_number':1977,'multiline':False]['text':'/ which is to be decremented with each skipped conditional of the specified','line_number':1978,'multiline':False]['text':'/ type.','line_number':1979,'multiline':False]['text':'/ Also free "for info" structures where needed.','line_number':1980,'multiline':False]['text':'/ Handle ":endfunction" when not after a ":function"','line_number':1994,'multiline':False]['text':'/ @return  true if the string "p" looks like a ":while" or ":for" command.','line_number':2000,'multiline':False]['text':' skip modifiers, white space and ':'','line_number':2003,'multiline':False]