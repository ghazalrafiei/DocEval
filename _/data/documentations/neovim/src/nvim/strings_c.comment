['text':'/ Copy up to `len` bytes of `string` into newly allocated memory and','line_number':67,'multiline':False]['text':'/ terminate with a NUL. The allocated memory always has size `len + 1`, even','line_number':68,'multiline':False]['text':'/ when `string` is shorter.','line_number':69,'multiline':False]['text':' NOLINT(runtime/printf)','line_number':73,'multiline':False]['text':' Same as vim_strsave(), but any characters found in esc_chars are preceded','line_number':76,'multiline':False]['text':' by a backslash.','line_number':77,'multiline':False]['text':' Same as vim_strsave_escaped(), but when "bsl" is true also escape','line_number':84,'multiline':False]['text':' characters where rem_backslash() would remove the backslash.','line_number':85,'multiline':False]['text':' Escape the characters with "cc".','line_number':86,'multiline':False]['text':' First count the number of backslashes required.','line_number':90,'multiline':False]['text':' Then allocate the memory and insert them.','line_number':91,'multiline':False]['text':' count the trailing NUL','line_number':92,'multiline':False]['text':' count a multibyte char','line_number':96,'multiline':False]['text':' count a backslash','line_number':101,'multiline':False]['text':' count an ordinary char','line_number':103,'multiline':False]['text':' skip multibyte char','line_number':113,'multiline':False]['text':'/ Save a copy of an unquoted string','line_number':126,'multiline':False]['text':'/','line_number':127,'multiline':False]['text':'/ Turns string like `a\bc"def\"ghi\\\n"jkl` into `a\bcdef"ghi\\njkl`, for use','line_number':128,'multiline':False]['text':'/ in shell_build_argv: the only purpose of backslash is making next character','line_number':129,'multiline':False]['text':'/ be treated literally inside the double quotes, if this character is','line_number':130,'multiline':False]['text':'/ backslash or quote.','line_number':131,'multiline':False]['text':'/','line_number':132,'multiline':False]['text':'/ @param[in]  string  String to copy.','line_number':133,'multiline':False]['text':'/ @param[in]  length  Length of the string to copy.','line_number':134,'multiline':False]['text':'/','line_number':135,'multiline':False]['text':'/ @return [allocated] Copy of the string.','line_number':136,'multiline':False]['text':'/ Escape "string" for use as a shell argument with system().','line_number':174,'multiline':False]['text':'/ This uses single quotes, except when we know we need to use double quotes','line_number':175,'multiline':False]['text':'/ (MS-Windows without 'shellslash' set).','line_number':176,'multiline':False]['text':'/ Escape a newline, depending on the 'shell' option.','line_number':177,'multiline':False]['text':'/ When "do_special" is true also replace "!", "%", "#" and things starting','line_number':178,'multiline':False]['text':'/ with "<" like "<cfile>".','line_number':179,'multiline':False]['text':'/ When "do_newline" is false do not escape newline unless it is csh shell.','line_number':180,'multiline':False]['text':'/','line_number':181,'multiline':False]['text':'/ @return  the result in allocated memory.','line_number':182,'multiline':False]['text':' Only csh and similar shells expand '!' within single quotes.  For sh and','line_number':192,'multiline':False]['text':' the like we must not put a backslash before it, it will be taken','line_number':193,'multiline':False]['text':' literally.  If do_special is set the '!' will be escaped twice.','line_number':194,'multiline':False]['text':' Csh also needs to have "\n" escaped twice when do_special is set.','line_number':195,'multiline':False]['text':' Fish shell uses '\' as an escape character within single quotes, so '\'','line_number':198,'multiline':False]['text':' itself must be escaped to get a literal '\'.','line_number':199,'multiline':False]['text':' First count the number of extra bytes required.','line_number':202,'multiline':False]['text':' two quotes and a trailing NUL','line_number':203,'multiline':False]['text':' " -> ""','line_number':208,'multiline':False]['text':' ' => '\''','line_number':213,'multiline':False]['text':' insert backslash','line_number':217,'multiline':False]['text':' insert backslash','line_number':219,'multiline':False]['text':' insert backslash','line_number':223,'multiline':False]['text':' insert backslash','line_number':227,'multiline':False]['text':' Allocate memory for the result and fill it.','line_number':231,'multiline':False]['text':' add opening quote','line_number':235,'multiline':False]['text':' insert backslash','line_number':272,'multiline':False]['text':' copy the var','line_number':273,'multiline':False]['text':' add terminating quote and finish with a NUL','line_number':287,'multiline':False]['text':' Like vim_strsave(), but make all characters uppercase.','line_number':299,'multiline':False]['text':' This uses ASCII lower-to-upper case translation, language independent.','line_number':300,'multiline':False]['text':'/ Like xstrnsave(), but make all characters uppercase.','line_number':311,'multiline':False]['text':'/ This uses ASCII lower-to-upper case translation, language independent.','line_number':312,'multiline':False]['text':' ASCII lower-to-upper case translation, language independent.','line_number':321,'multiline':False]['text':'/ Make given string all upper-case or all lower-case','line_number':331,'multiline':False]['text':'/','line_number':332,'multiline':False]['text':'/ Handles multi-byte characters as good as possible.','line_number':333,'multiline':False]['text':'/','line_number':334,'multiline':False]['text':'/ @param[in]  orig  Input string.','line_number':335,'multiline':False]['text':'/ @param[in]  upper If true make uppercase, otherwise lowercase','line_number':336,'multiline':False]['text':'/','line_number':337,'multiline':False]['text':'/ @return [allocated] upper-cased string.','line_number':338,'multiline':False]['text':' overlong sequence, use only the first byte','line_number':349,'multiline':False]['text':' Reallocate string when byte count changes.  This is rare,','line_number':355,'multiline':False]['text':' thus it's OK to do another malloc()/free().','line_number':356,'multiline':False]['text':' TODO(philix): use xrealloc() in strcase_save()','line_number':359,'multiline':False]['text':' delete spaces at the end of a string','line_number':375,'multiline':False]['text':' Compare two strings, ignoring case, using current locale.','line_number':388,'multiline':False]['text':' Doesn't work for multi-byte characters.','line_number':389,'multiline':False]['text':' return 0 for match, < 0 for smaller, > 0 for bigger','line_number':390,'multiline':False]['text':' this character different','line_number':399,'multiline':False]['text':' strings match until NUL','line_number':402,'multiline':False]['text':' strings match','line_number':407,'multiline':False]['text':' Compare two strings, for length "len", ignoring case, using current locale.','line_number':412,'multiline':False]['text':' Doesn't work for multi-byte characters.','line_number':413,'multiline':False]['text':' return 0 for match, < 0 for smaller, > 0 for bigger','line_number':414,'multiline':False]['text':' this character different','line_number':423,'multiline':False]['text':' strings match until NUL','line_number':426,'multiline':False]['text':' strings match','line_number':432,'multiline':False]['text':'/ Case-insensitive `strequal`.','line_number':436,'multiline':False]['text':'/ strchr() version which handles multibyte strings','line_number':443,'multiline':False]['text':'/','line_number':444,'multiline':False]['text':'/ @param[in]  string  String to search in.','line_number':445,'multiline':False]['text':'/ @param[in]  c  Character to search for.','line_number':446,'multiline':False]['text':'/','line_number':447,'multiline':False]['text':'/ @return Pointer to the first byte of the found character in string or NULL','line_number':448,'multiline':False]['text':'/         if it was not found or character is invalid. NUL character is never','line_number':449,'multiline':False]['text':'/         found, use `strlen()` instead.','line_number':450,'multiline':False]['text':' Sort an array of strings.','line_number':466,'multiline':False]['text':' Return true if string "s" contains a non-ASCII character (128 or higher).','line_number':479,'multiline':False]['text':' When "s" is NULL false is returned.','line_number':480,'multiline':False]['text':'/ Return true if string "s" contains a non-ASCII character (128 or higher).','line_number':494,'multiline':False]['text':'/ When "s" is NULL false is returned.','line_number':495,'multiline':False]['text':'/ Concatenate two strings and return the result in allocated memory.','line_number':509,'multiline':False]['text':'/ Get number argument from idxp entry in tvs','line_number':523,'multiline':False]['text':'/','line_number':524,'multiline':False]['text':'/ Will give an error message for Vimscript entry with invalid type or for insufficient entries.','line_number':525,'multiline':False]['text':'/','line_number':526,'multiline':False]['text':'/ @param[in]  tvs  List of Vimscript values. List is terminated by VAR_UNKNOWN value.','line_number':527,'multiline':False]['text':'/ @param[in,out]  idxp  Index in a list. Will be incremented. Indexing starts at 1.','line_number':528,'multiline':False]['text':'/','line_number':529,'multiline':False]['text':'/ @return Number value or 0 in case of error.','line_number':530,'multiline':False]['text':'/ Get string argument from idxp entry in tvs','line_number':550,'multiline':False]['text':'/','line_number':551,'multiline':False]['text':'/ Will give an error message for Vimscript entry with invalid type or for','line_number':552,'multiline':False]['text':'/ insufficient entries.','line_number':553,'multiline':False]['text':'/','line_number':554,'multiline':False]['text':'/ @param[in]  tvs  List of Vimscript values. List is terminated by VAR_UNKNOWN','line_number':555,'multiline':False]['text':'/                  value.','line_number':556,'multiline':False]['text':'/ @param[in,out]  idxp  Index in a list. Will be incremented.','line_number':557,'multiline':False]['text':'/ @param[out]  tofree  If the idxp entry in tvs is not a String or a Number,','line_number':558,'multiline':False]['text':'/                      it will be converted to String in the same format','line_number':559,'multiline':False]['text':'/                      as ":echo" and stored in "*tofree". The caller must','line_number':560,'multiline':False]['text':'/                      free "*tofree".','line_number':561,'multiline':False]['text':'/','line_number':562,'multiline':False]['text':'/ @return String value or NULL in case of error.','line_number':563,'multiline':False]['text':'/ Get pointer argument from the next entry in tvs','line_number':584,'multiline':False]['text':'/','line_number':585,'multiline':False]['text':'/ Will give an error message for Vimscript entry with invalid type or for','line_number':586,'multiline':False]['text':'/ insufficient entries.','line_number':587,'multiline':False]['text':'/','line_number':588,'multiline':False]['text':'/ @param[in]  tvs  List of typval_T values.','line_number':589,'multiline':False]['text':'/ @param[in,out]  idxp  Pointer to the index of the current value.','line_number':590,'multiline':False]['text':'/','line_number':591,'multiline':False]['text':'/ @return Pointer stored in typval_T or NULL.','line_number':592,'multiline':False]['text':'/ Get float argument from idxp entry in tvs','line_number':615,'multiline':False]['text':'/','line_number':616,'multiline':False]['text':'/ Will give an error message for Vimscript entry with invalid type or for','line_number':617,'multiline':False]['text':'/ insufficient entries.','line_number':618,'multiline':False]['text':'/','line_number':619,'multiline':False]['text':'/ @param[in]  tvs  List of Vimscript values. List is terminated by VAR_UNKNOWN value.','line_number':620,'multiline':False]['text':'/ @param[in,out]  idxp  Index in a list. Will be incremented.','line_number':621,'multiline':False]['text':'/','line_number':622,'multiline':False]['text':'/ @return Floating-point value or zero in case of error.','line_number':623,'multiline':False]['text':' This code was included to provide a portable vsnprintf() and snprintf().','line_number':645,'multiline':False]['text':' Some systems may provide their own, but we always use this one for','line_number':646,'multiline':False]['text':' consistency.','line_number':647,'multiline':False]['text':'','line_number':648,'multiline':False]['text':' This code is based on snprintf.c - a portable implementation of snprintf','line_number':649,'multiline':False]['text':' by Mark Martinec <mark.martinec@ijs.si>, Version 2.2, 2000-10-06.','line_number':650,'multiline':False]['text':' Included with permission.  It was heavily modified to fit in Vim.','line_number':651,'multiline':False]['text':' The original code, including useful comments, can be found here:','line_number':652,'multiline':False]['text':'','line_number':653,'multiline':False]['text':'     http://www.ijs.si/software/snprintf/','line_number':654,'multiline':False]['text':'','line_number':655,'multiline':False]['text':' This snprintf() only supports the following conversion specifiers:','line_number':656,'multiline':False]['text':' s, c, b, B, d, u, o, x, X, p  (and synonyms: i, D, U, O - see below)','line_number':657,'multiline':False]['text':' with flags: '-', '+', ' ', '0' and '#'.','line_number':658,'multiline':False]['text':' An asterisk is supported for field width as well as precision.','line_number':659,'multiline':False]['text':'','line_number':660,'multiline':False]['text':' Limited support for floating point was added: 'f', 'e', 'E', 'g', 'G'.','line_number':661,'multiline':False]['text':'','line_number':662,'multiline':False]['text':' Length modifiers 'h' (short int), 'l' (long int) and "ll" (long long int) are','line_number':663,'multiline':False]['text':' supported.','line_number':664,'multiline':False]['text':'','line_number':665,'multiline':False]['text':' The locale is not used, the string is used as a byte string.  This is only','line_number':666,'multiline':False]['text':' relevant for double-byte encodings where the second byte may be '%'.','line_number':667,'multiline':False]['text':'','line_number':668,'multiline':False]['text':' It is permitted for "str_m" to be zero, and it is permitted to specify NULL','line_number':669,'multiline':False]['text':' pointer for resulting string argument if "str_m" is zero (as per ISO C99).','line_number':670,'multiline':False]['text':'','line_number':671,'multiline':False]['text':' The return value is the number of characters which would be generated','line_number':672,'multiline':False]['text':' for the given input, excluding the trailing NUL. If this value','line_number':673,'multiline':False]['text':' is greater or equal to "str_m", not all characters from the result','line_number':674,'multiline':False]['text':' have been stored in str, output bytes beyond the ("str_m"-1) -th character','line_number':675,'multiline':False]['text':' are discarded. If "str_m" is greater than zero it is guaranteed','line_number':676,'multiline':False]['text':' the resulting string will be NUL-terminated.','line_number':677,'multiline':False]['text':' vim_vsnprintf_typval() can be invoked with either "va_list" or a list of','line_number':679,'multiline':False]['text':' "typval_T".  When the latter is not used it must be NULL.','line_number':680,'multiline':False]['text':'/ Append a formatted value to the string','line_number':682,'multiline':False]['text':'/','line_number':683,'multiline':False]['text':'/ @see vim_vsnprintf_typval().','line_number':684,'multiline':False]['text':'/ Write formatted value to the string','line_number':703,'multiline':False]['text':'/','line_number':704,'multiline':False]['text':'/ @param[out]  str  String to write to.','line_number':705,'multiline':False]['text':'/ @param[in]  str_m  String length.','line_number':706,'multiline':False]['text':'/ @param[in]  fmt  String format.','line_number':707,'multiline':False]['text':'/','line_number':708,'multiline':False]['text':'/ @return Number of bytes excluding NUL byte that would be written to the','line_number':709,'multiline':False]['text':'/         string if str_m was greater or equal to the return value.','line_number':710,'multiline':False]['text':' Return the representation of infinity for printf() function:','line_number':721,'multiline':False]['text':' "-inf", "inf", "+inf", " inf", "-INF", "INF", "+INF" or " INF".','line_number':722,'multiline':False]['text':'/ Types that can be used in a format string','line_number':759,'multiline':False]['text':' allowed values: \0, h, l, L','line_number':763,'multiline':False]['text':' current conversion specifier character','line_number':766,'multiline':False]['text':' parse 'h', 'l', 'll' and 'z' length modifiers','line_number':769,'multiline':False]['text':' double l = long long','line_number':774,'multiline':False]['text':' common synonyms:','line_number':781,'multiline':False]['text':' get parameter value, do initial processing','line_number':797,'multiline':False]['text':' '%' and 'c' behave similar to 's' regarding flags and field','line_number':799,'multiline':False]['text':' widths','line_number':800,'multiline':False]['text':' NOTE: the u, b, o, x, X and p conversion specifiers','line_number':819,'multiline':False]['text':' imply the value is unsigned;  d implies a signed','line_number':820,'multiline':False]['text':' value','line_number':821,'multiline':False]['text':' 0 if numeric argument is zero (or if pointer is','line_number':823,'multiline':False]['text':' NULL for 'p'), +1 if greater than zero (or nonzero','line_number':824,'multiline':False]['text':' for unsigned arguments), -1 if negative (unsigned','line_number':825,'multiline':False]['text':' argument is never negative)','line_number':826,'multiline':False]['text':' signed','line_number':833,'multiline':False]['text':' char and short arguments are passed as int.','line_number':837,'multiline':False]['text':' unsigned','line_number':847,'multiline':False]['text':' allowed values: \0, h, l, L','line_number':985,'multiline':False]['text':' variable for positional arg','line_number':988,'multiline':False]['text':' skip '%'','line_number':991,'multiline':False]['text':' First check to see if we find a positional','line_number':993,'multiline':False]['text':' argument specifier','line_number':994,'multiline':False]['text':' 0 flag at the wrong place','line_number':1003,'multiline':False]['text':' Positional argument','line_number':1008,'multiline':False]['text':' parse flags','line_number':1022,'multiline':False]['text':' If both the ' ' and '+' flags appear, the ' '','line_number':1032,'multiline':False]['text':' flag should be ignored','line_number':1033,'multiline':False]['text':' If the '0' and '-' flags both appear, the '0' flag should be','line_number':1042,'multiline':False]['text':' ignored.','line_number':1043,'multiline':False]['text':' parse field width','line_number':1045,'multiline':False]['text':' Positional argument field width','line_number':1050,'multiline':False]['text':' size_t could be wider than unsigned int; make sure we treat','line_number':1074,'multiline':False]['text':' argument like common implementations do','line_number':1075,'multiline':False]['text':' parse precision','line_number':1088,'multiline':False]['text':' Parse precision','line_number':1096,'multiline':False]['text':' size_t could be wider than unsigned int; make sure we','line_number':1121,'multiline':False]['text':' treat argument like common implementations do','line_number':1122,'multiline':False]['text':' parse 'h', 'l', 'll' and 'z' length modifiers','line_number':1143,'multiline':False]['text':' double l = long long','line_number':1148,'multiline':False]['text':' length_modifier = 'L';','line_number':1149,'multiline':False]['text':' Check for known format specifiers. % is special!','line_number':1155,'multiline':False]['text':' step over the just processed conversion specifier','line_number':1196,'multiline':False]['text':' Reset ap to ap_start and skip arg_idx - 1 types','line_number':1235,'multiline':False]['text':' Skip over any we should skip','line_number':1239,'multiline':False]['text':' get parameter value, do initial processing','line_number':1253,'multiline':False]['text':' NOLINT(runtime/int)','line_number':1280,'multiline':False]['text':' implementation-defined, usually ptrdiff_t','line_number':1283,'multiline':False]['text':' NOLINT(runtime/int)','line_number':1296,'multiline':False]['text':' Because we know that after we return from this call,','line_number':1309,'multiline':False]['text':' a va_arg() call is made, we can pre-emptively','line_number':1310,'multiline':False]['text':' increment the current argument index.','line_number':1311,'multiline':False]['text':'/ Write formatted value to the string','line_number':1316,'multiline':False]['text':'/','line_number':1317,'multiline':False]['text':'/ @param[out]  str  String to write to.','line_number':1318,'multiline':False]['text':'/ @param[in]  str_m  String length.','line_number':1319,'multiline':False]['text':'/ @param[in]  fmt  String format.','line_number':1320,'multiline':False]['text':'/ @param[in]  ap  Values that should be formatted. Ignored if tvs is not NULL.','line_number':1321,'multiline':False]['text':'/ @param[in]  tvs  Values that should be formatted, for printf() Vimscript','line_number':1322,'multiline':False]['text':'/                  function. Must be NULL in other cases.','line_number':1323,'multiline':False]['text':'/','line_number':1324,'multiline':False]['text':'/ @return Number of bytes excluding NUL byte that would be written to the','line_number':1325,'multiline':False]['text':'/         string if str_m was greater or equal to the return value.','line_number':1326,'multiline':False]['text':' copy up to the next '%' or NUL without any changes','line_number':1350,'multiline':False]['text':' if both ' ' and '+' flags appear, ' ' flag should be ignored','line_number':1365,'multiline':False]['text':' allowed values: \0, h, l, 2 (for ll), z, L','line_number':1368,'multiline':False]['text':' temporary buffer for simple numeric->string conversion','line_number':1371,'multiline':False]['text':' 1e308 seems reasonable as the maximum printable','line_number':1372,'multiline':False]['text':' string address in case of string argument','line_number':1375,'multiline':False]['text':' natural field width of arg without padding and sign','line_number':1378,'multiline':False]['text':' unsigned char argument value (only defined for c conversion);','line_number':1381,'multiline':False]['text':' standard explicitly states the char argument for the c','line_number':1382,'multiline':False]['text':' conversion is unsigned','line_number':1383,'multiline':False]['text':' number of zeros to be inserted for numeric conversions as','line_number':1386,'multiline':False]['text':' required by the precision or minimal field width','line_number':1387,'multiline':False]['text':' index into tmp where zero padding is to be inserted','line_number':1390,'multiline':False]['text':' current conversion specifier character','line_number':1393,'multiline':False]['text':' buffer for 's' and 'S' specs','line_number':1396,'multiline':False]['text':' variable for positional arg','line_number':1399,'multiline':False]['text':' skip '%'','line_number':1402,'multiline':False]['text':' First check to see if we find a positional','line_number':1404,'multiline':False]['text':' argument specifier','line_number':1405,'multiline':False]['text':' Positional argument','line_number':1413,'multiline':False]['text':' parse flags','line_number':1424,'multiline':False]['text':' if both '0' and '-' flags appear, '0' should be ignored','line_number':1431,'multiline':False]['text':' if both ' ' and '+' flags appear, ' ' should be ignored','line_number':1436,'multiline':False]['text':' parse field width','line_number':1447,'multiline':False]['text':' Positional argument field width','line_number':1452,'multiline':False]['text':' size_t could be wider than unsigned int; make sure we treat','line_number':1476,'multiline':False]['text':' argument like common implementations do','line_number':1477,'multiline':False]['text':' parse precision','line_number':1486,'multiline':False]['text':' size_t could be wider than unsigned int; make sure we','line_number':1492,'multiline':False]['text':' treat argument like common implementations do','line_number':1493,'multiline':False]['text':' positional argument','line_number':1504,'multiline':False]['text':' parse 'h', 'l', 'll' and 'z' length modifiers','line_number':1530,'multiline':False]['text':' double l = long long','line_number':1535,'multiline':False]['text':' common synonyms','line_number':1543,'multiline':False]['text':' get parameter value, do initial processing','line_number':1574,'multiline':False]['text':' '%' and 'c' behave similar to 's' regarding flags and field widths','line_number':1576,'multiline':False]['text':' standard demands unsigned char','line_number':1594,'multiline':False]['text':' make sure not to address string beyond the specified','line_number':1612,'multiline':False]['text':' precision','line_number':1613,'multiline':False]['text':' truncate string if necessary as requested by precision','line_number':1616,'multiline':False]['text':' memchr on HP does not like n > 2^31','line_number':1619,'multiline':False]['text':' TODO(elmart): check if this still holds / is relevant','line_number':1620,'multiline':False]['text':' u, b, B, o, x, X and p conversion specifiers imply','line_number':1659,'multiline':False]['text':' the value is unsigned; d implies a signed value','line_number':1660,'multiline':False]['text':' 0 if numeric argument is zero (or if pointer is NULL for 'p'),','line_number':1662,'multiline':False]['text':' +1 if greater than zero (or non NULL for 'p'),','line_number':1663,'multiline':False]['text':' -1 if negative (unsigned argument is never negative)','line_number':1664,'multiline':False]['text':' only defined for p conversion','line_number':1670,'multiline':False]['text':' signed','line_number':1684,'multiline':False]['text':' char and short arguments are passed as int16_t','line_number':1694,'multiline':False]['text':' NOLINT(runtime/int)','line_number':1711,'multiline':False]['text':' NOLINT(runtime/int)','line_number':1714,'multiline':False]['text':' implementation-defined, usually ptrdiff_t','line_number':1716,'multiline':False]['text':' unsigned','line_number':1730,'multiline':False]['text':' NOLINT(runtime/int)','line_number':1756,'multiline':False]['text':' NOLINT(runtime/int)','line_number':1759,'multiline':False]['text':' For d, i, u, o, x, and X conversions, if precision is specified,','line_number':1775,'multiline':False]['text':' '0' flag should be ignored. This is so with Solaris 2.6, Digital','line_number':1776,'multiline':False]['text':' UNIX 4.0, HPUX 10, Linux, FreeBSD, NetBSD; but not with Perl.','line_number':1777,'multiline':False]['text':' leave negative numbers for snprintf to handle, to','line_number':1786,'multiline':False]['text':' avoid handling tricky cases like (short int)-32768','line_number':1787,'multiline':False]['text':' alternate form should have no effect for p * conversion, but ...','line_number':1794,'multiline':False]['text':' default precision is 1','line_number':1799,'multiline':False]['text':' when zero value is formatted with an explicit precision 0,','line_number':1802,'multiline':False]['text':' resulting formatted string is empty (d, i, u, b, B, o, x, X, p)','line_number':1803,'multiline':False]['text':' pointer','line_number':1806,'multiline':False]['text':' signed','line_number':1811,'multiline':False]['text':' binary','line_number':1817,'multiline':False]['text':' unsigned','line_number':1830,'multiline':False]['text':' construct a simple format string for snprintf','line_number':1831,'multiline':False]['text':' include the optional minus sign and possible "0x" in the region','line_number':1843,'multiline':False]['text':' before the zero padding insertion point','line_number':1844,'multiline':False]['text':' unless zero is already the first character','line_number':1863,'multiline':False]['text':' assure leading zero for alternate-form octal numbers','line_number':1866,'multiline':False]['text':' precision is increased to force the first character to be','line_number':1869,'multiline':False]['text':' zero, except if a zero value is formatted with an explicit','line_number':1870,'multiline':False]['text':' precision of zero','line_number':1871,'multiline':False]['text':' zero padding to specified precision?','line_number':1875,'multiline':False]['text':' zero padding to specified minimal field width?','line_number':1880,'multiline':False]['text':' floating point','line_number':1897,'multiline':False]['text':' can't use %g directly, cause it prints "1.0" as "1"','line_number':1910,'multiline':False]['text':' Not a number: nan or NAN','line_number':1927,'multiline':False]['text':' Regular float number','line_number':1932,'multiline':False]['text':' make sure we don't get more digits than we have room for','line_number':1941,'multiline':False]['text':' Cast to char to avoid a conversion warning on Ubuntu 12.04.','line_number':1952,'multiline':False]['text':' using %g or %G: remove superfluous zeroes','line_number':1963,'multiline':False]['text':' remove superfluous '+' and leading zeroes from exponent','line_number':1969,'multiline':False]['text':' change "1.0e+07" to "1.0e07"','line_number':1971,'multiline':False]['text':' change "1.0e07" to "1.0e7"','line_number':1977,'multiline':False]['text':' remove trailing zeroes, but keep the one just after a dot','line_number':1986,'multiline':False]['text':' Be consistent: some printf("%e") use 1.0e+12 and some','line_number':1994,'multiline':False]['text':' 1.0e+012; remove one zero in the last case.','line_number':1995,'multiline':False]['text':' Padding 0's should be inserted after the sign.','line_number':2006,'multiline':False]['text':' unrecognized conversion specifier, keep format string as-is','line_number':2015,'multiline':False]['text':' turn zero padding off for non-numeric conversion','line_number':2016,'multiline':False]['text':' reset flags','line_number':2018,'multiline':False]['text':' discard the unrecognized conversion, just keep','line_number':2020,'multiline':False]['text':' the unrecognized conversion character','line_number':2021,'multiline':False]['text':' include invalid conversion specifier','line_number':2025,'multiline':False]['text':' unchanged if not at end-of-string','line_number':2027,'multiline':False]['text':' step over the just processed conversion specifier','line_number':2032,'multiline':False]['text':' insert padding to the left as requested by min_field_width;','line_number':2035,'multiline':False]['text':' this does not include the zero padding in case of numerical conversions','line_number':2036,'multiline':False]['text':' left padding with blank or zero','line_number':2040,'multiline':False]['text':' zero padding as requested by the precision or by the minimal','line_number':2052,'multiline':False]['text':' field width for numeric conversions required?','line_number':2053,'multiline':False]['text':' will not copy first part of numeric right now,','line_number':2055,'multiline':False]['text':' force it to be copied later in its entirety','line_number':2056,'multiline':False]['text':' insert first part of numerics (sign or '0x') before zero padding','line_number':2059,'multiline':False]['text':' insert zero padding as requested by precision or min field width','line_number':2071,'multiline':False]['text':' insert formatted string','line_number':2082,'multiline':False]['text':' (or as-is conversion specifier for unknown conversions)','line_number':2083,'multiline':False]['text':' insert right padding','line_number':2097,'multiline':False]['text':' right blank padding to the field width','line_number':2101,'multiline':False]['text':' make sure the string is nul-terminated even at the expense of','line_number':2118,'multiline':False]['text':' overwriting the last character (shouldn't happen, but just in case)','line_number':2119,'multiline':False]['text':' return the number of characters formatted (excluding trailing nul','line_number':2131,'multiline':False]['text':' character); that is, the number of characters that would have been','line_number':2132,'multiline':False]['text':' written to the buffer if it were large enough.','line_number':2133,'multiline':False]['text':' printed string didn't fit, resize and try again','line_number':2151,'multiline':False]['text':' include space for NUL terminator at the end','line_number':2153,'multiline':False]['text':'/ Reverse text into allocated memory.','line_number':2167,'multiline':False]['text':'/','line_number':2168,'multiline':False]['text':'/ @return  the allocated string.','line_number':2169,'multiline':False]['text':'/ Replace all occurrences of "what" with "rep" in "src". If no replacement happens then NULL is','line_number':2185,'multiline':False]['text':'/ returned otherwise return a newly allocated string.','line_number':2186,'multiline':False]['text':'/','line_number':2187,'multiline':False]['text':'/ @param[in] src  Source text','line_number':2188,'multiline':False]['text':'/ @param[in] what Substring to replace','line_number':2189,'multiline':False]['text':'/ @param[in] rep  Substring to replace with','line_number':2190,'multiline':False]['text':'/','line_number':2191,'multiline':False]['text':'/ @return [allocated] Copy of the string.','line_number':2192,'multiline':False]['text':' Count occurrences','line_number':2198,'multiline':False]['text':' Copy remaining','line_number':2221,'multiline':False]['text':'/ Implementation of "byteidx()" and "byteidxcomp()" functions','line_number':2227,'multiline':False]['text':' EOL reached.','line_number':2260,'multiline':False]['text':'/ "byteidx()" function','line_number':2277,'multiline':False]['text':'/ "byteidxcomp()" function','line_number':2283,'multiline':False]['text':'/ "charidx()" function','line_number':2289,'multiline':False]['text':' If the index is exactly the number of bytes or utf-16 code units','line_number':2328,'multiline':False]['text':' in the string then return the length of the string in characters.','line_number':2329,'multiline':False]['text':'/ "str2list()" function','line_number':2349,'multiline':False]['text':'/ "str2nr()" function','line_number':2360,'multiline':False]['text':' Text after the number is silently ignored.','line_number':2395,'multiline':False]['text':'/ "strgetchar()" function','line_number':2403,'multiline':False]['text':'/ "stridx()" function','line_number':2431,'multiline':False]['text':' Type error; errmsg already given.','line_number':2441,'multiline':False]['text':'/ "string()" function','line_number':2463,'multiline':False]['text':'/ "strlen()" function','line_number':2470,'multiline':False]['text':'/ "strcharlen()" function','line_number':2490,'multiline':False]['text':'/ "strchars()" function','line_number':2496,'multiline':False]['text':'/ "strutf16len()" function','line_number':2516,'multiline':False]['text':'/ "strdisplaywidth()" function','line_number':2546,'multiline':False]['text':'/ "strwidth()" function','line_number':2559,'multiline':False]['text':'/ "strcharpart()" function','line_number':2567,'multiline':False]['text':' default: all bytes that are available.','line_number':2621,'multiline':False]['text':' Only return the overlap between the specified part and the actual','line_number':2624,'multiline':False]['text':' string.','line_number':2625,'multiline':False]['text':'/ "strpart()" function','line_number':2642,'multiline':False]['text':' Default len: all bytes that are available.','line_number':2657,'multiline':False]['text':' Only return the overlap between the specified part and the actual','line_number':2660,'multiline':False]['text':' string.','line_number':2661,'multiline':False]['text':' length in characters','line_number':2677,'multiline':False]['text':'/ "strridx()" function','line_number':2688,'multiline':False]['text':' Type error; errmsg already given.','line_number':2697,'multiline':False]['text':' Third argument: upper limit for index.','line_number':2703,'multiline':False]['text':' Can never find a match.','line_number':2706,'multiline':False]['text':' Empty string matches past the end.','line_number':2714,'multiline':False]['text':'/ "strtrans()" function','line_number':2731,'multiline':False]['text':'/ "utf16idx()" function','line_number':2738,'multiline':False]['text':'/','line_number':2739,'multiline':False]['text':'/ Converts a byte or character offset in a string to the corresponding UTF-16','line_number':2740,'multiline':False]['text':'/ code unit offset.','line_number':2741,'multiline':False]['text':' If the index is exactly the number of bytes or characters in the','line_number':2781,'multiline':False]['text':' string then return the length of the string in utf-16 code units.','line_number':2782,'multiline':False]['text':'/ "tolower(string)" function','line_number':2803,'multiline':False]['text':'/ "toupper(string)" function','line_number':2810,'multiline':False]['text':'/ "tr(string, fromstr, tostr)" function','line_number':2817,'multiline':False]['text':' Default return value: empty string.','line_number':2827,'multiline':False]['text':' Type error; errmsg already given.','line_number':2831,'multiline':False]['text':' fromstr and tostr have to contain the same number of chars.','line_number':2836,'multiline':False]['text':' tostr is shorter than fromstr.','line_number':2856,'multiline':False]['text':' Check that fromstr and tostr have the same number of','line_number':2865,'multiline':False]['text':' (multi-byte) characters.  Done only once when a character','line_number':2866,'multiline':False]['text':' of in_str doesn't appear in fromstr.','line_number':2867,'multiline':False]['text':' add a terminating NUL','line_number':2886,'multiline':False]['text':'/ "trim({expr})" function','line_number':2896,'multiline':False]['text':' leading or trailing characters to trim','line_number':2925,'multiline':False]['text':' Trim leading characters','line_number':2938,'multiline':False]['text':' Trim trailing characters','line_number':2961,'multiline':False]