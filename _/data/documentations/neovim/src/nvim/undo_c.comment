['text':' undo.c: multi level undo facility','line_number':1,'multiline':False]['text':' The saved lines are stored in a list of lists (one for each buffer):','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':' b_u_oldhead------------------------------------------------+','line_number':5,'multiline':False]['text':'                                                            |','line_number':6,'multiline':False]['text':'                                                            V','line_number':7,'multiline':False]['text':'                +--------------+    +--------------+    +--------------+','line_number':8,'multiline':False]['text':' b_u_newhead--->| u_header     |    | u_header     |    | u_header     |','line_number':9,'multiline':False]['text':'                |     uh_next------>|     uh_next------>|     uh_next---->NULL','line_number':10,'multiline':False]['text':'         NULL<--------uh_prev  |<---------uh_prev  |<---------uh_prev  |','line_number':11,'multiline':False]['text':'                |     uh_entry |    |     uh_entry |    |     uh_entry |','line_number':12,'multiline':False]['text':'                +--------|-----+    +--------|-----+    +--------|-----+','line_number':13,'multiline':False]['text':'                         |                   |                   |','line_number':14,'multiline':False]['text':'                         V                   V                   V','line_number':15,'multiline':False]['text':'                +--------------+    +--------------+    +--------------+','line_number':16,'multiline':False]['text':'                | u_entry      |    | u_entry      |    | u_entry      |','line_number':17,'multiline':False]['text':'                |     ue_next  |    |     ue_next  |    |     ue_next  |','line_number':18,'multiline':False]['text':'                +--------|-----+    +--------|-----+    +--------|-----+','line_number':19,'multiline':False]['text':'                         |                   |                   |','line_number':20,'multiline':False]['text':'                         V                   V                   V','line_number':21,'multiline':False]['text':'                +--------------+            NULL                NULL','line_number':22,'multiline':False]['text':'                | u_entry      |','line_number':23,'multiline':False]['text':'                |     ue_next  |','line_number':24,'multiline':False]['text':'                +--------|-----+','line_number':25,'multiline':False]['text':'                         |','line_number':26,'multiline':False]['text':'                         V','line_number':27,'multiline':False]['text':'                        etc.','line_number':28,'multiline':False]['text':'','line_number':29,'multiline':False]['text':' Each u_entry list contains the information for one undo or redo.','line_number':30,'multiline':False]['text':' curbuf->b_u_curhead points to the header of the last undo (the next redo),','line_number':31,'multiline':False]['text':' or is NULL if nothing has been undone (end of the branch).','line_number':32,'multiline':False]['text':'','line_number':33,'multiline':False]['text':' For keeping alternate undo/redo branches the uh_alt field is used.  Thus at','line_number':34,'multiline':False]['text':' each point in the list a branch may appear for an alternate to redo.  The','line_number':35,'multiline':False]['text':' uh_seq field is numbered sequentially to be able to find a newer or older','line_number':36,'multiline':False]['text':' branch.','line_number':37,'multiline':False]['text':'','line_number':38,'multiline':False]['text':'                 +---------------+    +---------------+','line_number':39,'multiline':False]['text':' b_u_oldhead --->| u_header      |    | u_header      |','line_number':40,'multiline':False]['text':'                 |   uh_alt_next ---->|   uh_alt_next ----> NULL','line_number':41,'multiline':False]['text':'         NULL <----- uh_alt_prev |<------ uh_alt_prev |','line_number':42,'multiline':False]['text':'                 |   uh_prev     |    |   uh_prev     |','line_number':43,'multiline':False]['text':'                 +-----|---------+    +-----|---------+','line_number':44,'multiline':False]['text':'                       |                    |','line_number':45,'multiline':False]['text':'                       V                    V','line_number':46,'multiline':False]['text':'                 +---------------+    +---------------+','line_number':47,'multiline':False]['text':'                 | u_header      |    | u_header      |','line_number':48,'multiline':False]['text':'                 |   uh_alt_next |    |   uh_alt_next |','line_number':49,'multiline':False]['text':' b_u_newhead --->|   uh_alt_prev |    |   uh_alt_prev |','line_number':50,'multiline':False]['text':'                 |   uh_prev     |    |   uh_prev     |','line_number':51,'multiline':False]['text':'                 +-----|---------+    +-----|---------+','line_number':52,'multiline':False]['text':'                       |                    |','line_number':53,'multiline':False]['text':'                       V                    V','line_number':54,'multiline':False]['text':'                     NULL             +---------------+    +---------------+','line_number':55,'multiline':False]['text':'                                      | u_header      |    | u_header      |','line_number':56,'multiline':False]['text':'                                      |   uh_alt_next ---->|   uh_alt_next |','line_number':57,'multiline':False]['text':'                                      |   uh_alt_prev |<------ uh_alt_prev |','line_number':58,'multiline':False]['text':'                                      |   uh_prev     |    |   uh_prev     |','line_number':59,'multiline':False]['text':'                                      +-----|---------+    +-----|---------+','line_number':60,'multiline':False]['text':'                                            |                    |','line_number':61,'multiline':False]['text':'                                           etc.                 etc.','line_number':62,'multiline':False]['text':'','line_number':63,'multiline':False]['text':'','line_number':64,'multiline':False]['text':' All data is allocated and will all be freed when the buffer is unloaded.','line_number':65,'multiline':False]['text':' Uncomment the next line for including the u_check() function.  This warns','line_number':67,'multiline':False]['text':' for errors in the debug information.','line_number':68,'multiline':False]['text':' #define U_DEBUG 1','line_number':69,'multiline':False]['text':' value for uh_magic when in use','line_number':70,'multiline':False]['text':' value for ue_magic when in use','line_number':71,'multiline':False]['text':'/ Structure passed around between undofile functions.','line_number':129,'multiline':False]['text':' used in undo_end() to report number of added and deleted lines','line_number':146,'multiline':False]['text':' When 'u' flag included in 'cpoptions', we behave like vi.  Need to remember','line_number':149,'multiline':False]['text':' the action that "u" should do.','line_number':150,'multiline':False]['text':' Check the undo structures for being valid.  Print a warning when something','line_number':156,'multiline':False]['text':' looks wrong.','line_number':157,'multiline':False]['text':' Check pointers back are correct.','line_number':180,'multiline':False]['text':' Check the undo tree at this header.','line_number':192,'multiline':False]['text':' Check the next alt tree.','line_number':200,'multiline':False]['text':' Check the next header in this branch.','line_number':203,'multiline':False]['text':'/ Save the current line for both the "u" and "U" command.','line_number':232,'multiline':False]['text':'/ Careful: may trigger autocommands that reload the buffer.','line_number':233,'multiline':False]['text':'/ Returns OK or FAIL.','line_number':234,'multiline':False]['text':'/ Save the lines between "top" and "bot" for both the "u" and "U" command.','line_number':244,'multiline':False]['text':'/ "top" may be 0 and bot may be curbuf->b_ml.ml_line_count + 1.','line_number':245,'multiline':False]['text':'/ Careful: may trigger autocommands that reload the buffer.','line_number':246,'multiline':False]['text':'/ Returns FAIL when lines could not be saved, OK otherwise.','line_number':247,'multiline':False]['text':' rely on caller to do error messages','line_number':256,'multiline':False]['text':'/ Save the line "lnum" (used by ":s" and "~" command).','line_number':266,'multiline':False]['text':'/ The line is replaced, so the new bottom line is lnum + 1.','line_number':267,'multiline':False]['text':'/ Careful: may trigger autocommands that reload the buffer.','line_number':268,'multiline':False]['text':'/ Returns FAIL when lines could not be saved, OK otherwise.','line_number':269,'multiline':False]['text':'/ A new line is inserted before line "lnum" (used by :s command).','line_number':275,'multiline':False]['text':'/ The line is inserted, so the new bottom line is lnum + 1.','line_number':276,'multiline':False]['text':'/ Careful: may trigger autocommands that reload the buffer.','line_number':277,'multiline':False]['text':'/ Returns FAIL when lines could not be saved, OK otherwise.','line_number':278,'multiline':False]['text':'/ Save the lines "lnum" - "lnum" + nlines (used by delete command).','line_number':284,'multiline':False]['text':'/ The lines are deleted, so the new bottom line is lnum, unless the buffer','line_number':285,'multiline':False]['text':'/ becomes empty.','line_number':286,'multiline':False]['text':'/ Careful: may trigger autocommands that reload the buffer.','line_number':287,'multiline':False]['text':'/ Returns FAIL when lines could not be saved, OK otherwise.','line_number':288,'multiline':False]['text':'/ Return true when undo is allowed. Otherwise print an error message and','line_number':295,'multiline':False]['text':'/ return false.','line_number':296,'multiline':False]['text':'/','line_number':297,'multiline':False]['text':'/ @return true if undo is allowed.','line_number':298,'multiline':False]['text':' Don't allow changes when 'modifiable' is off.','line_number':301,'multiline':False]['text':' In the sandbox it's not allowed to change the text.','line_number':307,'multiline':False]['text':' Don't allow changes in the buffer while editing the cmdline.  The','line_number':313,'multiline':False]['text':' caller of getcmdline() may get confused.','line_number':314,'multiline':False]['text':'/ Get the 'undolevels' value for the current buffer.','line_number':323,'multiline':False]['text':'/ Common code for various ways to save text before a change.','line_number':340,'multiline':False]['text':'/ "top" is the line above the first changed line.','line_number':341,'multiline':False]['text':'/ "bot" is the line below the last changed line.','line_number':342,'multiline':False]['text':'/ "newbot" is the new bottom line.  Use zero when not known.','line_number':343,'multiline':False]['text':'/ "reload" is true when saving for a buffer reload.','line_number':344,'multiline':False]['text':'/ Careful: may trigger autocommands that reload the buffer.','line_number':345,'multiline':False]['text':'/ Returns FAIL when lines could not be saved, OK otherwise.','line_number':346,'multiline':False]['text':' When making changes is not allowed return FAIL.  It's a crude way','line_number':350,'multiline':False]['text':' to make all change commands fail.','line_number':351,'multiline':False]['text':' Saving text for undo means we are going to make a change.  Give a','line_number':356,'multiline':False]['text':' warning for a read-only file before making the change, so that the','line_number':357,'multiline':False]['text':' FileChangedRO event can replace the buffer with a read-write version','line_number':358,'multiline':False]['text':' (e.g., obtained from a source control system).','line_number':359,'multiline':False]['text':'  This happens when the FileChangedRO autocommand changes the','line_number':365,'multiline':False]['text':'  file in a way it becomes shorter.','line_number':366,'multiline':False]['text':' If curbuf->b_u_synced == true make a new header.','line_number':380,'multiline':False]['text':' Need to create new entry in b_changelist.','line_number':382,'multiline':False]['text':' Make a new header entry.  Do this first so that we don't mess','line_number':387,'multiline':False]['text':' up the undo info when out of memory.','line_number':388,'multiline':False]['text':' If we undid more than we redid, move the entry lists before and','line_number':398,'multiline':False]['text':' including curbuf->b_u_curhead to an alternate branch.','line_number':399,'multiline':False]['text':' free headers to keep the size right','line_number':406,'multiline':False]['text':' Can't reconnect the branch, delete all of it.','line_number':412,'multiline':False]['text':' There is no branch, only free one header.','line_number':415,'multiline':False]['text':' Free the oldest alternate branch as a whole.','line_number':418,'multiline':False]['text':' no undo at all','line_number':429,'multiline':False]['text':' save cursor pos. for undo','line_number':469,'multiline':False]['text':' save changed and buffer empty flag for undo','line_number':476,'multiline':False]['text':' save named marks and Visual marks for undo','line_number':480,'multiline':False]['text':' no undo at all','line_number':493,'multiline':False]['text':' When saving a single line, and it has been saved just before, it','line_number':497,'multiline':False]['text':' doesn't make sense saving it again.  Saves a lot of memory when','line_number':498,'multiline':False]['text':' making lots of changes inside the same line.','line_number':499,'multiline':False]['text':' This is only possible if the previous change didn't increase or','line_number':500,'multiline':False]['text':' decrease the number of lines.','line_number':501,'multiline':False]['text':' Check the ten last changes.  More doesn't make sense and takes too','line_number':502,'multiline':False]['text':' long.','line_number':503,'multiline':False]['text':' If lines have been inserted/deleted we give up.','line_number':512,'multiline':False]['text':' Also when the line was included in a multi-line save.','line_number':513,'multiline':False]['text':' If it's the same line we can skip saving it again.','line_number':526,'multiline':False]['text':' It's not the last entry: get ue_bot for the last','line_number':529,'multiline':False]['text':' entry now.  Following deleted/inserted lines go to','line_number':530,'multiline':False]['text':' the re-used entry.','line_number':531,'multiline':False]['text':' Move the found entry to become the last entry.  The','line_number':535,'multiline':False]['text':' order of undo/redo doesn't matter for the entries','line_number':536,'multiline':False]['text':' we move it over, since they don't change the line','line_number':537,'multiline':False]['text':' count and don't include this line.  It does matter','line_number':538,'multiline':False]['text':' for the found entry if the line count is changed by','line_number':539,'multiline':False]['text':' the executed command.','line_number':540,'multiline':False]['text':' The executed command may change the line count.','line_number':546,'multiline':False]['text':' find line number for ue_bot for previous u_save()','line_number':562,'multiline':False]['text':' add lines in front of entry list','line_number':566,'multiline':False]['text':' Use 0 for ue_bot if bot is below last line.','line_number':577,'multiline':False]['text':' Otherwise we have to compute ue_bot later.','line_number':578,'multiline':False]['text':' buffer was reloaded, notify text change subscribers','line_number':605,'multiline':False]['text':' magic at start of undofile','line_number':617,'multiline':False]['text':' magic at start of header','line_number':620,'multiline':False]['text':' magic after last header','line_number':622,'multiline':False]['text':' magic at start of entry','line_number':624,'multiline':False]['text':' magic after last entry','line_number':626,'multiline':False]['text':' 2-byte undofile version number','line_number':629,'multiline':False]['text':' extra fields for header','line_number':632,'multiline':False]['text':' extra fields for uhp','line_number':635,'multiline':False]['text':'/ Compute the hash for a buffer text into hash[UNDO_HASH_SIZE].','line_number':640,'multiline':False]['text':'/','line_number':641,'multiline':False]['text':'/ @param[in] buf The buffer used to compute the hash','line_number':642,'multiline':False]['text':'/ @param[in] hash Array of size UNDO_HASH_SIZE in which to store the value of','line_number':643,'multiline':False]['text':'/                 the hash','line_number':644,'multiline':False]['text':'/ Return an allocated string of the full path of the target undofile.','line_number':656,'multiline':False]['text':'/','line_number':657,'multiline':False]['text':'/ @param[in]  buf_ffname  Full file name for which undo file location should','line_number':658,'multiline':False]['text':'/                         be found.','line_number':659,'multiline':False]['text':'/ @param[in]  reading  If true, find the file to read by traversing all of the','line_number':660,'multiline':False]['text':'/                      directories in &undodir. If false use the first','line_number':661,'multiline':False]['text':'/                      existing directory. If none of the directories in','line_number':662,'multiline':False]['text':'/                      &undodir option exist then last directory in the list','line_number':663,'multiline':False]['text':'/                      will be automatically created.','line_number':664,'multiline':False]['text':'/','line_number':665,'multiline':False]['text':'/ @return [allocated] File name to read from/write to or NULL.','line_number':666,'multiline':False]['text':' Expand symlink in the file name, so that we put the undo file with the','line_number':678,'multiline':False]['text':' actual file instead of with the symlink.','line_number':679,'multiline':False]['text':' Loop over 'undodir'.  When reading find the first file that exists.','line_number':689,'multiline':False]['text':' When not reading use the first directory that exists or ".".','line_number':690,'multiline':False]['text':' Use same directory as the ffname,','line_number':695,'multiline':False]['text':' "dir/name" -> "dir/.name.un~"','line_number':696,'multiline':False]['text':' Remove trailing pathseps from directory name','line_number':708,'multiline':False]['text':' Last directory in the list does not exist, create it.','line_number':716,'multiline':False]['text':' When reading check if the file exists.','line_number':740,'multiline':False]['text':'/ Display an error for corrupted undo file','line_number':752,'multiline':False]['text':'/','line_number':753,'multiline':False]['text':'/ @param[in]  mesg  Identifier of the corruption kind.','line_number':754,'multiline':False]['text':'/ @param[in]  file_name  File in which error occurred.','line_number':755,'multiline':False]['text':'/ Writes the undofile header.','line_number':773,'multiline':False]['text':'/','line_number':774,'multiline':False]['text':'/ @param bi   The buffer information','line_number':775,'multiline':False]['text':'/ @param hash The hash of the buffer contents','line_number':776,'multiline':False]['text':'','line_number':777,'multiline':False]['text':'/ @returns false in case of an error.','line_number':778,'multiline':False]['text':' Start writing, first the magic marker and undo info version.','line_number':785,'multiline':False]['text':' Write a hash of the buffer text, so that we can verify it is','line_number':792,'multiline':False]['text':' still the same when reading the buffer text.','line_number':793,'multiline':False]['text':' Write buffer-specific data.','line_number':798,'multiline':False]['text':' Write undo structures header data.','line_number':808,'multiline':False]['text':' Write optional fields.','line_number':820,'multiline':False]['text':' Write end marker.','line_number':825,'multiline':False]['text':'/ Writes an undo header.','line_number':831,'multiline':False]['text':'/','line_number':832,'multiline':False]['text':'/ @param bi  The buffer information','line_number':833,'multiline':False]['text':'/ @param uhp The undo header to write','line_number':834,'multiline':False]['text':'','line_number':835,'multiline':False]['text':'/ @returns false in case of an error.','line_number':836,'multiline':False]['text':' Assume NMARKS will stay the same.','line_number':851,'multiline':False]['text':' Write optional fields.','line_number':860,'multiline':False]['text':' Write end marker.','line_number':865,'multiline':False]['text':' Write all the entries.','line_number':868,'multiline':False]['text':' Write all extmark undo objects','line_number':877,'multiline':False]['text':' Unserialize optional fields.','line_number':917,'multiline':False]['text':' Field not supported, skip it.','line_number':935,'multiline':False]['text':' Unserialize the uep list.','line_number':942,'multiline':False]['text':' Unserialize all extmark undo information','line_number':965,'multiline':False]['text':' Note: We do not serialize ExtmarkSavePos information, since','line_number':1005,'multiline':False]['text':' buffer marktrees are not retained when closing/reopening a file','line_number':1006,'multiline':False]['text':'/ Serializes "uep".','line_number':1049,'multiline':False]['text':'/','line_number':1050,'multiline':False]['text':'/ @param bi  The buffer information','line_number':1051,'multiline':False]['text':'/ @param uep The undo entry to write','line_number':1052,'multiline':False]['text':'','line_number':1053,'multiline':False]['text':'/ @returns false in case of an error.','line_number':1054,'multiline':False]['text':'/ Serializes "pos".','line_number':1113,'multiline':False]['text':'/ Unserializes the pos_T at the current position.','line_number':1121,'multiline':False]['text':'/ Serializes "info".','line_number':1138,'multiline':False]['text':'/ Unserializes the visualinfo_T at the current position.','line_number':1147,'multiline':False]['text':'/ Write the undo tree in an undo file.','line_number':1156,'multiline':False]['text':'/','line_number':1157,'multiline':False]['text':'/ @param[in]  name  Name of the undo file or NULL if this function needs to','line_number':1158,'multiline':False]['text':'/                   generate the undo file name based on buf->b_ffname.','line_number':1159,'multiline':False]['text':'/ @param[in]  forceit  True for `:wundo!`, false otherwise.','line_number':1160,'multiline':False]['text':'/ @param[in]  buf  Buffer for which undo file is written.','line_number':1161,'multiline':False]['text':'/ @param[in]  hash  Hash value of the buffer text. Must have #UNDO_HASH_SIZE','line_number':1162,'multiline':False]['text':'/                   size.','line_number':1163,'multiline':False]['text':' Decide about the permission to use for the undo file.  If the buffer','line_number':1188,'multiline':False]['text':' has a name use the permission of the original file.  Otherwise only','line_number':1189,'multiline':False]['text':' allow the user to access the undo file.','line_number':1190,'multiline':False]['text':' Strip any sticky and executable bits.','line_number':1199,'multiline':False]['text':' If the undo file already exists, verify that it actually is an undo','line_number':1204,'multiline':False]['text':' file, and delete it.','line_number':1205,'multiline':False]['text':' Check we can read it and it's an undo file.','line_number':1208,'multiline':False]['text':' If there is no undo information at all, quit here after deleting any','line_number':1245,'multiline':False]['text':' existing undo file.','line_number':1246,'multiline':False]['text':' Check there is no problem in undo info before writing.','line_number':1267,'multiline':False]['text':' Try to set the group of the undo file same as the original file. If','line_number':1272,'multiline':False]['text':' this fails, set the protection bits for the group same as the','line_number':1273,'multiline':False]['text':' protection bits for others.','line_number':1274,'multiline':False]['text':' Undo must be synced.','line_number':1294,'multiline':False]['text':' Write the header.','line_number':1297,'multiline':False]['text':' Iteratively serialize UHPs and their UEPs from the top down.','line_number':1306,'multiline':False]['text':' Serialize current UHP if we haven't seen it','line_number':1310,'multiline':False]['text':' Now walk through the tree - algorithm from undo_time().','line_number':1321,'multiline':False]['text':' For systems that support ACL: get the ACL from the original file.','line_number':1358,'multiline':False]['text':'/ Loads the undo tree from an undo file.','line_number':1370,'multiline':False]['text':'/ If "name" is not NULL use it as the undo file name. This also means being','line_number':1371,'multiline':False]['text':'/ a bit more verbose.','line_number':1372,'multiline':False]['text':'/ Otherwise use curbuf->b_ffname to generate the undo file name.','line_number':1373,'multiline':False]['text':'/ "hash[UNDO_HASH_SIZE]" must be the hash value of the buffer text.','line_number':1374,'multiline':False]['text':' For safety we only read an undo file if the owner is equal to the','line_number':1389,'multiline':False]['text':' owner of the text file or equal to the current user.','line_number':1390,'multiline':False]['text':' Read the undo file header.','line_number':1429,'multiline':False]['text':' Read undo data for "U" command.','line_number':1462,'multiline':False]['text':' Begin general undo data','line_number':1478,'multiline':False]['text':' Optional header fields.','line_number':1487,'multiline':False]['text':' field not supported, skip','line_number':1502,'multiline':False]['text':' uhp_table will store the freshly created undo headers we allocate','line_number':1509,'multiline':False]['text':' until we insert them into curbuf. The table remains sorted by the','line_number':1510,'multiline':False]['text':' sequence numbers of the headers.','line_number':1511,'multiline':False]['text':' When there are no headers uhp_table is NULL.','line_number':1512,'multiline':False]['text':' We have put all of the headers into a table. Now we iterate through the','line_number':1553,'multiline':False]['text':' table and swizzle each sequence number we have stored in uh_*_seq into','line_number':1554,'multiline':False]['text':' a pointer corresponding to the header with that sequence number.','line_number':1555,'multiline':False]['text':' Now that we have read the undo info successfully, free the current undo','line_number':1618,'multiline':False]['text':' info and use the info from the file.','line_number':1619,'multiline':False]['text':'/ Writes a sequence of bytes to the undo file.','line_number':1672,'multiline':False]['text':'/','line_number':1673,'multiline':False]['text':'/ @param bi  The buffer info','line_number':1674,'multiline':False]['text':'/ @param ptr The byte buffer to write','line_number':1675,'multiline':False]['text':'/ @param len The number of bytes to write','line_number':1676,'multiline':False]['text':'/','line_number':1677,'multiline':False]['text':'/ @returns false in case of an error.','line_number':1678,'multiline':False]['text':'/ Writes a number, most significant bit first, in "len" bytes.','line_number':1685,'multiline':False]['text':'/','line_number':1686,'multiline':False]['text':'/ Must match with undo_read_?c() functions.','line_number':1687,'multiline':False]['text':'/','line_number':1688,'multiline':False]['text':'/ @param bi  The buffer info','line_number':1689,'multiline':False]['text':'/ @param nr  The number to write','line_number':1690,'multiline':False]['text':'/ @param len The number of bytes to use when writing the number.','line_number':1691,'multiline':False]['text':'/','line_number':1692,'multiline':False]['text':'/ @returns false in case of an error.','line_number':1693,'multiline':False]['text':'/ Writes the pointer to an undo header.','line_number':1704,'multiline':False]['text':'/','line_number':1705,'multiline':False]['text':'/ Instead of writing the pointer itself, we use the sequence','line_number':1706,'multiline':False]['text':'/ number of the header. This is converted back to pointers','line_number':1707,'multiline':False]['text':'/ when reading.','line_number':1708,'multiline':False]['text':'/ Reads "buffer[size]" from the undo file.','line_number':1735,'multiline':False]['text':'/','line_number':1736,'multiline':False]['text':'/ @param bi     The buffer info','line_number':1737,'multiline':False]['text':'/ @param buffer Character buffer to read data into','line_number':1738,'multiline':False]['text':'/ @param size   The size of the character buffer','line_number':1739,'multiline':False]['text':'/','line_number':1740,'multiline':False]['text':'/ @returns false in case of an error.','line_number':1741,'multiline':False]['text':' Error may be checked for only later.  Fill with zeros,','line_number':1747,'multiline':False]['text':' so that the reader won't use garbage.','line_number':1748,'multiline':False]['text':'/ Reads a string of length "len" from "bi->bi_fd" and appends a zero to it.','line_number':1754,'multiline':False]['text':'/','line_number':1755,'multiline':False]['text':'/ @param len can be zero to allocate an empty line.','line_number':1756,'multiline':False]['text':'/','line_number':1757,'multiline':False]['text':'/ @returns a pointer to allocated memory or NULL in case of an error.','line_number':1758,'multiline':False]['text':'/ If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible).','line_number':1769,'multiline':False]['text':'/ If 'cpoptions' does not contain 'u': Always undo.','line_number':1770,'multiline':False]['text':' If we get an undo command while executing a macro, we behave like the','line_number':1773,'multiline':False]['text':' original vi. If this happens twice in one macro the result will not','line_number':1774,'multiline':False]['text':' be compatible.','line_number':1775,'multiline':False]['text':'/ If 'cpoptions' contains 'u': Repeat the previous undo or redo.','line_number':1789,'multiline':False]['text':'/ If 'cpoptions' does not contain 'u': Always redo.','line_number':1790,'multiline':False]['text':'/ Undo and remove the branch from the undo tree.','line_number':1800,'multiline':False]['text':'/ Also moves the cursor (as a "normal" undo would).','line_number':1801,'multiline':False]['text':'/','line_number':1802,'multiline':False]['text':'/ @param do_buf_event If `true`, send the changedtick with the buffer updates','line_number':1803,'multiline':False]['text':' nothing was undone.','line_number':1814,'multiline':False]['text':' Delete the current redo header','line_number':1818,'multiline':False]['text':' set the redo header to the next alternative branch (if any)','line_number':1819,'multiline':False]['text':' otherwise we will be in the leaf state','line_number':1820,'multiline':False]['text':'/ Undo or redo, depending on `undo_undoes`, `count` times.','line_number':1845,'multiline':False]['text':'/','line_number':1846,'multiline':False]['text':'/ @param startcount How often to undo or redo','line_number':1847,'multiline':False]['text':'/ @param quiet If `true`, don't show messages','line_number':1848,'multiline':False]['text':'/ @param do_buf_event If `true`, send the changedtick with the buffer updates','line_number':1849,'multiline':False]['text':' Do the change warning now, so that it triggers FileChangedRO when','line_number':1864,'multiline':False]['text':' needed.  This may cause the file to be reloaded, that must happen','line_number':1865,'multiline':False]['text':' before we do anything, because it may change curbuf->b_u_curhead','line_number':1866,'multiline':False]['text':' and more.','line_number':1867,'multiline':False]['text':' first undo','line_number':1871,'multiline':False]['text':' multi level undo','line_number':1873,'multiline':False]['text':' get next undo','line_number':1874,'multiline':False]['text':' nothing to undo','line_number':1877,'multiline':False]['text':' stick curbuf->b_u_curhead at end','line_number':1879,'multiline':False]['text':' nothing to redo','line_number':1892,'multiline':False]['text':' Advance for next redo.  Set "newhead" when at the end of the','line_number':1902,'multiline':False]['text':' redoable changes.','line_number':1903,'multiline':False]['text':' Undo or redo over the timeline.','line_number':1913,'multiline':False]['text':' When "step" is negative go back in time, otherwise goes forward in time.','line_number':1914,'multiline':False]['text':' When "sec" is false make "step" steps, when "sec" is true use "step" as','line_number':1915,'multiline':False]['text':' seconds.','line_number':1916,'multiline':False]['text':' When "file" is true use "step" as a number of file writes.','line_number':1917,'multiline':False]['text':' When "absolute" is true use "step" as the sequence number to jump to.','line_number':1918,'multiline':False]['text':' "sec" must be false then.','line_number':1919,'multiline':False]['text':' First make sure the current undoable change is synced.','line_number':1927,'multiline':False]['text':' "target" is the node below which we want to be.','line_number':1946,'multiline':False]['text':' Init "closest" to a value we can't reach.','line_number':1947,'multiline':False]['text':' Going back to a previous write. If there were changes after','line_number':1956,'multiline':False]['text':' the last write, count that as moving one file-write, so','line_number':1957,'multiline':False]['text':' that ":earlier 1f" undoes all changes since the last save.','line_number':1958,'multiline':False]['text':' "uh_save_nr" was set in the last block, that means','line_number':1966,'multiline':False]['text':' there were no changes since the last write','line_number':1967,'multiline':False]['text':' count the changes since the last write as one step','line_number':1970,'multiline':False]['text':' Go to before first write: before the oldest change. Use','line_number':1974,'multiline':False]['text':' the sequence number for that.','line_number':1975,'multiline':False]['text':' Moving forward to a newer write.','line_number':1979,'multiline':False]['text':' Go to after last write: after the latest change. Use','line_number':1982,'multiline':False]['text':' the sequence number for that.','line_number':1983,'multiline':False]['text':' shut up compiler','line_number':2012,'multiline':False]['text':' When "target" is 0; Back to origin.','line_number':2014,'multiline':False]['text':' avoid that GCC complains','line_number':2016,'multiline':False]['text':' May do this twice:','line_number':2020,'multiline':False]['text':' 1. Search for "target", update "closest" to the best match found.','line_number':2021,'multiline':False]['text':' 2. If "target" not found search for "closest".','line_number':2022,'multiline':False]['text':'','line_number':2023,'multiline':False]['text':' When using the closest time we use the sequence number in the second','line_number':2024,'multiline':False]['text':' round, because there may be several entries with the same time.','line_number':2025,'multiline':False]['text':' Find the path from the current state to where we want to go.  The','line_number':2027,'multiline':False]['text':' desired state can be anywhere in the undo tree, need to go all over','line_number':2028,'multiline':False]['text':' it.  We put "nomark" in uh_walk where we have been without success,','line_number':2029,'multiline':False]['text':' "mark" where it could possibly be.','line_number':2030,'multiline':False]['text':' at leaf of the tree','line_number':2034,'multiline':False]['text':' Remember the header that is closest to the target.','line_number':2047,'multiline':False]['text':' It must be at least in the right direction (checked with','line_number':2048,'multiline':False]['text':' "b_u_seq_cur").  When the timestamp is equal find the','line_number':2049,'multiline':False]['text':' highest/lowest sequence number.','line_number':2050,'multiline':False]['text':' Quit searching when we found a match.  But when searching for a','line_number':2070,'multiline':False]['text':' time we need to continue looking for the best uh_seq.','line_number':2071,'multiline':False]['text':' go down in the tree if we haven't been there','line_number':2077,'multiline':False]['text':' go to alternate branch if we haven't been there','line_number':2084,'multiline':False]['text':' go up in the tree if we haven't been there and we are at the','line_number':2087,'multiline':False]['text':' start of alternate branches','line_number':2088,'multiline':False]['text':' If still at the start we don't go through this change.','line_number':2091,'multiline':False]['text':' need to backtrack; mark this node as useless','line_number':2097,'multiline':False]['text':' found it','line_number':2107,'multiline':False]['text':' stop above the header','line_number':2129,'multiline':False]['text':' If we found it: Follow the path to go to where we want to be.','line_number':2134,'multiline':False]['text':' First go up the tree as much as needed.','line_number':2136,'multiline':False]['text':' Do the change warning now, for the same reason as above.','line_number':2138,'multiline':False]['text':' don't go back down here','line_number':2155,'multiline':False]['text':' When back to origin, redo is not needed.','line_number':2159,'multiline':False]['text':' And now go down the tree (redo), branching off where needed.','line_number':2161,'multiline':False]['text':' Do the change warning now, for the same reason as above.','line_number':2163,'multiline':False]['text':' Go back to the first branch with a mark.','line_number':2171,'multiline':False]['text':' Find the last branch with a mark, that's the one.','line_number':2177,'multiline':False]['text':' Make the used branch the first entry in the list of','line_number':2184,'multiline':False]['text':' alternatives to make "u" and CTRL-R take this branch.','line_number':2185,'multiline':False]['text':' must have reached the target','line_number':2208,'multiline':False]['text':' Stop when going backwards in time and didn't find the exact','line_number':2211,'multiline':False]['text':' header we were looking for.','line_number':2212,'multiline':False]['text':' Advance "curhead" to below the header we last used.  If it','line_number':2220,'multiline':False]['text':' becomes NULL then we need to set "newhead" to this leaf.','line_number':2221,'multiline':False]['text':' found it!','line_number':2228,'multiline':False]['text':' Need to redo more but can't find it...','line_number':2234,'multiline':False]['text':'/ u_undoredo: common code for undo and redo','line_number':2244,'multiline':False]['text':'/','line_number':2245,'multiline':False]['text':'/ The lines in the file are replaced by the lines in the entry list at','line_number':2246,'multiline':False]['text':'/ curbuf->b_u_curhead. The replaced lines in the file are saved in the entry','line_number':2247,'multiline':False]['text':'/ list for the next undo/redo.','line_number':2248,'multiline':False]['text':'/','line_number':2249,'multiline':False]['text':'/ @param undo If `true`, go up the tree. Down if `false`.','line_number':2250,'multiline':False]['text':'/ @param do_buf_event If `true`, send buffer updates.','line_number':2251,'multiline':False]['text':' Don't want autocommands using the undo structures here, they are','line_number':2261,'multiline':False]['text':' invalid till the end.','line_number':2262,'multiline':False]['text':' save marks before undo/redo','line_number':2274,'multiline':False]['text':' don't want UNCHANGED now','line_number':2293,'multiline':False]['text':' number of lines before undo','line_number':2297,'multiline':False]['text':' number of lines after undo','line_number':2298,'multiline':False]['text':' If the saved cursor is somewhere in this undo block, move it to','line_number':2301,'multiline':False]['text':' the remembered position.  Makes "gwap" put the cursor back','line_number':2302,'multiline':False]['text':' where it was.','line_number':2303,'multiline':False]['text':' Use the first line that actually changed.  Avoids that','line_number':2309,'multiline':False]['text':' undoing auto-formatting puts the cursor in the previous','line_number':2310,'multiline':False]['text':' line.','line_number':2311,'multiline':False]['text':' delete the lines between top and bot and save them in newarray','line_number':2330,'multiline':False]['text':' delete backwards, it goes faster in most cases','line_number':2333,'multiline':False]['text':' what can we do when we run out of memory?','line_number':2337,'multiline':False]['text':' remember we deleted the last line in the buffer, and a','line_number':2339,'multiline':False]['text':' dummy empty line will be inserted','line_number':2340,'multiline':False]['text':' insert the lines in u_array between top and bot','line_number':2350,'multiline':False]['text':' If the file is empty, there is an empty line 1 that we','line_number':2355,'multiline':False]['text':' should get rid of, by replacing it with the new line','line_number':2356,'multiline':False]['text':' Adjust marks','line_number':2367,'multiline':False]['text':' When text has been changed, possibly the start of the next line','line_number':2379,'multiline':False]['text':' may have SpellCap that should be removed or it needs to be','line_number':2380,'multiline':False]['text':' displayed.  Schedule the next line for redrawing just in case.','line_number':2381,'multiline':False]['text':' Set the '[ mark.','line_number':2386,'multiline':False]['text':' Set the '] mark.','line_number':2390,'multiline':False]['text':' insert this entry in front of the new entry list','line_number':2403,'multiline':False]['text':' Ensure the '[ and '] marks are within bounds.','line_number':2409,'multiline':False]['text':' Adjust Extmarks','line_number':2417,'multiline':False]['text':' redo','line_number':2424,'multiline':False]['text':' TODO(bfredl): this is a bit crude. When 'undoreload' is used we','line_number':2432,'multiline':False]['text':' should have all info to send a buffer-reloaing on_lines/on_bytes event','line_number':2433,'multiline':False]['text':' finish Adjusting extmarks','line_number':2436,'multiline':False]['text':' because the calls to changed()/unchanged() above will bump changedtick','line_number':2449,'multiline':False]['text':' again, we need to send a nvim_buf_lines_event with just the new value of','line_number':2450,'multiline':False]['text':' b:changedtick','line_number':2451,'multiline':False]['text':' restore marks from before undo/redo','line_number':2456,'multiline':False]['text':' If the cursor is only off by one line, put it at the same position as','line_number':2473,'multiline':False]['text':' before starting the change (for the "o" command).','line_number':2474,'multiline':False]['text':' Otherwise the cursor should go to the first undone line.','line_number':2475,'multiline':False]['text':' We get here with the current cursor line being past the end (eg','line_number':2492,'multiline':False]['text':' after adding lines at the end of the file, and then undoing it).','line_number':2493,'multiline':False]['text':' check_cursor() will move the cursor to the last line.  Move it to','line_number':2494,'multiline':False]['text':' the first column here.','line_number':2495,'multiline':False]['text':' Make sure the cursor is on an existing line and column.','line_number':2500,'multiline':False]['text':' Remember where we are for "g-" and ":earlier 10s".','line_number':2503,'multiline':False]['text':' We are below the previous undo.  However, to make ":earlier 1s"','line_number':2506,'multiline':False]['text':' work we compute this as being just above the just undone change.','line_number':2507,'multiline':False]['text':' Remember where we are for ":earlier 1f" and ":later 1f".','line_number':2512,'multiline':False]['text':' The timestamp can be the same for multiple changes, just use the one of','line_number':2521,'multiline':False]['text':' the undone/redone change.','line_number':2522,'multiline':False]['text':'/ If we deleted or added lines, report the number of less/more lines.','line_number':2531,'multiline':False]['text':'/ Otherwise, report the number of changes (this may be incorrect','line_number':2532,'multiline':False]['text':'/ in some cases, but it's better than nothing).','line_number':2533,'multiline':False]['text':'/','line_number':2534,'multiline':False]['text':'/ @param did_undo  just did an undo','line_number':2535,'multiline':False]['text':'/ @param absolute  used ":undo N"','line_number':2536,'multiline':False]['text':' no messages until global is finished','line_number':2544,'multiline':False]['text':' 'lazyredraw' set, don't do messages now','line_number':2545,'multiline':False]['text':' For ":undo N" we prefer a "after #N" message.','line_number':2574,'multiline':False]['text':'/ Put the timestamp of an undo header in "buf[buflen]" in a nice format.','line_number':2615,'multiline':False]['text':' within 12 hours','line_number':2623,'multiline':False]['text':' longer ago','line_number':2626,'multiline':False]['text':'/ u_sync: stop adding to the current entry list','line_number':2641,'multiline':False]['text':'/','line_number':2642,'multiline':False]['text':'/ @param force  if true, also sync when no_u_sync is set.','line_number':2643,'multiline':False]['text':' Skip it when already synced or syncing is disabled.','line_number':2646,'multiline':False]['text':' no entries, nothing to do','line_number':2652,'multiline':False]['text':' compute ue_bot of previous u_save','line_number':2654,'multiline':False]['text':'/ ":undolist": List the leafs of the undo tree','line_number':2659,'multiline':False]['text':' 1: walk the tree to find all leafs, put the info in "ga".','line_number':2664,'multiline':False]['text':' 2: sort the lines','line_number':2665,'multiline':False]['text':' 3: display the list','line_number':2666,'multiline':False]['text':' go down in the tree if we haven't been there','line_number':2689,'multiline':False]['text':' go to alternate branch if we haven't been there','line_number':2697,'multiline':False]['text':' go up in the tree if we haven't been there and we are at the','line_number':2700,'multiline':False]['text':' start of alternate branches','line_number':2701,'multiline':False]['text':' need to backtrack; mark this node as done','line_number':2707,'multiline':False]['text':'/ ":undojoin": continue adding to the last entry list','line_number':2739,'multiline':False]['text':' nothing changed before','line_number':2743,'multiline':False]['text':' already unsynced','line_number':2750,'multiline':False]['text':' no entries, nothing to do','line_number':2753,'multiline':False]['text':' Append next change to last entry','line_number':2755,'multiline':False]['text':'/ Called after writing or reloading the file and setting b_changed to false.','line_number':2758,'multiline':False]['text':'/ Now an undo means that the buffer is modified.','line_number':2759,'multiline':False]['text':'/ After reloading a buffer which was saved for 'undoreload': Find the first','line_number':2766,'multiline':False]['text':'/ line that was changed and set the cursor there.','line_number':2767,'multiline':False]['text':' undid something in an autocmd?','line_number':2773,'multiline':False]['text':' Check that the last undo block was for the whole file.','line_number':2775,'multiline':False]['text':' lines added or deleted at the end, put the cursor there','line_number':2791,'multiline':False]['text':'/ Increase the write count, store it in the last undo header, what would be','line_number':2797,'multiline':False]['text':'/ used for "u".','line_number':2798,'multiline':False]['text':' recursive','line_number':2819,'multiline':False]['text':'/ Get pointer to last added entry.','line_number':2824,'multiline':False]['text':'/ If it's not valid, give an error message and return NULL.','line_number':2825,'multiline':False]['text':'/ u_getbot(): compute the line number of the previous u_save','line_number':2835,'multiline':False]['text':'/              It is called only when b_u_synced is false.','line_number':2836,'multiline':False]['text':' check for corrupt undo list','line_number':2839,'multiline':False]['text':' the new ue_bot is computed from the number of lines that has been','line_number':2846,'multiline':False]['text':' inserted (0 - deleted) since calling u_save. This is equal to the','line_number':2847,'multiline':False]['text':' old line count subtracted from the current line count.','line_number':2848,'multiline':False]['text':' assume all lines deleted, will','line_number':2853,'multiline':False]['text':' get all the old lines back','line_number':2854,'multiline':False]['text':' without deleting the current','line_number':2855,'multiline':False]['text':' ones','line_number':2856,'multiline':False]['text':'/ Free one header "uhp" and its entry list and adjust the pointers.','line_number':2865,'multiline':False]['text':'/','line_number':2866,'multiline':False]['text':'/ @param uhpp  if not NULL reset when freeing this header','line_number':2867,'multiline':False]['text':' When there is an alternate redo list free that branch completely,','line_number':2870,'multiline':False]['text':' because we can never go there.','line_number':2871,'multiline':False]['text':' Update the links in the list to remove the header.','line_number':2880,'multiline':False]['text':'/ Free an alternate branch and any following alternate branches.','line_number':2899,'multiline':False]['text':'/','line_number':2900,'multiline':False]['text':'/ @param uhpp  if not NULL reset when freeing this header','line_number':2901,'multiline':False]['text':' If this is the top branch we may need to use u_freeheader() to update','line_number':2904,'multiline':False]['text':' all the pointers.','line_number':2905,'multiline':False]['text':' recursive','line_number':2921,'multiline':False]['text':'/ Free all the undo entries for one header and the header itself.','line_number':2928,'multiline':False]['text':'/ This means that "uhp" is invalid when returning.','line_number':2929,'multiline':False]['text':'/','line_number':2930,'multiline':False]['text':'/ @param uhpp  if not NULL reset when freeing this header','line_number':2931,'multiline':False]['text':' Check for pointers to the header that become invalid now.','line_number':2934,'multiline':False]['text':' freeing the newest entry','line_number':2939,'multiline':False]['text':'/ free entry 'uep' and 'n' lines in uep->ue_array[]','line_number':2960,'multiline':False]['text':'/ invalidate the undo buffer; called when storage has already been released','line_number':2973,'multiline':False]['text':'/ Save the line "lnum" for the "U" command.','line_number':2983,'multiline':False]['text':' line is already saved','line_number':2986,'multiline':False]['text':' should never happen','line_number':2989,'multiline':False]['text':'/ clear the line saved for the "U" command','line_number':3002,'multiline':False]['text':'/ (this is used externally for crossing a line while in insert mode)','line_number':3003,'multiline':False]['text':'/ Implementation of the "U" command.','line_number':3014,'multiline':False]['text':'/ Differentiation from vi: "U" can be undone with the next "U".','line_number':3015,'multiline':False]['text':'/ We also allow the cursor to be in another line.','line_number':3016,'multiline':False]['text':'/ Careful: may trigger autocommands that reload the buffer.','line_number':3017,'multiline':False]['text':' first save the line for the 'u' command','line_number':3026,'multiline':False]['text':'/ Free all allocated memory blocks for the buffer 'buf'.','line_number':3049,'multiline':False]['text':'/ Allocate memory and copy curbuf line into it.','line_number':3063,'multiline':False]['text':'/','line_number':3064,'multiline':False]['text':'/ @param lnum the line to copy','line_number':3065,'multiline':False]['text':'/ Allocate memory and copy line into it','line_number':3071,'multiline':False]['text':'/','line_number':3072,'multiline':False]['text':'/ @param lnum line to copy','line_number':3073,'multiline':False]['text':'/ @param buf buffer to copy from','line_number':3074,'multiline':False]['text':'/ Check if the 'modified' flag is set, or 'ff' has changed (only need to','line_number':3080,'multiline':False]['text':'/ check the first character, because it can only be "dos", "unix" or "mac").','line_number':3081,'multiline':False]['text':'/ "nofile" and "scratch" type buffers are considered to always be unchanged.','line_number':3082,'multiline':False]['text':'/','line_number':3083,'multiline':False]['text':'/ @param buf The buffer to check','line_number':3084,'multiline':False]['text':'/','line_number':3085,'multiline':False]['text':'/ @return true if the buffer has changed','line_number':3086,'multiline':False]['text':' In a "prompt" buffer we do respect 'modified', so that we can control','line_number':3090,'multiline':False]['text':' closing the window by setting or resetting that option.','line_number':3091,'multiline':False]['text':' Return true if any buffer has changes.  Also buffers that are not written.','line_number':3096,'multiline':False]['text':'/ @see bufIsChanged','line_number':3108,'multiline':False]['text':'/ @return true if the current buffer has changed','line_number':3109,'multiline':False]['text':'/ Append the list of undo blocks to a newly allocated list','line_number':3116,'multiline':False]['text':'/','line_number':3117,'multiline':False]['text':'/ For use in undotree(). Recursive.','line_number':3118,'multiline':False]['text':'/','line_number':3119,'multiline':False]['text':'/ @param[in]  first_uhp  Undo blocks list to start with.','line_number':3120,'multiline':False]['text':'/','line_number':3121,'multiline':False]['text':'/ @return [allocated] List with a representation of undo blocks.','line_number':3122,'multiline':False]['text':' Recursive call to add alternate undo tree.','line_number':3143,'multiline':False]['text':'/ "undofile(name)" function','line_number':3153,'multiline':False]['text':' If there is no file name there will be no undo file.','line_number':3160,'multiline':False]['text':'/ "undotree(expr)" function','line_number':3172,'multiline':False]['text':' Given the buffer, Return the undo header. If none is set, set one first.','line_number':3195,'multiline':False]['text':' NULL will be returned if e.g undolevels = -1 (undo disabled)','line_number':3196,'multiline':False]['text':' Create the first undo header for the buffer','line_number':3205,'multiline':False]['text':' Args are tricky: this means replace empty range by empty range..','line_number':3207,'multiline':False]