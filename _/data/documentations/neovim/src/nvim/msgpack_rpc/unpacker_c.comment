['text':' TODO(bfredl): when implementing interrupt parse on error,','line_number':61,'multiline':False]['text':' stop parsing here when node is not a STR/BIN','line_number':62,'multiline':False]['text':' handled in chunk; but save result location','line_number':114,'multiline':False]['text':' EOF, let's get back to it later','line_number':134,'multiline':False]['text':' TODO(bfredl): once we fixed memory management, we can set','line_number':141,'multiline':False]['text':' p->unpack_error and a flag like p->interrupted','line_number':142,'multiline':False]['text':' if this fails, p->handler.fn will be NULL','line_number':250,'multiline':False]['text':' recover later by retrying from scratch','line_number':262,'multiline':False]['text':' when more data is available.','line_number':263,'multiline':False]['text':' BASIC BITCH STATE MACHINE','line_number':272,'multiline':False]['text':'','line_number':273,'multiline':False]['text':' With some basic assumptions, we can parse the overall structure of msgpack-rpc','line_number':274,'multiline':False]['text':' messages with a hand-rolled FSM of just 3 states (<x> = p->state):','line_number':275,'multiline':False]['text':'','line_number':276,'multiline':False]['text':' <0>[0, request_id, method_name, <2>args]','line_number':277,'multiline':False]['text':' <0>[1, request_id, <1>err, <2>result]','line_number':278,'multiline':False]['text':' <0>[2, method_name, <2>args]','line_number':279,'multiline':False]['text':'','line_number':280,'multiline':False]['text':' The assumption here is that the header of the message, which we define as the','line_number':281,'multiline':False]['text':' initial array head, the kind integer, request_id and/or method name (when needed),','line_number':282,'multiline':False]['text':' is relatively small, just ~10 bytes + the method name. Thus we can simply refuse','line_number':283,'multiline':False]['text':' to advance the stream beyond the header until it can be parsed in its entirety.','line_number':284,'multiline':False]['text':'','line_number':285,'multiline':False]['text':' Later on, we want to specialize state 2 into more sub-states depending','line_number':286,'multiline':False]['text':' on the specific method. "nvim_exec_lua" should just decode direct into lua','line_number':287,'multiline':False]['text':' objects. For the moment "redraw/grid_line" uses a hand-rolled decoder,','line_number':288,'multiline':False]['text':' to avoid a blizzard of small objects for each screen cell.','line_number':289,'multiline':False]['text':'','line_number':290,'multiline':False]['text':' <0>[2, "redraw", <10>[<11>["method", <12>[args], <12>[args], ...], <11>[...], ...]]','line_number':291,'multiline':False]['text':'','line_number':292,'multiline':False]['text':' Where [args] gets unpacked as an Array. Note: first {11} is not saved as a state.','line_number':293,'multiline':False]['text':'','line_number':294,'multiline':False]['text':' When method is "grid_line", we furthermore decode a cell at a time like:','line_number':295,'multiline':False]['text':'','line_number':296,'multiline':False]['text':' <0>[2, "redraw", <10>[<11>["grid_line", <14>[g, r, c, [<15>[cell], <15>[cell], ...], <16>wrap]], <11>[...], ...]]','line_number':297,'multiline':False]['text':'','line_number':298,'multiline':False]['text':' where [cell] is [char, repeat, attr], where 'repeat' and 'attr' is optional','line_number':299,'multiline':False]['text':' grid_line event already unpacked','line_number':323,'multiline':False]['text':' unpack other ui events using mpack_parse()','line_number':327,'multiline':False]