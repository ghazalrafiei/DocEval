['text':' Implements extended marks for plugins. Marks sit in a MarkTree','line_number':1,'multiline':False]['text':' datastructure which provides both efficient mark insertations/lookups','line_number':2,'multiline':False]['text':' and adjustment to text changes. See marktree.c for more details.','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':' A map of pointers to the marks is used for fast lookup by mark id.','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':' Marks are moved by calls to extmark_splice. Some standard interfaces','line_number':7,'multiline':False]['text':' mark_adjust and inserted_bytes already adjust marks, check if these are','line_number':8,'multiline':False]['text':' being used before adding extmark_splice calls!','line_number':9,'multiline':False]['text':'','line_number':10,'multiline':False]['text':' Undo/Redo of marks is implemented by storing the call arguments to','line_number':11,'multiline':False]['text':' extmark_splice. The list of arguments is applied in extmark_apply_undo.','line_number':12,'multiline':False]['text':' We have to copy extmark positions when the extmarks are within a','line_number':13,'multiline':False]['text':' deleted/changed region.','line_number':14,'multiline':False]['text':'','line_number':15,'multiline':False]['text':' Marks live in namespaces that allow plugins/users to segregate marks','line_number':16,'multiline':False]['text':' from other users.','line_number':17,'multiline':False]['text':'','line_number':18,'multiline':False]['text':' Deleting marks only happens when explicitly calling extmark_del, deleting','line_number':19,'multiline':False]['text':' over a range of marks will only move the marks. Deleting on a mark will','line_number':20,'multiline':False]['text':' leave it in same position unless it is on the EOL of a line.','line_number':21,'multiline':False]['text':'','line_number':22,'multiline':False]['text':' Extmarks are used to implement buffer decoration. Decoration is mostly','line_number':23,'multiline':False]['text':' regarded as an application of extmarks, however for practical reasons code','line_number':24,'multiline':False]['text':' that deletes an extmark with decoration will call back into the decoration','line_number':25,'multiline':False]['text':' code for redrawing the line with the deleted decoration.','line_number':26,'multiline':False]['text':'/ Create or update an extmark','line_number':48,'multiline':False]['text':'/','line_number':49,'multiline':False]['text':'/ must not be used during iteration!','line_number':50,'multiline':False]['text':' not paired: we can revise in place','line_number':70,'multiline':False]['text':'/ Remove an extmark in "ns_id" by "id"','line_number':119,'multiline':False]['text':'/','line_number':120,'multiline':False]['text':'/ @return false on missing id','line_number':121,'multiline':False]['text':'/ Remove a (paired) extmark "key" pointed to by "itr"','line_number':133,'multiline':False]['text':' TODO(bfredl): delete it from current undo header, opportunistically?','line_number':153,'multiline':False]['text':'/ Free extmarks in a ns between lines','line_number':156,'multiline':False]['text':'/ if ns = 0, it means clear all namespaces','line_number':157,'multiline':False]['text':' nothing to do','line_number':169,'multiline':False]['text':'/ @return  the position of marks between a range,','line_number':194,'multiline':False]['text':'/          marks found at the start or end index will be included.','line_number':195,'multiline':False]['text':'/','line_number':196,'multiline':False]['text':'/ if upper_lnum or upper_col are negative the buffer','line_number':197,'multiline':False]['text':'/ will be searched to the start, or end','line_number':198,'multiline':False]['text':'/ reverse can be set to control the order of the array','line_number':199,'multiline':False]['text':'/ amount = amount of marks to find or INT64_MAX for all','line_number':200,'multiline':False]['text':' Find all the marks overlapping the start position','line_number':209,'multiline':False]['text':' Find all the marks beginning with the start position','line_number':219,'multiline':False]['text':'/ Lookup an extmark by id','line_number':267,'multiline':False]['text':' invalid','line_number':272,'multiline':False]['text':'/ free extmarks from the buffer','line_number':280,'multiline':False]['text':' don't free mark.decor twice for a paired mark.','line_number':295,'multiline':False]['text':'/ invalidate extmarks between range and copy to undo header','line_number':309,'multiline':False]['text':'/','line_number':310,'multiline':False]['text':'/ copying is useful when we cannot simply reverse the operation. This will do','line_number':311,'multiline':False]['text':'/ nothing on redo, enforces correct position when undo.','line_number':312,'multiline':False]['text':' Invalidate/delete mark','line_number':329,'multiline':False]['text':' Invalidate unpaired marks in deleted lines and paired marks whose entire','line_number':335,'multiline':False]['text':' range has been deleted.','line_number':336,'multiline':False]['text':' Push mark to undo header','line_number':353,'multiline':False]['text':'/ undo or redo an extmark operation','line_number':372,'multiline':False]['text':' splice: any text operation changing position (except :move)','line_number':375,'multiline':False]['text':' Undo','line_number':377,'multiline':False]['text':' kExtmarkSavePos','line_number':392,'multiline':False]['text':' Redo','line_number':406,'multiline':False]['text':'/ Adjust extmark row for inserted/deleted rows (columns stay fixed).','line_number':430,'multiline':False]['text':' TODO(bfredl): ej kasta?','line_number':442,'multiline':False]['text':' A region is either deleted (amount == MAXLNUM) or','line_number':446,'multiline':False]['text':' added (line2 == MAXLNUM). The only other case is :move','line_number':447,'multiline':False]['text':' which is handled by a separate entry point extmark_move_region.','line_number':448,'multiline':False]['text':' Adjust extmarks following a text edit.','line_number':463,'multiline':False]['text':'','line_number':464,'multiline':False]['text':' @param buf','line_number':465,'multiline':False]['text':' @param start_row   Start row of the region to be changed','line_number':466,'multiline':False]['text':' @param start_col   Start col of the region to be changed','line_number':467,'multiline':False]['text':' @param old_row     End row of the region to be changed.','line_number':468,'multiline':False]['text':'                      Encoded as an offset to start_row.','line_number':469,'multiline':False]['text':' @param old_col     End col of the region to be changed. Encodes','line_number':470,'multiline':False]['text':'                      an offset from start_col if old_row = 0; otherwise,','line_number':471,'multiline':False]['text':'                      encodes the end column of the old region.','line_number':472,'multiline':False]['text':' @param old_byte    Byte extent of the region to be changed.','line_number':473,'multiline':False]['text':' @param new_row     Row offset of the new region.','line_number':474,'multiline':False]['text':' @param new_col     Col offset of the new region. Encodes an offset from','line_number':475,'multiline':False]['text':'                      start_col if new_row = 0; otherwise, encodes','line_number':476,'multiline':False]['text':'                      the end column of the new region.','line_number':477,'multiline':False]['text':' @param new_byte    Byte extent of the new region.','line_number':478,'multiline':False]['text':' @param undo','line_number':479,'multiline':False]['text':' On empty buffers, when editing the first line, the line is buffered,','line_number':486,'multiline':False]['text':' causing offset to be < 0. While the buffer is not actually empty, the','line_number':487,'multiline':False]['text':' buffered line has not been flushed (and should not be) yet, so the call is','line_number':488,'multiline':False]['text':' valid but an edge case.','line_number':489,'multiline':False]['text':'','line_number':490,'multiline':False]['text':' TODO(vigoux): maybe the is a better way of testing that ?','line_number':491,'multiline':False]['text':' Copy and invalidate marks that would be effected by delete','line_number':510,'multiline':False]['text':' TODO(bfredl): Be "smart" about gravity here, left-gravity at the','line_number':511,'multiline':False]['text':' beginning and right-gravity at the end need not be preserved.','line_number':512,'multiline':False]['text':' Also be smart about marks that already have been saved (important for','line_number':513,'multiline':False]['text':' merge!)','line_number':514,'multiline':False]['text':' TODO(bfredl): this is quite rudimentary. We merge small (within line)','line_number':533,'multiline':False]['text':' inserts with each other and small deletes with each other. Add full','line_number':534,'multiline':False]['text':' merge algorithm later.','line_number':535,'multiline':False]['text':' TODO(bfredl): this is not synced to the buffer state inside the callback.','line_number':597,'multiline':False]['text':' But unless we make the undo implementation smarter, this is not ensured','line_number':598,'multiline':False]['text':' anyway.','line_number':599,'multiline':False]