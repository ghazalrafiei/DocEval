['text':'/ Vimscript expression parser','line_number':1,'multiline':False]['text':' Planned incompatibilities (to be included into vim_diff.txt when this parser','line_number':3,'multiline':False]['text':' will be an actual part of Vimscript evaluation process):','line_number':4,'multiline':False]['text':'','line_number':5,'multiline':False]['text':' 1. Expressions are first fully parsed and only then executed.  This means','line_number':6,'multiline':False]['text':'    that while ":echo [system('touch abc')" will create file "abc" in Vim and','line_number':7,'multiline':False]['text':'    only then raise syntax error regarding missing comma in list in Neovim','line_number':8,'multiline':False]['text':'    trying to execute that will immediately raise syntax error regarding','line_number':9,'multiline':False]['text':'    missing list end without actually executing anything.','line_number':10,'multiline':False]['text':' 2. Expressions are first fully parsed, without considering any runtime','line_number':11,'multiline':False]['text':'    information.  This means things like that "d.a" does not change its','line_number':12,'multiline':False]['text':'    meaning depending on type of "d" (or whether Vim is currently executing or','line_number':13,'multiline':False]['text':'    skipping).  For compatibility reasons the dot thus may either be “concat','line_number':14,'multiline':False]['text':'    or subscript” operator or just “concat” operator.','line_number':15,'multiline':False]['text':' 3. Expressions parser is aware whether it is called for :echo or <C-r>=.','line_number':16,'multiline':False]['text':'    This means that while "<C-r>=1 | 2<CR>" is equivalent to "<C-r>=1<CR>"','line_number':17,'multiline':False]['text':'    because "| 2" part is left to be treated as a command separator and then','line_number':18,'multiline':False]['text':'    ignored in Neovim it is an error.','line_number':19,'multiline':False]['text':' 4. Expressions parser has generally better error reporting.  But for','line_number':20,'multiline':False]['text':'    compatibility reasons most errors have error code E15 while error messages','line_number':21,'multiline':False]['text':'    are significantly different from Vim’s E15.  Also some error codes were','line_number':22,'multiline':False]['text':'    retired because of being harder to emulate or because of them being','line_number':23,'multiline':False]['text':'    a result of differences in parsing process: e.g. with ":echo {a, b}" Vim','line_number':24,'multiline':False]['text':'    will attempt to parse expression as lambda, fail, check whether it is','line_number':25,'multiline':False]['text':'    a curly-braces-name, fail again, and evaluate that as a dictionary, giving','line_number':26,'multiline':False]['text':'    error regarding undefined variable "a" (or about missing colon).  Neovim','line_number':27,'multiline':False]['text':'    will not try to evaluate anything here: comma right after an argument name','line_number':28,'multiline':False]['text':'    means that expression may not be anything, but lambda, so the resulting','line_number':29,'multiline':False]['text':'    error message will never be about missing variable or colon: it will be','line_number':30,'multiline':False]['text':'    about missing arrow (or a continuation of argument list).','line_number':31,'multiline':False]['text':' 5. Failing to parse expression always gives exactly one error message: no','line_number':32,'multiline':False]['text':'    more stack of error messages like >','line_number':33,'multiline':False]['text':'','line_number':34,'multiline':False]['text':'        :echo [1,','line_number':35,'multiline':False]['text':'        E697: Missing end of List ']':','line_number':36,'multiline':False]['text':'        E15: Invalid expression: [1,','line_number':37,'multiline':False]['text':'','line_number':38,'multiline':False]['text':' <  , just exactly one E697 message.','line_number':39,'multiline':False]['text':' 6. Some expressions involving calling parenthesis which are treated','line_number':40,'multiline':False]['text':'    separately by Vim even when not separated by spaces are treated as one','line_number':41,'multiline':False]['text':'    expression by Neovim: e.g. ":echo (1)(1)" will yield runtime error after','line_number':42,'multiline':False]['text':'    failing to call "1", while Vim will echo "1 1". Reasoning is the same:','line_number':43,'multiline':False]['text':'    type of what is in the first expression is generally not known when','line_number':44,'multiline':False]['text':'    parsing, so to have separate expressions like this separate them with','line_number':45,'multiline':False]['text':'    spaces.','line_number':46,'multiline':False]['text':' 7. 'isident' no longer applies to environment variables, they always include','line_number':47,'multiline':False]['text':'    ASCII alphanumeric characters and underscore and nothing except this.','line_number':48,'multiline':False]['text':'/ Which nodes may be wanted','line_number':73,'multiline':False]['text':'/ Operators: function call, subscripts, binary operators, …','line_number':75,'multiline':False]['text':'/','line_number':76,'multiline':False]['text':'/ For unrestricted expressions.','line_number':77,'multiline':False]['text':'/ Values: literals, variables, nested expressions, unary operators.','line_number':79,'multiline':False]['text':'/','line_number':80,'multiline':False]['text':'/ For unrestricted expressions as well, implies that top item in AST stack','line_number':81,'multiline':False]['text':'/ points to NULL.','line_number':82,'multiline':False]['text':'/ Parse type: what is being parsed currently','line_number':86,'multiline':False]['text':'/ Parsing regular Vimscript expression','line_number':88,'multiline':False]['text':'/ Parsing lambda arguments','line_number':90,'multiline':False]['text':'/','line_number':91,'multiline':False]['text':'/ Just like parsing function arguments, but it is valid to be ended with an','line_number':92,'multiline':False]['text':'/ arrow only.','line_number':93,'multiline':False]['text':'/ Assignment: parsing for :let','line_number':95,'multiline':False]['text':'/ Single assignment: used when lists are not allowed (i.e. when nesting)','line_number':97,'multiline':False]['text':'/ Operator priority level','line_number':103,'multiline':False]['text':'/< Addition, subtraction and concatenation.','line_number':117,'multiline':False]['text':'/< Multiplication, division and modulo.','line_number':118,'multiline':False]['text':'/< Unary operations: not, minus, plus.','line_number':119,'multiline':False]['text':'/< Subscripts.','line_number':120,'multiline':False]['text':'/< Values: literals, variables, nested expressions, …','line_number':121,'multiline':False]['text':'/ Operator associativity','line_number':124,'multiline':False]['text':'/< Not associative / not applicable.','line_number':126,'multiline':False]['text':'/< Left associativity.','line_number':127,'multiline':False]['text':'/< Right associativity.','line_number':128,'multiline':False]['text':'/ Scale number by a given factor','line_number':135,'multiline':False]['text':'/','line_number':136,'multiline':False]['text':'/ Used to apply exponent to a number. Idea taken from uClibc.','line_number':137,'multiline':False]['text':'/','line_number':138,'multiline':False]['text':'/ @param[in]  num  Number to scale. Does not bother doing anything if it is','line_number':139,'multiline':False]['text':'/                  zero.','line_number':140,'multiline':False]['text':'/ @param[in]  base  Base, should be 10 since non-decimal floating-point','line_number':141,'multiline':False]['text':'/                   numbers are not supported.','line_number':142,'multiline':False]['text':'/ @param[in]  exponent  Exponent to scale by.','line_number':143,'multiline':False]['text':'/ @param[in]  exponent_negative  True if exponent is negative.','line_number':144,'multiline':False]['text':'/ Get next token for the Vimscript expression input','line_number':170,'multiline':False]['text':'/','line_number':171,'multiline':False]['text':'/ @param  pstate  Parser state.','line_number':172,'multiline':False]['text':'/ @param[in]  flags  Flags, @see LexExprFlags.','line_number':173,'multiline':False]['text':'/','line_number':174,'multiline':False]['text':'/ @return Next token.','line_number':175,'multiline':False]['text':' Paired brackets.','line_number':207,'multiline':False]['text':' Single character tokens without data.','line_number':220,'multiline':False]['text':' Multiplication/division/modulo.','line_number':231,'multiline':False]['text':' Whitespace.','line_number':252,'multiline':False]['text':' Control character, except for NUL, NL and TAB.','line_number':258,'multiline':False]['text':' Number.','line_number':292,'multiline':False]['text':' A small optimization: trailing zeroes in fractional part do not','line_number':321,'multiline':False]['text':' add anything to significand, so it is useless to include them in','line_number':322,'multiline':False]['text':' frac_end.','line_number':323,'multiline':False]['text':' TODO(ZyX-I): detect overflows','line_number':351,'multiline':False]['text':' Vim used to use string2float here which in turn uses strtod(). There','line_number':353,'multiline':False]['text':' are two problems with this approach:','line_number':354,'multiline':False]['text':' 1. strtod() is locale-dependent. Not sure how it is worked around so','line_number':355,'multiline':False]['text':'    that I do not see relevant bugs, but it still does not look like','line_number':356,'multiline':False]['text':'    a good idea.','line_number':357,'multiline':False]['text':' 2. strtod() does not accept length argument.','line_number':358,'multiline':False]['text':'','line_number':359,'multiline':False]['text':' The below variant of parsing floats was recognized as acceptable','line_number':360,'multiline':False]['text':' because it is basically how uClibc does the thing: it generates','line_number':361,'multiline':False]['text':' a number ignoring decimal point (but recording its position), then','line_number':362,'multiline':False]['text':' uses recorded position to scale number down when processing exponent.','line_number':363,'multiline':False]['text':' Environment variable.','line_number':409,'multiline':False]['text':' Normal variable/function name.','line_number':414,'multiline':False]['text':' "is" and "isnot" operators.','line_number':471,'multiline':False]['text':' Scope: `s:`, etc.','line_number':479,'multiline':False]['text':' Previous CHARREG stopped at autoload character in order to make it','line_number':492,'multiline':False]['text':' possible to detect `is#`. Continue now with autoload characters','line_number':493,'multiline':False]['text':' included.','line_number':494,'multiline':False]['text':'','line_number':495,'multiline':False]['text':' Warning: there is ambiguity for the lexer: `is#Foo(1)` is a call of','line_number':496,'multiline':False]['text':' function `is#Foo()`, `1is#Foo(1)` is a comparison `1 is# Foo(1)`. This','line_number':497,'multiline':False]['text':' needs to be resolved on the higher level where context is available.','line_number':498,'multiline':False]['text':' Option.','line_number':509,'multiline':False]['text':' Register.','line_number':556,'multiline':False]['text':' Single quoted string.','line_number':567,'multiline':False]['text':' Double quoted string.','line_number':582,'multiline':False]['text':' Unary not, (un)equality and regex (not) match comparison operators.','line_number':597,'multiline':False]['text':' Less/greater [or equal to] comparison operators.','line_number':622,'multiline':False]['text':' Minus sign, arrow from lambdas or augmented assignment.','line_number':638,'multiline':False]['text':' Sign or augmented assignment.','line_number':653,'multiline':False]['text':' Expression end because Ex command ended.','line_number':669,'multiline':False]['text':' "||" is or.','line_number':683,'multiline':False]['text':' Note: `<C-r>=1 | 2<CR>` actually yields 1 in Vim without any','line_number':687,'multiline':False]['text':'       errors. This will be changed here.','line_number':688,'multiline':False]['text':' Everything else is not valid.','line_number':697,'multiline':False]['text':'/ Represent token as a string','line_number':780,'multiline':False]['text':'/','line_number':781,'multiline':False]['text':'/ Intended for testing and debugging purposes.','line_number':782,'multiline':False]['text':'/','line_number':783,'multiline':False]['text':'/ @param[in]  pstate  Parser state, needed to get token string from it. May be','line_number':784,'multiline':False]['text':'/                     NULL, in which case in place of obtaining part of the','line_number':785,'multiline':False]['text':'/                     string represented by token only token length is','line_number':786,'multiline':False]['text':'/                     returned.','line_number':787,'multiline':False]['text':'/ @param[in]  token  Token to represent.','line_number':788,'multiline':False]['text':'/ @param[out]  ret_size  Return string size, for cases like NULs inside','line_number':789,'multiline':False]['text':'/                        a string. May be NULL.','line_number':790,'multiline':False]['text':'/','line_number':791,'multiline':False]['text':'/ @return Token represented in a string form, in a static buffer (overwritten','line_number':792,'multiline':False]['text':'/         on each call).','line_number':793,'multiline':False]['text':' No additional arguments.','line_number':842,'multiline':False]['text':'/ Represent `int` character as a string','line_number':905,'multiline':False]['text':'/','line_number':906,'multiline':False]['text':'/ Converts','line_number':907,'multiline':False]['text':'/ - ASCII digits into '{digit}'','line_number':908,'multiline':False]['text':'/ - ASCII printable characters into a single-character strings','line_number':909,'multiline':False]['text':'/ - everything else to numbers.','line_number':910,'multiline':False]['text':'/','line_number':911,'multiline':False]['text':'/ @param[in]  ch  Character to convert.','line_number':912,'multiline':False]['text':'/','line_number':913,'multiline':False]['text':'/ @return Converted string, stored in a static buffer (overridden after each','line_number':914,'multiline':False]['text':'/         call).','line_number':915,'multiline':False]['text':'/ Free memory occupied by AST','line_number':1024,'multiline':False]['text':'/','line_number':1025,'multiline':False]['text':'/ @param  ast  AST stack to free.','line_number':1026,'multiline':False]['text':' Explicitly check for AST recursiveness.','line_number':1035,'multiline':False]['text':' Binary operator precedence and associativity:','line_number':1109,'multiline':False]['text':'','line_number':1110,'multiline':False]['text':' Operator | Precedence | Associativity','line_number':1111,'multiline':False]['text':' ---------+------------+-----------------','line_number':1112,'multiline':False]['text':' ||       | 2          | left','line_number':1113,'multiline':False]['text':' &&       | 3          | left','line_number':1114,'multiline':False]['text':' cmp*     | 4          | not associative','line_number':1115,'multiline':False]['text':' + - .    | 5          | left','line_number':1116,'multiline':False]['text':' * / %    | 6          | left','line_number':1117,'multiline':False]['text':'','line_number':1118,'multiline':False]['text':' * comparison operators:','line_number':1119,'multiline':False]['text':'','line_number':1120,'multiline':False]['text':' == ==# ==?  != !=# !=?','line_number':1121,'multiline':False]['text':' =~ =~# =~?  !~ !~# !~?','line_number':1122,'multiline':False]['text':'  >  >#  >?  <= <=# <=?','line_number':1123,'multiline':False]['text':'  <  <#  <?  >= >=# >=?','line_number':1124,'multiline':False]['text':' is is# is?  isnot isnot# isnot?','line_number':1125,'multiline':False]['text':'/ Allocate a new node and set some of the values','line_number':1127,'multiline':False]['text':'/','line_number':1128,'multiline':False]['text':'/ @param[in]  type  Node type to allocate.','line_number':1129,'multiline':False]['text':'/ @param[in]  level  Node level to allocate','line_number':1130,'multiline':False]['text':' Note: below nodes are kEOpLvlSubscript for “binary operator” itself, but','line_number':1149,'multiline':False]['text':'       kEOpLvlParens when it comes to inside the parenthesis.','line_number':1150,'multiline':False]['text':' Right associativity for comma because this means easier access to arguments','line_number':1161,'multiline':False]['text':' list, etc: for "[a, b, c, d]" you can access "a" in one step if it is','line_number':1162,'multiline':False]['text':' represented as "list(comma(a, comma(b, comma(c, d))))" then if it is','line_number':1163,'multiline':False]['text':' "list(comma(comma(comma(a, b), c), d))" in which case you will need to','line_number':1164,'multiline':False]['text':' traverse all three comma() structures. And with comma operator (including','line_number':1165,'multiline':False]['text':' actual comma operator from C which is not present in Vimscript) nobody cares','line_number':1166,'multiline':False]['text':' about associativity, only about order of execution.','line_number':1167,'multiline':False]['text':' Colons are not eligible for chaining, so nobody cares about associativity.','line_number':1170,'multiline':False]['text':'/ Get AST node priority level','line_number':1214,'multiline':False]['text':'/','line_number':1215,'multiline':False]['text':'/ Used primary to reduce line length, so keep the name short.','line_number':1216,'multiline':False]['text':'/','line_number':1217,'multiline':False]['text':'/ @param[in]  node  Node to get priority for.','line_number':1218,'multiline':False]['text':'/','line_number':1219,'multiline':False]['text':'/ @return Node priority level.','line_number':1220,'multiline':False]['text':'/ Get AST node associativity, to be used for operator nodes primary','line_number':1227,'multiline':False]['text':'/','line_number':1228,'multiline':False]['text':'/ Used primary to reduce line length, so keep the name short.','line_number':1229,'multiline':False]['text':'/','line_number':1230,'multiline':False]['text':'/ @param[in]  node  Node to get priority for.','line_number':1231,'multiline':False]['text':'/','line_number':1232,'multiline':False]['text':'/ @return Node associativity.','line_number':1233,'multiline':False]['text':'/ Handle binary operator','line_number':1240,'multiline':False]['text':'/','line_number':1241,'multiline':False]['text':'/ This function is responsible for handling priority levels as well.','line_number':1242,'multiline':False]['text':'/','line_number':1243,'multiline':False]['text':'/ @param[in]  pstate  Parser state, used for error reporting.','line_number':1244,'multiline':False]['text':'/ @param  ast_stack  AST stack. May be popped of some values and will','line_number':1245,'multiline':False]['text':'/                    definitely receive new ones.','line_number':1246,'multiline':False]['text':'/ @param  bop_node  New node to handle.','line_number':1247,'multiline':False]['text':'/ @param[out]  want_node_p  New value of want_node.','line_number':1248,'multiline':False]['text':'/ @param[out]  ast_err  Location where error is saved, if any.','line_number':1249,'multiline':False]['text':'/','line_number':1250,'multiline':False]['text':'/ @return True if no errors occurred, false otherwise.','line_number':1251,'multiline':False]['text':' outer(op(x,y)) -> outer(new_op(op(x,y),*))','line_number':1298,'multiline':False]['text':'','line_number':1299,'multiline':False]['text':' Before: top_node_p = outer(*), points to op(x,y)','line_number':1300,'multiline':False]['text':'         Other stack elements unknown','line_number':1301,'multiline':False]['text':'','line_number':1302,'multiline':False]['text':' After: top_node_p = outer(*), points to new_op(op(x,y))','line_number':1303,'multiline':False]['text':'        &bop_node->children->next = new_op(op(x,y),*), points to NULL','line_number':1304,'multiline':False]['text':' outer(op(x,y)) -> outer(op(x,new_op(y,*)))','line_number':1313,'multiline':False]['text':'','line_number':1314,'multiline':False]['text':' Before: top_node_p = outer(*), points to op(x,y)','line_number':1315,'multiline':False]['text':'         Other stack elements unknown','line_number':1316,'multiline':False]['text':'','line_number':1317,'multiline':False]['text':' After: top_node_p = outer(*), points to op(x,new_op(y))','line_number':1318,'multiline':False]['text':'        &top_node->children->next = op(x,*), points to new_op(y)','line_number':1319,'multiline':False]['text':'        &bop_node->children->next = new_op(y,*), points to NULL','line_number':1320,'multiline':False]['text':' TODO(ZyX-I): Make this not error, but treat like Python does','line_number':1327,'multiline':False]['text':'/ ParserPosition literal based on ParserPosition pos with columns shifted','line_number':1339,'multiline':False]['text':'/','line_number':1340,'multiline':False]['text':'/ Function does not check whether resulting position is valid.','line_number':1341,'multiline':False]['text':'/','line_number':1342,'multiline':False]['text':'/ @param[in]  pos  Position to shift.','line_number':1343,'multiline':False]['text':'/ @param[in]  shift  Number of bytes to shift.','line_number':1344,'multiline':False]['text':'/','line_number':1345,'multiline':False]['text':'/ @return Shifted position.','line_number':1346,'multiline':False]['text':'/ ParserPosition literal based on ParserPosition pos with specified column','line_number':1353,'multiline':False]['text':'/','line_number':1354,'multiline':False]['text':'/ Function does not check whether remaining position is valid.','line_number':1355,'multiline':False]['text':'/','line_number':1356,'multiline':False]['text':'/ @param[in]  pos  Position to adjust.','line_number':1357,'multiline':False]['text':'/ @param[in]  new_col  New column.','line_number':1358,'multiline':False]['text':'/','line_number':1359,'multiline':False]['text':'/ @return Shifted position.','line_number':1360,'multiline':False]['text':'/ Get highlight group name','line_number':1367,'multiline':False]['text':'/ Highlight current token with the given group','line_number':1370,'multiline':False]['text':'/ Allocate new node, saving some values','line_number':1375,'multiline':False]['text':'/ Set position of the given node to position from the given token','line_number':1379,'multiline':False]['text':'/','line_number':1380,'multiline':False]['text':'/ @param  cur_node  Node to modify.','line_number':1381,'multiline':False]['text':'/ @param  cur_token  Token to set position from.','line_number':1382,'multiline':False]['text':'/ Allocate new node and set its position from the current token','line_number':1389,'multiline':False]['text':'/','line_number':1390,'multiline':False]['text':'/ If previous token happened to contain spacing then it will be included.','line_number':1391,'multiline':False]['text':'/','line_number':1392,'multiline':False]['text':'/ @param  cur_node  Variable to save allocated node to.','line_number':1393,'multiline':False]['text':'/ @param  typ  Node type.','line_number':1394,'multiline':False]['text':'/ Check whether it is possible to have next expression after current','line_number':1405,'multiline':False]['text':'/','line_number':1406,'multiline':False]['text':'/ For :echo: `:echo @a @a` is a valid expression. `:echo (@a @a)` is not.','line_number':1407,'multiline':False]['text':'/ Add operator node','line_number':1411,'multiline':False]['text':'/','line_number':1412,'multiline':False]['text':'/ @param[in]  cur_node  Node to add.','line_number':1413,'multiline':False]['text':'/ Record missing operator: for things like','line_number':1418,'multiline':False]['text':'/','line_number':1419,'multiline':False]['text':'/     :echo @a @a','line_number':1420,'multiline':False]['text':'/','line_number':1421,'multiline':False]['text':'/ (allowed) or','line_number':1422,'multiline':False]['text':'/','line_number':1423,'multiline':False]['text':'/     :echo (@a @a)','line_number':1424,'multiline':False]['text':'/','line_number':1425,'multiline':False]['text':'/ (parsed as OpMissing(@a, @a)).','line_number':1426,'multiline':False]['text':' Multiple expressions allowed, return without calling ','line_number':1430,'multiline':True]['text':' viml_parser_advance(). ','line_number':1431,'multiline':True]['text':'/ Record missing value: for things like "* 5"','line_number':1443,'multiline':False]['text':'/','line_number':1444,'multiline':False]['text':'/ @param[in]  msg  Error message.','line_number':1445,'multiline':False]['text':'/ Set AST error, unless AST already is not correct','line_number':1456,'multiline':False]['text':'/','line_number':1457,'multiline':False]['text':'/ @param[out]  ret_ast  AST to set error in.','line_number':1458,'multiline':False]['text':'/ @param[in]  pstate  Parser state, used to get error message argument.','line_number':1459,'multiline':False]['text':'/ @param[in]  msg  Error message, assumed to be already translated and','line_number':1460,'multiline':False]['text':'/                  containing a single %token "%.*s".','line_number':1461,'multiline':False]['text':'/ @param[in]  start  Position at which error occurred.','line_number':1462,'multiline':False]['text':'/ Set error from the given token and given message','line_number':1476,'multiline':False]['text':'/ Like #ERROR_FROM_TOKEN_AND_MSG, but gets position from a node','line_number':1483,'multiline':False]['text':'/ Set error from the given kExprLexInvalid token','line_number':1490,'multiline':False]['text':'/ Select figure brace type, altering highlighting as well if needed','line_number':1494,'multiline':False]['text':'/','line_number':1495,'multiline':False]['text':'/ @param[out]  node  Node to modify type.','line_number':1496,'multiline':False]['text':'/ @param[in]  new_type  New type, one of ExprASTNodeType values without','line_number':1497,'multiline':False]['text':'/                       kExprNode prefix.','line_number':1498,'multiline':False]['text':'/ @param[in]  hl  Corresponding highlighting, passed as an argument to #HL.','line_number':1499,'multiline':False]['text':'/ Add identifier which should constitute complex identifier node','line_number':1512,'multiline':False]['text':'/','line_number':1513,'multiline':False]['text':'/ This one is to be called only in case want_node is kENodeOperator.','line_number':1514,'multiline':False]['text':'/','line_number':1515,'multiline':False]['text':'/ @param  new_ident_node_code  Code used to create a new identifier node and','line_number':1516,'multiline':False]['text':'/                              update want_node and ast_stack, without','line_number':1517,'multiline':False]['text':'/                              a trailing semicolon.','line_number':1518,'multiline':False]['text':'/ @param  hl  Highlighting name to use, passed as an argument to #HL.','line_number':1519,'multiline':False]['text':' Operator: may only be curly braces name, but only under certain ','line_number':1523,'multiline':True]['text':' conditions. ','line_number':1524,'multiline':True]['text':' First condition is that there is no space before a part of complex ','line_number':1525,'multiline':True]['text':' identifier. ','line_number':1526,'multiline':True]['text':' Second is that previous node is one of the identifiers: ','line_number':1531,'multiline':True]['text':' complex, plain, curly braces. ','line_number':1532,'multiline':True]['text':' TODO(ZyX-I): Extend syntax to allow ${expr}. This is needed to ','line_number':1533,'multiline':True]['text':' handle environment variables like those bash uses for ','line_number':1534,'multiline':True]['text':' `export -f`: their names consist not only of alphanumeric ','line_number':1535,'multiline':True]['text':' characters. ','line_number':1536,'multiline':True]['text':'/ Determine whether given parse type is an assignment','line_number':1559,'multiline':False]['text':'/','line_number':1560,'multiline':False]['text':'/ @param[in]  pt  Checked parse type.','line_number':1561,'multiline':False]['text':'/','line_number':1562,'multiline':False]['text':'/ @return true if parsing an assignment, false otherwise.','line_number':1563,'multiline':False]['text':'/ Structure used to define “string shifts” necessary to map string','line_number':1570,'multiline':False]['text':'/ highlighting to actual strings.','line_number':1571,'multiline':False]['text':'/< Where special character starts in original string.','line_number':1573,'multiline':False]['text':'/< Length of orininal string (e.g. 4 for "\x80").','line_number':1574,'multiline':False]['text':'/< Length of resulting character(s) (e.g. 1 for "\x80").','line_number':1575,'multiline':False]['text':'/< True if escape sequence in original is not known.','line_number':1576,'multiline':False]['text':'/ Parse and highlight single- or double-quoted string','line_number':1579,'multiline':False]['text':'/','line_number':1580,'multiline':False]['text':'/ Function is supposed to detect and highlight regular expressions (but does','line_number':1581,'multiline':False]['text':'/ not do now).','line_number':1582,'multiline':False]['text':'/','line_number':1583,'multiline':False]['text':'/ @param[out]  pstate  Parser state which also contains a place where','line_number':1584,'multiline':False]['text':'/                      highlighting is saved.','line_number':1585,'multiline':False]['text':'/ @param[out]  node  Node where string parsing results are saved.','line_number':1586,'multiline':False]['text':'/ @param[in]  token  Token to highlight.','line_number':1587,'multiline':False]['text':'/ @param[in]  ast_stack  Parser AST stack, used to detect whether current','line_number':1588,'multiline':False]['text':'/                        string is a regex.','line_number':1589,'multiline':False]['text':'/ @param[in]  is_invalid  Whether currently processed token is not valid.','line_number':1590,'multiline':False]['text':' A "\<x>" form occupies at least 4 characters, and produces up to','line_number':1651,'multiline':False]['text':' to 9 characters (6 for the char and 3 for a modifier):','line_number':1652,'multiline':False]['text':' reserve space for 5 extra, but do not compute actual length','line_number':1653,'multiline':False]['text':' just now, it would be costly.','line_number':1654,'multiline':False]['text':' Hexadecimal, always single byte, but at least three bytes each.','line_number':1658,'multiline':False]['text':' Unicode','line_number':1669,'multiline':False]['text':'','line_number':1670,'multiline':False]['text':' \uF takes 1 byte which is 2 bytes less then escape sequence.','line_number':1671,'multiline':False]['text':' \uFF: 2 bytes, 2 bytes less.','line_number':1672,'multiline':False]['text':' \uFFF: 3 bytes, 2 bytes less.','line_number':1673,'multiline':False]['text':' \uFFFF: 3 bytes, 3 bytes less.','line_number':1674,'multiline':False]['text':' \UFFFFF: 4 bytes, 3 bytes less.','line_number':1675,'multiline':False]['text':' \UFFFFFF: 5 bytes, 3 bytes less.','line_number':1676,'multiline':False]['text':' \UFFFFFFF: 6 bytes, 3 bytes less.','line_number':1677,'multiline':False]['text':' \U7FFFFFFF: 6 bytes, 4 bytes less.','line_number':1678,'multiline':False]['text':' Escape length: (esc_start - 1) points to "\\", esc_start to "u"','line_number':1689,'multiline':False]['text':' or "U", p to the byte after last byte. So escape sequence','line_number':1690,'multiline':False]['text':' occupies p - (esc_start - 1), but it stands for a utf_char2len','line_number':1691,'multiline':False]['text':' bytes.','line_number':1692,'multiline':False]['text':' Octal, always single byte, but at least two bytes each.','line_number':1697,'multiline':False]['text':' Hexadecimal or unicode.','line_number':1763,'multiline':False]['text':' Octal: "\1", "\12", "\123".','line_number':1797,'multiline':False]['text':' Special key, e.g.: "\<C-W>"','line_number':1816,'multiline':False]['text':' TODO(ZyX-I): use ast_stack to determine and highlight regular expressions','line_number':1851,'multiline':False]['text':' TODO(ZyX-I): use ast_stack to determine and highlight printf format str','line_number':1852,'multiline':False]['text':' TODO(ZyX-I): use ast_stack to determine and highlight expression strings','line_number':1853,'multiline':False]['text':'/ Additional flags to pass to lexer depending on want_node','line_number':1899,'multiline':False]['text':'/ Number of characters to highlight as NumberPrefix depending on the base','line_number':1905,'multiline':False]['text':'/ Parse one Vimscript expression','line_number':1913,'multiline':False]['text':'/','line_number':1914,'multiline':False]['text':'/ @param  pstate  Parser state.','line_number':1915,'multiline':False]['text':'/ @param[in]  flags  Additional flags, see ExprParserFlags','line_number':1916,'multiline':False]['text':'/','line_number':1917,'multiline':False]['text':'/ @return Parsed AST.','line_number':1918,'multiline':False]['text':' Expression stack contains current branch in AST tree: that is','line_number':1930,'multiline':False]['text':' - Stack item 0 contains root of the tree, i.e. &ast->root.','line_number':1931,'multiline':False]['text':' - Stack item i points to the previous stack items’ last child.','line_number':1932,'multiline':False]['text':'','line_number':1933,'multiline':False]['text':' When parser expects “value” node that is something like identifier or "["','line_number':1934,'multiline':False]['text':' (list start) last stack item contains NULL. Otherwise last stack item is','line_number':1935,'multiline':False]['text':' supposed to contain last “finished” value: e.g. "1" or "+(1, 1)" (node','line_number':1936,'multiline':False]['text':' representing "1+1").','line_number':1937,'multiline':False]['text':' Lambda node, valid when parsing lambda arguments only.','line_number':1950,'multiline':False]['text':' May use different flags this time.','line_number':1979,'multiline':False]['text':' Do not do anything: let regular spacing be highlighted as normal.','line_number':1986,'multiline':False]['text':' This also allows later to highlight spacing as invalid.','line_number':1987,'multiline':False]['text':' Check that stack item i + 1 points to stack items’ i *last* child.','line_number':2005,'multiline':False]['text':' Note: in Vim whether expression "cond?d.a:2" is valid depends both on','line_number':2019,'multiline':False]['text':' "cond" and whether "d" is a dictionary: expression is valid if condition','line_number':2020,'multiline':False]['text':' is true and "d" is a dictionary (with "a" key or it will complain about','line_number':2021,'multiline':False]['text':' missing one, but this is not relevant); if any of the requirements is','line_number':2022,'multiline':False]['text':' broken then this thing is parsed as "d . a:2" yielding missing colon','line_number':2023,'multiline':False]['text':' error. This parser does not allow such ambiguity, especially because it','line_number':2024,'multiline':False]['text':' simply can’t: whether "d" is a dictionary is not known at the parsing','line_number':2025,'multiline':False]['text':' time.','line_number':2026,'multiline':False]['text':'','line_number':2027,'multiline':False]['text':' Here example will always contain a concat with "a:2" sucking colon,','line_number':2028,'multiline':False]['text':' making expression invalid both because there is no longer a spare colon','line_number':2029,'multiline':False]['text':' for ternary and because concatenating dictionary with anything is not','line_number':2030,'multiline':False]['text':' valid. There are more cases when this will make a difference though.','line_number':2031,'multiline':False]['text':' Note: in Vim "d. a" (this is the reason behind `prev_token.type !=','line_number':2040,'multiline':False]['text':' kExprLexSpacing` part of the condition) as well as any other "d.{expr}"','line_number':2041,'multiline':False]['text':' where "{expr}" does not look like a key is invalid whenever "d" happens','line_number':2042,'multiline':False]['text':' to be a dictionary. Since parser has no idea whether preceding','line_number':2043,'multiline':False]['text':' expression is actually a dictionary it can’t outright reject anything,','line_number':2044,'multiline':False]['text':' so it turns kExprNodeConcatOrSubscript into kExprNodeConcat instead,','line_number':2045,'multiline':False]['text':' which will yield different errors then Vim does in a number of','line_number':2046,'multiline':False]['text':' circumstances, and in any case runtime and not parse time errors.','line_number':2047,'multiline':False]['text':' Pop some stack pt_stack items in case of misplaced nodes.','line_number':2050,'multiline':False]['text':' If lambda has comma child this means that parser has already seen','line_number':2067,'multiline':False]['text':' at least "{arg1,", so node cannot possibly be anything, but','line_number':2068,'multiline':False]['text':' lambda.','line_number':2069,'multiline':False]['text':' Vim may give E121 or E720 in this case, but it does not look','line_number':2071,'multiline':False]['text':' right to have either because both are results of reevaluation','line_number':2072,'multiline':False]['text':' possibly-lambda node as a dictionary and here this is not going','line_number':2073,'multiline':False]['text':' to happen.','line_number':2074,'multiline':False]['text':' Else it may appear that possibly-lambda node is actually','line_number':2078,'multiline':False]['text':' a dictionary or curly-braces-name identifier.','line_number':2079,'multiline':False]['text':' Curly brace identifiers: will contain plain identifier or','line_number':2105,'multiline':False]['text':' another curly brace in position where operator is wanted.','line_number':2106,'multiline':False]['text':' Value level: assume unary operator. ','line_number':2127,'multiline':True]['text':' Register in operator position: e.g. @a @a','line_number':2151,'multiline':False]['text':' Value level: comma appearing here is not valid.','line_number':2279,'multiline':False]['text':' Note: in Vim string(,x) will give E116, this is not the case here.','line_number':2280,'multiline':False]['text':' Do nothing','line_number':2311,'multiline':False]['text':' can_be_ternary = false;','line_number':2364,'multiline':False]['text':' Do nothing','line_number':2370,'multiline':False]['text':' Colon immediately following subscript start: it is empty subscript','line_number':2382,'multiline':False]['text':' part like a[:2].','line_number':2383,'multiline':False]['text':' Always drop the topmost value:','line_number':2417,'multiline':False]['text':'','line_number':2418,'multiline':False]['text':' 1. When want_node != kENodeValue topmost item on stack is','line_number':2419,'multiline':False]['text':'    a *finished* left operand, which may as well be "{@a}" which','line_number':2420,'multiline':False]['text':'    needs not be finished again.','line_number':2421,'multiline':False]['text':' 2. Otherwise it is pointing to NULL what nobody wants.','line_number':2422,'multiline':False]['text':' It is OK to want value if','line_number':2434,'multiline':False]['text':'','line_number':2435,'multiline':False]['text':' 1. It is empty list literal, in which case top node will be','line_number':2436,'multiline':False]['text':'    ListLiteral.','line_number':2437,'multiline':False]['text':' 2. It is list literal with trailing comma, in which case top node','line_number':2438,'multiline':False]['text':'    will be that comma.','line_number':2439,'multiline':False]['text':' 3. It is subscript with colon, but without one of the values:','line_number':2440,'multiline':False]['text':'    e.g. "a[:]", "a[1:]", top node will be colon in this case.','line_number':2441,'multiline':False]['text':' Value means list literal or list assignment.','line_number':2491,'multiline':False]['text':' Additional assignment parse type allows to easily forbid nested','line_number':2496,'multiline':False]['text':' lists.','line_number':2497,'multiline':False]['text':' Operator means subscript, also in assignment. But in assignment','line_number':2505,'multiline':False]['text':' subscript may be pretty much any expression, so need to push','line_number':2506,'multiline':False]['text':' kEPTExpr.','line_number':2507,'multiline':False]['text':' Subtract 1 for NULL at top.','line_number':2515,'multiline':False]['text':' Always drop the topmost value:','line_number':2525,'multiline':False]['text':'','line_number':2526,'multiline':False]['text':' 1. When want_node != kENodeValue topmost item on stack is','line_number':2527,'multiline':False]['text':'    a *finished* left operand, which may as well be "{@a}" which','line_number':2528,'multiline':False]['text':'    needs not be finished again.','line_number':2529,'multiline':False]['text':' 2. Otherwise it is pointing to NULL what nobody wants.','line_number':2530,'multiline':False]['text':' kv_last being UnknownFigure may occur for empty dictionary','line_number':2548,'multiline':False]['text':' literal, while Comma is expected in case of non-empty one.','line_number':2549,'multiline':False]['text':' No children of curly braces node indicates empty dictionary.','line_number':2567,'multiline':False]['text':' If by this time type of the node has not already been','line_number':2577,'multiline':False]['text':' guessed, but it definitely is not a curly braces name then','line_number':2578,'multiline':False]['text':' it is invalid for sure.','line_number':2579,'multiline':False]['text':' Will reset to NvimInvalidFigureBrace.','line_number':2583,'multiline':False]['text':' Value: may be any of lambda, dictionary literal and curly braces','line_number':2621,'multiline':False]['text':' name.','line_number':2622,'multiline':False]['text':' Though if we are in an assignment this may only be a curly braces','line_number':2624,'multiline':False]['text':' name.','line_number':2625,'multiline':False]['text':' uncrustify:off','line_number':2646,'multiline':False]['text':' uncrustify:on','line_number':2661,'multiline':False]['text':' Subtract 1 for NULL at top.','line_number':2665,'multiline':False]['text':' Wanting value means trailing comma and NULL at the top of the','line_number':2675,'multiline':False]['text':' stack.','line_number':2676,'multiline':False]['text':' Only first branch is valid.','line_number':2699,'multiline':False]['text':' uncrustify:off','line_number':2739,'multiline':False]['text':' uncrustify:on','line_number':2748,'multiline':False]['text':' Function call without arguments, this is not an error.','line_number':2801,'multiline':False]['text':' But further code does not expect NULL nodes.','line_number':2802,'multiline':False]['text':' Always drop the topmost value: when want_node != kENodeValue','line_number':2812,'multiline':False]['text':' topmost item on stack is a *finished* left operand, which may as','line_number':2813,'multiline':False]['text':' well be "(@a)" which needs not be finished again.','line_number':2814,'multiline':False]['text':' “Always drop the topmost value” branch has got rid of the single','line_number':2834,'multiline':False]['text':' value stack had, so there is nothing known to enclose. Correct','line_number':2835,'multiline':False]['text':' this.','line_number':2836,'multiline':False]['text':' Unexpected closing parenthesis, assume that it was wanted to','line_number':2845,'multiline':False]['text':' enclose everything in ().','line_number':2846,'multiline':False]['text':' For some reason "function (args)" is a function call, but','line_number':2863,'multiline':False]['text':' "(funcref) (args)" is not. As far as I remember this somehow involves','line_number':2864,'multiline':False]['text':' compatibility and Bram was commenting that this is','line_number':2865,'multiline':False]['text':' intentionally inconsistent and he is not very happy with the','line_number':2866,'multiline':False]['text':' situation himself.','line_number':2867,'multiline':False]['text':' It is weird, but Vim has two identical errors messages with','line_number':2901,'multiline':False]['text':' different error numbers: "E114: Missing quote" and','line_number':2902,'multiline':False]['text':' "E115: Missing quote".','line_number':2903,'multiline':False]['text':' Blacklist some parse type entries as their presence means better error','line_number':2956,'multiline':False]['text':' message in the other branch.','line_number':2957,'multiline':False]['text':' Something may be wrong, check whether it really is.','line_number':2962,'multiline':False]['text':' Pointer to ast.root must never be dropped, so “!= 1” is expected to be','line_number':2964,'multiline':False]['text':' the same as “> 1”.','line_number':2965,'multiline':False]['text':' Topmost stack item must be a *finished* value, so it must not be','line_number':2967,'multiline':False]['text':' analyzed. E.g. it may contain an already finished nested expression.','line_number':2968,'multiline':False]['text':' This should only happen when want_node == kENodeValue.','line_number':2972,'multiline':False]['text':' TODO(ZyX-I): Rehighlight as invalid?','line_number':2974,'multiline':False]['text':' Error should’ve been already reported.','line_number':2978,'multiline':False]['text':' For whatever reason "[1" yields "E696: Missing comma in list" error','line_number':2992,'multiline':False]['text':' in Vim while "[1," yields E697.','line_number':2993,'multiline':False]['text':' Same problem like with list literal with E722 (missing comma) vs','line_number':2999,'multiline':False]['text':' E723, but additionally just "{" yields only E15.','line_number':3000,'multiline':False]['text':' Until trailing "}" it is impossible to distinguish curly braces','line_number':3016,'multiline':False]['text':' identifier and dictionary, so it must not appear in the stack like','line_number':3017,'multiline':False]['text':' this.','line_number':3018,'multiline':False]['text':' These are plain values and not containers, for them it should only','line_number':3029,'multiline':False]['text':' be possible to show up in the topmost stack element, but it was','line_number':3030,'multiline':False]['text':' unconditionally popped at the start.','line_number':3031,'multiline':False]['text':' It is actually only valid inside something else, but everything','line_number':3036,'multiline':False]['text':' where one of the above is valid requires to be closed and thus is','line_number':3037,'multiline':False]['text':' to be caught later.','line_number':3038,'multiline':False]['text':' It is OK to see these in the stack.','line_number':3057,'multiline':False]['text':' Actually Vim throws E109 in more cases.','line_number':3061,'multiline':False]