['text':' Defines whether to ignore case:','line_number':13,'multiline':False]['text':'    ==   kCCStrategyUseOption','line_number':14,'multiline':False]['text':'    ==#  kCCStrategyMatchCase','line_number':15,'multiline':False]['text':'    ==?  kCCStrategyIgnoreCase','line_number':16,'multiline':False]['text':' 0 for xcalloc','line_number':18,'multiline':False]['text':'/ Lexer token type','line_number':23,'multiline':False]['text':'/< Invalid token, indicaten an error.','line_number':25,'multiline':False]['text':'/< Missing token, for use in parser.','line_number':26,'multiline':False]['text':'/< Spaces, tabs, newlines, etc.','line_number':27,'multiline':False]['text':'/< End of command character: NL, |, just end of stream.','line_number':28,'multiline':False]['text':'/< Question mark, for use in ternary.','line_number':30,'multiline':False]['text':'/< Colon, for use in ternary.','line_number':31,'multiline':False]['text':'/< Logical or operator.','line_number':32,'multiline':False]['text':'/< Logical and operator.','line_number':33,'multiline':False]['text':'/< One of the comparison operators.','line_number':34,'multiline':False]['text':'/< Plus sign.','line_number':35,'multiline':False]['text':'/< Minus sign.','line_number':36,'multiline':False]['text':'/< Dot: either concat or subscript, also part of the float.','line_number':37,'multiline':False]['text':'/< Multiplication, division or modulo operator.','line_number':38,'multiline':False]['text':'/< Not: !.','line_number':40,'multiline':False]['text':'/< Integer number literal, or part of a float.','line_number':42,'multiline':False]['text':'/< Single quoted string literal.','line_number':43,'multiline':False]['text':'/< Double quoted string literal.','line_number':44,'multiline':False]['text':'/< &optionname option value.','line_number':45,'multiline':False]['text':'/< @r register value.','line_number':46,'multiline':False]['text':'/< Environment $variable value.','line_number':47,'multiline':False]['text':'/< Identifier without scope: `abc`, `foo#bar`.','line_number':48,'multiline':False]['text':'/< Bracket, either opening or closing.','line_number':50,'multiline':False]['text':'/< Figure brace, either opening or closing.','line_number':51,'multiline':False]['text':'/< Parenthesis, either opening or closing.','line_number':52,'multiline':False]['text':'/< Comma.','line_number':53,'multiline':False]['text':'/< Arrow, like from lambda expressions.','line_number':54,'multiline':False]['text':'/< Assignment: `=` or `{op}=`.','line_number':55,'multiline':False]['text':' XXX When modifying this enum you need to also modify eltkn_type_tab in','line_number':56,'multiline':False]['text':'     expressions.c and tests and, possibly, viml_pexpr_repr_token.','line_number':57,'multiline':False]['text':'/< Equality, inequality.','line_number':61,'multiline':False]['text':'/< Matches regex, not matches regex.','line_number':62,'multiline':False]['text':'/< `>` or `<=`','line_number':63,'multiline':False]['text':'/< `>=` or `<`.','line_number':64,'multiline':False]['text':'/< `is` or `isnot`','line_number':65,'multiline':False]['text':'/ All possible option scopes','line_number':68,'multiline':False]['text':'/ All possible assignment types: `=` and `{op}=`.','line_number':75,'multiline':False]['text':'/< Plain assignment: `=`.','line_number':77,'multiline':False]['text':'/< Assignment augmented with addition: `+=`.','line_number':78,'multiline':False]['text':'/< Assignment augmented with subtraction: `-=`.','line_number':79,'multiline':False]['text':'/< Assignment augmented with concatenation: `.=`.','line_number':80,'multiline':False]['text':'/ All possible variable scopes','line_number':86,'multiline':False]['text':'/ Lexer token','line_number':106,'multiline':False]['text':'/< Comparison type.','line_number':113,'multiline':False]['text':'/< Case comparison strategy.','line_number':114,'multiline':False]['text':'/< True if comparison is to be inverted.','line_number':115,'multiline':False]['text':'/< For kExprLexComparison.','line_number':116,'multiline':False]['text':'/< Real multiplication.','line_number':120,'multiline':False]['text':'/< Division.','line_number':121,'multiline':False]['text':'/< Modulo.','line_number':122,'multiline':False]['text':'/< Multiplication type.','line_number':123,'multiline':False]['text':'/< For kExprLexMultiplication.','line_number':124,'multiline':False]['text':'/< True if bracket/etc is a closing one.','line_number':127,'multiline':False]['text':'/< For brackets/braces/parenthesis.','line_number':128,'multiline':False]['text':'/< Register name, may be -1 if name not present.','line_number':131,'multiline':False]['text':'/< For kExprLexRegister.','line_number':132,'multiline':False]['text':'/< True if quote was closed.','line_number':135,'multiline':False]['text':'/< For kExprLexSingleQuotedString and kExprLexDoubleQuotedString.','line_number':136,'multiline':False]['text':'/< Option name start.','line_number':139,'multiline':False]['text':'/< Option name length.','line_number':140,'multiline':False]['text':'/< Option scope: &l:, &g: or not specified.','line_number':141,'multiline':False]['text':'/< Option properties.','line_number':142,'multiline':False]['text':'/< Scope character or 0 if not present.','line_number':145,'multiline':False]['text':'/< Has autoload characters.','line_number':146,'multiline':False]['text':'/< For kExprLexPlainIdentifier','line_number':147,'multiline':False]['text':'/< Suggested type for parsing incorrect code.','line_number':150,'multiline':False]['text':'/< Error message.','line_number':151,'multiline':False]['text':'/< For kExprLexInvalid','line_number':152,'multiline':False]['text':'/< Number value.','line_number':158,'multiline':False]['text':'/< Base: 2, 8, 10 or 16.','line_number':159,'multiline':False]['text':'/< True if number is a floating-point.','line_number':160,'multiline':False]['text':'/< For kExprLexNumber','line_number':161,'multiline':False]['text':'/< For kExprLexAssignment','line_number':165,'multiline':False]['text':'/< Additional data, if needed.','line_number':166,'multiline':False]['text':'/ If set, “pointer” to the current byte in pstate will not be shifted','line_number':170,'multiline':False]['text':'/ Determines whether scope is allowed to come before the identifier','line_number':172,'multiline':False]['text':'/ Determines whether floating-point numbers are allowed','line_number':174,'multiline':False]['text':'/','line_number':175,'multiline':False]['text':'/ I.e. whether dot is a decimal point separator or is not a part of','line_number':176,'multiline':False]['text':'/ a number at all.','line_number':177,'multiline':False]['text':'/ Determines whether `is` and `isnot` are seen as comparison operators','line_number':179,'multiline':False]['text':'/','line_number':180,'multiline':False]['text':'/ If set they are supposed to be just regular identifiers.','line_number':181,'multiline':False]['text':'/ Determines whether EOC tokens are allowed','line_number':183,'multiline':False]['text':'/','line_number':184,'multiline':False]['text':'/ If set then it will yield Invalid token with E15 in place of EOC one if','line_number':185,'multiline':False]['text':'/ “EOC” is something like "|". It is fine with emitting EOC at the end of','line_number':186,'multiline':False]['text':'/ string still, with or without this flag set.','line_number':187,'multiline':False]['text':' XXX Whenever you add a new flag, alter klee_assume() statement in','line_number':189,'multiline':False]['text':'     viml_expressions_lexer.c.','line_number':190,'multiline':False]['text':'/ Expression AST node type','line_number':193,'multiline':False]['text':'/< Ternary operator.','line_number':197,'multiline':False]['text':'/< Ternary operator, colon.','line_number':198,'multiline':False]['text':'/< Register.','line_number':199,'multiline':False]['text':'/< Subscript.','line_number':200,'multiline':False]['text':'/< List literal.','line_number':201,'multiline':False]['text':'/< Nested parenthesised expression.','line_number':204,'multiline':False]['text':'/< Function call.','line_number':205,'multiline':False]['text':'/ Plain identifier: simple variable/function name','line_number':206,'multiline':False]['text':'/','line_number':207,'multiline':False]['text':'/ Looks like "string", "g:Foo", etc: consists from a single','line_number':208,'multiline':False]['text':'/ kExprLexPlainIdentifier token.','line_number':209,'multiline':False]['text':'/ Plain dictionary key, for use with kExprNodeConcatOrSubscript','line_number':211,'multiline':False]['text':'/ Complex identifier: variable/function name with curly braces','line_number':213,'multiline':False]['text':'/ Figure brace expression which is not yet known','line_number':215,'multiline':False]['text':'/','line_number':216,'multiline':False]['text':'/ May resolve to any of kExprNodeDictLiteral, kExprNodeLambda or','line_number':217,'multiline':False]['text':'/ kExprNodeCurlyBracesIdentifier.','line_number':218,'multiline':False]['text':'/< Lambda.','line_number':220,'multiline':False]['text':'/< Dictionary literal.','line_number':221,'multiline':False]['text':'/< Part of the curly braces name.','line_number':222,'multiline':False]['text':'/< Comma “operator”.','line_number':223,'multiline':False]['text':'/< Colon “operator”.','line_number':224,'multiline':False]['text':'/< Arrow “operator”.','line_number':225,'multiline':False]['text':'/< Various comparison operators.','line_number':226,'multiline':False]['text':'/ Concat operator','line_number':227,'multiline':False]['text':'/','line_number':228,'multiline':False]['text':'/ To be only used in cases when it is known for sure it is not a subscript.','line_number':229,'multiline':False]['text':'/ Concat or subscript operator','line_number':231,'multiline':False]['text':'/','line_number':232,'multiline':False]['text':'/ For cases when it is not obvious whether expression is a concat or','line_number':233,'multiline':False]['text':'/ a subscript. May only have either number or plain identifier as the second','line_number':234,'multiline':False]['text':'/ child. To make it easier to avoid curly braces in place of','line_number':235,'multiline':False]['text':'/ kExprNodePlainIdentifier node kExprNodePlainKey is used.','line_number':236,'multiline':False]['text':'/< Integral number.','line_number':238,'multiline':False]['text':'/< Floating-point number.','line_number':239,'multiline':False]['text':' XXX When modifying this list also modify east_node_type_tab both in parser','line_number':253,'multiline':False]['text':'     and in tests, and you most likely will also have to alter list of','line_number':254,'multiline':False]['text':'     highlight groups stored in highlight_init_cmdline variable.','line_number':255,'multiline':False]['text':'/ Structure representing one AST node','line_number':260,'multiline':False]['text':'/< Node type.','line_number':262,'multiline':False]['text':'/ Node children: e.g. for 1 + 2 nodes 1 and 2 will be children of +.','line_number':263,'multiline':False]['text':'/ Next node: e.g. for 1 + 2 child nodes 1 and 2 are put into a single-linked','line_number':265,'multiline':False]['text':'/ list: `(+)->children` references only node 1, node 2 is in','line_number':266,'multiline':False]['text':'/ `(+)->children->next`.','line_number':267,'multiline':False]['text':'/< Register name, may be -1 if name not present.','line_number':273,'multiline':False]['text':'/< For kExprNodeRegister.','line_number':274,'multiline':False]['text':'/ Which nodes UnknownFigure can’t possibly represent.','line_number':276,'multiline':False]['text':'/ True if UnknownFigure may actually represent dictionary literal.','line_number':278,'multiline':False]['text':'/ True if UnknownFigure may actually represent lambda.','line_number':280,'multiline':False]['text':'/ True if UnknownFigure may actually be part of curly braces name.','line_number':282,'multiline':False]['text':'/ Highlight chunk index, used for rehighlighting if needed','line_number':285,'multiline':False]['text':'/< For kExprNodeUnknownFigure.','line_number':287,'multiline':False]['text':'/< Scope character or 0 if not present.','line_number':289,'multiline':False]['text':'/ Actual identifier without scope.','line_number':290,'multiline':False]['text':'/','line_number':291,'multiline':False]['text':'/ Points to inside parser reader state.','line_number':292,'multiline':False]['text':'/< Actual identifier length.','line_number':294,'multiline':False]['text':'/< For kExprNodePlainIdentifier and kExprNodePlainKey.','line_number':295,'multiline':False]['text':'/< True if colon was seen.','line_number':297,'multiline':False]['text':'/< For kExprNodeTernaryValue.','line_number':298,'multiline':False]['text':'/< Comparison type.','line_number':300,'multiline':False]['text':'/< Case comparison strategy.','line_number':301,'multiline':False]['text':'/< True if comparison is to be inverted.','line_number':302,'multiline':False]['text':'/< For kExprNodeComparison.','line_number':303,'multiline':False]['text':'/< For kExprNodeInteger.','line_number':306,'multiline':False]['text':'/< For kExprNodeFloat.','line_number':309,'multiline':False]['text':'/< For kExprNodeSingleQuotedString and','line_number':313,'multiline':False]['text':'/< kExprNodeDoubleQuotedString.','line_number':314,'multiline':False]['text':'/< Option name start.','line_number':316,'multiline':False]['text':'/< Option name length.','line_number':317,'multiline':False]['text':'/< Option scope: &l:, &g: or not specified.','line_number':318,'multiline':False]['text':'/< For kExprNodeOption.','line_number':319,'multiline':False]['text':'/< Environment variable name start.','line_number':321,'multiline':False]['text':'/< Environment variable name length.','line_number':322,'multiline':False]['text':'/< For kExprNodeEnvironment.','line_number':323,'multiline':False]['text':'/< For kExprNodeAssignment','line_number':326,'multiline':False]['text':'/ Allow multiple expressions in a row: e.g. for :echo','line_number':331,'multiline':False]['text':'/','line_number':332,'multiline':False]['text':'/ Parser will still parse only one of them though.','line_number':333,'multiline':False]['text':'/ Allow NL, NUL and bar to be EOC','line_number':335,'multiline':False]['text':'/','line_number':336,'multiline':False]['text':'/ When parsing expressions input by user bar is assumed to be a binary','line_number':337,'multiline':False]['text':'/ operator and other two are spacings.','line_number':338,'multiline':False]['text':'/ Parse :let argument','line_number':340,'multiline':False]['text':'/','line_number':341,'multiline':False]['text':'/ That mean that top level node must be an assignment and first nodes','line_number':342,'multiline':False]['text':'/ belong to lvalues.','line_number':343,'multiline':False]['text':' XXX whenever you add a new flag, alter klee_assume() statement in','line_number':345,'multiline':False]['text':'     viml_expressions_parser.c, nvim_parse_expression() flags parsing','line_number':346,'multiline':False]['text':'     alongside with its documentation and flag sets in check_parsing()','line_number':347,'multiline':False]['text':'     function in expressions parser functional and unit tests.','line_number':348,'multiline':False]['text':'/ AST error definition','line_number':351,'multiline':False]['text':'/ Error message. Must contain a single printf format atom: %.*s.','line_number':353,'multiline':False]['text':'/ Error message argument: points to the location of the error.','line_number':355,'multiline':False]['text':'/ Message argument length: length till the end of string.','line_number':357,'multiline':False]['text':'/ Structure representing complete AST for one expression','line_number':361,'multiline':False]['text':'/ When AST is not correct this message will be printed.','line_number':363,'multiline':False]['text':'/','line_number':364,'multiline':False]['text':'/ Uses `semsg(msg, arg_len, arg);`, `msg` is assumed to contain only `%.*s`.','line_number':365,'multiline':False]['text':'/ Root node of the AST.','line_number':367,'multiline':False]['text':'/ Array mapping ExprASTNodeType to maximum amount of children node may have','line_number':371,'multiline':False]['text':'/ Array mapping ExprASTNodeType values to their stringified versions','line_number':374,'multiline':False]['text':'/ Array mapping ExprComparisonType values to their stringified versions','line_number':377,'multiline':False]['text':'/ Array mapping ExprCaseCompareStrategy values to their stringified versions','line_number':380,'multiline':False]['text':'/ Array mapping ExprAssignmentType values to their stringified versions','line_number':383,'multiline':False]