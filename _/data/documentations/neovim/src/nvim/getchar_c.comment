['text':' getchar.c: Code related to getting a character from the user or a script','line_number':1,'multiline':False]['text':' file, manipulations with redo buffer and stuff buffer.','line_number':2,'multiline':False]['text':'/ Index in scriptin','line_number':61,'multiline':False]['text':' These buffers are used for storing:','line_number':65,'multiline':False]['text':' - stuffed characters: A command that is translated into another command.','line_number':66,'multiline':False]['text':' - redo characters: will redo the last change.','line_number':67,'multiline':False]['text':' - recorded characters: for the "q" command.','line_number':68,'multiline':False]['text':'','line_number':69,'multiline':False]['text':' The bytes are stored like in the typeahead buffer:','line_number':70,'multiline':False]['text':' - K_SPECIAL introduces a special key (two more bytes follow).  A literal','line_number':71,'multiline':False]['text':'   K_SPECIAL is stored as K_SPECIAL KS_SPECIAL KE_FILLER.','line_number':72,'multiline':False]['text':' These translations are also done on multi-byte characters!','line_number':73,'multiline':False]['text':'','line_number':74,'multiline':False]['text':' Escaping K_SPECIAL is done by inchar().','line_number':75,'multiline':False]['text':' Un-escaping is done by vgetc().','line_number':76,'multiline':False]['text':' minimal size for b_str','line_number':78,'multiline':False]['text':'/ First read ahead buffer. Used for translated commands.','line_number':84,'multiline':False]['text':'/ Second read ahead buffer. Used for redo.','line_number':87,'multiline':False]['text':'/< typeahead char that's not flushed','line_number':90,'multiline':False]['text':'/ When block_redo is true the redo buffer will not be changed.','line_number':92,'multiline':False]['text':'/ Used by edit() to repeat insertions.','line_number':93,'multiline':False]['text':'/< remapping flags','line_number':96,'multiline':False]['text':'/ Variables used by vgetorpeek() and flush_buffers()','line_number':98,'multiline':False]['text':'/','line_number':99,'multiline':False]['text':'/ typebuf.tb_buf[] contains all characters that are not consumed yet.','line_number':100,'multiline':False]['text':'/ typebuf.tb_buf[typebuf.tb_off] is the first valid character.','line_number':101,'multiline':False]['text':'/ typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len - 1] is the last valid char.','line_number':102,'multiline':False]['text':'/ typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len] must be NUL.','line_number':103,'multiline':False]['text':'/ The head of the buffer may contain the result of mappings, abbreviations','line_number':104,'multiline':False]['text':'/ and @a commands.  The length of this part is typebuf.tb_maplen.','line_number':105,'multiline':False]['text':'/ typebuf.tb_silent is the part where <silent> applies.','line_number':106,'multiline':False]['text':'/ After the head are characters that come from the terminal.','line_number':107,'multiline':False]['text':'/ typebuf.tb_no_abbr_cnt is the number of characters in typebuf.tb_buf that','line_number':108,'multiline':False]['text':'/ should not be considered for abbreviations.','line_number':109,'multiline':False]['text':'/ Some parts of typebuf.tb_buf may not be mapped. These parts are remembered','line_number':110,'multiline':False]['text':'/ in typebuf.tb_noremap[], which is the same length as typebuf.tb_buf and','line_number':111,'multiline':False]['text':'/ contains RM_NONE for the characters that are not to be remapped.','line_number':112,'multiline':False]['text':'/ typebuf.tb_noremap[typebuf.tb_off] is the first valid flag.','line_number':113,'multiline':False]['text':'/< tb_noremap: remap','line_number':115,'multiline':False]['text':'/< tb_noremap: don't remap','line_number':116,'multiline':False]['text':'/< tb_noremap: remap local script mappings','line_number':117,'multiline':False]['text':'/< tb_noremap: don't remap, do abbrev.','line_number':118,'multiline':False]['text':' typebuf.tb_buf has three parts: room in front (for result of mappings), the','line_number':121,'multiline':False]['text':' middle for typeahead and room for new characters (which needs to be 3 *','line_number':122,'multiline':False]['text':' MAXMAPLEN for the Amiga).','line_number':123,'multiline':False]['text':'/< initial typebuf.tb_buf','line_number':125,'multiline':False]['text':'/< initial typebuf.tb_noremap','line_number':126,'multiline':False]['text':'/< number of last recorded chars','line_number':128,'multiline':False]['text':'/< keylen value for incomplete key-code','line_number':131,'multiline':False]['text':'/< keylen value for incomplete mapping','line_number':132,'multiline':False]['text':'/ Free and clear a buffer.','line_number':145,'multiline':False]['text':'/ Return the contents of a buffer as a single string.','line_number':158,'multiline':False]['text':'/ K_SPECIAL in the returned string is escaped.','line_number':159,'multiline':False]['text':'/','line_number':160,'multiline':False]['text':'/ @param dozero  count == zero is not an error','line_number':161,'multiline':False]['text':' compute the total length of the string','line_number':167,'multiline':False]['text':'/ Return the contents of the record buffer as a single string','line_number':187,'multiline':False]['text':'/ and clear the record buffer.','line_number':188,'multiline':False]['text':'/ K_SPECIAL in the returned string is escaped.','line_number':189,'multiline':False]['text':' Remove the characters that were added the last time, these must be the','line_number':198,'multiline':False]['text':' (possibly mapped) characters that stopped the recording.','line_number':199,'multiline':False]['text':' When stopping recording from Insert mode with CTRL-O q, also remove the','line_number':206,'multiline':False]['text':' CTRL-O.','line_number':207,'multiline':False]['text':'/ Return the contents of the redo buffer as a single string.','line_number':215,'multiline':False]['text':'/ K_SPECIAL in the returned string is escaped.','line_number':216,'multiline':False]['text':'/ Add string after the current block of the given buffer','line_number':222,'multiline':False]['text':'/','line_number':223,'multiline':False]['text':'/ K_SPECIAL should have been escaped already.','line_number':224,'multiline':False]['text':'/','line_number':225,'multiline':False]['text':'/ @param[out]  buf  Buffer to add to.','line_number':226,'multiline':False]['text':'/ @param[in]  s  String to add.','line_number':227,'multiline':False]['text':'/ @param[in]  slen  String length or -1 for NUL-terminated string.','line_number':228,'multiline':False]['text':' don't add empty strings','line_number':234,'multiline':False]['text':' first add to list','line_number':238,'multiline':False]['text':' buffer has already been read','line_number':241,'multiline':False]['text':'/ Delete "slen" bytes from the end of "buf".','line_number':272,'multiline':False]['text':'/ Only works when it was just added.','line_number':273,'multiline':False]['text':' nothing to delete','line_number':279,'multiline':False]['text':'/ Add number "n" to buffer "buf".','line_number':290,'multiline':False]['text':'/ Add character 'c' to buffer "buf".','line_number':298,'multiline':False]['text':'/ Translates special keys, NUL, K_SPECIAL and multibyte characters.','line_number':299,'multiline':False]['text':' Translate special key code into three byte sequence.','line_number':318,'multiline':False]['text':'/ Get one byte from the read buffers.  Use readbuf1 one first, use readbuf2','line_number':331,'multiline':False]['text':'/ if that one is empty.','line_number':332,'multiline':False]['text':'/ If advance == true go to the next char.','line_number':333,'multiline':False]['text':'/ No translation is done K_SPECIAL is escaped.','line_number':334,'multiline':False]['text':' buffer is empty','line_number':348,'multiline':False]['text':'/ Prepare the read buffers for reading (if they contain something).','line_number':365,'multiline':False]['text':'/ Return true if the stuff buffer is empty.','line_number':378,'multiline':False]['text':'/ Return true if readbuf1 is empty.  There may still be redo characters in','line_number':385,'multiline':False]['text':'/ redbuf2.','line_number':386,'multiline':False]['text':'/ Set a typeahead character that won't be flushed.','line_number':393,'multiline':False]['text':'/ Remove the contents of the stuff buffer and the mapped characters in the','line_number':399,'multiline':False]['text':'/ typeahead buffer (used in case of an error).  If "flush_typeahead" is true,','line_number':400,'multiline':False]['text':'/ flush all typeahead characters (used when interrupted by a CTRL-C).','line_number':401,'multiline':False]['text':' remove mapped characters at the start only','line_number':410,'multiline':False]['text':' remove typeahead','line_number':414,'multiline':False]['text':' We have to get all characters, because we may delete the first','line_number':416,'multiline':False]['text':' part of an escape sequence.  In an xterm we get one char at a','line_number':417,'multiline':False]['text':' time and we have to get them all.','line_number':418,'multiline':False]['text':' Reset the flag that text received from a client or from feedkeys()','line_number':423,'multiline':False]['text':' was inserted in the typeahead buffer.','line_number':424,'multiline':False]['text':'/ flush map and typeahead buffers and give a warning for an error','line_number':436,'multiline':False]['text':'/ The previous contents of the redo buffer is kept in old_redobuffer.','line_number':445,'multiline':False]['text':'/ This is used for the CTRL-O <.> command in insert mode.','line_number':446,'multiline':False]['text':'/ Discard the contents of the redo buffer and restore the previous redo','line_number':458,'multiline':False]['text':'/ buffer.','line_number':459,'multiline':False]['text':'/ Save redobuff and old_redobuff to save_redobuff and save_old_redobuff.','line_number':473,'multiline':False]['text':'/ Used before executing autocommands and user functions.','line_number':474,'multiline':False]['text':' Make a copy, so that ":normal ." in a function works.','line_number':482,'multiline':False]['text':'/ Restore redobuff and old_redobuff from save_redobuff and save_old_redobuff.','line_number':492,'multiline':False]['text':'/ Used after executing autocommands and user functions.','line_number':493,'multiline':False]['text':'/ Append "s" to the redo buffer.','line_number':502,'multiline':False]['text':'/ K_SPECIAL should already have been escaped.','line_number':503,'multiline':False]['text':'/ Append to Redo buffer literally, escaping special characters with CTRL-V.','line_number':511,'multiline':False]['text':'/ K_SPECIAL is escaped as well.','line_number':512,'multiline':False]['text':'/','line_number':513,'multiline':False]['text':'/ @param str  String to append','line_number':514,'multiline':False]['text':'/ @param len  Length of `str` or -1 for up to the NUL.','line_number':515,'multiline':False]['text':' Put a string of normal characters in the redo buffer (that's','line_number':524,'multiline':False]['text':' faster).','line_number':525,'multiline':False]['text':' Don't put '0' or '^' as last character, just in case a CTRL-D is','line_number':531,'multiline':False]['text':' typed next.','line_number':532,'multiline':False]['text':' Handle a special or multibyte character.','line_number':544,'multiline':False]['text':' Composing chars separately are handled separately.','line_number':545,'multiline':False]['text':' CTRL-V '0' must be inserted as CTRL-V 048.','line_number':551,'multiline':False]['text':'/ Append "s" to the redo buffer, leaving 3-byte special key codes unmodified','line_number':560,'multiline':False]['text':'/ and escaping other K_SPECIAL bytes.','line_number':561,'multiline':False]['text':' Insert special key literally.','line_number':570,'multiline':False]['text':'/ Append a character to the redo buffer.','line_number':579,'multiline':False]['text':'/ Translates special keys, NUL, K_SPECIAL and multibyte characters.','line_number':580,'multiline':False]['text':' Append a number to the redo buffer.','line_number':588,'multiline':False]['text':'/ Append string "s" to the stuff buffer.','line_number':596,'multiline':False]['text':'/ K_SPECIAL must already have been escaped.','line_number':597,'multiline':False]['text':'/ Append string "s" to the redo stuff buffer.','line_number':603,'multiline':False]['text':'/ @remark K_SPECIAL must already have been escaped.','line_number':604,'multiline':False]['text':'/ Stuff "s" into the stuff buffer, leaving special key codes unmodified and','line_number':615,'multiline':False]['text':'/ escaping other K_SPECIAL bytes.','line_number':616,'multiline':False]['text':'/ Change CR, LF and ESC into a space.','line_number':617,'multiline':False]['text':' Insert special key literally.','line_number':622,'multiline':False]['text':'/ Append a character to the stuff buffer.','line_number':635,'multiline':False]['text':'/ Translates special keys, NUL, K_SPECIAL and multibyte characters.','line_number':636,'multiline':False]['text':' Append a number to the stuff buffer.','line_number':642,'multiline':False]['text':'/ Stuff a string into the typeahead buffer, such that edit() will insert it','line_number':648,'multiline':False]['text':'/ literally ("literally" true) or interpret is as typed characters.','line_number':649,'multiline':False]['text':' Stuff a sequence of normal ASCII characters, that's fast.  Also','line_number':653,'multiline':False]['text':' stuff K_SPECIAL to get the effect of a special key when "literally"','line_number':654,'multiline':False]['text':' is true.','line_number':655,'multiline':False]['text':' stuff a single special character','line_number':665,'multiline':False]['text':'/ Read a character from the redo buffer.  Translates K_SPECIAL and','line_number':676,'multiline':False]['text':'/ multibyte characters.','line_number':677,'multiline':False]['text':'/ The redo buffer is left as it is.','line_number':678,'multiline':False]['text':'/ If init is true, prepare for redo, return FAIL if nothing to redo, OK','line_number':679,'multiline':False]['text':'/ otherwise.','line_number':680,'multiline':False]['text':'/ If old_redo is true, use old_redobuff instead of redobuff.','line_number':681,'multiline':False]['text':' Reverse the conversion done by add_char_buff()','line_number':701,'multiline':False]['text':' For a multi-byte character get all the bytes and return the','line_number':702,'multiline':False]['text':' converted character.','line_number':703,'multiline':False]['text':' special key or escaped K_SPECIAL','line_number':710,'multiline':False]['text':' last byte of a character','line_number':719,'multiline':False]['text':' cannot happen?','line_number':726,'multiline':False]['text':'/ Copy the rest of the redo buffer into the stuff buffer (in a slow way).','line_number':734,'multiline':False]['text':'/ If old_redo is true, use old_redobuff instead of redobuff.','line_number':735,'multiline':False]['text':'/ The escaped K_SPECIAL is copied without translation.','line_number':736,'multiline':False]['text':'/ Stuff the redo buffer into readbuf2.','line_number':746,'multiline':False]['text':'/ Insert the redo count into the command.','line_number':747,'multiline':False]['text':'/ If "old_redo" is true, the last but one command is repeated','line_number':748,'multiline':False]['text':'/ instead of the last command (inserting text). This is used for','line_number':749,'multiline':False]['text':'/ CTRL-O <.> in insert mode','line_number':750,'multiline':False]['text':'/','line_number':751,'multiline':False]['text':'/ @return  FAIL for failure, OK otherwise','line_number':752,'multiline':False]['text':' init the pointers; return if nothing to redo','line_number':755,'multiline':False]['text':' copy the buffer name, if present','line_number':762,'multiline':False]['text':' if a numbered buffer is used, increment the number','line_number':767,'multiline':False]['text':' the expression register should be re-evaluated','line_number':773,'multiline':False]['text':' redo Visual','line_number':782,'multiline':False]['text':' try to enter the count (in place of a previous count)','line_number':791,'multiline':False]['text':' skip "old" count','line_number':793,'multiline':False]['text':' copy from the redo buffer into the stuff buffer','line_number':799,'multiline':False]['text':'/ Repeat the last insert (R, o, O, a, A, i or I command) by stuffing','line_number':805,'multiline':False]['text':'/ the redo buffer into readbuf2.','line_number':806,'multiline':False]['text':'/','line_number':807,'multiline':False]['text':'/ @return  FAIL for failure, OK otherwise','line_number':808,'multiline':False]['text':' skip the count and the command character','line_number':818,'multiline':False]['text':' copy the typed text from the redo buffer into the stuff buffer','line_number':828,'multiline':False]['text':'/ Initialize typebuf.tb_buf to point to typebuf_init.','line_number':839,'multiline':False]['text':'/ alloc() cannot be used here: In out-of-memory situations it would','line_number':840,'multiline':False]['text':'/ be impossible to type anything.','line_number':841,'multiline':False]['text':'/ @return true when keys cannot be remapped.','line_number':856,'multiline':False]['text':'/ Insert a string in position "offset" in the typeahead buffer.','line_number':862,'multiline':False]['text':'/','line_number':863,'multiline':False]['text':'/ If "noremap" is REMAP_YES, new string can be mapped again.','line_number':864,'multiline':False]['text':'/ If "noremap" is REMAP_NONE, new string cannot be mapped again.','line_number':865,'multiline':False]['text':'/ If "noremap" is REMAP_SKIP, first char of new string cannot be mapped again,','line_number':866,'multiline':False]['text':'/ but abbreviations are allowed.','line_number':867,'multiline':False]['text':'/ If "noremap" is REMAP_SCRIPT, new string cannot be mapped again, except for','line_number':868,'multiline':False]['text':'/                               script-local mappings.','line_number':869,'multiline':False]['text':'/ If "noremap" is > 0, that many characters of the new string cannot be mapped.','line_number':870,'multiline':False]['text':'/','line_number':871,'multiline':False]['text':'/ If "nottyped" is true, the string does not return KeyTyped (don't use when','line_number':872,'multiline':False]['text':'/ "offset" is non-zero!).','line_number':873,'multiline':False]['text':'/','line_number':874,'multiline':False]['text':'/ If "silent" is true, cmd_silent is set when the characters are obtained.','line_number':875,'multiline':False]['text':'/','line_number':876,'multiline':False]['text':'/ @return  FAIL for failure, OK otherwise','line_number':877,'multiline':False]['text':' Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off]','line_number':892,'multiline':False]['text':' Buffer is empty and string fits in the existing buffer.','line_number':897,'multiline':False]['text':' Leave some space before and after, if possible.','line_number':898,'multiline':False]['text':' Need to allocate a new buffer.','line_number':902,'multiline':False]['text':' In typebuf.tb_buf there must always be room for 3 * (MAXMAPLEN + 4)','line_number':903,'multiline':False]['text':' characters.  We add some extra room to avoid having to allocate too','line_number':904,'multiline':False]['text':' often.','line_number':905,'multiline':False]['text':' string is getting too long for 32 bit int','line_number':909,'multiline':False]['text':' also calls flush_buffers','line_number':910,'multiline':False]['text':' copy the old chars, before the insertion point','line_number':919,'multiline':False]['text':' copy the new chars','line_number':921,'multiline':False]['text':' copy the old chars, after the insertion point, including the NUL at','line_number':923,'multiline':False]['text':' the end','line_number':924,'multiline':False]['text':' If noremap == REMAP_SCRIPT: do remap script-local mappings.','line_number':948,'multiline':False]['text':' Adjust typebuf.tb_noremap[] for the new characters:','line_number':957,'multiline':False]['text':' If noremap == REMAP_NONE or REMAP_SCRIPT: new characters are','line_number':958,'multiline':False]['text':'                    (sometimes) not remappable','line_number':959,'multiline':False]['text':' If noremap == REMAP_YES: all the new characters are mappable','line_number':960,'multiline':False]['text':' If noremap  > 0: "noremap" characters are not remappable, the rest','line_number':961,'multiline':False]['text':'                    mappable','line_number':962,'multiline':False]['text':' tb_maplen and tb_silent only remember the length of mapped and/or','line_number':975,'multiline':False]['text':' silent mappings at the start of the buffer, assuming that a mapped','line_number':976,'multiline':False]['text':' sequence doesn't result in typed characters.','line_number':977,'multiline':False]['text':' and not used for abbrev.s','line_number':985,'multiline':False]['text':'/ Put character "c" back into the typeahead buffer.','line_number':992,'multiline':False]['text':'/ Can be used for a character obtained by vgetc() that needs to be put back.','line_number':993,'multiline':False]['text':'/ Uses cmd_silent, KeyTyped and KeyNoremap to restore the flags belonging to','line_number':994,'multiline':False]['text':'/ the char.','line_number':995,'multiline':False]['text':'/','line_number':996,'multiline':False]['text':'/ @return the length of what was inserted','line_number':997,'multiline':False]['text':'/ Return true if the typeahead buffer was changed (while waiting for a','line_number':1008,'multiline':False]['text':'/ character to arrive).  Happens when a message was received from a client or','line_number':1009,'multiline':False]['text':'/ from feedkeys().','line_number':1010,'multiline':False]['text':'/ But check in a more generic way to avoid trouble: When "typebuf.tb_buf"','line_number':1011,'multiline':False]['text':'/ changed it was reallocated and the old pointer can no longer be used.','line_number':1012,'multiline':False]['text':'/ Or "typebuf.tb_off" may have been changed and we would overwrite characters','line_number':1013,'multiline':False]['text':'/ that was just added.','line_number':1014,'multiline':False]['text':'/','line_number':1015,'multiline':False]['text':'/ @param tb_change_cnt  old value of typebuf.tb_change_cnt','line_number':1016,'multiline':False]['text':'/ Return true if there are no characters in the typeahead buffer that have','line_number':1024,'multiline':False]['text':'/ not been typed (result from a mapping or come from ":normal").','line_number':1025,'multiline':False]['text':'/ Get the number of characters that are mapped (or not typed).','line_number':1032,'multiline':False]['text':'/ Remove "len" characters from typebuf.tb_buf[typebuf.tb_off + offset]','line_number':1039,'multiline':False]['text':' nothing to do','line_number':1043,'multiline':False]['text':' Easy case: Just increase typebuf.tb_off.','line_number':1048,'multiline':False]['text':' Have to move the characters in typebuf.tb_buf[] and typebuf.tb_noremap[]','line_number':1053,'multiline':False]['text':' Leave some extra room at the end to avoid reallocation.','line_number':1055,'multiline':False]['text':' adjust typebuf.tb_buf (include the NUL at the end)','line_number':1063,'multiline':False]['text':' adjust typebuf.tb_noremap[]','line_number':1068,'multiline':False]['text':' adjust tb_maplen','line_number':1074,'multiline':False]['text':' adjust tb_silent','line_number':1081,'multiline':False]['text':' adjust tb_no_abbr_cnt','line_number':1088,'multiline':False]['text':' Reset the flag that text received from a client or from feedkeys()','line_number':1096,'multiline':False]['text':' was inserted in the typeahead buffer.','line_number':1097,'multiline':False]['text':'/ Write typed characters to script file.','line_number':1104,'multiline':False]['text':'/ If recording is on put the character in the recordbuffer.','line_number':1105,'multiline':False]['text':' When receiving a special key sequence, store it until we have all','line_number':1117,'multiline':False]['text':' the bytes and we can decide what to do with it.','line_number':1118,'multiline':False]['text':' Handle one byte at a time; no translation to be done.','line_number':1126,'multiline':False]['text':' remember how many chars were last recorded','line_number':1134,'multiline':False]['text':' output "debug mode" message next time in debug mode','line_number':1142,'multiline':False]['text':' Since characters have been typed, consider the following to be in','line_number':1145,'multiline':False]['text':' another mapping.  Search string will be kept in history.','line_number':1146,'multiline':False]['text':'/ Record a <Nop> key.','line_number':1150,'multiline':False]['text':'/ Undo the last gotchars() for "len" bytes.  To be used when putting a typed','line_number':1157,'multiline':False]['text':'/ character back into the typeahead buffer, thus gotchars() will be called','line_number':1158,'multiline':False]['text':'/ again.','line_number':1159,'multiline':False]['text':'/ Only affects recorded characters.','line_number':1160,'multiline':False]['text':'/ Sync undo.  Called when typed characters are obtained from the typeahead','line_number':1171,'multiline':False]['text':'/ buffer, or when a menu is used.','line_number':1172,'multiline':False]['text':'/ Do not sync:','line_number':1173,'multiline':False]['text':'/ - In Insert mode, unless cursor key has been used.','line_number':1174,'multiline':False]['text':'/ - While reading a script file.','line_number':1175,'multiline':False]['text':'/ - When no_u_sync is non-zero.','line_number':1176,'multiline':False]['text':'/ Make "typebuf" empty and allocate new buffers.','line_number':1185,'multiline':False]['text':' can insert without realloc','line_number':1191,'multiline':False]['text':'/ Free the buffers of "typebuf".','line_number':1201,'multiline':False]['text':'/ When doing ":so! file", the current typeahead needs to be saved, and','line_number':1216,'multiline':False]['text':'/ restored when "file" has been read completely.','line_number':1217,'multiline':False]['text':'/< character put back by vungetc()','line_number':1227,'multiline':False]['text':'/< mod_mask for ungotten character','line_number':1228,'multiline':False]['text':'/< mouse_grid related to old_char','line_number':1229,'multiline':False]['text':'/< mouse_row related to old_char','line_number':1230,'multiline':False]['text':'/< mouse_col related to old_char','line_number':1231,'multiline':False]['text':'/< whether old_char was stuffed','line_number':1232,'multiline':False]['text':' If the old character was not stuffed and characters have been added to','line_number':1236,'multiline':False]['text':' the stuff buffer, need to first get the stuffed characters instead.','line_number':1237,'multiline':False]['text':'/ Save all three kinds of typeahead, so that the user must type at a prompt.','line_number':1241,'multiline':False]['text':'/ Restore the typeahead to what it was before calling save_typeahead().','line_number':1257,'multiline':False]['text':'/ The allocated memory is freed, can only be called once!','line_number':1258,'multiline':False]['text':'/ Open a new script file for the ":source!" command.','line_number':1275,'multiline':False]['text':'/','line_number':1276,'multiline':False]['text':'/ @param directly  when true execute directly','line_number':1277,'multiline':False]['text':' Disallow sourcing a file in the sandbox, the commands would be executed','line_number':1285,'multiline':False]['text':' later, possibly outside of the sandbox.','line_number':1286,'multiline':False]['text':' Not reading from script, also don't open one.  Warning message?','line_number':1292,'multiline':False]['text':' already reading script','line_number':1296,'multiline':False]['text':' use NameBuff for expanded name','line_number':1299,'multiline':False]['text':' Execute the commands from the file right now when using ":source!"','line_number':1312,'multiline':False]['text':' after ":global" or ":argdo" or in a loop.  Also when another command','line_number':1313,'multiline':False]['text':' follows.  This means the display won't be updated.  Don't do this','line_number':1314,'multiline':False]['text':' always, "make test" would fail.','line_number':1315,'multiline':False]['text':' no msg scrolling in Normal mode','line_number':1325,'multiline':False]['text':' don't go to Insert mode','line_number':1326,'multiline':False]['text':' update cursor position and topline','line_number':1332,'multiline':False]['text':' execute one command','line_number':1333,'multiline':False]['text':' check for end of file','line_number':1334,'multiline':False]['text':'/ Close the currently active input script.','line_number':1344,'multiline':False]['text':'/ Return true when reading keys from a script file.','line_number':1367,'multiline':False]['text':'/ This function is called just before doing a blocking wait.  Thus after','line_number':1374,'multiline':False]['text':'/ waiting 'updatetime' for a character to arrive.','line_number':1375,'multiline':False]['text':'/ updatescript() is called when a character can be written to the script','line_number':1384,'multiline':False]['text':'/ file or when we have waited some time for a character (c == 0).','line_number':1385,'multiline':False]['text':'/','line_number':1386,'multiline':False]['text':'/ All the changed memfiles are synced if c == 0 or when the number of typed','line_number':1387,'multiline':False]['text':'/ characters reaches 'updatecount' and 'updatecount' is non-zero.','line_number':1388,'multiline':False]['text':' Always fsync at idle (CursorHold).','line_number':1399,'multiline':False]['text':'/ Merge "modifiers" into "c_arg".','line_number':1404,'multiline':False]['text':' CTRL-6 is equivalent to CTRL-^','line_number':1416,'multiline':False]['text':'/ Get the next input character.','line_number':1426,'multiline':False]['text':'/ Can return a special key or a multi-byte character.','line_number':1427,'multiline':False]['text':'/ Can return NUL when called recursively, use safe_vgetc() if that's not','line_number':1428,'multiline':False]['text':'/ wanted.','line_number':1429,'multiline':False]['text':'/ This translates escaped K_SPECIAL bytes to a K_SPECIAL byte.','line_number':1430,'multiline':False]['text':'/ Collects the bytes of a multibyte character into the whole character.','line_number':1431,'multiline':False]['text':'/ Returns the modifiers in the global "mod_mask".','line_number':1432,'multiline':False]['text':' Do garbage collection when garbagecollect() was called previously and','line_number':1438,'multiline':False]['text':' we are now at the toplevel.','line_number':1439,'multiline':False]['text':' If a character was put back with vungetc, it was already processed.','line_number':1444,'multiline':False]['text':' Return it directly.','line_number':1445,'multiline':False]['text':' number of characters recorded from the last vgetc() call','line_number':1456,'multiline':False]['text':' last_recorded_len can be larger than last_vgetc_recorded_len','line_number':1463,'multiline':False]['text':' if peeking records more','line_number':1464,'multiline':False]['text':' this is done twice if there are modifiers','line_number':1467,'multiline':False]['text':' no mapping after modifier has been read','line_number':1469,'multiline':False]['text':' mod_mask may change value','line_number':1472,'multiline':False]['text':' Get two extra bytes for special keys','line_number':1480,'multiline':False]['text':' make sure BS is not found','line_number':1484,'multiline':False]['text':' no mapping for these chars','line_number':1485,'multiline':False]['text':' a keypad or special function key was not mapped, use it like','line_number':1496,'multiline':False]['text':' its ASCII equivalent','line_number':1497,'multiline':False]['text':' For a multi-byte character get all the bytes and return the','line_number':1575,'multiline':False]['text':' converted character.','line_number':1576,'multiline':False]['text':' Note: This will loop until enough bytes are received!','line_number':1577,'multiline':False]['text':' Must be a K_SPECIAL - KS_SPECIAL - KE_FILLER sequence,','line_number':1584,'multiline':False]['text':' which represents a K_SPECIAL (0x80).','line_number':1585,'multiline':False]['text':' skip KS_SPECIAL','line_number':1586,'multiline':False]['text':' skip KE_FILLER','line_number':1587,'multiline':False]['text':' If mappings are enabled (i.e., not i_CTRL-V) and the user directly typed something with','line_number':1599,'multiline':False]['text':' MOD_MASK_ALT (<M-/<A- modifier) that was not mapped, interpret <M-x> as <Esc>x rather','line_number':1600,'multiline':False]['text':' than as an unbound <M-x> keypress. #8213','line_number':1601,'multiline':False]['text':' In Terminal mode, however, this is not desirable. #16202 #16220','line_number':1602,'multiline':False]['text':' Also do not do this for mouse keys, as terminals encode mouse events as CSI sequences, and','line_number':1603,'multiline':False]['text':' MOD_MASK_ALT has a meaning even for unmapped mouse keys.','line_number':1604,'multiline':False]['text':' K_SPECIAL KS_MODIFIER MOD_MASK_ALT takes 3 more bytes','line_number':1610,'multiline':False]['text':' In the main loop "may_garbage_collect" can be set to do garbage','line_number':1620,'multiline':False]['text':' collection in the first next vgetc().  It's disabled after that to','line_number':1621,'multiline':False]['text':' avoid internally used Lists and Dicts to be freed.','line_number':1622,'multiline':False]['text':' Execute Lua on_key callbacks.','line_number':1625,'multiline':False]['text':' Need to process the character before we know it's safe to do something','line_number':1628,'multiline':False]['text':' else.','line_number':1629,'multiline':False]['text':'/ Like vgetc(), but never return a NUL when called recursively, get a key','line_number':1637,'multiline':False]['text':'/ directly from the user (ignoring typeahead).','line_number':1638,'multiline':False]['text':'/ Like safe_vgetc(), but loop to handle K_IGNORE.','line_number':1650,'multiline':False]['text':'/ Also ignore scrollbar events.','line_number':1651,'multiline':False]['text':'/ Check if a character is available, such that vgetc() will not block.','line_number':1664,'multiline':False]['text':'/ If the next character is a special character or multi-byte, the returned','line_number':1665,'multiline':False]['text':'/ character is not valid!.','line_number':1666,'multiline':False]['text':'/ Returns NUL if no character is available.','line_number':1667,'multiline':False]['text':'/ Check if any character is available, also half an escape sequence.','line_number':1676,'multiline':False]['text':'/ Trick: when no typeahead found, but there is something in the typeahead','line_number':1677,'multiline':False]['text':'/ buffer, it must be an ESC that is recognized as the start of a key code.','line_number':1678,'multiline':False]['text':'/ Call vpeekc() without causing anything to be mapped.','line_number':1690,'multiline':False]['text':'/ @return  true if a character is available, false otherwise.','line_number':1691,'multiline':False]['text':'/ "getchar()" and "getcharstr()" functions','line_number':1702,'multiline':False]['text':' Position the cursor. Needed after a message that ends in a space.','line_number':1713,'multiline':False]['text':' getchar(): blocking wait.','line_number':1718,'multiline':False]['text':' TODO(bfredl): deduplicate shared logic with state_enter ?','line_number':1719,'multiline':False]['text':' Flush screen updates before blocking.','line_number':1721,'multiline':False]['text':' getchar(1): only check if char avail','line_number':1731,'multiline':False]['text':' illegal argument or getchar(0) and no char avail: return zero','line_number':1734,'multiline':False]['text':' getchar(0) and char avail() != NUL: get a character.','line_number':1737,'multiline':False]['text':' Note that vpeekc_any() returns K_SPECIAL for K_IGNORE.','line_number':1738,'multiline':False]['text':' modifier: 3, mbyte-char: 6, NUL: 1','line_number':1760,'multiline':False]['text':' Turn a special key into three bytes, plus modifier.','line_number':1763,'multiline':False]['text':' Find the window at the mouse coordinates and compute the','line_number':1790,'multiline':False]['text':' text position.','line_number':1791,'multiline':False]['text':'/ "getchar()" function','line_number':1809,'multiline':False]['text':'/ "getcharstr()" function','line_number':1815,'multiline':False]['text':' mbyte-char: 6, NUL: 1','line_number':1824,'multiline':False]['text':'/ "getcharmod()" function','line_number':1837,'multiline':False]['text':' failed, break loop','line_number':1844,'multiline':False]['text':' get a character from typeahead','line_number':1845,'multiline':False]['text':' try to map again','line_number':1846,'multiline':False]['text':' no matching mapping, get char','line_number':1847,'multiline':False]['text':'/ Put "string[new_slen]" in typebuf.','line_number':1850,'multiline':False]['text':'/ Remove "slen" bytes.','line_number':1851,'multiline':False]['text':'/ @return  FAIL for error, OK otherwise.','line_number':1852,'multiline':False]['text':' remove matched chars, taking care of noremap','line_number':1858,'multiline':False]['text':' insert the extra space we need','line_number':1861,'multiline':False]['text':' Careful: del_typebuf() and ins_typebuf() may have reallocated','line_number':1866,'multiline':False]['text':' typebuf.tb_buf[]!','line_number':1867,'multiline':False]['text':'/ Check if the bytes at the start of the typeahead buffer are a character used','line_number':1872,'multiline':False]['text':'/ in Insert mode completion.  This includes the form with a CTRL modifier.','line_number':1873,'multiline':False]['text':'/ Check if typebuf.tb_buf[] contains a modifier plus key that can be changed','line_number':1886,'multiline':False]['text':'/ into just a key, apply that.','line_number':1887,'multiline':False]['text':'/ Check from typebuf.tb_buf[typebuf.tb_off] to typebuf.tb_buf[typebuf.tb_off + "max_offset"].','line_number':1888,'multiline':False]['text':'/ @return  the length of the replaced bytes, 0 if nothing changed, -1 for error.','line_number':1889,'multiline':False]['text':' A modifier was not used for a mapping, apply it to ASCII','line_number':1898,'multiline':False]['text':' keys.  Shift would already have been applied.','line_number':1899,'multiline':False]['text':' At the start: remember the character and mod_mask before','line_number':1906,'multiline':False]['text':' merging, in some cases, e.g. at the hit-return prompt,','line_number':1907,'multiline':False]['text':' they are put back in the typeahead buffer.','line_number':1908,'multiline':False]['text':'/ Handle mappings in the typeahead buffer.','line_number':1939,'multiline':False]['text':'/ - When something was mapped, return map_result_retry for recursive mappings.','line_number':1940,'multiline':False]['text':'/ - When nothing mapped and typeahead has a character: return map_result_get.','line_number':1941,'multiline':False]['text':'/ - When there is no match yet, return map_result_nomatch, need to get more','line_number':1942,'multiline':False]['text':'/   typeahead.','line_number':1943,'multiline':False]['text':'/ - On failure (out of memory) return map_result_fail.','line_number':1944,'multiline':False]['text':' If typeahead starts with <Plug> then remap, even for a "noremap" mapping.','line_number':1957,'multiline':False]['text':' Check for a mappable key sequence.','line_number':1965,'multiline':False]['text':' Walk through one maphash[] list until we find an entry that matches.','line_number':1966,'multiline':False]['text':'','line_number':1967,'multiline':False]['text':' Don't look for mappings if:','line_number':1968,'multiline':False]['text':' - no_mapping set: mapping disabled (e.g. for CTRL-V)','line_number':1969,'multiline':False]['text':' - maphash_valid not set: no mappings present.','line_number':1970,'multiline':False]['text':' - typebuf.tb_buf[typebuf.tb_off] should not be remapped','line_number':1971,'multiline':False]['text':' - in insert or cmdline mode and 'paste' option set','line_number':1972,'multiline':False]['text':' - waiting for "hit return to continue" and CR or SPACE typed','line_number':1973,'multiline':False]['text':' - waiting for a char with --more--','line_number':1974,'multiline':False]['text':' - in Ctrl-X mode, and we get a valid char for that mode','line_number':1975,'multiline':False]['text':' First try buffer-local mappings.','line_number':1995,'multiline':False]['text':' There are no buffer-local mappings.','line_number':1999,'multiline':False]['text':' Loop until a partly matching mapping is found or all (local)','line_number':2003,'multiline':False]['text':' mappings have been checked.','line_number':2004,'multiline':False]['text':' The longest full match is remembered in "mp_match".','line_number':2005,'multiline':False]['text':' A full match is only accepted if there is no partly match, so "aa"','line_number':2006,'multiline':False]['text':' and "aaa" can both be mapped.','line_number':2007,'multiline':False]['text':' Only consider an entry if the first character matches and it is','line_number':2011,'multiline':False]['text':' for the current state.','line_number':2012,'multiline':False]['text':' Skip ":lmap" mappings if keys were mapped.','line_number':2013,'multiline':False]['text':' find the match length of this mapping','line_number':2018,'multiline':False]['text':' Only apply 'langmap' if merging modifiers into','line_number':2032,'multiline':False]['text':' the key will not result in another character,','line_number':2033,'multiline':False]['text':' so that 'langmap' behaves consistently in','line_number':2034,'multiline':False]['text':' different terminals and GUIs.','line_number':2035,'multiline':False]['text':' Don't allow mapping the first byte(s) of a multi-byte char.','line_number':2045,'multiline':False]['text':' Happens when mapping <M-a> and then changing 'encoding'.','line_number':2046,'multiline':False]['text':' Beware that 0x80 is escaped.','line_number':2047,'multiline':False]['text':' Check an entry whether it matches.','line_number':2055,'multiline':False]['text':' - Full match: mlen == keylen','line_number':2056,'multiline':False]['text':' - Partly match: mlen == typebuf.tb_len','line_number':2057,'multiline':False]['text':' If only script-local mappings are allowed, check if the','line_number':2062,'multiline':False]['text':' mapping starts with K_SNR.','line_number':2063,'multiline':False]['text':' If one of the typed keys cannot be remapped, skip the entry.','line_number':2072,'multiline':False]['text':' break at a partly match','line_number':2084,'multiline':False]['text':' found a longer match','line_number':2093,'multiline':False]['text':' No match; may have to check for termcode at next character.','line_number':2098,'multiline':False]['text':' If no partly match found, use the longest full match.','line_number':2106,'multiline':False]['text':' When no matching mapping found or found a non-matching mapping that','line_number':2114,'multiline':False]['text':' matches at least what the matching mapping matched:','line_number':2115,'multiline':False]['text':' Try to include the modifier into the key when mapping is allowed.','line_number':2116,'multiline':False]['text':' Incomplete modifier sequence: cannot decide whether to simplify yet.','line_number':2121,'multiline':False]['text':' Try to include the modifier into the key.','line_number':2124,'multiline':False]['text':' ins_typebuf() failed','line_number':2127,'multiline':False]['text':' no simplification has been done','line_number':2134,'multiline':False]['text':' If there was no mapping at all use the character from the','line_number':2135,'multiline':False]['text':' typeahead buffer right here.','line_number':2136,'multiline':False]['text':' get character from typeahead','line_number':2139,'multiline':False]['text':' keys have been simplified','line_number':2143,'multiline':False]['text':' try mapping again','line_number':2145,'multiline':False]['text':' Incomplete key sequence: get some more characters.','line_number':2149,'multiline':False]['text':' When a matching mapping was found use that one.','line_number':2153,'multiline':False]['text':' complete match','line_number':2158,'multiline':False]['text':' Write chars to script file(s).','line_number':2163,'multiline':False]['text':' Note: :lmap mappings are written *after* being applied. #5658','line_number':2164,'multiline':False]['text':' remove the mapped keys','line_number':2171,'multiline':False]['text':' Put the replacement string in front of mapstr.','line_number':2173,'multiline':False]['text':' The depth check catches ":map x y" and ":map y x".','line_number':2174,'multiline':False]['text':' for next one','line_number':2183,'multiline':False]['text':' In Select mode and a Visual mode mapping is used: Switch to Visual','line_number':2188,'multiline':False]['text':' mode temporarily.  Append K_SELECT to switch back to Select mode.','line_number':2189,'multiline':False]['text':' Copy the values from *mp that are used, because evaluating the','line_number':2195,'multiline':False]['text':' expression may invoke a function that redefines the mapping, thereby','line_number':2196,'multiline':False]['text':' making *mp invalid.','line_number':2197,'multiline':False]['text':' only saved when needed','line_number':2201,'multiline':False]['text':' only saved when needed','line_number':2202,'multiline':False]['text':' Handle ":map <expr>": evaluate the {rhs} as an','line_number':2205,'multiline':False]['text':' expression.  Also save and restore the command line','line_number':2206,'multiline':False]['text':' for "normal :".','line_number':2207,'multiline':False]['text':' If an error was displayed and the expression returns an empty','line_number':2223,'multiline':False]['text':' string, generate a <Nop> to allow for a redraw.','line_number':2224,'multiline':False]['text':' redraw the command below the error','line_number':2234,'multiline':False]['text':' otherwise, just put back the cursor','line_number':2242,'multiline':False]['text':' Insert the 'to' part in the typebuf.tb_buf.','line_number':2253,'multiline':False]['text':' If 'from' field is the same as the start of the 'to' field, don't','line_number':2254,'multiline':False]['text':' remap the first character (but do allow abbreviations).','line_number':2255,'multiline':False]['text':' If m_noremap is set, don't remap the whole 'to' part.','line_number':2256,'multiline':False]['text':' If this is a LANGMAP mapping, then we didn't record the keys','line_number':2262,'multiline':False]['text':' at the start of the function and have to record them now.','line_number':2263,'multiline':False]['text':'/ unget one character (can only be done once!)','line_number':2294,'multiline':False]['text':'/ If the character was stuffed, vgetc() will get it next time it is called.','line_number':2295,'multiline':False]['text':'/ Otherwise vgetc() will only get it when the stuff buffer is empty.','line_number':2296,'multiline':False]['text':'/ When peeking and not getting a character, reg_executing cannot be cleared','line_number':2307,'multiline':False]['text':'/ yet, so set a flag to clear it later.','line_number':2308,'multiline':False]['text':'/ Gets a byte:','line_number':2321,'multiline':False]['text':'/ 1. from the stuffbuffer','line_number':2322,'multiline':False]['text':'/    This is used for abbreviated commands like "D" -> "d$".','line_number':2323,'multiline':False]['text':'/    Also used to redo a command for ".".','line_number':2324,'multiline':False]['text':'/ 2. from the typeahead buffer','line_number':2325,'multiline':False]['text':'/    Stores text obtained previously but not used yet.','line_number':2326,'multiline':False]['text':'/    Also stores the result of mappings.','line_number':2327,'multiline':False]['text':'/    Also used for the ":normal" command.','line_number':2328,'multiline':False]['text':'/ 3. from the user','line_number':2329,'multiline':False]['text':'/    This may do a blocking wait if "advance" is true.','line_number':2330,'multiline':False]['text':'/','line_number':2331,'multiline':False]['text':'/ if "advance" is true (vgetc()):','line_number':2332,'multiline':False]['text':'/    Really get the character.','line_number':2333,'multiline':False]['text':'/    KeyTyped is set to true in the case the user typed the key.','line_number':2334,'multiline':False]['text':'/    KeyStuffed is true if the character comes from the stuff buffer.','line_number':2335,'multiline':False]['text':'/ if "advance" is false (vpeekc()):','line_number':2336,'multiline':False]['text':'/    Just look whether there is a character available.','line_number':2337,'multiline':False]['text':'/    Return NUL if not.','line_number':2338,'multiline':False]['text':'/','line_number':2339,'multiline':False]['text':'/ When `no_mapping` (global) is zero, checks for mappings in the current mode.','line_number':2340,'multiline':False]['text':'/ Only returns one byte (of a multi-byte character).','line_number':2341,'multiline':False]['text':'/ K_SPECIAL may be escaped, need to get two more bytes then.','line_number':2342,'multiline':False]['text':' waited for more than 'timeoutlen'','line_number':2346,'multiline':False]['text':' for mapping to complete or','line_number':2347,'multiline':False]['text':' 'ttimeoutlen' for complete key code','line_number':2348,'multiline':False]['text':' check for recursive mapping','line_number':2349,'multiline':False]['text':' set when mode has been deleted','line_number':2350,'multiline':False]['text':' This function doesn't work very well when called recursively.  This may','line_number':2352,'multiline':False]['text':' happen though, because of:','line_number':2353,'multiline':False]['text':' 1. The call to add_to_showcmd().   char_avail() is then used to check if','line_number':2354,'multiline':False]['text':' there is a character available, which calls this function.  In that','line_number':2355,'multiline':False]['text':' case we must return NUL, to indicate no character is available.','line_number':2356,'multiline':False]['text':' 2. A GUI callback function writes to the screen, causing a','line_number':2357,'multiline':False]['text':' wait_return().','line_number':2358,'multiline':False]['text':' Using ":normal" can also do this, but it saves the typeahead buffer,','line_number':2359,'multiline':False]['text':' thus it should be OK.  But don't get a key from the user then.','line_number':2360,'multiline':False]['text':' get a character: 1. from the stuffbuffer','line_number':2376,'multiline':False]['text':' KeyTyped = false;  When the command that stuffed something','line_number':2387,'multiline':False]['text':' was typed, behave like the stuffed command was typed.','line_number':2388,'multiline':False]['text':' needed for CTRL-W CTRL-] to open a fold, for example.','line_number':2389,'multiline':False]['text':' no abbreviations now','line_number':2393,'multiline':False]['text':' Loop until we either find a matching mapped key, or we','line_number':2396,'multiline':False]['text':' are sure that it is not a mapped key.','line_number':2397,'multiline':False]['text':' If a mapped key sequence is found we go back to the start to','line_number':2398,'multiline':False]['text':' try re-mapping.','line_number':2399,'multiline':False]['text':' os_breakcheck() is slow, don't use it too often when','line_number':2402,'multiline':False]['text':' inside a mapping.  But call it each time for typed','line_number':2403,'multiline':False]['text':' characters.','line_number':2404,'multiline':False]['text':' os_breakcheck() can call input_enqueue()','line_number':2408,'multiline':False]['text':' check for CTRL-C','line_number':2412,'multiline':False]['text':' flush all input','line_number':2417,'multiline':False]['text':' If inchar() returns true (script file was active) or we','line_number':2420,'multiline':False]['text':' are inside a mapping, get out of Insert mode.','line_number':2421,'multiline':False]['text':' Otherwise we behave like having gotten a CTRL-C.','line_number':2422,'multiline':False]['text':' As a result typing CTRL-C in insert mode will','line_number':2423,'multiline':False]['text':' really insert a CTRL-C.','line_number':2424,'multiline':False]['text':' flush all typeahead','line_number':2431,'multiline':False]['text':' Also record this character, it might be needed to','line_number':2434,'multiline':False]['text':' get out of Insert mode.','line_number':2435,'multiline':False]['text':' Check for a mapping in "typebuf".','line_number':2443,'multiline':False]['text':' try mapping again','line_number':2447,'multiline':False]['text':' failed, use the outer loop','line_number':2452,'multiline':False]['text':' get a character: 2. from the typeahead buffer','line_number':2458,'multiline':False]['text':' remove chars from tb_buf','line_number':2460,'multiline':False]['text':' write char to script file(s)','line_number':2466,'multiline':False]['text':' got character, break the for loop','line_number':2472,'multiline':False]['text':' not enough characters, get more','line_number':2475,'multiline':False]['text':' get a character: 3. from the user - handle <Esc> in Insert mode','line_number':2478,'multiline':False]['text':' special case: if we get an <ESC> in insert mode and there','line_number':2480,'multiline':False]['text':' are no more characters at once, we pretend to go out of','line_number':2481,'multiline':False]['text':' insert mode.  This prevents the one second delay after','line_number':2482,'multiline':False]['text':' typing an <ESC>.  If we get something after all, we may','line_number':2483,'multiline':False]['text':' have to redisplay the mode. That the cursor is in the wrong','line_number':2484,'multiline':False]['text':' place does not matter.','line_number':2485,'multiline':False]['text':' move cursor left, if possible','line_number':2506,'multiline':False]['text':' After auto-indenting and no text is following,','line_number':2511,'multiline':False]['text':' we are expecting to truncate the trailing','line_number':2512,'multiline':False]['text':' white-space, so find the last non-white','line_number':2513,'multiline':False]['text':' character -- webb','line_number':2514,'multiline':False]['text':' no correction needed','line_number':2534,'multiline':False]['text':' Correct when the cursor is on the right halve','line_number':2545,'multiline':False]['text':' of a double-wide character.','line_number':2546,'multiline':False]['text':' end of input script reached','line_number':2562,'multiline':False]['text':' Allow mapping for just typed characters. When we get here c','line_number':2565,'multiline':False]['text':' is the number of extra bytes and typebuf.tb_len is 1.','line_number':2566,'multiline':False]['text':' buffer full, don't map','line_number':2572,'multiline':False]['text':' No typeahead left and inside ":normal".  Must return','line_number':2581,'multiline':False]['text':' something to avoid getting stuck.  When an incomplete','line_number':2582,'multiline':False]['text':' mapping is present, behave like it timed out.','line_number':2583,'multiline':False]['text':' In Ex-mode \n is compatible with original Vim behaviour.','line_number':2588,'multiline':False]['text':' For the command line only CTRL-C always breaks it.','line_number':2589,'multiline':False]['text':' For the cmdline window: Alternate between ESC and','line_number':2590,'multiline':False]['text':' CTRL-C: ESC for most situations and CTRL-C to close the','line_number':2591,'multiline':False]['text':' cmdline window.','line_number':2592,'multiline':False]['text':' set a flag to indicate this wasn't a normal char','line_number':2600,'multiline':False]['text':' return 0 in normal_check()','line_number':2605,'multiline':False]['text':' no chars to block abbreviations for','line_number':2610,'multiline':False]['text':' get a character: 3. from the user - update display','line_number':2616,'multiline':False]['text':' In insert mode a screen update is skipped when characters','line_number':2618,'multiline':False]['text':' are still available.  But when those available characters','line_number':2619,'multiline':False]['text':' are part of a mapping, and we are going to do a blocking','line_number':2620,'multiline':False]['text':' wait here.  Need to update the screen to display the','line_number':2621,'multiline':False]['text':' changed text so far. Also for when 'lazyredraw' is set and','line_number':2622,'multiline':False]['text':' redrawing was postponed because there was something in the','line_number':2623,'multiline':False]['text':' input buffer (e.g., termresponse).','line_number':2624,'multiline':False]['text':' put cursor back where it belongs','line_number':2628,'multiline':False]['text':' If we have a partial match (and are going to wait for more','line_number':2631,'multiline':False]['text':' input from the user), show the partially matched characters','line_number':2632,'multiline':False]['text':' to the user with showcmd.','line_number':2633,'multiline':False]['text':' this looks nice when typing a dead character map','line_number':2639,'multiline':False]['text':' put cursor back where it belongs','line_number':2643,'multiline':False]['text':' need to use the col and row from above here','line_number':2646,'multiline':False]['text':' This looks nice when typing a dead character map.','line_number':2662,'multiline':False]['text':' There is no actual command line for get_number().','line_number':2663,'multiline':False]['text':' get a character: 3. from the user - get it','line_number':2675,'multiline':False]['text':' timedout may have been set if a mapping with empty RHS','line_number':2677,'multiline':False]['text':' fully matched while longer mappings timed out.','line_number':2678,'multiline':False]['text':' blocking wait','line_number':2686,'multiline':False]['text':' put cursor back where it belongs','line_number':2711,'multiline':False]['text':' end of input script reached','line_number':2716,'multiline':False]['text':' no character available','line_number':2718,'multiline':False]['text':' timed out','line_number':2722,'multiline':False]['text':' allow mapping for just typed characters','line_number':2726,'multiline':False]['text':' while (true)','line_number':2731,'multiline':False]['text':' if (!character from stuffbuf)','line_number':2732,'multiline':False]['text':' if advance is false don't loop on NULs','line_number':2734,'multiline':False]['text':' The "INSERT" message is taken care of here:','line_number':2737,'multiline':False]['text':'     if we return an ESC to exit insert mode, the message is deleted','line_number':2738,'multiline':False]['text':'     if we don't return an ESC but deleted the message before, redisplay it','line_number':2739,'multiline':False]['text':' delete mode later','line_number':2743,'multiline':False]['text':' show mode later','line_number':2749,'multiline':False]['text':' When recording there will be no timeout.  Add a <Nop> after the ESC','line_number':2757,'multiline':False]['text':' to avoid that it forms a key code with following characters.','line_number':2758,'multiline':False]['text':'/ inchar() - get one character from','line_number':2767,'multiline':False]['text':'/      1. a scriptfile','line_number':2768,'multiline':False]['text':'/      2. the keyboard','line_number':2769,'multiline':False]['text':'/','line_number':2770,'multiline':False]['text':'/  As many characters as we can get (up to 'maxlen') are put in "buf" and','line_number':2771,'multiline':False]['text':'/  NUL terminated (buffer length must be 'maxlen' + 1).','line_number':2772,'multiline':False]['text':'/  Minimum for "maxlen" is 3!!!!','line_number':2773,'multiline':False]['text':'/','line_number':2774,'multiline':False]['text':'/  "tb_change_cnt" is the value of typebuf.tb_change_cnt if "buf" points into','line_number':2775,'multiline':False]['text':'/  it.  When typebuf.tb_change_cnt changes (e.g., when a message is received','line_number':2776,'multiline':False]['text':'/  from a remote client) "buf" can no longer be used.  "tb_change_cnt" is 0','line_number':2777,'multiline':False]['text':'/  otherwise.','line_number':2778,'multiline':False]['text':'/','line_number':2779,'multiline':False]['text':'/  If we got an interrupt all input is read until none is available.','line_number':2780,'multiline':False]['text':'/','line_number':2781,'multiline':False]['text':'/  If wait_time == 0  there is no waiting for the char.','line_number':2782,'multiline':False]['text':'/  If wait_time == n  we wait for n msec for a character to arrive.','line_number':2783,'multiline':False]['text':'/  If wait_time == -1 we wait forever for a character to arrive.','line_number':2784,'multiline':False]['text':'/','line_number':2785,'multiline':False]['text':'/  Return the number of obtained characters.','line_number':2786,'multiline':False]['text':'/  Return -1 when end of input script reached.','line_number':2787,'multiline':False]['text':'/','line_number':2788,'multiline':False]['text':'/ @param wait_time  milliseconds','line_number':2789,'multiline':False]['text':' Init for GCC.','line_number':2792,'multiline':False]['text':' Return ESC with gotint.','line_number':2793,'multiline':False]['text':' flush output before waiting','line_number':2797,'multiline':False]['text':' Don't reset these when at the hit-return prompt, otherwise an endless','line_number':2801,'multiline':False]['text':' recursive loop may result (write error in swapfile, hit-return, timeout','line_number':2802,'multiline':False]['text':' on char wait, flush swapfile, write error....).','line_number':2803,'multiline':False]['text':' display out of memory message (again)','line_number':2805,'multiline':False]['text':' display swap file write error again','line_number':2806,'multiline':False]['text':' Get a character from a script file if there is one.','line_number':2809,'multiline':False]['text':' If interrupted: Stop reading script files, close them all.','line_number':2810,'multiline':False]['text':' Reached EOF or some error occurred.','line_number':2816,'multiline':False]['text':' Careful: closescript() frees typebuf.tb_buf[] and buf[] may','line_number':2817,'multiline':False]['text':' point inside typebuf.tb_buf[].  Don't use buf[] after this!','line_number':2818,'multiline':False]['text':' When reading script file is interrupted, return an ESC to get','line_number':2820,'multiline':False]['text':' back to normal mode.','line_number':2821,'multiline':False]['text':' Otherwise return -1, because typebuf.tb_buf[] has changed.','line_number':2822,'multiline':False]['text':' Did not get a character from script.','line_number':2834,'multiline':False]['text':' If we got an interrupt, skip all previously typed characters and','line_number':2835,'multiline':False]['text':' return true if quit reading script file.','line_number':2836,'multiline':False]['text':' Stop reading typeahead when a single CTRL-C was read,','line_number':2837,'multiline':False]['text':' fill_input_buf() returns this when not able to read from stdin.','line_number':2838,'multiline':False]['text':' Don't use buf[] here, closescript() may have freed typebuf.tb_buf[]','line_number':2839,'multiline':False]['text':' and buf may be pointing inside typebuf.tb_buf[].','line_number':2840,'multiline':False]['text':' Always flush the output characters when getting input characters','line_number':2854,'multiline':False]['text':' from the user and not just peeking.','line_number':2855,'multiline':False]['text':' Fill up to a third of the buffer, because each character may be','line_number':2860,'multiline':False]['text':' tripled below.','line_number':2861,'multiline':False]['text':' If the typebuf was changed further down, it is like nothing was added by','line_number':2865,'multiline':False]['text':' this call.','line_number':2866,'multiline':False]['text':' Note the change in the typeahead buffer, this matters for when','line_number':2871,'multiline':False]['text':' vgetorpeek() is called recursively, e.g. using getchar(1) in a timer','line_number':2872,'multiline':False]['text':' function.','line_number':2873,'multiline':False]['text':'/ Fix typed characters for use by vgetc().','line_number':2881,'multiline':False]['text':'/ "buf[]" must have room to triple the number of bytes!','line_number':2882,'multiline':False]['text':'/ Returns the new length.','line_number':2883,'multiline':False]['text':' Should not escape K_SPECIAL reading input from the user because vim','line_number':2888,'multiline':False]['text':' key codes keys are processed in input.c/input_enqueue.','line_number':2889,'multiline':False]['text':' Reading from script, need to process special bytes','line_number':2894,'multiline':False]['text':' Two characters are special: NUL and K_SPECIAL.','line_number':2897,'multiline':False]['text':' Replace       NUL by K_SPECIAL KS_ZERO    KE_FILLER','line_number':2898,'multiline':False]['text':' Replace K_SPECIAL by K_SPECIAL KS_SPECIAL KE_FILLER','line_number':2899,'multiline':False]['text':' add trailing NUL','line_number':2912,'multiline':False]['text':'/ Function passed to do_cmdline() to get the command after a <Cmd> key from','line_number':2916,'multiline':False]['text':'/ typeahead.','line_number':2917,'multiline':False]['text':' no mapping for these characters','line_number':2928,'multiline':False]['text':' incomplete <Cmd> is an error, because there is not much the user','line_number':2936,'multiline':False]['text':' could do in this state.','line_number':2937,'multiline':False]['text':' Get one character at a time.','line_number':2943,'multiline':False]['text':' Get two extra bytes for special keys','line_number':2946,'multiline':False]['text':' end the line','line_number':2960,'multiline':False]['text':' give a nicer error message for this special case','line_number':2964,'multiline':False]['text':'/ Handle a Lua mapping: get its LuaRef from typeahead and execute it.','line_number':2996,'multiline':False]['text':'/','line_number':2997,'multiline':False]['text':'/ @param may_repeat  save the LuaRef for redoing with "." later','line_number':2998,'multiline':False]['text':'/','line_number':2999,'multiline':False]['text':'/ @return  false if getting the LuaRef was aborted, true otherwise','line_number':3000,'multiline':False]['text':' Get one character at a time.','line_number':3014,'multiline':False]['text':' end the line','line_number':3019,'multiline':False]