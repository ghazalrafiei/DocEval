['text':' syntax.c: code for syntax highlighting','line_number':1,'multiline':False]['text':' different types of offsets that are possible','line_number':50,'multiline':False]['text':' match  start offset','line_number':51,'multiline':False]['text':' match  end   offset','line_number':52,'multiline':False]['text':' highl. start offset','line_number':53,'multiline':False]['text':' highl. end   offset','line_number':54,'multiline':False]['text':' region start offset','line_number':55,'multiline':False]['text':' region end   offset','line_number':56,'multiline':False]['text':' leading context offset','line_number':57,'multiline':False]['text':' The patterns that are being searched for are stored in a syn_pattern.','line_number':68,'multiline':False]['text':' A match item consists of one pattern.','line_number':69,'multiline':False]['text':' A start/end item consists of n start patterns and m end patterns.','line_number':70,'multiline':False]['text':' A start/skip/end item consists of n start patterns, one skip pattern and m','line_number':71,'multiline':False]['text':' end patterns.','line_number':72,'multiline':False]['text':' For the latter two, the patterns are always consecutive: start-skip-end.','line_number':73,'multiline':False]['text':'','line_number':74,'multiline':False]['text':' A character offset can be given for the matched text (_m_start and _m_end)','line_number':75,'multiline':False]['text':' and for the actually highlighted text (_h_start and _h_end).','line_number':76,'multiline':False]['text':'','line_number':77,'multiline':False]['text':' Note that ordering of members is optimized to reduce padding.','line_number':78,'multiline':False]['text':' see SPTYPE_ defines below','line_number':80,'multiline':False]['text':' this item used for syncing','line_number':81,'multiline':False]['text':' highlight group ID of pattern','line_number':82,'multiline':False]['text':' see below','line_number':83,'multiline':False]['text':' offsets','line_number':84,'multiline':False]['text':' see HL_ defines below','line_number':85,'multiline':False]['text':' conceal substitute character','line_number':86,'multiline':False]['text':' ignore-case flag for sp_prog','line_number':87,'multiline':False]['text':' sync item index (syncing only)','line_number':88,'multiline':False]['text':' ID of last line where tried','line_number':89,'multiline':False]['text':' next match in sp_line_id line','line_number':90,'multiline':False]['text':' cont. group IDs, if non-zero','line_number':91,'multiline':False]['text':' next group IDs, if non-zero','line_number':92,'multiline':False]['text':' struct passed to in_id_list()','line_number':93,'multiline':False]['text':' regexp to match, pattern','line_number':94,'multiline':False]['text':' regexp to match, program','line_number':95,'multiline':False]['text':' syntax cluster name','line_number':100,'multiline':False]['text':' uppercase of scl_name','line_number':101,'multiline':False]['text':' IDs in this syntax cluster','line_number':102,'multiline':False]['text':' For the current state we need to remember more than just the idx.','line_number':105,'multiline':False]['text':' When si_m_endpos.lnum is 0, the items other than si_idx are unknown.','line_number':106,'multiline':False]['text':' (The end positions have the column number of the next char)','line_number':107,'multiline':False]['text':' index of syntax pattern or','line_number':109,'multiline':False]['text':' KEYWORD_IDX','line_number':110,'multiline':False]['text':' highlight group ID for keywords','line_number':111,'multiline':False]['text':' idem, transparency removed','line_number':112,'multiline':False]['text':' lnum of the match','line_number':113,'multiline':False]['text':' starting column of the match','line_number':114,'multiline':False]['text':' just after end posn of the match','line_number':115,'multiline':False]['text':' start position of the highlighting','line_number':116,'multiline':False]['text':' end position of the highlighting','line_number':117,'multiline':False]['text':' end position of end pattern','line_number':118,'multiline':False]['text':' group ID for end pattern or zero','line_number':119,'multiline':False]['text':' if match ends before si_m_endpos','line_number':120,'multiline':False]['text':' attributes in this state','line_number':121,'multiline':False]['text':' HL_HAS_EOL flag in this state, and','line_number':122,'multiline':False]['text':' HL_SKIP* for si_next_list','line_number':123,'multiline':False]['text':' sequence number','line_number':124,'multiline':False]['text':' substitution character for conceal','line_number':125,'multiline':False]['text':' list of contained groups','line_number':126,'multiline':False]['text':' nextgroup IDs after this item ends','line_number':127,'multiline':False]['text':' \z(...\) matches from start','line_number':128,'multiline':False]['text':' pattern','line_number':129,'multiline':False]['text':' Struct to reduce the number of arguments to get_syn_options(), it's used','line_number':132,'multiline':False]['text':' very often.','line_number':133,'multiline':False]['text':' flags for contained and transparent','line_number':135,'multiline':False]['text':' true for ":syn keyword"','line_number':136,'multiline':False]['text':' syntax item for "grouphere" argument, NULL','line_number':137,'multiline':False]['text':' if not allowed','line_number':138,'multiline':False]['text':' true if "cont_list" can be used','line_number':139,'multiline':False]['text':' group IDs for "contains" argument','line_number':140,'multiline':False]['text':' group IDs for "containedin" argument','line_number':141,'multiline':False]['text':' group IDs for "nextgroup" argument','line_number':142,'multiline':False]['text':' The sp_off_flags are computed like this:','line_number':167,'multiline':False]['text':' offset from the start of the matched text: (1 << SPO_XX_OFF)','line_number':168,'multiline':False]['text':' offset from the end   of the matched text: (1 << (SPO_XX_OFF + SPO_COUNT))','line_number':169,'multiline':False]['text':' When both are present, only one is used.','line_number':170,'multiline':False]['text':' match keyword with this group ID','line_number':172,'multiline':False]['text':' match a regexp, start of item','line_number':173,'multiline':False]['text':' match a regexp, end of item','line_number':174,'multiline':False]['text':' match a regexp, skip within item','line_number':175,'multiline':False]['text':' value of sp_sync_idx for "NONE"','line_number':179,'multiline':False]['text':' Flags for b_syn_sync_flags:','line_number':181,'multiline':False]['text':' sync on a C-style comment','line_number':182,'multiline':False]['text':' sync by matching a pattern','line_number':183,'multiline':False]['text':' maximum length of a keyword','line_number':187,'multiline':False]['text':' The attributes of the syntax item that has been recognized.','line_number':189,'multiline':False]['text':' attr of current syntax word','line_number':190,'multiline':False]['text':' ID of current char for syn_get_id()','line_number':191,'multiline':False]['text':' idem, transparency removed','line_number':192,'multiline':False]['text':' Methods of combining two clusters','line_number':197,'multiline':False]['text':' replace first list with second','line_number':198,'multiline':False]['text':' add second list to first','line_number':199,'multiline':False]['text':' subtract second list from first','line_number':200,'multiline':False]['text':' Syntax group IDs have different types:','line_number':204,'multiline':False]['text':'     0 - 19999  normal syntax groups','line_number':205,'multiline':False]['text':' 20000 - 20999  ALLBUT indicator (current_syn_inc_tag added)','line_number':206,'multiline':False]['text':' 21000 - 21999  TOP indicator (current_syn_inc_tag added)','line_number':207,'multiline':False]['text':' 22000 - 22999  CONTAINED indicator (current_syn_inc_tag added)','line_number':208,'multiline':False]['text':' 23000 - 32767  cluster IDs (subtract SYNID_CLUSTER for the cluster ID)','line_number':209,'multiline':False]['text':' syntax group ID for contains=ALLBUT','line_number':210,'multiline':False]['text':' syntax group ID for contains=TOP','line_number':211,'multiline':False]['text':' syntax group ID for contains=CONTAINED','line_number':212,'multiline':False]['text':' first syntax group ID for clusters','line_number':213,'multiline':False]['text':' maximum before the above overflow','line_number':215,'multiline':False]['text':' Annoying Hack(TM):  ":syn include" needs this pointer to pass to','line_number':218,'multiline':False]['text':' expand_filename().  Most of the other syntax commands don't need it, so','line_number':219,'multiline':False]['text':' instead of passing it to them, we stow it here.','line_number':220,'multiline':False]['text':' Another Annoying Hack(TM):  To prevent rules from other ":syn include"'d','line_number':223,'multiline':False]['text':' files from leaking into ALLBUT lists, we assign a unique ID to the','line_number':224,'multiline':False]['text':' rules in each ":syn include"'d file.','line_number':225,'multiline':False]['text':' In a hashtable item "hi_key" points to "keyword" in a keyentry.','line_number':229,'multiline':False]['text':' This avoids adding a pointer to the hashtable item.','line_number':230,'multiline':False]['text':' KE2HIKEY() converts a var pointer to a hashitem key pointer.','line_number':231,'multiline':False]['text':' HIKEY2KE() converts a hashitem key pointer to a var pointer.','line_number':232,'multiline':False]['text':' HI2KE() converts a hashitem pointer to a var pointer.','line_number':233,'multiline':False]['text':' To reduce the time spent in keepend(), remember at which level in the state','line_number':239,'multiline':False]['text':' stack the first item with "keepend" is present.  When "-1", there is no','line_number':240,'multiline':False]['text':' "keepend" on the stack.','line_number':241,'multiline':False]['text':' value of si_idx for keywords','line_number':246,'multiline':False]['text':' valid of si_cont_list for containing all but contained groups','line_number':248,'multiline':False]['text':' value to use for si_seqnr','line_number':251,'multiline':False]['text':' The next possible match in the current line for any pattern is remembered,','line_number':253,'multiline':False]['text':' to avoid having to try for a match in each column.','line_number':254,'multiline':False]['text':' If next_match_idx == -1, not tried (in this line) yet.','line_number':255,'multiline':False]['text':' If next_match_col == MAXCOL, no match found in this line.','line_number':256,'multiline':False]['text':' (All end positions have the column of the char after the end)','line_number':257,'multiline':False]['text':' column for start of next match','line_number':258,'multiline':False]['text':' position for end of next match','line_number':259,'multiline':False]['text':' pos. for highl. start of next match','line_number':260,'multiline':False]['text':' pos. for highl. end of next match','line_number':261,'multiline':False]['text':' index of matched item','line_number':262,'multiline':False]['text':' flags for next match','line_number':263,'multiline':False]['text':' end of start pattn (start region)','line_number':264,'multiline':False]['text':' pos. for end of end pattern','line_number':265,'multiline':False]['text':' ID of group for end pattn or zero','line_number':266,'multiline':False]['text':' A state stack is an array of integers or stateitem_T, stored in a','line_number':269,'multiline':False]['text':' garray_T.  A state stack is invalid if its itemsize entry is zero.','line_number':270,'multiline':False]['text':' The current state (within the line) of the recognition engine.','line_number':274,'multiline':False]['text':' When current_state.ga_itemsize is 0 the current state is invalid.','line_number':275,'multiline':False]['text':' current window for highlighting','line_number':276,'multiline':False]['text':' current buffer for highlighting','line_number':277,'multiline':False]['text':' current buffer for highlighting','line_number':278,'multiline':False]['text':' timeout limit','line_number':279,'multiline':False]['text':' lnum of current state','line_number':280,'multiline':False]['text':' column of current state','line_number':281,'multiline':False]['text':' true if stored current state','line_number':282,'multiline':False]['text':' after setting current_finished','line_number':283,'multiline':False]['text':' current line has been finished','line_number':284,'multiline':False]['text':' current stack of state_items','line_number':285,'multiline':False]['text':' when non-zero, nextgroup list','line_number':287,'multiline':False]['text':' flags for current_next_list','line_number':288,'multiline':False]['text':' unique number for current line','line_number':289,'multiline':False]['text':' Set the timeout used for syntax highlighting.','line_number':296,'multiline':False]['text':' Use NULL to reset, no timeout.','line_number':297,'multiline':False]['text':' Start the syntax recognition for a line.  This function is normally called','line_number':303,'multiline':False]['text':' from the screen updating, once for each displayed line.','line_number':304,'multiline':False]['text':' The buffer is remembered in syn_buf, because get_syntax_attr() doesn't get','line_number':305,'multiline':False]['text':' it.  Careful: curbuf and curwin are likely to point to another buffer and','line_number':306,'multiline':False]['text':' window.','line_number':307,'multiline':False]['text':' remember the last change ID','line_number':316,'multiline':False]['text':' After switching buffers, invalidate current_state.','line_number':320,'multiline':False]['text':' Also do this when a change was made, the current state may be invalid','line_number':321,'multiline':False]['text':' then.','line_number':322,'multiline':False]['text':' Allocate syntax stack when needed.','line_number':333,'multiline':False]['text':' out of memory','line_number':336,'multiline':False]['text':' If the state of the end of the previous line is useful, store it.','line_number':340,'multiline':False]['text':' If the current_lnum is now the same as "lnum", keep the current','line_number':350,'multiline':False]['text':' state (this happens very often!).  Otherwise invalidate','line_number':351,'multiline':False]['text':' current_state and figure it out below.','line_number':352,'multiline':False]['text':' Try to synchronize from a saved state in b_sst_array[].','line_number':360,'multiline':False]['text':' Only do this if lnum is not before and not to far beyond a saved state.','line_number':361,'multiline':False]['text':' Find last valid saved state before start_lnum.','line_number':363,'multiline':False]['text':' If "lnum" is before or far beyond a line with a saved state, need to','line_number':380,'multiline':False]['text':' re-synchronize.','line_number':381,'multiline':False]['text':' First line is always valid, no matter "minlines".','line_number':385,'multiline':False]['text':' Need to parse "minlines" lines before state can be considered','line_number':388,'multiline':False]['text':' valid to store.','line_number':389,'multiline':False]['text':' Advance from the sync point or saved state until the current line.','line_number':396,'multiline':False]['text':' Save some entries for syncing with later on.','line_number':397,'multiline':False]['text':' If we parsed at least "minlines" lines or started at a valid','line_number':408,'multiline':False]['text':' state, the current state is considered valid.','line_number':409,'multiline':False]['text':' Check if the saved state entry is for the current line and is','line_number':411,'multiline':False]['text':' equal to the current state.  If so, then validate all saved','line_number':412,'multiline':False]['text':' states that depended on a change before the parsed line.','line_number':413,'multiline':False]['text':' valid state before desired line, use this one','line_number':432,'multiline':False]['text':' past saved states depending on change, break here.','line_number':435,'multiline':False]['text':' Store the state at this line when it's the first one, the line','line_number':443,'multiline':False]['text':' where we start parsing, or some distance from the previously','line_number':444,'multiline':False]['text':' saved state.  But only when parsed at least 'minlines'.','line_number':445,'multiline':False]['text':' This can take a long time: break when CTRL-C pressed.  The current','line_number':452,'multiline':False]['text':' state will be wrong then.','line_number':453,'multiline':False]['text':' We cannot simply discard growarrays full of state_items or buf_states; we','line_number':464,'multiline':False]['text':' have to manually release their extmatch pointers first.','line_number':465,'multiline':False]['text':' Cleanup the current_state stack.','line_number':478,'multiline':False]['text':' Try to find a synchronisation point for line "lnum".','line_number':485,'multiline':False]['text':'','line_number':486,'multiline':False]['text':' This sets current_lnum and the current state.  One of three methods is','line_number':487,'multiline':False]['text':' used:','line_number':488,'multiline':False]['text':' 1. Search backwards for the end of a C-comment.','line_number':489,'multiline':False]['text':' 2. Search backwards for given sync patterns.','line_number':490,'multiline':False]['text':' 3. Simply start on a given number of lines above "lnum".','line_number':491,'multiline':False]['text':' Clear any current state that might be hanging around.','line_number':512,'multiline':False]['text':' Start at least "minlines" back.  Default starting point for parsing is','line_number':515,'multiline':False]['text':' there.','line_number':516,'multiline':False]['text':' Start further back, to avoid that scrolling backwards will result in','line_number':517,'multiline':False]['text':' resyncing for every line.  Now it resyncs only one out of N lines,','line_number':518,'multiline':False]['text':' where N is minlines * 1.5, or minlines * 2 if minlines is small.','line_number':519,'multiline':False]['text':' Watch out for overflow when minlines is MAXLNUM.','line_number':520,'multiline':False]['text':' 1. Search backwards for the end of a C-style comment.','line_number':543,'multiline':False]['text':' Need to make syn_buf the current buffer for a moment, to be able to','line_number':545,'multiline':False]['text':' use find_start_comment().','line_number':546,'multiline':False]['text':' Skip lines that end in a backslash.','line_number':552,'multiline':False]['text':' set cursor to start of search','line_number':561,'multiline':False]['text':' If the line is inside a comment, need to find the syntax item that','line_number':566,'multiline':False]['text':' defines the comment.','line_number':567,'multiline':False]['text':' Restrict the search for the end of a comment to b_syn_sync_maxlines.','line_number':568,'multiline':False]['text':' restore cursor and buffer','line_number':582,'multiline':False]['text':' 2. Search backwards for given sync patterns.','line_number':587,'multiline':False]['text':' This can take a long time: break when CTRL-C pressed.','line_number':600,'multiline':False]['text':' Check if we have run into a valid saved state stack now.','line_number':608,'multiline':False]['text':' Check if the previous line has the line-continuation pattern.','line_number':614,'multiline':False]['text':' Start with nothing on the state stack','line_number':619,'multiline':False]['text':' When a sync point has been found, remember where, and','line_number':626,'multiline':False]['text':' continue to look for another one, further on in the line.','line_number':627,'multiline':False]['text':' ignore match that goes to after where started','line_number':631,'multiline':False]['text':' Cannot happen?','line_number':636,'multiline':False]['text':' Continue after the match (be aware of a zero-length','line_number':647,'multiline':False]['text':' match).','line_number':648,'multiline':False]['text':' syn_current_attr() will have skipped the check for','line_number':661,'multiline':False]['text':' an item that ends here, need to do that now.  Be','line_number':662,'multiline':False]['text':' careful not to go past the NUL.','line_number':663,'multiline':False]['text':' If a sync point was encountered, break here.','line_number':676,'multiline':False]['text':' Put the item that was specified by the sync point on the','line_number':678,'multiline':False]['text':' state stack.  If there was no item specified, make the','line_number':679,'multiline':False]['text':' state stack empty.','line_number':680,'multiline':False]['text':' When using "grouphere", continue from the sync point','line_number':687,'multiline':False]['text':' match, until the end of the line.  Parsing starts at','line_number':688,'multiline':False]['text':' the next line.','line_number':689,'multiline':False]['text':' For "groupthere" the parsing starts at start_lnum.','line_number':690,'multiline':False]['text':' Ran into start of the file or exceeded maximum number of lines','line_number':714,'multiline':False]['text':'/ Return true if the line-continuation pattern matches in line "lnum".','line_number':741,'multiline':False]['text':' chartab array for syn iskeyword','line_number':749,'multiline':False]['text':' Prepare the current state for the start of a line.','line_number':763,'multiline':False]['text':' Need to update the end of a start/skip/end that continues from the','line_number':769,'multiline':False]['text':' previous line and regions that have "keepend".','line_number':770,'multiline':False]['text':'/ Check for items in the stack that need their end updated.','line_number':781,'multiline':False]['text':'/','line_number':782,'multiline':False]['text':'/ @param startofline  if true the last item is always updated.','line_number':783,'multiline':False]['text':'/                     if false the item with "keepend" is forcefully updated.','line_number':784,'multiline':False]['text':' Check for a match carried over from a previous line with a','line_number':790,'multiline':False]['text':' contained region.  The match ends as soon as the region ends.','line_number':791,'multiline':False]['text':' Need to update the end of a start/skip/end that continues from the','line_number':807,'multiline':False]['text':' previous line.  And regions that have "keepend", because they may','line_number':808,'multiline':False]['text':' influence contained items.  If we've just removed "extend"','line_number':809,'multiline':False]['text':' (startofline == 0) then we should update ends of normal regions','line_number':810,'multiline':False]['text':' contained inside "keepend" because "extend" could have extended','line_number':811,'multiline':False]['text':' these "keepend" regions as well as contained normal regions.','line_number':812,'multiline':False]['text':' Then check for items ending in column 0.','line_number':813,'multiline':False]['text':' start highl. in col 0','line_number':829,'multiline':False]['text':'///////////////////////////////////////','line_number':844,'multiline':False]['text':' Handling of the state stack cache.','line_number':845,'multiline':False]['text':' EXPLANATION OF THE SYNTAX STATE STACK CACHE','line_number':847,'multiline':False]['text':'','line_number':848,'multiline':False]['text':' To speed up syntax highlighting, the state stack for the start of some','line_number':849,'multiline':False]['text':' lines is cached.  These entries can be used to start parsing at that point.','line_number':850,'multiline':False]['text':'','line_number':851,'multiline':False]['text':' The stack is kept in b_sst_array[] for each buffer.  There is a list of','line_number':852,'multiline':False]['text':' valid entries.  b_sst_first points to the first one, then follow sst_next.','line_number':853,'multiline':False]['text':' The entries are sorted on line number.  The first entry is often for line 2','line_number':854,'multiline':False]['text':' (line 1 always starts with an empty stack).','line_number':855,'multiline':False]['text':' There is also a list for free entries.  This construction is used to avoid','line_number':856,'multiline':False]['text':' having to allocate and free memory blocks too often.','line_number':857,'multiline':False]['text':'','line_number':858,'multiline':False]['text':' When making changes to the buffer, this is logged in b_mod_*.  When calling','line_number':859,'multiline':False]['text':' update_screen() to update the display, it will call','line_number':860,'multiline':False]['text':' syn_stack_apply_changes() for each displayed buffer to adjust the cached','line_number':861,'multiline':False]['text':' entries.  The entries which are inside the changed area are removed,','line_number':862,'multiline':False]['text':' because they must be recomputed.  Entries below the changed have their line','line_number':863,'multiline':False]['text':' number adjusted for deleted/inserted lines, and have their sst_change_lnum','line_number':864,'multiline':False]['text':' set to indicate that a check must be made if the changed lines would change','line_number':865,'multiline':False]['text':' the cached entry.','line_number':866,'multiline':False]['text':'','line_number':867,'multiline':False]['text':' When later displaying lines, an entry is stored for each line.  Displayed','line_number':868,'multiline':False]['text':' lines are likely to be displayed again, in which case the state at the','line_number':869,'multiline':False]['text':' start of the line is needed.','line_number':870,'multiline':False]['text':' For not displayed lines, an entry is stored for every so many lines.  These','line_number':871,'multiline':False]['text':' entries will be used e.g., when scrolling backwards.  The distance between','line_number':872,'multiline':False]['text':' entries depends on the number of lines in the buffer.  For small buffers','line_number':873,'multiline':False]['text':' the distance is fixed at SST_DIST, for large buffers there is a fixed','line_number':874,'multiline':False]['text':' number of entries SST_MAX_ENTRIES, and the distance is computed.','line_number':875,'multiline':False]['text':' Free b_sst_array[] for buffer "buf".','line_number':890,'multiline':False]['text':' Used when syntax items changed to force resyncing everywhere.','line_number':891,'multiline':False]['text':' When using "syntax" fold method, must update all folds.','line_number':896,'multiline':False]['text':' Allocate the syntax state stack for syn_buf when needed.','line_number':904,'multiline':False]['text':' If the number of entries in b_sst_array[] is much too big or a bit too','line_number':905,'multiline':False]['text':' small, reallocate it.','line_number':906,'multiline':False]['text':' Also used to allocate b_sst_array[] for the first time.','line_number':907,'multiline':False]['text':' Allocate 50% too much, to avoid reallocating too often.','line_number':917,'multiline':False]['text':' When shrinking the array, cleanup the existing stack.','line_number':927,'multiline':False]['text':' Make sure that all valid entries fit in the new array.','line_number':928,'multiline':False]['text':' Move the states from the old array to the new one.','line_number':941,'multiline':False]['text':' Create the list of free entries.','line_number':958,'multiline':False]['text':' Check for changes in a buffer to affect stored syntax states.  Uses the','line_number':971,'multiline':False]['text':' b_mod_* fields.','line_number':972,'multiline':False]['text':' Called from update_screen(), before screen is being updated, once for each','line_number':973,'multiline':False]['text':' displayed buffer.','line_number':974,'multiline':False]['text':' this state is inside the changed area, remove it','line_number':993,'multiline':False]['text':' This state is below the changed area.  Remember the line','line_number':1004,'multiline':False]['text':' that needs to be parsed before this entry can be made valid','line_number':1005,'multiline':False]['text':' again.','line_number':1006,'multiline':False]['text':'/ Reduce the number of entries in the state stack for syn_buf.','line_number':1026,'multiline':False]['text':'/','line_number':1027,'multiline':False]['text':'/ @return  true if at least one entry was freed.','line_number':1028,'multiline':False]['text':' Compute normal distance between non-displayed entries.','line_number':1040,'multiline':False]['text':' Go through the list to find the "tick" for the oldest entry that can','line_number':1047,'multiline':False]['text':' be removed.  Set "above" when the "tick" for the oldest entry is above','line_number':1048,'multiline':False]['text':' "b_sst_lasttick" (the display tick wraps around).','line_number':1049,'multiline':False]['text':' Go through the list to make the entries for the oldest tick at an','line_number':1066,'multiline':False]['text':' interval of several lines.','line_number':1067,'multiline':False]['text':' Move this entry from used list to free list','line_number':1071,'multiline':False]['text':' Free the allocated memory for a syn_state item.','line_number':1081,'multiline':False]['text':' Move the entry into the free list.','line_number':1082,'multiline':False]['text':' Find an entry in the list of state stacks at or before "lnum".','line_number':1091,'multiline':False]['text':' Returns NULL when there is no entry or the first entry is after "lnum".','line_number':1092,'multiline':False]['text':' Try saving the current state in b_sst_array[].','line_number':1107,'multiline':False]['text':' The current state must be valid for the start of the current_lnum line!','line_number':1108,'multiline':False]['text':' If the current state contains a start or end pattern that continues','line_number':1117,'multiline':False]['text':' from the previous line, we can't use it.  Don't store it then.','line_number':1118,'multiline':False]['text':' find "sp" in the list and remove it','line_number':1131,'multiline':False]['text':' it's the first entry','line_number':1133,'multiline':False]['text':' find the entry just before this one to adjust sst_next','line_number':1136,'multiline':False]['text':' just in case','line_number':1142,'multiline':False]['text':' Add a new entry','line_number':1150,'multiline':False]['text':' If no free items, cleanup the array first.','line_number':1151,'multiline':False]['text':' "sp" may have been moved to the freelist now','line_number':1154,'multiline':False]['text':' Still no free items?  Must be a strange problem...','line_number':1157,'multiline':False]['text':' Take the first item from the free list and put it in the used','line_number':1161,'multiline':False]['text':' list, after *sp','line_number':1162,'multiline':False]['text':' Insert in front of the list','line_number':1167,'multiline':False]['text':' insert in list after *sp','line_number':1171,'multiline':False]['text':' When overwriting an existing state stack, clear it first','line_number':1181,'multiline':False]['text':' Need to clear it, might be something remaining from when the','line_number':1185,'multiline':False]['text':' length was less than SST_FIX_STATES.','line_number':1186,'multiline':False]['text':' Copy a state stack from "from" in b_sst_array[] to current_state;','line_number':1210,'multiline':False]['text':'/ Compare saved state stack "*sp" with the current state.','line_number':1251,'multiline':False]['text':'/','line_number':1252,'multiline':False]['text':'/ @return  true when they are equal.','line_number':1253,'multiline':False]['text':' First a quick check if the stacks have the same size end nextlist.','line_number':1258,'multiline':False]['text':' Need to compare all states on both stacks.','line_number':1264,'multiline':False]['text':' If the item has another index the state is different.','line_number':1273,'multiline':False]['text':' When the extmatch pointers are different, the strings in them can','line_number':1280,'multiline':False]['text':' still be the same.  Check if the extmatch references are equal.','line_number':1281,'multiline':False]['text':' If one of the extmatch pointers is NULL the states are different.','line_number':1284,'multiline':False]['text':' Check each referenced match string. They must all be equal.','line_number':1290,'multiline':False]['text':' If the pointer is different it can still be the same text.','line_number':1292,'multiline':False]['text':' Compare the strings, ignore case when the start item has the','line_number':1293,'multiline':False]['text':' sp_ic flag set.','line_number':1294,'multiline':False]['text':' We stop parsing syntax above line "lnum".  If the stored state at or below','line_number':1312,'multiline':False]['text':' this line depended on a change before it, it now depends on the line below','line_number':1313,'multiline':False]['text':' the last parsed line.','line_number':1314,'multiline':False]['text':' The window looks like this:','line_number':1315,'multiline':False]['text':'          line which changed','line_number':1316,'multiline':False]['text':'          displayed line','line_number':1317,'multiline':False]['text':'          displayed line','line_number':1318,'multiline':False]['text':' lnum ->  line below window','line_number':1319,'multiline':False]['text':' not the right window','line_number':1325,'multiline':False]['text':' End of handling of the state stack.','line_number':1337,'multiline':False]['text':' **************************************','line_number':1338,'multiline':False]['text':' mark current_state invalid','line_number':1343,'multiline':False]['text':'/ This will only be called just after get_syntax_attr() for the previous','line_number':1354,'multiline':False]['text':'/ line, to check if the next line needs to be redrawn too.','line_number':1355,'multiline':False]['text':'/','line_number':1356,'multiline':False]['text':'/ @return  true if the syntax at start of lnum changed since last time.','line_number':1357,'multiline':False]['text':' Check the state stack when:','line_number':1363,'multiline':False]['text':' - lnum is just below the previously syntaxed line.','line_number':1364,'multiline':False]['text':' - lnum is not before the lines with saved states.','line_number':1365,'multiline':False]['text':' - lnum is not past the lines with saved states.','line_number':1366,'multiline':False]['text':' - lnum is at or before the last changed line.','line_number':1367,'multiline':False]['text':' finish the previous line (needed when not all of the line was','line_number':1371,'multiline':False]['text':' drawn)','line_number':1372,'multiline':False]['text':' Compare the current state with the previously saved state of','line_number':1375,'multiline':False]['text':' the line.','line_number':1376,'multiline':False]['text':' Store the current state in b_sst_array[] for later use.','line_number':1381,'multiline':False]['text':'/ Finish the current line.','line_number':1390,'multiline':False]['text':'/ This doesn't return any attributes, it only gets the state at the end of','line_number':1391,'multiline':False]['text':'/ the line.  It can start anywhere in the line, as long as the current state','line_number':1392,'multiline':False]['text':'/ is valid.','line_number':1393,'multiline':False]['text':'/','line_number':1394,'multiline':False]['text':'/ @param syncing  called for syncing','line_number':1395,'multiline':False]['text':' When syncing, and found some item, need to check the item.','line_number':1401,'multiline':False]['text':' Check for match with sync item.','line_number':1403,'multiline':False]['text':' syn_current_attr() will have skipped the check for an item','line_number':1411,'multiline':False]['text':' that ends here, need to do that now.  Be careful not to go','line_number':1412,'multiline':False]['text':' past the NUL.','line_number':1413,'multiline':False]['text':'/ Gets highlight attributes for next character.','line_number':1426,'multiline':False]['text':'/ Must first call syntax_start() once for the line.','line_number':1427,'multiline':False]['text':'/ "col" is normally 0 for the first use in a line, and increments by one each','line_number':1428,'multiline':False]['text':'/ time.  It's allowed to skip characters and to stop before the end of the','line_number':1429,'multiline':False]['text':'/ line.  But only a "col" after a previously used column is allowed.','line_number':1430,'multiline':False]['text':'/ When "can_spell" is not NULL set it to true when spell-checking should be','line_number':1431,'multiline':False]['text':'/ done.','line_number':1432,'multiline':False]['text':'/','line_number':1433,'multiline':False]['text':'/ @param keep_state  keep state of char at "col"','line_number':1434,'multiline':False]['text':'/','line_number':1435,'multiline':False]['text':'/ @return            highlight attributes for next character.','line_number':1436,'multiline':False]['text':' Default: Only do spelling when there is no @Spell cluster or when','line_number':1442,'multiline':False]['text':' ":syn spell toplevel" was used.','line_number':1443,'multiline':False]['text':' check for out of memory situation','line_number':1449,'multiline':False]['text':' After 'synmaxcol' the attribute is always zero.','line_number':1454,'multiline':False]['text':' Make sure current_state is valid','line_number':1464,'multiline':False]['text':' Skip from the current column to "col", get the attributes for "col".','line_number':1469,'multiline':False]['text':'/ Get syntax attributes for current_lnum, current_col.','line_number':1479,'multiline':False]['text':'/','line_number':1480,'multiline':False]['text':'/ @param syncing     When true: called for syncing','line_number':1481,'multiline':False]['text':'/ @param displaying  result will be displayed','line_number':1482,'multiline':False]['text':'/ @param can_spell   return: do spell checking','line_number':1483,'multiline':False]['text':'/ @param keep_state  keep syntax stack afterwards','line_number':1484,'multiline':False]['text':' end-of-start match (start region)','line_number':1491,'multiline':False]['text':' end-of-end pattern','line_number':1492,'multiline':False]['text':' group ID for end pattern','line_number':1493,'multiline':False]['text':' found usable match','line_number':1501,'multiline':False]['text':' must try in next col','line_number':1502,'multiline':False]['text':' chartab array for syn iskeyword','line_number':1506,'multiline':False]['text':' current line.  NOTE: becomes invalid after','line_number':1507,'multiline':False]['text':' looking for a pattern match!','line_number':1508,'multiline':False]['text':' variables for zero-width matches that have a "nextgroup" argument','line_number':1510,'multiline':False]['text':' No character, no attributes!  Past end of line?','line_number':1515,'multiline':False]['text':' Do try matching with an empty line (could be the start of a region).','line_number':1516,'multiline':False]['text':' If we found a match after the last column, use it.','line_number':1519,'multiline':False]['text':' if the current or next character is NUL, we will finish the line now','line_number':1530,'multiline':False]['text':' When in the previous column there was a match but it could not be used','line_number':1536,'multiline':False]['text':' (empty match or already matched in this column) need to try again in','line_number':1537,'multiline':False]['text':' the next column.','line_number':1538,'multiline':False]['text':' Only check for keywords when not syncing and there are some.','line_number':1544,'multiline':False]['text':' Init the list of zero-width matches with a nextlist.  This is used to','line_number':1549,'multiline':False]['text':' avoid matching the same item in the same position twice.','line_number':1550,'multiline':False]['text':' use syntax iskeyword option','line_number':1553,'multiline':False]['text':' Repeat matching keywords and patterns, to find contained items at the','line_number':1556,'multiline':False]['text':' same column.  This stops when there are no extra matches at the current','line_number':1557,'multiline':False]['text':' column.','line_number':1558,'multiline':False]['text':' 1. Check for a current state.','line_number':1564,'multiline':False]['text':'    Only when there is no current state, or if the current state may','line_number':1565,'multiline':False]['text':'    contain other things, we need to check for keywords and patterns.','line_number':1566,'multiline':False]['text':'    Always need to check for contained items if some item has the','line_number':1567,'multiline':False]['text':'    "containedin" argument (takes extra time!).','line_number':1568,'multiline':False]['text':' 2. Check for keywords, if on a keyword char after a non-keyword','line_number':1577,'multiline':False]['text':'          char.  Don't do this when syncing.','line_number':1578,'multiline':False]['text':' starts right away','line_number':1595,'multiline':False]['text':' 3. Check for patterns (only if no keyword found).','line_number':1631,'multiline':False]['text':' If we didn't check for a match yet, or we are past it, check','line_number':1633,'multiline':False]['text':' for any match with a pattern.','line_number':1634,'multiline':False]['text':' Check all relevant patterns for a match at this','line_number':1636,'multiline':False]['text':' position.  This is complicated, because matching with a','line_number':1637,'multiline':False]['text':' pattern takes quite a bit of time, thus we want to','line_number':1638,'multiline':False]['text':' avoid doing it when it's not needed.','line_number':1639,'multiline':False]['text':' no match in this line yet','line_number':1640,'multiline':False]['text':' If we already tried matching in this line, and','line_number':1655,'multiline':False]['text':' there isn't a match before next_match_col, skip','line_number':1656,'multiline':False]['text':' this item.','line_number':1657,'multiline':False]['text':' no match in this line, try another one','line_number':1675,'multiline':False]['text':' Compute the first column of the match.','line_number':1680,'multiline':False]['text':' must have used end of match in a next line,','line_number':1684,'multiline':False]['text':' we can't handle that','line_number':1685,'multiline':False]['text':' remember the next column where this pattern','line_number':1691,'multiline':False]['text':' matches in the current line','line_number':1692,'multiline':False]['text':' If a previously found match starts at a lower','line_number':1695,'multiline':False]['text':' column number, don't use this one.','line_number':1696,'multiline':False]['text':' If we matched this pattern at this position','line_number':1701,'multiline':False]['text':' before, skip it.  Must retry in the next','line_number':1702,'multiline':False]['text':' column, because it may match from there.','line_number':1703,'multiline':False]['text':' Compute the highlight start.','line_number':1712,'multiline':False]['text':' Compute the region start.','line_number':1716,'multiline':False]['text':' Default is to use the end of the match.','line_number':1717,'multiline':False]['text':' Grab the external submatches before they get','line_number':1721,'multiline':False]['text':' overwritten.  Reference count doesn't change.','line_number':1722,'multiline':False]['text':' avoid warning','line_number':1728,'multiline':False]['text':' For a "oneline" the end must be found in the','line_number':1733,'multiline':False]['text':' same line too.  Search for it after the end of','line_number':1734,'multiline':False]['text':' the match with the start pattern.  Set the','line_number':1735,'multiline':False]['text':' resulting end positions at the same time.','line_number':1736,'multiline':False]['text':' not found','line_number':1745,'multiline':False]['text':' For a "match" the size must be > 0 after the','line_number':1748,'multiline':False]['text':' end offset needs has been added.  Except when','line_number':1749,'multiline':False]['text':' syncing.','line_number':1750,'multiline':False]['text':' If an empty string is matched, may need','line_number':1757,'multiline':False]['text':' to try matching again at next column.','line_number':1758,'multiline':False]['text':' keep the best match so far in next_match_*','line_number':1766,'multiline':False]['text':' Highlighting must start after startpos and end','line_number':1768,'multiline':False]['text':' before endpos.','line_number':1769,'multiline':False]['text':' If we found a match at the current column, use it.','line_number':1792,'multiline':False]['text':' When a zero-width item matched which has a nextgroup,','line_number':1796,'multiline':False]['text':' don't push the item but set nextgroup.','line_number':1797,'multiline':False]['text':' Add the index to a list, so that we can check','line_number':1807,'multiline':False]['text':' later that we don't match it again (and cause an','line_number':1808,'multiline':False]['text':' endless loop).','line_number':1809,'multiline':False]['text':' Handle searching for nextgroup match.','line_number':1820,'multiline':False]['text':' If a nextgroup was not found, continue looking for one if:','line_number':1822,'multiline':False]['text':' - this is an empty line and the "skipempty" option was given','line_number':1823,'multiline':False]['text':' - we are on white space and the "skipwhite" option was given','line_number':1824,'multiline':False]['text':' If a nextgroup was found: Use it, and continue looking for','line_number':1835,'multiline':False]['text':' contained matches.','line_number':1836,'multiline':False]['text':' If a nextgroup was not found: Continue looking for a normal','line_number':1837,'multiline':False]['text':' match.','line_number':1838,'multiline':False]['text':' When did set current_next_list for a zero-width item and no','line_number':1839,'multiline':False]['text':' match was found don't loop (would get stuck).','line_number':1840,'multiline':False]['text':' Use attributes from the current state, if within its highlighting.','line_number':1851,'multiline':False]['text':' If not, use attributes from the current-but-one state, etc.','line_number':1852,'multiline':False]['text':' set "can_spell" to true if spell checking is supposed to be','line_number':1881,'multiline':False]['text':' done in the current item.','line_number':1882,'multiline':False]['text':' There is no @Spell cluster: Do spelling for items without','line_number':1884,'multiline':False]['text':' @NoSpell cluster.','line_number':1885,'multiline':False]['text':' The @Spell cluster is defined: Do spelling in items with','line_number':1896,'multiline':False]['text':' the @Spell cluster.  But not when @NoSpell is also there.','line_number':1897,'multiline':False]['text':' At the toplevel only spell check when ":syn spell toplevel"','line_number':1898,'multiline':False]['text':' was used.','line_number':1899,'multiline':False]['text':' Check for end of current state (and the states before it) at the','line_number':1918,'multiline':False]['text':' next column.  Don't do this for syncing, because we would miss a','line_number':1919,'multiline':False]['text':' single character match.','line_number':1920,'multiline':False]['text':' First check if the current state ends at the current column.  It','line_number':1921,'multiline':False]['text':' may be for an empty match and a containing item might end in the','line_number':1922,'multiline':False]['text':' current column.','line_number':1923,'multiline':False]['text':' Default: Only do spelling when there is no @Spell cluster or when','line_number':1934,'multiline':False]['text':' ":syn spell toplevel" was used.','line_number':1935,'multiline':False]['text':' nextgroup ends at end of line, unless "skipnl" or "skipempty" present','line_number':1941,'multiline':False]['text':' No longer need external matches.  But keep next_match_extmatch.','line_number':1953,'multiline':False]['text':'/ @return  true if we already matched pattern "idx" at the current column.','line_number':1961,'multiline':False]['text':' Zero-width matches with a nextgroup argument are not put on the syntax','line_number':1972,'multiline':False]['text':' stack, and can only be matched once anyway.','line_number':1973,'multiline':False]['text':' Push the next match onto the stack.','line_number':1983,'multiline':False]['text':' Push the item in current_state stack;','line_number':1992,'multiline':False]['text':' If it's a start-skip-end type that crosses lines, figure out how','line_number':1995,'multiline':False]['text':' much it continues in this line.  Otherwise just fill in the length.','line_number':1996,'multiline':False]['text':' Try to find the end pattern in the current line','line_number':2011,'multiline':False]['text':' If the start pattern has another highlight group, push another item','line_number':2029,'multiline':False]['text':' on the stack for the start pattern.','line_number':2030,'multiline':False]['text':' try other match next time','line_number':2053,'multiline':False]['text':' Check for end of current state (and the states before it).','line_number':2058,'multiline':False]['text':' If there is an end pattern group ID, highlight the end pattern','line_number':2070,'multiline':False]['text':' now.  No need to pop the current item from the stack.','line_number':2071,'multiline':False]['text':' Only do this if the end pattern continues beyond the current','line_number':2072,'multiline':False]['text':' position.','line_number':2073,'multiline':False]['text':' nextgroup= should not match in the end pattern','line_number':2089,'multiline':False]['text':' what matches next may be different now, clear it','line_number':2092,'multiline':False]['text':' handle next_list, unless at end of line and no "skipnl" or','line_number':2098,'multiline':False]['text':' "skipempty"','line_number':2099,'multiline':False]['text':' When the ended item has "extend", another item with','line_number':2107,'multiline':False]['text':' "keepend" now needs to check for its end.','line_number':2108,'multiline':False]['text':' Only for a region the search for the end continues after','line_number':2126,'multiline':False]['text':' the end of the contained item.  If the contained match','line_number':2127,'multiline':False]['text':' included the end-of-line, break here, the region continues.','line_number':2128,'multiline':False]['text':' Don't do this when:','line_number':2129,'multiline':False]['text':' - "keepend" is used for the contained item','line_number':2130,'multiline':False]['text':' - not at the end of the line (could be end="x$"me=e-1).','line_number':2131,'multiline':False]['text':' - "excludenl" is used (HL_HAS_EOL won't be set)','line_number':2132,'multiline':False]['text':' Update an entry in the current_state stack for a match or region.  This','line_number':2150,'multiline':False]['text':' fills in si_attr, si_next_list and si_cont_list.','line_number':2151,'multiline':False]['text':' This should not happen...','line_number':2157,'multiline':False]['text':' For transparent items, take attr from outer item.','line_number':2176,'multiline':False]['text':' Also take cont_list, if there is none.','line_number':2177,'multiline':False]['text':' Don't do this for the matchgroup of a start or end pattern.','line_number':2178,'multiline':False]['text':' Check the current stack for patterns with "keepend" flag.','line_number':2197,'multiline':False]['text':' Propagate the match-end to contained items, until a "skipend" item is found.','line_number':2198,'multiline':False]['text':' This check can consume a lot of time; only do it from the level where','line_number':2206,'multiline':False]['text':' there really is a keepend.','line_number':2207,'multiline':False]['text':' Find the last index of an "extend" item.  "keepend" items before that','line_number':2212,'multiline':False]['text':' won't do anything.  If there is no "extend" item "i" will be','line_number':2213,'multiline':False]['text':' "keepend_level" and all "keepend" items will work normally.','line_number':2214,'multiline':False]['text':'/ Update an entry in the current_state stack for a start-skip-end pattern.','line_number':2250,'multiline':False]['text':'/ This finds the end of the current item, if it's in the current line.','line_number':2251,'multiline':False]['text':'/','line_number':2252,'multiline':False]['text':'/ @param startcol  where to start searching for the end','line_number':2253,'multiline':False]['text':'/ @param force     when true overrule a previous end','line_number':2254,'multiline':False]['text':'/','line_number':2255,'multiline':False]['text':'/ @return          the flags for the matched END.','line_number':2256,'multiline':False]['text':' return quickly for a keyword','line_number':2262,'multiline':False]['text':' Don't update when it's already done.  Can be a match of an end pattern','line_number':2267,'multiline':False]['text':' that started in a previous line.  Watch out: can also be a "keepend"','line_number':2268,'multiline':False]['text':' from a containing item.','line_number':2269,'multiline':False]['text':' We need to find the end of the region.  It may continue in the next','line_number':2274,'multiline':False]['text':' line.','line_number':2275,'multiline':False]['text':' No end pattern matched.','line_number':2286,'multiline':False]['text':' a "oneline" never continues in the next line','line_number':2288,'multiline':False]['text':' continues in the next line','line_number':2293,'multiline':False]['text':' match within this line','line_number':2299,'multiline':False]['text':' Add a new state to the current state stack.','line_number':2308,'multiline':False]['text':' It is cleared and the index set to "idx".','line_number':2309,'multiline':False]['text':' Remove a state from the current_state stack.','line_number':2317,'multiline':False]['text':' after the end of a pattern, try matching a keyword or pattern','line_number':2324,'multiline':False]['text':' if first state with "keepend" is popped, reset keepend_level','line_number':2327,'multiline':False]['text':'/ Find the end of a start/skip/end syntax region after "startpos".','line_number':2333,'multiline':False]['text':'/ Only checks one line.','line_number':2334,'multiline':False]['text':'/ Also handles a match item that continued from a previous line.','line_number':2335,'multiline':False]['text':'/ If not found, the syntax item continues in the next line.  m_endpos->lnum','line_number':2336,'multiline':False]['text':'/ will be 0.','line_number':2337,'multiline':False]['text':'/ If found, the end of the region and the end of the highlighting is','line_number':2338,'multiline':False]['text':'/ computed.','line_number':2339,'multiline':False]['text':'/','line_number':2340,'multiline':False]['text':'/ @param idx         index of the pattern','line_number':2341,'multiline':False]['text':'/ @param startpos    where to start looking for an END match','line_number':2342,'multiline':False]['text':'/ @param m_endpos    return: end of match','line_number':2343,'multiline':False]['text':'/ @param hl_endpos   return: end of highlighting','line_number':2344,'multiline':False]['text':'/ @param flagsp      return: flags of matching END','line_number':2345,'multiline':False]['text':'/ @param end_endpos  return: end of end pattern match','line_number':2346,'multiline':False]['text':'/ @param end_idx     return: group ID for end pat. match, or 0','line_number':2347,'multiline':False]['text':'/ @param start_ext   submatches from the start pattern','line_number':2348,'multiline':False]['text':' startpos/endpos of best match','line_number':2355,'multiline':False]['text':' chartab array for syn option iskeyword','line_number':2359,'multiline':False]['text':' just in case we are invoked for a keyword','line_number':2361,'multiline':False]['text':' Check for being called with a START pattern.','line_number':2366,'multiline':False]['text':' Can happen with a match that continues to the next line, because it','line_number':2367,'multiline':False]['text':' contained a region.','line_number':2368,'multiline':False]['text':' Find the SKIP or first END pattern after the last START pattern.','line_number':2375,'multiline':False]['text':'    Lookup the SKIP pattern (if present)','line_number':2384,'multiline':False]['text':' Setup external matches for syn_regexec().','line_number':2392,'multiline':False]['text':' start looking for a match at sstart','line_number':2396,'multiline':False]['text':' remember the first END pattern.','line_number':2397,'multiline':False]['text':' avoid compiler warning','line_number':2398,'multiline':False]['text':' use syntax iskeyword option','line_number':2400,'multiline':False]['text':' Find end pattern that matches first after "matchcol".','line_number':2404,'multiline':False]['text':' past last END pattern','line_number':2410,'multiline':False]['text':' If all end patterns have been tried, and there is no match, the','line_number':2433,'multiline':False]['text':' item continues until end-of-line.','line_number':2434,'multiline':False]['text':' If the skip pattern matches before the end pattern,','line_number':2439,'multiline':False]['text':' continue searching after the skip pattern.','line_number':2440,'multiline':False]['text':' Add offset to skip pattern match','line_number':2453,'multiline':False]['text':' If the skip pattern goes on to the next line, there is no','line_number':2456,'multiline':False]['text':' match with an end pattern in this line.','line_number':2457,'multiline':False]['text':' take care of an empty match or negative offset','line_number':2465,'multiline':False]['text':' Be careful not to jump over the NUL at the end-of-line','line_number':2471,'multiline':False]['text':' if the skip pattern includes end-of-line, break here','line_number':2477,'multiline':False]['text':' start with first end pattern again','line_number':2482,'multiline':False]['text':' Match from start pattern to end pattern.','line_number':2486,'multiline':False]['text':' Correct for match and highlight offset of end pattern.','line_number':2487,'multiline':False]['text':' can't end before the start','line_number':2490,'multiline':False]['text':' can't end before the start','line_number':2496,'multiline':False]['text':' can't end after the match','line_number':2501,'multiline':False]['text':' If the end group is highlighted differently, adjust the pointers.','line_number':2504,'multiline':False]['text':' can't end before the start','line_number':2516,'multiline':False]['text':' now the match ends where the highlighting ends, it is turned','line_number':2523,'multiline':False]['text':' into the matchgroup for the end','line_number':2524,'multiline':False]['text':' no match for an END pattern in this line','line_number':2537,'multiline':False]['text':' Remove external matches.','line_number':2544,'multiline':False]['text':' Limit "pos" not to be after "limit".','line_number':2549,'multiline':False]['text':' Limit "pos" not to be after "limit", unless pos->lnum is zero.','line_number':2559,'multiline':False]['text':'/ Add offset to matched text for end of match or highlight.','line_number':2569,'multiline':False]['text':'/','line_number':2570,'multiline':False]['text':'/ @param result    returned position','line_number':2571,'multiline':False]['text':'/ @param regmatch  start/end of match','line_number':2572,'multiline':False]['text':'/ @param spp       matched pattern','line_number':2573,'multiline':False]['text':'/ @param idx       index of offset','line_number':2574,'multiline':False]['text':'/ @param extra     extra chars for offset to start','line_number':2575,'multiline':False]['text':' Don't go past the end of the line.  Matters for "rs=e+2" when there','line_number':2593,'multiline':False]['text':' is a matchgroup. Watch out for match with last NL in the buffer.','line_number':2594,'multiline':False]['text':'/ Add offset to matched text for start of match or highlight.','line_number':2614,'multiline':False]['text':'/ Avoid resulting column to become negative.','line_number':2615,'multiline':False]['text':'/','line_number':2616,'multiline':False]['text':'/ @param result    returned position','line_number':2617,'multiline':False]['text':'/ @param regmatch  start/end of match','line_number':2618,'multiline':False]['text':'/ @param extra     extra chars for offset to end','line_number':2619,'multiline':False]['text':' a "\n" at the end of the pattern may take us below the last line','line_number':2638,'multiline':False]['text':'/ Get current line in syntax buffer.','line_number':2659,'multiline':False]['text':' Call vim_regexec() to find a match with "rmp" in "syn_buf".','line_number':2665,'multiline':False]['text':' Returns true when there is a match.','line_number':2666,'multiline':False]['text':' This can happen if a previous call to vim_regexec_multi() tried to','line_number':2678,'multiline':False]['text':' use the NFA engine, which resulted in NFA_TOO_EXPENSIVE, and','line_number':2679,'multiline':False]['text':' compiling the pattern with the other engine fails.','line_number':2680,'multiline':False]['text':'/ Check one position in a line for a matching keyword.','line_number':2711,'multiline':False]['text':'/ The caller must check if a keyword can start at startcol.','line_number':2712,'multiline':False]['text':'/ Return its ID if found, 0 otherwise.','line_number':2713,'multiline':False]['text':'/','line_number':2714,'multiline':False]['text':'/ @param startcol    position in line to check for keyword','line_number':2715,'multiline':False]['text':'/ @param endcolp     return: character after found keyword','line_number':2716,'multiline':False]['text':'/ @param flagsp      return: flags of matching keyword','line_number':2717,'multiline':False]['text':'/ @param next_listp  return: next_list of matching keyword','line_number':2718,'multiline':False]['text':'/ @param cur_si      item at the top of the stack','line_number':2719,'multiline':False]['text':'/ @param ccharp      conceal substitution char','line_number':2720,'multiline':False]['text':' Find first character after the keyword.  First character was already','line_number':2725,'multiline':False]['text':' checked.','line_number':2726,'multiline':False]['text':' Must make a copy of the keyword, so we can add a NUL and make it','line_number':2737,'multiline':False]['text':' lowercase.','line_number':2738,'multiline':False]['text':' assume max. keyword len is 80','line_number':2739,'multiline':False]['text':' matching case','line_number':2744,'multiline':False]['text':' ignoring case','line_number':2749,'multiline':False]['text':'/ Find keywords that match.  There can be several with different','line_number':2766,'multiline':False]['text':'/ attributes.','line_number':2767,'multiline':False]['text':'/ When current_next_list is non-zero accept only that group, otherwise:','line_number':2768,'multiline':False]['text':'/  Accept a not-contained keyword at toplevel.','line_number':2769,'multiline':False]['text':'/  Accept a keyword at other levels only if it is in the contains list.','line_number':2770,'multiline':False]['text':' Handle ":syntax conceal" command.','line_number':2789,'multiline':False]['text':'/ Handle ":syntax case" command.','line_number':2816,'multiline':False]['text':'/ Handle ":syntax foldlevel" command.','line_number':2843,'multiline':False]['text':'/ Handle ":syntax spell" command.','line_number':2882,'multiline':False]['text':' assume spell checking changed, force a redraw','line_number':2913,'multiline':False]['text':'/ Handle ":syntax iskeyword" command.','line_number':2917,'multiline':False]['text':' Clear all syntax info for one buffer.','line_number':2957,'multiline':False]['text':' clear previous error','line_number':2960,'multiline':False]['text':' clear previous timeout','line_number':2961,'multiline':False]['text':' Use case, by default','line_number':2962,'multiline':False]['text':' default spell checking','line_number':2964,'multiline':False]['text':' free the keywords','line_number':2968,'multiline':False]['text':' free the syntax patterns','line_number':2972,'multiline':False]['text':' free the syntax clusters','line_number':2978,'multiline':False]['text':' free the stored states','line_number':2997,'multiline':False]['text':' Reset the counter for ":syn include"','line_number':3001,'multiline':False]['text':' Get rid of ownsyntax for window "wp".','line_number':3005,'multiline':False]['text':' Clear syncing info for one buffer.','line_number':3015,'multiline':False]['text':' free the syntax patterns','line_number':3018,'multiline':False]['text':' Need to recompute all syntax.','line_number':3035,'multiline':False]['text':' Remove one pattern from the buffer's pattern list.','line_number':3038,'multiline':False]['text':' Clear and free one syntax pattern.  When clearing all, must be called from','line_number':3052,'multiline':False]['text':' last to first!','line_number':3053,'multiline':False]['text':' Only free sp_cont_list and sp_next_list of first start pattern','line_number':3058,'multiline':False]['text':' Clear and free one syntax cluster.','line_number':3066,'multiline':False]['text':'/ Handle ":syntax clear" command.','line_number':3074,'multiline':False]['text':' We have to disable this within ":syn include @group filename",','line_number':3086,'multiline':False]['text':' because otherwise @group would get deleted.','line_number':3087,'multiline':False]['text':' Only required for Vim 5.x syntax files, 6.0 ones don't contain ":syn','line_number':3088,'multiline':False]['text':' clear".','line_number':3089,'multiline':False]['text':' No argument: Clear all syntax items.','line_number':3095,'multiline':False]['text':' Clear the group IDs that are in the argument.','line_number':3106,'multiline':False]['text':' We can't physically delete a cluster without changing','line_number':3115,'multiline':False]['text':' the IDs of other clusters, so we do the next best thing','line_number':3116,'multiline':False]['text':' and make it empty.','line_number':3117,'multiline':False]['text':' Need to recompute all syntax.','line_number':3133,'multiline':False]['text':' Clear one syntax group for the current buffer.','line_number':3136,'multiline':False]['text':' Clear keywords only when not ":syn sync clear group-name"','line_number':3141,'multiline':False]['text':' clear the patterns for "id"','line_number':3147,'multiline':False]['text':' Handle ":syntax on" command.','line_number':3157,'multiline':False]['text':' Handle ":syntax reset" command.','line_number':3163,'multiline':False]['text':' It actually resets highlighting, not syntax.','line_number':3164,'multiline':False]['text':' Handle ":syntax manual" command.','line_number':3173,'multiline':False]['text':' Handle ":syntax off" command.','line_number':3179,'multiline':False]['text':'/ Handle ":syntax [list]" command: list current syntax words.','line_number':3208,'multiline':False]['text':'/','line_number':3209,'multiline':False]['text':'/ @param syncing  when true: list syncing items','line_number':3210,'multiline':False]['text':' No argument: List all group IDs and all syntax clusters.','line_number':3259,'multiline':False]['text':' List the group IDs and syntax clusters that are in the argument.','line_number':3267,'multiline':False]['text':'/ List one syntax item, for ":syntax" or "syntax list syntax_name".','line_number':3326,'multiline':False]['text':'/','line_number':3327,'multiline':False]['text':'/ @param syncing    when true: list syncing items','line_number':3328,'multiline':False]['text':'/ @param link_only  when true; list link-only too','line_number':3329,'multiline':False]['text':' highlight like directories','line_number':3353,'multiline':False]['text':' list the keywords for "id"','line_number':3355,'multiline':False]['text':' list the patterns for "id"','line_number':3362,'multiline':False]['text':' list the link, if there is one','line_number':3422,'multiline':False]['text':' List one syntax cluster, for ":syntax" or "syntax list syntax_name".','line_number':3441,'multiline':False]['text':' slight hack:  roughly duplicate the guts of syn_list_header()','line_number':3446,'multiline':False]['text':' output at least one space','line_number':3450,'multiline':False]['text':' avoid hang for tiny window','line_number':3453,'multiline':False]['text':' May have to write "matchgroup=group"','line_number':3501,'multiline':False]['text':' Output the name of the pattern and an '=' or ' '.','line_number':3514,'multiline':False]['text':' output the pattern, in between a char that is not in the pattern','line_number':3518,'multiline':False]['text':' no good char found, just use the first one','line_number':3521,'multiline':False]['text':' output any pattern options','line_number':3529,'multiline':False]['text':' Separate with commas.','line_number':3537,'multiline':False]['text':'/ List or clear the keywords for one syntax group.','line_number':3559,'multiline':False]['text':'/','line_number':3560,'multiline':False]['text':'/ @param did_header  header has already been printed','line_number':3561,'multiline':False]['text':'/','line_number':3562,'multiline':False]['text':'/ @return            true if the header has been printed.','line_number':3563,'multiline':False]['text':' Unfortunately, this list of keywords is not sorted on alphabet but on','line_number':3574,'multiline':False]['text':' hash value...','line_number':3575,'multiline':False]['text':' output "contained" and "nextgroup" on each line','line_number':3596,'multiline':False]['text':' Clear a whole keyword table.','line_number':3685,'multiline':False]['text':'/ Add a keyword to the list of keywords.','line_number':3709,'multiline':False]['text':'/','line_number':3710,'multiline':False]['text':'/ @param name name of keyword','line_number':3711,'multiline':False]['text':'/ @param id group ID for this keyword','line_number':3712,'multiline':False]['text':'/ @param flags flags for this keyword','line_number':3713,'multiline':False]['text':'/ @param cont_in_list containedin for this keyword','line_number':3714,'multiline':False]['text':'/ @param next_list nextgroup for this keyword','line_number':3715,'multiline':False]['text':' even though it looks like only the kp->keyword member is','line_number':3745,'multiline':False]['text':' being used here, vim uses some pointer trickery to get the original','line_number':3746,'multiline':False]['text':' struct again later by using knowledge of the offset of the keyword','line_number':3747,'multiline':False]['text':' field in the struct. See the definition of the HI2KE macro.','line_number':3748,'multiline':False]['text':' new keyword, add to hashtable','line_number':3750,'multiline':False]['text':' keyword already exists, prepend to list','line_number':3754,'multiline':False]['text':'/ Get the start and end of the group name argument.','line_number':3760,'multiline':False]['text':'/','line_number':3761,'multiline':False]['text':'/ @param arg       start of the argument','line_number':3762,'multiline':False]['text':'/ @param name_end  pointer to end of the name','line_number':3763,'multiline':False]['text':'/','line_number':3764,'multiline':False]['text':'/ @return          a pointer to the first argument.','line_number':3765,'multiline':False]['text':'/                  Return NULL if the end of the command was found instead of further args.','line_number':3766,'multiline':False]['text':' Check if there are enough arguments.  The first argument may be a','line_number':3772,'multiline':False]['text':' pattern, where '|' is allowed, so only check for NUL.','line_number':3773,'multiline':False]['text':'/ Check for syntax command option arguments.','line_number':3780,'multiline':False]['text':'/ This can be called at any place in the list of arguments, and just picks','line_number':3781,'multiline':False]['text':'/ out the arguments that are known.  Can be called several times in a row to','line_number':3782,'multiline':False]['text':'/ collect all options in between other arguments.','line_number':3783,'multiline':False]['text':'/','line_number':3784,'multiline':False]['text':'/ @param arg   next argument to be checked','line_number':3785,'multiline':False]['text':'/ @param opt   various things','line_number':3786,'multiline':False]['text':'/ @param skip  true if skipping over command','line_number':3787,'multiline':False]['text':'/','line_number':3788,'multiline':False]['text':'/ @return      a pointer to the next argument (which isn't an option).','line_number':3789,'multiline':False]['text':'/              Return NULL for any error;','line_number':3790,'multiline':False]['text':' already detected error','line_number':3822,'multiline':False]['text':' This is used very often when a large number of keywords is defined.','line_number':3831,'multiline':False]['text':' Need to skip quickly when no option name is found.','line_number':3832,'multiline':False]['text':' Also avoid tolower(), it's slow.','line_number':3833,'multiline':False]['text':' treat "display", "fold" and "extend" as a keyword','line_number':3854,'multiline':False]['text':' no match found','line_number':3860,'multiline':False]['text':' cchar=?','line_number':3881,'multiline':False]['text':' Need to update folds later.','line_number':3928,'multiline':False]['text':' Adjustments to syntax item when declared in a ":syn include"'d file.','line_number':3937,'multiline':False]['text':' Set the contained flag, and if the item is not already contained, add it','line_number':3938,'multiline':False]['text':' to the specified top-level group, if any.','line_number':3939,'multiline':False]['text':' We have to alloc this, because syn_combine_list() will free it.','line_number':3947,'multiline':False]['text':' Handle ":syntax include [@{group-name}] filename" command.','line_number':3958,'multiline':False]['text':' separate_nextcmd() and expand_filename() depend on this','line_number':3986,'multiline':False]['text':' Everything that's left, up to the next command, should be the','line_number':3990,'multiline':False]['text':' filename to include.','line_number':3991,'multiline':False]['text':' For an absolute path, "$VIM/..." or "<sfile>.." we ":source" the','line_number':3995,'multiline':False]['text':' file.  Need to expand the file name first.  In other cases','line_number':3996,'multiline':False]['text':' ":runtime!" is used.','line_number':3997,'multiline':False]['text':' Save and restore the existing top-level grouplist id and ":syn','line_number':4007,'multiline':False]['text':' include" tag around the actual inclusion.','line_number':4008,'multiline':False]['text':' Handle ":syntax keyword {group-name} [{option}] keyword .." command.','line_number':4026,'multiline':False]['text':' Allocate a buffer, for removing backslashes in the keyword.','line_number':4049,'multiline':False]['text':' The options given apply to ALL keywords, so all options must be','line_number':4060,'multiline':False]['text':' found before keywords can be created.','line_number':4061,'multiline':False]['text':' 1: collect the options and copy the keywords to keyword_copy.','line_number':4062,'multiline':False]['text':' Copy the keyword, removing backslashes, and add a NUL.','line_number':4070,'multiline':False]['text':' Adjust flags for use of ":syn include".','line_number':4082,'multiline':False]['text':' 2: Add an entry for each keyword.','line_number':4085,'multiline':False]['text':' skip over the "]"','line_number':4107,'multiline':False]['text':' Need to recompute all syntax.','line_number':4131,'multiline':False]['text':'/ Handle ":syntax match {name} [{options}] {pattern} [{options}]".','line_number':4134,'multiline':False]['text':'/','line_number':4135,'multiline':False]['text':'/ Also ":syntax sync match {name} [[grouphere | groupthere] {group-name}] .."','line_number':4136,'multiline':False]['text':'/','line_number':4137,'multiline':False]['text':'/ @param syncing  true for ":syntax sync match .. "','line_number':4138,'multiline':False]['text':' the item found in the line','line_number':4143,'multiline':False]['text':' Isolate the group name, check for validity','line_number':4149,'multiline':False]['text':' Get options before the pattern','line_number':4152,'multiline':False]['text':' get the pattern.','line_number':4162,'multiline':False]['text':' Get options after the pattern','line_number':4170,'multiline':False]['text':' all arguments are valid','line_number':4173,'multiline':False]['text':' Check for trailing command and illegal trailing arguments.','line_number':4174,'multiline':False]['text':' Store the pattern in the syn_items list','line_number':4181,'multiline':False]['text':' remember that we found a match for syncing on','line_number':4199,'multiline':False]['text':' Need to recompute all syntax.','line_number':4208,'multiline':False]['text':' don't free the progs and patterns now','line_number':4209,'multiline':False]['text':' Something failed, free the allocated memory.','line_number':4214,'multiline':False]['text':'/ Handle ":syntax region {group-name} [matchgroup={group-name}]','line_number':4226,'multiline':False]['text':'/              start {start} .. [skip {skip}] end {end} .. [{options}]".','line_number':4227,'multiline':False]['text':'/','line_number':4228,'multiline':False]['text':'/ @param syncing  true for ":syntax sync region .."','line_number':4229,'multiline':False]['text':' next arg, NULL on error','line_number':4234,'multiline':False]['text':' pointer to syn_pattern','line_number':4244,'multiline':False]['text':' matchgroup ID','line_number':4245,'multiline':False]['text':' pointer to next pat_ptr','line_number':4246,'multiline':False]['text':' patterns found in the line','line_number':4248,'multiline':False]['text':' nr of syn_patterns found','line_number':4251,'multiline':False]['text':' not enough arguments','line_number':4254,'multiline':False]['text':' illegal arguments','line_number':4255,'multiline':False]['text':' Isolate the group name, check for validity','line_number':4260,'multiline':False]['text':' get the options, patterns and matchgroup.','line_number':4277,'multiline':False]['text':' Check for option arguments','line_number':4279,'multiline':False]['text':' must be a pattern or matchgroup then','line_number':4285,'multiline':False]['text':' One skip pattern allowed.','line_number':4299,'multiline':False]['text':' Allocate room for a syn_pattern, and link it in the list of','line_number':4332,'multiline':False]['text':' syn_patterns for this item, at the start (because the list is','line_number':4333,'multiline':False]['text':' used from end to start).','line_number':4334,'multiline':False]['text':' Get the syntax pattern and the following offset(s).','line_number':4340,'multiline':False]['text':' Enable the appropriate \z specials.','line_number':4342,'multiline':False]['text':' Must have a "start" and "end" pattern.','line_number':4364,'multiline':False]['text':' Check for trailing garbage or command.','line_number':4372,'multiline':False]['text':' If OK, add the item.','line_number':4373,'multiline':False]['text':' Store the start/skip/end in the syn_items list','line_number':4381,'multiline':False]['text':' Need to recompute all syntax.','line_number':4416,'multiline':False]['text':' don't free the progs and patterns now','line_number':4417,'multiline':False]['text':' Free the allocated memory.','line_number':4422,'multiline':False]['text':' A simple syntax group ID comparison function suitable for use in qsort()','line_number':4447,'multiline':False]['text':' Combines lists of syntax clusters.','line_number':4456,'multiline':False]['text':' *clstr1 and *clstr2 must both be allocated memory; they will be consumed.','line_number':4457,'multiline':False]['text':' Handle degenerate cases.','line_number':4466,'multiline':False]['text':' For speed purposes, sort both lists.','line_number':4489,'multiline':False]['text':' We proceed in two passes; in round 1, we count the elements to place','line_number':4493,'multiline':False]['text':' in the new list, and in round 2, we allocate and populate the new','line_number':4494,'multiline':False]['text':' list.  For speed, we use a mergesort-like method, adding the smaller','line_number':4495,'multiline':False]['text':' of the current elements in each list to the new list.','line_number':4496,'multiline':False]['text':' First, loop through the lists until one of them is empty.','line_number':4502,'multiline':False]['text':' We always want to add from the first list.','line_number':4504,'multiline':False]['text':' We only want to add from the second list if we're adding the','line_number':4513,'multiline':False]['text':' lists.','line_number':4514,'multiline':False]['text':' Now add the leftovers from whichever list didn't get finished','line_number':4527,'multiline':False]['text':' first.  As before, we only want to add from the second list if','line_number':4528,'multiline':False]['text':' we're adding the lists.','line_number':4529,'multiline':False]['text':' If the group ended up empty, we don't need to allocate any','line_number':4544,'multiline':False]['text':' space for it.','line_number':4545,'multiline':False]['text':' Finally, put the new list in place.','line_number':4555,'multiline':False]['text':'/ Lookup a syntax cluster name and return its ID.','line_number':4561,'multiline':False]['text':'/ If it is not found, 0 is returned.','line_number':4562,'multiline':False]['text':' Avoid using stricmp() too much, it's slow on some systems','line_number':4565,'multiline':False]['text':'/ Like syn_scl_name2id(), but take a pointer + length argument.','line_number':4578,'multiline':False]['text':'/ Find syntax cluster name in the table and return its ID.','line_number':4588,'multiline':False]['text':'/ The argument is a pointer to the name and the length of the name.','line_number':4589,'multiline':False]['text':'/ If it doesn't exist yet, a new entry is created.','line_number':4590,'multiline':False]['text':'/','line_number':4591,'multiline':False]['text':'/ @return  0 for failure.','line_number':4592,'multiline':False]['text':' doesn't exist yet','line_number':4597,'multiline':False]['text':'/ Add new syntax cluster and return its ID.','line_number':4605,'multiline':False]['text':'/ "name" must be an allocated string, it will be consumed.','line_number':4606,'multiline':False]['text':'/','line_number':4607,'multiline':False]['text':'/ @return  0 for failure.','line_number':4608,'multiline':False]['text':' First call for this growarray: init growing array.','line_number':4611,'multiline':False]['text':' Handle ":syntax cluster {cluster-name} [contains={groupname},..]','line_number':4641,'multiline':False]['text':'              [add={groupname},..] [remove={groupname},..]".','line_number':4642,'multiline':False]['text':' Need to recompute all.','line_number':4699,'multiline':False]['text':' On first call for current buffer: Init growing array.','line_number':4711,'multiline':False]['text':'/ Get one pattern for a ":syntax match" or ":syntax region" command.','line_number':4718,'multiline':False]['text':'/ Stores the pattern and program in a synpat_T.','line_number':4719,'multiline':False]['text':'/','line_number':4720,'multiline':False]['text':'/ @return  a pointer to the next argument, or NULL in case of an error.','line_number':4721,'multiline':False]['text':' need at least three chars','line_number':4727,'multiline':False]['text':' end delimiter not found','line_number':4733,'multiline':False]['text':' store the pattern and compiled regexp program','line_number':4737,'multiline':False]['text':' Make 'cpoptions' empty, to avoid the 'l' flag','line_number':4740,'multiline':False]['text':' Check for a match, highlight or region offset.','line_number':4752,'multiline':False]['text':' lc=99','line_number':4776,'multiline':False]['text':' "lc=" offset automatically sets "ms=" offset','line_number':4780,'multiline':False]['text':' yy=x+99','line_number':4785,'multiline':False]['text':' positive offset','line_number':4789,'multiline':False]['text':' negative offset','line_number':4792,'multiline':False]['text':'/ Handle ":syntax sync .." command.','line_number':4810,'multiline':False]['text':' missing pattern','line_number':4876,'multiline':False]['text':' end delimiter not found','line_number':4886,'multiline':False]['text':' store the pattern and compiled regexp program','line_number':4892,'multiline':False]['text':' Make 'cpoptions' empty, to avoid the 'l' flag','line_number':4897,'multiline':False]['text':' Need to recompute all syntax.','line_number':4934,'multiline':False]['text':'/ Convert a line of highlight group names into a list of group ID numbers.','line_number':4938,'multiline':False]['text':'/ "arg" should point to the "contains" or "nextgroup" keyword.','line_number':4939,'multiline':False]['text':'/ "arg" is advanced to after the last group name.','line_number':4940,'multiline':False]['text':'/ Careful: the argument is modified (NULs added).','line_number':4941,'multiline':False]['text':'/','line_number':4942,'multiline':False]['text':'/ @param keylen  length of keyword','line_number':4943,'multiline':False]['text':'/ @param list    where to store the resulting list, if not NULL, the list is silently skipped!','line_number':4944,'multiline':False]['text':'/','line_number':4945,'multiline':False]['text':'/ @return        FAIL for some error, OK for success.','line_number':4946,'multiline':False]['text':' We parse the list twice:','line_number':4957,'multiline':False]['text':' round == 1: count the number of items, allocate the array.','line_number':4958,'multiline':False]['text':' round == 2: fill the array with the items.','line_number':4959,'multiline':False]['text':' In round 1 new groups may be added, causing the number of items to','line_number':4960,'multiline':False]['text':' grow when a regexp is used.  In that case round 1 is done once again.','line_number':4961,'multiline':False]['text':' skip "contains"','line_number':4963,'multiline':False]['text':' parse the arguments after "contains"','line_number':4975,'multiline':False]['text':' leave room for "^$"','line_number':4979,'multiline':False]['text':' Handle full group name.','line_number':5016,'multiline':False]['text':' Handle match of regexp with group names.','line_number':5020,'multiline':False]['text':' Got more items than expected; can happen','line_number':5035,'multiline':False]['text':' when adding items that match:','line_number':5036,'multiline':False]['text':' "contains=a.*b,axb".','line_number':5037,'multiline':False]['text':' Go back to first round.','line_number':5038,'multiline':False]['text':' Remember that we found one.','line_number':5047,'multiline':False]['text':' Got more items than expected, go back to first round.','line_number':5061,'multiline':False]['text':' skip comma in between arguments','line_number':5075,'multiline':False]['text':' zero means end of the list','line_number':5082,'multiline':False]['text':' list already found, don't overwrite it','line_number':5096,'multiline':False]['text':' Make a copy of an ID list.','line_number':5101,'multiline':False]['text':'/ Check if syntax group "ssp" is in the ID list "list" of "cur_si".','line_number':5117,'multiline':False]['text':'/ "cur_si" can be NULL if not checking the "containedin" list.','line_number':5118,'multiline':False]['text':'/ Used to check if a syntax item is in the "contains" or "nextgroup" list of','line_number':5119,'multiline':False]['text':'/ the current item.','line_number':5120,'multiline':False]['text':'/ This function is called very often, keep it fast!!','line_number':5121,'multiline':False]['text':'/','line_number':5122,'multiline':False]['text':'/ @param cur_si     current item or NULL','line_number':5123,'multiline':False]['text':'/ @param list       id list','line_number':5124,'multiline':False]['text':'/ @param ssp        group id and ":syn include" tag of group','line_number':5125,'multiline':False]['text':'/ @param contained  group id is contained','line_number':5126,'multiline':False]['text':' If ssp has a "containedin" list and "cur_si" is in it, return true.','line_number':5135,'multiline':False]['text':' Ignore transparent items without a contains argument.  Double check','line_number':5138,'multiline':False]['text':' that we don't go back past the first one.','line_number':5139,'multiline':False]['text':' cur_si->si_idx is -1 for keywords, these never contain anything.','line_number':5144,'multiline':False]['text':' If list is ID_LIST_ALL, we are in a transparent item that isn't','line_number':5157,'multiline':False]['text':' inside anything.  Only allow not-contained groups.','line_number':5158,'multiline':False]['text':' If the first item is "ALLBUT", return true if "id" is NOT in the','line_number':5163,'multiline':False]['text':' contains list.  We also require that "id" is at the same ":syn include"','line_number':5164,'multiline':False]['text':' level as the list.','line_number':5165,'multiline':False]['text':' ALL or ALLBUT: accept all groups in the same file','line_number':5169,'multiline':False]['text':' TOP: accept all not-contained groups in the same file','line_number':5174,'multiline':False]['text':' CONTAINED: accept all contained groups in the same file','line_number':5179,'multiline':False]['text':' Return "retval" if id is in the contains list.','line_number':5190,'multiline':False]['text':' restrict recursiveness to 30 to avoid an endless loop for a','line_number':5197,'multiline':False]['text':' cluster that includes itself (indirectly)','line_number':5198,'multiline':False]['text':' subcommand name','line_number':5214,'multiline':False]['text':' function to call','line_number':5215,'multiline':False]['text':'/ ":syntax".','line_number':5241,'multiline':False]['text':'/ This searches the subcommands[] table for the subcommand name, and calls a','line_number':5242,'multiline':False]['text':'/ syntax_subcommand() function to do the rest.','line_number':5243,'multiline':False]['text':' isolate subcommand name','line_number':5251,'multiline':False]['text':' skip error messages for all subcommands','line_number':5254,'multiline':False]['text':' TODO(vim): Keep the spell checking as it was.','line_number':5280,'multiline':False]['text':' No spell checking','line_number':5281,'multiline':False]['text':' make sure option values are "empty_string_option" instead of NULL','line_number':5282,'multiline':False]['text':' Save value of b:current_syntax.','line_number':5290,'multiline':False]['text':' Apply the "syntax" autocommand event, this finds and loads the syntax file.','line_number':5296,'multiline':False]['text':' Move value of b:current_syntax to w:current_syntax.','line_number':5299,'multiline':False]['text':' Restore value of b:current_syntax.','line_number':5305,'multiline':False]['text':' expand ":syn" sub-commands','line_number':5323,'multiline':False]['text':' expand ":syn case" arguments','line_number':5324,'multiline':False]['text':' expand ":syn spell" arguments','line_number':5325,'multiline':False]['text':' expand ":syn sync" arguments','line_number':5326,'multiline':False]['text':' expand ":syn list @cluster" arguments','line_number':5327,'multiline':False]['text':' Reset include_link, include_default, include_none to 0.','line_number':5330,'multiline':False]['text':' Called when we are done expanding.','line_number':5331,'multiline':False]['text':' Handle command line completion for :match and :echohl command: Add "None"','line_number':5337,'multiline':False]['text':' as highlight group.','line_number':5338,'multiline':False]['text':' Handle command line completion for :syntax command.','line_number':5346,'multiline':False]['text':' Default: expand subcommands.','line_number':5349,'multiline':False]['text':' (part of) subcommand already typed','line_number':5360,'multiline':False]['text':' past first world','line_number':5366,'multiline':False]['text':' Function given to ExpandGeneric() to obtain the list syntax names for','line_number':5392,'multiline':False]['text':' expansion.','line_number':5393,'multiline':False]['text':'/ Function called for expression evaluation: get syntax ID at file position.','line_number':5427,'multiline':False]['text':'/','line_number':5428,'multiline':False]['text':'/ @param trans       remove transparency','line_number':5429,'multiline':False]['text':'/ @param spellp      return: can do spell checking','line_number':5430,'multiline':False]['text':'/ @param keep_state  keep state of char at "col"','line_number':5431,'multiline':False]['text':' When the position is not after the current position and in the same','line_number':5434,'multiline':False]['text':' line of the same window with the same buffer, need to restart parsing.','line_number':5435,'multiline':False]['text':' next_match may not be correct when moving around, e.g. with the','line_number':5439,'multiline':False]['text':' "skip" expression in searchpair()','line_number':5440,'multiline':False]['text':' Get extra information about the syntax item.  Must be called right after','line_number':5449,'multiline':False]['text':' get_syntax_attr().','line_number':5450,'multiline':False]['text':' Stores the current item sequence nr in "*seqnrp".','line_number':5451,'multiline':False]['text':' Returns the current flags.','line_number':5452,'multiline':False]['text':'/ Get the sequence number of the concealed file position.','line_number':5459,'multiline':False]['text':'/','line_number':5460,'multiline':False]['text':'/ @return seqnr if the file position is concealed, 0 otherwise.','line_number':5461,'multiline':False]['text':' Return conceal substitution character','line_number':5475,'multiline':False]['text':' Return the syntax ID at position "i" in the current stack.','line_number':5481,'multiline':False]['text':' The caller must have called syn_get_id() before to fill the stack.','line_number':5482,'multiline':False]['text':' Returns -1 when "i" is out of range.','line_number':5483,'multiline':False]['text':' Need to invalidate the state, because we didn't properly finish it','line_number':5487,'multiline':False]['text':' for the last character, "keep_state" was true.','line_number':5488,'multiline':False]['text':'/ Function called to get folding level for line "lnum" in window "wp".','line_number':5507,'multiline':False]['text':' Return quickly when there are no fold items at all.','line_number':5512,'multiline':False]['text':' Start with the fold level at the start of the line.','line_number':5518,'multiline':False]['text':' Find the lowest fold level that is followed by a higher one.','line_number':5522,'multiline':False]['text':' ":syntime".','line_number':5546,'multiline':False]['text':' Clear the syntax timing for the current buffer.','line_number':5570,'multiline':False]['text':' Function given to ExpandGeneric() to obtain the possible arguments of the','line_number':5585,'multiline':False]['text':' ":syntime {on,off,clear,report}" command.','line_number':5586,'multiline':False]['text':' Clear the syntax timing for the current buffer.','line_number':5610,'multiline':False]['text':' Sort on total time. Skip if there are no items to avoid passing NULL','line_number':5641,'multiline':False]['text':' pointer to qsort().','line_number':5642,'multiline':False]['text':' make sure there is always a separating space','line_number':5654,'multiline':False]['text':' will wrap anyway','line_number':5674,'multiline':False]