['text':' Some of this code was adapted from 'if_py_both.h' from the original','line_number':1,'multiline':False]['text':' vim source','line_number':2,'multiline':False]['text':'/ \defgroup api-buffer','line_number':46,'multiline':False]['text':'/','line_number':47,'multiline':False]['text':'/ \brief For more information on buffers, see |buffers|','line_number':48,'multiline':False]['text':'/','line_number':49,'multiline':False]['text':'/ Unloaded Buffers: ~','line_number':50,'multiline':False]['text':'/','line_number':51,'multiline':False]['text':'/ Buffers may be unloaded by the |:bunload| command or the buffer's','line_number':52,'multiline':False]['text':'/ |'bufhidden'| option. When a buffer is unloaded its file contents are freed','line_number':53,'multiline':False]['text':'/ from memory and vim cannot operate on the buffer lines until it is reloaded','line_number':54,'multiline':False]['text':'/ (usually by opening the buffer again in a new window). API methods such as','line_number':55,'multiline':False]['text':'/ |nvim_buf_get_lines()| and |nvim_buf_line_count()| will be affected.','line_number':56,'multiline':False]['text':'/','line_number':57,'multiline':False]['text':'/ You can use |nvim_buf_is_loaded()| or |nvim_buf_line_count()| to check','line_number':58,'multiline':False]['text':'/ whether a buffer is loaded.','line_number':59,'multiline':False]['text':'/ Returns the number of lines in the given buffer.','line_number':61,'multiline':False]['text':'/','line_number':62,'multiline':False]['text':'/ @param buffer   Buffer handle, or 0 for current buffer','line_number':63,'multiline':False]['text':'/ @param[out] err Error details, if any','line_number':64,'multiline':False]['text':'/ @return Line count, or 0 for unloaded buffer. |api-buffer|','line_number':65,'multiline':False]['text':' return sentinel value if the buffer isn't loaded','line_number':75,'multiline':False]['text':'/ Activates buffer-update events on a channel, or as Lua callbacks.','line_number':83,'multiline':False]['text':'/','line_number':84,'multiline':False]['text':'/ Example (Lua): capture buffer updates in a global `events` variable','line_number':85,'multiline':False]['text':'/ (use "vim.print(events)" to see its contents):','line_number':86,'multiline':False]['text':'/','line_number':87,'multiline':False]['text':'/ ```lua','line_number':88,'multiline':False]['text':'/ events = {}','line_number':89,'multiline':False]['text':'/ vim.api.nvim_buf_attach(0, false, {','line_number':90,'multiline':False]['text':'/   on_lines = function(...)','line_number':91,'multiline':False]['text':'/     table.insert(events, {...})','line_number':92,'multiline':False]['text':'/   end,','line_number':93,'multiline':False]['text':'/ })','line_number':94,'multiline':False]['text':'/ ```','line_number':95,'multiline':False]['text':'/','line_number':96,'multiline':False]['text':'/ @see |nvim_buf_detach()|','line_number':97,'multiline':False]['text':'/ @see |api-buffer-updates-lua|','line_number':98,'multiline':False]['text':'/','line_number':99,'multiline':False]['text':'/ @param channel_id','line_number':100,'multiline':False]['text':'/ @param buffer Buffer handle, or 0 for current buffer','line_number':101,'multiline':False]['text':'/ @param send_buffer True if the initial notification should contain the','line_number':102,'multiline':False]['text':'/        whole buffer: first notification will be `nvim_buf_lines_event`.','line_number':103,'multiline':False]['text':'/        Else the first notification will be `nvim_buf_changedtick_event`.','line_number':104,'multiline':False]['text':'/        Not for Lua callbacks.','line_number':105,'multiline':False]['text':'/ @param  opts  Optional parameters.','line_number':106,'multiline':False]['text':'/             - on_lines: Lua callback invoked on change.','line_number':107,'multiline':False]['text':'/               Return `true` to detach. Args:','line_number':108,'multiline':False]['text':'/               - the string "lines"','line_number':109,'multiline':False]['text':'/               - buffer handle','line_number':110,'multiline':False]['text':'/               - b:changedtick','line_number':111,'multiline':False]['text':'/               - first line that changed (zero-indexed)','line_number':112,'multiline':False]['text':'/               - last line that was changed','line_number':113,'multiline':False]['text':'/               - last line in the updated range','line_number':114,'multiline':False]['text':'/               - byte count of previous contents','line_number':115,'multiline':False]['text':'/               - deleted_codepoints (if `utf_sizes` is true)','line_number':116,'multiline':False]['text':'/               - deleted_codeunits (if `utf_sizes` is true)','line_number':117,'multiline':False]['text':'/             - on_bytes: Lua callback invoked on change.','line_number':118,'multiline':False]['text':'/               This callback receives more granular information about the','line_number':119,'multiline':False]['text':'/               change compared to on_lines.','line_number':120,'multiline':False]['text':'/               Return `true` to detach.','line_number':121,'multiline':False]['text':'/               Args:','line_number':122,'multiline':False]['text':'/               - the string "bytes"','line_number':123,'multiline':False]['text':'/               - buffer handle','line_number':124,'multiline':False]['text':'/               - b:changedtick','line_number':125,'multiline':False]['text':'/               - start row of the changed text (zero-indexed)','line_number':126,'multiline':False]['text':'/               - start column of the changed text','line_number':127,'multiline':False]['text':'/               - byte offset of the changed text (from the start of','line_number':128,'multiline':False]['text':'/                   the buffer)','line_number':129,'multiline':False]['text':'/               - old end row of the changed text','line_number':130,'multiline':False]['text':'/               - old end column of the changed text','line_number':131,'multiline':False]['text':'/               - old end byte length of the changed text','line_number':132,'multiline':False]['text':'/               - new end row of the changed text','line_number':133,'multiline':False]['text':'/               - new end column of the changed text','line_number':134,'multiline':False]['text':'/               - new end byte length of the changed text','line_number':135,'multiline':False]['text':'/             - on_changedtick: Lua callback invoked on changedtick','line_number':136,'multiline':False]['text':'/               increment without text change. Args:','line_number':137,'multiline':False]['text':'/               - the string "changedtick"','line_number':138,'multiline':False]['text':'/               - buffer handle','line_number':139,'multiline':False]['text':'/               - b:changedtick','line_number':140,'multiline':False]['text':'/             - on_detach: Lua callback invoked on detach. Args:','line_number':141,'multiline':False]['text':'/               - the string "detach"','line_number':142,'multiline':False]['text':'/               - buffer handle','line_number':143,'multiline':False]['text':'/             - on_reload: Lua callback invoked on reload. The entire buffer','line_number':144,'multiline':False]['text':'/                          content should be considered changed. Args:','line_number':145,'multiline':False]['text':'/               - the string "reload"','line_number':146,'multiline':False]['text':'/               - buffer handle','line_number':147,'multiline':False]['text':'/             - utf_sizes: include UTF-32 and UTF-16 size of the replaced','line_number':148,'multiline':False]['text':'/               region, as args to `on_lines`.','line_number':149,'multiline':False]['text':'/             - preview: also attach to command preview (i.e. 'inccommand')','line_number':150,'multiline':False]['text':'/               events.','line_number':151,'multiline':False]['text':'/ @param[out] err Error details, if any','line_number':152,'multiline':False]['text':'/ @return False if attach failed (invalid parameter, or buffer isn't loaded);','line_number':153,'multiline':False]['text':'/         otherwise True. TODO: LUA_API_NO_EVAL','line_number':154,'multiline':False]['text':'/ Deactivates buffer-update events on the channel.','line_number':201,'multiline':False]['text':'/','line_number':202,'multiline':False]['text':'/ @see |nvim_buf_attach()|','line_number':203,'multiline':False]['text':'/ @see |api-lua-detach| for detaching Lua callbacks','line_number':204,'multiline':False]['text':'/','line_number':205,'multiline':False]['text':'/ @param channel_id','line_number':206,'multiline':False]['text':'/ @param buffer Buffer handle, or 0 for current buffer','line_number':207,'multiline':False]['text':'/ @param[out] err Error details, if any','line_number':208,'multiline':False]['text':'/ @return False if detach failed (because the buffer isn't loaded);','line_number':209,'multiline':False]['text':'/         otherwise True.','line_number':210,'multiline':False]['text':'/ Gets a line-range from the buffer.','line_number':237,'multiline':False]['text':'/','line_number':238,'multiline':False]['text':'/ Indexing is zero-based, end-exclusive. Negative indices are interpreted','line_number':239,'multiline':False]['text':'/ as length+1+index: -1 refers to the index past the end. So to get the','line_number':240,'multiline':False]['text':'/ last element use start=-2 and end=-1.','line_number':241,'multiline':False]['text':'/','line_number':242,'multiline':False]['text':'/ Out-of-bounds indices are clamped to the nearest valid value, unless','line_number':243,'multiline':False]['text':'/ `strict_indexing` is set.','line_number':244,'multiline':False]['text':'/','line_number':245,'multiline':False]['text':'/ @param channel_id','line_number':246,'multiline':False]['text':'/ @param buffer           Buffer handle, or 0 for current buffer','line_number':247,'multiline':False]['text':'/ @param start            First line index','line_number':248,'multiline':False]['text':'/ @param end              Last line index, exclusive','line_number':249,'multiline':False]['text':'/ @param strict_indexing  Whether out-of-bounds should be an error.','line_number':250,'multiline':False]['text':'/ @param[out] err         Error details, if any','line_number':251,'multiline':False]['text':'/ @return Array of lines, or empty array for unloaded buffer.','line_number':252,'multiline':False]['text':' return sentinel value if the buffer isn't loaded','line_number':269,'multiline':False]['text':' Return 0-length array','line_number':283,'multiline':False]['text':'/ Sets (replaces) a line-range in the buffer.','line_number':305,'multiline':False]['text':'/','line_number':306,'multiline':False]['text':'/ Indexing is zero-based, end-exclusive. Negative indices are interpreted','line_number':307,'multiline':False]['text':'/ as length+1+index: -1 refers to the index past the end. So to change','line_number':308,'multiline':False]['text':'/ or delete the last element use start=-2 and end=-1.','line_number':309,'multiline':False]['text':'/','line_number':310,'multiline':False]['text':'/ To insert lines at a given index, set `start` and `end` to the same index.','line_number':311,'multiline':False]['text':'/ To delete a range of lines, set `replacement` to an empty array.','line_number':312,'multiline':False]['text':'/','line_number':313,'multiline':False]['text':'/ Out-of-bounds indices are clamped to the nearest valid value, unless','line_number':314,'multiline':False]['text':'/ `strict_indexing` is set.','line_number':315,'multiline':False]['text':'/','line_number':316,'multiline':False]['text':'/ @see |nvim_buf_set_text()|','line_number':317,'multiline':False]['text':'/','line_number':318,'multiline':False]['text':'/ @param channel_id','line_number':319,'multiline':False]['text':'/ @param buffer           Buffer handle, or 0 for current buffer','line_number':320,'multiline':False]['text':'/ @param start            First line index','line_number':321,'multiline':False]['text':'/ @param end              Last line index, exclusive','line_number':322,'multiline':False]['text':'/ @param strict_indexing  Whether out-of-bounds should be an error.','line_number':323,'multiline':False]['text':'/ @param replacement      Array of lines to use as replacement','line_number':324,'multiline':False]['text':'/ @param[out] err         Error details, if any','line_number':325,'multiline':False]['text':' load buffer first if it's not loaded','line_number':337,'multiline':False]['text':' lines added to text, can be negative','line_number':363,'multiline':False]['text':' Fill lines[i] with l's contents. Convert NULs to newlines as required by','line_number':369,'multiline':False]['text':' NL-used-for-NUL.','line_number':370,'multiline':False]['text':' If the size of the range is reducing (ie, new_len < old_len) we','line_number':389,'multiline':False]['text':' need to delete some old_len. We do this at the start, by','line_number':390,'multiline':False]['text':' repeatedly deleting line "start".','line_number':391,'multiline':False]['text':' For as long as possible, replace the existing old_len with the','line_number':404,'multiline':False]['text':' new old_len. This is a more efficient operation, as it requires','line_number':405,'multiline':False]['text':' less memory allocation and freeing.','line_number':406,'multiline':False]['text':' Mark lines that haven't been passed to the buffer as they need','line_number':422,'multiline':False]['text':' to be freed later','line_number':423,'multiline':False]['text':' Now we may need to insert the remaining new old_len','line_number':427,'multiline':False]['text':' Same as with replacing, but we also need to free lines','line_number':442,'multiline':False]['text':' Adjust marks. Invalidate any which lie in the','line_number':448,'multiline':False]['text':' changed range, and move any in the remainder of the buffer.','line_number':449,'multiline':False]['text':'/ Sets (replaces) a range in the buffer','line_number':475,'multiline':False]['text':'/','line_number':476,'multiline':False]['text':'/ This is recommended over |nvim_buf_set_lines()| when only modifying parts of','line_number':477,'multiline':False]['text':'/ a line, as extmarks will be preserved on non-modified parts of the touched','line_number':478,'multiline':False]['text':'/ lines.','line_number':479,'multiline':False]['text':'/','line_number':480,'multiline':False]['text':'/ Indexing is zero-based. Row indices are end-inclusive, and column indices','line_number':481,'multiline':False]['text':'/ are end-exclusive.','line_number':482,'multiline':False]['text':'/','line_number':483,'multiline':False]['text':'/ To insert text at a given `(row, column)` location, use `start_row = end_row','line_number':484,'multiline':False]['text':'/ = row` and `start_col = end_col = col`. To delete the text in a range, use','line_number':485,'multiline':False]['text':'/ `replacement = {}`.','line_number':486,'multiline':False]['text':'/','line_number':487,'multiline':False]['text':'/ Prefer |nvim_buf_set_lines()| if you are only adding or deleting entire lines.','line_number':488,'multiline':False]['text':'/','line_number':489,'multiline':False]['text':'/ Prefer |nvim_put()| if you want to insert text at the cursor position.','line_number':490,'multiline':False]['text':'/','line_number':491,'multiline':False]['text':'/ @see |nvim_buf_set_lines()|','line_number':492,'multiline':False]['text':'/ @see |nvim_put()|','line_number':493,'multiline':False]['text':'/','line_number':494,'multiline':False]['text':'/ @param channel_id','line_number':495,'multiline':False]['text':'/ @param buffer           Buffer handle, or 0 for current buffer','line_number':496,'multiline':False]['text':'/ @param start_row        First line index','line_number':497,'multiline':False]['text':'/ @param start_col        Starting column (byte offset) on first line','line_number':498,'multiline':False]['text':'/ @param end_row          Last line index, inclusive','line_number':499,'multiline':False]['text':'/ @param end_col          Ending column (byte offset) on last line, exclusive','line_number':500,'multiline':False]['text':'/ @param replacement      Array of lines to use as replacement','line_number':501,'multiline':False]['text':'/ @param[out] err         Error details, if any','line_number':502,'multiline':False]['text':' load buffer first if it's not loaded','line_number':519,'multiline':False]['text':' check range is ordered and everything!','line_number':529,'multiline':False]['text':' start_row, end_row within buffer len (except add text past the end?)','line_number':530,'multiline':False]['text':' Another call to ml_get_buf() may free the line, so make a copy.','line_number':544,'multiline':False]['text':' Another call to ml_get_buf() may free the line, so make a copy.','line_number':552,'multiline':False]['text':' calculate byte size of old region before it gets modified/deleted','line_number':575,'multiline':False]['text':' Fill lines[i] with l's contents. Convert NULs to newlines as required by','line_number':617,'multiline':False]['text':' NL-used-for-NUL.','line_number':618,'multiline':False]['text':' Small note about undo states: unlike set_lines, we want to save the','line_number':635,'multiline':False]['text':' undo state of one past the end_row, since end_row is inclusive.','line_number':636,'multiline':False]['text':' lines added to text, can be negative','line_number':642,'multiline':False]['text':' If the size of the range is reducing (ie, new_len < old_len) we','line_number':645,'multiline':False]['text':' need to delete some old_len. We do this at the start, by','line_number':646,'multiline':False]['text':' repeatedly deleting line "start".','line_number':647,'multiline':False]['text':' For as long as possible, replace the existing old_len with the','line_number':660,'multiline':False]['text':' new old_len. This is a more efficient operation, as it requires','line_number':661,'multiline':False]['text':' less memory allocation and freeing.','line_number':662,'multiline':False]['text':' Mark lines that haven't been passed to the buffer as they need','line_number':675,'multiline':False]['text':' to be freed later','line_number':676,'multiline':False]['text':' Now we may need to insert the remaining new old_len','line_number':680,'multiline':False]['text':' Same as with replacing, but we also need to free lines','line_number':693,'multiline':False]['text':' Adjust marks. Invalidate any which lie in the','line_number':702,'multiline':False]['text':' changed range, and move any in the remainder of the buffer.','line_number':703,'multiline':False]['text':' Do not adjust any cursors. need to use column-aware logic (below)','line_number':704,'multiline':False]['text':'/ Gets a range from the buffer.','line_number':739,'multiline':False]['text':'/','line_number':740,'multiline':False]['text':'/ This differs from |nvim_buf_get_lines()| in that it allows retrieving only','line_number':741,'multiline':False]['text':'/ portions of a line.','line_number':742,'multiline':False]['text':'/','line_number':743,'multiline':False]['text':'/ Indexing is zero-based. Row indices are end-inclusive, and column indices','line_number':744,'multiline':False]['text':'/ are end-exclusive.','line_number':745,'multiline':False]['text':'/','line_number':746,'multiline':False]['text':'/ Prefer |nvim_buf_get_lines()| when retrieving entire lines.','line_number':747,'multiline':False]['text':'/','line_number':748,'multiline':False]['text':'/ @param channel_id','line_number':749,'multiline':False]['text':'/ @param buffer     Buffer handle, or 0 for current buffer','line_number':750,'multiline':False]['text':'/ @param start_row  First line index','line_number':751,'multiline':False]['text':'/ @param start_col  Starting column (byte offset) on first line','line_number':752,'multiline':False]['text':'/ @param end_row    Last line index, inclusive','line_number':753,'multiline':False]['text':'/ @param end_col    Ending column (byte offset) on last line, exclusive','line_number':754,'multiline':False]['text':'/ @param opts       Optional parameters. Currently unused.','line_number':755,'multiline':False]['text':'/ @param[out] err   Error details, if any','line_number':756,'multiline':False]['text':'/ @return Array of lines, or empty array for unloaded buffer.','line_number':757,'multiline':False]['text':' return sentinel value if the buffer isn't loaded','line_number':773,'multiline':False]['text':' nvim_buf_get_lines doesn't care if the start row is greater than the end','line_number':786,'multiline':False]['text':' row (it will just return an empty array), but nvim_buf_get_text does in','line_number':787,'multiline':False]['text':' order to maintain symmetry with nvim_buf_set_text.','line_number':788,'multiline':False]['text':'/ Returns the byte offset of a line (0-indexed). |api-indexing|','line_number':840,'multiline':False]['text':'/','line_number':841,'multiline':False]['text':'/ Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is one byte.','line_number':842,'multiline':False]['text':'/ 'fileformat' and 'fileencoding' are ignored. The line index just after the','line_number':843,'multiline':False]['text':'/ last line gives the total byte-count of the buffer. A final EOL byte is','line_number':844,'multiline':False]['text':'/ counted if it would be written, see 'eol'.','line_number':845,'multiline':False]['text':'/','line_number':846,'multiline':False]['text':'/ Unlike |line2byte()|, throws error for out-of-bounds indexing.','line_number':847,'multiline':False]['text':'/ Returns -1 for unloaded buffer.','line_number':848,'multiline':False]['text':'/','line_number':849,'multiline':False]['text':'/ @param buffer     Buffer handle, or 0 for current buffer','line_number':850,'multiline':False]['text':'/ @param index      Line index','line_number':851,'multiline':False]['text':'/ @param[out] err   Error details, if any','line_number':852,'multiline':False]['text':'/ @return Integer byte offset, or -1 for unloaded buffer.','line_number':853,'multiline':False]['text':' return sentinel value if the buffer isn't loaded','line_number':862,'multiline':False]['text':'/ Gets a buffer-scoped (b:) variable.','line_number':874,'multiline':False]['text':'/','line_number':875,'multiline':False]['text':'/ @param buffer     Buffer handle, or 0 for current buffer','line_number':876,'multiline':False]['text':'/ @param name       Variable name','line_number':877,'multiline':False]['text':'/ @param[out] err   Error details, if any','line_number':878,'multiline':False]['text':'/ @return Variable value','line_number':879,'multiline':False]['text':'/ Gets a changed tick of a buffer','line_number':892,'multiline':False]['text':'/','line_number':893,'multiline':False]['text':'/ @param[in]  buffer  Buffer handle, or 0 for current buffer','line_number':894,'multiline':False]['text':'/ @param[out] err     Error details, if any','line_number':895,'multiline':False]['text':'/','line_number':896,'multiline':False]['text':'/ @return `b:changedtick` value.','line_number':897,'multiline':False]['text':'/ Gets a list of buffer-local |mapping| definitions.','line_number':910,'multiline':False]['text':'/','line_number':911,'multiline':False]['text':'/ @param  mode       Mode short-name ("n", "i", "v", ...)','line_number':912,'multiline':False]['text':'/ @param  buffer     Buffer handle, or 0 for current buffer','line_number':913,'multiline':False]['text':'/ @param[out]  err   Error details, if any','line_number':914,'multiline':False]['text':'/ @returns Array of |maparg()|-like dictionaries describing mappings.','line_number':915,'multiline':False]['text':'/          The "buffer" key holds the associated buffer handle.','line_number':916,'multiline':False]['text':'/ Sets a buffer-local |mapping| for the given mode.','line_number':929,'multiline':False]['text':'/','line_number':930,'multiline':False]['text':'/ @see |nvim_set_keymap()|','line_number':931,'multiline':False]['text':'/','line_number':932,'multiline':False]['text':'/ @param  buffer  Buffer handle, or 0 for current buffer','line_number':933,'multiline':False]['text':'/ Unmaps a buffer-local |mapping| for the given mode.','line_number':941,'multiline':False]['text':'/','line_number':942,'multiline':False]['text':'/ @see |nvim_del_keymap()|','line_number':943,'multiline':False]['text':'/','line_number':944,'multiline':False]['text':'/ @param  buffer  Buffer handle, or 0 for current buffer','line_number':945,'multiline':False]['text':'/ Sets a buffer-scoped (b:) variable','line_number':953,'multiline':False]['text':'/','line_number':954,'multiline':False]['text':'/ @param buffer     Buffer handle, or 0 for current buffer','line_number':955,'multiline':False]['text':'/ @param name       Variable name','line_number':956,'multiline':False]['text':'/ @param value      Variable value','line_number':957,'multiline':False]['text':'/ @param[out] err   Error details, if any','line_number':958,'multiline':False]['text':'/ Removes a buffer-scoped (b:) variable','line_number':971,'multiline':False]['text':'/','line_number':972,'multiline':False]['text':'/ @param buffer     Buffer handle, or 0 for current buffer','line_number':973,'multiline':False]['text':'/ @param name       Variable name','line_number':974,'multiline':False]['text':'/ @param[out] err   Error details, if any','line_number':975,'multiline':False]['text':'/ Gets the full file name for the buffer','line_number':988,'multiline':False]['text':'/','line_number':989,'multiline':False]['text':'/ @param buffer     Buffer handle, or 0 for current buffer','line_number':990,'multiline':False]['text':'/ @param[out] err   Error details, if any','line_number':991,'multiline':False]['text':'/ @return Buffer name','line_number':992,'multiline':False]['text':'/ Sets the full file name for a buffer','line_number':1006,'multiline':False]['text':'/','line_number':1007,'multiline':False]['text':'/ @param buffer     Buffer handle, or 0 for current buffer','line_number':1008,'multiline':False]['text':'/ @param name       Buffer name','line_number':1009,'multiline':False]['text':'/ @param[out] err   Error details, if any','line_number':1010,'multiline':False]['text':' Using aucmd_*: autocommands will be executed by rename_buffer','line_number':1022,'multiline':False]['text':'/ Checks if a buffer is valid and loaded. See |api-buffer| for more info','line_number':1037,'multiline':False]['text':'/ about unloaded buffers.','line_number':1038,'multiline':False]['text':'/','line_number':1039,'multiline':False]['text':'/ @param buffer Buffer handle, or 0 for current buffer','line_number':1040,'multiline':False]['text':'/ @return true if the buffer is valid and loaded, false otherwise.','line_number':1041,'multiline':False]['text':'/ Deletes the buffer. See |:bwipeout|','line_number':1051,'multiline':False]['text':'/','line_number':1052,'multiline':False]['text':'/ @param buffer Buffer handle, or 0 for current buffer','line_number':1053,'multiline':False]['text':'/ @param opts  Optional parameters. Keys:','line_number':1054,'multiline':False]['text':'/          - force:  Force deletion and ignore unsaved changes.','line_number':1055,'multiline':False]['text':'/          - unload: Unloaded only, do not delete. See |:bunload|','line_number':1056,'multiline':False]['text':'/ Checks if a buffer is valid.','line_number':1083,'multiline':False]['text':'/','line_number':1084,'multiline':False]['text':'/ @note Even if a buffer is valid it may have been unloaded. See |api-buffer|','line_number':1085,'multiline':False]['text':'/ for more info about unloaded buffers.','line_number':1086,'multiline':False]['text':'/','line_number':1087,'multiline':False]['text':'/ @param buffer Buffer handle, or 0 for current buffer','line_number':1088,'multiline':False]['text':'/ @return true if the buffer is valid, false otherwise.','line_number':1089,'multiline':False]['text':'/ Deletes a named mark in the buffer. See |mark-motions|.','line_number':1099,'multiline':False]['text':'/','line_number':1100,'multiline':False]['text':'/ @note only deletes marks set in the buffer, if the mark is not set','line_number':1101,'multiline':False]['text':'/ in the buffer it will return false.','line_number':1102,'multiline':False]['text':'/ @param buffer     Buffer to set the mark on','line_number':1103,'multiline':False]['text':'/ @param name       Mark name','line_number':1104,'multiline':False]['text':'/ @return true if the mark was deleted, else false.','line_number':1105,'multiline':False]['text':'/ @see |nvim_buf_set_mark()|','line_number':1106,'multiline':False]['text':'/ @see |nvim_del_mark()|','line_number':1107,'multiline':False]['text':' fm is NULL when there's no mark with the given name','line_number':1124,'multiline':False]['text':' mark.lnum is 0 when the mark is not valid in the buffer, or is not set.','line_number':1129,'multiline':False]['text':' since the mark belongs to the buffer delete it.','line_number':1131,'multiline':False]['text':'/ Sets a named mark in the given buffer, all marks are allowed','line_number':1138,'multiline':False]['text':'/ file/uppercase, visual, last change, etc. See |mark-motions|.','line_number':1139,'multiline':False]['text':'/','line_number':1140,'multiline':False]['text':'/ Marks are (1,0)-indexed. |api-indexing|','line_number':1141,'multiline':False]['text':'/','line_number':1142,'multiline':False]['text':'/ @note Passing 0 as line deletes the mark','line_number':1143,'multiline':False]['text':'/','line_number':1144,'multiline':False]['text':'/ @param buffer     Buffer to set the mark on','line_number':1145,'multiline':False]['text':'/ @param name       Mark name','line_number':1146,'multiline':False]['text':'/ @param line       Line number','line_number':1147,'multiline':False]['text':'/ @param col        Column/row number','line_number':1148,'multiline':False]['text':'/ @param opts       Optional parameters. Reserved for future use.','line_number':1149,'multiline':False]['text':'/ @return true if the mark was set, else false.','line_number':1150,'multiline':False]['text':'/ @see |nvim_buf_del_mark()|','line_number':1151,'multiline':False]['text':'/ @see |nvim_buf_get_mark()|','line_number':1152,'multiline':False]['text':'/ Returns a `(row,col)` tuple representing the position of the named mark.','line_number':1173,'multiline':False]['text':'/ "End of line" column position is returned as |v:maxcol| (big number).','line_number':1174,'multiline':False]['text':'/ See |mark-motions|.','line_number':1175,'multiline':False]['text':'/','line_number':1176,'multiline':False]['text':'/ Marks are (1,0)-indexed. |api-indexing|','line_number':1177,'multiline':False]['text':'/','line_number':1178,'multiline':False]['text':'/ @param buffer     Buffer handle, or 0 for current buffer','line_number':1179,'multiline':False]['text':'/ @param name       Mark name','line_number':1180,'multiline':False]['text':'/ @param[out] err   Error details, if any','line_number':1181,'multiline':False]['text':'/ @return (row, col) tuple, (0, 0) if the mark is not set, or is an','line_number':1182,'multiline':False]['text':'/ uppercase/file mark set in another buffer.','line_number':1183,'multiline':False]['text':'/ @see |nvim_buf_set_mark()|','line_number':1184,'multiline':False]['text':'/ @see |nvim_buf_del_mark()|','line_number':1185,'multiline':False]['text':' (0, 0) uppercase/file mark set in another buffer.','line_number':1208,'multiline':False]['text':'/ call a function with buffer as temporary current buffer','line_number':1222,'multiline':False]['text':'/','line_number':1223,'multiline':False]['text':'/ This temporarily switches current buffer to "buffer".','line_number':1224,'multiline':False]['text':'/ If the current window already shows "buffer", the window is not switched','line_number':1225,'multiline':False]['text':'/ If a window inside the current tabpage (including a float) already shows the','line_number':1226,'multiline':False]['text':'/ buffer One of these windows will be set as current window temporarily.','line_number':1227,'multiline':False]['text':'/ Otherwise a temporary scratch window (called the "autocmd window" for','line_number':1228,'multiline':False]['text':'/ historical reasons) will be used.','line_number':1229,'multiline':False]['text':'/','line_number':1230,'multiline':False]['text':'/ This is useful e.g. to call Vimscript functions that only work with the','line_number':1231,'multiline':False]['text':'/ current buffer/window currently, like |termopen()|.','line_number':1232,'multiline':False]['text':'/','line_number':1233,'multiline':False]['text':'/ @param buffer     Buffer handle, or 0 for current buffer','line_number':1234,'multiline':False]['text':'/ @param fun        Function to call inside the buffer (currently Lua callable','line_number':1235,'multiline':False]['text':'/                   only)','line_number':1236,'multiline':False]['text':'/ @param[out] err   Error details, if any','line_number':1237,'multiline':False]['text':'/ @return           Return value of function. NB: will deepcopy Lua values','line_number':1238,'multiline':False]['text':'/                   currently, use upvalues to send Lua references in and out.','line_number':1239,'multiline':False]['text':' Number of times the cached line was flushed.','line_number':1269,'multiline':False]['text':' This should generally not increase while editing the same','line_number':1270,'multiline':False]['text':' line in the same mode.','line_number':1271,'multiline':False]['text':' lnum of current line','line_number':1273,'multiline':False]['text':' whether the line has unflushed changes.','line_number':1275,'multiline':False]['text':' NB: this should be zero at any time API functions are called,','line_number':1277,'multiline':False]['text':' this exists to debug issues','line_number':1278,'multiline':False]['text':' Check if deleting lines made the cursor position invalid.','line_number':1296,'multiline':False]['text':' Changed lines from `lo` to `hi`; added `extra` lines (negative if deleted).','line_number':1297,'multiline':False]['text':' Adjust cursor position if it's in/after the changed lines.','line_number':1301,'multiline':False]['text':'/ Fix cursor position after replacing text','line_number':1313,'multiline':False]['text':'/ between (start_row, start_col) and (end_row, end_col).','line_number':1314,'multiline':False]['text':'/','line_number':1315,'multiline':False]['text':'/ win->w_cursor.lnum is assumed to be >= start_row and <= end_row.','line_number':1316,'multiline':False]['text':' check if cursor is after replaced range or not','line_number':1325,'multiline':False]['text':' if cursor is after replaced range, it's shifted','line_number':1327,'multiline':False]['text':' to keep it's position the same, relative to end_col','line_number':1328,'multiline':False]['text':' if cursor is inside replaced range','line_number':1334,'multiline':False]['text':' and the new range got smaller,','line_number':1335,'multiline':False]['text':' it's shifted to keep it inside the new range','line_number':1336,'multiline':False]['text':'','line_number':1337,'multiline':False]['text':' if cursor is before range or range did not','line_number':1338,'multiline':False]['text':' got smaller, position is not changed','line_number':1339,'multiline':False]['text':' it's easier to work with a single value here.','line_number':1343,'multiline':False]['text':' col and coladd are fixed by a later call','line_number':1344,'multiline':False]['text':' to check_cursor_col_win when necessary','line_number':1345,'multiline':False]['text':' make sure cursor row is in the new row range','line_number':1351,'multiline':False]['text':' don't simply move cursor up, but to the end','line_number':1355,'multiline':False]['text':' of new_end_row, if it's not at or after','line_number':1356,'multiline':False]['text':' it already (in case virtualedit is active)','line_number':1357,'multiline':False]['text':' column might be additionally adjusted below','line_number':1358,'multiline':False]['text':' to keep it inside col range if needed','line_number':1359,'multiline':False]['text':' if cursor is at the last row and','line_number':1366,'multiline':False]['text':' it wasn't after eol before, move it exactly','line_number':1367,'multiline':False]['text':' to end_row_change_end','line_number':1368,'multiline':False]['text':' make sure cursor is inside range, not after it,','line_number':1373,'multiline':False]['text':' except when doing so would move it before new range','line_number':1374,'multiline':False]['text':'/ Initialise a string array either:','line_number':1386,'multiline':False]['text':'/ - on the Lua stack (as a table) (if lstate is not NULL)','line_number':1387,'multiline':False]['text':'/ - as an API array object (if lstate is NULL).','line_number':1388,'multiline':False]['text':'/','line_number':1389,'multiline':False]['text':'/ @param lstate  Lua state. When NULL the Array is initialized instead.','line_number':1390,'multiline':False]['text':'/ @param a       Array to initialize','line_number':1391,'multiline':False]['text':'/ @param size    Size of array','line_number':1392,'multiline':False]['text':'/ Push a string onto either the Lua stack (as a table element) or an API array object.','line_number':1403,'multiline':False]['text':'/','line_number':1404,'multiline':False]['text':'/ For Lua, a table of the correct size must be created first.','line_number':1405,'multiline':False]['text':'/ API array objects must be pre allocated.','line_number':1406,'multiline':False]['text':'/','line_number':1407,'multiline':False]['text':'/ @param lstate      Lua state. When NULL the Array is pushed to instead.','line_number':1408,'multiline':False]['text':'/ @param a           Array to push onto when not using Lua','line_number':1409,'multiline':False]['text':'/ @param s           String to push','line_number':1410,'multiline':False]['text':'/ @param len         Size of string','line_number':1411,'multiline':False]['text':'/ @param idx         0-based index to place s','line_number':1412,'multiline':False]['text':'/ @param replace_nl  Replace newlines ('\n') with null ('\0')','line_number':1413,'multiline':False]['text':' Vim represents NULs as NLs','line_number':1418,'multiline':False]['text':' Vim represents NULs as NLs, but this may confuse clients.','line_number':1433,'multiline':False]['text':'/ Collects `n` buffer lines into array `l` and/or lua_State `lstate`, optionally replacing','line_number':1442,'multiline':False]['text':'/ newlines with NUL.','line_number':1443,'multiline':False]['text':'/','line_number':1444,'multiline':False]['text':'/ @param buf Buffer to get lines from','line_number':1445,'multiline':False]['text':'/ @param n Number of lines to collect','line_number':1446,'multiline':False]['text':'/ @param replace_nl Replace newlines ("\n") with NUL','line_number':1447,'multiline':False]['text':'/ @param start Line number to start from','line_number':1448,'multiline':False]['text':'/ @param start_idx First index to push to','line_number':1449,'multiline':False]['text':'/ @param[out] l If not NULL, Lines are copied here','line_number':1450,'multiline':False]['text':'/ @param[out] lstate If not NULL, Lines are pushed into a table onto the stack','line_number':1451,'multiline':False]['text':'/ @param err[out] Error, if any','line_number':1452,'multiline':False]['text':'/ @return true unless `err` was set','line_number':1453,'multiline':False]