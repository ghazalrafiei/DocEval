['text':' For CUDA_VERSION','line_number':12,'multiline':False]['text':'*
 * The method should_include_kernel_dtype() returns true/false
 * based on whether the switching code for a specific dtype should be
 * included based on build time constants generated from tracing model
 * execution. This method will be implmeneted via code-generation and
 * included in this file when code-gen is ready.
 ','line_number':19,'multiline':True]['text':'kernel_tag_str','line_number':27,'multiline':True]['text':'scalar_type','line_number':28,'multiline':True]['text':' namespace at','line_number':32,'multiline':False]['text':'*
 * In the Facebook internal build (using BUCK), this macro is enabled by
 * passing in -c pt.enable_record_kernel_dtype=1 when building the tracer
 * binary.
 ','line_number':35,'multiline':True]['text':' namespace at','line_number':45,'multiline':False]['text':' namespace detail','line_number':124,'multiline':False]['text':' The AT_DISPATCH_* family of macros provides the ability to','line_number':126,'multiline':False]['text':' conveniently generate specializations of a kernel over all of the','line_number':127,'multiline':False]['text':' dtypes we care about in PyTorch.  We call it "dispatch" because','line_number':128,'multiline':False]['text':' we are "dispatching" to the correct, dtype-specific kernel.','line_number':129,'multiline':False]['text':'','line_number':130,'multiline':False]['text':' A standard usage looks like:','line_number':131,'multiline':False]['text':'','line_number':132,'multiline':False]['text':'      AT_DISPATCH_ALL_TYPES(self.scalar_type(), "op_name", [&] {','line_number':133,'multiline':False]['text':'          // Your code here, with 'scalar_t' now defined to','line_number':134,'multiline':False]['text':'          // be the dtype in question','line_number':135,'multiline':False]['text':'      });','line_number':136,'multiline':False]['text':'','line_number':137,'multiline':False]['text':' There are many variations of this macro, so it's important to','line_number':138,'multiline':False]['text':' understand exactly /which/ dtypes you want to get instantiated, as','line_number':139,'multiline':False]['text':' well as what the "default" set is.','line_number':140,'multiline':False]['text':'','line_number':141,'multiline':False]['text':' The default set of dtypes that are instantiated (e.g., by','line_number':142,'multiline':False]['text':' AT_DISPATCH_ALL_TYPES) are floating point types (float, double),','line_number':143,'multiline':False]['text':' and integral types (int32_t, int64_t, int16_t, int8_t, uint8_t),','line_number':144,'multiline':False]['text':' but NOT booleans (bool), half-precision floats (Half) or','line_number':145,'multiline':False]['text':' complex number (c10::complex<float>, c10::complex<double>).','line_number':146,'multiline':False]['text':' This "cut" is somewhat historical (the default types are the','line_number':147,'multiline':False]['text':' ones that TH historically supported), but it also reflects the','line_number':148,'multiline':False]['text':' fact that the non-default types are "poorly" behaved (booleans','line_number':149,'multiline':False]['text':' are NOT integers mod 2, half precision operations ~essentially','line_number':150,'multiline':False]['text':' don't exist on CPU, complex numbers are an experimental application).','line_number':151,'multiline':False]['text':'','line_number':152,'multiline':False]['text':' Here are the questions you should generally ask to decide which','line_number':153,'multiline':False]['text':' dispatch you want:','line_number':154,'multiline':False]['text':'','line_number':155,'multiline':False]['text':' 1. Is this an integral or floating point specific operation?','line_number':156,'multiline':False]['text':'    (If so, you'll want one of the FLOATING or INTEGRAL macros.)','line_number':157,'multiline':False]['text':'','line_number':158,'multiline':False]['text':' 2. Should half be supported?  (If you're on CPU, the answer is almost','line_number':159,'multiline':False]['text':'    definitely no.  If you do want support, use one of the AND_HALF','line_number':160,'multiline':False]['text':'    macros)','line_number':161,'multiline':False]['text':'','line_number':162,'multiline':False]['text':' Much rarer situations:','line_number':163,'multiline':False]['text':'','line_number':164,'multiline':False]['text':' 3. Should bool be supported?  (You often have to write your kernel','line_number':165,'multiline':False]['text':'    differently if arithmetic operations are involved.)  If so,','line_number':166,'multiline':False]['text':'    Use AT_DISPATCH_ALL_TYPES_AND along with ScalarType::Bool','line_number':167,'multiline':False]['text':'','line_number':168,'multiline':False]['text':' 4. Should complex be supported?  The answer is almost always no,','line_number':169,'multiline':False]['text':'    unless you are working on "generic" code that should work on','line_number':170,'multiline':False]['text':'    all dtypes.','line_number':171,'multiline':False]['text':'','line_number':172,'multiline':False]['text':' Parameters:','line_number':173,'multiline':False]['text':' -----------','line_number':174,'multiline':False]['text':'','line_number':175,'multiline':False]['text':' 1. The NAME argument is a "tag" that is used to trace and then','line_number':176,'multiline':False]['text':'    conditionally compile fragments of the case statements such','line_number':177,'multiline':False]['text':'    that the kernel functions are specialized only for the dtypes','line_number':178,'multiline':False]['text':'    that are needed. The NAME parameter *must* be a build time','line_number':179,'multiline':False]['text':'    const char* (can't be std::string, etc...)','line_number':180,'multiline':False]['text':'','line_number':181,'multiline':False]['text':' Please ensure that the NAME is unique for every implementation','line_number':182,'multiline':False]['text':' or you run the risk of over-including code for the kernel','line_number':183,'multiline':False]['text':' functions. There is no risk of missing out on any code, so','line_number':184,'multiline':False]['text':' it's mostly a risk of a Type-2 error, and not a Type-1 error.','line_number':185,'multiline':False]['text':'','line_number':186,'multiline':False]['text':' Switch-like syntax:','line_number':187,'multiline':False]['text':' -------------------','line_number':188,'multiline':False]['text':' There is also a switch-case like syntax which is useful if a kernel','line_number':189,'multiline':False]['text':' needs to be specialized for particular scalar types','line_number':190,'multiline':False]['text':'','line_number':191,'multiline':False]['text':'      AT_DISPATCH_SWITCH(self.scalar_type(), "op_name",','line_number':192,'multiline':False]['text':'          AT_DISPATCH_CASE_INTEGRAL_TYPES([&] {','line_number':193,'multiline':False]['text':'            op_integral<scalar_t>(iter);','line_number':194,'multiline':False]['text':'          })','line_number':195,'multiline':False]['text':'          AT_DISPATCH_CASE_FLOATING_TYPES([&] {','line_number':196,'multiline':False]['text':'            op_floating<scalar_t>(iter);','line_number':197,'multiline':False]['text':'          })','line_number':198,'multiline':False]['text':'          AT_DISPATCH_CASE(kBool, [&] {','line_number':199,'multiline':False]['text':'            op_bool(iter);','line_number':200,'multiline':False]['text':'          })','line_number':201,'multiline':False]['text':'      );','line_number':202,'multiline':False]['text':'','line_number':203,'multiline':False]['text':' For each AT_DISPATCH_FOO macro, there is a corresponding','line_number':204,'multiline':False]['text':' AT_DISPATCH_CASE_FOO macro which can be used inside of an','line_number':205,'multiline':False]['text':' AT_DISPATCH_SWITCH block.','line_number':206,'multiline':False]['text':' NB: the the_type variable is not used, but we have kept it for','line_number':208,'multiline':False]['text':' backwards compatibility.  It's probably not used by anyone though;','line_number':209,'multiline':False]['text':' but we're just being safe (and it doesn't hurt.)  Note we must','line_number':210,'multiline':False]['text':' use it to shut up warnings about unused store.','line_number':211,'multiline':False]['text':' don't use TYPE again in case it is an expensive or side-effect op ','line_number':217,'multiline':True]['text':' ----------------------------------------------------------------------------','line_number':799,'multiline':False]['text':' DEPRECATED MACROS, DON'T USE THESE','line_number':800,'multiline':False]['text':' ----------------------------------------------------------------------------','line_number':801,'multiline':False]