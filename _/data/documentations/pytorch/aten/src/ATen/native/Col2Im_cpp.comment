['text':' Note [im2col/col2im output padding]','line_number':19,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':20,'multiline':False]['text':' Our implementations of im2col and col2im take both the input height/width as','line_number':21,'multiline':False]['text':' well as a seemingly redundant output height/width.  In principle, you could','line_number':22,'multiline':False]['text':' compute the output height/width by using the convolution shape formulas.  So,','line_number':23,'multiline':False]['text':' what's up with that?','line_number':24,'multiline':False]['text':'','line_number':25,'multiline':False]['text':' The trouble arises when one runs the backward of a transposed convolution','line_number':26,'multiline':False]['text':' with output_padding >= stride.  (BTW, output_padding is known as adj inside','line_number':27,'multiline':False]['text':' THNN.) Let's consider a simple case where we have kernel=2, dilation=2,','line_number':28,'multiline':False]['text':' stride=1, output_padding=1 for a 4x4 input:','line_number':29,'multiline':False]['text':'','line_number':30,'multiline':False]['text':' Input:  X','line_number':31,'multiline':False]['text':'','line_number':32,'multiline':False]['text':' Output: X.X.','line_number':33,'multiline':False]['text':'         ....','line_number':34,'multiline':False]['text':'         X.X.','line_number':35,'multiline':False]['text':'         ....','line_number':36,'multiline':False]['text':'','line_number':37,'multiline':False]['text':' If we compute backwards of output with a standard convolution on the output','line_number':38,'multiline':False]['text':' with the same parameters, we would end up with a 2x2 grad_input (because you','line_number':39,'multiline':False]['text':' can slide the stencil over to the right once and down once).  But that is all','line_number':40,'multiline':False]['text':' out-of-bounds if you're computing backwards for a 1x1 input.','line_number':41,'multiline':False]['text':'','line_number':42,'multiline':False]['text':' "Now Edward," you might say, "the real problem is that you set output_padding','line_number':43,'multiline':False]['text':' >= stride, surely an error should have been raised in this case."  To','line_number':44,'multiline':False]['text':' understand why it is useful to handle this case, we have to understand how we','line_number':45,'multiline':False]['text':' compute the weight gradient of a convolution.  Suppose we have a convolution','line_number':46,'multiline':False]['text':' with kernel=2, stride=2 on a 5x5 input.  Let us see all the contributions of','line_number':47,'multiline':False]['text':' weight[0][0] (which we have labeled w) in the output:','line_number':48,'multiline':False]['text':'','line_number':49,'multiline':False]['text':' Input:  a.b..  Weight: w.','line_number':50,'multiline':False]['text':'         .....          ..','line_number':51,'multiline':False]['text':'         c.d..','line_number':52,'multiline':False]['text':'         .....','line_number':53,'multiline':False]['text':'         .....','line_number':54,'multiline':False]['text':'','line_number':55,'multiline':False]['text':' Output: [ aw+...  bw+... ]','line_number':56,'multiline':False]['text':'         [ cw+...  dw+... ]','line_number':57,'multiline':False]['text':'','line_number':58,'multiline':False]['text':' From this diagram, it easy to see that we can compute the weight gradient','line_number':59,'multiline':False]['text':' by performing a *dilated* convolution between the input and the','line_number':60,'multiline':False]['text':' output gradients with kernel=2, dilation=2, stride=1.  But there's a rub: if','line_number':61,'multiline':False]['text':' we do a dilated convolution directly, we'll end up with a 3x3 weight','line_number':62,'multiline':False]['text':' gradient, when we clearly wanted a 2x2.  So how do we avoid going out','line_number':63,'multiline':False]['text':' of bounds?  We could add a notion of 'output_padding' for non-transposed','line_number':64,'multiline':False]['text':' convolution, but another simple and effective fix is to just accept','line_number':65,'multiline':False]['text':' the desired output size directly, and compute only within those bounds.','line_number':66,'multiline':False]['text':'','line_number':67,'multiline':False]['text':'','line_number':68,'multiline':False]['text':' ALSO do vol2col','line_number':69,'multiline':False]['text':' Force batch','line_number':137,'multiline':False]['text':' namespace','line_number':190,'multiline':False]['text':' namespace native','line_number':218,'multiline':False]['text':' namespace at','line_number':219,'multiline':False]