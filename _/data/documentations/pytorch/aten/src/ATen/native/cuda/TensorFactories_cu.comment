['text':' the default value of `m` equals to `n`','line_number':35,'multiline':False]['text':' See Note [Enabling Deterministic Operations]','line_number':56,'multiline':False]['text':' See Note [Enabling Deterministic Operations]','line_number':82,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ triangle ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':89,'multiline':False]['text':' To find the max integer that does not exceed the root of an int64_t variable,','line_number':92,'multiline':False]['text':' we could use a loop to test one bit at a time, which takes up to 31','line_number':93,'multiline':False]['text':' iterations. This would give the accurate result, but is relatively slow and','line_number':94,'multiline':False]['text':' is an overkill for most cases where double's precision suffice.','line_number':95,'multiline':False]['text':'','line_number':96,'multiline':False]['text':' If we directly use sqrt to calculate the root, the conversion from int64_t','line_number':97,'multiline':False]['text':' to double would lose 11 bits precision.','line_number':98,'multiline':False]['text':'','line_number':99,'multiline':False]['text':' The following solution uses sqrt directly for most cases, and would only','line_number':100,'multiline':False]['text':' special handle it if there is indeed precision loss.','line_number':101,'multiline':False]['text':' potential precision loss could occur here when casting int64_t (63 bits','line_number':106,'multiline':False]['text':' precision) to double (52 bits precision)','line_number':107,'multiline':False]['text':' have to cast double to int64_t, otherwise it would only compare up to the','line_number':111,'multiline':False]['text':' precision of a double variable, ignoring the precision loss','line_number':112,'multiline':False]['text':' handle precision loss by using binary search','line_number':114,'multiline':False]['text':' Use the following math to reduce search space.','line_number':116,'multiline':False]['text':' Suppose z is the accurate result of sqrt(bXb_cX4) without precision loss','line_number':117,'multiline':False]['text':' let d = abs(bXb_cX4 - llsr * llsr), then we have:','line_number':118,'multiline':False]['text':' z = sqrt(bXb_cX4) <= sqrt(llsr * llsr + d) <= llsr + sqrt(d)','line_number':119,'multiline':False]['text':' z = sqrt(bXb_cX4) >= sqrt(llsr * llsr - d) >= llsr - sqrt(d)','line_number':120,'multiline':False]['text':' Hence, it is sufficient to search range [llsr - sqrt(d), llsr + sqrt(d)).','line_number':121,'multiline':False]['text':' And the true value of row would also be with in range,','line_number':122,'multiline':False]['text':'            [res - sqrt(d), res + sqrt(d) + 1)','line_number':123,'multiline':False]['text':' as the denominator would only reduce the precision penalty.','line_number':124,'multiline':False]['text':' l never exceeds (could equal to) the target row index','line_number':127,'multiline':False]['text':' r is always larger than the target row index','line_number':129,'multiline':False]['text':' binary search for the correct answer','line_number':132,'multiline':False]['text':' the loop always compares with 2x, so do it once here','line_number':133,'multiline':False]['text':' for tril:','line_number':136,'multiline':False]['text':'    b = 2f - 1, sign = 1, hence (2f + m - 1) * m / 2','line_number':137,'multiline':False]['text':' for triu:','line_number':138,'multiline':False]['text':'    b = -2f - 1, sign = -1, hence (2f - m + 1) * m / 2','line_number':139,'multiline':False]['text':' f: the number of elements in the first row of the trapezoid.','line_number':152,'multiline':False]['text':' x: the index of the target coordinates ordered by row and then column.','line_number':153,'multiline':False]['text':'','line_number':154,'multiline':False]['text':' View the tril as a top trapezoid stacked on a bottom rectangle. Assume x','line_number':155,'multiline':False]['text':' corresponds to the coordinate (row, col) in the trapezoid, where the row and','line_number':156,'multiline':False]['text':' the col both start from 0, then we have:','line_number':157,'multiline':False]['text':'','line_number':158,'multiline':False]['text':'                   (f + f + row - 1) * row / 2 <= x                       [1]','line_number':159,'multiline':False]['text':'                 (f + f + row) * (row + 1) / 2  > x                       [2]','line_number':160,'multiline':False]['text':'','line_number':161,'multiline':False]['text':' Therefore, row is the maximum integer satisfying the following inequality:','line_number':162,'multiline':False]['text':'','line_number':163,'multiline':False]['text':'                       (row + 2f - 1)row <= 2x','line_number':164,'multiline':False]['text':'                  row^2 + (2f-1)row - 2x <= 0.                            [3]','line_number':165,'multiline':False]['text':'','line_number':166,'multiline':False]['text':' Based on inequality [3], we have the following coefficients for formula of','line_number':167,'multiline':False]['text':' root:','line_number':168,'multiline':False]['text':'                               a = 1','line_number':169,'multiline':False]['text':'                               b = 2f - 1','line_number':170,'multiline':False]['text':'                               c = -2x','line_number':171,'multiline':False]['text':' There are two roots, and we should use the largest integer that does not','line_number':172,'multiline':False]['text':' exceed the root on the right. Intuitively, it is because:','line_number':173,'multiline':False]['text':'  i)  the valid solution range of row is between two roots, as it is <= 0;','line_number':174,'multiline':False]['text':'  ii) as we count in more rows, the total # of elements should always','line_number':175,'multiline':False]['text':'      increase, hence so does the left-hand side row^2 + (2f-1)row - 2x.','line_number':176,'multiline':False]['text':'      Therefore, the valid range of row lies in between the nadir point and','line_number':177,'multiline':False]['text':'      the larger root on the right.','line_number':178,'multiline':False]['text':' Full proof can be derived from inequality [2]. So, we calculate the result','line_number':179,'multiline':False]['text':' coordinate as:','line_number':180,'multiline':False]['text':'','line_number':181,'multiline':False]['text':'                   row = floor((-b + sqrt(b^2 - 4c)) / 2)','line_number':182,'multiline':False]['text':'                   col = x - (f + f + row - 1) * row / 2','line_number':183,'multiline':False]['text':' all statements use 2f, so only calculate it once here.','line_number':187,'multiline':False]['text':' 4 * c = 4 * (-2x) = -8x;','line_number':189,'multiline':False]['text':' f: the number of elements in the first row of the bottom trapezoid.','line_number':194,'multiline':False]['text':' x: the index of the target coordinates ordered by row and then column.','line_number':195,'multiline':False]['text':'','line_number':196,'multiline':False]['text':' View the triu as a top rectangle stacked on a bottom trapezoid, where the','line_number':197,'multiline':False]['text':' trapezoid is upside down. Assume x corresponds to the coordinate (row, col)','line_number':198,'multiline':False]['text':' in the bottom trapezoid, where the row and the col start from 0, then we','line_number':199,'multiline':False]['text':' have:','line_number':200,'multiline':False]['text':'','line_number':201,'multiline':False]['text':'                   (f + f - row + 1) * row / 2 <= x                       [1]','line_number':202,'multiline':False]['text':'                 (f + f - row) * (row + 1) / 2  > x                       [2]','line_number':203,'multiline':False]['text':'','line_number':204,'multiline':False]['text':' Therefore, row is the maximum integer satisfying the following inequality:','line_number':205,'multiline':False]['text':'','line_number':206,'multiline':False]['text':'                       (-row + 2f + 1)row <= 2x','line_number':207,'multiline':False]['text':'                   row^2 - (2f+1)row + 2x >= 0.                           [3]','line_number':208,'multiline':False]['text':'','line_number':209,'multiline':False]['text':' Based on inequality [3], we have the following coefficients for formula of','line_number':210,'multiline':False]['text':' root:','line_number':211,'multiline':False]['text':'                               a = 1','line_number':212,'multiline':False]['text':'                               b = -1 - 2f','line_number':213,'multiline':False]['text':'                               c = 2x','line_number':214,'multiline':False]['text':' There are two roots, and we should use the largest integer that does not','line_number':215,'multiline':False]['text':' exceed the root on the left. Intuitively, it is because:','line_number':216,'multiline':False]['text':'  i)  the valid solution range of row is outside of the two roots, as it is <','line_number':217,'multiline':False]['text':'      > 0;','line_number':218,'multiline':False]['text':'  ii) as we count in more rows, the total # of elements should always','line_number':219,'multiline':False]['text':'      increase, hence so does the left-hand side row^2 - (2f+1)row + 2x.','line_number':220,'multiline':False]['text':'      Therefore, the valid range of row lies to the left of the smaller root','line_number':221,'multiline':False]['text':'      on the left.','line_number':222,'multiline':False]['text':' Full proof can be derived from inequality [2]. So, we calculate the result','line_number':223,'multiline':False]['text':' coordinate as:','line_number':224,'multiline':False]['text':'','line_number':225,'multiline':False]['text':'                   row = floor((-b - sqrt(b^2 - 4c)) / 2)','line_number':226,'multiline':False]['text':'                   col = x - (f + f - row + 1) * row / 2','line_number':227,'multiline':False]['text':' all statements use 2f, so only calculate it once here.','line_number':231,'multiline':False]['text':' 4 * c = 4 * (2x) = 8x;','line_number':233,'multiline':False]['text':' namespace','line_number':238,'multiline':False]['text':' the coordinate is within the top trapezoid','line_number':256,'multiline':False]['text':' the coordinate falls in the bottom rectangle','line_number':259,'multiline':False]['text':' add the height of trapezoid: m_last_row (col) - m_first_row + 1','line_number':261,'multiline':False]['text':' Some Large test cases for the fallback binary search path is disabled by','line_number':272,'multiline':False]['text':' default to speed up CI tests and to avoid OOM error. When modifying the','line_number':273,'multiline':False]['text':' implementation, please enable them in test/test_cuda.py and make sure they','line_number':274,'multiline':False]['text':' pass on your local server.','line_number':275,'multiline':False]['text':' upper bounded by col','line_number':286,'multiline':False]['text':' either 0 or 1','line_number':287,'multiline':False]['text':' using tril_size instead of tensor.numel(), as each thread takes care of','line_number':297,'multiline':False]['text':' two elements in the tensor.','line_number':298,'multiline':False]['text':' the coordinate is within the top rectangle','line_number':332,'multiline':False]['text':' the coordinate falls in the bottom trapezoid','line_number':336,'multiline':False]['text':' Some Large test cases for the fallback binary search path is disabled by','line_number':348,'multiline':False]['text':' default to speed up CI tests and to avoid OOM error. When modifying the','line_number':349,'multiline':False]['text':' implementation, please enable them in test/test_cuda.py and make sure they','line_number':350,'multiline':False]['text':' pass on your local server.','line_number':351,'multiline':False]['text':' # of triu elements in the first row','line_number':361,'multiline':False]['text':' upper bounded by col','line_number':363,'multiline':False]['text':' size of the top rectangle','line_number':366,'multiline':False]['text':' using triu_size instead of tensor.numel(), as each thread takes care of','line_number':375,'multiline':False]['text':' two elements in the tensor.','line_number':376,'multiline':False]['text':' namespace at::native','line_number':397,'multiline':False]