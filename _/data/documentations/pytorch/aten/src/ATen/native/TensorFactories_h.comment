['text':' Different combinations of row, col, and offset can lead to two cases:','line_number':16,'multiline':False]['text':'','line_number':17,'multiline':False]['text':' Case 1 - Trapezoid (Triangle as a special case): row + offset <= col','line_number':18,'multiline':False]['text':'    Example A: offset > 0','line_number':19,'multiline':False]['text':'      1 1 0 0 0','line_number':20,'multiline':False]['text':'      1 1 1 0 0','line_number':21,'multiline':False]['text':'      1 1 1 1 0','line_number':22,'multiline':False]['text':'    Example B: offset <= 0','line_number':23,'multiline':False]['text':'      0 0 0','line_number':24,'multiline':False]['text':'      1 0 0','line_number':25,'multiline':False]['text':'      1 1 0','line_number':26,'multiline':False]['text':'    In this case, we calculate the number of elements in the first row and','line_number':27,'multiline':False]['text':'    last row of the tril respectively, and then compute the tril size.','line_number':28,'multiline':False]['text':'','line_number':29,'multiline':False]['text':' Case 2 - Trapezoid + Rectangle: row + offset > col','line_number':30,'multiline':False]['text':'    Example:','line_number':31,'multiline':False]['text':'      1 1 0','line_number':32,'multiline':False]['text':'      1 1 1','line_number':33,'multiline':False]['text':'      1 1 1','line_number':34,'multiline':False]['text':'    In this case, we first calculate the size of top trapezoid, and then','line_number':35,'multiline':False]['text':'    calculate the size of the bottom rectangle.','line_number':36,'multiline':False]['text':' If either dimension is 0 then the there is no tril','line_number':38,'multiline':False]['text':' number of elements in the first row of the tril','line_number':42,'multiline':False]['text':' upper bounded by col','line_number':44,'multiline':False]['text':' either 0 or 1','line_number':45,'multiline':False]['text':' number of elements in the last row of the tril, bounded by [0, col]','line_number':46,'multiline':False]['text':' number of rows, bounded by [0, row]','line_number':48,'multiline':False]['text':' calculate # of elements in the top trapezoid','line_number':52,'multiline':False]['text':' calculate # of elements in the bottom rectangle if there is any','line_number':55,'multiline':False]['text':' assumes maximum value in created tensor is n-1 (e.g., torch.randperm(n))','line_number':78,'multiline':False]['text':' match defined() to behavior of checks below','line_number':80,'multiline':False]['text':' Ensure sufficient precision for floating point representation.','line_number':84,'multiline':False]['text':' Unlikely to happen, but doesn't hurt to check','line_number':92,'multiline':False]['text':' Called by `empty*` functions when deterministic algorithms are enabled to','line_number':100,'multiline':False]['text':' fill the tensor with NaN if it is floating point or complex type, or fill','line_number':101,'multiline':False]['text':' with max value if it is integer type','line_number':102,'multiline':False]['text':' The ZeroTensor allocator ignores whatever allocation is requested and always','line_number':118,'multiline':False]['text':' gives you nullptr','line_number':119,'multiline':False]['text':'nbytes','line_number':126,'multiline':True]['text':' namespace at::native','line_number':140,'multiline':False]