['text':' Used for a segmented reduction','line_number':11,'multiline':False]['text':' In the kernel below, we have a common pattern of reducing (unsigned int,','line_number':17,'multiline':False]['text':' unsigned int) pairs of data','line_number':18,'multiline':False]['text':' Inclusive Scan via an upsweep/downsweep mechanism. Assumes:','line_number':24,'multiline':False]['text':'','line_number':25,'multiline':False]['text':' 1. Power2ScanSize is a power of 2. This code still works for collections that','line_number':26,'multiline':False]['text':' do not exactly contain a power of 2 number of elements, simply round up to','line_number':27,'multiline':False]['text':' the nearest power of 2 and then call.','line_number':28,'multiline':False]['text':'','line_number':29,'multiline':False]['text':' 2. That there are two-elements per thread, i.e. the size of the smem storage','line_number':30,'multiline':False]['text':' is 2 * blockDim.x * sizeof(T).','line_number':31,'multiline':False]['text':'','line_number':32,'multiline':False]['text':' Consider a (+)-Scan on the following elements:','line_number':33,'multiline':False]['text':'','line_number':34,'multiline':False]['text':' Upsweep:','line_number':35,'multiline':False]['text':'','line_number':36,'multiline':False]['text':'    0  1  2  3  4  5  6  7','line_number':37,'multiline':False]['text':'       1     5     9    13','line_number':38,'multiline':False]['text':'             6          22','line_number':39,'multiline':False]['text':'                        28','line_number':40,'multiline':False]['text':'','line_number':41,'multiline':False]['text':' Downsweep:','line_number':42,'multiline':False]['text':'                  15','line_number':43,'multiline':False]['text':'         3     10    21','line_number':44,'multiline':False]['text':' Reduce step ("upsweep")','line_number':47,'multiline':False]['text':' Post-reduce step ("downsweep")','line_number':57,'multiline':False]['text':' Block-wide reduction where each thread locally reduces N','line_number':68,'multiline':False]['text':' values before letting a single warp take over - assumes','line_number':69,'multiline':False]['text':' threadVals is in registers, not shared memory','line_number':70,'multiline':False]['text':'','line_number':71,'multiline':False]['text':' If smem is not used again, there is no need to __syncthreads before this','line_number':72,'multiline':False]['text':' call. However, if smem will be used, e.g., this function is called in a loop,','line_number':73,'multiline':False]['text':' then __syncthreads is needed either before or afterwards to prevent non-0','line_number':74,'multiline':False]['text':' threads overriding smem in the next loop before num-0 thread reads from it.','line_number':75,'multiline':False]['text':' Invalid entries always sort to the end','line_number':113,'multiline':False]['text':' The mode kernel has the following characteristics: It uses internal shared','line_number':188,'multiline':False]['text':' memory buffers of Power2Size, which must be greater than the number of','line_number':189,'multiline':False]['text':' elements. Additionally, there is one block for every slice to calculate the','line_number':190,'multiline':False]['text':' mode for, and in each block there is one thread for every two elements.','line_number':191,'multiline':False]['text':'','line_number':192,'multiline':False]['text':' Both sorted and positions are assumed to be contiguous Tensors with the mode','line_number':193,'multiline':False]['text':' dimension as the innermost dim, such that we can get the particular slice for','line_number':194,'multiline':False]['text':' a Tensor via its linear block dimension * the slice size.','line_number':195,'multiline':False]['text':' Second index this thread responsible for','line_number':207,'multiline':False]['text':' First, we need to calculate the offset into the sorted Tensor that','line_number':209,'multiline':False]['text':' represents the start of the slice for this block to calculate the mode for.','line_number':210,'multiline':False]['text':' This offset is a combination of the gridIndices, and the number of elements','line_number':211,'multiline':False]['text':' in the slice.','line_number':212,'multiline':False]['text':' shmem is a dynamically sized buffer we will use throughout the kernel to','line_number':220,'multiline':False]['text':' handle computation efficiently. The size of this shmem must be','line_number':221,'multiline':False]['text':' sizeof(T) * Power2Size + (2 * sizeof(unsigned int) * Power2Size)','line_number':222,'multiline':False]['text':'','line_number':223,'multiline':False]['text':' Initially, the buffer will be organized as follows:','line_number':224,'multiline':False]['text':'','line_number':225,'multiline':False]['text':' [smem (slice elements) | bmem (valid indices) | <scratch space>]','line_number':226,'multiline':False]['text':' smem represents a proportion of the shared memory buffer that is used to','line_number':229,'multiline':False]['text':' store the elements from the slice:','line_number':230,'multiline':False]['text':' Each thread loads up to two elements from the Tensor into shared memory','line_number':233,'multiline':False]['text':' Next, we initialize a boolean region of the buffer, offset by the loaded','line_number':241,'multiline':False]['text':' element smem region','line_number':242,'multiline':False]['text':' The first use of this region stores bmem[i] = i < sliceSize to mark the','line_number':245,'multiline':False]['text':' valid components in the smem buffer','line_number':246,'multiline':False]['text':' barrier for smem, bmem initialization','line_number':249,'multiline':False]['text':' First, sort the input slice in ascending order. smem contains the input','line_number':251,'multiline':False]['text':' elements, and bmem marks the valid indices','line_number':252,'multiline':False]['text':' make no assumptions that the sort syncs at end','line_number':257,'multiline':False]['text':' The next step of our algorithm is performing a block-wide comparison of','line_number':259,'multiline':False]['text':' neighboring elements. In particular, given an sorted input slice A, we','line_number':260,'multiline':False]['text':' produce an output slice B, such that B[i] = 1 if A[i-i] != A[i], otherwise','line_number':261,'multiline':False]['text':' 0.','line_number':262,'multiline':False]['text':'','line_number':263,'multiline':False]['text':' Given the input A = [0, 0, 1, 1, 2, 2, 2, 4, 5, 6, 6, 7, 8]','line_number':264,'multiline':False]['text':'                 B = [1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1]','line_number':265,'multiline':False]['text':'','line_number':266,'multiline':False]['text':' In particular, we can think of B[i] true indicating the start of a sequence','line_number':267,'multiline':False]['text':' of equal values in the sorted list. Similarly, we will also store the','line_number':268,'multiline':False]['text':' negation of B, which we'll call C. In particular, we can think of C[i] =','line_number':269,'multiline':False]['text':' true iff A[i-1] == A[i] in our original sorted slice.','line_number':270,'multiline':False]['text':'','line_number':271,'multiline':False]['text':'                 C = [0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0]','line_number':272,'multiline':False]['text':' We overwrite bmem, and treat the rest of shared memory as a buffer of','line_number':274,'multiline':False]['text':' (index, flag) pairs where the index represents values from C, and the flag','line_number':275,'multiline':False]['text':' represents values from B.','line_number':276,'multiline':False]['text':'','line_number':277,'multiline':False]['text':' [smem (sorted slice) | ubpmem (index, flag pairs)]','line_number':278,'multiline':False]['text':' Compares elements (0, 1), (2, 3), ... and sets 1, 3, ...','line_number':288,'multiline':False]['text':' (0, 1), (1, 2), etc.','line_number':290,'multiline':False]['text':' Compares elements (1, 2), (3, 4), ... and sets 2, 4, ...','line_number':293,'multiline':False]['text':' barrier for ubpmem initialization','line_number':299,'multiline':False]['text':' Next, we perform a segmented prefix sum on the neighboring elements, where','line_number':301,'multiline':False]['text':' the presence of a one indicates the start of a segment. In this case B acts','line_number':302,'multiline':False]['text':' as the segment start flags, and C is the buffer to be summed:','line_number':303,'multiline':False]['text':'','line_number':304,'multiline':False]['text':' Input  (C)  = [0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0]','line_number':305,'multiline':False]['text':' Flag   (B)  = [1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1]','line_number':306,'multiline':False]['text':' Output (C)  = [0, 1, 0, 1, 0, 1, 2, 0, 0, 0, 1, 0, 0]','line_number':307,'multiline':False]['text':'','line_number':308,'multiline':False]['text':' Afterwards, the (index) components of the ubpmem buffer contain the lengths','line_number':309,'multiline':False]['text':' of the segments (minus 1), i.e. the counts of each element in the original','line_number':310,'multiline':False]['text':' input.','line_number':311,'multiline':False]['text':' assumes scan syncs at the end','line_number':319,'multiline':False]['text':' Next, we reinterpret the ubpmem buffer as pairs of unsigned integers (i.e.','line_number':321,'multiline':False]['text':' we treat the boolean flag regions as integers). We initialize these to','line_number':322,'multiline':False]['text':' represent indices, and we'll call this buffer I','line_number':323,'multiline':False]['text':' At this point, we need to find the maximum element in lengths buffer C.','line_number':327,'multiline':False]['text':' This element will represent the count (-1) of the mode. Because of the','line_number':328,'multiline':False]['text':' way we have set up the problem, the index where this mode occurs will','line_number':329,'multiline':False]['text':' also be the location of the mode value in the sorted array, e.g.','line_number':330,'multiline':False]['text':'','line_number':331,'multiline':False]['text':' smem = [0, 0, 1, 1, 1, 2]','line_number':332,'multiline':False]['text':' C    = [0, 1, 0, 1, 2, 0]','line_number':333,'multiline':False]['text':' I    = [0, 1, 2, 3, 4, 5]','line_number':334,'multiline':False]['text':'                     ^','line_number':335,'multiline':False]['text':'                     maximum value, also aligned with mode = 1','line_number':336,'multiline':False]['text':'','line_number':337,'multiline':False]['text':' We perform a block wide max-reduction of the C buffer, but we also need the','line_number':338,'multiline':False]['text':' indices to come along with it, so we utilize the uupmem construction.','line_number':339,'multiline':False]['text':'','line_number':340,'multiline':False]['text':' At the end we need to return the ModeUnsignedPair containing index = 4, val','line_number':341,'multiline':False]['text':' = 2, which represents the max','line_number':342,'multiline':False]['text':' In practice, we will make each thread locally reduce 2 values in its','line_number':344,'multiline':False]['text':' registers prior to the global block-wide reduction. Note that instead of','line_number':345,'multiline':False]['text':' tidx/stidx, we utilize tidx * 2, tidx * 2 + 1, so each thread deals with','line_number':346,'multiline':False]['text':' adjacent elements. This is because the reduce code below relies on thread','line_number':347,'multiline':False]['text':' elements to be adjacent.','line_number':348,'multiline':False]['text':' Store the mode in shared memory for use in finding the mode in the input','line_number':378,'multiline':False]['text':' slice','line_number':379,'multiline':False]['text':' Given the above constraints, the mode is the value at the reduced index in','line_number':382,'multiline':False]['text':' the original sorted element buffer','line_number':383,'multiline':False]['text':' broadcast mode','line_number':387,'multiline':False]['text':' Finally, we need to find "an" index of the mode in the input','line_number':389,'multiline':False]['text':' Tensor. The API does not constrain which index we pick, but here','line_number':390,'multiline':False]['text':' we always pick the largest index. We store the index if the value','line_number':391,'multiline':False]['text':' is the mode, or 0 otherwise. Then find the maximum value.','line_number':392,'multiline':False]['text':'','line_number':393,'multiline':False]['text':' Again we reduce 2 elements in the thread's registers prior to the','line_number':394,'multiline':False]['text':' block-wide reduction','line_number':395,'multiline':False]['text':' Finally, we have the mode, and an index where it occurs. We use a single','line_number':423,'multiline':False]['text':' thread to place this in the appropriate output position','line_number':424,'multiline':False]['text':' namespace native','line_number':434,'multiline':False]['text':' namespace at','line_number':435,'multiline':False]