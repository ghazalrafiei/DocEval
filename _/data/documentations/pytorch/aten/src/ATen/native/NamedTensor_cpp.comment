['text':' Let tensor `t` have size `tensor_sizes` and `tensor_names`.','line_number':76,'multiline':False]['text':' This helper function computes the resulting size of `t` after aligning it','line_number':77,'multiline':False]['text':' to `aligned_names`. Enforces the alignment rules in Note [Alignment rules].','line_number':78,'multiline':False]['text':' We've found a None name in `shorter` and `longer`. If their absolute positions','line_number':91,'multiline':False]['text':' from the right are not equal, then aligning the two names would require','line_number':92,'multiline':False]['text':' changing the absolute position from right of one of the None names,','line_number':93,'multiline':False]['text':' violating condition 2 of our [Alignment rules].','line_number':94,'multiline':False]['text':'','line_number':95,'multiline':False]['text':' For example:','line_number':96,'multiline':False]['text':' *, c, a, b','line_number':97,'multiline':False]['text':'       *, a','line_number':98,'multiline':False]['text':' [*, a] is a subsequence of [*, c, a, b], but in order to align them,','line_number':99,'multiline':False]['text':' we'd have to move the * to create [*, c: 1, a, b: 1]','line_number':100,'multiline':False]['text':'is_aligning_two_tensors=','line_number':104,'multiline':True]['text':'is_aligning_two_tensors=','line_number':111,'multiline':True]['text':' done handling errors','line_number':141,'multiline':False]['text':' [Alignment rules]','line_number':149,'multiline':False]['text':' Aligns `tensor` to names with the following rules:','line_number':150,'multiline':False]['text':' 1) Check that tensor.names is a subsequence (not necessarily contiguous) of `names`.','line_number':151,'multiline':False]['text':' 2) Aligning tensor.names to names must not change the absolute position from the','line_number':152,'multiline':False]['text':'    right of any unnamed dimension.','line_number':153,'multiline':False]['text':'','line_number':154,'multiline':False]['text':' is_aligning_two_tensors tunes the error message to better match the following cases:','line_number':155,'multiline':False]['text':' 1) tensor.align_to(names)  (is_aligning_two_tensors=false)','line_number':156,'multiline':False]['text':' 2) torch.align_tensors([tensor, other])  (is_aligning_two_tensors=true)','line_number':157,'multiline':False]['text':' Handles `tensor.align_to(*order)` in the case where there is an ellipsis.','line_number':177,'multiline':False]['text':'','line_number':178,'multiline':False]['text':' Let tensor: Tensor[N, C, H, W]. Consider `tensor.align_to('W', ..., 'N')`','line_number':179,'multiline':False]['text':' We expand the `...` to "all unmentioned dimensions, in the order which they','line_number':180,'multiline':False]['text':' appear in the original tensor."','line_number':181,'multiline':False]['text':'','line_number':182,'multiline':False]['text':' `order` is passed in **without** the ellipsis name. This is because ellipsis','line_number':183,'multiline':False]['text':' is not a valid name in cpp right now. Future work should be done on making','line_number':184,'multiline':False]['text':' ellipsis a valid name.','line_number':185,'multiline':False]['text':'','line_number':186,'multiline':False]['text':' `ellipsis_idx` is where the ellipsis occurs in the Python call.','line_number':187,'multiline':False]['text':' In our example, `tensor.align_to('W', ..., 'N')`, order = ['W', 'N'] and','line_number':188,'multiline':False]['text':' ellipsis_idx = 1.','line_number':189,'multiline':False]['text':' General strategy.','line_number':197,'multiline':False]['text':'','line_number':198,'multiline':False]['text':' Step 1: We compute the following 3 things:','line_number':199,'multiline':False]['text':' 1. How many names the ellipsis should expand to','line_number':200,'multiline':False]['text':' 2. Which names in `tensor.names` are not mentioned in `order`.','line_number':201,'multiline':False]['text':' 3. Where names in `order` occur in tensor, if at all.','line_number':202,'multiline':False]['text':'','line_number':203,'multiline':False]['text':' Step 2: Compute the new sizes/strides/names.','line_number':204,'multiline':False]['text':' First, determine the ndim of the output tensor (this is not obvious)','line_number':205,'multiline':False]['text':' by counting the number of names in `tensor` that are not in `order`.','line_number':206,'multiline':False]['text':' Next, fill in output sizes/strides/names by using `order` and knowledge','line_number':207,'multiline':False]['text':' of which dimensions in `tensor` are unmentioned in `order`.','line_number':208,'multiline':False]['text':' tensor_idx_for[i] = j means that the ith name in `order`','line_number':212,'multiline':False]['text':' appears in the jth element of tensor.','line_number':213,'multiline':False]['text':' Step 2: Now that we know the size of the output tensor, we can use the','line_number':233,'multiline':False]['text':' metadata obtained from Step 1 to fill in the new sizes/strides/names','line_number':234,'multiline':False]['text':' Fill in the non-ellipsis dimensions','line_number':245,'multiline':False]['text':' We are adding a new size-one dimension','line_number':253,'multiline':False]['text':' Fill in the ellipsis dimensions','line_number':260,'multiline':False]['text':'validate_names=','line_number':276,'multiline':True]['text':'is_aligning_two_tensors=','line_number':317,'multiline':True]['text':' Misc. Dimname overloads that don't have homes. Maybe we should move','line_number':331,'multiline':False]['text':' all of them here or autogenerate them because they look so similar.','line_number':332,'multiline':False]['text':' namespace at::native','line_number':410,'multiline':False]