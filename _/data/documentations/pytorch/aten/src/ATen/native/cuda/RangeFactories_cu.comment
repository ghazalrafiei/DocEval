['text':' namespace','line_number':68,'multiline':False]['text':' skip','line_number':82,'multiline':False]['text':' Cast `end` and `start` to `float`, since range can be larger than scalar_t for integral types','line_number':89,'multiline':False]['text':' skip','line_number':133,'multiline':False]['text':' Use float to avoid promotion to double','line_number':142,'multiline':False]['text':' we use double precision for (start - end) / step','line_number':227,'multiline':False]['text':' to compute size_d for consistency across devices.','line_number':228,'multiline':False]['text':' The problem with using accscalar_t is that accscalar_t might be float32 on gpu for a float32 scalar_t,','line_number':229,'multiline':False]['text':' but double on cpu for the same,','line_number':230,'multiline':False]['text':' and the effective output size starts differing on CPU vs GPU because of precision issues, which','line_number':231,'multiline':False]['text':' we dont want.','line_number':232,'multiline':False]['text':' the corner-case we do want to take into account is int64_t, which has higher precision than double','line_number':233,'multiline':False]['text':' namespace at::native','line_number':274,'multiline':False]