['text':' namespace jit','line_number':26,'multiline':False]['text':' namespace torch','line_number':27,'multiline':False]['text':' Any is the top of the type hierarchy, all other types are subtypes','line_number':63,'multiline':False]['text':' T <: Any, forall T','line_number':64,'multiline':False]['text':' global singleton','line_number':73,'multiline':False]['text':' Shim for compatibility with code that uses TypePtr.','line_number':84,'multiline':False]['text':' common base for all types that have a single sub element','line_number':93,'multiline':False]['text':' e.g. Future[T], Optional[T], List[T]','line_number':94,'multiline':False]['text':' For testing purposes only','line_number':153,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':178,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':180,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':182,'multiline':False]['text':' This type represents an optional type. There is one `Optional` for','line_number':189,'multiline':False]['text':' each element type. `Optional[T]` can accept both `T` and','line_number':190,'multiline':False]['text':' `None`(`c10::nullopt` in C++)','line_number':191,'multiline':False]['text':' Subtype hierarchy for Optional:','line_number':192,'multiline':False]['text':'     - Optional[T] <: Optional[R] iff T <: R','line_number':193,'multiline':False]['text':'     - T <: Optional[R] if T <: R','line_number':194,'multiline':False]['text':'     - None <: Optional[T] for all T','line_number':195,'multiline':False]['text':'     - Optional[T] == Union[T, None] for all T','line_number':196,'multiline':False]['text':' common cast Optional[Tensor] for undefined tensor type','line_number':232,'multiline':False]['text':'','line_number':234,'multiline':False]['text':' global singleton','line_number':235,'multiline':False]['text':' If we see `a + b + c`  and know that a, b, and c are the same size and have','line_number':260,'multiline':False]['text':' two dimensions (WxH), then we can generate a fused kernel for them. That','line_number':261,'multiline':False]['text':' fused kernel would likely have indexing math to handling both the W and H','line_number':262,'multiline':False]['text':' dimensions. However, if we knew the WxH dimensions were contiguous, we can','line_number':263,'multiline':False]['text':' pretend like we only have a single dimension, simplifying the indexing logic.','line_number':264,'multiline':False]['text':' This can be performed even if the dimensions are transposed,','line_number':265,'multiline':False]['text':' as long as a, b, and c are transposed in the same way.','line_number':266,'multiline':False]['text':' We'd like to have the compiler be able to do this dimensionality reduction,','line_number':267,'multiline':False]['text':' but simply knowing sizes is not enough.','line_number':268,'multiline':False]['text':' We can extend profiling to also record stride information.','line_number':269,'multiline':False]['text':' Rather than recording specific strides,','line_number':270,'multiline':False]['text':' we can simply order the strides from smallest to largest with','line_number':271,'multiline':False]['text':' `stride_indices` A contiguity marker on the smallest stride (c0) indicates','line_number':272,'multiline':False]['text':' the stride is precisely 1, otherwise a contiguity marker means that $stride_n','line_number':273,'multiline':False]['text':' = size_{n-1}*stride_{n-1}$','line_number':274,'multiline':False]['text':' normalize','line_number':315,'multiline':False]['text':' needed for use in `std::map`','line_number':325,'multiline':False]['text':' is this symbol a fixed/static dimension','line_number':327,'multiline':False]['text':' Shape of a Tensor represented with ShapeSymbol's. Unranked, ranked unknown','line_number':372,'multiline':False]['text':' dims, partially known and fully known shapes are all supported.','line_number':373,'multiline':False]['text':' Unranked shape constructor.','line_number':375,'multiline':False]['text':' Known rank but unknown dimentions.','line_number':378,'multiline':False]['text':' Mix of known and unknown ranks','line_number':392,'multiline':False]['text':' Returns rank or nullopt in case of unranked shape.','line_number':433,'multiline':False]['text':' Checks whether the shape is fully defined/complete, ie. rank and sizes','line_number':456,'multiline':False]['text':' of every dimension are known.','line_number':457,'multiline':False]['text':' Create new SymbolicShape that is result of merging self and another','line_number':470,'multiline':False]['text':' SymbolicShape. Only dimensions that are static and equal will be','line_number':471,'multiline':False]['text':' preserved.','line_number':472,'multiline':False]['text':' If either of two shapes are of unknown rank or they have unmatching rank,','line_number':473,'multiline':False]['text':' result will be unranked.','line_number':474,'multiline':False]['text':'t','line_number':495,'multiline':True]['text':' TODO: investigate making this SingletonOrSharedTypePtr<TensorType>','line_number':575,'multiline':False]['text':' This type represents a single Tensor with a specific size','line_number':577,'multiline':False]['text':' used by TensorType::create(size_t dim) which in turn used by','line_number':581,'multiline':False]['text':' shape_analysis.cpp','line_number':582,'multiline':False]['text':' overloaded create variadic template argument as it could not distinguish','line_number':606,'multiline':False]['text':' initializer list','line_number':607,'multiline':False]['text':' withDim is only used by the legacy executor','line_number':681,'multiline':False]['text':' that only cares about the rank, so create dummy symbols)) :','line_number':682,'multiline':False]['text':' is all information about the type specified except for autograd?','line_number':744,'multiline':False]['text':' This replaces the notion of a 'CompleteTensorType' that used to exist','line_number':745,'multiline':False]['text':' in the type-hierarchy. Excluding require_grad and undefined allows','line_number':746,'multiline':False]['text':' this to match the old behavior.','line_number':747,'multiline':False]['text':'scalar_type=','line_number':758,'multiline':True]['text':'device=','line_number':759,'multiline':True]['text':'sizes=','line_number':760,'multiline':True]['text':'stride=','line_number':761,'multiline':True]['text':'requires_grad=','line_number':762,'multiline':True]['text':'undefined=','line_number':763,'multiline':True]['text':' this property is used by GuardElimination','line_number':768,'multiline':False]['text':' please see `checkInputs` for more details','line_number':769,'multiline':False]['text':' zero-dim case','line_number':799,'multiline':False]['text':' Reverse','line_number':819,'multiline':False]['text':' we exploit the fact certain tensors must be zero in the autograd to','line_number':849,'multiline':False]['text':' optimize gradient computation. Such zero tensors are currently implemented','line_number':850,'multiline':False]['text':' with `UndefinedTensorImpl.` They can be handled only by special operators','line_number':851,'multiline':False]['text':' (e.g. `AutogradAdd`) and their `Tensor::defined()` property returns false.','line_number':852,'multiline':False]['text':' Normally, `undefined_` is set to false, unless a type was created','line_number':853,'multiline':False]['text':' with `withUndefined`','line_number':854,'multiline':False]['text':' This will also mean that `undefined` tensors will fail','line_number':855,'multiline':False]['text':' `subtypeOf(TensorType::get())` check','line_number':856,'multiline':False]['text':' undefined_ may become `c10::nullopt` if the tensor was observed to be both','line_number':857,'multiline':False]['text':' defined and undefined. However, no tensor type starts out with','line_number':858,'multiline':False]['text':' `undefined_` set to `c10::nullopt`','line_number':859,'multiline':False]['text':' Represents whether or not this type was inferred.','line_number':861,'multiline':False]['text':' It's not exactly a singleton, but there should be exactly one instance of','line_number':869,'multiline':False]['text':' List[T] for every T','line_number':870,'multiline':False]['text':' NOLINT(modernize-make-shared)','line_number':875,'multiline':False]['text':' global singleton','line_number':890,'multiline':False]['text':' Given an inner type T and an identifier,','line_number':891,'multiline':False]['text':' this function wil return the global singleton type pointer','line_number':892,'multiline':False]['text':' the type List<T>.','line_number':893,'multiline':False]['text':' The extra "identifier" argument is needed beccause we have multiple container types','line_number':894,'multiline':False]['text':' that all re-use this function (List<T>, array<T, N>, etc.)','line_number':895,'multiline':False]['text':' common cast List[Tensor]','line_number':898,'multiline':False]['text':' aligned with the format in FunctionSchema','line_number':948,'multiline':False]['text':' global singleton','line_number':988,'multiline':False]['text':' Given an inner type T and an identifier,','line_number':989,'multiline':False]['text':' this function will return the global singleton type pointer','line_number':990,'multiline':False]['text':' the type List<T>.','line_number':991,'multiline':False]['text':' The extra "identifier" argument is needed because we have multiple container types','line_number':992,'multiline':False]['text':' that all re-use this function (Dict<K, V> and unordered_map<K, V>)','line_number':993,'multiline':False]['text':' NOLINT(modernize-make-shared)','line_number':1021,'multiline':False]['text':' NOLINT(modernize-make-shared)','line_number':1063,'multiline':False]['text':' NOLINT(modernize-make-shared)','line_number':1105,'multiline':False]['text':' Any should never appear in a named type like a class, namedtuple or','line_number':1128,'multiline':False]['text':' interface. If it does, then dynamic type information will be lost in the','line_number':1129,'multiline':False]['text':' Pickler, leading to hard-to-track-down bugs that will only occur','line_number':1130,'multiline':False]['text':' after saving or loading a model. This is because we rely on the','line_number':1131,'multiline':False]['text':' static types in named types to reconstruct type tags of loaded','line_number':1132,'multiline':False]['text':' values. Lifting this restriction requires solving the serialization','line_number':1133,'multiline':False]['text':' problem first.','line_number':1134,'multiline':False]['text':' This type represents a Tuple','line_number':1144,'multiline':False]['text':' NOLINT(modernize-make-shared)','line_number':1165,'multiline':False]['text':' the common supertype of all Enums, only used in operator registraion.','line_number':1235,'multiline':False]['text':' EnumType <: AnyEnumType for all Enums','line_number':1236,'multiline':False]['text':' global singleton','line_number':1247,'multiline':False]['text':' This type represents a Python number','line_number':1256,'multiline':False]['text':' Subtype hierarchy for Number Types (NumberType as the base type):','line_number':1257,'multiline':False]['text':' IntType <: NumberType','line_number':1258,'multiline':False]['text':' FloatType <: NumberType','line_number':1259,'multiline':False]['text':' ComplexType <:NumberType','line_number':1260,'multiline':False]['text':'','line_number':1261,'multiline':False]['text':' WARNING: if you add a new subtype of NumberType that is not','line_number':1262,'multiline':False]['text':' represented by a global singleton, you need to change NumberTypePtr','line_number':1263,'multiline':False]['text':' to a SingletonOrSharedTypePtr and deal with NumberType needing to','line_number':1264,'multiline':False]['text':' both inherit and not inherit from SharedType!','line_number':1265,'multiline':False]['text':' match what PythonArgParser says for clarity','line_number':1272,'multiline':False]['text':' global singleton','line_number':1275,'multiline':False]['text':' technically not a valid python type, but','line_number':1282,'multiline':False]['text':' we need to use it when parsing back in annotations','line_number':1283,'multiline':False]['text':' for implicit conversions','line_number':1284,'multiline':False]['text':' This type represents a Python float number','line_number':1290,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-parent-virtual-call)','line_number':1299,'multiline':False]['text':' global singleton','line_number':1303,'multiline':False]['text':' This type represents a Python float number','line_number':1315,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-parent-virtual-call)','line_number':1324,'multiline':False]['text':' global singleton','line_number':1328,'multiline':False]['text':' We need to introduce `SymIntType` to represent the `SymInt` type','line_number':1338,'multiline':False]['text':' used in function schemas e.g. `aten::narrow_copy(... SymInt length)','line_number':1339,'multiline':False]['text':' `SymInt` will be used to enable tracing arithmetic operations on','line_number':1340,'multiline':False]['text':' dimension values. Please see [SymInt.h] for more information','line_number':1341,'multiline':False]['text':' global singleton','line_number':1355,'multiline':False]['text':' global singleton','line_number':1375,'multiline':False]['text':' global singleton','line_number':1395,'multiline':False]['text':' This type represents a Python int number','line_number':1404,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-parent-virtual-call)','line_number':1413,'multiline':False]['text':' global singleton','line_number':1417,'multiline':False]['text':' This node represents a Python bool value','line_number':1429,'multiline':False]['text':' global singleton','line_number':1438,'multiline':False]['text':' This type represents a Python string','line_number':1447,'multiline':False]['text':' we only use "str" (not "string") in both FunctionSchema and script','line_number':1453,'multiline':False]['text':' global singleton','line_number':1460,'multiline':False]['text':' global singleton','line_number':1480,'multiline':False]['text':' NOLINT(modernize-make-shared)','line_number':1492,'multiline':False]['text':' This type represents a Python None','line_number':1520,'multiline':False]['text':' global singleton','line_number':1531,'multiline':False]['text':' This type represents a Generator','line_number':1540,'multiline':False]['text':' global singleton','line_number':1549,'multiline':False]['text':' This type represents a Quantizer','line_number':1558,'multiline':False]['text':' global singleton','line_number':1567,'multiline':False]['text':' This type represents a QScheme','line_number':1576,'multiline':False]['text':' global singleton','line_number':1585,'multiline':False]['text':' This type represents a Device','line_number':1594,'multiline':False]['text':' global singleton','line_number':1603,'multiline':False]['text':' This type represents a Generator','line_number':1612,'multiline':False]['text':' global singleton','line_number':1621,'multiline':False]['text':' This type represents a type variable, used in FunctionSchema','line_number':1630,'multiline':False]['text':' This type represents a Python Capsule.','line_number':1657,'multiline':False]['text':' It does not appear in the IR and is only used during runtime','line_number':1658,'multiline':False]['text':' global singleton','line_number':1667,'multiline':False]['text':' This type represents a PyObject Type','line_number':1676,'multiline':False]['text':' global singleton','line_number':1685,'multiline':False]['text':' what is the type, ignoring extra size/shape information?','line_number':1711,'multiline':False]['text':' e.g. Tensor(2x3) -> Dynamic, and Tuple(Tensor(2x3),...) -> Tuple(Dynamic,...)','line_number':1712,'multiline':False]['text':' `unshapedType` is used to remove Tensor subtypes. We treat all Tensor','line_number':1714,'multiline':False]['text':' subtypes as simply "Tensor"; we also create a new version of any','line_number':1715,'multiline':False]['text':' container types in which internal Tensors have undergone the same','line_number':1716,'multiline':False]['text':' operation. This is used for type comparisons between two Tensor types','line_number':1717,'multiline':False]['text':' (`unshapedType` means that we don't falsely return `false` for e.g.','line_number':1718,'multiline':False]['text':' Tensors of different dimensions). It's also used in the alias','line_number':1719,'multiline':False]['text':' analysis pass.','line_number':1720,'multiline':False]['text':' Be careful with calls because this can be very slow. If calling this','line_number':1721,'multiline':False]['text':' on a graph, use `EraseShapeInformation` in shape_analysis.h','line_number':1722,'multiline':False]['text':' Attempt to find the correct supertype of the two types `t1` and `t2`.','line_number':1770,'multiline':False]['text':' If no supertype is found, then nullopt will be returned if','line_number':1771,'multiline':False]['text':' `default_to_union` is false, and `Union[t1, t2]` will be returned','line_number':1772,'multiline':False]['text':' if it is true. If `t1 == t2`, or `t1` is a type refinement of `t2`,','line_number':1773,'multiline':False]['text':' then `t2` will be returned (and vice versa).','line_number':1774,'multiline':False]['text':'','line_number':1775,'multiline':False]['text':' Two different tensortypes will return dynamic.','line_number':1776,'multiline':False]['text':'','line_number':1777,'multiline':False]['text':' Currently we chose not to support returning a NumberType for','line_number':1778,'multiline':False]['text':' two types from the set of {FloatType, IntType, ComplexType}, because','line_number':1779,'multiline':False]['text':' there is a lack of operator support for NumberType.','line_number':1780,'multiline':False]['text':'','line_number':1781,'multiline':False]['text':' If `type_hint` is an `InterfaceType`, then we can use that as a','line_number':1782,'multiline':False]['text':' potential supertype for `ClassType`s in the list. Otherwise, we have','line_number':1783,'multiline':False]['text':' no way to find and use some common interface type','line_number':1784,'multiline':False]['text':' The "per vector<T>" static singleton needs to live in a .cpp file,','line_number':1966,'multiline':False]['text':' otherwise we'll end up with one singleton instance per shared library.','line_number':1967,'multiline':False]['text':' The "per ArrayRef<T>" static singleton needs to live in a .cpp file,','line_number':1976,'multiline':False]['text':' otherwise we'll end up with one singleton instance per shared library.','line_number':1977,'multiline':False]['text':' The "per List<T>" static singleton needs to live in a .cpp file,','line_number':1993,'multiline':False]['text':' otherwise we'll end up with one singleton instance per shared library.','line_number':1994,'multiline':False]['text':' The "per array<T, N>" static singleton needs to live in a .cpp file,','line_number':2011,'multiline':False]['text':' otherwise we'll end up with one singleton instance per shared library.','line_number':2012,'multiline':False]['text':' (Concatenating the length onto the end of the string because we want a unique','line_number':2013,'multiline':False]['text':' type_ptr created for every std::array<T, N> type).','line_number':2014,'multiline':False]['text':' The "per unordered_map<K, V>" static singleton needs to live in a .cpp file,','line_number':2024,'multiline':False]['text':' otherwise we'll end up with one singleton instance per shared library.','line_number':2025,'multiline':False]['text':' The "per Dict<K, V>" static singleton needs to live in a .cpp file,','line_number':2035,'multiline':False]['text':' otherwise we'll end up with one singleton instance per shared library.','line_number':2036,'multiline':False]['text':' The "per optional<T>" static singleton needs to live in a .cpp file,','line_number':2046,'multiline':False]['text':' otherwise we'll end up with one singleton instance per shared library.','line_number':2047,'multiline':False]['text':' The "per optional<T>" static singleton needs to live in a .cpp file,','line_number':2058,'multiline':False]['text':' otherwise we'll end up with one singleton instance per shared library.','line_number':2059,'multiline':False]['text':' The "per optional<T>" static singleton needs to live in a .cpp file,','line_number':2068,'multiline':False]['text':' otherwise we'll end up with one singleton instance per shared library.','line_number':2069,'multiline':False]['text':' namespace detail','line_number':2094,'multiline':False]['text':' TODO: static_assert that a templated function exists, and throw a friendly','line_number':2097,'multiline':False]['text':' error message if not','line_number':2098,'multiline':False]['text':' TODO: static_assert that a templated function exists, and throw a friendly','line_number':2104,'multiline':False]['text':' error message if not','line_number':2105,'multiline':False]['text':' is there is no match, this contains the reason','line_number':2135,'multiline':False]['text':' attempt to match the type variables in formal to actual, adding them to type_env.','line_number':2138,'multiline':False]['text':' If no match is possible this returns a MatchTypeReturn with r.success() == false','line_number':2139,'multiline':False]['text':' and a r.reason() that describes why it could not match.','line_number':2140,'multiline':False]['text':' note: It is possible to successfully match a formal, but for type variables','line_number':2141,'multiline':False]['text':' in the formal to still not be defined. In particular, None matches Optional[T]','line_number':2142,'multiline':False]['text':' but does not define the value of T.','line_number':2143,'multiline':False]['text':' replace type variables appearing in `type` with the values in','line_number':2147,'multiline':False]['text':' `type_env`. Returns nullptr if a variable used in `type`','line_number':2148,'multiline':False]['text':' does not appear in `type_env`','line_number':2149,'multiline':False]['text':' Interfaces are a list of abstract methods that a class might meet.','line_number':2157,'multiline':False]['text':' If a class provides those methods, it implicitly meets the interface.','line_number':2158,'multiline':False]['text':' Subtype relations for Interface with ClassType:','line_number':2160,'multiline':False]['text':' lhs (ClassType or InterfaceType) is a subtype of rhs if:','line_number':2161,'multiline':False]['text':' 1. lhs methods are a superset of rhs methods','line_number':2162,'multiline':False]['text':' 2. if rhs is module interface, the lhs must be module interface or module itself','line_number':2163,'multiline':False]['text':' try to find a method of this interface,','line_number':2182,'multiline':False]['text':' returns nullptr if not found.','line_number':2183,'multiline':False]['text':' shared_ptr so that this header does not have to depend on','line_number':2206,'multiline':False]['text':' FunctionSchema.h','line_number':2207,'multiline':False]['text':' flag to distinguish if it's an interface type from a module or not','line_number':2209,'multiline':False]['text':' WARNING: These enumeration types below DO NOT actually get parsed out','line_number':2225,'multiline':False]['text':' from the logical schema strings, instead they are mapped as ints.  To','line_number':2226,'multiline':False]['text':' observe these types, use real_type() instead of type() on Argument','line_number':2227,'multiline':False]['text':' global singleton','line_number':2236,'multiline':False]['text':' global singleton','line_number':2250,'multiline':False]['text':' global singleton','line_number':2264,'multiline':False]['text':' namespace detail','line_number':2308,'multiline':False]['text':' the common supertype of all lists,','line_number':2310,'multiline':False]['text':' List[T] <: AnyList for all T','line_number':2311,'multiline':False]['text':' global singleton','line_number':2322,'multiline':False]['text':' the common supertype of all tuples,','line_number':2329,'multiline':False]['text':' Tuple[T...] <: AnyTuple for all T','line_number':2330,'multiline':False]['text':' global singleton','line_number':2343,'multiline':False]['text':' the common supertype of all classes,','line_number':2350,'multiline':False]['text':' ClassType <: AnyClassType for all classes','line_number':2351,'multiline':False]['text':' global singleton','line_number':2362,'multiline':False]['text':' Used as a return type when inferring the IValue type of a Python object.','line_number':2396,'multiline':False]['text':' implicit ','line_number':2398,'multiline':True]['text':' implicit ','line_number':2399,'multiline':True]['text':' namespace c10','line_number':2424,'multiline':False]