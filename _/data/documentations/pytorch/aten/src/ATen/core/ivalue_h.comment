['text':' namespace jit','line_number':29,'multiline':False]['text':' namespace torch','line_number':30,'multiline':False]['text':' A comparator that checks ordering of two IValues of same type.','line_number':52,'multiline':False]['text':' We need a ComplexHolder because currently the payloads in the Union','line_number':67,'multiline':False]['text':' only take 64 bits. Since ComplexDouble takes up 128 bits, and is too big','line_number':68,'multiline':False]['text':' to fit in the IValue directly, we indirect complex numbers through an','line_number':69,'multiline':False]['text':' intrusive pointer to ComplexHolder (which contains a c10::complex).','line_number':70,'multiline':False]['text':' Similar to ComplexHolder, for StreamData3','line_number':81,'multiline':False]['text':' namespace ivalue','line_number':89,'multiline':False]['text':' This is an owning wrapper for a c10::optional<std::vector<T>>','line_number':91,'multiline':False]['text':' that can be implicitly converted to a (non-owning) optional<ArrayRef<T>>.','line_number':92,'multiline':False]['text':' Its purpose is to be used in generated code to keep the vector alive','line_number':93,'multiline':False]['text':' either until the end of a statement (as a temporary), or as a saved arg','line_number':94,'multiline':False]['text':' in autograd.','line_number':95,'multiline':False]['text':' Used when saving an argument for the backwards pass.','line_number':103,'multiline':False]['text':' Used when saving an argument for the backwards pass.','line_number':113,'multiline':False]['text':' Capsule is an internal implementation detail of custom C++ classes. We','line_number':138,'multiline':False]['text':' define it as an owning wrapper for','line_number':139,'multiline':False]['text':' c10::intrusive_ptr<torch::CustomClassHolder> This wrapper is here to serve as','line_number':140,'multiline':False]['text':' an abstraction of the type erased custom class object pointer. It also allow','line_number':141,'multiline':False]['text':' pybind11 to treat this as a standalone class to register as a separate type','line_number':142,'multiline':False]['text':' caster, instead of a custom pointer holder which the pointer holder type','line_number':143,'multiline':False]['text':' caster try to "unwrap" it automatically.','line_number':144,'multiline':False]['text':' IValue is the generic tagged union used by the interpreter to hold','line_number':151,'multiline':False]['text':' all value types.','line_number':152,'multiline':False]['text':' It is a 16-byte object with an 8-byte payload and an 8-byte tag.','line_number':153,'multiline':False]['text':' The tag is currently 4 bytes to determine the type, and 1 byte','line_number':154,'multiline':False]['text':' to mark whether that type is a subtype of c10::intrusive_ptr_target and needs','line_number':155,'multiline':False]['text':' retain/release calls.','line_number':156,'multiline':False]['text':' [doxygen private]','line_number':187,'multiline':False]['text':' These methods are not actually private but we don't want to document them, so','line_number':188,'multiline':False]['text':' they are marked `@private`, which hides them on the doxygen documentation for','line_number':189,'multiline':False]['text':' this page.','line_number':190,'multiline':False]['text':'/ IValue (Interpreter Value) is a tagged union over the types','line_number':192,'multiline':False]['text':'/ supported by the TorchScript interpreter. IValues contain their','line_number':193,'multiline':False]['text':'/ values as an `IValue::Payload`, which holds primitive types','line_number':194,'multiline':False]['text':'/ (`int64_t`, `bool`, `double`, `Device`) and `Tensor` as values,','line_number':195,'multiline':False]['text':'/ and all other types as a `c10::intrusive_ptr`. In order to','line_number':196,'multiline':False]['text':'/ optimize performance of the destructor and related operations by','line_number':197,'multiline':False]['text':'/ making the `Tensor` and `c10::intrusive_ptr` paths generate the','line_number':198,'multiline':False]['text':'/ same code, we represent a null `c10::intrusive_ptr` as','line_number':199,'multiline':False]['text':'/ `UndefinedTensorImpl::singleton()`, *not* `nullptr`.','line_number':200,'multiline':False]['text':'/','line_number':201,'multiline':False]['text':'/ IValues are used as inputs to and outputs from the TorchScript interpreter.','line_number':202,'multiline':False]['text':'/ To retrieve the value contained within an IValue, use the `.toX()` methods,','line_number':203,'multiline':False]['text':'/ where `X` is the type you are trying to get. Note that neither the `.toX()`','line_number':204,'multiline':False]['text':'/ methods nor the templated `.to<T>` functions do any kind of casting, they','line_number':205,'multiline':False]['text':'/ only unwrap the contained value. For example:','line_number':206,'multiline':False]['text':'/','line_number':207,'multiline':False]['text':'/ \rst','line_number':208,'multiline':False]['text':'/ .. code-block:: cpp','line_number':209,'multiline':False]['text':'/','line_number':210,'multiline':False]['text':'/   // Make the IValue','line_number':211,'multiline':False]['text':'/   torch::IValue my_ivalue(26);','line_number':212,'multiline':False]['text':'/   std::cout << my_ivalue << "\n";','line_number':213,'multiline':False]['text':'/','line_number':214,'multiline':False]['text':'/   // Unwrap the IValue','line_number':215,'multiline':False]['text':'/   int64_t my_int = my_ivalue.toInt();','line_number':216,'multiline':False]['text':'/   std::cout << my_int << "\n";','line_number':217,'multiline':False]['text':'/','line_number':218,'multiline':False]['text':'/   // This will throw an error!','line_number':219,'multiline':False]['text':'/   // `my_ivalue` is tagged as an int and cannot be used as another type','line_number':220,'multiline':False]['text':'/   torch::Tensor my_tensor = my_ivalue.toTensor();','line_number':221,'multiline':False]['text':'/ \endrst','line_number':222,'multiline':False]['text':'/ @private [doxygen private]','line_number':235,'multiline':False]['text':'*
   * Equality comparison. The semantics are the same as Python's `==`:
   * 1. Numerical types are compared by value.
   * 2. Tensors compute element-wise equality, returning a BoolTensor (see:
   * `torch.eq()`)
   * 3. Strings are compared by value.
   * 4. Sequence types (list, tuple) are compared lexicographically by
   *    comparing their elements. Different sequence types never compare equal.
   * 5. Mappings (dict) must have equal (key, value) pairs.
   * 6. If not listed above, the default behavior for is to test identity
   * equality (e.g. pointer equality).
   *
   * Why does this return an IValue instead of a bool? Because in PyTorch,
   * `tensor1 == tensor2` returns a `BoolTensor`, not a bool.
   *
   * NOTE: we (like Python) assume that identity equality implies value equality
   * for efficiency.
   * TODO: need to support customizing equality
   ','line_number':257,'multiline':True]['text':'*
   * This implements the same semantics as `bool(lhs == rhs)` in Python. which
   * is the same as `equals()` except for Tensor types.
   ','line_number':277,'multiline':True]['text':'*
   * Identity comparison. Checks if `this` is the same object as `rhs`. The
   * semantics are the same as Python's `is` operator.
   *
   * NOTE: Like in Python, this operation is poorly defined for primitive types
   * like numbers and strings. Prefer to use `==` unless you really want to
   * check identity equality.
   ','line_number':284,'multiline':True]['text':'*
   * Hashing for IValues. Returns an IValue-boxed int.
   *
   * Some notes:
   * - Like eager, Tensors are hashed by looking at the pointer. This is not
   *   strictly correct because two value-equal tensors with different tensor
   *   pointers will hash differently, but we choose to reproduce the eager
   *   semantics.
   * - Hashing is not defined on all built-in IValue types (e.g. list and
   *   dict), following Python. Calling `hash()` on these types will throw.
   ','line_number':294,'multiline':True]['text':' This is defined because `c10::hash` dispatches to a function of this','line_number':308,'multiline':False]['text':' signature. See the member function `hash()`.','line_number':309,'multiline':False]['text':'*
   * @private [doxygen private]
   * [container equality]
   * This is an equality implementation that assumes objects with the same
   * identity equal themselves, for efficiency reasons. We primarily have this
   * for consistency, because Python does the same thing. This actually
   * provokes user-visible changes in behavior due to quirks in torch:
   *      [tensor1] == [tensor1] -> True (because container equality will first
   * compare identity) [tensor1] == [tensor1_copy] -> RuntimeError:
   * Boolean value of Tensor with more than one value is ambiguous
   ','line_number':312,'multiline':True]['text':' Opaque tensors such as the ones constructed by the MKL-DNN backend','line_number':344,'multiline':False]['text':' don't have storage so we just compare their TensorImpls.','line_number':345,'multiline':False]['text':' TODO: Find way to expose alias info for opaque tensors.','line_number':346,'multiline':False]['text':'/ @private [doxygen private]','line_number':358,'multiline':False]['text':' Trivially don't alias if the type is different','line_number':361,'multiline':False]['text':' Tensors should be compared based on internal storage','line_number':365,'multiline':False]['text':' Primitive types don't alias anything','line_number':371,'multiline':False]['text':' Other types can be compared by their ptr value','line_number':377,'multiline':False]['text':'/ @private [doxygen private]','line_number':381,'multiline':False]['text':'/ @private [doxygen private]','line_number':397,'multiline':False]['text':' As far as I can tell, omitting the usual explicit destructor call','line_number':403,'multiline':False]['text':' is not UB in and of itself, and it's a slight perf win. The','line_number':404,'multiline':False]['text':' destructor is a no-op, because the moved-from Tensor is','line_number':405,'multiline':False]['text':' effectively an intrusive_ptr in the null state, so we don't need','line_number':406,'multiline':False]['text':' the behavior for correctness reasons either. Leaving this','line_number':407,'multiline':False]['text':' explanatory comment, including commented-out destructor call, to','line_number':408,'multiline':False]['text':' make this abundantly clear.','line_number':409,'multiline':False]['text':'','line_number':410,'multiline':False]['text':' payload.as_tensor.~Tensor();','line_number':411,'multiline':False]['text':' Accessors for subtypes are arranged together below','line_number':423,'multiline':False]['text':' While some of these accessors could be generated through templates,','line_number':424,'multiline':False]['text':' we prefer to write them manually for clarity','line_number':425,'multiline':False]['text':' Outlined error path so that toTensor() can be inlined.','line_number':435,'multiline':False]['text':'/ @private [doxygen private]','line_number':464,'multiline':False]['text':' TODO (after Tensor merge) If we pass in a Blob holding a Tensor, extract','line_number':466,'multiline':False]['text':' and store it as a Tensor instead.','line_number':467,'multiline':False]['text':'/ @private [doxygen private]','line_number':471,'multiline':False]['text':'/ @private [doxygen private]','line_number':476,'multiline':False]['text':'/ @private [doxygen private]','line_number':479,'multiline':False]['text':' Capsule. No new callsites of these APIs should','line_number':482,'multiline':False]['text':' be introduced.','line_number':483,'multiline':False]['text':' Custom C++ classes','line_number':492,'multiline':False]['text':' Tuple','line_number':505,'multiline':False]['text':' Double','line_number':531,'multiline':False]['text':' ComplexDouble','line_number':543,'multiline':False]['text':' Future','line_number':551,'multiline':False]['text':' RRef','line_number':566,'multiline':False]['text':' Quantizer','line_number':574,'multiline':False]['text':' Int','line_number':582,'multiline':False]['text':' allow you to pass literals (3, 4) without ambiguity','line_number':638,'multiline':False]['text':' Bool','line_number':650,'multiline':False]['text':' Initializing entire payload stops valgrind's from reporting','line_number':653,'multiline':False]['text':' "jump or move depends on uninitialised value" in IValue copy constructor','line_number':654,'multiline':False]['text':' See https://github.com/pytorch/pytorch/issues/37117','line_number':655,'multiline':False]['text':' IntList','line_number':669,'multiline':False]['text':' ConstantString','line_number':678,'multiline':False]['text':' DoubleList','line_number':693,'multiline':False]['text':' ComplexDoubleList','line_number':699,'multiline':False]['text':' BoolList','line_number':705,'multiline':False]['text':' TensorList','line_number':710,'multiline':False]['text':' OptionalTensorList','line_number':716,'multiline':False]['text':' GenericList','line_number':722,'multiline':False]['text':' Some template constructors of IValue calls another constructor recursively.','line_number':731,'multiline':False]['text':' This SFINAEs the called constructor exists.','line_number':732,'multiline':False]['text':' The rule for lists is more complicated; the generic constructor is only','line_number':737,'multiline':False]['text':' acceptable if your element isn't SymInt.  If you do have a SymInt element,','line_number':738,'multiline':False]['text':' then you must also, at construction time, check if you can decay the list','line_number':739,'multiline':False]['text':' into an int list (this is MANDATORY, as at a use site we may expect','line_number':740,'multiline':False]['text':' toIntList to work even if at the call site you had a SymIntArrayRef','line_number':741,'multiline':False]['text':' argument).  In practice, only SymIntArrayRef is used this way, so we','line_number':742,'multiline':False]['text':' didn't bother making it work for the other constructors, we just make sure','line_number':743,'multiline':False]['text':' they're not selectable.','line_number':744,'multiline':False]['text':' Manual constructors for lists of symints, which decay to int list if','line_number':762,'multiline':False]['text':' possible.  To avoid ambiguous overload situations, we template them','line_number':763,'multiline':False]['text':' to prevent implicit conversions','line_number':764,'multiline':False]['text':' GenericDict','line_number':787,'multiline':False]['text':'/ \cond','line_number':799,'multiline':False]['text':'/ DOXYGEN_CANNOT_HANDLE_CONSTRUCTORS_WITH_MACROS_SO_EXCLUDE_THIS_LINE_FROM_DOXYGEN','line_number':800,'multiline':False]['text':'/ \endcond','line_number':803,'multiline':False]['text':' ClassType','line_number':812,'multiline':False]['text':' PyObject','line_number':824,'multiline':False]['text':' Enum','line_number':833,'multiline':False]['text':' None','line_number':841,'multiline':False]['text':' Scalar, which gets encoded as either an Int, a Double or a ComplexDouble','line_number':857,'multiline':False]['text':' NB: do the symbolic versions first, as isFloatingPoint is true','line_number':859,'multiline':False]['text':' for both SymFloat and double','line_number':860,'multiline':False]['text':' Device','line_number':909,'multiline':False]['text':' Stream','line_number':922,'multiline':False]['text':' ScalarType','line_number':933,'multiline':False]['text':' Layout','line_number':940,'multiline':False]['text':' MemoryFormat','line_number':947,'multiline':False]['text':' QScheme','line_number':954,'multiline':False]['text':' Dimname','line_number':963,'multiline':False]['text':' Generator','line_number':970,'multiline':False]['text':' for debugging','line_number':981,'multiline':False]['text':' generic v.to<at::Tensor>() implementations','line_number':993,'multiline':False]['text':' that can be used in special functions like pop/push','line_number':994,'multiline':False]['text':' that use template meta-programming.','line_number':995,'multiline':False]['text':' prefer the directly named methods when you can,','line_number':996,'multiline':False]['text':' since they are simpler to understand','line_number':997,'multiline':False]['text':' Note: if you get linker errors saying one of these is missing,','line_number':999,'multiline':False]['text':' change it to ... && = delete; and you will see better error messages for','line_number':1000,'multiline':False]['text':' why However, we cannot commit this because some compiler versions barf on','line_number':1001,'multiline':False]['text':' it.','line_number':1002,'multiline':False]['text':' ToOptional: convert a IValue to the Optional obj that accepts both T and','line_number':1009,'multiline':False]['text':' None','line_number':1010,'multiline':False]['text':'/ @private [doxygen private]','line_number':1016,'multiline':False]['text':'/ this is a shallow comparison of two IValues to test the object identity','line_number':1017,'multiline':False]['text':' Computes the "official" string representation of an IValue. This produces a','line_number':1020,'multiline':False]['text':' TorchScript expression that can be used to recreate an IValue with the same','line_number':1021,'multiline':False]['text':' value (e.g. when we are printing constants in the serializer).','line_number':1022,'multiline':False]['text':'','line_number':1023,'multiline':False]['text':' Callers can use `customFormatter` to override how `repr()` prints out an','line_number':1024,'multiline':False]['text':' IValue. This is useful if you have some other environment where you can','line_number':1025,'multiline':False]['text':' look up values, and you want to print a reference to that environment (like','line_number':1026,'multiline':False]['text':' the serializer's constant table).','line_number':1027,'multiline':False]['text':'','line_number':1028,'multiline':False]['text':' repr() is not necessarily defined on all objects!','line_number':1029,'multiline':False]['text':' Computes an "informal" string representation of an IValue. This should be','line_number':1035,'multiline':False]['text':' used for debugging, or servicing `print()`-like functions.','line_number':1036,'multiline':False]['text':' This is different from `repr()` in that there is no expectation that we can','line_number':1037,'multiline':False]['text':' exactly reconstruct an IValue from the output; feel free to use a','line_number':1038,'multiline':False]['text':' concise/pretty form','line_number':1039,'multiline':False]['text':'/ @private [doxygen private]','line_number':1049,'multiline':False]['text':' Detect aliased tensors.','line_number':1065,'multiline':False]['text':' COO sparse tensors have a "values" tensor and an "indices" tensor','line_number':1069,'multiline':False]['text':' so this will detect overlap of sparse tensors that share a values','line_number':1070,'multiline':False]['text':' tensor, but not sparse tensors that share an indices tensor.','line_number':1071,'multiline':False]['text':' COO sparse tensors have a "values" tensor and an "indices" tensor','line_number':1074,'multiline':False]['text':' so this will detect overlap of sparse tensors that share a values','line_number':1075,'multiline':False]['text':' tensor, but not sparse tensors that share an indices tensor.','line_number':1076,'multiline':False]['text':' Opaque tensors such as the ones constructed by the MKL-DNN backend','line_number':1079,'multiline':False]['text':' don't have storage so we just use their TensorImpls.','line_number':1080,'multiline':False]['text':' TODO: Find way to expose alias info for opaque tensors.','line_number':1081,'multiline':False]['text':' If it is not a Tensor, then two mutable IValues alias each other only','line_number':1091,'multiline':False]['text':' if they are the same pointer.','line_number':1092,'multiline':False]['text':' Chechs if this and rhs has a subvalues in common.','line_number':1108,'multiline':False]['text':' [t1,t2] and [t2, t3] returns true.','line_number':1109,'multiline':False]['text':' Inserts all subvalues of this in subValues.','line_number':1112,'multiline':False]['text':' Apply visitor to every subvalue.','line_number':1115,'multiline':False]['text':' TODO: There are several places that recurse over IValue. This is fragile.','line_number':1116,'multiline':False]['text':' This visitor should be used to recurse over ivalues.','line_number':1117,'multiline':False]['text':' NOTE: IValue tags are intentionally private. In the future we may encode','line_number':1133,'multiline':False]['text':' this value different (e.g. using NaN boxing), and this would make it more','line_number':1134,'multiline':False]['text':' costly to determine the tag for all types vs just determining if something','line_number':1135,'multiline':False]['text':' is a particular type. Instead we want clients to use the `isX` methods when','line_number':1136,'multiline':False]['text':' possible. If for perf. reasons you really, absolutely, must have a jump','line_number':1137,'multiline':False]['text':' table, then we can revisit this.','line_number':1138,'multiline':False]['text':' We carefully construct this call to both 1) avoid UB by using','line_number':1159,'multiline':False]['text':' the "wrong" one of as_tensor and as_intrusive_ptr and 2) enable','line_number':1160,'multiline':False]['text':' the compiler to generate the same code for each case. It is','line_number':1161,'multiline':False]['text':' surprisingly difficult to get this right.','line_number':1162,'multiline':False]['text':' No need to make this destructor call!','line_number':1169,'multiline':False]['text':' payload.as_tensor.~Tensor();','line_number':1170,'multiline':False]['text':' As far as I can tell, omitting the usual explicit destructor call','line_number':1177,'multiline':False]['text':' is not UB in and of itself, and it's a slight perf win. The','line_number':1178,'multiline':False]['text':' destructor is a no-op, because the moved-from Tensor is','line_number':1179,'multiline':False]['text':' effectively an intrusive_ptr in the null state, so we don't need','line_number':1180,'multiline':False]['text':' the behavior for correctness reasons either. Leaving this','line_number':1181,'multiline':False]['text':' explanatory comment, including commented-out destructor call, to','line_number':1182,'multiline':False]['text':' make this abundantly clear.','line_number':1183,'multiline':False]['text':'','line_number':1184,'multiline':False]['text':' rhs.payload.as_tensor.~Tensor();','line_number':1185,'multiline':False]['text':' This is the source of truth for isIntrusivePtr; edit results here','line_number':1199,'multiline':False]['text':' as needed and isIntrusivePtr will pick them up.','line_number':1200,'multiline':False]['text':' NOLINTBEGIN(bugprone-branch-clone)','line_number':1201,'multiline':False]['text':' NOLINTEND(bugprone-branch-clone)','line_number':1261,'multiline':False]['text':' Don't edit this just to add results for new tags; edit','line_number':1264,'multiline':False]['text':' isIntrusivePtrConstexpr above.','line_number':1265,'multiline':False]['text':' Implementation NOTE: the switch in isIntrusivePtrConstexpr','line_number':1267,'multiline':False]['text':' above is the previous production implementation of this','line_number':1268,'multiline':False]['text':' function. We observed that, at least on x86_64, the generated','line_number':1269,'multiline':False]['text':' instruction sequence was a similar bit vector test to what we','line_number':1270,'multiline':False]['text':' have manually implemented below, except that there was an extra','line_number':1271,'multiline':False]['text':' "bounds check" branch confirming, essentially, that `tag <','line_number':1272,'multiline':False]['text':' kNumTags` and providing a consistent result in that case. We','line_number':1273,'multiline':False]['text':' don't care about the result if tag is out of bounds, so we'd','line_number':1274,'multiline':False]['text':' like to eliminate that comparison and branch; manually','line_number':1275,'multiline':False]['text':' implementing this function as a bit test is the simplest way I','line_number':1276,'multiline':False]['text':' could find to accomplish that elimination.','line_number':1277,'multiline':False]['text':' Storage and Generator were treated specially when','line_number':1292,'multiline':False]['text':' is_intrusive_ptr was stored as explicit state. This getter','line_number':1293,'multiline':False]['text':' preserves the old behavior for use with WeakIValue for now.','line_number':1294,'multiline':False]['text':' [TriviallyCopyablePayload]','line_number':1305,'multiline':False]['text':' We use a nested union here so that we can make the copy easy','line_number':1306,'multiline':False]['text':' and efficient in the non-tensor (i.e., trivially copyable)','line_number':1307,'multiline':False]['text':' case. Specifically, we do not have to do a switch-on-tag to','line_number':1308,'multiline':False]['text':' figure out which union member to assign; we can just use','line_number':1309,'multiline':False]['text':' TriviallyCopyablePayload::operator=.','line_number':1310,'multiline':False]['text':' Invariant: never nullptr; null state is represented as','line_number':1316,'multiline':False]['text':' c10::UndefinedTensorImpl::singleton() for consistency of','line_number':1317,'multiline':False]['text':' representation with Tensor.','line_number':1318,'multiline':False]['text':' this also sets rhs to None','line_number':1384,'multiline':False]['text':' An owning pointer to a type. When the type is class type, it requires a pair','line_number':1470,'multiline':False]['text':' of shared_ptrs to the class type and its owning CU, so that the class type is','line_number':1471,'multiline':False]['text':' guaranteed to stay alive as long as we hold this object.','line_number':1472,'multiline':False]['text':' [Constant Object Weak CompilationUnit Reference]','line_number':1480,'multiline':False]['text':' A non owning pointer to a type. When a class get inserted as a constant','line_number':1481,'multiline':False]['text':' into a graph, if we used a strong pointer we would have a circular reference','line_number':1482,'multiline':False]['text':' from Object -> CompilationUnit and CompilationUnit -> Graph (which owns the','line_number':1483,'multiline':False]['text':' Constant Object)','line_number':1484,'multiline':False]['text':' internal build errors with std::variant :/','line_number':1492,'multiline':False]['text':' An Object will hold a non-owning Compilation Unit reference if it is a','line_number':1524,'multiline':False]['text':' Constant in the graph and a Owning reference otherwise','line_number':1525,'multiline':False]['text':' namespace c10','line_number':1549,'multiline':False]['text':' IWYU pragma: keep','line_number':1551,'multiline':False]