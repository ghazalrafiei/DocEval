['text':' This file contains boxing (not unboxing) logic,','line_number':3,'multiline':False]['text':' i.e. how to make a vector<IValue> from a set of concrete arguments.','line_number':4,'multiline':False]['text':'','line_number':17,'multiline':False]['text':' utils','line_number':18,'multiline':False]['text':'','line_number':19,'multiline':False]['text':' is_mutable_tensor_ref','line_number':21,'multiline':False]['text':' is_tuple_of_mutable_tensor_refs','line_number':25,'multiline':False]['text':'','line_number':26,'multiline':False]['text':' has_ivalue_to<T> tests the presence/absence of instance method IValue::to<T>()','line_number':35,'multiline':False]['text':'','line_number':36,'multiline':False]['text':'','line_number':45,'multiline':False]['text':' boxing predicates','line_number':46,'multiline':False]['text':'','line_number':47,'multiline':False]['text':' A boxable arg type is one that IValue has a constructor for.','line_number':49,'multiline':False]['text':' TensorOptions are not directly constructible into IValue,','line_number':54,'multiline':False]['text':' but torch::jit::push knows how to handle them','line_number':55,'multiline':False]['text':' an unboxable result is one that can be extracted from an IValue','line_number':62,'multiline':False]['text':' void returns are ok','line_number':68,'multiline':False]['text':'','line_number':74,'multiline':False]['text':' boxArgs - utility for pushing unboxed args onto IValue stack','line_number':75,'multiline':False]['text':'','line_number':76,'multiline':False]['text':' TODO Reuse stack vector instead of allocating?','line_number':79,'multiline':False]['text':' torch::jit::push pushes 4 values for a TensorOptions; this needs to','line_number':92,'multiline':False]['text':' be kept in sync.','line_number':93,'multiline':False]['text':' NOTE: this could probably be simplified with C++17 fold expressions.','line_number':99,'multiline':False]['text':'','line_number':133,'multiline':False]['text':' PopResult is a helper class whose specializations handle popping single and','line_number':134,'multiline':False]['text':' multiple return values, respectively.','line_number':135,'multiline':False]['text':'','line_number':136,'multiline':False]['text':' for tuple return types, boxed kernel has pushed multiple values onto the stack','line_number':154,'multiline':False]['text':' note: this has been moved into its own helper only to avoid a parse error on `indices` otherwise.','line_number':164,'multiline':False]['text':' I'm sure there's an incantation that slips it past the parser but eh','line_number':165,'multiline':False]['text':'','line_number':172,'multiline':False]['text':' BoxedKernelWrapper','line_number':173,'multiline':False]['text':'','line_number':174,'multiline':False]['text':' For a given function type FT, BoxedKernelWrapper<FT> implements','line_number':175,'multiline':False]['text':' a `call` method that','line_number':176,'multiline':False]['text':' - takes a boxed kernel and unboxed arguments as specified by FT,','line_number':177,'multiline':False]['text':' - calls `boxArgs` to box the arguments','line_number':178,'multiline':False]['text':' - calls the boxed kernel','line_number':179,'multiline':False]['text':' - unboxes and returns the result','line_number':180,'multiline':False]['text':'','line_number':181,'multiline':False]['text':' The partial specializations below handle various cases: in','line_number':182,'multiline':False]['text':' particular, not all types appearing in op signatures are supported,','line_number':183,'multiline':False]['text':' and ops returning references have nonstandard wrapper implementations.','line_number':184,'multiline':False]['text':'','line_number':185,'multiline':False]['text':' 1. The base specialization of BoxedKernelWrapper should never be instantiated.','line_number':187,'multiline':False]['text':' A "no call method defined on BoxedKernelWrapper" compile error means that','line_number':188,'multiline':False]['text':' an op signature has failed to trigger any of the partial specializations','line_number':189,'multiline':False]['text':' that follow this one.','line_number':190,'multiline':False]['text':'','line_number':191,'multiline':False]['text':' The reason we're not just doing straight up static_assert(false, ...) here:','line_number':194,'multiline':False]['text':' Basically, the way to make sure a static_assert only fires if a template','line_number':195,'multiline':False]['text':' is actually instantiated (rather than every time the file is parsed) is to use','line_number':196,'multiline':False]['text':' template parameters in the expression, e.g. FuncType here. However, since','line_number':197,'multiline':False]['text':' `sizeof(FuncType) != sizeof(FuncType)` is always false, this has the same','line_number':198,'multiline':False]['text':' effect.','line_number':199,'multiline':False]['text':'','line_number':207,'multiline':False]['text':' 2. Supported signatures, other than those involving non-const Tensor refs -','line_number':208,'multiline':False]['text':' i.e., "functional" ops.','line_number':209,'multiline':False]['text':'','line_number':210,'multiline':False]['text':' op has pushed one or more values onto the stack.','line_number':230,'multiline':False]['text':' op returns void, boxed kernel has pushed nothing onto stack.','line_number':233,'multiline':False]['text':'','line_number':243,'multiline':False]['text':' 3. in-place ops take a single non-const Tensor reference','line_number':244,'multiline':False]['text':' as their first argument, and return it.','line_number':245,'multiline':False]['text':'','line_number':246,'multiline':False]['text':' Note: all signatures matching this pattern are assumed to be for such ops.','line_number':247,'multiline':False]['text':' Because of this, the generated BoxedKernelWrapper specializations simply','line_number':248,'multiline':False]['text':' return the in-place argument.','line_number':249,'multiline':False]['text':'','line_number':250,'multiline':False]['text':'','line_number':275,'multiline':False]['text':' 3.5. In-process migration to make in-place ops take and return','line_number':276,'multiline':False]['text':' const references instead.','line_number':277,'multiline':False]['text':'','line_number':301,'multiline':False]['text':' 4. out of place ops that take a single non-const Tensor reference as their','line_number':302,'multiline':False]['text':' final argument, and also return it.','line_number':303,'multiline':False]['text':'','line_number':304,'multiline':False]['text':' Note: all signatures matching this pattern are assumed to be for such ops.','line_number':305,'multiline':False]['text':' This assumption permits the generated BoxedKernelWrapper specializations to simply','line_number':306,'multiline':False]['text':' return out arguments.','line_number':307,'multiline':False]['text':'','line_number':308,'multiline':False]['text':' this skips over in-place kernels with a non-const Tensor','line_number':314,'multiline':False]['text':' arg at the front, so those can unambiguously trigger the preceding specialization.','line_number':315,'multiline':False]['text':' reusing restArgs after it has been forwarded here is ok because we know','line_number':334,'multiline':False]['text':' that the last element is of type `Tensor&`.','line_number':335,'multiline':False]['text':'','line_number':340,'multiline':False]['text':' 5. out of place ops that take multiple non-const Tensor references as their','line_number':341,'multiline':False]['text':' final arguments, and return them in a std::tuple.','line_number':342,'multiline':False]['text':'','line_number':343,'multiline':False]['text':' Note: all signatures matching this pattern are assumed to be for such ops.','line_number':344,'multiline':False]['text':' This assumption permits the generated BoxedKernelWrapper specializations to simply','line_number':345,'multiline':False]['text':' return the out arguments.','line_number':346,'multiline':False]['text':'','line_number':347,'multiline':False]['text':' reusing args after it has been forwarded here is ok because we know','line_number':373,'multiline':False]['text':' that the last RetCount elements are of type `Tensor&`.','line_number':374,'multiline':False]['text':' impl','line_number':385,'multiline':False]['text':' c10','line_number':386,'multiline':False]