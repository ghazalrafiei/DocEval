['text':' aten_interned_strings.h includes the names of all operators','line_number':1,'multiline':False]['text':' NOLINTBEGIN(cppcoreguidelines-avoid-const-or-ref-data-members)','line_number':11,'multiline':False]['text':' NOLINTEND(cppcoreguidelines-avoid-const-or-ref-data-members)','line_number':18,'multiline':False]['text':' NOTE: we could save even more space by packing the string data as follows:','line_number':33,'multiline':False]['text':' constexpr char namespaces[] = "namespaces\0prim\0aten\0...";','line_number':34,'multiline':False]['text':' constexpr char unqual_names[] = "prim\0aten\0cuda\0...";','line_number':35,'multiline':False]['text':' and then storing two uint16_t (or uint32_t if needed) offsets into','line_number':36,'multiline':False]['text':' the raw string tables in Entry instead of 8-byte pointers.','line_number':37,'multiline':False]['text':' I haven't implemented that because it's not clear to me how to','line_number':38,'multiline':False]['text':' dedupe the namespaces array at compile-time, particularly in C++14,','line_number':39,'multiline':False]['text':' but it would be straightforward if we switched to codegen.','line_number':40,'multiline':False]['text':' NOLINTNEXTLINE(modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays)','line_number':41,'multiline':False]['text':' namespace','line_number':49,'multiline':False]['text':' Instead of a loop, this could be done by expanding the','line_number':53,'multiline':False]['text':' assignments directly into FORALL_NS_SYMBOLS, but it would create','line_number':54,'multiline':False]['text':' a huge function (thanks to all the std::string constructors and','line_number':55,'multiline':False]['text':' operator[]s) which would take several minutes to optimize. A','line_number':56,'multiline':False]['text':' static C array of constexpr-constructible structs takes instead','line_number':57,'multiline':False]['text':' no time to compile.','line_number':58,'multiline':False]['text':' namespace c10','line_number':67,'multiline':False]