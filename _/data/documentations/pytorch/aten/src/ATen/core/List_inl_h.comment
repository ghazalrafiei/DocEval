['text':' If there's other instances of the list (i.e. list.use_count() > 1), then we have to be invariant','line_number':57,'multiline':False]['text':' because upcasting would allow people to add types into the new list that would break the old list.','line_number':58,'multiline':False]['text':' However, if there aren't any other instances of this list (i.e. list.use_count() == 1), then we can','line_number':59,'multiline':False]['text':' allow upcasting. This can be a perf improvement since we can cast List<T> to List<optional<T>>','line_number':60,'multiline':False]['text':' without having to copy it. This is also used to provide backwards compatibility with some old models','line_number':61,'multiline':False]['text':' that serialized the index arguments to aten::index, aten::index_put, aten::index_put_ and aten::index_put_impl_','line_number':62,'multiline':False]['text':' as List<Tensor> before we changed that argument to be List<optional<Tensor>>. When deserializing, we','line_number':63,'multiline':False]['text':' have list.use_count() == 1 and can deserialize the List<Tensor> directly as List<optional<Tensor>>.','line_number':64,'multiline':False]['text':' namespace impl','line_number':176,'multiline':False]['text':' Throw the exception if it is out of range.','line_number':200,'multiline':False]['text':' Reset the list element to a T() instead of None to keep it correctly typed','line_number':208,'multiline':False]['text':' TODO Use list_element_from?','line_number':256,'multiline':False]['text':' TODO Use list_element_from?','line_number':282,'multiline':False]['text':' Lists with the same identity trivially compare equal.','line_number':313,'multiline':False]['text':' Otherwise, just compare values directly.','line_number':318,'multiline':False]