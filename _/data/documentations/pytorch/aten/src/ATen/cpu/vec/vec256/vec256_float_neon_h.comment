['text':' DO NOT DEFINE STATIC DATA IN THIS HEADER!','line_number':3,'multiline':False]['text':' See Note [Do not compile initializers with AVX]','line_number':4,'multiline':False]['text':' Sleef offers vectorized versions of some transcedentals','line_number':14,'multiline':False]['text':' such as sin, cos, tan etc..','line_number':15,'multiline':False]['text':' However for now opting for STL, since we are not building','line_number':16,'multiline':False]['text':' with Sleef for mobile yet.','line_number':17,'multiline':False]['text':' See Note [CPU_CAPABILITY namespace]','line_number':20,'multiline':False]['text':' Right now contains only aarch64 implementation.','line_number':23,'multiline':False]['text':' Due to follow two reasons aarch32 is not currently supported.','line_number':24,'multiline':False]['text':' 1. Due to difference in ISA been aarch32 and aarch64, intrinsics','line_number':25,'multiline':False]['text':'    that work for aarch64 dont work for aarch32.','line_number':26,'multiline':False]['text':' 2. Android NDK r21 has problems with compiling aarch32.','line_number':27,'multiline':False]['text':'    Clang seg faults.','line_number':28,'multiline':False]['text':'    https://github.com/android/ndk/issues/1248','line_number':29,'multiline':False]['text':'    https://bugs.llvm.org/show_bug.cgi?id=45824','line_number':30,'multiline':False]['text':' Most likely we will do aarch32 support with inline asm.','line_number':31,'multiline':False]['text':' 0.','line_number':88,'multiline':False]['text':' 1.','line_number':101,'multiline':False]['text':' TODO','line_number':118,'multiline':False]['text':' NB: This requires that each value, i.e., each uint value,','line_number':119,'multiline':False]['text':' of the mask either all be zeros or all be 1s.','line_number':120,'multiline':False]['text':' We perhaps need some kind of an assert?','line_number':121,'multiline':False]['text':' But that will affect performance.','line_number':122,'multiline':False]['text':' Very slow implementation of indexing.','line_number':270,'multiline':False]['text':' Only required because vec256_qint refers to this.','line_number':271,'multiline':False]['text':' Once we specialize that implementation for ARM','line_number':272,'multiline':False]['text':' this should be removed. TODO (kimishpatel)','line_number':273,'multiline':False]['text':' For boolean version where we want to if any 1/all zero','line_number':284,'multiline':False]['text':' etc. can be done faster in a different way.','line_number':285,'multiline':False]['text':' We do not use std::round because we would like to round midway numbers to the nearest even integer.','line_number':571,'multiline':False]['text':' frac. Implement this here so we can use subtraction','line_number':712,'multiline':False]['text':' Implements the IEEE 754 201X `maximum` operation, which propagates NaN if','line_number':717,'multiline':False]['text':' either input is a NaN.','line_number':718,'multiline':False]['text':' Implements the IEEE 754 201X `minimum` operation, which propagates NaN if','line_number':726,'multiline':False]['text':' either input is a NaN.','line_number':727,'multiline':False]['text':' constants','line_number':850,'multiline':False]['text':' sign(x)','line_number':859,'multiline':False]['text':' t = 1 / (p * abs(x) + 1)','line_number':862,'multiline':False]['text':' r = p5 * t ^ 4 + p4 * t ^ 3 + p3 * t ^ 2 + p2 * t + p1','line_number':865,'multiline':False]['text':' - exp(- x * x)','line_number':870,'multiline':False]['text':' This can be swapped for a faster implementation of exp.','line_number':873,'multiline':False]['text':' erf(x) = sign(x) * (1 - r * t * exp(- x * x))','line_number':875,'multiline':False]['text':' defined(aarch64) ','line_number':880,'multiline':True]['text':' namespace at::vec::CPU_CAPABILITY','line_number':882,'multiline':False]