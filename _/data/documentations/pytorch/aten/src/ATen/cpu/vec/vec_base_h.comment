['text':' DO NOT DEFINE STATIC DATA IN THIS HEADER!','line_number':3,'multiline':False]['text':' See Note [Do not compile initializers with AVX]','line_number':4,'multiline':False]['text':'','line_number':5,'multiline':False]['text':' Note [Do not compile initializers with AVX]','line_number':6,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':7,'multiline':False]['text':' If you define a static initializer in this file, the initialization will use','line_number':8,'multiline':False]['text':' AVX instructions because these object files are compiled with AVX enabled.','line_number':9,'multiline':False]['text':' We need to avoid non-trivial global data in these architecture specific files','line_number':10,'multiline':False]['text':' because there's no way to guard the global initializers with CPU capability','line_number':11,'multiline':False]['text':' detection.','line_number':12,'multiline':False]['text':'','line_number':13,'multiline':False]['text':' See https://github.com/pytorch/pytorch/issues/37577 for an instance','line_number':14,'multiline':False]['text':' of this bug in the past.','line_number':15,'multiline':False]['text':' These macros helped us unify vec_base.h','line_number':41,'multiline':False]['text':' CPU_CAPABILITY_AVX512','line_number':52,'multiline':False]['text':' CPU_CAPABILITY_AVX512','line_number':62,'multiline':False]['text':' See Note [CPU_CAPABILITY namespace]','line_number':65,'multiline':False]['text':' at::Half and at::BFloat16 should be treated as floating point','line_number':67,'multiline':False]['text':' NOTE: If you specialize on a type, you must define all operations!','line_number':104,'multiline':False]['text':' emulates Vectorized types','line_number':106,'multiline':False]['text':' Note [constexpr static function to avoid odr-usage compiler bug]','line_number':118,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':119,'multiline':False]['text':' Why, you might ask, is size defined to be a static constexpr function,','line_number':120,'multiline':False]['text':' rather than a more ordinary 'static constexpr int size;' variable?','line_number':121,'multiline':False]['text':' The problem lies within ODR rules for static constexpr members versus','line_number':122,'multiline':False]['text':' static constexpr functions.  First, recall that this class (along with all','line_number':123,'multiline':False]['text':' of its derivations) live in an anonymous namespace: they are intended to be','line_number':124,'multiline':False]['text':' *completely* inlined at their use-sites, because we need to compile it','line_number':125,'multiline':False]['text':' multiple times for different instruction sets.','line_number':126,'multiline':False]['text':'','line_number':127,'multiline':False]['text':' Because of this constraint, we CANNOT provide a single definition for','line_number':128,'multiline':False]['text':' any static members in this class; since we want to compile the class','line_number':129,'multiline':False]['text':' multiple times, there wouldn't actually be any good place to put the','line_number':130,'multiline':False]['text':' definition.  Now here is the problem: if we ODR-use a static constexpr','line_number':131,'multiline':False]['text':' member, we are *obligated* to provide a definition.  Without the','line_number':132,'multiline':False]['text':' definition, you get a compile error like:','line_number':133,'multiline':False]['text':'','line_number':134,'multiline':False]['text':'    relocation R_X86_64_PC32 against undefined symbol','line_number':135,'multiline':False]['text':'    `_ZN2at6vec25612_GLOBAL__N_16VectorizedIdE4sizeE' can not be used when making','line_number':136,'multiline':False]['text':'    a shared object; recompile with -fPIC','line_number':137,'multiline':False]['text':'','line_number':138,'multiline':False]['text':' If this were C++17, we could replace a static constexpr variable with','line_number':139,'multiline':False]['text':' an inline variable which doesn't require one definition. But we are not','line_number':140,'multiline':False]['text':' C++17.  So the next best thing is to replace the member with a static','line_number':141,'multiline':False]['text':' constexpr (and therefore inline) function, which does not require ODR','line_number':142,'multiline':False]['text':' either.','line_number':143,'multiline':False]['text':'','line_number':144,'multiline':False]['text':' Also, technically according to the C++ standard, we don't have to define','line_number':145,'multiline':False]['text':' a constexpr variable if we never odr-use it.  But it seems that some','line_number':146,'multiline':False]['text':' versions GCC/Clang have buggy determinations on whether or not an','line_number':147,'multiline':False]['text':' identifier is odr-used or not, and in any case it's hard to tell if','line_number':148,'multiline':False]['text':' a variable is odr-used or not.  So best to just cut the problem at the root.','line_number':149,'multiline':False]['text':' Workaround to compile with VS2022.','line_number':150,'multiline':False]['text':' This also implies const T& operator[](int idx) const','line_number':164,'multiline':False]['text':' This also implies T& operator[](int idx)','line_number':168,'multiline':False]['text':' Return the values as char* for type punning','line_number':172,'multiline':False]['text':' step sometimes requires a higher precision type (e.g., T=int, step_t=double)','line_number':205,'multiline':False]['text':' returns an integer mask where all zero elements are translated to 1-bit and others are translated to 0-bit','line_number':238,'multiline':False]['text':' other_t_abs is for SFINAE and clarity. Make sure it is not changed.','line_number':275,'multiline':False]['text':' float_t_abs is for SFINAE and clarity. Make sure it is not changed.','line_number':282,'multiline':False]['text':' Specifically deal with floating-point because the generic code above won't handle -0.0 (which should result in','line_number':284,'multiline':False]['text':' 0.0) properly.','line_number':285,'multiline':False]['text':' complex_t_abs is for SFINAE and clarity. Make sure it is not changed.','line_number':291,'multiline':False]['text':' Specifically map() does not perform the type conversion needed by abs.','line_number':293,'multiline':False]['text':' other_t_angle is for SFINAE and clarity. Make sure it is not changed.','line_number':306,'multiline':False]['text':' compiler is unable to resolve the overload without <T>','line_number':308,'multiline':False]['text':' complex_t_angle is for SFINAE and clarity. Make sure it is not changed.','line_number':313,'multiline':False]['text':' other_t_real is for SFINAE and clarity. Make sure it is not changed.','line_number':320,'multiline':False]['text':' complex_t_real is for SFINAE and clarity. Make sure it is not changed.','line_number':327,'multiline':False]['text':' other_t_imag is for SFINAE and clarity. Make sure it is not changed.','line_number':334,'multiline':False]['text':' complex_t_imag is for SFINAE and clarity. Make sure it is not changed.','line_number':341,'multiline':False]['text':' other_t_conj is for SFINAE and clarity. Make sure it is not changed.','line_number':348,'multiline':False]['text':' complex_t_conj is for SFINAE and clarity. Make sure it is not changed.','line_number':355,'multiline':False]['text':' U is for SFINAE purposes only. Make sure it is not changed.','line_number':416,'multiline':False]['text':' other_t_log2 is for SFINAE and clarity. Make sure it is not changed.','line_number':436,'multiline':False]['text':' complex_t_log2 is for SFINAE and clarity. Make sure it is not changed.','line_number':443,'multiline':False]['text':' NB: the trailing return type is needed because we need to coerce the','line_number':491,'multiline':False]['text':' return value back to T in the case of unary operator- incuring a','line_number':492,'multiline':False]['text':' promotion','line_number':493,'multiline':False]['text':' We do not use std::round because we would like to round midway numbers to the nearest even integer.','line_number':504,'multiline':False]['text':' All bits are set to 1 if the pred is true, otherwise 0.','line_number':544,'multiline':False]['text':' 1 if the pred is true, otherwise 0.','line_number':567,'multiline':False]['text':' Implements the IEEE 754 201X `maximum` operation, which propagates NaN if','line_number':625,'multiline':False]['text':' either input is a NaN.','line_number':626,'multiline':False]['text':' If either input is NaN, propagate a NaN.','line_number':634,'multiline':False]['text':' NOTE: The case where b[i] was NaN is handled correctly by the naive','line_number':635,'multiline':False]['text':' ternary operator above.','line_number':636,'multiline':False]['text':' If either input is NaN, propagate a NaN.','line_number':650,'multiline':False]['text':' NOTE: The case where b[i] was NaN is handled correctly by the naive','line_number':651,'multiline':False]['text':' ternary operator above.','line_number':652,'multiline':False]['text':' Implements the IEEE 754 201X `minimum` operation, which propagates NaN if','line_number':659,'multiline':False]['text':' either input is a NaN.','line_number':660,'multiline':False]['text':' If either input is NaN, propagate a NaN.','line_number':668,'multiline':False]['text':' NOTE: The case where b[i] was NaN is handled correctly by the naive','line_number':669,'multiline':False]['text':' ternary operator above.','line_number':670,'multiline':False]['text':' If either input is NaN, propagate a NaN.','line_number':684,'multiline':False]['text':' NOTE: The case where b[i] was NaN is handled correctly by the naive','line_number':685,'multiline':False]['text':' ternary operator above.','line_number':686,'multiline':False]['text':' We enclose _mm512_and_si512 or _mm256_and_si256 with lambda because it is always_inline','line_number':749,'multiline':False]['text':' We enclose _mm512_or_si512 or _mm256_or_si256 with lambda because it is always_inline','line_number':758,'multiline':False]['text':' We enclose _mm512_xor_si512 or _mm256_xor_si256 with lambda because it is always_inline','line_number':767,'multiline':False]['text':' We should be using memcpy in order to respect the strict aliasing rule','line_number':790,'multiline':False]['text':' see: https://github.com/pytorch/pytorch/issues/66119','line_number':791,'multiline':False]['text':' Using char* is defined in the C11 standard 6.5 Expression paragraph 7','line_number':792,'multiline':False]['text':' (http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf)','line_number':793,'multiline':False]['text':' load each intmax_t chunk and process; increase pointers by sizeof(intmax_t)','line_number':796,'multiline':False]['text':' defined(CPU_CAPABILITY_AVX2) || defined(CPU_CAPABILITY_AVX512)','line_number':820,'multiline':False]['text':' All bits are 1','line_number':824,'multiline':False]['text':' right shift value to retain sign bit for signed and no bits for unsigned','line_number':844,'multiline':False]['text':' use int type so we can logical and','line_number':925,'multiline':False]['text':' check highest bit','line_number':932,'multiline':False]['text':' "zero out" mask','line_number':938,'multiline':False]['text':' Cast a given vector to another type without changing the bits representation.','line_number':942,'multiline':False]['text':' So a Vectorized<double> of 512 bits containing all ones can be cast to a','line_number':943,'multiline':False]['text':' Vectorized<int64_t> of 512 bits containing all ones (i.e., eight negative 1s).','line_number':944,'multiline':False]['text':' A Vec<double> of 256 bits containing all ones can be cast to a','line_number':945,'multiline':False]['text':' Vec<int64_t> of 256 bits containing all ones (i.e., four negative 1s).','line_number':946,'multiline':False]['text':' There is a struct here because we don't have static_if and I can't','line_number':947,'multiline':False]['text':' partially specialize a templated function.','line_number':948,'multiline':False]['text':' Example inputs for AVX512:','line_number':983,'multiline':False]['text':' a   Vectorized<float>   = {a0, b0, a1, b1, a2, b2, a3, b3, a4, b4, a5, b5, a6, b6, a7, b7}','line_number':984,'multiline':False]['text':' b   Vectorized<float>   = {a8, b8, a9, b9, a10, b10, a11, b11, a12, b12, a13, b13, a14, b14, a15, b15}','line_number':985,'multiline':False]['text':' returns:','line_number':986,'multiline':False]['text':'           Vectorized<float>   = {a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15}','line_number':987,'multiline':False]['text':'           Vectorized<float>   = {b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15}','line_number':988,'multiline':False]['text':' Example inputs for AVX2: a           Vectorized<float>   = {a0, b0, a1, b1, a2, b2, a3, b3}','line_number':989,'multiline':False]['text':'               b                      Vectorized<float>   = {a4, b4, a5, b5, a6, b6, a7, b7}','line_number':990,'multiline':False]['text':'       returns:                       Vectorized<float>   = {a0, a1, a2, a3, a4, a5, a6, a7}','line_number':991,'multiline':False]['text':'                                      Vectorized<float>   = {b0, b1, b2, b3, b4, b5, b6, b7}','line_number':992,'multiline':False]['text':' inverse operation of deinterleave2','line_number':1014,'multiline':False]['text':' Example inputs for AVX512:','line_number':1015,'multiline':False]['text':'  a       Vectorized<float>   = {a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15}','line_number':1016,'multiline':False]['text':'  b       Vectorized<float>   = {b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15}','line_number':1017,'multiline':False]['text':' returns, for AVX512:','line_number':1018,'multiline':False]['text':'          Vectorized<float>   = {a0, b0, a1, b1, a2, b2, a3, b3, a4, b4, a5, b5, a6, b6, a7, b7}','line_number':1019,'multiline':False]['text':'          Vectorized<float>   = {a8, b8, a9, b9, a10, b10, a11, b11, a12, b12, a13, b13, a14, b14, a15, b15}','line_number':1020,'multiline':False]['text':' Example inputs for AVX2 : a           Vectorized<float>   = {a0, a1, a2, a3, a4, a5, a6, a7}','line_number':1021,'multiline':False]['text':'                   b                   Vectorized<float>   = {b0, b1, b2, b3, b4, b5, b6, b7}','line_number':1022,'multiline':False]['text':'       returns:            Vectorized<float>   = {a0, b0, a1, b1, a2, b2, a3, b3}','line_number':1023,'multiline':False]['text':'                           Vectorized<float>   = {a4, b4, a5, b5, a6, b6, a7, b7}','line_number':1024,'multiline':False]['text':' Transpose the `src` buffer of type `T` and size (M,N) into the `dst` buffer. `ld_src` is the leading','line_number':1070,'multiline':False]['text':' dimension of `src` and `ld_dst` is the leading dimension of `dst`.','line_number':1071,'multiline':False]['text':' namespace at::vec::CPU_CAPABILITY','line_number':1081,'multiline':False]