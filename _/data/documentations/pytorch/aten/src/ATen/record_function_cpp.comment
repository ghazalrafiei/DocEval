['text':' Used to generate unique callback handles','line_number':17,'multiline':False]['text':' Enumerates thread ids logically;','line_number':30,'multiline':False]['text':' note: std::this_thread::get_id may return potentially','line_number':31,'multiline':False]['text':' reused thread id','line_number':32,'multiline':False]['text':' ============================================================================','line_number':58,'multiline':False]['text':' == Callback manager ========================================================','line_number':59,'multiline':False]['text':' ============================================================================','line_number':60,'multiline':False]['text':' The high level idea of the RecordFunction callback machinery is based on the','line_number':61,'multiline':False]['text':' observation that the set of callbacks to be run changes infrequently.','line_number':62,'multiline':False]['text':' However, in order to reuse the active set we have to be able to invalidate','line_number':63,'multiline':False]['text':' when the active set changes. There are three events that can change which','line_number':64,'multiline':False]['text':' callbacks should be run:','line_number':65,'multiline':False]['text':'  1) The set of global callbacks changes','line_number':66,'multiline':False]['text':'  2) The set of local callbacks changes','line_number':67,'multiline':False]['text':'  3) A sampling callback is present, and should run on this iteration','line_number':68,'multiline':False]['text':'','line_number':69,'multiline':False]['text':' Global callbacks rely on thread local replication and an atomic version','line_number':70,'multiline':False]['text':' counter to maintain consistency. Whenever we change the set of active global','line_number':71,'multiline':False]['text':' callbacks (add / remove / enable / disable) the `GlobalCallbackManager`','line_number':72,'multiline':False]['text':' increments the version number and updates the global state while holding','line_number':73,'multiline':False]['text':' a mutex. The local callback manager snapshots the global callbacks and','line_number':74,'multiline':False]['text':' lazily rebuilds by comparing`GlobalCallbackManager::version()` (which is','line_number':75,'multiline':False]['text':' a simple atomic read) to the version of the last rebuild. In the','line_number':76,'multiline':False]['text':' overwhelmingly common case that they match it can reuse the existing','line_number':77,'multiline':False]['text':' snapshot. Otherwise it must call the much more expensive (and locked)','line_number':78,'multiline':False]['text':' `GlobalCallbackManager::getSnapshot()`.','line_number':79,'multiline':False]['text':'','line_number':80,'multiline':False]['text':' Handling changes to the thread local callbacks is trivial; functions that','line_number':81,'multiline':False]['text':' change them can simply force a cache rebuild for that thread after the','line_number':82,'multiline':False]['text':' changes are made.','line_number':83,'multiline':False]['text':'','line_number':84,'multiline':False]['text':' Sampling is by far the most challenging to handle efficiently. In general','line_number':85,'multiline':False]['text':' sampling callbacks are expected to have very low frequency. (e.g. 1 per','line_number':86,'multiline':False]['text':' million) Random number generation is rather expensive, so flipping a coin on','line_number':87,'multiline':False]['text':' every call for every sampling callback is wasteful. We can significantly','line_number':88,'multiline':False]['text':' reduce this cost by noting that the number of failures of a Bernoulli random','line_number':89,'multiline':False]['text':' variable is a geometric distribution, and thus we can sample the geometric','line_number':90,'multiline':False]['text':' distribution to determine the next time a callback should run. This reduces','line_number':91,'multiline':False]['text':' the cost from a random sample to a simple integer decrement.','line_number':92,'multiline':False]['text':'','line_number':93,'multiline':False]['text':' We can further note that Bernoulli samples are independent. (In contrast to,','line_number':94,'multiline':False]['text':' say, sampling without replacement.) This means that we can generate a','line_number':95,'multiline':False]['text':' counter for each scope that a given callback supports and then decrement the','line_number':96,'multiline':False]['text':' counter corresponding to the RecordScope being called. Conceptually, this is','line_number':97,'multiline':False]['text':' analogous to flipping different coins with the same probability. By sharding','line_number':98,'multiline':False]['text':' on RecordScope, we can consolidate the decrement to a single shared counter','line_number':99,'multiline':False]['text':' and update individual counters during rebuild.','line_number':100,'multiline':False]['text':' Singleton','line_number':104,'multiline':False]['text':'                                                                Locking?','line_number':113,'multiline':False]['text':'                                     No','line_number':114,'multiline':False]['text':'                                Yes','line_number':115,'multiline':False]['text':'         Yes','line_number':116,'multiline':False]['text':'  Yes','line_number':117,'multiline':False]['text':'                    Yes','line_number':118,'multiline':False]['text':'                                         Yes','line_number':119,'multiline':False]['text':' Source of truth.','line_number':123,'multiline':False]['text':' The caller is expected to check `GlobalCallbackManager::get().version()'','line_number':132,'multiline':False]['text':' and call CacheEntry::update() if necessary.','line_number':133,'multiline':False]['text':' Full rebuild. (E.g. during registration)','line_number':137,'multiline':False]['text':' `-1` indicates that a callback is not sampled.','line_number':144,'multiline':False]['text':' std::mt19937 is quite large, so all scopes share the same generator.','line_number':153,'multiline':False]['text':' Includes sampling callbacks which are waiting to run.','line_number':156,'multiline':False]['text':' For managing sampling callbacks','line_number':162,'multiline':False]['text':' Singleton','line_number':169,'multiline':False]['text':' Source of truth.','line_number':199,'multiline':False]['text':' Runtime cache.','line_number':202,'multiline':False]['text':' ============================================================================','line_number':208,'multiline':False]['text':' == GlobalCallbackManager: Implementation ===================================','line_number':209,'multiline':False]['text':' ============================================================================','line_number':210,'multiline':False]['text':' ============================================================================','line_number':263,'multiline':False]['text':' == CacheEntry: Implementation ==============================================','line_number':264,'multiline':False]['text':' ============================================================================','line_number':265,'multiline':False]['text':' We rebuild the active set when `sampling_countdown_` reaches zero, so if it','line_number':283,'multiline':False]['text':' reaches zero at the start of this function something has gone wrong.','line_number':284,'multiline':False]['text':' Use inferred steps to update sampled callbacks.','line_number':288,'multiline':False]['text':' Determine which callbacks to run and for how long.','line_number':296,'multiline':False]['text':' Resample any sampled callbacks that ran this call.','line_number':299,'multiline':False]['text':' We could store thread ID in CacheEntry, but rebuilds are infrequent and','line_number':322,'multiline':False]['text':' this saves us from having to plumb it through.','line_number':323,'multiline':False]['text':' Callback is not sampled. Unconditionally push.','line_number':330,'multiline':False]['text':' Callback is sampled and we have reached a sampling event. Push and','line_number':335,'multiline':False]['text':' set `sampling_countdown_` to one so we trigger a rebuild after one call.','line_number':336,'multiline':False]['text':' Callback is sampled and we have not reached sampling event. Set','line_number':342,'multiline':False]['text':' `sampling_countdown_` to rebuild when it is time for this callback to','line_number':343,'multiline':False]['text':' execute.','line_number':344,'multiline':False]['text':' The geometric distribution returns the number of failures. We add one to','line_number':358,'multiline':False]['text':' also account for the call where we succeed.','line_number':359,'multiline':False]['text':' ============================================================================','line_number':363,'multiline':False]['text':' == LocalCallbackManager: Implementation ====================================','line_number':364,'multiline':False]['text':' ============================================================================','line_number':365,'multiline':False]['text':' defined(C10_PREFER_CUSTOM_THREAD_LOCAL_STORAGE)','line_number':370,'multiline':False]['text':' defined(C10_PREFER_CUSTOM_THREAD_LOCAL_STORAGE)','line_number':373,'multiline':False]['text':' Only rebuild scopes associated with `callback`','line_number':464,'multiline':False]['text':' ============================================================================','line_number':495,'multiline':False]['text':' == Callback execution ======================================================','line_number':496,'multiline':False]['text':' ============================================================================','line_number':497,'multiline':False]['text':' namespace','line_number':527,'multiline':False]['text':'is_start=','line_number':542,'multiline':True]['text':'is_start=','line_number':551,'multiline':True]['text':' namespace','line_number':634,'multiline':False]['text':' static ','line_number':705,'multiline':True]['text':' happens only once per thread','line_number':708,'multiline':False]['text':' static ','line_number':752,'multiline':True]['text':' static ','line_number':757,'multiline':True]['text':' namespace at','line_number':785,'multiline':False]