['text':' namespace internal','line_number':12,'multiline':False]['text':' NOTE: are_expandable did a similar check, please keep them sync if change is needed','line_number':15,'multiline':False]['text':' Use ptrdiff_t to ensure signed comparison.','line_number':23,'multiline':False]['text':' 1s map to the other size (even 0).','line_number':37,'multiline':False]['text':' create a new geometry for the tensors','line_number':77,'multiline':False]['text':' This function returns a dense and non-overlapping strides, which keeps the same layout permutation','line_number':134,'multiline':False]['text':' as the input `tensor_strides`, computed based on the input `tensor_sizes`.','line_number':135,'multiline':False]['text':' Note:','line_number':136,'multiline':False]['text':' 1. This function expects the inputs `tensor_strides` and `tensor_sizes` are non-dense or overlapping,','line_number':137,'multiline':False]['text':'    If the inputs are densed and non-overlapping, the output strides will be the same as `tensor_strides`.','line_number':138,'multiline':False]['text':'    However, this function won't check whether inputs are dense or overlapping, so the whole function will','line_number':139,'multiline':False]['text':'    still be executed even the inputs are already dense and non-overlapping, this will cause slowness.','line_number':140,'multiline':False]['text':'','line_number':141,'multiline':False]['text':'    Please verify whether the inputs are non-dense or overlapping before calling this function if possible,','line_number':142,'multiline':False]['text':'    if the inputs come from a tensor, you can check this through `is_non_overlapping_and_dense()`','line_number':143,'multiline':False]['text':'','line_number':144,'multiline':False]['text':' 2. The strides propagation rule that is used in this function is exactily the same as what is being used in','line_number':145,'multiline':False]['text':'    TensorIterator. Please refer to https://github.com/pytorch/pytorch/pull/42922 for more details','line_number':146,'multiline':False]['text':' initialize perm with n-1, n-2, ..., 1, 0','line_number':162,'multiline':False]['text':' The following sorting algorithm has exactly the same behavior as TensorIterator','line_number':165,'multiline':False]['text':' This is to make sure we have the same stride propagation everywhere.','line_number':166,'multiline':False]['text':' return -1 if dim0 should come before dim1','line_number':168,'multiline':False]['text':' return  1 if dim0 should come after dim1','line_number':169,'multiline':False]['text':' return  0 if comparison is ambiguous','line_number':170,'multiline':False]['text':' if any stride is 0, treat it as ambiguous comparison to','line_number':175,'multiline':False]['text':' keep the same behavior as TensorIterator','line_number':176,'multiline':False]['text':' for equal strides, the dimension with smaller size goes front','line_number':186,'multiline':False]['text':' Insertion sort (stable) indices in `perm` based on input tensor's stride and shape,','line_number':193,'multiline':False]['text':' all dimensions with 0 stride won't move. This is the same behavior as TensorIterator.','line_number':194,'multiline':False]['text':' eg. Given tensor with size/stride (6, 5, 4, 3, 2)/(6, 0, 120, 0, 1), the initial `perm`','line_number':195,'multiline':False]['text':'     is (4, 3, 2, 1, 0) and the sorted `perm` will be (4, 3, 0, 1, 2)','line_number':196,'multiline':False]['text':' compute output strides which preserves the input tensor's memory layout','line_number':212,'multiline':False]['text':' Note: for size 0, we simply treated it as 1, it really doesn't matter here','line_number':218,'multiline':False]['text':' since the total number of element is 0.','line_number':219,'multiline':False]['text':' namespace at','line_number':227,'multiline':False]