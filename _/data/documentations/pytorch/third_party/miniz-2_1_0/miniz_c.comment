['text':'*************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *************************************************************************','line_number':1,'multiline':True]['text':' ------------------- zlib-style API's ','line_number':37,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers,cppcoreguidelines-init-variables)','line_number':41,'multiline':False]['text':' Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed": http://www.geocities.com/malbrain/ ','line_number':68,'multiline':True]['text':' If USE_EXTERNAL_CRC is defined, an external module will export the
 * mz_crc32() symbol for us to use, e.g. an SSE-accelerated version.
 * Depending on the impl, it may be necessary to ~ the input/output crc values.
 ','line_number':87,'multiline':True]['text':' Faster, but larger CPU cache footprint.
 ','line_number':93,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':197,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':243,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':245,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':264,'multiline':False]['text':' Can't make forward progress without some input.
 ','line_number':295,'multiline':True]['text':' This is really over conservative. (And lame, but it's actually pretty tricky to compute a true upper bound given the way tdefl's blocking works.) ','line_number':317,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':323,'multiline':False]['text':' In case mz_ulong is 64-bits (argh I hate longs). ','line_number':328,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':373,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':415,'multiline':False]['text':' pDecomp->m_window_bits = window_bits ','line_number':435,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':442,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':444,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':446,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':448,'multiline':False]['text':' MZ_FINISH on the first call implies that the input and output buffers are large enough to hold the entire compressed/decompressed file. ','line_number':474,'multiline':True]['text':' flush != MZ_FINISH then we must assume there's more input. ','line_number':497,'multiline':True]['text':' Stream is corrupted (there could be some uncompressed data left in the output dictionary - oh well). ','line_number':537,'multiline':True]['text':' Signal caller that we can't make forward progress without supplying more input or by setting flush to MZ_FINISH. ','line_number':539,'multiline':True]['text':' The output buffer MUST be large to hold the remaining uncompressed data when flush==MZ_FINISH. ','line_number':542,'multiline':True]['text':' status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's at least 1 more byte on the way. If there's no more room left in the output buffer then something is wrong. ','line_number':545,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':571,'multiline':False]['text':' In case mz_ulong is 64-bits (argh I hate longs). ','line_number':575,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':609,'multiline':False]['text':'MINIZ_NO_ZLIB_APIS ','line_number':617,'multiline':True]['text':'
  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.

  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org/>
','line_number':623,'multiline':True]['text':'*************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *************************************************************************','line_number':649,'multiline':True]['text':' ------------------- Low-level Compression (independent from all decompression API's) ','line_number':682,'multiline':True]['text':' Purposely making these tables static for faster init and thread safety. ','line_number':684,'multiline':True]['text':' Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values. ','line_number':747,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers,cppcoreguidelines-init-variables)','line_number':754,'multiline':False]['text':' tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996. ','line_number':786,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':789,'multiline':False]['text':' Limits canonical Huffman code table's max code size. ','line_number':843,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':850,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':875,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':886,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':918,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables,cppcoreguidelines-avoid-magic-numbers)','line_number':993,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':998,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1000,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-signed-char-misuse)','line_number':1081,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1088,'multiline':False]['text':' This sequence coaxes MSVC into using cmov's vs. jmp's. ','line_number':1143,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1208,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1210,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1220,'multiline':False]['text':' MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS ','line_number':1255,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1268,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1270,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1273,'multiline':False]['text':' If the block gets expanded, forget the current contents of the output buffer and send a raw block instead. ','line_number':1302,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1306,'multiline':False]['text':' Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes. ','line_number':1324,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1342,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1353,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1427,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1430,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1432,'multiline':False]['text':' #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES ','line_number':1524,'multiline':True]['text':' Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio. ','line_number':1539,'multiline':True]['text':' MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN ','line_number':1709,'multiline':True]['text':' NOLINTNEXTLINE(clang-analyzer-core.UndefinedBinaryOperatorResult)','line_number':1715,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1727,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1764,'multiline':False]['text':' Update dictionary and hash chains. Keeps the lookahead size equal to TDEFL_MAX_MATCH_LEN. ','line_number':1766,'multiline':True]['text':' Simple lazy/greedy parsing state machine. ','line_number':1811,'multiline':True]['text':' Move the lookahead forward by len_to_move bytes. ','line_number':1880,'multiline':True]['text':' Check if it's time to flush the current LZ codes to the internal output buffer. ','line_number':1885,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1889,'multiline':False]['text':' #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN ','line_number':1967,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2045,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2047,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2074,'multiline':False]['text':' level may actually range from [0,10] (10 is a "hidden" max level, where we want a bit more compression and it's fine if throughput to fall off a cliff on some files). ','line_number':2123,'multiline':True]['text':' nonstandard extension used : non-constant aggregate initializer (also supported by GNU C and C99, so no big deal) ','line_number':2146,'multiline':True]['text':' Simple PNG writer function by Alex Evans, 2011. Released into the public domain: https://gist.github.com/908299, more context at
 http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
 This is actually a modification of Alex's original code so PNG files generated by this function pass pngcheck. ','line_number':2149,'multiline':True]['text':' Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was defined. ','line_number':2154,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2158,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2160,'multiline':False]['text':' write dummy header ','line_number':2173,'multiline':True]['text':' compress image data ','line_number':2176,'multiline':True]['text':' NOLINTNEXTLINE(bugprone-narrowing-conversions,cppcoreguidelines-narrowing-conversions)','line_number':2177,'multiline':False]['text':' write real header ','line_number':2190,'multiline':True]['text':' write footer (IDAT CRC-32, followed by IEND chunk) ','line_number':2217,'multiline':True]['text':' compute final size of file, grab compressed data buffer and return ','line_number':2228,'multiline':True]['text':' Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's where #defined out) ','line_number':2235,'multiline':True]['text':' Allocate the tdefl_compressor and tinfl_decompressor structures in C so that ','line_number':2240,'multiline':True]['text':' non-C language bindings to tdefL_ and tinfl_ API don't need to worry about ','line_number':2241,'multiline':True]['text':' structure size and allocation mechanism. ','line_number':2242,'multiline':True]['text':'*************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *************************************************************************','line_number':2261,'multiline':True]['text':' ------------------- Low-level Decompression (completely independent from all compression API's) ','line_number':2293,'multiline':True]['text':' TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2. ','line_number':2365,'multiline':True]['text':' It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a ','line_number':2366,'multiline':True]['text':' Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the ','line_number':2367,'multiline':True]['text':' bit buffer contains >=15 bits (deflate's max. Huffman code size). ','line_number':2368,'multiline':True]['text':' TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex than you would initially expect because the zlib API expects the decompressor to never read ','line_number':2394,'multiline':True]['text':' beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully ','line_number':2395,'multiline':True]['text':' decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren't followed by a byte aligned adler-32. ','line_number':2396,'multiline':True]['text':' The slow path is only executed at the very end of the input buffer. ','line_number':2397,'multiline':True]['text':' v1.16: The original macro handled the case at the very end of the passed-in input buffer, but we also need to handle the case where the user passes in 1+zillion bytes ','line_number':2398,'multiline':True]['text':' following the deflate data and our non-conservative read-ahead path won't kick in here on this code. This is much trickier. ','line_number':2399,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2444,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2446,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2450,'multiline':False]['text':' Ensure the output buffer's size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn't matter). ','line_number':2453,'multiline':True]['text':' NOLINTNEXTLINE(bugprone-misplaced-widening-cast,cppcoreguidelines-avoid-magic-numbers)','line_number':2476,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2514,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2540,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2564,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2573,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2575,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers,cppcoreguidelines-init-variables)','line_number':2577,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2598,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-narrowing-conversions,cppcoreguidelines-narrowing-conversions)','line_number':2624,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-narrowing-conversions,clang-analyzer-deadcode.DeadStores,cppcoreguidelines-narrowing-conversions)','line_number':2635,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2643,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers,bugprone-signed-char-misuse)','line_number':2655,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2672,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2689,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2691,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2763,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2774,'multiline':False]['text':' Ensure byte alignment and put back any bytes from the bitbuf if we've looked ahead too far on gzip, or other Deflate streams followed by arbitrary data. ','line_number':2847,'multiline':True]['text':' I'm being super conservative here. A number of simplifications can be made to the byte alignment part, and the Adler32 check shouldn't ever need to worry about reading from the bitbuf now. ','line_number':2848,'multiline':True]['text':' if this assert fires then we've read beyond the end of non-deflate/zlib streams with following data (such as gzip streams). ','line_number':2856,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2862,'multiline':False]['text':' As long as we aren't telling the caller that we NEED more input to make forward progress: ','line_number':2876,'multiline':True]['text':' Put back any bytes from the bitbuf in case we've looked ahead too far on gzip, or other Deflate streams followed by arbitrary data. ','line_number':2877,'multiline':True]['text':' We need to be very careful here to NOT push back any bytes we definitely know we need to make forward progress, though, or we'll lock the caller up into an inf loop. ','line_number':2878,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers,cppcoreguidelines-init-variables)','line_number':2899,'multiline':False]['text':' Higher level helper functions. ','line_number':2928,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2932,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2939,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2972,'multiline':False]['text':'*************************************************************************
 *
 * Copyright 2013-2014 RAD Game Tools and Valve Software
 * Copyright 2010-2014 Rich Geldreich and Tenacious Software LLC
 * Copyright 2016 Martin Raiber
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *************************************************************************','line_number':3026,'multiline':True]['text':' ------------------- .ZIP archive reading ','line_number':3060,'multiline':True]['text':' #ifdef _MSC_VER ','line_number':3177,'multiline':True]['text':' #ifdef MINIZ_NO_STDIO ','line_number':3178,'multiline':True]['text':' Various ZIP archive enums. To completely avoid cross platform compiler alignment and platform endian issues, miniz.c doesn't use structs for any of this stuff. ','line_number':3182,'multiline':True]['text':' ZIP archive identifiers and record sizes ','line_number':3185,'multiline':True]['text':' ZIP64 archive identifier and record sizes ','line_number':3193,'multiline':True]['text':' Central directory header record offsets ','line_number':3203,'multiline':True]['text':' Local directory header offsets ','line_number':3222,'multiline':True]['text':' End of central directory offsets ','line_number':3236,'multiline':True]['text':' ZIP64 End of central directory locator offsets ','line_number':3246,'multiline':True]['text':' 4 bytes ','line_number':3247,'multiline':True]['text':' 4 bytes ','line_number':3248,'multiline':True]['text':' 8 bytes ','line_number':3249,'multiline':True]['text':' 4 bytes ','line_number':3250,'multiline':True]['text':' ZIP64 End of central directory header offsets ','line_number':3252,'multiline':True]['text':' 4 bytes ','line_number':3253,'multiline':True]['text':' 8 bytes ','line_number':3254,'multiline':True]['text':' 2 bytes ','line_number':3255,'multiline':True]['text':' 2 bytes ','line_number':3256,'multiline':True]['text':' 4 bytes ','line_number':3257,'multiline':True]['text':' 4 bytes ','line_number':3258,'multiline':True]['text':' 8 bytes ','line_number':3259,'multiline':True]['text':' 8 bytes ','line_number':3260,'multiline':True]['text':' 8 bytes ','line_number':3261,'multiline':True]['text':' 8 bytes ','line_number':3262,'multiline':True]['text':' The flags passed in when the archive is initially opened. ','line_number':3285,'multiline':True]['text':' MZ_TRUE if the archive has a zip64 end of central directory headers, etc. ','line_number':3288,'multiline':True]['text':' MZ_TRUE if we found zip64 extended info in the central directory (m_zip64 will also be slammed to true too, even if we didn't find a zip64 end of central dir header, etc.) ','line_number':3291,'multiline':True]['text':' These fields are used by the file, FILE, memory, and memory/heap read/write helpers. ','line_number':3294,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3330,'multiline':False]['text':' #ifdef _MSC_VER ','line_number':3415,'multiline':True]['text':' MINIZ_NO_ARCHIVE_WRITING_APIS ','line_number':3420,'multiline':True]['text':' On Linux with x86 glibc, this call will fail on large files (I think >= 0x80000000 bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh. ','line_number':3428,'multiline':True]['text':' #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS','line_number':3436,'multiline':True]['text':' #ifndef MINIZ_NO_STDIO ','line_number':3448,'multiline':True]['text':' #ifndef MINIZ_NO_TIME ','line_number':3449,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3494,'multiline':False]['text':' Heap sort of lowercased filenames, used to help accelerate plain central directory searches by mz_zip_reader_locate_file(). (Could also use qsort(), but it could allocate memory.) ','line_number':3521,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3527,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3529,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3541,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3561,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3580,'multiline':False]['text':' Basic sanity checks - reject files which are too small ','line_number':3585,'multiline':True]['text':' Find the record by scanning the file from the end towards the beginning. ','line_number':3589,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3593,'multiline':False]['text':' Give up if we've searched the entire file, or we've gone back "too far" (~64kb) ','line_number':3615,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3631,'multiline':False]['text':' Basic sanity checks - reject files which are too small, and check the first 4 bytes of the file to make sure a local header is there. ','line_number':3645,'multiline':True]['text':' Read and verify the end of central directory record. ','line_number':3652,'multiline':True]['text':' NOLINTNEXTLINE(clang-analyzer-core.UndefinedBinaryOperatorResult)','line_number':3689,'multiline':False]['text':' NOLINTNEXTLINE(clang-analyzer-core.UndefinedBinaryOperatorResult)','line_number':3691,'multiline':False]['text':' Check for miniz's practical limits ','line_number':3703,'multiline':True]['text':' Check for miniz's current practical limits (sorry, this should be enough for millions of files) ','line_number':3714,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3743,'multiline':False]['text':' Read the entire central directory into a heap block, and allocate another heap block to hold the unsorted central dir file record offsets, and possibly another to hold the sorted indices. ','line_number':3745,'multiline':True]['text':' Now create an index into the central directory file records, do some basic sanity checking on each record ','line_number':3759,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3763,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3765,'multiline':False]['text':' Attempt to find zip64 extended information field in the entry's extra data ','line_number':3786,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3815,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':3817,'multiline':False]['text':' Ok, the archive didn't have any zip64 headers but it uses a zip64 extended information field so mark it as zip64 anyway (this can occur with infozip's zip util when it reads compresses files from stdin). ','line_number':3837,'multiline':True]['text':' I've seen archives that aren't marked as zip64 that uses zip64 ext data, argh ','line_number':3851,'multiline':True]['text':' #ifndef MINIZ_NO_STDIO ','line_number':3930,'multiline':True]['text':' TODO: Better sanity check archive_size and the # of actual remaining bytes ','line_number':4048,'multiline':True]['text':' #ifndef MINIZ_NO_STDIO ','line_number':4118,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4129,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4144,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4146,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4182,'multiline':False]['text':' Bugfix: This code was also checking if the internal attribute was non-zero, which wasn't correct. ','line_number':4198,'multiline':True]['text':' Most/all zip writers (hopefully) set DOS file/directory attributes in the low 16-bits, so check for the DOS directory flag and ignore the source OS ID in the created by field. ','line_number':4199,'multiline':True]['text':' FIXME: Remove this check? Is it necessary - we already check the filename. ','line_number':4200,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4215,'multiline':False]['text':' Extract fields from the central directory record. ','line_number':4225,'multiline':True]['text':' Copy as much of the filename and comment as possible. ','line_number':4242,'multiline':True]['text':' Set some flags for convienance ','line_number':4254,'multiline':True]['text':' See if we need to read any zip64 extended information fields. ','line_number':4259,'multiline':True]['text':' Confusingly, these zip64 fields can be present even on non-zip64 archives (Debian zip on a huge files from stdin piped to stdout creates them). ','line_number':4260,'multiline':True]['text':' Attempt to find zip64 extended information field in the entry's extra data ','line_number':4263,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4272,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4274,'multiline':False]['text':' NOLINTNEXTLINE(clang-analyzer-deadcode.DeadStores)','line_number':4320,'multiline':False]['text':' NOLINTNEXTLINE(clang-analyzer-deadcode.DeadStores)','line_number':4322,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4340,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4352,'multiline':False]['text':' yes I could use uint32_t's, but then we would have to add some special case checks in the loop, argh, and ','line_number':4382,'multiline':True]['text':' honestly the major expense here on 32-bit CPU's will still be the filename compare ','line_number':4383,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4410,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4420,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4422,'multiline':False]['text':' See if we can use a binary search ','line_number':4431,'multiline':True]['text':' Locate the entry by scanning the entire central directory ','line_number':4439,'multiline':True]['text':' NOLINTNEXTLINE(bugprone-narrowing-conversions,cppcoreguidelines-narrowing-conversions)','line_number':4464,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4489,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4492,'multiline':False]['text':' A directory or zero length file ','line_number':4504,'multiline':True]['text':' Encryption and patch files are not supported. ','line_number':4508,'multiline':True]['text':' This function only supports decompressing stored and deflate. ','line_number':4512,'multiline':True]['text':' Ensure supplied output buffer is large enough. ','line_number':4516,'multiline':True]['text':' Read and parse the local directory entry. ','line_number':4521,'multiline':True]['text':' The file is stored or the caller has requested the compressed data. ','line_number':4535,'multiline':True]['text':' Decompress the file either directly from memory or from a file input buffer. ','line_number':4550,'multiline':True]['text':' Read directly from the archive in memory. ','line_number':4555,'multiline':True]['text':' Use a user provided read buffer. ','line_number':4562,'multiline':True]['text':' Temporarily allocate a read buffer. ','line_number':4572,'multiline':True]['text':' The size_t cast here should be OK because we've verified that the output buffer is >= file_stat.m_uncomp_size above ','line_number':4586,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4587,'multiline':False]['text':' Make sure the entire file was decompressed, and check its CRC. ','line_number':4611,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4634,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4653,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4656,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4697,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4714,'multiline':False]['text':' A directory or zero length file ','line_number':4728,'multiline':True]['text':' Encryption and patch files are not supported. ','line_number':4732,'multiline':True]['text':' This function only supports decompressing stored and deflate. ','line_number':4736,'multiline':True]['text':' Read and do some minimal validation of the local directory entry (this doesn't crack the zip64 stuff, which we already have from the central dir) ','line_number':4740,'multiline':True]['text':' Decompress the file either directly from memory or from a file input buffer. ','line_number':4752,'multiline':True]['text':' The file is stored or the caller has requested the compressed data. ','line_number':4771,'multiline':True]['text':' NOLINTNEXTLINE(clang-analyzer-deadcode.DeadStores)','line_number':4789,'multiline':False]['text':' NOLINTNEXTLINE(clang-analyzer-deadcode.DeadStores)','line_number':4792,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4842,'multiline':False]['text':' Make sure the entire file was decompressed, and check its CRC. ','line_number':4888,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4914,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4924,'multiline':False]['text':' Argument sanity check ','line_number':4929,'multiline':True]['text':' Allocate an iterator status structure ','line_number':4933,'multiline':True]['text':' Fetch file details ','line_number':4941,'multiline':True]['text':' Encryption and patch files are not supported. ','line_number':4948,'multiline':True]['text':' This function only supports decompressing stored and deflate. ','line_number':4956,'multiline':True]['text':' Init state - save args ','line_number':4964,'multiline':True]['text':' Init state - reset variables to defaults ','line_number':4968,'multiline':True]['text':' Read and parse the local directory entry. ','line_number':4979,'multiline':True]['text':' Decompress the file either directly from memory or from a file input buffer. ','line_number':5003,'multiline':True]['text':' Decompression required, therefore intermediate read buffer required ','line_number':5014,'multiline':True]['text':' Decompression not required - we will be reading directly into user buffer, no temp buf required ','line_number':5025,'multiline':True]['text':' Decompression required, init decompressor ','line_number':5034,'multiline':True]['text':' Allocate write buffer ','line_number':5037,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5053,'multiline':False]['text':' Locate file index by name ','line_number':5056,'multiline':True]['text':' Construct iterator ','line_number':5060,'multiline':True]['text':' Argument sanity check ','line_number':5068,'multiline':True]['text':' The file is stored or the caller has requested the compressed data, calc amount to return. ','line_number':5074,'multiline':True]['text':' Zip is in memory....or requires reading from a file? ','line_number':5077,'multiline':True]['text':' Copy data to caller's buffer ','line_number':5080,'multiline':True]['text':' Read directly into caller's buffer ','line_number':5086,'multiline':True]['text':' Failed to read all that was asked for, flag failure and alert user ','line_number':5089,'multiline':True]['text':' Compute CRC if not returning compressed data only ','line_number':5097,'multiline':True]['text':' Advance offsets, dec counters ','line_number':5102,'multiline':True]['text':' Calc ptr to write buffer - given current output pos and block size ','line_number':5111,'multiline':True]['text':' Calc max output size - given current output pos and block size ','line_number':5114,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5115,'multiline':False]['text':' Read more data from file if none available (and reading from file) ','line_number':5120,'multiline':True]['text':' Calc read size ','line_number':5123,'multiline':True]['text':' Advance offsets, dec counters ','line_number':5132,'multiline':True]['text':' Perform decompression ','line_number':5138,'multiline':True]['text':' Update current output block size remaining ','line_number':5144,'multiline':True]['text':' Calc amount to return. ','line_number':5150,'multiline':True]['text':' Copy data to caller's buffer ','line_number':5153,'multiline':True]['text':' Perform CRC ','line_number':5157,'multiline':True]['text':' Decrement data consumed from block ','line_number':5161,'multiline':True]['text':' Inc output offset, while performing sanity check ','line_number':5164,'multiline':True]['text':' Increment counter of data copied to caller ','line_number':5172,'multiline':True]['text':' Return how many bytes were copied into user buffer ','line_number':5178,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5184,'multiline':False]['text':' Argument sanity check ','line_number':5187,'multiline':True]['text':' Was decompression completed and requested? ','line_number':5191,'multiline':True]['text':' Make sure the entire file was decompressed, and check its CRC. ','line_number':5194,'multiline':True]['text':' Free buffers ','line_number':5209,'multiline':True]['text':' Save status ','line_number':5215,'multiline':True]['text':' Free context ','line_number':5218,'multiline':True]['text':' #ifndef MINIZ_NO_STDIO ','line_number':5296,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5309,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5311,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5318,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5320,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5323,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5325,'multiline':False]['text':' A directory or zero length file ','line_number':5344,'multiline':True]['text':' Encryption and patch files are not supported. ','line_number':5348,'multiline':True]['text':' This function only supports stored and deflate. ','line_number':5352,'multiline':True]['text':' Read and parse the local directory entry. ','line_number':5359,'multiline':True]['text':' I've seen 1 archive that had the same pathname, but used backslashes in the local dir and forward slashes in the central dir. Do we care about this? For now, this case will fail validation. ','line_number':5392,'multiline':True]['text':' NOLINTNEXTLINE(clang-analyzer-unix.cstring.NullArg)','line_number':5393,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5414,'multiline':False]['text':' NOLINTNEXTLINE(clang-analyzer-core.NullDereference)','line_number':5420,'multiline':False]['text':' TODO: parse local header extra data when local_header_comp_size is 0xFFFFFFFF! (big_descriptor.zip) ','line_number':5450,'multiline':True]['text':' I've seen zips in the wild with the data descriptor bit set, but proper local header values and bogus data descriptors ','line_number':5451,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5455,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5457,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5459,'multiline':False]['text':' 1 more check to be sure, although the extract checks too. ','line_number':5509,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5526,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5528,'multiline':False]['text':' Basic sanity checks ','line_number':5536,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5558,'multiline':False]['text':' This check can fail if there are duplicate filenames in the archive (which we don't check for when writing - that's up to the user) ','line_number':5568,'multiline':True]['text':' #ifndef MINIZ_NO_STDIO ','line_number':5662,'multiline':True]['text':' ------------------- .ZIP archive writing ','line_number':5664,'multiline':True]['text':' An allocation this big is likely to just fail on 32-bit systems, so don't even go there. ','line_number':5699,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5708,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5731,'multiline':False]['text':' #ifndef MINIZ_NO_STDIO ','line_number':5763,'multiline':True]['text':' Ensure user specified file offset alignment is a power of 2. ','line_number':5791,'multiline':True]['text':' #ifndef MINIZ_NO_STDIO ','line_number':5951,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':5955,'multiline':False]['text':' We don't support converting a non-zip64 file to zip64 - this seems like more trouble than it's worth. (What about the existing 32-bit data descriptors that could follow the compressed data?) ','line_number':5963,'multiline':True]['text':' No sense in trying to write to an archive that's already at the support max size ','line_number':5968,'multiline':True]['text':' Archive is being read from stdio and was originally opened only for reading. Try to reopen as writable. ','line_number':5999,'multiline':True]['text':' The mz_zip_archive is now in a bogus state because pState->m_pFile is NULL, so just close it. ','line_number':6002,'multiline':True]['text':' #ifdef MINIZ_NO_STDIO ','line_number':6010,'multiline':True]['text':' Archive lives in a memory block. Assume it's from the heap that we can resize using the realloc callback. ','line_number':6014,'multiline':True]['text':' Archive is being read via a user provided read function - make sure the user has specified a write function too. ','line_number':6022,'multiline':True]['text':' Start writing new files at the archive's current central directory location. ','line_number':6026,'multiline':True]['text':' TODO: We could add a flag that lets the user start writing immediately AFTER the existing central dir - this would be safer. ','line_number':6027,'multiline':True]['text':' Clear the sorted central dir offsets, they aren't useful or maintained now. ','line_number':6031,'multiline':True]['text':' Even though we're now in write mode, files can still be extracted and verified, but file locates will be slow. ','line_number':6032,'multiline':True]['text':' TODO: We could easily maintain the sorted central directory offsets. ','line_number':6033,'multiline':True]['text':' TODO: pArchive_name is a terrible name here! ','line_number':6046,'multiline':True]['text':' miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet ','line_number':6168,'multiline':True]['text':' Try to resize the central directory array back into its original state. ','line_number':6182,'multiline':True]['text':' Basic ZIP archive filename validity checks: Valid filenames cannot start with a forward slash, cannot contain a drive letter, and cannot use DOS-style backward slashes. ','line_number':6192,'multiline':True]['text':' Making sure the name does not contain drive letters or DOS style backward slashes is the responsibility of the program using miniz','line_number':6196,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6203,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6238,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6241,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6245,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6247,'multiline':False]['text':'return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); ','line_number':6281,'multiline':True]['text':'return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); ','line_number':6286,'multiline':True]['text':' #ifndef MINIZ_NO_TIME ','line_number':6307,'multiline':True]['text':' miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet ','line_number':6326,'multiline':True]['text':' Bail early if the archive would obviously become too large ','line_number':6332,'multiline':True]['text':'return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); ','line_number':6339,'multiline':True]['text':' Set DOS Subdirectory attribute bit. ','line_number':6345,'multiline':True]['text':' Subdirectories cannot contain data. ','line_number':6348,'multiline':True]['text':' Try to do any allocations before writing to the archive, so if an allocation fails the file remains unmodified. (A good idea if we're doing an in-place modification.) ','line_number':6353,'multiline':True]['text':' Sanity checks ','line_number':6545,'multiline':True]['text':' Source file is too large for non-zip64 ','line_number':6553,'multiline':True]['text':'return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); ','line_number':6554,'multiline':True]['text':' We could support this, but why? ','line_number':6558,'multiline':True]['text':'return mz_zip_set_error(pZip, MZ_ZIP_TOO_MANY_FILES); ','line_number':6575,'multiline':True]['text':' miniz doesn't support central dirs >= MZ_UINT32_MAX bytes yet ','line_number':6585,'multiline':True]['text':' Bail early if the archive would obviously become too large ','line_number':6591,'multiline':True]['text':'return mz_zip_set_error(pZip, MZ_ZIP_ARCHIVE_TOO_LARGE); ','line_number':6597,'multiline':True]['text':' #ifndef MINIZ_NO_STDIO ','line_number':6876,'multiline':True]['text':' + 64 should be enough for any new zip64 data ','line_number':6880,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6931,'multiline':False]['text':' TODO: This func is now pretty freakin complex due to zip64, split it up? ','line_number':6958,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6961,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6963,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6965,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6970,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6972,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6974,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6976,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6979,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6981,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':6983,'multiline':False]['text':' Sanity checks ','line_number':6987,'multiline':True]['text':' Don't support copying files from zip64 archives to non-zip64, even though in some cases this is possible ','line_number':6993,'multiline':True]['text':' Get pointer to the source central dir header and crack it ','line_number':6997,'multiline':True]['text':' TODO: We don't support central dir's >= MZ_UINT32_MAX bytes right now (+32 fudge factor in case we need to add more extra data) ','line_number':7009,'multiline':True]['text':' TODO: Our zip64 support still has some 32-bit limits that may not be worth fixing. ','line_number':7022,'multiline':True]['text':' Read the source archive's local dir header ','line_number':7033,'multiline':True]['text':' Compute the total size we need to copy (filename+extra data+compressed data) ','line_number':7042,'multiline':True]['text':' Try to find a zip64 extended information field ','line_number':7049,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':7072,'multiline':False]['text':' NOLINTNEXTLINE(clang-analyzer-deadcode.DeadStores)','line_number':7101,'multiline':False]['text':' NOLINTNEXTLINE(clang-analyzer-deadcode.DeadStores)','line_number':7103,'multiline':False]['text':' may be 0 if there's a descriptor ','line_number':7104,'multiline':True]['text':' Try to detect if the new archive will most likely wind up too big and bail early (+(sizeof(mz_uint32) * 4) is for the optional descriptor which could be present, +64 is a fudge factor). ','line_number':7119,'multiline':True]['text':' We also check when the archive is finalized so this doesn't need to be perfect. ','line_number':7120,'multiline':True]['text':' Write dest archive padding ','line_number':7128,'multiline':True]['text':' The original zip's local header+ext block doesn't change, even with zip64, so we can just copy it over to the dest zip ','line_number':7140,'multiline':True]['text':' Copy over the source archive bytes to the dest archive, also ensure we have enough buf space to handle optional data descriptor ','line_number':7146,'multiline':True]['text':' Now deal with the optional data descriptor ','line_number':7170,'multiline':True]['text':' Copy data descriptor ','line_number':7174,'multiline':True]['text':' src is zip64, dest must be zip64 ','line_number':7177,'multiline':True]['text':' name			uint32_t's ','line_number':7179,'multiline':True]['text':' id				1 (optional in zip64?) ','line_number':7180,'multiline':True]['text':' crc			1 ','line_number':7181,'multiline':True]['text':' comp_size	2 ','line_number':7182,'multiline':True]['text':' uncomp_size 2 ','line_number':7183,'multiline':True]['text':' src is NOT zip64 ','line_number':7194,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':7195,'multiline':False]['text':' dest is zip64, so upgrade the data descriptor ','line_number':7208,'multiline':True]['text':' dest is NOT zip64, just copy it as-is ','line_number':7223,'multiline':True]['text':' NOLINTNEXTLINE(clang-analyzer-deadcode.DeadStores)','line_number':7234,'multiline':False]['text':' Finally, add the new central dir header ','line_number':7240,'multiline':True]['text':' This is the painful part: We need to write a new central dir header + ext block with updated zip64 fields, and ensure the old fields (if any) are not included. ','line_number':7247,'multiline':True]['text':' sanity checks ','line_number':7296,'multiline':True]['text':' This shouldn't trigger unless we screwed up during the initial sanity checks ','line_number':7315,'multiline':True]['text':' TODO: Support central dirs >= 32-bits in size ','line_number':7318,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':7338,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':7340,'multiline':False]['text':' Write central directory ','line_number':7364,'multiline':True]['text':' Write zip64 end of central directory header ','line_number':7376,'multiline':True]['text':' TODO: always Unix ','line_number':7382,'multiline':True]['text':' Write zip64 end of central directory locator ','line_number':7393,'multiline':True]['text':' Write end of central directory record ','line_number':7404,'multiline':True]['text':' #ifndef MINIZ_NO_STDIO ','line_number':7418,'multiline':True]['text':' Important: The regular non-64 bit version of stat() can fail here if the file is very large, which could cause the archive to be overwritten. ','line_number':7487,'multiline':True]['text':' So be sure to compile with _LARGEFILE64_SOURCE 1 ','line_number':7488,'multiline':True]['text':' Create a new archive. ','line_number':7491,'multiline':True]['text':' Append to an existing archive. ','line_number':7503,'multiline':True]['text':' Always finalize, even if adding failed for some reason, so we have a valid central directory. (This may not always succeed, but we can try.) ','line_number':7525,'multiline':True]['text':' It's a new archive and something went wrong, so just delete it. ','line_number':7544,'multiline':True]['text':' #ifndef MINIZ_NO_STDIO ','line_number':7599,'multiline':True]['text':' #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS ','line_number':7601,'multiline':True]['text':' ------------------- Misc utils ','line_number':7603,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':7617,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':7644,'multiline':False]['text':' Note: Just because the archive is not zip64 doesn't necessarily mean it doesn't have Zip64 extended information extra field, argh. ','line_number':7731,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':7784,'multiline':False]['text':'#ifndef MINIZ_NO_ARCHIVE_APIS','line_number':7828,'multiline':True]