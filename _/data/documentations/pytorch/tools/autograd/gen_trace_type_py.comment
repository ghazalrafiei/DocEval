['text':' Note [Manual Backend kernels]','line_number':12,'multiline':False]['text':' For these ops, we want to manually register to dispatch key Backend and','line_number':13,'multiline':False]['text':' skip codegen-ed registeration to all keys before Backend.','line_number':14,'multiline':False]['text':' For codegen this means:','line_number':15,'multiline':False]['text':'   - op set below must match ops with manual_kernel_registration=True in native_functions.yaml','line_number':16,'multiline':False]['text':'     where we skip codegen backend kernels','line_number':17,'multiline':False]['text':'   - all ops below are part of MANUAL_AUTOGRAD to skip codegen Autograd kernel registration','line_number':18,'multiline':False]['text':'   - all ops below are part of MANUAL_TRACER to skip codegen Tracer kernel registration','line_number':19,'multiline':False]['text':' Note: we still register to dispatch key Profiler for these ops, keeping it untouched for now.','line_number':20,'multiline':False]['text':' You can find the manual registration in torch/csrc/autograd/VariableTypeManual.cpp','line_number':21,'multiline':False]['text':' For these ops we want to skip the codegen-ed registration to both Autograd and Tracer keys.','line_number':34,'multiline':False]['text':' You can find the manual registration in torch/csrc/autograd/VariableTypeManual.cpp','line_number':35,'multiline':False]['text':' Currently MANUAL_AUTOGRAD and MANUAL_TRACER share the same set of ops:','line_number':46,'multiline':False]['text':'   union(MANUAL_BACKEND, MANUAL_AUTOGRAD_AND_TRACER)','line_number':47,'multiline':False]['text':' You can find the manual registration in torch/csrc/autograd/VariableTypeManual.cpp','line_number':48,'multiline':False]['text':' These functions we don't want to record for tracing, because we always want','line_number':51,'multiline':False]['text':' to trace their constituent parts.  This is a temporary hack in lieue','line_number':52,'multiline':False]['text':' of proper scopes, where subsequent compilation passes can ask for the unfolding','line_number':53,'multiline':False]['text':' on demand.  Only concrete ATen methods can be disabled this way; it will have','line_number':54,'multiline':False]['text':' NO EFFECT otherwise.','line_number':55,'multiline':False]['text':' FIXME: figure out a better way when we support sparse tensors in jit','line_number':68,'multiline':False]['text':' Operations involving Storage or Type are not traceable at the moment','line_number':74,'multiline':False]['text':' We can't trace functions which don't have any Tensor or TensorList returns','line_number':80,'multiline':False]['text':' These functions have their names recorded under trace renamed,','line_number':103,'multiline':False]['text':' replacing aten::zero_ with aten::zeros_like','line_number':105,'multiline':False]['text':' replacing aten::fill_ with aten::full_like','line_number':106,'multiline':False]['text':' TODO: byte-for-byte compatible with old codegen behavior - should clean up','line_number':111,'multiline':False]['text':' special case for *_out functions: the in-place and out-of-place ops','line_number':116,'multiline':False]['text':' are overloaded with the same name in the JIT','line_number':117,'multiline':False]['text':' otherwise, this is an in-place op and we need to emit both in- and','line_number':122,'multiline':False]['text':' out-of-place versions','line_number':123,'multiline':False]['text':' *_out functions take the result as a separate argument, but we don't want to','line_number':165,'multiline':False]['text':' trace that argument directly. Instead, we trace its TensorOptions.','line_number':166,'multiline':False]['text':' So first, we need to remove the out argument from the list of arguments to trace.','line_number':167,'multiline':False]['text':' for *_out functions, handle the result argument differently for inplace/outplace.','line_number':176,'multiline':False]['text':' For inplace: just add the input to the end to confirm with the JIT schema','line_number':177,'multiline':False]['text':' for outplace: do nothing, except if the function is a factory.','line_number':185,'multiline':False]['text':' Factories are a bit special because their out-of-place overloads','line_number':186,'multiline':False]['text':' take an extra TensorOptions argument, which is missing in the _out function','line_number':187,'multiline':False]['text':' HACK: preserve old codegen behavior - the old codegen set the `is_factory_method`','line_number':196,'multiline':False]['text':' flag for the whole family of ops with the same basename if any of them is a','line_number':197,'multiline':False]['text':' factory method. For most cases the whole family of ops are indeed all factory','line_number':198,'multiline':False]['text':' method - 'normal' is the only exception. So we handle it specially here to avoid','line_number':199,'multiline':False]['text':' cloning the old logic.','line_number':200,'multiline':False]['text':' `torch.jit.trace` have undocumented keyword argument `_force_outplace`,','line_number':233,'multiline':False]['text':' which force jit to replace functions with outplace variants (for','line_number':234,'multiline':False]['text':' example `aten::add_` becomes `aten::add`).','line_number':235,'multiline':False]['text':'','line_number':236,'multiline':False]['text':' This replacement implemented in-place with minimum modifications of','line_number':237,'multiline':False]['text':' arguments stack (as it assumes that outplace call has the same arguments','line_number':238,'multiline':False]['text':' as inplace version).','line_number':239,'multiline':False]['text':'','line_number':240,'multiline':False]['text':' However there are no such substitutions available for `aten::fill_`','line_number':241,'multiline':False]['text':' and `aten::zero_` operators, as we never implemented `aten::fill`','line_number':242,'multiline':False]['text':' and `aten::zero`. So jit tracing hack replacing `aten::zero_` with','line_number':243,'multiline':False]['text':' `aten::zeros_like` and replacing `aten::fill_` with `aten::full_like`.','line_number':244,'multiline':False]['text':'','line_number':245,'multiline':False]['text':' But as they potentially can have different arguments, we also have','line_number':246,'multiline':False]['text':' to hack into the stack and add missing ones.','line_number':247,'multiline':False]['text':'','line_number':248,'multiline':False]['text':' A possible alternative would be:','line_number':249,'multiline':False]['text':'','line_number':250,'multiline':False]['text':'  - Add `aten::fill` and `aten::zero`','line_number':251,'multiline':False]['text':'','line_number':252,'multiline':False]['text':'  - Or keep `aten::zeros_like` arguments aligned with `aten::zero_`','line_number':253,'multiline':False]['text':' arguments (inside of the `native_functions.yaml`)','line_number':254,'multiline':False]['text':' TODO: clean up old codegen behavior','line_number':303,'multiline':False]['text':' For outplacing ops, *_out overloads require special handling to move the','line_number':349,'multiline':False]['text':' output *argument* to a return value','line_number':350,'multiline':False]['text':' Code size optimization: the common case is that the return value is','line_number':355,'multiline':False]['text':' the same for both variants','line_number':356,'multiline':False]['text':' code-generated tracing kernels plumb and recompute dispatch keys directly through the kernel for performance.','line_number':423,'multiline':False]['text':' See Note [Plumbing Keys Through The Dispatcher] for details.','line_number':424,'multiline':False]['text':' Note that this calls the slow, dispatching variants of manual_cpp_binding ops.','line_number':435,'multiline':False]['text':' We could probably work harder to ensure that the fast variants are called instead, but the perf benefit would be minimal.','line_number':436,'multiline':False]['text':' The key argument is only used in gen_variable_type where we need fns per autograd dispatch key.','line_number':466,'multiline':False]['text':' In gen_trace_type and gen_inplace_view_type where only one fn per native_fn must be generated,','line_number':467,'multiline':False]['text':' the key argument should not be passed.','line_number':468,'multiline':False]['text':' We do not append key if it is Default so that generated functions from','line_number':469,'multiline':False]['text':' before per-dispatch-key derivatives were added retain the same names.','line_number':470,'multiline':False]['text':' code-generated tracing kernels plumb and recompute dispatch keys directly through the kernel for performance.','line_number':481,'multiline':False]['text':' See Note [Plumbing Keys Through The Dispatcher] for details.','line_number':482,'multiline':False]['text':' NOTE: see Note [Sharded File] at the top of the VariableType.cpp','line_number':529,'multiline':False]['text':' template regarding sharding of the generated files.','line_number':530,'multiline':False]