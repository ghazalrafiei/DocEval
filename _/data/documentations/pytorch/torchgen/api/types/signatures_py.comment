['text':' The schema this signature is derived from','line_number':25,'multiline':False]['text':' Is this a C++ signature for a method, i.e. Tensor::my_op(...)?','line_number':28,'multiline':False]['text':' Is this a faithful C++ signature (i.e. following the JIT schema) or a convenience API','line_number':31,'multiline':False]['text':' (i.e. with a potential TensorOptions argument and out arguments in the front)','line_number':32,'multiline':False]['text':' Is this a symint C++ signature.  For BC reasons, functions that take','line_number':35,'multiline':False]['text':' SymInts still present as int64_t in C++, and the SymInt variant is','line_number':36,'multiline':False]['text':' offered at a different overload name','line_number':37,'multiline':False]['text':'','line_number':38,'multiline':False]['text':' NB: If a function RETURNS a SymInt, this is ALWAYS false','line_number':39,'multiline':False]['text':' The set of C++ arguments which should not have defaults applied to them','line_number':42,'multiline':False]['text':' Is this a fallback C++ binding?  Fallback bindings are enabled by','line_number':45,'multiline':False]['text':' manual_cpp_binding: True and are alternate, non-public API that','line_number':46,'multiline':False]['text':' lets manual C++ binding implementors access the binding that would','line_number':47,'multiline':False]['text':' have been automatically generated','line_number':48,'multiline':False]['text':' Return the unpacked argument structure of this signature,','line_number':51,'multiline':False]['text':' discarding information about which arguments are semantically','line_number':52,'multiline':False]['text':' related to each other.','line_number':53,'multiline':False]['text':' Render the C++ declaration for this signature','line_number':73,'multiline':False]['text':' Render the C++ definition for this signature, not including','line_number':93,'multiline':False]['text':' the body (with curly braces)','line_number':94,'multiline':False]['text':' Return the C++ function type, e.g., something like int(bool)','line_number':117,'multiline':False]['text':' Represents group of all CppSignatures associated with a','line_number':123,'multiline':False]['text':' FunctionSchema.  Right now, that's the regular, user-visible','line_number':124,'multiline':False]['text':' signature, as well as a "faithful" signature which doesn't','line_number':125,'multiline':False]['text':' have grouping.','line_number':126,'multiline':False]['text':' The schema this signature is derived from','line_number':191,'multiline':False]['text':' Allows you to prepend an arbitrary prefix to the signature name.','line_number':194,'multiline':False]['text':' This is useful for parts of the codegen that generate wrappers around kernels,','line_number':195,'multiline':False]['text':' and need to avoid naming collisions.','line_number':196,'multiline':False]['text':' Return the C++ function type, e.g., something like int(bool)','line_number':234,'multiline':False]['text':' The schema this signature is derived from','line_number':248,'multiline':False]['text':' don't include defaults in type signature!','line_number':271,'multiline':False]['text':' are we generating the forward lambda or the reverse lambda?','line_number':311,'multiline':False]['text':' The lambda lives inside of a kernel following the dispatcher API, so its outer context is the dispatcher arguments','line_number':315,'multiline':False]['text':' We also need to read the "reapply views" TLS at the time that the functionalization kernel was executed,','line_number':316,'multiline':False]['text':' and plumb it into the lambda.','line_number':317,'multiline':False]['text':' allow_expensive_conversions is set because we want to convert','line_number':324,'multiline':False]['text':' some reference types (IntArrayRef) to value types (vector<int64_t>).','line_number':325,'multiline':False]['text':' Helper functions','line_number':389,'multiline':False]['text':' Note [External Backends Follow Dispatcher API]','line_number':395,'multiline':False]['text':' Kernel signatures for in-tree backends follow the "native" API,','line_number':396,'multiline':False]['text':' while kernels for out-of-tree backends follow the dispatcher API.','line_number':397,'multiline':False]['text':' See the comments in `native.py` for details, but historically there have been','line_number':398,'multiline':False]['text':' some small differences in schema convention between them and the Dispatcher API.','line_number':399,'multiline':False]['text':' Any differences that require translating between the two will results in a runtime cost,','line_number':400,'multiline':False]['text':' so we'd like to keep the differences as small as possible.','line_number':401,'multiline':False]['text':' With external backends, we'd like to enforce that they write their kernels with schemas','line_number':402,'multiline':False]['text':' that match the Dispatcher API directly, if they can.','line_number':403,'multiline':False]['text':' Functions only, no types','line_number':416,'multiline':False]