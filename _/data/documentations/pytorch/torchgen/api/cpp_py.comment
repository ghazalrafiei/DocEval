['text':' This file describes the translation of JIT schema to the public C++','line_number':51,'multiline':False]['text':' API, which is what people use when they call functions like at::add.','line_number':52,'multiline':False]['text':'','line_number':53,'multiline':False]['text':' Prominent characteristics of the C++ API:','line_number':54,'multiline':False]['text':'','line_number':55,'multiline':False]['text':'   - dtype, layout, device and pin_memory are collected into','line_number':56,'multiline':False]['text':'     a single C++ type TensorOptions  (the native functions API','line_number':57,'multiline':False]['text':'     also has this, but tensor options is really most relevant','line_number':58,'multiline':False]['text':'     for the C++ API; it makes calling kwarg factory functions','line_number':59,'multiline':False]['text':'     pleasant)','line_number':60,'multiline':False]['text':'','line_number':61,'multiline':False]['text':'   - defaulting lives here (in fact, the dispatcher is completely','line_number':62,'multiline':False]['text':'     oblivious of defaults!)','line_number':63,'multiline':False]['text':'','line_number':64,'multiline':False]['text':' BTW: policy on name collisions: we try not to have types with','line_number':65,'multiline':False]['text':' collisions, but functions are fair game to collide','line_number':66,'multiline':False]['text':' Translation of "value types" in JIT schema to C++ API type.  Value','line_number':87,'multiline':False]['text':' types look the same no matter if they are argument types or return','line_number':88,'multiline':False]['text':' types.  Returns None if the type in question is not a value type.','line_number':89,'multiline':False]['text':' All other BaseType currently map directly to BaseCppTypes.','line_number':110,'multiline':False]['text':' Translation of types occurring in JIT arguments to a C++ argument type.','line_number':127,'multiline':False]['text':' If remove_non_owning_ref_types is set, we'll guarantee that the outputed CType is not a non-owning reference type.','line_number':128,'multiline':False]['text':' For example, we'll return std::vector<int> instead of IntArrayRef.','line_number':129,'multiline':False]['text':' See Note [translation from C++ reference to value types]','line_number':130,'multiline':False]['text':' If it's a value type, do the value type translation','line_number':139,'multiline':False]['text':' TODO: fix this discrepancy','line_number':164,'multiline':False]['text':' TODO: remove these special cases, ArrayRef fallthrough works fine','line_number':181,'multiline':False]['text':' Translate a JIT argument into its C++ type','line_number':217,'multiline':False]['text':' Translation of a (non-multi) return type from JIT to C++','line_number':222,'multiline':False]['text':' N.B: returntype_type returns a CType, not a NamedCType.','line_number':223,'multiline':False]['text':' This is mostly because of the mismatch between return types and return names.','line_number':224,'multiline':False]['text':' e.g. a function with a return type of 'void' has 0 return names,','line_number':225,'multiline':False]['text':' and a function with a return type of 'std::tuple' has >1 return name.','line_number':226,'multiline':False]['text':' placeholder is ignored','line_number':228,'multiline':False]['text':' NB: symint is ALWAYS respected for return types.  So symint argument','line_number':229,'multiline':False]['text':' here is IGNORED','line_number':230,'multiline':False]['text':' Note [Tensor Copy Returns]','line_number':243,'multiline':False]['text':' Currently, we use "Argument.is_write" to determine','line_number':244,'multiline':False]['text':' whether or not Tensor return types should be copies or references.','line_number':245,'multiline':False]['text':' If that ever changes, take a look at other locations of this note!','line_number':246,'multiline':False]['text':' Translation of a single return to its C++ type','line_number':265,'multiline':False]['text':' Translation of a full (possibly multi) return from JIT to its C++ type','line_number':270,'multiline':False]['text':' If we have an inplace function, the return argument is','line_number':283,'multiline':False]['text':' implicitly named self.','line_number':284,'multiline':False]['text':' TODO: Consider incorporating this into the data model','line_number':285,'multiline':False]['text':' If we are out function, the name is the name of the','line_number':289,'multiline':False]['text':' corresponding output function (r.name will get recorded','line_number':290,'multiline':False]['text':' in field_name later.)','line_number':291,'multiline':False]['text':' If the return argument is explicitly named...','line_number':294,'multiline':False]['text':' If there is no explicit name and no fallback name was passed in, we just name the output result,','line_number':303,'multiline':False]['text':' unless it's a multi-return, in which case it's result0,','line_number':304,'multiline':False]['text':' result1, etc (zero-indexed)','line_number':305,'multiline':False]['text':' UGH this one is type directed','line_number':315,'multiline':False]['text':' Convert a JIT default into C++ expression representing the default','line_number':323,'multiline':False]['text':' Schema allows single quotes but C++ needs double','line_number':328,'multiline':False]['text':' NOTE: Sized lists can have scalar defaults','line_number':360,'multiline':False]['text':' Convert an argument into its C++ API form','line_number':366,'multiline':False]['text':' Enforced by NativeFunction.__post_init__','line_number':417,'multiline':False]['text':' TODO: this is wrong','line_number':422,'multiline':False]['text':' Caller is responsible for installing implicit this in context!','line_number':433,'multiline':False]