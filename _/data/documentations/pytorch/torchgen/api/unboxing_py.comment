['text':' This file generates the code for unboxing wrappers, i.e., the glue logic to unbox a boxed operator and convert the','line_number':15,'multiline':False]['text':' ivalues from stack to correct arguments to the unboxed kernel, based on corresponding JIT schema. This codegen is','line_number':16,'multiline':False]['text':' an alternative way to generate unboxing wrappers similar to the existing C++ metaprogramming approach but gets the','line_number':17,'multiline':False]['text':' job done statically. These generated unboxing wrappers will be useful under the scenario where we need to register','line_number':18,'multiline':False]['text':' a fixed set of operators known at compile time and thus can save some time in runtime initialization phase.','line_number':19,'multiline':False]['text':'','line_number':20,'multiline':False]['text':' Here's an example on how the codegen works:','line_number':21,'multiline':False]['text':'','line_number':22,'multiline':False]['text':' - Function Schema (source of truth)','line_number':23,'multiline':False]['text':'','line_number':24,'multiline':False]['text':'      aten::empty.names(int[] size, *, Dimname[]? names,','line_number':25,'multiline':False]['text':'                        ScalarType? dtype=None, Layout? layout=None,','line_number':26,'multiline':False]['text':'                        Device? device=None, bool? pin_memory=None,','line_number':27,'multiline':False]['text':'                        MemoryFormat? memory_format=None) -> Tensor','line_number':28,'multiline':False]['text':' - Argument Conversion','line_number':29,'multiline':False]['text':'       Generates C++ code to convert an ivalue (from stack) to its underlying C++ type.','line_number':30,'multiline':False]['text':'    - int[] size','line_number':31,'multiline':False]['text':'        ```cpp','line_number':32,'multiline':False]['text':'           const c10::List<c10::IValue> size_list_in = (std::move(peek(stack, 0, 7))).toList();','line_number':33,'multiline':False]['text':'','line_number':34,'multiline':False]['text':'           std::vector<int64_t> size_vec;','line_number':35,'multiline':False]['text':'           for (c10::IValue size_elem: size_list_in) {','line_number':36,'multiline':False]['text':'               int64_t size_base = size_elem.to<int64_t>();','line_number':37,'multiline':False]['text':'               size_vec.push_back(size_base);','line_number':38,'multiline':False]['text':'           }','line_number':39,'multiline':False]['text':'           at::ArrayRef<int64_t> size_list_out(size_vec);','line_number':40,'multiline':False]['text':'                                 ~~~~~~~~~~~~~ <-- The converted argument from ivalues in the stack.','line_number':41,'multiline':False]['text':'                                                   Will be passed to unboxed kernel.','line_number':42,'multiline':False]['text':'       ```','line_number':43,'multiline':False]['text':'    - Dimname[]? names','line_number':44,'multiline':False]['text':'       ```cpp','line_number':45,'multiline':False]['text':'           c10::optional<c10::IValue> names_opt = (std::move(peek(stack, 1, 7))).toOptional<c10::IValue>();','line_number':46,'multiline':False]['text':'           c10::optional<at::ArrayRef<at::Dimname>> names_opt_out;','line_number':47,'multiline':False]['text':'           if (names_opt.has_value()) {','line_number':48,'multiline':False]['text':'                         ~~~~~~~~~~~ <-- Unwrapping optional shell','line_number':49,'multiline':False]['text':'               const c10::IValue names_opt_in = names_opt.value();','line_number':50,'multiline':False]['text':'               const c10::List<c10::IValue> names_list_in = names_opt_in.toList();','line_number':51,'multiline':False]['text':'','line_number':52,'multiline':False]['text':'               std::vector<at::Dimname> names_vec;','line_number':53,'multiline':False]['text':'               for (c10::IValue names_elem: names_list_in) {','line_number':54,'multiline':False]['text':'                                ~~~~~~~~~~~~~~~~~~~~~~~~~ <-- Unrolling list, then convert elements one by one.','line_number':55,'multiline':False]['text':'                   at::Dimname names_base = names_elem.to<at::Dimname>();','line_number':56,'multiline':False]['text':'                   names_vec.push_back(names_base);','line_number':57,'multiline':False]['text':'               }','line_number':58,'multiline':False]['text':'               at::ArrayRef<at::Dimname> names_list_out(names_vec);','line_number':59,'multiline':False]['text':'','line_number':60,'multiline':False]['text':'               names_opt_out = c10::optional<at::ArrayRef<at::Dimname>>(names_list_out);','line_number':61,'multiline':False]['text':'           } else {','line_number':62,'multiline':False]['text':'               names_opt_out = c10::optional<at::ArrayRef<at::Dimname>>();','line_number':63,'multiline':False]['text':'           }','line_number':64,'multiline':False]['text':'       ```','line_number':65,'multiline':False]['text':'    - ScalarType? dtype (similarly for the rest of the arguments)','line_number':66,'multiline':False]['text':'       ```cpp','line_number':67,'multiline':False]['text':'           c10::optional<c10::IValue> dtype_opt = (std::move(peek(stack, 2, 7))).toOptional<c10::IValue>();','line_number':68,'multiline':False]['text':'           c10::optional<at::ScalarType> dtype_opt_out;','line_number':69,'multiline':False]['text':'           if (dtype_opt.has_value()) {','line_number':70,'multiline':False]['text':'               const c10::IValue dtype_opt_in = dtype_opt.value();','line_number':71,'multiline':False]['text':'               at::ScalarType dtype_base = dtype_opt_in.to<at::ScalarType>();','line_number':72,'multiline':False]['text':'                                                        ~~~~~~~~~~~~~~~~~~~~ <-- For base types, convert ivalue to it','line_number':73,'multiline':False]['text':'                                                                                 directly using ".to<T>()" API.','line_number':74,'multiline':False]['text':'               dtype_opt_out = c10::optional<at::ScalarType>(dtype_base);','line_number':75,'multiline':False]['text':'           } else {','line_number':76,'multiline':False]['text':'               dtype_opt_out = c10::optional<at::ScalarType>();','line_number':77,'multiline':False]['text':'           }','line_number':78,'multiline':False]['text':'       ```','line_number':79,'multiline':False]['text':'','line_number':80,'multiline':False]['text':' - Unboxed Kernel Call','line_number':81,'multiline':False]['text':'   ```cpp','line_number':82,'multiline':False]['text':'       auto result_ = torch::empty(','line_number':83,'multiline':False]['text':'           size_list_out,','line_number':84,'multiline':False]['text':'           names_opt_out,','line_number':85,'multiline':False]['text':'           options,','line_number':86,'multiline':False]['text':'           memory_format_opt_out','line_number':87,'multiline':False]['text':'       );','line_number':88,'multiline':False]['text':'   ```','line_number':89,'multiline':False]['text':'','line_number':90,'multiline':False]['text':' - Push Result Back to Stack','line_number':91,'multiline':False]['text':'   ```cpp','line_number':92,'multiline':False]['text':'       drop(stack, 7);','line_number':93,'multiline':False]['text':'       pack(stack, std::move(result_));','line_number':94,'multiline':False]['text':'   ```','line_number':95,'multiline':False]['text':' Return unboxing function name for a NativeFunction','line_number':99,'multiline':False]['text':' Convert all the arguments in a NativeFunction to C++ code','line_number':104,'multiline':False]['text':' we need the 'self' argument so method needs to be False','line_number':106,'multiline':False]['text':' expecting only Argument','line_number':118,'multiline':False]['text':' Takes in the type, name and mutability corresponding to an argument, and generates a tuple of:','line_number':135,'multiline':False]['text':' (1) the C++ code necessary to unbox the argument','line_number':136,'multiline':False]['text':' (2) A Binding corresponding to the newly created unboxed variable, including variable name and its CType','line_number':137,'multiline':False]['text':' Unboxing is for mobile, which doesn't care about SymInts','line_number':141,'multiline':False]['text':' handle list type with size, e.g., bool[4]','line_number':210,'multiline':False]['text':' we have to use c10::List for optional element. e.g., Tensor?[] -> c10::List<c10::optional<at::Tensor>>','line_number':219,'multiline':False]['text':' use ArrayRef as default.','line_number':233,'multiline':False]['text':' need to bring vector instantiation out of scope so that ArrayRef has valid data','line_number':235,'multiline':False]