['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':21,'multiline':False]['text':'','line_number':22,'multiline':False]['text':'                           Data Models','line_number':23,'multiline':False]['text':'','line_number':24,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':25,'multiline':False]['text':'','line_number':26,'multiline':False]['text':' [Notes] python binding codegen','line_number':27,'multiline':False]['text':'','line_number':28,'multiline':False]['text':' The Python binding codegen produces code that takes the input list of','line_number':29,'multiline':False]['text':' PyObjects, finds the matching ATen C++ function using PythonArgParser,','line_number':30,'multiline':False]['text':' converts the PyObjects into C++ types and calls the ATen C++ function:','line_number':31,'multiline':False]['text':'','line_number':32,'multiline':False]['text':' +--------+  parsing   +------------------------+  binding   +-----------------------+','line_number':33,'multiline':False]['text':' | PyObjs | ---------> | PythonArgParser Output | ---------> | Cpp Function Dispatch |','line_number':34,'multiline':False]['text':' +--------+            +------------------------+            +-----------------------+','line_number':35,'multiline':False]['text':'','line_number':36,'multiline':False]['text':' The following examples demonstrate the data models the Python binding','line_number':37,'multiline':False]['text':' codegen needs to deal with and the tasks it needs to accomplish. It','line_number':38,'multiline':False]['text':' helps understand the purpose of the new data types we introduced below.','line_number':39,'multiline':False]['text':'','line_number':40,'multiline':False]['text':'  - Function Schema (source of truth)','line_number':41,'multiline':False]['text':'','line_number':42,'multiline':False]['text':'      aten::empty.names(int[] size, *, Dimname[]? names,','line_number':43,'multiline':False]['text':'                        ScalarType? dtype=None, Layout? layout=None,','line_number':44,'multiline':False]['text':'                        Device? device=None, bool? pin_memory=None,','line_number':45,'multiline':False]['text':'                        MemoryFormat? memory_format=None) -> Tensor','line_number':46,'multiline':False]['text':'','line_number':47,'multiline':False]['text':'  - Python Signature','line_number':48,'multiline':False]['text':'','line_number':49,'multiline':False]['text':'    It's used to generate input schema string for PythonArgParser.','line_number':50,'multiline':False]['text':'    Note: TensorOptions fields are reordered and the additional','line_number':51,'multiline':False]['text':'    'requires_grad' field is added:','line_number':52,'multiline':False]['text':'','line_number':53,'multiline':False]['text':'      empty(IntArrayRef size, *, DimnameList? names,','line_number':54,'multiline':False]['text':'            MemoryFormat? memory_format=None, ScalarType dtype=None,','line_number':55,'multiline':False]['text':'            Layout layout=torch.strided, Device device=None,','line_number':56,'multiline':False]['text':'            bool pin_memory=False, bool requires_grad=False)','line_number':57,'multiline':False]['text':'','line_number':58,'multiline':False]['text':'  - C++ Signature','line_number':59,'multiline':False]['text':'','line_number':60,'multiline':False]['text':'    It's used to generate C++ lambda formals & dispatch call.','line_number':61,'multiline':False]['text':'    Note: the scattered TensorOptions fields are packed into 'options'.','line_number':62,'multiline':False]['text':'','line_number':63,'multiline':False]['text':'      auto dispatch_empty =','line_number':64,'multiline':False]['text':'          [](IntArrayRef size, c10::optional<DimnameList> names,','line_number':65,'multiline':False]['text':'             const TensorOptions & options,','line_number':66,'multiline':False]['text':'             c10::optional<MemoryFormat> memory_format) -> Tensor {','line_number':67,'multiline':False]['text':'          pybind11::gil_scoped_release no_gil;','line_number':68,'multiline':False]['text':'          return torch::empty(size, names, options, memory_format);','line_number':69,'multiline':False]['text':'      };','line_number':70,'multiline':False]['text':'','line_number':71,'multiline':False]['text':'  - Binding between Python Arguments and C++ Arguments','line_number':72,'multiline':False]['text':'','line_number':73,'multiline':False]['text':'    Given a set of Python Arguments in scope, we need produce the','line_number':74,'multiline':False]['text':'    binding expressions that translate the Python API into C++ API:','line_number':75,'multiline':False]['text':'','line_number':76,'multiline':False]['text':'            Python Args               Cpp Args       Binding Exprs','line_number':77,'multiline':False]['text':'     -----------------------------------------------------------------','line_number':78,'multiline':False]['text':'         0: size                      size           '_r.intlist(0)'','line_number':79,'multiline':False]['text':'         1: names                     names          'names' [special init]','line_number':80,'multiline':False]['text':'         2: memory_format -------+','line_number':81,'multiline':False]['text':'         3: dtype         -----+-|--> options        'options' [special packing]','line_number':82,'multiline':False]['text':'         4: layout            /  |','line_number':83,'multiline':False]['text':'         5: device           /   +--> memory_format  '_r.memoryformatOptional(2)'','line_number':84,'multiline':False]['text':'         6: pin_memory      /','line_number':85,'multiline':False]['text':'         7: requires_grad -+','line_number':86,'multiline':False]['text':'','line_number':87,'multiline':False]['text':'    So the full dispatch expression would look like:','line_number':88,'multiline':False]['text':'','line_number':89,'multiline':False]['text':'      dispatch_empty(_r.intlist(0), names, options,','line_number':90,'multiline':False]['text':'                     _r.memoryformatOptional(2))','line_number':91,'multiline':False]['text':'','line_number':92,'multiline':False]['text':'    Where does 'names' come from? It involves special local init:','line_number':93,'multiline':False]['text':'','line_number':94,'multiline':False]['text':'      auto __names = _r.toDimnameListOptional(1);','line_number':95,'multiline':False]['text':'      c10::optional<DimnameList> names =','line_number':96,'multiline':False]['text':'          __names ? c10::make_optional(DimnameList(__names.value()))','line_number':97,'multiline':False]['text':'                  : c10::nullopt;','line_number':98,'multiline':False]['text':'','line_number':99,'multiline':False]['text':'    Where does 'options' come from? It involves special local init','line_number':100,'multiline':False]['text':'    for TensorOptions. Note that Python side has the additional','line_number':101,'multiline':False]['text':'    'requires_grad' field:','line_number':102,'multiline':False]['text':'','line_number':103,'multiline':False]['text':'      const auto options = TensorOptions()','line_number':104,'multiline':False]['text':'          .dtype(_r.scalartype(3))','line_number':105,'multiline':False]['text':'          .device(_r.device(5))','line_number':106,'multiline':False]['text':'          .layout(_r.layoutOptional(4))','line_number':107,'multiline':False]['text':'          .requires_grad(_r.toBool(7))','line_number':108,'multiline':False]['text':'          .pinned_memory(_r.toBool(6));','line_number':109,'multiline':False]['text':'','line_number':110,'multiline':False]['text':'    In some other cases one Python Argument can map to multiple C++','line_number':111,'multiline':False]['text':'    Arguments. For example:','line_number':112,'multiline':False]['text':'','line_number':113,'multiline':False]['text':'     aten::max.names_dim(Tensor self, Dimname dim, bool keepdim=False)','line_number':114,'multiline':False]['text':'       -> (Tensor values, Tensor indices)','line_number':115,'multiline':False]['text':'','line_number':116,'multiline':False]['text':'            Python Args               Cpp Args          Binding Exprs','line_number':117,'multiline':False]['text':'     ---------------------------------------------------------------------','line_number':118,'multiline':False]['text':'                               +----> max               'out[0]'','line_number':119,'multiline':False]['text':'                              /-----> max_values        'out[1]','line_number':120,'multiline':False]['text':'         0: input            /        self              '_r.tensor(0)'','line_number':121,'multiline':False]['text':'         1: dim             /         dim               '_r.dimname(1)'','line_number':122,'multiline':False]['text':'         2: keepdim        /          keepdim           '_r.toBool(2)'','line_number':123,'multiline':False]['text':'         3: out      -----+           [local init] out  '_r.tensorlist_n<2>(3)'','line_number':124,'multiline':False]['text':'','line_number':125,'multiline':False]['text':'    As demonstrated above, the binding can involve reordering,','line_number':126,'multiline':False]['text':'    packing, unpacking and special local inits.','line_number':127,'multiline':False]['text':'','line_number':128,'multiline':False]['text':'','line_number':129,'multiline':False]['text':'  Let's look at a concrete example:','line_number':130,'multiline':False]['text':'','line_number':131,'multiline':False]['text':'      static PythonArgParser parser({','line_number':132,'multiline':False]['text':'        "abs(Tensor input, *, Tensor out=None)",','line_number':133,'multiline':False]['text':'        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':134,'multiline':False]['text':'         ^','line_number':135,'multiline':False]['text':'         +--- Python Schema, represented by PythonSignature and PythonArgument','line_number':136,'multiline':False]['text':'','line_number':137,'multiline':False]['text':'      }, /*traceable=*/true);','line_number':138,'multiline':False]['text':'','line_number':139,'multiline':False]['text':'      ParsedArgs<2> parsed_args;','line_number':140,'multiline':False]['text':'      auto _r = parser.parse(nullptr, args, kwargs, parsed_args);','line_number':141,'multiline':False]['text':'','line_number':142,'multiline':False]['text':'      ...','line_number':143,'multiline':False]['text':'','line_number':144,'multiline':False]['text':'      if (_r.isNone(1)) {','line_number':145,'multiline':False]['text':'          ~~~~~~~~~~~~  <--- Scattered PythonArgParser output (arg name = 'out')','line_number':146,'multiline':False]['text':'                             represented by PythonArgParserOutputExpr','line_number':147,'multiline':False]['text':'','line_number':148,'multiline':False]['text':'        // aten::abs(Tensor self) -> Tensor','line_number':149,'multiline':False]['text':'        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':150,'multiline':False]['text':'         ^','line_number':151,'multiline':False]['text':'         +--- NativeFunction schema, base version','line_number':152,'multiline':False]['text':'','line_number':153,'multiline':False]['text':'        auto dispatch_abs = [](const Tensor & self) -> Tensor {','line_number':154,'multiline':False]['text':'                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':155,'multiline':False]['text':'                             ^','line_number':156,'multiline':False]['text':'                             +--- dispatch_lambda_args / dispatch_lambda_return_str','line_number':157,'multiline':False]['text':'                                  generated from NativeFunction / CppSignature','line_number':158,'multiline':False]['text':'                                  (deprecated PythonSignature is special)','line_number':159,'multiline':False]['text':'                                  arguments are represented by DispatchLambdaArgument','line_number':160,'multiline':False]['text':'','line_number':161,'multiline':False]['text':'          pybind11::gil_scoped_release no_gil;','line_number':162,'multiline':False]['text':'          return self.abs();','line_number':163,'multiline':False]['text':'                 ~~~~~~~~~~~  <--- cpp_dispatch_target / cpp_dispatch_exprs','line_number':164,'multiline':False]['text':'                                   generated from NativeFunction / CppSignature','line_number':165,'multiline':False]['text':'        };','line_number':166,'multiline':False]['text':'        return wrap(dispatch_abs(_r.tensor(0)));','line_number':167,'multiline':False]['text':'                                 ~~~~~~~~~~~~~','line_number':168,'multiline':False]['text':'                                  ^','line_number':169,'multiline':False]['text':'                                  +--- dispatch_lambda_exprs','line_number':170,'multiline':False]['text':'                                       binding PythonArgParserOutputExpr (python args)','line_number':171,'multiline':False]['text':'                                       and DispatchLambdaArgument (c++ args)','line_number':172,'multiline':False]['text':'','line_number':173,'multiline':False]['text':'      } else {','line_number':174,'multiline':False]['text':'        // aten::abs.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)','line_number':175,'multiline':False]['text':'        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':176,'multiline':False]['text':'         ^','line_number':177,'multiline':False]['text':'         +--- NativeFunction schema, out-variant','line_number':178,'multiline':False]['text':'','line_number':179,'multiline':False]['text':'        auto dispatch_abs_out = [](Tensor out, const Tensor & self) -> Tensor {','line_number':180,'multiline':False]['text':'          pybind11::gil_scoped_release no_gil;','line_number':181,'multiline':False]['text':'          return at::abs_out(out, self);','line_number':182,'multiline':False]['text':'        };','line_number':183,'multiline':False]['text':'        return wrap(dispatch_abs_out(_r.tensor(1), _r.tensor(0)));','line_number':184,'multiline':False]['text':'      }','line_number':185,'multiline':False]['text':'','line_number':186,'multiline':False]['text':'','line_number':187,'multiline':False]['text':' [Notes] python interface codegen','line_number':188,'multiline':False]['text':' The python dataclasses below are used used to generate both python binding code','line_number':189,'multiline':False]['text':' and pyi type hint signatures.','line_number':190,'multiline':False]['text':' In theory these two should look very similar, but there are number of differences','line_number':191,'multiline':False]['text':' in how pyi signatures vs. python_arg_parser signatures are generated.','line_number':192,'multiline':False]['text':' These differences have been encapsulated in signature_str() vs. signature_str_pyi()','line_number':193,'multiline':False]['text':' to display the full signatures, and argument_str() vs argument_str_pyi() to display arguments.','line_number':194,'multiline':False]['text':' For examples, only pyi signatures include return types.','line_number':195,'multiline':False]['text':' Used to generate the default init expr for some PythonArgParser outputs, e.g.:','line_number':209,'multiline':False]['text':'','line_number':210,'multiline':False]['text':'   _r.layoutWithDefault(3, layout_from_backend(self.options().backend())))','line_number':211,'multiline':False]['text':'                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':212,'multiline':False]['text':'                            ^','line_number':213,'multiline':False]['text':'                            +--- default_init str','line_number':214,'multiline':False]['text':' Compute argument formal for python argument parsing.','line_number':217,'multiline':False]['text':' Needs to be consistent with torch/csrc/utils/python_arg_parser.h.','line_number':218,'multiline':False]['text':' s/self/input/ outside method bindings','line_number':227,'multiline':False]['text':' [old codegen] TODO: remove this? doesn't rename in codegen, it's just','line_number':228,'multiline':False]['text':' for the parse string','line_number':229,'multiline':False]['text':' add default','line_number':233,'multiline':False]['text':' s/self/input/ outside method bindings','line_number':250,'multiline':False]['text':' [old codegen] TODO: remove this? doesn't rename in codegen, it's just','line_number':251,'multiline':False]['text':' for the parse string','line_number':252,'multiline':False]['text':' from is a Python keyword...','line_number':256,'multiline':False]['text':' pyi merges the _out and functional variants into the same signature, with an optional out arg','line_number':259,'multiline':False]['text':' pyi deprecated signatures don't get defaults for their out arg','line_number':263,'multiline':False]['text':' add default','line_number':270,'multiline':False]['text':' In Python signature multiple output fields are packed into one 'out' argument.','line_number':294,'multiline':False]['text':' When binding to C++, it's first binded to a local 'out' variable:','line_number':295,'multiline':False]['text':'   'auto out = _r.tensorlist_n<2>(2);',','line_number':296,'multiline':False]['text':' then binded to scattered C++ output arguments as 'out[0]', 'out[1]', and etc.','line_number':297,'multiline':False]['text':' TODO: maybe don't need keep scattered out fields for python signature?','line_number':298,'multiline':False]['text':' TODO: shouldn't this be OptionalType[ListType[...]], since it defaults to None?','line_number':322,'multiline':False]['text':' Base operator name, without inplace/outplace suffix.','line_number':333,'multiline':False]['text':' Positional arguments.','line_number':336,'multiline':False]['text':' TODO: create a dedicated SelfArgument type for 'self'?','line_number':337,'multiline':False]['text':' Keyword arguments excluding the 'out' argument and scattered kwargs belonging','line_number':340,'multiline':False]['text':' to TensorOptions (dtype, layout, device, pin_memory, requires_grad, etc).','line_number':341,'multiline':False]['text':' Return types, which are only used by pyi','line_number':346,'multiline':False]['text':' These are scattered kwargs arguments belonging to TensorOptions.','line_number':349,'multiline':False]['text':' When binding to C++, they are packed into a TensorOptions object 'options'.','line_number':350,'multiline':False]['text':' It's possible that the C++ signature doesn't take TensorOptions object (e.g.','line_number':351,'multiline':False]['text':' for out variant), in which case they will be used as scattered fields without','line_number':352,'multiline':False]['text':' being packed into 'options'.','line_number':353,'multiline':False]['text':' TODO: maybe create a PythonTensorOptionsArgument?','line_number':354,'multiline':False]['text':' method or function signature?','line_number':357,'multiline':False]['text':' [old codegen] Compute the Python function signature for argument parsing,','line_number':382,'multiline':False]['text':' as specified in torch/csrc/utils/python_arg_parser.h.  WARNING:','line_number':383,'multiline':False]['text':' this is NOT the same type signature as specified by PEP 484','line_number':384,'multiline':False]['text':' as understood by mypy; our format was independently developed','line_number':385,'multiline':False]['text':' and has some quirks to make it more suitable specifically','line_number':386,'multiline':False]['text':' for error parsing.','line_number':387,'multiline':False]['text':'','line_number':388,'multiline':False]['text':' For a translation to mypy-valid type signatures, see','line_number':389,'multiline':False]['text':' signature_str_pyi().','line_number':390,'multiline':False]['text':' only pyi signatures include returns','line_number':411,'multiline':False]['text':' pyi also includes self (with no typing/defaults) for methods','line_number':413,'multiline':False]['text':' only pyi uses vararg signatures','line_number':419,'multiline':False]['text':' vararg only applies to pyi signatures. vararg variants are not generated for all signatures','line_number':424,'multiline':False]['text':' Below are the major changes in vararg vs. regular pyi signatures','line_number':440,'multiline':False]['text':' vararg signatures also omit the asterix','line_number':441,'multiline':False]['text':' pyi also includes self (with no typing/defaults) for methods','line_number':445,'multiline':False]['text':' The deprecated python signature involves some special logic, so create a','line_number':451,'multiline':False]['text':' dedicated data model to store these extra properties.','line_number':452,'multiline':False]['text':' Schema for the deprecated function','line_number':455,'multiline':False]['text':' The deprecated signature might miss some arguments that the corresponding','line_number':458,'multiline':False]['text':' C++ signature expects. We need store the constant default values to pass in.','line_number':459,'multiline':False]['text':' For example:','line_number':460,'multiline':False]['text':'   [deprecate signature]: addmm(Scalar beta, Tensor self, Tensor mat1, Tensor mat2)','line_number':461,'multiline':False]['text':'   [func schema]: aten::addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor','line_number':462,'multiline':False]['text':'   [func call]: self.addmm(mat1, mat2, beta, 1)','line_number':463,'multiline':False]['text':' We store ['self', 'mat1', 'mat2', 'beta', '1'] in this case.','line_number':464,'multiline':False]['text':' the codegen doesn't include vararg variants for deprecated signatures','line_number':492,'multiline':False]['text':' This struct is used to hold the PythonSignature and its corresponding','line_number':496,'multiline':False]['text':' NativeFunction BEFORE grouping base and out-variant functions.','line_number':497,'multiline':False]['text':' Why not store NativeFunction in PythonSignature or construct PythonSignature','line_number':498,'multiline':False]['text':' from NativeFunction? Because they are not 1-1 mapped.','line_number':499,'multiline':False]['text':' One native function could have both deprecated and non-deprecated python','line_number':500,'multiline':False]['text':' signatures - NativeFunction doesn't contain information to construct the','line_number':501,'multiline':False]['text':' deprecated python signature.','line_number':502,'multiline':False]['text':' One python signature is used to handle both the base and the out-variant','line_number':503,'multiline':False]['text':' function - see 'PythonSignatureGroup'.','line_number':504,'multiline':False]['text':' We merge pairs of functions with signatures that are equivalent mod','line_number':511,'multiline':False]['text':' output arguments, and use a single entry in the python_arg_parser sig','line_number':512,'multiline':False]['text':' list for both (output arguments become optional).','line_number':513,'multiline':False]['text':' The signature used for Python argument parsing. The outplace signature','line_number':516,'multiline':False]['text':' is preferred if exists, because it can be used to parse inputs for both','line_number':517,'multiline':False]['text':' the out-place variant and the base version (with output omitted).','line_number':518,'multiline':False]['text':' The regular ATen declaration (e.g. conv2d)','line_number':521,'multiline':False]['text':' The out variant (e.g. conv2d_out)','line_number':524,'multiline':False]['text':' prefer the signature with optional out=... arguments because it's the','line_number':540,'multiline':False]['text':' superset that can be used to parse input for both base and outplace.','line_number':541,'multiline':False]['text':' Out overloads in C++ don't have TensorOptions arguments,','line_number':544,'multiline':False]['text':' so take these from the functional variant','line_number':545,'multiline':False]['text':' C++ function dispatch is wrapped in a lambda function. The lambda function','line_number':557,'multiline':False]['text':' has almost the same signature as the C++ function, only with some small','line_number':558,'multiline':False]['text':' variants - see details below.','line_number':559,'multiline':False]['text':' This data model is used to represent arguments of the lambda function','line_number':560,'multiline':False]['text':' signature.','line_number':561,'multiline':False]['text':' To pass PyObjects arguments to C++ function (via the lambda wrapper),','line_number':569,'multiline':False]['text':' we need first convert PyObjects into simple C++ objects. This work','line_number':570,'multiline':False]['text':' is done by PythonArgParser.','line_number':571,'multiline':False]['text':' This data model is used to represent the output of PythonArgParser.','line_number':572,'multiline':False]['text':' It has 1-1 mapping with PythonArgument in PythonSignature.','line_number':573,'multiline':False]['text':' argument name','line_number':576,'multiline':False]['text':' RHS expression to reference PythonArgParser output.','line_number':579,'multiline':False]['text':' In some special cases we need create different expr, e.g.:','line_number':582,'multiline':False]['text':' '_r.isNone(1)' instead of '_r.tensor(1)'.','line_number':583,'multiline':False]['text':' The python argument it maps to.','line_number':586,'multiline':False]['text':' To pass PythonArgParser output to the lambda wrapper, we need bind','line_number':594,'multiline':False]['text':' PythonArgParserOutputExpr to DispatchLambdaArgument.','line_number':595,'multiline':False]['text':' They are not always 1-1 mapped, e.g. scattered TensorOptions fields','line_number':596,'multiline':False]['text':' need be packed into a TensorOptions object, which is the argument','line_number':597,'multiline':False]['text':' that the lambda function wrapper takes.','line_number':598,'multiline':False]['text':' The exprs that provide the binding for lambda arguments, e.g.:','line_number':601,'multiline':False]['text':'','line_number':602,'multiline':False]['text':'   'self' -> '_r.tensor(0)'','line_number':603,'multiline':False]['text':'   'min' -> 'out[0]' / 'min_indices' -> 'out[1]'','line_number':604,'multiline':False]['text':'   'options' -> 'options'','line_number':605,'multiline':False]['text':'','line_number':606,'multiline':False]['text':' It has 1-1 mapping with DispatchLambdaArgument.','line_number':607,'multiline':False]['text':' Special local inits, which might introduce new variables that','line_number':610,'multiline':False]['text':' the 'exprs' above reference, e.g.:','line_number':611,'multiline':False]['text':'','line_number':612,'multiline':False]['text':'   'auto out = _r.tensorlist_n<2>(2);'','line_number':613,'multiline':False]['text':'','line_number':614,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':618,'multiline':False]['text':'','line_number':619,'multiline':False]['text':'                          Helper Functions','line_number':620,'multiline':False]['text':'','line_number':621,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':622,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':633,'multiline':False]['text':'','line_number':634,'multiline':False]['text':'                          Python Signature','line_number':635,'multiline':False]['text':'','line_number':636,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':637,'multiline':False]['text':' 'simple_type' was introduced by the old codegen, which is slightly','line_number':640,'multiline':False]['text':' different from the python schema type, e.g.: doesn't have '?' suffix','line_number':641,'multiline':False]['text':' for optional Tensor/TensorList; doesn't have '[size]' suffix for list type.','line_number':642,'multiline':False]['text':' These python schema type names line up with their function schema names','line_number':671,'multiline':False]['text':' Is it desired to keep '?' for simple_type with new style dispatcher?','line_number':676,'multiline':False]['text':' TODO: directly translate a.default to python default','line_number':723,'multiline':False]['text':' Generates a PythonSignature that can be used for either .pyi or PythonArgParser codegen','line_number':733,'multiline':False]['text':' Skip SelfArgument if this is method.','line_number':751,'multiline':False]['text':' Skip TensorOptionsArguments. Python side TensorOptions','line_number':756,'multiline':False]['text':' arguments are created based on different rules - see below.','line_number':757,'multiline':False]['text':' Reintroduce the scattered fields of TensorOptions for Python.','line_number':771,'multiline':False]['text':' Compared to the cpp counterpart, the python arguments have new property','line_number':772,'multiline':False]['text':' (default_init) and a new argument 'requires_grad', which require some','line_number':773,'multiline':False]['text':' special handlings.','line_number':774,'multiline':False]['text':' [old codegen] TODO: because these aren't guaranteed to be 100% faithful','line_number':775,'multiline':False]['text':' to the original versions in the yaml, this recreation is a potential','line_number':776,'multiline':False]['text':' source of drift between eager and JIT. Pull this logic out to a shared place.','line_number':777,'multiline':False]['text':' [old codegen] this probably won't work if one of the returns is not a tensor,','line_number':787,'multiline':False]['text':' but it will produce a compile-time error that is obvious.','line_number':788,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':878,'multiline':False]['text':'','line_number':879,'multiline':False]['text':'                          Python Interface','line_number':880,'multiline':False]['text':'','line_number':881,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':882,'multiline':False]['text':' When building on Windows, `PyStructSequence_UnnamedField` could not be','line_number':890,'multiline':False]['text':' resolved by the linker for some reason, which cause error in building:','line_number':891,'multiline':False]['text':'','line_number':892,'multiline':False]['text':' python_nn_functions.cpp.obj : error LNK2001: unresolved external symbol','line_number':893,'multiline':False]['text':' PyStructSequence_UnnamedField','line_number':894,'multiline':False]['text':'','line_number':895,'multiline':False]['text':' Thus, at this point in time, we do not support unnamed','line_number':896,'multiline':False]['text':' fields in namedtuple; you must either name all fields,','line_number':897,'multiline':False]['text':' or none of them.','line_number':898,'multiline':False]['text':' These python schema type names line up with their function schema names','line_number':938,'multiline':False]['text':' TODO: this doesn't seem right...','line_number':945,'multiline':False]['text':' Tensor?[] currently translates to Optional[Union[Tuple[Tensor, ...], List[Tensor]]]','line_number':946,'multiline':False]['text':' It should probably translate to   Union[Tuple[Optional[Tensor], ...], List[Optional[Tensor]]]','line_number':947,'multiline':False]['text':' Where arguments are open to accepting Union, return types should return','line_number':974,'multiline':False]['text':' concrete types','line_number':975,'multiline':False]['text':' add an extra newline','line_number':1005,'multiline':False]['text':' Example:','line_number':1007,'multiline':False]['text':' namedtuple_def = (','line_number':1008,'multiline':False]['text':'     "class max(NamedTuple):\n"','line_number':1009,'multiline':False]['text':'     "    values: Tensor\n"','line_number':1010,'multiline':False]['text':'     "    indices: Tensor\n"','line_number':1011,'multiline':False]['text':' )','line_number':1012,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':1030,'multiline':False]['text':'','line_number':1031,'multiline':False]['text':'                        C++ Function Dispatch','line_number':1032,'multiline':False]['text':'','line_number':1033,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':1034,'multiline':False]['text':' This section provides APIs to generate the code that does C++ function','line_number':1035,'multiline':False]['text':' dispatch. The C++ function call is wrapped by a lambda function.','line_number':1036,'multiline':False]['text':' For example:','line_number':1037,'multiline':False]['text':'','line_number':1038,'multiline':False]['text':'    // aten::selu_(Tensor(a!) self) -> Tensor(a!)','line_number':1039,'multiline':False]['text':'    auto dispatch_selu_ = [](Tensor self) -> Tensor {','line_number':1040,'multiline':False]['text':'      pybind11::gil_scoped_release no_gil;','line_number':1041,'multiline':False]['text':'      return at::selu_(self);','line_number':1042,'multiline':False]['text':'    };','line_number':1043,'multiline':False]['text':'','line_number':1044,'multiline':False]['text':' The lambda function's signature follows the C++ signature in common','line_number':1045,'multiline':False]['text':' cases, e.g.:','line_number':1046,'multiline':False]['text':'','line_number':1047,'multiline':False]['text':'   // aten::add.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor','line_number':1048,'multiline':False]['text':'   [](const Tensor & self, const Tensor & other, Scalar alpha) -> Tensor','line_number':1049,'multiline':False]['text':'','line_number':1050,'multiline':False]['text':' For out variant the 'out' argument's type is changed from 'Tensor &'','line_number':1051,'multiline':False]['text':' to 'Tensor'. It's because when calling the lambda it passes in the','line_number':1052,'multiline':False]['text':' PythonArgParser output '_r.tensor(3)', which is stack allocated object','line_number':1053,'multiline':False]['text':' and needs to pass by value. Also see comments in 'dispatch_lambda_return_str()'.','line_number':1054,'multiline':False]['text':'','line_number':1055,'multiline':False]['text':'   // aten::add.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)','line_number':1056,'multiline':False]['text':'   [](Tensor out, const Tensor & self, const Tensor & other, Scalar alpha) -> Tensor','line_number':1057,'multiline':False]['text':'','line_number':1058,'multiline':False]['text':' For multi-output case it can keep using reference type because the','line_number':1059,'multiline':False]['text':' PythonArgParser output has been unpacked to local variables, e.g.:','line_number':1060,'multiline':False]['text':'','line_number':1061,'multiline':False]['text':'   // aten::max.names_dim_max(Tensor self, Dimname dim, bool keepdim=False, *,','line_number':1062,'multiline':False]['text':'   //     Tensor(a!) max, Tensor(b!) max_values) -> (Tensor(a!) values, Tensor(b!) indices)','line_number':1063,'multiline':False]['text':'   [](Tensor & max, Tensor & max_values, const Tensor & self, Dimname dim, bool keepdim) -> std::tuple<Tensor,Tensor>','line_number':1064,'multiline':False]['text':'','line_number':1065,'multiline':False]['text':' For deprecated python signature, it should follow deprecated python arg order.','line_number':1066,'multiline':False]['text':' TODO: This is to keep same byte-for-byte result as the old codegen - maybe unnecessary?','line_number':1067,'multiline':False]['text':' Start with cpp arguments - dispatch lambda signature always include 'self'','line_number':1078,'multiline':False]['text':' Convert from cpp argument to lambda argument','line_number':1088,'multiline':False]['text':' For method's 'self', we can use 'const Tensor &' and simply ignore mutability!','line_number':1093,'multiline':False]['text':' For other cases we need prevent dangling refs to temps (unless it's','line_number':1096,'multiline':False]['text':' unpacked scattered output)','line_number':1097,'multiline':False]['text':' The reason is explained in the comments above and in 'dispatch_lambda_return_str()'.','line_number':1098,'multiline':False]['text':' TODO: avoid this special handling?','line_number':1099,'multiline':False]['text':' [old codegen] XXX: if you got here because of an assertion failure, it doesn't mean','line_number':1114,'multiline':False]['text':' it's enough to just extend the list here. Before you do this, make sure','line_number':1115,'multiline':False]['text':' to add an appropriate wrap() overload in torch/csrc/autograd/utils/wrap_outputs.h.','line_number':1116,'multiline':False]['text':' Needed for flash attention forw/backward','line_number':1131,'multiline':False]['text':' [old codegen] Remove type annotation (e.g. 'Tensor' rather than 'Tensor &')','line_number':1147,'multiline':False]['text':' because the dispatch lambdas take mutable arguments *by value*, not','line_number':1148,'multiline':False]['text':' by reference. If you then return a reference to such an argument, you','line_number':1149,'multiline':False]['text':' will now have a pointer to a dangling stack entry. Not good.','line_number':1150,'multiline':False]['text':'','line_number':1151,'multiline':False]['text':' You want:','line_number':1152,'multiline':False]['text':'','line_number':1153,'multiline':False]['text':'   auto dispatch_selu_ = [](Tensor self) -> Tensor { ...; return at::selu_(self); };','line_number':1154,'multiline':False]['text':'                                            ^^^^^^','line_number':1155,'multiline':False]['text':'','line_number':1156,'multiline':False]['text':' *not*','line_number':1157,'multiline':False]['text':'','line_number':1158,'multiline':False]['text':'   auto dispatch_selu_ = [](Tensor self) -> Tensor& { ...; return at::selu_(self); };','line_number':1159,'multiline':False]['text':'                                            ^^^^^^^','line_number':1160,'multiline':False]['text':'','line_number':1161,'multiline':False]['text':' (NB: We can't make dispatch_selu_ take Tensor&, because the enclosing','line_number':1162,'multiline':False]['text':' codegen looks like dispatch_selu_(_r.tensor(0)), and you can't take a','line_number':1163,'multiline':False]['text':' mutable reference to temporary.  Maybe we could assign it to a','line_number':1164,'multiline':False]['text':' variable itself.)','line_number':1165,'multiline':False]['text':' By default the exprs are consistent with the C++ signature.','line_number':1198,'multiline':False]['text':' For deprecated python signature we may need fill in some constants.','line_number':1201,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':1215,'multiline':False]['text':'','line_number':1216,'multiline':False]['text':'                     Python / C++ Args Binding','line_number':1217,'multiline':False]['text':'','line_number':1218,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #','line_number':1219,'multiline':False]['text':' We explicitly enumerate the PythonArgParser unpacking methods for all','line_number':1222,'multiline':False]['text':' supported types. This might be more verbose than necessary, partially','line_number':1223,'multiline':False]['text':' because of the irregularity of unpacking method naming, partially','line_number':1224,'multiline':False]['text':' because we want to mimic the old codegen behavior - to reject','line_number':1225,'multiline':False]['text':' unexpected and/or unsupported cases which the old codegen rejects.','line_number':1226,'multiline':False]['text':' For certain cases it is intentionally more restrictive than necessary,','line_number':1227,'multiline':False]['text':' e.g.: it doesn't accepts doublelist with definite size.','line_number':1228,'multiline':False]['text':' These unpack methods line up with their schema names','line_number':1253,'multiline':False]['text':' If default is None: append 'Optional' to elem's unpacking method','line_number':1284,'multiline':False]['text':' Otherwise, load as underlying type with default','line_number':1289,'multiline':False]['text':' accept and use definite size','line_number':1296,'multiline':False]['text':' accept definite size','line_number':1301,'multiline':False]['text':' accept definite size','line_number':1304,'multiline':False]['text':' accept definite size','line_number':1309,'multiline':False]['text':' Return RHS expression for python argument using PythonArgParser output.','line_number':1316,'multiline':False]['text':' e.g. for arg name 'foo', arg type 'bool', arg_index = 2, returns '_r.toBool(2)'','line_number':1317,'multiline':False]['text':' Returns a map with key = arg_name and value = PythonArgParserOutputExpr.','line_number':1336,'multiline':False]['text':' argument name to type for scattered tensor options fields','line_number':1347,'multiline':False]['text':' bind arg parser outputs (python args) with dispatch lambda arguments (c++ args).','line_number':1357,'multiline':False]['text':' This method is to bind 'arg_parser_outputs' and 'lambda_args' by producing','line_number':1361,'multiline':False]['text':' 'inits' and 'lambda_args_exprs' for each lambda argument using arg parser','line_number':1362,'multiline':False]['text':' outputs.','line_number':1363,'multiline':False]['text':' 1. special inits/unpacking to provide binding exprs for lambda arguments.','line_number':1371,'multiline':False]['text':' TODO: why this needs to be special case?','line_number':1377,'multiline':False]['text':' [old codegen]','line_number':1397,'multiline':False]['text':' TODO: make this part of something more general, or get rid of it.','line_number':1398,'multiline':False]['text':' optional<ArrayRef<T>> are special. The PythonArgParser returns an','line_number':1399,'multiline':False]['text':' optional<vector<T>>, which cannot be implicitly converted to','line_number':1400,'multiline':False]['text':' optional<ArrayRef<T>>. One needs to unwrap the optional and rewrap.','line_number':1401,'multiline':False]['text':' noqa: B950','line_number':1405,'multiline':False]['text':' default case - directly using PythonArgParser output expr','line_number':1410,'multiline':False]['text':' method's self is passed directly to python binding, rather than parsed','line_number':1413,'multiline':False]['text':' 2. special packing/checking for TensorOptions.','line_number':1417,'multiline':False]['text':' 3. special case - access scattered TensorOptions fields without packing','line_number':1451,'multiline':False]['text':' TODO: maybe move to the generator side as it's not related to binding.','line_number':1452,'multiline':False]['text':' we're an output-arg variant, check these args against output tensor','line_number':1455,'multiline':False]['text':' we'll set requires_grad on outgoing tensor','line_number':1472,'multiline':False]