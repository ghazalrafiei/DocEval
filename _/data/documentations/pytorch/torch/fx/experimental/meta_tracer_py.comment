['text':' torch.where returns the broadcasted tensor of condition, x, and y,','line_number':31,'multiline':False]['text':' so hack it by using addition','line_number':32,'multiline':False]['text':' Hack so we can track when devices are used. During meta-tensor propagation,','line_number':96,'multiline':False]['text':' replace these values with a constant 'meta'','line_number':97,'multiline':False]['text':' note: not added to the graph yet, if this is a method call','line_number':103,'multiline':False]['text':' we peephole optimize to the method invocation','line_number':104,'multiline':False]['text':' the node for attributes is added lazily, since most will just be method calls','line_number':117,'multiline':False]['text':' which do not rely on the getitem call','line_number':118,'multiline':False]['text':' NOTE: tensor constructors in PyTorch define the `device` argument as','line_number':151,'multiline':False]['text':' *kwargs-only*. That is why this works. If you add methods to','line_number':152,'multiline':False]['text':' _TORCH_METHODS_TO_PATCH that do not define `device` as kwarg-only,','line_number':153,'multiline':False]['text':' this will break and you will likely see issues where we cannot infer','line_number':154,'multiline':False]['text':' the size of the output.','line_number':155,'multiline':False]['text':' TODO','line_number':194,'multiline':False]