['text':' Works for length 2 patterns with 2 modules','line_number':25,'multiline':False]['text':' Output of conv is used by other nodes','line_number':67,'multiline':False]['text':' These are operators that may not be convertible into MKLDNN ops (e.g. the','line_number':115,'multiline':False]['text':' args are scalar values). Thus, we only include them in the subgraph if their','line_number':116,'multiline':False]['text':' arguments are already in MKLDNN.','line_number':117,'multiline':False]['text':' TODO: Determine whether this can be removed after type inference.','line_number':118,'multiline':False]['text':' type: ignore[attr-defined]','line_number':181,'multiline':False]['text':' type: ignore[attr-defined]','line_number':183,'multiline':False]['text':' Inserts to_mkldnn and to_dense around every node we want to be a MKLDNN node.','line_number':285,'multiline':False]['text':' If the op is in `mkldnn_supported` then we always treat it as a MKLDNN node.','line_number':286,'multiline':False]['text':' However, if it's in `mkldnn_supported_unknown`, then we only treat it as','line_number':287,'multiline':False]['text':' a MKLDNN node if its inputs are MKLDNN nodes.','line_number':288,'multiline':False]['text':' Does pre-conversion of all modules into MKLDNN (when possible)','line_number':319,'multiline':False]['text':' type: ignore[attr-defined]','line_number':321,'multiline':False]['text':' optimizes all a -> to_dense -> to_mkldnn -> b patterns into a -> b','line_number':323,'multiline':False]['text':' Current node is part of a MKL subgraph','line_number':340,'multiline':False]['text':' Current node is input to MKL subgraph','line_number':342,'multiline':False]['text':' This code is to find each MKLDNN subgraph. Each MKLDNN subgraph consists','line_number':347,'multiline':False]['text':' of input nodes (which are only `to_mkldnn` calls), output nodes','line_number':348,'multiline':False]['text':' (`to_dense` calls), and intermediate nodes, which are run entirely on','line_number':349,'multiline':False]['text':' MKLDNN layout tensors.','line_number':350,'multiline':False]['text':'','line_number':351,'multiline':False]['text':' Specifically, this code does a flood fill on a directed acyclic graph','line_number':352,'multiline':False]['text':' (DAG), starting from each possible "start node" (i.e: `to_mkldnn` nodes).','line_number':353,'multiline':False]['text':' If every node only had one input, this would be sufficient. However, in','line_number':354,'multiline':False]['text':' the case that a node has multiple inputs coming from different start','line_number':355,'multiline':False]['text':' nodes (i.e. colors), we need to join these 2 colors into 1. That's done','line_number':356,'multiline':False]['text':' using a Disjoint Set Union.','line_number':357,'multiline':False]['text':' Now that we have all the subgraphs, we need to decide which MKLDNN','line_number':387,'multiline':False]['text':' subgraphs we actually want to keep in MKLDNN.','line_number':388,'multiline':False]