['text':' weakref to torch.Tensor','line_number':77,'multiline':False]['text':' TODO: We don't need t_id; we can get it off of w_tensor','line_number':78,'multiline':False]['text':' NOTE(avik): In the future, this could be Union[StrictMinMaxConstraint, <other kinds>]','line_number':120,'multiline':False]['text':' type: ignore[name-defined]','line_number':121,'multiline':False]['text':' Represent that `constraint_range` is shared with another _ConstraintTarget, which','line_number':122,'multiline':False]['text':' typically arises because of a specified equality with another dynamic dimension.','line_number':123,'multiline':False]['text':' Import sympy locally','line_number':128,'multiline':False]['text':' NOTE(avik): We do not support compound expressions like a <= x <= b.','line_number':158,'multiline':False]['text':' This is because Python implicitly desugars them into bool(a <= x) and bool(x <= b),','line_number':159,'multiline':False]['text':' and moreover, enforces that any overload of __bool__ must return True or False.','line_number':160,'multiline':False]['text':' FWIW, sympy also raises TypeError in this case.','line_number':161,'multiline':False]['text':' We need a serialization compatible format of the constraint so that it','line_number':170,'multiline':False]['text':' can be savedin the graph module w/o breaking the module serialization.','line_number':171,'multiline':False]['text':' The saved constraints will be used directly for the post-exporting pass','line_number':172,'multiline':False]['text':' that converts constraints to runtime assertion. The saved constraints','line_number':173,'multiline':False]['text':' will not be saved in the serialized module.','line_number':174,'multiline':False]['text':' TODO: A better way is needed. Currently we use 't_id' to map the constraint,','line_number':175,'multiline':False]['text':' which is not reliable','line_number':176,'multiline':False]['text':' import sympy locally','line_number':199,'multiline':False]['text':' Import sympy locally','line_number':310,'multiline':False]['text':' This means user didn't specify dynamic shapes with argument names.','line_number':463,'multiline':False]['text':' type: ignore[assignment]','line_number':464,'multiline':False]['text':' Import sympy locally','line_number':508,'multiline':False]['text':' Create dict mapping tensor_id to node names','line_number':515,'multiline':False]['text':' Create dict mapping placeholder node names to their nodes','line_number':517,'multiline':False]['text':' All placeholder nodes should be together in the beginning of the','line_number':521,'multiline':False]['text':' graph','line_number':522,'multiline':False]['text':' Create list of (node name, dim) tuples to mark that they are equal','line_number':529,'multiline':False]['text':' Create dict mapping (node name, dim) a list of range (lower, upper)','line_number':531,'multiline':False]['text':' constraints','line_number':532,'multiline':False]['text':' Accumulate range constraints','line_number':538,'multiline':False]['text':' Accumulate equality constraints','line_number':543,'multiline':False]['text':' Create dict mapping symbol to a singular range (lower, upper)','line_number':549,'multiline':False]['text':' Add inline constraints to range_constraints','line_number':552,'multiline':False]['text':' Add input range constraints to range_constraints','line_number':557,'multiline':False]['text':' type: ignore[assignment]','line_number':558,'multiline':False]['text':' Simplify the range constraints into a single range constraint','line_number':559,'multiline':False]['text':' Ex. ranges [2, 10] and [3, 11] would get merged to [3, 10]','line_number':560,'multiline':False]['text':' type: ignore[type-var]','line_number':563,'multiline':False]['text':' type: ignore[type-var]','line_number':564,'multiline':False]['text':' type: ignore[operator]','line_number':565,'multiline':False]['text':' Add input node range constraints','line_number':567,'multiline':False]