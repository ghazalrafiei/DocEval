['text':' Encoding quadruples of True/False values as follows:','line_number':37,'multiline':False]['text':'     [True,  True,  False, False] -> 0b0100','line_number':38,'multiline':False]['text':'     [True,  False, True,  False] -> 0b1000','line_number':39,'multiline':False]['text':'     [False, True,  True,  False] -> 0b1001','line_number':40,'multiline':False]['text':'     [True,  False, False, True ] -> 0b1100','line_number':41,'multiline':False]['text':'     [False, True,  False, True ] -> 0b1101','line_number':42,'multiline':False]['text':'     [False, False, True,  True ] -> 0b1110','line_number':43,'multiline':False]['text':' Thus, lower two bits in the encoding are index of the True value','line_number':44,'multiline':False]['text':' at the lowest index in the quadruple, and the higher two bits in','line_number':45,'multiline':False]['text':' the encoding are index of the other True value in the quadruple.','line_number':46,'multiline':False]['text':' In case there are less than two True values, than False value or','line_number':47,'multiline':False]['text':' values at some index or indices are considered True for the','line_number':48,'multiline':False]['text':' encoding.  In case there are more than two True values, then the','line_number':49,'multiline':False]['text':' excess True value(s) at some indices are considered False for','line_number':50,'multiline':False]['text':' the encoding.  The exact encodings used for these cases are as','line_number':51,'multiline':False]['text':' follows:','line_number':52,'multiline':False]['text':'     [False, False, False, False] -> 0b1110','line_number':53,'multiline':False]['text':'     [False, False, False, True ] -> 0b1110','line_number':54,'multiline':False]['text':'     [False, False, True,  False] -> 0b1110','line_number':55,'multiline':False]['text':'     [False, True,  False, False] -> 0b1101','line_number':56,'multiline':False]['text':'     [False, True,  True,  True ] -> 0b1001','line_number':57,'multiline':False]['text':'     [True,  False, False, False] -> 0b1100','line_number':58,'multiline':False]['text':'     [True,  False, True,  True ] -> 0b1000','line_number':59,'multiline':False]['text':'     [True,  True,  False, True ] -> 0b0100','line_number':60,'multiline':False]['text':'     [True,  True,  True,  False] -> 0b1000','line_number':61,'multiline':False]['text':'     [True,  True,  True,  True ] -> 0b1000','line_number':62,'multiline':False]['text':' These particular encodings are chosen, with the help of Espresso','line_number':63,'multiline':False]['text':' logic minimizer software, for the purpose of minimization of','line_number':64,'multiline':False]['text':' corresponding Boolean functions, that translate non-zero flags','line_number':65,'multiline':False]['text':' into encoding bits.','line_number':66,'multiline':False]['text':' Metadata values are now to be reshuffled in a way given in','line_number':101,'multiline':False]['text':' reorder_meta() function, in','line_number':102,'multiline':False]['text':' tools/util/include/cutlass/util/host_reorder.h file of CUTLASS','line_number':103,'multiline':False]['text':' source tree.  Furthermore, CUTLASS template for sparse GEMM','line_number':104,'multiline':False]['text':' decides upon layout of this matrix, and at the moment for the','line_number':105,'multiline':False]['text':' sparse GEMM executed on tensor cores, this is layout described','line_number':106,'multiline':False]['text':' by ColumnMajorInterleaved<2> data structure, in','line_number':107,'multiline':False]['text':' include/cutlass/layout/matrix.h of CUTLASS source tree.  The','line_number':108,'multiline':False]['text':' reordering of meta matrix into meta_reordered matrix calculated','line_number':109,'multiline':False]['text':' according to these segments of CUTLASS code is given below.','line_number':110,'multiline':False]['text':' However, this calculation produces offsets for scatter access','line_number':111,'multiline':False]['text':' from metadata matrix to redordered metadata matrix, and gather','line_number':112,'multiline':False]['text':' pattern is more efficient.  For this reason, the scatter offsets','line_number':113,'multiline':False]['text':' are reverted and printed, through enabling commented block at','line_number':114,'multiline':False]['text':' the end of following code.  Resulting gather offsets are then','line_number':115,'multiline':False]['text':' analyzed, on several (m, k) value pairs (in particular: (32,','line_number':116,'multiline':False]['text':' 128), (32, 256), (64, 128) and (64, 256)), and the code that','line_number':117,'multiline':False]['text':' follows this comment is written to reproduce these gather offsets.','line_number':118,'multiline':False]['text':'','line_number':119,'multiline':False]['text':'    dst_rows = torch.arange(0, m, device=device)[:, None].repeat(1, meta_ncols)','line_number':120,'multiline':False]['text':'    dst_cols = torch.arange(0, meta_ncols, device=device).repeat(m, 1)','line_number':121,'multiline':False]['text':'','line_number':122,'multiline':False]['text':'    # Reorder the rows, then swizzle the 2x2 blocks.','line_number':123,'multiline':False]['text':'    group = 32 if meta_dtype.itemsize == 2 else 16','line_number':124,'multiline':False]['text':'    interweave = 4 if meta_dtype.itemsize == 2 else 2','line_number':125,'multiline':False]['text':'    dst_rows = (','line_number':126,'multiline':False]['text':'        dst_rows // group * group','line_number':127,'multiline':False]['text':'        + (dst_rows % 8) * interweave','line_number':128,'multiline':False]['text':'        + (dst_rows % group) // 8','line_number':129,'multiline':False]['text':'    )','line_number':130,'multiline':False]['text':'','line_number':131,'multiline':False]['text':'    topright = ((dst_rows % 2 == 0) & (dst_cols % 2 == 1)).to(torch.int8)','line_number':132,'multiline':False]['text':'    bottomleft = ((dst_rows % 2 == 1) & (dst_cols % 2 == 0)).to(torch.int8)','line_number':133,'multiline':False]['text':'    dst_rows += topright - bottomleft','line_number':134,'multiline':False]['text':'    dst_cols -= topright - bottomleft','line_number':135,'multiline':False]['text':'','line_number':136,'multiline':False]['text':'    # Assumed that meta tensor is to be stored in CUTLASS','line_number':137,'multiline':False]['text':'    # InterleavedColumnMajor layout, and reverse engineered','line_number':138,'multiline':False]['text':'    # corresponding code to store values into this tensor.','line_number':139,'multiline':False]['text':'    interleave = 2','line_number':140,'multiline':False]['text':'    cols_maj = dst_cols // interleave','line_number':141,'multiline':False]['text':'    cols_min = dst_cols % interleave','line_number':142,'multiline':False]['text':'    meta_reordered_offsets = (','line_number':143,'multiline':False]['text':'        cols_maj * m * interleave + dst_rows * interleave + cols_min','line_number':144,'multiline':False]['text':'    )','line_number':145,'multiline':False]['text':'','line_number':146,'multiline':False]['text':'    meta_reordered = torch.empty((m, meta_ncols), dtype=meta_dtype, device=device)','line_number':147,'multiline':False]['text':'    meta_reordered.view(-1)[meta_reordered_offsets.view(-1)] = meta.view(-1)','line_number':148,'multiline':False]['text':'','line_number':149,'multiline':False]['text':'    # Uncomment to have gather pattern for meta_reordered printed','line_number':150,'multiline':False]['text':'    #','line_number':151,'multiline':False]['text':'    #offsets = torch.empty(','line_number':152,'multiline':False]['text':'    #    (m, meta_ncols), dtype=meta_reordered_offsets.dtype, device=device','line_number':153,'multiline':False]['text':'    #)','line_number':154,'multiline':False]['text':'    #offsets.view(-1)[meta_reordered_offsets.view(-1)] = torch.arange(','line_number':155,'multiline':False]['text':'    #    0, m * meta_ncols, dtype=meta_reordered_offsets.dtype, device=device','line_number':156,'multiline':False]['text':'    #)','line_number':157,'multiline':False]['text':'    #torch.set_printoptions(threshold=1000000)','line_number':158,'multiline':False]['text':'    #print("------------------------------------------------------------")','line_number':159,'multiline':False]['text':'    #print("dtype =", dtype, ", m =", m, ", k =", k, ", meta_ncols =", meta_ncols)','line_number':160,'multiline':False]['text':'    #print(offsets.view(-1))','line_number':161,'multiline':False]['text':'','line_number':162,'multiline':False]['text':' No point to try to understand this code: as mentioned in the','line_number':164,'multiline':False]['text':' comment above it is written to reproduce gather offsets, as','line_number':165,'multiline':False]['text':' these would be calculated by CUTLASS, and to be efficient, but','line_number':166,'multiline':False]['text':' it contains several magic values and magic calculations that','line_number':167,'multiline':False]['text':' make it rather hard to read, let alone understand.','line_number':168,'multiline':False]['text':' This function converts dense matrix into sparse semi-structured','line_number':322,'multiline':False]['text':' representation, producing "compressed" matrix, in the layout used by','line_number':323,'multiline':False]['text':' CUTLASS backend, and corresponding metadata matrix.','line_number':324,'multiline':False]['text':' This function performs reverse of the function above - it','line_number':335,'multiline':False]['text':' reconstructs dense matrix from a pair of "compressed" matrix, given','line_number':336,'multiline':False]['text':' in the layout used by CUTLASS backend, and accompanying metadata','line_number':337,'multiline':False]['text':' matrix.','line_number':338,'multiline':False]