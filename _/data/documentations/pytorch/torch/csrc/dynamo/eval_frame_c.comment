['text':' Problem in CPython includes when mixing core and non-core build','line_number':8,'multiline':False]['text':' The fix was not backported to 3.12 so this is needed here','line_number':9,'multiline':False]['text':' https://github.com/python/cpython/issues/105268','line_number':10,'multiline':False]['text':' see https://bugs.python.org/issue35886','line_number':15,'multiline':False]['text':' These headers were added in 3.11','line_number':20,'multiline':False]['text':' PY_VERSION_HEX >= 0x03080000','line_number':26,'multiline':False]['text':' All the eval APIs change in 3.11 so we need to decide which one to use on the fly','line_number':28,'multiline':False]['text':' https://docs.python.org/3/c-api/init.html#c._PyFrameEvalFunction','line_number':29,'multiline':False]['text':' We need to be able to return the _PyInterpreterFrame to python so create','line_number':33,'multiline':False]['text':' a python binding for it','line_number':34,'multiline':False]['text':' Borrowed reference','line_number':38,'multiline':False]['text':' This is not a true attribute of the class but we do access it in python and it is hard to implement','line_number':68,'multiline':False]['text':' on the python side, so do it here:','line_number':69,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,cppcoreguidelines-avoid-non-const-global-variables,modernize-avoid-c-arrays)','line_number':92,'multiline':False]['text':' Uncomment next line to print debug message','line_number':156,'multiline':False]['text':' #define TORCHDYNAMO_DEBUG 1','line_number':157,'multiline':False]['text':' Flag to just run a frame normally','line_number':177,'multiline':False]['text':' Points to the extra scratch space on the code object','line_number':184,'multiline':False]['text':' First call','line_number':258,'multiline':False]['text':' First call','line_number':275,'multiline':False]['text':' Returns the C string name of the current frame.','line_number':283,'multiline':False]['text':'
Our cache resides on the extra scratch space of the code object. The structure
of the cache is as follows:

-> ExtraState
  -> CacheEntry
    -> check_fn
    -> optimized_code
    -> next
  -> FrameState

CacheEntry is a linked list, with each node containing the check_fn for guards
and the optimized code.

The frame_state is a PyDict that enables sharing between different frames. This
is used to detect dynamism in automatic dynamic shapes.

These two are encapsulated into a ExtraState.
','line_number':289,'multiline':True]['text':' Linked list of cache entries, where each cache entry stores','line_number':309,'multiline':False]['text':' the check_fn and the torch.compile optimized python bytecode.','line_number':310,'multiline':False]['text':' check the guards: lambda: <locals of user function>: bool','line_number':313,'multiline':False]['text':' modified user bytecode (protected by check_fn's guards)','line_number':315,'multiline':False]['text':' on a cache miss, linked list of next thing to try','line_number':317,'multiline':False]['text':' The corresponding decrefs for Py_None are in cache_entry_init.','line_number':344,'multiline':False]['text':' ExtraState encasulates CacheEntry and FrameState. ExtraState is the highest','line_number':404,'multiline':False]['text':' level of abstraction of what is stored on the extra code object. Previously,','line_number':405,'multiline':False]['text':' we saved different parts on different extra indexes.  We prefer this way','line_number':406,'multiline':False]['text':' because of cleaner abstraction and faster SetExtra access.','line_number':407,'multiline':False]['text':' TODO(anijain2305) - Consider making this a PyObject. Benefits are','line_number':409,'multiline':False]['text':'   1) Modular dealloc - destroy_extra_state just becomes Py_DECREF(extra)','line_number':410,'multiline':False]['text':'   2) We can directly send the extra object to convert_frame callback. One','line_number':411,'multiline':False]['text':'   data structure - easier to understand code.','line_number':412,'multiline':False]['text':' There might be some perf impact of going through a PyObject on the critical','line_number':413,'multiline':False]['text':' path, but it should not be too bad.','line_number':414,'multiline':False]['text':' Cache entry for the code object','line_number':416,'multiline':False]['text':' Frame state to detect dynamic shape dims','line_number':418,'multiline':False]['text':' CacheEntry helper functions begins ','line_number':423,'multiline':True]['text':' Ownership contract','line_number':428,'multiline':False]['text':' args','line_number':429,'multiline':False]['text':'   - next: steals','line_number':430,'multiline':False]['text':'   - guarded_code: Borrowed','line_number':431,'multiline':False]['text':'  return','line_number':432,'multiline':False]['text':'   - CacheEntry*: new reference.','line_number':433,'multiline':False]['text':' new reference','line_number':434,'multiline':False]['text':' new reference','line_number':435,'multiline':False]['text':' equivalent to CacheEntry(check_fn, code, next) in Python','line_number':437,'multiline':False]['text':' new reference','line_number':439,'multiline':False]['text':' CacheEntry e is the now the owner of old cachey entry next. This happens','line_number':440,'multiline':False]['text':' when we incref the next pointer in cache_entry_init.','line_number':441,'multiline':False]['text':' This will recursively call cache_entry_dealloc for the next items in the','line_number':452,'multiline':False]['text':' linked list.','line_number':453,'multiline':False]['text':' CacheEntry helper functions ends ','line_number':458,'multiline':True]['text':' Extractions helper functions begins. They help with NULL and SKIP_CODE corner cases ','line_number':460,'multiline':True]['text':' Helper to extra the cache_entry from the extra state.','line_number':463,'multiline':False]['text':' Ownership contract','line_number':465,'multiline':False]['text':' args','line_number':466,'multiline':False]['text':'  - extra_state: Borrowed','line_number':467,'multiline':False]['text':' return','line_number':468,'multiline':False]['text':'  - CacheEntry: Borrowed.','line_number':469,'multiline':False]['text':' Returns either the previously stored frame state or an empty dict.','line_number':478,'multiline':False]['text':' Ownership contract','line_number':480,'multiline':False]['text':' args','line_number':481,'multiline':False]['text':'  - extra_state: Borrowed','line_number':482,'multiline':False]['text':' return','line_number':483,'multiline':False]['text':'  - extra_state->frame_state: Borrowed.','line_number':484,'multiline':False]['text':' Extractions helper functions ends ','line_number':491,'multiline':True]['text':' Extra state helper functions begins ','line_number':493,'multiline':True]['text':' Ownership contract','line_number':496,'multiline':False]['text':' args','line_number':497,'multiline':False]['text':'  - code: Borrowed','line_number':498,'multiline':False]['text':' return','line_number':499,'multiline':False]['text':'  - extra_state: Borrowed.','line_number':500,'multiline':False]['text':' This is passed as freefunc to _PyEval_RequestCodeExtraIndex. This acts as a','line_number':507,'multiline':False]['text':' deleter for the object on extra scratch space. This function is called','line_number':508,'multiline':False]['text':' internally in _PyCode_SetExtra and also during the code deallocation.','line_number':509,'multiline':False]['text':' Destroys the extra state by deleting cache_entry, frame state and finally','line_number':511,'multiline':False]['text':' freeing the constructed extra state.','line_number':512,'multiline':False]['text':' Developer note - You should not call this function directly. This is called','line_number':514,'multiline':False]['text':' directly inside set_extra_state. If you are in a situation trying to call','line_number':515,'multiline':False]['text':' this function, consider if set_extra_state should be called.','line_number':516,'multiline':False]['text':' Cpython gc will call cache_entry_dealloc on its own when the ref count','line_number':520,'multiline':False]['text':' goes to 0.','line_number':521,'multiline':False]['text':' Clears the existing object sitting on the extra scratch spance and sets it','line_number':529,'multiline':False]['text':' up with the new state. Note that _PyCode_SetExtra calls the','line_number':530,'multiline':False]['text':' destroy_extra_state deleter internally, and therefore we don't call it','line_number':531,'multiline':False]['text':' explicity here.','line_number':532,'multiline':False]['text':' Ownership contract','line_number':534,'multiline':False]['text':' args','line_number':535,'multiline':False]['text':'  - extra_state: Stolen','line_number':536,'multiline':False]['text':' return','line_number':537,'multiline':False]['text':'  - there is no return, but the extra_state is stolen, so it becomes','line_number':538,'multiline':False]['text':'  set_extra_state responsibility to clean it up. It will be deleted during','line_number':539,'multiline':False]['text':'  the reset_code/skip, when the set_extra_state is called with','line_number':540,'multiline':False]['text':'  NULL/SKIP_CODE.','line_number':541,'multiline':False]['text':' Invariant - Dont set the extra state for the extra state that is already on','line_number':543,'multiline':False]['text':' the code object. Otherwise, we will first free up the old extra state','line_number':544,'multiline':False]['text':' (which is also the new extra state) and write something invalid on the','line_number':545,'multiline':False]['text':' scratch space.','line_number':546,'multiline':False]['text':' Creates a new extra state and put it on the extra scrach space of the code','line_number':553,'multiline':False]['text':' object.','line_number':554,'multiline':False]['text':' Ownership contract','line_number':556,'multiline':False]['text':' args','line_number':557,'multiline':False]['text':'  - code: Borrowed','line_number':558,'multiline':False]['text':' return:','line_number':559,'multiline':False]['text':'   - extra_state: New reference.','line_number':560,'multiline':False]['text':' These references are then further passed to set_extra_state which becomes','line_number':561,'multiline':False]['text':' the final owner of these references.','line_number':562,'multiline':False]['text':' Invariant - Extra state should not have been set before, therefore it should be NULL.','line_number':564,'multiline':False]['text':' We set the last node in the linked list to Py_None. We incref the Py_None','line_number':568,'multiline':False]['text':' here, the corresponding decref is in cache_entry_dealloc.','line_number':569,'multiline':False]['text':' Extra state helper functions ends ','line_number':577,'multiline':True]['text':'
Debugger helper functions.
','line_number':579,'multiline':True]['text':' get the cache entry out of a code object','line_number':584,'multiline':False]['text':' remember to update the type signature for DynamoCallbackFn.__call__ in torch/_dynamo/types.py','line_number':611,'multiline':False]['text':' if this function changes','line_number':612,'multiline':False]['text':' call debugging logic when a guard fails','line_number':637,'multiline':False]['text':' Return value: borrowed reference','line_number':648,'multiline':False]['text':' Is either Py_None or a PyCodeObject','line_number':649,'multiline':False]['text':' NB: intentionally not using Py_RETURN_NONE, to return borrowed ref','line_number':652,'multiline':False]['text':' remember to update the type signature for GuardFn.__call__ in torch/_dynamo/types.py','line_number':656,'multiline':False]['text':' if this calling convention changes','line_number':657,'multiline':False]['text':' Keep the head as the most recently used cache entry.','line_number':674,'multiline':False]['text':' If the hit cache entry is not the head of the linked list,','line_number':675,'multiline':False]['text':' move it to the head','line_number':676,'multiline':False]['text':' Override the extra state to reflect the updated cache line.','line_number':679,'multiline':False]['text':' Generate Python function object and _PyInterpreterFrame in a way similar to','line_number':702,'multiline':False]['text':' https://github.com/python/cpython/blob/e715da6db1d1d70cd779dc48e1ba8110c51cc1bf/Python/ceval.c#L1130','line_number':703,'multiline':False]['text':' Most of these don't exist in 3.12 anymore.','line_number':705,'multiline':False]['text':' _PyFunction_CopyWithNewCode and _PyFrame_InitializeSpecials in particular','line_number':706,'multiline':False]['text':' THP_EVAL_API_FRAME_OBJECT (_PyInterpreterFrame) is a regular C struct, so','line_number':718,'multiline':False]['text':' it should be safe to use system malloc over Python malloc, e.g. PyMem_Malloc','line_number':719,'multiline':False]['text':' consumes reference to func','line_number':727,'multiline':False]['text':' localsplus are XINCREF'd by default eval frame, so all values must be valid.','line_number':735,'multiline':False]['text':' copy from old localsplus to new localsplus:','line_number':740,'multiline':False]['text':' for i, name in enumerate(localsplusnames_new):','line_number':741,'multiline':False]['text':'   name_to_idx[name] = i','line_number':742,'multiline':False]['text':' for i, name in enumerate(localsplusnames_old):','line_number':743,'multiline':False]['text':'   fastlocals_new[name_to_idx[name]] = fastlocals_old[i]','line_number':744,'multiline':False]['text':' This wrapper function adds a profiler event','line_number':831,'multiline':False]['text':' Shims logic into one of three states. Can probably be refactored into a','line_number':852,'multiline':False]['text':' single func, later:','line_number':853,'multiline':False]['text':'  - None: disables TorchDynamo','line_number':854,'multiline':False]['text':'  - False: run-only mode (reuse existing compiles)','line_number':855,'multiline':False]['text':'  - Python callable(): enables TorchDynamo','line_number':856,'multiline':False]['text':' When unwinding generators, eval frame is called with throw_flag ==','line_number':889,'multiline':False]['text':' true.  Frame evaluation is supposed to continue unwinding by propagating','line_number':890,'multiline':False]['text':' the exception.  Dynamo doesn't really know how to do this, nor does it','line_number':891,'multiline':False]['text':' really want to do this, because there's unlikely any code to capture','line_number':892,'multiline':False]['text':' (you're going to immediately quit out of the frame, perhaps running','line_number':893,'multiline':False]['text':' some unwinding logic along the way).  So we just run the default','line_number':894,'multiline':False]['text':' handler in this case.','line_number':895,'multiline':False]['text':'','line_number':896,'multiline':False]['text':' NB: A previous version of this patch returned NULL.  This is wrong,','line_number':897,'multiline':False]['text':' because returning NULL is *different* from unwinding an exception.','line_number':898,'multiline':False]['text':' In particular, you will not execute things like context manager','line_number':899,'multiline':False]['text':' __exit__ if you just return NULL.','line_number':900,'multiline':False]['text':'','line_number':901,'multiline':False]['text':' NB: It's /conceivable/ that you might want to actually still call the','line_number':902,'multiline':False]['text':' Dynamo callback when throw_flag == TRUE, to give Dynamo a chance to','line_number':903,'multiline':False]['text':' do any stack unwinding code.  But this is not really useful because','line_number':904,'multiline':False]['text':' (1) Dynamo doesn't actually know how to do stack unwinding, so it would','line_number':905,'multiline':False]['text':' immediately skip the frame, and (2) even if it did, this would only','line_number':906,'multiline':False]['text':' be profitable if there was tensor code in the unwinding code.  Seems','line_number':907,'multiline':False]['text':' unlikely.','line_number':908,'multiline':False]['text':' TODO(jansel): investigate directly using the "fast" representation','line_number':926,'multiline':False]['text':' TODO(alband): This is WRONG for python3.11+ we pass in a _PyInterpreterFrame','line_number':927,'multiline':False]['text':' even though we should pass a PyFrameObject.','line_number':928,'multiline':False]['text':' A callback of Py_False indicates "run only" mode, the cache is checked, but','line_number':934,'multiline':False]['text':' we never compile.','line_number':935,'multiline':False]['text':' guard eval failed, keep propagating','line_number':943,'multiline':False]['text':' used cached version','line_number':950,'multiline':False]['text':' We don't run the current custom_eval_frame behavior for guards.','line_number':958,'multiline':False]['text':' So we temporarily set the callback to Py_None to drive the correct behavior','line_number':959,'multiline':False]['text':' in the shim.','line_number':960,'multiline':False]['text':' Python error','line_number':967,'multiline':False]['text':' used cached version','line_number':971,'multiline':False]['text':' Re-enable custom behavior','line_number':973,'multiline':False]['text':' cache miss','line_number':977,'multiline':False]['text':' TODO(alband): This is WRONG for python3.11+ we pass in a _PyInterpreterFrame','line_number':978,'multiline':False]['text':' that gets re-interpreted as a PyObject (which it is NOT!)','line_number':979,'multiline':False]['text':' internal exception, returning here will leak the exception into user code','line_number':983,'multiline':False]['text':' this is useful for debugging -- but we dont want it to happen outside of','line_number':984,'multiline':False]['text':' testing','line_number':985,'multiline':False]['text':' NB: we intentionally DO NOT re-enable custom behavior to prevent','line_number':986,'multiline':False]['text':' cascading failure from internal exceptions.  The upshot is if','line_number':987,'multiline':False]['text':' Dynamo barfs, that's it for Dynamo, even if you catch the exception','line_number':988,'multiline':False]['text':' inside the torch.compile block we won't try to Dynamo anything else.','line_number':989,'multiline':False]['text':' NB: We could use extract_cache_entry to get the cache_entry, but','line_number':994,'multiline':False]['text':' extract_cache_entry returns a borrowed reference. Modifying a borrowed','line_number':995,'multiline':False]['text':' reference seems wrong. Therefore, we directly access the','line_number':996,'multiline':False]['text':' extra->cache_entry. extra wont be NULL here.','line_number':997,'multiline':False]['text':' Update the existing cache_entry on the extra object. This extra object is','line_number':1000,'multiline':False]['text':' sitting on the extra scratch space, we are just changing the cache_entry','line_number':1001,'multiline':False]['text':' ptr. As a result, extra now becomes the owner of CacheEntry object. This','line_number':1002,'multiline':False]['text':' will be cleaned up when set_extra_state is called.','line_number':1003,'multiline':False]['text':' Re-enable custom behavior','line_number':1004,'multiline':False]['text':' Re-enable custom behavior','line_number':1011,'multiline':False]['text':' Change the eval frame callback and return the old one','line_number':1038,'multiline':False]['text':'  - None: disables TorchDynamo','line_number':1039,'multiline':False]['text':'  - False: run-only mode (reuse existing compiles)','line_number':1040,'multiline':False]['text':'  - Python callable(): enables TorchDynamo','line_number':1041,'multiline':False]['text':' owned by caller','line_number':1044,'multiline':False]['text':' Set thread local callback. This will drive behavior of our shim, if/when it','line_number':1056,'multiline':False]['text':' is installed.','line_number':1057,'multiline':False]['text':' set_extra_state destroys the existing object on extra scratch space.','line_number':1085,'multiline':False]['text':' a dummy C function used in testing','line_number':1091,'multiline':False]['text':' set_extra_state destroys the existing object on extra scratch space.','line_number':1107,'multiline':False]