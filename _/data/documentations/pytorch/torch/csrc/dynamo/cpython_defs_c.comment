['text':' NOTE: all `assert`s below are converted to `CHECK`s','line_number':16,'multiline':False]['text':' Problem in CPython includes when mixing core and non-core build','line_number':20,'multiline':False]['text':' The fix was not backported to 3.12 so this is needed here','line_number':21,'multiline':False]['text':' https://github.com/python/cpython/issues/105268','line_number':22,'multiline':False]['text':' To get _PyOpcode_Deopt','line_number':29,'multiline':False]['text':' As a simple way to reduce the impact of ABI changes on the CPython side, this check forces','line_number':35,'multiline':False]['text':' us to manually re-check that the function didn't change on the next major version','line_number':36,'multiline':False]['text':' 3.12','line_number':37,'multiline':False]['text':' Spoiler alert: They don't! This will be done in a follow up.','line_number':38,'multiline':False]['text':' #error "Please ensure that the functions below still match the CPython implementation for 3.12"','line_number':39,'multiline':False]['text':' https://github.com/python/cpython/blob/a7715ccfba5b86ab09f86ec56ac3755c93b46b48/Objects/frameobject.c#L1079','line_number':42,'multiline':False]['text':' This only works when opcode is a non-quickened form:','line_number':46,'multiline':False]['text':' https://github.com/python/cpython/blob/a7715ccfba5b86ab09f86ec56ac3755c93b46b48/Objects/frameobject.c#L1182','line_number':68,'multiline':False]['text':' Merge fast locals into f->f_locals ','line_number':71,'multiline':True]['text':' COPY_FREE_VARS has no quickened forms, so no need to use _PyOpcode_Deopt','line_number':83,'multiline':False]['text':' here:','line_number':84,'multiline':False]['text':' Free vars have not been initialized -- Do that ','line_number':87,'multiline':True]['text':' COPY_FREE_VARS doesn't have inline CACHEs, either:','line_number':101,'multiline':False]['text':' If the namespace is unoptimized, then one of the
           following cases applies:
           1. It does not contain free variables, because it
              uses import * or is a top-level namespace.
           2. It is a class namespace.
           We don't want to accidentally copy free variables
           into the locals dict used by the class.
        ','line_number':107,'multiline':True]['text':' The cell was set by COPY_FREE_VARS.','line_number':123,'multiline':False]['text':' Note that no *_DEREF ops can happen before MAKE_CELL','line_number':128,'multiline':False]['text':' executes.  So there's no need to duplicate the work','line_number':129,'multiline':False]['text':' that MAKE_CELL would otherwise do later, if it hasn't','line_number':130,'multiline':False]['text':' run yet.','line_number':131,'multiline':False]['text':' (likely) MAKE_CELL must have executed already.','line_number':135,'multiline':False]['text':' (likely) Otherwise it it is an arg (kind & CO_FAST_LOCAL),','line_number':138,'multiline':False]['text':' with the initial value set when the frame was created...','line_number':139,'multiline':False]['text':' (unlikely) ...or it was set to some initial value by','line_number':140,'multiline':False]['text':' an earlier call to PyFrame_LocalsToFast().','line_number':141,'multiline':False]['text':' e.g. COPY_FIELD(op, o, globals) becomes','line_number':167,'multiline':False]['text':' PY_XINCREF((o)->func_globals);','line_number':168,'multiline':False]['text':' (op)->func_globals = (o)->func_globals;','line_number':169,'multiline':False]['text':' Not actually copied from CPython, but loosely based on','line_number':174,'multiline':False]['text':' https://github.com/python/cpython/blob/e715da6db1d1d70cd779dc48e1ba8110c51cc1bf/Objects/funcobject.c','line_number':175,'multiline':False]['text':' Makes a new PyFunctionObject copy of `o`, but with the code object fields','line_number':176,'multiline':False]['text':' determined from `code`.','line_number':177,'multiline':False]['text':' Ensure that all fields defined in the PyFunctionObject struct in','line_number':178,'multiline':False]['text':' https://github.com/python/cpython/blob/e715da6db1d1d70cd779dc48e1ba8110c51cc1bf/Include/cpython/funcobject.h','line_number':179,'multiline':False]['text':' are accounted for.','line_number':180,'multiline':False]['text':' From https://github.com/python/cpython/blob/e715da6db1d1d70cd779dc48e1ba8110c51cc1bf/Objects/frameobject.c#L1020','line_number':210,'multiline':False]['text':' DYNAMO: commented out','line_number':214,'multiline':False]['text':' CALL_STAT_INC(frame_objects_created);','line_number':215,'multiline':False]['text':' From https://github.com/python/cpython/blob/e715da6db1d1d70cd779dc48e1ba8110c51cc1bf/Python/frame.c#L27','line_number':230,'multiline':False]['text':' GH-97002: How did we get into this horrible situation? Most likely,','line_number':247,'multiline':False]['text':' allocating f triggered a GC collection, which ran some code that','line_number':248,'multiline':False]['text':' *also* created the same frame... while we were in the middle of','line_number':249,'multiline':False]['text':' creating it! See test_sneaky_frame_object in test_frame.py for a','line_number':250,'multiline':False]['text':' concrete example.','line_number':251,'multiline':False]['text':'','line_number':252,'multiline':False]['text':' Regardless, just throw f away and use that frame instead, since it's','line_number':253,'multiline':False]['text':' already been exposed to user code. It's actually a bit tricky to do','line_number':254,'multiline':False]['text':' this, since we aren't backed by a real _PyInterpreterFrame anymore.','line_number':255,'multiline':False]['text':' Just pretend that we have an owned, cleared frame so frame_dealloc','line_number':256,'multiline':False]['text':' doesn't make the situation worse:','line_number':257,'multiline':False]['text':' From https://github.com/python/cpython/blob/e715da6db1d1d70cd779dc48e1ba8110c51cc1bf/Include/internal/pycore_frame.h#L163','line_number':271,'multiline':False]['text':' From https://github.com/python/cpython/blob/e715da6db1d1d70cd779dc48e1ba8110c51cc1bf/Python/frame.c#L79','line_number':284,'multiline':False]['text':' This may be a newly-created generator or coroutine frame. Since it's','line_number':296,'multiline':False]['text':' dead anyways, just pretend that the first RESUME ran:','line_number':297,'multiline':False]['text':' Link PyFrameObjects.f_back and remove link through _PyInterpreterFrame.previous ','line_number':308,'multiline':True]['text':' Memory error here. ','line_number':311,'multiline':True]['text':' Nothing we can do about it ','line_number':313,'multiline':True]['text':' DYNAMO: use public GC functions instead of internal ones','line_number':321,'multiline':False]['text':' From https://github.com/python/cpython/blob/e715da6db1d1d70cd779dc48e1ba8110c51cc1bf/Python/frame.c#L120','line_number':327,'multiline':False]['text':' It is the responsibility of the owning generator/coroutine
     * to have cleared the enclosing generator, if any. ','line_number':331,'multiline':True]['text':' GH-99729: Clearing this frame can expose the stack (via finalizers). It's','line_number':335,'multiline':False]['text':' crucial that this frame has been unlinked, and is no longer visible:','line_number':336,'multiline':False]