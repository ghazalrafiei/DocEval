['text':' Together with `torch/utils/data/_utils/signal_handling.py`, the following','line_number':3,'multiline':False]['text':' is an effort to do our best to provide some error message to users when a','line_number':4,'multiline':False]['text':' worker dies due to error / critical signals.','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':' See NOTE [ Signal handling in multiprocessing data loading ] for more','line_number':7,'multiline':False]['text':' details.','line_number':8,'multiline':False]['text':' TODO: The following don't work on Windows. Specifically, sigaction, waitid','line_number':10,'multiline':False]['text':' calls, and SIGCHLD handler. Currently, dummy implementations are provided','line_number':11,'multiline':False]['text':' for Windows.','line_number':12,'multiline':False]['text':' Critical signal handlers should be registered on worker processes before','line_number':31,'multiline':False]['text':' doing work.','line_number':32,'multiline':False]['text':' The handler will raise default handler so that the kill information will be','line_number':33,'multiline':False]['text':' retrieved from main process.','line_number':34,'multiline':False]['text':' Python handle is _set_worker_signal_handlers().','line_number':35,'multiline':False]['text':' signal(2) is really not portable. So use sigaction.','line_number':52,'multiline':False]['text':' http://man7.org/linux/man-pages/man2/signal.2.html','line_number':53,'multiline':False]['text':' When an error happened in DataLoader methods and Python starts to exit, the','line_number':84,'multiline':False]['text':' error trace will keep the loader alive, and Python may kill the children','line_number':85,'multiline':False]['text':' processes first before deleting the loader object. Then the cleaning up','line_number':86,'multiline':False]['text':' methods in DataLoader.__del__ are not yet called, and SIGCHILD will print an','line_number':87,'multiline':False]['text':' error saying a worker is killed by SIGTERM. So we suppress SIGTERM from main','line_number':88,'multiline':False]['text':' loader process here to avoid this by _exit(EXIT_SUCCESS). Note that if we','line_number':89,'multiline':False]['text':' exit with nonzero code, the loader SIGCHLD handler may report RuntimeError','line_number':90,'multiline':False]['text':' again, and then it defeats the whole purpose.','line_number':91,'multiline':False]['text':' Only check the pids we care about','line_number':128,'multiline':False]['text':' Use waitid rather than waitpid so that we can set NOWAIT, and that','line_number':132,'multiline':False]['text':' Python and other handlers can get whatever info they want about the','line_number':133,'multiline':False]['text':' child.','line_number':134,'multiline':False]['text':' ignore errors and case with no waitable child','line_number':139,'multiline':False]['text':' exit with error','line_number':143,'multiline':False]['text':' This is necessary. Otherwise, the runtime error will kill the other','line_number':149,'multiline':False]['text':' workers, and trigger this again.','line_number':150,'multiline':False]['text':' killed by signal','line_number':155,'multiline':False]['text':' This is necessary. Otherwise, the runtime error will kill the other','line_number':163,'multiline':False]['text':' workers, and trigger this again.','line_number':164,'multiline':False]['text':' We don't want to exit on any SIGCHLD from any child. child_pids is a tuple','line_number':174,'multiline':False]['text':' of pids we are interested in.','line_number':175,'multiline':False]['text':' dummy implementations for windows','line_number':227,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,cppcoreguidelines-avoid-non-const-global-variables,modernize-avoid-c-arrays)','line_number':253,'multiline':False]