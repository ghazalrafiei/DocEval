['text':' As described in https://docs.python.org/3/library/functions.html#round','line_number':59,'multiline':False]['text':' When a number is exactly halfway between two integers, python builtin round','line_number':60,'multiline':False]['text':' function will round to even number. We use round(x/2)*2 to handle the','line_number':61,'multiline':False]['text':' special halfway case. For positive 'x', round(x/2)*2 =','line_number':62,'multiline':False]['text':' round((x_e + x_r)/2)*2 = x_e + round(x_r/2)*2, where x_e is an even integer,','line_number':63,'multiline':False]['text':' x_r is either 0.5 of 1.5, round(x_r/2)*2 results a 0 or 2, so the final','line_number':64,'multiline':False]['text':' result will always be a even number. Due to symmetricity, it also applies to','line_number':65,'multiline':False]['text':' negative cases.','line_number':66,'multiline':False]['text':' using the rules from python_arg_parser FunctionParameter::check','line_number':71,'multiline':False]['text':' tensor cannot have grad set, tensor must be 0 dim,','line_number':72,'multiline':False]['text':' and if the dest is an int the source must be integral type','line_number':73,'multiline':False]['text':' simple case, both have same sign','line_number':81,'multiline':False]['text':' in python division rounds down, it doesn't not truncate like in c++','line_number':84,'multiline':False]['text':' in python gcd returns non-negative values','line_number':105,'multiline':False]['text':' Convert an python index (which may be negative) into an index usable for a','line_number':121,'multiline':False]['text':' C++ container','line_number':122,'multiline':False]['text':' Equivalent to list.at(idx)','line_number':124,'multiline':False]['text':' This preserves Python's semantics, which uses eq() to compare two','line_number':307,'multiline':False]['text':' elements, then passes the result to bool().','line_number':308,'multiline':False]['text':' see: https://docs.python.org/3.4/reference/datamodel.html#object.__ge__','line_number':309,'multiline':False]['text':' Specialization for at::Tensor, since it doesn't define operator==','line_number':319,'multiline':False]['text':' Specialization for at::Tensor, since it doesn't define operator==','line_number':323,'multiline':False]['text':' NOLINTNEXTLINE(performance-implicit-conversion-in-loop)','line_number':333,'multiline':False]['text':' FBCode errors without this check - "strict weak ordering"','line_number':360,'multiline':False]['text':' TODO: remove when possible, since it just slows down','line_number':361,'multiline':False]['text':' sorting and doesn't do anything useful','line_number':362,'multiline':False]['text':' Specialization for at::Tensor','line_number':370,'multiline':False]['text':' "strict weak ordering" issue - see other sort','line_number':379,'multiline':False]['text':' Specialization for at::Tensor','line_number':388,'multiline':False]['text':' define implementations for primitive number ops','line_number':463,'multiline':False]['text':' NOLINT(hicpp-signed-bitwise) ','line_number':511,'multiline':True]['text':' define a primitive op over Scalar operands.','line_number':525,'multiline':False]['text':' it's necessary to register this overload following','line_number':526,'multiline':False]['text':' int/float variations to avoid trapping Scalar args','line_number':527,'multiline':False]['text':' in unintended implicit conversions','line_number':528,'multiline':False]['text':'-----------------------------------------------------------------------------','line_number':642,'multiline':False]['text':'-----------------------------------------------------------------------------','line_number':643,'multiline':False]['text':'-----------------------------------------------------------------------------','line_number':644,'multiline':False]['text':'-----------------------------------------------------------------------------','line_number':645,'multiline':False]['text':' Some complex unary ops (like abs, angle) return real valued output, but most','line_number':656,'multiline':False]['text':' other unary ops return complex valued output. So, this macro is used in the','line_number':657,'multiline':False]['text':' former case where we can explicitly pass complex_result_cast argument, which','line_number':658,'multiline':False]['text':' is set to c10::complex<float> in the macro `DEFINE_UNARY_OP_WITH_COMPLEX`','line_number':659,'multiline':False]['text':' defined below.','line_number':660,'multiline':False]['text':' namespace torch::jit','line_number':885,'multiline':False]