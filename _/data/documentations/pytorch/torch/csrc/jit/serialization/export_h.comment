['text':' This map is used to keep track of parameters that should be exported','line_number':22,'multiline':False]['text':' externally. When `defer_weight_export` is true, the returned map contains','line_number':23,'multiline':False]['text':' kv pairs that map {external reference name} -> {at::Tensor to be exported}.','line_number':24,'multiline':False]['text':' It is the responsibility of the caller to export these appropriately.','line_number':25,'multiline':False]['text':'','line_number':26,'multiline':False]['text':' For example, when exporting to a zip archive, the caller may write out files','line_number':27,'multiline':False]['text':' for each entry in the export map, with the filename being the key and the','line_number':28,'multiline':False]['text':' file contents being the raw tensor data.','line_number':29,'multiline':False]['text':' Used for modularized export settling function and node attributes.','line_number':36,'multiline':False]['text':' Serializer for both oldsyle and unified format TorchScript serialization','line_number':69,'multiline':False]['text':' qualifier, e.g. '__torch__.Bar' -> PythonPrint for the file that will be','line_number':107,'multiline':False]['text':' created','line_number':108,'multiline':False]['text':' Used to keep references of storages around during serialization to solve','line_number':110,'multiline':False]['text':' for ABA memory reuse problem hit when storages are created/destroyed','line_number':111,'multiline':False]['text':' during serialization process. Also used to coordinate sharing of storages','line_number':112,'multiline':False]['text':' between Script and eager modules in torch.package.','line_number':113,'multiline':False]['text':' Uniquely identifies a SourceRange in a model.','line_number':116,'multiline':False]['text':' SourceRanges are associated with Nodes of Graphs.','line_number':117,'multiline':False]['text':' However for mobile deployment we dont intend to ship','line_number':118,'multiline':False]['text':' full JIT with capabilities of reading code and constructing','line_number':119,'multiline':False]['text':' graphs.','line_number':120,'multiline':False]['text':' Instead we serialize the Code generated from graph of the methods.','line_number':121,'multiline':False]['text':' Code is serialized in bytecode format that contains instructions','line_number':122,'multiline':False]['text':' corresponding to the nodes of the graph. Since original graph is gone, the','line_number':123,'multiline':False]['text':' question is how do we identify where the ops, in serialized bytecode, come','line_number':124,'multiline':False]['text':' from in original model code. We do this in two parts.','line_number':125,'multiline':False]['text':' 1. Associate a unique tag to SourceRange.','line_number':126,'multiline':False]['text':' 2. Serialize this unique_tag.','line_number':127,'multiline':False]['text':'  2.1 Meaning save <byte_offset, source_range_tag, source range> instead of','line_number':128,'multiline':False]['text':'      <byte_offset, source range>','line_number':129,'multiline':False]['text':' 3. During serializing model for mobile, i.e. bytecode generation,','line_number':130,'multiline':False]['text':'    save unique tag of SourceRange corresponding to the Node.','line_number':131,'multiline':False]['text':' 4. During deserialization, read all the debug_pkl, to construct a map','line_number':132,'multiline':False]['text':'    of <unique_tag, SourceRange> and use tag saved with OPs in bytecode','line_number':133,'multiline':False]['text':'    to lookup the source range.','line_number':134,'multiline':False]['text':' Strictly speaking we will serialize InlinedCallStack directly, which','line_number':135,'multiline':False]['text':' contains SourceRange. This way we have access to entire callstack and not','line_number':136,'multiline':False]['text':' just source information about where the node is, since bytecode inlines the','line_number':137,'multiline':False]['text':' graph before saving it.','line_number':138,'multiline':False]['text':' For testing purposes','line_number':143,'multiline':False]['text':' Write the bytes of a pickle archive and the tensors referenced inside that','line_number':180,'multiline':False]['text':' archive','line_number':181,'multiline':False]['text':' Surrounding system can install an additional hook to produce extra files','line_number':189,'multiline':False]['text':' with metadata based on environment every time a module is serialized.','line_number':190,'multiline':False]['text':'*
 * Generates new bytecode for a Script module and returns what the op list
 * would be for a LiteScriptModule based off the current code base. If you
 * have a LiteScriptModule and want to get the currently present
 * list of ops call _export_operator_list instead.
 ','line_number':194,'multiline':True]['text':' RAII guard to switch the way JIT emits the bytecode for inputs.','line_number':213,'multiline':False]['text':' default_value_for_unspecified_arg:','line_number':214,'multiline':False]['text':' true: instruction of default argument values (like LOADC) is emitted.','line_number':215,'multiline':False]['text':' false: instruction of default argument values are not emitted. Instead','line_number':216,'multiline':False]['text':' they are fetched from operator schema.','line_number':217,'multiline':False]['text':' default_args_before_out_args (to forward compatibile support','line_number':218,'multiline':False]['text':' operators allowing out arguments and default arguments):','line_number':219,'multiline':False]['text':' true: the number of specified arguments will deserialized to (#all_args -','line_number':220,'multiline':False]['text':' #default_args). false: the number of specified arguments will deserialized to','line_number':221,'multiline':False]['text':' (#all_args).','line_number':222,'multiline':False]['text':' TODO remove these switches once interface call is rolled out.','line_number':258,'multiline':False]['text':' namespace jit','line_number':279,'multiline':False]['text':' namespace torch','line_number':280,'multiline':False]