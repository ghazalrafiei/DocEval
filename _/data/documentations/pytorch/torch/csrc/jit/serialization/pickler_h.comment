['text':' See Python's pickletools.py for a detailed description of each of these codes','line_number':20,'multiline':False]['text':' NB: Avoid using UNICODE as it is a macro in the Windows API','line_number':40,'multiline':False]['text':' Protocol 2','line_number':65,'multiline':False]['text':' Protocol 3 (Python 3.x)','line_number':79,'multiline':False]['text':' Protocol 4','line_number':83,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':98,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':130,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-exception-escape)','line_number':144,'multiline':False]['text':' Push protocol onto the stack','line_number':147,'multiline':False]['text':' Push STOP PickleOpCode onto the stack','line_number':150,'multiline':False]['text':' unmemoized version','line_number':187,'multiline':False]['text':' raw string data is appended directly to the byte stream','line_number':197,'multiline':False]['text':' Add a BINPUT op and return the memoization id used','line_number':201,'multiline':False]['text':' Caller checks that bufferPos_ > 0','line_number':206,'multiline':False]['text':' These convert values to bytes and add them to the stack (NB: since T is to','line_number':218,'multiline':False]['text':' the left of a '::', its type cannot be deduced by the compiler so one must','line_number':219,'multiline':False]['text':' explicitly instantiate the template, i.e. push<int>(int) works, push(int)','line_number':220,'multiline':False]['text':' does not)','line_number':221,'multiline':False]['text':' Stream to write binary data to','line_number':234,'multiline':False]['text':' Code shouldn't call writer_ directly without first flush()ing.','line_number':235,'multiline':False]['text':' Buffer to avoid calling a writer_ on a per-byte basis.','line_number':238,'multiline':False]['text':' Stack of opcodes/data','line_number':242,'multiline':False]['text':' External table of tensors to serialize. If this is missing, then tensors','line_number':245,'multiline':False]['text':' are serialized directly into the pickle','line_number':246,'multiline':False]['text':' TODO: only use this if necessary (add a pass to find all shared ivalues,','line_number':249,'multiline':False]['text':' and only memoize those)','line_number':250,'multiline':False]['text':' Memoization of IValues that have been written (index in table is used for','line_number':253,'multiline':False]['text':' BINPUT opcodes) to enable shared references','line_number':254,'multiline':False]['text':' because we de-dup ivalues based on their raw pointer address in the above','line_number':257,'multiline':False]['text':' map we need to keep all the memoized values alive during the pickle.','line_number':258,'multiline':False]['text':' Otherwise, it is possible that a raw address gets reused for another','line_number':259,'multiline':False]['text':' object, and we will alias it to the old object at that address.','line_number':260,'multiline':False]['text':' List of all the types that it wrote, inspect from the IValues it wrote.','line_number':265,'multiline':False]['text':' Function to grab next id_name for tensor storage, function is responsible','line_number':268,'multiline':False]['text':' for returning unique ids','line_number':269,'multiline':False]['text':' List of tensor storages to serialize in the same binary as the pickle data','line_number':272,'multiline':False]['text':' similar to ivalues, they are memoized using BINPUT','line_number':273,'multiline':False]['text':' when true, List and Dict objects will be wrapped in a','line_number':280,'multiline':False]['text':' torch.jit._pickle.restore_type_tag call to correctly set the dynamic','line_number':281,'multiline':False]['text':' TorchScript type for the object. When true the thing unpickling must have','line_number':282,'multiline':False]['text':' torch installed.','line_number':283,'multiline':False]['text':' returns a (tensor, record_size) for a tensor, converting it to a CPU tensor','line_number':287,'multiline':False]['text':' if it was CUDA and to_cpu is True.','line_number':288,'multiline':False]['text':' return the value of the tensor's storage pointer','line_number':292,'multiline':False]['text':' if the cls has __getstate__/__setstate__','line_number':295,'multiline':False]['text':' assert they have the right schema and return true,','line_number':296,'multiline':False]['text':' otherwise return false','line_number':297,'multiline':False]['text':' Declare BackendMeta serialization and deserialization function pointer types.','line_number':300,'multiline':False]['text':' A allowlist of device type, currently available is PrivateUse1','line_number':304,'multiline':False]['text':' Dynamically obtain serialization function pairs','line_number':311,'multiline':False]['text':' that require the corresponding backend.','line_number':312,'multiline':False]['text':' The array to save function pointer for BackendMeta serialization.','line_number':317,'multiline':False]['text':' key is the DeviceType, value is std::pair obj.','line_number':318,'multiline':False]['text':' value.first represent get function and value.seconde represent set function','line_number':319,'multiline':False]['text':' Register function pointer of Tensor BackendMetadata for serialization.','line_number':327,'multiline':False]['text':' allowlist verification','line_number':332,'multiline':False]['text':' Only if the devicetype is in the allowlist,','line_number':333,'multiline':False]['text':' we allow the serialization extension to be registered for backendmeta data.','line_number':334,'multiline':False]['text':' Register function pointer','line_number':342,'multiline':False]['text':' Return a map of Tensor Metadata which including BackendMetaData for','line_number':355,'multiline':False]['text':' serialization. For now, it only takes care of `conj` and `neg` bit.','line_number':356,'multiline':False]['text':' We don't support serializing `ZeroTensor` as it is not public','line_number':359,'multiline':False]['text':' facing yet.','line_number':360,'multiline':False]['text':' Only add meta-data if the value is not default.','line_number':367,'multiline':False]['text':' Only add BackendMetaData for custom backend if the function pointer is','line_number':374,'multiline':False]['text':' registered.','line_number':375,'multiline':False]['text':' Pass the tensor and metadata map references as parameters to the custom','line_number':379,'multiline':False]['text':' serialization function.','line_number':380,'multiline':False]['text':' set Tensor Metadata based on the map.','line_number':387,'multiline':False]['text':' Refer: getTensorMetadata','line_number':388,'multiline':False]['text':' Only set BackendMetaData for custom backend if the function pointer is','line_number':403,'multiline':False]['text':' registered.','line_number':404,'multiline':False]['text':' Pass the tensor and metadata map references as parameters to the custom','line_number':408,'multiline':False]['text':' deserialization function.','line_number':409,'multiline':False]['text':' set Tensor metadata based on the map.','line_number':415,'multiline':False]['text':' NOTE: This overload is required by unpickler.cpp','line_number':416,'multiline':False]['text':' namespace jit','line_number':428,'multiline':False]['text':' namespace torch','line_number':429,'multiline':False]