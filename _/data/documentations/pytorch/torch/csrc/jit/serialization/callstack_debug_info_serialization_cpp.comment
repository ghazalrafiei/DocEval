['text':' namespace','line_number':10,'multiline':False]['text':' Inlined callstack pointer is serialized as tuple of 4 elements','line_number':22,'multiline':False]['text':' {IValue(module_instance_info), source_range_tag, IValue(InlinedCallStack),','line_number':23,'multiline':False]['text':' function name} Note function name is serialized separately because Function','line_number':24,'multiline':False]['text':' is only in memory structure. It gets constructed by JIT from serialized','line_number':25,'multiline':False]['text':' Code at runtime. As such even InlinedCallStack get constructed by JIT at','line_number':26,'multiline':False]['text':' runtime during graph inlining. However, we introduce','line_number':27,'multiline':False]['text':' serialization/deserialization of it in order to generate callstack debug','line_number':28,'multiline':False]['text':' information, _when_ equivalent InlinedCallStack cannot be constructed at','line_number':29,'multiline':False]['text':' runtime. For example, in lite interpreter or delegated backend.','line_number':30,'multiline':False]['text':' Module instance info is serialized as','line_number':77,'multiline':False]['text':' {type name, instance name}','line_number':78,'multiline':False]['text':'
     * Debug handles and debug info (source range + inlinded callstack)
     * are serialized as a tuple of 3 elements
     * {debug_handle, source_range_tag, serialized_callstack}
     ','line_number':91,'multiline':True]['text':' {IValue(module_instance_info), source_range_tag, IValue(InlinedCallStack),','line_number':137,'multiline':False]['text':' function name}','line_number':138,'multiline':False]['text':' Invoking move constructor','line_number':164,'multiline':False]['text':' It is not clear if copy-ellision can happen since','line_number':165,'multiline':False]['text':' cs_ptr is copied into map above.','line_number':166,'multiline':False]['text':' This is to help avoid ref count update','line_number':167,'multiline':False]['text':' type_name might be empty string ""','line_number':187,'multiline':False]['text':' In that case type_ptr should be just nullptr','line_number':188,'multiline':False]['text':' We may have lost type information. For example in lowered backends','line_number':191,'multiline':False]['text':' original class type has no relevance.','line_number':192,'multiline':False]['text':' However, to correlate ops to their original modules','line_number':193,'multiline':False]['text':' we saved both type name and instance name.','line_number':194,'multiline':False]['text':' In such cases, when module is absorbed by lowered backend','line_number':195,'multiline':False]['text':' we augment instance name with type name instead of losing it.','line_number':196,'multiline':False]['text':' namespace torch::jit','line_number':249,'multiline':False]