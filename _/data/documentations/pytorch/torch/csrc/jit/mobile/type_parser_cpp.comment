['text':' Torchbind custom class always starts with the follow prefix, so use it as','line_number':17,'multiline':False]['text':' an identifier for torchbind custom class type','line_number':18,'multiline':False]['text':' namespace','line_number':30,'multiline':False]['text':' For the Python string list parsing, the order of the Python string matters.','line_number':40,'multiline':False]['text':' In bytecode, the order of the type list correspondings to the order of','line_number':41,'multiline':False]['text':' instruction. In nested type, the lowest level type will be at the beginning','line_number':42,'multiline':False]['text':' of the type list. It is possible to parse it without worrying about','line_number':43,'multiline':False]['text':' ordering, but it also introduces 1) extra cost to process nested type to','line_number':44,'multiline':False]['text':' the correct order 2) lost the benifit that the instruction order is likely','line_number':45,'multiline':False]['text':' problematic if type list parsing fails.','line_number':46,'multiline':False]['text':' The list of non-simple types supported by current parser.','line_number':73,'multiline':False]['text':' The list of custom types supported by current parser.','line_number':80,'multiline':False]['text':' Given a PyThon str, get all contained types. It's usually used for','line_number':87,'multiline':False]['text':' compatibility check between model and runtime. For example:','line_number':88,'multiline':False]['text':' PyThon string: "Dict[int, Tuple[Tensor, Tensor, Tensor]]"','line_number':89,'multiline':False]['text':' contained type is: [Dict, int, Tuple, Tensor]','line_number':90,'multiline':False]['text':' torch bind class starts with __torch__.torch.classes','line_number':147,'multiline':False]['text':' other class starts with __torch__ following by custom names','line_number':150,'multiline':False]['text':' TODO Union types are not supported on embedded runtime, and we need to','line_number':154,'multiline':False]['text':' generate compiler errors for users scripting UnionTypes. Right now','line_number':155,'multiline':False]['text':' for preserving backward compatibility we have to return a nullptr since','line_number':156,'multiline':False]['text':' it does not get involved in type reflection.','line_number':157,'multiline':False]['text':' NamedTuple custom type will be following structure:','line_number':170,'multiline':False]['text':' "qualified_named[','line_number':171,'multiline':False]['text':'   NamedTuple, [','line_number':172,'multiline':False]['text':'       [filed_name_1, field_type_1],','line_number':173,'multiline':False]['text':'       [filed_name_2, field_type_2]','line_number':174,'multiline':False]['text':'   ]','line_number':175,'multiline':False]['text':' ]"','line_number':176,'multiline':False]['text':'  Example NamedTuple type:','line_number':177,'multiline':False]['text':'  "__torch__.base_models.sparse_nn.pytorch_preproc_types.PreprocOutputType[','line_number':178,'multiline':False]['text':'     NamedTuple, [','line_number':179,'multiline':False]['text':'         [float_features, Tensor],','line_number':180,'multiline':False]['text':'         [id_list_features, List[Tensor]],','line_number':181,'multiline':False]['text':'         [label,  Tensor],','line_number':182,'multiline':False]['text':'         [weight, Tensor],','line_number':183,'multiline':False]['text':'         ]','line_number':184,'multiline':False]['text':'     ]"','line_number':185,'multiline':False]['text':' Custom type will be following structure:','line_number':208,'multiline':False]['text':' "qualified_named[','line_number':209,'multiline':False]['text':'   custom_type, [','line_number':210,'multiline':False]['text':'       [filed_name_1, field_type_1],','line_number':211,'multiline':False]['text':'       [filed_name_2, field_type_2]','line_number':212,'multiline':False]['text':'   ]','line_number':213,'multiline':False]['text':' ]"','line_number':214,'multiline':False]['text':' After cur() moves to the next token after qualified name, if it's "[", it','line_number':225,'multiline':False]['text':' means this custom type follow by it's class definition. Otherwise, it's a','line_number':226,'multiline':False]['text':' barebone qualified name and needs to look up str_type_ptr_map_ to find','line_number':227,'multiline':False]['text':' the typeptr.','line_number':228,'multiline':False]['text':' Currently only supports NamedTuple custom type, if more types need to','line_number':232,'multiline':False]['text':' be supported, extend them here.','line_number':233,'multiline':False]['text':' When the type definition can't be found, likely two reasons','line_number':246,'multiline':False]['text':' 1. The type list in bytecode.pkl is not in the correct order','line_number':247,'multiline':False]['text':' 2. This custom type definition doesn't exist in bytecode.pkl type','line_number':248,'multiline':False]['text':' table','line_number':249,'multiline':False]['text':' c10::string_view::operator== calls memcmp to compare against the target','line_number':288,'multiline':False]['text':' string; we can do better if we specialize for a single character.','line_number':289,'multiline':False]['text':' skip white spaces','line_number':304,'multiline':False]['text':' A word','line_number':310,'multiline':False]['text':' namespace c10','line_number':357,'multiline':False]