['text':' namespace','line_number':46,'multiline':False]['text':' If no valid debug handle found then just log pc.','line_number':91,'multiline':False]['text':' This is possible when we did not save debug handles','line_number':92,'multiline':False]['text':' std::cout << "RUNNING " << pc << " " << code.instructions_[pc];','line_number':99,'multiline':False]['text':' if (inst.op == OP) {','line_number':100,'multiline':False]['text':'   std::cout << ", " << code.op_names_[inst.X].name;','line_number':101,'multiline':False]['text':'   if (!code.op_names_[inst.X].overload_name.empty()) {','line_number':102,'multiline':False]['text':'     std::cout << "." << code.op_names_[inst.X].overload_name;','line_number':103,'multiline':False]['text':'   }','line_number':104,'multiline':False]['text':' }','line_number':105,'multiline':False]['text':' std::cout << std::endl;','line_number':106,'multiline':False]['text':' TODO(iliacher): remove the workaround after RecordFunction is in','line_number':108,'multiline':False]['text':' Dispatcher','line_number':109,'multiline':False]['text':' Check with iliacher if has been done.','line_number':110,'multiline':False]['text':' Plus this is not safe as if you throw exception record function will be','line_number':111,'multiline':False]['text':' left enabled. That is a TODO','line_number':112,'multiline':False]['text':' NOTE: this recordFunction logic takes up ~2-3% of cpu cycles in some','line_number':113,'multiline':False]['text':' workflows. do we need it and/or can we opt-out of','line_number':114,'multiline':False]['text':' isRecordFunctionEnabled with a macro? if we delete it, things appear to','line_number':115,'multiline':False]['text':' work just fine.','line_number':116,'multiline':False]['text':' enable only for the RecordFunction','line_number':119,'multiline':False]['text':' Mobile only: since the number of slots is not known, resize the','line_number':214,'multiline':False]['text':' numAttributes before setSlot.','line_number':215,'multiline':False]['text':' stack: iteration_count, max_iter, cond, loop_carried_deps...','line_number':231,'multiline':False]['text':' iteration_count, max_iter, cond','line_number':245,'multiline':False]['text':' Note: Please don't move the pop(stack) code below into the','line_number':347,'multiline':False]['text':' TORCH_WARN macro since TORCH_WARN fails to evaluate its arguments','line_number':348,'multiline':False]['text':' when STRIP_ERROR_MESSAGES is defined (which happens for production','line_number':349,'multiline':False]['text':' mobile builds). This will cause the stack to be in an inconsistent','line_number':350,'multiline':False]['text':' state. It has previously resulted in a SEV (S22350).','line_number':351,'multiline':False]['text':' This exception must be caught first as it derived from c10::Error','line_number':364,'multiline':False]['text':' Reason for catching and rethrowing the error is so that we can','line_number':369,'multiline':False]['text':' set the exception pc that is queried later','line_number':370,'multiline':False]['text':'  for (auto val : stack) {','line_number':377,'multiline':False]['text':'    if (val.isTensor()) {','line_number':378,'multiline':False]['text':'      std::cout << val.toTensor().sizes() << std::endl;','line_number':379,'multiline':False]['text':'    } else {','line_number':380,'multiline':False]['text':'      std::cout << val << std::endl;','line_number':381,'multiline':False]['text':'    }','line_number':382,'multiline':False]['text':'  }','line_number':383,'multiline':False]['text':' namespace mobile','line_number':392,'multiline':False]['text':' namespace jit','line_number':393,'multiline':False]['text':' namespace torch','line_number':394,'multiline':False]