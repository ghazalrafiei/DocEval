['text':' This class determines whether a type is mutable, and, if so, it maps','line_number':24,'multiline':False]['text':' the type to its "mutable equivalent" (see definition in','line_number':25,'multiline':False]['text':' `mapTypeToAliasTypeSet`). It uses a cache of TypePtrs to speed up these','line_number':26,'multiline':False]['text':' type lookups','line_number':27,'multiline':False]['text':' Map any mutable type to a type such that all other types which the','line_number':34,'multiline':False]['text':' mutable type can alias will be mapped to the same type. For','line_number':35,'multiline':False]['text':' example, calling this method on `Optional[List[int]]` should be','line_number':36,'multiline':False]['text':' the same as calling this method on `List[int]`.','line_number':37,'multiline':False]['text':'','line_number':38,'multiline':False]['text':' Rules:','line_number':39,'multiline':False]['text':'   - If the type is not mutable, return `nullopt`','line_number':40,'multiline':False]['text':'   - If the type is a `Tuple`, that means that it's an immutable','line_number':41,'multiline':False]['text':'     object that can itself contain mutable objects. We want to make','line_number':42,'multiline':False]['text':'     sure that the mutable objects are correctly aliased, so we','line_number':43,'multiline':False]['text':'     remove the immutable objects. (For example,','line_number':44,'multiline':False]['text':'     `Tuple[int, Tensor]` would become `Tuple[Tensor]`, while','line_number':45,'multiline':False]['text':'     `Tuple[int, str]` would be returned as `nullopt`.) This is a','line_number':46,'multiline':False]['text':'     convenience that makes it easy to check if the `Tuple`','line_number':47,'multiline':False]['text':'     contains only immutable objects, though it's not technically','line_number':48,'multiline':False]['text':'     necessary','line_number':49,'multiline':False]['text':'   - For any Tensor type (including Tensor types that are part of','line_number':50,'multiline':False]['text':'     a larger container, e.g. `List[Tensor]`), return the','line_number':51,'multiline':False]['text':'     "unshaped" version of that Tensor. An "unshaped" Tensor is a','line_number':52,'multiline':False]['text':'     Tensor with shape information removed. For example, a Tensor','line_number':53,'multiline':False]['text':'     of dimension 4 would map to the same type as a Tensor of','line_number':54,'multiline':False]['text':'     dimension 1. This allows us to treat all subclasses of Tensor','line_number':55,'multiline':False]['text':'     as a single, homogenous "Tensor" type.','line_number':56,'multiline':False]['text':' TODO: Look up cached contained types. this is kind of tricky','line_number':91,'multiline':False]['text':' because a `List[Optional[T]]` should still be','line_number':92,'multiline':False]['text':' `List[Optional[Unshaped(T)]]`, but','line_number':93,'multiline':False]['text':' `mapTypeToAliasTypeSet(Optional[T])` should be `T`','line_number':94,'multiline':False]['text':' Check common cases to avoid recursively constructing type in','line_number':159,'multiline':False]['text':' `mapTypeToAliasTypeSetPtrImpl`','line_number':160,'multiline':False]['text':' namespace','line_number':174,'multiline':False]['text':' Static `isMutableType` does not use cache of type -> mutable type equivalent','line_number':176,'multiline':False]['text':' Make use of type -> mutable cache','line_number':185,'multiline':False]['text':' Structure used during analysis to keep track of all writes at a high','line_number':202,'multiline':False]['text':' level. When the analysis is completed, this will be used to construct','line_number':203,'multiline':False]['text':' a more efficient WriteIndex','line_number':204,'multiline':False]['text':' to make further access a hard error','line_number':232,'multiline':False]['text':' Now we build up the various write indices based on information in the write','line_number':239,'multiline':False]['text':' registry that we populated during analysis','line_number':240,'multiline':False]['text':' Initialize the write index','line_number':242,'multiline':False]['text':' to make operator[] less ugly','line_number':244,'multiline':False]['text':' Build the write index','line_number':246,'multiline':False]['text':' Now that we've built the write index, we can null out the WriteRegistry to','line_number':278,'multiline':False]['text':' make future access an error. In this way we prevent the index from getting','line_number':279,'multiline':False]['text':' out of sync (since we have no way of registering new writes)','line_number':280,'multiline':False]['text':' Initialize the write cache','line_number':283,'multiline':False]['text':' Does `n` write to an alias of one of the values in `vs`?','line_number':346,'multiline':False]['text':' Add all memory locations this element may alias and their contained','line_number':379,'multiline':False]['text':' elements','line_number':380,'multiline':False]['text':' Not the most efficient way, but given the fact there are','line_number':400,'multiline':False]['text':' not too many types and even fewer of them will end up in','line_number':401,'multiline':False]['text':' `wildcardIndex_`, we should be fine with a linear search','line_number':402,'multiline':False]['text':' each time we hit a Wildcard leaf','line_number':403,'multiline':False]['text':' Local helper to generate a graphviz-friendly name encoding','line_number':492,'multiline':False]['text':' See also AliasDb::getElementName()','line_number':493,'multiline':False]['text':' Include the textual representation for reference','line_number':517,'multiline':False]['text':' Returns true if analysis was run using','line_number':565,'multiline':False]['text':' the registered analyzer.','line_number':566,'multiline':False]['text':' The basic strategy is:','line_number':577,'multiline':False]['text':'   1. Retrieve alias information for every input.','line_number':578,'multiline':False]['text':'   2. Use the node's schema's alias annotations to propgagate alias/write','line_number':579,'multiline':False]['text':'      information to the outputs. For unschematized nodes, a special analyzer','line_number':580,'multiline':False]['text':'      will have to be handwritten.','line_number':581,'multiline':False]['text':' These nodes are not schematized, so we need to handle them specially','line_number':625,'multiline':False]['text':' TODO: think more about TensorExpr alias correctness','line_number':662,'multiline':False]['text':' this should never be seen outside of initial compilation','line_number':676,'multiline':False]['text':' but because of some dependencies with closure invoking alias','line_number':677,'multiline':False]['text':' db needs to be handled here','line_number':678,'multiline':False]['text':' TODO: this can be improved with summarizes of what the function does','line_number':732,'multiline':False]['text':' for now we assume the worst','line_number':733,'multiline':False]['text':' this is an unoptimized path - we copy the subgraph for each function','line_number':741,'multiline':False]['text':' call past the first - so we do not generally enable the recursive','line_number':742,'multiline':False]['text':' analysis. use cases for fine-grained alias analysis without inlining','line_number':743,'multiline':False]['text':' are very uncommon','line_number':744,'multiline':False]['text':' alias analysis will use Value* as mappings for information,','line_number':746,'multiline':False]['text':' so for each analysis of a particular function call we need a new graph','line_number':747,'multiline':False]['text':' for all copies made, store them for duration of analysis so we do not','line_number':748,'multiline':False]['text':' run into lifetime issues with the graph','line_number':749,'multiline':False]['text':' TODO: this can be improved with summarizes of what the function does','line_number':764,'multiline':False]['text':' for now we assume the worst','line_number':765,'multiline':False]['text':' NB: update safeToChangeAliasingRelationship if changed','line_number':766,'multiline':False]['text':' These ops do nothing','line_number':770,'multiline':False]['text':' TODO There is nothing in the system that relies on aten:: and prim::','line_number':787,'multiline':False]['text':' ops using AliasAnalysisKind::FROM_SCHEMA or','line_number':788,'multiline':False]['text':' AliasAnalysisKind::INTERNAL_SPECIAL_CASE, but this is the intended','line_number':789,'multiline':False]['text':' behavior for all current ops and a good error check. We can consider','line_number':790,'multiline':False]['text':' lifting this constraint later if we have a use case for it.','line_number':791,'multiline':False]['text':' TODO A previous implementation of alias analysis always accessed','line_number':803,'multiline':False]['text':' node->schema , which cause the schema caches in the Node class to be','line_number':804,'multiline':False]['text':' filled for the full graph. Unfortunately, our JIT passes started relying','line_number':805,'multiline':False]['text':' on that, so we need to keep doing this. Details: in','line_number':806,'multiline':False]['text':' caffe2/torch/onnx/utils.py, _jit_pass_onnx is called on an invalid JIT','line_number':807,'multiline':False]['text':' graph because we called _jit_pass_erase_number_types right before and','line_number':808,'multiline':False]['text':' ints are now Tensors instead. So if _jit_pass_onnx tries to look up','line_number':809,'multiline':False]['text':' operator schemas, it will crash. However, _jit_pass_constant_propagation,','line_number':810,'multiline':False]['text':' which is called before it, runs alias analysis and prefills the schema','line_number':811,'multiline':False]['text':' cache in the all Node instances so that _jit_pass_onnx doesn't look up','line_number':812,'multiline':False]['text':' operators to get the schemas anymore. We should fix this.','line_number':813,'multiline':False]['text':' fill the schema cache in the Node class','line_number':814,'multiline':False]['text':' Bind the schema's "formal" alias annotation to the actual values those','line_number':824,'multiline':False]['text':' schema arguments represent','line_number':825,'multiline':False]['text':' Skip if there's no alias annotation','line_number':831,'multiline':False]['text':' If this type cannot alias, continue. Can occur with a VarType schema','line_number':836,'multiline':False]['text':' Do sanity checks on the alias annotation','line_number':841,'multiline':False]['text':' This is a special case where we have alias info before [] but not after,','line_number':848,'multiline':False]['text':' such as `Tensor(a!)[]`','line_number':849,'multiline':False]['text':' Use the first containedType in alias info.','line_number':851,'multiline':False]['text':' skip if we've already bound this alias','line_number':857,'multiline':False]['text':' Bind the formal to the actual','line_number':862,'multiline':False]['text':' Record writes','line_number':865,'multiline':False]['text':' Now deal with sets after the '->'','line_number':870,'multiline':False]['text':' We don't understand anything else in the after yet, so assert there's','line_number':878,'multiline':False]['text':' been no change.','line_number':879,'multiline':False]['text':' Use the formal-actual mapping to give aliases to the outputs','line_number':884,'multiline':False]['text':' This is a fresh tensor','line_number':889,'multiline':False]['text':' If this type cannot alias, continue. Can occur with a VarType schema','line_number':894,'multiline':False]['text':' Use the first containedType in alias info.','line_number':904,'multiline':False]['text':' If all the alias annotation that we encounter weren't in the inputs:','line_number':924,'multiline':False]['text':'   e.g. foo(Tensor(a) self) -> Tensor(b)','line_number':925,'multiline':False]['text':'   or foo(Tensor(a) self) -> Tensor(b|c)','line_number':926,'multiline':False]['text':' Otherwise it is the form of a|fresh, which we can ignore, taking the','line_number':927,'multiline':False]['text':' conservative assumption that the output must alias `a`, e.g','line_number':928,'multiline':False]['text':'   aten::cuda(Tensor(a) self) -> Tensor(a|fresh)','line_number':929,'multiline':False]['text':' Record writes','line_number':934,'multiline':False]['text':' Register the fact that `n` writes to `v`.','line_number':941,'multiline':False]['text':' don't need to register a write if the value isn't mutable','line_number':944,'multiline':False]['text':' For if statements, the alias set of an output is the union of the','line_number':955,'multiline':False]['text':' alias sets generated by the if and else block','line_number':956,'multiline':False]['text':' skip max, cond','line_number':975,'multiline':False]['text':' skip trip','line_number':976,'multiline':False]['text':' skip trip','line_number':977,'multiline':False]['text':' Run alias analysis on the loop body, iterating until the block output','line_number':981,'multiline':False]['text':' alias info converges. Copy node input aliases to block input','line_number':982,'multiline':False]['text':' Populate block output alias info by analyzing the body','line_number':985,'multiline':False]['text':' Copy the alias info from the block output to the node output','line_number':988,'multiline':False]['text':' CallFunction nodes have an extra first parameter','line_number':1000,'multiline':False]['text':' Note: the subgraph outputs and node outputs are NOT NECESSARILY the','line_number':1009,'multiline':False]['text':' same length. Autodifferentiation maybe capture additional outputs in the','line_number':1010,'multiline':False]['text':' subgraph block.','line_number':1011,'multiline':False]['text':' For nodes that generate a fresh value from nothing','line_number':1023,'multiline':False]['text':' For nodes that extract values from a composite type. Right now, this just','line_number':1030,'multiline':False]['text':' gives up and creates wildcards for everything.','line_number':1031,'multiline':False]['text':' For torch.chunk(), all returned tensors may alias the input tensor','line_number':1038,'multiline':False]['text':' Give the future that the fork emits a fresh value','line_number':1050,'multiline':False]['text':' the forked subgraph that `wait` is waiting on may write to any of its','line_number':1061,'multiline':False]['text':' inputs. We don't have a reliable way of recovering the fork inputs, so','line_number':1062,'multiline':False]['text':' for safety we just register a write to every wildcard.','line_number':1063,'multiline':False]['text':' the awaitable subgraph that `wait` is waiting on may write to any of its','line_number':1082,'multiline':False]['text':' inputs. We don't have a reliable way of recovering the awaitable inputs, so','line_number':1083,'multiline':False]['text':' for safety we just register a write to every wildcard.','line_number':1084,'multiline':False]['text':' Give the future that the rpc_async emits a fresh value','line_number':1093,'multiline':False]['text':' namespace','line_number':1111,'multiline':False]['text':' custom behavior for batch_norm because (a!)? annotations currently','line_number':1113,'multiline':False]['text':' aren't supported, and because behavior differs depending on the value of','line_number':1114,'multiline':False]['text':' training','line_number':1115,'multiline':False]['text':' we invoking freezing for inference, so we assume training will be folded to','line_number':1117,'multiline':False]['text':' a constant false to avoid needing to invoke freezing multiple times in','line_number':1118,'multiline':False]['text':' order to make batch norm weights constant','line_number':1119,'multiline':False]['text':' custom behavior for instance_norm, because (a!)? annotations currently','line_number':1143,'multiline':False]['text':' aren't supported, and because behavior differs depending on the value of','line_number':1144,'multiline':False]['text':' use_input_stats','line_number':1145,'multiline':False]['text':' SetAttr: writes to the `self` field','line_number':1166,'multiline':False]['text':' Also the value being set must become a wildcard.','line_number':1171,'multiline':False]['text':' Used for anything where we do not have accurate alias summaries','line_number':1176,'multiline':False]['text':' may write to any input and produce wildcards','line_number':1177,'multiline':False]['text':'writeToContained=','line_number':1183,'multiline':True]['text':' only consider aten op uses of lists','line_number':1197,'multiline':False]['text':'
  in the general case, we consider any Value that enters another container as
  entering the heap, and thus aliasing all other heap values of the same type.
  the advantage of this approach are:
  - there are many composite list/container ops that would be tricky to
  schematize if we did something more complicated
  - limits the size of the AliasDb, because a container of size 10 only contains
  1 memory dag element instead of 10
  - we do not need to worry about adding contained elements to the wildcard set
  when a container escapes the graph.
  The downside of this approach is we are unable to handle the common case of a
  list constructed and passed into an aten op. Here, optimize for a set of
  common ops where the output does not alias the list or the list elements
  ','line_number':1202,'multiline':True]['text':' only used in output of graph - no further uses,','line_number':1217,'multiline':False]['text':' so there will be no use of it where the contained element leaks','line_number':1218,'multiline':False]['text':' TODO(T97387453): Cover more ops that do not let escape tuples' elements.','line_number':1246,'multiline':False]['text':' List or dict or tuple construct: create an aliasing element for the actual','line_number':1252,'multiline':False]['text':' container, then mark all inputs as wildcards, since they've gone inside the','line_number':1253,'multiline':False]['text':' container. Then, add the wildcard sets of appropriate type to the contained','line_number':1254,'multiline':False]['text':' elements of the container.','line_number':1255,'multiline':False]['text':' tuples which contain immutable types are immutable','line_number':1262,'multiline':False]['text':' optimization:','line_number':1270,'multiline':False]['text':' if a list is only used once in an aten op, and the op output','line_number':1271,'multiline':False]['text':' doesn't alias the input, then we can add all inputs to the list's','line_number':1272,'multiline':False]['text':' contained elements instead of the wildcard set.','line_number':1273,'multiline':False]['text':' BroadcastingChunk: all inputs are broadcasted, and then individually chunked.','line_number':1295,'multiline':False]['text':' This is an intermediate node used only in the graph fuser.','line_number':1296,'multiline':False]['text':' Each inputs[i] is aliased by exactly `nchunks` distinct output tensors:','line_number':1302,'multiline':False]['text':' inputs[i] produces chunks outputs[i * nchunks + k] for k in [0..nchunks)','line_number':1303,'multiline':False]['text':' these are values which can point to aliasing types in the graph,','line_number':1312,'multiline':False]['text':' as with a None value pointing to an optional if node output,','line_number':1313,'multiline':False]['text':' but will never alias themselves','line_number':1314,'multiline':False]['text':' Register the fact that `from` is a pointer to `to`','line_number':1318,'multiline':False]['text':' if either value is guaranteed to be non-aliasing, we do not need to','line_number':1321,'multiline':False]['text':' connect the two elements. however, it is invariant that aliasing types','line_number':1322,'multiline':False]['text':' that are not wildcards have a memory dag element, so we create one if','line_number':1323,'multiline':False]['text':' needed','line_number':1324,'multiline':False]['text':' The contained types of immutable type containers (`Optional`,','line_number':1330,'multiline':False]['text':' `Tuple`, `Future`, and `Union`) are unified, so these types can be','line_number':1331,'multiline':False]['text':' mutable or immutable and point to a type which is mutable or','line_number':1332,'multiline':False]['text':' immutable. `Any` is mutable but can point to an immutable type','line_number':1333,'multiline':False]['text':' through refinement','line_number':1334,'multiline':False]['text':' both immutable','line_number':1338,'multiline':False]['text':' At this point, we are dealing with two mutable types','line_number':1346,'multiline':False]['text':' Record all memory locations from group `a`','line_number':1379,'multiline':False]['text':' If any of group `b`s memory locations overlap, return true.','line_number':1388,'multiline':False]['text':' No overlap, so group `a` and `b` do not share a memory location','line_number':1397,'multiline':False]['text':' Make each value in the `from` list point to its partner in the `to` list','line_number':1436,'multiline':False]['text':' Should only be called from create_functional_graphs.','line_number':1444,'multiline':False]['text':' The asserts are to guard against unintentional use.','line_number':1445,'multiline':False]['text':' FIXME refactor aliasdb construction to be more robust to mutation so this','line_number':1446,'multiline':False]['text':' hack isn't necessary.','line_number':1447,'multiline':False]['text':' Inside a loop, we may have given a fresh alias to this value already, so','line_number':1463,'multiline':False]['text':' skip','line_number':1464,'multiline':False]['text':'dryRun=','line_number':1522,'multiline':True]['text':'dryRun=','line_number':1526,'multiline':True]['text':' We have to distinguish the move side (instead of just moving after','line_number':1530,'multiline':False]['text':' n->prev()). Consider the following example:','line_number':1531,'multiline':False]['text':' If the dependency graph looks like','line_number':1532,'multiline':False]['text':'   n -> movePoint -> o','line_number':1533,'multiline':False]['text':' then moveBefore(o) will end up with','line_number':1534,'multiline':False]['text':'   n, o, movePoint','line_number':1535,'multiline':False]['text':' but moveAfter(n) will return false.','line_number':1536,'multiline':False]['text':'dryRun=','line_number':1537,'multiline':True]['text':'dryRun=','line_number':1541,'multiline':True]['text':' Correctness conditions:','line_number':1555,'multiline':False]['text':' no values in either set can have writers, and values in both sets','line_number':1556,'multiline':False]['text':' cannot escape the current graph scope. Values can escape the current scope','line_number':1557,'multiline':False]['text':' by aliasing a graph output or input, or by aliasing the wildcard set.','line_number':1558,'multiline':False]['text':' Helper for topologically-safe node moves. See `tryMove()` for details.','line_number':1569,'multiline':False]['text':' Add `n` to the working set','line_number':1581,'multiline':False]['text':' Does the working set depend on `n`?','line_number':1604,'multiline':False]['text':' Check that `n` does not write to anything used by the working set','line_number':1627,'multiline':False]['text':' Check that the working set doesn't write to anything that `n` uses.','line_number':1636,'multiline':False]['text':' Does the working set produce any values consumed by `n`?','line_number':1647,'multiline':False]['text':' This equivalent to asking: does the total use-set of all the nodes in the','line_number':1649,'multiline':False]['text':' working set include `n`?','line_number':1650,'multiline':False]['text':' Does the working set consume any values produced by `n`?','line_number':1657,'multiline':False]['text':' Get all users of outputs of `n`, in the same block as `n`.','line_number':1669,'multiline':False]['text':' This means if there is an `if` node that uses an output of `n` in some','line_number':1670,'multiline':False]['text':' inner sub-block, we will consider the whole `if` node a user of `n`.','line_number':1671,'multiline':False]['text':' Traverse `target`'s blockchain upward until we find a node that shares a','line_number':1684,'multiline':False]['text':' block with `n`.','line_number':1685,'multiline':False]['text':'','line_number':1686,'multiline':False]['text':' If one can't be found (say, because `n` is an inner block and target is','line_number':1687,'multiline':False]['text':' outside), then return nullptr. Since we can only reorder nodes within a','line_number':1688,'multiline':False]['text':' block, `target` would be irrelevant.','line_number':1689,'multiline':False]['text':' This user is in a sub-block. Traverse the blockchain upward until','line_number':1695,'multiline':False]['text':' we arrive at a node that shares a block with `this`','line_number':1696,'multiline':False]['text':' Extra data structure for nodes for faster look up','line_number':1710,'multiline':False]['text':' Since the tryMove method is used a lot, we want to','line_number':1711,'multiline':False]['text':' make it as fast as possible.','line_number':1712,'multiline':False]['text':' Mover dependencies. We track these separately since we may erase the mover','line_number':1715,'multiline':False]['text':' from the working set.','line_number':1716,'multiline':False]['text':' users => # of working set nodes it uses','line_number':1722,'multiline':False]['text':' Values written to by the working set => number of nodes writing to value','line_number':1724,'multiline':False]['text':' Try to move `toMove` before/after `movePoint` while preserving value','line_number':1729,'multiline':False]['text':' dependencies. Returns false iff such a move could not be made.','line_number':1730,'multiline':False]['text':'','line_number':1731,'multiline':False]['text':' If `dryRun` is set, don't actually execute the move, just check if the move','line_number':1732,'multiline':False]['text':' is possible','line_number':1733,'multiline':False]['text':'','line_number':1734,'multiline':False]['text':' The basic approach is: have a "working set" that we are moving forward, one','line_number':1735,'multiline':False]['text':' node at a time. When we can't move past a node (because it depends on the','line_number':1736,'multiline':False]['text':' working set), then add it to the working set and keep moving until we hit','line_number':1737,'multiline':False]['text':' `moveAfter`.','line_number':1738,'multiline':False]['text':' 1. Move from `this` toward movePoint, building up the working set of','line_number':1751,'multiline':False]['text':' dependencies','line_number':1752,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1755,'multiline':False]['text':' it is never valid to move reorder a node with side effects','line_number':1773,'multiline':False]['text':' Move forward one node at a time','line_number':1779,'multiline':False]['text':' never valid to reorder around a node with side effects','line_number':1781,'multiline':False]['text':' If we can't move past this node, add it to the working set','line_number':1787,'multiline':False]['text':' 2. Decide whether we can move it all to `movePoint`.','line_number':1793,'multiline':False]['text':' Say we are moving directly before movePoint and `toMove` starts before','line_number':1795,'multiline':False]['text':' movePoint in the graph. The move looks like','line_number':1796,'multiline':False]['text':'','line_number':1797,'multiline':False]['text':'  `toMove`            `toMove`         |','line_number':1798,'multiline':False]['text':'  <dependencies>  ->  `movePoint`      | `toMove` and deps are split','line_number':1799,'multiline':False]['text':'  `movePoint`         <dependencies>   |','line_number':1800,'multiline':False]['text':'','line_number':1801,'multiline':False]['text':' Contrast with the case where `toMove` starts AFTER movePoint:','line_number':1802,'multiline':False]['text':'','line_number':1803,'multiline':False]['text':'  `movePoint`           <dependencies>   |','line_number':1804,'multiline':False]['text':'  <dependencies>  ->    `toMove`         | `toMove` and deps are together','line_number':1805,'multiline':False]['text':'  `toMove`              `movePoint`      |','line_number':1806,'multiline':False]['text':'','line_number':1807,'multiline':False]['text':' In the first case, we need to split `this` off from its dependencies, so we','line_number':1808,'multiline':False]['text':' can move the dependencies below `movePoint` and keep `toMove` above.','line_number':1809,'multiline':False]['text':' remove `this` from dependencies to be moved past `movePoint`','line_number':1815,'multiline':False]['text':' Check if we can move the working set past the move point','line_number':1819,'multiline':False]['text':' if we can't, then there are intermediate dependencies between the','line_number':1821,'multiline':False]['text':' `this` and `movePoint`, so we can't do the move','line_number':1822,'multiline':False]['text':' 3. Execute the move','line_number':1830,'multiline':False]['text':' Move `toMove`','line_number':1833,'multiline':False]['text':' Then move all of its dependencies on the other side of `movePoint`','line_number':1836,'multiline':False]['text':' Just append/prepend everything to `movePoint`','line_number':1844,'multiline':False]['text':' Helper function so we can generalize `tryMove`','line_number':1855,'multiline':False]['text':' Are any of these memoryLocs a wildcard element?','line_number':1873,'multiline':False]['text':' There were no wildcards of this type, so return false.','line_number':1887,'multiline':False]['text':' Search the wildcard index for an element that corresponds to the given type.','line_number':1942,'multiline':False]['text':' Const version returns nullptr','line_number':1943,'multiline':False]['text':' Get a <TypePtr, Element*> pair where the TypePtr is this Union','line_number':1951,'multiline':False]['text':' type and the Element is the corresponding Wildcard','line_number':1952,'multiline':False]['text':' Get a <TypePtr, Element*> pair where the TypePtr is the given','line_number':1958,'multiline':False]['text':' type and the Element is the corresponding Wildcard','line_number':1959,'multiline':False]['text':' Register `v` as a wildcard value.','line_number':1968,'multiline':False]['text':' Ensure that we create a corresponding Element for `v` still, as it is an','line_number':1975,'multiline':False]['text':' invariant that all mutable values have an Element','line_number':1976,'multiline':False]['text':' Every mutable value in the system has a corresponding element.','line_number':1995,'multiline':False]['text':' Two checks that we want to add but can't until the mutation API is more','line_number':2010,'multiline':False]['text':' fully developed.','line_number':2011,'multiline':False]['text':' - Every mutable value in the aliasdb belongs to the graph','line_number':2012,'multiline':False]['text':' - All container values have contained elements','line_number':2013,'multiline':False]['text':' namespace torch::jit','line_number':2016,'multiline':False]