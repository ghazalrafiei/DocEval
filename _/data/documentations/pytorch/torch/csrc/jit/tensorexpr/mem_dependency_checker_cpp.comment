['text':' AccessInfo','line_number':58,'multiline':False]['text':' MemDependencyChecker','line_number':255,'multiline':False]['text':'','line_number':256,'multiline':False]['text':' dependsDirectly, dependsIndirectly and friends:','line_number':308,'multiline':False]['text':' TODO exprs can have multiple accesses... we're returning the first but that','line_number':456,'multiline':False]['text':' isn't great. Can't do much here.','line_number':457,'multiline':False]['text':' Node visitors:','line_number':503,'multiline':False]['text':' Create a new AccessInfo for the store.','line_number':515,'multiline':False]['text':' Add a dependency to any accesses that are within the scope of this store','line_number':520,'multiline':False]['text':' (ie. the RHS).','line_number':521,'multiline':False]['text':' This write is open, and will close any open writes that it totally','line_number':530,'multiline':False]['text':' overlaps.','line_number':531,'multiline':False]['text':' Create a temporary scope to hold any loads that occur within the indices of','line_number':538,'multiline':False]['text':' this load.','line_number':539,'multiline':False]['text':' Create a new AccessInfo for the load.','line_number':548,'multiline':False]['text':' If there were loads in the indices, this load depends on them, and merge','line_number':558,'multiline':False]['text':' them in.','line_number':559,'multiline':False]['text':' This is a read, and does not close any accesses - but we need to establish','line_number':573,'multiline':False]['text':' dependencies on accesses in the same scope.','line_number':574,'multiline':False]['text':' Intentionally using operator[], we want it to be created if it does not','line_number':575,'multiline':False]['text':' exist.','line_number':576,'multiline':False]['text':' This check determines if two accesses within a loop are "safe" from loop-self','line_number':582,'multiline':False]['text':' dependence. This function does not consider overlap in bound range, but','line_number':583,'multiline':False]['text':' rather the stride of the bound relative to the loop variable. This is the','line_number':584,'multiline':False]['text':' section of the code which considers iteration order, if allowed.','line_number':585,'multiline':False]['text':' can't be safe on this index if we can't determine stride.','line_number':602,'multiline':False]['text':' If the first access has no stride don't apply safety).','line_number':612,'multiline':False]['text':' if the strides can't have easily inferable distinct offsets, they're not','line_number':619,'multiline':False]['text':' safe.','line_number':620,'multiline':False]['text':' If the loop has a defined execution order (ie. sequential for) then','line_number':625,'multiline':False]['text':' the order of execution can provide safety from overlaps.','line_number':626,'multiline':False]['text':' Specifically if the difference in first access position for any','line_number':627,'multiline':False]['text':' axis is the same sign as the common stride, then they will not','line_number':628,'multiline':False]['text':' overlap.','line_number':629,'multiline':False]['text':' Invert the startDiff so mod works.','line_number':637,'multiline':False]['text':' If both accesses have the same stride, and the difference in start','line_number':643,'multiline':False]['text':' element is smaller than this stride then the entire range is distinct.','line_number':644,'multiline':False]['text':' If the start difference modulo the minimum stride is offset from that','line_number':660,'multiline':False]['text':' stride, then the ranges have distinct strides.','line_number':661,'multiline':False]['text':' If we can consider execution order and the difference in offset is','line_number':666,'multiline':False]['text':' opposite signed to the stride then the read occurs in the past and we can','line_number':667,'multiline':False]['text':' infer safety.','line_number':668,'multiline':False]['text':' Loads inside the For's start and stop expression are special.','line_number':686,'multiline':False]['text':' They exist in the enclosing scope, but accesses within the loop body may','line_number':687,'multiline':False]['text':' depend on them via usage of the loop variable.','line_number':688,'multiline':False]['text':' The way we handle this is to create a new scope so we have an easily','line_number':689,'multiline':False]['text':' accessible list of the accesses within the extents.','line_number':690,'multiline':False]['text':' Ok now we need to determine whether accesses in the loop depend on','line_number':707,'multiline':False]['text':' other loop iterations.','line_number':708,'multiline':False]['text':'','line_number':709,'multiline':False]['text':' This is the real challenge here, it depends on both the fully expanded','line_number':710,'multiline':False]['text':' bounds and the symbolic bounds.','line_number':711,'multiline':False]['text':' The indices must change monotonically to avoid intersection. This is','line_number':713,'multiline':False]['text':' hard to determine, so here's our heuristic I hope it's conservative','line_number':714,'multiline':False]['text':' enough.','line_number':715,'multiline':False]['text':' the size of at least one dependent index must be >= the size of the','line_number':717,'multiline':False]['text':' loop.','line_number':718,'multiline':False]['text':' First step is to infer the stride relative to each dimension of each','line_number':720,'multiline':False]['text':' access, which we do via substituting the loop var with (var+1) into the','line_number':721,'multiline':False]['text':' indices expr.','line_number':722,'multiline':False]['text':' index expr must depend on the loop var in some way to have a stride.','line_number':735,'multiline':False]['text':' If we've previously swapped the start and end of this bound, we','line_number':741,'multiline':False]['text':' should apply the substitution to the reverse of the bounds.','line_number':742,'multiline':False]['text':' If the start < end then swap the order of the bound.','line_number':764,'multiline':False]['text':' If this access uses the loop var, it depends on loads used to compute','line_number':771,'multiline':False]['text':' the loop var.','line_number':772,'multiline':False]['text':' Now we need to update the bounds in openWrites since that is what we use to','line_number':781,'multiline':False]['text':' merge.','line_number':782,'multiline':False]['text':' The bounds may not contain the loop var, but in that case Substitute','line_number':787,'multiline':False]['text':' does nothing.','line_number':788,'multiline':False]['text':' If the start < end then swap the order of the bound.','line_number':795,'multiline':False]['text':' TODO this isn't a scalable way to determine parallelism.','line_number':805,'multiline':False]['text':' Store buffers allocated at this scope.','line_number':809,'multiline':False]['text':' Scanning from the top of the loop, we look for accesses which may depend','line_number':812,'multiline':False]['text':' on a previous or parallel loop iteration.','line_number':813,'multiline':False]['text':' Vars that don't carry outside this scope can't have loop self dependence.','line_number':825,'multiline':False]['text':' Copy the bounds so we can keep track of open bounds internally without','line_number':830,'multiline':False]['text':' affecting the merge into the enclosing scope. The open portion of the','line_number':831,'multiline':False]['text':' bounds may be cut into multiple independent slices.','line_number':832,'multiline':False]['text':' Scan from the bottom of the loop.','line_number':835,'multiline':False]['text':' Whether or not the accesses within the loop are dependent on other','line_number':850,'multiline':False]['text':' iterations depends whether the loop could be parallelized, the','line_number':851,'multiline':False]['text':' difference in their strides and their start offset.','line_number':852,'multiline':False]['text':' It's dependent, link it to other.','line_number':872,'multiline':False]['text':' Otherwise update openBounds.','line_number':880,'multiline':False]['text':' it's a little faster to merge without closing, and since no writes can','line_number':906,'multiline':False]['text':' occur within the start and stop exprs we'll do that.','line_number':907,'multiline':False]['text':' condition is in enclosing scope.','line_number':920,'multiline':False]['text':' Create scopes so the Block visitor doesn't create and merge a new scope.','line_number':926,'multiline':False]['text':' TODO(nickg): this logic isn't quite correct, if a write's Bound range is','line_number':940,'multiline':False]['text':' present in both the true and false branches then we can close overlapping','line_number':941,'multiline':False]['text':' accesses in the enclosing scope. Without that analysis future accesses','line_number':942,'multiline':False]['text':' may be dependent on a write of a common range in all three of the','line_number':943,'multiline':False]['text':' enclosing, true and false scope. This is a false positive so not too bad','line_number':944,'multiline':False]['text':' in the short term, I think.','line_number':945,'multiline':False]['text':' Merge both true and false branches into the parent, but don't close any','line_number':947,'multiline':False]['text':' accesses.','line_number':948,'multiline':False]['text':' Merge the enclosing scope into it's parent.','line_number':952,'multiline':False]['text':' condition is in enclosing scope.','line_number':963,'multiline':False]['text':' Create scopes to hold downstream Loads. It's safe to put nullptr for the','line_number':971,'multiline':False]['text':' Scope's Block as it is only used by Stmts, not Exprs.','line_number':972,'multiline':False]['text':' This doesn't have the same issue as Cond where there could be false','line_number':986,'multiline':False]['text':' positives from the enclosing scope since there are no Exprs which are','line_number':987,'multiline':False]['text':' writes.','line_number':988,'multiline':False]['text':' Merge both true and false branches into the parent, but don't close any','line_number':990,'multiline':False]['text':' accesses.','line_number':991,'multiline':False]['text':' condition is in enclosing scope.','line_number':999,'multiline':False]['text':' Create scopes to hold downstream Loads. It's safe to put nullptr for the','line_number':1008,'multiline':False]['text':' Scope's Block as it is only used by Stmts, not Exprs.','line_number':1009,'multiline':False]['text':' This doesn't have the same issue as Cond where there could be false','line_number':1023,'multiline':False]['text':' positives from the enclosing scope since there are no Exprs which are','line_number':1024,'multiline':False]['text':' writes.','line_number':1025,'multiline':False]['text':' Merge both true and false branches into the parent, but don't close any','line_number':1027,'multiline':False]['text':' accesses.','line_number':1028,'multiline':False]['text':' Inserts accesses for a map of buffers (ie. for inputs and outputs).','line_number':1035,'multiline':False]['text':' handle kernel inputs.','line_number':1061,'multiline':False]['text':' handle kernel outputs.','line_number':1088,'multiline':False]['text':' Don't support AtomicAdd yet, it's a bit more complex since it's both a read','line_number':1111,'multiline':False]['text':' and a write. It's only inserted during Cuda codegen so this should be okay.','line_number':1112,'multiline':False]['text':' TODO: remove the "buf_flat_size" process below and extend the buf bound','line_number':1125,'multiline':False]['text':' check to support N-d indices access and 1-d index access.','line_number':1126,'multiline':False]['text':' "Allocate" stmt is based on "Buf" which supports N-d indices access and 1-d','line_number':1127,'multiline':False]['text':' index access. Currently the write bound check in memory analysis cannot','line_number':1128,'multiline':False]['text':' identify 1-d index access for N-d bufs. Thus we flatten N-d bufs here to','line_number':1129,'multiline':False]['text':' avoid failing the bound check. But this is not the correct approach and','line_number':1130,'multiline':False]['text':' should be fixed.','line_number':1131,'multiline':False]['text':' Only writes can close open accesses.','line_number':1197,'multiline':False]['text':' If we're not closing accesses we can stop here.','line_number':1205,'multiline':False]['text':' Total overlap is easy - the new access totally replaces the old.','line_number':1212,'multiline':False]['text':' The new write partially overlaps a previous write. We want to keep','line_number':1215,'multiline':False]['text':' both, but only track the uncovered part of the earlier write.','line_number':1216,'multiline':False]['text':' Determine the slices of the earlier bound not covered by info.','line_number':1218,'multiline':False]['text':' Erase the old slice.','line_number':1222,'multiline':False]['text':' Add all new slices.','line_number':1225,'multiline':False]['text':' No need to increment the iterator since it has been updated after','line_number':1229,'multiline':False]['text':' `erase` above.','line_number':1230,'multiline':False]['text':' Update dependencies, but don't add new open writes yet.','line_number':1247,'multiline':False]['text':' Intentionally using operator[], we want it to be created if it does not','line_number':1249,'multiline':False]['text':' exist.','line_number':1250,'multiline':False]['text':' Copy open writes up.','line_number':1258,'multiline':False]['text':' Intentionally using operator[], we want it to be created if it does not','line_number':1262,'multiline':False]['text':' exist.','line_number':1263,'multiline':False]['text':' the parent scope is responsible for holding all accesses now.','line_number':1271,'multiline':False]['text':' A visitor which applies known Bounds to symbolic expressions.','line_number':1278,'multiline':False]['text':' namespace torch::jit::tensorexpr::analysis','line_number':1319,'multiline':False]