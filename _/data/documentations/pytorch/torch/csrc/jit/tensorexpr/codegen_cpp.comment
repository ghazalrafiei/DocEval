['text':' This algorithm takes the list of intermediate buffers and their liveness','line_number':109,'multiline':False]['text':' ranges, and returns the allocations of these buffers. A buffer 'A' can be','line_number':110,'multiline':False]['text':' allocated in the memory (appears as a pair of 'A's in the allocation results)','line_number':111,'multiline':False]['text':' or reuse another buffer such as 'B' (appears as ('A', 'B')). Specifically, we','line_number':112,'multiline':False]['text':' linearly scan the intermediate buffers by the time they appear, and try to','line_number':113,'multiline':False]['text':' assign it an existing non-occupied memory allocation. If there are no such','line_number':114,'multiline':False]['text':' allocations available, we'll create memory for it. Once we are beyond the','line_number':115,'multiline':False]['text':' liveness range of this buffer, we'll mark its corresponding memory allocation','line_number':116,'multiline':False]['text':' as "up for grabs" for future reuse.','line_number':117,'multiline':False]['text':' Sort buffers by the time they appear.','line_number':122,'multiline':False]['text':' Map intermediate buffers to the most recently used memory if any.','line_number':131,'multiline':False]['text':' If the buf has dynamic shapes, we'll skip it (i.e., allocate memory for','line_number':141,'multiline':False]['text':' it, and there are no future reuses on its memory).','line_number':142,'multiline':False]['text':' TODO: reuse memory for bufs with dynamic shapes','line_number':143,'multiline':False]['text':' Release memory for buffers whose liveness range ends before the creation','line_number':151,'multiline':False]['text':' time of this buf.','line_number':152,'multiline':False]['text':' TODO: optimize in-place operations and copy operations','line_number':153,'multiline':False]['text':' Sort the buffers in the order of used time so the head of the release','line_number':163,'multiline':False]['text':' list contains the most recently used buf.','line_number':164,'multiline':False]['text':' Check whether there are free memories that this buf can reuse.','line_number':176,'multiline':False]['text':' If there are no memories to reuse, we'll have to allocate new memory for','line_number':190,'multiline':False]['text':' it.','line_number':191,'multiline':False]['text':' Insert allocations and frees for temporary buffers at global scope.','line_number':211,'multiline':False]['text':' We allocate intermediate buffers by inserting Allocate/Free or','line_number':274,'multiline':False]['text':' PlacementAllocate stmts. Allocate/Free stmts will allocate memory at runtime,','line_number':275,'multiline':False]['text':' and PlacementAllocate stmt reuses the memory of one buffer for another','line_number':276,'multiline':False]['text':' buffer. In current implementation, we use linear scan for memory reuses.','line_number':277,'multiline':False]['text':' TODO: try more memory reuse algorithms and compare their memory efficiency.','line_number':278,'multiline':False]['text':' Identify intermediate buffers that are not allocated yet.','line_number':280,'multiline':False]['text':' Identify the access stmts to each unallocated intermediate buffer.','line_number':297,'multiline':False]['text':' For each intermediate buffer, we reuse the memory of an old buffer whose','line_number':305,'multiline':False]['text':' liveness range does not overlap with the current buffer, or allocate memory','line_number':306,'multiline':False]['text':' if reusing buffer is impossible.','line_number':307,'multiline':False]['text':' Insert memory allocation/mapping nodes.','line_number':311,'multiline':False]['text':' namespace torch::jit::tensorexpr','line_number':320,'multiline':False]