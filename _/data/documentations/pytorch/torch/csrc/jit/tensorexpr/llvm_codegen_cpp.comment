['text':' Note [llvm::SCEVPredicate non-virtual destructor]','line_number':12,'multiline':False]['text':' llvm::SCEVPredicate has virtual function but non-virtual destructor','line_number':13,'multiline':False]['text':' https://github.com/llvm/llvm-project/blob/c1a0a213378a458fbea1a5c77b315c7dce08fd05/llvm/include/llvm/Analysis/ScalarEvolution.h#L198','line_number':14,'multiline':False]['text':' see Note [llvm::SCEVPredicate non-virtual destructor]','line_number':32,'multiline':False]['text':' Address and type pair to assist in handling of opaque pointers.','line_number':107,'multiline':False]['text':' TODO: change to a proper error report','line_number':137,'multiline':False]['text':' TODO: change to a proper error report','line_number':158,'multiline':False]['text':' namespace','line_number':207,'multiline':False]['text':' namespace torch::jit::tensorexpr','line_number':387,'multiline':False]['text':' numel ','line_number':425,'multiline':True]['text':'=""','line_number':461,'multiline':True]['text':' Global mutex to protect LLVM initialization.  TargetRegistry::lookupTarget','line_number':481,'multiline':False]['text':' in particular is not thread-safe.','line_number':482,'multiline':False]['text':' namespace','line_number':484,'multiline':False]['text':' Manually map types to LLVM types.','line_number':508,'multiline':False]['text':' We support float16 ops by casting expr inputs to float32','line_number':537,'multiline':False]['text':' and then casting the result back to float16','line_number':538,'multiline':False]['text':' Emit prototype and bind argument Vars to parameter indices.','line_number':545,'multiline':False]['text':' TODO: fast exp','line_number':686,'multiline':False]['text':' TODO: fast erf','line_number':687,'multiline':False]['text':' TODO: fast sigmoid','line_number':688,'multiline':False]['text':' Set insert point to the real function.','line_number':696,'multiline':False]['text':' Maybe expand some of the intrinsics.','line_number':700,'multiline':False]['text':' Compile the kernel.','line_number':709,'multiline':False]['text':' If the kernel is empty, set a default return value.','line_number':712,'multiline':False]['text':' print graph debug info before optimization','line_number':719,'multiline':False]['text':' print graph debug info after optimization','line_number':740,'multiline':False]['text':' TODO: The binary ops are copypasta.','line_number':760,'multiline':False]['text':' TODO: Handle arg promotion.','line_number':770,'multiline':False]['text':' TODO: Handle arg promotion.','line_number':788,'multiline':False]['text':' TODO: Handle arg promotion.','line_number':806,'multiline':False]['text':' TODO: Handle arg promotion.','line_number':824,'multiline':False]['text':' do nothing.','line_number':1129,'multiline':False]['text':' Scalar casts','line_number':1141,'multiline':False]['text':' Shift the BF16 value left by 16bits and then bit cast the shifted value','line_number':1143,'multiline':False]['text':' to FP32.','line_number':1144,'multiline':False]['text':'   FP32_VAL = BF16_VAL << 16','line_number':1145,'multiline':False]['text':' Convert the FP32 value by RNE(Rounding to Nearest Even). Algorithm is as','line_number':1155,'multiline':False]['text':' follows:','line_number':1156,'multiline':False]['text':'   STEP1: U32_VAL = BITCAST(F32_VAL)','line_number':1157,'multiline':False]['text':'   STEP2: U32_VAL_TMP = U32_VAL >> 16','line_number':1158,'multiline':False]['text':'   STEP3: U32_VAL_TMP = U32_VAL_TMP & 1','line_number':1159,'multiline':False]['text':'   STEP4: ROUNDING_BIAS = U32_VAL_TMP + UINT32(0x7FFF)','line_number':1160,'multiline':False]['text':'   STEP5: U32_VAL_TMP = U32_VAL + ROUNDING_BIAS','line_number':1161,'multiline':False]['text':'   STEP6: BF16_VAL = static_cast<UINT16>(U32_VAL_TMP >> 16)','line_number':1162,'multiline':False]['text':' STEP1: U32_VAL = BITCAST(F32_VAL)','line_number':1170,'multiline':False]['text':' STEP2: U32_VAL_TMP = (U32_VAL >> 16)','line_number':1173,'multiline':False]['text':' STEP3: U32_VAL_TMP = U32_VAL_TMP & 1','line_number':1176,'multiline':False]['text':' STEP4: ROUNDING_BIAS = U32_VAL_TMP + UINT32(0x7FFF)','line_number':1178,'multiline':False]['text':' STEP5: U32_VAL_TMP = U32_VAL + ROUNDING_BIAS','line_number':1181,'multiline':False]['text':' STEP6: BF16_VAL = static_cast<UINT16>(U32_VAL_TMP >> 16)','line_number':1183,'multiline':False]['text':' If the value is NaN, return BF16 NaN.','line_number':1187,'multiline':False]['text':' as with eager, convert from Double -> Half by Converting to Float then','line_number':1194,'multiline':False]['text':' Half. TODO: __truncdfhf2','line_number':1195,'multiline':False]['text':' Strictly casting from Float -> i8 doesnt give correct results','line_number':1203,'multiline':False]['text':' set one bit true if the input float is not 0','line_number':1204,'multiline':False]['text':' Ensure bool true value is exactly one, since we convert to int','line_number':1236,'multiline':False]['text':' from bool by zero extending the int8','line_number':1237,'multiline':False]['text':' do nothing.','line_number':1259,'multiline':False]['text':' It is possible for v to be in both varToVal_ and varToArgs.','line_number':1273,'multiline':False]['text':' In that case, varToVal_ takes precedence.','line_number':1274,'multiline':False]['text':' Create block structure for the masked load.','line_number':1368,'multiline':False]['text':' Test the mask','line_number':1373,'multiline':False]['text':' Do the load','line_number':1377,'multiline':False]['text':' Merge the masked and unmasked CFG edges','line_number':1391,'multiline':False]['text':' Handle the case where the load is contiguous and unmasked efficiently','line_number':1433,'multiline':False]['text':' Fallback to a scalar implementation','line_number':1463,'multiline':False]['text':' Pack the arguments into an aggregate struct for forwarding.','line_number':1481,'multiline':False]['text':' Unpack the aggregate struct into individual arguments.','line_number':1505,'multiline':False]['text':' TODO: extract arg_count from packed.','line_number':1509,'multiline':False]['text':' Pack the arguments into an aggregate struct for forwarding.','line_number':1521,'multiline':False]['text':' Unpack the aggregate struct into individual arguments.','line_number':1545,'multiline':False]['text':' TODO: extract arg_count from packed.','line_number':1549,'multiline':False]['text':' Lower the parallel for-loop.','line_number':1563,'multiline':False]['text':' * Move the body into its own closure.','line_number':1564,'multiline':False]['text':' * Identify var across the boundary into arguments and forward them.','line_number':1565,'multiline':False]['text':' * Send the closure and range to the dispatcher for execution.','line_number':1566,'multiline':False]['text':' Create "start" and "stop" values.','line_number':1568,'multiline':False]['text':' The Vars that need to be forward in the body closure.','line_number':1574,'multiline':False]['text':' Corresponding Value* that was used in the old body for the caller.','line_number':1576,'multiline':False]['text':' Corresponding Value* that will be used in the new body closure.','line_number':1578,'multiline':False]['text':' Identify the VarPtr used in the body, and generated outside.','line_number':1581,'multiline':False]['text':' Pack the arguments in an automatic variable for forwarding.','line_number':1592,'multiline':False]['text':' Remember where we are before moving to the new function.','line_number':1599,'multiline':False]['text':' Create the new body closure code.','line_number':1602,'multiline':False]['text':' Unpack the arguments from the opaque buffer.','line_number':1621,'multiline':False]['text':' Set the codegen to the new func.','line_number':1632,'multiline':False]['text':' TODO: this should be replaced by RAII wrappers.','line_number':1633,'multiline':False]['text':' Restore back to the previous fn_','line_number':1641,'multiline':False]['text':' Points back to the original block and generate the callee code.','line_number':1647,'multiline':False]['text':' Create "start" and "stop" values.','line_number':1682,'multiline':False]['text':' Create block for loop condition test.','line_number':1688,'multiline':False]['text':' Set up phi node for index variable.','line_number':1694,'multiline':False]['text':' Create the body and exit blocks.','line_number':1703,'multiline':False]['text':' Create the stop condition.','line_number':1707,'multiline':False]['text':' Codegen the body.','line_number':1711,'multiline':False]['text':' "Body" block may have changed if we generated nested control flow.','line_number':1716,'multiline':False]['text':' Increment the index variable and branch back to loop test.','line_number':1719,'multiline':False]['text':' Exit the loop.','line_number':1725,'multiline':False]['text':' Create block structure for the masked store.','line_number':1773,'multiline':False]['text':' Test the mask','line_number':1777,'multiline':False]['text':' Do the store','line_number':1781,'multiline':False]['text':' Merge the masked and unmasked CFG edges','line_number':1794,'multiline':False]['text':' Handle the case where the store is contiguous and unmasked efficiently','line_number':1817,'multiline':False]['text':' Fallback to a scalar implementation','line_number':1851,'multiline':False]['text':' TODO: Adding this attr should be correct, but as of LLVM 9.0.1 adding it','line_number':1900,'multiline':False]['text':' causes some math functions to incorrectly be turned into tail calls.','line_number':1901,'multiline':False]['text':' f->addFnAttr(llvm::Attribute::Speculatable);','line_number':1902,'multiline':False]['text':'isSigned','line_number':1933,'multiline':True]['text':' Using sleef on these ops is slower than libm.','line_number':1938,'multiline':False]['text':' Determine whether to use vectorized intrinsic.','line_number':1963,'multiline':False]['text':' Get function to call from name and type.','line_number':1979,'multiline':False]['text':' abs is only intrinsic defined for integer inputs in pytorch eager','line_number':2139,'multiline':False]['text':' TODO: use llvm.abs intrinsic for LLVM 12','line_number':2144,'multiline':False]['text':' Prepare a vector of bufs that we need to pass to the external function.','line_number':2197,'multiline':False]['text':' This vector is the output buf followed by the buf_args.','line_number':2198,'multiline':False]['text':' Count the size of dims array - it consists of dimension of all bufs','line_number':2205,'multiline':False]['text':' concatenated together.','line_number':2206,'multiline':False]['text':' Store value for buf pointer','line_number':2233,'multiline':False]['text':' Store dtype of the buf','line_number':2247,'multiline':False]['text':' Store rank of the buf','line_number':2254,'multiline':False]['text':' Store dims of the buf','line_number':2260,'multiline':False]['text':' Store strides of the buf','line_number':2270,'multiline':False]['text':' Generate the call itself','line_number':2294,'multiline':False]['text':' return type','line_number':2300,'multiline':False]['text':' int64_t bufs_num','line_number':2301,'multiline':False]['text':' void** buf_data','line_number':2302,'multiline':False]['text':' int64_t* buf_ranks','line_number':2303,'multiline':False]['text':' int64_t* buf_dims','line_number':2304,'multiline':False]['text':' int64_t* buf_strides','line_number':2305,'multiline':False]['text':' int64_t* buf_dtypes','line_number':2306,'multiline':False]['text':' int64_t args_num','line_number':2307,'multiline':False]['text':' int64_t* extra_args','line_number':2308,'multiline':False]['text':' is var_arg','line_number':2309,'multiline':False]['text':' return type','line_number':2314,'multiline':False]['text':' int64_t bufs_num','line_number':2315,'multiline':False]['text':' void** buf_data','line_number':2316,'multiline':False]['text':' int64_t* buf_ranks','line_number':2317,'multiline':False]['text':' int64_t* buf_dims','line_number':2318,'multiline':False]['text':' int64_t* buf_strides','line_number':2319,'multiline':False]['text':' int64_t* buf_dtypes','line_number':2320,'multiline':False]['text':' int64_t args_num','line_number':2321,'multiline':False]['text':' int64_t* extra_args','line_number':2322,'multiline':False]['text':' is var_arg','line_number':2323,'multiline':False]['text':' Count the size of dims array - it consists of dimension of all bufs','line_number':2358,'multiline':False]['text':' concatenated together.','line_number':2359,'multiline':False]['text':' bufs_out_size for out tensors data pointers','line_number':2365,'multiline':False]['text':' bufs_in_size for input pointers','line_number':2366,'multiline':False]['text':' bufs_out_size for out tensors TensorImpl* to pass to nnc_aten_free to','line_number':2367,'multiline':False]['text':' release out tensors','line_number':2368,'multiline':False]['text':' @lint-ignore CLANGTIDY','line_number':2378,'multiline':False]['text':' @lint-ignore CLANGTIDY','line_number':2387,'multiline':False]['text':' Store value for buf pointer','line_number':2395,'multiline':False]['text':' @lint-ignore CLANGTIDY','line_number':2403,'multiline':False]['text':' @lint-ignore CLANGTIDY','line_number':2410,'multiline':False]['text':' Store dtype of the buf','line_number':2417,'multiline':False]['text':' Store rank of the buf','line_number':2424,'multiline':False]['text':' @lint-ignore CLANGTIDY','line_number':2425,'multiline':False]['text':' Store dims of the buf','line_number':2431,'multiline':False]['text':' Store strides of the buf','line_number':2441,'multiline':False]['text':' Generate the call itself','line_number':2465,'multiline':False]['text':' return type','line_number':2472,'multiline':False]['text':' int64_t bufs_in_size','line_number':2473,'multiline':False]['text':' void** buf_data','line_number':2474,'multiline':False]['text':' int64_t* buf_ranks','line_number':2475,'multiline':False]['text':' int64_t* buf_dims','line_number':2476,'multiline':False]['text':' int64_t* buf_strides','line_number':2477,'multiline':False]['text':' int64_t* buf_dtypes','line_number':2478,'multiline':False]['text':' int64_t args_num','line_number':2479,'multiline':False]['text':' int64_t* extra_args','line_number':2480,'multiline':False]['text':' is var_arg','line_number':2481,'multiline':False]['text':' return type','line_number':2486,'multiline':False]['text':' int64_t bufs_in_size','line_number':2487,'multiline':False]['text':' void** buf_data','line_number':2488,'multiline':False]['text':' int64_t* buf_ranks','line_number':2489,'multiline':False]['text':' int64_t* buf_dims','line_number':2490,'multiline':False]['text':' int64_t* buf_strides','line_number':2491,'multiline':False]['text':' int64_t* buf_dtypes','line_number':2492,'multiline':False]['text':' int64_t args_num','line_number':2493,'multiline':False]['text':' int64_t* extra_args','line_number':2494,'multiline':False]['text':' is var_arg','line_number':2495,'multiline':False]['text':' @lint-ignore CLANGTIDY','line_number':2505,'multiline':False]['text':' @lint-ignore CLANGTIDY','line_number':2512,'multiline':False]['text':' @lint-ignore CLANGTIDY','line_number':2516,'multiline':False]['text':' @lint-ignore CLANGTIDY','line_number':2545,'multiline':False]['text':' @lint-ignore CLANGTIDY','line_number':2552,'multiline':False]['text':' Insert the bitcast into the block.','line_number':2592,'multiline':False]['text':' return type','line_number':2657,'multiline':False]['text':' int64_t bufs_num','line_number':2659,'multiline':False]['text':' void** ptrs','line_number':2660,'multiline':False]['text':' is var_arg','line_number':2662,'multiline':False]['text':' return type','line_number':2667,'multiline':False]['text':' int64_t bufs_num','line_number':2669,'multiline':False]['text':' void** ptrs','line_number':2670,'multiline':False]['text':' is var_arg','line_number':2672,'multiline':False]['text':' Even if true_stmt and false_stmt are nullptr,','line_number':2698,'multiline':False]['text':' in case condition is a function call with side effect,','line_number':2699,'multiline':False]['text':' we still evaluate it.','line_number':2700,'multiline':False]['text':' "New" PassManager needed to replace TM.adjustPassManager','line_number':2739,'multiline':False]['text':' Add internal analysis passes from the target machine.','line_number':2742,'multiline':False]['text':' Create the analysis managers.','line_number':2745,'multiline':False]['text':' Create the new pass manager builder.','line_number':2751,'multiline':False]['text':' Take a look at the PassBuilder constructor parameters for more','line_number':2752,'multiline':False]['text':' customization, e.g. specifying a TargetMachine or various debugging','line_number':2753,'multiline':False]['text':' options.','line_number':2754,'multiline':False]['text':' Register all the basic analyses with the managers.','line_number':2759,'multiline':False]['text':' "Old" PassManager','line_number':2786,'multiline':False]['text':' Add internal analysis passes from the target machine.','line_number':2791,'multiline':False]['text':' TORCH_ENABLE_LLVM','line_number':2817,'multiline':False]