['text':' Handle negative indexing','line_number':12,'multiline':False]['text':' Convert boolean to integer, if needed.','line_number':22,'multiline':False]['text':' NOLINTNEXTLINE','line_number':33,'multiline':False]['text':' assume JIT not supporting complex and qint yet','line_number':65,'multiline':False]['text':' Find the highest type among the inputs.','line_number':95,'multiline':False]['text':'includeBool','line_number':121,'multiline':True]['text':' We intend to promote Integers to floating-point types','line_number':127,'multiline':False]['text':'includeBool','line_number':129,'multiline':True]['text':' NOLINTNEXTLINE','line_number':148,'multiline':False]['text':' TODO: if neither *at nor *bt is 1, ensure they are identical','line_number':209,'multiline':False]['text':' expressions.  Nb: `==` doesn't work since that simply produces a new','line_number':210,'multiline':False]['text':' ExprHandle.','line_number':211,'multiline':False]['text':' This is just a placeholder so we don't throw.  None-handling','line_number':288,'multiline':False]['text':' is operator-specific and should be handled properly in','line_number':289,'multiline':False]['text':' the operator-specific lowering code.','line_number':290,'multiline':False]['text':' Trivial case of 0-dim and 1-dim tensors: transpose is just a copy','line_number':361,'multiline':False]['text':' Usual case where transpose actually swaps dimensions','line_number':371,'multiline':False]['text':'
        Example for the index transformation. Assume we have a tensor A and
        its view B:
          A.size() = [6,2,3]
          B = A.view(2,1,9,1,2)

        In TE IR we would want to represent B as the following loopnest:
          for (i1 in 0..2)
            for (i2 in 0..1)
              for (i3 in 0..9)
                for (i4 in 0..1)
                  for (i5 in 0..2)
                    idx = i5 + i4*2 + i3*2 + i2*18 + i1*18
                    B[i1,i2,i3,i4,i5] = A[idx/(3*2), (idx/3)%2, idx%3]
        ','line_number':413,'multiline':True]['text':' We don't need to generate mod-div for the first dimension -','line_number':446,'multiline':False]['text':' ideally IRSimplifier would get rid of that for us, but for now','line_number':447,'multiline':False]['text':' let's just avoid generating it in the first place.','line_number':448,'multiline':False]['text':' In the example above the stride is initially 1 for dim_idx = 2,','line_number':454,'multiline':False]['text':' then it's 3 for dim_idx = 1, and then it's 3*2 for dim_idx = 0.','line_number':455,'multiline':False]['text':' NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)','line_number':458,'multiline':False]['text':' Ignore buffers that are 0-sized on any dimension.','line_number':491,'multiline':False]['text':' NOLINTNEXTLINE(performance-unnecessary-copy-initialization)','line_number':515,'multiline':False]['text':' Now we build one loop per input:','line_number':522,'multiline':False]['text':'','line_number':523,'multiline':False]['text':' for i','line_number':524,'multiline':False]['text':'   for j','line_number':525,'multiline':False]['text':'     for k','line_number':526,'multiline':False]['text':'       output[i,j,k] = inp1[i,j,k]','line_number':527,'multiline':False]['text':' for i','line_number':528,'multiline':False]['text':'   for j','line_number':529,'multiline':False]['text':'     for k','line_number':530,'multiline':False]['text':'       output[i,j+l1,k] = inp2[i,j,k]','line_number':531,'multiline':False]['text':' for i','line_number':532,'multiline':False]['text':'   for j','line_number':533,'multiline':False]['text':'     for k','line_number':534,'multiline':False]['text':'       output[i,j+l2,k] = inp3[i,j,k]','line_number':535,'multiline':False]['text':' NOLINTNEXTLINE(performance-unnecessary-copy-initialization)','line_number':630,'multiline':False]['text':' Promote input types.','line_number':647,'multiline':False]['text':' Note that we need to consider all inputs, including empty - they','line_number':648,'multiline':False]['text':' also affect the resultant dtype.','line_number':649,'multiline':False]['text':' Now we know the final dtype, we know what inputs are non-empty,','line_number':651,'multiline':False]['text':' and we know that there is at least one such an input. With all','line_number':652,'multiline':False]['text':' that we construct a tensor expression performing the','line_number':653,'multiline':False]['text':' concatenation.','line_number':654,'multiline':False]['text':' The expression we build here is a cascading if-then-else that','line_number':655,'multiline':False]['text':' essentially represents:','line_number':656,'multiline':False]['text':'','line_number':657,'multiline':False]['text':'              inp1[i, j, k]         if 0   < i < l1,','line_number':658,'multiline':False]['text':' out[i,j,k] = inp2[i, j-l1, k]      if l1 =< i < l1 + l2,','line_number':659,'multiline':False]['text':'              ...','line_number':660,'multiline':False]['text':'              inpN[i, j-l_N_1, k]   if l1+l2+...l_N_1  < i','line_number':661,'multiline':False]['text':' where l_i is the corresponding size of the i-th input.','line_number':662,'multiline':False]['text':' namespace tensorexpr','line_number':704,'multiline':False]['text':' namespace jit','line_number':705,'multiline':False]['text':' namespace torch','line_number':706,'multiline':False]