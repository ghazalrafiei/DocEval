['text':' Annotated attributes retrieved from module by inspecting module annotations.','line_number':13,'multiline':False]['text':' These attributes are not used inside the subgraph of ONNX local function','line_number':14,'multiline':False]['text':' because they are not created by PyTorch JIT tracing, but they may be used by','line_number':15,'multiline':False]['text':' consumers to determine whether or not to replace the function with a','line_number':16,'multiline':False]['text':' particular fused kernel.','line_number':17,'multiline':False]['text':' Passed later to serialization.','line_number':71,'multiline':False]['text':' Track modules with same module name that are exported as different onnx','line_number':117,'multiline':False]['text':' local functions.','line_number':118,'multiline':False]['text':' NOTE: Function scopes must have same number and order of nodes.','line_number':133,'multiline':False]['text':' The scope of node n is assigned based on the following rules.','line_number':351,'multiline':False]['text':' 1. If all uses of outputs of n belongs to the same scope,','line_number':352,'multiline':False]['text':'    assign that scope, otherwise','line_number':353,'multiline':False]['text':' 2. If all nodes of inputs of n belongs to the same scope,','line_number':354,'multiline':False]['text':'    assign that scope, otherwise','line_number':355,'multiline':False]['text':' 3. Find common ancestor of the scopes of uses of outputs of n,','line_number':356,'multiline':False]['text':'    and the scopes of nodes of inputs of n.','line_number':357,'multiline':False]['text':' TODO: Update input names of function to match those in Module source code','line_number':426,'multiline':False]['text':' signature.','line_number':427,'multiline':False]['text':' This requires mapping between function node inputs and Module inputs.','line_number':428,'multiline':False]['text':' Due to the lack of such mapping, currently debugName is used as input','line_number':429,'multiline':False]['text':' names.','line_number':430,'multiline':False]['text':' If values are used outside of this graph, set as graph output.','line_number':454,'multiline':False]['text':' create and insert local function definition node','line_number':476,'multiline':False]['text':' set constants and attributes of different values as function attributes.','line_number':483,'multiline':False]['text':' Add prefix "inferred::" to name of inferred attribute.','line_number':501,'multiline':False]['text':' This is to differentiate from annotated attributes picked up','line_number':502,'multiline':False]['text':' from python module annotation.','line_number':503,'multiline':False]['text':' Set annotated attributes','line_number':512,'multiline':False]['text':' set attributes of different values as function attributes.','line_number':577,'multiline':False]['text':' annotated attributes','line_number':627,'multiline':False]['text':' This function needs to be called always on inner most scopes.','line_number':646,'multiline':False]['text':' 1. Generate function context, this identifies different constants and','line_number':647,'multiline':False]['text':' attributes.','line_number':648,'multiline':False]['text':' 2. Create function definition node, and insert to main graph.','line_number':649,'multiline':False]['text':' 3. Create function node for each call, and replace subgraph nodes in parent','line_number':650,'multiline':False]['text':' functions.','line_number':651,'multiline':False]['text':' create and insert local function node to graph.','line_number':679,'multiline':False]['text':' replace function body nodes in parent scopes with local function node.','line_number':690,'multiline':False]['text':' insert local function node','line_number':708,'multiline':False]['text':' remove replaced nodes from list','line_number':712,'multiline':False]['text':' refresh inputs/outputs.','line_number':724,'multiline':False]['text':' delete replaced nodes in graph.','line_number':731,'multiline':False]['text':' Differentiate same function under different inputs.','line_number':743,'multiline':False]['text':' When constants are passed in place of inputs, it leads to different','line_number':744,'multiline':False]['text':' input count and node count. Likewise, due to different uses, output','line_number':745,'multiline':False]['text':' count can be different as well.','line_number':746,'multiline':False]['text':' For now export them as different functions.','line_number':747,'multiline':False]['text':' Covered by `test_local_function_overloads` in','line_number':748,'multiline':False]['text':' `test/onnx/test_utility_funs.py`.','line_number':749,'multiline':False]['text':' Add initializers after inputs.','line_number':786,'multiline':False]['text':' Deepest scope comes first, guaranteeing no other scope can be its child.','line_number':1049,'multiline':False]['text':' Construct return mappings','line_number':1061,'multiline':False]['text':' Clear','line_number':1069,'multiline':False]['text':' Retrieves the node representing the most recent','line_number':1082,'multiline':False]['text':' ScopePtr. This function should only be invoked from module forward hook. At','line_number':1083,'multiline':False]['text':' this point, module forward call is completed, and the most recent ScopePtr','line_number':1084,'multiline':False]['text':' is popped from TracingState.','line_number':1085,'multiline':False]['text':' This function inspects the node, and its subblock, to find','line_number':1086,'multiline':False]['text':' the node associated with the most recent ScopePtr.','line_number':1087,'multiline':False]['text':' namespace','line_number':1105,'multiline':False]['text':' FunctionExtractor runs in the following steps. Updates are made inplace to','line_number':1107,'multiline':False]['text':' the graph argument.','line_number':1108,'multiline':False]['text':'    1. Partition nodes into groups based on their scope information.','line_number':1109,'multiline':False]['text':'    Each scope represents an individual nn.Module call. A ScopeContext object','line_number':1110,'multiline':False]['text':'    is created for each group.','line_number':1111,'multiline':False]['text':'    2. Compare and find groups with the same subgraph pattern from step 1.','line_number':1112,'multiline':False]['text':'    3. Scopes are nested. Starting from the deepest scope, extract the','line_number':1113,'multiline':False]['text':'    subgraph pattern, and define as local function node. Replace subgraph','line_number':1114,'multiline':False]['text':'    pattern with a single node of the new local function node type. A','line_number':1115,'multiline':False]['text':'    FunctionContext object is created for each function.','line_number':1116,'multiline':False]['text':'    4. Construct NodeAttrNameMap tracking mapping from attribute name of','line_number':1117,'multiline':False]['text':'    IR Node inside function subgraph, to function attribute name.','line_number':1118,'multiline':False]['text':' Skip the "real" last node which is `return_node`.','line_number':1152,'multiline':False]['text':' namespace onnx','line_number':1186,'multiline':False]['text':' namespace jit','line_number':1187,'multiline':False]['text':' namespace torch','line_number':1188,'multiline':False]