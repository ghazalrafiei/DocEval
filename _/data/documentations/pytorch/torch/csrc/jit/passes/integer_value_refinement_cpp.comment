['text':' see [value refinement algorithm] for full explanation.','line_number':14,'multiline':False]['text':' When a comparison like `cond = x == 4` or `cond = x != 4` is made,','line_number':15,'multiline':False]['text':' `cond` value carries information (refinements) about the value of `x`.','line_number':16,'multiline':False]['text':' in an example like:','line_number':17,'multiline':False]['text':' if x == 1:','line_number':18,'multiline':False]['text':'    ...','line_number':19,'multiline':False]['text':' we can substitute all uses of x dominated by the true block','line_number':20,'multiline':False]['text':' with 1.','line_number':21,'multiline':False]['text':' we are looking for cases where we can replace both block outputs with the','line_number':61,'multiline':False]['text':' same value, which opens up further optimization opportunities. The pass','line_number':62,'multiline':False]['text':' will already handle if both outputs are refined to the same constant.','line_number':63,'multiline':False]['text':' Here, we look for cases where one block output has been refined in the','line_number':64,'multiline':False]['text':' other block to be equal to the same constant value as the other other','line_number':65,'multiline':False]['text':' block output:','line_number':66,'multiline':False]['text':'  graph(%y.1 : int):','line_number':67,'multiline':False]['text':'   %one_constant : int = prim::Constant[value=1]()','line_number':68,'multiline':False]['text':'   %3 : bool = aten::eq(%y.1, %one_constant)','line_number':69,'multiline':False]['text':'   %15 : int = prim::If(%3)','line_number':70,'multiline':False]['text':'     block0():','line_number':71,'multiline':False]['text':'       -> (%one_constant)','line_number':72,'multiline':False]['text':'     block1():','line_number':73,'multiline':False]['text':'       -> (%y.1)','line_number':74,'multiline':False]['text':'   return (%15)','line_number':75,'multiline':False]['text':' %15 can always be safely replaced with %y.1','line_number':76,'multiline':False]['text':' this is an important case for symbolic shape analysis','line_number':77,'multiline':False]['text':' Value must be in scope for both blocks','line_number':86,'multiline':False]['text':' in example above, %y.1 cannot be defined in block1','line_number':87,'multiline':False]['text':' one constant value one not - we are looking for the pattern','line_number':91,'multiline':False]['text':' where y.1 is refined to the existing block output %one_constant','line_number':92,'multiline':False]['text':' here, we are looking in refinements in the other block of our','line_number':101,'multiline':False]['text':' current output. in the example, we are looking for refinements of','line_number':102,'multiline':False]['text':' %y.1 in `block0`, and we are checking that %y.1 is refined','line_number':103,'multiline':False]['text':' to the constant value of %one_constant','line_number':104,'multiline':False]['text':' iteratively look through the block `b` for refinements or Value uses that','line_number':118,'multiline':False]['text':' can be refined, `block_refinements` are the refinements present starting at','line_number':119,'multiline':False]['text':' this block (and for all blocks dominated by this block).','line_number':120,'multiline':False]['text':' iterating over all nodes in the block will not iterate over','line_number':179,'multiline':False]['text':' block outputs, so we need to add handling of them.','line_number':180,'multiline':False]['text':' %3 : int = prim::Constant[value=3]()','line_number':181,'multiline':False]['text':' %4 : bool = aten::eq(%y.1, %3)','line_number':182,'multiline':False]['text':' %a : int = prim::If(%4)','line_number':183,'multiline':False]['text':'   block0():','line_number':184,'multiline':False]['text':'     -> (%y.1)','line_number':185,'multiline':False]['text':' Here, we can replace y.1 with 3','line_number':186,'multiline':False]['text':' A stack of active refinements, one for each block','line_number':218,'multiline':False]['text':' A map from Boolean Value * -> associated refinements','line_number':220,'multiline':False]['text':' namespace jit','line_number':230,'multiline':False]['text':' namespace torch','line_number':231,'multiline':False]