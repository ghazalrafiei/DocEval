['text':' prev:  cond_val -> consumer_node','line_number':35,'multiline':False]['text':' after: cond_val -> cast -> consumer_node','line_number':36,'multiline':False]['text':' NOTE: The cast is required because operators like PyTorch Greater/Less','line_number':37,'multiline':False]['text':'       return tensor in type torch.uint8. However the type for condition','line_number':38,'multiline':False]['text':'       input in ONNX Loop must be bool.','line_number':39,'multiline':False]['text':' Non-default insert position is not supported.','line_number':70,'multiline':False]['text':' Only SequenceInsert that applies on loop-carried sequence is supported.','line_number':75,'multiline':False]['text':' Initial sequence must be empty.','line_number':84,'multiline':False]['text':' The sequence is not supported to be used elsewhere inside the sub-block.','line_number':89,'multiline':False]['text':' ONNX::Loop does not support Sequence type as loop-carried dependencies. Only','line_number':96,'multiline':False]['text':' tensors are supported. This pass converts Sequence loop-carried dependencies','line_number':97,'multiline':False]['text':' to scan_outputs. In opset 11, only the below pattern is supported.','line_number':98,'multiline':False]['text':'','line_number':99,'multiline':False]['text':' PTIR graph:','line_number':100,'multiline':False]['text':'  ...','line_number':101,'multiline':False]['text':'  %res.1 : Tensor[] = prim::ListConstruct()','line_number':102,'multiline':False]['text':'  %res : Tensor[] = prim::Loop(%11, %22, %res.1)','line_number':103,'multiline':False]['text':'    block0(%i.1 : Tensor, %res.6 : Tensor[]):','line_number':104,'multiline':False]['text':'      ...','line_number':105,'multiline':False]['text':'      %res.3 : Tensor[] = aten::append(%res.6, %17)','line_number':106,'multiline':False]['text':'      -> (%22, %res.3)','line_number':107,'multiline':False]['text':'  return (%res.3)','line_number':108,'multiline':False]['text':'','line_number':109,'multiline':False]['text':' ONNX graph:','line_number':110,'multiline':False]['text':'  ...','line_number':111,'multiline':False]['text':'  %res : Tensor = onnx::Loop(%11, %22)','line_number':112,'multiline':False]['text':'    block0(%i.1 : Tensor):','line_number':113,'multiline':False]['text':'      ...','line_number':114,'multiline':False]['text':'      -> (%22, %17)','line_number':115,'multiline':False]['text':'  %res_seq : Tensor[] = onnx::SplitToSequence[keepdims=0](%res)','line_number':116,'multiline':False]['text':'  return (%res_seq)','line_number':117,'multiline':False]['text':' Sequence type as loop-carried dependencies should be supported by ONNX','line_number':124,'multiline':False]['text':' ospet 13.','line_number':125,'multiline':False]['text':' ONNX Loop node:','line_number':136,'multiline':False]['text':' sub-block inputs are  (iter, cond, loop-carried dependencies)','line_number':137,'multiline':False]['text':' sub-block outputs are (      cond, loop-carried dependencies, scan outputs)','line_number':138,'multiline':False]['text':' inputs are            (iter, cond, loop-carried dependencies)','line_number':139,'multiline':False]['text':' outputs are           (            loop-carried dependencies, scan outputs)','line_number':140,'multiline':False]['text':' Replace sequence output with the inserted element.','line_number':144,'multiline':False]['text':' Split the added scan_output back to expected tensor sequence.','line_number':149,'multiline':False]['text':' Update loop output type.','line_number':160,'multiline':False]['text':' The node that produces sequence should be safe to remove now.','line_number':163,'multiline':False]['text':' Remove sequence outputs, and replace with scan outputs.','line_number':173,'multiline':False]['text':' Swap output order. Move all scan outputs to the back.','line_number':180,'multiline':False]['text':' Replaces block output i with an onnx::Optional','line_number':203,'multiline':False]['text':' with `type` taken from opt_type. If and Loop Ops shares this function.','line_number':204,'multiline':False]['text':' 1. If Op: Needed when control flow has multiple branches, one of which','line_number':205,'multiline':False]['text':' is defined by `block` and returns a None and another branch','line_number':206,'multiline':False]['text':' returns not-None. The passed-in opt_type should be from the other branch.','line_number':207,'multiline':False]['text':' 2. Loop Op: insert Optional node before output, if input is Optional type','line_number':208,'multiline':False]['text':' or output type is None.','line_number':209,'multiline':False]['text':' replace only the last value as Optional type only affects','line_number':217,'multiline':False]['text':' the value right before output','line_number':218,'multiline':False]['text':' Resolving limitation from ONNX that the block output can not be','line_number':226,'multiline':False]['text':' a value from outside the block. Inserting an Identity node inside','line_number':227,'multiline':False]['text':' the block, linking with the value outside as workaround.','line_number':228,'multiline':False]['text':' Simplify graph by creating an empty optional rather than','line_number':234,'multiline':False]['text':' Identity(None). Also enables shape inference later on, since','line_number':235,'multiline':False]['text':' ONNX shape inference doesn't handle None.','line_number':236,'multiline':False]['text':' Infer type of optional inputs from outputs.','line_number':252,'multiline':False]['text':' input i corresponds to output i until we run FixupONNXLoopNodeInputs.','line_number':256,'multiline':False]['text':' Replace None in outputs with Optional.','line_number':273,'multiline':False]['text':' output 0 is continue_condition, never None.','line_number':276,'multiline':False]['text':' Two conditions that we need to replace block output with optional','line_number':278,'multiline':False]['text':' 1. output is NoneType','line_number':279,'multiline':False]['text':' 2. input is optional but output type is not','line_number':280,'multiline':False]['text':' Output 0 is continue_condition.','line_number':285,'multiline':False]['text':' Inputs (0, 1) are (loop_counter, cond). So input i + 1','line_number':286,'multiline':False]['text':' corresponds to output i.','line_number':287,'multiline':False]['text':' add cast to condition input outside the loop.','line_number':304,'multiline':False]['text':' Setup Loop input cond and i.','line_number':311,'multiline':False]['text':' add cast to condition input inside the loop.','line_number':320,'multiline':False]['text':' Inputs (0, 1) are (max_trip_count, start_condition). Skip them','line_number':328,'multiline':False]['text':' since they're never None or Optional.','line_number':329,'multiline':False]['text':' If loop input is not optional but block input is, wrap loop input with','line_number':334,'multiline':False]['text':' Optional. Happens when the loop takes in None and outputs not-None, or','line_number':335,'multiline':False]['text':' vice-versa.','line_number':336,'multiline':False]['text':' anonymous namespace','line_number':357,'multiline':False]['text':' NOTE: the output order is deliberately changed to match expected order','line_number':368,'multiline':False]['text':'       since onnx loop requires scan outputs to be the last outputs.','line_number':369,'multiline':False]['text':' Copy type of block output to node output.','line_number':371,'multiline':False]['text':' Check if node is prim::Uninitialized,','line_number':378,'multiline':False]['text':' or output of prim::Uninitialized->onnx::Identity','line_number':379,'multiline':False]['text':' Infer shape and type of the uninitialized_output from the corresponding','line_number':389,'multiline':False]['text':' output of the other subblock. prim::Uninitialized node is proven to be','line_number':390,'multiline':False]['text':' unused. So replace this node with one of the inferred shape and type.','line_number':391,'multiline':False]['text':' Corresponding outputs for ONNX If then and else subblocks should have','line_number':447,'multiline':False]['text':' same shape and type. This pass detects if prim::Uninitialized node','line_number':448,'multiline':False]['text':' appears as part of outputs of either of the subblocks, and infers','line_number':449,'multiline':False]['text':' shape and type from the corresponding output of the other subblock','line_number':450,'multiline':False]['text':' In the example graph below, shape and type of the subblock output %7','line_number':451,'multiline':False]['text':' for subblock 1 is inferred from %y.1. Shape and type of Subblock','line_number':452,'multiline':False]['text':' output %7 is inferred from %y.5.','line_number':453,'multiline':False]['text':'','line_number':454,'multiline':False]['text':' graph(%y.1 : Int(3:4, 4:1, requires_grad=0, device=cpu)):','line_number':455,'multiline':False]['text':'   ...','line_number':456,'multiline':False]['text':'   %7 : Tensor = prim::Uninitialized()','line_number':457,'multiline':False]['text':'   %16 : bool, %17 : Tensor, %y.14 : Tensor = prim::If(%15) #','line_number':458,'multiline':False]['text':'   test/onnx/test_pytorch_onnx_onnxruntime.py:614:20','line_number':459,'multiline':False]['text':'     block0():','line_number':460,'multiline':False]['text':'       %y.5 : Tensor = aten::add(%y.1, %3, %6) #','line_number':461,'multiline':False]['text':'       test/onnx/test_pytorch_onnx_onnxruntime.py:615:28','line_number':462,'multiline':False]['text':'       -> (%2, %7, %y.5)','line_number':463,'multiline':False]['text':'     block1():','line_number':464,'multiline':False]['text':'       -> (%1, %y.1, %7)','line_number':465,'multiline':False]['text':'   ...','line_number':466,'multiline':False]['text':' Check if the input to ONNX If node is node Bool, and insert','line_number':477,'multiline':False]['text':' cast to Bool if needed.','line_number':478,'multiline':False]['text':' Infer shape and type for subblock outputs','line_number':488,'multiline':False]['text':' If both subblocks have an uninitialized output, shape and type cannot','line_number':495,'multiline':False]['text':' be inferred.','line_number':496,'multiline':False]['text':' Both branches produce ListType without tensor shape.','line_number':578,'multiline':False]['text':' Both branches produce OptionalType without tensor shape.','line_number':599,'multiline':False]['text':' Both branches produce OptionalType without tensor shape.','line_number':608,'multiline':False]['text':' Both branches output types must match.','line_number':654,'multiline':False]['text':' inputs (0, 1) are (i, cond), remainder are carried outputs.','line_number':705,'multiline':False]['text':' Handle the case where a block input is Optional but the','line_number':715,'multiline':False]['text':' output is not (i.e. if the loop executes > 0 times, the','line_number':716,'multiline':False]['text':' output will not be None).','line_number':717,'multiline':False]['text':' scan output, should be a Tensor type','line_number':724,'multiline':False]['text':' namespace jit','line_number':748,'multiline':False]['text':' namespace torch','line_number':749,'multiline':False]