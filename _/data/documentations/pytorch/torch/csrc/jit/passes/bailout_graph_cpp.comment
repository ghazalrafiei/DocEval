['text':' capture `old_value` into the bailout graph','line_number':28,'multiline':False]['text':' by creating a new input and mapping','line_number':29,'multiline':False]['text':' `old_value` to it','line_number':30,'multiline':False]['text':' this reduces the number of inputs to a bailout graph significantly','line_number':33,'multiline':False]['text':' making it easier to debug','line_number':34,'multiline':False]['text':' buildBailOutBlockFrom builds a bailout graph from','line_number':85,'multiline':False]['text':' a given node `n` until the end of the owning block','line_number':86,'multiline':False]['text':' If `n` belongs to `prim::If` or `prim::Loop`','line_number':87,'multiline':False]['text':' buildBailOutLoop/If continue','line_number':88,'multiline':False]['text':' from block's owning node (e.g. `prim::If` or','line_number':89,'multiline':False]['text':' `prim::Loop`)','line_number':90,'multiline':False]['text':' we are either in `prim::If` or `prim::Loop`','line_number':97,'multiline':False]['text':' bailout graph building will continue from `outer_node` next','line_number':98,'multiline':False]['text':' subtract the number of iterations','line_number':128,'multiline':False]['text':' We need to be careful when mapping `block_outputs` to continuation','line_number':137,'multiline':False]['text':' loop's inputs since `cloneFrom` will replace `%4` with the same value','line_number':138,'multiline':False]['text':' in both, `prim::Loop` and `aten::cat` in the example below:','line_number':139,'multiline':False]['text':'','line_number':140,'multiline':False]['text':' ... : Tensor = prim::Loop(%MAX_TRIP_COUNT, %COND, ..., %4)','line_number':141,'multiline':False]['text':'   block0(%i.2 : int, ...):','line_number':142,'multiline':False]['text':'     ...','line_number':143,'multiline':False]['text':'     %y.5 : Double(3) = aten::cat(%22, %4)','line_number':144,'multiline':False]['text':'     ...','line_number':145,'multiline':False]['text':'','line_number':146,'multiline':False]['text':' However for the cloned loop node, the values should be different.','line_number':147,'multiline':False]['text':' Namely, the value in `prim::Loop` should come from','line_number':148,'multiline':False]['text':' `lv.bodyBlock()->outputs()` which are mapped to the outputs of the','line_number':149,'multiline':False]['text':' current iteration whereas `%4` in `aten::cat` needs to be mapped to the','line_number':150,'multiline':False]['text':' cloned value of `%4` in a bailout graph. To work around this, we manually','line_number':151,'multiline':False]['text':' clone loop nodes','line_number':152,'multiline':False]['text':' map the residual loop's inputs to the outputs of the current iteration','line_number':154,'multiline':False]['text':' (i.e. `block_outputs`)','line_number':155,'multiline':False]['text':' clone the loop body and map old loop's outputs to new loop's outputs','line_number':164,'multiline':False]['text':' `one` will be replaced with new_lv.currentTripCount()','line_number':175,'multiline':False]['text':' but it needs to be done after','line_number':176,'multiline':False]['text':' new_lv.currentTripCount()->replaceAllUsesWith(adj_iter_ctr);','line_number':177,'multiline':False]['text':' to avoid cyclical references','line_number':178,'multiline':False]['text':' add graph inputs for guard's input','line_number':198,'multiline':False]['text':' and loop counts for loops `n` is contained in','line_number':199,'multiline':False]['text':' to make sure we can line bailout grap's inputs up properly','line_number':200,'multiline':False]['text':' with arguments to this BailOut node.','line_number':201,'multiline':False]['text':' add graph outputs','line_number':207,'multiline':False]['text':' `BailOutInserter` replaces prim::Guard nodes with','line_number':220,'multiline':False]['text':' prim::BailOut nodes that allow interpreter to','line_number':221,'multiline':False]['text':' resume execution of the unoptimized(deoptimized)','line_number':222,'multiline':False]['text':' version of an original graph from a particular point','line_number':223,'multiline':False]['text':' embed a full original graph','line_number':232,'multiline':False]['text':' Packs the original unoptimized graph into a Function constant','line_number':236,'multiline':False]['text':' and add it as the first input to every prim::BailOut point','line_number':237,'multiline':False]['text':' This graph will be used to compute a bailout graph for','line_number':238,'multiline':False]['text':' any given bailout point','line_number':239,'multiline':False]['text':' Returns an int so that we have an easy way to do graph traversal','line_number':245,'multiline':False]['text':' Removes guards by hooking up the guarded tensor','line_number':253,'multiline':False]['text':' directly to its users and also clears','line_number':254,'multiline':False]['text':' profiling information on it.','line_number':255,'multiline':False]['text':' this will need to be profiled again','line_number':259,'multiline':False]['text':' destroy the guard','line_number':261,'multiline':False]['text':' replace each prim::Guard','line_number':272,'multiline':False]['text':' with its corresponding prim::BailOut','line_number':273,'multiline':False]['text':' Inserts prim::BailOut nodes for every prim::Guard','line_number':282,'multiline':False]['text':' Each BailOut point takes the set of inputs live','line_number':283,'multiline':False]['text':' at that particular execution point.','line_number':284,'multiline':False]['text':' An input is live if it's used beyond the guard/BailOut','line_number':285,'multiline':False]['text':' point to compute graph's outputs','line_number':286,'multiline':False]['text':' guarded inputs come first','line_number':295,'multiline':False]['text':' currently, there's always one guarded input','line_number':296,'multiline':False]['text':' Guarded inputs have already been added','line_number':299,'multiline':False]['text':' Also, skip some inputs that BailOutGraphBuilder can','line_number':300,'multiline':False]['text':' materialize into bailout graphs directly','line_number':301,'multiline':False]['text':' we can't immediately replace nodes since this action will corrupt','line_number':310,'multiline':False]['text':' the liveness sets of following BailOut nodes if any of their','line_number':311,'multiline':False]['text':' arguments are BailOut nodes themselves','line_number':312,'multiline':False]['text':' linearly scans through graph's nodes to locate prim::BailOut whose','line_number':336,'multiline':False]['text':' index matches the given `index`','line_number':337,'multiline':False]['text':' Removes prim::BailOuts and hooks the guarded input directly','line_number':353,'multiline':False]['text':' to its users','line_number':354,'multiline':False]['text':' clear profiling information','line_number':358,'multiline':False]['text':' see `bailout_graph.h`','line_number':370,'multiline':False]['text':' namespace jit','line_number':397,'multiline':False]['text':' namespace torch','line_number':398,'multiline':False]