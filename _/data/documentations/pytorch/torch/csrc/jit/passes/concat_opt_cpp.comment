['text':' Save the input list and the current cat node, so that this can be','line_number':68,'multiline':False]['text':' used for subsequent cat nodes, unless there are writes to this cat','line_number':69,'multiline':False]['text':' node. When there are writes to this cat node, its output does not','line_number':70,'multiline':False]['text':' represent this concatenated list beyond the writes. Currently, we do','line_number':71,'multiline':False]['text':' not perform such fine-grained analysis. So, if there are any writes to','line_number':72,'multiline':False]['text':' the output, we do not use this cat node for optimization here.','line_number':73,'multiline':False]['text':' The case when concat has 2 input tensors could only be optimized if','line_number':79,'multiline':False]['text':' there is another concat of the exact same 2 input tensors. That case','line_number':80,'multiline':False]['text':' is expected to be handled by the CSE pass.','line_number':81,'multiline':False]['text':' Now, we check if the first N-1 elements in %inputs appeared in any of','line_number':85,'multiline':False]['text':' the previous cat ops.','line_number':86,'multiline':False]['text':'','line_number':87,'multiline':False]['text':' Example:','line_number':88,'multiline':False]['text':'    %11 = prim::VarConcat(%0, %1, <dim>)','line_number':89,'multiline':False]['text':'    ...','line_number':90,'multiline':False]['text':'    %13 = prim::VarConcat(%0, %1, %2, <dim>) // first 2 inputs same as %11','line_number':91,'multiline':False]['text':'    ...','line_number':92,'multiline':False]['text':'        = %13 ... // Use %13','line_number':93,'multiline':False]['text':'','line_number':94,'multiline':False]['text':' After CSE opt:','line_number':95,'multiline':False]['text':'    %11 = prim::VarConcat(%0, %1, <dim>)','line_number':96,'multiline':False]['text':'    ...','line_number':97,'multiline':False]['text':'    %14 = prim::VarConcat(%11, %2, <dim>) // Replace first 2 inputs','line_number':98,'multiline':False]['text':'                                          // with %11','line_number':99,'multiline':False]['text':'    ...','line_number':100,'multiline':False]['text':'        = %14 ... // Replace use of %13 with %14','line_number':101,'multiline':False]['text':' We can't use the previous concatenated output if it does not','line_number':113,'multiline':False]['text':' dominate the current concat node.','line_number':114,'multiline':False]['text':' Now, we check if the last N-1 elements in %inputs appeared in any of','line_number':128,'multiline':False]['text':' the previous cat ops.','line_number':129,'multiline':False]['text':'','line_number':130,'multiline':False]['text':' Example:','line_number':131,'multiline':False]['text':'    %10 = prim::ListConstruct(%1, %2)','line_number':132,'multiline':False]['text':'    %11 = aten::cat(%10, ...)','line_number':133,'multiline':False]['text':'    ...','line_number':134,'multiline':False]['text':'    %12 = prim::ListConstruct(%0, %1, %2)  // last 2 inputs same as %11','line_number':135,'multiline':False]['text':'    %13 = aten::cat(%12, ...)','line_number':136,'multiline':False]['text':'    ...','line_number':137,'multiline':False]['text':'        = %13 ... // Use %13','line_number':138,'multiline':False]['text':'','line_number':139,'multiline':False]['text':' After CSE opt:','line_number':140,'multiline':False]['text':'    %10 = prim::ListConstruct(%0, %1)','line_number':141,'multiline':False]['text':'    %11 = aten::cat(%10, ...)','line_number':142,'multiline':False]['text':'    ...','line_number':143,'multiline':False]['text':'    %12 = prim::ListConstruct(%0, %11) // Replace last 2 inputs with %11','line_number':144,'multiline':False]['text':'    %13 = aten::cat(%12, ...)','line_number':145,'multiline':False]['text':'    ...','line_number':146,'multiline':False]['text':'        = %13 ... // Use %13','line_number':147,'multiline':False]['text':' We can't use the previous concatenated list if it does not','line_number':158,'multiline':False]['text':' dominate the current list.','line_number':159,'multiline':False]['text':' Do we need to handle other cases where N-2 or lesser elements from','line_number':173,'multiline':False]['text':' %inputs appear in any of the previous cat ops?','line_number':174,'multiline':False]['text':' TODO.','line_number':175,'multiline':False]['text':' Replace the list nodes that have been marked.','line_number':179,'multiline':False]['text':' namespace','line_number':209,'multiline':False]['text':' Expand cat node into multiple copy nodes.','line_number':246,'multiline':False]['text':'','line_number':247,'multiline':False]['text':' Example:','line_number':248,'multiline':False]['text':'     %2 = aten::clamp(%0, ...)','line_number':249,'multiline':False]['text':'     %3 = aten::clamp(%1, ...)','line_number':250,'multiline':False]['text':'     %10 = prim::ListConstruct(%2, %3)','line_number':251,'multiline':False]['text':'     %11 = aten::cat(%10, ...)','line_number':252,'multiline':False]['text':'     ...','line_number':253,'multiline':False]['text':'         = %11 ... // Use %11','line_number':254,'multiline':False]['text':'','line_number':255,'multiline':False]['text':' After expanding cat:','line_number':256,'multiline':False]['text':'     %2 = aten::clamp(%0, ...)','line_number':257,'multiline':False]['text':'     %3 = aten::clamp(%1, ...)','line_number':258,'multiline':False]['text':'     %20 = aten::empty(...)          // cat output buffer','line_number':259,'multiline':False]['text':'     %21 = aten::slice(%20, ...)     // slice for %2','line_number':260,'multiline':False]['text':'     %22 = aten::copy_(%21, %2)      // copy %2','line_number':261,'multiline':False]['text':'     %23 = aten::slice(%20, ...)     // slice for %3','line_number':262,'multiline':False]['text':'     %24 = aten::copy_(%23, %3)      // copy %3','line_number':263,'multiline':False]['text':'     ...','line_number':264,'multiline':False]['text':'         = %20 ... // Use %20 in place of %11','line_number':265,'multiline':False]['text':' Do not optimize cat nodes whose inputs are mutated in the graph.','line_number':268,'multiline':False]['text':' TODO: Improve this by checking if it is mutated in the graph region','line_number':269,'multiline':False]['text':' where this optimization is applied.','line_number':270,'multiline':False]['text':' Unknown form of input to `cat` op.','line_number':275,'multiline':False]['text':' Can't expand when shapes are not known for the `cat` op.','line_number':279,'multiline':False]['text':' Can't expand when shapes of the inputs to `cat` are not known.','line_number':284,'multiline':False]['text':' TODO: Handle non-contiguous Tensors.','line_number':288,'multiline':False]['text':' For example, how to handle the cases where the inputs are all channels','line_number':289,'multiline':False]['text':' last?','line_number':290,'multiline':False]['text':' Can't expand when cat dimension is not a constant.','line_number':294,'multiline':False]['text':' Set the insertion point to the current `cat` node.','line_number':300,'multiline':False]['text':' Insert the constants needed for the `cat` output buffer size.','line_number':305,'multiline':False]['text':' Create a list of int for `cat` output buffer size.','line_number':314,'multiline':False]['text':' Create an empty buffer to be used as `cat` output buffer.','line_number':318,'multiline':False]['text':' TODO: Handle tensors with different dtype, layout, device, memory','line_number':319,'multiline':False]['text':' format, etc.','line_number':320,'multiline':False]['text':' For every input to this `cat` node:','line_number':326,'multiline':False]['text':'   * Create a slice of `cat` output buffer.','line_number':327,'multiline':False]['text':' Create a slice of the cat output buffer that correspond to','line_number':333,'multiline':False]['text':' this input size and position in the output.','line_number':334,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-narrowing-conversions,cppcoreguidelines-narrowing-conversions)','line_number':340,'multiline':False]['text':' Insert a copy from this input to the output slice.','line_number':350,'multiline':False]['text':' Replace the uses of `cat` node with the cat output buffer.','line_number':360,'multiline':False]['text':' TODO: Relax the checks to support dynamic shapes','line_number':377,'multiline':False]['text':' In order to move a node before another node, we need to move','line_number':406,'multiline':False]['text':' all the nodes it depends on as well.','line_number':407,'multiline':False]['text':' Reuse buffers in copies wherever possible.','line_number':414,'multiline':False]['text':'','line_number':415,'multiline':False]['text':' For example, consider the following sequence of ops:','line_number':416,'multiline':False]['text':'     %10 = prim::ListConstruct(%0, %1)','line_number':417,'multiline':False]['text':'     %11 = aten::cat(%10, ...)','line_number':418,'multiline':False]['text':'     ...','line_number':419,'multiline':False]['text':'     %12 = prim::ListConstruct(%11, %2)  // Uses the result of above cat','line_number':420,'multiline':False]['text':'     %13 = aten::cat(%12, ...)','line_number':421,'multiline':False]['text':'','line_number':422,'multiline':False]['text':' Once these cat ops are expanded into copies, we will have two buffers; one','line_number':423,'multiline':False]['text':' for %11 and another for %13. This can be optimized by using only one','line_number':424,'multiline':False]['text':' buffer. We can only have the buffer that represents %13 and use a view','line_number':425,'multiline':False]['text':' (slice) of that one as the buffer for %11.','line_number':426,'multiline':False]['text':'','line_number':427,'multiline':False]['text':' If any of the copies added earlier has `aten::empty` as its source,','line_number':428,'multiline':False]['text':' those cases can be replaced with a single buffer.','line_number':429,'multiline':False]['text':'','line_number':430,'multiline':False]['text':' Example:','line_number':431,'multiline':False]['text':'     %20 = aten::empty(...)          // cat.1 output buffer','line_number':432,'multiline':False]['text':'     %21 = aten::slice(%20, ...)','line_number':433,'multiline':False]['text':'     %22 = aten::copy_(%21, %2)','line_number':434,'multiline':False]['text':'     %23 = aten::slice(%20, ...)','line_number':435,'multiline':False]['text':'     %24 = aten::copy_(%23, %3)','line_number':436,'multiline':False]['text':'     ...','line_number':437,'multiline':False]['text':'     %30 = aten::empty(...)          // cat.2 output buffer','line_number':438,'multiline':False]['text':'     %31 = aten::slice(%30, ...)','line_number':439,'multiline':False]['text':'     %32 = aten::copy_(%31, %20)     // src of copy is aten::empty','line_number':440,'multiline':False]['text':'                                     // so, we reuse this buffer above','line_number':441,'multiline':False]['text':'     %33 = aten::slice(%30, ...)','line_number':442,'multiline':False]['text':'     %34 = aten::copy_(%33, %4)','line_number':443,'multiline':False]['text':'','line_number':444,'multiline':False]['text':' After reusing copy buffers:','line_number':445,'multiline':False]['text':'     %30 = aten::empty(...)          // cat.2 output buffer','line_number':446,'multiline':False]['text':'     %31 = aten::slice(%30, ...)     // move %31 and inputs before %20','line_number':447,'multiline':False]['text':'     %21 = aten::slice(%31, ...)     // use %31 in place of %20','line_number':448,'multiline':False]['text':'     %22 = aten::copy_(%21, %2)','line_number':449,'multiline':False]['text':'     %23 = aten::slice(%31, ...)     // use %31 in place of %20','line_number':450,'multiline':False]['text':'     %24 = aten::copy_(%23, %3)','line_number':451,'multiline':False]['text':'     ...','line_number':452,'multiline':False]['text':'     ...                             // copy to %31 is now removed','line_number':453,'multiline':False]['text':'     %33 = aten::slice(%30, ...)','line_number':454,'multiline':False]['text':'     %34 = aten::copy_(%33, %4)','line_number':455,'multiline':False]['text':' Move the destination node before the source.','line_number':464,'multiline':False]['text':' namespace','line_number':495,'multiline':False]['text':' Given a concat node, see if it can be optimized with another.','line_number':536,'multiline':False]['text':' If so, add a CombinablePair to combinable_concats_.','line_number':537,'multiline':False]['text':' We need to be able to determine dim statically to match it with another','line_number':543,'multiline':False]['text':' concat.','line_number':544,'multiline':False]['text':' Check that the input of this node is an unmodified list construct','line_number':550,'multiline':False]['text':' Check that the only output of this node is used in an unmodified list','line_number':556,'multiline':False]['text':' construct.','line_number':557,'multiline':False]['text':' Dimension must be determined statically and match the one we've already','line_number':576,'multiline':False]['text':' seen.','line_number':577,'multiline':False]['text':' Construct a map (concat node) -> (new list inputs for this node).','line_number':606,'multiline':False]['text':' std::deque is used so we can do O(1) insertions to the front.','line_number':607,'multiline':False]['text':' Combine the list inputs of first_concat with those of second_concat','line_number':611,'multiline':False]['text':' We're moving all inputs to second_concat.','line_number':618,'multiline':False]['text':' If cur_list is not empty, it's guaranteed to already contain all of','line_number':625,'multiline':False]['text':' first_concat's inputs.','line_number':626,'multiline':False]['text':' Represents an optimizable pair of concat nodes.','line_number':667,'multiline':False]['text':' - first_concat must appear before second_concat','line_number':668,'multiline':False]['text':' - idx is the index where first_concat's inputs must be inserted into','line_number':669,'multiline':False]['text':'   second_concat's new inputs.','line_number':670,'multiline':False]['text':' Example:','line_number':671,'multiline':False]['text':'    %inputs.1 = prim::ListConstruct(%0, %0)','line_number':672,'multiline':False]['text':'    %concat.1 = aten::cat(%inputs.1, %dim)','line_number':673,'multiline':False]['text':'    %inputs.2 = prim::ListConstruct(%1, %concat.1, %1)','line_number':674,'multiline':False]['text':'    %concat.2 = aten::cat(%inputs.2, %dim)','line_number':675,'multiline':False]['text':' -> first_concat = &concat.1, second_concat = &concat.2, idx = 1','line_number':676,'multiline':False]['text':' namespace','line_number':692,'multiline':False]['text':' namespace jit','line_number':700,'multiline':False]['text':' namespace torch','line_number':701,'multiline':False]