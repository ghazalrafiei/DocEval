['text':' 1. number of outputs is restricted to 1.','line_number':19,'multiline':False]['text':' 2. output is only used by prim::ListUnpack.','line_number':20,'multiline':False]['text':' Fuse node + ListUnpack','line_number':34,'multiline':False]['text':' Node such as split/unbind produces tensor[] of static size,','line_number':35,'multiline':False]['text':' that is later unpacked by ListUnpack.','line_number':36,'multiline':False]['text':' This pass fuses the two nodes, and adds an additional input "_outputs" such','line_number':37,'multiline':False]['text':' that the symbolic function is aware of the number of outputs.','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':' Example IR','line_number':40,'multiline':False]['text':'  split.Tensor(Tensor(a -> *) self, int split_size, int dim=0) -> Tensor[]','line_number':41,'multiline':False]['text':'  split_with_sizes(Tensor self, int[] split_sizes, int dim=0) -> Tensor[]','line_number':42,'multiline':False]['text':'','line_number':43,'multiline':False]['text':' graph(%input : Float(5, 4, 3, strides=[12, 3, 1])):','line_number':44,'multiline':False]['text':'   %13 : int[] = prim::Constant[value=[2, 1, 2]]()','line_number':45,'multiline':False]['text':'   %7 : int = prim::Constant[value=0]()','line_number':46,'multiline':False]['text':'   %8 : Tensor[] = aten::split_with_sizes(%input, %13, %7)','line_number':47,'multiline':False]['text':'   %9 : Float(2, 4, 3, strides=[12, 3, 1]), %10 : Float(1, 4, 3, strides=[12,','line_number':48,'multiline':False]['text':'   3, 1]), %11 : Float(2, 4, 3, strides=[12, 3, 1]) = prim::ListUnpack(%8)','line_number':49,'multiline':False]['text':'   return (%9, %10, %11)','line_number':50,'multiline':False]['text':'','line_number':51,'multiline':False]['text':' After fusion','line_number':52,'multiline':False]['text':' graph(%input : Float(5, 4, 3, strides=[12, 3, 1])):','line_number':53,'multiline':False]['text':'   %13 : int[] = prim::Constant[value=[2, 1, 2]]()','line_number':54,'multiline':False]['text':'   %7 : int = prim::Constant[value=0]()','line_number':55,'multiline':False]['text':'   %8 : int = prim::Constant[value=3]()  # Adding additional input of value 3','line_number':56,'multiline':False]['text':'      representing the number of outputs.','line_number':57,'multiline':False]['text':'   %14 : Float(2, 4, 3, strides=[12, 3, 1]), %15 : Float(1, 4, 3, strides=[12,','line_number':58,'multiline':False]['text':'      3, 1]), %16 : Float(2, 4, 3, strides=[12, 3, 1] =','line_number':59,'multiline':False]['text':'      aten::split_with_sizes(%input, %13, %7, %8) return (%14, %15, %16)','line_number':60,'multiline':False]['text':' 1. Add internal input "_outputs" to node, so that later symbolic function','line_number':70,'multiline':False]['text':'    conversion is aware of the number of outputs.','line_number':71,'multiline':False]['text':' 2. Add the exact number of outputs to n, copy metadata and replace uses of','line_number':72,'multiline':False]['text':'    listUnpack outputs.','line_number':73,'multiline':False]['text':' remove original output, which is input to listUnpack node.','line_number':83,'multiline':False]['text':' Replace aten::add with onnx::Concat','line_number':112,'multiline':False]['text':' when inputs to the add node are two int lists','line_number':113,'multiline':False]['text':'','line_number':114,'multiline':False]['text':' before the pass:','line_number':115,'multiline':False]['text':' graph(%x.1 : Float(2, 3, 4, strides=[12, 4, 1], requires_grad=0, device=cpu),','line_number':116,'multiline':False]['text':'  %y.1 : Float(1, 2, 3, strides=[6, 3, 1], requires_grad=0, device=cpu)):','line_number':117,'multiline':False]['text':'  %2 : None = prim::Constant()','line_number':118,'multiline':False]['text':'  %3 : int[] = aten::size(%x.1)','line_number':119,'multiline':False]['text':'  %l1.1 : int[] = aten::list(%3','line_number':120,'multiline':False]['text':'  %5 : int[] = aten::size(%y.1)','line_number':121,'multiline':False]['text':'  %l2.1 : int[] = aten::list(%5)','line_number':122,'multiline':False]['text':'  %7 : int[] = aten::add(%l1.1, %l2.1)','line_number':123,'multiline':False]['text':'  %8 : Tensor = aten::new_zeros(%x.1, %7, %2, %2, %2, %2)','line_number':124,'multiline':False]['text':'  return (%8)','line_number':125,'multiline':False]['text':'','line_number':126,'multiline':False]['text':' after the pass:','line_number':127,'multiline':False]['text':' graph(%x.1 : Float(2, 3, 4, strides=[12, 4, 1], requires_grad=0, device=cpu),','line_number':128,'multiline':False]['text':'  %y.1 : Float(1, 2, 3, strides=[6, 3, 1], requires_grad=0, device=cpu)):','line_number':129,'multiline':False]['text':'  %2 : None = prim::Constant()','line_number':130,'multiline':False]['text':'  %3 : int[] = aten::size(%x.1)','line_number':131,'multiline':False]['text':'  %l1.1 : int[] = aten::list(%3)','line_number':132,'multiline':False]['text':'  %5 : int[] = aten::size(%y.1)','line_number':133,'multiline':False]['text':'  %l2.1 : int[] = aten::list(%5)','line_number':134,'multiline':False]['text':'  %9 : Tensor = onnx::Concat[axis=0](%l1.1, %l2.1)','line_number':135,'multiline':False]['text':'  %8 : Tensor = aten::new_zeros(%x.1, %9, %2, %2, %2, %2)','line_number':136,'multiline':False]['text':'  return (%8)','line_number':137,'multiline':False]['text':' This pass also covers the case when the input to ListUnpack','line_number':167,'multiline':False]['text':' is int[] coming from some other op than ListConstruct (like Slice or Shape)','line_number':168,'multiline':False]['text':'','line_number':169,'multiline':False]['text':' before the pass','line_number':170,'multiline':False]['text':' graph(%x.1 : Float(2, 3, strides=[3, 1], requires_grad=0, device=cpu)):','line_number':171,'multiline':False]['text':'   %1 : None = prim::Constant()','line_number':172,'multiline':False]['text':'   %2 : int[] = aten::size(%x.1)','line_number':173,'multiline':False]['text':'   %a.1 : int, %b.1 : int = prim::ListUnpack(%2)','line_number':174,'multiline':False]['text':'   %5 : int[] = prim::ListConstruct(%a.1, %b.1)','line_number':175,'multiline':False]['text':'   %6 : Tensor = aten::new_zeros(%x.1, %5, %1, %1, %1, %1)','line_number':176,'multiline':False]['text':'','line_number':177,'multiline':False]['text':' after the pass:','line_number':178,'multiline':False]['text':' graph(%x.1 : Float(2, 3, strides=[3, 1], requires_grad=0, device=cpu)):','line_number':179,'multiline':False]['text':'   %1 : None = prim::Constant()','line_number':180,'multiline':False]['text':'   %2 : int[] = aten::size(%x.1)','line_number':181,'multiline':False]['text':'   %7 : Tensor = onnx::Constant[value={0}]()','line_number':182,'multiline':False]['text':'   %8 : Tensor = onnx::Gather(%2, %7)','line_number':183,'multiline':False]['text':'   %9 : Tensor = onnx::Constant[value={1}]()','line_number':184,'multiline':False]['text':'   %10 : Tensor = onnx::Gather(%2, %9)','line_number':185,'multiline':False]['text':'   %a.1 : int, %b.1 : int = prim::ListUnpack(%2)','line_number':186,'multiline':False]['text':'   %5 : int[] = prim::ListConstruct(%8, %10)','line_number':187,'multiline':False]['text':'   %6 : Tensor = aten::new_zeros(%x.1, %5, %1, %1, %1, %1)','line_number':188,'multiline':False]['text':' namespace','line_number':221,'multiline':False]['text':' namespace jit','line_number':232,'multiline':False]['text':' namespace torch','line_number':233,'multiline':False]