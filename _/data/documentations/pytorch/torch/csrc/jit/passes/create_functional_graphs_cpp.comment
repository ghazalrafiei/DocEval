['text':' TODO: more sane strategy','line_number':22,'multiline':False]['text':' First, analyze the functional subset of the graph, and then create','line_number':25,'multiline':False]['text':' functional graphs. The graph gets mutated when we create functional','line_number':26,'multiline':False]['text':' subgraphs, invalidating the AliasDb, so we need to do our analysis','line_number':27,'multiline':False]['text':' first.','line_number':28,'multiline':False]['text':'
    Iterate the block in reverse and create FunctionalSubgraphs.
    When we encounter a node that isn't functional, we skip it. Otherwise,
    we try to merge the functional node into the current functional subgraph.
    If it can't be merged into the current functional subgraph node, then we
    start a functional subgraph group.
    ','line_number':70,'multiline':True]['text':' constants get copied into the graph','line_number':88,'multiline':False]['text':' if `n` is functional, all of its blocks will be merged into the','line_number':93,'multiline':False]['text':' new functional subgraph, so we only need to recurse if it is not','line_number':94,'multiline':False]['text':' functional','line_number':95,'multiline':False]['text':' TODO: clarify hasSideEffects, isNondeterministic','line_number':132,'multiline':False]['text':' Functional Graphs are not responsible for maintaining aliasing','line_number':135,'multiline':False]['text':' relationships. If an output of a functional graph escapes scope','line_number':136,'multiline':False]['text':' or is mutated then we might change semantics of the program if','line_number':137,'multiline':False]['text':' aliasing relationships are changed.','line_number':138,'multiline':False]['text':' We don't allow any node in the functional graph to output a value','line_number':139,'multiline':False]['text':' that escapes scope or is mutated, and we don't allow any mutating nodes','line_number':140,'multiline':False]['text':' into the graph.','line_number':141,'multiline':False]['text':' - allow functional graphs to have at most one value that can escape scope','line_number':142,'multiline':False]['text':' - allow outputs which alias the wildcard set but do not "re-escape"','line_number':143,'multiline':False]['text':' block inputs will not yet have been iterated through,','line_number':173,'multiline':False]['text':' so we need to add them to our set of mutated & escape values.','line_number':174,'multiline':False]['text':' if a block output is not functional, then the corresponding output for','line_number':181,'multiline':False]['text':' the node that contains the block will not be functional either, so we do','line_number':182,'multiline':False]['text':' not need to analyze the block outputs here.','line_number':183,'multiline':False]['text':' namespace','line_number':211,'multiline':False]['text':' Run Constant Pooling so constants get hoisted','line_number':214,'multiline':False]['text':' Creation of Functional Subgraphs & Deinlining creates excess constants','line_number':218,'multiline':False]['text':' namespace jit','line_number':226,'multiline':False]['text':' namespace torch','line_number':227,'multiline':False]