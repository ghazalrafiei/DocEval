['text':' A CompilationUnit is a list of named Functions','line_number':40,'multiline':False]['text':' with helper methods to iterate the list or invoke the function.','line_number':41,'multiline':False]['text':' Classes have a CompilationUnit holding the class methods,','line_number':42,'multiline':False]['text':' and Modules have a CompilationUnit holding the Functions that','line_number':43,'multiline':False]['text':' are used to implement their Methods','line_number':44,'multiline':False]['text':' constructor that takes a set of functions to compile using the native','line_number':48,'multiline':False]['text':' resolver','line_number':49,'multiline':False]['text':' for historic reasons, these are defined in ir_emitter.cpp','line_number':86,'multiline':False]['text':' Returns the list of Functions just defined.','line_number':87,'multiline':False]['text':' determines how we handle free
                     variables in each definition','line_number':94,'multiline':True]['text':' if non-null, the first argument to each def, is bound to this value','line_number':96,'multiline':False]['text':' see [name mangling]','line_number':98,'multiline':False]['text':' same as above but parse the definitions from source','line_number':111,'multiline':False]['text':' Returns the list of Functions just defined.','line_number':112,'multiline':False]['text':' prefix namespace to put all the defined functions into','line_number':114,'multiline':False]['text':'/ Run a method from this compilation.','line_number':146,'multiline':False]['text':'/','line_number':147,'multiline':False]['text':'/ For example:','line_number':148,'multiline':False]['text':'/ @code','line_number':149,'multiline':False]['text':'/   IValue output = module->run("relu_script", a, b);','line_number':150,'multiline':False]['text':'/ @endcode','line_number':151,'multiline':False]['text':'/','line_number':152,'multiline':False]['text':'/ To get a compile a module from a source string, see torch::jit::compile','line_number':153,'multiline':False]['text':'/','line_number':154,'multiline':False]['text':'/ @param method_name The name of the method to run','line_number':155,'multiline':False]['text':'/ @param args Arguments to be passed to the method','line_number':156,'multiline':False]['text':'/ @return An IValue containing the return value (or values if it is a tuple)','line_number':157,'multiline':False]['text':'/ from the method','line_number':158,'multiline':False]['text':'*
   * Register a class as being owned by this compilation unit.
   ','line_number':169,'multiline':True]['text':' TODO: class types cannot be redefined because we have no way right now','line_number':173,'multiline':False]['text':' of invalidating their methods. NamedTuples are fine though, since they','line_number':174,'multiline':False]['text':' don't have methods.','line_number':175,'multiline':False]['text':' For testing: clear all Python-defined classes to ensure that unit tests','line_number':218,'multiline':False]['text':' have isolation.','line_number':219,'multiline':False]['text':' Delete all the associated class methods','line_number':221,'multiline':False]['text':' Tombstone the method in the compilation unit.','line_number':225,'multiline':False]['text':' Don't erase because the dict_','line_number':226,'multiline':False]['text':' Erase in our big lookup table','line_number':230,'multiline':False]['text':' Classes can have multiple pointers to the same hook,','line_number':234,'multiline':False]['text':' need to make sure to not delete it twice','line_number':235,'multiline':False]['text':' Tombstone the hook in the compilation unit.','line_number':244,'multiline':False]['text':' Erase in our big lookup table','line_number':248,'multiline':False]['text':' [Internal Only] Remove method.','line_number':258,'multiline':False]['text':' Note Used for freezing.','line_number':259,'multiline':False]['text':' [name mangling] All code objects must have a unique qualified name in a','line_number':271,'multiline':False]['text':' CompilationUnit. In Python, sometimes functions won't have unique qualified','line_number':272,'multiline':False]['text':' name (for example, nested functions). So we mangle Python functions to','line_number':273,'multiline':False]['text':' ensure that they are uniquely named.','line_number':274,'multiline':False]['text':'','line_number':275,'multiline':False]['text':' We also use mangling to distinguish different Module instances. Since each','line_number':276,'multiline':False]['text':' Module is a singleton class instance, different instances of the same','line_number':277,'multiline':False]['text':' Python Module will have different types but the same qualified name.','line_number':278,'multiline':False]['text':' Define a property on \p self.','line_number':298,'multiline':False]['text':' for fast lookup','line_number':319,'multiline':False]['text':' [class ownership] Right now there are two relationships between classes','line_number':323,'multiline':False]['text':' and compilation units:','line_number':324,'multiline':False]['text':' 1. Classes have compilation units internally that hold their methods.','line_number':325,'multiline':False]['text':' 2. On load, the TypePtrs of any imported classes are owned by the main','line_number':326,'multiline':False]['text':' module's compilation unit.','line_number':327,'multiline':False]['text':' An owning pointer to a Function. Just a pair of a raw Function ptr and it's','line_number':333,'multiline':False]['text':' owning CU. We need this because pybind requires a ref-counted way to refer to','line_number':334,'multiline':False]['text':' Functions.','line_number':335,'multiline':False]['text':' We once had a `script::` namespace that was deleted. This is for backcompat','line_number':347,'multiline':False]['text':' of the public API; new code should not use this type alias.','line_number':348,'multiline':False]['text':' namespace script','line_number':350,'multiline':False]['text':' namespace torch::jit','line_number':351,'multiline':False]