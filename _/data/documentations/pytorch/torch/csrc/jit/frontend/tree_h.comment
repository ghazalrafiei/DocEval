['text':' Trees are used to represent all forms of TC IR, pre- and post-typechecking.','line_number':15,'multiline':False]['text':' Rather than have a full class hierarchy for all TC statements, trees are a','line_number':16,'multiline':False]['text':' slight variation of Lisp s-expressions. For instance, the expression a*b+1','line_number':17,'multiline':False]['text':' is represented as:','line_number':18,'multiline':False]['text':' (+ (* (ident a) (ident b)) (const 1))','line_number':19,'multiline':False]['text':' Atoms like 'a', 'b', and '1' are represented by subclasses of Tree which','line_number':20,'multiline':False]['text':' define stringValue(). Everything else is a Compound object, which has a','line_number':21,'multiline':False]['text':' 'kind' that is a token from lexer.h's TokenKind enum. Single-character','line_number':22,'multiline':False]['text':' operators like '+' are represented using the character itself (so, add.kind()','line_number':23,'multiline':False]['text':' would be '+'). Each Compound object also contains a list of subtrees and is','line_number':24,'multiline':False]['text':' associated with a SourceRange for error reporting.','line_number':25,'multiline':False]['text':' Memory management of trees is done using intrusive_ptr.','line_number':26,'multiline':False]['text':' we are creating a new pointer','line_number':55,'multiline':False]['text':' from a raw `this` pointer','line_number':56,'multiline':False]['text':' so we need to bump the refcount','line_number':57,'multiline':False]['text':' to account for this ownership','line_number':58,'multiline':False]['text':' tree pretty printer','line_number':167,'multiline':False]['text':' namespace jit','line_number':219,'multiline':False]['text':' namespace torch','line_number':220,'multiline':False]