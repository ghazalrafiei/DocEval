['text':' namespace','line_number':61,'multiline':False]['text':' When a comparison like x is None is made, we associate type refinements','line_number':87,'multiline':False]['text':' with its true value and its false value. If a boolean that has refinements','line_number':88,'multiline':False]['text':' associated with it is used in a conditional of an if statement, the true','line_number':89,'multiline':False]['text':' and false refinements are inserted into the corresponding blocks','line_number':90,'multiline':False]['text':' empty','line_number':101,'multiline':False]['text':' if the result of an AND is true, both a & b had to be true,','line_number':103,'multiline':False]['text':' so we take the union of a.true_refinements and b.true_refinements.','line_number':104,'multiline':False]['text':' if the result is false, either a or b could have been false,','line_number':105,'multiline':False]['text':' so we take their intersection.','line_number':106,'multiline':False]['text':' if the result of an OR is true, either a & b could have been true,','line_number':112,'multiline':False]['text':' so we take the intersection of a.true_refinements & b.true_refinements.','line_number':113,'multiline':False]['text':' if the result is false, both a and b had to be false,','line_number':114,'multiline':False]['text':' so we take their union.','line_number':115,'multiline':False]['text':' we only keep refinements when they exactly match one','line_number':142,'multiline':False]['text':' refinement type, for instance, we do not attempt to refine:','line_number':143,'multiline':False]['text':' isinstance(x, float) and isinstance(x, int)','line_number':144,'multiline':False]['text':' certain expression cause us to emit a static if statement','line_number':197,'multiline':False]['text':' this value is present if this is the case.','line_number':198,'multiline':False]['text':' this is not equivalent to value_ being a constant','line_number':199,'multiline':False]['text':' it is possible for value_ to be constant but for','line_number':200,'multiline':False]['text':' the expression that produced it to not trigger the','line_number':201,'multiline':False]['text':' static if behavior. e.g. use of a variable assigned','line_number':202,'multiline':False]['text':' to a constant','line_number':203,'multiline':False]['text':' Auxiliary data structure for desugaring variable binding into our always','line_number':232,'multiline':False]['text':' explicitly scoped language as we descend down nested control structures in','line_number':233,'multiline':False]['text':' the frontend (which themselves don't introduce scopes)','line_number':234,'multiline':False]['text':'','line_number':235,'multiline':False]['text':' The Environment keeps track of two tables, one for values which are not first','line_number':236,'multiline':False]['text':' class and a type table for values which are. When a first class value','line_number':237,'multiline':False]['text':' is set in the environment, we emit a prim::Store which sets the','line_number':238,'multiline':False]['text':' name of the variable to appropriate type, and when a first-class value is','line_number':239,'multiline':False]['text':' referenced we emit a prim::Load that generates a value of the appropriate','line_number':240,'multiline':False]['text':' type.','line_number':241,'multiline':False]['text':'','line_number':242,'multiline':False]['text':' a = 1','line_number':243,'multiline':False]['text':' print(a)','line_number':244,'multiline':False]['text':' becomes:','line_number':245,'multiline':False]['text':' = prim::Store[name="a"](%a.1)','line_number':246,'multiline':False]['text':' %a : int = prim::Load[name="a"]()','line_number':247,'multiline':False]['text':' prim::Print(%a)','line_number':248,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':261,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':263,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':265,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':267,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':270,'multiline':False]['text':' set type error in the lowest environment. if the variable is used after an','line_number':273,'multiline':False]['text':' error has been set, then we will use the more informative error message','line_number':274,'multiline':False]['text':' see if type error has been set for a variable','line_number':285,'multiline':False]['text':' note: type is not always the same as v->type(), e.g.','line_number':308,'multiline':False]['text':' type: Optional[Tensor]','line_number':309,'multiline':False]['text':' v->type(): Tensor','line_number':310,'multiline':False]['text':'annotated_type=','line_number':359,'multiline':True]['text':' note: if the value wasn't defined in this block, we might be giving a','line_number':370,'multiline':False]['text':' name only used inside this block to a value outside of this. this is','line_number':371,'multiline':False]['text':' not normally helpful for debugging and causes import/export jitter.','line_number':372,'multiline':False]['text':' prevent re-assignment involving any sugared values','line_number':376,'multiline':False]['text':' any reassignment like:','line_number':377,'multiline':False]['text':' a = ...','line_number':378,'multiline':False]['text':' while ...','line_number':379,'multiline':False]['text':'   a = ..','line_number':380,'multiline':False]['text':' requires 'a' to be first-class in the graph since its value depends on','line_number':381,'multiline':False]['text':' control flow','line_number':382,'multiline':False]['text':'allow_conversions=','line_number':409,'multiline':True]['text':' Special-cased error msg if we're trying to assign to a tensor list.','line_number':418,'multiline':False]['text':' check if this value was not emitted in an if statement because of a','line_number':457,'multiline':False]['text':' type mismatch. if it was, then we print a more informative error msg','line_number':458,'multiline':False]['text':' todo(zach): remove when we can correctly export torch.full via ONNX','line_number':498,'multiline':False]['text':' or we have implicit conversion that can convert numbers to tensors','line_number':499,'multiline':False]['text':' Only AssertionError is bound so that we can use it from emitAssert,','line_number':541,'multiline':False]['text':' all other exceptions should be resolved at the Python level','line_number':542,'multiline':False]['text':' Information for each def being emitted.','line_number':633,'multiline':False]['text':' Defs can be nested to support closures so we need a stack of this information','line_number':634,'multiline':False]['text':' Currently records information about the functions return type.','line_number':635,'multiline':False]['text':' nullptr if not annotated','line_number':637,'multiline':False]['text':' nullptr if a Return has not been seen yet','line_number':638,'multiline':False]['text':' method being constructed','line_number':663,'multiline':False]['text':'starts_def=','line_number':670,'multiline':True]['text':' Type annotations exclude explicitly typing the "self" parameter, so in','line_number':672,'multiline':False]['text':' the case that this is a method with self we expect one fewer parameter','line_number':673,'multiline':False]['text':' annotation than the number of parameters this Def takes.','line_number':674,'multiline':False]['text':' At this point, we might have received a graph that is compiled with','line_number':681,'multiline':False]['text':' old operator schemas that might not exist in the system anymore.','line_number':682,'multiline':False]['text':' Therefore, we replace such ops with its' valid upgrader.','line_number':683,'multiline':False]['text':' NB ORDERING: SSA conversion has to occur before','line_number':686,'multiline':False]['text':' lifting of closures and forks, this way closures are converted','line_number':687,'multiline':False]['text':' to SSA while part of their original graph, and closures are ready to','line_number':688,'multiline':False]['text':' be inlined into forked closures','line_number':689,'multiline':False]['text':' convert loops with an iter and body condition specified to','line_number':692,'multiline':False]['text':' python-recognize while loops. we do this so they can be exported,','line_number':693,'multiline':False]['text':' and run the pass early to avoid jitter. Like conversion to SSA,','line_number':694,'multiline':False]['text':' it only needs to run once.','line_number':695,'multiline':False]['text':' Convert Ops to a Normalized Form','line_number':698,'multiline':False]['text':' Singly-linked list of environments. This top element contains a member','line_number':719,'multiline':False]['text':' `next` that points to the most immediate enclosing scope's value.','line_number':720,'multiline':False]['text':' If the graph might not return, add an implicit None return at the end','line_number':744,'multiline':False]['text':' if we haven't seen any return statements, but the graph block exits','line_number':758,'multiline':False]['text':' (the function always throws) then we accept the declared return type if','line_number':759,'multiline':False]['text':' it exists or set it to none','line_number':760,'multiline':False]['text':' TODO need guards on init returning none','line_number':770,'multiline':False]['text':' body','line_number':777,'multiline':False]['text':' see [setstate type]','line_number':785,'multiline':False]['text':' see [setstate type]','line_number':805,'multiline':False]['text':' Do some additional basic validation that the __setstate__ func is','line_number':819,'multiline':False]['text':' well-formed','line_number':820,'multiline':False]['text':' for schema','line_number':835,'multiline':False]['text':' inputs','line_number':836,'multiline':False]['text':'annotated_type=','line_number':859,'multiline':True]['text':' [setstate type]','line_number':864,'multiline':False]['text':' __setstate__ is special, because if the user leaves it un-annotated we','line_number':865,'multiline':False]['text':' will derive the type for `state` from the output type of __getstate__.','line_number':866,'multiline':False]['text':' This is necessary so that we can allow submodules to appear in `state`.','line_number':867,'multiline':False]['text':' Add the input to the graph','line_number':872,'multiline':False]['text':' Record the type for the schema and set the Type on the Value*','line_number':877,'multiline':False]['text':' NB: set type of new_input before setVar call so the Store is','line_number':888,'multiline':False]['text':' typed appropriately','line_number':889,'multiline':False]['text':' handleMaybeNoReturn ensures that merged_return_type_ is always set','line_number':899,'multiline':False]['text':' in the ConvertToSSA pass, prim::ReturnStmts are lowered so that the','line_number':903,'multiline':False]['text':' correct return value is set. Until then, we have a correctly-typed','line_number':904,'multiline':False]['text':' placeholder return value. This is needed so that closures & graphs','line_number':905,'multiline':False]['text':' are correctly typed.','line_number':906,'multiline':False]['text':' XXX: Right now closures are not generically implemented and are only used','line_number':917,'multiline':False]['text':' as an intermediate form for special tasks, like defining gradients or','line_number':918,'multiline':False]['text':' forked functions.','line_number':919,'multiline':False]['text':'','line_number':920,'multiline':False]['text':' There are several unfinished aspects that make them unusable generally','line_number':921,'multiline':False]['text':' 1. We do not have a type, ivalue, operator to represent prim::Closure, so','line_number':922,'multiline':False]['text':' closure_node has type None','line_number':923,'multiline':False]['text':' 2. There is no export logic for it yet, so it cannot be','line_number':924,'multiline':False]['text':' exported/python_printed','line_number':925,'multiline':False]['text':' 3. There is nothing preventing the assignment of already existing variables','line_number':926,'multiline':False]['text':' inside the closures','line_number':927,'multiline':False]['text':'    the changes to those variables will just get forgotten.','line_number':928,'multiline':False]['text':' 4. There is no parsing support in frontend.py, this is intentional since it','line_number':929,'multiline':False]['text':'    prevents people from accidentally using this feature.','line_number':930,'multiline':False]['text':'','line_number':931,'multiline':False]['text':' This function leaves in the graph something like:','line_number':932,'multiline':False]['text':'','line_number':933,'multiline':False]['text':'   %2 : None = prim::Closure()','line_number':934,'multiline':False]['text':'     block0():','line_number':935,'multiline':False]['text':'       %1 : Tensor = prim::DoSomething(%0)','line_number':936,'multiline':False]['text':'       -> (%1)','line_number':937,'multiline':False]['text':'','line_number':938,'multiline':False]['text':' A separate pass is required to erase this closure and replace it with','line_number':939,'multiline':False]['text':' something actually executable (see liftClosure and inlineForkedClosure).','line_number':940,'multiline':False]['text':' it is not a real thing yet, so just say the type is None','line_number':944,'multiline':False]['text':'starts_def=','line_number':950,'multiline':True]['text':'ends_def=','line_number':952,'multiline':True]['text':' invoked once the closure block is set as the environment','line_number':958,'multiline':False]['text':' ignore schema return, we just wont use it for now','line_number':963,'multiline':False]['text':' since we never create a Method for the closure','line_number':964,'multiline':False]['text':'annotated_type=','line_number':971,'multiline':True]['text':' If val is a class instance, this is a method call to a type-specific','line_number':1017,'multiline':False]['text':' implementation of del defined in a __delitem__ method.','line_number':1018,'multiline':False]['text':' Use MethodValue to call the method to handle recursion.','line_number':1025,'multiline':False]['text':'check_if_removed=','line_number':1035,'multiline':True]['text':' nullptr if not annotated','line_number':1046,'multiline':False]['text':' result type is annotated, every return must convert to that type','line_number':1049,'multiline':False]['text':' this guard skips implicit conversion from None -> Tensor for the return','line_number':1051,'multiline':False]['text':' type. otherwise forgetting a return a function returning a tensor will','line_number':1052,'multiline':False]['text':' cause a None to be converted to a tensor.','line_number':1053,'multiline':False]['text':'allow_conversions=','line_number':1061,'multiline':True]['text':' If the annotated return type is Any and the result type is not Any,','line_number':1089,'multiline':False]['text':' cast the result to Any to facilitate type unification between return','line_number':1090,'multiline':False]['text':' statements on different code paths (e.g. different branches of an if,','line_number':1091,'multiline':False]['text':' body and containing scope of a loop).','line_number':1092,'multiline':False]['text':' Emit nothing for pass','line_number':1145,'multiline':False]['text':' Found an exit statement in this block. The remaining statements aren't','line_number':1160,'multiline':False]['text':' reachable so we don't emit them.','line_number':1161,'multiline':False]['text':' make 'None is var' into 'var is None'','line_number':1174,'multiline':False]['text':' statement must be var {is, is not} None','line_number':1180,'multiline':False]['text':' While it should in theory be possible to specialize','line_number':1182,'multiline':False]['text':' the `x is None` to know x has type NoneType, we have previously','line_number':1183,'multiline':False]['text':' not done this. Unfortunately, doing this will make the type None','line_number':1184,'multiline':False]['text':' propagate further in all loaded models. The handling of','line_number':1185,'multiline':False]['text':' unwrap_optional will fail in these cases since export did','line_number':1186,'multiline':False]['text':' not expect that the input would be none and an unannotated None.','line_number':1187,'multiline':False]['text':' To enable this, we need to (1) implement a real casting operator','line_number':1188,'multiline':False]['text':' annotated(T, X) that stays in the graph and does the cast','line_number':1189,'multiline':False]['text':' and (2) only enable this OPTIONAL_NONE when loading newer','line_number':1190,'multiline':False]['text':' graphs because it is incompatible with older graphs.','line_number':1191,'multiline':False]['text':' Refinement none(name, RefinementKind::OPTIONAL_NONE);','line_number':1192,'multiline':False]['text':' TK_ISNOT','line_number':1197,'multiline':False]['text':' TK_ISNOT','line_number':1212,'multiline':False]['text':' meta programming on AST for is/is not cases and emit branches base on','line_number':1239,'multiline':False]['text':' Dispatch logic (A: ALWAYS, N: NEVER, M: MAYBE):','line_number':1247,'multiline':False]['text':'','line_number':1248,'multiline':False]['text':' AA, -> statically IS always holds, IS_NOT never holds','line_number':1249,'multiline':False]['text':' AN , NA-> statically IS_NOT always holds, IS never holds','line_number':1250,'multiline':False]['text':' MA, MM, MN, NM, NN, AM -> cannot prove anything statically','line_number':1251,'multiline':False]['text':' lhs_val/rhs_val with A/M: only emit never_none_branch','line_number':1258,'multiline':False]['text':' MetaCompile on boolean literals and constants','line_number':1304,'multiline':False]['text':' If the cond expr is a static value, then we metacompile the `if`','line_number':1332,'multiline':False]['text':' statemement and only emit true or false branch','line_number':1333,'multiline':False]['text':' `candidate_types` holds all List types that were in the Union','line_number':1358,'multiline':False]['text':' annotation','line_number':1359,'multiline':False]['text':' The Union only had a single type of the container we want to','line_number':1374,'multiline':False]['text':' match, so we can unconditionally refine it to that type','line_number':1375,'multiline':False]['text':' We can't refine the Union yet, since it contains multiple','line_number':1378,'multiline':False]['text':' types of the container we want to match, but we do at least','line_number':1379,'multiline':False]['text':' have a list of possiblee types (e.g. `Union[List[int],','line_number':1380,'multiline':False]['text':' List[str], float, str]` -> candidates={List[int], List[str]})','line_number':1381,'multiline':False]['text':' This case handles code like `dict([(x, y), (a, b)])` that would','line_number':1390,'multiline':False]['text':' otherwise fail the following error checks','line_number':1391,'multiline':False]['text':' If we had any annotation that was NOT a Union that can hold more','line_number':1396,'multiline':False]['text':' than one type of the container we want to match','line_number':1397,'multiline':False]['text':' If there is no type hint, and this is emitted over an iterable that is','line_number':1510,'multiline':False]['text':' unrolled and of length 0, then we emit a List of tensors','line_number':1511,'multiline':False]['text':' A list comprehension introduces its own scope','line_number':1539,'multiline':False]['text':' If we didn't have a type annotation, the type of the list would','line_number':1548,'multiline':False]['text':' be set to `Tensor`. We don't want to unify this default type','line_number':1549,'multiline':False]['text':' with the actual elements in the list, so let the type begin as','line_number':1550,'multiline':False]['text':' the first element in the list','line_number':1551,'multiline':False]['text':'default_to_union=','line_number':1565,'multiline':True]['text':' Case: The list comprehension generated heterogenous values,','line_number':1568,'multiline':False]['text':' and we don't have a type hint to suggest that this is what the','line_number':1569,'multiline':False]['text':' user expected','line_number':1570,'multiline':False]['text':' Case: We had an annotation that we were able to narrow down to','line_number':1592,'multiline':False]['text':' a single ListType, but the most recently generated element in','line_number':1593,'multiline':False]['text':' the list comprehension doesn't match that annotation','line_number':1594,'multiline':False]['text':' If we had a Union type annotation that could hold more than','line_number':1606,'multiline':False]['text':' one different type of `List`','line_number':1607,'multiline':False]['text':' Set the default type to be Dict[str, Tensor]','line_number':1638,'multiline':False]['text':' A dict comprehension introduces its own scope. No variable assigned','line_number':1668,'multiline':False]['text':' may leak into the rest of the graph','line_number':1669,'multiline':False]['text':' If we didn't have a type annotation, the type of the dict would','line_number':1679,'multiline':False]['text':' be set to `(str, Tensor)`. We don't want to unify this default','line_number':1680,'multiline':False]['text':' type with the actual elements in the dict, so let the type','line_number':1681,'multiline':False]['text':' begin as the first element in the dict','line_number':1682,'multiline':False]['text':' Values can be heterogenous, so we only need to check that the','line_number':1689,'multiline':False]['text':' key types are all the same','line_number':1690,'multiline':False]['text':' If we had any annotation OTHER THAN a Union that can hold more','line_number':1702,'multiline':False]['text':' than one type of Dict','line_number':1703,'multiline':False]['text':'default_to_union=','line_number':1746,'multiline':True]['text':' Insert subtyping refinements','line_number':1809,'multiline':False]['text':' if the continue expr in the short circuit is not evaluated,','line_number':1824,'multiline':False]['text':' than the const expression is False if the short circuit','line_number':1825,'multiline':False]['text':' is an `and` and True if the short circuit is an `or`.','line_number':1826,'multiline':False]['text':' `False and expr` -> False, `True or expr` -> True','line_number':1827,'multiline':False]['text':'','line_number':1828,'multiline':False]['text':' inserting it as a constant makes optimization easier','line_number':1829,'multiline':False]['text':' if it's an OR the first expr is emitted in the true branch','line_number':1831,'multiline':False]['text':' and the second expr in the false branch, if it's an AND the opposite','line_number':1832,'multiline':False]['text':' if this is an OR, eval second expression if first expr is False','line_number':1841,'multiline':False]['text':' If this is an AND, eval second expression if first expr is True','line_number':1842,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1843,'multiline':False]['text':' Add op outputs','line_number':1903,'multiline':False]['text':' Resulting value','line_number':1904,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1909,'multiline':False]['text':' cast value not response for checking output type','line_number':1918,'multiline':False]['text':' this is a static if statement: that is, it contains a subset','line_number':1932,'multiline':False]['text':' of operators where we are willing to specialize the if statement','line_number':1933,'multiline':False]['text':' to be only the true or false branch when the condition is statically','line_number':1934,'multiline':False]['text':' known. This is used to meta-program modules, for instance, when a','line_number':1935,'multiline':False]['text':' submodule is absent, an is None check can be used to ensure the','line_number':1936,'multiline':False]['text':' accesses to the None check, which would error, are not compiled.','line_number':1937,'multiline':False]['text':' Emit both blocks once to get the union of all mutated values','line_number':1954,'multiline':False]['text':' In python, every variable assigned in an if statement escapes','line_number':1966,'multiline':False]['text':' the scope of the if statement (all variables are scoped to the function).','line_number':1967,'multiline':False]['text':' Script is a subset of python: we consider variables to be in scope','line_number':1968,'multiline':False]['text':' as long as there is a definition of the variable along all paths','line_number':1969,'multiline':False]['text':' through the if statement','line_number':1970,'multiline':False]['text':' ----','line_number':1971,'multiline':False]['text':' if ...:','line_number':1972,'multiline':False]['text':'   a =','line_number':1973,'multiline':False]['text':' else:','line_number':1974,'multiline':False]['text':'   ...','line_number':1975,'multiline':False]['text':' ... = a  # error, a is not defined along all paths','line_number':1976,'multiline':False]['text':' ----','line_number':1977,'multiline':False]['text':' if ...:','line_number':1978,'multiline':False]['text':'   a =','line_number':1979,'multiline':False]['text':' else:','line_number':1980,'multiline':False]['text':'   a =','line_number':1981,'multiline':False]['text':' ... = a # OK, a is defined along all paths','line_number':1982,'multiline':False]['text':' ----','line_number':1983,'multiline':False]['text':' a = ...','line_number':1984,'multiline':False]['text':' if ...:','line_number':1985,'multiline':False]['text':'   a =','line_number':1986,'multiline':False]['text':' ... = a # OK, a is defined along all paths','line_number':1987,'multiline':False]['text':' if ...:','line_number':1988,'multiline':False]['text':'   a =','line_number':1989,'multiline':False]['text':' else:','line_number':1990,'multiline':False]['text':'   return','line_number':1991,'multiline':False]['text':' ... = a # OK, a is always defined','line_number':1992,'multiline':False]['text':' ordered set, because we want deterministic graph output','line_number':1994,'multiline':False]['text':' When we access either the true or false environment,','line_number':1997,'multiline':False]['text':' we need to set the insertion point so the prim::Load is inserted','line_number':1998,'multiline':False]['text':' into the right block.','line_number':1999,'multiline':False]['text':' if var is only defined in one branch save error in case it's used later','line_number':2000,'multiline':False]['text':' Register outputs in each block','line_number':2052,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2054,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2056,'multiline':False]['text':' if both branches exit don't emit any variables','line_number':2072,'multiline':False]['text':' if one branch exits then we allow the all variables in the other branch','line_number':2073,'multiline':False]['text':' to escape scope since they are well-defined','line_number':2074,'multiline':False]['text':' Try to unify the types. If we found a type annotation earlier','line_number':2098,'multiline':False]['text':' in the environment, and if that type annotation is some form','line_number':2099,'multiline':False]['text':' of union, then we need to tell `unifyTypes` not to throw an','line_number':2100,'multiline':False]['text':' error if the branched return types we found are heterogenous','line_number':2101,'multiline':False]['text':'default_to_union=','line_number':2107,'multiline':True]['text':' We allow variables to be set to different types in each branch','line_number':2109,'multiline':False]['text':' as long as that variable is not already in scope or if that','line_number':2110,'multiline':False]['text':' variable does not get used later. Here, we save the error so','line_number':2111,'multiline':False]['text':' that the error message will be more informative in the case','line_number':2112,'multiline':False]['text':' that is used later. When `a` is accessed in `(a + 1)`, the','line_number':2113,'multiline':False]['text':' error will get printed:','line_number':2114,'multiline':False]['text':' if cond:','line_number':2115,'multiline':False]['text':'    a = 1','line_number':2116,'multiline':False]['text':' else:','line_number':2117,'multiline':False]['text':'    a = tensor','line_number':2118,'multiline':False]['text':' b = a + 1','line_number':2119,'multiline':False]['text':'','line_number':2120,'multiline':False]['text':' We can discard any rhs types that we know statically would be','line_number':2186,'multiline':False]['text':' impossible. For example, if we had:','line_number':2187,'multiline':False]['text':'','line_number':2188,'multiline':False]['text':'    def fn(x: Optional[str]):','line_number':2189,'multiline':False]['text':'        if isinstance(x, (List[str], str, int)):','line_number':2190,'multiline':False]['text':'            ...','line_number':2191,'multiline':False]['text':'','line_number':2192,'multiline':False]['text':' then `x` would be `str` in the true branch and `None` in the','line_number':2193,'multiline':False]['text':' false branch, not `(List[str], str, int)` in the true branch','line_number':2194,'multiline':False]['text':' and `None` in the false branch','line_number':2195,'multiline':False]['text':' Edge case: we can still say that all lhs types subtype some','line_number':2201,'multiline':False]['text':' rhs type if `lhs` is `Any` and `rhs` is `Any`','line_number':2202,'multiline':False]['text':' Cover the case that we have something like','line_number':2227,'multiline':False]['text':' lhs = `List[str]` and rhs = `list`','line_number':2228,'multiline':False]['text':' We want the narrowest possible type','line_number':2231,'multiline':False]['text':' If the lhs couldn't be a subtype of the rhs (or couldn't','line_number':2244,'multiline':False]['text':' be "refined" to itself, as in the `List[str]` and `list`','line_number':2245,'multiline':False]['text':' case above), then we add `lhs_type` to the false branch','line_number':2246,'multiline':False]['text':' refinements. This is because the type can still be itself','line_number':2247,'multiline':False]['text':' if the `isinstance` check is false','line_number':2248,'multiline':False]['text':' For use with `unifyTypeList`','line_number':2254,'multiline':False]['text':' Get a single type for the true and false branches','line_number':2257,'multiline':False]['text':'default_to_union=','line_number':2260,'multiline':True]['text':' Get a single type for the true and false branches','line_number':2267,'multiline':False]['text':'default_to_union=','line_number':2270,'multiline':True]['text':' If the statement is statically true','line_number':2281,'multiline':False]['text':' check maybe true/false at runtime, need an actual op','line_number':2290,'multiline':False]['text':' *********************** Loop Operators ************************************','line_number':2304,'multiline':False]['text':' Emits a loop operator with the form:','line_number':2305,'multiline':False]['text':' Loop(max_trip_count)','line_number':2306,'multiline':False]['text':' block0(loop_counter) {','line_number':2307,'multiline':False]['text':'   <body>','line_number':2308,'multiline':False]['text':' }','line_number':2309,'multiline':False]['text':' block1 {','line_number':2310,'multiline':False]['text':'   <loop condition>','line_number':2311,'multiline':False]['text':'   -> (condition)','line_number':2312,'multiline':False]['text':' }','line_number':2313,'multiline':False]['text':' For loops will have an empty loop condition block with condition set to','line_number':2314,'multiline':False]['text':' true. In the convert to ssa pass, the loop condition will correctly','line_number':2315,'multiline':False]['text':' inlined. and inputs and outputs added so that the loop conforms to the','line_number':2316,'multiline':False]['text':' semantics specified at','line_number':2317,'multiline':False]['text':' https://github.com/onnx/onnx/blob/master/docs/Operators.md#Loop','line_number':2318,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2341,'multiline':False]['text':' Iteration num','line_number':2357,'multiline':False]['text':' if the FOR iters and targets are present, emit FOR target assignments','line_number':2362,'multiline':False]['text':' if target exprs are more than 1, it means iteration unpacking on LHS','line_number':2370,'multiline':False]['text':' we create Tuple literal to wrap those target exprs for assignments','line_number':2371,'multiline':False]['text':'n_binders=','line_number':2376,'multiline':True]['text':' In order to support ModuleLists which return different types,','line_number':2393,'multiline':False]['text':' as with an nn.Sequential which has a module that returns a Dict and then','line_number':2394,'multiline':False]['text':' a module which returns a Tensor,','line_number':2395,'multiline':False]['text':' we do not push a new environment frame because if we did all intermediary','line_number':2396,'multiline':False]['text':' values would have to subtype the input type.','line_number':2397,'multiline':False]['text':'n_binders=','line_number':2403,'multiline':True]['text':' Emit loop information for builtinFunction values like range(), zip(),','line_number':2417,'multiline':False]['text':' enumerate() or SimpleValue like List, Tensor, Dict, etc.','line_number':2418,'multiline':False]['text':' We unroll the loop for iterables that contain ModuleLists so that we can','line_number':2422,'multiline':False]['text':' compile Heterogenous module lists.','line_number':2423,'multiline':False]['text':' Keep a stack of entered objects so they can be exited','line_number':2444,'multiline':False]['text':' in the right order.','line_number':2445,'multiline':False]['text':' Check the schema of __enter__.','line_number':2469,'multiline':False]['text':' Check the schema of __exit__.','line_number':2476,'multiline':False]['text':' Set the output of the enter node to be the return type of __enter__.','line_number':2490,'multiline':False]['text':' Set i = e.__enter__() so that references to i in the body of the with','line_number':2493,'multiline':False]['text':' will resolve correctly.','line_number':2494,'multiline':False]['text':' Insert all the corresponding prim::Exit nodes.','line_number':2503,'multiline':False]['text':' Currently we do not support assigning exceptions to variables,','line_number':2513,'multiline':False]['text':' a = Exception("hi")','line_number':2514,'multiline':False]['text':' raise a','line_number':2515,'multiline':False]['text':'','line_number':2516,'multiline':False]['text':' We ignore the expression following raise','line_number':2517,'multiline':False]['text':' The typical case, an instance of the exception class was thrown:','line_number':2525,'multiline':False]['text':'    raise RuntimeError("error")','line_number':2526,'multiline':False]['text':' A bare exception was thrown so add an empty message. e.g.','line_number':2531,'multiline':False]['text':'    raise RuntimeError','line_number':2532,'multiline':False]['text':' The raise was not followed by an exception (i.e. it was something like','line_number':2535,'multiline':False]['text':' `raise "error"` instead of `raise RuntimeError("error")`)','line_number':2536,'multiline':False]['text':' emit assserions as an if branch so that assertions will reuse the','line_number':2553,'multiline':False]['text':' message','line_number':2554,'multiline':False]['text':' Create an `AssertionError("the_message")` call','line_number':2558,'multiline':False]['text':' Validate that the `lhs` Expr's in an assignment statement are valid. That','line_number':2575,'multiline':False]['text':' is:','line_number':2576,'multiline':False]['text':'','line_number':2577,'multiline':False]['text':' 1) All lhs Expr's are either Var, Tuple or Starred nodes','line_number':2578,'multiline':False]['text':' 2) There is at most one Starred node in the lhs Expr','line_number':2579,'multiline':False]['text':' 3) A Starred node can only appear when there is another non-Starred lhs','line_number':2580,'multiline':False]['text':'    Expr. Concretely this means that `*abc = func()` is illegal. Unpacking','line_number':2581,'multiline':False]['text':'    all outputs into a tuple is covered by `abc = func()`.','line_number':2582,'multiline':False]['text':' Get the appropriate builtin op for this augmented assignment','line_number':2612,'multiline':False]['text':' If the RHS is a tensor, return the corresponding ATen in-place op','line_number':2613,'multiline':False]['text':' If it's a list of scalars, then return the corresponding list augment op','line_number':2614,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-branch-clone)','line_number':2636,'multiline':False]['text':' Get a pair of <in place magic method name, out of place magic method name>','line_number':2648,'multiline':False]['text':' since the out of place method is called if the in place method is not','line_number':2649,'multiline':False]['text':' present','line_number':2650,'multiline':False]['text':' Emit nodes for augmented assignments like `+=`','line_number':2670,'multiline':False]['text':' This will be called when there is a class param or module buffer','line_number':2689,'multiline':False]['text':' mutation which make the LHS of the expr be a select expression','line_number':2690,'multiline':False]['text':'','line_number':2691,'multiline':False]['text':' Example like:','line_number':2692,'multiline':False]['text':' class A(Module):','line_number':2693,'multiline':False]['text':'  def __init__():','line_number':2694,'multiline':False]['text':'    self.register_buffer("running_var", torch.zeros(1))','line_number':2695,'multiline':False]['text':'','line_number':2696,'multiline':False]['text':'  def forward():','line_number':2697,'multiline':False]['text':'    self.num_batches += 1','line_number':2698,'multiline':False]['text':' Call `__iadd__` so updates happen in place on class types','line_number':2718,'multiline':False]['text':' https://docs.python.org/3/reference/datamodel.html#object.__iadd__','line_number':2719,'multiline':False]['text':' Determine whether to use __iadd__ or __add__ (use __add__ only if','line_number':2726,'multiline':False]['text':' __iadd__ is not present)','line_number':2727,'multiline':False]['text':' x += y is equivalent to x = x.__iadd__(y) or x = x.__add__(y) if','line_number':2741,'multiline':False]['text':' __iadd__ is not present','line_number':2742,'multiline':False]['text':'args=','line_number':2753,'multiline':True]['text':'kwargs=','line_number':2754,'multiline':True]['text':'self=','line_number':2755,'multiline':True]['text':' Get the idx to augment','line_number':2763,'multiline':False]['text':' Process the base list value','line_number':2803,'multiline':False]['text':' If it's a tensor, just fully evaluate the subscript operation and emit','line_number':2808,'multiline':False]['text':' an in-place assignment','line_number':2809,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2811,'multiline':False]['text':' Common case: we only tried to index with int and slices. Emit the','line_number':2819,'multiline':False]['text':' correct augmented assignment op to the sliced value','line_number':2820,'multiline':False]['text':' Special case: we tried to do "advanced indexing". Lower this expr','line_number':2829,'multiline':False]['text':' into `index` and `index_put_` ops with tensordices of Tensor?[]','line_number':2830,'multiline':False]['text':' Add implicit conversion of int/float/complex/bool/number types to tensors','line_number':2858,'multiline':False]['text':' Used in emitSubscriptAssign to convert:','line_number':2859,'multiline':False]['text':'   `tensor(...)[x] = 99` to `tensor(...)[x] = tensor(99)`','line_number':2860,'multiline':False]['text':' Mirrors the `valueToTensor` behavior in python_variable_indexing.cpp','line_number':2861,'multiline':False]['text':' Emit mutating assignments like `foo[0] = bar`','line_number':2878,'multiline':False]['text':' First check the base value.','line_number':2890,'multiline':False]['text':' If it's a tensor, copy the RHS data into it','line_number':2893,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2896,'multiline':False]['text':' Handle multi-dimensional slicing: first emit int/slice indexing','line_number':2898,'multiline':False]['text':' TODO: the Python equivalent code has special-cased copy_to','line_number':2899,'multiline':False]['text':' broadcasting to match NumPy semantics (see PR#4853). We can't','line_number':2900,'multiline':False]['text':' replicate that without knowing the size of the Tensor; so really that','line_number':2901,'multiline':False]['text':' code should be moved into the aten function','line_number':2902,'multiline':False]['text':' rhs must be a tensor, implicitly convert int/float/complex/bool','line_number':2908,'multiline':False]['text':' Common case: we only tried to index with int and slices. Copy the','line_number':2912,'multiline':False]['text':' RHS into the resulting tensor.','line_number':2913,'multiline':False]['text':' Special case: we tried to do "advanced indexing" with a tensor.','line_number':2916,'multiline':False]['text':' Dispatch to `aten::index_put_` with tensorindices of Tensor?[]','line_number':2917,'multiline':False]['text':' Otherwise, this is a list or a classtype.','line_number':2929,'multiline':False]['text':' Dispatch to aten::_set_item to both select and assign','line_number':2930,'multiline':False]['text':'annotated_type=','line_number':3008,'multiline':True]['text':' recursively emit tuple assignments on tuple literal input','line_number':3028,'multiline':False]['text':' multiple assign & annotated type not supported in python','line_number':3058,'multiline':False]['text':' a = b = expr()','line_number':3060,'multiline':False]['text':' the semantics of multiple assignment is that expr() is emitted once, then','line_number':3061,'multiline':False]['text':' from left to right the assignments are made','line_number':3062,'multiline':False]['text':'annotated_type=','line_number':3068,'multiline':True]['text':' START BC HACK','line_number':3094,'multiline':False]['text':'','line_number':3095,'multiline':False]['text':' For old serialized quantized RNN modules, switch','line_number':3096,'multiline':False]['text':' quantized::linear_prepack to quantized::linear_prepack_legacy. We','line_number':3097,'multiline':False]['text':' changed linear_prepack to return a TorchBind class and not a','line_number':3098,'multiline':False]['text':' cpp_custom_type_hack tensor anymore, but the old serialized models','line_number':3099,'multiline':False]['text':' are tightly coupled with the type_hack version. If we still create a','line_number':3100,'multiline':False]['text':' Tensor here, then the quantized_lstm.legacy overload can kick in in','line_number':3101,'multiline':False]['text':' forward_impl(), and the module will still run correctly.','line_number':3102,'multiline':False]['text':' END BC HACK','line_number':3123,'multiline':False]['text':'annotated_type=','line_number':3128,'multiline':True]['text':' this function handles expressions that look like apply statements','line_number':3366,'multiline':False]['text':' but have special evaluation rules for the arguments.','line_number':3367,'multiline':False]['text':' when adding a new case, only add a special form if it cannot be expressed','line_number':3368,'multiline':False]['text':' using the standard SugaredValue::call function, which enforces normal','line_number':3369,'multiline':False]['text':' evaluation order.','line_number':3370,'multiline':False]['text':'allow_conversions=','line_number':3410,'multiline':True]['text':' None is a subtype of Optional[T], but we want to remember what T is','line_number':3420,'multiline':False]['text':' after annotation so that variables assigned to this None will still','line_number':3421,'multiline':False]['text':' get the right type. To do this, we make a None constant that','line_number':3422,'multiline':False]['text':' has the type Optional[T]','line_number':3423,'multiline':False]['text':' avoid generating nested unchecked_casts because they are already','line_number':3445,'multiline':False]['text':' inserted during serialization','line_number':3446,'multiline':False]['text':' 3 inputs form of getattr, the third argument is the default value','line_number':3465,'multiline':False]['text':' to return when attribute is not found','line_number':3466,'multiline':False]['text':' attribute not found, just default val (3rd arg)','line_number':3470,'multiline':False]['text':' see legacy_tensor_generic_ctor_new','line_number':3493,'multiline':False]['text':' These legacy constructors do not follow schemas that can be','line_number':3494,'multiline':False]['text':' typed in native_functions.yaml / JIT type signature and are handled','line_number':3495,'multiline':False]['text':' here. Only the two common cases are handled initially:','line_number':3496,'multiline':False]['text':' "new(IntArrayRef size, *, Device? device=None)",','line_number':3497,'multiline':False]['text':' "new(PyObject* data, *, Device? device=None)",','line_number':3498,'multiline':False]['text':' Note: device argument is unused in the kernel','line_number':3499,'multiline':False]['text':' supporting "new(IntArrayRef size, *, Device? device=None)", through','line_number':3522,'multiline':False]['text':' empty.memory_format(int[] size, *, ScalarType? dtype=None, Layout?','line_number':3523,'multiline':False]['text':' layout=None, Device? device=None, bool? pin_memory=None,','line_number':3524,'multiline':False]['text':' MemoryFormat? memory_format=None) -> Tensor','line_number':3525,'multiline':False]['text':' empty inputs == torch.tensor([], dtype=....)','line_number':3530,'multiline':False]['text':' This represents the "__new__" method on classes','line_number':3580,'multiline':False]['text':' because it takes a ClassValue as input.','line_number':3581,'multiline':False]['text':' So if we see:','line_number':3582,'multiline':False]['text':'   Foo.__new__(Foo)','line_number':3583,'multiline':False]['text':' Foo is a ClassValue, calling `attr("__new__")` will return a','line_number':3584,'multiline':False]['text':' CreateObject special form.','line_number':3585,'multiline':False]['text':' We construct the iterable tree here using the IterableTree','line_number':3602,'multiline':False]['text':' SugaredValue, The tree consists of SimpleValue, RangeValue or','line_number':3603,'multiline':False]['text':' IterableTree: For SimpleValues(List, Dict, etc) or RangeValue. We will','line_number':3604,'multiline':False]['text':' make them as tree leaves since we could get the loop information from','line_number':3605,'multiline':False]['text':' len() and get_item(). For IterableTree like zip(), enumerate(), we can','line_number':3606,'multiline':False]['text':' model them as a combination of leaves, and we emit a IterableTree value','line_number':3607,'multiline':False]['text':' to record the tree information','line_number':3608,'multiline':False]['text':'maybe_unpack=','line_number':3611,'multiline':True]['text':' enumerate(x) can be rewrite as subtrees:','line_number':3620,'multiline':False]['text':' IterableTree(RangeValue(0, math.inf), SimpleValue(x))','line_number':3621,'multiline':False]['text':' range should have the same static length as the other iterable','line_number':3660,'multiline':False]['text':' zip(x, y) can be rewrite as subtrees:','line_number':3671,'multiline':False]['text':' IterableTree(IterableTree(x), IterableTree(y))','line_number':3672,'multiline':False]['text':' list(iter) desugars to [_elem for _elem in iter]','line_number':3731,'multiline':False]['text':' aten::list builtin op is registered for List and Str input','line_number':3735,'multiline':False]['text':' dispatch to the builtin op to avoid perf slowdown on existing uses','line_number':3736,'multiline':False]['text':'annotated_type=','line_number':3749,'multiline':True]['text':' true if `dict()`','line_number':3817,'multiline':False]['text':' true if `dict({})`','line_number':3821,'multiline':False]['text':' true if `dict([])`','line_number':3827,'multiline':False]['text':'is_dict_constructor=','line_number':3864,'multiline':True]['text':' If possible, just cast what we have to a Dict and add the','line_number':3876,'multiline':False]['text':' kwargs by hand. This is not only the simplest solution; it also','line_number':3877,'multiline':False]['text':' hits cases like `dict(dict([1, 2, 3]))` or `dict(x)` (where `x`','line_number':3878,'multiline':False]['text':' is some previously-defined variable)','line_number':3879,'multiline':False]['text':' TODO(@ansley): Fix this! We have a weird situation where the','line_number':3881,'multiline':False]['text':' dict constructor may be handed an internal container literal','line_number':3882,'multiline':False]['text':' or comprehension, in which case we'd throw an error because','line_number':3883,'multiline':False]['text':' the lhs type wouldn't match the rhs type (the compiler wouldn't','line_number':3884,'multiline':False]['text':' be able to tell that this was part of a nested expression). We','line_number':3885,'multiline':False]['text':' used to get around this by simply not passing `type_hint`, but','line_number':3886,'multiline':False]['text':' 1) that's bad, and 2) we actually need `type_hint` for','line_number':3887,'multiline':False]['text':' inference now that Union has been introduced.','line_number':3888,'multiline':False]['text':' If we have a call with an empty container, or if we have a','line_number':3908,'multiline':False]['text':' call with kwargs only','line_number':3909,'multiline':False]['text':' If we have a completely empty call to dict()','line_number':3916,'multiline':False]['text':' Special-case logic for if we have a dict comprehension','line_number':3945,'multiline':False]['text':' We can't feasibly register all possible key x value','line_number':3953,'multiline':False]['text':' combinations of new prim ops for the case that we use the','line_number':3954,'multiline':False]['text':' constructor with a dict literal. It makes much more sense','line_number':3955,'multiline':False]['text':' to transform the dict literal into a list of tuples so that','line_number':3956,'multiline':False]['text':' we can use the existing constructors','line_number':3957,'multiline':False]['text':' Change `apply` to a new Apply node holding a list of','line_number':3977,'multiline':False]['text':' tuples','line_number':3978,'multiline':False]['text':' If we have kwargs to include, we'll take a similar approach','line_number':3983,'multiline':False]['text':' to the above logic and standardize the Apply node','line_number':3984,'multiline':False]['text':' Gather all the existing tuples in the input iterable','line_number':3989,'multiline':False]['text':' Create tuples out of each kwarg and gather them as well','line_number':3996,'multiline':False]['text':'annotated_type=','line_number':4033,'multiline':True]['text':' Push the source range of a call in case compiling this function','line_number':4047,'multiline':False]['text':' triggers an error','line_number':4048,'multiline':False]['text':' AnyType is the only user-exposed type which we don't unify to from','line_number':4052,'multiline':False]['text':' its subtypes, so we add a cast for use cases like','line_number':4053,'multiline':False]['text':' x : Any = 1 if cond else "str"','line_number':4054,'multiline':False]['text':' any expression that can produce a SugaredValue is handled here','line_number':4075,'multiline':False]['text':' expressions that only return a single Value* are handled in emitSimpleExpr','line_number':4076,'multiline':False]['text':' type_hint is set if there is a type that this value is expected to be','line_number':4077,'multiline':False]['text':' e.g. a : List[int] = []','line_number':4078,'multiline':False]['text':' or a = torch.jit.annotate(List[int], [])','line_number':4079,'multiline':False]['text':' the caller is responsible for checking that the result matches type_hint','line_number':4080,'multiline':False]['text':' emitSugaredExpr is free to ignore it.','line_number':4081,'multiline':False]['text':'maybe_unpack=','line_number':4112,'multiline':True]['text':' if we emitted the unary op and not some other overloaded function,','line_number':4119,'multiline':False]['text':' then try to constantfold','line_number':4120,'multiline':False]['text':'*
   * Emit a fork expression, of the form:
   *   torch.jit.fork(forked, *args, **kwargs)
   ','line_number':4133,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4143,'multiline':False]['text':' We create a fork by emitting a closure and setting the closure output','line_number':4150,'multiline':False]['text':' into the fork input. If a closure doesn't already exist, we create one.','line_number':4151,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':4182,'multiline':False]['text':' TODO: This is a temporary apporoach to enable calling user fucntion','line_number':4214,'multiline':False]['text':' through RPC in TorchScript,','line_number':4215,'multiline':False]['text':' Ideally, function value in JIT IR is first-class citizen and','line_number':4216,'multiline':False]['text':' The RPC C++ entry API can take c10::Function directly.','line_number':4217,'multiline':False]['text':' NOLINT','line_number':4219,'multiline':False]['text':' TODO: Make rpc_op(..) support taking kwargs,','line_number':4237,'multiline':False]['text':' like rpc_async(to="worker1", func=my_func, args=(), kwargs={})','line_number':4238,'multiline':False]['text':' NB: This should be done using `std::dynamic_pointer_cast`','line_number':4248,'multiline':False]['text':' and assert `user_callable_function_value != nullptr`. But somehow on','line_number':4249,'multiline':False]['text':' macos std::dynamic_pointer_cast always returns','line_number':4250,'multiline':False]['text':' `user_callable_function_value` as a `nullptr`, even if','line_number':4251,'multiline':False]['text':' `user_callable_sugared_value->kind() == "function"`.','line_number':4252,'multiline':False]['text':' If `kwargs` is an empty dict, users are allowed to not pass `kwargs`.','line_number':4255,'multiline':False]['text':' If `args` and `kwargs` are an empty tuple and an empty dict,','line_number':4256,'multiline':False]['text':' respectively, users are allowed to not pass `args` and `kwargs`.','line_number':4257,'multiline':False]['text':' Get user callable.','line_number':4262,'multiline':False]['text':' Match FunctionSchema.','line_number':4274,'multiline':False]['text':' Get args and kwargs as `NamedValue`s.','line_number':4277,'multiline':False]['text':' Similar to getNamedValues(..) and emitAttributes(..).','line_number':4278,'multiline':False]['text':' Unroll args from a Var that is known to be a Tuple.','line_number':4280,'multiline':False]['text':' NB: Can't do schema check on kwargs, given the RPC API is','line_number':4290,'multiline':False]['text':' rpc_op(to, user_callable, args, kwargs),','line_number':4291,'multiline':False]['text':' users can construct kwargs = {"first" + "_arg" : 1}.','line_number':4292,'multiline':False]['text':' Notice the key is determined at run time.','line_number':4293,'multiline':False]['text':' We can do it at compile time, unless one day the RPC API is','line_number':4294,'multiline':False]['text':' rpc_op(to, user_callable, arg_0, arg_1, kwarg_0="foo",','line_number':4295,'multiline':False]['text':' kwarg_1="bar")','line_number':4296,'multiline':False]['text':' Graph insert the QualifiedName as an constant input IR Value.','line_number':4300,'multiline':False]['text':' Graph insert the corresponding RPC node to the graph.','line_number':4306,'multiline':False]['text':' Set output type from FunctionSchema and corresponding rpc_op.','line_number':4320,'multiline':False]['text':' rpc_async returns FutureType of the functionSchema's return type','line_number':4325,'multiline':False]['text':' rpc_sync returns the functionSchema's return type','line_number':4328,'multiline':False]['text':' rpc_remote returns RRefType of the functionSchema's return type','line_number':4331,'multiline':False]['text':'maybe_unpack=','line_number':4345,'multiline':True]['text':' For `in` the arguments are in reverse order (the object being','line_number':4347,'multiline':False]['text':' checked is second)','line_number':4348,'multiline':False]['text':' if this is adding two tuples, we deal with it here.','line_number':4352,'multiline':False]['text':' the reason is we can't specify the length of tuples','line_number':4353,'multiline':False]['text':' when registering custom aten::add.','line_number':4354,'multiline':False]['text':'maybe_unpack=','line_number':4373,'multiline':True]['text':' Empty List Literals that are not assigned to variables','line_number':4375,'multiline':False]['text':' may match to any list type in schema matching,','line_number':4376,'multiline':False]['text':' but still default to List[Tensor] if assigned to a variable','line_number':4377,'multiline':False]['text':' or returned from a function','line_number':4378,'multiline':False]['text':' Restricting empty list matching to temporary values','line_number':4379,'multiline':False]['text':' avoids difficult to handle cases such as','line_number':4380,'multiline':False]['text':' a = []','line_number':4381,'multiline':False]['text':' b = a','line_number':4382,'multiline':False]['text':' if cond:','line_number':4383,'multiline':False]['text':'    b.append(2)','line_number':4384,'multiline':False]['text':' else:','line_number':4385,'multiline':False]['text':'    a.append("hi")','line_number':4386,'multiline':False]['text':' This is also the same behavior that C++ allows with {}','line_number':4387,'multiline':False]['text':' (cannot assign to a variable typed as auto)','line_number':4388,'multiline':False]['text':' These nodes will be removed in a later pass after initial compilation','line_number':4389,'multiline':False]['text':' Determine the element type of the list. If we have a type hint','line_number':4396,'multiline':False]['text':' of `List[T]`, use `T`. If the list is non-empty, find the','line_number':4397,'multiline':False]['text':' greatest common supertype of all the list elements (defaulting to','line_number':4398,'multiline':False]['text':' `Any` as a catch-all supertype). Assume `[]` is `List[Tensor]`','line_number':4399,'multiline':False]['text':' If `type_hint` is a Union/Optional, we're going to change it to','line_number':4404,'multiline':False]['text':' be the type of the rhs List, so we need to store the original','line_number':4405,'multiline':False]['text':' UnionType for later. `nullptr` means that we don't need to emit','line_number':4406,'multiline':False]['text':' an `unchecked_cast` node (either because we don't have a type','line_number':4407,'multiline':False]['text':' hint or because the type hint wasn't a Union)','line_number':4408,'multiline':False]['text':' This is used in the case that we have a Union annotation that','line_number':4414,'multiline':False]['text':' contains multiple Lists','line_number':4415,'multiline':False]['text':' never used','line_number':4450,'multiline':False]['text':' We don't want to use `elem_type` as the final argument to','line_number':4452,'multiline':False]['text':' `unifyTypeList` because there's a chance that `elem_type` is','line_number':4453,'multiline':False]['text':' the Tensor default','line_number':4454,'multiline':False]['text':'default_to_union=','line_number':4461,'multiline':True]['text':' We only want to set `elem_type` if we don't have a type hint','line_number':4495,'multiline':False]['text':' to allow for the case that `*unified` is a subtype of','line_number':4496,'multiline':False]['text':' `type_hint`','line_number':4497,'multiline':False]['text':'default_to_union=','line_number':4539,'multiline':True]['text':' We must have either a) specific key/value types already, or b) a','line_number':4596,'multiline':False]['text':' list of possible candidates','line_number':4597,'multiline':False]['text':'maybe_unpack=','line_number':4651,'multiline':True]['text':'maybe_unpack=','line_number':4660,'multiline':True]['text':'maybe_unpack=','line_number':4729,'multiline':True]['text':' Desugars select indexing: tensor[i] -> tensor.select(dim, i)','line_number':4765,'multiline':False]['text':' XXX: If list slicing becomes more complicated or stops using','line_number':4785,'multiline':False]['text':' aten::slice, we should separate it from this function.','line_number':4786,'multiline':False]['text':' since we are only dealing with tuple slicing, we try to keep','line_number':4797,'multiline':False]['text':' tuple args separate for now','line_number':4798,'multiline':False]['text':' handling cases like x[0:2]. x[0:2:] is already handled from python','line_number':4811,'multiline':False]['text':' Desugars slice indexing: tensor[begin:end] -> tensor.slice(dim, begin, end,','line_number':4822,'multiline':False]['text':' 1)','line_number':4823,'multiline':False]['text':' Only used for tensor slicing','line_number':4827,'multiline':False]['text':' NB: the index of aten::index should be a type of List[Optional[Tensor]],','line_number':4852,'multiline':False]['text':' this is to support the case like t[:, :, 1] where : here indicates a','line_number':4853,'multiline':False]['text':' None/undefined tensor(optional tensor)','line_number':4854,'multiline':False]['text':' Emits multidimensional slicing with int and slice indices.','line_number':4861,'multiline':False]['text':' Returns:','line_number':4862,'multiline':False]['text':' - Value*: the input after it has been indexed by int and slice indices.','line_number':4863,'multiline':False]['text':' - vector<Value*>: A list of tensor Value* indices that have not been','line_number':4864,'multiline':False]['text':' applied yet.','line_number':4865,'multiline':False]['text':'   Should be NULL at indices where sliceable (post-slicing) isn't indexed by','line_number':4866,'multiline':False]['text':'   a tensor.','line_number':4867,'multiline':False]['text':' Overall, to handle indexing (other than Tensors), we need to handle a','line_number':4872,'multiline':False]['text':' couple different things. For example, for x[1:3, None, 4], each of these','line_number':4873,'multiline':False]['text':' different index types (slice, None, and integer) result in different','line_number':4874,'multiline':False]['text':' number of dimensions. Slicing doesn't change the number of dimensions,','line_number':4875,'multiline':False]['text':' None adds a dimension, and integer removes a dimension. As these indexing','line_number':4876,'multiline':False]['text':' operations are applied left to right, the actual index that it's being','line_number':4877,'multiline':False]['text':' applied to depends on the previous operations. Ellipses indexing throws','line_number':4878,'multiline':False]['text':' another wrinkle. Ellipses selects any remaining unspecified dimensions.','line_number':4879,'multiline':False]['text':' Thus, for indexes following an ellipses, the actual index an indexing','line_number':4880,'multiline':False]['text':' operation is being applied to depends on the operations to the right.','line_number':4881,'multiline':False]['text':' Thus, we do two passes, one from left to right up until the ellipses, and','line_number':4882,'multiline':False]['text':' one from right to left.','line_number':4883,'multiline':False]['text':' Slice expression case, does not represent a single index.','line_number':4900,'multiline':False]['text':' Slice object case, does not represent a single index.','line_number':4909,'multiline':False]['text':' Accept list as subscript but convert it to a Tensor','line_number':4925,'multiline':False]['text':' since it's equivalent to indexing with Tensor.','line_number':4926,'multiline':False]['text':' The list can be a list literal or list variable.','line_number':4927,'multiline':False]['text':' Advanced indexing using list:','line_number':4928,'multiline':False]['text':' @torch.jit.script','line_number':4929,'multiline':False]['text':' def f(x):','line_number':4930,'multiline':False]['text':'   return x[[0, 1, 5]]  # or','line_number':4931,'multiline':False]['text':'   return x[[0, 1], [0, 1]]  # or','line_number':4932,'multiline':False]['text':'   return x[[[0, 1], [0, 1]], [[0, 1], [0, 1]]]  # or','line_number':4933,'multiline':False]['text':'   ls = [0, 1]','line_number':4934,'multiline':False]['text':'   return x[ls]','line_number':4935,'multiline':False]['text':' Statements above are equivalent to advanced indexing using Tensor:','line_number':4936,'multiline':False]['text':' @torch.jit.script','line_number':4937,'multiline':False]['text':' def f(x):','line_number':4938,'multiline':False]['text':'   return x[torch.tensor([0, 1, 5])]  # or','line_number':4939,'multiline':False]['text':'   return x[torch.tensor([0, 1]), torch.tensor([0, 1])]  # or','line_number':4940,'multiline':False]['text':'   return x[torch.tensor([[0, 1], [0, 1]]),','line_number':4941,'multiline':False]['text':'            torch.tensor([[0, 1], [0, 1]])]  # or','line_number':4942,'multiline':False]['text':'   ls = [0, 1]','line_number':4943,'multiline':False]['text':'   return x[torch.tensor(ls)]','line_number':4944,'multiline':False]['text':' Always create index tensor as LongTensor.','line_number':4946,'multiline':False]['text':' This is to match Pytorch eager frontend behavior which accepts','line_number':4947,'multiline':False]['text':' indexing with float list.','line_number':4948,'multiline':False]['text':'is_reverse=','line_number':4988,'multiline':True]['text':'is_reverse=','line_number':4999,'multiline':True]['text':' at::index takes in a List[Optional[Tensor]] where some dims can be None.','line_number':5045,'multiline':False]['text':' create None node with optional tensor output type and pass to at::index.','line_number':5046,'multiline':False]['text':' Desugars multidim slicing into slice/select/index/unsqueeze calls.','line_number':5055,'multiline':False]['text':'','line_number':5056,'multiline':False]['text':' XXX: Errors in user code are not elegantly reported.','line_number':5057,'multiline':False]['text':' Let's say someone were to do the following:','line_number':5058,'multiline':False]['text':'   @torch.jit.script','line_number':5059,'multiline':False]['text':'   def fn(x):','line_number':5060,'multiline':False]['text':'       return x[0, 1]','line_number':5061,'multiline':False]['text':'   fn(torch.randn(5))','line_number':5062,'multiline':False]['text':' Because we desugar this into two aten::select ops, the error message','line_number':5063,'multiline':False]['text':' complains about aten::select failing rather than there "not being','line_number':5064,'multiline':False]['text':' enough dimensions to index".','line_number':5065,'multiline':False]['text':'','line_number':5066,'multiline':False]['text':' The strategy is to slice and select the tensor for int and slices first','line_number':5067,'multiline':False]['text':' in one pass and then apply at::index on the result of the','line_number':5068,'multiline':False]['text':' slicing/selecting. Call the tensor after we've applied slice / select the','line_number':5069,'multiline':False]['text':' `sliced`. tensor_indices should have the same size as sliced.dim():','line_number':5070,'multiline':False]['text':' - tensor_indices[i] = NULL if we should not index `sliced` at dim i','line_number':5071,'multiline':False]['text':' - tensor_indices[i] = t if we should index `sliced` at dim i with tensor t.','line_number':5072,'multiline':False]['text':' XXX: Might need to at::alias this when we support mutability','line_number':5088,'multiline':False]['text':' Desugars slice syntactic sugar tensor[begin:end] -> tensor.slice(begin,','line_number':5095,'multiline':False]['text':' end).','line_number':5096,'multiline':False]['text':' If the sliceable object is a tensor, specify a default dimension','line_number':5106,'multiline':False]['text':' set index to be positive to simplify logic in runtime','line_number':5117,'multiline':False]['text':' When a list is marked const in a module, it gets converted to a tuple.','line_number':5130,'multiline':False]['text':' The result is indexing into a Tuple which contains only one type','line_number':5131,'multiline':False]['text':' is quite common. since indexing will likely be done in a for loop,','line_number':5132,'multiline':False]['text':' we do not want to invoke the overhead of converting the tuple to a list','line_number':5133,'multiline':False]['text':' each iter.','line_number':5134,'multiline':False]['text':'allow_out_of_bounds','line_number':5156,'multiline':True]['text':' TODO @wconstab refactor using Symbol instead of string compare','line_number':5222,'multiline':False]['text':' Slicing isn't currently implemented for Sequential/ModuleList,','line_number':5224,'multiline':False]['text':' but is implemented for Tuples, so a quick workaround is to','line_number':5225,'multiline':False]['text':' convert to a tuple of Modules for slicing support.','line_number':5226,'multiline':False]['text':' In case of subscript expression being a Python Slice object.','line_number':5266,'multiline':False]['text':' aten::slice.tensor needs an additional `dim` input.','line_number':5271,'multiline':False]['text':' subscript is not a slice object, then it must be convertible to','line_number':5286,'multiline':False]['text':' a normal value.','line_number':5287,'multiline':False]['text':' Desugars gather syntactic sugar foo[i]','line_number':5288,'multiline':False]['text':' calles the define with native resolver to generate the graph for functions','line_number':5332,'multiline':False]['text':' This pair represents a pair of functions (getter and setter) obtained from','line_number':5336,'multiline':False]['text':' compiling a Property.','line_number':5337,'multiline':False]['text':' self must be defined because properties are features of classes and','line_number':5364,'multiline':False]['text':' modules.','line_number':5365,'multiline':False]['text':' Compile the getter function.','line_number':5368,'multiline':False]['text':' Compile the setter function if it exists.','line_number':5372,'multiline':False]['text':' Add the property to the class type definition.','line_number':5384,'multiline':False]['text':' if self is defined, then these are methods and do not go into the','line_number':5403,'multiline':False]['text':' global namespace otherwise, they get defined together so we add them to','line_number':5404,'multiline':False]['text':' the function table so the methods can see each other','line_number':5405,'multiline':False]['text':' Store the function name so that it can be referenced if there is an error','line_number':5410,'multiline':False]['text':' while compiling this function','line_number':5411,'multiline':False]['text':' There should be at least a ClassName.method_name','line_number':5415,'multiline':False]['text':' If `shouldMangle` is set, we should generate a unique name for this','line_number':5425,'multiline':False]['text':' function if there is already an existing one.','line_number':5426,'multiline':False]['text':' Register this as a method on `self`'s type','line_number':5437,'multiline':False]['text':' Records fn in function_table, functions and with register_function.','line_number':5463,'multiline':False]['text':' This is done several times below, so this lambda helps avoid repeating','line_number':5464,'multiline':False]['text':' code.','line_number':5465,'multiline':False]['text':' We need to compile `__init__` first, since it can determine what attributes','line_number':5505,'multiline':False]['text':' are available to other methods. So reorder the definitions accordingly.','line_number':5506,'multiline':False]['text':' check hook for name collisions and redefinition','line_number':5533,'multiline':False]['text':' check if hook is already defined for this module','line_number':5537,'multiline':False]['text':' check if hook name is already defined on module as method','line_number':5541,'multiline':False]['text':' build_schema for checking','line_number':5555,'multiline':False]['text':' skip_self','line_number':5560,'multiline':True]['text':' need to add self as the first because we skipped it','line_number':5561,'multiline':False]['text':' define hooks','line_number':5570,'multiline':False]['text':' check to see if already defined this hook','line_number':5572,'multiline':False]['text':' add it to class type again so it's called','line_number':5575,'multiline':False]['text':' define hook','line_number':5579,'multiline':False]['text':' define pre_hooks','line_number':5597,'multiline':False]['text':' check to see if already defined this hook','line_number':5599,'multiline':False]['text':' add it to class type again so it's called','line_number':5602,'multiline':False]['text':' define pre_hook','line_number':5606,'multiline':False]['text':'is_method=','line_number':5634,'multiline':True]['text':'properties=','line_number':5640,'multiline':True]['text':'propResolvers=','line_number':5641,'multiline':True]['text':' these exist temporarily in initial compilation','line_number':5676,'multiline':False]['text':' remove any uses of tuples that we inserted that are not needed','line_number':5679,'multiline':False]['text':' full constant propagation runs ops with mutable inputs if it can','line_number':5682,'multiline':False]['text':' prove that the inputs are not mutated anywhere in the graph.','line_number':5683,'multiline':False]['text':' if a mutating node is removed in the graph (e.g. constant prop inlined a','line_number':5684,'multiline':False]['text':' a constant if) then the next time constant prop is run it might be able','line_number':5685,'multiline':False]['text':' to run nodes it was not able to previously, and the graph may change','line_number':5686,'multiline':False]['text':' (jitter) So we run only constant prop w immutable types here bc','line_number':5687,'multiline':False]['text':' successive runs of immutable constant prop does not change the graph','line_number':5688,'multiline':False]['text':' Constant Pooling pass must be after ConstantPropogation, which can create','line_number':5691,'multiline':False]['text':' new constants that needs to be pooled.','line_number':5692,'multiline':False]['text':' For jitter','line_number':5695,'multiline':False]['text':' Annotate aten::warns so that each has its unique ID. This enables us to','line_number':5698,'multiline':False]['text':' mimic Python behavior of only emitting each warning only once.','line_number':5699,'multiline':False]['text':' we consider _N where N is a number, to be a non-meaningful name','line_number':5703,'multiline':False]['text':' and do not record it as a unique name. This allows python printing to','line_number':5704,'multiline':False]['text':' be able to export and import more consistently named graphs','line_number':5705,'multiline':False]['text':' skip_self','line_number':5739,'multiline':True]['text':' need to add self as the first because we skipped it','line_number':5740,'multiline':False]['text':' we need to make sure everything but the last element is just string','line_number':5746,'multiline':False]['text':' literals (aka comments) unless there is "pass" in between','line_number':5747,'multiline':False]['text':' if we see a "pass", we just stop there','line_number':5758,'multiline':False]['text':' namespace torch::jit','line_number':5773,'multiline':False]