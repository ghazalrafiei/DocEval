['text':' At the beginning of the pass the Graph has already undergone type checking,','line_number':10,'multiline':False]['text':' and writes or reads to a variable are emitted as Loads and Stores in the','line_number':11,'multiline':False]['text':' graph.','line_number':12,'multiline':False]['text':'     a = 1','line_number':13,'multiline':False]['text':'     print(a)','line_number':14,'multiline':False]['text':' is represented as:','line_number':15,'multiline':False]['text':'     %a.1 : int = prim::Constant[value=1]()','line_number':16,'multiline':False]['text':'     prim::Store[name="a"](%a.1)','line_number':17,'multiline':False]['text':'     %a : int = prim::Load[name="a"]()','line_number':18,'multiline':False]['text':'     prim::Print(%a)','line_number':19,'multiline':False]['text':'','line_number':20,'multiline':False]['text':' First, this pass recursively adds the Loads & Stores to control flow nodes','line_number':21,'multiline':False]['text':' Then the graph is converted to SSA form.','line_number':22,'multiline':False]['text':' Adds Loads & Stores to Loops & Ifs','line_number':27,'multiline':False]['text':' Following the same logic as emitIfElseBlocks in ir_emitter.cpp,','line_number':88,'multiline':False]['text':' we emit a node output if the variable is defined in each block','line_number':89,'multiline':False]['text':' and the types of each block can be unified','line_number':90,'multiline':False]['text':'default_to_union=','line_number':95,'multiline':True]['text':' loop_carried_outputs* = Loop(max_trip_count, start_condition,','line_number':103,'multiline':False]['text':'                              loop_carried_inputs*)','line_number':104,'multiline':False]['text':'                    block0(loop_counter, loop_carried_block*) {','line_number':105,'multiline':False]['text':'                       <body>','line_number':106,'multiline':False]['text':'                       -> (continue_condition, loop_carried_block_outputs*)','line_number':107,'multiline':False]['text':'                    }','line_number':108,'multiline':False]['text':' all loop_carried_... lists are the same length and represent the value of','line_number':109,'multiline':False]['text':' loop-carried variables whose definitions are updated as the loop executes','line_number':110,'multiline':False]['text':' in a way that ensure single static assignment.','line_number':111,'multiline':False]['text':' if the variable local to the loop body, then','line_number':117,'multiline':False]['text':' we do not need a loop carried variable for it','line_number':118,'multiline':False]['text':' since the loop may execute 0 or many times, the output types','line_number':124,'multiline':False]['text':' of the loop and the input loop carried dependencies are conservatively','line_number':125,'multiline':False]['text':' the union of the output of the body and the input to the loop','line_number':126,'multiline':False]['text':' Insert a store at the beginning of the loop block, so that all','line_number':130,'multiline':False]['text':' loads of the variable will use the loop carried value','line_number':131,'multiline':False]['text':' Given a graph where 1) outputs have been added to control flow nodes and','line_number':182,'multiline':False]['text':' 2) loads and stores are represented in the graph, erase the Loads & Stores.','line_number':183,'multiline':False]['text':' writes within a local variable scope do not leak into','line_number':205,'multiline':False]['text':' the rest of the graph','line_number':206,'multiline':False]['text':' inline the local variable scope into the graph','line_number':209,'multiline':False]['text':' This pass transforms Breaks & Continues to be LoopContinuations,','line_number':246,'multiline':False]['text':' of the form LoopContinuations(%loop_continue_condition, *loop_carried_vars)','line_number':247,'multiline':False]['text':' Break Statements have the condition set to false, and Continue statements','line_number':248,'multiline':False]['text':' inline the loop condition as the first input.','line_number':249,'multiline':False]['text':' NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)','line_number':260,'multiline':False]['text':' NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)','line_number':294,'multiline':False]['text':' first input is the loop continue condition - break sets false','line_number':306,'multiline':False]['text':' Converting to SSA works in multiple parts. First, we add control flow','line_number':329,'multiline':False]['text':' loads and stores to the graph. Now that control flow outputs are set,','line_number':330,'multiline':False]['text':' we can set remove Break & Continue to have the correct continuations to the','line_number':331,'multiline':False]['text':' end of the block (LoopContinuation). Then we inline the loop condition into','line_number':332,'multiline':False]['text':' the graph. Then, we erase Loads & Stores. Finally, we remove','line_number':333,'multiline':False]['text':' LoopContinuations from the graph.','line_number':334,'multiline':False]['text':' namespace torch::jit','line_number':346,'multiline':False]