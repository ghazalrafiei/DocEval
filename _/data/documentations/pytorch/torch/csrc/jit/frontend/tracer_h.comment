['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':49,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':51,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':53,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':55,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':57,'multiline':False]['text':' This is meant to be used as a thread local place, where we can store extra','line_number':98,'multiline':False]['text':' info that gets lost when we call into ATen from Python bindings. One example','line_number':99,'multiline':False]['text':' for when this happens is when we get an IntArrayRef argument with e.g. sizes','line_number':100,'multiline':False]['text':' for view. When tracing, those might be tensors, which let us encode extra','line_number':101,'multiline':False]['text':' data dependencies, but once they get to the ATen call where we actually have','line_number':102,'multiline':False]['text':' the tracing logic, they get converted into a raw IntArrayRef, and we loose','line_number':103,'multiline':False]['text':' all information. To prevent this, we temporarily stash it in here.','line_number':104,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':105,'multiline':False]['text':' Value stashing: Use these methods to stash arguments which correspond','line_number':131,'multiline':False]['text':' to regular Value*'s in the graph. i.e. they don't require special','line_number':132,'multiline':False]['text':' handling like in the case of IntArrayRefs','line_number':133,'multiline':False]['text':' Retrieve or set the current tracing state. Returns a nullptr if tracing is','line_number':156,'multiline':False]['text':' disabled.','line_number':157,'multiline':False]['text':' Having finished adding a new 'node' to the graph IR 'setValueTrace'','line_number':211,'multiline':False]['text':' associates this node with an output variable, so that further operations','line_number':212,'multiline':False]['text':' involving this variable know which node in the IR to reference.','line_number':213,'multiline':False]['text':' NB: those serve both as an intermediate steps in addInputs below,','line_number':233,'multiline':False]['text':' as well as the overloads that terminate template recursion','line_number':234,'multiline':False]['text':' namespace tracer','line_number':412,'multiline':False]['text':' namespace jit','line_number':413,'multiline':False]['text':' namespace torch','line_number':414,'multiline':False]