['text':' You can think of an nn.Module as a template that corresponds to a family of','line_number':16,'multiline':False]['text':' JIT types. The template "arguments" are things like the constant values.','line_number':17,'multiline':False]['text':' e.g.','line_number':18,'multiline':False]['text':'   class M(nn.Module):','line_number':19,'multiline':False]['text':'        __constants__ = ["const"]','line_number':20,'multiline':False]['text':'        ...','line_number':21,'multiline':False]['text':'','line_number':22,'multiline':False]['text':' Is similar to writing the following in C++:','line_number':23,'multiline':False]['text':'','line_number':24,'multiline':False]['text':'    template<TConst>','line_number':25,'multiline':False]['text':'    class M {','line_number':26,'multiline':False]['text':'       ...','line_number':27,'multiline':False]['text':'    }','line_number':28,'multiline':False]['text':'','line_number':29,'multiline':False]['text':' We need to consider each different member of the type family a different JIT','line_number':30,'multiline':False]['text':' type because, e.g. different constant values lead to different versions of','line_number':31,'multiline':False]['text':' the same method.','line_number':32,'multiline':False]['text':'','line_number':33,'multiline':False]['text':' ConcreteModuleType corresponds to a single member of the type family, with','line_number':34,'multiline':False]['text':' all template arguments fully specified. Two Modules that share a','line_number':35,'multiline':False]['text':' ConcreteModuleType can share a JIT type, and vice versa.','line_number':36,'multiline':False]['text':'','line_number':37,'multiline':False]['text':' Why not just use a JIT type to represent concrete types? Because constants,','line_number':38,'multiline':False]['text':' function attributes, etc. are currently not representable in the type system,','line_number':39,'multiline':False]['text':' so this acts a non-first-class way of tracking concrete types.','line_number':40,'multiline':False]['text':'','line_number':41,'multiline':False]['text':' ConcreteModuleType is also the source of truth for servicing all','line_number':42,'multiline':False]['text':' ModuleValue::attr calls. This is so we can guarantee that if two Module's','line_number':43,'multiline':False]['text':' share a JIT type (and thus a ConcreteModuleType), then they behave the same','line_number':44,'multiline':False]['text':' way when you access attributes on them.','line_number':45,'multiline':False]['text':' ConcreteModuleType has two phases.','line_number':47,'multiline':False]['text':' 1. Creation: First we build it up, during the ScriptModule conversion','line_number':48,'multiline':False]['text':' process. This is represented by ConcreteModuleTypeBuilder.','line_number':49,'multiline':False]['text':'    ...then the converter calls ConcreteModuleTypeBuilder::build(), producing','line_number':50,'multiline':False]['text':'    a','line_number':51,'multiline':False]['text':'       ConcreteModuleType ready for querying.','line_number':52,'multiline':False]['text':' 2. Querying: We use ConcreteModuleType as a source of truth for','line_number':53,'multiline':False]['text':' ModuleValue::attr calls during method compilation.','line_number':54,'multiline':False]['text':' Represents a concrete type during in the process for construction. We use','line_number':56,'multiline':False]['text':' this to decide whether we can share types between modules.','line_number':57,'multiline':False]['text':' If a ConcreteModuleType is poisoned, it will never compare equal to any','line_number':90,'multiline':False]['text':' other concrete type','line_number':91,'multiline':False]['text':' This determines whether two modules can share a type. The container structs','line_number':98,'multiline':False]['text':' used by ConcreteModuleType have been defined such that operator==','line_number':99,'multiline':False]['text':' implements a meaningful comparison in that context.','line_number':100,'multiline':False]['text':' Functions are not first class, so we can't do type comparison like a','line_number':110,'multiline':False]['text':' regular attribute. So we do a pointer equality check on the actual','line_number':111,'multiline':False]['text':' Python function object.','line_number':112,'multiline':False]['text':' If true, this type will never compare equally to anything else. This is','line_number':143,'multiline':False]['text':' used if we want to ensure that this type is not shared (for example, if it','line_number':144,'multiline':False]['text':' came from a traced module)','line_number':145,'multiline':False]['text':' The value of any constants defined by the module.','line_number':148,'multiline':False]['text':' The types of any attributes','line_number':150,'multiline':False]['text':' Overloads, in the same format as `__overloads__` in Python','line_number':152,'multiline':False]['text':' Any attributes we failed to convert to TorchScript, along with a hint as to','line_number':154,'multiline':False]['text':' why','line_number':155,'multiline':False]['text':' Any attributes that were marked as ignored. They cannot be used in','line_number':157,'multiline':False]['text':' TorchScript but can still be used in ignored function in Python.','line_number':158,'multiline':False]['text':' Any function attributes. These are special right now because functions are','line_number':160,'multiline':False]['text':' not first-class in the type system.','line_number':161,'multiline':False]['text':' Function attributes that are calls to builtin functions. These get','line_number':163,'multiline':False]['text':' de-sugared directly into the corresponding aten:: call. The map is','line_number':164,'multiline':False]['text':' attribute name -> aten symbol name','line_number':165,'multiline':False]['text':' The concrete types of any submodules','line_number':167,'multiline':False]['text':' Hooks to be called before/after forward when the module','line_number':169,'multiline':False]['text':' is called directly. Used to ensure modules have different types','line_number':170,'multiline':False]['text':' when they have different python hooks','line_number':171,'multiline':False]['text':' Actual hooks are added to ClassType directly during compilation','line_number':172,'multiline':False]['text':' If something is a ModuleDict/ModuleList, it means:','line_number':176,'multiline':False]['text':'   1. The order of the submodules matters for comparing the type','line_number':177,'multiline':False]['text':'   2. The compiler is allowed to treat it like a dict/tuple','line_number':178,'multiline':False]['text':' The original `nn.Module` class that we derived this ScriptModule from.','line_number':181,'multiline':False]['text':' NOTE: If you ever add any more state to this struct, you need to make sure','line_number':184,'multiline':False]['text':' operator== still makes sense!','line_number':185,'multiline':False]['text':' Represents a finalized concrete type, used to service ModuleValue::attr calls','line_number':189,'multiline':False]['text':' during method compilation.','line_number':190,'multiline':False]['text':' These getters are only here to return things as types that can be','line_number':209,'multiline':False]['text':' automatically converted by pybind.','line_number':210,'multiline':False]['text':' If the computed types are the same, these modules can (obviously) share','line_number':219,'multiline':False]['text':' a type.','line_number':220,'multiline':False]['text':' The JIT type derived from this ConcreteModuleType.','line_number':235,'multiline':False]['text':' namespace jit','line_number':240,'multiline':False]['text':' namespace torch','line_number':241,'multiline':False]