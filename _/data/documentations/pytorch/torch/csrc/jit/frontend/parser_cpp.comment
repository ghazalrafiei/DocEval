['text':' `self` argument','line_number':17,'multiline':False]['text':' Merge signature idents and ranges with annotation types','line_number':30,'multiline':False]['text':' whenever we parse something that has a TreeView type we always','line_number':53,'multiline':False]['text':' use its create method so that the accessors and the constructor','line_number':54,'multiline':False]['text':' of the Compound tree are in the same place.','line_number':55,'multiline':False]['text':' exp | expr, | expr, expr, ...','line_number':92,'multiline':False]['text':' things like a 1.0 or a(4) that are not unary/binary expressions','line_number':107,'multiline':False]['text':' and have higher precedence than all of them','line_number':108,'multiline':False]['text':'/ here we have the empty tuple case','line_number':127,'multiline':False]['text':' If we have a dict literal, `keys` and `values` will store the keys','line_number':154,'multiline':False]['text':' and values used in the object's construction. EDGE CASE: We have a','line_number':155,'multiline':False]['text':' dict comprehension, so we'll get the first element of the dict','line_number':156,'multiline':False]['text':' comprehension in `keys` and a list comprehension in `values`.','line_number':157,'multiline':False]['text':' For example, `{i : chr(i + 65) for i in range(4)}` would give us','line_number':158,'multiline':False]['text':' `i` in `keys` and `chr(i + 65) for i in range(4)` in `values`.','line_number':159,'multiline':False]['text':' The optimal way of handling this case is to simply splice the new','line_number':160,'multiline':False]['text':' dict comprehension together from the existing list comprehension.','line_number':161,'multiline':False]['text':' Splicing prevents breaking changes to our API and does not require','line_number':162,'multiline':False]['text':' the use of global variables.','line_number':163,'multiline':False]['text':' no reduction','line_number':241,'multiline':False]['text':' parse the longest expression whose binary operators have','line_number':257,'multiline':False]['text':' precedence strictly greater than 'precedence'','line_number':258,'multiline':False]['text':' precedence == 0 will parse _all_ expressions','line_number':259,'multiline':False]['text':' this is the core loop of 'top-down precedence parsing'','line_number':260,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':266,'multiline':False]['text':' fold '-' into constant numbers, so that attributes can accept','line_number':276,'multiline':False]['text':' things like -1','line_number':277,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':286,'multiline':False]['text':' not allowed to parse something which is','line_number':289,'multiline':False]['text':' not greater than 'precedence'','line_number':290,'multiline':False]['text':' NB: `not in` is just `not( in )`, so we don't introduce new tree view','line_number':300,'multiline':False]['text':' but just make it a nested call in our tree view structure','line_number':301,'multiline':False]['text':' special case for trinary operator','line_number':307,'multiline':False]['text':' TK_FOR targets should only parse exprs prec greater than 4, which','line_number':314,'multiline':False]['text':' only includes subset of Exprs that suppose to be on the LHS according','line_number':315,'multiline':False]['text':' to the python grammar','line_number':316,'multiline':False]['text':' https://docs.python.org/3/reference/grammar.html','line_number':317,'multiline':False]['text':' parse LHS acceptable exprs, which only includes subset of Exprs that prec','line_number':391,'multiline':False]['text':' is greater than 4 according to the python grammar','line_number':392,'multiline':False]['text':' Parse expr's of the form [a:], [:b], [a:b], [:] and all variations with','line_number':397,'multiline':False]['text':' "::"','line_number':398,'multiline':False]['text':' NB: parseExp must not be called inline, since argument evaluation order','line_number':439,'multiline':False]['text':' changes when L.cur().range is mutated with respect to the parseExp()','line_number':440,'multiline':False]['text':' call.','line_number':441,'multiline':False]['text':' NB: parseExp must not be called inline, since argument evaluation order','line_number':454,'multiline':False]['text':' changes when L.cur().range is mutated with respect to the parseExp()','line_number':455,'multiline':False]['text':' call.','line_number':456,'multiline':False]['text':'kwarg_only=','line_number':477,'multiline':True]['text':' 'first' has already been parsed since expressions can exist','line_number':495,'multiline':False]['text':' alone on a line:','line_number':496,'multiline':False]['text':' first[,other,lhs] = rhs','line_number':497,'multiline':False]['text':' There is an assignment operator, parse the RHS and generate the','line_number':502,'multiline':False]['text':' assignment.','line_number':503,'multiline':False]['text':' this is an augmented assignment','line_number':523,'multiline':False]['text':' There is no assignment operator, so this is of the form `lhs : <type>`','line_number':532,'multiline':False]['text':'is_method=','line_number':599,'multiline':True]['text':' If the current token is TK_AS, this with item is of the form','line_number':627,'multiline':False]['text':' "expression as target".','line_number':628,'multiline':False]['text':' If not, this with item is of the form "expression".','line_number':635,'multiline':False]['text':'expect_indent=','line_number':647,'multiline':True]['text':'expect_indent=','line_number':651,'multiline':True]['text':' NB: this needs to be a separate statement, since the call to parseIf','line_number':653,'multiline':False]['text':' mutates the lexer state, and thus causes a heap-use-after-free in','line_number':654,'multiline':False]['text':' compilers which evaluate argument expressions LTR','line_number':655,'multiline':False]['text':'expect_indent=','line_number':667,'multiline':True]['text':'expect_indent=','line_number':676,'multiline':True]['text':' Parse "with expression [as target][, expression [as target]]*:".','line_number':682,'multiline':False]['text':' Parse the body.','line_number':685,'multiline':False]['text':'expect_indent=','line_number':686,'multiline':True]['text':' Exactly one expression for return type annotation','line_number':704,'multiline':False]['text':' Parse return type annotation','line_number':726,'multiline':False]['text':' Only support inheriting from NamedTuple right now.','line_number':740,'multiline':False]['text':'expect_indent=','line_number':747,'multiline':True]['text':'in_class=','line_number':747,'multiline':True]['text':' Handle type annotations specified in a type comment as the first line','line_number':759,'multiline':False]['text':' of the function.','line_number':760,'multiline':False]['text':' Special case: the Python grammar allows one-line functions with a','line_number':769,'multiline':False]['text':' single statement.','line_number':770,'multiline':False]['text':' short helpers to create nodes','line_number':789,'multiline':False]['text':' namespace torch::jit','line_number':824,'multiline':False]