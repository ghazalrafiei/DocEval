['text':' single character tokens are just the character itself '+'','line_number':25,'multiline':False]['text':' multi-character tokens need an entry here','line_number':26,'multiline':False]['text':' if the third entry is not the empty string, it is used','line_number':27,'multiline':False]['text':' in the lexer to match this token.','line_number':28,'multiline':False]['text':' These kinds are also used in Tree.h as the kind of the AST node.','line_number':30,'multiline':False]['text':' Some kinds TK_APPLY, TK_LIST are only used in the AST and are not seen in the','line_number':31,'multiline':False]['text':' lexer.','line_number':32,'multiline':False]['text':' we use characters to represent themselves so skip all valid characters','line_number':131,'multiline':False]['text':' before','line_number':132,'multiline':False]['text':' assigning enum values to multi-char tokens.','line_number':133,'multiline':False]['text':' nested hash tables that indicate char-by-char what is a valid token.','line_number':143,'multiline':False]['text':' 0 == invalid token','line_number':166,'multiline':False]['text':' stuff that is shared against all TC lexers/parsers and is initialized only','line_number':172,'multiline':False]['text':' once.','line_number':173,'multiline':False]['text':' are we inside a scope where newlines don't count','line_number':192,'multiline':False]['text':' (e.g. inside parens)','line_number':193,'multiline':False]['text':' should we treat whitespace as a token','line_number':194,'multiline':False]['text':' skip whitespace','line_number':199,'multiline':False]['text':' special handling','line_number':204,'multiline':False]['text':' skip comments','line_number':207,'multiline':False]['text':' tail call, handle whitespace and more comments','line_number':210,'multiline':False]['text':' we handle white space before EOF because in the case we have something','line_number':225,'multiline':False]['text':' like the following where we need to generate the dedent token if foo:','line_number':226,'multiline':False]['text':'   ...','line_number':227,'multiline':False]['text':' else:','line_number':228,'multiline':False]['text':'   pass','line_number':229,'multiline':False]['text':' invariant: the next token is not whitespace or newline','line_number':241,'multiline':False]['text':' check for a valid number','line_number':243,'multiline':False]['text':' check for string','line_number':251,'multiline':False]['text':' check for either an ident or a token','line_number':259,'multiline':False]['text':' ident tracks whether what we have scanned so far could be an identifier','line_number':260,'multiline':False]['text':' matched indicates if we have found any match.','line_number':261,'multiline':False]['text':' for (size_t i = 0; pos + i < str.size() && (ident || cur != nullptr);','line_number':265,'multiline':False]['text':' i++)','line_number':266,'multiline':False]['text':' check for token second, so that e.g. 'max' matches the token TK_MAX','line_number':275,'multiline':False]['text':' rather the','line_number':276,'multiline':False]['text':' identifier 'max'','line_number':277,'multiline':False]['text':' 1. skip whitespace','line_number':314,'multiline':False]['text':' 2. handle comment or newline','line_number':315,'multiline':False]['text':'','line_number':316,'multiline':False]['text':' strtod allows numbers to start with + or - or nan or inf','line_number':319,'multiline':False]['text':' http://en.cppreference.com/w/cpp/string/byte/strtof','line_number':320,'multiline':False]['text':' but we want only the number part, otherwise 1+3 will turn into two','line_number':321,'multiline':False]['text':' adjacent numbers in the lexer','line_number':322,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':326,'multiline':False]['text':' check if the number is complex valued','line_number':330,'multiline':False]['text':' access is safe because string is assumed to be null terminated','line_number':331,'multiline':False]['text':' count checks from [start, start + len)','line_number':339,'multiline':False]['text':' python concatenates all adjacent strings "a" "b" == "ab"','line_number':344,'multiline':False]['text':' strings can be enclosed with 1 or 3 single or double quotes','line_number':345,'multiline':False]['text':' if enclosed with 3 quotes newlines are valid','line_number':346,'multiline':False]['text':' as elsewhere, backslash and new line should be ignored','line_number':347,'multiline':False]['text':' end is now set past the opening quotation marks','line_number':354,'multiline':False]['text':' handle escaped characters. advances past escaped quotation marks,','line_number':360,'multiline':False]['text':' escaped newlines and escaped backslashes','line_number':361,'multiline':False]['text':' multi-char escapes like \x1A are handled fine here because the','line_number':362,'multiline':False]['text':' remainder of the escape are valid string characters anyway','line_number':363,'multiline':False]['text':' set length equal to the complete string including quotations','line_number':369,'multiline':False]['text':' if end finished without going past the last character of the string than','line_number':371,'multiline':False]['text':' there is a match','line_number':372,'multiline':False]['text':' Make an exception ignoring comments for type annotation comments','line_number':390,'multiline':False]['text':' Return the current token, and then move to the next one','line_number':429,'multiline':False]['text':' Skip the current token if it matches the given kind','line_number':440,'multiline':False]['text':' Check that the current token has a given kind, return the current token,','line_number':467,'multiline':False]['text':' and advance to the next one.','line_number':468,'multiline':False]['text':' note: TK_WHITESPACE_EOF is whitespace right before the EOF token','line_number':504,'multiline':False]['text':' just like we allow the code to be indented to a particular initial','line_number':505,'multiline':False]['text':' indent level, we allow the final indent to be anything and set','line_number':506,'multiline':False]['text':' it back to the initial indent level. This allows the code to be','line_number':507,'multiline':False]['text':' put into string literals inside code without worrying about final','line_number':508,'multiline':False]['text':' whitespace','line_number':509,'multiline':False]['text':' We've already queued the tokens','line_number':524,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':533,'multiline':False]['text':' depth of ( [ { nesting...','line_number':567,'multiline':False]['text':' stack of indentation level of blocks','line_number':568,'multiline':False]['text':' Invariant: this should always contain at least a single element','line_number':569,'multiline':False]['text':' namespace jit','line_number':573,'multiline':False]['text':' namespace torch','line_number':574,'multiline':False]