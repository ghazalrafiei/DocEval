['text':' The visibility attribute is to avoid a warning about storing a field in the','line_number':48,'multiline':False]['text':' struct that has a different visibility (from pybind) than the struct.','line_number':49,'multiline':False]['text':' Hack to overload the behavior of toIValue to accept Python','line_number':69,'multiline':False]['text':' numbers in places where a Tensor is expected','line_number':70,'multiline':False]['text':' See also torch::should_allow_numbers_as_tensors','line_number':71,'multiline':False]['text':' Wrap Python function to guard deref','line_number':80,'multiline':False]['text':' NB: Need VISIBILITY_HIDDEN for silencing compiler error,','line_number':81,'multiline':False]['text':' 'torch::jit::PythonFunctionGuard' declared with greater visibility than the','line_number':82,'multiline':False]['text':' type of its field 'torch::jit::PythonFunctionGuard::func_'','line_number':83,'multiline':False]['text':' explicitly setting PyObject* to nullptr to prevent py::object's dtor to','line_number':90,'multiline':False]['text':' decref on the PyObject again.','line_number':91,'multiline':False]['text':' See Note [Destructing py::object] in python_ivalue.h','line_number':92,'multiline':False]['text':' The PythonFutureWrapper for ivalue::Future','line_number':99,'multiline':False]['text':'','line_number':100,'multiline':False]['text':' NB: VISIBILITY_HIDDEN is for silencing compiling error,','line_number':101,'multiline':False]['text':' "error: 'torch::jit::PythonFutureWrapper' declared with greater visibility','line_number':102,'multiline':False]['text':' than the type of its field 'torch::jit::PythonFutureWrapper::unwrap_func'','line_number':103,'multiline':False]['text':' [-Werror=attributes]"','line_number':104,'multiline':False]['text':'','line_number':105,'multiline':False]['text':' NB: inherit from enable_shared_from_this because then(py::function) needs to','line_number':106,'multiline':False]['text':'     get a shared_ptr from this pointer.','line_number':107,'multiline':False]['text':' acquiring GIL as toPyObject creates new py::object','line_number':125,'multiline':False]['text':' without grabbing the GIL.','line_number':126,'multiline':False]['text':' unwrap_func is a general compositional function that takes in a','line_number':129,'multiline':False]['text':' py::object and executes some python function. It is currently mostly used','line_number':130,'multiline':False]['text':' to throw python exceptions.','line_number':131,'multiline':False]['text':' The py::function cb arg must take a std::shared_ptr<PythonFutureWrapper>','line_number':150,'multiline':False]['text':' (i.e., torch._C.Future) as the only argument. If the type mismatches, an','line_number':151,'multiline':False]['text':' error will be thrown when waiting for the value of this returned Future.','line_number':152,'multiline':False]['text':' We need this an additional layer of wrapper here to guard the','line_number':154,'multiline':False]['text':' destruction of the py::function object. Because, the','line_number':155,'multiline':False]['text':' Future owns a reference to the py::function in its callback','line_number':156,'multiline':False]['text':' vector, but Future does not acquire GIL on destruction.','line_number':157,'multiline':False]['text':' Capture a copy of the ivalue::Future instead of the `this` pointer','line_number':161,'multiline':False]['text':' because the PythonFutureWrapper object could have been deleted','line_number':162,'multiline':False]['text':' when the callbacks are fired. For example, RPC only captures the','line_number':163,'multiline':False]['text':' ivalue::Future instead of PythonFutureWrapper in JitFuture's','line_number':164,'multiline':False]['text':' callback functions. Hence, if user code does not hold a reference to','line_number':165,'multiline':False]['text':' this PythonFutureWrapper object, there is no guarantee that the','line_number':166,'multiline':False]['text':' PythonFutureWrapper is still valid when running the callback.','line_number':167,'multiline':False]['text':' unused ','line_number':169,'multiline':True]['text':' Release ownership on py::objects and also restore Python','line_number':179,'multiline':False]['text':' Error Indicator.','line_number':180,'multiline':False]['text':' Clear the Python Error Indicator as we has recorded the','line_number':182,'multiline':False]['text':' exception in the response message.','line_number':183,'multiline':False]['text':' NOLINTNEXTLINE(modernize-avoid-bind)','line_number':195,'multiline':False]['text':' Release ownership on py::objects and also restore Python','line_number':204,'multiline':False]['text':' Error Indicator.','line_number':205,'multiline':False]['text':' Clear the Python Error Indicator as we has recorded the','line_number':207,'multiline':False]['text':' exception in the response message.','line_number':208,'multiline':False]['text':' Log and ignore exceptions raised through the callback','line_number':211,'multiline':False]['text':' Log and ignore exceptions raised through the callback','line_number':216,'multiline':False]['text':' unwrap_func works like a callback for the value returned by','line_number':233,'multiline':False]['text':' PythonFutureWrapper::wait().','line_number':234,'multiline':False]['text':' The PythonAwaitWrapper for ivalue::Await','line_number':243,'multiline':False]['text':'','line_number':244,'multiline':False]['text':' Expresses delayed function execution with Lazy semantic.','line_number':245,'multiline':False]['text':' i.e. Await[W] in eager mode can be used as W.','line_number':246,'multiline':False]['text':' When the attribute of W type is requested, Await[W] will return the','line_number':247,'multiline':False]['text':' attribute of W, transparently calling wait() beforehand.','line_number':248,'multiline':False]['text':' No Lazy semantic for script, explicit wait(Await[W]) -> W must be called to','line_number':249,'multiline':False]['text':' convert to type W.','line_number':250,'multiline':False]['text':'','line_number':251,'multiline':False]['text':' The Await object takes shared ownership of specified function and the','line_number':252,'multiline':False]['text':' arguments. After first call for wait() it owns the result. Deliberately no','line_number':253,'multiline':False]['text':' type inference for eager mode.','line_number':254,'multiline':False]['text':' Nowait semantic means trivial case when Await is constructed from the','line_number':286,'multiline':False]['text':' result','line_number':287,'multiline':False]['text':' error reporting: when reporting user-caused errors, these functions should','line_number':316,'multiline':False]['text':' not use AT_ERROR macros, since these macros add stack trace information','line_number':317,'multiline':False]['text':' that is confusing to display to the end user since it always reports','line_number':318,'multiline':False]['text':' locations in libtorch code rather than user code.','line_number':319,'multiline':False]['text':' Try to infer the type of a Python object','line_number':364,'multiline':False]['text':' The type cannot be inferred if:','line_number':365,'multiline':False]['text':'   input is an empty container (list, dict)','line_number':366,'multiline':False]['text':'   input is an list with element types that cannot be unified','line_number':367,'multiline':False]['text':'   input is an dict with key or value types that cannot be unified','line_number':368,'multiline':False]['text':' Try tensor types','line_number':370,'multiline':False]['text':' Try basic types first','line_number':384,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-branch-clone)','line_number':387,'multiline':False]['text':' Assume that the class is compiled already or will compile. Invalidate','line_number':425,'multiline':False]['text':' this later if needed.','line_number':426,'multiline':False]['text':' Check if the type is already compiled.','line_number':429,'multiline':False]['text':' If not, try to compile it.','line_number':434,'multiline':False]['text':' Try to compile the class. This is wrapped in a try-catch because','line_number':439,'multiline':False]['text':' compilation of class types can raise an Exception and in that case,','line_number':440,'multiline':False]['text':' we want to defer to other attempts at type inference below rather','line_number':441,'multiline':False]['text':' than fail compilation altogether.','line_number':442,'multiline':False]['text':' Invalidate the assumption that the class compiled so that we don't','line_number':448,'multiline':False]['text':' look up and return its JIT type as the type for the input.','line_number':449,'multiline':False]['text':' If the class compiled successfully, look up the existing JIT type by','line_number':455,'multiline':False]['text':' qualified name and return it.','line_number':456,'multiline':False]['text':' Try container types','line_number':498,'multiline':False]['text':' Forward error message along','line_number':513,'multiline':False]['text':' Check to make sure we can generate useful input/output types','line_number':519,'multiline':False]['text':' Try to infer the key type and unify it with the existing one','line_number':530,'multiline':False]['text':' Try to infer the value type and unify it with the existing one','line_number':545,'multiline':False]['text':' TODO: this message is not correct anymore, since this InferredType is','line_number':593,'multiline':False]['text':' used from a bunch of circumstances unrelated to tracing. We can re-use','line_number':594,'multiline':False]['text':' this instead of the attribute_failure stuff in concreteType','line_number':595,'multiline':False]['text':' if obj is already a ScriptModule, just return its ivalue','line_number':636,'multiline':False]['text':' explict copy semantics for strong ownership of the resource.','line_number':638,'multiline':False]['text':' Check if the obj is a ScriptObject.','line_number':643,'multiline':False]['text':' Serialize the python dictionary into a traceable stack.','line_number':666,'multiline':False]['text':' Extract custom class registered with torchbind','line_number':706,'multiline':False]['text':' Small wrapper around getting the type name string from Python to make','line_number':716,'multiline':False]['text':' types easier to interpret, e.g. give the structural type for a NamedTuple','line_number':717,'multiline':False]['text':' Thrown when trying to create a schema for a list of python','line_number':740,'multiline':False]['text':' arguments that cannot be converted.','line_number':741,'multiline':False]['text':' Can be caught by the caller to attempt to use other schema','line_number':742,'multiline':False]['text':' when there is an overloaded operator.','line_number':743,'multiline':False]['text':'implicit','line_number':808,'multiline':True]['text':' First push all positional args.','line_number':857,'multiline':False]['text':' ...but refuse to do it if the schema says that this was supposed','line_number':859,'multiline':False]['text':' to be keyword only','line_number':860,'multiline':False]['text':' Use the type information from the schema to convert the PyObject.','line_number':871,'multiline':False]['text':' Now for every remaining non-positional argument in the schema, look for it','line_number':876,'multiline':False]['text':' in the kwargs dict and push it if found, or use its default value if it','line_number':877,'multiline':False]['text':' has one.','line_number':878,'multiline':False]['text':' Return a simple value and not a single-element tuple if there is only one','line_number':913,'multiline':False]['text':' return value.','line_number':914,'multiline':False]['text':' If there is more than one return value, pop them into a py::tuple.','line_number':919,'multiline':False]['text':' TODO: Remove once we clean up the GraphExecutor usage.','line_number':928,'multiline':False]['text':' Run `callee`, potentially inserting a CallFunction/CallMethod node into the','line_number':946,'multiline':False]['text':' tracing graph.','line_number':947,'multiline':False]['text':' Lambda that tells this function how to insert `callee` into the graph if','line_number':953,'multiline':False]['text':' we're tracing.','line_number':954,'multiline':False]['text':' If we're not tracing, just run the callee as normal.','line_number':962,'multiline':False]['text':' If we are tracing, insert the appropriate CallFunction or CallMethod node','line_number':965,'multiline':False]['text':' and then run the callee with tracing disabled.','line_number':966,'multiline':False]['text':' Get the graph `Value`s that represent the input IValues','line_number':968,'multiline':False]['text':' Add a call node.','line_number':981,'multiline':False]['text':' Actually run the callee. Pause the tracer so that we don't double-add the','line_number':990,'multiline':False]['text':' callee nodes.','line_number':991,'multiline':False]['text':' Associate the output IValues with the output `Value`s in the graph','line_number':998,'multiline':False]['text':' Handle __torch_function__ dispatch','line_number':1019,'multiline':False]['text':' throw_error ','line_number':1028,'multiline':True]['text':' NB: for kwargs, we cannot guarantee the order of appending','line_number':1030,'multiline':False]['text':' is the same as the argument order in operator's schema.','line_number':1031,'multiline':False]['text':' This is suboptimal, but should be fine. Later when we have','line_number':1032,'multiline':False]['text':' better schema matching and argument parsing, we could','line_number':1033,'multiline':False]['text':' match the operator in `operations` first, then the order will','line_number':1034,'multiline':False]['text':' be guaranteed.','line_number':1035,'multiline':False]['text':' throw_error ','line_number':1042,'multiline':True]['text':'overloaded_args=','line_number':1047,'multiline':True]['text':'args=','line_number':1048,'multiline':True]['text':'kwargs=','line_number':1049,'multiline':True]['text':'func_name=','line_number':1050,'multiline':True]['text':'torch_api_function=','line_number':1051,'multiline':True]['text':'module_name=','line_number':1052,'multiline':True]['text':' TODO: we could add __torch_function__ dispatch here but I don't know','line_number':1062,'multiline':False]['text':' the implications of doing so','line_number':1063,'multiline':False]['text':'self=','line_number':1069,'multiline':True]['text':' namespace torch::jit','line_number':1115,'multiline':False]