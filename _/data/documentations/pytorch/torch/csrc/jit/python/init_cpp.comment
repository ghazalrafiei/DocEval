['text':' #include <torch/csrc/jit/codegen/cuda/python_frontend/python_bindings.h>','line_number':10,'multiline':False]['text':' Leaving this code here, because it will likely be useful at some point','line_number':139,'multiline':False]['text':' PyObject *jit_module = PyImport_ImportModule("torch.jit");','line_number':140,'multiline':False]['text':' THPUtils_assert(jit_module, "class loader couldn't access "','line_number':141,'multiline':False]['text':'"torch.jit module");','line_number':142,'multiline':False]['text':' PyObject *jit_dict = PyModule_GetDict(jit_module);','line_number':143,'multiline':False]['text':' Errors need to be caught here because toTypeInferredIValue errors out','line_number':155,'multiline':False]['text':' on various object types, but we want it to work with all types.','line_number':156,'multiline':False]['text':' anonymous namespace','line_number':163,'multiline':False]['text':' This is a static object, so we must leak the Python object','line_number':173,'multiline':False]['text':' "release()" is used here to preserve 1 refcount on the','line_number':174,'multiline':False]['text':' object, preventing it from ever being de-allocated by CPython.','line_number':175,'multiline':False]['text':' special handling of JITException, to set its python class name and msg','line_number':185,'multiline':False]['text':' If we still had the py::exception<JITException> object, we could','line_number':191,'multiline':False]['text':' just call it. But we must get a handle to leak it and there is no','line_number':192,'multiline':False]['text':' way I can find to re-create it from the handle. So setting the','line_number':193,'multiline':False]['text':' exception manually','line_number':194,'multiline':False]['text':' NOLINT(bugprone-unused-raii)','line_number':208,'multiline':False]['text':' using Node* here instead of Schema because looking up the schema','line_number':235,'multiline':False]['text':' and passing it in from Python will have a different pointer than the','line_number':236,'multiline':False]['text':' schema that is globally used for caching','line_number':237,'multiline':False]['text':' because this is invoked by python, the function schema *','line_number':251,'multiline':False]['text':' becomes different, and we need to find and reuse the','line_number':252,'multiline':False]['text':' one that is used for caching','line_number':253,'multiline':False]['text':' overload resolution','line_number':292,'multiline':False]['text':' overload','line_number':301,'multiline':False]['text':' resolution','line_number':302,'multiline':False]['text':' overload resolution','line_number':307,'multiline':False]['text':' overload resolution','line_number':312,'multiline':False]['text':' RemoveInplaceOps is used by CoreML so it must be removed with care.','line_number':492,'multiline':False]['text':' captures?','line_number':555,'multiline':False]['text':' We only get partial specialization from the arg_spec_creator, but','line_number':561,'multiline':False]['text':' we want full shape specialization. The alternative would be to','line_number':562,'multiline':False]['text':' have a "complete type inference" function in ArguemntSpecCreator.','line_number':563,'multiline':False]['text':' captures?','line_number':576,'multiline':False]['text':' captures?','line_number':596,'multiline':False]['text':' captures?','line_number':613,'multiline':False]['text':' the easiest way to replace a graph in a module is','line_number':621,'multiline':False]['text':' to remove all the nodes in the original graph','line_number':622,'multiline':False]['text':' clone everything from the traced one','line_number':623,'multiline':False]['text':' We have to release the GIL inside this method, because if we','line_number':687,'multiline':False]['text':' happen to initialize the autograd engine in these tests, the','line_number':688,'multiline':False]['text':' newly spawned worker threads will try to initialize their','line_number':689,'multiline':False]['text':' PyThreadState*, and they need the GIL for this.','line_number':690,'multiline':False]['text':' the python binding slightly differs in semantics','line_number':726,'multiline':False]['text':' it makes a copy of the input Graph, and works on that','line_number':727,'multiline':False]['text':' jit::differentiate mutates the input Graph','line_number':728,'multiline':False]['text':' pybind can't automatically bind to atomic size_t','line_number':848,'multiline':False]['text':' Dummy CompleteTensorType to appease ONNX validator.','line_number':1162,'multiline':False]['text':' NB: This isn't actually used for regular PyTorch symbolic tracing;','line_number':1174,'multiline':False]['text':' XLA is what needs this','line_number':1175,'multiline':False]['text':' clang-format off','line_number':1189,'multiline':False]['text':' These DO NOT install magic methods; the SymInt/SymFloat wrapper in','line_number':1190,'multiline':False]['text':' Python is responsible for this','line_number':1191,'multiline':False]['text':' clang-format on','line_number':1298,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-unused-raii)','line_number':1300,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-unused-raii)','line_number':1307,'multiline':False]['text':' we leave an empty entry for node that doesn't have an','line_number':1327,'multiline':False]['text':' optimized plan','line_number':1328,'multiline':False]['text':' Writing an empty file is a noop','line_number':1372,'multiline':False]['text':' This allows PyTorchStreamReader to read from a Python buffer. It requires','line_number':1421,'multiline':False]['text':' that the buffer implement `seek()`, `tell()`, and `read()`.','line_number':1422,'multiline':False]['text':' Jump to the end of the buffer to get its size','line_number':1426,'multiline':False]['text':' If we can read directly into a buffer, do that instead of an extra copy','line_number':1433,'multiline':False]['text':' Seek to desired position (NB: this has to be a Py_ssize_t or Python','line_number':1452,'multiline':False]['text':' throws a weird error)','line_number':1453,'multiline':False]['text':' Read bytes into `buf` from the buffer','line_number':1470,'multiline':False]['text':'allocator=','line_number':1519,'multiline':True]['text':'resizable=','line_number':1520,'multiline':True]['text':' Used by torch.Package to coordinate deserialization of storages across','line_number':1538,'multiline':False]['text':' ScriptModules and eager modules','line_number':1539,'multiline':False]['text':'is_overload','line_number':1604,'multiline':True]['text':'is_overload','line_number':1613,'multiline':True]['text':' No such operator','line_number':1658,'multiline':False]['text':' For normalization purposes there is an inconsistency within','line_number':1758,'multiline':False]['text':' torch.fx that turns all arguments named "self" into "input".','line_number':1759,'multiline':False]['text':' Thus this check ensures that those arguments are checked','line_number':1760,'multiline':False]['text':' correctly.','line_number':1761,'multiline':False]['text':' For normalization purposes there is an inconsistency within','line_number':1779,'multiline':False]['text':' torch.fx that','line_number':1780,'multiline':False]['text':' turns all arguments named "self" into "input". Thus this check','line_number':1781,'multiline':False]['text':' ensures that those arguments are checked correctly.','line_number':1782,'multiline':False]['text':' Intentionally not releasing GIL','line_number':1910,'multiline':False]['text':' Intentionally not releasing GIL','line_number':1930,'multiline':False]['text':' Intentionally not releasing GIL as this just does an assign','line_number':1934,'multiline':False]['text':' __getstate__ ','line_number':1949,'multiline':True]['text':' unused ','line_number':1950,'multiline':True]['text':' Note that this return has no meaning since we always','line_number':1952,'multiline':False]['text':' throw, it's only here to satisfy Pybind API's','line_number':1953,'multiline':False]['text':' requirement.','line_number':1954,'multiline':False]['text':' __setstate__ ','line_number':1957,'multiline':True]['text':' unused ','line_number':1958,'multiline':True]['text':' NOLINT','line_number':1958,'multiline':False]['text':' Note that this return has no meaning since we always','line_number':1960,'multiline':False]['text':' throw, it's only here to satisfy PyBind's API','line_number':1961,'multiline':False]['text':' requirement.','line_number':1962,'multiline':False]['text':' In eager mode allow Await[W] to be used as W, redirecting getattr','line_number':1980,'multiline':False]['text':' to the result of delayed function.','line_number':1981,'multiline':False]['text':' __getstate__ ','line_number':1986,'multiline':True]['text':' unused ','line_number':1987,'multiline':True]['text':' Note that this return has no meaning since we always','line_number':1989,'multiline':False]['text':' throw, it's only here to satisfy Pybind API's','line_number':1990,'multiline':False]['text':' requirement.','line_number':1991,'multiline':False]['text':' __setstate__ ','line_number':1994,'multiline':True]['text':' unused ','line_number':1995,'multiline':True]['text':' NOLINT','line_number':1995,'multiline':False]['text':' Note that this return has no meaning since we always','line_number':1997,'multiline':False]['text':' throw, it's only here to satisfy PyBind's API','line_number':1998,'multiline':False]['text':' requirement.','line_number':1999,'multiline':False]['text':' Only return true if we are certain that self and other are aliasing.','line_number':2008,'multiline':False]['text':' Only return true if we are certain that self and other are overlapping.','line_number':2018,'multiline':False]['text':' Insert new trace ops into the fork op's sub-block','line_number':2058,'multiline':False]['text':' Run the user-supplied function','line_number':2064,'multiline':False]['text':' Convert the output of the user-supplied function to IValue. The type','line_number':2067,'multiline':False]['text':' information of this IValue is used both to record the correct type in','line_number':2068,'multiline':False]['text':' the trace.','line_number':2069,'multiline':False]['text':' Record the ivalue in the tracer','line_number':2080,'multiline':False]['text':' stuff the ivalue output in the Future','line_number':2083,'multiline':False]['text':' unwrap_func ','line_number':2116,'multiline':True]['text':'unused','line_number':2116,'multiline':True]['text':' Throw errors when calling wait() on the returned Future if','line_number':2117,'multiline':False]['text':' any of the original futures would throw.','line_number':2118,'multiline':False]['text':' NB: PythonFutureWrapper takes an unwrap_func which serves as a','line_number':2119,'multiline':False]['text':' callback to evalute the value in the Future. RPC uses this','line_number':2120,'multiline':False]['text':' unwrap_func to check whether the returned py::object is a','line_number':2121,'multiline':False]['text':' RemoteException object, and re-throw the exception if it is.','line_number':2122,'multiline':False]['text':' By extracting the c10::ivalue::Future from PythonFutureWrapper','line_number':2123,'multiline':False]['text':' the unwrap_func on the original PythonFutureWrapper objects are','line_number':2124,'multiline':False]['text':' discarded, and hence it will return the RemoteException as an','line_number':2125,'multiline':False]['text':' object instead of re-throwing it.','line_number':2126,'multiline':False]['text':' defined(C10_SUPPORTS_SIGNAL_HANDLER)','line_number':2143,'multiline':False]['text':' initNvFuserPythonBindings(module);','line_number':2153,'multiline':False]['text':' On exit we need to reset the print handler to default one,','line_number':2165,'multiline':False]['text':' because otherwise prim::Print() instruction won't work for JIT modules.','line_number':2166,'multiline':False]['text':' namespace torch::jit','line_number':2172,'multiline':False]