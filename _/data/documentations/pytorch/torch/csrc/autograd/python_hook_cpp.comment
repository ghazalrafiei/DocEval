['text':' This function is called in 4 different cases:','line_number':34,'multiline':False]['text':'   1) TensorPreHook','line_number':35,'multiline':False]['text':'   2) PreHook','line_number':36,'multiline':False]['text':'   3) PostHook','line_number':37,'multiline':False]['text':'   4) TensorPostAccGradHook','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':' Depending on the case, args and res can hold different types of objects:','line_number':40,'multiline':False]['text':'','line_number':41,'multiline':False]['text':' args:','line_number':42,'multiline':False]['text':' TensorPreHook   (Tensor,)','line_number':43,'multiline':False]['text':' PreHook         ((Tensor, ...),)                (grad_outputs,)','line_number':44,'multiline':False]['text':' PostHook        ((Tensor, ...), (Tensor, ...))  (grad_inputs, grad_outputs)','line_number':45,'multiline':False]['text':' TensorPostAccGradHook  ((Tensor), ())                  (tensor,)','line_number':46,'multiline':False]['text':'','line_number':47,'multiline':False]['text':' res:','line_number':48,'multiline':False]['text':' TensorPreHook          Tensor','line_number':49,'multiline':False]['text':' PreHook                ((Tensor, ...),)                (grad_outputs,)','line_number':50,'multiline':False]['text':' PostHook               ((Tensor, ...),)                (grad_inputs,)','line_number':51,'multiline':False]['text':' TensorPostAccGradHook  None','line_number':52,'multiline':False]['text':'','line_number':53,'multiline':False]['text':' This function returns True if any hook returned non-None value, and False','line_number':54,'multiline':False]['text':' otherwise.','line_number':55,'multiline':False]['text':' Note: [Extend Hook Lifetime]','line_number':57,'multiline':False]['text':' Hold a reference to hooks till we iterate over them.','line_number':58,'multiline':False]['text':' This is to handle the case when hook calls `handle.remove` inside it','line_number':59,'multiline':False]['text':' and it's refcount goes to `0`, Python is free to GC it.','line_number':60,'multiline':False]['text':' We hold onto a stale pointer and subsequent call to','line_number':61,'multiline':False]['text':' `check_single_result`, which tries to fetch the `hook`'s name segfaults.','line_number':62,'multiline':False]['text':' So, we use `PyDict_Values` which returns a new reference to the values','line_number':63,'multiline':False]['text':' i.e. we hold the reference to the hooks till we have iterated over them.','line_number':64,'multiline':False]['text':' Reference: https://github.com/pytorch/pytorch/issues/58354','line_number':65,'multiline':False]['text':' namespace','line_number':94,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-exception-escape)','line_number':103,'multiline':False]['text':' If python is already dead, leak the wrapped python objects','line_number':105,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-exception-escape)','line_number':132,'multiline':False]['text':' If python is already dead, leak the wrapped python objects','line_number':134,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-exception-escape)','line_number':155,'multiline':False]['text':' If python is already dead, leak the wrapped python objects','line_number':157,'multiline':False]['text':' grad_inputs ','line_number':165,'multiline':True]['text':' grad_outputs ','line_number':166,'multiline':True]['text':' NOLINTNEXTLINE(bugprone-exception-escape)','line_number':212,'multiline':False]['text':' If python is already dead, leak the wrapped python objects','line_number':214,'multiline':False]['text':' namespace autograd','line_number':256,'multiline':False]['text':' namespace torch','line_number':257,'multiline':False]['text':' this should never happen, but just in case...','line_number':282,'multiline':False]