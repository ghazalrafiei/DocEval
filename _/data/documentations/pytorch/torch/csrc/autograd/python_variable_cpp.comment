['text':' About all the pointers:','line_number':60,'multiline':False]['text':'','line_number':61,'multiline':False]['text':' f(int x, int y = 0, *, int z = 0)','line_number':62,'multiline':False]['text':'                                  ^- arguments.size()','line_number':63,'multiline':False]['text':'                        ^- kwarg_only_start','line_number':64,'multiline':False]['text':'          ^- positional_default_start','line_number':65,'multiline':False]['text':'   ^- 0','line_number':66,'multiline':False]['text':' Find the split point between kwarg-only and regular.  Since most functions','line_number':68,'multiline':False]['text':' don't have kwarg-only arguments, it is more efficient to scan from the','line_number':69,'multiline':False]['text':' right (but ideally, this would just be precomputed in FunctionSchema','line_number':70,'multiline':False]['text':' itself).  (NB: minus one in the loop is because we're testing if the','line_number':71,'multiline':False]['text':' *next* argument is kwarg-only before we advance the starting index)','line_number':72,'multiline':False]['text':' Find the first positional argument that isn't defaulted','line_number':81,'multiline':False]['text':' Populate positional arguments','line_number':136,'multiline':False]['text':' Populate keyword arguments','line_number':142,'multiline':False]['text':' But don't populate default keyword arguments','line_number':144,'multiline':False]['text':' Check that we got a None return from Python. Anything else is an error.','line_number':163,'multiline':False]['text':' anonymous namespace','line_number':203,'multiline':False]['text':' clang-tidy gets confused by static const','line_number':215,'multiline':False]['text':' NOLINTNEXTLINE','line_number':231,'multiline':False]['text':' TODO: Make this take Variable by const reference','line_number':258,'multiline':False]['text':'ignore_hermetic_tls=','line_number':273,'multiline':True]['text':' C++ owns the Python object; this implies there weren't any other','line_number':279,'multiline':False]['text':' owning references to the Python object.  Since we're making the','line_number':280,'multiline':False]['text':' object "live" again on Python side, let's flip back the ownership','line_number':281,'multiline':False]['text':' (Python owns C++) as it would now be unsound to deallocate the C++','line_number':282,'multiline':False]['text':' object if all C++ references go to zero','line_number':283,'multiline':False]['text':' NB: incref is not necessary, because we are "stealing" the previous','line_number':287,'multiline':False]['text':' ownership from the Variable to return it here for the wrap','line_number':288,'multiline':False]['text':' TODO: a better invariant is that if we tagged, we MUST have a valid','line_number':294,'multiline':False]['text':' PyObject.  That's PyObject preservation','line_number':295,'multiline':False]['text':' (https://github.com/pytorch/pytorch/pull/56017).  Prior to this PR','line_number':296,'multiline':False]['text':' being a thing, the PyObject field will get cleared when all references','line_number':297,'multiline':False]['text':' to the Python object are removed.','line_number':298,'multiline':False]['text':' Assumption: if a Tensor has been shared across threads, this induces','line_number':301,'multiline':False]['text':' a refcount bump.  Therefore, if the use count 1, we are the sole thread','line_number':302,'multiline':False]['text':' with access to this tensor and no race is possible.','line_number':303,'multiline':False]['text':' We want to divide this check into 2 cases.','line_number':325,'multiline':False]['text':' 1. C++ owns PyObject (in this case, self->cdata.unsafeIsBorrowed() is','line_number':327,'multiline':False]['text':' true). You might think that in this case, it is impossible for tp_clear to','line_number':328,'multiline':False]['text':' be called: surely the C++ reference to the PyObject is keeping it live? And','line_number':329,'multiline':False]['text':' you'd be right! In fact, when C++ owns the PyObject, we have an invariant','line_number':330,'multiline':False]['text':' that the refcount on the PyObject should be precisely one (because if you','line_number':331,'multiline':False]['text':' take out another reference to the PyObject, we're supposed to flip the','line_number':332,'multiline':False]['text':' ownership pointer back). In reality, you can violate this invariant','line_number':333,'multiline':False]['text':' temporarily with weak references, so we don't test for it in asserts.','line_number':334,'multiline':False]['text':' 2. PyObject owns C++ (in this case, self->cdata.unsafeIsBorrowed() is','line_number':336,'multiline':False]['text':' false). In this case, tp_clear can get called if the PyObject is referenced','line_number':337,'multiline':False]['text':' from a dead cycle, and nowhere else. But if resurrection did not occur,','line_number':338,'multiline':False]['text':' then the reference to C++ from the PyObject must be the ONLY reference to','line_number':339,'multiline':False]['text':' the C++ object.','line_number':340,'multiline':False]['text':' Check if this is hermetic. If it is, no resurrection.','line_number':348,'multiline':False]['text':'ignore_hermetic_tls=','line_number':350,'multiline':True]['text':' returns true if successfully rezzed; if so, cancel the','line_number':357,'multiline':False]['text':' rest of deallocation','line_number':358,'multiline':False]['text':' At this point, we are definitely going to resurrect the tensor. So, the','line_number':366,'multiline':False]['text':' tensor better be defined :)','line_number':367,'multiline':False]['text':' There are other C++ owners of the tensor.  Flip ownership','line_number':370,'multiline':False]['text':' so that C++ owns this Python object, and cancel deallocation.','line_number':371,'multiline':False]['text':'ignore_hermetic_tls=','line_number':378,'multiline':True]['text':' Resurrect the Python object.  This is something CPython does','line_number':386,'multiline':False]['text':' internally occasionally, see','line_number':387,'multiline':False]['text':' https://github.com/python/cpython/blob/b98eba5bc2ffbe7a0ed49d540ebc4f756ae61985/Objects/object.c#L248-L259','line_number':388,'multiline':False]['text':' so we just copy the pattern here.  Note that we don't have to worry','line_number':389,'multiline':False]['text':' about saving and restoring the refcount (as the quoted code does)','line_number':390,'multiline':False]['text':' because we actually DO need to reset the refcount to one here, we','line_number':391,'multiline':False]['text':' can't assume that some other code has taken care of it.','line_number':392,'multiline':False]['text':' NB: this will overreport _Py_RefTotal but based on inspection of object.c','line_number':393,'multiline':False]['text':' there is no way to avoid this','line_number':394,'multiline':False]['text':' Flip THPVariable to be non-owning','line_number':400,'multiline':False]['text':' (near use-after-free miss here: fresh MaybeOwned is created breaking','line_number':401,'multiline':False]['text':' reference on Tensor in struct BEFORE we overwrite the old one)','line_number':402,'multiline':False]['text':' NB: At this point, tensor *could* be dead (e.g., some other C++ thread','line_number':406,'multiline':False]['text':' decrefed it.)  At this point, it is probably waiting on the GIL to','line_number':407,'multiline':False]['text':' deallocate the Python object and will kill self, BUT NOT YET.','line_number':408,'multiline':False]['text':' Is it OK for an object to still be live after running','line_number':414,'multiline':False]['text':' tp_clear? Yes. When Python is breaking reference cycles, it can't assume','line_number':415,'multiline':False]['text':' that an object will dealloc after it's cleared.  The source code explicitly','line_number':416,'multiline':False]['text':' handles this case:','line_number':417,'multiline':False]['text':' https://github.com/python/cpython/blob/4e661cd69164318c1f871faa476c68a04092ddc4/Modules/gcmodule.c#L1010-L1025','line_number':418,'multiline':False]['text':' Note that we don't need to actually resurrect here. There are 2 cases:','line_number':420,'multiline':False]['text':' 1. The PyObject is not part of a reference cycle. In this case, we don't','line_number':421,'multiline':False]['text':' need to do anything. The GC will move on to try and break the reference','line_number':422,'multiline':False]['text':' cycle on another object, which will eventually trigger tp_dealloc (and thus','line_number':423,'multiline':False]['text':' resurrection).','line_number':424,'multiline':False]['text':' 2. The PyObject is part of a reference cycle. This case should not actually','line_number':426,'multiline':False]['text':' be possible, due to the logic in our tp_traverse','line_number':427,'multiline':False]['text':' (THPVariable_subclass_traverse).','line_number':428,'multiline':False]['text':' In fact, resurrecting here breaks the invariant that "C++ owns Python only','line_number':430,'multiline':False]['text':' when PyObject's refcount would otherwise be 0". Most immediately, as we're','line_number':431,'multiline':False]['text':' merely breaking reference cycles here, there can be other references to the','line_number':432,'multiline':False]['text':' PyObject. *However*, if other objects in the refcycle resurrect, then we','line_number':433,'multiline':False]['text':' will be in a state where the PyObject has multiple Python references, yet','line_number':434,'multiline':False]['text':' C++ owns the PyObject.','line_number':435,'multiline':False]['text':' See https://github.com/pytorch/pytorch/pull/75933 for more discussion.','line_number':437,'multiline':False]['text':' Two situations to consider:','line_number':445,'multiline':False]['text':'    PyObject -owns-> Tensor','line_number':446,'multiline':False]['text':'        unsafeIsBorrowed() is FALSE.  We're obligated to look through','line_number':447,'multiline':False]['text':'        Tensor to break references.  Clearing cdata must induce the','line_number':448,'multiline':False]['text':'        destruction of the C++ Tensor.  If there were other references','line_number':449,'multiline':False]['text':'        to C++ tensor, the Python object would have been resurrected','line_number':450,'multiline':False]['text':'        by flipping the ownership.','line_number':451,'multiline':False]['text':'    Tensor -owns-> PyObject','line_number':452,'multiline':False]['text':'        unsafeIsBorrowed() is TRUE.  We're deallocating the PyObject','line_number':453,'multiline':False]['text':'        because Tensor asked us to (it's already destructing).','line_number':454,'multiline':False]['text':'ignore_hermetic_tls=','line_number':458,'multiline':True]['text':' TODO: empirically, on OS X this assert appears to be untrue','line_number':460,'multiline':False]['text':' In test_py_tensors_multi_async_call - ProcessGroupRpcTestWithSpawn','line_number':461,'multiline':False]['text':' distributed/rpc/test_process_group_agent.py','line_number':462,'multiline':False]['text':'','line_number':463,'multiline':False]['text':'  libc++abi.dylib: terminating with uncaught exception of type','line_number':464,'multiline':False]['text':'  c10::Error:','line_number':465,'multiline':False]['text':'  !tensor.unsafeGetTensorImpl()->pyobj_slot()->owns_pyobj()INTERNAL','line_number':466,'multiline':False]['text':'  ASSERT FAILED at "../torch/csrc/autograd/python_variable.cpp":171,','line_number':467,'multiline':False]['text':'  please report a bug to PyTorch. Exception raised from','line_number':468,'multiline':False]['text':'  THPVariable_clear at','line_number':469,'multiline':False]['text':'  ../torch/csrc/autograd/python_variable.cpp:171 (most recent call','line_number':470,'multiline':False]['text':'  first): frame #0: c10::Error::Error(c10::SourceLocation,','line_number':471,'multiline':False]['text':'  std::__1::basic_string<char, std::__1::char_traits<char>,','line_number':472,'multiline':False]['text':'  std::__1::allocator<char> >) + 98 (0x1158a0442 in libc10.dylib) frame','line_number':473,'multiline':False]['text':'  #1: c10::detail::torchCheckFail(char const*, char const*, unsigned','line_number':474,'multiline':False]['text':'  int, char const*) + 205 (0x11589ed3d in libc10.dylib) frame #2:','line_number':475,'multiline':False]['text':'  c10::detail::torchInternalAssertFail(char const*, char const*,','line_number':476,'multiline':False]['text':'  unsigned int, char const*, c10::detail::CompileTimeEmptyString) + 9','line_number':477,'multiline':False]['text':'  (0x1141e3f89 in libtorch_python.dylib) frame #3:','line_number':478,'multiline':False]['text':'  THPVariable_clear(THPVariable*) + 412 (0x1148a547c in','line_number':479,'multiline':False]['text':'  libtorch_python.dylib) frame #4:','line_number':480,'multiline':False]['text':'  THPVariable_subclass_dealloc(_object*) + 453 (0x1148a5035 in','line_number':481,'multiline':False]['text':'  libtorch_python.dylib) frame #5: (anonymous','line_number':482,'multiline':False]['text':'  namespace)::concrete_decref_fn(c10::impl::PyInterpreter const*,','line_number':483,'multiline':False]['text':'  _object*) + 53 (0x1148a5ea5 in libtorch_python.dylib) frame #6:','line_number':484,'multiline':False]['text':'  c10::TensorImpl::release_resources() + 182 (0x11588c4a6 in','line_number':485,'multiline':False]['text':'  libc10.dylib) frame #7:','line_number':486,'multiline':False]['text':'  c10::MaybeOwned<at::Tensor>::operator=(c10::MaybeOwned<at::Tensor>&&)','line_number':487,'multiline':False]['text':'  + 91 (0x11488c11b in libtorch_python.dylib) frame #8:','line_number':488,'multiline':False]['text':'  THPVariable_subclass_dealloc(_object*) + 607 (0x1148a50cf in','line_number':489,'multiline':False]['text':'  libtorch_python.dylib) <omitting python frames> frame #47: start + 1','line_number':490,'multiline':False]['text':'  (0x7fff6ffc7cc9 in libdyld.dylib) frame #48: 0x0 + 4 (0x4 in ???)','line_number':491,'multiline':False]['text':' TORCH_INTERNAL_ASSERT(!tensor.unsafeGetTensorImpl()->pyobj_slot()->owns_pyobj());','line_number':492,'multiline':False]['text':' MapAllocator can take significant time to release large tensors;','line_number':503,'multiline':False]['text':' release the GIL here to avoid impacting main thread perf.','line_number':504,'multiline':False]['text':' Ensure that self is indeed a backward differentiable view','line_number':539,'multiline':False]['text':' If not, we return an undefined Tensor (None) and let the user handle it.','line_number':540,'multiline':False]['text':' Ensure that the newly provided base is similar to the original base','line_number':545,'multiline':False]['text':' Do the actual view replay','line_number':548,'multiline':False]['text':'check_has_same_meta=','line_number':562,'multiline':True]['text':'check_has_same_meta=','line_number':566,'multiline':True]['text':' Instantiates a subclass of self with the same data.','line_number':569,'multiline':False]['text':' guard completely turns off torch dispatch modes, doesn't just pop off the','line_number':608,'multiline':False]['text':' stack','line_number':609,'multiline':False]['text':' creates a fresh Tensor (DEFINITELY_UNINITIALIZED)','line_number':613,'multiline':False]['text':' We set `data`'s `allow_tensor_metadata_change` to true here, because we','line_number':614,'multiline':False]['text':' want to allow the following use case for backward compatibility:','line_number':615,'multiline':False]['text':'','line_number':616,'multiline':False]['text':' ```python','line_number':617,'multiline':False]['text':' rnn = torch.nn.RNN(100, 100, 2)','line_number':618,'multiline':False]['text':' # The following calls `torch._cudnn_rnn_flatten_weight(rnn._flat_weights,','line_number':619,'multiline':False]['text':' ...)`, # which changes storage of `rnn`'s weights in-place','line_number':620,'multiline':False]['text':' rnn.flatten_parameters()','line_number':621,'multiline':False]['text':' ```','line_number':622,'multiline':False]['text':' NB: pin_memory doesn't actually do anything','line_number':652,'multiline':False]['text':' TODO: strides variant?','line_number':653,'multiline':False]['text':' This is an important safety check; without it, the default behavior will be','line_number':671,'multiline':False]['text':' to continue on to the underlying CPU/CUDA kernel advertised by the dispatch','line_number':672,'multiline':False]['text':' key, which will immediately segfault because the data pointer is null.  By','line_number':673,'multiline':False]['text':' forcing users to define __torch_dispatch__ we ensure this does not happen','line_number':674,'multiline':False]['text':' TODO: This check is not complete; because the user can disable torch','line_number':675,'multiline':False]['text':' dispatch and then go again, triggering segfault.  TBH I'm thinking I want','line_number':676,'multiline':False]['text':' to delete this function entirely','line_number':677,'multiline':False]['text':' NB: long standing issue, requires_grad is not','line_number':689,'multiline':False]['text':' respected here; you have to set it post facto, see','line_number':690,'multiline':False]['text':' https://github.com/pytorch/pytorch/issues/26428','line_number':691,'multiline':False]['text':' .requires_grad(r.toBool(7))','line_number':692,'multiline':False]['text':' don't bother releasing GIL here, as we are not allocating any nontrivial','line_number':695,'multiline':False]['text':' data','line_number':696,'multiline':False]['text':' TODO: Remove.','line_number':700,'multiline':False]['text':' We use storages **only** to track aliasing of subclasses during tracing.','line_number':722,'multiline':False]['text':' The actual data pointers are not valid.','line_number':723,'multiline':False]['text':'allocator=','line_number':727,'multiline':True]['text':'resizable=','line_number':728,'multiline':True]['text':' TODO: constructor should probably accept data pointer','line_number':729,'multiline':False]['text':' CRTP base class to implement the python bindings for a Tensor property in','line_number':785,'multiline':False]['text':' PyTorch A class that implements a property is expected to have:','line_number':786,'multiline':False]['text':' - static constexpr const char* name;','line_number':787,'multiline':False]['text':'   - This variable should hold the Python name of the property','line_number':788,'multiline':False]['text':' - static Tensor fn(const Tensor&);','line_number':789,'multiline':False]['text':'   - This function calls the relevant ATen on the tensor','line_number':790,'multiline':False]['text':'unused','line_number':793,'multiline':True]['text':' The long-term plan is to return a list of (python) torch.Dimname.','line_number':1072,'multiline':False]['text':' However, for now, return a list of string.','line_number':1073,'multiline':False]['text':' PyTuple_SET_ITEM steals a reference to the object. When the tuple is','line_number':1084,'multiline':False]['text':' deallocated, it'll decrement the refcount on Py_None, which is bad.','line_number':1085,'multiline':False]['text':' To avoid this, we "create" a new reference to Py_None by increasing','line_number':1086,'multiline':False]['text':' the refcount.','line_number':1087,'multiline':False]['text':' Sources:','line_number':1088,'multiline':False]['text':' - https://docs.python.org/3/c-api/tuple.html#c.PyTuple_SetItem','line_number':1089,'multiline':False]['text':' -','line_number':1090,'multiline':False]['text':' https://stackoverflow.com/questions/16400600/how-to-return-a-tuple-containing-a-none-value-from-the-c-api','line_number':1091,'multiline':False]['text':' properties are registered here because we are currently only able to bind','line_number':1508,'multiline':False]['text':' them manually. TODO: make declarable in native_functions','line_number':1509,'multiline':False]['text':' NOLINTNEXTLINE(modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays,cppcoreguidelines-avoid-non-const-global-variables)','line_number':1510,'multiline':False]['text':' Allows the python class to override .grad','line_number':1544,'multiline':False]['text':' NOLINTNEXTLINE(modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays,cppcoreguidelines-avoid-non-const-global-variables)','line_number':1632,'multiline':False]['text':' tp_name ','line_number':1660,'multiline':True]['text':' tp_basicsize ','line_number':1661,'multiline':True]['text':' tp_itemsize ','line_number':1662,'multiline':True]['text':' tp_dealloc ','line_number':1663,'multiline':True]['text':' tp_vectorcall_offset ','line_number':1664,'multiline':True]['text':' tp_getattr ','line_number':1665,'multiline':True]['text':' tp_setattr ','line_number':1666,'multiline':True]['text':' tp_reserved ','line_number':1667,'multiline':True]['text':' tp_repr ','line_number':1668,'multiline':True]['text':' tp_as_number ','line_number':1669,'multiline':True]['text':' tp_as_sequence ','line_number':1670,'multiline':True]['text':' tp_as_mapping ','line_number':1671,'multiline':True]['text':' tp_hash  ','line_number':1672,'multiline':True]['text':' tp_call ','line_number':1673,'multiline':True]['text':' tp_str ','line_number':1674,'multiline':True]['text':' tp_getattro ','line_number':1675,'multiline':True]['text':' tp_setattro ','line_number':1676,'multiline':True]['text':' tp_as_buffer ','line_number':1677,'multiline':True]['text':' NOLINTNEXTLINE(misc-redundant-expression)','line_number':1678,'multiline':False]['text':' tp_flags ','line_number':1679,'multiline':True]['text':' tp_doc ','line_number':1680,'multiline':True]['text':' tp_traverse ','line_number':1681,'multiline':True]['text':' tp_clear ','line_number':1682,'multiline':True]['text':' tp_richcompare ','line_number':1683,'multiline':True]['text':' tp_weaklistoffset ','line_number':1684,'multiline':True]['text':' tp_iter ','line_number':1685,'multiline':True]['text':' tp_iternext ','line_number':1686,'multiline':True]['text':' tp_methods ','line_number':1687,'multiline':True]['text':' tp_members ','line_number':1688,'multiline':True]['text':' tp_getset ','line_number':1689,'multiline':True]['text':' tp_base ','line_number':1690,'multiline':True]['text':' tp_dict ','line_number':1691,'multiline':True]['text':' tp_descr_get ','line_number':1692,'multiline':True]['text':' tp_descr_set ','line_number':1693,'multiline':True]['text':' tp_dictoffset ','line_number':1694,'multiline':True]['text':' tp_init ','line_number':1695,'multiline':True]['text':' tp_alloc ','line_number':1696,'multiline':True]['text':' tp_new ','line_number':1697,'multiline':True]['text':' tp_name ','line_number':1703,'multiline':True]['text':' tp_basicsize ','line_number':1704,'multiline':True]['text':' tp_itemsize ','line_number':1705,'multiline':True]['text':' This is unspecified, because it is illegal to create a THPVariableType','line_number':1706,'multiline':False]['text':' directly.  Subclasses will have their tp_dealloc set appropriately','line_number':1707,'multiline':False]['text':' by the metaclass','line_number':1708,'multiline':False]['text':' tp_dealloc ','line_number':1709,'multiline':True]['text':' tp_vectorcall_offset ','line_number':1710,'multiline':True]['text':' tp_getattr ','line_number':1711,'multiline':True]['text':' tp_setattr ','line_number':1712,'multiline':True]['text':' tp_reserved ','line_number':1713,'multiline':True]['text':' tp_repr ','line_number':1714,'multiline':True]['text':' tp_as_number ','line_number':1715,'multiline':True]['text':' tp_as_sequence ','line_number':1716,'multiline':True]['text':' tp_as_mapping ','line_number':1717,'multiline':True]['text':' tp_hash  ','line_number':1718,'multiline':True]['text':' tp_call ','line_number':1719,'multiline':True]['text':' tp_str ','line_number':1720,'multiline':True]['text':' tp_getattro ','line_number':1721,'multiline':True]['text':' tp_setattro ','line_number':1722,'multiline':True]['text':' tp_as_buffer ','line_number':1723,'multiline':True]['text':' NOLINTNEXTLINE(misc-redundant-expression)','line_number':1724,'multiline':False]['text':' tp_flags ','line_number':1726,'multiline':True]['text':' tp_doc ','line_number':1727,'multiline':True]['text':' Also set by metaclass','line_number':1728,'multiline':False]['text':' tp_traverse ','line_number':1729,'multiline':True]['text':' tp_clear ','line_number':1730,'multiline':True]['text':' tp_richcompare ','line_number':1731,'multiline':True]['text':' tp_weaklistoffset ','line_number':1732,'multiline':True]['text':' tp_iter ','line_number':1733,'multiline':True]['text':' tp_iternext ','line_number':1734,'multiline':True]['text':' tp_methods ','line_number':1735,'multiline':True]['text':' tp_members ','line_number':1736,'multiline':True]['text':' tp_getset ','line_number':1737,'multiline':True]['text':' tp_base ','line_number':1738,'multiline':True]['text':' tp_dict ','line_number':1739,'multiline':True]['text':' tp_descr_get ','line_number':1740,'multiline':True]['text':' tp_descr_set ','line_number':1741,'multiline':True]['text':' tp_dictoffset ','line_number':1742,'multiline':True]['text':' tp_init ','line_number':1743,'multiline':True]['text':' tp_alloc ','line_number':1744,'multiline':True]['text':' Although new is provided here, it is illegal to call this with cls ==','line_number':1745,'multiline':False]['text':' THPVariableMeta.  Instead, subclass it first and then construct it','line_number':1746,'multiline':False]['text':' tp_new ','line_number':1747,'multiline':True]['text':' WARNING: tensor is NOT guaranteed to be a fresh tensor; e.g., if it was','line_number':1760,'multiline':False]['text':' given a raw pointer that will refcount bump','line_number':1761,'multiline':False]['text':' NB: base_tensor_ctor can call into dispatched ATen functions (e.g.,','line_number':1762,'multiline':False]['text':' alias(), lift_fresh()) which can return Tensor subclasses.  We allow','line_number':1763,'multiline':False]['text':' these to be passed on directly.','line_number':1764,'multiline':False]['text':'allow_preexisting_pyobj=','line_number':1769,'multiline':True]['text':' NB: this is not the tp_dealloc on THPVariable; instead, its the dealloc','line_number':1773,'multiline':False]['text':' on subclasses.  It's never valid to construct a THPVariable so it's not','line_number':1774,'multiline':False]['text':' necessary to implement the dealloc for that case','line_number':1775,'multiline':False]['text':' This is like a crappy version of subtype_dealloc.','line_number':1780,'multiline':False]['text':' Unfortunately, we cannot directly delegate to','line_number':1781,'multiline':False]['text':' subtype_dealloc as it will start walking the parent','line_number':1782,'multiline':False]['text':' chain *starting with* the type of self, which will cause','line_number':1783,'multiline':False]['text':' us to go back to our custom dealloc.','line_number':1784,'multiline':False]['text':'','line_number':1785,'multiline':False]['text':' We have to replicate the subtype_dealloc logic to ensure','line_number':1786,'multiline':False]['text':' that finalizers are handled correctly','line_number':1787,'multiline':False]['text':' TODO: consider using trash can','line_number':1793,'multiline':False]['text':' Resurrected ','line_number':1800,'multiline':True]['text':' base test is unnecessary as THPVariable does not set this','line_number':1806,'multiline':False]['text':' Resurrected ','line_number':1815,'multiline':True]['text':' New weakrefs could be created during the finalizer call.
       If this occurs, clear them out without calling their
       finalizers since they might rely on part of the object
       being finalized that has already been destroyed. ','line_number':1822,'multiline':True]['text':' Modeled after GET_WEAKREFS_LISTPTR() ','line_number':1827,'multiline':True]['text':' Clear all slots until we get to base class THPVariableType','line_number':1835,'multiline':False]['text':' All Python defined classes have __dict__','line_number':1847,'multiline':False]['text':' subtype_dealloc allows for this but we don't','line_number':1859,'multiline':False]['text':' Finally clear out the base THPVariable','line_number':1862,'multiline':False]['text':' Python defined subclasses should always be on the heap','line_number':1867,'multiline':False]['text':' Creates a new Python object for a Variable.  The status parameter','line_number':1872,'multiline':False]['text':' specifies what the interpreter tag status on the object is; for','line_number':1873,'multiline':False]['text':' example, if you ran check_pyobj, the return optional of this object','line_number':1874,'multiline':False]['text':' tells you if the tensor was already tagged or not so you can pass','line_number':1875,'multiline':False]['text':' TAGGED_BY_US or MAYBE_UNINITIALIZED; in other cases, you know where','line_number':1876,'multiline':False]['text':' var came from and can directly assert that it's DEFINITELY_UNINITIALIZED.','line_number':1877,'multiline':False]['text':' It's ALWAYS safe (albeit slower) to call this with MAYBE_UNINITIALIZED.','line_number':1878,'multiline':False]['text':' Make sure that the reinterpret into a THPVariable* will be valid','line_number':1884,'multiline':False]['text':' This function overwrite the Tensor's pyobj field without extra checks','line_number':1890,'multiline':False]['text':' Make sure it is not set otherwise we would leak memory','line_number':1891,'multiline':False]['text':'ignore_hermetic_tls=','line_number':1893,'multiline':True]['text':' Under some circumstances, we may attempt to create a new Python','line_number':1895,'multiline':False]['text':' object for a variable that already has a Python object.  The most common','line_number':1896,'multiline':False]['text':' situation this can occur is if you have a TorchDispatchMode active that','line_number':1897,'multiline':False]['text':' is returning a subclass from lift_fresh (which is invoked to','line_number':1898,'multiline':False]['text':' appropriately "wrap" a constant tensor into whatever ambient modes are','line_number':1899,'multiline':False]['text':' active.)','line_number':1900,'multiline':False]['text':'','line_number':1901,'multiline':False]['text':' In general, it is impossible to handle this case compositionally.','line_number':1902,'multiline':False]['text':' Suppose you have a user call ATensor([1, 2, 3]) when a mode is active','line_number':1903,'multiline':False]['text':' that is transforming all ops (including the internal lift_fresh call that','line_number':1904,'multiline':False]['text':' transforms [1, 2, 3] into a torch.tensor([1., 2., 3.])) to output','line_number':1905,'multiline':False]['text':' BTensor, where ATensor and BTensor are completely unrelated subclasses','line_number':1906,'multiline':False]['text':' and there is no way to compose them.  There is no way to satisfy the user','line_number':1907,'multiline':False]['text':' request here: in particular, you can't just try to re-invoke the ATensor','line_number':1908,'multiline':False]['text':' constructor on the returned BTensor, because (1) this could cause an','line_number':1909,'multiline':False]['text':' infinite loop--we are already in ATensor.__new__ and (2) there isn't any','line_number':1910,'multiline':False]['text':' guarantee that ATensor.__new__ supports a single element constructor','line_number':1911,'multiline':False]['text':' anyway.','line_number':1912,'multiline':False]['text':'','line_number':1913,'multiline':False]['text':' However, a more common case is a user just called torch.Tensor([1, 2, 3]),','line_number':1914,'multiline':False]['text':' and a fake tensor mode is active.  Really, all you want is to get back','line_number':1915,'multiline':False]['text':' a FakeTensor, in the same way torch.tensor([1, 2, 3]) or torch.arange(3)','line_number':1916,'multiline':False]['text':' would have returned a fake tensor (concretely, the way this happens','line_number':1917,'multiline':False]['text':' is we create a *real* tensor torch.tensor([1., 2., 3.]), and then it','line_number':1918,'multiline':False]['text':' turns into a FakeTensor when we call lift_fresh on this real tensor).','line_number':1919,'multiline':False]['text':' This case is compositional because FakeTensor is a subclass of Tensor, so','line_number':1920,'multiline':False]['text':' it's valid for us to return it in place of a Tensor.  So this is what we','line_number':1921,'multiline':False]['text':' do.','line_number':1922,'multiline':False]['text':' Even if we allow pre-existing PyObject, we don't allow completely','line_number':1932,'multiline':False]['text':' ignoring the requested type.  Check that we fulfilled a subtype','line_number':1933,'multiline':False]['text':' relation here.  In the common case the requested type is Tensor and','line_number':1934,'multiline':False]['text':' this always succeeds.','line_number':1935,'multiline':False]['text':' Check if it's OK to just directly return the Python object without','line_number':1937,'multiline':False]['text':' allocating a new variable.  We just check that the existing Python','line_number':1938,'multiline':False]['text':' object is a subclass of the requested type.','line_number':1939,'multiline':False]['text':' We may (in fact, we typically will) need to resurrect this','line_number':1950,'multiline':False]['text':' TODO: named constructor to avoid default initialization','line_number':1957,'multiline':False]['text':' Do NOT initialize pyobj field on the tensor, you own the C++','line_number':1960,'multiline':False]['text':' Normal codepath','line_number':1972,'multiline':False]['text':'/ NOTE [ PyObject Traversal ]','line_number':1985,'multiline':False]['text':'/','line_number':1986,'multiline':False]['text':'/ PyObjects that are wrapping c++ objects can lead to non-trivial traverse','line_number':1987,'multiline':False]['text':'/ logic and it can be tricky to know what to traverse and when. This note','line_number':1988,'multiline':False]['text':'/ tries to clarify what is the danger here and a simple algorithm to choose','line_number':1989,'multiline':False]['text':'/ how to write the tp_traverse and tp_clear functions. If you're not already','line_number':1990,'multiline':False]['text':'/ familiar with how the CPython GC works, you should read this in-depth','line_number':1991,'multiline':False]['text':'/ description: https://devguide.python.org/garbage_collector/','line_number':1992,'multiline':False]['text':'/','line_number':1993,'multiline':False]['text':'/ The complexity for us comes from the fact that some c++ shared_ptr objects','line_number':1994,'multiline':False]['text':'/ own references to python objects and are also owned both by other python','line_number':1995,'multiline':False]['text':'/ objects and c++ objects. This means that to allow the GC to collect all','line_number':1996,'multiline':False]['text':'/ cycles, we need to properly implement the traverse/clear methods that take','line_number':1997,'multiline':False]['text':'/ into account these C++ ownership links.','line_number':1998,'multiline':False]['text':'/','line_number':1999,'multiline':False]['text':'/ The main danger here comes from the fact that, while all python-related code','line_number':2000,'multiline':False]['text':'/ is thread safe wrt the GC execution (thanks to the GIL), other threads might','line_number':2001,'multiline':False]['text':'/ be using our C++ objects arbitrarily which can lead to shared_ptr ref count','line_number':2002,'multiline':False]['text':'/ going up or down in between the different traverse/clear invocations. The','line_number':2003,'multiline':False]['text':'/ one constraint we add here that is not explicitly mentioned in the GC','line_number':2004,'multiline':False]['text':'/ description above is that for a given GC run (meaning while the GIL is','line_number':2005,'multiline':False]['text':'/ held), the traverse/clear pair should never report different ownership','line_number':2006,'multiline':False]['text':'/ relations: if traverse visited a given PyObject, then the clear within that','line_number':2007,'multiline':False]['text':'/ same GC run must still be the sole owner and clear that PyObject.','line_number':2008,'multiline':False]['text':'/','line_number':2009,'multiline':False]['text':'/ A more mechanical algorithm to know what to traverse/clear is as follows:','line_number':2010,'multiline':False]['text':'/   - Any field on this PyObject that contains a strong reference to another','line_number':2011,'multiline':False]['text':'/   PyObject','line_number':2012,'multiline':False]['text':'/     must be visited and cleared. An example of that is the "backward_hooks"','line_number':2013,'multiline':False]['text':'/     field of the THPVariable.','line_number':2014,'multiline':False]['text':'/   - Any field that contains a C++ object that is uniquely owned by this','line_number':2015,'multiline':False]['text':'/   PyObject (either','line_number':2016,'multiline':False]['text':'/     a unique_ptr or a shared_ptr with use_count==1) should have all the','line_number':2017,'multiline':False]['text':'/     PyObject it owns visited and cleared. An example would be here the','line_number':2018,'multiline':False]['text':'/     tensor hooks.','line_number':2019,'multiline':False]['text':'/   - If that uniquely owned C++ object also uniquely owns other C++ objects,','line_number':2020,'multiline':False]['text':'/   these should be','line_number':2021,'multiline':False]['text':'/     visited and cleared as well if they contain any PyObject.','line_number':2022,'multiline':False]['text':'/','line_number':2023,'multiline':False]['text':'/ Caveat: to avoid slow runtime, we limit the depth of this exploration of C++','line_number':2024,'multiline':False]['text':'/ objects in practice and we do not, for example, go through the whole','line_number':2025,'multiline':False]['text':'/ autograd graph, even if it is uniquely owned. This is a known place where','line_number':2026,'multiline':False]['text':'/ users can create noncollectable cycles as described in:','line_number':2027,'multiline':False]['text':'/ https://github.com/pytorch/pytorch/issues/7343','line_number':2028,'multiline':False]['text':'/','line_number':2029,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2036,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2038,'multiline':False]['text':' If the tensor is eligible to be resurrected, don't traverse it; instead','line_number':2061,'multiline':False]['text':' treat all of its references as a root (as they WOULD be a root since we','line_number':2062,'multiline':False]['text':' can treat the inbound C++ references as root owners).','line_number':2063,'multiline':False]['text':'','line_number':2064,'multiline':False]['text':' This works because unlike conventional GCs, Python's GC operates in two','line_number':2065,'multiline':False]['text':' phases: first it uses traverse to discover roots, and then it uses traverse','line_number':2066,'multiline':False]['text':' to do reachability.  Bypassing traverse during root discovery forces Python','line_number':2067,'multiline':False]['text':' to treat self as a root for everything it refers to.  For a full','line_number':2068,'multiline':False]['text':' explanation of the algorithm see','line_number':2069,'multiline':False]['text':' https://devguide.python.org/garbage_collector/','line_number':2070,'multiline':False]['text':'','line_number':2071,'multiline':False]['text':' NB: if we don't hold an owning reference to the underlying Tensor, it is','line_number':2072,'multiline':False]['text':' possible that the underlying Tensor has already gone dead.  In that case,','line_number':2073,'multiline':False]['text':' it's not safe to access it.  But it's also safe to traverse, because if','line_number':2074,'multiline':False]['text':' the underlying Tensor *is* live, then root discovery will determine that','line_number':2075,'multiline':False]['text':' self is live, and nothing will get GC'ed anyway (resurrection cannot happen','line_number':2076,'multiline':False]['text':' if the C++ objects owns the PyObject)','line_number':2077,'multiline':False]['text':' Crappy version of subtype_traverse; same deal as','line_number':2083,'multiline':False]['text':' THPVariable_subclass_dealloc','line_number':2084,'multiline':False]['text':' Traverse slots until we get to base class THPVariableType','line_number':2087,'multiline':False]['text':' All Python defined classes have __dict__','line_number':2101,'multiline':False]['text':' Finally traverse THPVariable special stuff','line_number':2111,'multiline':False]['text':' WARNING: The grad_fn traversal logic is very subtle, if you change','line_number':2117,'multiline':False]['text':' this, be very careful not to re-introduce this bug:','line_number':2118,'multiline':False]['text':' https://gist.github.com/zou3519/7ac92b84dd7d206dcc6eae55fee8372c','line_number':2119,'multiline':False]['text':' We ensure that we follow NOTE [ PyObject Traversal ] he by checking','line_number':2121,'multiline':False]['text':' that this python object is the sole owner of the underlying Tensor and','line_number':2122,'multiline':False]['text':' that this Tensor is the sole owner of its grad_fn. In this case, the','line_number':2123,'multiline':False]['text':' only way to get a new reference to the grad_fn is by using this python','line_number':2124,'multiline':False]['text':' object, which requires the GIL to be accessed. Note that this is only','line_number':2125,'multiline':False]['text':' valid as long as user don't share non-owning references across','line_number':2126,'multiline':False]['text':' different threads (which is crazy and should never be done).','line_number':2127,'multiline':False]['text':' Do NOT call grad_fn() here as that might trigger a recompute','line_number':2131,'multiline':False]['text':' All Node can have a pyobj (stored in "pyobj_")','line_number':2134,'multiline':False]['text':' PyNode are special as they also have an "obj" field','line_number':2136,'multiline':False]['text':' NOLINTNEXTLINE(modernize-avoid-c-arrays,cppcoreguidelines-avoid-c-arrays,cppcoreguidelines-avoid-non-const-global-variables)','line_number':2170,'multiline':False]['text':' set on the module level to avoid mixing pybind and plain CPython extensions','line_number':2183,'multiline':False]['text':' We return a raw non-owning pointer here, we rely on surrounding','line_number':2185,'multiline':False]['text':' code to keep the original tensor alive','line_number':2186,'multiline':False]['text':' namespace autograd','line_number':2190,'multiline':False]['text':' namespace torch','line_number':2191,'multiline':False]