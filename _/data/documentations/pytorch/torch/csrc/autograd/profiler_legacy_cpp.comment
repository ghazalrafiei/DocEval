['text':' We decompose the profiler logic into the following components:','line_number':31,'multiline':False]['text':'','line_number':32,'multiline':False]['text':' ThreadLocalDebugInfo:','line_number':33,'multiline':False]['text':'','line_number':34,'multiline':False]['text':' ThreadLocalDebugInfo is a thread local mapping from slots into','line_number':35,'multiline':False]['text':' the debug information structs.','line_number':36,'multiline':False]['text':' ThreadLocalDebugInfo is automatically propagated across thread','line_number':37,'multiline':False]['text':' boundaries, including the cases of:','line_number':38,'multiline':False]['text':'  - launching async jobs with at::launch','line_number':39,'multiline':False]['text':'  - executing JIT continuations','line_number':40,'multiline':False]['text':'  - moving from the forward threads into autograd (backward) threads','line_number':41,'multiline':False]['text':'','line_number':42,'multiline':False]['text':' Entries in ThreadLocalDebugInfo are managed by DebugInfoGuard','line_number':43,'multiline':False]['text':' which can be used to add or overwrite an entry in the thread local','line_number':44,'multiline':False]['text':' mapping. A corresponding entry is removed when the guard is destroyed,','line_number':45,'multiline':False]['text':' potentially revealing the previously set value for the same slot.','line_number':46,'multiline':False]['text':'','line_number':47,'multiline':False]['text':' For the async tasks, slots previously set in the main thread before','line_number':48,'multiline':False]['text':' launching of an async task are shared and visible in the async task.','line_number':49,'multiline':False]['text':'','line_number':50,'multiline':False]['text':' On the other hand, any adding or overwriting of the mapping by the','line_number':51,'multiline':False]['text':' async task is not visible to the main thread and any modification','line_number':52,'multiline':False]['text':' (including removal of the entries) in the main thread is not visible','line_number':53,'multiline':False]['text':' to the async task if it happens after launching the task.','line_number':54,'multiline':False]['text':'','line_number':55,'multiline':False]['text':' We use ThreadLocalDebugInfo (slot PROFILER_STATE) to store profiler config,','line_number':56,'multiline':False]['text':' as well as a list of events that happen during profiling.','line_number':57,'multiline':False]['text':' An instance of ThreadLocalDebugInfo is created each time we enter','line_number':58,'multiline':False]['text':' profiler (i.e. enter profiling context manager/call enableConfig) and','line_number':59,'multiline':False]['text':' uniquely identifies a profiling run.','line_number':60,'multiline':False]['text':'','line_number':61,'multiline':False]['text':' We automatically propagate ThreadLocalDebugInfo into async tasks,','line_number':62,'multiline':False]['text':' as well as across JIT continuations and autograd thread, so all','line_number':63,'multiline':False]['text':' the operations that happen between profiling start and end','line_number':64,'multiline':False]['text':' (not necessarily within the same thread) are recorded.','line_number':65,'multiline':False]['text':' Unless the profiling slot is overwritten as in the case of nested','line_number':66,'multiline':False]['text':' profiling ranges (in this case events for the subrange are handled','line_number':67,'multiline':False]['text':' by the nested profiler)','line_number':68,'multiline':False]['text':'','line_number':69,'multiline':False]['text':' When we exit a profiling range (either by exiting profiling context','line_number':70,'multiline':False]['text':' manager or by calling disableProfiler), we remove the previously set','line_number':71,'multiline':False]['text':' profiling entry for the given thread local mapping, and consolidate','line_number':72,'multiline':False]['text':' events in the profiling result','line_number':73,'multiline':False]['text':'','line_number':74,'multiline':False]['text':'','line_number':75,'multiline':False]['text':' ThreadLocalState:','line_number':76,'multiline':False]['text':'','line_number':77,'multiline':False]['text':' ThreadLocalState takes a 'snapshot' of thread local variables','line_number':78,'multiline':False]['text':' using provided getters. It is used together with ThreadLocalStateGuard','line_number':79,'multiline':False]['text':' to transfer the snapshot across thread boundary and set the thread local','line_number':80,'multiline':False]['text':' values as in the parent task.','line_number':81,'multiline':False]['text':'','line_number':82,'multiline':False]['text':' Profiler uses ThreadLocalState to propagate profiler's thread local state.','line_number':83,'multiline':False]['text':' ThreadLocalState also automatically propagates profiler callbacks.','line_number':84,'multiline':False]['text':'','line_number':85,'multiline':False]['text':'','line_number':86,'multiline':False]['text':' at::RecordFunction and observers','line_number':87,'multiline':False]['text':'','line_number':88,'multiline':False]['text':' Profiler uses observers mechanism to add a pair of thread local callbacks','line_number':89,'multiline':False]['text':' that are executed on a number of predetermined ranges, including:','line_number':90,'multiline':False]['text':'  - c10/ATen ops','line_number':91,'multiline':False]['text':'  - TorchScript functions/methods','line_number':92,'multiline':False]['text':'  - user defined named ranges (see `record_function` python context manager)','line_number':93,'multiline':False]['text':'','line_number':94,'multiline':False]['text':' Profiler setups a pair of callbacks that record profiling events and save','line_number':95,'multiline':False]['text':' them into the thread local profiler struct (ThreadLocalDebugInfo,','line_number':96,'multiline':False]['text':' PROFILER_STATE slot)','line_number':97,'multiline':False]['text':'','line_number':98,'multiline':False]['text':'','line_number':99,'multiline':False]['text':' Thus, the overall logic is:','line_number':100,'multiline':False]['text':'','line_number':101,'multiline':False]['text':' enableProfiler:','line_number':102,'multiline':False]['text':'  - checks that profiler is not enabled (otherwise throws)','line_number':103,'multiline':False]['text':'  - pushes new ThreadLocalDebugInfo (slot PROFILER_STATE) as the profiler','line_number':104,'multiline':False]['text':'    config for the current thread','line_number':105,'multiline':False]['text':'  - pushes profiling callbacks for the current thread','line_number':106,'multiline':False]['text':'','line_number':107,'multiline':False]['text':' disableProfiler:','line_number':108,'multiline':False]['text':'  - pops PROFILER_STATE slot from the current ThreadLocalDebugInfo and','line_number':109,'multiline':False]['text':'    consolidates events','line_number':110,'multiline':False]['text':'  - removes profiling callbacks','line_number':111,'multiline':False]['text':'','line_number':112,'multiline':False]['text':' ThreadLocalState:','line_number':113,'multiline':False]['text':'  - propagates ThreadLocalDebugInfo across threads','line_number':114,'multiline':False]['text':'  - propagates profiler callbacks across threads','line_number':115,'multiline':False]['text':'','line_number':116,'multiline':False]['text':' Profiler callbacks:','line_number':117,'multiline':False]['text':'  - get the current profiling state (PROFILER slot in ThreadLocalDebugInfo)','line_number':118,'multiline':False]['text':'  - save profiling events into the profiling state','line_number':119,'multiline':False]['text':'','line_number':120,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':127,'multiline':False]['text':'global=','line_number':134,'multiline':True]['text':' unused ','line_number':155,'multiline':True]['text':' total_allocated, unused for legacy ','line_number':157,'multiline':True]['text':' total_reserved, unused for legacy ','line_number':158,'multiline':True]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':172,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':175,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':178,'multiline':False]['text':' Consolidate remote events if applicable as well.','line_number':189,'multiline':False]['text':' Lock to serialize access from multiple callback threads.','line_number':219,'multiline':False]['text':' TODO: will unify the two macros BUILD_LITE_INTERPRETER and C10_MOBILE soon.','line_number':258,'multiline':False]['text':' backward nodes source range corresponds to the forward node','line_number':260,'multiline':False]['text':' TODO: consider using C++ stack trace','line_number':261,'multiline':False]['text':' In some cases RecordFunction (and popRange) may be','line_number':286,'multiline':False]['text':' called on a different thread than pushRange','line_number':287,'multiline':False]['text':' As a convention, we put the async pop on the original','line_number':288,'multiline':False]['text':' thread and save current thread id in pop event','line_number':289,'multiline':False]['text':' unused ','line_number':302,'multiline':True]['text':' total_allocated, unused for legacy ','line_number':304,'multiline':True]['text':' total_reserved, unused for legacy ','line_number':305,'multiline':True]['text':' must be last in list','line_number':350,'multiline':False]['text':' namespace','line_number':417,'multiline':False]['text':' all the DebugInfoBase objects are scope based and supposed to use','line_number':444,'multiline':False]['text':' DebugInfoGuard','line_number':445,'multiline':False]['text':' Note that this will erase the underlying events.','line_number':466,'multiline':False]['text':' static ','line_number':484,'multiline':True]['text':' Reconstruct input shapes from ivalues.','line_number':496,'multiline':False]['text':' EventKind','line_number':521,'multiline':False]['text':' name','line_number':522,'multiline':False]['text':' thread_id','line_number':523,'multiline':False]['text':' handle','line_number':525,'multiline':False]['text':' input shapes','line_number':526,'multiline':False]['text':' node id','line_number':527,'multiline':False]['text':' is remote','line_number':528,'multiline':False]['text':' cpu_mem_usage','line_number':529,'multiline':False]['text':' cpu_ns','line_number':530,'multiline':False]['text':' was cuda recorded','line_number':531,'multiline':False]['text':' cuda memory usage','line_number':532,'multiline':False]['text':' device','line_number':533,'multiline':False]['text':' cuda_us','line_number':534,'multiline':False]['text':' CUDA event information','line_number':549,'multiline':False]['text':' Shapes','line_number':555,'multiline':False]['text':' validate that cuda_us_ has been set properly.','line_number':578,'multiline':False]['text':' namespace profiler','line_number':683,'multiline':False]['text':' namespace autograd','line_number':684,'multiline':False]['text':' namespace torch','line_number':685,'multiline':False]