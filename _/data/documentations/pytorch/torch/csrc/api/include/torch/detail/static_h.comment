['text':' namespace nn','line_number':12,'multiline':False]['text':' namespace torch','line_number':13,'multiline':False]['text':'/ Detects if a type T has a forward() method.','line_number':17,'multiline':False]['text':' Declare two types with differing size.','line_number':20,'multiline':False]['text':' Here we declare two functions. The first is only enabled if `&U::forward`','line_number':24,'multiline':False]['text':' is well-formed and returns the `yes` type. In C++, the ellipsis parameter','line_number':25,'multiline':False]['text':' type (`...`) always puts the function at the bottom of overload resolution.','line_number':26,'multiline':False]['text':' This is specified in the standard as: 1) A standard conversion sequence is','line_number':27,'multiline':False]['text':' always better than a user-defined conversion sequence or an ellipsis','line_number':28,'multiline':False]['text':' conversion sequence. 2) A user-defined conversion sequence is always better','line_number':29,'multiline':False]['text':' than an ellipsis conversion sequence This means that if the first overload','line_number':30,'multiline':False]['text':' is viable, it will be preferred over the second as long as we pass any','line_number':31,'multiline':False]['text':' convertible type. The type of `&U::forward` is a pointer type, so we can','line_number':32,'multiline':False]['text':' pass e.g. 0.','line_number':33,'multiline':False]['text':' Finally we test statically whether the size of the type returned by the','line_number':39,'multiline':False]['text':' selected overload is the size of the `yes` type.','line_number':40,'multiline':False]['text':'/ A type trait whose `value` member is true if `M` derives from `Module`.','line_number':56,'multiline':False]['text':' namespace detail','line_number':64,'multiline':False]['text':' namespace torch','line_number':65,'multiline':False]