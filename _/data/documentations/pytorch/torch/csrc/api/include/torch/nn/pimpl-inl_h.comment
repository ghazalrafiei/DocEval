['text':' This class exists  only to do SFINAE on abstract types `T` that are really','line_number':1,'multiline':False]['text':' `ModuleHolder<ModuleType>`, because there's no good way to say that `T` is a','line_number':2,'multiline':False]['text':' `ModuleHolder` over some unknown type `ModuleType`. With this, you can do','line_number':3,'multiline':False]['text':' `enable_if_t<is_base_of_v<ModuleHolderIndicator, T>>`.','line_number':4,'multiline':False]['text':' A type trait that is true for types that are `ModuleHolder`s.','line_number':7,'multiline':False]['text':' A collection of templates that answer the question whether a type `T` is a','line_number':14,'multiline':False]['text':' `ModuleHolder`, and if so whether its contained type is of type `C`. This is','line_number':15,'multiline':False]['text':' tricky because it is hard to short circuit in template metaprogramming. A','line_number':16,'multiline':False]['text':' naive and incorrect solution to this problem would be something like','line_number':17,'multiline':False]['text':' `disable_if<is_module_holder<T>::value && typename T::ContainedType == C>`.','line_number':18,'multiline':False]['text':' This would disable all types that are not `ModuleHolder`s, because even','line_number':19,'multiline':False]['text':' though the `is_module_holder<T>::value` may be `false` for such types the','line_number':20,'multiline':False]['text':' `T::ContainedType` access would be ill-formed and thus fail the whole','line_number':21,'multiline':False]['text':' expression by the rules of SFINAE. Instead we have to use template','line_number':22,'multiline':False]['text':' specialization to statically branch on the first condition','line_number':23,'multiline':False]['text':' (`is_module_holder<T>`) and are only then allowed to query','line_number':24,'multiline':False]['text':' `T::ContainedType` in the branch for which the condition was true.','line_number':25,'multiline':False]['text':' Base template.','line_number':27,'multiline':False]['text':' False branch. `T` is not a `ModuleHolder` and thus not a `ModuleHolder` with','line_number':31,'multiline':False]['text':' contained type `C`.','line_number':32,'multiline':False]['text':' True branch. `T` is a `ModuleHolder` and thus we can legit access its','line_number':36,'multiline':False]['text':' `ContainedType` and compare it against `C`.','line_number':37,'multiline':False]['text':' Helper template.','line_number':42,'multiline':False]['text':' A collection of templates that allow deducing the return type of the','line_number':49,'multiline':False]['text':' `forward()` method, but only if a module actually has a `forward()` method,','line_number':50,'multiline':False]['text':' and otherwise deduces to the type `void`.','line_number':51,'multiline':False]