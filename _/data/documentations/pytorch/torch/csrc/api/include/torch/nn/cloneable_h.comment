['text':'/ The `clone()` method in the base `Module` class does not have knowledge of','line_number':15,'multiline':False]['text':'/ the concrete runtime type of its subclasses. Therefore, `clone()` must','line_number':16,'multiline':False]['text':'/ either be called from within the subclass, or from a base class that has','line_number':17,'multiline':False]['text':'/ knowledge of the concrete type. `Cloneable` uses the CRTP to gain','line_number':18,'multiline':False]['text':'/ knowledge of the subclass' static type and provide an implementation of the','line_number':19,'multiline':False]['text':'/ `clone()` method. We do not want to use this pattern in the base class,','line_number':20,'multiline':False]['text':'/ because then storing a module would always require templatizing it.','line_number':21,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-exception-escape)','line_number':23,'multiline':False]['text':'/ `reset()` must perform initialization of all members with reference','line_number':28,'multiline':False]['text':'/ semantics, most importantly parameters, buffers and submodules.','line_number':29,'multiline':False]['text':'/ Performs a recursive "deep copy" of the `Module`, such that all parameters','line_number':32,'multiline':False]['text':'/ and submodules in the cloned module are different from those in the','line_number':33,'multiline':False]['text':'/ original module.','line_number':34,'multiline':False]['text':'recurse=','line_number':51,'multiline':True]['text':'recurse=','line_number':64,'multiline':True]['text':' Here we are *pretty* certain that `other's` type is `Derived` (because it','line_number':85,'multiline':False]['text':' was registered under the same name as `this`), but you never know what','line_number':86,'multiline':False]['text':' crazy things `reset()` does, so `dynamic_cast` just to be safe.','line_number':87,'multiline':False]['text':' namespace nn','line_number':97,'multiline':False]['text':' namespace torch','line_number':98,'multiline':False]