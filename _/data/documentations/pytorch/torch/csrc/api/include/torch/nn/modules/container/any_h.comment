['text':'/ Stores a type erased `Module`.','line_number':24,'multiline':False]['text':'/','line_number':25,'multiline':False]['text':'/ The PyTorch C++ API does not impose an interface on the signature of','line_number':26,'multiline':False]['text':'/ `forward()` in `Module` subclasses. This gives you complete freedom to','line_number':27,'multiline':False]['text':'/ design your `forward()` methods to your liking. However, this also means','line_number':28,'multiline':False]['text':'/ there is no unified base type you could store in order to call `forward()`','line_number':29,'multiline':False]['text':'/ polymorphically for any module. This is where the `AnyModule` comes in.','line_number':30,'multiline':False]['text':'/ Instead of inheritance, it relies on type erasure for polymorphism.','line_number':31,'multiline':False]['text':'/','line_number':32,'multiline':False]['text':'/ An `AnyModule` can store any `nn::Module` subclass that provides a','line_number':33,'multiline':False]['text':'/ `forward()` method. This `forward()` may accept any types and return any','line_number':34,'multiline':False]['text':'/ type. Once stored in an `AnyModule`, you can invoke the underlying module's','line_number':35,'multiline':False]['text':'/ `forward()` by calling `AnyModule::forward()` with the arguments you would','line_number':36,'multiline':False]['text':'/ supply to the stored module (though see one important limitation below).','line_number':37,'multiline':False]['text':'/ Example:','line_number':38,'multiline':False]['text':'/','line_number':39,'multiline':False]['text':'/ \rst','line_number':40,'multiline':False]['text':'/ .. code-block:: cpp','line_number':41,'multiline':False]['text':'/','line_number':42,'multiline':False]['text':'/   struct GenericTrainer {','line_number':43,'multiline':False]['text':'/     torch::nn::AnyModule module;','line_number':44,'multiline':False]['text':'/','line_number':45,'multiline':False]['text':'/     void train(torch::Tensor input) {','line_number':46,'multiline':False]['text':'/       module.forward(input);','line_number':47,'multiline':False]['text':'/     }','line_number':48,'multiline':False]['text':'/   };','line_number':49,'multiline':False]['text':'/','line_number':50,'multiline':False]['text':'/   GenericTrainer trainer1{torch::nn::Linear(3, 4)};','line_number':51,'multiline':False]['text':'/   GenericTrainer trainer2{torch::nn::Conv2d(3, 4, 2)};','line_number':52,'multiline':False]['text':'/ \endrst','line_number':53,'multiline':False]['text':'/','line_number':54,'multiline':False]['text':'/ As `AnyModule` erases the static type of the stored module (and its','line_number':55,'multiline':False]['text':'/ `forward()` method) to achieve polymorphism, type checking of arguments is','line_number':56,'multiline':False]['text':'/ moved to runtime. That is, passing an argument with an incorrect type to an','line_number':57,'multiline':False]['text':'/ `AnyModule` will compile, but throw an exception at runtime:','line_number':58,'multiline':False]['text':'/','line_number':59,'multiline':False]['text':'/ \rst','line_number':60,'multiline':False]['text':'/ .. code-block:: cpp','line_number':61,'multiline':False]['text':'/','line_number':62,'multiline':False]['text':'/   torch::nn::AnyModule module(torch::nn::Linear(3, 4));','line_number':63,'multiline':False]['text':'/   // Linear takes a tensor as input, but we are passing an integer.','line_number':64,'multiline':False]['text':'/   // This will compile, but throw a `torch::Error` exception at runtime.','line_number':65,'multiline':False]['text':'/   module.forward(123);','line_number':66,'multiline':False]['text':'/ \endrst','line_number':67,'multiline':False]['text':'/','line_number':68,'multiline':False]['text':'/ \rst','line_number':69,'multiline':False]['text':'/ .. attention::','line_number':70,'multiline':False]['text':'/   One noteworthy limitation of `AnyModule` is that its `forward()` method','line_number':71,'multiline':False]['text':'/   does not support implicit conversion of argument types. For example, if','line_number':72,'multiline':False]['text':'/   the stored module's `forward()` method accepts a `float` and you call','line_number':73,'multiline':False]['text':'/   `any_module.forward(3.4)` (where `3.4` is a `double`), this will throw','line_number':74,'multiline':False]['text':'/   an exception.','line_number':75,'multiline':False]['text':'/ \endrst','line_number':76,'multiline':False]['text':'/','line_number':77,'multiline':False]['text':'/ The return type of the `AnyModule`'s `forward()` method is controlled via','line_number':78,'multiline':False]['text':'/ the first template argument to `AnyModule::forward()`. It defaults to','line_number':79,'multiline':False]['text':'/ `torch::Tensor`. To change it, you can write `any_module.forward<int>()`,','line_number':80,'multiline':False]['text':'/ for example.','line_number':81,'multiline':False]['text':'/','line_number':82,'multiline':False]['text':'/ \rst','line_number':83,'multiline':False]['text':'/ .. code-block:: cpp','line_number':84,'multiline':False]['text':'/','line_number':85,'multiline':False]['text':'/   torch::nn::AnyModule module(torch::nn::Linear(3, 4));','line_number':86,'multiline':False]['text':'/   auto output = module.forward(torch::ones({2, 3}));','line_number':87,'multiline':False]['text':'/','line_number':88,'multiline':False]['text':'/   struct IntModule {','line_number':89,'multiline':False]['text':'/     int forward(int x) { return x; }','line_number':90,'multiline':False]['text':'/   };','line_number':91,'multiline':False]['text':'/   torch::nn::AnyModule module(IntModule{});','line_number':92,'multiline':False]['text':'/   int output = module.forward<int>(5);','line_number':93,'multiline':False]['text':'/ \endrst','line_number':94,'multiline':False]['text':'/','line_number':95,'multiline':False]['text':'/ The only other method an `AnyModule` provides access to on the stored','line_number':96,'multiline':False]['text':'/ module is `clone()`. However, you may acquire a handle on the module via','line_number':97,'multiline':False]['text':'/ `.ptr()`, which returns a `shared_ptr<nn::Module>`. Further, if you know','line_number':98,'multiline':False]['text':'/ the concrete type of the stored module, you can get a concrete handle to it','line_number':99,'multiline':False]['text':'/ using `.get<T>()` where `T` is the concrete module type.','line_number':100,'multiline':False]['text':'/','line_number':101,'multiline':False]['text':'/ \rst','line_number':102,'multiline':False]['text':'/ .. code-block:: cpp','line_number':103,'multiline':False]['text':'/','line_number':104,'multiline':False]['text':'/   torch::nn::AnyModule module(torch::nn::Linear(3, 4));','line_number':105,'multiline':False]['text':'/   std::shared_ptr<nn::Module> ptr = module.ptr();','line_number':106,'multiline':False]['text':'/   torch::nn::Linear linear(module.get<torch::nn::Linear>());','line_number':107,'multiline':False]['text':'/ \endrst','line_number':108,'multiline':False]['text':'/ A default-constructed `AnyModule` is in an empty state.','line_number':111,'multiline':False]['text':'/ Constructs an `AnyModule` from a `shared_ptr` to concrete module object.','line_number':114,'multiline':False]['text':'/ Constructs an `AnyModule` from a concrete module object.','line_number':118,'multiline':False]['text':'/ Constructs an `AnyModule` from a module holder.','line_number':124,'multiline':False]['text':'/ Move construction and assignment is allowed, and follows the default','line_number':128,'multiline':False]['text':'/ behavior of move for `std::unique_ptr`.','line_number':129,'multiline':False]['text':'/ Creates a shallow copy of an `AnyModule`.','line_number':133,'multiline':False]['text':'/ Creates a deep copy of an `AnyModule` if it contains a module, else an','line_number':137,'multiline':False]['text':'/ empty `AnyModule` if it is empty.','line_number':138,'multiline':False]['text':'/ Assigns a module to the `AnyModule` (to circumvent the explicit','line_number':141,'multiline':False]['text':'/ constructor).','line_number':142,'multiline':False]['text':'/ Invokes `forward()` on the contained module with the given arguments, and','line_number':146,'multiline':False]['text':'/ returns the return value as an `AnyValue`. Use this method when chaining','line_number':147,'multiline':False]['text':'/ `AnyModule`s in a loop.','line_number':148,'multiline':False]['text':'/ Invokes `forward()` on the contained module with the given arguments, and','line_number':152,'multiline':False]['text':'/ casts the returned `AnyValue` to the supplied `ReturnType` (which defaults','line_number':153,'multiline':False]['text':'/ to `torch::Tensor`).','line_number':154,'multiline':False]['text':'/ Attempts to cast the underlying module to the given module type. Throws an','line_number':158,'multiline':False]['text':'/ exception if the types do not match.','line_number':159,'multiline':False]['text':'/ Attempts to cast the underlying module to the given module type. Throws an','line_number':163,'multiline':False]['text':'/ exception if the types do not match.','line_number':164,'multiline':False]['text':'/ Returns the contained module in a `nn::ModuleHolder` subclass if possible','line_number':168,'multiline':False]['text':'/ (i.e. if `T` has a constructor for the underlying module type).','line_number':169,'multiline':False]['text':'/ Returns a `std::shared_ptr` whose dynamic type is that of the underlying','line_number':173,'multiline':False]['text':'/ module.','line_number':174,'multiline':False]['text':'/ Like `ptr()`, but casts the pointer to the given type.','line_number':177,'multiline':False]['text':'/ Returns the `type_info` object of the contained value.','line_number':181,'multiline':False]['text':'/ Returns true if the `AnyModule` does not contain a module.','line_number':184,'multiline':False]['text':'/ Creates a `unique_ptr<AnyModulePlaceholder>` pointing to a','line_number':188,'multiline':False]['text':'/ `AnyModuleHolder` of the correct type. This method is used to deduce the','line_number':189,'multiline':False]['text':'/ arguments of the module's `forward()` method.','line_number':190,'multiline':False]['text':'/ Helper method invoked by const and non-const `get()`.','line_number':200,'multiline':False]['text':'/ Helper method invoked by const and non-const `get()`.','line_number':204,'multiline':False]['text':'/ The type erased module.','line_number':208,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ AnyModule ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':212,'multiline':False]['text':' `AnyModule` can only store an `nn::Module` subclass object that provides','line_number':219,'multiline':False]['text':' a `forward()` method that has a non-templatized return type.','line_number':220,'multiline':False]['text':' (e.g. `AnyModule` cannot store `nn::Sequential`, because `nn::Sequential`'s','line_number':221,'multiline':False]['text':' `forward()` method has a templatized return type.)','line_number':222,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-c-copy-assignment-signature)','line_number':264,'multiline':False]['text':' Call get() but discard the value, just to do the type checking.','line_number':310,'multiline':False]['text':' Private Methods','line_number':324,'multiline':False]['text':' namespace nn','line_number':371,'multiline':False]['text':' namespace torch','line_number':372,'multiline':False]