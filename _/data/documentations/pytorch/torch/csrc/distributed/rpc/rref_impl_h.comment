['text':' index of ownerId in the tuple','line_number':21,'multiline':False]['text':' index of RRefId.createdOn_ in the tuple','line_number':22,'multiline':False]['text':' index of RRefId.localId_ in the tuple','line_number':23,'multiline':False]['text':' index of ForkId.createdOn_ in the tuple','line_number':24,'multiline':False]['text':' index of ForkId.localId_ in the tuple','line_number':25,'multiline':False]['text':' index of parent in the tuple','line_number':26,'multiline':False]['text':' index of parent in the tuple','line_number':27,'multiline':False]['text':' NB: if more fields are added, make sure this field is also bumped','line_number':29,'multiline':False]['text':' number of RRefForkData fields in py::tuple','line_number':30,'multiline':False]['text':' Represents fork of an RRef to be sent over the wire.','line_number':32,'multiline':False]['text':' Note [RRef Protocol]','line_number':48,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':49,'multiline':False]['text':'','line_number':50,'multiline':False]['text':' [Background]','line_number':51,'multiline':False]['text':'','line_number':52,'multiline':False]['text':' RRef stands for Remote REFerence. Each RRef is owned by a single worker','line_number':53,'multiline':False]['text':' (i.e., owner) and can be used by multiple users. The owner stores the real','line_number':54,'multiline':False]['text':' data referenced by its RRefs. RRef needs to support fast and scalable RPC.','line_number':55,'multiline':False]['text':' Hence, in the design, we avoid using a single global master to keep RRef','line_number':56,'multiline':False]['text':' states, instead owners will keep track of the global reference counts','line_number':57,'multiline':False]['text':' for its RRefs. Every RRef can be uniquely identified by a global RRefId,','line_number':58,'multiline':False]['text':' which is assigned at the time it is first created either on a user or on the','line_number':59,'multiline':False]['text':' owner.','line_number':60,'multiline':False]['text':'','line_number':61,'multiline':False]['text':' On the owner worker, there is only one OwnerRRef instance, which contains the','line_number':62,'multiline':False]['text':' real data, while on user workers, there can be as many UserRRefs as','line_number':63,'multiline':False]['text':' necessary, and UserRRef does not hold the data. All usage on the OwnerRRef','line_number':64,'multiline':False]['text':' should retrieve the unique OwnerRRef instance using the globally unique','line_number':65,'multiline':False]['text':' RRefId. //A UserRRef will be created when it is used as an argument or return','line_number':66,'multiline':False]['text':' value in dist.rpc or dist.remote call, but RRef forking and reference','line_number':67,'multiline':False]['text':' counting (RC) are completely transparent to applications. Every UserRRef will','line_number':68,'multiline':False]['text':' also have its globally unique ForkId.','line_number':69,'multiline':False]['text':'','line_number':70,'multiline':False]['text':' [Assumptions]','line_number':71,'multiline':False]['text':'','line_number':72,'multiline':False]['text':' 1. Transient Network Failures','line_number':73,'multiline':False]['text':'','line_number':74,'multiline':False]['text':' TODO: current RRef implementation does not tolerate failures','line_number':75,'multiline':False]['text':'','line_number':76,'multiline':False]['text':' The RRef design handles transient network failures by retrying','line_number':77,'multiline':False]['text':' messages. Node crashes or permanent network partition is beyond the scope.','line_number':78,'multiline':False]['text':' When those incidents occur, the application may take down all workers, revert','line_number':79,'multiline':False]['text':' to the previous checkpoint, and resume training.','line_number':80,'multiline':False]['text':'','line_number':81,'multiline':False]['text':' 2. Non-idempotent UDFs','line_number':82,'multiline':False]['text':'','line_number':83,'multiline':False]['text':' We assume UDFs are not idempotent and therefore cannot be retried. However,','line_number':84,'multiline':False]['text':' internal RRef control messages are idempotent and retried upon message','line_number':85,'multiline':False]['text':' failure.','line_number':86,'multiline':False]['text':'','line_number':87,'multiline':False]['text':' TODO: RRef internal messages are not yet idempotent','line_number':88,'multiline':False]['text':'','line_number':89,'multiline':False]['text':' 3. Out of Order Message Delivery','line_number':90,'multiline':False]['text':'','line_number':91,'multiline':False]['text':' We do not assume message delivery order between any pair of nodes, because','line_number':92,'multiline':False]['text':' both sender and receiver are using multiple threads. There is no guarantee on','line_number':93,'multiline':False]['text':' which message will be processed first.','line_number':94,'multiline':False]['text':'','line_number':95,'multiline':False]['text':' [RRef Lifetime]','line_number':96,'multiline':False]['text':'','line_number':97,'multiline':False]['text':' The goal of the protocol is to delete an OwnerRRef at an appropriate time.','line_number':98,'multiline':False]['text':' The right time to delete an OwnerRRef is when there are no living UserRRefs','line_number':99,'multiline':False]['text':' and Python GC also agrees to delete the OwnerRRef instance on the owner. The','line_number':100,'multiline':False]['text':' tricky part is to determine if there are any living UserRRefs.','line_number':101,'multiline':False]['text':'','line_number':102,'multiline':False]['text':' A user can get a UserRRef in three situations:','line_number':103,'multiline':False]['text':'','line_number':104,'multiline':False]['text':' (1). Receiving a UserRRef from the owner.','line_number':105,'multiline':False]['text':' (2). Receiving a UserRRef from another user.','line_number':106,'multiline':False]['text':' (3). Creating a new UserRRef owned by another worker.','line_number':107,'multiline':False]['text':'','line_number':108,'multiline':False]['text':' (1) is the simplest case where the owner initiates the fork, and hence it can','line_number':109,'multiline':False]['text':' easily increment local RC. The only requirement is that any UserRRef must','line_number':110,'multiline':False]['text':' notify the owner before destruction. Hence, we need the first guarantee:','line_number':111,'multiline':False]['text':'','line_number':112,'multiline':False]['text':' G1. The owner will be notified when any UserRRef is deleted.','line_number':113,'multiline':False]['text':'','line_number':114,'multiline':False]['text':' As messages might come delayed or out-of-order, we need more one guarantee to','line_number':115,'multiline':False]['text':' make sure the delete message is not sent out too soon. Let us first introduce','line_number':116,'multiline':False]['text':' a new concept. If A sends an RPC to B that involves an RRef, we call the RRef','line_number':117,'multiline':False]['text':' on A the parent RRef and the RRef on B the child RRef.','line_number':118,'multiline':False]['text':'','line_number':119,'multiline':False]['text':' G2. Parent RRef cannot be deleted until the child RRef is confirmed by the','line_number':120,'multiline':False]['text':'     owner.','line_number':121,'multiline':False]['text':'','line_number':122,'multiline':False]['text':' Under (1), where the caller is UserRRef and callee is OwnerRRef, it simply','line_number':123,'multiline':False]['text':' means that the user will not send out the delete message until all previous','line_number':124,'multiline':False]['text':' messages are ACKed. Note that ACKed does not mean the owner finishes','line_number':125,'multiline':False]['text':' executing the function, instead, it only means the owner has retrieved its','line_number':126,'multiline':False]['text':' local OwnerRRef and about to pass it to the function, which is sufficient to','line_number':127,'multiline':False]['text':' keep the OwnerRRef alive even if the delete message from the user arrives at','line_number':128,'multiline':False]['text':' the owner before the function finishes execution.','line_number':129,'multiline':False]['text':'','line_number':130,'multiline':False]['text':' With (2) and (3), it is possible that the owner only partially knows the RRef','line_number':131,'multiline':False]['text':' fork graph or not even knowing it at all. For example, the RRef could be','line_number':132,'multiline':False]['text':' constructed on a user, and before the owner receives the RPC call, the','line_number':133,'multiline':False]['text':' creator user might have already shared the RRef with other users, and those','line_number':134,'multiline':False]['text':' users could further share the RRef. One invariant is that the fork graph of','line_number':135,'multiline':False]['text':' any RRef is always a tree rooted at the owner, because forking an RRef always','line_number':136,'multiline':False]['text':' creates a new RRef instance, and hence every RRef has a single parent. One','line_number':137,'multiline':False]['text':' nasty detail is that when an RRef is created on a user, technically the owner','line_number':138,'multiline':False]['text':' is not its parent but we still consider it that way and it does not break the','line_number':139,'multiline':False]['text':' argument below.','line_number':140,'multiline':False]['text':'','line_number':141,'multiline':False]['text':' The owner's view on any node (fork) in the tree has three stages:','line_number':142,'multiline':False]['text':'','line_number':143,'multiline':False]['text':'       1) unknown -> 2) known -> 3) deleted.','line_number':144,'multiline':False]['text':'','line_number':145,'multiline':False]['text':' The owner's view on the entire tree keeps changing. The owner deletes its','line_number':146,'multiline':False]['text':' OwnerRRef instance when it thinks there are no living UserRRefs, i.e., when','line_number':147,'multiline':False]['text':' OwnerRRef is deleted, all UserRRefs could be either indeed deleted or','line_number':148,'multiline':False]['text':' unknown. The dangerous case is when some forks are unknown and others are','line_number':149,'multiline':False]['text':' deleted.','line_number':150,'multiline':False]['text':'','line_number':151,'multiline':False]['text':' G2 trivially guarantees that no parent UserRRef Y can be deleted before the','line_number':152,'multiline':False]['text':' owner knows all of Y's children UserRRefs.','line_number':153,'multiline':False]['text':'','line_number':154,'multiline':False]['text':' However, it is possible that the child UserRRef Z may be deleted before the','line_number':155,'multiline':False]['text':' owner knows its parent Y. More specifically, this can happen when all of Z's','line_number':156,'multiline':False]['text':' messages are processed by the owner before all messages from Y, including the','line_number':157,'multiline':False]['text':' delete message. Nevertheless, this does not cause any problem. Because, at','line_number':158,'multiline':False]['text':' least one of Y's ancestor will be alive, and it will prevent the owner from','line_number':159,'multiline':False]['text':' deleting the OwnerRRef. Consider the following example: (NB: this scenario','line_number':160,'multiline':False]['text':' will no longer relevant when we block UDF until all RRefs are confirmed by','line_number':161,'multiline':False]['text':' the owner)','line_number':162,'multiline':False]['text':'','line_number':163,'multiline':False]['text':'     OwnerRRef -> A -> Y -> Z','line_number':164,'multiline':False]['text':'','line_number':165,'multiline':False]['text':' OwnerRRef forks to A, then A forks to Y, and Y forks to Z. Z can be deleted','line_number':166,'multiline':False]['text':' without OwnerRRef knowing Y. However, the OwnerRRef will at least know A, as','line_number':167,'multiline':False]['text':' the owner directly forks the RRef to A. A won't die before the owner knows Y.','line_number':168,'multiline':False]['text':'','line_number':169,'multiline':False]['text':' Things get a little trickier if the RRef is created on a user:','line_number':170,'multiline':False]['text':'','line_number':171,'multiline':False]['text':'  OwnerRRef','line_number':172,'multiline':False]['text':'      ^','line_number':173,'multiline':False]['text':'      |','line_number':174,'multiline':False]['text':'      A -> Y -> Z','line_number':175,'multiline':False]['text':'','line_number':176,'multiline':False]['text':' If Z calls to_here on the UserRRef, the owner at least knows A when Z is','line_number':177,'multiline':False]['text':' deleted, because otherwise to_here wouldn't finish. If Z does not call','line_number':178,'multiline':False]['text':' to_here, it is possible that the owner receives all messages from Z before','line_number':179,'multiline':False]['text':' any message from A and Y. In this case, as the real data of the OwnerRRef has','line_number':180,'multiline':False]['text':' not been created yet, there is nothing to be deleted either. It is the same','line_number':181,'multiline':False]['text':' as Z does not exist at all Hence, it's still OK.','line_number':182,'multiline':False]['text':'','line_number':183,'multiline':False]['text':' See #26759 for more details and discussions.','line_number':184,'multiline':False]['text':'','line_number':185,'multiline':False]['text':' TODO: make RRef an IValue, and edit createStackForSchema accordingly','line_number':186,'multiline':False]['text':' TODO: make RRef system messages idempotent and retry on failures.','line_number':187,'multiline':False]['text':'','line_number':188,'multiline':False]['text':' ``RRef`` is the base type for both ``UserRRef`` and ``OwnerRRef``.','line_number':189,'multiline':False]['text':' Each ``RRef`` has a globally unique ``RRefId``.','line_number':190,'multiline':False]['text':' RRef is made NOT copyable NOT movable to prevent messing up reference','line_number':193,'multiline':False]['text':' counting.','line_number':194,'multiline':False]['text':' returns the worker id of the owner','line_number':201,'multiline':False]['text':' returns the worker name of the owner','line_number':206,'multiline':False]['text':' returns the worker info of the owner','line_number':211,'multiline':False]['text':' Returns the globally unique RRefId of this RRef','line_number':216,'multiline':False]['text':' Save the future corresponding to the creation of this RRef on a remote','line_number':228,'multiline':False]['text':' node. Note that this is only set when processing requests invoked with','line_number':229,'multiline':False]['text':' rpc.remote. This is only used to get the future corresponding to the rref','line_number':230,'multiline':False]['text':' for profiling use cases.','line_number':231,'multiline':False]['text':' Get the future corresponding to the creation of this rref.','line_number':236,'multiline':False]['text':' Check if creation of this RRef on owner node has timed out.','line_number':241,'multiline':False]['text':' Dispatches an error to the correct handler based on its RPCErrorType.','line_number':246,'multiline':False]['text':' Send delete UserRRef request to Owner,','line_number':249,'multiline':False]['text':' if the request hasn't been sent yet.','line_number':250,'multiline':False]['text':' There are 2 cases to call it,','line_number':251,'multiline':False]['text':' 1, Python GC decides end of UserRRef lifetime, calling destructor.','line_number':252,'multiline':False]['text':' 2, RPC module graceful shutdown calls it on all UserRRefs tracked','line_number':253,'multiline':False]['text':'    in the RRefContext.','line_number':254,'multiline':False]['text':' Indicates that the creation of this RRef on owner node has timed out.','line_number':258,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':268,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':270,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':272,'multiline':False]['text':' type field to denote the type of the element that the RRef is holding','line_number':275,'multiline':False]['text':' it could be any TypePtr that JIT support, including PyObjectType','line_number':276,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':277,'multiline':False]['text':' Future corresponding to request to create RRef on remote node.','line_number':279,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)','line_number':280,'multiline':False]['text':' ``UserRRef`` represents a user of an RRef. Besides the ``RRefId``, each user','line_number':284,'multiline':False]['text':' also has a globally unique ``ForkId`` to identify this user. ``UserRRef``','line_number':285,'multiline':False]['text':' never owns the real value, the only way to get the value of the ``RRef`` is','line_number':286,'multiline':False]['text':' to call ``to_here()`` and get a copy..','line_number':287,'multiline':False]['text':' Returns the globally unique ForkId of this RRef','line_number':309,'multiline':False]['text':' Get of copy of the value from the ``OwnerRRef``. If the value is not ready','line_number':312,'multiline':False]['text':' yet, this call will block.','line_number':313,'multiline':False]['text':' Will be called when refcount reaches 0.','line_number':320,'multiline':False]['text':' Upon destruction, this ``UserRRef`` will tell the owner to deref.','line_number':321,'multiline':False]['text':' Will be called when both refcount and weakcount reach 0. See','line_number':324,'multiline':False]['text':' https://github.com/pytorch/pytorch/blob/9116f02bebf3a5260feef5732d36c54ecb3b4033/c10/util/intrusive_ptr.h#L204','line_number':325,'multiline':False]['text':' This is called on destructing the wrapping intrusive_ptr_target instance','line_number':326,'multiline':False]['text':' and it's data members.','line_number':327,'multiline':False]['text':' Indicates if this user has sent delete message to it's owner.','line_number':340,'multiline':False]['text':' Note, thread safety is needed because delete message could be sent by','line_number':341,'multiline':False]['text':' either the destructor called by Python garbage collection or RRefContext','line_number':342,'multiline':False]['text':' proactive cleanup on RPC graceful shutdown.','line_number':343,'multiline':False]['text':' Indicating whether this UserRRef has been confirmed by its owner.','line_number':346,'multiline':False]['text':' Keep the template only on the derived class because ``RRefContext`` needs to','line_number':350,'multiline':False]['text':' erase the type on ``RRef`` and keep them in one map.','line_number':351,'multiline':False]['text':' OwnerRRef is always confirmed, while UserRRef is only confirmed when the','line_number':376,'multiline':False]['text':' owner knows about it.','line_number':377,'multiline':False]['text':' Get a constant reference of the real value. This method will block if the','line_number':382,'multiline':False]['text':' value is not ready. This method does not need GIL as it does not create','line_number':383,'multiline':False]['text':' any new py::object. It will throw if there is an error.','line_number':384,'multiline':False]['text':' Set the value of this ``OwnerRRef``. This method does not need GIL as it','line_number':387,'multiline':False]['text':' does not create any new py::object.','line_number':388,'multiline':False]['text':' Sets the value of this ``OwnerRRef`` to contain an exception.','line_number':390,'multiline':False]['text':' Has a value or error been set?','line_number':393,'multiline':False]['text':' Gets a future that is satisfied when the value or error is set.','line_number':395,'multiline':False]['text':' Helper function that casts from c10::RRefInterface to OwnerRRef','line_number':406,'multiline':False]['text':' Helper function that casts from OwnerRRef to c10::RRefInterface','line_number':412,'multiline':False]['text':' namespace rpc','line_number':418,'multiline':False]['text':' namespace distributed','line_number':419,'multiline':False]['text':' namespace torch','line_number':420,'multiline':False]