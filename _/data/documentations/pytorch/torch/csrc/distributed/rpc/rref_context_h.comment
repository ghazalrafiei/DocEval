['text':' It's the callback for RemoteCall.','line_number':17,'multiline':False]['text':' It's the callback for finishing creating owner rref, it returned deletedRRef,','line_number':21,'multiline':False]['text':' so that the deletedRRef can be handled under GIL in python_functions.cpp if','line_number':22,'multiline':False]['text':' deletedRRef contains python object.','line_number':23,'multiline':False]['text':' namespace callback','line_number':26,'multiline':False]['text':' Manages RRef lifetime and keeps track of RRef forks.','line_number':28,'multiline':False]['text':' NB: This method must be called before destructing RRefContext singleton.','line_number':32,'multiline':False]['text':' Similar to delForkOfOwner, this method returns a vector of OwnerRRefs that','line_number':33,'multiline':False]['text':' hold py::object. The call-site is also responsible for resetting those','line_number':34,'multiline':False]['text':' shared_ptr objects with a GIL. See comments at delForkOfOwner() for more','line_number':35,'multiline':False]['text':' details.','line_number':36,'multiline':False]['text':' handle exception without throw ::c10::Error again','line_number':42,'multiline':False]['text':' get the worker id of the current worker','line_number':52,'multiline':False]['text':' get the worker name of the current worker','line_number':57,'multiline':False]['text':'  generate a globally unique ID','line_number':62,'multiline':False]['text':' create a ``UserRRef`` owned by the worker ``ownerId``','line_number':71,'multiline':False]['text':' Convert an RRefForkData into an RRef. This RRef could be user or owner.','line_number':76,'multiline':False]['text':' This RRef could have already existed before, or could be created in this','line_number':77,'multiline':False]['text':' method, we pass type here to validate or help the rref creation.','line_number':78,'multiline':False]['text':' Get the ``OwnerRRef`` of id ``rrefId``. If it does not exist, create a new','line_number':83,'multiline':False]['text':' one. This function is called in two places:','line_number':84,'multiline':False]['text':' 1. when processing ``rpc.remote()``, i.e., ``SCRIPT_REMOTE_CALL``','line_number':85,'multiline':False]['text':'    ``PYTHON_REMOTE_CALL``.','line_number':86,'multiline':False]['text':' 2. when unpickling ``OwnerRRef``.','line_number':87,'multiline':False]['text':' What's common in these two cases are, 1) the RRefId is already generated','line_number':88,'multiline':False]['text':' 2) the TypePtr is presented. So it can always create the ``OwnerRRef`` if','line_number':89,'multiline':False]['text':' it is not yet available.','line_number':90,'multiline':False]['text':' Create an empty owner rref of type.','line_number':95,'multiline':False]['text':' This method is called to first time generate an ``OwnerRRef``, e.g.,','line_number':96,'multiline':False]['text':' 1) ``rpc.RRef(obj)``','line_number':97,'multiline':False]['text':' 2) create the ``OwnerRRef`` on `rpc.remote()` caller side.','line_number':98,'multiline':False]['text':' What's common in these two cases are, 1) the RRefId hasn't been generated','line_number':99,'multiline':False]['text':' 2) the TypePtr is presented.','line_number':100,'multiline':False]['text':' Returns a Future of the OwnerRRef, which will be marked completed when','line_number':103,'multiline':False]['text':' ``OwnerRRef`` is created. This method is used when the TypePtr is not','line_number':104,'multiline':False]['text':' available, e.g., when processing to_here(). The forceCreated flag can be','line_number':105,'multiline':False]['text':' used to ensure that the rref is created on the owner, otherwise throw in','line_number':106,'multiline':False]['text':' cases where the user of this API expects this to return a completed future.','line_number':107,'multiline':False]['text':' Note that the return value is a intrusive_ptr to a c10::ivalue::Future that','line_number':108,'multiline':False]['text':' holds the RRef.','line_number':109,'multiline':False]['text':' Adding the RRefId of an OwnerRRef into the forks_ map. This is useful when','line_number':114,'multiline':False]['text':' making a remote call to self, which as for now, still goes through serde','line_number':115,'multiline':False]['text':' and invokes request callback. In this case, the OwnerRRef has already been','line_number':116,'multiline':False]['text':' created on the send side, and we need to pass it to the receive side,','line_number':117,'multiline':False]['text':' instead of creating a new OwnerRRef. This is done by adding the OwnerRRef','line_number':118,'multiline':False]['text':' into owners_. However, that alone is not enough, as it could be deleted','line_number':119,'multiline':False]['text':' when all UserRRef die, which would then remove the OwnerRRef from owners_','line_number':120,'multiline':False]['text':' and this could happen before the self remote call finishes. To prevent','line_number':121,'multiline':False]['text':' that, this API adds the RRefId as a ForkId, which will then delete the','line_number':122,'multiline':False]['text':' ForkId when the self remote is done.','line_number':123,'multiline':False]['text':' Register a fork of the ``OwnerRRef``, and inserts a intrusive_ptr of the','line_number':126,'multiline':False]['text':' ``OwnerRRef`` in a map to keep it alive.','line_number':127,'multiline':False]['text':' Performs the same function as addForkOfOwner but ignores duplicate','line_number':129,'multiline':False]['text':' requests. This idempotent function is used with RREF_FORK_REQUEST calls,','line_number':130,'multiline':False]['text':' whereas all other message types use the non-idempotent variant.','line_number':131,'multiline':False]['text':' Delete a fork of the ``OwnerRRef``. NB: this could trigger deletion on the','line_number':133,'multiline':False]['text':' IValue or py::object. For the later, this method will acquire GIL.','line_number':134,'multiline':False]['text':' NB: If this fork deletion triggered deleting OwnerRRef, this method will','line_number':135,'multiline':False]['text':' return a shared_ptr to the OwnerRRef, which is likely to be the last','line_number':136,'multiline':False]['text':' shared_ptr instance for it. Therefore, deleting this shared_ptr<OwnerRRef>','line_number':137,'multiline':False]['text':' will also trigger deleting the object it points to. If OwnerRRef holds a','line_number':138,'multiline':False]['text':' py::object, deleting it require GIL. The call site should guarded it with','line_number':139,'multiline':False]['text':' a GIL and reset the shared_ptr. The GIL-guarded deletion is intentionally','line_number':140,'multiline':False]['text':' left out of this function to avoid creating dependency on pybind.','line_number':141,'multiline':False]['text':' Invoked when pickling an RRef to setup child/fork properly','line_number':146,'multiline':False]['text':' Invoked when unpickling an RRef to send RREF_FORK_REQUEST to owner and','line_number':148,'multiline':False]['text':' send RREF_CHILD_ACCEPT to the parent.','line_number':149,'multiline':False]['text':' NB: forkId is necessary here as the rref could be an OwnerRRef','line_number':150,'multiline':False]['text':' When a UserRRef is forked to another worker (user or owner), it is added','line_number':156,'multiline':False]['text':' into pendingChildren_ to be held alive until it receives RREF_CHILD_ACCEPT','line_number':157,'multiline':False]['text':' from the child.','line_number':158,'multiline':False]['text':' NB: This is necessary for both user and owner child. As we do not have FIFO','line_number':159,'multiline':False]['text':' communication between workers, we need this strategy to make sure that all','line_number':160,'multiline':False]['text':' previously submitted rpc/remote calls are acked before sending out the','line_number':161,'multiline':False]['text':' RREF_USER_DELETE message. Otherwise, the OwnerRRef could be deleted too','line_number':162,'multiline':False]['text':' soon.','line_number':163,'multiline':False]['text':' When a UserRRef is created, it is added into pendingUsers_ to be held alive','line_number':169,'multiline':False]['text':' until it receives RREF_USER_ACCEPT from the owner.','line_number':170,'multiline':False]['text':' Retrieve a pending user given the fork ID. Throws if the user has already','line_number':179,'multiline':False]['text':' been confirmed (i.e. is no longer in the pendingUsers_ map).','line_number':180,'multiline':False]['text':' Start recording new pending UserRRefs. All pending UserRRefs introduced','line_number':183,'multiline':False]['text':' after this point will be put into the thread_local userTable_, which will','line_number':184,'multiline':False]['text':' then be consumed and cleared in waitForThreadLocalPendingRRefs().','line_number':185,'multiline':False]['text':' End recording new pending UserRRefs, and clear the thread_local userTable_.','line_number':187,'multiline':False]['text':' Returns a Future which will be marked as completed when all pending','line_number':188,'multiline':False]['text':' UserRRefs in the current userTable_ are confirmed by their owners. The bool','line_number':189,'multiline':False]['text':' value in the Future is unused.','line_number':190,'multiline':False]['text':' This method is useful to make sure RRefs in user function arguments are','line_number':191,'multiline':False]['text':' confirmed before launching user code.','line_number':192,'multiline':False]['text':' NB: Callers of this method does not need to keep the returned Future alive,','line_number':193,'multiline':False]['text':' because this Future is already captured in callbacks of the','line_number':194,'multiline':False]['text':' PendingUserState. If there is no pending UserRRefs, this method returns a','line_number':195,'multiline':False]['text':' completed future.','line_number':196,'multiline':False]['text':' Only call this function when there are errors during a recording session,','line_number':198,'multiline':False]['text':' and it is likely that waitForThreadLocalPendingRRefs() cannot be invoked','line_number':199,'multiline':False]['text':' properly.','line_number':200,'multiline':False]['text':' TODO: make this a context guard','line_number':201,'multiline':False]['text':' Use Future.wait() and Future.markCompleted() to block and unblock user','line_number':225,'multiline':False]['text':' functions. The bool value wrapped by the future_ is not used.','line_number':226,'multiline':False]['text':' If there is any leak on any RRef, this method will throw an error.','line_number':240,'multiline':False]['text':' Keep OwnerRRefs alive until there is no living UserRRefs.','line_number':247,'multiline':False]['text':' A map to track OwnerRRefs that are requested but not yet created. This can','line_number':249,'multiline':False]['text':' happen if the to_here() message is processed on the owner before the','line_number':250,'multiline':False]['text':' corresponding creator rpc.remote() message. If this happens, instead of','line_number':251,'multiline':False]['text':' to_here() RPC thread to block waiting for the OwnerRRef creation, the','line_number':252,'multiline':False]['text':' RRefContext returns a Future, so that the RPC request processing logic can','line_number':253,'multiline':False]['text':' attach subsequent code as a callback to that Future.','line_number':254,'multiline':False]['text':' NB: the OwnerRRefs in this map must be cleared when the corresponding','line_number':255,'multiline':False]['text':' OwnerRRef is created. Note that the values in this map are intrusive_ptrs','line_number':256,'multiline':False]['text':' to c10::ivalue::Future that will be marked completed with the owner RRef.','line_number':257,'multiline':False]['text':' Tracks known living UserRRefs of an OwnerRRef','line_number':260,'multiline':False]['text':' This cond var is used by deleteAllUsers(), a event notification is sent if','line_number':267,'multiline':False]['text':' number of pending UserRRef or UserRRef children is reduced, or','line_number':268,'multiline':False]['text':' number of owned OwnerRRef is reduced.','line_number':269,'multiline':False]['text':' The follow 3 maps keep UserRRefs alive by holding a intrusive_ptr to the','line_number':271,'multiline':False]['text':' RRef instances. A UserRRef must be added into this map if any of the','line_number':272,'multiline':False]['text':' following two conditions is true:','line_number':273,'multiline':False]['text':'','line_number':274,'multiline':False]['text':' (1) A UserRRef has not been accepted by owner yet.','line_number':275,'multiline':False]['text':'','line_number':276,'multiline':False]['text':'     It can be used or shared, but cannot be deleted, and hence kept alive','line_number':277,'multiline':False]['text':'     in this map. A message of type RREF_USER_ACCEPT will move the','line_number':278,'multiline':False]['text':'     corresponding RRef from pendingUsers_ map to confirmedUsers_ map.','line_number':279,'multiline':False]['text':'     UserRRefs are added into this map when it is confirmed by the owner.','line_number':282,'multiline':False]['text':'     When destroying RRefContext this map helps to find local UserRRefs','line_number':283,'multiline':False]['text':'     and send delete messages if they are still not deleted by Python','line_number':284,'multiline':False]['text':'     garbage collection.','line_number':285,'multiline':False]['text':' (2) A UserRRef has forked a child UserRRef which has not been accepted by','line_number':289,'multiline':False]['text':'     the owner yet.','line_number':290,'multiline':False]['text':'','line_number':291,'multiline':False]['text':'     In this case, this UserRRef cannot send out RREF_USER_DELETE message,','line_number':292,'multiline':False]['text':'     as it could potentially trigger the OwnerRRef been deleted before the','line_number':293,'multiline':False]['text':'     owner learns about the forked child.','line_number':294,'multiline':False]['text':' The RRef context performs its operations through async RPC requests, in','line_number':298,'multiline':False]['text':' order to not block the user code. Therefore the RRef context's state may be','line_number':299,'multiline':False]['text':' lagging a bit behind what it is intended to be, while it waits for these','line_number':300,'multiline':False]['text':' requests to complete. To allow syncing when needed, we store the count of','line_number':301,'multiline':False]['text':' these pending requests, so that users can wait for it to reach zero.','line_number':302,'multiline':False]['text':' Thread local states to keep UserRRefs deserialized from user function','line_number':308,'multiline':False]['text':' arguments.','line_number':309,'multiline':False]['text':' A flag indicating whether subsequently created UserRRefs should be added to','line_number':311,'multiline':False]['text':' the thread_local userTable_. The flag is set to true before serializing','line_number':312,'multiline':False]['text':' RPC arguments and then set to false before running the corresponding','line_number':313,'multiline':False]['text':' user code. See addPendingUser and delPendingUser for more details.','line_number':314,'multiline':False]['text':' NB: The reason for having this flag is because addPendingUser are called in','line_number':315,'multiline':False]['text':' two cases, and we only want to track the 2nd case.','line_number':316,'multiline':False]['text':' (1) RRef as the return value: when calling rpc.remote, the UserRRef on the','line_number':317,'multiline':False]['text':'     caller side is added to the context using addPendingUser.','line_number':318,'multiline':False]['text':' (2) RRef as an argument: When running an RPC using RRefs as arguments, the','line_number':319,'multiline':False]['text':'     RRef is forwarded to the callee as new UserRRefs (if the callee is not','line_number':320,'multiline':False]['text':'     the owner). In this case, we block running the user function until all','line_number':321,'multiline':False]['text':'     UserRRefs are confirmed by the owner.','line_number':322,'multiline':False]['text':' This contract gurantees that no UserRRefs can be used remotely without','line_number':323,'multiline':False]['text':' confirmation. Note that, however, the UserRRef created by rpc.remote can','line_number':324,'multiline':False]['text':' still be passed to local functions as arguments and used there. This is by','line_number':325,'multiline':False]['text':' design, because this feature is especially useful when, say a master node','line_number':326,'multiline':False]['text':' creates multiple UserRRefs in a loop and then shares them with other nodes.','line_number':327,'multiline':False]['text':' Blocking every iteration in the loop until RRefs are confirmed will slow','line_number':328,'multiline':False]['text':' this down. This nuance on UserRRef can be interpreted as we only make','line_number':329,'multiline':False]['text':' exceptions for UserRRef creators. And using the UserRRef on its creator','line_number':330,'multiline':False]['text':' without confirmation is OK, because the creator would either call to_here','line_number':331,'multiline':False]['text':' or forward the UserRRef, and both would then require confirmations from the','line_number':332,'multiline':False]['text':' owner.','line_number':333,'multiline':False]['text':' namespace rpc','line_number':337,'multiline':False]['text':' namespace distributed','line_number':338,'multiline':False]['text':' namespace torch','line_number':339,'multiline':False]