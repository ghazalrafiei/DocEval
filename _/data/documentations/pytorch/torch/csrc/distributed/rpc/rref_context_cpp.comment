['text':' Handle errors, such as timeouts, by invoking the error handler on the','line_number':26,'multiline':False]['text':' rref.','line_number':27,'multiline':False]['text':' Note [Best Effort Error handling for Remote calls]:','line_number':28,'multiline':False]['text':' When remote calls initiated by rpc.remote() fail, such as with a timeout','line_number':29,'multiline':False]['text':' error, we take a best-effort approach to error handling. We handle errors','line_number':30,'multiline':False]['text':' when callbacks corresponding to the remote call run, and set the error','line_number':31,'multiline':False]['text':' information on the RRef. If the RRef has not been used by the application','line_number':32,'multiline':False]['text':' before this process (such as to_here or fork call), then future uses of','line_number':33,'multiline':False]['text':' the RRef will appropriately raise errors. However, it is possible that','line_number':34,'multiline':False]['text':' the user application will use the RRef before the errors are handled. In','line_number':35,'multiline':False]['text':' this case, errors may not be raised as they have not yet been handled.','line_number':36,'multiline':False]['text':' We expect to run this callback only after the OwnerRRef has been created,','line_number':49,'multiline':False]['text':' since this is only invoked when sending to self.','line_number':50,'multiline':False]['text':' foreCreated ','line_number':52,'multiline':True]['text':' OwnerRRefs do not have a forkId, so don't need to assert here.','line_number':57,'multiline':False]['text':' namespace callback','line_number':75,'multiline':False]['text':' Keys for RRef-related debug information.','line_number':77,'multiline':False]['text':' Leaky singleton to avoid module destructor races.','line_number':84,'multiline':False]['text':' Explicitly creating rrefId before forkId to make sure the order is','line_number':184,'multiline':False]['text':' deterministic, as the argument evaluation order is system and compiler','line_number':185,'multiline':False]['text':' dependent.','line_number':186,'multiline':False]['text':' RRefContext does not track user RRefs, it will be destructed when there','line_number':198,'multiline':False]['text':' is no shared_ptrs pointing to it.','line_number':199,'multiline':False]['text':'','line_number':200,'multiline':False]['text':' NB: cannot use make_shared here as the constructor of UserRRef is private.','line_number':201,'multiline':False]['text':' NB: This UserRRef has not been confirmed by the owner yet. This function's','line_number':202,'multiline':False]['text':' call site is responsible for adding this UserRRef to pendingUsers_.','line_number':203,'multiline':False]['text':' Currently, there are two call sites.','line_number':204,'multiline':False]['text':' (1) The creator user in python_functions.cpp','line_number':205,'multiline':False]['text':' (2) The callee user in RRefContext::notifyOwnerAndParentOfFork.','line_number':206,'multiline':False]['text':'','line_number':207,'multiline':False]['text':' The reason for not adding the pending user here is to put addPendingUser()','line_number':208,'multiline':False]['text':' close to where the RPC occurs, and it is more clear to pair it with','line_number':209,'multiline':False]['text':' deletePendingUser() in the response callback at the call site.','line_number':210,'multiline':False]['text':' Sending an RRefUserDelete causes the receiver to run delForkOfOwner,','line_number':221,'multiline':False]['text':' which is now idempotent. See the comment at RRefContext::delForkOfOwner','line_number':222,'multiline':False]['text':' for more details.','line_number':223,'multiline':False]['text':' First, wait for all pending UserRRefs to be confirmed,','line_number':242,'multiline':False]['text':' one kind is pendingUsers_, which are shared from Owner,','line_number':243,'multiline':False]['text':' the other kind pendingChildren_, which are shared from another User.','line_number':244,'multiline':False]['text':' Start sending UserRRef delete messages, after all pendings are confirmed.','line_number':259,'multiline':False]['text':' Note, there should be no new forkings in between, because it's assumed that','line_number':260,'multiline':False]['text':' this utility is called during graceful shutdown, where no new user RPCs can','line_number':261,'multiline':False]['text':' be initiaited anymore.','line_number':262,'multiline':False]['text':' tryDel() below will re-acquire lock, lock must be released here.','line_number':268,'multiline':False]['text':' If an rref in the owners_ map has never been forked, we will never get a','line_number':272,'multiline':False]['text':' corresponding message from the forking node(s) telling us to delete the','line_number':273,'multiline':False]['text':' RRef. Hence we delete the RRef here. This can occur when a remote call is','line_number':274,'multiline':False]['text':' sent to self and times out.','line_number':275,'multiline':False]['text':' Successful fork of owner was never processed.','line_number':282,'multiline':False]['text':' Wait for this node to process all delete UserRRef messages it may get for','line_number':295,'multiline':False]['text':' the OwnerRRefs that exist on this node.','line_number':296,'multiline':False]['text':' Scenario (1) the first time this owner knows about this RRef','line_number':326,'multiline':False]['text':'','line_number':327,'multiline':False]['text':' NB: cannot use make_shared here as the constructor of OwnerRRef is','line_number':328,'multiline':False]['text':' private.','line_number':329,'multiline':False]['text':' cast to RRefInterface to hold it into IValue','line_number':335,'multiline':False]['text':' Scenario (2) retrieving an existing RRef','line_number':342,'multiline':False]['text':' Now double check if the two types match','line_number':344,'multiline':False]['text':'','line_number':345,'multiline':False]['text':' Why we are special casing the check for tensor type here?','line_number':346,'multiline':False]['text':' this is because tensor types might get specialized on tensors when','line_number':347,'multiline':False]['text':' we pass inputs to the function, i.e. TensorType can filled with','line_number':348,'multiline':False]['text':' specific shape info, requires_grad info, etc. so the OwerRRef we','line_number':349,'multiline':False]['text':' found might already have those infos, but the `type` we passed in','line_number':350,'multiline':False]['text':' here is a plain TensorType, they are not equal relationship:','line_number':351,'multiline':False]['text':' specialized TensorType <: plain TensorType','line_number':352,'multiline':False]['text':'','line_number':353,'multiline':False]['text':' In RPC we don't care the difference as we ser/de with just the','line_number':354,'multiline':False]['text':' plain TensorType. This is not a issue for UserRRef creation either,','line_number':355,'multiline':False]['text':' since Tensor can only get specialized with a previous run of local','line_number':356,'multiline':False]['text':' JIT function, and we shouldn't preserve the specialized SubTensorType','line_number':357,'multiline':False]['text':' information on other workers because it's only information only.','line_number':358,'multiline':False]['text':' Don't add this OnwerRRef to the owners_ map yet, otherwise','line_number':378,'multiline':False]['text':' it will never be removed from there. Instead, only add it to the','line_number':379,'multiline':False]['text':' map in prepareChildFork, in case this local RRef is being passed','line_number':380,'multiline':False]['text':' to another worker.','line_number':381,'multiline':False]['text':' Scenario (1) RRef is used before it is created','line_number':397,'multiline':False]['text':' Note: The type passed into RRefType::create() does not matter here, as','line_number':400,'multiline':False]['text':' the future is marked as completed with the RRef of the specific type','line_number':401,'multiline':False]['text':' in getOrCreateOwnerRRef().','line_number':402,'multiline':False]['text':' We need to set devices here, even if they won't be used by the value','line_number':403,'multiline':False]['text':' (an RRef object doesn't contain any tensors, it just provides means to','line_number':404,'multiline':False]['text':' retrieve them) because we need them to be propagated/ to child futures.','line_number':405,'multiline':False]['text':' This is silly and we should find a way to avoid this.','line_number':406,'multiline':False]['text':' Scenario (2) retrieving an existing RRef','line_number':415,'multiline':False]['text':' Marks IValue Future as completed with the RRef IValue.','line_number':416,'multiline':False]['text':' We need to set devices here, even if they won't be used by the value (an','line_number':420,'multiline':False]['text':' RRef object doesn't contain any tensors, it just provides means to','line_number':421,'multiline':False]['text':' retrieve them) because we need them to be propagated/ to child futures.','line_number':422,'multiline':False]['text':' This is silly and we should find a way to avoid this.','line_number':423,'multiline':False]['text':' If we know that rref creation on the owner has timed out, raise it to the','line_number':433,'multiline':False]['text':' user here, otherwise continue with pickling.','line_number':434,'multiline':False]['text':' Note [Early Fork Registration]','line_number':442,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':443,'multiline':False]['text':' If the parent (caller) is the owner, directly register the fork, instead','line_number':444,'multiline':False]['text':' of waiting for another RREF_FORK_REQUEST or RREF_CHILD_ACCEPT message. An','line_number':445,'multiline':False]['text':' Alternative is adding the fork when the callee user ACKs. However, before','line_number':446,'multiline':False]['text':' that, the owner still have to adds the OwnerRRef into some map to keep it','line_number':447,'multiline':False]['text':' alive (e.g., in pendingChildren_). Hence, adding the fork here or in the','line_number':448,'multiline':False]['text':' ACK does not making any difference but only add complexity.','line_number':449,'multiline':False]['text':' TODO: When adding failure retries and timeout, this fork needs to be','line_number':450,'multiline':False]['text':' deleted if the owner does not receive the ACK within the timeout.','line_number':451,'multiline':False]['text':' ensure that this RRef is in the owners_ list to keep it alive.','line_number':453,'multiline':False]['text':' this is needed for OwnerRRefs that were created locally.','line_number':454,'multiline':False]['text':' Note [Useful Phantom Fork ID for User to Owner Call]','line_number':460,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':461,'multiline':False]['text':' If the callee of dist.remote or dist.rpc is the owner of this RRef, the','line_number':462,'multiline':False]['text':' callee will not create a fork using this rrefForkData.forkId_, because','line_number':463,'multiline':False]['text':' the owner will only keep one `OwnerRRef` instance and will not create any','line_number':464,'multiline':False]['text':' `UserRRef` instances. However, this rrefForkData.forkId_ is still','line_number':465,'multiline':False]['text':' necessary, as the caller user needs to keep this `UserRRef` alive until','line_number':466,'multiline':False]['text':' it gets the ACK from the callee owner. Otherwise, the delete message','line_number':467,'multiline':False]['text':' could arrive at the owner before this dist.rpc or dist.remote call, which','line_number':468,'multiline':False]['text':' could potentially trigger the `OwnerRRef` to be deleted before running','line_number':469,'multiline':False]['text':' the user code.','line_number':470,'multiline':False]['text':' Fork is shared from owner.','line_number':480,'multiline':False]['text':' Owner sending RRef to self, remove the forkId as it was added during','line_number':483,'multiline':False]['text':' pickling','line_number':484,'multiline':False]['text':' NB: not necessary to reset deletedRRef as rref is another shared_ptr','line_number':493,'multiline':False]['text':' instance pointing to the same OwnerRRef.','line_number':494,'multiline':False]['text':' If the parent is the owner, this fork has already been added into the','line_number':497,'multiline':False]['text':' forks_ map when the owner sends the message to the callee user.','line_number':498,'multiline':False]['text':' Hence, it is not necessary to send another RREF_CHILD_ACCEPT or','line_number':499,'multiline':False]['text':' RREF_FORK_REQUEST back to the owner. See Note [Early Fork','line_number':500,'multiline':False]['text':' Registration].','line_number':501,'multiline':False]['text':' Fork is shared from user.','line_number':508,'multiline':False]['text':' See Note [Useful Phantom Fork ID for User to Owner Call]','line_number':510,'multiline':False]['text':' In this case, the owner is the caller, and it does not add the fork id','line_number':511,'multiline':False]['text':' into forks_. Because, there will be no real `UserRRef` associated','line_number':512,'multiline':False]['text':' with this fork ID.','line_number':513,'multiline':False]['text':' Decrease after calling finishForkRequest because, as that creates a new','line_number':532,'multiline':False]['text':' future, it might otherwise cause the count to briefly go to zero.','line_number':533,'multiline':False]['text':' see Note [Early Fork Registration]','line_number':542,'multiline':False]['text':' If the parent is the owner, it should directly add the child UserRRef as a','line_number':543,'multiline':False]['text':' fork.','line_number':544,'multiline':False]['text':' We first check whether the child exists in pendingChildren_. It's','line_number':559,'multiline':False]['text':' possible the child may have been removed by a previous send attempt, and','line_number':560,'multiline':False]['text':' this check (as opposed to an assertion here) ensures that messages that','line_number':561,'multiline':False]['text':' trigger this function are idempotent.','line_number':562,'multiline':False]['text':' Since this UserRRef is removed from the map,','line_number':564,'multiline':False]['text':' the refcount of this UserRRef could reach to 0,','line_number':565,'multiline':False]['text':' so the "destructor", `release_resources()`, might be called,','line_number':566,'multiline':False]['text':' in which the lock is acquired again.','line_number':567,'multiline':False]['text':' So it must be destructed with the lock released.','line_number':568,'multiline':False]['text':' Meet this constraint by creating a temporary pointer to increase the','line_number':569,'multiline':False]['text':' refcount, extending its lifetime until lock released.','line_number':570,'multiline':False]['text':' Increase refcount.','line_number':571,'multiline':False]['text':' Decrease refcount.','line_number':572,'multiline':False]['text':' The refcount of this UserRRef could reach to 0,','line_number':579,'multiline':False]['text':' so the "destructor", release_resources(), might be called,','line_number':580,'multiline':False]['text':' in which the lock is acquired again,','line_number':581,'multiline':False]['text':' so must destruct it with the lock released.','line_number':582,'multiline':False]['text':' Decrease refcount.','line_number':583,'multiline':False]['text':' adding and waiting for pending users are guaranteed to be called from the','line_number':594,'multiline':False]['text':' same thread, but deleting pending users will be called from another','line_number':595,'multiline':False]['text':' thread. As the delPendingUser will not be able to access the same','line_number':596,'multiline':False]['text':' thread_local variable, we cannot address this problem by making','line_number':597,'multiline':False]['text':' pendingUsers_ thread_local. Instead, pendingUsers_ and userTable_ share','line_number':598,'multiline':False]['text':' the same PendingUserState shared_ptr.','line_number':599,'multiline':False]['text':' There are two reasons for keeping the deleted PendingUserState alive','line_number':623,'multiline':False]['text':' until exiting the critical section.','line_number':624,'multiline':False]['text':' (1) Since this UserRRef is removed from the map, the refcount of this','line_number':625,'multiline':False]['text':'     UserRRef could reach to 0. So the resource destructor','line_number':626,'multiline':False]['text':'     (`release_resources()`) might be called, in which the lock is','line_number':627,'multiline':False]['text':'     acquired again. Hence, it must be destructed with the lock released.','line_number':628,'multiline':False]['text':'     To meet this constraint, we intentionally create a temporary pointer','line_number':629,'multiline':False]['text':'     to increase the refcount of the deleted PendingUserState, extending','line_number':630,'multiline':False]['text':'     its lifetime until lock released.','line_number':631,'multiline':False]['text':' (2) Since #34497, a user function only runs after all RRefs in the','line_number':632,'multiline':False]['text':'     arguments are confirmed by their owners, which is done by adding the','line_number':633,'multiline':False]['text':'     RPC processing logic as a callback to the UserRRef ready future. So,','line_number':634,'multiline':False]['text':'     calling `confirm` on the PendingUserState could trigger pending user','line_number':635,'multiline':False]['text':'     functions, which might in turn acquire the lock in RRefContext.','line_number':636,'multiline':False]['text':'     Hence, we must release the lock to prevent deadlock.','line_number':637,'multiline':False]['text':' NB: Another option is to use reentrant lock. However, it is better for','line_number':638,'multiline':False]['text':' the developers to fully understand the locking behavior instead of','line_number':639,'multiline':False]['text':' hiding the subtle logic using a reentrant lock.','line_number':640,'multiline':False]['text':' Increase refcount','line_number':641,'multiline':False]['text':' Decrease refcount.','line_number':644,'multiline':False]['text':' Decrease refcount.','line_number':648,'multiline':False]['text':' Notice, caller need to hold the mutex for confirmedUsers_.','line_number':654,'multiline':False]['text':' std::lock_guard<std::mutex> lock(mutex_);','line_number':655,'multiline':False]['text':' We need to set devices here, even if they won't be used by the value (it's','line_number':680,'multiline':False]['text':' a bool, it doesn't contain tensors!) because we need them to be propagated','line_number':681,'multiline':False]['text':' to child futures. This is silly and we should find a way to avoid this.','line_number':682,'multiline':False]['text':' unused ','line_number':692,'multiline':True]['text':' We first check whether the child exists in rrefForks. It's possible','line_number':749,'multiline':False]['text':' the child may have been added by a previous send attempt, and this check','line_number':750,'multiline':False]['text':' (as opposed to an assertion here) ensures that messages that trigger this','line_number':751,'multiline':False]['text':' function are idempotent.','line_number':752,'multiline':False]['text':' There were previously multiple TORCH_CHECKs in this function that checked','line_number':766,'multiline':False]['text':' whether the passed in fork was known by the user and whether the fork had','line_number':767,'multiline':False]['text':' already been deleted. These assertions are now replaced with nested if','line_number':768,'multiline':False]['text':' statements to ensure this function is idempotent. This makes it safe to','line_number':769,'multiline':False]['text':' retry RRefUserDelete messages.','line_number':770,'multiline':False]['text':' namespace rpc','line_number':806,'multiline':False]['text':' namespace distributed','line_number':807,'multiline':False]['text':' namespace torch','line_number':808,'multiline':False]