['text':' Forward-declare the TensorPipe classes we need, to avoid including its','line_number':13,'multiline':False]['text':' headers in PyTorch's ones and thus have it become a public dependency.','line_number':14,'multiline':False]['text':' namespace transport','line_number':26,'multiline':False]['text':' namespace channel','line_number':30,'multiline':False]['text':' namespace tensorpipe','line_number':32,'multiline':False]['text':' These priorities instruct TensorPipe on which transport/channel to pick','line_number':38,'multiline':False]['text':' during handshake. Higher priorities will take precedence over lower ones.','line_number':39,'multiline':False]['text':' The transport with lowest priority will be the one used to bootstrap pipes.','line_number':40,'multiline':False]['text':' The UV transport just uses TCP and should work everywhere, thus keep it last.','line_number':44,'multiline':False]['text':' The basic channel reuses a transport as a channel, and is thus our fallback.','line_number':49,'multiline':False]['text':' CPU channel have higher priority than CUDA channels, since the latter might','line_number':52,'multiline':False]['text':' handle CPU-to-CPU transfers, but will always be less efficient than their','line_number':53,'multiline':False]['text':' CPU-only counterparts.','line_number':54,'multiline':False]['text':' c10::Device has no default constructor, hence map[device] dosn't work','line_number':125,'multiline':False]['text':' In C++-17 we can use insert_or_assign.','line_number':126,'multiline':False]['text':' Struct to track the network source metrics','line_number':144,'multiline':False]['text':' Struct to track aggregated network metrics','line_number':150,'multiline':False]['text':' TensorPipeAgent leverages TensorPipe (https://github.com/pytorch/tensorpipe)','line_number':158,'multiline':False]['text':' to transparently move tensors and payloads through the fastest available','line_number':159,'multiline':False]['text':' transport or channel. It acts like a hybrid RPC transport, providing shared','line_number':160,'multiline':False]['text':' memory (linux) and TCP (linux & mac) support. CUDA support is in progress.','line_number':161,'multiline':False]['text':' join() and sync() would be deprecated -','line_number':183,'multiline':False]['text':' https://github.com/pytorch/pytorch/issues/27647','line_number':184,'multiline':False]['text':' Returns metrics tracked by the NetworkDataDict','line_number':216,'multiline':False]['text':' Returns NetworkSourceInfo struct','line_number':218,'multiline':False]['text':' For testing purposes.','line_number':223,'multiline':False]['text':' TensorPipe write function that could be used to write response','line_number':231,'multiline':False]['text':' messages by server, and write request messages by client. This','line_number':232,'multiline':False]['text':' is a protected method since it is overwritten by FaultyTensorPipeAgent','line_number':233,'multiline':False]['text':' Removes the given messageId with the given expirationTime from the','line_number':242,'multiline':False]['text':' timeoutMap_.','line_number':243,'multiline':False]['text':' Populates workerIdToInfo_ and workerNameToInfo_ using addressStore_','line_number':246,'multiline':False]['text':' Check the static group attribute with the value set in store','line_number':249,'multiline':False]['text':' Only use for Dynamic RPC groups, method to have worker leave group','line_number':254,'multiline':False]['text':' TensorPipe read function that could be used to read response messages','line_number':257,'multiline':False]['text':' by client, and read request messages by server.','line_number':258,'multiline':False]['text':' Callback of listener accept()','line_number':266,'multiline':False]['text':' Respond to a call from a peer','line_number':271,'multiline':False]['text':' Collects metrics from successful RPC calls','line_number':280,'multiline':False]['text':' Collects metrics from failed RPC calls','line_number':286,'multiline':False]['text':' When a request+response completes, we need to mark the future message as','line_number':295,'multiline':False]['text':' complete. However, if its timeout has already expired, it already has an','line_number':296,'multiline':False]['text':' error set. There is no atomic "test-and-set" way to mark a future complete','line_number':297,'multiline':False]['text':' only if it isn't yet. It does exist for errors (setErrorIfNeeded) but, even','line_number':298,'multiline':False]['text':' then, it ends up printing a log message, which may worry the user. To solve','line_number':299,'multiline':False]['text':' both issues we use a separate atomic flag to know the status of the future.','line_number':300,'multiline':False]['text':' Maintains state per client pipe to track pending response messages and','line_number':311,'multiline':False]['text':' error states. pendingResponseMessage_ should be protected by a mutex since','line_number':312,'multiline':False]['text':' it can be raced with user send() call.','line_number':313,'multiline':False]['text':' TODO: To achieve better performance we can have a pipe pool per','line_number':314,'multiline':False]['text':' client that can be configured using RpcBackendOptions.','line_number':315,'multiline':False]['text':' Map from Message Request ID's to corresponding futures.','line_number':322,'multiline':False]['text':' For dynamic RPC, the reverse device maps are updated whenever a new rank','line_number':330,'multiline':False]['text':' joins or leaves the group','line_number':331,'multiline':False]['text':' Local devices used by this agent. If application didn't specify this','line_number':333,'multiline':False]['text':' field, it will be initialized using corresponding local devices in','line_number':334,'multiline':False]['text':' opts_.deviceMaps and reverseDeviceMaps_;','line_number':335,'multiline':False]['text':' Maps keyed on name and id for easy WorkerInfo lookup.','line_number':345,'multiline':False]['text':' Store keys that will used to count joined processes and active calls during','line_number':352,'multiline':False]['text':' the shutdown process','line_number':353,'multiline':False]['text':' Metadata used for tracking of whether certain RPCs have timed out or not.','line_number':358,'multiline':False]['text':' Map to store the expiration times for each message.','line_number':372,'multiline':False]['text':' Map to store the messageId to expiry time.','line_number':376,'multiline':False]['text':' Thread that will poll the timeoutMap_ for timed out messages and mark them','line_number':379,'multiline':False]['text':' with an error accordingly','line_number':380,'multiline':False]['text':' Function run by the timeoutThread_ to check for timed out RPCs','line_number':383,'multiline':False]['text':' Mutex to guard the timeoutMap_','line_number':386,'multiline':False]['text':' Condition Variable to signal population of the timeoutMap_','line_number':389,'multiline':False]['text':' Returns the expiration time for an RPC by adding the current time to the','line_number':392,'multiline':False]['text':' passed in timeout.','line_number':393,'multiline':False]['text':' Handle error on an outgoing pipe','line_number':400,'multiline':False]['text':' This is a generic struct for capturing Time-Series Metrics. It keeps a','line_number':405,'multiline':False]['text':' running sum and count of data points (observations), and can return an','line_number':406,'multiline':False]['text':' average of the data points seen so far. This is currently only used for','line_number':407,'multiline':False]['text':' tracking the GIL Wait Time in RPC Agents, but can be used for other metrics','line_number':408,'multiline':False]['text':' as well.','line_number':409,'multiline':False]['text':' Running sum of the data points seen so far','line_number':411,'multiline':False]['text':' Running count of the data points seen so far','line_number':413,'multiline':False]['text':' Adds a data point (which is basically one observation for the metric','line_number':420,'multiline':False]['text':' being tracked) to the running sum and count.','line_number':421,'multiline':False]['text':' Returns the average of all the data points seen so far.','line_number':423,'multiline':False]['text':' Map of Time-Series metrics tracked by the RPC Agent','line_number':427,'multiline':False]['text':' Mutex to guard timeSeriesMetrics_','line_number':429,'multiline':False]['text':' Custom lock guard used to check if the RPC group is dynamic and lock the','line_number':432,'multiline':False]['text':' mutex if so','line_number':433,'multiline':False]['text':' Mutex to guard access to group membership data','line_number':454,'multiline':False]['text':' e.g. updates to (workerIdToInfo_, workerNameToInfo_, workerNameToURL_)','line_number':455,'multiline':False]['text':' Map to Track Network Data','line_number':458,'multiline':False]['text':' Mutex to guard networkData_','line_number':460,'multiline':False]['text':' A mutex and a cv to guard access to the call counts and watch for changes.','line_number':463,'multiline':False]['text':' Running total of un-processed, un-errored RPC calls sent','line_number':466,'multiline':False]['text':' Running total of un-processed RPC requests received','line_number':468,'multiline':False]['text':' Running total of RPC requests that will be completed asynchronously','line_number':470,'multiline':False]['text':' Whether a global graceful shutdown has begun, in which case we'll silence','line_number':473,'multiline':False]['text':' error messages due to remote workers closing their pipes.','line_number':474,'multiline':False]['text':' Helpers to modify the counts while correctly dealing with the mutex and cv.','line_number':477,'multiline':False]['text':' Helpers to set the state of the requests.','line_number':481,'multiline':False]['text':' namespace rpc','line_number':491,'multiline':False]['text':' namespace distributed','line_number':492,'multiline':False]['text':' namespace torch','line_number':493,'multiline':False]['text':' USE_TENSORPIPE','line_number':495,'multiline':False]