['text':' This hook does 3 things:','line_number':32,'multiline':False]['text':'   1. Call pre hooks of the original AccumulateGrad to modify the input grad.','line_number':33,'multiline':False]['text':'   2. Accumurate the guard to RPC context.','line_number':34,'multiline':False]['text':'   3. Call post hooks of the original AccumulateGrad.','line_number':35,'multiline':False]['text':' It's intended that pre/post hooks are still called even if the grad is','line_number':48,'multiline':False]['text':' undefined here.','line_number':49,'multiline':False]['text':' It is possible that the grad is not defined since a separate','line_number':53,'multiline':False]['text':' invocation of the autograd engine on the same node might actually','line_number':54,'multiline':False]['text':' compute this gradient.','line_number':55,'multiline':False]['text':' There are 3 internal references to 'inputGrads[0]' at this moment:','line_number':57,'multiline':False]['text':'   1. 'inputGrads[0]' in this function.','line_number':58,'multiline':False]['text':'   2. 'graph_task->captured_vars_' on the callsite in the local engine.','line_number':59,'multiline':False]['text':'   3. 'InputBuffer& inputs' on the callsite as the inputs of the','line_number':60,'multiline':False]['text':'   function node.','line_number':61,'multiline':False]['text':' num_expected_refs ','line_number':63,'multiline':True]['text':' Need to shutdown this thread.','line_number':82,'multiline':False]['text':' GraphTask has expired, ignore and continue processing.','line_number':89,'multiline':False]['text':' Launch the execution on a JIT thread.','line_number':93,'multiline':False]['text':'node_task','line_number':104,'multiline':True]['text':'incrementOutstandingTasks','line_number':105,'multiline':True]['text':' Note [GPU to CPU continuations]','line_number':118,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':119,'multiline':False]['text':' Initialize a single CPU thread to execute continuations from GPU','line_number':120,'multiline':False]['text':' tasks. The multithreaded structure for the distributed engine works','line_number':121,'multiline':False]['text':' well only for CPU tasks. If we have an order of tasks like','line_number':122,'multiline':False]['text':' CPU->GPU->CPU, distributed autograd has no thread to execute the last','line_number':123,'multiline':False]['text':' CPU task on. To fix this, we introduce a global CPU thread to handle','line_number':124,'multiline':False]['text':' such situations and it will be responsible for executing these CPU','line_number':125,'multiline':False]['text':' tasks. The CPU thread has its own ready_queue which is used as the','line_number':126,'multiline':False]['text':' cpu_ready_queue for all GraphTasks for DistEngine. This ensures all GPU','line_number':127,'multiline':False]['text':' to CPU continuations are enqueued on this thread. The global CPU thread','line_number':128,'multiline':False]['text':' simply dequeues tasks from the global queue and calls','line_number':129,'multiline':False]['text':' "execute_graph_task_until_ready_queue_empty" on a JIT thread to execute the','line_number':130,'multiline':False]['text':' appropriate task.','line_number':131,'multiline':False]['text':' Ensure we shutdown the CPU thread.','line_number':136,'multiline':False]['text':' Leaky singleton to avoid module destructor race.','line_number':143,'multiline':False]['text':' Verify roots are all scalar and require gradients.','line_number':156,'multiline':False]['text':' Compute the root edges and generate the appropriate gradients.','line_number':168,'multiline':False]['text':' Validate rootEdges and grads.','line_number':173,'multiline':False]['text':' Store root nodes so we can traverse through the graph later','line_number':187,'multiline':False]['text':' e.g., for get_current_graph_task_execution_order','line_number':188,'multiline':False]['text':' Build the graph task and graph root.','line_number':194,'multiline':False]['text':' NOTE: we don't need to build and pass a cpu_ready_queue to GraphTask','line_number':195,'multiline':False]['text':' as we use execute_graph_task_until_ready_queue_empty, which will build','line_number':196,'multiline':False]['text':' a separate ReadyQueue for each call.','line_number':197,'multiline':False]['text':' keep_graph ','line_number':199,'multiline':True]['text':' create_graph ','line_number':200,'multiline':True]['text':' depth ','line_number':201,'multiline':True]['text':' cpu_ready_queue ','line_number':202,'multiline':True]['text':' graph_roots ','line_number':203,'multiline':True]['text':' exit_on_error ','line_number':204,'multiline':True]['text':' Run BFS to traverse the graph locally. The roots of the graph are','line_number':206,'multiline':False]['text':' GraphRoot and all send functions for this autograd context.','line_number':207,'multiline':False]['text':' Add all the send functions to the queue as roots.','line_number':214,'multiline':False]['text':' Increment 'outstanding_tasks_' for GraphTask for each send_function','line_number':216,'multiline':False]['text':' since we want the local autograd engine to wait for all of them.','line_number':217,'multiline':False]['text':' Traverse the graph.','line_number':226,'multiline':False]['text':' Seeing this function for the first time.','line_number':241,'multiline':False]['text':' We have found a leaf node which should be either AccumulateGrad','line_number':248,'multiline':False]['text':' or RecvRpcBackward. Record the function','line_number':249,'multiline':False]['text':' to ensure we don't execute it and instead accumulate the grads on','line_number':250,'multiline':False]['text':' the autograd context. These functions would be passed in as the','line_number':251,'multiline':False]['text':' 'outputs' parameter of the vanilla autograd engine.','line_number':252,'multiline':False]['text':' We don't accumulate any grads in the context for RecvRpcBackward.','line_number':254,'multiline':False]['text':' RecvRpcBackward is added as an output edge to indicate it is a','line_number':255,'multiline':False]['text':' leaf node and this helps in properly computing dependencies for','line_number':256,'multiline':False]['text':' the local autograd graph. Putting RecvRpcBackward in','line_number':257,'multiline':False]['text':' 'outputEdges' means that this function needs to be executed','line_number':258,'multiline':False]['text':' (inline with our assumption for FAST mode that all send/recv','line_number':259,'multiline':False]['text':' functions are valid in the backward pass), and as a result all of','line_number':260,'multiline':False]['text':'  its ancestors need to be executed as well.','line_number':261,'multiline':False]['text':' Collects current streams for devices where this process has a context,','line_number':273,'multiline':False]['text':' so graphTask::exec_post_processing can sync them with leaf_streams.','line_number':274,'multiline':False]['text':' Now lets compute which functions need to be executed. The algorithm is as','line_number':278,'multiline':False]['text':' follows:','line_number':279,'multiline':False]['text':' 1. Create a dummy GraphRoot which points to all 'send' functions for this','line_number':280,'multiline':False]['text':'    context and the original graphRoot. Run 'init_to_execute' with the','line_number':281,'multiline':False]['text':'    outputEdges and the dummy GraphRoot. This ensures we mark','line_number':282,'multiline':False]['text':'    appropriate functions as needed if they are reachable only from a','line_number':283,'multiline':False]['text':'    specific 'send' function locally and not necessarily from the provided','line_number':284,'multiline':False]['text':'    roots.','line_number':285,'multiline':False]['text':' 2. For all edges in 'outputEdges' which point to 'RecvRpcBackward', mark','line_number':286,'multiline':False]['text':'    those functions as needed for execution. The reason for this is that','line_number':287,'multiline':False]['text':'    'init_to_execute', will mark these as not needed. But 'RecvRpcBackward'','line_number':288,'multiline':False]['text':'    is unique in the sense that we use it as a leaf node in graph to compute','line_number':289,'multiline':False]['text':'    needed execution accurately, but unlike AccumulateGrad, we do need to','line_number':290,'multiline':False]['text':'    execute this function.','line_number':291,'multiline':False]['text':' Compute 'needed execution' starting from all 'send' functions and the','line_number':293,'multiline':False]['text':' original graphRoot.','line_number':294,'multiline':False]['text':' Create some dummy edges (input_nr not important for init_to_execute).','line_number':296,'multiline':False]['text':' Add the original graphRoot as an edge.','line_number':301,'multiline':False]['text':' Create a dummy GraphRoot and run init_to_execute with it.','line_number':304,'multiline':False]['text':'accumulate_grad=','line_number':307,'multiline':True]['text':'min_topo_nr=','line_number':307,'multiline':True]['text':' There may be nodes other than 'AccumulateGrad', e.g. RecvRPCBackward,','line_number':314,'multiline':False]['text':' to be captured.','line_number':315,'multiline':False]['text':' Capture hooks are technically deprecated, but as an exception below','line_number':318,'multiline':False]['text':' is the single and only instance of capture hooks usage that we','line_number':319,'multiline':False]['text':' support. See NOTE [Deprecated capture hooks] for more context.','line_number':320,'multiline':False]['text':' Mark all 'RecvRPCBackward' as needing execution.','line_number':330,'multiline':False]['text':' Set graph task owner in a single thread since concurrent access to','line_number':336,'multiline':False]['text':' 'owner_' field is not permitted.','line_number':337,'multiline':False]['text':' Let autograd context take ownership of the GraphTask.','line_number':340,'multiline':False]['text':' Create a ready queue per call to traverse the graph_task from','line_number':348,'multiline':False]['text':' root_to_execute This allow concurrent execution of the same GraphTask from','line_number':349,'multiline':False]['text':' different threads','line_number':350,'multiline':False]['text':' Scope this block of execution since NodeTask is not needed after this','line_number':365,'multiline':False]['text':' block and can be deallocated (release any references to grad tensors','line_number':366,'multiline':False]['text':' as part of inputs_)','line_number':367,'multiline':False]['text':' break the loop in error so that we immediately stop the execution','line_number':380,'multiline':False]['text':' of this GraphTask, mark it completed if necessary and return the','line_number':381,'multiline':False]['text':' future with proper ErrorMessage','line_number':382,'multiline':False]['text':' Decrement the outstanding task.','line_number':387,'multiline':False]['text':' Check if we've completed execution.','line_number':390,'multiline':False]['text':' We don't need to explicitly notify the owner thread, since','line_number':392,'multiline':False]['text':' 'mark_as_completed_and_run_post_processing' would mark the Future as','line_number':393,'multiline':False]['text':' completed and this would notify the owner thread that the task has been','line_number':394,'multiline':False]['text':' completed.','line_number':395,'multiline':False]['text':' Cleanup previous state for outstanding RPCs. Outstanding RPCs could be','line_number':406,'multiline':False]['text':' lingering if we're running backward multiple times and some of the','line_number':407,'multiline':False]['text':' passes ran into errors.','line_number':408,'multiline':False]['text':'node_task','line_number':413,'multiline':True]['text':'incrementOutstandingTasks','line_number':414,'multiline':True]['text':' Use a reference here to avoid refcount bump on futureGrads.','line_number':416,'multiline':False]['text':' Build a future that waits for the callbacks to execute (since callbacks','line_number':419,'multiline':False]['text':' execute after the original future is completed). This ensures we return a','line_number':420,'multiline':False]['text':' future that waits for all gradient accumulation to finish.','line_number':421,'multiline':False]['text':' Don't accumulate gradients if we receive an error.','line_number':428,'multiline':False]['text':' We must add the node information here since DistEngine::execute','line_number':429,'multiline':False]['text':' waits on accumulateGradFuture and will throw an exception once we','line_number':430,'multiline':False]['text':' set the error below.','line_number':431,'multiline':False]['text':' Typically the local autograd engine ensures stream synchronizations between','line_number':458,'multiline':False]['text':' nodes in the graph. However, for distributed autograd the sendFunction','line_number':459,'multiline':False]['text':' inputs might have been retrieved over the wire on a separate stream and the','line_number':460,'multiline':False]['text':' sendFunction itself runs on a different stream. As a result, we need to','line_number':461,'multiline':False]['text':' manually synchronize those two streams here.','line_number':462,'multiline':False]['text':' Pass in a dummy graphRoot since all send functions are the roots.','line_number':481,'multiline':False]['text':' Mark the autograd context id as initialized and unlock.','line_number':486,'multiline':False]['text':' Enqueue the current send function.','line_number':490,'multiline':False]['text':' Run the autograd engine.','line_number':492,'multiline':False]['text':'incrementOutstandingTasks=','line_number':497,'multiline':True]['text':' Build the 'uber' future that waits for everything.','line_number':499,'multiline':False]['text':' Perform cleanup at the end of the backward pass (before we mark','line_number':508,'multiline':False]['text':' the future as completed).','line_number':509,'multiline':False]['text':' Skip any further processing on errors.','line_number':512,'multiline':False]['text':' Wait for all RPCs after the autograd engine is done.','line_number':517,'multiline':False]['text':' Perform cleanup at the end of the backward pass (before','line_number':523,'multiline':False]['text':' we mark the future as completed).','line_number':524,'multiline':False]['text':' Finally mark the 'uber' future as completed.','line_number':531,'multiline':False]['text':' Return the future which waits for all async processing to be done.','line_number':543,'multiline':False]['text':'node_task','line_number':550,'multiline':True]['text':'incrementOutstandingTasks','line_number':551,'multiline':True]['text':' Retrieve the context for the given context_id. This will throw if the','line_number':563,'multiline':False]['text':' context_id is invalid.','line_number':564,'multiline':False]['text':' Perform initial pre-processing.','line_number':568,'multiline':False]['text':' Compute dependencies locally, starting from all roots and all 'send'','line_number':576,'multiline':False]['text':' functions.','line_number':577,'multiline':False]['text':' Context should not have been initialized already.','line_number':580,'multiline':False]['text':' Mark the autograd context id as initialized.','line_number':588,'multiline':False]['text':' This needs to be blocking and as a result we wait for the future to','line_number':594,'multiline':False]['text':' complete.','line_number':595,'multiline':False]['text':' Wait for all of the outstanding rpcs to complete.','line_number':599,'multiline':False]['text':' Validate only the GraphTask is holding a reference to the Future','line_number':604,'multiline':False]['text':' which holds gradients for the backward pass. This ensures that','line_number':605,'multiline':False]['text':' after 'resetGraphTask' is called below, there are no remaining','line_number':606,'multiline':False]['text':' references left to the gradients for the backward pass.','line_number':607,'multiline':False]['text':'','line_number':608,'multiline':False]['text':' This ensures our 'use_count' checks in','line_number':609,'multiline':False]['text':' AccumulateGrad::accumulateGrad are correct and we're','line_number':610,'multiline':False]['text':' not leaking any references to the gradients anywhere else.','line_number':611,'multiline':False]['text':' Reset the graph task once we're done with all processing.','line_number':616,'multiline':False]['text':' Clear any outstanding rpcs.','line_number':619,'multiline':False]['text':' Clear the context id once we're done with the autograd engine','line_number':622,'multiline':False]['text':' processing.','line_number':623,'multiline':False]['text':' namespace autograd','line_number':641,'multiline':False]['text':' namespace distributed','line_number':642,'multiline':False]['text':' namespace torch','line_number':643,'multiline':False]