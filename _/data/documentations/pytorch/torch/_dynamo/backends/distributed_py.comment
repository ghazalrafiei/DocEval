['text':' Regular log messages should go through 'log'.','line_number':11,'multiline':False]['text':' ddp_graph_log is a separate artifact logger reserved for dumping graphs.','line_number':12,'multiline':False]['text':' See docs/source/logging.rst for more info.','line_number':13,'multiline':False]['text':' a debug helper','line_number':19,'multiline':False]['text':' param_ids is just used for unit testing','line_number':36,'multiline':False]['text':' keep track of any buckets that were extended for logging purposes','line_number':39,'multiline':False]['text':' we want to iterate in reverse order, but clumsi-luckily the bucket.nodes list was already created backwards','line_number':46,'multiline':False]['text':' so we don't reverse it here','line_number':47,'multiline':False]['text':' assume node.op != output, since those are filtered in the original iteration','line_number':49,'multiline':False]['text':' Check if there is a higher order op in the graph','line_number':117,'multiline':False]['text':' this constant comes from C10D lib which is not always built','line_number':196,'multiline':False]['text':' This indicates presence of a higher order op. For now, we','line_number':219,'multiline':False]['text':' have no way to break the higher order op into two buckets.','line_number':220,'multiline':False]['text':' Allowing higher order ops in the graph also requires','line_number':221,'multiline':False]['text':' changes in the split_module, becuase graph splitter','line_number':222,'multiline':False]['text':' currently assumes that all the args of all ops are','line_number':223,'multiline':False]['text':' tensors, but in the case of higher order ops, it could be','line_number':224,'multiline':False]['text':' a graph module. As a workaround, we are shortcircuiting','line_number':225,'multiline':False]['text':' 1: compute the partition map according to DDP bucket logic','line_number':235,'multiline':False]['text':' (size, param_names)','line_number':236,'multiline':False]['text':' continue building this bucket past the point of filling its parameter capacity,','line_number':249,'multiline':False]['text':' to increase chances it contains at least one node that is either a global output or','line_number':250,'multiline':False]['text':' passed as input to a subsequent graph','line_number':251,'multiline':False]['text':' All nodes have to be mapped to a bucket, even if they don't have their own params','line_number':273,'multiline':False]['text':' Ignored params still end up in buckets, we just don't count them towards the capacity','line_number':274,'multiline':False]['text':' we collected a small preamble graph with ops that don't include parameters, fuse it back','line_number':278,'multiline':False]['text':' stash buckets for testing/debugging purposes','line_number':283,'multiline':False]['text':' bypass split/fuse logic if there is only one bucket','line_number':288,'multiline':False]['text':' 2: partition the graphmodule according to bucket capacity','line_number':291,'multiline':False]['text':' only print the submod graphs, not their children','line_number':307,'multiline':False]['text':' 3: Replace submodules with lazily compiling submodule','line_number':312,'multiline':False]['text':' First compile with args as example_inputs','line_number':335,'multiline':False]['text':' These args will be fakeified if using Inductor/AOTAutograd','line_number':336,'multiline':False]['text':' we must let 'input_mod' return a tuple, to make AOT happy.','line_number':344,'multiline':False]['text':' (aot_autograd compile_fn literally requires that the output of a graph it compiles is a tuple).','line_number':345,'multiline':False]['text':' however, we don't acutally want this tuple to be returned, since the fx logic that calls the submod','line_number':346,'multiline':False]['text':' will again wrap outputs from the submod in a tuple.  So we unwrap it, and count on it being re-wrapped','line_number':347,'multiline':False]['text':' it's close to useless to get a real stacktrace here, and quite verbose.','line_number':364,'multiline':False]['text':' We replace the submodules with lazy submodules which compile','line_number':375,'multiline':False]['text':' the corresponding submodules when they are run with real values','line_number':376,'multiline':False]['text':' Always returns `None` - we do not need to propagate values in order','line_number':377,'multiline':False]['text':' to replace submodules.','line_number':378,'multiline':False]['text':' We update the original (outer) graph with a call into the compiled module','line_number':390,'multiline':False]['text':' instead of the uncompiled one.','line_number':391,'multiline':False]