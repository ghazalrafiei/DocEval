['text':' type: ignore[assignment]','line_number':28,'multiline':False]['text':' noqa: F401','line_number':58,'multiline':False]['text':' For user stack printing','line_number':85,'multiline':False]['text':' If not numpy array, piggy back on e.g. tensor guards to check type','line_number':123,'multiline':False]['text':' [Note: Python Version <= 3.8]','line_number':129,'multiline':False]['text':' This branch should be dropped when we drop support for Python 3.8.','line_number':130,'multiline':False]['text':' Reason: 'ast.unparse' function was introduced in Python 3.9.','line_number':131,'multiline':False]['text':' type: ignore[import]','line_number':134,'multiline':False]['text':' recursively find valid object name in function','line_number':158,'multiline':False]['text':' The ready to eval generated code (possibly multiple parts) for a guard, plus','line_number':181,'multiline':False]['text':' the original guard object that created it for provenance','line_number':182,'multiline':False]['text':' Write the package module into the scope so that we can import it','line_number':209,'multiline':False]['text':' Write the demangled name to the scope so that we can use it','line_number':211,'multiline':False]['text':' Code is python expression strings generated for each guard','line_number':215,'multiline':False]['text':' shape_env_code is only used by builder and is used for','line_number':217,'multiline':False]['text':' shape env code.  This exists only because we need to make sure','line_number':218,'multiline':False]['text':' shape env guards get run after tensor match guards (since the','line_number':219,'multiline':False]['text':' tensor match guards make sure we actually have tensors)','line_number':220,'multiline':False]['text':' [Note - On Eager Tensor Guards]','line_number':223,'multiline':False]['text':' Most of the time, we generate Python code in a guard to directly','line_number':224,'multiline':False]['text':' check various properties.  However, tensors are a bit special;','line_number':225,'multiline':False]['text':' it is too slow to check their properties one-by-one in Python.','line_number':226,'multiline':False]['text':' Instead, there is a C++ function TensorGuards.check which takes','line_number':227,'multiline':False]['text':' all of the tensor arguments and checks them all against compile-time','line_number':228,'multiline':False]['text':' examples entirely in C++.  Thus, every time we process a','line_number':229,'multiline':False]['text':' TENSOR_MATCH guard, we just add another entry to','line_number':230,'multiline':False]['text':' tensor_check_names/tensor_check_examples, saying "for this local,','line_number':231,'multiline':False]['text':' check it against this example", and it all ends up getting','line_number':232,'multiline':False]['text':' swept up into a single call to ___check_tensors.  Invariant:','line_number':233,'multiline':False]['text':' len(tensor_check_names) == len(tensor_check_examples).','line_number':234,'multiline':False]['text':' TODO: something here','line_number':235,'multiline':False]['text':' Keep track of weak references of objects with ID_MATCH guard. This','line_number':241,'multiline':False]['text':' info is stored alongside optimized_code and check_fn and is used to','line_number':242,'multiline':False]['text':' limit the number of cache entries with same ID_MATCH'd object.','line_number':243,'multiline':False]['text':' Warning: use this with care!  This lets you access what the current','line_number':246,'multiline':False]['text':' value of the value you are guarding on is.  You probably don't want','line_number':247,'multiline':False]['text':' to actually durably save this value though (because it's specific','line_number':248,'multiline':False]['text':' to this frame!)  Instead, you should be reading out some property','line_number':249,'multiline':False]['text':' (like its type) which is what you permanently install into the','line_number':250,'multiline':False]['text':' guard code.','line_number':251,'multiline':False]['text':' Registers the usage of the source name referenced by the','line_number':255,'multiline':False]['text':' string (or stored in the Guard) as being guarded upon.  It's important','line_number':256,'multiline':False]['text':' to call this before generating some code that makes use of 'guard',','line_number':257,'multiline':False]['text':' because without this call, we won't actually bind the variable','line_number':258,'multiline':False]['text':' you reference in the actual guard closure (oops!)','line_number':259,'multiline':False]['text':' ___check_type_id is same as `id(type(x)) == y`','line_number':276,'multiline':False]['text':' ___check_dict_version is same as `dict_version(x) == y`','line_number':283,'multiline':False]['text':' Guard on the runtime value being 'False',','line_number':297,'multiline':False]['text':' can be faster than seemingly equivalent checks like DICT_KEYS for empty dict','line_number':298,'multiline':False]['text':'','line_number':299,'multiline':False]['text':' WARNING: this guard is not safe to use generally.  It only works if the runtime','line_number':300,'multiline':False]['text':' value is of a type that supports bool(), and some types e.g. Tensor do not.','line_number':301,'multiline':False]['text':' Only use this guard in cases you can guarantee the runtime type will be friendly.','line_number':302,'multiline':False]['text':' (e.g. Specialized NNModule with mutation protection via setattr)','line_number':303,'multiline':False]['text':'','line_number':304,'multiline':False]['text':' Why not simply check the runtime type inside this guard?  It's slow enough to defeat','line_number':305,'multiline':False]['text':' the purpose of using this guard, which itself is supposed to be a faster alternative','line_number':306,'multiline':False]['text':' to DICT_KEYS.','line_number':307,'multiline':False]['text':' ___check_obj_id is same as `id(x) == y`','line_number':313,'multiline':False]['text':' optional optimization to produce cleaner/faster guard code','line_number':315,'multiline':False]['text':' type: ignore[arg-type]','line_number':317,'multiline':False]['text':' Keep track of ID_MATCH'd objects. This will be used to modify the','line_number':325,'multiline':False]['text':' cache size logic','line_number':326,'multiline':False]['text':' TODO(janimesh) - This is currently restricted to nn.Module objects','line_number':328,'multiline':False]['text':' because many other ID_MATCH'd objects fail - like DeviceMesh.','line_number':329,'multiline':False]['text':' Increase the scope of ID_MATCH'd objects.','line_number':330,'multiline':False]['text':' Special case for nan because float("nan") == float("nan") evaluates to False','line_number':409,'multiline':False]['text':' If matching equality against list/tuple, we must also check that','line_number':419,'multiline':False]['text':' the internal types match.  (TODO: what about nested lists?)','line_number':420,'multiline':False]['text':' NB: LIST_LENGTH takes care of the outer __check_type_id test','line_number':422,'multiline':False]['text':' Add type check to prevent equality check between tensor and non-tensor.','line_number':430,'multiline':False]['text':' TODO: It feels like it would be better to just implement our own','line_number':436,'multiline':False]['text':' equality test in C that handles all of the necessary type checking','line_number':437,'multiline':False]['text':' and NaN tests','line_number':438,'multiline':False]['text':' TODO: Why doesn't this use produce_guard_code?','line_number':456,'multiline':False]['text':' There are cases where a monkeypatched object has a guard made between __new__ and __init__','line_number':462,'multiline':False]['text':' Strictly only want user-defined functions','line_number':476,'multiline':False]['text':' TODO(voz): Deduplicate w/ AOTAutograd dupe input guards','line_number':514,'multiline':False]['text':' we always guard on this via GlobalStateGuard()','line_number':573,'multiline':False]['text':' we always guard on this via GlobalStateGuard()','line_number':576,'multiline':False]['text':' we always guard on this via GlobalStateGuard()','line_number':579,'multiline':False]['text':' Let's handle ShapeEnv guards.  To do this, we will resolve','line_number':602,'multiline':False]['text':' shape variables to sources from tracked_fakes.  This must happen after','line_number':603,'multiline':False]['text':' tensor checks.','line_number':604,'multiline':False]['text':' NB: self.output_graph can be None in the debug_nops tests','line_number':607,'multiline':False]['text':' Looks up base sources mapped to a tensor id and uses them to create','line_number':612,'multiline':False]['text':' sources for the corresponding tensor dimension.','line_number':613,'multiline':False]['text':' When t.size()[dim] maps to src0, src1, ..., srcN, we add','line_number':626,'multiline':False]['text':' constraints that make src0 "equal" to src1, ..., srcN.','line_number':627,'multiline':False]['text':' Moreover, when t.size()[dim] is specified equal to t'.size()[dim']','line_number':632,'multiline':False]['text':' and t'.size()[dim'] maps to src1', ..., srcN', we add','line_number':633,'multiline':False]['text':' constraints that also make src0 "equal" to src1', ..., srcN'.','line_number':634,'multiline':False]['text':' Export keeps static.','line_number':655,'multiline':False]['text':' [Note - On Export Tensor Guards]','line_number':673,'multiline':False]['text':'','line_number':674,'multiline':False]['text':' In eager mode, tensor guards are evaluated through C++, in guards.cpp','line_number':675,'multiline':False]['text':' see [Note - On Eager Tensor Guards] for more info.','line_number':676,'multiline':False]['text':'','line_number':677,'multiline':False]['text':' In export mode, we instead maintain parallel logic between C++ and python','line_number':678,'multiline':False]['text':' here, with an exception of checking the dispatch key - with the idea that a dispatch key','line_number':679,'multiline':False]['text':' is an entirely runtime notion that would make no sense to keep in an exported graph.','line_number':680,'multiline':False]['text':'','line_number':681,'multiline':False]['text':' Now, this idea is okay, but to paraphrase @ezyang, this mental model is sufficient for now, although','line_number':682,'multiline':False]['text':' not entirely true.','line_number':683,'multiline':False]['text':' For example, suppose one of the input tensors had the negative dispatch key.','line_number':684,'multiline':False]['text':' You should end up with a graph that is specialized for tensors that have a negative dispatch key.','line_number':685,'multiline':False]['text':' If you allow a Tensor that does NOT have this bit set, you will accidentally run it "as if" it were negated.','line_number':686,'multiline':False]['text':' Now, negative key only shows up for complex numbers, and most likely, the exported to target doesn't','line_number':687,'multiline':False]['text':' support this feature at all, but the point stands that :some: tensor state only shows up on dispatch key.','line_number':688,'multiline':False]['text':' TODO(voz): Either populate a dispatch_key check into the guards, or error on users passing in an unsupported','line_number':689,'multiline':False]['text':' subset of keys during export.','line_number':690,'multiline':False]['text':'','line_number':691,'multiline':False]['text':' The list of tensor fields and calls we care about can be found in `terms` below.','line_number':692,'multiline':False]['text':' TODO(voz): We are missing storage offset in all our tensor guards?','line_number':693,'multiline':False]['text':' copy pasted from EQUALS_MATCH','line_number':707,'multiline':False]['text':' A frame is valid for reuse with dynamic dimensions if the new dynamic dimensions are a','line_number':716,'multiline':False]['text':' strict subset of the old.','line_number':717,'multiline':False]['text':'','line_number':718,'multiline':False]['text':' The logic here is as follows:','line_number':719,'multiline':False]['text':'','line_number':720,'multiline':False]['text':' Every mark_dynamic directive is a user-knows-best command, which can incur a raise at tracing','line_number':721,'multiline':False]['text':' time if we find guards that run counter to the user directive.','line_number':722,'multiline':False]['text':' If compiling a frame with explicit dynamic dims X could cause an exception, we MUST NOT skip compiling.','line_number':723,'multiline':False]['text':'','line_number':724,'multiline':False]['text':' If the frame is compiled with any marked dynamic indices, let's call that set of indices X.','line_number':725,'multiline':False]['text':' When we evaluated inputs against the guards, given the same tensor with potentially new dynamic indices,','line_number':726,'multiline':False]['text':' let's call that set Y.','line_number':727,'multiline':False]['text':'','line_number':728,'multiline':False]['text':' When X is a strict subset of Y, the potential new raises introduced during compilation are a strict subset','line_number':729,'multiline':False]['text':' of the raises we','line_number':730,'multiline':False]['text':' could have encountered. The frame compiled under Y is safe to reuse with X.','line_number':731,'multiline':False]['text':' When X is not a strict subset of Y, the non-overlapping new elements of X may cause new raises, and the','line_number':732,'multiline':False]['text':' frame is no longer fit for reuse.','line_number':733,'multiline':False]['text':'','line_number':734,'multiline':False]['text':' This is the case because any newly introduced mark_dynamic directives have a chance of','line_number':735,'multiline':False]['text':' raising, failing compilation. Any existing mark_dynamic indices that we lost are safe to lose','line_number':736,'multiline':False]['text':' as all it means is that we have gotten rid of a user directive which could incur a raise at compile time.','line_number':737,'multiline':False]['text':' In the case of when there is no Y, that is, there are no dynamic indices marked at all, the frame is safe','line_number':738,'multiline':False]['text':' to reuse','line_number':739,'multiline':False]['text':' as an empty set is a safe degeneration - that is, a strictly static tensor is always valid for a frame','line_number':740,'multiline':False]['text':' compiled with that same','line_number':741,'multiline':False]['text':' tensor + more onerous user directives.','line_number':742,'multiline':False]['text':' noqa: B950','line_number':750,'multiline':False]['text':' In the case of us not having any dynamic dimension indices, we compiled the frame with no chance of','line_number':752,'multiline':False]['text':' raising for this specific tensor - and any inputs with more dynamic user directives specified must be recompiled.','line_number':753,'multiline':False]['text':' A util that appends guarded code, or, in the case of export, adds data onto guards','line_number':761,'multiline':False]['text':' WARNING: It is important that cur_frame/caller do NOT stay in','line_number':765,'multiline':False]['text':' the current frame, because they will keep things live longer','line_number':766,'multiline':False]['text':' than they should.  See TestMisc.test_release_module_memory','line_number':767,'multiline':False]['text':' We use func_name for export, so might as well get a nice defensive check out of it','line_number':775,'multiline':False]['text':' Not all guards have names, some can be installed globally (see asserts on HAS_GRAD)','line_number':785,'multiline':False]['text':' Not necessary to have weakref for Enum type, but there is a bug that','line_number':797,'multiline':False]['text':' makes hasattr(guarded_object.__class__, "__weakref__") return True.','line_number':798,'multiline':False]['text':' Common Sub-Expression Elimination for Python expressions.','line_number':812,'multiline':False]['text':'','line_number':813,'multiline':False]['text':' There are 2 steps to this pass:','line_number':814,'multiline':False]['text':'     1. Count the frequency of each sub-expression (i.e. inner','line_number':815,'multiline':False]['text':'        node in the AST tree)','line_number':816,'multiline':False]['text':'','line_number':817,'multiline':False]['text':'     2. Replace those that occur more than once by a fresh variable 'v'.','line_number':818,'multiline':False]['text':'        'v' will be defined in the 'preface' list (output argument to','line_number':819,'multiline':False]['text':'        'NodeTransformer')','line_number':820,'multiline':False]['text':'','line_number':821,'multiline':False]['text':' NB: the use of 'ast.unparse' while visiting the nodes makes this pass','line_number':822,'multiline':False]['text':' quadratic on the depth of the tree.','line_number':823,'multiline':False]['text':'','line_number':824,'multiline':False]['text':' NB: this pass creates a new variable for each AST node that is repeated','line_number':825,'multiline':False]['text':' more than 'USE_THRESHOLD'. e.g. if 'a.b.c.d' is used 10 times, 'a.b.c'','line_number':826,'multiline':False]['text':' and 'a.b' are also used 10 times. So, there will be a new variable for','line_number':827,'multiline':False]['text':' each of them.','line_number':828,'multiline':False]['text':' Maximum number of times a given expression can be used without being','line_number':830,'multiline':False]['text':' replaced by a fresh variable.','line_number':831,'multiline':False]['text':' Ad-Hoc: AST nodes this pass focuses on.','line_number':834,'multiline':False]['text':' Replacement only occurs if a given expression is used more','line_number':866,'multiline':False]['text':' than once.','line_number':867,'multiline':False]['text':' Parent 'visit' is called so that we CSE the inner expressions first.','line_number':870,'multiline':False]['text':'','line_number':871,'multiline':False]['text':' The resulting expression is used as right-hand-side of the variable','line_number':872,'multiline':False]['text':' assignment. i.e. we are CSE-ing the children before the parents.','line_number':873,'multiline':False]['text':'','line_number':874,'multiline':False]['text':' Indexing still uses the old 'node', since that's what was counted','line_number':875,'multiline':False]['text':' by the 'NodeVisitor'.','line_number':876,'multiline':False]['text':' For config.guard_nn_modules=False, we can skip all the guards that','line_number':911,'multiline':False]['text':' originate from inside of nn module except for a few categories.','line_number':912,'multiline':False]['text':' Guard for defaults','line_number':914,'multiline':False]['text':' Guard using dict tags if the config flag is set','line_number':916,'multiline':False]['text':' NB: Naively, you'd expect this to only be a function that produces','line_number':924,'multiline':False]['text':' the callable that constitutes the guard.  However, there is some','line_number':925,'multiline':False]['text':' delicate handling for invalidating this check function when the','line_number':926,'multiline':False]['text':' locals/globals get invalidated, so there's some extra state','line_number':927,'multiline':False]['text':' we have to hold in this manager class.','line_number':928,'multiline':False]['text':'','line_number':929,'multiline':False]['text':' TODO: this object has reference cycle with itself, via check_fn which','line_number':930,'multiline':False]['text':' references back to CheckFunction via ___guarded_code in closure_vars.','line_number':931,'multiline':False]['text':' Ideally, there shouldn't be any ref cycle so that guards are','line_number':932,'multiline':False]['text':' promptly disposed of.','line_number':933,'multiline':False]['text':' Note: right overrides left','line_number':945,'multiline':False]['text':' No need to track constants','line_number':960,'multiline':False]['text':' Break retain cycle. See test_release_input_memory','line_number':975,'multiline':False]['text':' Default func args must be guarded on.','line_number':982,'multiline':False]['text':' TODO: we could make use of 'DefaultsSource' and offer a .guard.is_defaults() API','line_number':983,'multiline':False]['text':' Keep track of weak references of objects with ID_MATCH guard. This','line_number':993,'multiline':False]['text':' info is stored alongside optimized_code and check_fn and is used to','line_number':994,'multiline':False]['text':' limit the number of cache entries with same ID_MATCH'd object.','line_number':995,'multiline':False]['text':' TODO(janimesh) - Currently this information is stored as an attr on','line_number':996,'multiline':False]['text':' the check_fn itself to avoid changing CacehEntry datastructure in','line_number':997,'multiline':False]['text':' eval_frame.c. In future, we should probably replace check_fn with a','line_number':998,'multiline':False]['text':' queryable data structure such that this information is already present','line_number':999,'multiline':False]['text':' in some form.','line_number':1000,'multiline':False]['text':' see parallel handling of ".0" / "___implicit0" in _eval_frame.c','line_number':1004,'multiline':False]['text':' Don't report this guard, it's always the same, useless!','line_number':1010,'multiline':False]['text':' Do this manually, to un-stagger the guards in log message','line_number':1093,'multiline':False]['text':' This is a copy of what guards.cpp checks against','line_number':1099,'multiline':False]['text':' Keep this in sync with TensorCheck constructor','line_number':1100,'multiline':False]['text':' TODO: the "guard" here is actually just the top level SHAPE_ENV','line_number':1132,'multiline':False]['text':' which is useless.  Get ShapeEnv to pass in more provenance.','line_number':1133,'multiline':False]['text':' we should only hit this case in NopTests()','line_number':1140,'multiline':False]['text':' TODO(whc) maybe '.code_parts' was only kept around for the guard callback? so we don't need both','line_number':1163,'multiline':False]['text':' Grab only G, but preserve "G" because guards access it as "G"','line_number':1167,'multiline':False]['text':' A weakref is no longer valid, self.check_fn should return false','line_number':1175,'multiline':False]['text':' TODO(janimesh) - Free up cache entry after the cache entry formation','line_number':1176,'multiline':False]['text':' is in python, and the underlying data structure is a doubly linked','line_number':1177,'multiline':False]['text':' list.','line_number':1178,'multiline':False]['text':' We will clear the _weakrefs dict at the end of __init__','line_number':1185,'multiline':False]['text':' function, which will delete the callbacks as well. Therefore,','line_number':1186,'multiline':False]['text':' we are using a finalizer which is kept alive.','line_number':1187,'multiline':False]['text':' cannot weakref bool object','line_number':1191,'multiline':False]['text':' Generate the inner body of the guard function.','line_number':1216,'multiline':False]['text':' i.e. if-chain of the guard expressions.','line_number':1217,'multiline':False]['text':' Wrap the inner body into the actual guard function.','line_number':1226,'multiline':False]['text':' Wrap the whole guard function into another function','line_number':1233,'multiline':False]['text':' with the closure variables.','line_number':1234,'multiline':False]['text':' Only ___check_tensors knows how to return a fancy fail reason;','line_number':1277,'multiline':False]['text':' for everything else we just report the code that failed','line_number':1278,'multiline':False]['text':' at least one of "recompiles" or "recompiles_verbose" is enabled','line_number':1322,'multiline':False]['text':' TODO: If we passed in the exception here, we could get a precise','line_number':1361,'multiline':False]['text':' column number of which subexpression failed.  But that would also','line_number':1362,'multiline':False]['text':' require us to have the TRUE code that was eval'ed, not a shoddy','line_number':1363,'multiline':False]['text':' reconstruction (like is done here)','line_number':1364,'multiline':False]['text':' Note - we may end up in a situation where we invoke something like','line_number':1381,'multiline':False]['text':' def fn(x, y)','line_number':1382,'multiline':False]['text':' with fn(x, x)','line_number':1383,'multiline':False]['text':' Prior to the addition of tracking to all relevant objects, we would handle this just fine by','line_number':1384,'multiline':False]['text':' eagerly re-entering VB and rewrapping inputs, correctly creating graphargs and placeholders. However,','line_number':1385,'multiline':False]['text':' with tracking on inputs, duplicate inputs or aliased relationships may end up getting erased here -','line_number':1386,'multiline':False]['text':' In the fn(x, x) example call above look like a graph with a single input.','line_number':1387,'multiline':False]['text':' In order to ensure that we do not reuse fn(x, x) for fn(x, y), we create a duplicate input guard.','line_number':1388,'multiline':False]['text':' Note - we may not have a source, that is fine, it just means we had an object that is safe to have','line_number':1390,'multiline':False]['text':' leave unsourced - like a local list created and discharged entirely within a local scope.','line_number':1391,'multiline':False]['text':' Note - both must be local, or global, or we will run afoul of a lack of merging in how we currently','line_number':1395,'multiline':False]['text':' reconcile guards builder scopes in compile_check_fn. This technically means we miss a guard here,','line_number':1396,'multiline':False]['text':' so maybe we should do this refactor before we land this...','line_number':1397,'multiline':False]['text':' TODO(voz): Combine local and global guard builders.','line_number':1398,'multiline':False]['text':' Note - this is a little aggressive - these being duplicate input does not always matter.','line_number':1400,'multiline':False]['text':' However, this should always be a sound guard to add here.','line_number':1401,'multiline':False]