['text':' This util function splits tensors into groups by device and dtype, which is useful before sending','line_number':19,'multiline':False]['text':' tensors off to a foreach implementation, which requires tensors to be on one device and dtype.','line_number':20,'multiline':False]['text':' If tensorlistlist contains more than one tensorlist, the following assumptions are made BUT NOT verified:','line_number':21,'multiline':False]['text':'   - tensorlists CAN be None','line_number':22,'multiline':False]['text':'   - all tensors in the first specified list cannot be None','line_number':23,'multiline':False]['text':'   - given an index i, all specified tensorlist[i]s match in dtype and device','line_number':24,'multiline':False]['text':' with_indices (bool, optional): whether to track previous indices as the last list per dictionary entry.','line_number':25,'multiline':False]['text':'   It comes in handy if there are Nones or literals in the tensorlists that are getting scattered out.','line_number':26,'multiline':False]['text':'   Whereas mutating a tensor in the resulting split-up tensorlists WILL propagate changes back to the','line_number':27,'multiline':False]['text':'   original input tensorlists, changing up Nones/literals WILL NOT propagate, and manual propagation','line_number':28,'multiline':False]['text':'   may be necessary. Check out torch/optim/sgd.py for an example.','line_number':29,'multiline':False]