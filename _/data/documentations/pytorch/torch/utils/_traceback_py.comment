['text':' This file contains utilities for ensuring dynamically compile()'d','line_number':9,'multiline':False]['text':' code fragments display their line numbers in backtraces.','line_number':10,'multiline':False]['text':'','line_number':11,'multiline':False]['text':' The constraints:','line_number':12,'multiline':False]['text':'','line_number':13,'multiline':False]['text':' - We don't have control over the user exception printer (in particular,','line_number':14,'multiline':False]['text':'   we cannot assume the linecache trick will work, c.f.','line_number':15,'multiline':False]['text':'   https://stackoverflow.com/q/50515651/23845 )','line_number':16,'multiline':False]['text':'','line_number':17,'multiline':False]['text':' - We don't want to create temporary files every time we compile()','line_number':18,'multiline':False]['text':'   some code; file creation should happen lazily only at exception','line_number':19,'multiline':False]['text':'   time.  Arguably, you *should* be willing to write out your','line_number':20,'multiline':False]['text':'   generated Python code to file system, but in some situations','line_number':21,'multiline':False]['text':'   (esp. library code) it would violate user expectation to write','line_number':22,'multiline':False]['text':'   to the file system, so we try to avoid it.  In particular, we'd','line_number':23,'multiline':False]['text':'   like to keep the files around, so users can open up the files','line_number':24,'multiline':False]['text':'   mentioned in the trace; if the file is invisible, we want to','line_number':25,'multiline':False]['text':'   avoid clogging up the filesystem.','line_number':26,'multiline':False]['text':'','line_number':27,'multiline':False]['text':'   If this is not a constraint for you, there is a substantially simpler','line_number':28,'multiline':False]['text':'   way to implement the functionality in this PR: instead of using','line_number':29,'multiline':False]['text':'   eval/exec directly, just always write a Python file to filesystem','line_number':30,'multiline':False]['text':'   and compile that.','line_number':31,'multiline':False]['text':'','line_number':32,'multiline':False]['text':' - You have control over a context where the compiled code will get','line_number':33,'multiline':False]['text':'   executed, so that we can interpose while the stack is unwinding','line_number':34,'multiline':False]['text':'   (otherwise, we have no way to interpose on the exception printing','line_number':35,'multiline':False]['text':'   process.)','line_number':36,'multiline':False]['text':'','line_number':37,'multiline':False]['text':' There are two things you have to do to make use of the utilities here:','line_number':38,'multiline':False]['text':'','line_number':39,'multiline':False]['text':' - When you compile your source code, you must save its string source','line_number':40,'multiline':False]['text':'   in its f_globals under the magic name "__compile_source__"','line_number':41,'multiline':False]['text':'','line_number':42,'multiline':False]['text':' - Before running the compiled code, enter the','line_number':43,'multiline':False]['text':'   report_compile_source_on_error() context manager.','line_number':44,'multiline':False]['text':' Walk the traceback, looking for frames that have','line_number':53,'multiline':False]['text':' source attached','line_number':54,'multiline':False]['text':' What black magic are we doing here?  Intuitively, what','line_number':61,'multiline':False]['text':' we would like to do is overwrite the co_filename on any','line_number':62,'multiline':False]['text':' frames that were generated from exec/eval so that they','line_number':63,'multiline':False]['text':' point to a temporary file that has the actual line','line_number':64,'multiline':False]['text':' information, so Python's default error printer can print','line_number':65,'multiline':False]['text':' useful line information on it.','line_number':66,'multiline':False]['text':'','line_number':67,'multiline':False]['text':' Writing out the temporary file is easy.  But overwriting','line_number':68,'multiline':False]['text':' co_filename is not!  You can't modify the code object','line_number':69,'multiline':False]['text':' associated with a frame.  You can, however, reconstruct','line_number':70,'multiline':False]['text':' a traceback with entirely new frames from scratch, so that's','line_number':71,'multiline':False]['text':' what we do.  But there's another problem, which is how to','line_number':72,'multiline':False]['text':' make the frame?','line_number':73,'multiline':False]['text':'','line_number':74,'multiline':False]['text':' The black magic is we make a frankenstein frame and code','line_number':75,'multiline':False]['text':' object which resembles the original frame/code enough so','line_number':76,'multiline':False]['text':' that it will print properly under traceback and the default','line_number':77,'multiline':False]['text':' error printer, but IT IS NOT THE ORIGINAL FRAME (you','line_number':78,'multiline':False]['text':' couldn't, e.g., execute its code with different variables','line_number':79,'multiline':False]['text':' and expect it to work.)','line_number':80,'multiline':False]['text':' Don't delete the temporary file so the user can inspect it','line_number':82,'multiline':False]['text':' TODO: This creates a temporary file for every frame, but we','line_number':83,'multiline':False]['text':' technically only need one per distinct __compile_source__','line_number':84,'multiline':False]['text':' Create a frame.  Python doesn't let you construct','line_number':87,'multiline':False]['text':' FrameType directly, so just make one with compile','line_number':88,'multiline':False]['text':' Python 3.11 only','line_number':92,'multiline':False]['text':' We can't copy ALL of the metadata over, because you','line_number':94,'multiline':False]['text':' can cause Python to segfault this way.  What exactly','line_number':95,'multiline':False]['text':' do we need?  We need enough information for','line_number':96,'multiline':False]['text':' traceback to be able to print the exception','line_number':97,'multiline':False]['text':' correctly.  Code reading Lib/traceback.py reveals','line_number':98,'multiline':False]['text':' that traceback calls code.co_positions() in order to','line_number':99,'multiline':False]['text':' get the augmented line/col numbers.  Objects/codeobject.c,','line_number':100,'multiline':False]['text':' specifically _PyCode_InitAddressRange, reveals that','line_number':101,'multiline':False]['text':' this iterator is initialized from co_linetable and','line_number':102,'multiline':False]['text':' co_firstfileno.  So copy these we must!','line_number':103,'multiline':False]['text':' type: ignore[call-arg]','line_number':104,'multiline':False]['text':' type: ignore[attr-defined]','line_number':105,'multiline':False]['text':' type: ignore[attr-defined]','line_number':106,'multiline':False]['text':' Reconstruct the linked list','line_number':125,'multiline':False]['text':' noqa: TRY200','line_number':131,'multiline':False]['text':' Truncate torch/foo.py to foo.py','line_number':137,'multiline':False]['text':' TODO: Maybe indicate that the traceback was elided?','line_number':174,'multiline':False]['text':' TB is not pickleable','line_number':184,'multiline':False]['text':' Elide extract() frame if we don't have script/cpp frames.  If','line_number':207,'multiline':False]['text':' we do have those frames, it doesn't work so force zero.','line_number':208,'multiline':False]['text':' Directly populate tracebacks that already have cached summaries','line_number':229,'multiline':False]