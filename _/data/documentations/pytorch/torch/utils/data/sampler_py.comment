['text':' NOTE [ Lack of Default `__len__` in Python Abstract Base Classes ]','line_number':70,'multiline':False]['text':'','line_number':71,'multiline':False]['text':' Many times we have an abstract class representing a collection/iterable of','line_number':72,'multiline':False]['text':' data, e.g., `torch.utils.data.Sampler`, with its subclasses optionally','line_number':73,'multiline':False]['text':' implementing a `__len__` method. In such cases, we must make sure to not','line_number':74,'multiline':False]['text':' provide a default implementation, because both straightforward default','line_number':75,'multiline':False]['text':' implementations have their issues:','line_number':76,'multiline':False]['text':'','line_number':77,'multiline':False]['text':'   + `return NotImplemented`:','line_number':78,'multiline':False]['text':'     Calling `len(subclass_instance)` raises:','line_number':79,'multiline':False]['text':'       TypeError: 'NotImplementedType' object cannot be interpreted as an integer','line_number':80,'multiline':False]['text':'','line_number':81,'multiline':False]['text':'   + `raise NotImplementedError()`:','line_number':82,'multiline':False]['text':'     This prevents triggering some fallback behavior. E.g., the built-in','line_number':83,'multiline':False]['text':'     `list(X)` tries to call `len(X)` first, and executes a different code','line_number':84,'multiline':False]['text':'     path if the method is not found or `NotImplemented` is returned, while','line_number':85,'multiline':False]['text':'     raising a `NotImplementedError` will propagate and make the call fail','line_number':86,'multiline':False]['text':'     where it could have used `__iter__` to complete the call.','line_number':87,'multiline':False]['text':'','line_number':88,'multiline':False]['text':' Thus, the only two sensible things to do are','line_number':89,'multiline':False]['text':'','line_number':90,'multiline':False]['text':'   + **not** provide a default `__len__`.','line_number':91,'multiline':False]['text':'','line_number':92,'multiline':False]['text':'   + raise a `TypeError` instead, which is what Python uses when users call','line_number':93,'multiline':False]['text':'     a method that is not defined on an object.','line_number':94,'multiline':False]['text':'     (@ssnl verifies that this works on at least Python 3.7.)','line_number':95,'multiline':False]['text':' dataset size might change at runtime','line_number':147,'multiline':False]['text':' Since collections.abc.Iterable does not check for `__getitem__`, which','line_number':262,'multiline':False]['text':' is one way for an object to be an iterable, we don't do an `isinstance`','line_number':263,'multiline':False]['text':' check here.','line_number':264,'multiline':False]['text':' Implemented based on the benchmarking in https://github.com/pytorch/pytorch/pull/76951','line_number':275,'multiline':False]['text':' Can only be called if self.sampler has __len__ implemented','line_number':298,'multiline':False]['text':' We cannot enforce this condition, so we turn off typechecking for the','line_number':299,'multiline':False]['text':' implementation below.','line_number':300,'multiline':False]['text':' Somewhat related: see NOTE [ Lack of Default `__len__` in Python Abstract Base Classes ]','line_number':301,'multiline':False]['text':' type: ignore[arg-type]','line_number':303,'multiline':False]['text':' type: ignore[arg-type]','line_number':305,'multiline':False]