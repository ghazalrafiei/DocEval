['text':' type: ignore[attr-defined]','line_number':13,'multiline':False]['text':' prctl(2) is a Linux specific system call.','line_number':68,'multiline':False]['text':' On other systems the following function call has no effect.','line_number':69,'multiline':False]['text':' This is set to ensure that non-daemonic child processes can','line_number':70,'multiline':False]['text':' terminate if their parent terminates before they do.','line_number':71,'multiline':False]['text':' SIGINT; Killed by parent, do nothing','line_number':77,'multiline':False]['text':' Propagate exception to parent process, keeping original traceback','line_number':79,'multiline':False]['text':' Ensure this function can be called even when we're done.','line_number':112,'multiline':False]['text':' Wait for any process to fail or all of them to succeed.','line_number':116,'multiline':False]['text':' Return if there was no error.','line_number':131,'multiline':False]['text':' Return whether or not all processes have been joined.','line_number':133,'multiline':False]['text':' Assume failure. Terminate processes that are still alive.','line_number':136,'multiline':False]['text':' Try SIGTERM then SIGKILL if the process isn't going down.','line_number':137,'multiline':False]['text':' The reason is related to python signal handling is limited','line_number':138,'multiline':False]['text':' to main thread and if that is in c/c++ land and stuck it won't','line_number':139,'multiline':False]['text':' to handle it. We have seen processes getting stuck not handling','line_number':140,'multiline':False]['text':' SIGTERM for the above reason.','line_number':141,'multiline':False]['text':' The file will only be created if the process crashed.','line_number':160,'multiline':False]['text':' Note: [start_processes]','line_number':197,'multiline':False]['text':' mp.start_processes handles both start_method='spawn' and 'fork'. It's supposed to be a','line_number':198,'multiline':False]['text':' more generalized API than mp.spawn. Currently we only document mp.spawn as it's the','line_number':199,'multiline':False]['text':' CUDA compatible start_method. However, in environments like Ipython notebooks, 'fork'','line_number':200,'multiline':False]['text':' works better than 'spawn'. Every helper function we created for mp.spawn is indeed','line_number':201,'multiline':False]['text':' general enough, and backends like XLA can reuse them in Colab notebooks as well.','line_number':202,'multiline':False]['text':' Currently we only add this API first, we can consider adding it to documentation as','line_number':203,'multiline':False]['text':' needed in the future.','line_number':204,'multiline':False]['text':' Each process is assigned a file to write tracebacks to.  We','line_number':212,'multiline':False]['text':' use the file being non-empty to indicate an exception','line_number':213,'multiline':False]['text':' occurred (vs an expected shutdown).  Note: this previously','line_number':214,'multiline':False]['text':' used a multiprocessing.Queue but that can be prone to','line_number':215,'multiline':False]['text':' deadlocks, so we went with a simpler solution for a one-shot','line_number':216,'multiline':False]['text':' message between processes.','line_number':217,'multiline':False]['text':' Loop on join until it returns True or raises an exception.','line_number':236,'multiline':False]