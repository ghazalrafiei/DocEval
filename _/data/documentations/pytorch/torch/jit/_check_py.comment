['text':' Ignore comments no matter the indentation','line_number':63,'multiline':False]['text':' This AST only contains the `__init__` method of the nn.Module','line_number':72,'multiline':False]['text':' Get items annotated in the class body','line_number':75,'multiline':False]['text':' Flag for later','line_number':78,'multiline':False]['text':' Assigning `[]` to a `List` type gives you a Node where','line_number':85,'multiline':False]['text':' value=List(elts=[], ctx=Load())','line_number':86,'multiline':False]['text':' Assigning `{}` to a `Dict` type gives you a Node where','line_number':92,'multiline':False]['text':' value=Dict(keys=[], values=[])','line_number':93,'multiline':False]['text':' Assigning `None` to an `Optional` type gives you a','line_number':99,'multiline':False]['text':' Node where value=Constant(value=None, kind=None)','line_number':100,'multiline':False]['text':' type: ignore[attr-defined]','line_number':103,'multiline':False]['text':' If we have a local variable','line_number':135,'multiline':False]['text':' If we have an attribute that's already been annotated at the','line_number':142,'multiline':False]['text':' class level','line_number':143,'multiline':False]['text':' TODO @ansley: add `Union` once landed','line_number':147,'multiline':False]['text':' NB: Even though `Tuple` is a "container", we don't want to','line_number':149,'multiline':False]['text':' check for it here. `Tuple` functions as an type with an','line_number':150,'multiline':False]['text':' "infinite" number of subtypes, in the sense that you can have','line_number':151,'multiline':False]['text':' `Tuple[())]`, `Tuple[T1]`, `Tuple[T2]`, `Tuple[T1, T2]`,','line_number':152,'multiline':False]['text':' `Tuple[T2, T1]` and so on, and none of these subtypes can be','line_number':153,'multiline':False]['text':' used in place of the other. Therefore, assigning an empty','line_number':154,'multiline':False]['text':' tuple in `__init__` CORRECTLY means that that variable','line_number':155,'multiline':False]['text':' cannot be reassigned later to a non-empty tuple. Same','line_number':156,'multiline':False]['text':' deal with `NamedTuple`','line_number':157,'multiline':False]['text':' If we're not evaluating one of the specified problem types','line_number':161,'multiline':False]['text':' To evaluate a base type (`str`, `int`, etc.), we would','line_number':166,'multiline':False]['text':' have needed to get the name through `node.annotation.id`','line_number':167,'multiline':False]['text':' instead of `node.annotation.value.id`. Seems that we're','line_number':168,'multiline':False]['text':' not evaluating one of our "containers"','line_number':169,'multiline':False]['text':' Check if the assigned variable is empty','line_number':172,'multiline':False]['text':' If we have an attribute that's already been annotated at the','line_number':192,'multiline':False]['text':' class level','line_number':193,'multiline':False]['text':' If this isn't a call to `torch.jit.annotate`','line_number':197,'multiline':False]['text':' Looks like we didn't even have the right node structure','line_number':210,'multiline':False]['text':' to check for `torch.jit.annotate` in the first place','line_number':211,'multiline':False]['text':' Invariant: we have a `torch.jit.annotate` or a','line_number':214,'multiline':False]['text':' `torch.annotate` call','line_number':215,'multiline':False]['text':' A Call Node for `torch.jit.annotate` should have an `args`','line_number':217,'multiline':False]['text':' list of length 2 where args[0] represents the annotation and','line_number':218,'multiline':False]['text':' args[1] represents the actual value','line_number':219,'multiline':False]['text':' See notes in `visit_AnnAssign` r.e. containers','line_number':226,'multiline':False]['text':' type: ignore[attr-defined]','line_number':231,'multiline':False]['text':' Check if the assigned variable is empty','line_number':238,'multiline':False]