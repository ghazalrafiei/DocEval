['text':' avoid computing these values, pessimistically assume that they are unbounded','line_number':32,'multiline':False]['text':' To access this variable call `get_bounds()`','line_number':39,'multiline':False]['text':' Initialize the environment with the unbounded variables','line_number':46,'multiline':False]['text':' we need to evaluate masked_subblock to recurse, and we need to set indirect values','line_number':48,'multiline':False]['text':' The result within the lambda will reference to the final','line_number':69,'multiline':False]['text':' set of modules at the end of the for-loop as it stores a reference to it','line_number':70,'multiline':False]['text':' bind subblock in a function because python lambdas close over by reference','line_number':72,'multiline':False]['text':' moving the lambda out of make_fn would close over the reference to subblock,','line_number':73,'multiline':False]['text':' so all lambdas would have the same subblock reference that is the final','line_number':74,'multiline':False]['text':' subblock in the loop','line_number':75,'multiline':False]['text':' dont bother unioning with value since the load from buffer will be','line_number':106,'multiline':False]['text':' pessimistically assumed to be inf anyway','line_number':107,'multiline':False]['text':' The following assertion is true at the time of this writing','line_number':120,'multiline':False]['text':' We don't assert is as to not execute bound_sympy when bound is not None','line_number':121,'multiline':False]['text':' assert bound is None or bound == bound_sympy(expr, self.replacement_vals)','line_number':122,'multiline':False]