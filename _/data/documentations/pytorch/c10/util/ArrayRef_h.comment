['text':'===--- ArrayRef.h - Array Reference Wrapper -------------------*- C++ -*-===//','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':'                     The LLVM Compiler Infrastructure','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':' This file is distributed under the University of Illinois Open Source','line_number':5,'multiline':False]['text':' License. See LICENSE.TXT for details.','line_number':6,'multiline':False]['text':'','line_number':7,'multiline':False]['text':'===----------------------------------------------------------------------===//','line_number':8,'multiline':False]['text':' ATen: modified from llvm::ArrayRef.','line_number':10,'multiline':False]['text':' removed llvm-specific functionality','line_number':11,'multiline':False]['text':' removed some implicit const -> non-const conversions that rely on','line_number':12,'multiline':False]['text':' complicated std::enable_if meta-programming','line_number':13,'multiline':False]['text':' removed a bunch of slice variants for simplicity...','line_number':14,'multiline':False]['text':'/ ArrayRef - Represent a constant reference to an array (0 or more elements','line_number':27,'multiline':False]['text':'/ consecutively in memory), i.e. a start pointer and a length.  It allows','line_number':28,'multiline':False]['text':'/ various APIs to take consecutive elements easily and conveniently.','line_number':29,'multiline':False]['text':'/','line_number':30,'multiline':False]['text':'/ This class does not own the underlying data, it is expected to be used in','line_number':31,'multiline':False]['text':'/ situations where the data resides in some other buffer, whose lifetime','line_number':32,'multiline':False]['text':'/ extends past that of the ArrayRef. For this reason, it is not in general','line_number':33,'multiline':False]['text':'/ safe to store an ArrayRef.','line_number':34,'multiline':False]['text':'/','line_number':35,'multiline':False]['text':'/ This is intended to be trivially copyable, so it should be passed by','line_number':36,'multiline':False]['text':'/ value.','line_number':37,'multiline':False]['text':'/ The start of the array, in an external buffer.','line_number':49,'multiline':False]['text':'/ The number of elements.','line_number':52,'multiline':False]['text':'/ @name Constructors','line_number':62,'multiline':False]['text':'/ @{','line_number':63,'multiline':False]['text':'/ Construct an empty ArrayRef.','line_number':65,'multiline':False]['text':' implicit ','line_number':66,'multiline':True]['text':'/ Construct an ArrayRef from a single element.','line_number':68,'multiline':False]['text':' TODO Make this explicit','line_number':69,'multiline':False]['text':'/ Construct an ArrayRef from a pointer and length.','line_number':72,'multiline':False]['text':'/ Construct an ArrayRef from a range.','line_number':78,'multiline':False]['text':'/ Construct an ArrayRef from a SmallVector. This is templated in order to','line_number':84,'multiline':False]['text':'/ avoid instantiating SmallVectorTemplateCommon<T> whenever we','line_number':85,'multiline':False]['text':'/ copy-construct an ArrayRef.','line_number':86,'multiline':False]['text':' implicit ','line_number':88,'multiline':True]['text':' implicit ','line_number':98,'multiline':True]['text':'/ Construct an ArrayRef from a std::vector.','line_number':103,'multiline':False]['text':' The enable_if stuff here makes sure that this isn't used for','line_number':104,'multiline':False]['text':' std::vector<bool>, because ArrayRef can't work on a std::vector<bool>','line_number':105,'multiline':False]['text':' bitfield.','line_number':106,'multiline':False]['text':' implicit ','line_number':108,'multiline':True]['text':'/ Construct an ArrayRef from a std::array','line_number':115,'multiline':False]['text':' implicit ','line_number':117,'multiline':True]['text':'/ Construct an ArrayRef from a C array.','line_number':120,'multiline':False]['text':' implicit ','line_number':122,'multiline':True]['text':'/ Construct an ArrayRef from a std::initializer_list.','line_number':124,'multiline':False]['text':' implicit ','line_number':125,'multiline':True]['text':'/ @}','line_number':131,'multiline':False]['text':'/ @name Simple Operations','line_number':132,'multiline':False]['text':'/ @{','line_number':133,'multiline':False]['text':' These are actually the same as iterator, since ArrayRef only','line_number':142,'multiline':False]['text':' gives you const iterators.','line_number':143,'multiline':False]['text':'/ empty - Check if the array is empty.','line_number':158,'multiline':False]['text':'/ size - Get the array size.','line_number':167,'multiline':False]['text':'/ front - Get the first element.','line_number':172,'multiline':False]['text':'/ back - Get the last element.','line_number':179,'multiline':False]['text':'/ equals - Check for element-wise equality.','line_number':185,'multiline':False]['text':'/ slice(n, m) - Take M elements of the array starting at element N','line_number':190,'multiline':False]['text':'/ slice(n) - Chop off the first N elements of the array.','line_number':204,'multiline':False]['text':'/ @}','line_number':211,'multiline':False]['text':'/ @name Operator Overloads','line_number':212,'multiline':False]['text':'/ @{','line_number':213,'multiline':False]['text':'/ Vector compatibility','line_number':218,'multiline':False]['text':'/ Disallow accidental assignment from a temporary.','line_number':229,'multiline':False]['text':'/','line_number':230,'multiline':False]['text':'/ The declaration here is extra complicated so that "arrayRef = {}"','line_number':231,'multiline':False]['text':'/ continues to select the move assignment operator.','line_number':232,'multiline':False]['text':'/ Disallow accidental assignment from a temporary.','line_number':237,'multiline':False]['text':'/','line_number':238,'multiline':False]['text':'/ The declaration here is extra complicated so that "arrayRef = {}"','line_number':239,'multiline':False]['text':'/ continues to select the move assignment operator.','line_number':240,'multiline':False]['text':'/ @}','line_number':245,'multiline':False]['text':'/ @name Expensive Operations','line_number':246,'multiline':False]['text':'/ @{','line_number':247,'multiline':False]['text':'/ @}','line_number':252,'multiline':False]['text':'/ @name ArrayRef Convenience constructors','line_number':268,'multiline':False]['text':'/ @{','line_number':269,'multiline':False]['text':'/ Construct an ArrayRef from a single element.','line_number':271,'multiline':False]['text':'/ Construct an ArrayRef from a pointer and length.','line_number':277,'multiline':False]['text':'/ Construct an ArrayRef from a range.','line_number':283,'multiline':False]['text':'/ Construct an ArrayRef from a SmallVector.','line_number':289,'multiline':False]['text':'/ Construct an ArrayRef from a SmallVector.','line_number':295,'multiline':False]['text':'/ Construct an ArrayRef from a std::vector.','line_number':301,'multiline':False]['text':'/ Construct an ArrayRef from a std::array.','line_number':307,'multiline':False]['text':'/ Construct an ArrayRef from an ArrayRef (no-op) (const)','line_number':313,'multiline':False]['text':'/ Construct an ArrayRef from an ArrayRef (no-op)','line_number':319,'multiline':False]['text':'/ Construct an ArrayRef from a C array.','line_number':325,'multiline':False]['text':' WARNING: Template instantiation will NOT be willing to do an implicit','line_number':331,'multiline':False]['text':' conversions to get you to an c10::ArrayRef, which is why we need so','line_number':332,'multiline':False]['text':' many overloads.','line_number':333,'multiline':False]['text':' This alias is deprecated because it doesn't make ownership','line_number':367,'multiline':False]['text':' semantics obvious.  Use IntArrayRef instead!','line_number':368,'multiline':False]['text':' namespace c10','line_number':371,'multiline':False]