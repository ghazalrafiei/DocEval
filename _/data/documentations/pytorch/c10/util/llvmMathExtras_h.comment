['text':'===-- llvm/Support/MathExtras.h - Useful math functions -------*- C++ -*-===//','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.','line_number':3,'multiline':False]['text':' See https://llvm.org/LICENSE.txt for license information.','line_number':4,'multiline':False]['text':' SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'===----------------------------------------------------------------------===//','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':' This file contains some functions that are useful for math stuff.','line_number':9,'multiline':False]['text':'','line_number':10,'multiline':False]['text':'===----------------------------------------------------------------------===//','line_number':11,'multiline':False]['text':' Declare these intrinsics manually rather including intrin.h. It's very','line_number':48,'multiline':False]['text':' expensive, and MathExtras.h is popular.','line_number':49,'multiline':False]['text':' #include <intrin.h>','line_number':50,'multiline':False]['text':'/ The behavior an operation has on an input of 0.','line_number':61,'multiline':False]['text':'/ The returned value is undefined.','line_number':63,'multiline':False]['text':'/ The returned value is numeric_limits<T>::max()','line_number':65,'multiline':False]['text':'/ The returned value is numeric_limits<T>::digits','line_number':67,'multiline':False]['text':' Bisection method.','line_number':80,'multiline':False]['text':' namespace detail','line_number':131,'multiline':False]['text':'/ Count number of 0's from the least significant bit to the most','line_number':133,'multiline':False]['text':'/   stopping at the first 1.','line_number':134,'multiline':False]['text':'/','line_number':135,'multiline':False]['text':'/ Only unsigned integral types are allowed.','line_number':136,'multiline':False]['text':'/','line_number':137,'multiline':False]['text':'/ \param ZB the behavior on an input of 0. Only ZB_Width and ZB_Undefined are','line_number':138,'multiline':False]['text':'/   valid arguments.','line_number':139,'multiline':False]['text':' Bisection method.','line_number':155,'multiline':False]['text':' namespace detail','line_number':203,'multiline':False]['text':'/ Count number of 0's from the most significant bit to the least','line_number':205,'multiline':False]['text':'/   stopping at the first 1.','line_number':206,'multiline':False]['text':'/','line_number':207,'multiline':False]['text':'/ Only unsigned integral types are allowed.','line_number':208,'multiline':False]['text':'/','line_number':209,'multiline':False]['text':'/ \param ZB the behavior on an input of 0. Only ZB_Width and ZB_Undefined are','line_number':210,'multiline':False]['text':'/   valid arguments.','line_number':211,'multiline':False]['text':'/ Get the index of the first set bit starting from the least','line_number':220,'multiline':False]['text':'/   significant bit.','line_number':221,'multiline':False]['text':'/','line_number':222,'multiline':False]['text':'/ Only unsigned integral types are allowed.','line_number':223,'multiline':False]['text':'/','line_number':224,'multiline':False]['text':'/ \param ZB the behavior on an input of 0. Only ZB_Max and ZB_Undefined are','line_number':225,'multiline':False]['text':'/   valid arguments.','line_number':226,'multiline':False]['text':'/ Create a bitmask with the N right-most bits set to 1, and all other','line_number':235,'multiline':False]['text':'/ bits set to 0.  Only unsigned types are allowed.','line_number':236,'multiline':False]['text':'/ Create a bitmask with the N left-most bits set to 1, and all other','line_number':245,'multiline':False]['text':'/ bits set to 0.  Only unsigned types are allowed.','line_number':246,'multiline':False]['text':'/ Create a bitmask with the N right-most bits set to 0, and all other','line_number':252,'multiline':False]['text':'/ bits set to 1.  Only unsigned types are allowed.','line_number':253,'multiline':False]['text':'/ Create a bitmask with the N left-most bits set to 0, and all other','line_number':259,'multiline':False]['text':'/ bits set to 1.  Only unsigned types are allowed.','line_number':260,'multiline':False]['text':'/ Get the index of the last set bit starting from the least','line_number':266,'multiline':False]['text':'/   significant bit.','line_number':267,'multiline':False]['text':'/','line_number':268,'multiline':False]['text':'/ Only unsigned integral types are allowed.','line_number':269,'multiline':False]['text':'/','line_number':270,'multiline':False]['text':'/ \param ZB the behavior on an input of 0. Only ZB_Max and ZB_Undefined are','line_number':271,'multiline':False]['text':'/   valid arguments.','line_number':272,'multiline':False]['text':' Use ^ instead of - because both gcc and llvm can remove the associated ^','line_number':278,'multiline':False]['text':' in the __builtin_clz intrinsic on x86.','line_number':279,'multiline':False]['text':'/ Macro compressed bit reversal table for 256 bits.','line_number':284,'multiline':False]['text':'/','line_number':285,'multiline':False]['text':'/ http://graphics.stanford.edu/~seander/bithacks.html#BitReverseTable','line_number':286,'multiline':False]['text':'/ Reverse the bits in \p Val.','line_number':300,'multiline':False]['text':' NOTE: The following support functions use the _32/_64 extensions instead of','line_number':312,'multiline':False]['text':' type overloading so that signed and unsigned integers can be used without','line_number':313,'multiline':False]['text':' ambiguity.','line_number':314,'multiline':False]['text':'/ Return the high 32 bits of a 64 bit value.','line_number':316,'multiline':False]['text':'/ Return the low 32 bits of a 64 bit value.','line_number':321,'multiline':False]['text':'/ Make a 64-bit integer from a high / low pair of 32-bit integers.','line_number':326,'multiline':False]['text':'/ Checks if an integer fits into the given bit width.','line_number':331,'multiline':False]['text':' Template specializations to get better code for common cases.','line_number':337,'multiline':False]['text':'/ Checks if a signed integer is an N bit number shifted left by S.','line_number':351,'multiline':False]['text':'/ Checks if an unsigned integer fits into the given bit width.','line_number':360,'multiline':False]['text':'/','line_number':361,'multiline':False]['text':'/ This is written as two functions rather than as simply','line_number':362,'multiline':False]['text':'/','line_number':363,'multiline':False]['text':'/   return N >= 64 || X < (UINT64_C(1) << N);','line_number':364,'multiline':False]['text':'/','line_number':365,'multiline':False]['text':'/ to keep MSVC from (incorrectly) warning on isUInt<64> that we're shifting','line_number':366,'multiline':False]['text':'/ left too many places.','line_number':367,'multiline':False]['text':'X','line_number':376,'multiline':True]['text':' Template specializations to get better code for common cases.','line_number':380,'multiline':False]['text':'/ Checks if a unsigned integer is an N bit number shifted left by S.','line_number':394,'multiline':False]['text':' Per the two static_asserts above, S must be strictly less than 64.  So','line_number':401,'multiline':False]['text':' 1 << S is not undefined behavior.','line_number':402,'multiline':False]['text':'/ Gets the maximum value for a N-bit unsigned integer.','line_number':406,'multiline':False]['text':' uint64_t(1) << 64 is undefined behavior, so we can't do','line_number':410,'multiline':False]['text':'   (uint64_t(1) << N) - 1','line_number':411,'multiline':False]['text':' without checking first that N != 64.  But this works and doesn't have a','line_number':412,'multiline':False]['text':' branch.','line_number':413,'multiline':False]['text':' Ignore the false warning "Arithmetic overflow" for MSVC','line_number':417,'multiline':False]['text':'/ Gets the minimum value for a N-bit signed integer.','line_number':423,'multiline':False]['text':'/ Gets the maximum value for a N-bit signed integer.','line_number':434,'multiline':False]['text':' This relies on two's complement wraparound when N == 64, so we convert to','line_number':438,'multiline':False]['text':' int64_t only at the very end to avoid UB.','line_number':439,'multiline':False]['text':'/ Checks if an unsigned integer fits into the given (dynamic) bit width.','line_number':443,'multiline':False]['text':'/ Checks if an signed integer fits into the given (dynamic) bit width.','line_number':448,'multiline':False]['text':'/ Return true if the argument is a non-empty sequence of ones starting at the','line_number':453,'multiline':False]['text':'/ least significant bit with the remainder zero (32 bit version).','line_number':454,'multiline':False]['text':'/ Ex. isMask_32(0x0000FFFFU) == true.','line_number':455,'multiline':False]['text':'/ Return true if the argument is a non-empty sequence of ones starting at the','line_number':460,'multiline':False]['text':'/ least significant bit with the remainder zero (64 bit version).','line_number':461,'multiline':False]['text':'/ Return true if the argument contains a non-empty sequence of ones with the','line_number':466,'multiline':False]['text':'/ remainder zero (32 bit version.) Ex. isShiftedMask_32(0x0000FF00U) == true.','line_number':467,'multiline':False]['text':'/ Return true if the argument contains a non-empty sequence of ones with the','line_number':472,'multiline':False]['text':'/ remainder zero (64 bit version.)','line_number':473,'multiline':False]['text':'/ Return true if the argument is a power of two > 0.','line_number':478,'multiline':False]['text':'/ Ex. isPowerOf2_32(0x00100000U) == true (32 bit edition.)','line_number':479,'multiline':False]['text':'/ Return true if the argument is a power of two > 0 (64 bit edition.)','line_number':484,'multiline':False]['text':'/ Count the number of ones from the most significant bit to the first','line_number':489,'multiline':False]['text':'/ zero bit.','line_number':490,'multiline':False]['text':'/','line_number':491,'multiline':False]['text':'/ Ex. countLeadingOnes(0xFF0FFF00) == 8.','line_number':492,'multiline':False]['text':'/ Only unsigned integral types are allowed.','line_number':493,'multiline':False]['text':'/','line_number':494,'multiline':False]['text':'/ \param ZB the behavior on an input of all ones. Only ZB_Width and','line_number':495,'multiline':False]['text':'/ ZB_Undefined are valid arguments.','line_number':496,'multiline':False]['text':'/ Count the number of ones from the least significant bit to the first','line_number':505,'multiline':False]['text':'/ zero bit.','line_number':506,'multiline':False]['text':'/','line_number':507,'multiline':False]['text':'/ Ex. countTrailingOnes(0x00FF00FF) == 8.','line_number':508,'multiline':False]['text':'/ Only unsigned integral types are allowed.','line_number':509,'multiline':False]['text':'/','line_number':510,'multiline':False]['text':'/ \param ZB the behavior on an input of all ones. Only ZB_Width and','line_number':511,'multiline':False]['text':'/ ZB_Undefined are valid arguments.','line_number':512,'multiline':False]['text':' Generic version, forward to 32 bits.','line_number':525,'multiline':False]['text':' namespace detail','line_number':552,'multiline':False]['text':'/ Count the number of set bits in a value.','line_number':554,'multiline':False]['text':'/ Ex. countPopulation(0xF000F000) = 8','line_number':555,'multiline':False]['text':'/ Returns 0 if the word is zero.','line_number':556,'multiline':False]['text':'/ Return the log base 2 of the specified value.','line_number':565,'multiline':False]['text':'/ Return the floor log base 2 of the specified value, -1 if the value is zero.','line_number':574,'multiline':False]['text':'/ (32 bit edition.)','line_number':575,'multiline':False]['text':'/ Ex. Log2_32(32) == 5, Log2_32(1) == 0, Log2_32(0) == -1, Log2_32(6) == 2','line_number':576,'multiline':False]['text':'/ Return the floor log base 2 of the specified value, -1 if the value is zero.','line_number':581,'multiline':False]['text':'/ (64 bit edition.)','line_number':582,'multiline':False]['text':'/ Return the ceil log base 2 of the specified value, 32 if the value is zero.','line_number':587,'multiline':False]['text':'/ (32 bit edition).','line_number':588,'multiline':False]['text':'/ Ex. Log2_32_Ceil(32) == 5, Log2_32_Ceil(1) == 0, Log2_32_Ceil(6) == 3','line_number':589,'multiline':False]['text':'/ Return the ceil log base 2 of the specified value, 64 if the value is zero.','line_number':594,'multiline':False]['text':'/ (64 bit edition.)','line_number':595,'multiline':False]['text':'/ Return the greatest common divisor of the values using Euclid's algorithm.','line_number':600,'multiline':False]['text':'/ This function takes a 64-bit integer and returns the bit equivalent double.','line_number':610,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':612,'multiline':False]['text':'/ This function takes a 32-bit integer and returns the bit equivalent float.','line_number':619,'multiline':False]['text':' TODO: Use std::bit_cast once C++20 becomes available.','line_number':621,'multiline':False]['text':'/ This function takes a double and returns the bit equivalent 64-bit integer.','line_number':625,'multiline':False]['text':'/ Note that copying doubles around changes the bits of NaNs on some hosts,','line_number':626,'multiline':False]['text':'/ notably x86, so this routine cannot be used if these bits are needed.','line_number':627,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':629,'multiline':False]['text':'/ This function takes a float and returns the bit equivalent 32-bit integer.','line_number':636,'multiline':False]['text':'/ Note that copying floats around changes the bits of NaNs on some hosts,','line_number':637,'multiline':False]['text':'/ notably x86, so this routine cannot be used if these bits are needed.','line_number':638,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':640,'multiline':False]['text':'/ A and B are either alignments or offsets. Return the minimum alignment that','line_number':647,'multiline':False]['text':'/ may be assumed after adding the two together.','line_number':648,'multiline':False]['text':' The largest power of 2 that divides both A and B.','line_number':650,'multiline':False]['text':'','line_number':651,'multiline':False]['text':' Replace "-Value" by "1+~Value" in the following commented code to avoid','line_number':652,'multiline':False]['text':' MSVC warning C4146','line_number':653,'multiline':False]['text':'    return (A | B) & -(A | B);','line_number':654,'multiline':False]['text':'/ Aligns \c Addr to \c Alignment bytes, rounding up.','line_number':658,'multiline':False]['text':'/','line_number':659,'multiline':False]['text':'/ Alignment should be a power of two.  This method rounds up, so','line_number':660,'multiline':False]['text':'/ alignAddr(7, 4) == 8 and alignAddr(8, 4) == 8.','line_number':661,'multiline':False]['text':'/ Returns the necessary adjustment for aligning \c Ptr to \c Alignment','line_number':672,'multiline':False]['text':'/ bytes, rounding up.','line_number':673,'multiline':False]['text':'/ Returns the next power of two (in 64-bits) that is strictly greater than A.','line_number':678,'multiline':False]['text':'/ Returns zero on overflow.','line_number':679,'multiline':False]['text':'/ Returns the power of two which is less than or equal to the given value.','line_number':690,'multiline':False]['text':'/ Essentially, it is a floor operation across the domain of powers of two.','line_number':691,'multiline':False]['text':'/ Returns the power of two which is greater than or equal to the given value.','line_number':698,'multiline':False]['text':'/ Essentially, it is a ceil operation across the domain of powers of two.','line_number':699,'multiline':False]['text':'/ Returns the next integer (mod 2**64) that is greater than or equal to','line_number':706,'multiline':False]['text':'/ \p Value and is a multiple of \p Align. \p Align must be non-zero.','line_number':707,'multiline':False]['text':'/','line_number':708,'multiline':False]['text':'/ If non-zero \p Skew is specified, the return value will be a minimal','line_number':709,'multiline':False]['text':'/ integer that is greater than or equal to \p Value and equal to','line_number':710,'multiline':False]['text':'/ \p Align * N + \p Skew for some integer N. If \p Skew is larger than','line_number':711,'multiline':False]['text':'/ \p Align, its value is adjusted to '\p Skew mod \p Align'.','line_number':712,'multiline':False]['text':'/','line_number':713,'multiline':False]['text':'/ Examples:','line_number':714,'multiline':False]['text':'/ \code','line_number':715,'multiline':False]['text':'/   alignTo(5, 8) = 8','line_number':716,'multiline':False]['text':'/   alignTo(17, 8) = 24','line_number':717,'multiline':False]['text':'/   alignTo(~0LL, 8) = 0','line_number':718,'multiline':False]['text':'/   alignTo(321, 255) = 510','line_number':719,'multiline':False]['text':'/','line_number':720,'multiline':False]['text':'/   alignTo(5, 8, 7) = 7','line_number':721,'multiline':False]['text':'/   alignTo(17, 8, 1) = 17','line_number':722,'multiline':False]['text':'/   alignTo(~0LL, 8, 3) = 3','line_number':723,'multiline':False]['text':'/   alignTo(321, 255, 42) = 552','line_number':724,'multiline':False]['text':'/ \endcode','line_number':725,'multiline':False]['text':'/ Returns the next integer (mod 2**64) that is greater than or equal to','line_number':732,'multiline':False]['text':'/ \p Value and is a multiple of \c Align. \c Align must be non-zero.','line_number':733,'multiline':False]['text':'/ Returns the integer ceil(Numerator / Denominator).','line_number':740,'multiline':False]['text':'/ \c alignTo for contexts where a constant expression is required.','line_number':745,'multiline':False]['text':'/ \sa alignTo','line_number':746,'multiline':False]['text':'/','line_number':747,'multiline':False]['text':'/ \todo FIXME: remove when \c constexpr becomes really \c constexpr','line_number':748,'multiline':False]['text':'/ Returns the largest uint64_t less than or equal to \p Value and is','line_number':758,'multiline':False]['text':'/ \p Skew mod \p Align. \p Align must be non-zero','line_number':759,'multiline':False]['text':'/ Returns the offset to the next integer (mod 2**64) that is greater than','line_number':766,'multiline':False]['text':'/ or equal to \p Value and is a multiple of \p Align. \p Align must be','line_number':767,'multiline':False]['text':'/ non-zero.','line_number':768,'multiline':False]['text':'/ Sign-extend the number in the bottom B bits of X to a 32-bit integer.','line_number':773,'multiline':False]['text':'/ Requires 0 < B <= 32.','line_number':774,'multiline':False]['text':'/ Sign-extend the number in the bottom B bits of X to a 32-bit integer.','line_number':782,'multiline':False]['text':'/ Requires 0 < B < 32.','line_number':783,'multiline':False]['text':'/ Sign-extend the number in the bottom B bits of X to a 64-bit integer.','line_number':790,'multiline':False]['text':'/ Requires 0 < B < 64.','line_number':791,'multiline':False]['text':'/ Sign-extend the number in the bottom B bits of X to a 64-bit integer.','line_number':799,'multiline':False]['text':'/ Requires 0 < B < 64.','line_number':800,'multiline':False]['text':'/ Subtract two unsigned integers, X and Y, of type T and return the absolute','line_number':807,'multiline':False]['text':'/ value of the result.','line_number':808,'multiline':False]['text':'/ Add two unsigned integers, X and Y, of type T.  Clamp the result to the','line_number':816,'multiline':False]['text':'/ maximum representable value of T on overflow.  ResultOverflowed indicates if','line_number':817,'multiline':False]['text':'/ the result is larger than the maximum representable value of type T.','line_number':818,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':824,'multiline':False]['text':' Hacker's Delight, p. 29','line_number':827,'multiline':False]['text':'/ Multiply two unsigned integers, X and Y, of type T.  Clamp the result to the','line_number':836,'multiline':False]['text':'/ maximum representable value of T on overflow.  ResultOverflowed indicates if','line_number':837,'multiline':False]['text':'/ the result is larger than the maximum representable value of type T.','line_number':838,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':844,'multiline':False]['text':' Hacker's Delight, p. 30 has a different algorithm, but we don't use that','line_number':848,'multiline':False]['text':' because it fails for uint16_t (where multiplication can have undefined','line_number':849,'multiline':False]['text':' behavior due to promotion to int), and requires a division in addition','line_number':850,'multiline':False]['text':' to the multiplication.','line_number':851,'multiline':False]['text':' Log2(Z) would be either Log2Z or Log2Z + 1.','line_number':855,'multiline':False]['text':' Special case: if X or Y is 0, Log2_64 gives -1, and Log2Z','line_number':856,'multiline':False]['text':' will necessarily be less than Log2Max as desired.','line_number':857,'multiline':False]['text':' We're going to use the top bit, and maybe overflow one','line_number':869,'multiline':False]['text':' bit past it. Multiply all but the bottom bit then add','line_number':870,'multiline':False]['text':' that on at the end.','line_number':871,'multiline':False]['text':'/ Multiply two unsigned integers, X and Y, and add the unsigned integer, A to','line_number':884,'multiline':False]['text':'/ the product. Clamp the result to the maximum representable value of T on','line_number':885,'multiline':False]['text':'/ overflow. ResultOverflowed indicates if the result is larger than the','line_number':886,'multiline':False]['text':'/ maximum representable value of type T.','line_number':887,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':891,'multiline':False]['text':'/ Use this rather than HUGE_VALF; the latter causes warnings on MSVC.','line_number':902,'multiline':False]['text':' namespace llvm','line_number':904,'multiline':False]['text':' namespace c10','line_number':905,'multiline':False]