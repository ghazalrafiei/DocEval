['text':'===- llvm/ADT/SparseBitVector.h - Efficient Sparse BitVector --*- C++ -*-===//','line_number':1,'multiline':False]['text':'','line_number':2,'multiline':False]['text':' Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.','line_number':3,'multiline':False]['text':' See https://llvm.org/LICENSE.txt for license information.','line_number':4,'multiline':False]['text':' SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception','line_number':5,'multiline':False]['text':'','line_number':6,'multiline':False]['text':'===----------------------------------------------------------------------===//','line_number':7,'multiline':False]['text':'','line_number':8,'multiline':False]['text':' This file defines the SparseBitVector class.  See the doxygen comment for','line_number':9,'multiline':False]['text':' SparseBitVector for more details on the algorithm used.','line_number':10,'multiline':False]['text':'','line_number':11,'multiline':False]['text':'===----------------------------------------------------------------------===//','line_number':12,'multiline':False]['text':'/ SparseBitVector is an implementation of a bitvector that is sparse by only','line_number':30,'multiline':False]['text':'/ storing the elements that have non-zero bits set.  In order to make this','line_number':31,'multiline':False]['text':'/ fast for the most common cases, SparseBitVector is implemented as a linked','line_number':32,'multiline':False]['text':'/ list of SparseBitVectorElements.  We maintain a pointer to the last','line_number':33,'multiline':False]['text':'/ SparseBitVectorElement accessed (in the form of a list iterator), in order','line_number':34,'multiline':False]['text':'/ to make multiple in-order test/set constant time after the first one is','line_number':35,'multiline':False]['text':'/ executed.  Note that using vectors to store SparseBitVectorElement's does','line_number':36,'multiline':False]['text':'/ not work out very well because it causes insertion in the middle to take','line_number':37,'multiline':False]['text':'/ enormous amounts of time with a large amount of bits.  Other structures that','line_number':38,'multiline':False]['text':'/ have better worst cases for insertion in the middle (various balanced trees,','line_number':39,'multiline':False]['text':'/ etc) do not perform as well in practice as a linked list with this iterator','line_number':40,'multiline':False]['text':'/ kept up to date.  They are also significantly more memory intensive.','line_number':41,'multiline':False]['text':' Index of Element in terms of where first bit starts.','line_number':55,'multiline':False]['text':' Comparison.','line_number':70,'multiline':False]['text':' Return the bits that make up word Idx in our element.','line_number':84,'multiline':False]['text':'/ find_first - Returns the index of the first set bit.','line_number':129,'multiline':False]['text':'/ find_last - Returns the index of the last set bit.','line_number':137,'multiline':False]['text':'/ find_next - Returns the index of the next set bit starting from the','line_number':148,'multiline':False]['text':'/ "Curr" bit. Returns -1 if the next set bit is not found.','line_number':149,'multiline':False]['text':' Mask off previous bits.','line_number':160,'multiline':False]['text':' Check subsequent words.','line_number':166,'multiline':False]['text':' Union this element with RHS and return true if this one changed.','line_number':173,'multiline':False]['text':' Return true if we have any bits in common with RHS','line_number':186,'multiline':False]['text':' Intersect this Element with RHS and return true if this one changed.','line_number':195,'multiline':False]['text':' BecameZero is set to true if this element became all-zero bits.','line_number':196,'multiline':False]['text':' Intersect this Element with the complement of RHS and return true if this','line_number':215,'multiline':False]['text':' one changed.  BecameZero is set to true if this element became all-zero','line_number':216,'multiline':False]['text':' bits.','line_number':217,'multiline':False]['text':' Three argument version of intersectWithComplement that intersects','line_number':238,'multiline':False]['text':' RHS1 & ~RHS2 into this element','line_number':239,'multiline':False]['text':' Pointer to our current Element. This has no visible effect on the external','line_number':263,'multiline':False]['text':' state of a SparseBitVector, it's just used to improve performance in the','line_number':264,'multiline':False]['text':' common case of testing/modifying bits with similar indices.','line_number':265,'multiline':False]['text':' This is like std::lower_bound, except we do linear searching from the','line_number':268,'multiline':False]['text':' current position.','line_number':269,'multiline':False]['text':' We cache a non-const iterator so we're forced to resort to const_cast to','line_number':271,'multiline':False]['text':' get the begin/end in the case where 'this' is const. To avoid duplication','line_number':272,'multiline':False]['text':' of code with the only difference being whether the const cast is present','line_number':273,'multiline':False]['text':' 'this' is always const in this particular function and we sort out the','line_number':274,'multiline':False]['text':' difference in FindLowerBound and FindLowerBoundConst.','line_number':275,'multiline':False]['text':' Make sure our current iterator is valid.','line_number':286,'multiline':False]['text':' Search from our current iterator, either backwards or forwards,','line_number':290,'multiline':False]['text':' depending on what element we are looking for.','line_number':291,'multiline':False]['text':' Iterator to walk set bits in the bitmap.  This iterator is a lot uglier','line_number':312,'multiline':False]['text':' than it would be, in order to be efficient.','line_number':313,'multiline':False]['text':' Current element inside of bitmap.','line_number':320,'multiline':False]['text':' Current bit number inside of our bitmap.','line_number':323,'multiline':False]['text':' Current word number inside of our element.','line_number':326,'multiline':False]['text':' Current bits from the element.','line_number':329,'multiline':False]['text':' Move our iterator to the first non-zero bit in the bitmap.','line_number':332,'multiline':False]['text':' Move our iterator to the next non-zero bit.','line_number':349,'multiline':False]['text':' See if we ran out of Bits in this word.','line_number':359,'multiline':False]['text':' If we ran out of set bits in this element, move to next element.','line_number':362,'multiline':False]['text':' We may run out of elements in the bitmap.','line_number':367,'multiline':False]['text':' Set up for next non-zero word in bitmap.','line_number':372,'multiline':False]['text':' Preincrement.','line_number':404,'multiline':False]['text':' Postincrement.','line_number':412,'multiline':False]['text':' Return the current set bit number.','line_number':419,'multiline':False]['text':' If they are both at the end, ignore the rest of the fields.','line_number':425,'multiline':False]['text':' Otherwise they are the same if they have the same bit number and','line_number':428,'multiline':False]['text':' bitmap.','line_number':429,'multiline':False]['text':' Clear.','line_number':448,'multiline':False]['text':' Assignment','line_number':453,'multiline':False]['text':' Test, Reset, and Set a bit in the bitmap.','line_number':468,'multiline':False]['text':' If we can't find an element that is supposed to contain this bit, there','line_number':476,'multiline':False]['text':' is nothing more to do.','line_number':477,'multiline':False]['text':' If we can't find an element that is supposed to contain this bit, there','line_number':490,'multiline':False]['text':' is nothing more to do.','line_number':491,'multiline':False]['text':' When the element is zeroed out, delete it.','line_number':496,'multiline':False]['text':' We may have hit the beginning of our SparseBitVector, in which case,','line_number':513,'multiline':False]['text':' we may need to insert right after this element, which requires moving','line_number':514,'multiline':False]['text':' the current iterator forward one, because insert does insert before.','line_number':515,'multiline':False]['text':' Union our bitmap with the RHS and return true if we changed.','line_number':552,'multiline':False]['text':' If RHS is empty, we are done','line_number':566,'multiline':False]['text':' Intersect our bitmap with the RHS and return true if ours changed.','line_number':587,'multiline':False]['text':' Intersect our bitmap with the RHS and return true if ours changed.','line_number':592,'multiline':False]['text':' Check if both bitmaps are empty.','line_number':601,'multiline':False]['text':' Loop through, intersecting as we go, erasing elements when necessary.','line_number':605,'multiline':False]['text':' Intersect our bitmap with the complement of the RHS and return true','line_number':640,'multiline':False]['text':' if ours changed.','line_number':641,'multiline':False]['text':' If either our bitmap or RHS is empty, we are done','line_number':655,'multiline':False]['text':' Loop through, intersecting as we go, erasing elements when necessary.','line_number':659,'multiline':False]['text':'  Three argument version of intersectWithComplement.','line_number':691,'multiline':False]['text':'  Result of RHS1 & ~RHS2 is stored into this bitmap.','line_number':692,'multiline':False]['text':' If RHS1 is empty, we are done','line_number':710,'multiline':False]['text':' If RHS2 is empty, we still have to copy RHS1','line_number':711,'multiline':False]['text':' Loop through, intersecting as we go, erasing elements when necessary.','line_number':715,'multiline':False]['text':' copy the remaining elements','line_number':735,'multiline':False]['text':' Return true if we share any bits in common with RHS','line_number':749,'multiline':False]['text':' Check if both bitmaps are empty.','line_number':754,'multiline':False]['text':' Loop through, intersecting stopping when we hit bits in common.','line_number':758,'multiline':False]['text':' Return true iff all bits set in this SparseBitVector are','line_number':777,'multiline':False]['text':' also set in RHS.','line_number':778,'multiline':False]['text':' Return the first set bit in the bitmap.  Return -1 if no bits are set.','line_number':785,'multiline':False]['text':' Return the last set bit in the bitmap.  Return -1 if no bits are set.','line_number':793,'multiline':False]['text':' Return true if the SparseBitVector is empty','line_number':801,'multiline':False]['text':' Convenience functions to allow Or and And without dereferencing in the user','line_number':824,'multiline':False]['text':' code.','line_number':825,'multiline':False]['text':' Convenience functions for infix union, intersection, difference operators.','line_number':855,'multiline':False]['text':' end namespace c10','line_number':902,'multiline':False]