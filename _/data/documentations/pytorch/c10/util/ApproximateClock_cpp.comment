['text':' Take a measurement on either side to avoid an ordering bias.','line_number':13,'multiline':False]['text':' `x + (y - x) / 2` is a more numerically stable average than `(x + y) / 2`.','line_number':22,'multiline':False]['text':' Compute the real time that passes for each tick of the approximate clock.','line_number':45,'multiline':False]['text':' We shift all times by `t0` for better numerics. Double precision only has','line_number':55,'multiline':False]['text':' 16 decimal digits of accuracy, so if we blindly multiply times by','line_number':56,'multiline':False]['text':' `scale_factor` we may suffer from precision loss. The choice of `t0` is','line_number':57,'multiline':False]['text':' mostly arbitrary; we just need a factor that is the correct order of','line_number':58,'multiline':False]['text':' magnitude to bring the intermediate values closer to zero. We are not,','line_number':59,'multiline':False]['text':' however, guaranteed that `t0_approx` is *exactly* the getApproximateTime','line_number':60,'multiline':False]['text':' equivalent of `t0`; it is only an estimate that we have to fine tune.','line_number':61,'multiline':False]['text':' NOLINT','line_number':69,'multiline':False]['text':' NOLINT','line_number':71,'multiline':False]['text':' See above for why this is more stable than `A * t_approx + B`.','line_number':74,'multiline':False]['text':' namespace c10','line_number':79,'multiline':False]