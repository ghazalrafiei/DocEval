['text':' Header file to define the common scaffolding for exported symbols.
 *
 * Export is by itself a quite tricky situation to deal with, and if you are
 * hitting this file, make sure you start with the background here:
 * - Linux: https://gcc.gnu.org/wiki/Visibility
 * - Windows:
 * https://docs.microsoft.com/en-us/cpp/cpp/dllexport-dllimport?view=vs-2017
 *
 * Do NOT include this file directly. Instead, use c10/macros/Macros.h
 ','line_number':4,'multiline':True]['text':' You do not need to edit this part of file unless you are changing the core','line_number':15,'multiline':False]['text':' pytorch export abstractions.','line_number':16,'multiline':False]['text':'','line_number':17,'multiline':False]['text':' This part defines the C10 core export and import macros. This is controlled','line_number':18,'multiline':False]['text':' by whether we are building shared libraries or not, which is determined','line_number':19,'multiline':False]['text':' during build time and codified in c10/core/cmake_macros.h.','line_number':20,'multiline':False]['text':' When the library is built as a shared lib, EXPORT and IMPORT will contain','line_number':21,'multiline':False]['text':' visibility attributes. If it is being built as a static lib, then EXPORT','line_number':22,'multiline':False]['text':' and IMPORT basically have no effect.','line_number':23,'multiline':False]['text':' As a rule of thumb, you should almost NEVER mix static and shared builds for','line_number':25,'multiline':False]['text':' libraries that depend on c10. AKA, if c10 is built as a static library, we','line_number':26,'multiline':False]['text':' recommend everything dependent on c10 to be built statically. If c10 is built','line_number':27,'multiline':False]['text':' as a shared library, everything dependent on it should be built as shared. In','line_number':28,'multiline':False]['text':' the PyTorch project, all native libraries shall use the macro','line_number':29,'multiline':False]['text':' C10_BUILD_SHARED_LIB to check whether pytorch is building shared or static','line_number':30,'multiline':False]['text':' libraries.','line_number':31,'multiline':False]['text':' For build systems that do not directly depend on CMake and directly build','line_number':33,'multiline':False]['text':' from the source directory (such as Buck), one may not have a cmake_macros.h','line_number':34,'multiline':False]['text':' file at all. In this case, the build system is responsible for providing','line_number':35,'multiline':False]['text':' correct macro definitions corresponding to the cmake_macros.h.in file.','line_number':36,'multiline':False]['text':'','line_number':37,'multiline':False]['text':' In such scenarios, one should define the macro','line_number':38,'multiline':False]['text':'     C10_USING_CUSTOM_GENERATED_MACROS','line_number':39,'multiline':False]['text':' to inform this header that it does not need to include the cmake_macros.h','line_number':40,'multiline':False]['text':' file.','line_number':41,'multiline':False]['text':' C10_USING_CUSTOM_GENERATED_MACROS','line_number':45,'multiline':False]['text':' _WIN32','line_number':56,'multiline':False]['text':' defined(__GNUC__)','line_number':60,'multiline':False]['text':' defined(__GNUC__)','line_number':63,'multiline':False]['text':' _WIN32','line_number':65,'multiline':False]['text':' Definition of an adaptive XX_API macro, that depends on whether you are','line_number':72,'multiline':False]['text':' building the library itself or not, routes to XX_EXPORT and XX_IMPORT.','line_number':73,'multiline':False]['text':' Basically, you will need to do this for each shared library that you are','line_number':74,'multiline':False]['text':' building, and the instruction is as follows: assuming that you are building','line_number':75,'multiline':False]['text':' a library called libawesome.so. You should:','line_number':76,'multiline':False]['text':' (1) for your cmake target (usually done by "add_library(awesome, ...)"),','line_number':77,'multiline':False]['text':'     define a macro called AWESOME_BUILD_MAIN_LIB using','line_number':78,'multiline':False]['text':'     target_compile_options.','line_number':79,'multiline':False]['text':' (2) define the AWESOME_API macro similar to the one below.','line_number':80,'multiline':False]['text':' And in the source file of your awesome library, use AWESOME_API to','line_number':81,'multiline':False]['text':' annotate public symbols.','line_number':82,'multiline':False]['text':' Here, for the C10 library, we will define the macro C10_API for both import','line_number':84,'multiline':False]['text':' and export.','line_number':85,'multiline':False]['text':' This one is being used by libc10.so','line_number':87,'multiline':False]['text':' This one is being used by libtorch.so','line_number':94,'multiline':False]['text':' You may be wondering: Whose brilliant idea was it to split torch_cuda into','line_number':101,'multiline':False]['text':' two pieces with confusing names?','line_number':102,'multiline':False]['text':' Once upon a time, there _was_ only TORCH_CUDA_API. All was happy until we','line_number':103,'multiline':False]['text':' tried to compile PyTorch for CUDA 11.1, which ran into relocation marker','line_number':104,'multiline':False]['text':' issues when linking big binaries.','line_number':105,'multiline':False]['text':' (https://github.com/pytorch/pytorch/issues/39968) We had two choices:','line_number':106,'multiline':False]['text':'    (1) Stop supporting so many GPU architectures','line_number':107,'multiline':False]['text':'    (2) Do something else','line_number':108,'multiline':False]['text':' We chose #2 and decided to split the behemoth that was torch_cuda into two','line_number':109,'multiline':False]['text':' smaller libraries, one with most of the core kernel functions (torch_cuda_cu)','line_number':110,'multiline':False]['text':' and the other that had..well..everything else (torch_cuda_cpp). The idea was','line_number':111,'multiline':False]['text':' this: instead of linking our static libraries (like the hefty','line_number':112,'multiline':False]['text':' libcudnn_static.a) with another huge library, torch_cuda, and run into pesky','line_number':113,'multiline':False]['text':' relocation marker issues, we could link our static libraries to a smaller','line_number':114,'multiline':False]['text':' part of torch_cuda (torch_cuda_cpp) and avoid the issues.','line_number':115,'multiline':False]['text':' libtorch_cuda_cu.so','line_number':117,'multiline':False]['text':' libtorch_cuda_cpp.so','line_number':124,'multiline':False]['text':' libtorch_cuda.so (where torch_cuda_cu and torch_cuda_cpp are a part of the','line_number':131,'multiline':False]['text':' same api)','line_number':132,'multiline':False]['text':' Enums only need to be exported on windows for non-CUDA files','line_number':147,'multiline':False]['text':' C10_MACROS_MACROS_H_','line_number':154,'multiline':False]