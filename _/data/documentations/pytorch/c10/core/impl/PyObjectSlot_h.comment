['text':' Associate the TensorImpl with the specified PyObject, and, if necessary,','line_number':21,'multiline':False]['text':' also tag the interpreter.','line_number':22,'multiline':False]['text':'','line_number':23,'multiline':False]['text':' NB: This lives in a header so that we can inline away the switch on status','line_number':24,'multiline':False]['text':'','line_number':25,'multiline':False]['text':' NB: THIS FUNCTION CAN RAISE AN EXCEPTION.  Make sure to clean up after','line_number':26,'multiline':False]['text':' PyObject if necessary!','line_number':27,'multiline':False]['text':' caller guarantees there is no multithreaded access; if there is','line_number':35,'multiline':False]['text':' no data race OK to do a relaxed store','line_number':36,'multiline':False]['text':' no tagging is necessary, the tag is already correct','line_number':40,'multiline':False]['text':' attempt to claim this TensorImpl with the specified interpreter','line_number':43,'multiline':False]['text':' tag','line_number':44,'multiline':False]['text':' test if, actually, it was already tagged by us!  this situation can't','line_number':49,'multiline':False]['text':' be caused by a race, but it could be caused by a situation','line_number':50,'multiline':False]['text':' where someone conservatively tagged the tensor as MAYBE_UNINITIALIZED','line_number':51,'multiline':False]['text':' (because they didn't pre-check the tag) when actually it was','line_number':52,'multiline':False]['text':' owned by the interpreter','line_number':53,'multiline':False]['text':' fallthrough, we lost the race.  We are guaranteed not to lose the','line_number':57,'multiline':False]['text':' race with ourself, as calls to init_pyobj with the same interpreter','line_number':58,'multiline':False]['text':' ID must be sequentialized by the GIL','line_number':59,'multiline':False]['text':' we are the ONLY thread that can have gotten to this point.  It is not','line_number':70,'multiline':False]['text':' possible to conflict with another zero interpreter as access is protected','line_number':71,'multiline':False]['text':' by GIL','line_number':72,'multiline':False]['text':' NB: owns_pyobj tag is initially false','line_number':73,'multiline':False]['text':' Query the PyObject interpreter.  This may return null if there is no','line_number':77,'multiline':False]['text':' interpreter.  This is racy!','line_number':78,'multiline':False]['text':' Test the interpreter tag.  If tagged for the current interpreter, return','line_number':83,'multiline':False]['text':' a non-nullopt (but possibly null) PyObject.  If (possibly) untagged,','line_number':84,'multiline':False]['text':' returns a nullopt.  If it is definitely invalid, raises an error.','line_number':85,'multiline':False]['text':'','line_number':86,'multiline':False]['text':' If `ignore_hermetic_tls` is false and this function is called from a','line_number':87,'multiline':False]['text':' hermetic context (ie, `HermeticPyObjectTLS::get_state()` is true), then','line_number':88,'multiline':False]['text':' nullopt is returned. If `ignore_hermetic_tls` is true, then the hermetic','line_number':89,'multiline':False]['text':' context is ignored, allowing you to check the interpreter tag of a','line_number':90,'multiline':False]['text':' nonhermetic PyObject from within a hermetic context. This is necessary','line_number':91,'multiline':False]['text':' because there are some cases where the deallocator function of a','line_number':92,'multiline':False]['text':' nonhermetic PyObject is called from within a hermetic context, so it must','line_number':93,'multiline':False]['text':' be properly treated as a nonhermetic PyObject.','line_number':94,'multiline':False]['text':'','line_number':95,'multiline':False]['text':' NB: this lives in header so that we can avoid actually creating the','line_number':96,'multiline':False]['text':' c10::optional','line_number':97,'multiline':False]['text':' Note [Memory ordering on Python interpreter tag]','line_number':101,'multiline':False]['text':' NB: This never returns DEFINITELY_UNINITIALIZED because there is','line_number':105,'multiline':False]['text':' always the possibility that another thread races to initialize','line_number':106,'multiline':False]['text':' after we query here.  The only time when we can conclude a tensor','line_number':107,'multiline':False]['text':' is definitely uninitialized is when we have just allocated it and','line_number':108,'multiline':False]['text':' it cannot have escaped to other threads yet','line_number':109,'multiline':False]['text':' NB: pyobj_ could still be null!','line_number':112,'multiline':False]['text':' Clear the PyObject field for an interpreter, in situations where we','line_number':128,'multiline':False]['text':' statically know the tensor is tagged with our interpreter.','line_number':129,'multiline':False]['text':' Check if the PyObjectSlot's interpreter is the same as the specified','line_number':134,'multiline':False]['text':' interpreter','line_number':135,'multiline':False]['text':' Check if the PyObjectSlot is holding a PyObject, owned or non-owned','line_number':138,'multiline':False]['text':' This field contains the interpreter tag for this object.  See','line_number':146,'multiline':False]['text':' Note [Python interpreter tag] for general context','line_number':147,'multiline':False]['text':'','line_number':148,'multiline':False]['text':' Note [Memory ordering on Python interpreter tag]','line_number':149,'multiline':False]['text':' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~','line_number':150,'multiline':False]['text':' What memory_order do we need when accessing this atomic?  We don't','line_number':151,'multiline':False]['text':' need a single total modification order (as provided by','line_number':152,'multiline':False]['text':' memory_order_seq_cst) as pyobj_interpreter_ is monotonic: it can only','line_number':153,'multiline':False]['text':' transition from -1 to some positive integer and never changes afterwards.','line_number':154,'multiline':False]['text':' Because there is only one modification, it trivially already has a total','line_number':155,'multiline':False]['text':' modification order (e.g., we don't need fences or locked instructions on','line_number':156,'multiline':False]['text':' x86)','line_number':157,'multiline':False]['text':'','line_number':158,'multiline':False]['text':' In fact, one could make a reasonable argument that relaxed reads are OK,','line_number':159,'multiline':False]['text':' due to the presence of external locking (GIL) to ensure that interactions','line_number':160,'multiline':False]['text':' with other data structures are still correctly synchronized, so that','line_number':161,'multiline':False]['text':' we fall in the "Single-Location Data Structures" case as described in','line_number':162,'multiline':False]['text':' http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2055r0.pdf','line_number':163,'multiline':False]['text':' However, on x86, it doesn't matter if I use acquire or relaxed on the load','line_number':164,'multiline':False]['text':' as I get the same assembly in both cases.  So I just use the more','line_number':165,'multiline':False]['text':' conservative acquire (which will impede compiler optimizations but I don't','line_number':166,'multiline':False]['text':' care)','line_number':167,'multiline':False]['text':' This field contains a reference to a PyObject representing this Tensor.','line_number':170,'multiline':False]['text':' If pyobj is nullptr, when we transfer Tensor to Python, we allocate a new','line_number':171,'multiline':False]['text':' PyObject for it and set this field.  This field does not have to be','line_number':172,'multiline':False]['text':' protected by an atomic as it is only allowed to be accessed when you hold','line_number':173,'multiline':False]['text':' the GIL, or during destruction of the tensor.','line_number':174,'multiline':False]['text':'','line_number':175,'multiline':False]['text':' When a PyObject dies, you are obligated to clear this field','line_number':176,'multiline':False]['text':' (otherwise, you will try to use-after-free the pyobj); this currently','line_number':177,'multiline':False]['text':' occurs in THPVariable_clear in torch/csrc/autograd/python_variable.cpp','line_number':178,'multiline':False]['text':'','line_number':179,'multiline':False]['text':' NB: Ordinarily, this should not be a strong reference, as if the','line_number':180,'multiline':False]['text':' PyObject owns the Tensor, this would create a reference cycle.','line_number':181,'multiline':False]['text':' However, sometimes this ownership flips.  To track who owns','line_number':182,'multiline':False]['text':' who, this has a single pointer tag indicating whether or not the','line_number':183,'multiline':False]['text':' C++ object owns the PyObject (the common case, zero, means PyObject','line_number':184,'multiline':False]['text':' owns the C++ object); see _unchecked_untagged_pyobj for raw access','line_number':185,'multiline':False]['text':' or check_pyobj for checked access.  See references to PyObject','line_number':186,'multiline':False]['text':' resurrection in torch/csrc/autograd/python_variable.cpp','line_number':187,'multiline':False]['text':' namespace impl','line_number':191,'multiline':False]['text':' namespace c10','line_number':192,'multiline':False]