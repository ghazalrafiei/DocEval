['text':' This TLS controls whether or not we permanently associate PyObject','line_number':9,'multiline':False]['text':' with Tensor the first time it is allocated.  When hermetic PyObject','line_number':10,'multiline':False]['text':' TLS is enabled (state is true), we DO NOT save PyObjects to Tensor,','line_number':11,'multiline':False]['text':' meaning you get a distinct PyObject whenever you execute the code in','line_number':12,'multiline':False]['text':' question.','line_number':13,'multiline':False]['text':' Hypothetical fastpath if torchdeploy/multipy isn't used.  Per','line_number':17,'multiline':False]['text':' https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2055r0.pdf','line_number':18,'multiline':False]['text':' this qualifies relaxed access because it is a single-location data','line_number':19,'multiline':False]['text':' structure (only the boolean here).','line_number':20,'multiline':False]['text':'','line_number':21,'multiline':False]['text':' Forgetting about data races for a moment, is there a logical race?','line_number':22,'multiline':False]['text':'','line_number':23,'multiline':False]['text':'  - Boolean only ever transitions from false to true.  So the','line_number':24,'multiline':False]['text':'    critical situation is when one interpreter is already running','line_number':25,'multiline':False]['text':'    when a second interpreter switches haveState from false to true.','line_number':26,'multiline':False]['text':'','line_number':27,'multiline':False]['text':'  - The first interpreter is indifferent whether or not it sees','line_number':28,'multiline':False]['text':'    hasState true/false; obviously false works (this is what the','line_number':29,'multiline':False]['text':'    interpreter was previously using; more directly, the interpreter','line_number':30,'multiline':False]['text':'    calls into itself as the handler, so being hermetic is not','line_number':31,'multiline':False]['text':'    required), and true simply means serviced python operator calls will','line_number':32,'multiline':False]['text':'    be hermetic; in these cases it is expected to be functionally','line_number':33,'multiline':False]['text':'    equivalent.','line_number':34,'multiline':False]['text':'','line_number':35,'multiline':False]['text':'  - The second interpreter MUST see hasState true (as its requests will','line_number':36,'multiline':False]['text':'    be forwarded to the first interpreter), but it is assumed that there','line_number':37,'multiline':False]['text':'    is a synchronization between the interpreter initialization, and','line_number':38,'multiline':False]['text':'    when we actually perform operations, so it is guaranteed to see','line_number':39,'multiline':False]['text':'    hasState true.','line_number':40,'multiline':False]['text':'','line_number':41,'multiline':False]['text':' QED.','line_number':42,'multiline':False]['text':'','line_number':43,'multiline':False]['text':' This fastpath is currently disabled so that we can more easily test that','line_number':44,'multiline':False]['text':' hermetic mode works correctly even on stock build of PyTorch.','line_number':45,'multiline':False]['text':' Call this from the multipy/torchdeploy top level','line_number':50,'multiline':False]['text':' This only flipped once from false to true during torchdeploy/multipy','line_number':54,'multiline':False]['text':' initialization, and never again.','line_number':55,'multiline':False]['text':' namespace impl','line_number':60,'multiline':False]['text':' namespace c10','line_number':61,'multiline':False]