['text':' Packed container for TensorImpl sizes and strides.','line_number':15,'multiline':False]['text':' This design improves on the previous approach of using a pair of','line_number':16,'multiline':False]['text':' c10::SmallVector<int64_t, 5> by specializing for the operations we','line_number':17,'multiline':False]['text':' actually use and enforcing that the number of sizes is the same as','line_number':18,'multiline':False]['text':' the number of strides. The memory layout is as follows:','line_number':19,'multiline':False]['text':'','line_number':20,'multiline':False]['text':' 1 size_t for the size','line_number':21,'multiline':False]['text':' 5 eightbytes of inline sizes and 5 eightbytes of inline strides, OR pointer','line_number':22,'multiline':False]['text':' to out-of-line array','line_number':23,'multiline':False]['text':' TODO: different iterator types for sizes & strides to prevent','line_number':26,'multiline':False]['text':' mixing the two accidentally.','line_number':27,'multiline':False]['text':' Move from rhs. rhs.size() == 0 afterwards.','line_number':74,'multiline':False]['text':' Move from rhs. rhs.size() == 0 afterwards.','line_number':86,'multiline':False]['text':' They're outline. We're going to steal their vector.','line_number':97,'multiline':False]['text':' Size accessors.','line_number':204,'multiline':False]['text':' Size accessors.','line_number':223,'multiline':False]['text':' namespace impl','line_number':307,'multiline':False]['text':' namespace c10','line_number':308,'multiline':False]