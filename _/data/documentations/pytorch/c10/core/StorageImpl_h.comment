['text':' A storage represents the underlying backing data buffer for a','line_number':11,'multiline':False]['text':' tensor.  This concept was inherited from the original Torch7','line_number':12,'multiline':False]['text':' codebase; we'd kind of like to get rid of the concept','line_number':13,'multiline':False]['text':' (see https://github.com/pytorch/pytorch/issues/14797) but','line_number':14,'multiline':False]['text':' it's hard work and no one has gotten around to doing it.','line_number':15,'multiline':False]['text':'','line_number':16,'multiline':False]['text':' NB: storage is supposed to uniquely own a data pointer; e.g.,','line_number':17,'multiline':False]['text':' two non-null data pointers alias if and only if they are from','line_number':18,'multiline':False]['text':' the same storage.  Technically you can violate this invariant','line_number':19,'multiline':False]['text':' (e.g., you can create a non-owning StorageImpl with at::from_blob)','line_number':20,'multiline':False]['text':' but a lot of things won't work correctly, including:','line_number':21,'multiline':False]['text':'','line_number':22,'multiline':False]['text':' - An ordinary deleter on such a storage is wrong, because normal deleters','line_number':23,'multiline':False]['text':'   assume unique ownership, but if you have two storages at the same data,','line_number':24,'multiline':False]['text':'   that implies there is some sort of shared ownership. So your deleter would','line_number':25,'multiline':False]['text':'   have to actually be internally doing some sort of refcount thing','line_number':26,'multiline':False]['text':' - Deepcopy in Python side relies on storage equality and not data pointer','line_number':27,'multiline':False]['text':'   equality; so if there are two separate storages pointing to the same data,','line_number':28,'multiline':False]['text':'   the data will actually get duplicated in that case (one data ptr before,','line_number':29,'multiline':False]['text':'   two data ptrs after)','line_number':30,'multiline':False]['text':' - Version counts won't work correctly, because we do all VC tracking at the','line_number':31,'multiline':False]['text':'   level of storages (unless you explicitly disconnect the VC with detach);','line_number':32,'multiline':False]['text':'   mutation because data pointers are the same are totally untracked','line_number':33,'multiline':False]['text':'use_byte_size','line_number':39,'multiline':True]['text':'use_byte_size','line_number':57,'multiline':True]['text':' Destructor doesn't call release_resources because it's','line_number':83,'multiline':False]['text':' unnecessary; don't forget to change that if needed!','line_number':84,'multiline':False]['text':' OK to do this instead of maybe_as_int as nbytes is guaranteed positive','line_number':90,'multiline':False]['text':' TODO: remove later','line_number':99,'multiline':False]['text':' Returns the previous data_ptr','line_number':121,'multiline':False]['text':' You generally shouldn't use this method, but it is occasionally','line_number':152,'multiline':False]['text':' useful if you want to override how a tensor will be reallocated,','line_number':153,'multiline':False]['text':' after it was already allocated (and its initial allocator was','line_number':154,'multiline':False]['text':' set)','line_number':155,'multiline':False]['text':' We need an allocator to be resizable','line_number':166,'multiline':False]['text':'*
   * Can only be called when use_count is 1
   ','line_number':172,'multiline':True]['text':'*
   * Can only be called when use_count is 1
   ','line_number':183,'multiline':True]['text':' This method can be used only after storage construction and cannot be used','line_number':196,'multiline':False]['text':' to modify storage status','line_number':197,'multiline':False]['text':' Identifies that Storage was received from another process and doesn't have','line_number':219,'multiline':False]['text':' local to process cuda memory allocation','line_number':220,'multiline':False]['text':' Declare StorageImpl create function pointer types.','line_number':226,'multiline':False]['text':' namespace c10','line_number':237,'multiline':False]