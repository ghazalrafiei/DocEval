['text':' two blocks dont overlap if','line_number':34,'multiline':False]['text':' |---a--------|--------------b--------|','line_number':35,'multiline':False]['text':' strat_a     end_a <= start_b       end_b','line_number':36,'multiline':False]['text':' Skip allocations not managed by AllocationPlan','line_number':47,'multiline':False]['text':' If observed allocation are freed outside the scope of','line_number':91,'multiline':False]['text':' observation, then allocations are not managed by the','line_number':92,'multiline':False]['text':' AllocationPlan.','line_number':93,'multiline':False]['text':' Step 1. Construct all allocation/free events.','line_number':113,'multiline':False]['text':'         Sort these events by timestamp.','line_number':114,'multiline':False]['text':' Step 2. Iterate through all events.','line_number':115,'multiline':False]['text':'  2.1 If allocate event:','line_number':116,'multiline':False]['text':'      Find all candidate in free_size_to_offset map','line_number':117,'multiline':False]['text':'      Greedily pick the first one.','line_number':118,'multiline':False]['text':'      Remove the entry from free_size_to_offset map.','line_number':119,'multiline':False]['text':'      new_offset = offset + request_size','line_number':120,'multiline':False]['text':'      new_size = size - request_size','line_number':121,'multiline':False]['text':'      Add new entry to both maps','line_number':122,'multiline':False]['text':'  2.2 If free event.','line_number':123,'multiline':False]['text':'      Check if the returned offset merges with another chunk.','line_number':124,'multiline':False]['text':'      If so merge until no more merging is possible.','line_number':125,'multiline':False]['text':'      If returned offset does not merge, then','line_number':126,'multiline':False]['text':'      just return it as a chunk.','line_number':127,'multiline':False]['text':' lower_bound on this map will get all candidates of','line_number':129,'multiline':False]['text':' the right size for allocation.','line_number':130,'multiline':False]['text':' This provides fast lookup when we want to insert freed block','line_number':132,'multiline':False]['text':' back, especially when we want to merge blocks.','line_number':133,'multiline':False]['text':' Upon free end_ptr = offset + size','line_number':138,'multiline':False]['text':' If end_ptr exists merge freed allocation','line_number':139,'multiline':False]['text':' Also find corresponding offset in size_to_offset','line_number':140,'multiline':False]['text':' Remove that entry and update with new size and offset','line_number':141,'multiline':False]['text':' If end_ptr does not exist then just insert offset,size','line_number':142,'multiline':False]['text':' in map and correspondingly size, offset in the other map.','line_number':143,'multiline':False]['text':' Merging should always be done recursively until no more chunks','line_number':144,'multiline':False]['text':' that can be found.','line_number':145,'multiline':False]['text':' After last free we should have only one entry left in these maps.','line_number':146,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':154,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':156,'multiline':False]['text':' If there is no contiguous block of the size requested','line_number':161,'multiline':False]['text':' allocate a new one.','line_number':162,'multiline':False]['text':' If we have found a block of the size we want','line_number':166,'multiline':False]['text':' 1. change the block by allocating out of it.','line_number':167,'multiline':False]['text':'    1.1 Erase the entire block','line_number':168,'multiline':False]['text':'    1.2 Erase the reverse map entries','line_number':169,'multiline':False]['text':' 2. If block still has space left insert the remainder back in map.','line_number':170,'multiline':False]['text':'    Including reverse map entries.','line_number':171,'multiline':False]['text':' 1. Check if freed block is adjacent to an existing free block','line_number':186,'multiline':False]['text':'    at its end boundary. This is done by checking','line_number':187,'multiline':False]['text':'    free_end_offset_to_size_iter.','line_number':188,'multiline':False]['text':'    If we find such a block, remove it and adjust size of','line_number':189,'multiline':False]['text':'    the block being freed.','line_number':190,'multiline':False]['text':' 2. Similarly check if freed block is adjacent to an existing','line_number':191,'multiline':False]['text':'    free block at start boundary. This is done by checking','line_number':192,'multiline':False]['text':'    free_start_offset_to_size_iter.','line_number':193,'multiline':False]['text':'    If we find such a block, remove it and adjust size of','line_number':194,'multiline':False]['text':'    the block being freed.','line_number':195,'multiline':False]['text':' 3. Insert the freed block in map.','line_number':196,'multiline':False]['text':' Merge when another free block exist at the end of this block','line_number':200,'multiline':False]['text':' If the block is being merged then also remove it from','line_number':208,'multiline':False]['text':' free_end_offset_to_size_iter','line_number':209,'multiline':False]['text':' Merge when freed block exist at the end of another free block','line_number':212,'multiline':False]['text':' If the block is being merged then also remove it from','line_number':221,'multiline':False]['text':' free_start_offset_to_size_iter','line_number':222,'multiline':False]['text':' namespace','line_number':238,'multiline':False]['text':' Free being recorded was allocated outside of WithProfileAllocationGuard','line_number':267,'multiline':False]['text':' Allocation that was made outside the validation scope is being freed here','line_number':303,'multiline':False]['text':' Free existing memory and reallocate for larger size.','line_number':342,'multiline':False]['text':' This allocation is not managed by ProfilingAllocator.','line_number':361,'multiline':False]['text':' Either','line_number':375,'multiline':False]['text':' 1. Allocation that was made outside the validation scope is being freed','line_number':376,'multiline':False]['text':' here or','line_number':377,'multiline':False]['text':' 2. Allocation that is not managed by profiling allocator is being freed.','line_number':378,'multiline':False]['text':'    Example of the second type','line_number':379,'multiline':False]['text':'    Tensor out;','line_number':380,'multiline':False]['text':'    for (....) {','line_number':381,'multiline':False]['text':'      {','line_number':382,'multiline':False]['text':'        CPUProfilingAllocator','line_number':383,'multiline':False]['text':'        out = ...some op (This also frees previous memory held by out)','line_number':384,'multiline':False]['text':'      }','line_number':385,'multiline':False]['text':'      out is used..','line_number':386,'multiline':False]['text':'    }','line_number':387,'multiline':False]['text':' Nesting of allocation profiling does not seem meaningful.','line_number':411,'multiline':False]['text':' Nesting of allocation profiling does not seem meaningful.','line_number':428,'multiline':False]['text':' Nesting of profiling allocator is not supported.','line_number':449,'multiline':False]['text':' namespace c10','line_number':466,'multiline':False]