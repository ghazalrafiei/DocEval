['text':' Owner(s): ["module: functionalization"]','line_number':1,'multiline':False]['text':' Basic test: the out-of-place add() call should be converted','line_number':16,'multiline':False]['text':' into add_()','line_number':17,'multiline':False]['text':' We shouldn't re-inplace the first add(), because an alias of a is re-used later in the program','line_number':43,'multiline':False]['text':' Second add() is fine to re-inplace','line_number':45,'multiline':False]['text':' Naively, we shouldn't try to inplace the .ge() call,','line_number':70,'multiline':False]['text':' because that would require resizing "b" (from a float to a bool tensor).','line_number':71,'multiline':False]['text':' The .ge() should not be reinplaced.','line_number':79,'multiline':False]['text':' Can't reinplace because b has overlapping memory.','line_number':95,'multiline':False]['text':' This test won't actually run in CI, because it requires functionalize() from functorch.','line_number':114,'multiline':False]['text':' I'm planning on testing more comprehensively with torchbench models,','line_number':115,'multiline':False]['text':' but we can make this testing better once functorch moves into pytorch/pytorch.','line_number':116,'multiline':False]['text':' for now, don't test mutations to inputs','line_number':119,'multiline':False]['text':' NOTE: one slight pessimization here is the fact that','line_number':135,'multiline':False]['text':' there are a bunch of redundant views in the graph.','line_number':136,'multiline':False]['text':' Technically, half of these views are duplicates that we could de-dup.','line_number':137,'multiline':False]['text':' This shouldn't really hurt performance though, since creating an extra view','line_number':138,'multiline':False]['text':' is effectively just moving some metadata around (and allocating a new TensorImpl).','line_number':139,'multiline':False]['text':' We can/should update the pass in the future to clean this up.','line_number':140,'multiline':False]['text':' for now, don't test mutations to inputs','line_number':166,'multiline':False]['text':' good_mirror_of_b points to the same region of memory as b.','line_number':206,'multiline':False]['text':' and this scatter op below tries to scatter c_updated into the same region','line_number':207,'multiline':False]['text':' that c currently takes up.','line_number':208,'multiline':False]['text':' reinplacing logic checks this by confirming that:','line_number':209,'multiline':False]['text':'   c_updated','line_number':210,'multiline':False]['text':'   good_mirror_of_b.select(0, 1)','line_number':211,'multiline':False]['text':' have the same size/stride/storage_offset.','line_number':212,'multiline':False]['text':' Test example where we have a scatter op, where the base tensor','line_number':235,'multiline':False]['text':' has the same size/stride/storage offset (even though it is a different view),','line_number':236,'multiline':False]['text':' making it valid to re-inplace','line_number':237,'multiline':False]['text':' The first arg to select_scatter is an equivalent view to b.','line_number':245,'multiline':False]['text':' However, the select_scatter call below tries to put c_updated','line_number':246,'multiline':False]['text':' into a different slice of "b" than what "c" currently occupies.','line_number':247,'multiline':False]['text':'','line_number':248,'multiline':False]['text':' noqa: B950','line_number':271,'multiline':False]['text':' The first arg to select_scatter points to a different than c's base.','line_number':280,'multiline':False]['text':' This makes it invalid to re-inplace.','line_number':281,'multiline':False]['text':' self.assertEqual(actual_out, expected_out)','line_number':289,'multiline':False]['text':' noqa: B950','line_number':304,'multiline':False]['text':' reinplace needs to know to replace output [z] with [x]','line_number':313,'multiline':False]