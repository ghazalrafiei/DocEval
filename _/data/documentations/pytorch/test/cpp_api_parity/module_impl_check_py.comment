['text':' The purpose of this test is to check that we have implementation parity between','line_number':1,'multiline':False]['text':' a Python `torch.nn` module and its corresponding C++ `torch::nn` module. Concretely,','line_number':2,'multiline':False]['text':' this test does the following:','line_number':3,'multiline':False]['text':'','line_number':4,'multiline':False]['text':' 1. Get a test params dict from common_nn.py, run forward and backward on the','line_number':5,'multiline':False]['text':' Python module created using the test params.','line_number':6,'multiline':False]['text':'','line_number':7,'multiline':False]['text':' 2. Serialize the Python module's parameters / buffers and its forward input','line_number':8,'multiline':False]['text':' arguments, deserialize them in C++ and load them into the C++ module.','line_number':9,'multiline':False]['text':'','line_number':10,'multiline':False]['text':' 3. Run the same forward and backward passes on the C++ module, and serialize','line_number':11,'multiline':False]['text':' the C++ module's forward output and backward gradients.','line_number':12,'multiline':False]['text':'','line_number':13,'multiline':False]['text':' 4. Compare Python/C++ module's forward output and backward gradients. If they','line_number':14,'multiline':False]['text':' are the same, then we have implementation parity between Python/C++ module.','line_number':15,'multiline':False]['text':' Expected substitutions:','line_number':31,'multiline':False]['text':'','line_number':32,'multiline':False]['text':' ${module_variant_name}  (e.g. `Linear_no_bias_cpu`)','line_number':33,'multiline':False]['text':' ${module_qualified_name}  (e.g. `torch::nn::Linear`)','line_number':34,'multiline':False]['text':' ${cpp_args_construction_stmts}','line_number':35,'multiline':False]['text':' ${cpp_constructor_args}','line_number':36,'multiline':False]['text':' ${device}','line_number':37,'multiline':False]['text':' ${cpp_forward_args_symbols}','line_number':38,'multiline':False]['text':' Some modules (such as `RReLU`) create random tensors in their forward pass.','line_number':101,'multiline':False]['text':' To make sure the random tensors created are the same in Python/C++, we need','line_number':102,'multiline':False]['text':' to set the RNG seed manually.','line_number':103,'multiline':False]['text':' Forward pass','line_number':106,'multiline':False]['text':' NOTE: This is a workaround to allow any module to be traced.','line_number':109,'multiline':False]['text':' We can do this because we are only interested in transferring','line_number':110,'multiline':False]['text':' the Python module's parameters and buffers to the C++ module.','line_number':111,'multiline':False]['text':' Backward pass','line_number':115,'multiline':False]['text':' Put all gradients into a dict, to be compared later','line_number':121,'multiline':False]['text':' Remove the temporary folder if it exists already','line_number':136,'multiline':False]['text':' Run forward and backward on Python module','line_number':140,'multiline':False]['text':' Save Python module and arguments to be used from C++ function','line_number':143,'multiline':False]['text':' Check that forward outputs are equal','line_number':160,'multiline':False]['text':' Check that module parameter gradients are equal after backward pass','line_number':164,'multiline':False]['text':' Remove temporary folder that stores C++ outputs','line_number':190,'multiline':False]['text':' Example output: `BCELoss_weights_cuda`','line_number':206,'multiline':False]['text':' Build all C++ tests together, instead of once per test.','line_number':290,'multiline':False]