['text':' FIXME: adding value comparison is slow','line_number':15,'multiline':False]['text':' FIXME: adding value comparison is slow','line_number':24,'multiline':False]['text':' FIXME: it's vA < vB because the sorting order for V (aka','line_number':25,'multiline':False]['text':' indices) is different in our use case','line_number':26,'multiline':False]['text':' Per-warp heap structure in shared memory:','line_number':39,'multiline':False]['text':' [key_0, ..., key_(HeapSize-2)], [empty element] (warp 0)','line_number':40,'multiline':False]['text':' ...','line_number':41,'multiline':False]['text':' [key_0, ..., key_(HeapSize-2)], [empty element] (warp n-1)','line_number':42,'multiline':False]['text':' [value_0, ..., value_(HeapSize-2)], [empty element] (warp 0)','line_number':43,'multiline':False]['text':' ...','line_number':44,'multiline':False]['text':' [value_0, ..., value_(HeapSize-2)], [empty element] (warp n-1)','line_number':45,'multiline':False]['text':' Dir == true means we are selecting the largest values, thus','line_number':47,'multiline':False]['text':' the heap is a min-heap','line_number':48,'multiline':False]['text':' Replace head if we are < head','line_number':51,'multiline':False]['text':' Even though this is the single-thread case, another preceding','line_number':54,'multiline':False]['text':' thread in the warp may have inserted in a new element that','line_number':55,'multiline':False]['text':' supersedes our element and thus our attempt at an insert would do','line_number':56,'multiline':False]['text':' nothing.','line_number':57,'multiline':False]['text':' Swap with head if valid','line_number':62,'multiline':False]['text':' The number of interior nodes in the heap is log2(HeapSize / 2):','line_number':69,'multiline':False]['text':' heap size 8 means there are 7 elements in the heap, indices 0-6','line_number':70,'multiline':False]['text':' (0 12 3456)','line_number':71,'multiline':False]['text':' log2(8 / 2) = 2 levels of interior nodes for heap size 8 (0 and 12)','line_number':72,'multiline':False]['text':' What child might we want to swap with (max heap = larger child;','line_number':83,'multiline':False]['text':' min heap = smaller child)','line_number':84,'multiline':False]['text':' If we're bigger than both children (max heap), or smaller than','line_number':89,'multiline':False]['text':' both children (min heap), then we do nothing for the rest of','line_number':90,'multiline':False]['text':' the iterations','line_number':91,'multiline':False]['text':' Swap with childToSwap if still valid','line_number':95,'multiline':False]['text':' This is our new element to potentially downheap','line_number':104,'multiline':False]['text':' All threads in the warp have elements','line_number':113,'multiline':False]['text':' Find out all the lanes that have elements to add to the heap','line_number':116,'multiline':False]['text':' Everything the warp has is smaller than our heap','line_number':121,'multiline':False]['text':' Otherwise, we want to serialize execution of the threads','line_number':125,'multiline':False]['text':' that have elements','line_number':126,'multiline':False]['text':' Everything the warp has is smaller than our heap','line_number':133,'multiline':False]['text':' Otherwise, we want to serialize execution of the threads','line_number':137,'multiline':False]['text':' that have elements','line_number':138,'multiline':False]['text':' _USE_ROCM','line_number':141,'multiline':False]['text':' FIXME: try switch statement and explicitly handle cases','line_number':143,'multiline':False]['text':' FIXME: how do cases work?','line_number':144,'multiline':False]['text':' Insert into our heap','line_number':147,'multiline':False]['text':' Make sure all smem writes are visible','line_number':150,'multiline':False]['text':' Re-broadcast the new heap head','line_number':155,'multiline':False]['text':' FIXME: consider each updater above will broadcast its value with','line_number':156,'multiline':False]['text':' a shuffle instead?','line_number':157,'multiline':False]['text':' Returns a pointer to the start of our block-wide key storage','line_number':195,'multiline':False]['text':' Returns a pointer to the start of our block-wide value storage','line_number':200,'multiline':False]['text':' Returns a pointer past the end of our block-wide heap storage','line_number':206,'multiline':False]['text':' Reduce all per-warp heaps to a unified, sorted list','line_number':216,'multiline':False]['text':' m x n','line_number':244,'multiline':False]['text':' m x k','line_number':245,'multiline':False]['text':' m x k','line_number':246,'multiline':False]['text':' FIXME choose desired unroll level','line_number':259,'multiline':False]['text':' When finished, we restructure the heaps in shared memory','line_number':279,'multiline':False]['text':' The heaps are actually of size HeapSize - 1 (e.g., 32 -> 31); the','line_number':280,'multiline':False]['text':' extra element should have remained untouched, so we can still','line_number':281,'multiline':False]['text':' sort things in-place as a power of 2.','line_number':282,'multiline':False]['text':' Write out the final k-selected values; they should be all','line_number':293,'multiline':False]['text':' together','line_number':294,'multiline':False]['text':' namespace caffe2','line_number':301,'multiline':False]['text':' CAFFE2_OPERATORS_TOP_K_HEAP_SELECTION_H_','line_number':303,'multiline':False]