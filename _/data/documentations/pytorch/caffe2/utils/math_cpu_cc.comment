['text':' Implements the math functions for CPU.','line_number':1,'multiline':False]['text':' The implementation in this file allows us to route the underlying numerical','line_number':2,'multiline':False]['text':' computation library to different backends. Notably:','line_number':3,'multiline':False]['text':' (1) For all BLAS-related functions, one can explicitly request a BLAS backend','line_number':4,'multiline':False]['text':'     such as MKL, openblas or Atlas. To see the set of supported backends','line_number':5,'multiline':False]['text':'     currently provided, check //third_party/blas/.','line_number':6,'multiline':False]['text':' (2) If one chooses to link against MKL, we utilize MKL's vector math library','line_number':7,'multiline':False]['text':'     (VML) for a few functions such as Exp and Log.','line_number':8,'multiline':False]['text':' (3) Fallback implementations are provided in Eigen for cross-platform','line_number':9,'multiline':False]['text':'     support. Since Eigen is a header-only library and supports a number of','line_number':10,'multiline':False]['text':'     platforms, it allows one to quickly port Caffe2 to different platforms','line_number':11,'multiline':False]['text':'     where BLAS may not be present.','line_number':12,'multiline':False]['text':' CAFFE2_USE_MKL','line_number':42,'multiline':False]['text':' CAFFE2_USE_HPTT','line_number':46,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////','line_number':56,'multiline':False]['text':' BLAS alternatives.','line_number':57,'multiline':False]['text':' Depending on whether we have specified an external BLAS library or not, we','line_number':58,'multiline':False]['text':' will delegate the Caffe math functions that are BLAS-related to either the','line_number':59,'multiline':False]['text':' CBLAS call or the Eigen implementation.','line_number':60,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////','line_number':61,'multiline':False]['text':' Caffe2 gemm provides a simpler interface to the gemm functions, with the','line_number':64,'multiline':False]['text':' limitation that the data has to be contiguous in memory.','line_number':65,'multiline':False]['text':'','line_number':66,'multiline':False]['text':' The gemm call implements the following operation:','line_number':67,'multiline':False]['text':'','line_number':68,'multiline':False]['text':'                  C = alpha * op(A) * op(B) + beta * C','line_number':69,'multiline':False]['text':'','line_number':70,'multiline':False]['text':' where op(A) has size M x K, op(B) has size K x N, and C has size M x N. Each','line_number':71,'multiline':False]['text':' of A, B, and C are matrices and alpha and beta are scalars. Note that the','line_number':72,'multiline':False]['text':' most common use case of gemm will involve setting alpha to 1 and beta to 0.','line_number':73,'multiline':False]['text':'','line_number':74,'multiline':False]['text':' op(A) and op(B) represent the transformations that are done to A and B before','line_number':75,'multiline':False]['text':' the matrix multiply; depending on the flags set, op(A) is equal to A or A^T','line_number':76,'multiline':False]['text':' (transpose) if the argument TransA or TransB is set to CblasNoTrans or','line_number':77,'multiline':False]['text':' CblasTrans, respectively, for each of A and B.','line_number':78,'multiline':False]['text':' The line above calls `abort()`. Should never reach here.','line_number':114,'multiline':False]['text':' The line above calls `abort()`. Should never reach here.','line_number':131,'multiline':False]['text':' The line above calls `abort()`. Should never reach here.','line_number':181,'multiline':False]['text':' The line above calls `abort()`. Should never reach here.','line_number':205,'multiline':False]['text':' In Caffe2 we often do a lazy initialization, which may contain NaNs in','line_number':227,'multiline':False]['text':' the float values. As a result, if beta is 0, we explicitly do a setzero.','line_number':228,'multiline':False]['text':' CAFFE2_USE_EIGEN_FOR_BLAS','line_number':260,'multiline':False]['text':'context','line_number':274,'multiline':True]['text':'math_type','line_number':275,'multiline':True]['text':' MKL expects ld? >= 1','line_number':276,'multiline':False]['text':'context','line_number':311,'multiline':True]['text':'context','line_number':339,'multiline':True]['text':'math_type','line_number':340,'multiline':True]['text':' CAFFE2_USE_EIGEN_FOR_BLAS','line_number':353,'multiline':False]['text':' math_type ','line_number':369,'multiline':True]['text':' MKL expects ld? >= 1','line_number':372,'multiline':False]['text':' CAFFE2_USE_MKL','line_number':393,'multiline':False]['text':' loop over matrices in the batch','line_number':394,'multiline':False]['text':' CAFFE2_USE_MKL','line_number':399,'multiline':False]['text':' math_type ','line_number':419,'multiline':True]['text':' MKL expects ld? >= 1','line_number':422,'multiline':False]['text':' CAFFE2_USE_MKL','line_number':451,'multiline':False]['text':' loop over matrices in the batch','line_number':452,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////','line_number':463,'multiline':False]['text':' Common math functions being used in Caffe that do not have a BLAS or MKL','line_number':464,'multiline':False]['text':' equivalent. For all these functions, we will simply implement them either via','line_number':465,'multiline':False]['text':' Eigen or via custom code.','line_number':466,'multiline':False]['text':'//////////////////////////////////////////////////////////////////////////////','line_number':467,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':493,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':496,'multiline':False]['text':' namespace','line_number':518,'multiline':False]['text':' The actual implementation uses eigen which is column major, so notice the','line_number':585,'multiline':False]['text':' row/column swap in the actual implementation.','line_number':586,'multiline':False]['text':'context','line_number':754,'multiline':True]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':830,'multiline':False]['text':' namespace','line_number':840,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':893,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':895,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':897,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':899,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':901,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':903,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':908,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':910,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':912,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':920,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':922,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':924,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':954,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':956,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1064,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1066,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1068,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1070,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1072,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1074,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1085,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1087,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1089,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1091,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1096,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1098,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1100,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1108,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1110,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1112,'multiline':False]['text':' incrementIfNotMax increments the number if the value is not max for that','line_number':1120,'multiline':False]['text':' datatype. This ensures that the value never overflows.','line_number':1121,'multiline':False]['text':' namespace','line_number':1129,'multiline':False]['text':' This is not uniformly distributed between a and b.','line_number':1179,'multiline':False]['text':' It takes advantage of normal distribution to generate numbers','line_number':1180,'multiline':False]['text':' with mean = sum / n.','line_number':1181,'multiline':False]['text':' Ideally the algorithm should be generating n numbers between 0 and 1,','line_number':1182,'multiline':False]['text':' sum them up as scaled_sum, and use sum / scaled_sum to adjust the values','line_number':1183,'multiline':False]['text':' to between a and b.','line_number':1184,'multiline':False]['text':' The algorithm is non-trivial given the adjustment would be different towards','line_number':1185,'multiline':False]['text':' each value.','line_number':1186,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare,bugprone-integer-division)','line_number':1226,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare,bugprone-integer-division)','line_number':1228,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare,bugprone-integer-division)','line_number':1230,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare,bugprone-integer-division)','line_number':1232,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-integer-division)','line_number':1234,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-integer-division)','line_number':1236,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-integer-division)','line_number':1238,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-integer-division)','line_number':1240,'multiline':False]['text':' Description:
     Inverse Transform Sampling method to generate values for random variable X
     that is described by the cumulative distribution F (cum_val,cum_dis).
     Notice, that we may choose to use the inverse map of F (cum_map) as an
     approximation to avoid searching. Also, scaling the probability so that
     the values are within max_i refs, because stack distance can not be >
     than the # of already generated refs (max_i).
  ','line_number':1252,'multiline':True]['text':' generate a random number u in [0,1] from a uniform distribution U','line_number':1263,'multiline':False]['text':' scale the random number u to be within range [0,f(i)], if needed','line_number':1266,'multiline':False]['text':' approach 2: allows gaps in the distribution','line_number':1268,'multiline':False]['text':' 2. compute the stack distance value of x, s.t. F(x)=u','line_number':1275,'multiline':False]['text':' notice that the cumulative distribution F increases monotonically up to 1','line_number':1276,'multiline':False]['text':' look up cum_val corresponding to u <= cum_dis[j]','line_number':1278,'multiline':False]['text':' iterate until you find the cum_val corresponding to u <= cum_dis[j]','line_number':1284,'multiline':False]['text':' Description:
     Generate synthetic trace from a list of unique accesses uni_ref, and
     cumulative distribution of distances (cum_val,cum_dis) between them.
     Also, there is an option to use cum_map approximation to avoid searching.
  ','line_number':1307,'multiline':True]['text':' generate stack distance','line_number':1317,'multiline':False]['text':' fixed access within cache line','line_number':1320,'multiline':False]['text':' random access within cache line','line_number':1322,'multiline':False]['text':' Val_t r;','line_number':1323,'multiline':False]['text':' math::RandUniform<Val_t, Context_t>(1, 0, 1, &r, context);','line_number':1324,'multiline':False]['text':' mem_ref_within_line = floor(r*cache_line_size);','line_number':1325,'multiline':False]['text':' generate memory reference','line_number':1327,'multiline':False]['text':'/ new reference ///','line_number':1329,'multiline':False]['text':'/ existing reference ///','line_number':1332,'multiline':False]['text':' pop k-th element','line_number':1334,'multiline':False]['text':' append it back','line_number':1336,'multiline':False]['text':'
    //debug prints
    if ((mem_ref < min) || (mem_ref > max)) {
      //printf("mem_ref[%d]=%d (%ld) \n",j,mem_ref,syn_ref[j]);
      std::cout << "syn_ref[" << j << "]=" << (Type)mem_ref << " ";
      std::cout << "(" << mem_ref << ") ";
      std::cout << "[" << min << "," << max << "]" << std::endl;
      int scanf_temp;
      scanf("%d",&scanf_temp);
    }
    ','line_number':1338,'multiline':True]['text':' patch mem_ref to be within range','line_number':1350,'multiline':False]['text':' WARNING: this should not be needed if instantiation type and distribution','line_number':1351,'multiline':False]['text':' choice is correct. It is remeding a symptom of earlier mistakes.','line_number':1352,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1353,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-signed-char-misuse)','line_number':1355,'multiline':False]['text':' std::cout << "clamping (min) mem_ref=" << mem_ref << std::endl;','line_number':1357,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1359,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-signed-char-misuse)','line_number':1361,'multiline':False]['text':' mem_ref % max;','line_number':1362,'multiline':False]['text':' std::cout << "clamping (max) mem_ref=" << mem_ref << std::endl;','line_number':1363,'multiline':False]['text':' save generated memory reference','line_number':1366,'multiline':False]['text':' Generate n values from synthetic data distribution,','line_number':1371,'multiline':False]['text':' define by unique accesses and stack distances','line_number':1372,'multiline':False]['text':' WARNING: can create this for all tables or per table, but in latter','line_number':1373,'multiline':False]['text':' case we need to know the table id, to sample from the right distribution','line_number':1374,'multiline':False]['text':' unique memory references ','line_number':1379,'multiline':True]['text':' cumulative distribution of distances ','line_number':1381,'multiline':True]['text':' inverse map of cumulative distribution (for O(1) lookup) ','line_number':1384,'multiline':True]['text':' std::vector<int> cum_map = {0, 0, 0, 0, 0, 1, 2, 2, 3, 4}; ','line_number':1385,'multiline':True]['text':' 100; ','line_number':1386,'multiline':True]['text':' code to generate the synthetic data from the above values ','line_number':1396,'multiline':True]['text':' 64; ','line_number':1397,'multiline':True]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1402,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1404,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1406,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1408,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1410,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1412,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1414,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1416,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1418,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1420,'multiline':False]['text':' unused ','line_number':1477,'multiline':True]['text':' unused ','line_number':1478,'multiline':True]['text':'context','line_number':1493,'multiline':True]['text':' unused ','line_number':1493,'multiline':True]['text':'scratch_ptr','line_number':1494,'multiline':True]['text':' unused ','line_number':1494,'multiline':True]['text':'context','line_number':1503,'multiline':True]['text':' unused ','line_number':1503,'multiline':True]['text':'scratch_ptr','line_number':1504,'multiline':True]['text':' unused ','line_number':1504,'multiline':True]['text':'context','line_number':1515,'multiline':True]['text':'context','line_number':1531,'multiline':True]['text':' can coalesce to a single memcpy of size M * N','line_number':1537,'multiline':False]['text':' context ','line_number':1573,'multiline':True]['text':' context ','line_number':1586,'multiline':True]['text':' CAFFE2_USE_MKL','line_number':1604,'multiline':False]['text':' context ','line_number':1615,'multiline':True]['text':' CAFFE2_USE_MKL','line_number':1662,'multiline':False]['text':' NOLINTNEXTLINE(modernize-use-transparent-functors)','line_number':1827,'multiline':False]['text':' Loop over spatial axes in reverse order to compute a per-axis offset.','line_number':1836,'multiline':False]['text':' Loop over spatial axes in forward order to compute the indices in the','line_number':1842,'multiline':False]['text':' image and column, and whether the index lies in the padding.','line_number':1843,'multiline':False]['text':' Fast path for zero padding and no dilation','line_number':1903,'multiline':False]['text':' From Torch, THNN_(unfolded_copy)','line_number':1904,'multiline':False]['text':' Fast path for equal padding','line_number':1941,'multiline':False]['text':' Baseline','line_number':1991,'multiline':False]['text':' namespace','line_number':2027,'multiline':False]['text':' context ','line_number':2042,'multiline':True]['text':' groups ','line_number':2043,'multiline':True]['text':' In NCHW, the number of groups doesn't affect Im2Col.','line_number':2044,'multiline':False]['text':' context ','line_number':2099,'multiline':True]['text':' groups ','line_number':2100,'multiline':True]['text':' In NCHW, the number of groups doesn't affect Col2Im.','line_number':2101,'multiline':False]['text':' groups ','line_number':2134,'multiline':True]['text':' In NCHW, the number of groups doesn't affect Im2Col.','line_number':2135,'multiline':False]['text':' Fast path for zero padding and no dilation','line_number':2137,'multiline':False]['text':' Baseline','line_number':2154,'multiline':False]['text':' Fast path for zero padding and no dilation','line_number':2201,'multiline':False]['text':' iw','line_number':2241,'multiline':False]['text':' ih','line_number':2242,'multiline':False]['text':' w','line_number':2244,'multiline':False]['text':' h','line_number':2246,'multiline':False]['text':'*
     * img_data in N H W G C/G layout
     * col_data in N G H W R S C/G layout
     * Note that groups are pulled out to an outer dimension so that we can use
     * GEMMs efficiently.
     ','line_number':2248,'multiline':True]['text':' iw','line_number':2278,'multiline':False]['text':' ih','line_number':2279,'multiline':False]['text':' w','line_number':2282,'multiline':False]['text':' h','line_number':2284,'multiline':False]['text':'*
 * The layout of the result is N H W G R S C/G.
 * Note that groups are pulled out to an outer dimension so that we can use
 * GEMMs efficiently.
 ','line_number':2288,'multiline':True]['text':' previous frame','line_number':2305,'multiline':False]['text':' top','line_number':2306,'multiline':False]['text':' left','line_number':2307,'multiline':False]['text':' next frame','line_number':2308,'multiline':False]['text':' bottom','line_number':2309,'multiline':False]['text':' right','line_number':2310,'multiline':False]['text':' iw','line_number':2358,'multiline':False]['text':' ih','line_number':2359,'multiline':False]['text':' it','line_number':2360,'multiline':False]['text':' w','line_number':2363,'multiline':False]['text':' h','line_number':2365,'multiline':False]['text':' t','line_number':2367,'multiline':False]['text':'img_size','line_number':2373,'multiline':True]['text':'col_size','line_number':2374,'multiline':True]['text':' context ','line_number':2383,'multiline':True]['text':' groups ','line_number':2434,'multiline':True]['text':' In NCHW, the number of groups doesn't affect Col2Im.','line_number':2435,'multiline':False]['text':' Fast path for zero padding and no dilation','line_number':2437,'multiline':False]['text':' Fallback','line_number':2454,'multiline':False]['text':' Fast path for zero padding and no dilation','line_number':2502,'multiline':False]['text':' iw','line_number':2542,'multiline':False]['text':' ih','line_number':2543,'multiline':False]['text':' w','line_number':2545,'multiline':False]['text':' h','line_number':2547,'multiline':False]['text':' iw','line_number':2569,'multiline':False]['text':' ih','line_number':2570,'multiline':False]['text':' w','line_number':2573,'multiline':False]['text':' h','line_number':2575,'multiline':False]['text':'*
 * The layout of the result is N H W G R S C/G.
 * Note that groups are pulled out to an outer dimension so that we can use
 * GEMMs efficiently.
 ','line_number':2579,'multiline':True]['text':' previous frame','line_number':2596,'multiline':False]['text':' top','line_number':2597,'multiline':False]['text':' left','line_number':2598,'multiline':False]['text':' next frame','line_number':2599,'multiline':False]['text':' bottom','line_number':2600,'multiline':False]['text':' right','line_number':2601,'multiline':False]['text':' iw','line_number':2646,'multiline':False]['text':' ih','line_number':2647,'multiline':False]['text':' it','line_number':2648,'multiline':False]['text':' w','line_number':2651,'multiline':False]['text':' h','line_number':2653,'multiline':False]['text':' t','line_number':2655,'multiline':False]['text':'img_size','line_number':2661,'multiline':True]['text':'col_size','line_number':2662,'multiline':True]['text':'bias_multiplier','line_number':2708,'multiline':True]['text':'context','line_number':2712,'multiline':True]['text':' Sum the per-channel bias into every image plane','line_number':2713,'multiline':False]['text':' We give alignment hints for additional speed, so handle the','line_number':2720,'multiline':False]['text':' non-vectorizable prologue separately','line_number':2721,'multiline':False]['text':' FIXME: if input < kVecSizeInFloat, can't vectorize at all','line_number':2724,'multiline':False]['text':' remainder in floats','line_number':2727,'multiline':False]['text':' Prologue loop','line_number':2731,'multiline':False]['text':' The loop is manually unrolled by 8','line_number':2736,'multiline':False]['text':' Vectorizable body','line_number':2743,'multiline':False]['text':' Manually unrolled','line_number':2745,'multiline':False]['text':' Non-vectorizable epilogue','line_number':2774,'multiline':False]['text':' Non-NEON CPU implementation','line_number':2779,'multiline':False]['text':' defined(__ARM_NEON__) || defined(__ARM_NEON)','line_number':2783,'multiline':False]['text':'context','line_number':2792,'multiline':True]['text':' namespace math','line_number':2801,'multiline':False]['text':' namespace caffe2','line_number':2802,'multiline':False]