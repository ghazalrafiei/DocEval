['text':' Check precedence between two vector of ensorBoundShape::DimType.','line_number':51,'multiline':False]['text':' If return 1: right take precedence over left','line_number':52,'multiline':False]['text':' If return -1: left take precedence over right','line_number':53,'multiline':False]['text':' If return 0: no precedence between left and right','line_number':54,'multiline':False]['text':' If left is empty and right is not, right take precedence','line_number':78,'multiline':False]['text':' If right.size > left.size and left[0:i] == right[0:i],','line_number':83,'multiline':False]['text':' right take precedence','line_number':84,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':85,'multiline':False]['text':' namespace','line_number':110,'multiline':False]['text':' ws ','line_number':128,'multiline':True]['text':' Doing a reverse pass to infer the input shapes if applicable','line_number':214,'multiline':False]['text':' Make sure shape has name','line_number':231,'multiline':False]['text':' if allow_existing_shape is true, we use existing shape directly','line_number':245,'multiline':False]['text':' and not enforce shape to be equal to bound_dims','line_number':246,'multiline':False]['text':' else we enforce them to be equal','line_number':247,'multiline':False]['text':' If the shape information exists in shape_info_ already and we want to','line_number':272,'multiline':False]['text':' compare old/new shapes','line_number':273,'multiline':False]['text':' Check dim size consistency','line_number':275,'multiline':False]['text':' Get precedence of previous shape vs new shape','line_number':281,'multiline':False]['text':' If precedence == 0: check whether previous shape == new shape','line_number':288,'multiline':False]['text':' If precedence == 1, override shape with new value','line_number':289,'multiline':False]['text':' If precedence == -1, previous shape takes precedence and','line_number':290,'multiline':False]['text':' new value is skipped.','line_number':291,'multiline':False]['text':' Enforce previous dims and current dims are the same.','line_number':298,'multiline':False]['text':' If shape information does not exist in shape_info_,','line_number':316,'multiline':False]['text':' or shape info is not final,','line_number':317,'multiline':False]['text':' set shape info according to inputs.','line_number':318,'multiline':False]['text':' Both input and ouptut of LengthsRangeFill is int32:','line_number':360,'multiline':False]['text':' https://fburl.com/fhwb5666','line_number':361,'multiline':False]['text':' Handle the weights','line_number':398,'multiline':False]['text':' Bound inputs','line_number':452,'multiline':False]['text':' Infer output','line_number':466,'multiline':False]['text':' If the op is SparseLengthsSumFused8BitRowwise, we need to extract 4 bytes','line_number':471,'multiline':False]['text':' for fp32 scale and 4 bytes for fp32 bias (https://fburl.com/t6dp9tsc)','line_number':472,'multiline':False]['text':' If the op is SparseLengthsSumFused4BitRowwise, we need to extract 2 bytes','line_number':479,'multiline':False]['text':' for fp16 scale and 2 bytes for fp16 bias. Then we double it because we','line_number':480,'multiline':False]['text':' pack 2 entries into 1 uint8 element of the embedding table.','line_number':481,'multiline':False]['text':' (https://fburl.com/diffusion/stmsyz74)','line_number':482,'multiline':False]['text':' old_shape should be a constant','line_number':499,'multiline':False]['text':' old_shape should be a constant','line_number':507,'multiline':False]['text':' From definition of Add/Mul:','line_number':546,'multiline':False]['text':' "When broadcasting is specified,','line_number':547,'multiline':False]['text':' the second tensor can either be of size 1 (a scalar value),','line_number':548,'multiline':False]['text':' or having its shape as a contiguous subset of the first tensors shape."','line_number':549,'multiline':False]['text':' shape info of second input is always subset of first input.','line_number':550,'multiline':False]['text':' Set bound shape of second input same as first input.','line_number':551,'multiline':False]['text':' NOLINTNEXTLINE(bugprone-branch-clone)','line_number':559,'multiline':False]['text':' We can only infer one missing input shape info','line_number':590,'multiline':False]['text':' Infer the shape of the second output of Concat','line_number':603,'multiline':False]['text':' For concat net, if some inputs are missing and we have add_axis argument,','line_number':631,'multiline':False]['text':' it means that all the inputs should be of the same dimension. In this case,','line_number':632,'multiline':False]['text':' we can infer the shape of the missing inputs','line_number':633,'multiline':False]['text':' split_info should be a constant','line_number':685,'multiline':False]['text':' We don't have a hint at the x input we try to deduce it from weight','line_number':716,'multiline':False]['text':' shape','line_number':717,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':739,'multiline':False]['text':' Note: for FbFCPacked, weight is fp16 but activations are in fp32','line_number':753,'multiline':False]['text':' Standard shape inference for outputs','line_number':772,'multiline':False]['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':787,'multiline':False]['text':' Infers shapes for operators which are used to transform non-quantized','line_number':816,'multiline':False]['text':' operators (e.g. SparseLengthsSum) into quantized operators (e.g.','line_number':817,'multiline':False]['text':' SparseLengthsSumFused8BitRowwise) at model training time. If we're doing','line_number':818,'multiline':False]['text':' quantization for CONSTANTS (eg. embedding tables), current_dim_type_ should','line_number':819,'multiline':False]['text':' be set to CONSTANT.','line_number':820,'multiline':False]['text':' Special case of single tensor input','line_number':861,'multiline':False]['text':' Input is packed','line_number':864,'multiline':False]['text':' TODO: how to do this more intelligently','line_number':869,'multiline':False]['text':' In this case it should be existing dims in reverse order','line_number':1012,'multiline':False]['text':' First, we need to check that all the input shape/types are already','line_number':1050,'multiline':False]['text':' presented','line_number':1051,'multiline':False]['text':' Schema can be pre-defined.','line_number':1078,'multiline':False]['text':' If not predefined, get the schema for the op.','line_number':1079,'multiline':False]['text':' Force this op's output to be uint8','line_number':1098,'multiline':False]['text':' NOLINTNEXTLINE(clang-diagnostic-sign-compare)','line_number':1115,'multiline':False]['text':' Extract output scale and offset','line_number':1120,'multiline':False]['text':' namespace caffe2','line_number':1172,'multiline':False]