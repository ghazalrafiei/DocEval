['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]['text':'
 * Code to handle tags and the tag stack
 ','line_number':10,'multiline':True]['text':'
 * Structure to hold pointers to various items in a tag line.
 ','line_number':16,'multiline':True]['text':' filled in by parse_tag_line():','line_number':21,'multiline':False]['text':' start of tag name (skip "file:")','line_number':22,'multiline':False]['text':' char after tag name','line_number':23,'multiline':False]['text':' first char of file name','line_number':24,'multiline':False]['text':' char after file name','line_number':25,'multiline':False]['text':' first char of command','line_number':26,'multiline':False]['text':' filled in by parse_match():','line_number':27,'multiline':False]['text':' first char after command','line_number':28,'multiline':False]['text':' file name of the tags file. This is used','line_number':29,'multiline':False]['text':' when 'tr' is set.','line_number':30,'multiline':False]['text':' TRUE for emacs tag','line_number':32,'multiline':False]['text':' "kind:" value','line_number':34,'multiline':False]['text':' end of tagkind','line_number':35,'multiline':False]['text':' user_data string','line_number':36,'multiline':False]['text':' end of user_data','line_number':37,'multiline':False]['text':' "line:" value','line_number':38,'multiline':False]['text':'
 * Return values used when reading lines from a tags file.
 ','line_number':41,'multiline':True]['text':'
 * States used during a tags search
 ','line_number':51,'multiline':True]['text':' at start of file','line_number':56,'multiline':False]['text':' linear searching forward, till EOF','line_number':57,'multiline':False]['text':' binary searching','line_number':58,'multiline':False]['text':' skipping backwards','line_number':59,'multiline':False]['text':' stepping forwards','line_number':60,'multiline':False]['text':' Current search state','line_number':61,'multiline':False]['text':'
 * Binary search file offsets in a tags file
 ','line_number':63,'multiline':True]['text':' offset for first char of first line that','line_number':68,'multiline':False]['text':' could match','line_number':69,'multiline':False]['text':' offset of char after last line that could','line_number':70,'multiline':False]['text':' match','line_number':71,'multiline':False]['text':' Current file offset in search range','line_number':72,'multiline':False]['text':' curr_offset used when skipping back','line_number':73,'multiline':False]['text':' Where the binary search found a tag','line_number':74,'multiline':False]['text':' first char at low_offset','line_number':75,'multiline':False]['text':' first char at high_offset','line_number':76,'multiline':False]['text':'
 * Return values used when matching tags against a pattern.
 ','line_number':79,'multiline':True]['text':'
 * Arguments used for matching tags read from a tags file against a pattern.
 ','line_number':90,'multiline':True]['text':' tag match offset','line_number':95,'multiline':False]['text':' TRUE if the tag matches a regexp','line_number':96,'multiline':False]['text':' TRUE if the tag matches with case','line_number':97,'multiline':False]['text':' regular expression used','line_number':98,'multiline':False]['text':' tags file sorted ignoring case (foldcase)','line_number':99,'multiline':False]['text':' tags file not sorted','line_number':100,'multiline':False]['text':'
 * The matching tags are first stored in one of the hash tables.  In
 * which one depends on the priority of the match.
 * ht_match[] is used to find duplicates, ga_match[] to keep them in sequence.
 * At the end, all the matches from ga_match[] are concatenated, to make a list
 * sorted on priority.
 ','line_number':103,'multiline':True]['text':' static match in current file','line_number':110,'multiline':False]['text':' global match in current file','line_number':111,'multiline':False]['text':' global match in other file','line_number':112,'multiline':False]['text':' static match in other file','line_number':113,'multiline':False]['text':' add for icase match','line_number':114,'multiline':False]['text':' add for regexp match','line_number':115,'multiline':False]['text':' mask for printing priority','line_number':116,'multiline':False]['text':' return value for jumpto_tag','line_number':122,'multiline':False]['text':' fname for NOTAGFILE error','line_number':123,'multiline':False]['text':' name of last used tag','line_number':149,'multiline':False]['text':'
 * Tag for preview window is remembered separately, to avoid messing up the
 * normal tagstack.
 ','line_number':152,'multiline':True]['text':' disallow recursive call of tagfunc','line_number':160,'multiline':False]['text':' 'tagfunc' callback function','line_number':161,'multiline':False]['text':' Used instead of NUL to separate tag fields in the growarrays.','line_number':164,'multiline':False]['text':'
 * Reads the 'tagfunc' option value and convert that to a callback value.
 * Invoked when the 'tagfunc' option is set. The option value can be a name of
 * a function (string), or function(<name>) or funcref(<name>) or a lambda.
 ','line_number':168,'multiline':True]['text':'
 * Mark the global 'tagfunc' callback with "copyID" so that it is not garbage
 * collected.
 ','line_number':204,'multiline':True]['text':'
 * Copy the global 'tagfunc' callback function to the buffer-local 'tagfunc'
 * callback for 'buf'.
 ','line_number':218,'multiline':True]['text':'
 * Jump to tag; handling of tag commands and tag stack
 *
 * *tag != NUL: ":tag {tag}", jump to new tag, add to tag stack
 *
 * type == DT_TAG:	":tag [tag]", jump to newer position or same tag again
 * type == DT_HELP:	like DT_TAG, but don't use regexp.
 * type == DT_POP:	":pop" or CTRL-T, jump to old position
 * type == DT_NEXT:	jump to next match of same tag
 * type == DT_PREV:	jump to previous match of same tag
 * type == DT_FIRST:	jump to first match of same tag
 * type == DT_LAST:	jump to last match of same tag
 * type == DT_SELECT:	":tselect [tag]", select tag from a list of all matches
 * type == DT_JUMP:	":tjump [tag]", jump to tag or select tag from a list
 * type == DT_CSCOPE:	use cscope to find the tag
 * type == DT_LTAG:	use location list for displaying tag matches
 * type == DT_FREE:	free cached matches
 *
 * for cscope, returns TRUE if we jumped to tag or aborted, FALSE otherwise
 ','line_number':231,'multiline':True]['text':' tag (pattern) to jump to','line_number':253,'multiline':False]['text':' :ta with !','line_number':256,'multiline':False]['text':' print "tag not found" message','line_number':257,'multiline':False]['text':' name to use for','line_number':281,'multiline':False]['text':' priority computation','line_number':282,'multiline':False]['text':' remember the matches for the last used tag','line_number':286,'multiline':False]['text':' limit used for match search','line_number':288,'multiline':False]['text':' remove the list of matches','line_number':303,'multiline':False]['text':' shutup gcc 4.0','line_number':324,'multiline':False]['text':'
     * Don't add a tag to the tagstack if 'tagstack' has been reset.
     ','line_number':327,'multiline':True]['text':' new pattern, add to the tag stack','line_number':352,'multiline':False]['text':' Jumping to same tag: keep the current match, so that','line_number':369,'multiline':False]['text':' the CursorHold autocommand example works.','line_number':370,'multiline':False]['text':'
		 * If the last used entry is not at the top, delete all tag
		 * stack entries above it.
		 ','line_number':384,'multiline':True]['text':' if the tagstack is full: remove oldest entry','line_number':391,'multiline':False]['text':'
		 * put the tag name in the tag stack
		 ','line_number':401,'multiline':True]['text':' save the cursor position below','line_number':411,'multiline':False]['text':' empty stack','line_number':424,'multiline':False]['text':' go to older position','line_number':429,'multiline':False]['text':' We did [num]^T from the bottom of the stack','line_number':439,'multiline':False]['text':' We weren't at the bottom of the stack, so jump all the','line_number':443,'multiline':False]['text':' way to the bottom now.','line_number':444,'multiline':False]['text':' count == 0?','line_number':447,'multiline':False]['text':' Make a copy of the fmark, autocommands may invalidate the','line_number':453,'multiline':False]['text':' tagstack before it's used.','line_number':454,'multiline':False]['text':'
		     * Jump to other file. If this fails (e.g. because the
		     * file was changed) keep original position in tag stack.
		     ','line_number':458,'multiline':True]['text':' back to old posn','line_number':465,'multiline':False]['text':' An BufReadPost autocommand may jump to the '" mark, but','line_number':468,'multiline':False]['text':' we don't what that here.','line_number':469,'multiline':False]['text':' remove the old list of matches','line_number':485,'multiline':False]['text':' ":tag" (no argument): go to newer pattern','line_number':510,'multiline':False]['text':' save the cursor position below','line_number':511,'multiline':False]['text':'
			 * Beyond the last one, just give an error message and
			 * go to the last one.  Don't store the cursor
			 * position.
			 ','line_number':514,'multiline':True]['text':' must have been count == 0','line_number':523,'multiline':False]['text':' go to other matching tag','line_number':534,'multiline':False]['text':' Save index for when selection is cancelled.','line_number':536,'multiline':False]['text':'
	     * For ":tag [arg]" or ":tselect" remember position before the jump.
	     ','line_number':589,'multiline':True]['text':' Curwin will change in the call to jumpto_tag() if ":stag" was','line_number':599,'multiline':False]['text':' used or an autocommand jumps to another window; store value of','line_number':600,'multiline':False]['text':' tagstackidx now.','line_number':601,'multiline':False]['text':' When not using the current buffer get the name of buffer "cur_fnum".','line_number':611,'multiline':False]['text':' Makes sure that the tag order doesn't change when using a remembered','line_number':612,'multiline':False]['text':' position for "cur_match".','line_number':613,'multiline':False]['text':'
     * Repeat searching for tags, when a file has not been found.
     ','line_number':622,'multiline':True]['text':'
	 * When desired match not found yet, try to find it (and others).
	 ','line_number':630,'multiline':True]['text':' make a copy, the tagstack may change in 'tagfunc'','line_number':635,'multiline':False]['text':' when the argument starts with '/', use it as a regexp','line_number':668,'multiline':False]['text':' If less than max_num_matches','line_number':690,'multiline':False]['text':' found: all matches found.','line_number':691,'multiline':False]['text':' A tag function may do anything, which may cause various','line_number':693,'multiline':False]['text':' information to become invalid.  At least check for the tagstack','line_number':694,'multiline':False]['text':' to still be the same.','line_number':695,'multiline':False]['text':' If there already were some matches for the same name, move them','line_number':703,'multiline':False]['text':' to the start.  Avoids that the order changes when using','line_number':704,'multiline':False]['text':' ":tnext" and jumping to another file.','line_number':705,'multiline':False]['text':' Find the position of each old match in the new list.  Need','line_number':712,'multiline':False]['text':' to use parse_match() to find the tag line.','line_number':713,'multiline':False]['text':' If a count is supplied to the ":tag <name>" command, then','line_number':757,'multiline':False]['text':' jump to count'th matching tag.','line_number':758,'multiline':False]['text':' Jump to the first tag','line_number':770,'multiline':False]['text':'
		 * Ask to select a tag from the list.
		 ','line_number':776,'multiline':True]['text':' no valid choice: don't change anything','line_number':782,'multiline':False]['text':' Avoid giving this error when a file wasn't found and we're','line_number':799,'multiline':False]['text':' looking for a match in another file, which wasn't found.','line_number':800,'multiline':False]['text':' There will be an emsg("file doesn't exist") below then.','line_number':801,'multiline':False]['text':' store user-provided data originating from tagfunc','line_number':820,'multiline':False]['text':'
	     * Only when going to try the next match, report that the previous
	     * file didn't exist.  Otherwise an emsg() is given below.
	     ','line_number':839,'multiline':True]['text':' Give an indication of the number of matching tags','line_number':855,'multiline':False]['text':' don't overwrite this message','line_number':869,'multiline':False]['text':' Let the SwapExists event know what tag we are jumping to.','line_number':881,'multiline':False]['text':'
	     * Jump to the desired match.
	     ','line_number':886,'multiline':True]['text':' File not found: try again with another matching tag','line_number':897,'multiline':False]['text':' We may have jumped to another window, check that','line_number':920,'multiline':False]['text':' tagstackidx is still valid.','line_number':921,'multiline':False]['text':' Only store the new index when using the tagstack and it's valid.','line_number':933,'multiline':False]['text':' don't split next time','line_number':936,'multiline':False]['text':' don't do tag preview next time','line_number':938,'multiline':False]['text':'
 * List all the matching tags.
 ','line_number':949,'multiline':True]['text':'
     * Assume that the first match indicates how long the tags can
     * be, and align the file names to that.
     ','line_number':968,'multiline':True]['text':' overwrite previous message','line_number':979,'multiline':False]['text':' Find out the actual file name. If it is long, truncate','line_number':1013,'multiline':False]['text':' it and put "..." in the middle','line_number':1014,'multiline':False]['text':' print any extra fields','line_number':1027,'multiline':False]['text':' skip "file:" without a value (static tag)','line_number':1037,'multiline':False]['text':' skip "kind:<kind>" and "<kind>"','line_number':1044,'multiline':False]['text':' print all other extra fields','line_number':1052,'multiline':False]['text':' Put the info (in several lines) at column 15.','line_number':1089,'multiline':False]['text':' Don't display "/^" and "?^".','line_number':1090,'multiline':False]['text':' Remove leading whitespace from pattern','line_number':1098,'multiline':False]['text':' skip backslash used for escaping a command char or','line_number':1110,'multiline':False]['text':' a backslash','line_number':1111,'multiline':False]['text':' don't display the "$/;\"" and "$?;\""','line_number':1124,'multiline':False]['text':' don't display matching '/' or '?'','line_number':1128,'multiline':False]['text':' only stop the listing','line_number':1138,'multiline':False]['text':'
 * Add the matching tags to the location list for the current
 * window.
 ','line_number':1142,'multiline':True]['text':' Save the tag name','line_number':1180,'multiline':False]['text':' Save the tag file name','line_number':1187,'multiline':False]['text':' Get the line number or the search pattern used to locate','line_number':1194,'multiline':False]['text':' the tag.','line_number':1195,'multiline':False]['text':' Line number is used to locate the tag','line_number':1198,'multiline':False]['text':' Search pattern is used to locate the tag','line_number':1204,'multiline':False]['text':' Locate the end of the command','line_number':1206,'multiline':False]['text':' Now, cmd_end points to the character after the','line_number':1217,'multiline':False]['text':' command. Adjust it to point to the last','line_number':1218,'multiline':False]['text':' character of the command.','line_number':1219,'multiline':False]['text':' Skip the '/' and '?' characters at the','line_number':1222,'multiline':False]['text':' beginning and end of the search pattern.','line_number':1223,'multiline':False]['text':' If "^" is present in the tag search pattern, then','line_number':1233,'multiline':False]['text':' copy it first.','line_number':1234,'multiline':False]['text':' Precede the tag pattern with \V to make it very','line_number':1242,'multiline':False]['text':' nomagic.','line_number':1243,'multiline':False]['text':' Replace '$' at the end of the search pattern','line_number':1255,'multiline':False]['text':' with '\$'','line_number':1256,'multiline':False]['text':'
 * Free cached tags.
 ','line_number':1291,'multiline':True]['text':'
 * Print the tag stack
 ','line_number':1312,'multiline':True]['text':' Highlight title','line_number':1324,'multiline':False]['text':' file name not available','line_number':1331,'multiline':False]['text':' show one line at a time','line_number':1346,'multiline':False]['text':' idx at top of stack','line_number':1348,'multiline':False]['text':'
 * Compare two strings, for length "len", ignoring case the ASCII way.
 * return 0 for match, < 0 for smaller, > 0 for bigger
 * Make sure case is folded to uppercase in comparison (like for 'sort -f')
 ','line_number':1352,'multiline':True]['text':' this character different','line_number':1366,'multiline':False]['text':' strings match until NUL','line_number':1368,'multiline':False]['text':' strings match','line_number':1373,'multiline':False]['text':'
 * Structure to hold info about the tag pattern being used.
 ','line_number':1376,'multiline':True]['text':' the pattern','line_number':1381,'multiline':False]['text':' length of pat[]','line_number':1382,'multiline':False]['text':' start of pattern head','line_number':1383,'multiline':False]['text':' length of head[]','line_number':1384,'multiline':False]['text':' regexp program, may be NULL','line_number':1385,'multiline':False]['text':'
 * Extract info from the tag search pattern "pats->pat".
 ','line_number':1388,'multiline':True]['text':' When the pattern starts with '^' or "\\<", binary searching can be','line_number':1398,'multiline':False]['text':' used (much faster).','line_number':1399,'multiline':False]['text':' adjust for 'taglength'','line_number':1412,'multiline':False]['text':'
 * Call the user-defined function to generate a list of tags used by
 * find_tags().
 *
 * Return OK if at least 1 tag has been successfully found,
 * NOTDONE if the function returns v:null, and FAIL otherwise.
 ','line_number':1424,'multiline':True]['text':' pattern supplied to the user-defined function','line_number':1433,'multiline':False]['text':' the tags will be placed here','line_number':1434,'multiline':False]['text':' here the number of tags found will be placed','line_number':1435,'multiline':False]['text':' flags from find_tags (TAG_*)','line_number':1436,'multiline':False]['text':' name of buffer for priority','line_number':1437,'multiline':False]['text':' create 'info' dict argument','line_number':1459,'multiline':False]['text':' restore the cursor position','line_number':1481,'multiline':False]['text':' Space for "\tVALUE"','line_number':1532,'multiline':False]['text':' Other elements will be stored as "\tKEY:VALUE"','line_number':1554,'multiline':False]['text':' Allocate space for the key and the colon','line_number':1555,'multiline':False]['text':' need space for ;"','line_number':1560,'multiline':False]['text':' mtt','line_number':1580,'multiline':False]['text':' no tag file name','line_number':1581,'multiline':False]['text':' Add all matches because tagfunc should do filtering.','line_number':1635,'multiline':False]['text':'
 * State information used during a tag search
 ','line_number':1656,'multiline':True]['text':' tag search state','line_number':1661,'multiline':False]['text':' stop when match found or error','line_number':1662,'multiline':False]['text':' holds unconverted pattern info','line_number':1663,'multiline':False]['text':' line buffer','line_number':1664,'multiline':False]['text':' length of lbuf','line_number':1665,'multiline':False]['text':' name of the tag file','line_number':1666,'multiline':False]['text':' current tags file pointer','line_number':1667,'multiline':False]['text':' flags used for tag search','line_number':1668,'multiline':False]['text':' !_TAG_FILE_SORTED value','line_number':1669,'multiline':False]['text':' used for 'showfulltag'','line_number':1670,'multiline':False]['text':' only search for help tags','line_number':1671,'multiline':False]['text':' did open a tag file','line_number':1672,'multiline':False]['text':' MAXCOL: find all matches','line_number':1673,'multiline':False]['text':' other: minimal number of matches','line_number':1674,'multiline':False]['text':' do a linear search','line_number':1675,'multiline':False]['text':' current file is emacs style','line_number':1678,'multiline':False]['text':' additional buffer for etag fname','line_number':1679,'multiline':False]['text':' lang of current tags file','line_number':1682,'multiline':False]['text':' help language priority','line_number':1683,'multiline':False]['text':' lang to be found','line_number':1684,'multiline':False]['text':' flag of file extension','line_number':1685,'multiline':False]['text':' number of matches found','line_number':1687,'multiline':False]['text':' stores matches in sequence','line_number':1688,'multiline':False]['text':' stores matches by key','line_number':1689,'multiline':False]['text':'
 * Initialize the state used by find_tags().
 * Returns OK on success and FAIL on memory allocation failure.
 ','line_number':1692,'multiline':True]['text':' check for out of memory situation','line_number':1737,'multiline':False]['text':'
 * Free the state used by find_tags()
 ','line_number':1749,'multiline':True]['text':'
 * Initialize the language and priority used for searching tags in a Vim help
 * file.
 * Returns TRUE to process the help file for tags and FALSE to skip the file.
 ','line_number':1765,'multiline':True]['text':' Keep "en" as the language if the file extension is ".txt"','line_number':1776,'multiline':False]['text':' Prefer help tags according to 'helplang'.  Put the two-letter','line_number':1781,'multiline':False]['text':' language name in help_lang[].','line_number':1782,'multiline':False]['text':' When searching for a specific language skip tags files for other','line_number':1789,'multiline':False]['text':' languages.','line_number':1790,'multiline':False]['text':' For CTRL-] in a help file prefer a match with the same language.','line_number':1795,'multiline':False]['text':' search for the language in 'helplang'','line_number':1806,'multiline':False]['text':' Language not in 'helplang': use last, prefer English, unless','line_number':1818,'multiline':False]['text':' found already.','line_number':1819,'multiline':False]['text':'
 * Use the function set in 'tagfunc' (if configured and enabled) to get the
 * tags.
 * Return OK if at least 1 tag has been successfully found, NOTDONE if the
 * 'tagfunc' is not used or the 'tagfunc' returns v:null and FAIL otherwise.
 ','line_number':1831,'multiline':True]['text':'
 * Stack for included emacs-tags file.
 * It has a fixed size, to truncate cyclic includes. jw
 ','line_number':1856,'multiline':True]['text':' index in incstack','line_number':1866,'multiline':False]['text':'
 * Free the emacs include tags file stack.
 ','line_number':1868,'multiline':True]['text':'
 * Emacs tags line with CTRL-L: New file name on next line.
 * The file name is followed by a ','.  Remember etag file name in ebuf.
 * The FILE pointer to the tags file is stored in "st->fp".  If another tags
 * file is included, then the FILE pointer to the new tags file is stored in
 * "st->fp". The old file pointer is saved in incstack.
 ','line_number':1883,'multiline':True]['text':' check for an included tags file.','line_number':1903,'multiline':False]['text':' atoi(p+1) is the number of bytes before the next ^L unless it is an','line_number':1904,'multiline':False]['text':' include statement. Skip the included tags file if it exceeds the','line_number':1905,'multiline':False]['text':' maximum.','line_number':1906,'multiline':False]['text':' Save current "fp" and "tag_fname" in the stack.','line_number':1910,'multiline':False]['text':' Figure out "tag_fname" and "fp" to use for','line_number':1918,'multiline':False]['text':' included file.','line_number':1919,'multiline':False]['text':' we can include anything','line_number':1930,'multiline':False]['text':' Can't open the included file, skip it and','line_number':1936,'multiline':False]['text':' restore old value of "fp".','line_number':1937,'multiline':False]['text':'
 * Reached the end of an emacs-style tags file. If this is an included tags
 * file, then pop it from the incstack and continue processing the parent tags
 * file. Otherwise, processed all the tags.
 * Returns TRUE if an included tags file is popped and processing should
 * continue with the parent tags file. Returns FALSE to stop processing tags.
 ','line_number':1943,'multiline':True]['text':' reached end of file. stop processing.','line_number':1953,'multiline':False]['text':' reached the end of an included tags file. pop it.','line_number':1956,'multiline':False]['text':' end of this file ...','line_number':1958,'multiline':False]['text':' (only etags can include)','line_number':1962,'multiline':False]['text':'
 * Parse a line from an emacs-style tags file.
 * Returns OK if the line is parsed successfully, returns FAIL if the line is
 * not terminated by a newline.
 ','line_number':1967,'multiline':True]['text':' There are two formats for an emacs tag line:','line_number':1978,'multiline':False]['text':' 1:  struct EnvBase ^?EnvBase^A139,4627','line_number':1979,'multiline':False]['text':' 2: #define	ARPB_WILD_WORLD ^?153,5194','line_number':1980,'multiline':False]['text':' Truncated line.  Ignore it.','line_number':1988,'multiline':False]['text':' Find ^A.  If not found the line number is after the 0x7f','line_number':2001,'multiline':False]['text':' check for start of line number','line_number':2008,'multiline':False]['text':' first format: explicit tagname given','line_number':2012,'multiline':False]['text':' second format: isolate tagname','line_number':2017,'multiline':False]['text':' find end of tagname','line_number':2019,'multiline':False]['text':'
 * Read the next line from a tags file.
 * Returns TAGS_READ_SUCCESS if a tags line is successfully read and should be
 * processed.
 * Returns TAGS_READ_EOF if the end of file is reached.
 * Returns TAGS_READ_IGNORE if the current line should be ignored (used when
 * reached end of a emacs included tags file)
 ','line_number':2033,'multiline':True]['text':' For binary search: compute the next offset to use.','line_number':2047,'multiline':False]['text':' End the binary search without a match.','line_number':2053,'multiline':False]['text':' Skipping back (after a match during binary search).','line_number':2058,'multiline':False]['text':' When jumping around in the file, first read a line to find the','line_number':2070,'multiline':False]['text':' start of the next line.','line_number':2071,'multiline':False]['text':' Adjust the search file offset to the correct position','line_number':2074,'multiline':False]['text':' oops, gone a bit too far; try from low offset','line_number':2083,'multiline':False]['text':' skip empty and blank lines','line_number':2089,'multiline':False]['text':' Hit end of file.  Skip backwards.','line_number':2097,'multiline':False]['text':' Not jumping around in the file: Read the next line.','line_number':2104,'multiline':False]['text':' skip empty and blank lines','line_number':2107,'multiline':False]['text':' an included tags file. Continue processing the parent','line_number':2122,'multiline':False]['text':' tags file.','line_number':2123,'multiline':False]['text':'
 * Parse a tags file header line in "st->lbuf".
 * Returns TRUE if the current line in st->lbuf is not a tags header line and
 * should be parsed as a regular tag line. Returns FALSE if the line is a
 * header line and the next header line should be read.
 ','line_number':2133,'multiline':True]['text':' Header lines in a tags file start with "!_TAG_"','line_number':2144,'multiline':False]['text':' Non-header item before the header, e.g. "!" itself.','line_number':2146,'multiline':False]['text':' Process the header line.','line_number':2149,'multiline':False]['text':' Prepare to convert every line from the specified encoding to','line_number':2154,'multiline':False]['text':' 'encoding'.','line_number':2155,'multiline':False]['text':' Read the next line.  Unrecognized flags are ignored.','line_number':2162,'multiline':False]['text':'
 * Handler to initialize the state when starting to process a new tags file.
 * Called in the TS_START state when finding tags from a tags file.
 * Returns TRUE if the line read from the tags file should be parsed and
 * FALSE if the line should be ignored.
 ','line_number':2166,'multiline':True]['text':' The header ends when the line sorts below "!_TAG_".  When case is','line_number':2184,'multiline':False]['text':' folded lower case letters sort before "_".','line_number':2185,'multiline':False]['text':' Headers ends.','line_number':2190,'multiline':False]['text':' When there is no tag head, or ignoring case, need to do a','line_number':2192,'multiline':False]['text':' linear search.','line_number':2193,'multiline':False]['text':' When no "!_TAG_" is found, default to binary search.  If','line_number':2194,'multiline':False]['text':' the tag file isn't sorted, the second loop will find it.','line_number':2195,'multiline':False]['text':' When "!_TAG_FILE_SORTED" found: start binary search if','line_number':2196,'multiline':False]['text':' flag set.','line_number':2197,'multiline':False]['text':' For cscope, it's always linear.','line_number':2198,'multiline':False]['text':' Binary search won't work for ignoring case, use linear','line_number':2220,'multiline':False]['text':' search.','line_number':2221,'multiline':False]['text':' When starting a binary search, get the size of the file and','line_number':2226,'multiline':False]['text':' compute the first offset.','line_number':2227,'multiline':False]['text':' can't seek, don't use binary search','line_number':2231,'multiline':False]['text':' Get the tag file size (don't use mch_fstat(), it's','line_number':2235,'multiline':False]['text':' not portable).  Don't use lseek(), it doesn't work','line_number':2236,'multiline':False]['text':' properly on MacOS Catalina.','line_number':2237,'multiline':False]['text':' Calculate the first read offset in the file.  Start','line_number':2241,'multiline':False]['text':' the search in the middle of the file.','line_number':2242,'multiline':False]['text':'
 * Parse a tag line read from a tags file.
 * Also compares the tag name in "tagpp->tagname" with a search pattern in
 * "st->orgpat->head" as a quick check if the tag may match.
 * Returns:
 * - TAG_MATCH_SUCCESS if the tag may match
 * - TAG_MATCH_FAIL if the tag doesn't match
 * - TAG_MATCH_NEXT to look for the next matching tag (used in a binary search)
 * - TAG_MATCH_STOP if all the tags are processed without a match. Uses the
 *   values in "margs" for doing the comparison.
 ','line_number':2255,'multiline':True]['text':' Figure out where the different strings are in this line.','line_number':2278,'multiline':False]['text':' For "normal" tags: Do a quick check if the tag matches.','line_number':2279,'multiline':False]['text':' This speeds up tag searching a lot!','line_number':2280,'multiline':False]['text':' Corrupted tag line.','line_number':2291,'multiline':False]['text':' Skip this line if the length of the tag is different and','line_number':2294,'multiline':False]['text':' there is no regexp, or the tag is too short.','line_number':2295,'multiline':False]['text':' adjust for 'taglength'','line_number':2297,'multiline':False]['text':' Simplistic check for unsorted tags file.','line_number':2306,'multiline':False]['text':' Compare the current tag with the searched tag.','line_number':2313,'multiline':False]['text':' A match with a shorter tag means to search forward.','line_number':2320,'multiline':False]['text':' A match with a longer tag means to search backward.','line_number':2321,'multiline':False]['text':' We've located the tag, now skip back and search','line_number':2332,'multiline':False]['text':' forward until the first matching tag is found.','line_number':2333,'multiline':False]['text':' No match yet and are at the end of the binary search.','line_number':2361,'multiline':False]['text':' Have to skip back more.  Restore the curr_offset','line_number':2369,'multiline':False]['text':' used, otherwise we get stuck at a long line.','line_number':2370,'multiline':False]['text':' past last match','line_number':2379,'multiline':False]['text':' before first match','line_number':2381,'multiline':False]['text':' skip this match if it can't match','line_number':2385,'multiline':False]['text':' Can be a matching tag, isolate the file name and command.','line_number':2389,'multiline':False]['text':'
 * Initialize the structure used for tag matching.
 ','line_number':2418,'multiline':True]['text':' match offset','line_number':2424,'multiline':False]['text':' match with regexp','line_number':2425,'multiline':False]['text':' matches with case','line_number':2426,'multiline':False]['text':' regexp used','line_number':2427,'multiline':False]['text':' tag file sorted in nocase','line_number':2428,'multiline':False]['text':' tags file not sorted','line_number':2429,'multiline':False]['text':'
 * Compares the tag name in "tagpp->tagname" with a search pattern in
 * "st->orgpat->pat".
 * Returns TRUE if the tag matches, FALSE if the tag doesn't match.
 * Uses the values in "margs" for doing the comparison.
 ','line_number':2432,'multiline':True]['text':' First try matching with the pattern literally (also when it is','line_number':2447,'multiline':False]['text':' a regexp).','line_number':2448,'multiline':False]['text':' adjust for 'taglength'','line_number':2450,'multiline':False]['text':' if tag length does not match, don't try comparing','line_number':2452,'multiline':False]['text':' Has a regexp: Also find tags matching regexp.','line_number':2469,'multiline':False]['text':'
 * Convert the encoding of a line read from a tags file in "st->lbuf".
 * Converting the pattern from 'enc' to the tags file encoding doesn't work,
 * because characters are not recognized. The converted line is saved in
 * st->lbuf.
 ','line_number':2497,'multiline':True]['text':' Copy or swap lbuf and conv_line.','line_number':2513,'multiline':False]['text':'
 * Add a matching tag found in a tags file to st->ht_match and st->ga_match.
 * Returns OK if successfully added the match and FAIL on memory allocation
 * failure.
 ','line_number':2528,'multiline':True]['text':' file name matches','line_number':2547,'multiline':False]['text':' current tag line is static','line_number':2548,'multiline':False]['text':' Don't change the ordering, always use the same table.','line_number':2556,'multiline':False]['text':' Decide in which array to store this match.','line_number':2562,'multiline':False]['text':' emacs tags are never static','line_number':2570,'multiline':False]['text':' decide in which of the sixteen tables to store this','line_number':2574,'multiline':False]['text':' match','line_number':2575,'multiline':False]['text':' Add the found match in ht_match[mtt] and ga_match[mtt].','line_number':2596,'multiline':False]['text':' Store the info we need later, which depends on the kind of','line_number':2597,'multiline':False]['text':' tags we are dealing with.','line_number':2598,'multiline':False]['text':' Append the help-heuristic number after the tagname, for','line_number':2606,'multiline':False]['text':' sorting it later.  The heuristic is ignored for','line_number':2607,'multiline':False]['text':' detecting duplicates.','line_number':2608,'multiline':False]['text':' The format is {tagname}@{lang}NUL{heuristic}NUL','line_number':2609,'multiline':False]['text':' if wanted, re-read line to get long form too','line_number':2665,'multiline':False]['text':' Save the tag in a buffer.','line_number':2677,'multiline':False]['text':' Use 0x02 to separate fields (Can't use NUL because the','line_number':2678,'multiline':False]['text':' hash key is terminated by NUL, or Ctrl_A because that is','line_number':2679,'multiline':False]['text':' part of some Emacs tag files -- see parse_tag_line).','line_number':2680,'multiline':False]['text':' Emacs tag: <mtt><tag_fname><0x02><ebuf><0x02><lbuf><NUL>','line_number':2681,'multiline':False]['text':' other tag: <mtt><tag_fname><0x02><0x02><lbuf><NUL>','line_number':2682,'multiline':False]['text':' without Emacs tags: <mtt><tag_fname><0x02><lbuf><NUL>','line_number':2683,'multiline':False]['text':' Here <mtt> is the "mtt" value plus 1 to avoid NUL.','line_number':2684,'multiline':False]['text':' Ignore differences in slashes, avoid adding','line_number':2702,'multiline':False]['text':' both path/file and path\file.','line_number':2703,'multiline':False]['text':' Don't add identical matches.','line_number':2726,'multiline':False]['text':' Add all cscope tags, because they are all listed.','line_number':2727,'multiline':False]['text':' "mfp" is used as a hash key, there is a NUL byte to end','line_number':2728,'multiline':False]['text':' the part that matters for comparing, more bytes may','line_number':2729,'multiline':False]['text':' follow after it.  E.g. help tags store the priority','line_number':2730,'multiline':False]['text':' after the NUL.','line_number':2731,'multiline':False]['text':' Out of memory! Just forget about the rest.','line_number':2744,'multiline':False]['text':' duplicate tag, drop it','line_number':2754,'multiline':False]['text':'
 * Read and get all the tags from file st->tag_fname.
 * Sets "st->stop_searching" to TRUE to stop searching for additional tags.
 ','line_number':2761,'multiline':True]['text':' This is only to avoid a compiler warning for using search_info','line_number':2779,'multiline':False]['text':' uninitialised.','line_number':2780,'multiline':False]['text':' Read and parse the lines in the file one by one','line_number':2783,'multiline':False]['text':' check for CTRL-C typed, more often when jumping around','line_number':2786,'multiline':False]['text':' Double brackets for gcc','line_number':2791,'multiline':False]['text':' When mincount is TAG_MANY, stop when enough matches have been','line_number':2798,'multiline':False]['text':' found (for completion).','line_number':2799,'multiline':False]['text':' Emacs tags line with CTRL-L: New file name on next line.','line_number':2820,'multiline':False]['text':' The file name is followed by a ','.','line_number':2821,'multiline':False]['text':' Remember etag file name in ebuf.','line_number':2822,'multiline':False]['text':' in case at the start','line_number':2829,'multiline':False]['text':' When still at the start of the file, check for Emacs tags file','line_number':2836,'multiline':False]['text':' format, and for "not sorted" flag.','line_number':2837,'multiline':False]['text':' When the line is too long the NUL will not be in the','line_number':2844,'multiline':False]['text':' last-but-one byte (see vim_fgets()).','line_number':2845,'multiline':False]['text':' Has been reported for Mozilla JS with extremely long names.','line_number':2846,'multiline':False]['text':' In that case we need to increase lbuf_size.','line_number':2847,'multiline':False]['text':' Seek to the same position to read the same line again','line_number':2867,'multiline':False]['text':' this will try the same thing again, make sure the offset is','line_number':2870,'multiline':False]['text':' different','line_number':2871,'multiline':False]['text':' If a match is found, add it to ht_match[] and ga_match[].','line_number':2892,'multiline':False]['text':' forever','line_number':2899,'multiline':False]['text':'
 * Search for tags matching "st->orgpat->pat" in the "st->tag_fname" tags file.
 * Information needed to search for the tags is in the "st" state structure.
 * The matching tags are returned in "st". If an error is encountered, then
 * "st->stop_searching" is set to TRUE.
 ','line_number':2902,'multiline':True]['text':' A file that doesn't exist is silently ignored.  Only when not a','line_number':2921,'multiline':False]['text':' single file is found, an error message is given (further on).','line_number':2922,'multiline':False]['text':' avoid GCC warning','line_number':2925,'multiline':False]['text':' remember that we found at least one file','line_number':2948,'multiline':False]['text':' we're at the start of the file','line_number':2950,'multiline':False]['text':' default is: not emacs style','line_number':2952,'multiline':False]['text':' Read and parse the lines in the file one by one','line_number':2955,'multiline':False]['text':' Stop searching if sufficient tags have been found.','line_number':2972,'multiline':False]['text':'
 * Copy the tags found by find_tags() to "matchesp".
 * Returns the number of matches copied.
 ','line_number':2977,'multiline':True]['text':' Change mtt back to zero-based.','line_number':3007,'multiline':False]['text':' change the TAG_SEP back to NUL','line_number':3010,'multiline':False]['text':'
 * find_tags() - search for tags in tags files
 *
 * Return FAIL if search completely failed (*num_matches will be 0, *matchesp
 * will be NULL), OK otherwise.
 *
 * Priority depending on which type of tag is recognized:
 *  6.	A static or global tag with a full matching tag for the current file.
 *  5.	A global tag with a full matching tag for another file.
 *  4.	A static tag with a full matching tag for another file.
 *  3.	A static or global tag with an ignore-case matching tag for the
 *	current file.
 *  2.	A global tag with an ignore-case matching tag for another file.
 *  1.	A static tag with an ignore-case matching tag for another file.
 *
 * Tags in an emacs-style tags file are always global.
 *
 * flags:
 * TAG_HELP	  only search for help tags
 * TAG_NAMES	  only return name of tag
 * TAG_REGEXP	  use "pat" as a regexp
 * TAG_NOIC	  don't always ignore case
 * TAG_KEEP_LANG  keep language
 * TAG_CSCOPE	  use cscope results for tags
 * TAG_NO_TAGFUNC do not call the 'tagfunc' function
 ','line_number':3027,'multiline':True]['text':' pattern to search for','line_number':3055,'multiline':False]['text':' return: number of matches found','line_number':3056,'multiline':False]['text':' return: array of matches found','line_number':3057,'multiline':False]['text':' MAXCOL: find all matches','line_number':3059,'multiline':False]['text':' other: minimal number of matches','line_number':3060,'multiline':False]['text':' name of buffer for priority','line_number':3061,'multiline':False]['text':' info for get_tagfname()','line_number':3064,'multiline':False]['text':' trying first tag file','line_number':3065,'multiline':False]['text':' return value','line_number':3066,'multiline':False]['text':' copy of pat[]','line_number':3074,'multiline':False]['text':' find all matching tags','line_number':3078,'multiline':False]['text':' regexp used','line_number':3079,'multiline':False]['text':'
     * Change the value of 'ignorecase' according to 'tagcase' for the
     * duration of this function.
     ','line_number':3087,'multiline':True]['text':' for error messages','line_number':3106,'multiline':False]['text':'
     * Initialize a few variables
     ','line_number':3109,'multiline':True]['text':' want tags from help file','line_number':3112,'multiline':False]['text':' will be restored later','line_number':3113,'multiline':False]['text':' Make sure we don't mix help and cscope, confuses Coverity.','line_number':3117,'multiline':False]['text':' When "@ab" is specified use only the "ab" language, otherwise','line_number':3126,'multiline':False]['text':' search all languages.','line_number':3127,'multiline':False]['text':' adjust for 'taglength'','line_number':3142,'multiline':False]['text':' don't want error for invalid RE here','line_number':3146,'multiline':False]['text':' re-initialize the default return value','line_number':3157,'multiline':False]['text':' Set a flag if the file extension is .txt','line_number':3162,'multiline':False]['text':'
     * When finding a specified number of matches, first try with matching
     * case, so binary search can be used, and try ignore-case matches in a
     * second loop.
     * When finding all matches, 'tagbsearch' is off, or there is no fixed
     * string to look for, ignore case right away to avoid going though the
     * tags files twice.
     * When the tag file is case-fold sorted, it is either one or the other.
     * Only ignore case when TAG_NOIC not used or 'ignorecase' set.
     ','line_number':3171,'multiline':True]['text':'
       * Try tag file names from tags option one by one.
       ','line_number':3187,'multiline':True]['text':' end of for-each-file loop','line_number':3207,'multiline':False]['text':' stop searching when already did a linear search, or when TAG_NOIC','line_number':3214,'multiline':False]['text':' used, and 'ignorecase' not set or already did case-ignore search','line_number':3215,'multiline':False]['text':' try another time while ignoring case','line_number':3224,'multiline':False]['text':' never opened any tags file','line_number':3230,'multiline':False]['text':' It's OK even when no tag found','line_number':3232,'multiline':False]['text':'
     * Move the matches from the ga_match[] arrays into one list of
     * matches.  When retval == FAIL, free the matches.
     ','line_number':3238,'multiline':True]['text':'
 * Callback function for finding all "tags" and "tags-??" files in
 * 'runtimepath' doc directories.
 ','line_number':3259,'multiline':True]['text':'
 * Get the next name of a tag file from the tag file list.
 * For help files, use "tags" file only.
 *
 * Return FAIL if no more tag file names, OK otherwise.
 ','line_number':3293,'multiline':True]['text':' holds status info','line_number':3301,'multiline':False]['text':' TRUE when first file name is wanted','line_number':3302,'multiline':False]['text':' pointer to buffer of MAXPATHL chars','line_number':3303,'multiline':False]['text':'
	 * For help files it's done in a completely different way:
	 * Find "doc/tags" and "doc/tags-??" in all directories in
	 * 'runtimepath'.
	 ','line_number':3314,'multiline':True]['text':' Functions decc$to_vms() and decc$translate_vms() crash','line_number':3326,'multiline':False]['text':' on some VMS systems with wildcards "??".  Seems ECO','line_number':3327,'multiline':False]['text':' patches do fix the problem in C RTL, but we can't use','line_number':3328,'multiline':False]['text':' an #ifdef for that.','line_number':3329,'multiline':False]['text':' Not found in 'runtimepath', use 'helpfile', if it exists and','line_number':3342,'multiline':False]['text':' wasn't used yet, replacing "help.txt" with "tags".','line_number':3343,'multiline':False]['text':' avoid duplicate file names','line_number':3356,'multiline':False]['text':' Init.  We make a copy of 'tags', because autocommands may change','line_number':3366,'multiline':False]['text':' the value without notifying us.','line_number':3367,'multiline':False]['text':'
     * Loop until we have found a file name that can be used.
     * There are two states:
     * tnp->tn_did_filefind_init == FALSE: setup for next part in 'tags'.
     * tnp->tn_did_filefind_init == TRUE: find next file in this part.
     ','line_number':3375,'multiline':True]['text':' Stop when used all parts of 'tags'.','line_number':3395,'multiline':False]['text':'
	     * Copy next file name into buf.
	     ','line_number':3403,'multiline':True]['text':' move the filename one char forward and truncate the','line_number':3410,'multiline':False]['text':' filepath with a NUL','line_number':3411,'multiline':False]['text':' don't free visited list','line_number':3418,'multiline':False]['text':' we search for a file','line_number':3419,'multiline':False]['text':'
 * Free the contents of a tagname_T that was filled by get_tagfname().
 ','line_number':3431,'multiline':True]['text':'
 * Parse one line from the tags file. Find start/end of tag name, start/end of
 * file name and start of search pattern.
 *
 * If is_etag is TRUE, tagp->fname and tagp->fname_end are not set.
 *
 * Return FAIL if there is a format error in this line, OK otherwise.
 ','line_number':3443,'multiline':True]['text':' line to be parsed','line_number':3453,'multiline':False]['text':' emacs-style tag file','line_number':3463,'multiline':False]['text':' Isolate the tagname, from lbuf up to the first white','line_number':3467,'multiline':False]['text':' Isolate file name, from first to second white space','line_number':3474,'multiline':False]['text':' find start of search command, after second white space','line_number':3483,'multiline':False]['text':'
 * Check if tagname is a static tag
 *
 * Static tags produced by the older ctags program have the format:
 *	'file:tag  file  /pattern'.
 * This is only recognized when both occurrence of 'file' are the same, to
 * avoid recognizing "string::string" or ":exit".
 *
 * Static tags produced by the new ctags program have the format:
 *	'tag  file  /pattern/;"<Tab>file:'	    "
 *
 * Return TRUE if it is a static tag and adjust *tagname to the real tag.
 * Return FALSE if it is not a static tag.
 ','line_number':3493,'multiline':True]['text':'
     * Check for new style static tag ":...<Tab>file:[<Tab>...]"
     ','line_number':3512,'multiline':True]['text':'
 * Returns the length of a matching tag line.
 ','line_number':3526,'multiline':True]['text':' does the same thing as parse_match()','line_number':3534,'multiline':False]['text':'
 * Parse a line from a matching tag.  Does not change the line itself.
 *
 * The line that we get looks like this:
 * Emacs tag: <mtt><tag_fname><NUL><ebuf><NUL><lbuf>
 * other tag: <mtt><tag_fname><NUL><NUL><lbuf>
 * without Emacs tags: <mtt><tag_fname><NUL><lbuf>
 *
 * Return OK or FAIL.
 ','line_number':3542,'multiline':True]['text':' input: matching line','line_number':3554,'multiline':False]['text':' output: pointers into the line','line_number':3555,'multiline':False]['text':' Find search pattern and the file name for non-etags.','line_number':3578,'multiline':False]['text':' Try to find a kind field: "kind:<kind>" or just "<kind>"','line_number':3593,'multiline':False]['text':' drop trailing bar','line_number':3598,'multiline':False]['text':' skip ";\""','line_number':3601,'multiline':False]['text':' Accept ASCII alphabetic kind characters and any multi-byte','line_number':3603,'multiline':False]['text':' character.','line_number':3604,'multiline':False]['text':'
 * Find out the actual file name of a tag.  Concatenate the tags file name
 * with the matching tag file name.
 * Returns an allocated string or NULL (out of memory).
 ','line_number':3642,'multiline':True]['text':' to shut up GCC','line_number':3655,'multiline':False]['text':'
 * Jump to a tag that has been found in one of the tag files
 *
 * returns OK for success, NOTAGFILE when file not found, FAIL otherwise.
 ','line_number':3672,'multiline':True]['text':' line from the tags file for this tag','line_number':3679,'multiline':False]['text':' :ta with !','line_number':3680,'multiline':False]['text':' keep help flag (FALSE for cscope)','line_number':3681,'multiline':False]['text':' search pattern buffer','line_number':3687,'multiline':False]['text':' getting the file may reset it','line_number':3703,'multiline':False]['text':' Make a copy of the line, it can become invalid when an autocommand calls','line_number':3708,'multiline':False]['text':' back here recursively.','line_number':3709,'multiline':False]['text':' parse the match line into the tagp structure','line_number':3717,'multiline':False]['text':' truncate the file name, so it can be used as a string','line_number':3724,'multiline':False]['text':' copy the command to pbuf[], remove trailing CR/NL','line_number':3728,'multiline':False]['text':' stop at ',' after line number','line_number':3733,'multiline':False]['text':'
	 * Remove the "<Tab>fieldname:value" stuff; we don't need it here.
	 ','line_number':3746,'multiline':True]['text':'
     * Expand file name, when needed (for environment variables).
     * If 'tagrelative' option set, may change file name.
     ','line_number':3757,'multiline':True]['text':' free() it later','line_number':3764,'multiline':False]['text':'
     * Check if the file with the tag exists before abandoning the current
     * file.  Also accept a file name for which there is a matching BufReadCmd
     * autocommand event (e.g., http://sys/file).
     ','line_number':3766,'multiline':True]['text':' don't split again below','line_number':3790,'multiline':False]['text':' Save current window','line_number':3791,'multiline':False]['text':'
	 * If we are reusing a window, we may change dir when
	 * entering it (autocommands) so turn the tag filename
	 * into a fullpath
	 ','line_number':3793,'multiline':True]['text':'
	     * Make the preview window the current window.
	     * Open a preview window when needed.
	     ','line_number':3803,'multiline':True]['text':' If it was a CTRL-W CTRL-] command split window now.  For ":tab tag"','line_number':3811,'multiline':False]['text':' open a new tab page.','line_number':3812,'multiline':False]['text':' If 'switchbuf' is set jump to the window containing "buf".','line_number':3819,'multiline':False]['text':' We've switched to the buffer, the usual loading of the file','line_number':3821,'multiline':False]['text':' must be skipped.','line_number':3822,'multiline':False]['text':' A :ta from a help file will keep the b_help flag set.  For ":ptag"','line_number':3842,'multiline':False]['text':' we need to use the flag from the window where we came from.','line_number':3843,'multiline':False]['text':' Careful: getfile() may trigger autocommands and call jumpto_tag()','line_number':3853,'multiline':False]['text':' recursively.','line_number':3854,'multiline':False]['text':' got to the right file','line_number':3858,'multiline':False]['text':' always execute with 'nomagic'','line_number':3864,'multiline':False]['text':' Save value of no_hlsearch, jumping to a tag is not a real search','line_number':3866,'multiline':False]['text':' getfile() may have cleared options, apply 'previewpopup' again.','line_number':3870,'multiline':False]['text':'
	 * If 'cpoptions' contains 't', store the search pattern for the "n"
	 * command.  If 'cpoptions' does not contain 't', the search pattern
	 * is not stored.
	 ','line_number':3875,'multiline':True]['text':'
	 * If the command is a search, try here.
	 *
	 * Reset 'smartcase' for the search, since the search pattern was not
	 * typed by the user.
	 * Only use do_search() when there is a full search command, without
	 * anything following.
	 ','line_number':3885,'multiline':True]['text':' search command with nothing following','line_number':3896,'multiline':False]['text':' need 'wrapscan' for backward searches','line_number':3901,'multiline':False]['text':' don't ignore case now','line_number':3902,'multiline':False]['text':' start search before line from "line:" field','line_number':3906,'multiline':False]['text':' start search before first line','line_number':3909,'multiline':False]['text':'
		 * try again, ignore case now
		 ','line_number':3919,'multiline':True]['text':'
		     * Failed to find pattern, take a guess: "^func  ("
		     ','line_number':3926,'multiline':True]['text':' Guess again: "^char * \<func  ("','line_number':3937,'multiline':False]['text':'
		     * Only give a message when really guessed, not when 'ic'
		     * is set and match found while ignoring case.
		     ','line_number':3953,'multiline':True]['text':' A search command may have positioned the cursor beyond the end','line_number':3973,'multiline':False]['text':' of the line.  May need to correct that here.','line_number':3974,'multiline':False]['text':' Setup the sandbox for executing the command from the tags file.','line_number':3981,'multiline':False]['text':' start command in line 1','line_number':3986,'multiline':False]['text':' When the command has done something that is not allowed make','line_number':3990,'multiline':False]['text':' sure the error message can be seen.','line_number':3991,'multiline':False]['text':' restore no_hlsearch when keeping the old search pattern','line_number':4002,'multiline':False]['text':' Return OK if jumped to another file (at least we found the file!).','line_number':4007,'multiline':False]['text':'
	     * For a help buffer: Put the cursor line at the top of the window,
	     * the help subject will be below it.
	     ','line_number':4013,'multiline':True]['text':' Return cursor to where we were','line_number':4029,'multiline':False]['text':' don't want entering window to fail','line_number':4043,'multiline':False]['text':' close the window','line_number':4045,'multiline':False]['text':' something went wrong, still in popup, but it can't have focus','line_number':4063,'multiline':False]['text':' For next time','line_number':4069,'multiline':False]['text':'
 * If "expand" is TRUE, expand wildcards in fname.
 * If 'tagrelative' option set, change fname (name of file containing tag)
 * according to tag_fname (name of tag file containing fname).
 * Returns a pointer to allocated memory (or NULL when out of memory).
 ','line_number':4079,'multiline':True]['text':'
     * Expand file name (for environment variables) when needed.
     ','line_number':4093,'multiline':True]['text':'
	     * Translate names like "src/a/../b/file.c" into "src/b/file.c".
	     ','line_number':4116,'multiline':True]['text':'
 * Check if we have a tag for the buffer with name "buf_ffname".
 * This is a bit slow, because of the full path compare in fullpathcmp().
 * Return TRUE if tag for file "fname" if tag file "tag_fname" is for current
 * file.
 ','line_number':4130,'multiline':True]['text':' if the buffer has a name','line_number':4150,'multiline':False]['text':' to shut up GCC','line_number':4154,'multiline':False]['text':'
 * Find the end of the tagaddress.
 * Return OK if ";\"" is following, FAIL otherwise.
 ','line_number':4176,'multiline':True]['text':' Repeat for addresses separated with ';'','line_number':4186,'multiline':False]['text':' not a line number or search string, look for terminator.','line_number':4201,'multiline':False]['text':' skip ';'','line_number':4213,'multiline':False]['text':'
 * Free a single entry in a tag stack
 ','line_number':4225,'multiline':True]['text':' expand tag names','line_number':4237,'multiline':False]['text':' Reorganize the tags for display and matching as strings of:','line_number':4267,'multiline':False]['text':' "<tagname>\0<kind>\0<filename>\0"','line_number':4268,'multiline':False]['text':'
 * Add a tag field to the dictionary "dict".
 * Return OK or FAIL.
 ','line_number':4306,'multiline':True]['text':' start of the value','line_number':4314,'multiline':False]['text':' after the value; can be NULL','line_number':4315,'multiline':False]['text':' check that the field name doesn't exist yet','line_number':4321,'multiline':False]['text':'
 * Add the tags matching the specified pattern "pat" to the list "list"
 * as a dictionary. Use "buf_fname" for priority, unless NULL.
 ','line_number':4354,'multiline':True]['text':' Skip pseudo-tag lines.','line_number':4383,'multiline':False]['text':' skip "kind:<kind>" and "<kind>"','line_number':4419,'multiline':False]['text':' skip "file:" (static tag)','line_number':4422,'multiline':False]['text':' Add extra field as a dict entry.  Fields are','line_number':4429,'multiline':False]['text':' separated by Tabs.','line_number':4430,'multiline':False]['text':' Skip field without colon.','line_number':4446,'multiline':False]['text':'
 * Return information about 'tag' in dict 'retdict'.
 ','line_number':4461,'multiline':True]['text':'
 * Return the tag stack entries of the specified window 'wp' in dictionary
 * 'retdict'.
 ','line_number':4489,'multiline':True]['text':'
 * Free all the entries in the tag stack of the specified window
 ','line_number':4517,'multiline':True]['text':' Free the current tag stack','line_number':4525,'multiline':False]['text':'
 * Remove the oldest entry from the tag stack and shift the rest of
 * the entries to free up the top of the stack.
 ','line_number':4532,'multiline':True]['text':'
 * Push a new item to the tag stack
 ','line_number':4548,'multiline':True]['text':' top of the stack','line_number':4562,'multiline':False]['text':' if the tagstack is full: remove the oldest entry','line_number':4564,'multiline':False]['text':'
 * Add a list of items to the tag stack in the specified window
 ','line_number':4582,'multiline':True]['text':' Add one entry at a time to the tag stack','line_number':4595,'multiline':False]['text':' Skip non-dict items','line_number':4599,'multiline':False]['text':' parse 'from' for the cursor position before the tag jump','line_number':4602,'multiline':False]['text':'
 * Set the current index in the tag stack. Valid values are between 0
 * and the stack length (inclusive).
 ','line_number':4620,'multiline':True]['text':' sanity check','line_number':4628,'multiline':False]['text':'
 * Set the tag stack entries of the specified window.
 * 'action' is set to one of:
 *	'a' for append
 *	'r' for replace
 *	't' for truncate
 ','line_number':4634,'multiline':True]['text':' not allowed to alter the tag stack entries from inside tagfunc','line_number':4648,'multiline':False]['text':' truncate the stack','line_number':4669,'multiline':False]['text':' delete all the tag stack entries above the current entry','line_number':4675,'multiline':False]['text':' replace the stack','line_number':4683,'multiline':False]['text':' set the current index after the last entry','line_number':4687,'multiline':False]