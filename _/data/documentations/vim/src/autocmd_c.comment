['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]['text':'
 * autocmd.c: Autocommand related functions
 ','line_number':10,'multiline':True]['text':'
 * The autocommands are stored in a list for each event.
 * Autocommands for the same pattern, that are consecutive, are joined
 * together, to avoid having to match the pattern too often.
 * The result is an array of Autopat lists, which point to AutoCmd lists:
 *
 * last_autopat[0]  -----------------------------+
 *						 V
 * first_autopat[0] --> Autopat.next  -->  Autopat.next -->  NULL
 *			Autopat.cmds	   Autopat.cmds
 *			    |			 |
 *			    V			 V
 *			AutoCmd.next	   AutoCmd.next
 *			    |			 |
 *			    V			 V
 *			AutoCmd.next		NULL
 *			    |
 *			    V
 *			   NULL
 *
 * last_autopat[1]  --------+
 *			    V
 * first_autopat[1] --> Autopat.next  -->  NULL
 *			Autopat.cmds
 *			    |
 *			    V
 *			AutoCmd.next
 *			    |
 *			    V
 *			   NULL
 *   etc.
 *
 *   The order of AutoCmds is important, this is the order in which they were
 *   defined and will have to be executed.
 ','line_number':16,'multiline':True]['text':' The command to be executed (NULL','line_number':53,'multiline':False]['text':' when command has been removed).','line_number':54,'multiline':False]['text':' "One shot": removed after execution','line_number':55,'multiline':False]['text':' If autocommands nest here.','line_number':56,'multiline':False]['text':' last command in list','line_number':57,'multiline':False]['text':' script context where it is defined','line_number':58,'multiline':False]['text':' next AutoCmd in list','line_number':59,'multiline':False]['text':' Next AutoPat in AutoPat list; MUST','line_number':64,'multiline':False]['text':' be the first entry.','line_number':65,'multiline':False]['text':' pattern as typed (NULL when pattern','line_number':66,'multiline':False]['text':' has been removed)','line_number':67,'multiline':False]['text':' compiled regprog for pattern','line_number':68,'multiline':False]['text':' list of commands to do','line_number':69,'multiline':False]['text':' group ID','line_number':70,'multiline':False]['text':' strlen() of pat','line_number':71,'multiline':False]['text':' !=0 for buffer-local AutoPat','line_number':72,'multiline':False]['text':' Pattern may match whole path','line_number':73,'multiline':False]['text':' last pattern for apply_autocmds()','line_number':74,'multiline':False]['text':' event name','line_number':79,'multiline':False]['text':' event number','line_number':80,'multiline':False]['text':' default autocmd group','line_number':223,'multiline':False]['text':' erroneous autocmd group','line_number':224,'multiline':False]['text':' all autocmd groups','line_number':225,'multiline':False]['text':'
 * struct used to keep status while executing autocommands for an event.
 ','line_number':227,'multiline':True]['text':' next AutoPat to examine','line_number':232,'multiline':False]['text':' next AutoCmd to execute','line_number':233,'multiline':False]['text':' group being used','line_number':234,'multiline':False]['text':' fname to match with','line_number':235,'multiline':False]['text':' sfname to match with','line_number':236,'multiline':False]['text':' tail of fname','line_number':237,'multiline':False]['text':' current event','line_number':238,'multiline':False]['text':' script context where it is defined','line_number':239,'multiline':False]['text':' Initially equal to <abuf>, set to zero when','line_number':240,'multiline':False]['text':' buf is deleted.','line_number':241,'multiline':False]['text':' chain of active apc-s for auto-invalidation','line_number':242,'multiline':False]['text':' stack of active autocommands','line_number':245,'multiline':False]['text':' Macro to loop over all the patterns for an autocmd event','line_number':247,'multiline':False]['text':'
 * augroups stores a list of autocmd group names.
 ','line_number':251,'multiline':True]['text':' use get_deleted_augroup() to get this','line_number':256,'multiline':False]['text':'
 * The ID of the current group.  Group 0 is the default one.
 ','line_number':259,'multiline':True]['text':' need to delete marked patterns','line_number':264,'multiline':False]['text':' block all autocmds','line_number':275,'multiline':False]['text':'
 * Show the autocommands for one AutoPat.
 ','line_number':285,'multiline':True]['text':' Check for "got_int" (here and at various places below), which is set','line_number':293,'multiline':False]['text':' when "q" has been hit for the "--more--" prompt','line_number':294,'multiline':False]['text':' pattern has been removed','line_number':297,'multiline':False]['text':' Make sure no info referenced by "ap" is cleared, e.g. when a timer','line_number':300,'multiline':False]['text':' clears an augroup.  Jump to "theend" after this!','line_number':301,'multiline':False]['text':' "ap->pat" may be cleared anyway.','line_number':302,'multiline':False]['text':' timer might have cleared the pattern or group','line_number':327,'multiline':False]['text':' skip removed commands','line_number':334,'multiline':False]['text':'
 * Mark an autocommand pattern for deletion.
 ','line_number':361,'multiline':True]['text':'
 * Mark all commands for a pattern for deletion.
 ','line_number':372,'multiline':True]['text':' Delete one command from an autocmd pattern.','line_number':385,'multiline':False]['text':'
 * Cleanup autocommands and patterns that have been deleted.
 * This is only done when not executing autocommands.
 ','line_number':392,'multiline':True]['text':' loop over all events','line_number':406,'multiline':False]['text':' loop over all autocommand patterns','line_number':410,'multiline':False]['text':' loop over all commands for this pattern','line_number':416,'multiline':False]['text':' remove the command if the pattern is to be deleted or when','line_number':420,'multiline':False]['text':' the command has been marked for deletion','line_number':421,'multiline':False]['text':' Pattern was not marked for deletion, but all of its','line_number':436,'multiline':False]['text':' commands were.  So mark the pattern for deletion.','line_number':437,'multiline':False]['text':' remove the pattern if it has been marked for deletion','line_number':440,'multiline':False]['text':' this depends on the "next" field being the first in','line_number':448,'multiline':False]['text':' the struct','line_number':449,'multiline':False]['text':'
 * Called when buffer is freed, to remove/invalidate related buffer-local
 * autocmds.
 ','line_number':464,'multiline':True]['text':' invalidate currently executing autocommands','line_number':475,'multiline':False]['text':' invalidate buflocals looping through events','line_number':480,'multiline':False]['text':' loop over all autocommand patterns','line_number':483,'multiline':False]['text':'
 * Add an autocmd group name.
 * Return its ID.  Returns AUGROUP_ERROR (< 0) for error.
 ','line_number':499,'multiline':True]['text':' the group doesn't exist yet, add it.  First try using a free entry.','line_number':512,'multiline':False]['text':' the group doesn't exist','line_number':538,'multiline':False]['text':'
 * Find the ID of an autocmd group name.
 * Return its ID.  Returns AUGROUP_ERROR (< 0) for error.
 ','line_number':568,'multiline':True]['text':'
 * Return TRUE if augroup "name" exists.
 ','line_number':584,'multiline':True]['text':'
 * ":augroup {name}".
 ','line_number':593,'multiline':True]['text':' ":aug end": back to group 0','line_number':608,'multiline':False]['text':' ":aug xxx": switch to group xxx','line_number':610,'multiline':False]['text':' ":aug": list the group names','line_number':616,'multiline':False]['text':' aucmd_win[] is freed in win_free_all()','line_number':656,'multiline':False]['text':'
 * Return TRUE if "win" is an active entry in aucmd_win[].
 ','line_number':660,'multiline':True]['text':'
 * Return the event number for event name "start".
 * Return NUM_EVENTS if the event name was not found.
 * Return a pointer to the next event name in "end".
 ','line_number':672,'multiline':True]['text':' the event name ends with end of line, '|', a blank or a comma','line_number':684,'multiline':False]['text':'
 * Return the name for event "event".
 ','line_number':701,'multiline':True]['text':'
 * Scan over the events.  "*" stands for all events.
 ','line_number':715,'multiline':True]['text':' TRUE when group name was found','line_number':721,'multiline':False]['text':'
 * Return TRUE if "event" is included in 'eventignore'.
 ','line_number':752,'multiline':True]['text':'
 * Return OK when the contents of p_ei is valid, FAIL otherwise.
 ','line_number':771,'multiline':True]['text':'
 * Add "what" to 'eventignore' to skip loading syntax highlighting for every
 * buffer loaded into the window.  "what" must start with a comma.
 * Returns the old value of 'eventignore' in allocated memory.
 ','line_number':796,'multiline':True]['text':' FEAT_SYN_HL','line_number':838,'multiline':False]['text':'
 * do_autocmd() -- implements the :autocmd command.  Can be used in the
 *  following ways:
 *
 * :autocmd <event> <pat> <cmd>	    Add <cmd> to the list of commands that
 *				    will be automatically executed for <event>
 *				    when editing a file matching <pat>, in
 *				    the current group.
 * :autocmd <event> <pat>	    Show the autocommands associated with
 *				    <event> and <pat>.
 * :autocmd <event>		    Show the autocommands associated with
 *				    <event>.
 * :autocmd			    Show all autocommands.
 * :autocmd! <event> <pat> <cmd>    Remove all autocommands associated with
 *				    <event> and <pat>, and add the command
 *				    <cmd>, for the current group.
 * :autocmd! <event> <pat>	    Remove all autocommands associated with
 *				    <event> and <pat> for the current group.
 * :autocmd! <event>		    Remove all autocommands associated with
 *				    <event> for the current group.
 * :autocmd!			    Remove ALL autocommands for the current
 *				    group.
 *
 *  Multiple events and patterns may be given separated by commas.  Here are
 *  some examples:
 * :autocmd bufread,bufenter *.c,*.h	set tw=0 smartindent noic
 * :autocmd bufleave	     *		set tw=79 nosmartindent ic infercase
 *
 * :autocmd * *.c		show all autocommands for *.c files.
 *
 * Mostly a {group} argument can optionally appear before <event>.
 * "eap" can be NULL.
 ','line_number':840,'multiline':True]['text':' no argument, use all groups','line_number':893,'multiline':False]['text':'
	 * Check for a legal group name.  If not, use AUGROUP_ALL.
	 ','line_number':897,'multiline':True]['text':' out of memory','line_number':901,'multiline':False]['text':'
     * Scan over the events.
     * If we find an illegal name, return here, don't do anything.
     ','line_number':905,'multiline':True]['text':'
	 * Scan over the pattern.  Put a NUL at the end.
	 ','line_number':922,'multiline':True]['text':' Expand environment variables in the pattern.  Set 'shellslash', we','line_number':931,'multiline':False]['text':' want forward slashes here.','line_number':932,'multiline':False]['text':' Check for "++once" flag.','line_number':954,'multiline':False]['text':' Check for "++nested" flag.','line_number':963,'multiline':False]['text':' Check for the old "nested" flag in legacy script.','line_number':975,'multiline':False]['text':' If there ever is a :nested command this error should','line_number':980,'multiline':False]['text':' be removed and "nested" accepted as the start of the','line_number':981,'multiline':False]['text':' command.','line_number':982,'multiline':False]['text':'
	 * Find the start of the commands.
	 * Expand <sfile> in it.
	 ','line_number':996,'multiline':True]['text':' Read a {} block if it follows.','line_number':1003,'multiline':False]['text':' some error','line_number':1007,'multiline':False]['text':'
     * Print header when showing autocommands.
     ','line_number':1013,'multiline':True]['text':' Highlight title','line_number':1017,'multiline':False]['text':'
     * Loop over the events.
     ','line_number':1020,'multiline':True]['text':' for listing the event name','line_number':1023,'multiline':False]['text':' for listing the group name','line_number':1024,'multiline':False]['text':'
 * Find the group ID in a ":autocmd" or ":doautocmd" argument.
 * The "argp" argument is advanced to the following argument.
 *
 * Returns the group ID, AUGROUP_ERROR for error (out of memory).
 ','line_number':1050,'multiline':True]['text':' out of memory','line_number':1070,'multiline':False]['text':' no match, use all groups','line_number':1074,'multiline':False]['text':' match, skip over group name','line_number':1076,'multiline':False]['text':'
 * do_autocmd() for one event.
 * If *pat == NUL do for all patterns.
 * If *cmd == NUL show entries.
 * If forceit == TRUE delete entries.
 * If group is not AUGROUP_ALL, only use this group.
 ','line_number':1081,'multiline':True]['text':' for "<buffer=X>"','line_number':1110,'multiline':False]['text':'
     * Show or delete all patterns for an event.
     ','line_number':1118,'multiline':True]['text':' delete the AutoPat, if it's in the current group','line_number':1125,'multiline':False]['text':'
     * Loop through all the specified patterns.
     ','line_number':1135,'multiline':True]['text':'
	 * Find end of the pattern.
	 * Watch out for a comma in braces, like "*.\{obj,o\}".
	 ','line_number':1140,'multiline':True]['text':' ignore single comma','line_number':1153,'multiline':False]['text':'
	 * detect special <buflocal[=X]> buffer-local patterns
	 ','line_number':1157,'multiline':True]['text':' "<buffer...>": Error will be printed only for addition.','line_number':1166,'multiline':False]['text':' printing and removing will proceed silently.','line_number':1167,'multiline':False]['text':' "<buffer>"','line_number':1170,'multiline':False]['text':' "<buffer=abuf>"','line_number':1175,'multiline':False]['text':' "<buffer=123>"','line_number':1178,'multiline':False]['text':' normalize pat into standard "<buffer>#N" form','line_number':1185,'multiline':False]['text':' can modify pat and patlen','line_number':1187,'multiline':False]['text':'   but not endpat','line_number':1188,'multiline':False]['text':'
	 * Find AutoPat entries with this pattern.  When adding a command it
	 * always goes at or after the last one, so start at the end.
	 ','line_number':1191,'multiline':True]['text':'
		 * Accept a pattern when:
		 * - a group was specified and it's that group, or a group was
		 *   not specified and it's the current group, or a group was
		 *   not specified and we are listing
		 * - the length of the pattern matches
		 * - the pattern matches.
		 * For <buffer[=X]>, this condition works because we normalize
		 * all buffer-local patterns.
		 ','line_number':1203,'multiline':True]['text':'
		     * Remove existing autocommands.
		     * If adding any new autocmd's for this AutoPat, don't
		     * delete the pattern from the autopat list, append to
		     * this list.
		     ','line_number':1217,'multiline':True]['text':'
		     * Show autocmd's for this autopat, or buflocals <buffer=X>
		     ','line_number':1233,'multiline':True]['text':'
		     * Add autocmd to this autopat, if it's the last one.
		     ','line_number':1239,'multiline':True]['text':'
	 * Add a new command.
	 ','line_number':1249,'multiline':True]['text':'
	     * If the pattern we want to add a command to does appear at the
	     * end of the list (or not is not in the list at all), add the
	     * pattern at the end of the list.
	     ','line_number':1254,'multiline':True]['text':' refuse to add buffer-local ap if buffer number is invalid','line_number':1261,'multiline':False]['text':' need to initialize last_mode for the first ModeChanged','line_number':1281,'multiline':False]['text':' autocmd','line_number':1282,'multiline':False]['text':' Initialize the fields checked by the WinScrolled and','line_number':1286,'multiline':False]['text':' WinResized trigger to prevent them from firing right after','line_number':1287,'multiline':False]['text':' the first autocmd is defined.','line_number':1288,'multiline':False]['text':'
	     * Add the autocmd at the end of the AutoCmd list.
	     ','line_number':1336,'multiline':True]['text':' may really delete removed patterns/commands now','line_number':1364,'multiline':False]['text':'
 * Implementation of ":doautocmd [group] event [fname]".
 * Return OK for success, FAIL for failure;
 ','line_number':1368,'multiline':True]['text':' give message for no matching autocmds?','line_number':1375,'multiline':False]['text':'
     * Check for a legal group name.  If not, use AUGROUP_ALL.
     ','line_number':1386,'multiline':True]['text':' out of memory','line_number':1390,'multiline':False]['text':'
     * Scan over the events.
     * If we find an illegal name, return here, don't do anything.
     ','line_number':1399,'multiline':True]['text':'
     * Loop over the events.
     ','line_number':1409,'multiline':True]['text':'
 * ":doautoall": execute autocommands for each loaded buffer.
 ','line_number':1433,'multiline':True]['text':'
     * This is a bit tricky: For some commands curwin->w_buffer needs to be
     * equal to curbuf, but for some buffers there may not be a window.
     * So we change the buffer for the current window for a moment.  This
     * gives problems when the autocommands make changes to the list of
     * buffers or windows...
     ','line_number':1447,'multiline':True]['text':' Only do loaded buffers and skip the current buffer, it's done last.','line_number':1456,'multiline':False]['text':' Find a window for this buffer and save some values.','line_number':1460,'multiline':False]['text':' Failed to find a window for this buffer.  Better not execute','line_number':1464,'multiline':False]['text':' autocommands then.','line_number':1465,'multiline':False]['text':' execute the autocommands for this buffer','line_number':1472,'multiline':False]['text':' Execute the modeline settings, but don't set window-local','line_number':1476,'multiline':False]['text':' options if we are using the current window for another','line_number':1477,'multiline':False]['text':' buffer.','line_number':1478,'multiline':False]['text':' restore the current window','line_number':1481,'multiline':False]['text':' stop if there is some error or buffer was deleted','line_number':1484,'multiline':False]['text':' Execute autocommands for the current buffer last.','line_number':1492,'multiline':False]['text':'
 * Check *argp for <nomodeline>.  When it is present return FALSE, otherwise
 * return TRUE and advance *argp to after it.
 * Thus return TRUE when do_modelines() should be called.
 ','line_number':1501,'multiline':True]['text':'
 * Prepare for executing autocommands for (hidden) buffer "buf".
 * Search for a visible window containing the current buffer.  If there isn't
 * one then use an entry in "aucmd_win[]".
 * Set "curbuf" and "curwin" to match "buf".
 * When this fails "curbuf" is not equal "buf".
 ','line_number':1517,'multiline':True]['text':' structure to save values in','line_number':1526,'multiline':False]['text':' new curbuf','line_number':1527,'multiline':False]['text':' Find a window that is for the new buffer','line_number':1535,'multiline':False]['text':' be quick when buf is curbuf','line_number':1536,'multiline':False]['text':' Allocate a window when needed.','line_number':1543,'multiline':False]['text':' If this fails (out of memory or using all AUCMD_WIN_COUNT','line_number':1559,'multiline':False]['text':' entries) then we can't reliable execute the autocmd, return with','line_number':1560,'multiline':False]['text':' "curbuf" unequal "buf".','line_number':1561,'multiline':False]['text':' There is a window for "buf" in the current tab page, make it the','line_number':1573,'multiline':False]['text':' curwin.  This is preferred, it has the least side effects (esp. if','line_number':1574,'multiline':False]['text':' "buf" is curbuf).','line_number':1575,'multiline':False]['text':' There is no window for "buf", use "auc_win".  To minimize the side','line_number':1581,'multiline':False]['text':' effects, insert it in the current tab page.','line_number':1582,'multiline':False]['text':' Anything related to a window (e.g., setting folds) may have','line_number':1583,'multiline':False]['text':' unexpected results.','line_number':1584,'multiline':False]['text':' Split the current window, put the auc_win in the upper half.','line_number':1592,'multiline':False]['text':' We don't want the BufEnter or WinEnter autocommands.','line_number':1593,'multiline':False]['text':' Prevent chdir() call in win_enter_ext(), through do_autochdir().','line_number':1600,'multiline':False]['text':' recompute window positions','line_number':1606,'multiline':False]['text':' disable the Visual area, the position may be invalid in another buffer','line_number':1618,'multiline':False]['text':'
 * Cleanup after executing autocommands for a (hidden) buffer.
 * Restore the window as it was (if possible).
 ','line_number':1623,'multiline':True]['text':' structure holding saved values','line_number':1629,'multiline':False]['text':' Find "awp", it can't be closed, but it may be in another tab','line_number':1638,'multiline':False]['text':' page. Do not trigger autocommands here.','line_number':1639,'multiline':False]['text':' May need to stop Insert mode if we were in a prompt buffer.','line_number':1661,'multiline':False]['text':' Do not stop Insert mode when already in Insert mode before.','line_number':1663,'multiline':False]['text':' Remove the window and frame from the tree of frames.','line_number':1667,'multiline':False]['text':' The window is marked as not used, but it is not freed, it can be','line_number':1671,'multiline':False]['text':' used again.','line_number':1672,'multiline':False]['text':' may need to remove last status line','line_number':1674,'multiline':False]['text':' no valid window in current tabpage','line_number':1677,'multiline':False]['text':' recompute window positions','line_number':1681,'multiline':False]['text':' Hmm, original window disappeared.  Just use the first one.','line_number':1688,'multiline':False]['text':' May need to restore insert mode for a prompt buffer.','line_number':1692,'multiline':False]['text':' free all w: variables','line_number':1697,'multiline':False]['text':' re-use the hashtab','line_number':1698,'multiline':False]['text':' the buffer contents may have changed','line_number':1703,'multiline':False]['text':' Hide the scrollbars from the "awp" and update.','line_number':1716,'multiline':False]['text':' Restore curwin.  Use the window ID, a window may have been closed','line_number':1725,'multiline':False]['text':' and the memory re-used for another one.','line_number':1726,'multiline':False]['text':' Restore the buffer which was previously edited by curwin, if','line_number':1730,'multiline':False]['text':' it was changed, we are still the same window and the buffer is','line_number':1731,'multiline':False]['text':' valid.','line_number':1732,'multiline':False]['text':' In case the autocommand moves the cursor to a position that','line_number':1752,'multiline':False]['text':' does not exist in curbuf.','line_number':1753,'multiline':False]['text':' just in case lines got deleted','line_number':1760,'multiline':False]['text':'
 * Execute autocommands for "event" and file name "fname".
 * Return TRUE if some commands were executed.
 ','line_number':1767,'multiline':True]['text':' NULL or empty means use actual file name','line_number':1774,'multiline':False]['text':' fname to use for <afile> on cmdline','line_number':1775,'multiline':False]['text':' when TRUE, ignore autocmd_busy','line_number':1776,'multiline':False]['text':' buffer for <abuf>','line_number':1777,'multiline':False]['text':'
 * Like apply_autocmds(), but with extra "eap" argument.  This takes care of
 * setting v:filearg.
 ','line_number':1783,'multiline':True]['text':'
 * Like apply_autocmds(), but handles the caller's retval.  If the script
 * processing is being aborted or if retval is FAIL when inside a try
 * conditional, no autocommands are executed.  If otherwise the autocommands
 * cause the script to be aborted, retval is set to FAIL.
 ','line_number':1800,'multiline':True]['text':' NULL or empty means use actual file name','line_number':1809,'multiline':False]['text':' fname to use for <afile> on cmdline','line_number':1810,'multiline':False]['text':' when TRUE, ignore autocmd_busy','line_number':1811,'multiline':False]['text':' buffer for <abuf>','line_number':1812,'multiline':False]['text':' pointer to caller's retval','line_number':1813,'multiline':False]['text':'
 * Return TRUE when there is a CursorHold autocommand defined.
 ','line_number':1833,'multiline':True]['text':'
 * Return TRUE if the CursorHold event can be triggered.
 ','line_number':1843,'multiline':True]['text':'
 * Return TRUE when there is a WinResized autocommand defined.
 ','line_number':1864,'multiline':True]['text':'
 * Return TRUE when there is a WinScrolled autocommand defined.
 ','line_number':1873,'multiline':True]['text':'
 * Return TRUE when there is a CursorMoved autocommand defined.
 ','line_number':1882,'multiline':True]['text':'
 * Return TRUE when there is a CursorMovedI autocommand defined.
 ','line_number':1891,'multiline':True]['text':'
 * Return TRUE when there is a TextChanged autocommand defined.
 ','line_number':1900,'multiline':True]['text':'
 * Return TRUE when there is a TextChangedI autocommand defined.
 ','line_number':1909,'multiline':True]['text':'
 * Return TRUE when there is a TextChangedP autocommand defined.
 ','line_number':1918,'multiline':True]['text':'
 * Return TRUE when there is an InsertCharPre autocommand defined.
 ','line_number':1927,'multiline':True]['text':'
 * Return TRUE when there is an CmdUndefined autocommand defined.
 ','line_number':1936,'multiline':True]['text':'
 * Return TRUE when there is a TextYankPost autocommand defined.
 ','line_number':1946,'multiline':True]['text':'
 * Return TRUE when there is a CompleteChanged autocommand defined.
 ','line_number':1957,'multiline':True]['text':'
 * Return TRUE when there is a ModeChanged autocommand defined.
 ','line_number':1968,'multiline':True]['text':'
 * Execute autocommands for "event" and file name "fname".
 * Return TRUE if some commands were executed.
 ','line_number':1978,'multiline':True]['text':' NULL or empty means use actual file name','line_number':1985,'multiline':False]['text':' fname to use for <afile> on cmdline, NULL means','line_number':1986,'multiline':False]['text':' use fname','line_number':1987,'multiline':False]['text':' when TRUE, ignore autocmd_busy','line_number':1988,'multiline':False]['text':' group ID, or AUGROUP_ALL','line_number':1989,'multiline':False]['text':' buffer for <abuf>','line_number':1990,'multiline':False]['text':' command arguments','line_number':1991,'multiline':False]['text':' short file name','line_number':1993,'multiline':False]['text':'
     * Quickly return if there are no autocommands for this event or
     * autocommands are blocked.
     ','line_number':2022,'multiline':True]['text':'
     * When autocommands are busy, new autocommands are only executed when
     * explicitly enabled with the "nested" flag.
     ','line_number':2030,'multiline':True]['text':'
     * Quickly return when immediately aborting on error, or when an interrupt
     * occurred or an exception was thrown but not caught.
     ','line_number':2038,'multiline':True]['text':'
     * FileChangedShell never nests, because it can create an endless loop.
     ','line_number':2046,'multiline':True]['text':'
     * Ignore events in 'eventignore'.
     ','line_number':2053,'multiline':True]['text':'
     * Allow nesting of autocommands, but restrict the depth, because it's
     * possible to create an endless loop.
     ','line_number':2059,'multiline':True]['text':'
     * Check if these autocommands are disabled.  Used when doing ":all" or
     * ":ball".
     ','line_number':2069,'multiline':True]['text':'
     * Save the autocmd_* variables and info about the current buffer.
     ','line_number':2082,'multiline':True]['text':'
     * Set the file name to be used for <afile>.
     * Make a copy to avoid that changing a buffer name or directory makes it
     * invalid.
     ','line_number':2094,'multiline':True]['text':' call FullName_save() later','line_number':2116,'multiline':False]['text':'
     * Set the buffer number to be used for <abuf>.
     ','line_number':2118,'multiline':True]['text':'
     * When the file name is NULL or empty, use the file name of buffer "buf".
     * Always use the full path of the file name to match with, in case
     * "allow_dirs" is set.
     ','line_number':2126,'multiline':True]['text':' make a copy, so we can change it','line_number':2153,'multiline':False]['text':' Don't try expanding FileType, Syntax, FuncUndefined, WindowID,','line_number':2158,'multiline':False]['text':' ColorScheme, QuickFixCmd*, DirChanged and similar.','line_number':2159,'multiline':False]['text':' don't expand it later','line_number':2186,'multiline':False]['text':' out of memory','line_number':2191,'multiline':False]['text':'
     * Replace all backslashes with forward slashes.  This makes the
     * autocommand patterns portable between Unix and MS-DOS.
     ','line_number':2199,'multiline':True]['text':' remove version for correct match','line_number':2209,'multiline':False]['text':'
     * Set the name to be used for <amatch>.
     ','line_number':2215,'multiline':True]['text':' Don't redraw while doing autocommands.','line_number':2221,'multiline':False]['text':' name and lnum are filled in later','line_number':2224,'multiline':False]['text':' doesn't count for the caller itself','line_number':2233,'multiline':False]['text':' Don't use local function variables, if called from a function.','line_number':2236,'multiline':False]['text':'
     * When starting to execute autocommands, save the search patterns.
     ','line_number':2240,'multiline':True]['text':'
     * Note that we are applying autocmds.  Some commands need to know.
     ','line_number':2254,'multiline':True]['text':' see matching decrement below','line_number':2259,'multiline':False]['text':' Remember that FileType was triggered.  Used for did_filetype().','line_number':2261,'multiline':False]['text':' Find first autocommand that matches','line_number':2267,'multiline':False]['text':' found one, start executing the autocommands','line_number':2278,'multiline':False]['text':' add to active_apc_list','line_number':2281,'multiline':False]['text':' set v:cmdarg (only when there is a matching pattern)','line_number':2286,'multiline':False]['text':' avoid gcc warning','line_number':2294,'multiline':False]['text':' mark the last pattern, to avoid an endless loop when more patterns','line_number':2297,'multiline':False]['text':' are added when executing autocommands','line_number':2298,'multiline':False]['text':' Make sure cursor and topline are valid.  The first time the current','line_number':2303,'multiline':False]['text':' values are saved, restored by reset_lnums().  When nested only the','line_number':2304,'multiline':False]['text':' values are corrected when needed.','line_number':2305,'multiline':False]['text':' restore cursor and topline, unless they were changed','line_number':2321,'multiline':False]['text':' delete from active_apc_list','line_number':2331,'multiline':False]['text':' just in case','line_number':2332,'multiline':False]['text':' see matching increment above','line_number':2360,'multiline':False]['text':'
     * When stopping to execute autocommands, restore the search patterns and
     * the redo buffer.  Free any buffers in the au_pending_free_buf list and
     * free any windows in the au_pending_free_win list.
     ','line_number':2362,'multiline':True]['text':'
     * Some events don't set or reset the Changed flag.
     * Check if still in the same buffer!
     ','line_number':2389,'multiline':True]['text':' may really delete removed patterns/commands now','line_number':2405,'multiline':False]['text':' When wiping out a buffer make sure all its buffer-local autocommands','line_number':2408,'multiline':False]['text':' are deleted.','line_number':2409,'multiline':False]['text':'
 * Block triggering autocommands until unblock_autocmd() is called.
 * Can be used recursively, so long as it's symmetric.
 ','line_number':2423,'multiline':True]['text':' Remember the value of v:termresponse.','line_number':2431,'multiline':False]['text':' When v:termresponse was set while autocommands were blocked, trigger','line_number':2444,'multiline':False]['text':' the autocommands now.  Esp. useful when executing a shell command','line_number':2445,'multiline':False]['text':' during startup (vimdiff).','line_number':2446,'multiline':False]['text':'
 * Find next autocommand pattern that matches.
 ','line_number':2459,'multiline':True]['text':' stop when 'last' flag is set','line_number':2465,'multiline':False]['text':' Clear the exestack entry for this ETYPE_AUCMD entry.','line_number':2476,'multiline':False]['text':' Only use a pattern when it has not been removed, has commands and','line_number':2484,'multiline':False]['text':' the group matches. For buffer-local autocommands only check the','line_number':2485,'multiline':False]['text':' buffer number.','line_number':2486,'multiline':False]['text':' execution-condition','line_number':2490,'multiline':False]['text':' Update the exestack entry for this autocmd.','line_number':2510,'multiline':False]['text':' mark last command','line_number':2516,'multiline':False]['text':' found a match','line_number':2522,'multiline':False]['text':'
 * Get the script context where autocommand "acp" is defined.
 ','line_number':2531,'multiline':True]['text':'
 * Get next autocommand command.
 * Called by do_cmdline() to get the next line for ":if".
 * Returns allocated string, or NULL for end of autocommands.
 ','line_number':2541,'multiline':True]['text':' Can be called again after returning the last line.','line_number':2557,'multiline':False]['text':' repeat until we find an autocommand to execute','line_number':2561,'multiline':False]['text':' skip removed commands','line_number':2564,'multiline':False]['text':' at end of commands, find next pattern that matches','line_number':2574,'multiline':False]['text':' don't overwrite this either','line_number':2591,'multiline':False]['text':' Remove one-shot ("once") autocmd in anticipation of its execution.','line_number':2595,'multiline':False]['text':'
 * Return TRUE if there is a matching autocommand for "fname".
 * To account for buffer-local autocommands, function needs to know
 * in which buffer the file will be opened.
 ','line_number':2608,'multiline':True]['text':'
     * Replace all backslashes with forward slashes.  This makes the
     * autocommand patterns portable between Unix and MS-DOS.
     ','line_number':2626,'multiline':True]['text':'
 * Function given to ExpandGeneric() to obtain the list of autocommand group
 * names.
 ','line_number':2656,'multiline':True]['text':' add "END" add the end','line_number':2663,'multiline':False]['text':' end of list','line_number':2665,'multiline':False]['text':' skip deleted entries','line_number':2668,'multiline':False]['text':' return a name','line_number':2670,'multiline':False]['text':' TRUE for :doauto*, FALSE for :autocmd','line_number':2679,'multiline':False]['text':' check for a group name, skip it if present','line_number':2684,'multiline':False]['text':' If there only is a group name that's what we expand.','line_number':2690,'multiline':False]['text':' skip over event name','line_number':2697,'multiline':False]['text':' expand event name','line_number':2705,'multiline':False]['text':' skip over pattern','line_number':2710,'multiline':False]['text':' expand (next) command','line_number':2715,'multiline':False]['text':' expand file names','line_number':2718,'multiline':False]['text':' pattern is not expanded','line_number':2720,'multiline':False]['text':'
 * Function given to ExpandGeneric() to obtain the list of event names.
 ','line_number':2724,'multiline':True]['text':' First list group names, if wanted','line_number':2730,'multiline':False]['text':' skip deleted entries','line_number':2734,'multiline':False]['text':' return a name','line_number':2735,'multiline':False]['text':'
 * Function given to ExpandGeneric() to obtain the list of event names. Don't
 * include groups.
 ','line_number':2740,'multiline':True]['text':'
 * Return TRUE if autocmd is supported.
 ','line_number':2752,'multiline':True]['text':'
 * Return TRUE if an autocommand is defined for a group, event and
 * pattern:  The group can be omitted to accept any group. "event" and "pattern"
 * can be NULL to accept any event and pattern. "pattern" can be NULL to accept
 * any pattern. Buffer-local patterns <buffer> or <buffer=N> are accepted.
 * Used for:
 *	exists("#Group") or
 *	exists("#Group#Event") or
 *	exists("#Group#Event#pat") or
 *	exists("#Event") or
 *	exists("#Event#pat")
 ','line_number':2763,'multiline':True]['text':' Make a copy so that we can change the '#' chars to a NUL.','line_number':2788,'multiline':False]['text':' First, look for an autocmd group name','line_number':2796,'multiline':False]['text':' Didn't match a group name, assume the first argument is an event.','line_number':2800,'multiline':False]['text':' "Group": group name is present and it's recognized','line_number':2808,'multiline':False]['text':' Must be "Group#Event" or "Group#Event#pat".','line_number':2813,'multiline':False]['text':' "Group#Event#pat"','line_number':2817,'multiline':False]['text':' "pattern" is NULL when there is no pattern','line_number':2820,'multiline':False]['text':' find the index (enum) for the event name','line_number':2822,'multiline':False]['text':' return FALSE if the event name is not recognized','line_number':2825,'multiline':False]['text':' Find the first autocommand for this event.','line_number':2829,'multiline':False]['text':' If there isn't any, return FALSE;','line_number':2830,'multiline':False]['text':' If there is one and no pattern given, return TRUE;','line_number':2831,'multiline':False]['text':' if pattern is "<buffer>", special handling is needed which uses curbuf','line_number':2836,'multiline':False]['text':' for pattern "<buffer=N>, fnamecmp() will work fine','line_number':2837,'multiline':False]['text':' Check if there is an autocommand with the given pattern.','line_number':2841,'multiline':False]['text':' only use a pattern when it has not been removed and has commands.','line_number':2843,'multiline':False]['text':' For buffer-local autocommands, fnamecmp() works fine.','line_number':2844,'multiline':False]['text':'
 * autocmd_add() and autocmd_delete() functions
 ','line_number':2861,'multiline':True]['text':' replace the cmd for a group/event','line_number':2884,'multiline':False]['text':' if the autocmd group name is not specified, then use the current','line_number':2944,'multiline':False]['text':' autocmd group','line_number':2945,'multiline':False]['text':' group is not found, create it now','line_number':2958,'multiline':False]['text':' if a buffer number is specified, then generate a pattern of the form','line_number':2971,'multiline':False]['text':' "<buffer=n>. Otherwise, use the pattern supplied by the user.','line_number':2972,'multiline':False]['text':' if 'replace' is true, then remove all the commands associated with','line_number':3019,'multiline':False]['text':' this autocmd event/group and add the new command.','line_number':3020,'multiline':False]['text':' if the event name is not specified or '*', delete all the events','line_number':3035,'multiline':False]['text':' this also catches something following a valid event name','line_number':3081,'multiline':False]['text':' if only the autocmd group name is specified for delete and the','line_number':3122,'multiline':False]['text':' autocmd event, pattern and cmd are not specified, then delete the','line_number':3123,'multiline':False]['text':' autocmd group.','line_number':3124,'multiline':False]['text':'
 * autocmd_add() function
 ','line_number':3139,'multiline':True]['text':'
 * autocmd_delete() function
 ','line_number':3148,'multiline':True]['text':'
 * autocmd_get() function
 * Returns a List of autocmds.
 ','line_number':3157,'multiline':True]['text':' return only the autocmds in the specified group','line_number':3182,'multiline':False]['text':' return only the autocmds for the specified event','line_number':3204,'multiline':False]['text':' return only the autocmds for the specified pattern','line_number':3231,'multiline':False]['text':' iterate through all the autocmd events','line_number':3242,'multiline':False]['text':' iterate through all the patterns for this autocmd event','line_number':3251,'multiline':False]['text':' iterate through all the commands for this pattern and add one','line_number':3264,'multiline':False]['text':' item for each cmd.','line_number':3265,'multiline':False]