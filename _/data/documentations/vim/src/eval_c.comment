['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]['text':'
 * eval.c: Expression evaluation.
 ','line_number':10,'multiline':True]['text':'
 * When recursively copying lists and dicts we need to remember which ones we
 * have done to avoid endless recursiveness.  This unique ID is used for that.
 * The last bit is used for previous_funccal, ignored when comparing.
 ','line_number':25,'multiline':True]['text':'
 * Return "n1" divided by "n2", taking care of dividing by zero.
 * If "failed" is not NULL set it to TRUE when dividing by zero fails.
 ','line_number':45,'multiline':True]['text':' similar to NaN','line_number':63,'multiline':False]['text':' specific case: trying to do VARNUM_MIN / -1 results in a positive','line_number':71,'multiline':False]['text':' number that doesn't fit in varnumber_T and causes an FPE','line_number':72,'multiline':False]['text':'
 * Return "n1" modulus "n2", taking care of dividing by zero.
 * If "failed" is not NULL set it to TRUE when dividing by zero fails.
 ','line_number':81,'multiline':True]['text':'
 * Initialize the global and v: variables.
 ','line_number':97,'multiline':True]['text':' must come after evalvars_clear().','line_number':112,'multiline':False]['text':' autoloaded script names','line_number':115,'multiline':False]['text':' unreferenced lists and dicts','line_number':118,'multiline':False]['text':' functions not garbage collected','line_number':121,'multiline':False]['text':'
 * Top level evaluation function, returning a boolean.
 * Sets "error" to TRUE if there was an error.
 * Return TRUE or FALSE.
 ','line_number':143,'multiline':True]['text':' only parse, don't execute','line_number':153,'multiline':False]['text':'
 * Call eval1() and give an error message if not done at a lower level.
 ','line_number':190,'multiline':True]['text':' Report the invalid expression unless the expression evaluation has','line_number':207,'multiline':False]['text':' been cancelled due to an aborting error, an interrupt, or an','line_number':208,'multiline':False]['text':' exception, or we already gave a more specific error.','line_number':209,'multiline':False]['text':' Also check called_emsg for when using assert_fails().','line_number':210,'multiline':False]['text':'
 * Return whether a typval is a valid expression to pass to eval_expr_typval()
 * or eval_expr_to_bool().  An empty string returns FALSE;
 ','line_number':219,'multiline':True]['text':'
 * When calling eval_expr_typval() many times we only need one funccall_T.
 * Returns NULL when no funccall_T is to be used.
 * When returning non-NULL remove_funccal() must be called later.
 ','line_number':231,'multiline':True]['text':'
 * Evaluate an expression, which can be a function, partial or string.
 * Pass arguments "argv[argc]".
 * If "want_func" is TRUE treat a string as a function name, not an expression.
 * "fc_arg" is from eval_expr_get_funccal() or NULL;
 * Return the result in "rettv" and OK or FAIL.
 ','line_number':252,'multiline':True]['text':' Shortcut to call a compiled function with minimal overhead.','line_number':289,'multiline':False]['text':' check for trailing chars after expr','line_number':333,'multiline':False]['text':'
 * Like eval_to_bool() but using a typval_T instead of a string.
 * Works for string, funcref and partial.
 ','line_number':343,'multiline':True]['text':'
 * Top level evaluation function, returning a string.  If "skip" is TRUE,
 * only parsing to "nextcmd" is done, without reporting errors.  Return
 * pointer to allocated memory, or NULL for failure or when "skip" is TRUE.
 ','line_number':363,'multiline':True]['text':' only parse, don't execute','line_number':372,'multiline':False]['text':'
 * Initialize "evalarg" for use.
 ','line_number':395,'multiline':True]['text':'
 * If "evalarg->eval_tofree" is not NULL free it later.
 * Caller is expected to overwrite "evalarg->eval_tofree" next.
 ','line_number':405,'multiline':True]['text':'
 * After using "evalarg" filled from "eap": free the memory.
 ','line_number':423,'multiline':True]['text':' We may need to keep the original command line, e.g. for','line_number':438,'multiline':False]['text':' ":let" it has the variable names.  But we may also need','line_number':439,'multiline':False]['text':' the new one, "nextcmd" points into it.  Keep both.','line_number':440,'multiline':False]['text':' "nextcmd" points into the last line in eval_tofree_ga,','line_number':446,'multiline':False]['text':' need to keep it around.','line_number':447,'multiline':False]['text':'
 * Skip over an expression at "*pp".
 * Return FAIL for an error, OK otherwise.
 ','line_number':464,'multiline':True]['text':'
 * Skip over an expression at "*arg".
 * If in Vim9 script and line breaks are encountered, the lines are
 * concatenated.  "evalarg->eval_tofree" will be set accordingly.
 * "arg" is advanced to just after the expression.
 * "start" is set to the start of the expression, "end" to just after the end.
 * Also when the expression is copied to allocated memory.
 * Return FAIL for an error, OK otherwise.
 ','line_number':477,'multiline':True]['text':' leave room for "start"','line_number':506,'multiline':False]['text':' Don't evaluate the expression.','line_number':513,'multiline':False]['text':' just the one line, no need to concatenate','line_number':527,'multiline':False]['text':' Line breaks encountered, concatenate all the lines.','line_number':536,'multiline':False]['text':' free the lines only when using getsourceline()','line_number':540,'multiline':False]['text':' Do not free the first line, the caller can still use it.','line_number':543,'multiline':False]['text':' Do not free the last line, "arg" points into it, free it','line_number':545,'multiline':False]['text':' later.  Also free "eval_tofree" later if needed.','line_number':546,'multiline':False]['text':' free lines that were explicitly marked for freeing','line_number':557,'multiline':False]['text':' Compute "end" relative to the end.','line_number':567,'multiline':False]['text':'
 * Convert "tv" to a string.
 * When "convert" is TRUE convert a List into a sequence of lines.
 * Returns an allocated string (NULL when out of memory).
 ','line_number':575,'multiline':True]['text':'
 * Top level evaluation function, returning a string.  Does not handle line
 * breaks.
 * When "convert" is TRUE convert a List into a sequence of lines.
 * Return pointer to allocated memory, or NULL for failure.
 ','line_number':603,'multiline':True]['text':'
 * Call eval_to_string() without using current local variables and using
 * textlock.  When "use_sandbox" is TRUE use the sandbox.
 * Use legacy Vim script syntax.
 ','line_number':647,'multiline':True]['text':'
 * Top level evaluation function, returning a number.
 * Evaluates "expr" silently.
 * Returns -1 for an error.
 ','line_number':681,'multiline':True]['text':'
 * Top level evaluation function.
 * Returns an allocated typval_T with the result.
 * Returns NULL when there is an error.
 ','line_number':712,'multiline':True]['text':'
 * "*arg" points to what can be a function name in the form of "import.Name" or
 * "Funcref".  Return the name of the function.  Set "tofree" to something that
 * was allocated.
 * If "verbose" is FALSE no errors are given.
 * Return NULL for any failure.
 ','line_number':749,'multiline':True]['text':' need to evaluate this to get an import, like in "a.Func"','line_number':770,'multiline':False]['text':' If <SID>VarName was used it would not be found, try another way.','line_number':778,'multiline':False]['text':'
 * Call some Vim script function and return the result in "*rettv".
 * Uses argv[0] to argv[argc - 1] for the function arguments.  argv[argc]
 * should have type VAR_UNKNOWN.
 * Returns OK or FAIL.
 ','line_number':828,'multiline':True]['text':' clear_tv() uses this','line_number':848,'multiline':False]['text':' The name might be "import.Func" or "Funcref".  We don't know, we need to','line_number':854,'multiline':False]['text':' ignore errors for an undefined name.  But we do want errors when an','line_number':855,'multiline':False]['text':' autoload script has errors.  Guess that when there is a dot in the name','line_number':856,'multiline':False]['text':' showing errors is the right choice.','line_number':857,'multiline':False]['text':'
 * Call Vim script function "func" and return the result as a string.
 * Uses "argv[0]" to "argv[argc - 1]" for the function arguments. "argv[argc]"
 * should have type VAR_UNKNOWN.
 * Returns NULL when calling the function fails.
 ','line_number':877,'multiline':True]['text':'
 * Call Vim script function "func" and return the result as a List.
 * Uses "argv" and "argc" as call_func_retstr().
 * Returns NULL when there is something wrong.
 * Gives an error when the returned value is not a list.
 ','line_number':900,'multiline':True]['text':'
 * Evaluate "arg", which is 'foldexpr'.
 * Note: caller must set "curwin" to match "arg".
 * Returns the foldlevel, and any character preceding it in "*cp".  Doesn't
 * give error messages.
 ','line_number':929,'multiline':True]['text':' Evaluate the expression.  If the expression is "FuncName()" call the','line_number':955,'multiline':False]['text':' function directly.','line_number':956,'multiline':False]['text':' If the result is a number, just return the number.','line_number':961,'multiline':False]['text':' If the result is a string, check if there is a non-digit before','line_number':968,'multiline':False]['text':' the number.','line_number':969,'multiline':False]['text':'
 * Fill in "lp" using "root". This is used in a special case when
 * "get_lval()" parses a bare word when "lval_root" is not NULL.
 *
 * This is typically called with "lval_root" as "root". For a class, find
 * the name from lp in the class from root, fill in lval_T if found. For a
 * complex type, list/dict use it as the result; just put the root into
 * ll_tv.
 *
 * "lval_root" is a hack used during run-time/instr-execution to provide the
 * starting point for "get_lval()" to traverse a chain of indexes. In some
 * cases get_lval sees a bare name and uses this function to populate the
 * lval_T.
 *
 * For setting up "lval_root" (currently only used with lockvar)
 *	compile_lock_unlock - pushes object on stack (which becomes lval_root)
 *	execute_instructions: ISN_LOCKUNLOCK - sets lval_root from stack.
 ','line_number':1034,'multiline':True]['text':' Special special case. Look for a bare class variable reference.','line_number':1065,'multiline':False]['text':' Assuming "inside class" since bare reference.','line_number':1072,'multiline':False]['text':'
 * Check if the class has permission to access the member.
 * Returns OK or FAIL.
 ','line_number':1093,'multiline':True]['text':' executing class, NULL if :def or script level','line_number':1099,'multiline':False]['text':' class which contains the member','line_number':1100,'multiline':False]['text':' member being accessed','line_number':1101,'multiline':False]['text':' char after member name','line_number':1102,'multiline':False]['text':' GLV flags to check if writing to lval','line_number':1103,'multiline':False]['text':' If [idx] or .key following, read only OK.','line_number':1118,'multiline':False]['text':'
 * Get an lval: variable, Dict item or List item that can be assigned a value
 * to: "name", "na{me}", "name[expr]", "name[expr:expr]", "name[expr][expr]",
 * "name.key", "name.key[expr]" etc.
 * Indexing only works if "name" is an existing List or Dictionary.
 * "name" points to the start of the name.
 * If "rettv" is not NULL it points to the value to be assigned.
 * "unlet" is TRUE for ":unlet": slightly different behavior when something is
 * wrong; must end in space or cmd separator.
 *
 * flags:
 *  GLV_QUIET:       do not give error messages
 *  GLV_READ_ONLY:   will not change the variable
 *  GLV_NO_AUTOLOAD: do not use script autoloading
 *
 * Returns a pointer to just after the name, including indexes.
 * When an evaluation error occurs "lp->ll_name" is NULL;
 * Returns NULL for a parsing error.  Still need to free items in "lp"!
 ','line_number':1137,'multiline':True]['text':' GLV_ values','line_number':1163,'multiline':False]['text':' flags for find_name_end()','line_number':1164,'multiline':False]['text':' class that is executing, or NULL.','line_number':1179,'multiline':False]['text':' Clear everything in "lp".','line_number':1192,'multiline':False]['text':' When skipping or compiling just find the end of the name.','line_number':1197,'multiline':False]['text':' Cannot use "s:var" at the Vim9 script level.  "s: type" is OK.','line_number':1204,'multiline':False]['text':' Find the end of the name.','line_number':1212,'multiline':False]['text':' Don't expand the name when we already know there is an error.','line_number':1217,'multiline':False]['text':' Report an invalid expression in braces, unless the','line_number':1228,'multiline':False]['text':' expression evaluation has been cancelled due to an','line_number':1229,'multiline':False]['text':' aborting error, an interrupt, or an exception.','line_number':1230,'multiline':False]['text':' "a: type" is declaring variable "a" with a type, not "a:".','line_number':1246,'multiline':False]['text':' However, "g:[key]" is indexing a dictionary.','line_number':1247,'multiline':False]['text':' Using a type and not in a "var" declaration.','line_number':1280,'multiline':False]['text':' parse the type after the name','line_number':1286,'multiline':False]['text':' TODO: check inside class?','line_number':1294,'multiline':False]['text':' check the item is exported','line_number':1315,'multiline':False]['text':' Without [idx] or .key we are done.','line_number':1328,'multiline':False]['text':' using local variable','line_number':1340,'multiline':False]['text':' When we would write to the variable pass &ht and prevent autoload.','line_number':1348,'multiline':False]['text':'
     * Loop until no more [idx] or .key is following.
     ','line_number':1367,'multiline':True]['text':' A NULL list/blob works like an empty list/blob, allocate one now.','line_number':1397,'multiline':False]['text':' Vim9 script local variable: get the type','line_number':1424,'multiline':False]['text':' Get the index [expr] or the first index [expr: ].','line_number':1451,'multiline':False]['text':' recursive!','line_number':1458,'multiline':False]['text':' not a number or string','line_number':1462,'multiline':False]['text':' Optionally get the second index [ :expr].','line_number':1469,'multiline':False]['text':' recursive!','line_number':1496,'multiline':False]['text':' not a number or string','line_number':1504,'multiline':False]['text':' Skip to past ']'.','line_number':1524,'multiline':False]['text':' "[key]": get key from "var1"','line_number':1539,'multiline':False]['text':' is number or string','line_number':1540,'multiline':False]['text':' a NULL dict is equivalent with an empty dict','line_number':1551,'multiline':False]['text':' When assigning to a scope dictionary check that a function and','line_number':1566,'multiline':False]['text':' variable name is valid (only variable name unless it is l: or','line_number':1567,'multiline':False]['text':' g: dictionary). Disallow overwriting a builtin function.','line_number':1568,'multiline':False]['text':' avoid compiler warning','line_number':1579,'multiline':False]['text':' use the type of the member','line_number':1595,'multiline':False]['text':' Can't add "v:" or "a:" variable.','line_number':1600,'multiline':False]['text':' Key does not exist in dict: may need to add it.','line_number':1609,'multiline':False]['text':' existing variable, need to check if it can be changed','line_number':1626,'multiline':False]['text':'
	     * Get the number and item for the only or first index of the List.
	     ','line_number':1642,'multiline':True]['text':' is number or string','line_number':1648,'multiline':False]['text':'
	     * Get the number and item for the only or first index of the List.
	     ','line_number':1671,'multiline':True]['text':' is number or string','line_number':1677,'multiline':False]['text':' use the type of the member','line_number':1694,'multiline':False]['text':'
	     * May need to find the item or absolute index for the second
	     * index of a range.
	     * When no index given: "lp->ll_empty2" is TRUE.
	     * Otherwise "lp->ll_n2" is set to the second index.
	     ','line_number':1697,'multiline':True]['text':' is number or string','line_number':1706,'multiline':False]['text':' v_type == VAR_CLASS || v_type == VAR_OBJECT','line_number':1716,'multiline':False]['text':' TODO: what if class is NULL?','line_number':1740,'multiline':False]['text':' First look for a function with this name.','line_number':1747,'multiline':False]['text':' round 1: class functions (skipped for an object)','line_number':1748,'multiline':False]['text':' round 2: object methods','line_number':1749,'multiline':False]['text':'
 * Clear lval "lp" that was filled by get_lval().
 ','line_number':1805,'multiline':True]['text':'
 * Set a variable that was parsed by get_lval() to "rettv".
 * "endp" points to just after the parsed name.
 * "op" is NULL, "+" for "+=", "-" for "-=", "*" for "*=", "/" for "/=",
 * "%" for "%=", "." for ".=" or "=" for "=".
 ','line_number':1815,'multiline':True]['text':' ASSIGN_CONST, ASSIGN_NO_DECL','line_number':1827,'multiline':False]['text':' index for "let [a, b] = list"','line_number':1829,'multiline':False]['text':' handle +=, -=, *=, /=, %= and .=','line_number':1881,'multiline':False]['text':'
	 * Assign to a List, Dictionary or Object item.
	 ','line_number':1931,'multiline':True]['text':' Need to add an item to the Dictionary.','line_number':1957,'multiline':False]['text':'
	 * Assign the value to the variable or list item.
	 ','line_number':1976,'multiline':True]['text':'
 * Handle "tv1 += tv2", "tv1 -= tv2", "tv1 *= tv2", "tv1 /= tv2", "tv1 %= tv2"
 * and "tv1 .= tv2"
 * Returns OK or FAIL.
 ','line_number':1990,'multiline':True]['text':' Can't do anything with a Funcref or Dict on the right.','line_number':2003,'multiline':False]['text':' v:true and friends only work with "..=".','line_number':2004,'multiline':False]['text':' BLOB += BLOB','line_number':2030,'multiline':False]['text':' List += List','line_number':2044,'multiline':False]['text':' nr += nr , nr -= nr , nr *=nr , nr /= nr , nr %= nr','line_number':2063,'multiline':False]['text':' str .= str','line_number':2104,'multiline':False]['text':'
 * Evaluate the expression used in a ":for var in expr" command.
 * "arg" points to "var".
 * Set "*errp" to TRUE for an error, FALSE otherwise;
 * Return a pointer that holds the info.  Null when there is an error.
 ','line_number':2142,'multiline':True]['text':' default: there is an error','line_number':2162,'multiline':False]['text':' a null list is like an empty list: do nothing','line_number':2197,'multiline':False]['text':' Need a real list here.','line_number':2202,'multiline':False]['text':' No need to increment the refcount, it's already set for','line_number':2205,'multiline':False]['text':' the list being used in "tv".','line_number':2206,'multiline':False]['text':' Make a copy, so that the iteration still works when the','line_number':2219,'multiline':False]['text':' blob is changed.','line_number':2220,'multiline':False]['text':'
 * Used when looping over a :for line, skip the "in expr" part.
 ','line_number':2248,'multiline':True]['text':'
 * Use the first item in a ":for" list.  Advance to the next.
 * Assign the values to the variable (list).  "arg" points to the first one.
 * Return TRUE when a valid item was found, FALSE when at end of list or
 * something wrong.
 ','line_number':2261,'multiline':True]['text':' first round: error if variable exists','line_number':2274,'multiline':False]['text':'
 * Free the structure used to store info used by ":for".
 ','line_number':2337,'multiline':True]['text':' ":let var1 var2 ...": find last space.','line_number':2375,'multiline':False]['text':' environment variable','line_number':2411,'multiline':False]['text':' Autoload function/variable contains '#'.','line_number':2422,'multiline':False]['text':' Function name can start with "<SNR>" and contain '#'.','line_number':2429,'multiline':False]['text':' string','line_number':2434,'multiline':False]['text':' literal string','line_number':2441,'multiline':False]['text':' Trick: '' is like stopping and starting a literal string.','line_number':2443,'multiline':False]['text':' skip ','line_number':2445,'multiline':True]['text':' Doesn't look like something valid, expand as an expression','line_number':2462,'multiline':False]['text':' anyway.','line_number':2463,'multiline':False]['text':' skip ','line_number':2468,'multiline':True]['text':' ":exe one two" completes "two"','line_number':2471,'multiline':False]['text':'
 * Return TRUE if "pat" matches "text".
 * Does not use 'cpo' and always uses 'magic'.
 ','line_number':2492,'multiline':True]['text':' avoid 'l' flag in 'cpoptions'','line_number':2503,'multiline':False]['text':'
 * Handle a name followed by "(".  Both for just "name(arg)" and for
 * "expr->name(arg)".
 * Returns OK or FAIL.
 ','line_number':2517,'multiline':True]['text':' points to "(", will be advanced','line_number':2524,'multiline':False]['text':' "expr" for "expr->name(arg)"','line_number':2530,'multiline':False]['text':' If "s" is the name of a variable of type VAR_FUNC','line_number':2543,'multiline':False]['text':' use its contents.','line_number':2544,'multiline':False]['text':' Need to make a copy, in case evaluating the arguments makes','line_number':2548,'multiline':False]['text':' the name invalid.','line_number':2549,'multiline':False]['text':' Invoke the function.','line_number':2557,'multiline':False]['text':' If evaluate is FALSE rettv->v_type was not set in','line_number':2576,'multiline':False]['text':' get_func_tv, but it's needed in handle_subscript() to parse','line_number':2577,'multiline':False]['text':' what follows. So set it here.','line_number':2578,'multiline':False]['text':' Stop the expression evaluation when immediately','line_number':2585,'multiline':False]['text':' aborting on error, or when an interrupt occurred or','line_number':2586,'multiline':False]['text':' an exception was thrown but not caught.','line_number':2587,'multiline':False]['text':'
 * After a NL, skip over empty lines and comment-only lines.
 ','line_number':2597,'multiline':True]['text':' skip another NL','line_number':2621,'multiline':False]['text':'
 * Get the next line source line without advancing.  But do skip over comment
 * lines.
 * Only called for Vim9 script.
 ','line_number':2626,'multiline':True]['text':'
 * If inside Vim9 script, "arg" points to the end of a line (ignoring a #
 * comment) and there is a next line, return the next line (skipping blanks)
 * and set "getnext".
 * Otherwise return the next non-white at or after "arg" and set "getnext" to
 * FALSE.
 * "arg" must point somewhere inside a line, not at the start.
 ','line_number':2651,'multiline':True]['text':'
 * To be called after eval_next_non_blank() sets "getnext" to TRUE.
 * Only called for Vim9 script.
 ','line_number':2690,'multiline':True]['text':' Truncate before a trailing comment, so that concatenating the lines','line_number':2704,'multiline':False]['text':' won't turn the rest into a comment.','line_number':2705,'multiline':False]['text':' Going to concatenate the lines after parsing.  For an empty or','line_number':2723,'multiline':False]['text':' comment line use an empty string.','line_number':2724,'multiline':False]['text':' Advanced to the next line, "arg" no longer points into the previous','line_number':2740,'multiline':False]['text':' line.','line_number':2741,'multiline':False]['text':'
 * Call eval_next_non_blank() and get the next line if needed.
 ','line_number':2746,'multiline':True]['text':'
 * The "eval" functions have an "evalarg" argument: When NULL or
 * "evalarg->eval_flags" does not have EVAL_EVALUATE, then the argument is only
 * parsed but not executed.  The functions may return OK, but the rettv will be
 * of type VAR_UNKNOWN.  The functions still returns FAIL for a syntax error.
 ','line_number':2763,'multiline':True]['text':'
 * Handle zero level expression.
 * This calls eval1() and handles error message and nextcmd.
 * Put the result in "rettv" when returning OK and "evaluate" is TRUE.
 * Note: "rettv.v_lock" is not set.
 * "evalarg" can be NULL, EVALARG_EVALUATE or a pointer.
 * Return OK or FAIL.
 ','line_number':2770,'multiline':True]['text':'
 * If "arg" is a simple function call without arguments then call it and return
 * the result.  Otherwise return NOTDONE.
 ','line_number':2788,'multiline':True]['text':' If the expression is "FuncName()" then we can skip a lot of overhead.','line_number':2800,'multiline':False]['text':'
 * Handle zero level expression with optimization for a simple function call.
 * Same arguments and return value as eval0().
 ','line_number':2811,'multiline':True]['text':'
 * Like eval0() but when "retarg" is not NULL store the pointer to after the
 * expression and don't check what comes after the expression.
 ','line_number':2829,'multiline':True]['text':' In Vim9 script a command block is not split at NL characters for','line_number':2857,'multiline':False]['text':' commands using an expression argument.  Skip over a '#' comment to','line_number':2858,'multiline':False]['text':' check for a following NL.  Require white space before the '#'.','line_number':2859,'multiline':False]['text':'
	 * Report the invalid expression unless the expression evaluation has
	 * been cancelled due to an aborting error, an interrupt, or an
	 * exception, or we already gave a more specific error.
	 * Also check called_emsg for when using assert_fails().
	 ','line_number':2881,'multiline':True]['text':' Some of the expression may not have been consumed.','line_number':2900,'multiline':False]['text':' Only execute a next command if it cannot be a "||" operator.','line_number':2901,'multiline':False]['text':' The next command may be "catch".','line_number':2902,'multiline':False]['text':'
 * Handle top level expression:
 *	expr2 ? expr1 : expr1
 *	expr2 ?? expr1
 *
 * "arg" must point to the first non-white of the expression.
 * "arg" is advanced to just after the recognized expression.
 *
 * Note: "rettv.v_lock" is not set.
 *
 * Return OK or FAIL.
 ','line_number':2918,'multiline':True]['text':'
     * Get the first variable.
     ','line_number':2938,'multiline':True]['text':'
	 * Get the second variable.  Recursive!
	 ','line_number':2994,'multiline':True]['text':'
	     * Check for the ":".
	     ','line_number':3018,'multiline':True]['text':'
	     * Get the third variable.  Recursive!
	     ','line_number':3044,'multiline':True]['text':'
 * Handle first level expression:
 *	expr2 || expr2 || expr2	    logical OR
 *
 * "arg" must point to the first non-white of the expression.
 * "arg" is advanced to just after the recognized expression.
 *
 * Return OK or FAIL.
 ','line_number':3077,'multiline':True]['text':'
     * Get the first expression.
     ','line_number':3092,'multiline':True]['text':'
     * Handle the  "||" operator.
     ','line_number':3098,'multiline':True]['text':'
	 * Repeat until there is no following "||".
	 ','line_number':3131,'multiline':True]['text':'
	     * Get the second variable.
	     ','line_number':3149,'multiline':True]['text':'
	     * Compute the result.
	     ','line_number':3164,'multiline':True]['text':'
 * Handle second level expression:
 *	expr3 && expr3 && expr3	    logical AND
 *
 * "arg" must point to the first non-white of the expression.
 * "arg" is advanced to just after the recognized expression.
 *
 * Return OK or FAIL.
 ','line_number':3203,'multiline':True]['text':'
     * Get the first expression.
     ','line_number':3218,'multiline':True]['text':'
     * Handle the "&&" operator.
     ','line_number':3224,'multiline':True]['text':'
	 * Repeat until there is no following "&&".
	 ','line_number':3257,'multiline':True]['text':'
	     * Get the second variable.
	     ','line_number':3275,'multiline':True]['text':'
	     * Compute the result.
	     ','line_number':3291,'multiline':True]['text':'
 * Handle third level expression:
 *	var1 == var2
 *	var1 =~ var2
 *	var1 != var2
 *	var1 !~ var2
 *	var1 > var2
 *	var1 >= var2
 *	var1 < var2
 *	var1 <= var2
 *	var1 is var2
 *	var1 isnot var2
 *
 * "arg" must point to the first non-white of the expression.
 * "arg" is advanced to just after the recognized expression.
 *
 * Return OK or FAIL.
 ','line_number':3330,'multiline':True]['text':'
     * Get the first expression.
     ','line_number':3357,'multiline':True]['text':'
     * If there is a comparative operator, use it.
     ','line_number':3367,'multiline':True]['text':' extra question mark appended: ignore case','line_number':3398,'multiline':False]['text':' extra '#' appended: match case','line_number':3404,'multiline':False]['text':' nothing appended: use 'ignorecase' if not in Vim script','line_number':3410,'multiline':False]['text':'
	 * Get the second variable.
	 ','line_number':3414,'multiline':True]['text':' use the line of the comparison for messages','line_number':3433,'multiline':False]['text':'
 * Make a copy of blob "tv1" and append blob "tv2".
 ','line_number':3450,'multiline':True]['text':'
 * Make a copy of list "tv1" and append list "tv2".
 ','line_number':3473,'multiline':True]['text':' concatenate Lists','line_number':3481,'multiline':False]['text':'
 * Handle the bitwise left/right shift operator expression:
 *	var1 << var2
 *	var1 >> var2
 *
 * "arg" must point to the first non-white of the expression.
 * "arg" is advanced to just after the recognized expression.
 *
 * Return OK or FAIL.
 ','line_number':3493,'multiline':True]['text':'
     * Get the first expression.
     ','line_number':3506,'multiline':True]['text':'
     * Repeat computing, until no '<<' or '>>' is following.
     ','line_number':3512,'multiline':True]['text':' Handle a bitwise left or right shift operator','line_number':3532,'multiline':False]['text':' left operand should be a number','line_number':3536,'multiline':False]['text':'
	 * Get the second variable.
	 ','line_number':3555,'multiline':True]['text':' right operand should be a positive number','line_number':3575,'multiline':False]['text':' shifting more bits than we have always results in zero','line_number':3586,'multiline':False]['text':'
 * Handle fifth level expression:
 *	+	number addition, concatenation of list or blob
 *	-	number subtraction
 *	.	string concatenation (if script version is 1)
 *	..	string concatenation
 *
 * "arg" must point to the first non-white of the expression.
 * "arg" is advanced to just after the recognized expression.
 *
 * Return OK or FAIL.
 ','line_number':3602,'multiline':True]['text':'
     * Get the first expression.
     ','line_number':3617,'multiline':True]['text':'
     * Repeat computing, until no '+', '-' or '.' is following.
     ','line_number':3623,'multiline':True]['text':' "." is only string concatenation when scriptversion is 1','line_number':3637,'multiline':False]['text':' "+=", "-=" and "..=" are assignments','line_number':3638,'multiline':False]['text':' "++" and "--" on the next line are a separate command.','line_number':3639,'multiline':False]['text':' For "list + ...", an illegal use of the first operand as','line_number':3670,'multiline':False]['text':' a number cannot be determined before evaluating the 2nd','line_number':3671,'multiline':False]['text':' operand: if this is also a list, all is ok.','line_number':3672,'multiline':False]['text':' For "something . ...", "something - ..." or "non-list + ...",','line_number':3673,'multiline':False]['text':' we know that the first operand needs to be a string or number','line_number':3674,'multiline':False]['text':' without evaluating the 2nd operand.  So check before to avoid','line_number':3675,'multiline':False]['text':' side effects after an error.','line_number':3676,'multiline':False]['text':'
	 * Get the second variable.
	 ','line_number':3686,'multiline':True]['text':'
	     * Compute the result.
	     ','line_number':3704,'multiline':True]['text':' type error ?','line_number':3726,'multiline':False]['text':' This can only happen for "list + non-list" or','line_number':3762,'multiline':False]['text':' "blob + non-blob".  For "non-list + ..." or','line_number':3763,'multiline':False]['text':' "something - ...", we returned before evaluating the','line_number':3764,'multiline':False]['text':' 2nd operand.','line_number':3765,'multiline':False]['text':' If there is a float on either side the result is a float.','line_number':3792,'multiline':False]['text':'
 * Handle sixth level expression:
 *	*	number multiplication
 *	/	number division
 *	%	number modulo
 *
 * "arg" must point to the first non-white of the expression.
 * "arg" is advanced to just after the recognized expression.
 *
 * Return OK or FAIL.
 ','line_number':3818,'multiline':True]['text':' after "." operator','line_number':3834,'multiline':False]['text':'
     * Get the first expression.
     ','line_number':3838,'multiline':True]['text':'
     * Repeat computing, until no '*', '/' or '%' is following.
     ','line_number':3844,'multiline':True]['text':' "*=", "/=" and "%=" are assignments','line_number':3858,'multiline':False]['text':'
	 * Get the second variable.
	 ','line_number':3898,'multiline':True]['text':'
	     * Compute the result.
	     * When either side is a float the result is a float.
	     ','line_number':3933,'multiline':True]['text':' VMS crashes on divide by zero, work around it','line_number':3944,'multiline':False]['text':' similar to NaN','line_number':3948,'multiline':False]['text':' We rely on the floating point library to handle divide','line_number':3957,'multiline':False]['text':' by zero to result in "inf" and not a crash.','line_number':3958,'multiline':False]['text':'
 * Handle a type cast before a base level expression.
 * "arg" must point to the first non-white of the expression.
 * "arg" is advanced to just after the recognized expression.
 * Return OK or FAIL.
 ','line_number':3992,'multiline':True]['text':' after "." operator','line_number':4003,'multiline':False]['text':' list of pointers to allocated types','line_number':4006,'multiline':False]['text':' Recognize <type> in Vim9 script only.','line_number':4011,'multiline':False]['text':' can use "0" and "1" for boolean in some places','line_number':4054,'multiline':False]['text':' ++, --, -+ and +- are not accepted in Vim9 script','line_number':4083,'multiline':False]['text':'
 * Check for a predefined value "true", "false" and "null.*".
 * Return OK when recognized.
 ','line_number':4095,'multiline':True]['text':'
 * Handle sixth level expression:
 *  number		number constant
 *  0zFFFFFFFF		Blob constant
 *  "string"		string constant
 *  'string'		literal string constant
 *  &option-name	option value
 *  @r			register contents
 *  identifier		variable value
 *  function()		function call
 *  $VAR		environment variable
 *  (expression)	nested expression
 *  [expr, expr]	List
 *  {arg, arg -> expr}	Lambda
 *  {key: val, key: val}   Dictionary
 *  #{key: val, key: val}  Dictionary with literal keys
 *
 *  Also handle:
 *  ! in front		logical NOT
 *  - in front		unary minus
 *  + in front		unary plus (ignored)
 *  trailing []		subscript in String or List
 *  trailing .name	entry in Dictionary
 *  trailing ->name()	method call
 *
 * "arg" must point to the first non-white of the expression.
 * "arg" is advanced to just after the recognized expression.
 *
 * Return OK or FAIL.
 ','line_number':4208,'multiline':True]['text':' after "." operator','line_number':4243,'multiline':False]['text':'
     * Initialise variable so that clear_tv() can't mistake this for a
     * string and free a string that isn't there.
     ','line_number':4256,'multiline':True]['text':'
     * Skip '!', '-' and '+' characters.  They are handled later.
     ','line_number':4262,'multiline':True]['text':' Limit recursion to 1000 levels.  At least at 10000 we run out of stack','line_number':4277,'multiline':False]['text':' and crash.  With MSVC the stack is smaller.','line_number':4278,'multiline':False]['text':'
     * Number constant.
     ','line_number':4294,'multiline':True]['text':' Apply prefixed "-" and "+" now.  Matters especially when','line_number':4309,'multiline':False]['text':' "->" follows.','line_number':4310,'multiline':False]['text':'
     * String constant: "string".
     ','line_number':4316,'multiline':True]['text':'
     * Literal string constant: 'str''ing'.
     ','line_number':4322,'multiline':True]['text':'
     * List: [expr, expr]
     ','line_number':4328,'multiline':True]['text':'
     * Dictionary: #{key: val, key: val}
     ','line_number':4334,'multiline':True]['text':'
     * Lambda: {arg, arg -> expr}
     * Dictionary: {'key': val, 'key': val}
     ','line_number':4350,'multiline':True]['text':'
     * Option value: &name
     ','line_number':4362,'multiline':True]['text':'
     * Environment variable: $VAR.
     * Interpolated string: $"string" or $'string'.
     ','line_number':4368,'multiline':True]['text':'
     * Register contents: @r.
     ','line_number':4378,'multiline':True]['text':'
     * nested expression: (expression).
     * or lambda: (arg) => expr
     ','line_number':4399,'multiline':True]['text':' Compile it here to get the return type.  The return','line_number':4411,'multiline':False]['text':' type is optional, when it's missing use t_unknown.','line_number':4412,'multiline':False]['text':' This is recognized in compile_return().','line_number':4413,'multiline':False]['text':' recursive!','line_number':4427,'multiline':False]['text':'
	 * Must be a variable or function name.
	 * Can also be a curly-braces kind of name: {expr}.
	 ','line_number':4447,'multiline':True]['text':' "name(..."  recursive!','line_number':4475,'multiline':False]['text':' get the value of "true", "false", etc. or a variable','line_number':4481,'multiline':False]['text':' skip the name','line_number':4494,'multiline':False]['text':' Handle following '[', '(' and '.' for expr[expr], expr.name,','line_number':4502,'multiline':False]['text':' expr(expr), expr->name(expr)','line_number':4503,'multiline':False]['text':'
     * Apply logical NOT and unary '-', from right to left, ignore '+'.
     ','line_number':4507,'multiline':True]['text':'
 * Apply the leading "!" and "-" before an eval9 expression to "rettv".
 * When "numeric_only" is TRUE only handle "+" and "-".
 * Adjusts "end_leaderp" until it is at "start_leader".
 ','line_number':4517,'multiline':True]['text':'
 * Call the function referred to in "rettv".
 ','line_number':4611,'multiline':True]['text':' need to copy the funcref so that we can clear rettv','line_number':4629,'multiline':False]['text':' Invoke the function.  Recursive!','line_number':4635,'multiline':False]['text':' Clear the funcref afterwards, so that deleting it while','line_number':4665,'multiline':False]['text':' evaluating the arguments is possible (see test55).','line_number':4666,'multiline':False]['text':'
 * Evaluate "->method()".
 * "*arg" points to "method".
 * Returns FAIL or OK. "*arg" is advanced to after the ')'.
 ','line_number':4673,'multiline':True]['text':' give error messages','line_number':4683,'multiline':False]['text':' ->{lambda}()','line_number':4694,'multiline':False]['text':' ->(lambda)()','line_number':4699,'multiline':False]['text':' Clear the funcref afterwards, so that deleting it while','line_number':4734,'multiline':False]['text':' evaluating the arguments is possible (see test55).','line_number':4735,'multiline':False]['text':'
 * Evaluate "->method()".
 * "*arg" points to "method".
 * Returns FAIL or OK. "*arg" is advanced to after the ')'.
 ','line_number':4742,'multiline':True]['text':' give error messages','line_number':4752,'multiline':False]['text':' If there is no "(" immediately following, but there is further on,','line_number':4780,'multiline':False]['text':' it can be "import.Func()", "dict.Func()", "list[nr]", etc.','line_number':4781,'multiline':False]['text':' Does not handle anything where "(" is part of the expression.','line_number':4782,'multiline':False]['text':' Truncate the name a the "(".  Avoid trying to get another line','line_number':4790,'multiline':False]['text':' by making "getline" NULL.','line_number':4791,'multiline':False]['text':' Clear the funcref afterwards, so that deleting it while','line_number':4839,'multiline':False]['text':' evaluating the arguments is possible (see test55).','line_number':4840,'multiline':False]['text':'
 * Evaluate an "[expr]" or "[expr:expr]" index.  Also "dict.key".
 * "*arg" points to the '[' or '.'.
 * Returns FAIL or OK. "*arg" is advanced to after the ']'.
 ','line_number':4848,'multiline':True]['text':' give error messages','line_number':4858,'multiline':False]['text':'
	 * dict.name
	 ','line_number':4876,'multiline':True]['text':'
	 * something[idx]
	 *
	 * Get the (first) variable from inside the [].
	 ','line_number':4888,'multiline':True]['text':' recursive!','line_number':4896,'multiline':False]['text':' allow for indexing with float','line_number':4909,'multiline':False]['text':' not a number or string','line_number':4923,'multiline':False]['text':'
	 * Get the second variable from inside the [:].
	 ','line_number':4929,'multiline':True]['text':' recursive!','line_number':4948,'multiline':False]['text':' not a number or string','line_number':4956,'multiline':False]['text':' Check for the ']'.','line_number':4964,'multiline':False]['text':' skip over the ']'','line_number':4975,'multiline':False]['text':'
 * Check if "rettv" can have an [index] or [sli:ce]
 ','line_number':4993,'multiline':True]['text':' FALLTHROUGH','line_number':5029,'multiline':False]['text':'
 * slice() function
 ','line_number':5044,'multiline':True]['text':'
 * Apply index or range to "rettv".
 * "var1" is the first index, NULL for [:expr].
 * "var2" is the second index, NULL for [expr] and [expr: ]
 * "exclusive" is TRUE for slice(): second index is exclusive, use character
 * index for string.
 * Alternatively, "key" is not NULL, then key[keylen] is the dict index.
 ','line_number':5068,'multiline':True]['text':' not evaluating, skipping over subscript','line_number':5124,'multiline':False]['text':' The resulting variable is a substring.  If the indexes','line_number':5141,'multiline':False]['text':' are out of range the result is empty.','line_number':5142,'multiline':False]['text':' The resulting variable is a string of a single','line_number':5160,'multiline':False]['text':' character.  If the index is too big or negative the','line_number':5161,'multiline':False]['text':' result is empty.','line_number':5162,'multiline':False]['text':'
 * Return the function name of partial "pt".
 ','line_number':5223,'multiline':True]['text':' "out_up" is no longer used, decrement refcount on partial that owns it.','line_number':5257,'multiline':False]['text':' Using pt_outer from another partial.','line_number':5260,'multiline':False]['text':' Decrease the reference count for the context of a closure.  If down','line_number':5263,'multiline':False]['text':' to the minimum it may be time to free it.','line_number':5264,'multiline':False]['text':' Similarly for loop variables.','line_number':5270,'multiline':False]['text':'
 * Unreference a closure: decrement the reference count and free it when it
 * becomes zero.
 ','line_number':5281,'multiline':True]['text':' If the reference count goes down to one, the funcstack may be the','line_number':5296,'multiline':False]['text':' only reference and can be freed if no other partials reference it.','line_number':5297,'multiline':False]['text':' careful: if the funcstack is freed it may contain this partial','line_number':5300,'multiline':False]['text':' and it gets freed as well','line_number':5301,'multiline':False]['text':'
 * Return the next (unique) copy ID.
 * Used for serializing nested structures.
 ','line_number':5317,'multiline':True]['text':'
 * Garbage collection for lists and dictionaries.
 *
 * We use reference counts to be able to free most items right away when they
 * are no longer used.  But for composite items it's possible that it becomes
 * unused while the reference count is > 0: When there is a recursive
 * reference.  Example:
 *	:let l = [1, 2, 3]
 *	:let d = {9: l}
 *	:let l[1] = d
 *
 * Since this is quite unusual we handle this with garbage collection: every
 * once in a while find out which lists and dicts are not referenced from any
 * variable.
 *
 * Here is a good reference text about garbage collection (refers to Python
 * but it applies to all reference-counting mechanisms):
 *	http://python.ca/nas/python/gc/
 ','line_number':5328,'multiline':True]['text':'
 * Do garbage collection for lists and dicts.
 * When "testing" is TRUE this is called from test_garbagecollect_now().
 * Return TRUE if some memory was freed.
 ','line_number':5348,'multiline':True]['text':' Only do this once.','line_number':5365,'multiline':False]['text':' The execution stack can grow big, limit the size.','line_number':5371,'multiline':False]['text':' Keep 150% of the current size, with a minimum of the growth size.','line_number':5378,'multiline':False]['text':' Don't make it bigger though.','line_number':5383,'multiline':False]['text':' We advance by two because we add one for items referenced through','line_number':5395,'multiline':False]['text':' previous_funccal.','line_number':5396,'multiline':False]['text':'
     * 1. Go through all accessible variables and mark all lists and dicts
     *    with copyID.
     ','line_number':5399,'multiline':True]['text':' Don't free variables in the previous_funccal list unless they are only','line_number':5404,'multiline':False]['text':' referenced through previous_funccal.  This must be first, because if','line_number':5405,'multiline':False]['text':' the item is referenced elsewhere the funccal must not be freed.','line_number':5406,'multiline':False]['text':' script-local variables','line_number':5409,'multiline':False]['text':' buffer-local variables','line_number':5412,'multiline':False]['text':' window-local variables','line_number':5417,'multiline':False]['text':' window-local variables in autocmd windows','line_number':5421,'multiline':False]['text':' tabpage-local variables','line_number':5436,'multiline':False]['text':' global variables','line_number':5440,'multiline':False]['text':' function-local variables','line_number':5443,'multiline':False]['text':' named functions (matters for closures)','line_number':5446,'multiline':False]['text':' function call arguments, if v:testing is set.','line_number':5449,'multiline':False]['text':' funcstacks keep variables for closures','line_number':5452,'multiline':False]['text':' loopvars keep variables for loop blocks','line_number':5455,'multiline':False]['text':' v: vars','line_number':5458,'multiline':False]['text':' callbacks in buffers','line_number':5461,'multiline':False]['text':' 'completefunc', 'omnifunc' and 'thesaurusfunc' callbacks','line_number':5464,'multiline':False]['text':' 'operatorfunc' callback','line_number':5467,'multiline':False]['text':' 'tagfunc' callback','line_number':5470,'multiline':False]['text':' 'imactivatefunc' and 'imstatusfunc' callbacks','line_number':5473,'multiline':False]['text':'
	 * 2. Free lists and dictionaries that are not referenced.
	 ','line_number':5516,'multiline':True]['text':'
	 * 3. Check if any funccal can be freed now.
	 *    This may call us back recursively.
	 ','line_number':5521,'multiline':True]['text':'
 * Free lists, dictionaries, channels and jobs that are no longer referenced.
 ','line_number':5535,'multiline':True]['text':' Let all "free" functions know that we are here.  This means no','line_number':5543,'multiline':False]['text':' dictionaries, lists, channels or jobs are to be freed, because we will','line_number':5544,'multiline':False]['text':' do that here.','line_number':5545,'multiline':False]['text':'
     * PASS 1: free the contents of the items.  We don't free the items
     * themselves yet, so that it is possible to decrement refcount counters
     ','line_number':5548,'multiline':True]['text':' Go through the list of dicts and free items without this copyID.','line_number':5553,'multiline':False]['text':' Go through the list of lists and free items without this copyID.','line_number':5556,'multiline':False]['text':' Go through the list of objects and free items without this copyID.','line_number':5559,'multiline':False]['text':' Go through the list of classes and free items without this copyID.','line_number':5562,'multiline':False]['text':' Go through the list of jobs and free items without the copyID. This','line_number':5566,'multiline':False]['text':' must happen before doing channels, because jobs refer to channels, but','line_number':5567,'multiline':False]['text':' the reference from the channel to the job isn't tracked.','line_number':5568,'multiline':False]['text':' Go through the list of channels and free items without the copyID.','line_number':5571,'multiline':False]['text':'
     * PASS 2: free the items themselves.
     ','line_number':5575,'multiline':True]['text':' Go through the list of jobs and free items without the copyID. This','line_number':5583,'multiline':False]['text':' must happen before doing channels, because jobs refer to channels, but','line_number':5584,'multiline':False]['text':' the reference from the channel to the job isn't tracked.','line_number':5585,'multiline':False]['text':' Go through the list of channels and free items without the copyID.','line_number':5588,'multiline':False]['text':'
 * Mark all lists and dicts referenced through hashtab "ht" with "copyID".
 * "list_stack" is used to add lists to be marked.  Can be NULL.
 *
 * Returns TRUE if setting references failed somehow.
 ','line_number':5597,'multiline':True]['text':' Mark each item in the hashtab.  If the item contains a hashtab','line_number':5618,'multiline':False]['text':' it is added to ht_stack, if it contains a list it is added to','line_number':5619,'multiline':False]['text':' list_stack.','line_number':5620,'multiline':False]['text':' take an item from the stack','line_number':5634,'multiline':False]['text':'
 * Mark a dict and its items with "copyID".
 * Returns TRUE if setting references failed somehow.
 ','line_number':5646,'multiline':True]['text':'
 * Mark a list and its items with "copyID".
 * Returns TRUE if setting references failed somehow.
 ','line_number':5662,'multiline':True]['text':'
 * Mark all lists and dicts referenced through list "l" with "copyID".
 * "ht_stack" is used to add hashtabs to be marked.  Can be NULL.
 *
 * Returns TRUE if setting references failed somehow.
 ','line_number':5677,'multiline':True]['text':' Mark each item in the list.  If the item contains a hashtab','line_number':5696,'multiline':False]['text':' it is added to ht_stack, if it contains a list it is added to','line_number':5697,'multiline':False]['text':' list_stack.','line_number':5698,'multiline':False]['text':' take an item from the stack','line_number':5705,'multiline':False]['text':'
 * Mark the partial in callback 'cb' with "copyID".
 ','line_number':5715,'multiline':True]['text':'
 * Mark the dict "dd" with "copyID".
 * Also see set_ref_in_item().
 ','line_number':5731,'multiline':True]['text':' Didn't see this dict yet.','line_number':5745,'multiline':False]['text':'
 * Mark the list "ll" with "copyID".
 * Also see set_ref_in_item().
 ','line_number':5761,'multiline':True]['text':' Didn't see this list yet.','line_number':5775,'multiline':False]['text':'
 * Mark the partial "pt" with "copyID".
 * Also see set_ref_in_item().
 ','line_number':5791,'multiline':True]['text':' Didn't see this partial yet.','line_number':5805,'multiline':False]['text':' pt_funcstack is handled in set_ref_in_funcstacks()','line_number':5831,'multiline':False]['text':' pt_loopvars is handled in set_ref_in_loopvars()','line_number':5832,'multiline':False]['text':'
 * Mark the job "pt" with "copyID".
 * Also see set_ref_in_item().
 ','line_number':5838,'multiline':True]['text':'
 * Mark the channel "ch" with "copyID".
 * Also see set_ref_in_item().
 ','line_number':5871,'multiline':True]['text':'
 * Mark the class "cl" with "copyID".
 * Also see set_ref_in_item().
 ','line_number':5925,'multiline':True]['text':' The "class_members_tv" table is allocated only for regular classes','line_number':5944,'multiline':False]['text':' and not for interfaces.','line_number':5945,'multiline':False]['text':'
 * Mark the object "cl" with "copyID".
 * Also see set_ref_in_item().
 ','line_number':5963,'multiline':True]['text':' The typval_T array is right after the object_T.','line_number':5981,'multiline':False]['text':'
 * Mark all lists, dicts and other container types referenced through typval
 * "tv" with "copyID".
 * "list_stack" is used to add lists to be marked.  Can be NULL.
 * "ht_stack" is used to add hashtabs to be marked.  Can be NULL.
 *
 * Returns TRUE if setting references failed somehow.
 ','line_number':5991,'multiline':True]['text':' Types that do not contain any other item','line_number':6063,'multiline':False]['text':'
 * Return a string with the string representation of a variable.
 * If the memory is allocated "tofree" is set to it, otherwise NULL.
 * "numbuf" is used for a number.
 * When "copyID" is not NULL replace recursive lists and dicts with "...".
 * When both "echo_style" and "composite_val" are FALSE, put quotes around
 * strings as "string()", otherwise does not put quotes around strings, as
 * ":echo" displays values.
 * When "restore_copyID" is FALSE, repeated items in dictionaries and lists
 * are replaced with "...".
 * May return NULL.
 ','line_number':6070,'multiline':True]['text':' Only give this message once for a recursive call to avoid','line_number':6099,'multiline':False]['text':' flooding the user with errors.  And stop iterating over lists','line_number':6100,'multiline':False]['text':' and dicts.','line_number':6101,'multiline':False]['text':' When using uf_name prepend "g:" for a global function.','line_number':6168,'multiline':False]['text':' terminate with ')' and a NUL','line_number':6202,'multiline':False]['text':' NULL list is equivalent to empty list.','line_number':6217,'multiline':False]['text':' NULL dict is equivalent to empty dict.','line_number':6242,'multiline':False]['text':'
 * Return a string with the string representation of a variable.
 * If the memory is allocated "tofree" is set to it, otherwise NULL.
 * "numbuf" is used for a number.
 * Does not put quotes around strings, as ":echo" displays values.
 * When "copyID" is not NULL replace recursive lists and dicts with "...".
 * May return NULL.
 ','line_number':6359,'multiline':True]['text':'
 * Convert the specified byte index of line 'lnum' in buffer 'buf' to a
 * character index.  Works only for loaded buffers. Returns -1 on failure.
 * The index of the first byte and the first character is zero.
 ','line_number':6377,'multiline':True]['text':' count the number of characters','line_number':6402,'multiline':False]['text':' In insert mode, when the cursor is at the end of a non-empty line,','line_number':6407,'multiline':False]['text':' byteidx points to the NUL character immediately past the end of the','line_number':6408,'multiline':False]['text':' string. In this case, add one to the character count.','line_number':6409,'multiline':False]['text':'
 * Convert the specified character index of line 'lnum' in buffer 'buf' to a
 * byte index.  Works only for loaded buffers. Returns -1 on failure.
 * The index of the first byte and the first character is zero.
 ','line_number':6416,'multiline':True]['text':' Convert the character offset to a byte offset','line_number':6437,'multiline':False]['text':'
 * Translate a String variable into a position.
 * Returns NULL when there is an error.
 ','line_number':6445,'multiline':True]['text':' TRUE when $ is last line','line_number':6452,'multiline':False]['text':' set to fnum for '0, 'A, etc.','line_number':6453,'multiline':False]['text':' return character column','line_number':6454,'multiline':False]['text':' Argument can be [lnum, col, coladd].','line_number':6460,'multiline':False]['text':' Get the line number','line_number':6472,'multiline':False]['text':' invalid line number','line_number':6475,'multiline':False]['text':' Get the column number','line_number':6481,'multiline':False]['text':' We accept "$" for the column number: last column.','line_number':6482,'multiline':False]['text':' Accept a position up to the NUL after the line.','line_number':6497,'multiline':False]['text':' invalid column number','line_number':6499,'multiline':False]['text':' Get the virtual offset.  Defaults to zero.','line_number':6502,'multiline':False]['text':' cursor','line_number':6520,'multiline':False]['text':' Visual start','line_number':6525,'multiline':False]['text':' mark','line_number':6534,'multiline':False]['text':' the "w_valid" flags are not reset when moving the cursor, but they','line_number':6551,'multiline':False]['text':' do matter for update_topline() and validate_botline().','line_number':6552,'multiline':False]['text':' "w0": first visible line','line_number':6556,'multiline':False]['text':' In silent Ex mode topline is zero, but that's not a valid line','line_number':6559,'multiline':False]['text':' number; use one instead.','line_number':6560,'multiline':False]['text':' "w$": last visible line','line_number':6564,'multiline':False]['text':' In silent Ex mode botline is zero, return zero then.','line_number':6567,'multiline':False]['text':' last column or line','line_number':6572,'multiline':False]['text':'
 * Convert list in "arg" into position "posp" and optional file number "fnump".
 * When "fnump" is NULL there is no file number, only 3 items: [lnum, col, off]
 * Note that the column is passed on as-is, the caller may want to decrement
 * it to use 1 for the first column.
 * If "charcol" is TRUE use the column as the character index instead of the
 * byte index.
 * Return FAIL when conversion is not possible, doesn't check the position for
 * validity.
 ','line_number':6594,'multiline':True]['text':' List must be: [fnum, lnum, col, coladd, curswant], where "fnum" is only','line_number':6616,'multiline':False]['text':' there when "fnump" isn't NULL; "coladd" and "curswant" are optional.','line_number':6617,'multiline':False]['text':' fnum','line_number':6626,'multiline':False]['text':' current buffer','line_number':6630,'multiline':False]['text':' lnum','line_number':6634,'multiline':False]['text':' col','line_number':6639,'multiline':False]['text':' If character position is specified, then convert to byte position','line_number':6642,'multiline':False]['text':' If the line number is zero use the cursor line.','line_number':6643,'multiline':False]['text':' Get the text for the specified line in a loaded buffer','line_number':6648,'multiline':False]['text':' off','line_number':6658,'multiline':False]['text':' curswant','line_number':6665,'multiline':False]['text':'
 * Get the length of an environment variable name.
 * Advance "arg" to the first character after the name.
 * Return 0 for error.
 ','line_number':6670,'multiline':True]['text':' no name found','line_number':6683,'multiline':False]['text':'
 * Get the length of the name of a function or internal variable.
 * "arg" is advanced to after the name.
 * Return 0 if something is wrong.
 ','line_number':6691,'multiline':True]['text':' Find the end of the name.','line_number':6702,'multiline':False]['text':' "s:" is start of "s:var", but "n:" is not and can be used in','line_number':6707,'multiline':False]['text':' slice "[n:]".  Also "xx:" is not a namespace.','line_number':6708,'multiline':False]['text':' no name found','line_number':6715,'multiline':False]['text':'
 * Get the length of the name of a variable or function.
 * Only the name is recognized, does not handle ".key" or "[idx]".
 * "arg" is advanced to the first non-white character after the name.
 * Return -1 if curly braces expansion failed.
 * Return 0 if something else is wrong.
 * If the name contains 'magic' {}'s, expand them and return the
 * expanded name in an allocated string via 'alias' - caller must free.
 ','line_number':6724,'multiline':True]['text':' default to no alias','line_number':6745,'multiline':False]['text':' hard coded <SNR>, already translated','line_number':6750,'multiline':False]['text':' literal "<SID>", "s:" or "<SNR>"','line_number':6757,'multiline':False]['text':'
     * Find the end of the name; check for {} construction.
     ','line_number':6761,'multiline':True]['text':'
	 * Include any <SID> etc in the expanded string:
	 * Thus the -len here.
	 ','line_number':6777,'multiline':True]['text':' Only give an error when there is something, otherwise it will be','line_number':6790,'multiline':False]['text':' reported at a higher level.','line_number':6791,'multiline':False]['text':'
 * Find the end of a variable or function name, taking care of magic braces.
 * If "expr_start" is not NULL then "expr_start" and "expr_end" are set to the
 * start and end of the first magic braces item.
 * "flags" can have FNE_INCL_BR and FNE_CHECK_START.
 * Return a pointer to just after the name.  Equal to "arg" if there is no
 * valid name.
 ','line_number':6798,'multiline':True]['text':' Quick check for valid starting character.','line_number':6825,'multiline':False]['text':' skip over 'string' to avoid counting [ and ] inside it.','line_number':6840,'multiline':False]['text':' skip over "str\"ing" to avoid counting [ and ] inside it.','line_number':6848,'multiline':False]['text':' "s:" is start of "s:var", but "n:" is not and can be used in','line_number':6857,'multiline':False]['text':' slice "[n:]".  Also "xx:" is not a namespace. But {ns}: is.','line_number':6858,'multiline':False]['text':'
 * Expands out the 'magic' {}'s in a variable/function name.
 * Note that this can call itself recursively, to deal with
 * constructs like foo{bar}{baz}{bam}
 * The four pointer arguments point to "foo{expre}ss{ion}bar"
 *			"in_start"      ^
 *			"expr_start"	   ^
 *			"expr_end"		 ^
 *			"in_end"			    ^
 *
 * Returns a new allocated string, which the caller must free.
 * Returns NULL for failure.
 ','line_number':6893,'multiline':True]['text':' put char back for error messages','line_number':6938,'multiline':False]['text':' Further expansion!','line_number':6947,'multiline':False]['text':'
 * Return TRUE if character "c" can be used in a variable or function name.
 * Does not include '{' or '}' for magic braces.
 ','line_number':6958,'multiline':True]['text':'
 * Return TRUE if character "c" can be used as the first character in a
 * variable or function name (excluding '{' and '}').
 ','line_number':6968,'multiline':True]['text':'
 * Return TRUE if character "c" can be used as the first character of a
 * dictionary key.
 ','line_number':6978,'multiline':True]['text':'
 * Handle:
 * - expr[expr], expr[expr:expr] subscript
 * - ".name" lookup
 * - function call with Funcref variable: func(expr)
 * - method call: var->method()
 *
 * Can all be combined in any order: dict.func(expr)[idx]['func'](expr)->len()
 * "name_start" points to a variable before the subscript or is NULL.
 ','line_number':6988,'multiline':True]['text':' give error messages','line_number':7004,'multiline':False]['text':' When at the end of the line and ".name" or "->{" or "->X" follows in','line_number':7016,'multiline':False]['text':' the next line then consume the line break.','line_number':7017,'multiline':False]['text':' Found script from "import {name} as name", script item name must','line_number':7041,'multiline':False]['text':' follow.  "rettv->vval.v_number" has the script ID.','line_number':7042,'multiline':False]['text':' isolate the name','line_number':7060,'multiline':False]['text':' Stop the expression evaluation when immediately aborting on','line_number':7099,'multiline':False]['text':' error, or when an interrupt occurred or an exception was thrown','line_number':7100,'multiline':False]['text':' but not caught.','line_number':7101,'multiline':False]['text':' expr->{lambda}() or expr->(lambda)()','line_number':7123,'multiline':False]['text':' expr->name()','line_number':7126,'multiline':False]['text':' "." is ".name" lookup when we found a dict or when evaluating and','line_number':7129,'multiline':False]['text':' scriptversion is at least 2, where string concatenation is "..".','line_number':7130,'multiline':False]['text':' class member: SomeClass.varname','line_number':7155,'multiline':False]['text':' class method: SomeClass.SomeMethod()','line_number':7156,'multiline':False]['text':' class constructor: SomeClass.new()','line_number':7157,'multiline':False]['text':' object member: someObject.varname','line_number':7158,'multiline':False]['text':' object method: someObject.SomeMethod()','line_number':7159,'multiline':False]['text':' Turn "dict.Func" into a partial for "Func" bound to "dict".','line_number':7170,'multiline':False]['text':' Don't do this when "Func" is already a partial that was bound','line_number':7171,'multiline':False]['text':' explicitly (pt_auto is FALSE).','line_number':7172,'multiline':False]['text':'
 * Make a copy of an item.
 * Lists and Dictionaries are also copied.  A deep copy if "deep" is set.
 * "top" is TRUE for the toplevel of copy().
 * For deepcopy() "copyID" is zero for a full copy or the ID for when a
 * reference to an already copied list/dict can be used.
 * Returns FAIL or OK.
 ','line_number':7184,'multiline':True]['text':' use the copy made earlier','line_number':7234,'multiline':False]['text':' use the copy made earlier','line_number':7254,'multiline':False]['text':' Call msg_start() after eval1(), evaluating the expression','line_number':7284,'multiline':False]['text':' may cause a message to appear.','line_number':7285,'multiline':False]['text':' Mark the saved text as finishing the line, so that what','line_number':7288,'multiline':False]['text':' follows is displayed on a new line when scrolling back','line_number':7289,'multiline':False]['text':' at the more prompt.','line_number':7290,'multiline':False]['text':' remove any text still there from the command','line_number':7305,'multiline':False]['text':'
 * ":echo expr1 ..."	print each argument separated with a space, add a
 *			newline at the end.
 * ":echon expr1 ..."	print each argument plain.
 ','line_number':7327,'multiline':True]['text':' If eval1() causes an error message the text from the command may','line_number':7350,'multiline':False]['text':' still need to be cleared. E.g., "echo 22,44".','line_number':7351,'multiline':False]['text':'
	     * Report the invalid expression unless the expression evaluation
	     * has been cancelled due to an aborting error, an interrupt, or an
	     * exception.
	     ','line_number':7357,'multiline':True]['text':' remove text that may still be there from the command','line_number':7390,'multiline':False]['text':'
 * ":echohl {name}".
 ','line_number':7398,'multiline':True]['text':'
 * Returns the :echo attribute
 ','line_number':7407,'multiline':True]['text':'
 * ":execute expr1 ..."	execute the result of an expression.
 * ":echomsg expr1 ..."	Print a message
 * ":echowindow expr1 ..." Print a message in the messages window
 * ":echoerr expr1 ..."	Print an error
 * ":echoconsole expr1 ..." Print a message on stdout
 * Each gets spaces around each argument and a newline at the end for
 * echo commands
 ','line_number':7416,'multiline':True]['text':' use the first line of continuation lines for messages','line_number':7488,'multiline':False]['text':' Mark the already saved text as finishing the line, so that what','line_number':7495,'multiline':False]['text':' follows is displayed on a new line when scrolling back at the','line_number':7496,'multiline':False]['text':' more prompt.','line_number':7497,'multiline':False]['text':' We don't want to abort following commands, restore did_emsg.','line_number':7525,'multiline':False]['text':' "legacy exe cmd" and "vim9cmd exe cmd" applies to "cmd".','line_number':7534,'multiline':False]['text':'
 * Skip over the name of an option: "&option", "&g:option" or "&l:option".
 * "arg" points to the "&" or '+' when called, to "option" when returning.
 * Returns NULL when no option name found.  Otherwise pointer to the char
 * after the option name.
 ','line_number':7550,'multiline':True]['text':' termcap option','line_number':7580,'multiline':False]['text':'
 * Display script name where an item was last set.
 * Should only be invoked when 'verbose' is non-zero.
 ','line_number':7587,'multiline':True]['text':' FEAT_EVAL','line_number':7615,'multiline':False]['text':'
 * Perform a substitution on "str" with pattern "pat" and substitute "sub".
 * When "sub" is NULL "expr" is used, must be a VAR_FUNC or VAR_PARTIAL.
 * "flags" can be "g" to do a global substitute.
 * Returns an allocated string, NULL for error.
 ','line_number':7617,'multiline':True]['text':' Make 'cpoptions' empty, so that the 'l' flag doesn't work here','line_number':7642,'multiline':False]['text':' Skip empty match except for first match.','line_number':7658,'multiline':False]['text':' avoid getting stuck on a match with an empty string','line_number':7663,'multiline':False]['text':'
	     * Get some space for a temporary buffer to do the substitution
	     * into.  It will contain:
	     * - The text up to where the match is.
	     * - The substituted text.
	     * - The text after the match.
	     ','line_number':7674,'multiline':True]['text':' copy the text up to where the match is','line_number':7694,'multiline':False]['text':' add the substituted text','line_number':7697,'multiline':False]['text':' Darn, evaluating {sub} expression or {expr} changed the value.','line_number':7721,'multiline':False]['text':' If it's still empty it was changed and restored, need to restore in','line_number':7722,'multiline':False]['text':' the complicated way.','line_number':7723,'multiline':False]