['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]['text':'
 * getchar.c: Code related to getting a character from the user or a script
 * file, manipulations with redo buffer and stuff buffer.
 ','line_number':10,'multiline':True]['text':'
 * These buffers are used for storing:
 * - stuffed characters: A command that is translated into another command.
 * - redo characters: will redo the last change.
 * - recorded characters: for the "q" command.
 *
 * The bytes are stored like in the typeahead buffer:
 * - K_SPECIAL introduces a special key (two more bytes follow).  A literal
 *   K_SPECIAL is stored as K_SPECIAL KS_SPECIAL KE_FILLER.
 * - CSI introduces a GUI termcap code (also when gui.in_use is FALSE,
 *   otherwise switching the GUI on would make mappings invalid).
 *   A literal CSI is stored as CSI KS_EXTRA KE_CSI.
 * These translations are also done on multi-byte characters!
 *
 * Escaping CSI bytes is done by the system-specific input functions, called
 * by ui_inchar().
 * Escaping K_SPECIAL is done by inchar().
 * Un-escaping is done by vgetc().
 ','line_number':17,'multiline':True]['text':' minimal size for b_str','line_number':37,'multiline':False]['text':' typeahead char that's not flushed','line_number':43,'multiline':False]['text':'
 * When block_redo is TRUE the redo buffer will not be changed.
 * Used by edit() to repeat insertions.
 ','line_number':45,'multiline':True]['text':' remapping flags','line_number':51,'multiline':False]['text':'
 * Variables used by vgetorpeek() and flush_buffers().
 *
 * typebuf.tb_buf[] contains all characters that are not consumed yet.
 * typebuf.tb_buf[typebuf.tb_off] is the first valid character.
 * typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len - 1] is the last valid char.
 * typebuf.tb_buf[typebuf.tb_off + typebuf.tb_len] must be NUL.
 * The head of the buffer may contain the result of mappings, abbreviations
 * and @a commands.  The length of this part is typebuf.tb_maplen.
 * typebuf.tb_silent is the part where <silent> applies.
 * After the head are characters that come from the terminal.
 * typebuf.tb_no_abbr_cnt is the number of characters in typebuf.tb_buf that
 * should not be considered for abbreviations.
 * Some parts of typebuf.tb_buf may not be mapped. These parts are remembered
 * in typebuf.tb_noremap[], which is the same length as typebuf.tb_buf and
 * contains RM_NONE for the characters that are not to be remapped.
 * typebuf.tb_noremap[typebuf.tb_off] is the first valid flag.
 * (typebuf has been put in globals.h, because check_termcode() needs it).
 ','line_number':53,'multiline':True]['text':' tb_noremap: remap','line_number':72,'multiline':False]['text':' tb_noremap: don't remap','line_number':73,'multiline':False]['text':' tb_noremap: remap local script mappings','line_number':74,'multiline':False]['text':' tb_noremap: don't remap, do abbrev.','line_number':75,'multiline':False]['text':' typebuf.tb_buf has three parts: room in front (for result of mappings), the','line_number':77,'multiline':False]['text':' middle for typeahead and room for new characters (which needs to be 3 *','line_number':78,'multiline':False]['text':' MAXMAPLEN for the Amiga).','line_number':79,'multiline':False]['text':' initial typebuf.tb_buf','line_number':81,'multiline':False]['text':' initial typebuf.tb_noremap','line_number':82,'multiline':False]['text':' number of last recorded chars','line_number':84,'multiline':False]['text':'
 * Free and clear a buffer.
 ','line_number':100,'multiline':True]['text':'
 * Return the contents of a buffer as a single string.
 * K_SPECIAL and CSI in the returned string are escaped.
 ','line_number':117,'multiline':True]['text':' count == zero is not an error','line_number':124,'multiline':False]['text':' compute the total length of the string','line_number':132,'multiline':False]['text':'
 * Return the contents of the record buffer as a single string
 * and clear the record buffer.
 * K_SPECIAL and CSI in the returned string are escaped.
 ','line_number':147,'multiline':True]['text':'
     * Remove the characters that were added the last time, these must be the
     * (possibly mapped) characters that stopped the recording.
     ','line_number':161,'multiline':True]['text':'
     * When stopping recording from Insert mode with CTRL-O q, also remove the
     * CTRL-O.
     ','line_number':172,'multiline':True]['text':'
 * Return the contents of the redo buffer as a single string.
 * K_SPECIAL and CSI in the returned string are escaped.
 ','line_number':182,'multiline':True]['text':'
 * Add string "s" after the current block of buffer "buf".
 * K_SPECIAL and CSI should have been escaped already.
 ','line_number':192,'multiline':True]['text':' length of "s" or -1','line_number':200,'multiline':False]['text':' don't add empty strings','line_number':207,'multiline':False]['text':' first add to list','line_number':210,'multiline':False]['text':' buffer has already been read','line_number':215,'multiline':False]['text':' no space, just forget it','line_number':240,'multiline':False]['text':'
 * Delete "slen" bytes from the end of "buf".
 * Only works when it was just added.
 ','line_number':250,'multiline':True]['text':' nothing to delete','line_number':260,'multiline':False]['text':'
 * Add number "n" to buffer "buf".
 ','line_number':269,'multiline':True]['text':'
 * Add character 'c' to buffer "buf".
 * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.
 ','line_number':281,'multiline':True]['text':' translate special key code into three byte sequence','line_number':304,'multiline':False]['text':' Translate a CSI to a CSI - KS_EXTRA - KE_CSI sequence','line_number':313,'multiline':False]['text':' First read ahead buffer. Used for translated commands.','line_number':329,'multiline':False]['text':' Second read ahead buffer. Used for redo.','line_number':332,'multiline':False]['text':'
 * Get one byte from the read buffers.  Use readbuf1 one first, use readbuf2
 * if that one is empty.
 * If advance == TRUE go to the next char.
 * No translation is done K_SPECIAL and CSI are escaped.
 ','line_number':335,'multiline':True]['text':' buffer is empty','line_number':358,'multiline':False]['text':'
 * Prepare the read buffers for reading (if they contain something).
 ','line_number':376,'multiline':True]['text':'
 * Return TRUE if the stuff buffer is empty.
 ','line_number':394,'multiline':True]['text':'
 * Return TRUE if readbuf1 is empty.  There may still be redo characters in
 * redbuf2.
 ','line_number':405,'multiline':True]['text':'
 * Set a typeahead character that won't be flushed.
 ','line_number':416,'multiline':True]['text':'
 * Remove the contents of the stuff buffer and the mapped characters in the
 * typeahead buffer (used in case of an error).  If "flush_typeahead" is true,
 * flush all typeahead characters (used when interrupted by a CTRL-C).
 ','line_number':425,'multiline':True]['text':' remove mapped characters at the start only','line_number':441,'multiline':False]['text':' remove typeahead','line_number':451,'multiline':False]['text':' We have to get all characters, because we may delete the first','line_number':453,'multiline':False]['text':' part of an escape sequence.  In an xterm we get one char at a','line_number':454,'multiline':False]['text':' time and we have to get them all.','line_number':455,'multiline':False]['text':' Reset the flag that text received from a client or from feedkeys()','line_number':461,'multiline':False]['text':' was inserted in the typeahead buffer.','line_number':462,'multiline':False]['text':'
 * The previous contents of the redo buffer is kept in old_redobuffer.
 * This is used for the CTRL-O <.> command in insert mode.
 ','line_number':474,'multiline':True]['text':'
 * Discard the contents of the redo buffer and restore the previous redo
 * buffer.
 ','line_number':489,'multiline':True]['text':'
 * Save redobuff and old_redobuff to save_redobuff and save_old_redobuff.
 * Used before executing autocommands and user functions.
 ','line_number':507,'multiline':True]['text':' Make a copy, so that ":normal ." in a function works.','line_number':521,'multiline':False]['text':'
 * Restore redobuff and old_redobuff from save_redobuff and save_old_redobuff.
 * Used after executing autocommands and user functions.
 ','line_number':530,'multiline':True]['text':'
 * Append "s" to the redo buffer.
 * K_SPECIAL and CSI should already have been escaped.
 ','line_number':543,'multiline':True]['text':'
 * Append to Redo buffer literally, escaping special characters with CTRL-V.
 * K_SPECIAL and CSI are escaped as well.
 ','line_number':554,'multiline':True]['text':' length of "str" or -1 for up to the NUL','line_number':561,'multiline':False]['text':' Put a string of normal characters in the redo buffer (that's','line_number':572,'multiline':False]['text':' faster).','line_number':573,'multiline':False]['text':' Don't put '0' or '^' as last character, just in case a CTRL-D is','line_number':578,'multiline':False]['text':' typed next.','line_number':579,'multiline':False]['text':' Handle a special or multibyte character.','line_number':588,'multiline':False]['text':' Handle composing chars separately.','line_number':590,'multiline':False]['text':' CTRL-V '0' must be inserted as CTRL-V 048','line_number':597,'multiline':False]['text':'
 * Append "s" to the redo buffer, leaving 3-byte special key codes unmodified
 * and escaping other K_SPECIAL and CSI bytes.
 ','line_number':605,'multiline':True]['text':' Insert special key literally.','line_number':619,'multiline':False]['text':'
 * Append a character to the redo buffer.
 * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.
 ','line_number':628,'multiline':True]['text':'
 * Append a number to the redo buffer.
 ','line_number':639,'multiline':True]['text':'
 * Append string "s" to the stuff buffer.
 * CSI and K_SPECIAL must already have been escaped.
 ','line_number':649,'multiline':True]['text':'
 * Append string "s" to the redo stuff buffer.
 * CSI and K_SPECIAL must already have been escaped.
 ','line_number':659,'multiline':True]['text':'
 * Stuff "s" into the stuff buffer, leaving special key codes unmodified and
 * escaping other K_SPECIAL and CSI bytes.
 * Change CR, LF and ESC into a space.
 ','line_number':676,'multiline':True]['text':' Insert special key literally.','line_number':690,'multiline':False]['text':'
 * Append a character to the stuff buffer.
 * Translates special keys, NUL, CSI, K_SPECIAL and multibyte characters.
 ','line_number':705,'multiline':True]['text':'
 * Append a number to the stuff buffer.
 ','line_number':715,'multiline':True]['text':'
 * Stuff a string into the typeahead buffer, such that edit() will insert it
 * literally ("literally" TRUE) or interpret is as typed characters.
 ','line_number':724,'multiline':True]['text':' Stuff a sequence of normal ASCII characters, that's fast.  Also','line_number':736,'multiline':False]['text':' stuff K_SPECIAL to get the effect of a special key when "literally"','line_number':737,'multiline':False]['text':' is TRUE.','line_number':738,'multiline':False]['text':' stuff a single special character','line_number':746,'multiline':False]['text':'
 * Read a character from the redo buffer.  Translates K_SPECIAL, CSI and
 * multibyte characters.
 * The redo buffer is left as it is.
 * If init is TRUE, prepare for redo, return FAIL if nothing to redo, OK
 * otherwise.
 * If old is TRUE, use old_redobuff instead of redobuff.
 ','line_number':760,'multiline':True]['text':' Reverse the conversion done by add_char_buff()','line_number':791,'multiline':False]['text':' For a multi-byte character get all the bytes and return the','line_number':792,'multiline':False]['text':' converted character.','line_number':793,'multiline':False]['text':' special key or escaped K_SPECIAL','line_number':800,'multiline':False]['text':' escaped CSI','line_number':806,'multiline':False]['text':' last byte of a character','line_number':815,'multiline':False]['text':' cannot happen?','line_number':822,'multiline':False]['text':'
 * Copy the rest of the redo buffer into the stuff buffer (in a slow way).
 * If old_redo is TRUE, use old_redobuff instead of redobuff.
 * The escaped K_SPECIAL and CSI are copied without translation.
 ','line_number':830,'multiline':True]['text':'
 * Stuff the redo buffer into readbuf2.
 * Insert the redo count into the command.
 * If "old_redo" is TRUE, the last but one command is repeated
 * instead of the last command (inserting text). This is used for
 * CTRL-O <.> in insert mode
 *
 * return FAIL for failure, OK otherwise
 ','line_number':844,'multiline':True]['text':' init the pointers; return if nothing to redo','line_number':858,'multiline':False]['text':' Copy the <SID>{sid}; sequence','line_number':867,'multiline':False]['text':' copy the buffer name, if present','line_number':880,'multiline':False]['text':' if a numbered buffer is used, increment the number','line_number':886,'multiline':False]['text':' the expression register should be re-evaluated','line_number':891,'multiline':False]['text':' redo Visual','line_number':901,'multiline':False]['text':' try to enter the count (in place of a previous count)','line_number':911,'multiline':False]['text':' skip "old" count','line_number':914,'multiline':False]['text':' copy the rest from the redo buffer into the stuff buffer','line_number':919,'multiline':False]['text':'
 * Repeat the last insert (R, o, O, a, A, i or I command) by stuffing
 * the redo buffer into readbuf2.
 * return FAIL for failure, OK otherwise
 ','line_number':925,'multiline':True]['text':' skip the count and the command character','line_number':939,'multiline':False]['text':' copy the typed text from the redo buffer into the stuff buffer','line_number':950,'multiline':False]['text':'
 * Initialize typebuf.tb_buf to point to typebuf_init.
 * alloc() cannot be used here: In out-of-memory situations it would
 * be impossible to type anything.
 ','line_number':962,'multiline':True]['text':'
 * Returns TRUE when keys cannot be remapped.
 ','line_number':981,'multiline':True]['text':'
 * Insert a string in position 'offset' in the typeahead buffer (for "@r"
 * and ":normal" command, vgetorpeek() and check_termcode()).
 *
 * If "noremap" is REMAP_YES, new string can be mapped again.
 * If "noremap" is REMAP_NONE, new string cannot be mapped again.
 * If "noremap" is REMAP_SKIP, first char of new string cannot be mapped again,
 * but abbreviations are allowed.
 * If "noremap" is REMAP_SCRIPT, new string cannot be mapped again, except for
 *			script-local mappings.
 * If "noremap" is > 0, that many characters of the new string cannot be mapped.
 *
 * If "nottyped" is TRUE, the string does not return KeyTyped (don't use when
 * "offset" is non-zero!).
 *
 * If "silent" is TRUE, cmd_silent is set when the characters are obtained.
 *
 * return FAIL for failure, OK otherwise
 ','line_number':990,'multiline':True]['text':'
	 * Easy case: there is room in front of typebuf.tb_buf[typebuf.tb_off]
	 ','line_number':1034,'multiline':True]['text':'
	 * Buffer is empty and string fits in the existing buffer.
	 * Leave some space before and after, if possible.
	 ','line_number':1043,'multiline':True]['text':'
	 * Need to allocate a new buffer.
	 * In typebuf.tb_buf there must always be room for 3 * (MAXMAPLEN + 4)
	 * characters.  We add some extra room to avoid having to allocate too
	 * often.
	 ','line_number':1054,'multiline':True]['text':' string is getting too long for a 32 bit int','line_number':1064,'multiline':False]['text':' also calls flush_buffers','line_number':1065,'multiline':False]['text':' out of memory','line_number':1071,'multiline':False]['text':' out of memory','line_number':1074,'multiline':False]['text':' copy the old chars, before the insertion point','line_number':1081,'multiline':False]['text':' copy the new chars','line_number':1084,'multiline':False]['text':' copy the old chars, after the insertion point, including the	NUL at','line_number':1086,'multiline':False]['text':' the end','line_number':1087,'multiline':False]['text':' If noremap == REMAP_SCRIPT: do remap script-local mappings.','line_number':1108,'multiline':False]['text':'
     * Adjust typebuf.tb_noremap[] for the new characters:
     * If noremap == REMAP_NONE or REMAP_SCRIPT: new characters are
     *			(sometimes) not remappable
     * If noremap == REMAP_YES: all the new characters are mappable
     * If noremap  > 0: "noremap" characters are not remappable, the rest
     *			mappable
     ','line_number':1116,'multiline':True]['text':' tb_maplen and tb_silent only remember the length of mapped and/or','line_number':1134,'multiline':False]['text':' silent mappings at the start of the buffer, assuming that a mapped','line_number':1135,'multiline':False]['text':' sequence doesn't result in typed characters.','line_number':1136,'multiline':False]['text':' and not used for abbrev.s','line_number':1144,'multiline':False]['text':'
 * Put character "c" back into the typeahead buffer.
 * Can be used for a character obtained by vgetc() that needs to be put back.
 * Uses cmd_silent, KeyTyped and KeyNoremap to restore the flags belonging to
 * the char.
 * Returns the length of what was inserted.
 ','line_number':1150,'multiline':True]['text':'
 * Return TRUE if the typeahead buffer was changed (while waiting for a
 * character to arrive).  Happens when a message was received from a client or
 * from feedkeys().
 * But check in a more generic way to avoid trouble: When "typebuf.tb_buf"
 * changed it was reallocated and the old pointer can no longer be used.
 * Or "typebuf.tb_off" may have been changed and we would overwrite characters
 * that was just added.
 ','line_number':1168,'multiline':True]['text':' old value of typebuf.tb_change_cnt','line_number':1179,'multiline':False]['text':'
 * Return TRUE if there are no characters in the typeahead buffer that have
 * not been typed (result from a mapping or come from ":normal").
 ','line_number':1188,'multiline':True]['text':'
 * Return the number of characters that are mapped (or not typed).
 ','line_number':1198,'multiline':True]['text':'
 * remove "len" characters from typebuf.tb_buf[typebuf.tb_off + offset]
 ','line_number':1207,'multiline':True]['text':' nothing to do','line_number':1216,'multiline':False]['text':'
     * Easy case: Just increase typebuf.tb_off.
     ','line_number':1220,'multiline':True]['text':'
     * Have to move the characters in typebuf.tb_buf[] and typebuf.tb_noremap[]
     ','line_number':1226,'multiline':True]['text':'
	 * Leave some extra room at the end to avoid reallocation.
	 ','line_number':1232,'multiline':True]['text':' adjust typebuf.tb_buf (include the NUL at the end)','line_number':1243,'multiline':False]['text':' adjust typebuf.tb_noremap[]','line_number':1247,'multiline':False]['text':' adjust tb_maplen','line_number':1253,'multiline':False]['text':' adjust tb_silent','line_number':1260,'multiline':False]['text':' adjust tb_no_abbr_cnt','line_number':1267,'multiline':False]['text':' Reset the flag that text received from a client or from feedkeys()','line_number':1276,'multiline':False]['text':' was inserted in the typeahead buffer.','line_number':1277,'multiline':False]['text':'
 * Write typed characters to script file.
 * If recording is on put the character in the recordbuffer.
 ','line_number':1284,'multiline':True]['text':' When receiving a special key sequence, store it until we have all','line_number':1301,'multiline':False]['text':' the bytes and we can decide what to do with it.','line_number':1302,'multiline':False]['text':' Drop K_FOCUSGAINED and K_FOCUSLOST, they are not useful in a','line_number':1310,'multiline':False]['text':' recording.','line_number':1311,'multiline':False]['text':' Handle one byte at a time; no translation to be done.','line_number':1316,'multiline':False]['text':' remember how many chars were last recorded','line_number':1324,'multiline':False]['text':' output "debug mode" message next time in debug mode','line_number':1332,'multiline':False]['text':' Since characters have been typed, consider the following to be in','line_number':1336,'multiline':False]['text':' another mapping.  Search string will be kept in history.','line_number':1337,'multiline':False]['text':'
 * Record a <Nop> key.
 ','line_number':1341,'multiline':True]['text':'
 * Undo the last gotchars() for "len" bytes.  To be used when putting a typed
 * character back into the typeahead buffer, thus gotchars() will be called
 * again.
 * Only affects recorded characters.
 ','line_number':1351,'multiline':True]['text':'
 * Sync undo.  Called when typed characters are obtained from the typeahead
 * buffer, or when a menu is used.
 * Do not sync:
 * - In Insert mode, unless cursor key has been used.
 * - While reading a script file.
 * - When no_u_sync is non-zero.
 ','line_number':1367,'multiline':True]['text':'
 * Make "typebuf" empty and allocate new buffers.
 * Returns FAIL when out of memory.
 ','line_number':1383,'multiline':True]['text':' can insert without realloc','line_number':1398,'multiline':False]['text':'
 * Free the buffers of "typebuf".
 ','line_number':1411,'multiline':True]['text':'
 * When doing ":so! file", the current typeahead needs to be saved, and
 * restored when "file" has been read completely.
 ','line_number':1427,'multiline':True]['text':' If out of memory: restore typebuf and close file.','line_number':1438,'multiline':False]['text':' character put back by vungetc()','line_number':1447,'multiline':False]['text':' mod_mask for ungotten character','line_number':1448,'multiline':False]['text':' mouse_row related to old_char','line_number':1449,'multiline':False]['text':' mouse_col related to old_char','line_number':1450,'multiline':False]['text':' whether old_char was stuffed','line_number':1451,'multiline':False]['text':' If the old character was not stuffed and characters have been added to','line_number':1455,'multiline':False]['text':' the stuff buffer, need to first get the stuffed characters instead.','line_number':1456,'multiline':False]['text':'
 * Save all three kinds of typeahead, so that the user must type at a prompt.
 ','line_number':1460,'multiline':True]['text':'
 * Restore the typeahead to what it was before calling save_typeahead().
 * The allocated memory is freed, can only be called once!
 * When "overwrite" is FALSE input typed later is kept.
 ','line_number':1484,'multiline':True]['text':'
 * Open a new script file for the ":source!" command.
 ','line_number':1510,'multiline':True]['text':' when TRUE execute directly','line_number':1516,'multiline':False]['text':' Disallow sourcing a file in the sandbox, the commands would be executed','line_number':1524,'multiline':False]['text':' later, possibly outside of the sandbox.','line_number':1525,'multiline':False]['text':' Not reading from script, also don't open one.  Warning message?','line_number':1531,'multiline':False]['text':' already reading script','line_number':1535,'multiline':False]['text':' use NameBuff for expanded name','line_number':1537,'multiline':False]['text':'
     * Execute the commands from the file right now when using ":source!"
     * after ":global" or ":argdo" or in a loop.  Also when another command
     * follows.  This means the display won't be updated.  Don't do this
     * always, "make test" would fail.
     ','line_number':1549,'multiline':True]['text':' no msg scrolling in Normal mode','line_number':1566,'multiline':False]['text':' don't go to Insert mode','line_number':1567,'multiline':False]['text':' don't use 'insertmode'','line_number':1568,'multiline':False]['text':' update cursor position and topline','line_number':1575,'multiline':False]['text':' execute one command','line_number':1576,'multiline':False]['text':' check for end of file','line_number':1577,'multiline':False]['text':'
 * Close the currently active input script.
 ','line_number':1589,'multiline':True]['text':'
 * Return TRUE when reading keys from a script file.
 ','line_number':1613,'multiline':True]['text':'
 * This function is called just before doing a blocking wait.  Thus after
 * waiting 'updatetime' for a character to arrive.
 ','line_number':1622,'multiline':True]['text':'
 * updatescript() is called when a character can be written into the script
 * file or when we have waited some time for a character (c == 0)
 *
 * All the changed memfiles are synced if c == 0 or when the number of typed
 * characters reaches 'updatecount' and 'updatecount' is non-zero.
 ','line_number':1636,'multiline':True]['text':'
 * Convert "c_arg" plus "modifiers" to merge the effect of modifyOtherKeys into
 * the character.  Also for when the Kitty key protocol is used.
 ','line_number':1657,'multiline':True]['text':' CTRL only uses the lower 5 bits of the character.','line_number':1666,'multiline':False]['text':' CTRL-6 is equivalent to CTRL-^','line_number':1676,'multiline':False]['text':' These mappings look arbitrary at the first glance, but in fact','line_number':1679,'multiline':False]['text':' resemble quite exactly the behaviour of the GTK+ 1.2 GUI on my','line_number':1680,'multiline':False]['text':' machine.  The only difference is BS vs. DEL for CTRL-8 (makes','line_number':1681,'multiline':False]['text':' more sense and is consistent with usual terminal behaviour).','line_number':1682,'multiline':False]['text':' Alt/Meta sets the 8th bit of the character.','line_number':1696,'multiline':False]['text':' Some terminals (esp. Kitty) do not include Shift in the character.','line_number':1700,'multiline':False]['text':' Apply it here to get consistency across terminals.  Only do ASCII','line_number':1701,'multiline':False]['text':' letters, for other characters it depends on the keyboard layout.','line_number':1702,'multiline':False]['text':'
 * Get the next input character.
 * Can return a special key or a multi-byte character.
 * Can return NUL when called recursively, use safe_vgetc() if that's not
 * wanted.
 * This translates escaped K_SPECIAL and CSI bytes to a K_SPECIAL or CSI byte.
 * Collects the bytes of a multibyte character into the whole character.
 * Returns the modifiers in the global "mod_mask".
 ','line_number':1715,'multiline':True]['text':' Do garbage collection when garbagecollect() was called previously and','line_number':1733,'multiline':False]['text':' we are now at the toplevel.','line_number':1734,'multiline':False]['text':'
     * If a character was put back with vungetc, it was already processed.
     * Return it directly.
     ','line_number':1739,'multiline':True]['text':' number of characters recorded from the last vgetc() call','line_number':1753,'multiline':False]['text':' last_recorded_len can be larger than last_vgetc_recorded_len','line_number':1760,'multiline':False]['text':' if peeking records more','line_number':1761,'multiline':False]['text':' this is done twice if there are modifiers','line_number':1764,'multiline':False]['text':' No mapping after modifier has been read, using an input method','line_number':1768,'multiline':False]['text':' and when a popup window has disabled mapping.','line_number':1769,'multiline':False]['text':' mod_mask value may change, remember we did the increment','line_number':1781,'multiline':False]['text':' Get two extra bytes for special keys, handle modifiers.','line_number':1791,'multiline':False]['text':' make sure BS is not found','line_number':1801,'multiline':False]['text':' no mapping for these chars','line_number':1802,'multiline':False]['text':' K_ESC is used to avoid ambiguity with the single Esc','line_number':1813,'multiline':False]['text':' character that might be the start of an escape sequence.','line_number':1814,'multiline':False]['text':' Convert it back to a single Esc here.','line_number':1815,'multiline':False]['text':' Handle K_TEAROFF here, the caller of vgetc() doesn't need to','line_number':1820,'multiline':False]['text':' know that a menu was torn off','line_number':1821,'multiline':False]['text':' get menu path, it ends with a <CR>','line_number':1831,'multiline':False]['text':' GTK: <F10> normally selects the menu, but it's passed until','line_number':1844,'multiline':False]['text':' here to allow mapping it.  Intercept and invoke the GTK','line_number':1845,'multiline':False]['text':' behavior if it's not mapped.','line_number':1846,'multiline':False]['text':' Handle focus event here, so that the caller doesn't need to','line_number':1855,'multiline':False]['text':' know about it.  Return K_IGNORE so that we loop once (needed','line_number':1856,'multiline':False]['text':' if 'lazyredraw' is set).','line_number':1857,'multiline':False]['text':' Translate K_CSI to CSI.  The special key is only used to','line_number':1864,'multiline':False]['text':' avoid it being recognized as the start of a special key.','line_number':1865,'multiline':False]['text':' Handle <SID>{sid};  Do up to 20 digits for safety.','line_number':1874,'multiline':False]['text':' a keypad or special function key was not mapped, use it like','line_number':1884,'multiline':False]['text':' its ASCII equivalent','line_number':1885,'multiline':False]['text':' Can be either '.' or a ',',','line_number':1895,'multiline':False]['text':' depending on the type of keypad.','line_number':1896,'multiline':False]['text':' For a multi-byte character get all the bytes and return the','line_number':1947,'multiline':False]['text':' converted character.','line_number':1948,'multiline':False]['text':' Note: This will loop until enough bytes are received!','line_number':1949,'multiline':False]['text':' Must be a K_SPECIAL - KS_SPECIAL - KE_FILLER','line_number':1963,'multiline':False]['text':' sequence, which represents a K_SPECIAL (0x80),','line_number':1964,'multiline':False]['text':' or a CSI - KS_EXTRA - KE_CSI sequence, which','line_number':1965,'multiline':False]['text':' represents a CSI (0x9B),','line_number':1966,'multiline':False]['text':' or a K_SPECIAL - KS_EXTRA - KE_CSI, which is CSI','line_number':1967,'multiline':False]['text':' too.','line_number':1968,'multiline':False]['text':'
     * In the main loop "may_garbage_collect" can be set to do garbage
     * collection in the first next vgetc().  It's disabled after that to
     * avoid internally used Lists and Dicts to be freed.
     ','line_number':1991,'multiline':True]['text':' Don't trigger 'balloonexpr' unless only the mouse was moved.','line_number':2002,'multiline':False]['text':' Only filter keys that do not come from ":normal".  Keys from feedkeys()','line_number':2008,'multiline':False]['text':' are filtered.','line_number':2009,'multiline':False]['text':' avoid looping','line_number':2013,'multiline':False]['text':' Need to process the character before we know it's safe to do something','line_number':2018,'multiline':False]['text':' else.','line_number':2019,'multiline':False]['text':'
 * Like vgetc(), but never return a NUL when called recursively, get a key
 * directly from the user (ignoring typeahead).
 ','line_number':2026,'multiline':True]['text':'
 * Like safe_vgetc(), but loop to handle K_IGNORE.
 * Also ignore scrollbar events.
 * Does not handle bracketed paste - do not use the result for commands.
 ','line_number':2041,'multiline':True]['text':'
 * Like safe_vgetc(), but loop to handle K_IGNORE.
 * Also ignore scrollbar events.
 ','line_number':2059,'multiline':True]['text':' Only handle the first pasted character.  Drop the rest, since we','line_number':2069,'multiline':False]['text':' don't know what to do with it.','line_number':2070,'multiline':False]['text':'
 * Check if a character is available, such that vgetc() will not block.
 * If the next character is a special character or multi-byte, the returned
 * character is not valid!.
 * Returns NUL if no character is available.
 ','line_number':2076,'multiline':True]['text':'
 * Like vpeekc(), but don't allow mapping.  Do allow checking for terminal
 * codes.
 ','line_number':2091,'multiline':True]['text':'
 * Check if any character is available, also half an escape sequence.
 * Trick: when no typeahead found, but there is something in the typeahead
 * buffer, it must be an ESC that is recognized as the start of a key code.
 ','line_number':2109,'multiline':True]['text':'
 * Call vpeekc() without causing anything to be mapped.
 * Return TRUE if a character is available, FALSE otherwise.
 ','line_number':2125,'multiline':True]['text':' When test_override("char_avail", 1) was called pretend there is no','line_number':2135,'multiline':False]['text':' typeahead.','line_number':2136,'multiline':False]['text':'
 * "getchar()" and "getcharstr()" functions
 ','line_number':2147,'multiline':True]['text':' vpeekc() used to check for messages, but that caused problems, invoking','line_number':2160,'multiline':False]['text':' a callback where it was not expected.  Some plugins use getchar(1) in a','line_number':2161,'multiline':False]['text':' loop to await a message, therefore make sure we check for messages here.','line_number':2162,'multiline':False]['text':' Position the cursor.  Needed after a message that ends in a space.','line_number':2166,'multiline':False]['text':' getchar(): blocking wait.','line_number':2174,'multiline':False]['text':' getchar(1): only check if char avail','line_number':2177,'multiline':False]['text':' illegal argument or getchar(0) and no char avail: return zero','line_number':2180,'multiline':False]['text':' getchar(0) and char avail() != NUL: get a character.','line_number':2183,'multiline':False]['text':' Note that vpeekc_any() returns K_SPECIAL for K_IGNORE.','line_number':2184,'multiline':False]['text':' modifier: 3, mbyte-char: 6, NUL: 1','line_number':2203,'multiline':False]['text':' Turn a special key into three bytes, plus modifier.','line_number':2206,'multiline':False]['text':' Find the window at the mouse coordinates and compute the','line_number':2238,'multiline':False]['text':' text position.','line_number':2239,'multiline':False]['text':'
 * "getchar()" function
 ','line_number':2261,'multiline':True]['text':'
 * "getcharstr()" function
 ','line_number':2270,'multiline':True]['text':' mbyte-char: 6, NUL: 1','line_number':2281,'multiline':False]['text':'
 * "getcharmod()" function
 ','line_number':2297,'multiline':True]['text':' FEAT_EVAL','line_number':2305,'multiline':False]['text':'
 * Process messages that have been queued for netbeans or clientserver.
 * Also check if any jobs have ended.
 * These functions can call arbitrary Vim script and should only be called when
 * it is safe to do so.
 ','line_number':2310,'multiline':True]['text':' Do not handle messages while redrawing, because it may cause buffers to','line_number':2326,'multiline':False]['text':' change or be wiped while they are being redrawn.','line_number':2327,'multiline':False]['text':' Also bail out when parsing messages was explicitly disabled.','line_number':2328,'multiline':False]['text':' If memory allocation fails during startup we'll exit but curbuf or','line_number':2332,'multiline':False]['text':' curwin could be NULL.','line_number':2333,'multiline':False]['text':' may_garbage_collect is set in main_loop() to do garbage collection when','line_number':2342,'multiline':False]['text':' blocking to wait on a character.  We don't want that while parsing','line_number':2343,'multiline':False]['text':' messages, a callback may invoke vgetc() while lists and dicts are in use','line_number':2344,'multiline':False]['text':' in the call stack.','line_number':2345,'multiline':False]['text':' Loop when a job ended, but don't keep looping forever.','line_number':2348,'multiline':False]['text':' For Win32 mch_breakcheck() does not check for input, do it here.','line_number':2351,'multiline':False]['text':' Process the queued netbeans messages.','line_number':2357,'multiline':False]['text':' Write any buffer lines still to be written.','line_number':2361,'multiline':False]['text':' Process the messages queued on channels.','line_number':2364,'multiline':False]['text':' Process the queued clientserver messages.','line_number':2368,'multiline':False]['text':' Check if any jobs have ended.  If so, repeat the above to handle','line_number':2372,'multiline':False]['text':' changes, e.g. stdin may have been closed.','line_number':2373,'multiline':False]['text':' When not nested we'll go back to waiting for a typed character.  If it','line_number':2398,'multiline':False]['text':' was safe before then this triggers a SafeStateAgain autocommand event.','line_number':2399,'multiline':False]['text':' If the current window or buffer changed we need to bail out of the','line_number':2405,'multiline':False]['text':' waiting loop.  E.g. when a job exit callback closes the terminal window.','line_number':2406,'multiline':False]['text':' failed, break loop','line_number':2416,'multiline':False]['text':' get a character from typeahead','line_number':2417,'multiline':False]['text':' try to map again','line_number':2418,'multiline':False]['text':' no matching mapping, get char','line_number':2419,'multiline':False]['text':'
 * Check if the bytes at the start of the typeahead buffer are a character used
 * in Insert mode completion.  This includes the form with a CTRL modifier.
 ','line_number':2422,'multiline':True]['text':' CSI is used by the GUI','line_number':2433,'multiline':False]['text':'
 * Check if typebuf.tb_buf[] contains a modifier plus key that can be changed
 * into just a key, apply that.
 * Check from typebuf.tb_buf[typebuf.tb_off] to typebuf.tb_buf[typebuf.tb_off
 * + "max_offset"].
 * Return the length of the replaced bytes, 0 if nothing changed, -1 for error.
 ','line_number':2441,'multiline':True]['text':' A modifier was not used for a mapping, apply it to ASCII keys.','line_number':2461,'multiline':False]['text':' Shift would already have been applied.','line_number':2462,'multiline':False]['text':' At the start: remember the character and mod_mask before','line_number':2474,'multiline':False]['text':' merging, in some cases, e.g. at the hit-return prompt,','line_number':2475,'multiline':False]['text':' they are put back in the typeahead buffer.','line_number':2476,'multiline':False]['text':'
 * Return TRUE if the terminal sends modifiers with various keys.  This is when
 * modifyOtherKeys level 2 is enabled or the kitty keyboard protocol is
 * enabled.
 ','line_number':2509,'multiline':True]['text':' If xterm has responded to XTQMODKEYS it overrules seenModifyOtherKeys.','line_number':2517,'multiline':False]['text':'
 * Handle mappings in the typeahead buffer.
 * - When something was mapped, return map_result_retry for recursive mappings.
 * - When nothing mapped and typeahead has a character: return map_result_get.
 * - When there is no match yet, return map_result_nomatch, need to get more
 *   typeahead.
 * - On failure (out of memory) return map_result_fail.
 ','line_number':2524,'multiline':True]['text':' 1 if termcode expected after max_mlen','line_number':2543,'multiline':False]['text':' If typeahead starts with <Plug> then remap, even for a "noremap" mapping.','line_number':2554,'multiline':False]['text':'
     * Check for a mappable key sequence.
     * Walk through one maphash[] list until we find an entry that matches.
     *
     * Don't look for mappings if:
     * - no_mapping set: mapping disabled (e.g. for CTRL-V)
     * - maphash_valid not set: no mappings present.
     * - typebuf.tb_buf[typebuf.tb_off] should not be remapped
     * - in insert or cmdline mode and 'paste' option set
     * - waiting for "hit return to continue" and CR or SPACE typed
     * - waiting for a char with --more--
     * - in Ctrl-X mode, and we get a valid char for that mode
     ','line_number':2561,'multiline':True]['text':' The GUI code sends CSI KS_MODIFIER {flags}, but mappings expect','line_number':2591,'multiline':False]['text':' K_SPECIAL KS_MODIFIER {flags}.','line_number':2592,'multiline':False]['text':' First try buffer-local mappings.','line_number':2606,'multiline':False]['text':' There are no buffer-local mappings.','line_number':2611,'multiline':False]['text':'
	 * Loop until a partly matching mapping is found or all (local)
	 * mappings have been checked.
	 * The longest full match is remembered in "mp_match".
	 * A full match is only accepted if there is no partly match, so "aa"
	 * and "aaa" can both be mapped.
	 ','line_number':2616,'multiline':True]['text':' Only consider an entry if the first character matches and it is','line_number':2628,'multiline':False]['text':' for the current state.','line_number':2629,'multiline':False]['text':' Skip ":lmap" mappings if keys were mapped.','line_number':2630,'multiline':False]['text':' find the match length of this mapping','line_number':2642,'multiline':False]['text':' Only apply 'langmap' if merging modifiers into','line_number':2660,'multiline':False]['text':' the key will not result in another character,','line_number':2661,'multiline':False]['text':' so that 'langmap' behaves consistently in','line_number':2662,'multiline':False]['text':' different terminals and GUIs.','line_number':2663,'multiline':False]['text':' Don't allow mapping the first byte(s) of a multi-byte char.','line_number':2672,'multiline':False]['text':' Happens when mapping <M-a> and then changing 'encoding'.','line_number':2673,'multiline':False]['text':' Beware that 0x80 is escaped.','line_number':2674,'multiline':False]['text':' Check an entry whether it matches.','line_number':2684,'multiline':False]['text':' - Full match: mlen == keylen','line_number':2685,'multiline':False]['text':' - Partly match: mlen == typebuf.tb_len','line_number':2686,'multiline':False]['text':' If only script-local mappings are allowed, check if the','line_number':2694,'multiline':False]['text':' mapping starts with K_SNR.','line_number':2695,'multiline':False]['text':' If one of the typed keys cannot be remapped, skip the','line_number':2703,'multiline':False]['text':' entry.','line_number':2704,'multiline':False]['text':' break at a partly match','line_number':2716,'multiline':False]['text':' found a longer match','line_number':2723,'multiline':False]['text':' No match; may have to check for termcode at next','line_number':2729,'multiline':False]['text':' character.  If the first character that didn't match is','line_number':2730,'multiline':False]['text':' K_SPECIAL then check for a termcode.  This isn't perfect','line_number':2731,'multiline':False]['text':' but should work in most cases.','line_number':2732,'multiline':False]['text':' If no partly match found, use the longest full match.','line_number':2743,'multiline':False]['text':'
     * Check for match with 'pastetoggle'
     ','line_number':2751,'multiline':True]['text':' match','line_number':2759,'multiline':False]['text':' write chars to script file(s)','line_number':2761,'multiline':False]['text':' remove the chars','line_number':2766,'multiline':False]['text':' clear ruler','line_number':2773,'multiline':False]['text':' Need more chars for partly match.','line_number':2782,'multiline':False]['text':' no match, may have to check for termcode at next character','line_number':2786,'multiline':False]['text':' May check for a terminal code when there is no mapping or only a partial','line_number':2790,'multiline':False]['text':' mapping.  Also check if there is a full mapping with <Esc>, unless timed','line_number':2791,'multiline':False]['text':' out, since that is nearly always a partial match with a terminal code.','line_number':2792,'multiline':False]['text':'
	 * When no matching mapping found or found a non-matching mapping that
	 * matches at least what the matching mapping matched:
	 * Check if we have a terminal code, when:
	 * - mapping is allowed,
	 * - keys have not been mapped,
	 * - and not an ESC sequence, not in insert mode or p_ek is on,
	 * - and when not timed out,
	 ','line_number':2799,'multiline':True]['text':' If no termcode matched but 'pastetoggle' matched partially','line_number':2818,'multiline':False]['text':' it's like an incomplete key sequence.','line_number':2819,'multiline':False]['text':' If no termcode matched, try to include the modifier into the','line_number':2823,'multiline':False]['text':' key.  This is for when modifyOtherKeys is working.','line_number':2824,'multiline':False]['text':' may update the no_reduce_keys flag','line_number':2826,'multiline':False]['text':' ins_typebuf() failed','line_number':2832,'multiline':False]['text':' When getting a partial match, but the last characters were not','line_number':2836,'multiline':False]['text':' typed, don't wait for a typed character to complete the','line_number':2837,'multiline':False]['text':' termcode.  This helps a lot when a ":normal" command ends in an','line_number':2838,'multiline':False]['text':' ESC.','line_number':2839,'multiline':False]['text':' no matching terminal code','line_number':2845,'multiline':False]['text':' check for window bounds report','line_number':2848,'multiline':False]['text':' found one','line_number':2859,'multiline':False]['text':' get size and redraw screen','line_number':2863,'multiline':False]['text':' need more characters','line_number':2868,'multiline':False]['text':' When there was a matching mapping and no termcode could be','line_number':2873,'multiline':False]['text':' replaced after another one, use that mapping (loop around).','line_number':2874,'multiline':False]['text':' If there was no mapping at all use the character from the','line_number':2875,'multiline':False]['text':' typeahead buffer right here.','line_number':2876,'multiline':False]['text':' get character from typeahead','line_number':2880,'multiline':False]['text':' full matching terminal code','line_number':2884,'multiline':False]['text':' Using a menu may cause a break in undo!  It's like using','line_number':2893,'multiline':False]['text':' gotchars(), but without recording or writing to a script','line_number':2894,'multiline':False]['text':' file.','line_number':2895,'multiline':False]['text':' In Select mode and a Visual mode menu is used:  Switch','line_number':2901,'multiline':False]['text':' to Visual mode temporarily.  Append K_SELECT to switch','line_number':2902,'multiline':False]['text':' back to Select mode.','line_number':2903,'multiline':False]['text':' FEAT_GUI && FEAT_MENU','line_number':2916,'multiline':False]['text':' try mapping again','line_number':2918,'multiline':False]['text':' Partial match: get some more characters.  When a matching mapping','line_number':2921,'multiline':False]['text':' was found use that one.','line_number':2922,'multiline':False]['text':'
     * complete match
     ','line_number':2929,'multiline':True]['text':' write chars to script file(s)','line_number':2946,'multiline':False]['text':' remove the mapped keys','line_number':2952,'multiline':False]['text':'
	 * Put the replacement string in front of mapstr.
	 * The depth check catches ":map x y" and ":map y x".
	 ','line_number':2954,'multiline':True]['text':' for next one','line_number':2966,'multiline':False]['text':'
	 * In Select mode and a Visual mode mapping is used: Switch to Visual
	 * mode temporarily.  Append K_SELECT to switch back to Select mode.
	 ','line_number':2971,'multiline':True]['text':' Copy the values from *mp that are used, because evaluating the','line_number':2982,'multiline':False]['text':' expression may invoke a function that redefines the mapping, thereby','line_number':2983,'multiline':False]['text':' making *mp invalid.','line_number':2984,'multiline':False]['text':' only saved when needed','line_number':2988,'multiline':False]['text':'
	 * Handle ":map <expr>": evaluate the {rhs} as an expression.  Also
	 * save and restore the command line for "normal :".
	 ','line_number':2990,'multiline':True]['text':' The mapping may do anything, but we expect it to take care of','line_number':3008,'multiline':False]['text':' redrawing.  Do put the cursor back where it was.','line_number':3009,'multiline':False]['text':' If an error was displayed and the expression returns an empty','line_number':3013,'multiline':False]['text':' string, generate a <Nop> to allow for a redraw.','line_number':3014,'multiline':False]['text':' redraw the command below the error','line_number':3028,'multiline':False]['text':'
	 * Insert the 'to' part in the typebuf.tb_buf.
	 * If 'from' field is the same as the start of the 'to' field, don't
	 * remap the first character (but do allow abbreviations).
	 * If m_noremap is set, don't remap the whole 'to' part.
	 ','line_number':3043,'multiline':True]['text':'
 * unget one character (can only be done once!)
 * If the character was stuffed, vgetc() will get it next time it is called.
 * Otherwise vgetc() will only get it when the stuff buffer is empty.
 ','line_number':3092,'multiline':True]['text':'
 * When peeking and not getting a character, reg_executing cannot be cleared
 * yet, so set a flag to clear it later.
 ','line_number':3107,'multiline':True]['text':'
 * Get a byte:
 * 1. from the stuffbuffer
 *	This is used for abbreviated commands like "D" -> "d$".
 *	Also used to redo a command for ".".
 * 2. from the typeahead buffer
 *	Stores text obtained previously but not used yet.
 *	Also stores the result of mappings.
 *	Also used for the ":normal" command.
 * 3. from the user
 *	This may do a blocking wait if "advance" is TRUE.
 *
 * if "advance" is TRUE (vgetc()):
 *	Really get the character.
 *	KeyTyped is set to TRUE in the case the user typed the key.
 *	KeyStuffed is TRUE if the character comes from the stuff buffer.
 * if "advance" is FALSE (vpeekc()):
 *	Just look whether there is a character available.
 *	Return NUL if not.
 *
 * When "no_mapping" is zero, checks for mappings in the current mode.
 * Only returns one byte (of a multi-byte character).
 * K_SPECIAL and CSI may be escaped, need to get two more bytes then.
 ','line_number':3128,'multiline':True]['text':' waited for more than 'timeoutlen'','line_number':3156,'multiline':False]['text':' for mapping to complete or','line_number':3157,'multiline':False]['text':' 'ttimeoutlen' for complete key code','line_number':3158,'multiline':False]['text':' check for recursive mapping','line_number':3159,'multiline':False]['text':' set when mode has been deleted','line_number':3160,'multiline':False]['text':' adjusted cursor shape','line_number':3163,'multiline':False]['text':'
     * This function doesn't work very well when called recursively.  This may
     * happen though, because of:
     * 1. The call to add_to_showcmd().	char_avail() is then used to check if
     * there is a character available, which calls this function.  In that
     * case we must return NUL, to indicate no character is available.
     * 2. A GUI callback function writes to the screen, causing a
     * wait_return().
     * Using ":normal" can also do this, but it saves the typeahead buffer,
     * thus it should be OK.  But don't get a key from the user then.
     ','line_number':3169,'multiline':True]['text':'
 * get a character: 1. from the stuffbuffer
 ','line_number':3196,'multiline':True]['text':' KeyTyped = FALSE;  When the command that stuffed something','line_number':3211,'multiline':False]['text':' was typed, behave like the stuffed command was typed.','line_number':3212,'multiline':False]['text':' needed for CTRL-W CTRL-] to open a fold, for example.','line_number':3213,'multiline':False]['text':' no abbreviations now','line_number':3217,'multiline':False]['text':'
	     * Loop until we either find a matching mapped key, or we
	     * are sure that it is not a mapped key.
	     * If a mapped key sequence is found we go back to the start to
	     * try re-mapping.
	     ','line_number':3221,'multiline':True]['text':'
		 * ui_breakcheck() is slow, don't use it too often when
		 * inside a mapping.  But call it each time for typed
		 * characters.
		 ','line_number':3233,'multiline':True]['text':' check for CTRL-C','line_number':3241,'multiline':False]['text':' flush all input','line_number':3244,'multiline':False]['text':'
		     * If inchar() returns TRUE (script file was active) or we
		     * are inside a mapping, get out of Insert mode.
		     * Otherwise we behave like having gotten a CTRL-C.
		     * As a result typing CTRL-C in insert mode will
		     * really insert a CTRL-C.
		     ','line_number':3247,'multiline':True]['text':' flush all typeahead','line_number':3259,'multiline':False]['text':' Also record this character, it might be needed to','line_number':3263,'multiline':False]['text':' get out of Insert mode.','line_number':3264,'multiline':False]['text':'
		     * Check for a mapping in "typebuf".
		     ','line_number':3274,'multiline':True]['text':' try mapping again','line_number':3281,'multiline':False]['text':' failed, use the outer loop','line_number':3285,'multiline':False]['text':'
 * get a character: 2. from the typeahead buffer
 ','line_number':3291,'multiline':True]['text':' remove chars from typebuf','line_number':3295,'multiline':False]['text':' write char to script file(s)','line_number':3303,'multiline':False]['text':' got character, break the for loop','line_number':3310,'multiline':False]['text':' not enough characters, get more','line_number':3313,'multiline':False]['text':'
 * get a character: 3. from the user - handle <Esc> in Insert mode
 ','line_number':3316,'multiline':True]['text':'
		 * Special case: if we get an <ESC> in Insert mode and there
		 * are no more characters at once, we pretend to go out of
		 * Insert mode.  This prevents the one second delay after
		 * typing an <ESC>.  If we get something after all, we may
		 * have to redisplay the mode. That the cursor is in the wrong
		 * place does not matter.
		 * Do not do this if the kitty keyboard protocol is used, every
		 * <ESC> is the start of an escape sequence then.
		 ','line_number':3319,'multiline':True]['text':' may show a different cursor shape','line_number':3354,'multiline':False]['text':' move cursor left, if possible','line_number':3370,'multiline':False]['text':' After auto-indenting and no text is following,','line_number':3375,'multiline':False]['text':' we are expecting to truncate the trailing','line_number':3376,'multiline':False]['text':' white-space, so find the last non-white','line_number':3377,'multiline':False]['text':' character -- webb','line_number':3378,'multiline':False]['text':' no correction needed','line_number':3405,'multiline':False]['text':' Correct when the cursor is on the right halve','line_number':3421,'multiline':False]['text':' of a double-wide character.','line_number':3422,'multiline':False]['text':' end of input script reached','line_number':3437,'multiline':False]['text':' Allow mapping for just typed characters. When we get here c','line_number':3439,'multiline':False]['text':' is the number of extra bytes and typebuf.tb_len is 1.','line_number':3440,'multiline':False]['text':' buffer full, don't map','line_number':3445,'multiline':False]['text':' No typeahead left and inside ":normal".  Must return','line_number':3456,'multiline':False]['text':' something to avoid getting stuck.  When an incomplete','line_number':3457,'multiline':False]['text':' mapping is present, behave like it timed out.','line_number':3458,'multiline':False]['text':' When 'insertmode' is set, ESC just beeps in Insert','line_number':3465,'multiline':False]['text':' mode.  Use CTRL-L to make edit() return.','line_number':3466,'multiline':False]['text':' For the command line only CTRL-C always breaks it.','line_number':3467,'multiline':False]['text':' For the cmdline window: Alternate between ESC and','line_number':3468,'multiline':False]['text':' CTRL-C: ESC for most situations and CTRL-C to close the','line_number':3469,'multiline':False]['text':' cmdline window.','line_number':3470,'multiline':False]['text':' set a flag to indicate this wasn't a normal char','line_number':3483,'multiline':False]['text':' return from main_loop()','line_number':3487,'multiline':False]['text':' no chars to block abbreviation for','line_number':3491,'multiline':False]['text':'
 * get a character: 3. from the user - update display
 ','line_number':3497,'multiline':True]['text':' In insert mode a screen update is skipped when characters','line_number':3500,'multiline':False]['text':' are still available.  But when those available characters','line_number':3501,'multiline':False]['text':' are part of a mapping, and we are going to do a blocking','line_number':3502,'multiline':False]['text':' wait here.  Need to update the screen to display the','line_number':3503,'multiline':False]['text':' changed text so far. Also for when 'lazyredraw' is set and','line_number':3504,'multiline':False]['text':' redrawing was postponed because there was something in the','line_number':3505,'multiline':False]['text':' input buffer (e.g., termresponse).','line_number':3506,'multiline':False]['text':' put cursor back where it belongs','line_number':3512,'multiline':False]['text':'
		 * If we have a partial match (and are going to wait for more
		 * input from the user), show the partially matched characters
		 * to the user with showcmd.
		 ','line_number':3515,'multiline':True]['text':' this looks nice when typing a dead character map','line_number':3528,'multiline':False]['text':' put cursor back where it belongs','line_number':3535,'multiline':False]['text':' need to use the col and row from above here','line_number':3538,'multiline':False]['text':' This looks nice when typing a dead character map.','line_number':3553,'multiline':False]['text':' There is no actual command line for get_number().','line_number':3554,'multiline':False]['text':'
 * get a character: 3. from the user - get it
 ','line_number':3569,'multiline':True]['text':' timedout may have been set if a mapping with empty RHS','line_number':3573,'multiline':False]['text':' fully matched while longer mappings timed out.','line_number':3574,'multiline':False]['text':' blocking wait','line_number':3582,'multiline':False]['text':' put cursor back where it belongs','line_number':3607,'multiline':False]['text':' end of input script reached','line_number':3611,'multiline':False]['text':' no character available','line_number':3612,'multiline':False]['text':' timed out','line_number':3616,'multiline':False]['text':' allow mapping for just typed characters','line_number':3623,'multiline':False]['text':' Get IM status right after getting keys, not after the','line_number':3629,'multiline':False]['text':' timeout for a mapping (focus may be lost by then).','line_number':3630,'multiline':False]['text':' for (;;)','line_number':3634,'multiline':False]['text':' if (!character from stuffbuf)','line_number':3635,'multiline':False]['text':' if advance is FALSE don't loop on NULs','line_number':3637,'multiline':False]['text':'
     * The "INSERT" message is taken care of here:
     *	 if we return an ESC to exit insert mode, the message is deleted
     *	 if we don't return an ESC but deleted the message before, redisplay it
     ','line_number':3640,'multiline':True]['text':' delete mode later','line_number':3650,'multiline':False]['text':' show mode later','line_number':3657,'multiline':False]['text':' may unshow different cursor shape','line_number':3663,'multiline':False]['text':' When recording there will be no timeout.  Add a <Nop> after the ESC','line_number':3669,'multiline':False]['text':' to avoid that it forms a key code with following characters.','line_number':3670,'multiline':False]['text':'
 * inchar() - get one character from
 *	1. a scriptfile
 *	2. the keyboard
 *
 *  As many characters as we can get (up to 'maxlen') are put in "buf" and
 *  NUL terminated (buffer length must be 'maxlen' + 1).
 *  Minimum for "maxlen" is 3!!!!
 *
 *  "tb_change_cnt" is the value of typebuf.tb_change_cnt if "buf" points into
 *  it.  When typebuf.tb_change_cnt changes (e.g., when a message is received
 *  from a remote client) "buf" can no longer be used.  "tb_change_cnt" is 0
 *  otherwise.
 *
 *  If we got an interrupt all input is read until none is available.
 *
 *  If wait_time == 0  there is no waiting for the char.
 *  If wait_time == n  we wait for n msec for a character to arrive.
 *  If wait_time == -1 we wait forever for a character to arrive.
 *
 *  Return the number of obtained characters.
 *  Return -1 when end of input script reached.
 ','line_number':3679,'multiline':True]['text':' milliseconds','line_number':3706,'multiline':False]['text':' init for GCC','line_number':3708,'multiline':False]['text':' return ESC with gotint','line_number':3709,'multiline':False]['text':' flush output before waiting','line_number':3713,'multiline':False]['text':'
     * Don't reset these when at the hit-return prompt, otherwise a endless
     * recursive loop may result (write error in swapfile, hit-return, timeout
     * on char wait, flush swapfile, write error....).
     ','line_number':3723,'multiline':True]['text':' display out of memory message (again)','line_number':3730,'multiline':False]['text':' display swap file write error again','line_number':3731,'multiline':False]['text':' restart undo now','line_number':3733,'multiline':False]['text':'
     * Get a character from a script file if there is one.
     * If interrupted: Stop reading script files, close them all.
     ','line_number':3735,'multiline':True]['text':' Reached EOF.','line_number':3752,'multiline':False]['text':' Careful: closescript() frees typebuf.tb_buf[] and buf[] may','line_number':3753,'multiline':False]['text':' point inside typebuf.tb_buf[].  Don't use buf[] after this!','line_number':3754,'multiline':False]['text':'
	     * When reading script file is interrupted, return an ESC to get
	     * back to normal mode.
	     * Otherwise return -1, because typebuf.tb_buf[] has changed.
	     ','line_number':3756,'multiline':True]['text':' did not get a character from script','line_number':3773,'multiline':False]['text':'
	 * If we got an interrupt, skip all previously typed characters and
	 * return TRUE if quit reading script file.
	 * Stop reading typeahead when a single CTRL-C was read,
	 * fill_input_buf() returns this when not able to read from stdin.
	 * Don't use buf[] here, closescript() may have freed typebuf.tb_buf[]
	 * and buf may be pointing inside typebuf.tb_buf[].
	 ','line_number':3775,'multiline':True]['text':'
	 * Always flush the output characters when getting input characters
	 * from the user and not just peeking.
	 ','line_number':3797,'multiline':True]['text':'
	 * Fill up to a third of the buffer, because each character may be
	 * tripled below.
	 ','line_number':3804,'multiline':True]['text':' If the typebuf was changed further down, it is like nothing was added by','line_number':3811,'multiline':False]['text':' this call.','line_number':3812,'multiline':False]['text':' Note the change in the typeahead buffer, this matters for when','line_number':3816,'multiline':False]['text':' vgetorpeek() is called recursively, e.g. using getchar(1) in a timer','line_number':3817,'multiline':False]['text':' function.','line_number':3818,'multiline':False]['text':'
 * Fix typed characters for use by vgetc() and check_termcode().
 * "buf[]" must have room to triple the number of bytes!
 * Returns the new length.
 ','line_number':3825,'multiline':True]['text':'
     * Two characters are special: NUL and K_SPECIAL.
     * When compiled With the GUI CSI is also special.
     * Replace	     NUL by K_SPECIAL KS_ZERO	 KE_FILLER
     * Replace K_SPECIAL by K_SPECIAL KS_SPECIAL KE_FILLER
     * Replace       CSI by K_SPECIAL KS_EXTRA   KE_CSI
     ','line_number':3836,'multiline':True]['text':' When the GUI is used any character can come after a CSI, don't','line_number':3846,'multiline':False]['text':' escape it.','line_number':3847,'multiline':False]['text':' When not on MS-Windows and the GUI is not used CSI needs to be','line_number':3854,'multiline':False]['text':' escaped.','line_number':3855,'multiline':False]['text':' timeout may generate K_CURSORHOLD','line_number':3868,'multiline':False]['text':' Win32 console passes modifiers','line_number':3871,'multiline':False]['text':' add trailing NUL','line_number':3888,'multiline':False]['text':'
 * Return TRUE when bytes are in the input buffer or in the typeahead buffer.
 * Normally the input buffer would be sufficient, but the server_to_input_buf()
 * or feedkeys() may insert characters in the typeahead buffer while we are
 * waiting for input to arrive.
 ','line_number':3893,'multiline':True]['text':'
 * Function passed to do_cmdline() to get the command after a <Cmd> key from
 * typeahead.
 ','line_number':3910,'multiline':True]['text':' no mapping for these characters','line_number':3929,'multiline':False]['text':' incomplete <Cmd> is an error, because there is not much the user','line_number':3943,'multiline':False]['text':' could do in this state.','line_number':3944,'multiline':False]['text':' Get one character at a time.','line_number':3950,'multiline':False]['text':' Get two extra bytes for special keys','line_number':3953,'multiline':False]['text':' K_ESC is used to avoid ambiguity with the single Esc character','line_number':3965,'multiline':False]['text':' that might be the start of an escape sequence.  Convert it back','line_number':3966,'multiline':False]['text':' to a single Esc here.','line_number':3967,'multiline':False]['text':' end the line','line_number':3975,'multiline':False]['text':' give a nicer error message for this special case','line_number':3980,'multiline':False]['text':'
 * If there was a mapping we get its SID.  Otherwise, use "last_used_sid", it
 * is set when redo'ing.
 * Put this SID in the redo buffer, so that "." will use the same script
 * context.
 ','line_number':4018,'multiline':True]['text':' <K_SID>{nr};','line_number':4038,'multiline':False]