['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * NFA regular expression implementation.
 *
 * This file is included in "regexp.c".
 ','line_number':1,'multiline':True]['text':'
 * Logging of NFA engine.
 *
 * The NFA engine can write four log files:
 * - Error log: Contains NFA engine's fatal errors.
 * - Dump log: Contains compiled NFA state machine's information.
 * - Run log: Contains information of matching procedure.
 * - Debug log: Contains detailed information of matching procedure. Can be
 *   disabled by undefining NFA_REGEXP_DEBUG_LOG.
 * The first one can also be used without debug mode.
 * The last three are enabled when compiled as debug mode and individually
 * disabled by commenting them out.
 * The log files can get quite big!
 * To disable all of this when compiling Vim for debugging, undefine DEBUG in
 * regexp.c
 ','line_number':8,'multiline':True]['text':' Added to NFA_ANY - NFA_NUPPER_IC to include a NL.','line_number':32,'multiline':False]['text':' matches 0-length','line_number':39,'multiline':False]['text':' [abc] start','line_number':41,'multiline':False]['text':' [abc] end','line_number':42,'multiline':False]['text':' [^abc] start','line_number':43,'multiline':False]['text':' [^abc] end (postfix only)','line_number':44,'multiline':False]['text':' range of the two previous items','line_number':45,'multiline':False]['text':' (postfix only)','line_number':46,'multiline':False]['text':' low end of a range','line_number':47,'multiline':False]['text':' high end of a range','line_number':48,'multiline':False]['text':' concatenate two previous items (postfix','line_number':50,'multiline':False]['text':' only)','line_number':51,'multiline':False]['text':' \| (postfix only)','line_number':52,'multiline':False]['text':' greedy * (postfix only)','line_number':53,'multiline':False]['text':' non-greedy * (postfix only)','line_number':54,'multiline':False]['text':' greedy \? (postfix only)','line_number':55,'multiline':False]['text':' non-greedy \? (postfix only)','line_number':56,'multiline':False]['text':' ^    Begin line','line_number':58,'multiline':False]['text':' $    End line','line_number':59,'multiline':False]['text':' \<   Begin word','line_number':60,'multiline':False]['text':' \>   End word','line_number':61,'multiline':False]['text':' \%^  Begin file','line_number':62,'multiline':False]['text':' \%$  End file','line_number':63,'multiline':False]['text':' Used for \zs','line_number':65,'multiline':False]['text':' Used for \ze','line_number':66,'multiline':False]['text':' Start of subexpression marked with \%(','line_number':67,'multiline':False]['text':' End of subexpr. marked with \%( ... \)','line_number':68,'multiline':False]['text':' Next nodes in NFA are part of the','line_number':81,'multiline':False]['text':' composing multibyte char','line_number':82,'multiline':False]['text':' End of a composing char in the NFA','line_number':83,'multiline':False]['text':' \%C: Any composing characters.','line_number':84,'multiline':False]['text':' \%[abc]','line_number':85,'multiline':False]['text':' The following are used only in the postfix form, not in the NFA','line_number':87,'multiline':False]['text':' Used for \@=','line_number':88,'multiline':False]['text':' Used for \@!','line_number':89,'multiline':False]['text':' Used for \@<=','line_number':90,'multiline':False]['text':' Used for \@<!','line_number':91,'multiline':False]['text':' Used for \@>','line_number':92,'multiline':False]['text':' \1','line_number':94,'multiline':False]['text':' \2','line_number':95,'multiline':False]['text':' \3','line_number':96,'multiline':False]['text':' \4','line_number':97,'multiline':False]['text':' \5','line_number':98,'multiline':False]['text':' \6','line_number':99,'multiline':False]['text':' \7','line_number':100,'multiline':False]['text':' \8','line_number':101,'multiline':False]['text':' \9','line_number':102,'multiline':False]['text':' \z1','line_number':104,'multiline':False]['text':' \z2','line_number':105,'multiline':False]['text':' \z3','line_number':106,'multiline':False]['text':' \z4','line_number':107,'multiline':False]['text':' \z5','line_number':108,'multiline':False]['text':' \z6','line_number':109,'multiline':False]['text':' \z7','line_number':110,'multiline':False]['text':' \z8','line_number':111,'multiline':False]['text':' \z9','line_number':112,'multiline':False]['text':' Skip characters','line_number':114,'multiline':False]['text':' NFA_FIRST_NL','line_number':162,'multiline':False]['text':'	Match any one character.','line_number':163,'multiline':False]['text':'	Match identifier char','line_number':164,'multiline':False]['text':'	Match identifier char but no digit','line_number':165,'multiline':False]['text':'	Match keyword char','line_number':166,'multiline':False]['text':'	Match word char but no digit','line_number':167,'multiline':False]['text':'	Match file name char','line_number':168,'multiline':False]['text':'	Match file name char but no digit','line_number':169,'multiline':False]['text':'	Match printable char','line_number':170,'multiline':False]['text':'	Match printable char but no digit','line_number':171,'multiline':False]['text':'	Match whitespace char','line_number':172,'multiline':False]['text':'	Match non-whitespace char','line_number':173,'multiline':False]['text':'	Match digit char','line_number':174,'multiline':False]['text':'	Match non-digit char','line_number':175,'multiline':False]['text':'	Match hex char','line_number':176,'multiline':False]['text':'	Match non-hex char','line_number':177,'multiline':False]['text':'	Match octal char','line_number':178,'multiline':False]['text':'	Match non-octal char','line_number':179,'multiline':False]['text':'	Match word char','line_number':180,'multiline':False]['text':'	Match non-word char','line_number':181,'multiline':False]['text':'	Match head char','line_number':182,'multiline':False]['text':'	Match non-head char','line_number':183,'multiline':False]['text':'	Match alpha char','line_number':184,'multiline':False]['text':'	Match non-alpha char','line_number':185,'multiline':False]['text':'	Match lowercase char','line_number':186,'multiline':False]['text':'	Match non-lowercase char','line_number':187,'multiline':False]['text':'	Match uppercase char','line_number':188,'multiline':False]['text':'	Match non-uppercase char','line_number':189,'multiline':False]['text':'	Match [a-z]','line_number':190,'multiline':False]['text':'	Match [^a-z]','line_number':191,'multiline':False]['text':'	Match [A-Z]','line_number':192,'multiline':False]['text':'	Match [^A-Z]','line_number':193,'multiline':False]['text':'	Match cursor pos','line_number':198,'multiline':False]['text':'	Match line number','line_number':199,'multiline':False]['text':'	Match > line number','line_number':200,'multiline':False]['text':'	Match < line number','line_number':201,'multiline':False]['text':'	Match cursor column','line_number':202,'multiline':False]['text':'	Match > cursor column','line_number':203,'multiline':False]['text':'	Match < cursor column','line_number':204,'multiline':False]['text':'	Match cursor virtual column','line_number':205,'multiline':False]['text':'	Match > cursor virtual column','line_number':206,'multiline':False]['text':'	Match < cursor virtual column','line_number':207,'multiline':False]['text':'	Match mark','line_number':208,'multiline':False]['text':'	Match > mark','line_number':209,'multiline':False]['text':'	Match < mark','line_number':210,'multiline':False]['text':'	Match Visual area','line_number':211,'multiline':False]['text':' Character classes [:alnum:] etc','line_number':213,'multiline':False]['text':' Keep in sync with classchars.','line_number':235,'multiline':False]['text':' Variables only used in nfa_regcomp() and descendants.','line_number':246,'multiline':False]['text':' re_flags passed to nfa_regcomp()','line_number':247,'multiline':False]['text':' holds the postfix form of r.e.','line_number':248,'multiline':False]['text':' Set when the pattern should use the NFA engine.','line_number':252,'multiline':False]['text':' E.g. [[:upper:]] only allows 8bit characters for BT engine,','line_number':253,'multiline':False]['text':' while NFA engine handles multibyte characters correctly.','line_number':254,'multiline':False]['text':' Number of states in the NFA.','line_number':257,'multiline':False]['text':' Index in the state vector, used in alloc_state()','line_number':258,'multiline':False]['text':' If not NULL match must end at this position','line_number':260,'multiline':False]['text':' 0 for first call to nfa_regmatch(), 1 for recursive call.','line_number':263,'multiline':False]['text':' helper functions used when doing re2post() ... regatom() parsing','line_number':274,'multiline':False]['text':'
 * Initialize internal variables before NFA compilation.
 * Return OK on success, FAIL otherwise.
 ','line_number':281,'multiline':True]['text':' see vim_regcomp()','line_number':288,'multiline':False]['text':' A reasonable estimation for maximum size','line_number':295,'multiline':False]['text':' Some items blow up in size, such as [A-z].  Add more space for that.','line_number':298,'multiline':False]['text':' When it is still not enough realloc_post_list() will be used.','line_number':299,'multiline':False]['text':' Size for postfix representation of expr.','line_number':302,'multiline':False]['text':' shared with BT engine','line_number':314,'multiline':False]['text':'
 * Figure out if the NFA state list starts with an anchor, must match at start
 * of the line.
 ','line_number':320,'multiline':True]['text':' yes!','line_number':338,'multiline':False]['text':' noooo','line_number':376,'multiline':False]['text':'
 * Figure out if the NFA state list starts with a character which must match
 * at start of the match.
 ','line_number':382,'multiline':True]['text':' all kinds of zero-width matches','line_number':398,'multiline':False]['text':' yes!','line_number':452,'multiline':False]['text':' yes!','line_number':458,'multiline':False]['text':'
 * Figure out if the NFA state list contains just literal text and nothing
 * else.  If so return a string in allocated memory with what must match after
 * regstart.  Otherwise return NULL.
 ','line_number':465,'multiline':True]['text':' just in case','line_number':479,'multiline':False]['text':' skip first char, it goes into regstart','line_number':493,'multiline':False]['text':'
 * Allocate more space for post_start.  Called when
 * running above the estimated number of states.
 ','line_number':507,'multiline':True]['text':' For weird patterns the number of states can be very high. Increasing by','line_number':519,'multiline':False]['text':' 50% seems a reasonable compromise between memory use and speed.','line_number':520,'multiline':False]['text':'
 * Search between "start" and "end" and try to recognize a
 * character class in expanded form. For example [0-9].
 * On success, return the id the character class to be emitted.
 * On failure, return 0 (=FAIL)
 * Start points to the first char of the range, while end should point
 * to the closing brace.
 * Keep in mind that 'ignorecase' applies at execution time, thus [a-z] may
 * need to be interpreted as [a-zA-Z].
 ','line_number':534,'multiline':True]['text':' while (p < end)','line_number':639,'multiline':False]['text':'
 * Produce the bytes for equivalence class "c".
 * Currently only handles latin1, latin9 and utf-8.
 * Emits bytes in postfix notation: 'a,b,NFA_OR,c,NFA_OR' is
 * equivalent to 'a OR b OR c'
 *
 * NOTE! When changing this function, also update reg_equi_class()
 ','line_number':685,'multiline':True]['text':' default: character itself','line_number':1265,'multiline':False]['text':'
 * Code to parse regular expression.
 *
 * We try to reuse parsing functions in regexp.c to
 * minimize surprise and keep the syntax consistent.
 ','line_number':1274,'multiline':True]['text':'
 * Parse the lowest level.
 *
 * An atom can be one of a long list of items.  Many atoms match one character
 * in the text.  It is often an ordinary character or a character class.
 * Braces can be used to make a pattern into an atom.  The "\z(\)" construct
 * is only for syntax highlighting.
 *
 * atom    ::=     ordinary-atom
 *     or  \( pattern \)
 *     or  \%( pattern \)
 *     or  \z( pattern \)
 ','line_number':1281,'multiline':True]['text':' "\_^" is start-of-line','line_number':1342,'multiline':False]['text':' "\_$" is end-of-line','line_number':1347,'multiline':False]['text':' "\_[" is collection plus newline','line_number':1358,'multiline':False]['text':' "\_x" is character class plus newline','line_number':1362,'multiline':False]['text':' FALLTHROUGH','line_number':1363,'multiline':False]['text':'
	 * Character classes.
	 ','line_number':1365,'multiline':True]['text':' When '.' is followed by a composing char ignore the dot, so that','line_number':1408,'multiline':False]['text':' the composing char is matched here.','line_number':1409,'multiline':False]['text':' In a string "\n" matches a newline character.','line_number':1427,'multiline':False]['text':' In buffer text "\n" matches the end of a line.','line_number':1431,'multiline':False]['text':' cascaded error','line_number':1439,'multiline':False]['text':' these should follow an atom, not form an atom','line_number':1454,'multiline':False]['text':' Previous substitute pattern.','line_number':1462,'multiline':False]['text':' Generated as "\%(pattern\)".','line_number':1463,'multiline':False]['text':' \z1...\z9','line_number':1523,'multiline':False]['text':' No need to set rex.nfa_has_backref, the sub-matches don't','line_number':1527,'multiline':False]['text':' change when \z1 .. \z9 matches or not.','line_number':1528,'multiline':False]['text':' \z(','line_number':1532,'multiline':False]['text':' cascaded error','line_number':1536,'multiline':False]['text':' () without a back reference','line_number':1550,'multiline':False]['text':' %d123 decimal','line_number':1557,'multiline':False]['text':' %o123 octal','line_number':1558,'multiline':False]['text':' %xab hex 2','line_number':1559,'multiline':False]['text':' %uabcd hex 4','line_number':1560,'multiline':False]['text':' %U1234abcd hex 8','line_number':1561,'multiline':False]['text':' A NUL is stored in the text as NL','line_number':1578,'multiline':False]['text':' TODO: what if a composing character follows?','line_number':1579,'multiline':False]['text':' Catch \%^ and \%$ regardless of where they appear in the','line_number':1584,'multiline':False]['text':' pattern -- regardless of whether or not it makes sense.','line_number':1585,'multiline':False]['text':' misplaced \%#=1','line_number':1598,'multiline':False]['text':' \%[abc]','line_number':1618,'multiline':False]['text':' recursive call!','line_number':1624,'multiline':False]['text':' get the ]','line_number':1628,'multiline':False]['text':' Emit as "\%(\%[abc]\)" to be able to handle','line_number':1635,'multiline':False]['text':' "\%[abc]*" which would cause the empty string to be','line_number':1636,'multiline':False]['text':' matched an unlimited number of times. NFA_NOPEN is','line_number':1637,'multiline':False]['text':' added only once at a position, while NFA_SPLIT is','line_number':1638,'multiline':False]['text':' added multiple times.  This is more efficient than','line_number':1639,'multiline':False]['text':' not allowing NFA_SPLIT multiple times, it is used','line_number':1640,'multiline':False]['text':' a lot.','line_number':1641,'multiline':False]['text':' overflow.','line_number':1674,'multiline':False]['text':' \%{n}l  \%{n}<l  \%{n}>l','line_number':1696,'multiline':False]['text':' \%{n}c  \%{n}<c  \%{n}>c','line_number':1709,'multiline':False]['text':' \%{n}v  \%{n}<v  \%{n}>v','line_number':1723,'multiline':False]['text':' \%'m  \%<'m  \%>'m','line_number':1738,'multiline':False]['text':'
	     * [abc]  uses NFA_START_COLL - NFA_END_COLL
	     * [^abc] uses NFA_START_NEG_COLL - NFA_END_NEG_COLL
	     * Each character is produced as a regular state, using
	     * NFA_CONCAT to bind them together.
	     * Besides normal characters there can be:
	     * - character classes  NFA_CLASS_*
	     * - ranges, two characters followed by NFA_RANGE.
	     ','line_number':1753,'multiline':True]['text':'
		 * Try to reverse engineer character classes. For example,
		 * recognize that [0-9] stands for \d and [A-Za-z_] for \h,
		 * and perform the necessary substitutions in the NFA.
		 ','line_number':1767,'multiline':True]['text':'
		 * Failed to recognize a character class. Use the simple
		 * version that turns [abc] into 'a' OR 'b' OR 'c'
		 ','line_number':1788,'multiline':True]['text':' negated range','line_number':1794,'multiline':False]['text':' Emit the OR branches for each character in the []','line_number':1809,'multiline':False]['text':' Check for [: :], [= =], [. .]','line_number':1819,'multiline':False]['text':' Character class like [:alpha:]','line_number':1829,'multiline':False]['text':' Try equivalence class [=a=] and the like','line_number':1897,'multiline':False]['text':' should never happen','line_number':1903,'multiline':False]['text':' Try collating class like [. .]','line_number':1908,'multiline':False]['text':' allow [.a.]-x as a range','line_number':1911,'multiline':False]['text':' Will emit the proper atom at the end of the','line_number':1912,'multiline':False]['text':' while loop.','line_number':1913,'multiline':False]['text':' Try a range like 'a-x' or '\t-z'. Also allows '-' as a','line_number':1916,'multiline':False]['text':' start character.','line_number':1917,'multiline':False]['text':' reading the end of the range','line_number':1923,'multiline':False]['text':' Now handle simple and escaped characters.','line_number':1926,'multiline':False]['text':' Only "\]", "\^", "\]" and "\\" are special in Vi.  Vim','line_number':1927,'multiline':False]['text':' accepts "\t", "\e", etc., but only when the 'l' flag in','line_number':1928,'multiline':False]['text':' 'cpoptions' is not included.','line_number':1929,'multiline':False]['text':' Posix doesn't recognize backslash at all.','line_number':1930,'multiline':False]['text':' TODO(RE) This needs more testing','line_number':1953,'multiline':False]['text':' \r,\t,\e,\b','line_number':1960,'multiline':False]['text':' Normal printable char','line_number':1965,'multiline':False]['text':' Previous char was '-', so this char is end of range.','line_number':1969,'multiline':False]['text':' Emit a range instead of the sequence of','line_number':1980,'multiline':False]['text':' individual characters.','line_number':1981,'multiline':False]['text':' \x00 is translated to \x0a, start at \x01.','line_number':1983,'multiline':False]['text':' remove NFA_CONCAT','line_number':1986,'multiline':False]['text':' Emit the characters in the range.','line_number':1994,'multiline':False]['text':' "startc" was already emitted, so skip it.','line_number':1995,'multiline':False]['text':'','line_number':1996,'multiline':False]['text':' Emit the range. "startc" was already emitted, so','line_number':2005,'multiline':False]['text':' skip it.','line_number':2006,'multiline':False]['text':' This char (startc) is not part of a range. Just','line_number':2018,'multiline':False]['text':' emit it.','line_number':2019,'multiline':False]['text':' Normally, simply emit startc. But if we get char','line_number':2020,'multiline':False]['text':' code=0 from a collating char, then replace it with','line_number':2021,'multiline':False]['text':' 0x0a.','line_number':2022,'multiline':False]['text':' This is needed to completely mimic the behaviour of','line_number':2023,'multiline':False]['text':' the backtracking engine.','line_number':2024,'multiline':False]['text':' Line break can't be matched as part of the','line_number':2027,'multiline':False]['text':' collection, add an OR below. But not for negated','line_number':2028,'multiline':False]['text':' range.','line_number':2029,'multiline':False]['text':' while (p < endp)','line_number':2044,'multiline':False]['text':' if last, '-' is just a char','line_number':2047,'multiline':False]['text':' skip the trailing ]','line_number':2053,'multiline':False]['text':' Mark end of the collection.','line_number':2057,'multiline':False]['text':' \_[] also matches \n but it's not negated','line_number':2063,'multiline':False]['text':' if exists closing ]','line_number':2071,'multiline':False]['text':' FALLTHROUGH','line_number':2075,'multiline':False]['text':' plen is length of current char with composing chars','line_number':2082,'multiline':False]['text':' A base character plus composing characters, or just one','line_number':2089,'multiline':False]['text':' or more composing characters.','line_number':2090,'multiline':False]['text':' This requires creating a separate atom as if enclosing','line_number':2091,'multiline':False]['text':' the characters in (), where NFA_COMPOSING is the ( and','line_number':2092,'multiline':False]['text':' NFA_END_COMPOSING is the ). Note that right now we are','line_number':2093,'multiline':False]['text':' building the postfix form, not the NFA itself;','line_number':2094,'multiline':False]['text':' a composing char could be: a, b, c, NFA_COMPOSING','line_number':2095,'multiline':False]['text':' where 'b' and 'c' are chars with codes > 256.','line_number':2096,'multiline':False]['text':'
 * Parse something followed by possible [*+=].
 *
 * A piece is an atom, possibly followed by a multi, an indication of how many
 * times the atom can be matched.  Example: "a*" matches any sequence of "a"
 * characters: "", "a", "aa", etc.
 *
 * piece   ::=	    atom
 *	or  atom  multi
 ','line_number':2121,'multiline':True]['text':' Braces are prefixed with '-' ?','line_number':2138,'multiline':False]['text':' Save the current parse state, so that we can use it if <atom>{m,n} is','line_number':2146,'multiline':False]['text':' next.','line_number':2147,'multiline':False]['text':' store current pos in the postfix form, for \{m,n} involving 0s','line_number':2150,'multiline':False]['text':' cascaded error','line_number':2155,'multiline':False]['text':'
	     * Trick: Normally, (a*)\+ would match the whole input "aaa".  The
	     * first and only submatch would be "aaa". But the backtracking
	     * engine interprets the plus as "try matching one more time", and
	     * a* matches a second time at the end of the input, the empty
	     * string.
	     * The submatch will be the empty string.
	     *
	     * In order to be consistent with the old engine, we replace
	     * <atom>+ with <atom><atom>*
	     ','line_number':2169,'multiline':True]['text':' skip the \+','line_number':2186,'multiline':False]['text':' \@=','line_number':2196,'multiline':False]['text':' \@!','line_number':2200,'multiline':False]['text':' \@<=','line_number':2206,'multiline':False]['text':' \@<!','line_number':2209,'multiline':False]['text':' \@>','line_number':2213,'multiline':False]['text':' a{2,5} will expand to 'aaa?a?a?'','line_number':2234,'multiline':False]['text':' a{-1,3} will expand to 'aa??a??', where ?? is the nongreedy','line_number':2235,'multiline':False]['text':' version of '?'','line_number':2236,'multiline':False]['text':' \v(ab){2,3} will expand to '(ab)(ab)(ab)?', where all the','line_number':2237,'multiline':False]['text':' parenthesis have the same id','line_number':2238,'multiline':False]['text':'  <atom>{0,inf}, <atom>{0,} and <atom>{}  are equivalent to','line_number':2250,'multiline':False]['text':'  <atom>*','line_number':2251,'multiline':False]['text':' { { (match the braces)','line_number':2254,'multiline':False]['text':' \{}, \{0,}','line_number':2255,'multiline':False]['text':' { { (match the braces)','line_number':2257,'multiline':False]['text':' \{-}, \{-0,}','line_number':2258,'multiline':False]['text':' Special case: x{0} or x{-0}','line_number':2263,'multiline':False]['text':' Ignore result of previous call to nfa_regatom()','line_number':2266,'multiline':False]['text':' NFA_EMPTY is 0-length and works everywhere','line_number':2268,'multiline':False]['text':' The engine is very inefficient (uses too many states) when the','line_number':2273,'multiline':False]['text':' maximum is much larger than the minimum and when the maximum is','line_number':2274,'multiline':False]['text':' large.  However, when maxval is MAX_LIMIT, it is okay, as this','line_number':2275,'multiline':False]['text':' will emit NFA_STAR.','line_number':2276,'multiline':False]['text':' Bail out if we can use the other engine, but only, when the','line_number':2277,'multiline':False]['text':' pattern does not need the NFA engine like (e.g. [[:upper:]]\{2,\}','line_number':2278,'multiline':False]['text':' does not work with characters > 8 bit with the BT engine)','line_number':2279,'multiline':False]['text':' Ignore previous call to nfa_regatom()','line_number':2286,'multiline':False]['text':' Save parse state after the repeated atom and the \{}','line_number':2288,'multiline':False]['text':' Goto beginning of the repeated atom','line_number':2294,'multiline':False]['text':' after "minval" times, atoms are optional','line_number':2299,'multiline':False]['text':' Go to just after the repeated atom and the \{}','line_number':2318,'multiline':False]['text':' end switch','line_number':2327,'multiline':False]['text':' Can't have a multi follow a multi.','line_number':2330,'multiline':False]['text':'
 * Parse one or more pieces, concatenated.  It matches a match for the
 * first piece, followed by a match for the second piece, etc.  Example:
 * "f[0-9]b", first matches "f", then a digit and then "b".
 *
 * concat  ::=	    piece
 *	or  piece piece
 *	or  piece piece piece
 *	etc.
 ','line_number':2336,'multiline':True]['text':'
 * Parse a branch, one or more concats, separated by "\&".  It matches the
 * last concat, but only if all the preceding concats also match at the same
 * position.  Examples:
 *      "foobeep\&..." matches "foo" in "foobeep".
 *      ".*Peter\&.*Bob" matches in a line containing both "Peter" and "Bob"
 *
 * branch ::=	    concat
 *		or  concat \& concat
 *		or  concat \& concat \& concat
 *		etc.
 ','line_number':2410,'multiline':True]['text':' First branch, possibly the only one','line_number':2429,'multiline':False]['text':' Try next concats','line_number':2433,'multiline':False]['text':' if concat is empty do emit a node','line_number':2437,'multiline':False]['text':' if concat is empty do emit a node','line_number':2445,'multiline':False]['text':' if a branch is empty, emit one node for it','line_number':2451,'multiline':False]['text':'
 *  Parse a pattern, one or more branches, separated by "\|".  It matches
 *  anything that matches one of the branches.  Example: "foo\|beep" matches
 *  "foo" and matches "beep".  If more than one branch matches, the first one
 *  is used.
 *
 *  pattern ::=	    branch
 *	or  branch \| branch
 *	or  branch \| branch \| branch
 *	etc.
 ','line_number':2458,'multiline':True]['text':' REG_NOPAREN, REG_PAREN, REG_NPAREN or REG_ZPAREN','line_number':2471,'multiline':False]['text':' Too many `('','line_number':2477,'multiline':False]['text':' Make a ZOPEN node.','line_number':2484,'multiline':False]['text':' cascaded error','line_number':2492,'multiline':False]['text':' cascaded error','line_number':2498,'multiline':False]['text':' Check for proper termination.','line_number':2502,'multiline':False]['text':'
     * Here we set the flag allowing back references to this set of
     * parentheses.
     ','line_number':2518,'multiline':True]['text':' have seen the close paren','line_number':2524,'multiline':False]['text':'
 * Print the postfix notation of the current regexp.
 ','line_number':2775,'multiline':True]['text':'
 * Print the NFA starting with a root node "state".
 ','line_number':2806,'multiline':True]['text':' Output indent','line_number':2830,'multiline':False]['text':' grow indent for state->out','line_number':2856,'multiline':False]['text':' replace last part of indent for state->out1','line_number':2866,'multiline':False]['text':' shrink indent','line_number':2873,'multiline':False]['text':'
 * Print the NFA state machine.
 ','line_number':2878,'multiline':True]['text':' ENABLE_LOG','line_number':2901,'multiline':False]['text':' DEBUG','line_number':2902,'multiline':False]['text':'
 * Parse r.e. @expr and convert it into postfix form.
 * Return the postfix string on success, NULL otherwise.
 ','line_number':2904,'multiline':True]['text':' NB. Some of the code below is inspired by Russ's.','line_number':2917,'multiline':False]['text':'
 * Represents an NFA state plus zero or one or two arrows exiting.
 * if c == MATCH, no arrows out; matching state.
 * If c == SPLIT, unlabeled arrows to out and out1 (if != NULL).
 * If c < 256, labeled arrow with character c to out.
 ','line_number':2919,'multiline':True]['text':' points to nfa_prog->state','line_number':2926,'multiline':False]['text':'
 * Allocate and initialize nfa_state_T.
 ','line_number':2928,'multiline':True]['text':'
 * A partially built NFA without the matching state filled in.
 * Frag_T.start points at the start state.
 * Frag_T.out is a list of places that need to be set to the
 * next state for this fragment.
 ','line_number':2953,'multiline':True]['text':' Since the out pointers in the list are always','line_number':2960,'multiline':False]['text':' uninitialized, we use the pointers themselves','line_number':2961,'multiline':False]['text':' as storage for the Ptrlists.','line_number':2962,'multiline':False]['text':'
 * Initialize a Frag_T struct and return it.
 ','line_number':2977,'multiline':True]['text':'
 * Create singleton list containing just outp.
 ','line_number':2990,'multiline':True]['text':'
 * Patch the list of states at out to point to start.
 ','line_number':3004,'multiline':True]['text':'
 * Join the two lists l1 and l2, returning the combination.
 ','line_number':3020,'multiline':True]['text':'
 * Stack used for transforming postfix form into NFA.
 ','line_number':3035,'multiline':True]['text':'
 * Push an item onto the stack.
 ','line_number':3082,'multiline':True]['text':'
 * Pop an item from the stack.
 ','line_number':3096,'multiline':True]['text':'
 * Estimate the maximum byte length of anything matching "state".
 * When unknown or unlimited return -1.
 ','line_number':3111,'multiline':True]['text':' detect looping in a NFA_SPLIT','line_number':3122,'multiline':False]['text':' the end, return what we have','line_number':3132,'multiline':False]['text':' two alternatives, use the maximum','line_number':3136,'multiline':False]['text':' matches some character, including composing chars','line_number':3146,'multiline':False]['text':' skip over the characters','line_number':3155,'multiline':False]['text':' ascii','line_number':3165,'multiline':False]['text':' possibly non-ascii','line_number':3196,'multiline':False]['text':' zero-width, out1 points to the END state','line_number':3207,'multiline':False]['text':' unknown width','line_number':3233,'multiline':False]['text':' zero-width','line_number':3310,'multiline':False]['text':' don't know what this is','line_number':3315,'multiline':False]['text':' normal character','line_number':3317,'multiline':False]['text':' normal way to continue','line_number':3322,'multiline':False]['text':' unrecognized, "cannot happen"','line_number':3326,'multiline':False]['text':'
 * Convert a postfix form into its equivalent NFA.
 * Return the NFA start state on success, NULL otherwise.
 ','line_number':3330,'multiline':True]['text':' Allocate space for the stack. Max states on the stack: "nstate".','line_number':3365,'multiline':False]['text':' Concatenation.','line_number':3378,'multiline':False]['text':' Pay attention: this operator does not exist in the r.e. itself','line_number':3379,'multiline':False]['text':' (it is implicit, really).  It is added when r.e. is translated','line_number':3380,'multiline':False]['text':' to postfix form in re2post().','line_number':3381,'multiline':False]['text':' nstate += 0;','line_number':3384,'multiline':False]['text':' Alternation','line_number':3394,'multiline':False]['text':' Zero or more, prefer more','line_number':3409,'multiline':False]['text':' Zero or more, prefer zero','line_number':3424,'multiline':False]['text':' one or zero atoms=> greedy match','line_number':3439,'multiline':False]['text':' zero or one atoms => non-greedy match','line_number':3453,'multiline':False]['text':' On the stack is the sequence starting with NFA_START_COLL or','line_number':3468,'multiline':False]['text':' NFA_START_NEG_COLL and all possible characters. Patch it to','line_number':3469,'multiline':False]['text':' add the output to the start.','line_number':3470,'multiline':False]['text':' Before this are two characters, the low and high end of a','line_number':3486,'multiline':False]['text':' range.  Turn them into two states with MIN and MAX.','line_number':3487,'multiline':False]['text':' nstate += 0;','line_number':3490,'multiline':False]['text':' 0-length, used in a repetition with max/min count of 0','line_number':3504,'multiline':False]['text':' \%[abc] implemented as:','line_number':3520,'multiline':False]['text':'    NFA_SPLIT','line_number':3521,'multiline':False]['text':'    +-CHAR(a)','line_number':3522,'multiline':False]['text':'    | +-NFA_SPLIT','line_number':3523,'multiline':False]['text':'    |   +-CHAR(b)','line_number':3524,'multiline':False]['text':'    |   | +-NFA_SPLIT','line_number':3525,'multiline':False]['text':'    |   |   +-CHAR(c)','line_number':3526,'multiline':False]['text':'    |   |   | +-next','line_number':3527,'multiline':False]['text':'    |   |   +- next','line_number':3528,'multiline':False]['text':'    |   +- next','line_number':3529,'multiline':False]['text':'    +- next','line_number':3530,'multiline':False]['text':' get number of characters','line_number':3531,'multiline':False]['text':' avoid compiler warning','line_number':3537,'multiline':False]['text':' stores list with out1's','line_number':3538,'multiline':False]['text':' previous NFA_SPLIT to connect to','line_number':3539,'multiline':False]['text':' get character','line_number':3542,'multiline':False]['text':' NFA_PREV_ATOM_LIKE_PATTERN:','line_number':3589,'multiline':False]['text':' get the count','line_number':3596,'multiline':False]['text':' The \@= operator: match the preceding atom with zero width.','line_number':3598,'multiline':False]['text':' The \@! operator: no match for the preceding atom.','line_number':3599,'multiline':False]['text':' The \@<= operator: match for the preceding atom.','line_number':3600,'multiline':False]['text':' The \@<! operator: no match for the preceding atom.','line_number':3601,'multiline':False]['text':' Surrounds the preceding atom with START_INVISIBLE and','line_number':3602,'multiline':False]['text':' END_INVISIBLE, similarly to MOPEN.','line_number':3603,'multiline':False]['text':' NFA_ZEND -> NFA_END_PATTERN -> NFA_SKIP -> what follows.','line_number':3620,'multiline':False]['text':' See if we can guess the maximum width, it avoids a','line_number':3638,'multiline':False]['text':' lot of pointless tries.','line_number':3639,'multiline':False]['text':' store the count','line_number':3641,'multiline':False]['text':' char with composing char','line_number':3647,'multiline':False]['text':' TODO','line_number':3649,'multiline':False]['text':' use the base character only','line_number':3652,'multiline':False]['text':' FALLTHROUGH','line_number':3655,'multiline':False]['text':' \( \) Submatch','line_number':3657,'multiline':False]['text':' \z( \) Submatch','line_number':3668,'multiline':False]['text':' \%( \) "Invisible Submatch"','line_number':3679,'multiline':False]['text':' NFA_MOPEN, NFA_MOPEN1 .. NFA_MOPEN9','line_number':3704,'multiline':False]['text':' Allow "NFA_MOPEN" as a valid postfix representation for','line_number':3709,'multiline':False]['text':' the empty regexp "". In this case, the NFA will be','line_number':3710,'multiline':False]['text':' NFA_MOPEN -> NFA_MCLOSE. Note that this also allows','line_number':3711,'multiline':False]['text':' empty groups of parenthesis, and empty mbyte chars','line_number':3712,'multiline':False]['text':' At least one node was emitted before NFA_MOPEN, so','line_number':3726,'multiline':False]['text':' at least one node will be between NFA_MOPEN and NFA_MCLOSE','line_number':3727,'multiline':False]['text':' `('','line_number':3729,'multiline':False]['text':' `)'','line_number':3733,'multiline':False]['text':' COMPOSING->out1 = END_COMPOSING','line_number':3739,'multiline':False]['text':' lnum, col or mark name','line_number':3793,'multiline':False]['text':' Operands','line_number':3811,'multiline':False]['text':' switch(*p)','line_number':3823,'multiline':False]['text':' for (p = postfix; *p; ++p)','line_number':3825,'multiline':False]['text':' Return value when counting size is ignored anyway','line_number':3830,'multiline':False]['text':' the match state','line_number':3846,'multiline':False]['text':'
 * After building the NFA program, inspect it to add optimization hints.
 ','line_number':3866,'multiline':True]['text':' Do it directly when what follows is possibly the end of the','line_number':3885,'multiline':False]['text':' match.','line_number':3886,'multiline':False]['text':' Postpone when the invisible match is expensive or has a','line_number':3894,'multiline':False]['text':' lower chance of failing.','line_number':3895,'multiline':False]['text':' "before" matches are very expensive when','line_number':3899,'multiline':False]['text':' unbounded, always prefer what follows then,','line_number':3900,'multiline':False]['text':' unless what follows will always match.','line_number':3901,'multiline':False]['text':' Otherwise strongly prefer what follows.','line_number':3902,'multiline':False]['text':' normal invisible, first do the one with the','line_number':3910,'multiline':False]['text':' highest failure chance','line_number':3911,'multiline':False]['text':' switch to the _FIRST state','line_number':3916,'multiline':False]['text':'///////////////////////////////////////////////////////////////','line_number':3922,'multiline':False]['text':' NFA execution code.','line_number':3923,'multiline':False]['text':'///////////////////////////////////////////////////////////////','line_number':3924,'multiline':False]['text':' number of subexpr with useful info','line_number':3928,'multiline':False]['text':' When REG_MULTI is TRUE list.multi is used, otherwise list.line.','line_number':3930,'multiline':False]['text':' list.multi[0].start_col without \zs','line_number':3946,'multiline':False]['text':' \( .. \) matches','line_number':3951,'multiline':False]['text':' \z( .. \) matches','line_number':3953,'multiline':False]['text':' nfa_pim_T stores a Postponed Invisible Match.','line_number':3957,'multiline':False]['text':' NFA_PIM_*, see below','line_number':3961,'multiline':False]['text':' the invisible match start state','line_number':3962,'multiline':False]['text':' submatch info, only party used','line_number':3963,'multiline':False]['text':' where the match must end','line_number':3968,'multiline':False]['text':' Values for done in nfa_pim_T.','line_number':3971,'multiline':False]['text':' pim not used','line_number':3972,'multiline':False]['text':' pim not done yet','line_number':3973,'multiline':False]['text':' pim executed, matches','line_number':3974,'multiline':False]['text':' pim executed, no match','line_number':3975,'multiline':False]['text':' nfa_thread_T contains execution information of a NFA state','line_number':3978,'multiline':False]['text':' if pim.result != NFA_PIM_UNUSED: postponed','line_number':3983,'multiline':False]['text':' invisible match','line_number':3984,'multiline':False]['text':' submatch info, only party used','line_number':3985,'multiline':False]['text':' nfa_list_T contains the alternative NFA execution states.','line_number':3988,'multiline':False]['text':' allocated array of states','line_number':3991,'multiline':False]['text':' nr of states currently in "t"','line_number':3992,'multiline':False]['text':' max nr of states in "t"','line_number':3993,'multiline':False]['text':' ID of the list','line_number':3994,'multiline':False]['text':' TRUE when any state has a PIM','line_number':3995,'multiline':False]['text':' Used during execution: whether a match has been found.','line_number':4054,'multiline':False]['text':'
 * Copy postponed invisible match info from "from" to "to".
 ','line_number':4063,'multiline':True]['text':' Use 0xff to set lnum to -1','line_number':4083,'multiline':False]['text':'
 * Copy the submatches from "from" to "to".
 ','line_number':4092,'multiline':True]['text':' Copy the match start and end positions.','line_number':4102,'multiline':False]['text':'
 * Like copy_sub() but exclude the main match.
 ','line_number':4116,'multiline':True]['text':' Copy the match start and end positions.','line_number':4127,'multiline':False]['text':'
 * Like copy_sub() but only do the end of the main match if \ze is present.
 ','line_number':4138,'multiline':True]['text':'
 * Return TRUE if "sub1" and "sub2" have the same start positions.
 * When using back-references also check the end position.
 ','line_number':4162,'multiline':True]['text':'
 * Check if we are past the time limit, if there is one.
 ','line_number':4247,'multiline':True]['text':'
 * Return TRUE if the same state is already in list "l" with the same
 * positions as "subs".
 ','line_number':4312,'multiline':True]['text':' runtime state list','line_number':4318,'multiline':False]['text':' state to update','line_number':4319,'multiline':False]['text':' pointers to subexpressions','line_number':4320,'multiline':False]['text':' postponed match or NULL','line_number':4321,'multiline':False]['text':'
 * Return TRUE if "one" and "two" are equal.  That includes when both are not
 * set.
 ','line_number':4341,'multiline':True]['text':' one is unused: equal when two is also unused','line_number':4352,'multiline':False]['text':' one is used and two is not: not equal','line_number':4355,'multiline':False]['text':' compare the state id','line_number':4357,'multiline':False]['text':' compare the position','line_number':4360,'multiline':False]['text':'
 * Return TRUE if "state" leads to a NFA_MATCH without advancing the input.
 ','line_number':4367,'multiline':True]['text':' avoid too much recursion','line_number':4375,'multiline':False]['text':' skip ahead to next state','line_number':4403,'multiline':False]['text':' state will advance input','line_number':4442,'multiline':False]['text':' state will advance input','line_number':4447,'multiline':False]['text':' Others: zero-width or possibly zero-width, might still find','line_number':4450,'multiline':False]['text':' a match at the same position, keep looking.','line_number':4451,'multiline':False]['text':'
 * Return TRUE if "state" is already in list "l".
 ','line_number':4460,'multiline':True]['text':' runtime state list','line_number':4465,'multiline':False]['text':' state to update','line_number':4466,'multiline':False]['text':' pointers to subexpressions','line_number':4467,'multiline':False]['text':' Offset used for "off" by addstate_here().','line_number':4477,'multiline':False]['text':'
 * Add "state" and possibly what follows to state list ".".
 * Returns "subs_arg", possibly copied into temp_subs.
 * Returns NULL when recursiveness is too deep or timed out.
 ','line_number':4480,'multiline':True]['text':' runtime state list','line_number':4487,'multiline':False]['text':' state to update','line_number':4488,'multiline':False]['text':' pointers to subexpressions','line_number':4489,'multiline':False]['text':' postponed look-behind match','line_number':4490,'multiline':False]['text':' byte offset, when -1 go to next line','line_number':4491,'multiline':False]['text':' This function is called recursively.  When the depth is too much we run','line_number':4517,'multiline':False]['text':' out of stack and crash, limit recursiveness here.','line_number':4518,'multiline':False]['text':' These nodes are not added themselves but their "out" and/or','line_number':4561,'multiline':False]['text':' "out1" may be added below.','line_number':4562,'multiline':False]['text':' "^" won't match past end-of-line, don't bother trying.','line_number':4567,'multiline':False]['text':' Except when at the end of the line, or when we are going to the','line_number':4568,'multiline':False]['text':' next line for a look-behind match.','line_number':4569,'multiline':False]['text':' FALLTHROUGH','line_number':4576,'multiline':False]['text':' These nodes need to be added so that we can bail out when it','line_number':4601,'multiline':False]['text':' was added to this list before at the same position to avoid an','line_number':4602,'multiline':False]['text':' endless loop for "\(\)*"','line_number':4603,'multiline':False]['text':' This state is already in the list, don't add it again,','line_number':4608,'multiline':False]['text':' unless it is an MOPEN that is used for a backreference or','line_number':4609,'multiline':False]['text':' when there is a PIM. For NFA_MATCH check the position,','line_number':4610,'multiline':False]['text':' lower position is preferred.','line_number':4611,'multiline':False]['text':' When called from addstate_here() do insert before','line_number':4615,'multiline':False]['text':' existing states.','line_number':4616,'multiline':False]['text':' Do not add the state again when it exists with the same','line_number':4640,'multiline':False]['text':' positions.','line_number':4641,'multiline':False]['text':' When there are backreferences or PIMs the number of states may','line_number':4646,'multiline':False]['text':' be (a lot) bigger than anticipated.','line_number':4647,'multiline':False]['text':' "subs" may point into the current array, need to make a','line_number':4662,'multiline':False]['text':' copy before it becomes invalid.','line_number':4663,'multiline':False]['text':' out of memory','line_number':4675,'multiline':False]['text':' add the state to the list','line_number':4683,'multiline':False]['text':' order matters here','line_number':4715,'multiline':False]['text':' avoid compiler warnings','line_number':4767,'multiline':False]['text':' Set the position (with "off" added) in the subexpression.  Save','line_number':4771,'multiline':False]['text':' and restore it when it was in use.  Otherwise fill any gap.','line_number':4772,'multiline':False]['text':' "subs" may have changed, need to set "sub" again','line_number':4826,'multiline':False]['text':' Do not overwrite the position set by \ze.','line_number':4850,'multiline':False]['text':' FALLTHROUGH','line_number':4854,'multiline':False]['text':' We don't fill in gaps here, there must have been an MOPEN that','line_number':4895,'multiline':False]['text':' has done that.','line_number':4896,'multiline':False]['text':' avoid compiler warnings','line_number':4914,'multiline':False]['text':' avoid compiler warnings','line_number':4921,'multiline':False]['text':' "subs" may have changed, need to set "sub" again','line_number':4928,'multiline':False]['text':'
 * Like addstate(), but the new state(s) are put at position "*ip".
 * Used for zero-width matches, next state to use is the added one.
 * This makes sure the order of states to be tried does not change, which
 * matters for alternatives.
 ','line_number':4947,'multiline':True]['text':' runtime state list','line_number':4955,'multiline':False]['text':' state to update','line_number':4956,'multiline':False]['text':' pointers to subexpressions','line_number':4957,'multiline':False]['text':' postponed look-behind match','line_number':4958,'multiline':False]['text':' First add the state(s) at the end, so that we know how many there are.','line_number':4966,'multiline':False]['text':' Pass the listidx as offset (avoids adding another argument to','line_number':4967,'multiline':False]['text':' addstate()).','line_number':4968,'multiline':False]['text':' when "*ip" was at the end of the list, nothing to do','line_number':4973,'multiline':False]['text':' re-order to put the new state at the current position','line_number':4977,'multiline':False]['text':' no state got added','line_number':4980,'multiline':False]['text':' overwrite the current state','line_number':4983,'multiline':False]['text':' not enough space to move the new states, reallocate the list','line_number':4990,'multiline':False]['text':' and move the states to the right position','line_number':4991,'multiline':False]['text':' make space for new states, then move them from the','line_number':5019,'multiline':False]['text':' end to the current position','line_number':5020,'multiline':False]['text':'
 * Check character class "class" against current character c.
 ','line_number':5035,'multiline':True]['text':' should not be here :P','line_number':5121,'multiline':False]['text':'
 * Check for a match with subexpression "subidx".
 * Return TRUE if it matches.
 ','line_number':5128,'multiline':True]['text':' pointers to subexpressions','line_number':5134,'multiline':False]['text':' out: length of match in bytes','line_number':5136,'multiline':False]['text':' backref was not set, match an empty string','line_number':5143,'multiline':False]['text':'
 * Check for a match with \z subexpression "subidx".
 * Return TRUE if it matches.
 ','line_number':5193,'multiline':True]['text':' out: length of match in bytes','line_number':5200,'multiline':False]['text':' backref was not set, match an empty string','line_number':5207,'multiline':False]['text':'
 * Save list IDs for all NFA states of "prog" into "list".
 * Also reset the IDs to zero.
 * Only used for the recursive value lastlist[1].
 ','line_number':5222,'multiline':True]['text':' Order in the list is reverse, it's a bit faster that way.','line_number':5233,'multiline':False]['text':'
 * Restore list IDs from "list" to all NFA states.
 ','line_number':5243,'multiline':True]['text':'
 * Recursively call nfa_regmatch()
 * "pim" is NULL or contains info about a Postponed Invisible Match (start
 * position).
 ','line_number':5270,'multiline':True]['text':' start at the position where the postponed match was','line_number':5297,'multiline':False]['text':' The recursive match must end at the current position. When "pim" is','line_number':5309,'multiline':False]['text':' not NULL it specifies the current position.','line_number':5310,'multiline':False]['text':' Go back the specified number of bytes, or as far as the','line_number':5330,'multiline':False]['text':' start of the previous line, to try matching "\@<=" or','line_number':5331,'multiline':False]['text':' not matching "\@<!". This is very inefficient, limit the number of','line_number':5332,'multiline':False]['text':' bytes if possible.','line_number':5333,'multiline':False]['text':' can't go before the first line','line_number':5340,'multiline':False]['text':' Not enough bytes in this line, go to end of','line_number':5349,'multiline':False]['text':' previous line.','line_number':5350,'multiline':False]['text':' can't go before the first line','line_number':5354,'multiline':False]['text':' Have to clear the lastlist field of the NFA nodes, so that','line_number':5377,'multiline':False]['text':' nfa_regmatch() and addstate() can run properly after recursion.','line_number':5378,'multiline':False]['text':' Already calling nfa_regmatch() recursively.  Save the lastlist[1]','line_number':5381,'multiline':False]['text':' values and clear them.','line_number':5382,'multiline':False]['text':' any value of rex.nfa_listid will do','line_number':5396,'multiline':False]['text':' First recursive nfa_regmatch() call, switch to the second lastlist','line_number':5400,'multiline':False]['text':' entry.  Make sure rex.nfa_listid is different from a previous','line_number':5401,'multiline':False]['text':' recursive call, because some states may still have this ID.','line_number':5402,'multiline':False]['text':' Call nfa_regmatch() to check if the current concat matches at this','line_number':5408,'multiline':False]['text':' position. The concat ends with the node NFA_END_INVISIBLE','line_number':5409,'multiline':False]['text':' restore position in input text','line_number':5421,'multiline':False]['text':'
 * Estimate the chance of a match with "state" failing.
 * empty match: 0
 * NFA_ANY: 1
 * specific character: 99
 ','line_number':5440,'multiline':True]['text':' detect looping','line_number':5452,'multiline':False]['text':' avoid recursive stuff','line_number':5460,'multiline':False]['text':' two alternatives, use the lowest failure chance','line_number':5462,'multiline':False]['text':' matches anything, unlikely to fail','line_number':5468,'multiline':False]['text':' empty match works always','line_number':5474,'multiline':False]['text':' recursive regmatch is expensive, use low failure chance','line_number':5486,'multiline':False]['text':' backreferences don't match in many places','line_number':5565,'multiline':False]['text':' before/after positions don't match very often','line_number':5577,'multiline':False]['text':' specific positions rarely match','line_number':5587,'multiline':False]['text':' character match fails often','line_number':5595,'multiline':False]['text':' something else, includes character classes','line_number':5599,'multiline':False]['text':'
 * Skip until the char "c" we know a match must start with.
 ','line_number':5603,'multiline':True]['text':' Used often, do some work to avoid call overhead.','line_number':5611,'multiline':False]['text':'
 * Check for a match with match_text.
 * Called after skip_to_start() has found regstart.
 * Returns zero for no match, 1 for a match.
 ','line_number':5622,'multiline':True]['text':' skip regstart','line_number':5638,'multiline':False]['text':' check that no composing char follows','line_number':5652,'multiline':False]['text':' Try finding regstart after the current match.','line_number':5673,'multiline':False]['text':' skip regstart','line_number':5674,'multiline':False]['text':'
 * Main matching routine.
 *
 * Run NFA to determine whether it matches rex.input.
 *
 * When "nfa_endp" is not NULL it is a required end-of-match position.
 *
 * Return TRUE if there is a match, FALSE if there is no match,
 * NFA_TOO_EXPENSIVE if we end up with too many states.
 * When there is a match "submatch" contains the positions.
 *
 * Note: Caller must ensure that: start != NULL.
 ','line_number':5683,'multiline':True]['text':' Some patterns may take a long time to match, especially when using','line_number':5724,'multiline':False]['text':' recursive_regmatch(). Allow interrupting them with CTRL-C.','line_number':5725,'multiline':False]['text':' Allocate memory for the lists of nodes.','line_number':5744,'multiline':False]['text':' Inline optimized code for addstate(thislist, start, m, 0) if we know','line_number':5779,'multiline':False]['text':' it's the first MOPEN.','line_number':5780,'multiline':False]['text':'
     * Run for each character.
     ','line_number':5809,'multiline':True]['text':' swap lists','line_number':5833,'multiline':False]['text':' clear nextlist','line_number':5836,'multiline':False]['text':' too many states, retry with old engine','line_number':5846,'multiline':False]['text':'
	 * If the state lists are empty we can stop.
	 ','line_number':5871,'multiline':True]['text':' compute nextlist','line_number':5877,'multiline':False]['text':' If the list gets very long there probably is something wrong.','line_number':5880,'multiline':False]['text':' At least allow interrupting with CTRL-C.','line_number':5881,'multiline':False]['text':'
	     * Handle the possible codes of the current state.
	     * The most important is NFA_MATCH.
	     ','line_number':5912,'multiline':True]['text':' If the match is not at the start of the line, ends before a','line_number':5923,'multiline':False]['text':' composing characters and rex.reg_icombine is not set, that','line_number':5924,'multiline':False]['text':' is not really a match.','line_number':5925,'multiline':False]['text':' Found the left-most longest match, do not look at any other','line_number':5939,'multiline':False]['text':' states at this position.  When the list of states is going','line_number':5940,'multiline':False]['text':' to be empty quit without advancing, so that "rex.input" is','line_number':5941,'multiline':False]['text':' correct.','line_number':5942,'multiline':False]['text':'
		 * This is only encountered after a NFA_START_INVISIBLE or
		 * NFA_START_INVISIBLE_BEFORE node.
		 * They surround a zero-width group, used with "\@=", "\&",
		 * "\@!", "\@<=" and "\@<!".
		 * If we got here, it means that the current "invisible" group
		 * finished successfully, so return control to the parent
		 * nfa_regmatch().  For a look-behind match only when it ends
		 * in the position in "nfa_endp".
		 * Submatches are stored in *m, and used in the parent call.
		 ','line_number':5951,'multiline':True]['text':' If "nfa_endp" is set it's only a match if it ends at','line_number':5977,'multiline':False]['text':' "nfa_endp"','line_number':5978,'multiline':False]['text':' do not set submatches for \@!','line_number':5986,'multiline':False]['text':' See comment above at "goto nextchar".','line_number':6000,'multiline':False]['text':' Do it directly if there already is a PIM or when','line_number':6019,'multiline':False]['text':' nfa_postprocess() detected it will work better.','line_number':6020,'multiline':False]['text':' Copy submatch info for the recursive call, opposite','line_number':6029,'multiline':False]['text':' of what happens on success below.','line_number':6030,'multiline':False]['text':'
			 * First try matching the invisible match, then what
			 * follows.
			 ','line_number':6037,'multiline':True]['text':' for \@! and \@<! it is a match when the result is','line_number':6049,'multiline':False]['text':' FALSE','line_number':6050,'multiline':False]['text':' Copy submatch info from the recursive call','line_number':6058,'multiline':False]['text':' If the pattern has \ze and it matched in the','line_number':6064,'multiline':False]['text':' sub pattern, use it.','line_number':6065,'multiline':False]['text':' t->state->out1 is the corresponding','line_number':6068,'multiline':False]['text':' END_INVISIBLE node; Add its out to the current','line_number':6069,'multiline':False]['text':' list (zero-width match).','line_number':6070,'multiline':False]['text':'
			 * First try matching what follows.  Only if a match
			 * is found verify the invisible match matches.  Add a
			 * nfa_pim_T to the following states, it contains info
			 * about the invisible match.
			 ','line_number':6080,'multiline':True]['text':' t->state->out1 is the corresponding END_INVISIBLE','line_number':6100,'multiline':False]['text':' node; Add its out to the current list (zero-width','line_number':6101,'multiline':False]['text':' match).','line_number':6102,'multiline':False]['text':' There is no point in trying to match the pattern if the','line_number':6120,'multiline':False]['text':' output state is not going to be added to the list.','line_number':6121,'multiline':False]['text':' Copy submatch info to the recursive call, opposite of what','line_number':6154,'multiline':False]['text':' happens afterwards.','line_number':6155,'multiline':False]['text':' First try matching the pattern.','line_number':6162,'multiline':False]['text':' Copy submatch info from the recursive call','line_number':6178,'multiline':False]['text':' Now we need to skip over the matched text and then','line_number':6184,'multiline':False]['text':' continue with what follows.','line_number':6185,'multiline':False]['text':' TODO: multi-line match','line_number':6187,'multiline':False]['text':' empty match, output of corresponding','line_number':6198,'multiline':False]['text':' NFA_END_PATTERN/NFA_SKIP to be used at current','line_number':6199,'multiline':False]['text':' position','line_number':6200,'multiline':False]['text':' match current character, output of corresponding','line_number':6206,'multiline':False]['text':' NFA_END_PATTERN to be used at next position.','line_number':6207,'multiline':False]['text':' skip over the matched characters, set character','line_number':6213,'multiline':False]['text':' count in NFA_SKIP','line_number':6214,'multiline':False]['text':' Get class of current and previous char (if it exists).','line_number':6248,'multiline':False]['text':' Get class of current and previous char (if it exists).','line_number':6274,'multiline':False]['text':' Only match composing character(s), ignore base','line_number':6323,'multiline':False]['text':' character.  Used for ".{composing}" and "{composing}"','line_number':6324,'multiline':False]['text':' (no preceding character).','line_number':6325,'multiline':False]['text':' If \Z was present, then ignore composing characters.','line_number':6330,'multiline':False]['text':' When ignoring the base character this always matches.','line_number':6331,'multiline':False]['text':' Check base character matches first, unless ignored.','line_number':6340,'multiline':False]['text':' We don't care about the order of composing characters.','line_number':6349,'multiline':False]['text':' Get them into cchars[] first.','line_number':6350,'multiline':False]['text':' Check that each composing char in the pattern matches a','line_number':6360,'multiline':False]['text':' composing char in the text.  We do not check if all','line_number':6361,'multiline':False]['text':' composing chars are matched.','line_number':6362,'multiline':False]['text':' NFA_END_COMPOSING','line_number':6380,'multiline':False]['text':' Pass -1 for the offset, which means taking the position','line_number':6390,'multiline':False]['text':' at the start of the next line.','line_number':6391,'multiline':False]['text':' match \n as if it is an ordinary character','line_number':6397,'multiline':False]['text':' What follows is a list of characters, until NFA_END_COLL.','line_number':6406,'multiline':False]['text':' One of them must match or none of them must match.','line_number':6407,'multiline':False]['text':' Never match EOL. If it's part of the collection it is added','line_number':6412,'multiline':False]['text':' as a separate state with an OR.','line_number':6413,'multiline':False]['text':' advance to NFA_RANGE_MAX','line_number':6429,'multiline':False]['text':' next state is in out of the NFA_END_COLL, out1 of','line_number':6468,'multiline':False]['text':' START points to the END state','line_number':6469,'multiline':False]['text':' Any char except '\0', (end of input) does not match.','line_number':6477,'multiline':False]['text':' On a composing character skip over it.  Otherwise do','line_number':6486,'multiline':False]['text':' nothing.  Always matches.','line_number':6487,'multiline':False]['text':'
	     * Character classes like \a for alpha, \d for digit etc.
	     ','line_number':6500,'multiline':True]['text':'  \i','line_number':6503,'multiline':False]['text':'  \I','line_number':6508,'multiline':False]['text':'  \k','line_number':6513,'multiline':False]['text':'  \K','line_number':6518,'multiline':False]['text':'  \f','line_number':6524,'multiline':False]['text':'  \F','line_number':6529,'multiline':False]['text':'  \p','line_number':6534,'multiline':False]['text':'  \P','line_number':6539,'multiline':False]['text':'  \s','line_number':6544,'multiline':False]['text':'  \S','line_number':6549,'multiline':False]['text':'  \d','line_number':6554,'multiline':False]['text':'  \D','line_number':6559,'multiline':False]['text':'  \x','line_number':6564,'multiline':False]['text':'  \X','line_number':6569,'multiline':False]['text':'  \o','line_number':6574,'multiline':False]['text':'  \O','line_number':6579,'multiline':False]['text':'  \w','line_number':6584,'multiline':False]['text':'  \W','line_number':6589,'multiline':False]['text':'  \h','line_number':6594,'multiline':False]['text':'  \H','line_number':6599,'multiline':False]['text':'  \a','line_number':6604,'multiline':False]['text':'  \A','line_number':6609,'multiline':False]['text':'  \l','line_number':6614,'multiline':False]['text':'  \L','line_number':6619,'multiline':False]['text':'  \u','line_number':6624,'multiline':False]['text':' \U','line_number':6629,'multiline':False]['text':' [a-z]','line_number':6634,'multiline':False]['text':' [^a-z]','line_number':6639,'multiline':False]['text':' [A-Z]','line_number':6645,'multiline':False]['text':' ^[A-Z]','line_number':6650,'multiline':False]['text':' \1 .. \9  \z1 .. \z9','line_number':6676,'multiline':False]['text':' empty match always works, output of NFA_SKIP to be','line_number':6700,'multiline':False]['text':' used next','line_number':6701,'multiline':False]['text':' match current character, jump ahead to out of','line_number':6707,'multiline':False]['text':' NFA_SKIP','line_number':6708,'multiline':False]['text':' skip over the matched characters, set character','line_number':6714,'multiline':False]['text':' count in NFA_SKIP','line_number':6715,'multiline':False]['text':' character of previous matching \1 .. \9  or \@>','line_number':6724,'multiline':False]['text':' end of match, go to what follows','line_number':6727,'multiline':False]['text':' add state again with decremented count','line_number':6733,'multiline':False]['text':' Bail out quickly when there can't be a match, avoid the','line_number':6773,'multiline':False]['text':' overhead of win_linetabsize() on long lines.','line_number':6774,'multiline':False]['text':' Guess that a character won't use more columns than','line_number':6783,'multiline':False]['text':' 'tabstop', with a minimum of 4.','line_number':6784,'multiline':False]['text':' Line may have been freed, get it again.','line_number':6818,'multiline':False]['text':' Compare the mark position to the match position, if the mark','line_number':6825,'multiline':False]['text':' exists and mark is set in reg_buf.','line_number':6826,'multiline':False]['text':' These states are only added to be able to bail out when','line_number':6898,'multiline':False]['text':' they are added again, nothing is to be done.','line_number':6899,'multiline':False]['text':' regular character','line_number':6902,'multiline':False]['text':' If rex.reg_icombine is not set only skip over the character','line_number':6914,'multiline':False]['text':' itself.  When it is set skip over composing characters.','line_number':6915,'multiline':False]['text':' switch (t->state->c)','line_number':6922,'multiline':False]['text':' Handle the postponed invisible match if the match might end','line_number':6934,'multiline':False]['text':' without advancing and before the end of the line.','line_number':6935,'multiline':False]['text':' for \@! and \@<! it is a match when the result is','line_number':6949,'multiline':False]['text':' FALSE','line_number':6950,'multiline':False]['text':' Copy submatch info from the recursive call','line_number':6958,'multiline':False]['text':' for \@! and \@<! it is a match when result is FALSE','line_number':6977,'multiline':False]['text':' Copy submatch info from the recursive call','line_number':6985,'multiline':False]['text':' look-behind match failed, don't add the state','line_number':6993,'multiline':False]['text':' Postponed invisible match was handled, don't add it to','line_number':6996,'multiline':False]['text':' following states.','line_number':6997,'multiline':False]['text':' If "pim" points into l->t it will become invalid when','line_number':7001,'multiline':False]['text':' adding the state causes the list to be reallocated.  Make a','line_number':7002,'multiline':False]['text':' local copy to avoid that.','line_number':7003,'multiline':False]['text':' for (thislist = thislist; thislist->state; thislist++)','line_number':7026,'multiline':False]['text':' Look for the start of a match in the current position by adding the','line_number':7028,'multiline':False]['text':' start state to the list of states.','line_number':7029,'multiline':False]['text':' The first found match is the leftmost one, thus the order of states','line_number':7030,'multiline':False]['text':' matters!','line_number':7031,'multiline':False]['text':' Do not add the start state in recursive calls of nfa_regmatch(),','line_number':7032,'multiline':False]['text':' because recursive calls should only start in the first position.','line_number':7033,'multiline':False]['text':' Unless "nfa_endp" is not NULL, then we match the end position.','line_number':7034,'multiline':False]['text':' Also don't start a match past the first line.','line_number':7035,'multiline':False]['text':' Inline optimized code for addstate() if we know the state is','line_number':7053,'multiline':False]['text':' the first MOPEN.','line_number':7054,'multiline':False]['text':' Nextlist is empty, we can skip ahead to the','line_number':7066,'multiline':False]['text':' character that must appear at the start.','line_number':7067,'multiline':False]['text':' Checking if the required start character matches is','line_number':7078,'multiline':False]['text':' cheaper than adding a state that won't match.','line_number':7079,'multiline':False]['text':' Advance to the next character, or advance to the next line, or','line_number':7132,'multiline':False]['text':' finish.','line_number':7133,'multiline':False]['text':' Allow interrupting with CTRL-C.','line_number':7142,'multiline':False]['text':' Free memory','line_number':7159,'multiline':False]['text':'
 * Try match of "prog" with at rex.line["col"].
 * Returns <= 0 for failure, number of lines contained in the match otherwise.
 ','line_number':7171,'multiline':True]['text':' flag set on timeout or NULL','line_number':7179,'multiline':False]['text':' pattern has a \ze but it didn't match, use current end','line_number':7246,'multiline':False]['text':' Use line number of "\ze".','line_number':7251,'multiline':False]['text':' Package any found \z(...\) matches for export. Default is none.','line_number':7269,'multiline':False]['text':' Loop over \z1, \z2, etc.  There is no \z0.','line_number':7279,'multiline':False]['text':' Only accept single line matches that are valid.','line_number':7286,'multiline':False]['text':'
 * Match a regexp against a string ("line" points to the string) or multiple
 * lines (if "line" is NULL, use reg_getline()).
 *
 * Returns <= 0 for failure, number of lines contained in the match otherwise.
 ','line_number':7310,'multiline':True]['text':' column to start looking for match','line_number':7319,'multiline':False]['text':' flag set on timeout or NULL','line_number':7320,'multiline':False]['text':' relative to the cursor','line_number':7330,'multiline':False]['text':' Be paranoid...','line_number':7341,'multiline':False]['text':' If pattern contains "\c" or "\C": overrule value of rex.reg_ic','line_number':7348,'multiline':False]['text':' If pattern contains "\Z" overrule value of rex.reg_icombine','line_number':7354,'multiline':False]['text':' relative to line','line_number':7359,'multiline':False]['text':' Clear the external match subpointers if necessary.','line_number':7375,'multiline':False]['text':' Skip ahead until a character we know the match must start with.','line_number':7390,'multiline':False]['text':' When there is none there is no match.','line_number':7391,'multiline':False]['text':' If match_text is set it contains the full text that must match.','line_number':7395,'multiline':False]['text':' Nothing else to try. Doesn't handle combining chars well.','line_number':7396,'multiline':False]['text':' If the start column is past the maximum column: no need to try.','line_number':7408,'multiline':False]['text':' Set the "nstate" used by nfa_regcomp() to zero to trigger an error when','line_number':7412,'multiline':False]['text':' it's accidentally used during execution.','line_number':7413,'multiline':False]['text':' Make sure the end is never before the start.  Can happen when \zs and','line_number':7431,'multiline':False]['text':' \ze are used.','line_number':7432,'multiline':False]['text':' startpos[0] may be set by "\zs", also return the column where','line_number':7447,'multiline':False]['text':' the whole pattern matched.','line_number':7448,'multiline':False]['text':'
 * Compile a regular expression into internal code for the NFA matcher.
 * Returns the program in allocated space.  Returns NULL for an error.
 ','line_number':7456,'multiline':True]['text':' Build postfix form of the regexp. Needed to build the NFA','line_number':7480,'multiline':False]['text':' (and count its size).','line_number':7481,'multiline':False]['text':' Cascaded (syntax?) error','line_number':7484,'multiline':False]['text':'
     * In order to build the NFA, we parse the input regexp twice:
     * 1. first pass to count size (so we can allocate space)
     * 2. second to emit code
     ','line_number':7486,'multiline':True]['text':'
     * PASS 1
     * Count number of NFA states in "nstate". Do not build the NFA.
     ','line_number':7503,'multiline':True]['text':' allocate the regprog with space for the compiled regexp','line_number':7509,'multiline':False]['text':'
     * PASS 2
     * Build the NFA
     ','line_number':7517,'multiline':True]['text':' Remember whether this pattern has any \z specials in it.','line_number':7543,'multiline':False]['text':'
 * Free a compiled regexp program, returned by nfa_regcomp().
 ','line_number':7568,'multiline':True]['text':'
 * Match a regexp against a string.
 * "rmp->regprog" is a compiled regexp as returned by nfa_regcomp().
 * Uses curbuf for line count and 'iskeyword'.
 * If "line_lbr" is TRUE consider a "\n" in "line" to be a line break.
 *
 * Returns <= 0 for failure, number of lines contained in the match otherwise.
 ','line_number':7582,'multiline':True]['text':' string to match against','line_number':7593,'multiline':False]['text':' column to start looking for match','line_number':7594,'multiline':False]['text':'
 * Match a regexp against multiple lines.
 * "rmp->regprog" is a compiled regexp as returned by vim_regcomp().
 * Uses curbuf for line count and 'iskeyword'.
 *
 * Return <= 0 if there is no match.  Return number of lines contained in the
 * match otherwise.
 *
 * Note: the body is the same as bt_regexec() except for nfa_regexec_both()
 *
 * ! Also NOTE : match may actually be in another line. e.g.:
 * when r.e. is \nc, cursor is at 'a' and the text buffer looks like
 *
 * +-------------------------+
 * |a                        |
 * |b                        |
 * |c                        |
 * |                         |
 * +-------------------------+
 *
 * then nfa_regexec_multi() returns 3. while the original
 * vim_regexec_multi() returns 0 and a second call at line 2 will return 2.
 *
 * FIXME if this behavior is not compatible.
 ','line_number':7610,'multiline':True]['text':' window in which to search or NULL','line_number':7638,'multiline':False]['text':' buffer in which to search','line_number':7639,'multiline':False]['text':' nr of line to start looking for match','line_number':7640,'multiline':False]['text':' column to start looking for match','line_number':7641,'multiline':False]['text':' flag set on timeout or NULL','line_number':7642,'multiline':False]