['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]['text':'
 * buffer.c: functions for dealing with the buffer structure
 ','line_number':10,'multiline':True]['text':'
 * The buffer list is a double linked list of all buffers.
 * Each buffer can be in one of these states:
 * never loaded: BF_NEVERLOADED is set, only the file name is valid
 *   not loaded: b_ml.ml_mfp == NULL, no memfile allocated
 *	 hidden: b_nwindows == 0, loaded but not displayed in a window
 *	 normal: loaded and displayed in a window
 *
 * Instead of storing file names all over the place, each file name is
 * stored in the buffer list. It can be referenced by a number.
 *
 * The current implementation remembers all file names ever used.
 ','line_number':14,'multiline':True]['text':' Determines how deeply nested %{} blocks will be evaluated in statusline.','line_number':32,'multiline':False]['text':' Number of times free_buffer() was called.','line_number':68,'multiline':False]['text':' highest file number','line_number':71,'multiline':False]['text':' file numbers to recycle','line_number':72,'multiline':False]['text':'
 * Return the highest possible buffer number.
 ','line_number':74,'multiline':True]['text':'
 * Read data from buffer for retrying.
 ','line_number':83,'multiline':True]['text':' read file from stdin, otherwise fifo','line_number':88,'multiline':False]['text':' for forced 'ff' and 'fenc' or NULL','line_number':89,'multiline':False]['text':' extra flags for readfile()','line_number':90,'multiline':False]['text':' Read from the buffer which the text is already filled in and append at','line_number':95,'multiline':False]['text':' the end.  This makes it possible to retry when 'fileformat' or','line_number':96,'multiline':False]['text':' 'fileencoding' was guessed wrong.','line_number':97,'multiline':False]['text':' Delete the binary lines.','line_number':106,'multiline':False]['text':' Delete the converted lines.','line_number':112,'multiline':False]['text':' Put the cursor on the first line.','line_number':116,'multiline':False]['text':' Set or reset 'modified' before executing autocommands, so that','line_number':122,'multiline':False]['text':' it can be changed there.','line_number':123,'multiline':False]['text':'
 * Ensure buffer "buf" is loaded.  Does not trigger the swap-exists action.
 ','line_number':143,'multiline':True]['text':' Make sure the buffer is in a window.  If not then skip it.','line_number':154,'multiline':False]['text':'
 * Open current buffer, that is: open the memfile and read the file into
 * memory.
 * Return FAIL for failure, OK otherwise.
 ','line_number':166,'multiline':True]['text':' read file from stdin','line_number':173,'multiline':False]['text':' for forced 'ff' and 'fenc' or NULL','line_number':174,'multiline':False]['text':' extra flags for readfile()','line_number':175,'multiline':False]['text':' The 'readonly' flag is only set when BF_NEVERLOADED is being reset.','line_number':185,'multiline':False]['text':' When re-entering the same buffer, it should not change, because the','line_number':186,'multiline':False]['text':' user may have reset the flag by hand.','line_number':187,'multiline':False]['text':' There MUST be a memfile, otherwise we can't do anything','line_number':194,'multiline':False]['text':' If we can't create one for the current buffer, take another buffer','line_number':195,'multiline':False]['text':' If there is no memfile at all, exit.','line_number':200,'multiline':False]['text':' This is OK, since there are no changes to lose.','line_number':201,'multiline':False]['text':' Don't try to do any saving, with "curbuf" NULL almost nothing','line_number':206,'multiline':False]['text':' will work.','line_number':207,'multiline':False]['text':' Do not sync this buffer yet, may first want to read the file.','line_number':221,'multiline':False]['text':' The autocommands in readfile() may change the buffer, but only AFTER','line_number':225,'multiline':False]['text':' reading the file.','line_number':226,'multiline':False]['text':' mark cursor position as being invalid','line_number':230,'multiline':False]['text':' A buffer without an actual file should not use the buffer name to read a','line_number':233,'multiline':False]['text':' file.','line_number':234,'multiline':False]['text':' Read the file if there is one.','line_number':238,'multiline':False]['text':' Help buffer is filtered.','line_number':284,'multiline':False]['text':' First read the text in binary mode into the buffer.','line_number':292,'multiline':False]['text':' Then read from that same buffer and append at the end.  This makes','line_number':293,'multiline':False]['text':' it possible to retry when 'fileformat' or 'fileencoding' was','line_number':294,'multiline':False]['text':' guessed wrong.','line_number':295,'multiline':False]['text':' Can now sync this buffer in ml_sync_all().','line_number':305,'multiline':False]['text':' if first time loading this buffer, init b_chartab[]','line_number':310,'multiline':False]['text':' Set/reset the Changed flag first, autocmds may change the buffer.','line_number':317,'multiline':False]['text':' Apply the automatic commands, before processing the modelines.','line_number':318,'multiline':False]['text':' So the modelines have priority over autocommands.','line_number':319,'multiline':False]['text':'','line_number':320,'multiline':False]['text':' When reading stdin, the buffer contents always needs writing, so set','line_number':321,'multiline':False]['text':' the changed flag.  Unless in readonly mode: "ls | gview -".','line_number':322,'multiline':False]['text':' When interrupted and 'cpoptions' contains 'i' set changed flag.','line_number':323,'multiline':False]['text':' ":set modified" used in autocmd','line_number':325,'multiline':False]['text':' keep this fileformat','line_number':333,'multiline':False]['text':' Set last_changedtick to avoid triggering a TextChanged autocommand right','line_number':335,'multiline':False]['text':' after it was added.','line_number':336,'multiline':False]['text':' require "!" to overwrite the file, because it wasn't read completely','line_number':341,'multiline':False]['text':' Need to update automatic folding.  Do this before the autocommands,','line_number':350,'multiline':False]['text':' they may use the fold info.','line_number':351,'multiline':False]['text':' need to set w_topline, unless some autocommand already did that.','line_number':355,'multiline':False]['text':' The autocommands may have changed the current buffer.  Apply the','line_number':372,'multiline':False]['text':' modelines to the correct buffer, if it still exists and is loaded.','line_number':373,'multiline':False]['text':' Go to the buffer that was opened, make sure it is in a window.','line_number':378,'multiline':False]['text':' If not then skip it.','line_number':379,'multiline':False]['text':' restore curwin/curbuf and a few other things','line_number':395,'multiline':False]['text':'
 * Store "buf" in "bufref" and set the free count.
 ','line_number':403,'multiline':True]['text':'
 * Return TRUE if "bufref->br_buf" points to the same buffer as when
 * set_bufref() was called and it is a valid buffer.
 * Only goes through the buffer list if buf_free_count changed.
 * Also checks if b_fnum is still the same, a :bwipe followed by :new might get
 * the same allocated memory, but it's a different buffer.
 ','line_number':414,'multiline':True]['text':'
 * Return TRUE if "buf" points to a valid buffer (in the buffer list).
 * This can be slow if there are many buffers, prefer using bufref_valid().
 ','line_number':429,'multiline':True]['text':' Assume that we more often have a recent buffer, start with the last','line_number':438,'multiline':False]['text':' one.','line_number':439,'multiline':False]['text':'
 * A hash table used to quickly lookup a buffer by its number.
 ','line_number':446,'multiline':True]['text':'
 * Return TRUE when buffer "buf" can be unloaded.
 * Give an error message and return FALSE when the buffer is locked or the
 * screen is being redrawn and the buffer is in a window.
 ','line_number':468,'multiline':True]['text':'
 * Close the link to a buffer.
 * "action" is used when there is no longer a window for the buffer.
 * It can be:
 * 0			buffer becomes hidden
 * DOBUF_UNLOAD		buffer is unloaded
 * DOBUF_DEL		buffer is unloaded and removed from buffer list
 * DOBUF_WIPE		buffer is unloaded and really deleted
 * DOBUF_WIPE_REUSE	idem, and add to buf_reuse list
 * When doing all but the first one on the current buffer, the caller should
 * get a new buffer very soon!
 *
 * The 'bufhidden' option can force freeing and deleting.
 *
 * When "abort_if_last" is TRUE then do not close the buffer if autocommands
 * cause there to be only one window with this buffer.  e.g. when ":quit" is
 * supposed to close the window but autocommands close all other windows.
 *
 * When "ignore_abort" is TRUE don't abort even when aborting() returns TRUE.
 *
 * Return TRUE when we got to the end and b_nwindows was decremented.
 ','line_number':499,'multiline':True]['text':' if not NULL, set b_last_cursor','line_number':523,'multiline':False]['text':' Force unloading or deleting when 'bufhidden' says so.','line_number':541,'multiline':False]['text':' The caller must take care of NOT deleting/freeing when 'bufhidden' is','line_number':542,'multiline':False]['text':' "hide" (otherwise we could never free or delete a buffer).','line_number':543,'multiline':False]['text':' 'bufhidden' == "delete"','line_number':544,'multiline':False]['text':' 'bufhidden' == "wipe"','line_number':549,'multiline':False]['text':' 'bufhidden' == "unload"','line_number':555,'multiline':False]['text':' depending on how we get here b_nwindows may already be zero','line_number':559,'multiline':False]['text':' Wiping out or unloading a terminal buffer kills the job.','line_number':570,'multiline':False]['text':' A terminal buffer is wiped out when job has finished.','line_number':573,'multiline':False]['text':' The job keeps running, hide the buffer.','line_number':580,'multiline':False]['text':' Hide a terminal buffer.','line_number':587,'multiline':False]['text':' A terminal buffer is wiped out if the job has finished.','line_number':594,'multiline':False]['text':' We only do this when there's an intention to unload the','line_number':595,'multiline':False]['text':' buffer. This way, :hide and other similar commands won't','line_number':596,'multiline':False]['text':' wipe the buffer.','line_number':597,'multiline':False]['text':' Disallow deleting the buffer when it is locked (already being closed or','line_number':607,'multiline':False]['text':' halfway a command that relies on it). Unloading is allowed.','line_number':608,'multiline':False]['text':' check no autocommands closed the window','line_number':612,'multiline':False]['text':' Set b_last_cursor when closing the last window for the buffer.','line_number':615,'multiline':False]['text':' Remember the last cursor position and window options of the buffer.','line_number':616,'multiline':False]['text':' This used to be only for the current window, but then options like','line_number':617,'multiline':False]['text':' 'foldmethod' may be lost with a ":only" command.','line_number':618,'multiline':False]['text':' When the buffer is no longer in a window, trigger BufWinLeave','line_number':628,'multiline':False]['text':' Autocommands deleted the buffer.','line_number':637,'multiline':False]['text':' Autocommands made this the only window.','line_number':645,'multiline':False]['text':' When the buffer becomes hidden, but is not unloaded, trigger','line_number':648,'multiline':False]['text':' BufHidden','line_number':649,'multiline':False]['text':' Autocommands deleted the buffer.','line_number':657,'multiline':False]['text':' Autocommands made this the only window.','line_number':662,'multiline':False]['text':' autocmds may abort script processing','line_number':666,'multiline':False]['text':' If the buffer was in curwin and the window has changed, go back to that','line_number':672,'multiline':False]['text':' window, if it still exists.  This avoids that ":edit x" triggering a','line_number':673,'multiline':False]['text':' "tabnext" BufUnload autocmd leaves a window behind without a buffer.','line_number':674,'multiline':False]['text':' decrease the link count from windows (unless not in any window)','line_number':684,'multiline':False]['text':' Clear 'diff' for hidden buffer.','line_number':690,'multiline':False]['text':' Return when a window is displaying the buffer or when it's not','line_number':693,'multiline':False]['text':' unloaded.','line_number':694,'multiline':False]['text':' Always remove the buffer when there is no file name.','line_number':698,'multiline':False]['text':' When closing the current buffer stop Visual mode before freeing','line_number':702,'multiline':False]['text':' anything.','line_number':703,'multiline':False]['text':' Free all things allocated for this buffer.','line_number':711,'multiline':False]['text':' Also calls the "BufDelete" autocommands when del_buf is TRUE.','line_number':712,'multiline':False]['text':'','line_number':713,'multiline':False]['text':' Remember if we are closing the current buffer.  Restore the number of','line_number':714,'multiline':False]['text':' windows, so that autocommands in buf_freeall() don't get confused.','line_number':715,'multiline':False]['text':' Autocommands may have deleted the buffer.','line_number':723,'multiline':False]['text':' autocmds may abort script processing','line_number':727,'multiline':False]['text':' It's possible that autocommands change curbuf to the one being deleted.','line_number':732,'multiline':False]['text':' This might cause the previous curbuf to be deleted unexpectedly.  But','line_number':733,'multiline':False]['text':' in some cases it's OK to delete the curbuf, because a new one is','line_number':734,'multiline':False]['text':' obtained anyway.  Therefore only return if curbuf changed to the','line_number':735,'multiline':False]['text':' deleted buffer.','line_number':736,'multiline':False]['text':' make sure we don't use the buffer now','line_number':741,'multiline':False]['text':' Autocommands may have opened or closed windows for this buffer.','line_number':743,'multiline':False]['text':' Decrement the count for the close we do here.','line_number':744,'multiline':False]['text':'
     * Remove the buffer from the list.
     ','line_number':748,'multiline':True]['text':' Do not wipe out the buffer if it is used in a window.','line_number':753,'multiline':False]['text':' we can re-use this buffer number, store it','line_number':759,'multiline':False]['text':' Free all internal variables and reset option values, to make','line_number':784,'multiline':False]['text':' ":bdel" compatible with Vim 5.7.','line_number':785,'multiline':False]['text':' Make it look like a new buffer.','line_number':788,'multiline':False]['text':' Init the options when loaded again.','line_number':791,'multiline':False]['text':' NOTE: at this point "curbuf" may be invalid!','line_number':798,'multiline':False]['text':'
 * Make buffer not contain a file.
 ','line_number':802,'multiline':True]['text':' empty buffer','line_number':818,'multiline':False]['text':'
 * buf_freeall() - free all things allocated for a buffer that are related to
 * the file.  Careful: get here with "curwin" NULL when exiting.
 * flags:
 * BFA_DEL	     buffer is going to be deleted
 * BFA_WIPE	     buffer is going to be wiped out
 * BFA_KEEP_UNDO     do not free undo information
 * BFA_IGNORE_ABORT  don't abort even when aborting() returns TRUE
 ','line_number':824,'multiline':True]['text':' Make sure the buffer isn't closed by autocommands.','line_number':842,'multiline':False]['text':' autocommands deleted the buffer','line_number':851,'multiline':False]['text':' autocommands deleted the buffer','line_number':859,'multiline':False]['text':' autocommands deleted the buffer','line_number':867,'multiline':False]['text':' If the buffer was in curwin and the window has changed, go back to that','line_number':873,'multiline':False]['text':' window, if it still exists.  This avoids that ":edit x" triggering a','line_number':874,'multiline':False]['text':' "tabnext" BufUnload autocmd leaves a window behind without a buffer.','line_number':875,'multiline':False]['text':' autocmds may abort script processing','line_number':884,'multiline':False]['text':' It's possible that autocommands change curbuf to the one being deleted.','line_number':889,'multiline':False]['text':' This might cause curbuf to be deleted unexpectedly.  But in some cases','line_number':890,'multiline':False]['text':' it's OK to delete the curbuf, because a new one is obtained anyway.','line_number':891,'multiline':False]['text':' Therefore only return if curbuf changed to the deleted buffer.','line_number':892,'multiline':False]['text':' Can't use 'diff' for unloaded buffer.','line_number':896,'multiline':False]['text':' Remove any ownsyntax, unless exiting.','line_number':899,'multiline':False]['text':' No folds in an empty buffer.','line_number':905,'multiline':False]['text':' close and delete the memline/memfile','line_number':919,'multiline':False]['text':' no lines in buffer','line_number':920,'multiline':False]['text':' free the memory allocated for undo','line_number':923,'multiline':False]['text':' reset all undo information','line_number':924,'multiline':False]['text':' reset syntax info','line_number':927,'multiline':False]['text':' a read error is no longer relevant','line_number':932,'multiline':False]['text':'
 * Free a buffer structure and the things it contains related to the buffer
 * itself (not the file, that must have been done already).
 ','line_number':935,'multiline':True]['text':' b:changedtick uses an item in buf_T, remove it now','line_number':945,'multiline':False]['text':' Do not free the buffer structure while autocommands are executing,','line_number':986,'multiline':False]['text':' it's still needed. Free it when autocmd_busy is reset.','line_number':987,'multiline':False]['text':' make clear it's not to be used','line_number':995,'multiline':False]['text':'
 * Initializes b:changedtick.
 ','line_number':999,'multiline':True]['text':'
 * Free the b_wininfo list for buffer "buf".
 ','line_number':1018,'multiline':True]['text':'
 * Free stuff in the buffer for ":bdel" and when wiping out the buffer.
 ','line_number':1034,'multiline':True]['text':' free options as well','line_number':1040,'multiline':False]['text':' including window-local options','line_number':1044,'multiline':False]['text':' free all buffer variables','line_number':1054,'multiline':False]['text':' clear local user commands','line_number':1061,'multiline':False]['text':' delete any signs','line_number':1063,'multiline':False]['text':' clear local mappings','line_number':1071,'multiline':False]['text':' clear local abbrevs','line_number':1072,'multiline':False]['text':'
 * Free one wininfo_T.
 ','line_number':1076,'multiline':True]['text':'
 * Go to another buffer.  Handles the result of the ATTENTION dialog.
 ','line_number':1092,'multiline':True]['text':' Reset the error/interrupt/exception state here so that','line_number':1116,'multiline':False]['text':' aborting() returns FALSE when closing a window.','line_number':1117,'multiline':False]['text':' Quitting means closing the split window, nothing else.','line_number':1121,'multiline':False]['text':' Restore the error/interrupt/exception state if not discarded by a','line_number':1127,'multiline':False]['text':' new aborting error, interrupt, or uncaught exception.','line_number':1128,'multiline':False]['text':'
 * Handle the situation of swap_exists_action being set.
 * It is allowed for "old_curbuf" to be NULL or invalid.
 ','line_number':1136,'multiline':True]['text':' Reset the error/interrupt/exception state here so that','line_number':1154,'multiline':False]['text':' aborting() returns FALSE when closing a buffer.','line_number':1155,'multiline':False]['text':' User selected Quit at ATTENTION prompt.  Go back to previous','line_number':1159,'multiline':False]['text':' buffer.  If that buffer is gone or the same as the current one,','line_number':1160,'multiline':False]['text':' open a new, empty buffer.','line_number':1161,'multiline':False]['text':' don't want it again','line_number':1162,'multiline':False]['text':' Block autocommands here because curwin->w_buffer is NULL.','line_number':1168,'multiline':False]['text':' prevent fileinfo message','line_number':1180,'multiline':False]['text':' restore msg_silent, so that the command line will be shown','line_number':1182,'multiline':False]['text':' If "old_curbuf" is NULL we are in big trouble here...','line_number':1190,'multiline':False]['text':' Restore the error/interrupt/exception state if not discarded by a','line_number':1193,'multiline':False]['text':' new aborting error, interrupt, or uncaught exception.','line_number':1194,'multiline':False]['text':' Reset the error/interrupt/exception state here so that','line_number':1201,'multiline':False]['text':' aborting() returns FALSE when closing a buffer.','line_number':1202,'multiline':False]['text':' User selected Recover at ATTENTION prompt.','line_number':1206,'multiline':False]['text':' don't overwrite the last message','line_number':1209,'multiline':False]['text':' Restore the error/interrupt/exception state if not discarded by a','line_number':1214,'multiline':False]['text':' new aborting error, interrupt, or uncaught exception.','line_number':1215,'multiline':False]['text':'
 * Make the current buffer empty.
 * Used when it is wiped out and it's the last buffer.
 ','line_number':1222,'multiline':True]['text':' Close any other windows on this buffer, then make it empty.','line_number':1244,'multiline':False]['text':' do_ecmd() may create a new buffer, then we have to delete','line_number':1251,'multiline':False]['text':' the old one.  But do_ecmd() may have done that already, check','line_number':1252,'multiline':False]['text':' if the buffer still exists.','line_number':1253,'multiline':False]['text':'
 * Implementation of the commands for the buffer list.
 *
 * action == DOBUF_GOTO	    go to specified buffer
 * action == DOBUF_SPLIT    split window and go to specified buffer
 * action == DOBUF_UNLOAD   unload specified buffer(s)
 * action == DOBUF_DEL	    delete specified buffer(s) from buffer list
 * action == DOBUF_WIPE	    delete specified buffer(s) really
 * action == DOBUF_WIPE_REUSE idem, and add number to "buf_reuse"
 *
 * start == DOBUF_CURRENT   go to "count" buffer from current buffer
 * start == DOBUF_FIRST	    go to "count" buffer from first buffer
 * start == DOBUF_LAST	    go to "count" buffer from last buffer
 * start == DOBUF_MOD	    go to "count" modified buffer from current buffer
 *
 * Return FAIL or OK.
 ','line_number':1261,'multiline':True]['text':' FORWARD or BACKWARD','line_number':1282,'multiline':False]['text':' buffer number or number of buffers','line_number':1283,'multiline':False]['text':' DOBUF_FORCEIT etc.','line_number':1284,'multiline':False]['text':' find next modified buffer','line_number':1297,'multiline':False]['text':' find specified buffer number','line_number':1315,'multiline':False]['text':' remember the buffer where we start, we come back there when all','line_number':1325,'multiline':False]['text':' buffers are unlisted.','line_number':1326,'multiline':False]['text':' don't count unlisted buffers','line_number':1341,'multiline':False]['text':' use this buffer as new starting point','line_number':1345,'multiline':False]['text':' back where we started, didn't find anything.','line_number':1349,'multiline':False]['text':' could not find it','line_number':1356,'multiline':False]['text':' don't warn when deleting','line_number':1360,'multiline':False]['text':' disallow navigating to the dummy buffer','line_number':1377,'multiline':False]['text':'
     * delete buffer "buf" from memory and/or the list
     ','line_number':1386,'multiline':True]['text':' When unloading or deleting a buffer that's already unloaded and','line_number':1399,'multiline':False]['text':' unlisted: fail silently.','line_number':1400,'multiline':False]['text':' Autocommand deleted buffer, oops!  It's not changed','line_number':1421,'multiline':False]['text':' now.','line_number':1422,'multiline':False]['text':' If it's still changed fail silently, the dialog already','line_number':1424,'multiline':False]['text':' mentioned why it fails.','line_number':1425,'multiline':False]['text':' When closing the current buffer stop Visual mode.','line_number':1438,'multiline':False]['text':' If deleting the last (listed) buffer, make it empty.','line_number':1442,'multiline':False]['text':' The last (listed) buffer cannot be unloaded.','line_number':1443,'multiline':False]['text':' If the deleted buffer is the current one, close the current window','line_number':1450,'multiline':False]['text':' (unless it's the only window).  Repeat this so long as we end up in','line_number':1451,'multiline':False]['text':' a window with this buffer.','line_number':1452,'multiline':False]['text':' If the buffer to be deleted is not the current one, delete it here.','line_number':1461,'multiline':False]['text':'
	 * Deleting the current buffer: Need to find another buffer to go to.
	 * There should be another, otherwise it would have been handled
	 * above.  However, autocommands may have deleted all buffers.
	 * First use au_new_curbuf.br_buf, if it is valid.
	 * Then prefer the buffer we most recently visited.
	 * Else try to find one that is loaded, after the current buffer,
	 * then before the current buffer.
	 * Finally use any buffer.
	 ','line_number':1470,'multiline':True]['text':' selected buffer','line_number':1480,'multiline':False]['text':' used when no loaded buffer found','line_number':1481,'multiline':False]['text':' Skip current and unlisted bufs.  Also skip a quickfix','line_number':1498,'multiline':False]['text':' buffer, it might be deleted soon.','line_number':1499,'multiline':False]['text':' skip unloaded buf, but may keep it for later','line_number':1504,'multiline':False]['text':' found a valid buffer: stop searching','line_number':1510,'multiline':False]['text':' advance to older entry in jump list','line_number':1512,'multiline':False]['text':' List exhausted for sure','line_number':1517,'multiline':False]['text':' No previous buffer, Try 2'nd approach','line_number':1522,'multiline':False]['text':' tried both directions','line_number':1530,'multiline':False]['text':' in non-help buffer, try to skip help buffers, and vv','line_number':1536,'multiline':False]['text':' found loaded buffer','line_number':1540,'multiline':False]['text':' remember unloaded buf for later','line_number':1542,'multiline':False]['text':' No loaded buffer, use unloaded one','line_number':1551,'multiline':False]['text':' No loaded buffer, find listed one','line_number':1553,'multiline':False]['text':' Still no buffer, just take one','line_number':1559,'multiline':False]['text':' Autocommands must have wiped out all other buffers.  Only option','line_number':1572,'multiline':False]['text':' now is to make the current buffer empty.','line_number':1573,'multiline':False]['text':'
     * make "buf" the current buffer
     ','line_number':1577,'multiline':True]['text':' split window first','line_number':1580,'multiline':False]['text':' If 'switchbuf' is set jump to the window containing "buf".','line_number':1582,'multiline':False]['text':' go to current buffer - nothing to do','line_number':1590,'multiline':False]['text':' Check if the current buffer may be abandoned.','line_number':1594,'multiline':False]['text':' Manually kill the terminal here because this command will','line_number':1605,'multiline':False]['text':' hide it otherwise.','line_number':1606,'multiline':False]['text':' Autocommand deleted buffer, oops!','line_number':1617,'multiline':False]['text':' Go to the other buffer.','line_number':1635,'multiline':False]['text':' reset 'scrollbind' and 'cursorbind'','line_number':1639,'multiline':False]['text':' autocmds may abort script processing','line_number':1642,'multiline':False]['text':' FORWARD or BACKWARD','line_number':1653,'multiline':False]['text':' buffer number or number of buffers','line_number':1654,'multiline':False]['text':' TRUE when using !','line_number':1655,'multiline':False]['text':'
 * do_bufdel() - delete or unload buffer(s)
 *
 * addr_count == 0: ":bdel" - delete current buffer
 * addr_count == 1: ":N bdel" or ":bdel N [N ..]" - first delete
 *		    buffer "end_bnr", then any other arguments.
 * addr_count == 2: ":N,N bdel" - delete buffers in range
 *
 * command can be DOBUF_UNLOAD (":bunload"), DOBUF_WIPE (":bwipeout") or
 * DOBUF_DEL (":bdel")
 *
 * Returns error message or NULL
 ','line_number':1661,'multiline':True]['text':' pointer to extra arguments','line_number':1677,'multiline':False]['text':' first buffer number in a range','line_number':1679,'multiline':False]['text':' buffer nr or last buffer nr in a range','line_number':1680,'multiline':False]['text':' delete current buffer?','line_number':1683,'multiline':False]['text':' number of buffers deleted','line_number':1684,'multiline':False]['text':' return value','line_number':1685,'multiline':False]['text':' buffer number','line_number':1686,'multiline':False]['text':' both range and argument is not allowed','line_number':1697,'multiline':False]['text':' addr_count == 1','line_number':1701,'multiline':False]['text':' Delete the current buffer last, otherwise when the','line_number':1706,'multiline':False]['text':' current buffer is deleted, the next buffer becomes','line_number':1707,'multiline':False]['text':' the current one and will be loaded, which may then','line_number':1708,'multiline':False]['text':' also be deleted, etc.','line_number':1709,'multiline':False]['text':' find next buffer number to delete/unload','line_number':1716,'multiline':False]['text':' addr_count == 1','line_number':1722,'multiline':False]['text':' failed','line_number':1733,'multiline':False]['text':'
 * Set current buffer to "buf".  Executes autocommands and closes current
 * buffer.  "action" tells how to close the current buffer:
 * DOBUF_GOTO	    free or hide it
 * DOBUF_SPLIT	    nothing
 * DOBUF_UNLOAD	    unload it
 * DOBUF_DEL	    delete it
 * DOBUF_WIPE	    wipe it out
 * DOBUF_WIPE_REUSE wipe it out and add to "buf_reuse"
 ','line_number':1772,'multiline':True]['text':' remember alternate file','line_number':1797,'multiline':False]['text':' remember curpos','line_number':1798,'multiline':False]['text':' Don't restart Select mode after switching to another buffer.','line_number':1800,'multiline':False]['text':' close_windows() or apply_autocmds() may change curbuf and wipe out "buf"','line_number':1803,'multiline':False]['text':' Autocommands may delete the current buffer and/or the buffer we want to','line_number':1808,'multiline':False]['text':' go to.  In those cases don't close the buffer.','line_number':1809,'multiline':False]['text':' Do not sync when in Insert mode and the buffer is open in','line_number':1832,'multiline':False]['text':' another window, might be a timer doing something in another','line_number':1833,'multiline':False]['text':' window.','line_number':1834,'multiline':False]['text':' autocommands changed curwin, Grr!','line_number':1844,'multiline':False]['text':' An autocommand may have deleted "buf", already entered it (e.g., when','line_number':1848,'multiline':False]['text':' it did ":bunload") or aborted the script processing.','line_number':1849,'multiline':False]['text':' If curwin->w_buffer is null, enter_buffer() will make it valid again','line_number':1850,'multiline':False]['text':' If the buffer is not valid but curwin->w_buffer is NULL we must','line_number':1858,'multiline':False]['text':' enter some buffer.  Using the last one is hopefully OK.','line_number':1859,'multiline':False]['text':'
 * Enter a new current buffer.
 * Old curbuf must have been abandoned already!  This also means "curbuf" may
 * be pointing to freed memory.
 ','line_number':1871,'multiline':True]['text':' when closing the current buffer stop Visual mode','line_number':1879,'multiline':False]['text':' Get the buffer in the current window.','line_number':1887,'multiline':False]['text':' Copy buffer and window local option values.  Not for a help buffer.','line_number':1892,'multiline':False]['text':' Remove all folds in the window.','line_number':1898,'multiline':False]['text':' update folds (later).','line_number':1900,'multiline':False]['text':' Cursor on first line by default.','line_number':1912,'multiline':False]['text':' mark cursor position as being invalid','line_number':1919,'multiline':False]['text':' Make sure the buffer is loaded.','line_number':1925,'multiline':False]['text':' need to load the file','line_number':1926,'multiline':False]['text':' If there is no filetype, allow for detecting one.  Esp. useful for','line_number':1928,'multiline':False]['text':' ":ball" used in an autocommand.  If there already is a filetype we','line_number':1929,'multiline':False]['text':' might prefer to keep it.','line_number':1930,'multiline':False]['text':' display file info after redraw','line_number':1939,'multiline':False]['text':' check if file changed','line_number':1941,'multiline':False]['text':' If autocommands did not change the cursor position, restore cursor lnum','line_number':1952,'multiline':False]['text':' and possibly cursor col.','line_number':1953,'multiline':False]['text':' check for valid arg_idx','line_number':1957,'multiline':False]['text':' when autocmds didn't change it','line_number':1959,'multiline':False]['text':' redisplay at correct position','line_number':1961,'multiline':False]['text':' Send fileOpened event because we've changed buffers.','line_number':1964,'multiline':False]['text':' Change directories when the 'acd' option is set.','line_number':1968,'multiline':False]['text':' May need to set the spell language.  Can only do this after the buffer','line_number':1976,'multiline':False]['text':' has been properly setup.','line_number':1977,'multiline':False]['text':'
 * Change to the directory of the current buffer.
 * Don't do this while still starting up.
 ','line_number':1989,'multiline':True]['text':'
 * functions for dealing with the buffer list
 ','line_number':2040,'multiline':True]['text':'
 * Return TRUE if the current buffer is empty, unnamed, unmodified and used in
 * only one window.  That means it can be re-used.
 ','line_number':2044,'multiline':True]['text':'
 * Add a file name to the buffer list.  Return a pointer to the buffer.
 * If the same file name already exists return a pointer to that buffer.
 * If it does not exist, or if fname == NULL, a new entry is created.
 * If (flags & BLN_CURBUF) is TRUE, may use current buffer.
 * If (flags & BLN_LISTED) is TRUE, add new buffer to buffer list.
 * If (flags & BLN_DUMMY) is TRUE, don't count it as a real buffer.
 * If (flags & BLN_NEW) is TRUE, don't use an existing buffer.
 * If (flags & BLN_NOOPT) is TRUE, don't copy options from the current buffer
 *				    if the buffer already exists.
 * If (flags & BLN_REUSE) is TRUE, may use buffer number from "buf_reuse".
 * This is the ONLY way to create a new buffer.
 ','line_number':2059,'multiline':True]['text':' full path of fname or relative','line_number':2074,'multiline':False]['text':' short fname or NULL','line_number':2075,'multiline':False]['text':' preferred cursor line','line_number':2076,'multiline':False]['text':' BLN_ defines','line_number':2077,'multiline':False]['text':' will allocate ffname','line_number':2089,'multiline':False]['text':'
     * If the file name already exists in the list, update the entry.
     ','line_number':2091,'multiline':True]['text':' On Unix we can use inode numbers when the file exists.  Works better','line_number':2095,'multiline':False]['text':' for hard links.','line_number':2096,'multiline':False]['text':' copy the options now, if 'cpo' doesn't have 's' and not done','line_number':2114,'multiline':False]['text':' already','line_number':2115,'multiline':False]['text':'
     * If the current buffer has no name and no contents, use the current
     * buffer.	Otherwise: Need to allocate a new buffer structure.
     *
     * This is the ONLY place where a new buffer structure is allocated!
     * (A spell file buffer is allocated in spell.c, but that's not a normal
     * buffer.)
     ','line_number':2134,'multiline':True]['text':' It's like this buffer is deleted.  Watch out for autocommands that','line_number':2146,'multiline':False]['text':' change curbuf!  If that happens, allocate a new buffer anyway.','line_number':2147,'multiline':False]['text':' autocommands deleted the buffer!','line_number':2149,'multiline':False]['text':' autocmds may abort script processing','line_number':2152,'multiline':False]['text':' init b: variables','line_number':2168,'multiline':False]['text':' delete local variables et al.','line_number':2205,'multiline':False]['text':' Init the options.','line_number':2207,'multiline':False]['text':' need to reload lmaps and set b:keymap_name','line_number':2212,'multiline':False]['text':' put the new buffer at the end of the buffer list','line_number':2218,'multiline':False]['text':' buffer list is empty','line_number':2220,'multiline':False]['text':' append new buffer at end of list','line_number':2225,'multiline':False]['text':' Recycle a previously used buffer number.  Used for buffers which','line_number':2234,'multiline':False]['text':' are normally hidden, e.g. in a popup window.  Avoids that the','line_number':2235,'multiline':False]['text':' buffer number grows rapidly.','line_number':2236,'multiline':False]['text':' Move buffer to the right place in the buffer list.','line_number':2240,'multiline':False]['text':' wrap around (may cause duplicates)','line_number':2261,'multiline':False]['text':' make sure it is noticed','line_number':2267,'multiline':False]['text':' Always copy the options from the current buffer.','line_number':2273,'multiline':False]['text':' clear marks','line_number':2301,'multiline':False]['text':' check file marks for this file','line_number':2302,'multiline':False]['text':' init 'buflisted'','line_number':2303,'multiline':False]['text':' Tricky: these autocommands may change the buffer list.  They could','line_number':2308,'multiline':False]['text':' also split the window with re-using the one empty buffer. This may','line_number':2309,'multiline':False]['text':' result in unexpectedly losing the empty buffer.','line_number':2310,'multiline':False]['text':' autocmds may abort script processing','line_number':2322,'multiline':False]['text':'
 * Free the memory for the options of a buffer.
 * If "free_p_ff" is TRUE also free 'fileformat', 'buftype' and
 * 'fileencoding'.
 ','line_number':2330,'multiline':True]['text':'
 * Get alternate file "n".
 * Set linenr to "lnum" or altfpos.lnum if "lnum" == 0.
 *	Also set cursor column to altfpos.col if 'startofline' is not set.
 * if (options & GETF_SETMARK) call setpcmark()
 * if (options & GETF_ALT) we are jumping to an alternate file.
 * if (options & GETF_SWITCH) respect 'switchbuf' settings when jumping
 *
 * Return FAIL for failure, OK for success.
 ','line_number':2449,'multiline':True]['text':' if alternate file is the current buffer, nothing to do','line_number':2481,'multiline':False]['text':' altfpos may be changed by getfile(), get it now','line_number':2488,'multiline':False]['text':' If 'switchbuf' is set jump to the window containing "buf".','line_number':2500,'multiline':False]['text':' If 'switchbuf' contains "split", "vsplit" or "newtab" and the','line_number':2503,'multiline':False]['text':' current buffer isn't empty: open new tab or window','line_number':2504,'multiline':False]['text':' cursor is at to BOL and w_cursor.lnum is checked due to getfile()','line_number':2522,'multiline':False]['text':'
 * go to the last know line number for the current buffer
 ','line_number':2538,'multiline':True]['text':'
 * Find file in buffer list by name (it has to be for the current window).
 * Returns NULL if not found.
 ','line_number':2562,'multiline':True]['text':' First make the name into a full path name','line_number':2572,'multiline':False]['text':' force expansion, get rid of symbolic links','line_number':2575,'multiline':False]['text':'
 * Find file in buffer list by name (it has to be for the current window).
 * "ffname" must have a full path.
 * Skips dummy buffers.
 * Returns NULL if not found.
 ','line_number':2588,'multiline':True]['text':'
 * Same as buflist_findname(), but pass the stat structure to avoid getting it
 * twice for the same file.
 * Returns NULL if not found.
 ','line_number':2605,'multiline':True]['text':' Start at the last buffer, expect to find a match sooner.','line_number':2618,'multiline':False]['text':'
 * Find file in buffer list by a regexp pattern.
 * Return fnum of the found buffer.
 * Return < 0 for error.
 ','line_number':2629,'multiline':True]['text':' pointer to first char after pattern','line_number':2637,'multiline':False]['text':' find unlisted buffers','line_number':2638,'multiline':False]['text':' find diff-mode buffers only','line_number':2639,'multiline':False]['text':' find buffers in current tab only','line_number':2640,'multiline':False]['text':' "%" is current file, "%%" or "#" is alternate file','line_number':2651,'multiline':False]['text':'
     * Try four ways of matching a listed buffer:
     * attempt == 0: without '^' or '$' (at any position)
     * attempt == 1: with '^' at start (only at position 0)
     * attempt == 2: with '$' at end (only match at end)
     * attempt == 3: with '^' at start and '$' at end (only full match)
     * Repeat this for finding an unlisted buffer if there was no matching
     * listed buffer.
     ','line_number':2666,'multiline':True]['text':' First try finding a listed buffer.  If not found and "unlisted"','line_number':2683,'multiline':False]['text':' is TRUE, try finding an unlisted buffer.','line_number':2684,'multiline':False]['text':' may add '^' and '$'','line_number':2692,'multiline':False]['text':' add/remove '$'','line_number':2694,'multiline':False]['text':' add/remove '^'','line_number':2696,'multiline':False]['text':' invalid pattern, possibly after switching engine','line_number':2704,'multiline':False]['text':' Ignore the match if the buffer is not open in','line_number':2716,'multiline':False]['text':' the current tab.','line_number':2717,'multiline':False]['text':' already found a match','line_number':2726,'multiline':False]['text':' remember first match','line_number':2731,'multiline':False]['text':' found one match','line_number':2736,'multiline':False]['text':' Only search for unlisted buffers if there was no match with','line_number':2740,'multiline':False]['text':' a listed buffer.','line_number':2741,'multiline':False]['text':'
 * Find all buffer names that match.
 * For command line expansion of ":buf" and ":sbuf".
 * Return OK if matches found, FAIL otherwise.
 ','line_number':2764,'multiline':True]['text':' return values in case of FAIL','line_number':2788,'multiline':False]['text':' Make a copy of "pat" and change "^" to "\(^\|[\/]\)" (if doing regular','line_number':2798,'multiline':False]['text':' expression matching)','line_number':2799,'multiline':False]['text':' attempt == 0: try match with    '\<', match at start of word','line_number':2814,'multiline':False]['text':' attempt == 1: try match without '\<', match anywhere','line_number':2815,'multiline':False]['text':' there was no anchor, no need to try again','line_number':2824,'multiline':False]['text':' round == 1: Count the matches.','line_number':2828,'multiline':False]['text':' round == 2: Build the array to keep the matches.','line_number':2829,'multiline':False]['text':' skip unlisted buffers','line_number':2835,'multiline':False]['text':' Skip buffers not suitable for','line_number':2839,'multiline':False]['text':' :diffget or :diffput completion.','line_number':2840,'multiline':False]['text':' invalid pattern, possibly after recompiling','line_number':2849,'multiline':False]['text':' first try matching with the short file name','line_number':2859,'multiline':False]['text':' next try matching with the full path file name','line_number':2864,'multiline':False]['text':' no match found, break here','line_number':2905,'multiline':False]['text':' match(es) found, break here','line_number':2940,'multiline':False]['text':' if the current buffer is first in the list, place it at the end','line_number':2956,'multiline':False]['text':'
 * Check for a match on the file name for buffer "buf" with regprog "prog".
 * Note that rmp->regprog may become NULL when switching regexp engine.
 ','line_number':2982,'multiline':True]['text':' when TRUE ignore case, when FALSE use 'fic'','line_number':2990,'multiline':False]['text':' First try the short file name, then the long file name.','line_number':2994,'multiline':False]['text':'
 * Try matching the regexp in "rmp->regprog" with file name "name".
 * Note that rmp->regprog may become NULL when switching regexp engine.
 * Return "name" when there is a match, NULL when not.
 ','line_number':3002,'multiline':True]['text':' when TRUE ignore case, when FALSE use 'fic'','line_number':3011,'multiline':False]['text':' extra check for valid arguments','line_number':3016,'multiline':False]['text':' Ignore case when 'fileignorecase' or the argument is set.','line_number':3020,'multiline':False]['text':' Replace $(HOME) with '~' and try matching again.','line_number':3026,'multiline':False]['text':'
 * Find a file in the buffer list by buffer number.
 ','line_number':3036,'multiline':True]['text':'
 * Get name of file 'n' in the buffer list.
 * When the file has no name an empty string is returned.
 * home_replace() is used to shorten the file name (used for marks).
 * Returns a pointer to allocated memory, of NULL when failed.
 ','line_number':3056,'multiline':True]['text':' for help buffers return tail only','line_number':3066,'multiline':False]['text':'
 * Set the "lnum" and "col" for the buffer "buf" and the current window.
 * When "copy_options" is TRUE save the local window option values.
 * When "lnum" is 0 only do the options.
 ','line_number':3077,'multiline':True]['text':' may be NULL when using :badd','line_number':3085,'multiline':False]['text':' allocate a new entry','line_number':3097,'multiline':False]['text':' set lnum even when it's 0','line_number':3102,'multiline':False]['text':' remove the entry from the list','line_number':3107,'multiline':False]['text':' Save the window-specific option values.','line_number':3131,'multiline':False]['text':' insert the entry in front of the list','line_number':3140,'multiline':False]['text':'
 * Return TRUE when "wip" has 'diff' set and the diff is only for another tab
 * page.  That's because a diff is local to a tab page.
 ','line_number':3149,'multiline':True]['text':' return FALSE when it's a window in the current tab page, thus','line_number':3162,'multiline':False]['text':' the buffer was in diff mode here','line_number':3163,'multiline':False]['text':'
 * Find info for the current window in buffer "buf".
 * If not found, return the info for the most recently used window.
 * When "need_options" is TRUE skip entries where wi_optset is FALSE.
 * When "skip_diff_buffer" is TRUE avoid windows with 'diff' set that is in
 * another tab page.
 * Returns NULL when there isn't any info.
 ','line_number':3170,'multiline':True]['text':' If no wininfo for curwin, use the first in the list (that doesn't have','line_number':3198,'multiline':False]['text':' 'diff' set and is in another tab page).','line_number':3199,'multiline':False]['text':' If "need_options" is TRUE skip entries that don't have options set,','line_number':3200,'multiline':False]['text':' unless the window is editing "buf", so we can copy from the window','line_number':3201,'multiline':False]['text':' itself.','line_number':3202,'multiline':False]['text':'
 * Reset the local window options to the values last used in this window.
 * If the buffer wasn't used in this window before, use the values from
 * the most recently used window.  If the values were never set, use the
 * global values for the window.
 ','line_number':3219,'multiline':True]['text':' The buffer is currently displayed in the window: use the actual','line_number':3239,'multiline':False]['text':' option values instead of the saved (possibly outdated) values.','line_number':3240,'multiline':False]['text':' the buffer was displayed in the current window earlier','line_number':3252,'multiline':False]['text':' Set 'foldlevel' to 'foldlevelstart' if it's not negative.','line_number':3266,'multiline':False]['text':'
 * Find the position (lnum and col) for the buffer 'buf' for the current
 * window.
 * Returns a pointer to no_position if no position is found.
 ','line_number':3273,'multiline':True]['text':'
 * Find the lnum for the buffer 'buf' for the current window.
 ','line_number':3291,'multiline':True]['text':'
 * List all known file names (for :files and :buffers command).
 ','line_number':3300,'multiline':True]['text':' skip unlisted buffers, unless ! was used','line_number':3348,'multiline':False]['text':' bufIsChanged() returns TRUE to avoid','line_number':3388,'multiline':False]['text':' closing, but it's not actually changed.','line_number':3389,'multiline':False]['text':' put "line 999" in column 40 or after the file name','line_number':3411,'multiline':False]['text':' output one line at a time','line_number':3425,'multiline':False]['text':'
 * Get file name and line number for file 'fnum'.
 * Used by DoOneCmd() for translating '%' and '#'.
 * Used by insert_reg() and cmdline_paste() for '#' register.
 * Return FAIL if not found, OK for success.
 ','line_number':3435,'multiline':True]['text':'
 * Set the file name for "buf"' to "ffname_arg", short file name to
 * "sfname_arg".
 * The file name with the full path is also remembered, for when :cd is used.
 * Returns FAIL for failure (file name already in use by other buffer)
 *	OK otherwise.
 ','line_number':3459,'multiline':True]['text':' give message when buffer already exists','line_number':3471,'multiline':False]['text':' Removing the name.','line_number':3482,'multiline':False]['text':' will allocate ffname','line_number':3494,'multiline':False]['text':' out of memory','line_number':3495,'multiline':False]['text':'
	 * If the file name is already used in another buffer:
	 * - if the buffer is loaded, fail
	 * - if the buffer is not loaded, delete it from the list
	 ','line_number':3498,'multiline':True]['text':' during startup a window may use a buffer that is not loaded yet','line_number':3519,'multiline':False]['text':' it's loaded or used in a window, fail','line_number':3524,'multiline':False]['text':' delete from the list','line_number':3532,'multiline':False]['text':' set correct case for short file name','line_number':3543,'multiline':False]['text':'
 * Crude way of changing the name of a buffer.  Use with care!
 * The name should be relative to the current directory.
 ','line_number':3569,'multiline':True]['text':' Allocate ffname and expand into full path.  Also resolves .lnk','line_number':3587,'multiline':False]['text':' files on Win32.','line_number':3588,'multiline':False]['text':'
 * Take care of what needs to be done when the name of buffer "buf" has
 * changed.
 ','line_number':3593,'multiline':True]['text':'
     * If the file name changed, also change the name of the swapfile
     ','line_number':3600,'multiline':True]['text':' check file name for arg list','line_number':3612,'multiline':False]['text':' set window title','line_number':3613,'multiline':False]['text':' status lines need to be redrawn','line_number':3614,'multiline':False]['text':' check named file marks','line_number':3615,'multiline':False]['text':' reset timestamp','line_number':3616,'multiline':False]['text':'
 * set alternate file name for current window
 *
 * Used by do_one_cmd(), do_write() and do_ecmd().
 * Return the buffer.
 ','line_number':3619,'multiline':True]['text':' Create a buffer.  'buflisted' is not set if it's a new buffer','line_number':3633,'multiline':False]['text':'
 * Get alternate file name for current window.
 * Return NULL if there isn't any, and give error message if requested.
 ','line_number':3640,'multiline':True]['text':' give error message','line_number':3646,'multiline':False]['text':'
 * Add a file name to the buflist and return its number.
 * Uses same flags as buflist_new(), except BLN_DUMMY.
 *
 * used by qf_init(), main() and doarglist()
 ','line_number':3660,'multiline':True]['text':'
 * Adjust slashes in file names.  Called after 'shellslash' was set.
 ','line_number':3678,'multiline':True]['text':'
 * Set alternate cursor position for the current buffer and window "win".
 * Also save the local window option values.
 ','line_number':3696,'multiline':True]['text':'
 * Return TRUE if 'ffname' is not the same file as current file.
 * Fname must have a full path (expanded by mch_FullName()).
 ','line_number':3706,'multiline':True]['text':' no name is different','line_number':3729,'multiline':False]['text':' If no stat_T given, get it now','line_number':3738,'multiline':False]['text':' Use dev/ino to check if the files are the same, even when the names','line_number':3745,'multiline':False]['text':' are different (possible with links).  Still need to compare the','line_number':3746,'multiline':False]['text':' name above, for when the file doesn't exist yet.','line_number':3747,'multiline':False]['text':' Problem: The dev/ino changes when a file is deleted (and created','line_number':3748,'multiline':False]['text':' again) and remains the same when renamed/moved.  We don't want to','line_number':3749,'multiline':False]['text':' mch_stat() each buffer each time, that would be too slow.  Get the','line_number':3750,'multiline':False]['text':' dev/ino again when they appear to match, but not when they appear','line_number':3751,'multiline':False]['text':' to be different: Could skip a buffer when it's actually the same','line_number':3752,'multiline':False]['text':' file.','line_number':3753,'multiline':False]['text':'
 * Set inode and device number for a buffer.
 * Must always be called when b_fname is changed!.
 ','line_number':3766,'multiline':True]['text':'
 * Return TRUE if dev/ino in buffer "buf" matches with "stp".
 ','line_number':3785,'multiline':True]['text':'
 * Print info about the current buffer.
 ','line_number':3799,'multiline':True]['text':' when non-zero print full path','line_number':3804,'multiline':False]['text':' 2 CTRL-G: include buffer number','line_number':3818,'multiline':False]['text':' With 32 bit longs and more than 21,474,836 lines multiplying by 100','line_number':3852,'multiline':False]['text':' causes an overflow, thus for large numbers divide instead.','line_number':3853,'multiline':False]['text':' Current line and column are already on the screen -- webb','line_number':3863,'multiline':False]['text':' Temporarily set msg_scroll to avoid the message being truncated.','line_number':3886,'multiline':False]['text':' First call msg_start() to get the message in the right place.','line_number':3887,'multiline':False]['text':' Need to repeat the message after redrawing when:','line_number':3898,'multiline':False]['text':' - When restart_edit is set (otherwise there will be a delay','line_number':3899,'multiline':False]['text':'   before redrawing).','line_number':3900,'multiline':False]['text':' - When the screen was scrolled but there is no wait-return','line_number':3901,'multiline':False]['text':'   prompt.','line_number':3902,'multiline':False]['text':'
 * Put the file name in the title bar and icon of the window.
 ','line_number':3925,'multiline':True]['text':' Postpone updating the title when 'lazyredraw' is set.','line_number':3942,'multiline':False]['text':' nothing to do','line_number':3949,'multiline':False]['text':' format: "fname + (path) (1 of 2) - VIM"','line_number':3974,'multiline':False]['text':' at least room for " - VIM"','line_number':3978,'multiline':False]['text':' Get path of file, replace home dir with ~','line_number':4017,'multiline':False]['text':' avoid "c:/name" to be reduced to "c"','line_number':4024,'multiline':False]['text':' remove the file name','line_number':4028,'multiline':False]['text':' must be a help buffer','line_number':4032,'multiline':False]['text':' Translate unprintable chars and concatenate.  Keep some','line_number':4039,'multiline':False]['text':' room for the server name.  When there is no room (very long','line_number':4040,'multiline':False]['text':' file name) use (...).','line_number':4041,'multiline':False]['text':' make it shorter by removing a bit in the middle','line_number':4070,'multiline':False]['text':' use file name only in icon','line_number':4095,'multiline':False]['text':' Truncate name at 100 bytes.','line_number':4098,'multiline':False]['text':'
 * Used for title and icon: Check if "str" differs from "*last".  Set "*last"
 * from "str" if it does.
 * Return TRUE if resettitle() is to be called.
 ','line_number':4118,'multiline':True]['text':'
 * Put current window title back (used after calling a shell)
 ','line_number':4145,'multiline':True]['text':'
 * Used for building in the status line.
 ','line_number':4166,'multiline':True]['text':' Initial value, grows as needed.','line_number':4185,'multiline':False]['text':'
 * Build a string from the status line items in "fmt".
 * Return length of string in screen cells.
 *
 * Normally works for window "wp", except when working for 'tabline' then it
 * is "curwin".
 *
 * Items are drawn interspersed with the text that surrounds it
 * Specials: %-<wid>(xxx%) => group, %= => separation marker, %< => truncation
 * Item: %-<minwid>.<maxwid><itemch> All but <itemch> are optional
 *
 * If maxwidth is not zero, the string will be filled at any middle marker
 * or truncated if too long, fillchar is used for all whitespace.
 ','line_number':4192,'multiline':True]['text':' buffer to write into != NameBuff','line_number':4209,'multiline':False]['text':' length of out[]','line_number':4210,'multiline':False]['text':' option name corresponding to "fmt"','line_number':4212,'multiline':False]['text':' scope for "opt_name"','line_number':4213,'multiline':False]['text':' return: HL attributes (can be NULL)','line_number':4216,'multiline':False]['text':' return: tab page nrs (can be NULL)','line_number':4217,'multiline':False]['text':' TODO: find out why using called_emsg_before makes tests fail, does it','line_number':4262,'multiline':False]['text':' matter?','line_number':4263,'multiline':False]['text':' int	called_emsg_before = called_emsg;','line_number':4264,'multiline':False]['text':' When inside update_screen() we do not want redrawing a statusline,','line_number':4267,'multiline':False]['text':' ruler, title, etc. to trigger another redraw, it may cause an endless','line_number':4268,'multiline':False]['text':' loop.','line_number':4269,'multiline':False]['text':' Allocate one more, because the last element is used to indicate the','line_number':4278,'multiline':False]['text':' end of the list.','line_number':4279,'multiline':False]['text':' if "fmt" was set insecurely it needs to be evaluated in the sandbox','line_number':4287,'multiline':False]['text':' When the format starts with "%!" then evaluate it as an expression and','line_number':4290,'multiline':False]['text':' use the result as the actual format string.','line_number':4291,'multiline':False]['text':' The cursor in windows other than the current one isn't always','line_number':4311,'multiline':False]['text':' up-to-date, esp. because of autocommands and timers.','line_number':4312,'multiline':False]['text':' Get line & check if empty (cursorpos will show "0-1").  Note that','line_number':4320,'multiline':False]['text':' p will become invalid when getting another buffer line.','line_number':4321,'multiline':False]['text':' Get the byte value now, in case we need it below. This is more efficient','line_number':4325,'multiline':False]['text':' than making a copy of the line.','line_number':4326,'multiline':False]['text':' Line may have changed since checking the cursor column, or the lnum','line_number':4330,'multiline':False]['text':' was adjusted above.','line_number':4331,'multiline':False]['text':'
	 * Handle up to the next '%' or the end.
	 ','line_number':4388,'multiline':True]['text':'
	 * Handle one '%' item.
	 ','line_number':4396,'multiline':True]['text':' ignore trailing %','line_number':4400,'multiline':False]['text':' STL_SEPARATE: Separation between items, filled with white space.','line_number':4410,'multiline':False]['text':' remove group if all items are empty and highlight group','line_number':4440,'multiline':False]['text':' doesn't change','line_number':4441,'multiline':False]['text':' empty group','line_number':4461,'multiline':False]['text':' do not use the highlighting from the removed group','line_number':4466,'multiline':False]['text':' adjust the start position of TabPage to the next','line_number':4469,'multiline':False]['text':' item position','line_number':4470,'multiline':False]['text':' truncate, remove n bytes of text at the start','line_number':4478,'multiline':False]['text':' Find the first character that should be included.','line_number':4481,'multiline':False]['text':' Fill up space left over by half a double-wide char.','line_number':4497,'multiline':False]['text':' correct the start of the items for the truncation','line_number':4501,'multiline':False]['text':' Minus one for the leading '<' added above.','line_number':4504,'multiline':False]['text':' fill','line_number':4512,'multiline':False]['text':' fill by appending characters','line_number':4516,'multiline':False]['text':' fill by inserting characters','line_number':4523,'multiline':False]['text':' overflow','line_number':4554,'multiline':False]['text':' %X ends the close label, go back to the previously','line_number':4572,'multiline':False]['text':' define tab label nr.','line_number':4573,'multiline':False]['text':' close nrs are stored as negative values','line_number':4583,'multiline':False]['text':' overflow','line_number':4599,'multiline':False]['text':' Denotes end of expanded %{} block','line_number':4616,'multiline':False]['text':' can happen with "%0"','line_number':4626,'multiline':False]['text':' OK - now for the real work','line_number':4633,'multiline':False]['text':' don't change ' ' to fillchar','line_number':4644,'multiline':False]['text':' '{'','line_number':4660,'multiline':False]['text':' missing '}' or out of space','line_number':4674,'multiline':False]['text':' remove the % at the end of %{% expr %}','line_number':4678,'multiline':False]['text':' Visual mode is only valid in the current window.','line_number':4694,'multiline':False]['text':' If the output of the expression needs to be evaluated','line_number':4716,'multiline':False]['text':' replace the %{} block with the result of evaluation','line_number':4717,'multiline':False]['text':' Don't display %V if it's the same as %c.','line_number':4768,'multiline':False]['text':' FALLTHROUGH','line_number':4817,'multiline':False]['text':' FALLTHROUGH','line_number':4829,'multiline':False]['text':' Don't put a "-" in front of a digit.','line_number':4959,'multiline':False]['text':' Change a space by fillchar, unless fillchar is '-' and a','line_number':4971,'multiline':False]['text':' digit follows.','line_number':4972,'multiline':False]['text':' not sufficient space','line_number':4988,'multiline':False]['text':' Item not NULL, but not a flag','line_number':5029,'multiline':False]['text':'','line_number':5030,'multiline':False]['text':' Result is too long, must truncate somewhere.','line_number':5046,'multiline':False]['text':' Truncate at %< item.','line_number':5055,'multiline':False]['text':' No %< item, truncate first item.','line_number':5061,'multiline':False]['text':' Truncation mark is beyond max length','line_number':5069,'multiline':False]['text':' Fill up for half a double-wide character.','line_number':5081,'multiline':False]['text':' count the '<'','line_number':5111,'multiline':False]['text':' Fill up for half a double-wide character.','line_number':5120,'multiline':False]['text':' Find how many separators there are, which we will use when','line_number':5132,'multiline':False]['text':' figuring out how many groups there are.','line_number':5133,'multiline':False]['text':' Create an array of the start location for each separator','line_number':5140,'multiline':False]['text':' mark.','line_number':5141,'multiline':False]['text':' If we have separated groups, then we deal with it now','line_number':5147,'multiline':False]['text':' Store the info about highlighting.','line_number':5175,'multiline':False]['text':' Store the info about tab pages labels.','line_number':5193,'multiline':False]['text':' A user function may reset KeyTyped, restore it.','line_number':5213,'multiline':False]['text':' Check for an error.  If there is one the display will be messed up and','line_number':5216,'multiline':False]['text':' might loop redrawing.  Avoid that by making the corresponding option','line_number':5217,'multiline':False]['text':' empty.','line_number':5218,'multiline':False]['text':' TODO: find out why using called_emsg_before makes tests fail, does it','line_number':5219,'multiline':False]['text':' matter?','line_number':5220,'multiline':False]['text':' if (called_emsg > called_emsg_before)','line_number':5221,'multiline':False]['text':' FEAT_STL_OPT','line_number':5228,'multiline':False]['text':'
 * Get relative cursor position in window into "buf[buflen]", in the localized
 * percentage form like %99, 99%; using "Top", "Bot" or "All" when appropriate.
 ','line_number':5230,'multiline':True]['text':' number of lines above window','line_number':5240,'multiline':False]['text':' number of lines below window','line_number':5241,'multiline':False]['text':' need at least 3 chars for writing','line_number':5243,'multiline':False]['text':' All buffer lines are displayed and there is an','line_number':5249,'multiline':False]['text':' indication of filler lines, that can be considered','line_number':5250,'multiline':False]['text':' seeing all lines.','line_number':5251,'multiline':False]['text':' prepend one space','line_number':5269,'multiline':False]['text':' localized percentage value','line_number':5274,'multiline':False]['text':'
 * Append (file 2 of 8) to "buf[buflen]", if editing more than one file.
 * Return TRUE if it was appended.
 ','line_number':5279,'multiline':True]['text':' Add "file" before the arg number','line_number':5288,'multiline':False]['text':' nothing to do','line_number':5290,'multiline':False]['text':' go to the end of the buffer','line_number':5302,'multiline':False]['text':'
 * If fname is not a full path, make it a full path.
 * Returns pointer to allocated memory (NULL for failure).
 ','line_number':5308,'multiline':True]['text':'
     * Force expanding the path always for Unix, because symbolic links may
     * mess up the full path name, even though it starts with a '/'.
     * Also expand when there is ".." in the file name, try to remove it,
     * because "c:/src/../README" is equal to "c:/README".
     * Similarly "c:/src//file" is equal to "c:/src/file".
     * For MS-Windows also expand names like "longna~1" to "longname".
     ','line_number':5315,'multiline':True]['text':' set correct case for file name','line_number':5342,'multiline':False]['text':'
 * Make "*ffname" a full file name, set "*sfname" to "*ffname" if not NULL.
 * "*ffname" becomes a pointer to allocated memory (or NULL).
 * When resolving a link both "*sfname" and "*ffname" will point to the same
 * allocated memory.
 * The "*ffname" and "*sfname" pointer values on call will not be freed.
 * Note that the resulting "*ffname" pointer should be considered not allocated.
 ','line_number':5349,'multiline':True]['text':' no file name given, nothing to do','line_number':5363,'multiline':False]['text':' no short file name given, use ffname','line_number':5365,'multiline':False]['text':' expand to full path','line_number':5367,'multiline':False]['text':' If the file name is a shortcut file, use the file it links to.','line_number':5374,'multiline':False]['text':'
 * Open a window for a number of buffers.
 ','line_number':5386,'multiline':True]['text':' Maximum number of windows to open.','line_number':5398,'multiline':False]['text':' When TRUE also load inactive buffers.','line_number':5399,'multiline':False]['text':' make as many windows as possible','line_number':5403,'multiline':False]['text':' make as many windows as specified','line_number':5406,'multiline':False]['text':' Stop Visual mode, the cursor and "VIsual" may very well be invalid after','line_number':5412,'multiline':False]['text':' switching to another buffer.','line_number':5413,'multiline':False]['text':'
     * Close superfluous windows (two windows for the same buffer).
     * Also close windows that are not full-width.
     ','line_number':5422,'multiline':True]['text':' Just in case an autocommand does something strange with','line_number':5446,'multiline':False]['text':' windows: start all over...','line_number':5447,'multiline':False]['text':' Without the ":tab" modifier only do the current tab page.','line_number':5456,'multiline':False]['text':'
     * Go through the buffer list.  When a buffer doesn't have a window yet,
     * open one.  Otherwise move the window to the right position.
     * Watch out for autocommands that delete buffers or windows!
     ','line_number':5462,'multiline':True]['text':' Don't execute Win/Buf Enter/Leave autocommands here.','line_number':5467,'multiline':False]['text':' Check if this buffer needs a window','line_number':5473,'multiline':False]['text':' With the ":tab" modifier don't move the window.','line_number':5479,'multiline':False]['text':' buffer has a window, skip it','line_number':5481,'multiline':False]['text':' Check if this buffer already has a window','line_number':5487,'multiline':False]['text':' If the buffer already has a window, move it','line_number':5491,'multiline':False]['text':' Split the window and put the buffer in it','line_number':5502,'multiline':False]['text':' use space from all windows','line_number':5504,'multiline':False]['text':' Open the buffer in this window.','line_number':5511,'multiline':False]['text':' autocommands deleted the buffer!!!','line_number':5516,'multiline':False]['text':' Reset the error/interrupt/exception state here so that','line_number':5525,'multiline':False]['text':' aborting() returns FALSE when closing a window.','line_number':5526,'multiline':False]['text':' User selected Quit at ATTENTION prompt; close this window.','line_number':5530,'multiline':False]['text':' Restore the error/interrupt/exception state if not','line_number':5537,'multiline':False]['text':' discarded by a new aborting error, interrupt, or uncaught','line_number':5538,'multiline':False]['text':' exception.','line_number':5539,'multiline':False]['text':' only break the file loading, not the rest','line_number':5550,'multiline':False]['text':' Autocommands deleted the buffer or aborted script processing!!!','line_number':5554,'multiline':False]['text':' When ":tab" was used open a new tab for a new window repeatedly.','line_number':5558,'multiline':False]['text':' back to first window','line_number':5563,'multiline':False]['text':'
     * Close superfluous windows.
     ','line_number':5566,'multiline':True]['text':' BufWrite Autocommands made the window invalid, start over','line_number':5575,'multiline':False]['text':'
 * do_modelines() - process mode lines for the current file
 *
 * "flags" can be:
 * OPT_WINONLY	    only set options local to window
 * OPT_NOWIN	    don't set options local to window
 *
 * Returns immediately if the "ml" option isn't set.
 ','line_number':5596,'multiline':True]['text':' Disallow recursive entry here.  Can happen when executing a modeline','line_number':5615,'multiline':False]['text':' triggers an autocommand, which reloads modelines with a ":do".','line_number':5616,'multiline':False]['text':' for version number','line_number':5633,'multiline':False]['text':'
 * chk_modeline() - check a single line for a mode string
 * Return FAIL if an error encountered.
 ','line_number':5635,'multiline':True]['text':' Same as for do_modelines().','line_number':5642,'multiline':False]['text':' local copy of any modeline found','line_number':5646,'multiline':False]['text':' Accept both "vim" and "Vim".','line_number':5662,'multiline':False]['text':' skip over "ex:", "vi:" or "vim:"','line_number':5686,'multiline':False]['text':' copy the line, it will change','line_number':5690,'multiline':False]['text':' prepare for emsg()','line_number':5694,'multiline':False]['text':'
	     * Find end of set command: ':' or end of line.
	     * Skip over "\:", replacing it with ":".
	     ','line_number':5705,'multiline':True]['text':'
	     * If there is a "set" command, require a terminating ':' and
	     * ignore the stuff after the ':'.
	     * "vi:set opt opt opt: foo" -- foo not interpreted
	     * "vi:opt opt opt: foo" -- foo interpreted
	     * Accept "se" for compatibility with Elvis.
	     ','line_number':5715,'multiline':True]['text':' no terminating ':'?','line_number':5725,'multiline':False]['text':' truncate the set command','line_number':5730,'multiline':False]['text':' skip over an empty "::"','line_number':5732,'multiline':False]['text':' Make sure no risky things are executed as a side effect.','line_number':5744,'multiline':False]['text':' stop if error found','line_number':5751,'multiline':False]['text':' advance to next part','line_number':5754,'multiline':False]['text':'
 * Return TRUE if "buf" is a normal buffer, 'buftype' is empty.
 ','line_number':5764,'multiline':True]['text':'
 * Return TRUE if "buf" is the quickfix buffer.
 ','line_number':5773,'multiline':True]['text':'
 * Return TRUE if "buf" is a terminal buffer.
 ','line_number':5786,'multiline':True]['text':'
 * Return TRUE if "buf" is a help buffer.
 ','line_number':5799,'multiline':True]['text':'
 * Return TRUE if "buf" is a prompt buffer.
 ','line_number':5808,'multiline':True]['text':'
 * Return TRUE if "buf" is a buffer for a popup window.
 ','line_number':5818,'multiline':True]['text':'
 * Return TRUE if "buf" is a "nofile", "acwrite", "terminal" or "prompt"
 * buffer.  This means the buffer name may not be a file name, at least not for
 * writing the buffer.
 ','line_number':5829,'multiline':True]['text':'
 * Return TRUE if "buf" is a "nofile", "quickfix", "terminal" or "prompt"
 * buffer.  This means the buffer is not to be read from a file.
 ','line_number':5843,'multiline':True]['text':'
 * Return TRUE if "buf" has 'buftype' set to "nofile".
 ','line_number':5857,'multiline':True]['text':'
 * Return TRUE if "buf" is a "nowrite", "nofile", "terminal", "prompt", or
 * "popup" buffer.
 ','line_number':5867,'multiline':True]['text':'
 * Return TRUE if the buffer should be hidden, according to 'hidden', ":hide"
 * and 'bufhidden'.
 ','line_number':5890,'multiline':True]['text':' 'bufhidden' overrules 'hidden' and ":hide", check it first','line_number':5897,'multiline':False]['text':' "unload"','line_number':5900,'multiline':False]['text':' "wipe"','line_number':5901,'multiline':False]['text':' "delete"','line_number':5902,'multiline':False]['text':' "hide"','line_number':5903,'multiline':False]['text':'
 * Return special buffer name.
 * Returns NULL when the buffer has a normal file name.
 ','line_number':5908,'multiline':True]['text':'
	 * Differentiate between the quickfix and location list buffers using
	 * the buffer number stored in the global quickfix stack.
	 ','line_number':5918,'multiline':True]['text':' There is no _file_ when 'buftype' is "nofile", b_sfname','line_number':5929,'multiline':False]['text':' contains the name as specified by the user.','line_number':5930,'multiline':False]['text':'
 * Get "buf->b_fname", use "[No Name]" if it is NULL.
 ','line_number':5955,'multiline':True]['text':'
 * Set 'buflisted' for curbuf to "on" and trigger autocommands if it changed.
 ','line_number':5966,'multiline':True]['text':'
 * Read the file for "buf" again and check if the contents changed.
 * Return TRUE if it changed or this could not be checked.
 ','line_number':5982,'multiline':True]['text':' Allocate a buffer without putting it in the buffer list.','line_number':5995,'multiline':False]['text':' Force the 'fileencoding' and 'fileformat' to be equal.','line_number':6000,'multiline':False]['text':' Set curwin/curbuf to buf and save a few things.','line_number':6007,'multiline':False]['text':' Failed to find a window for "newbuf".','line_number':6011,'multiline':False]['text':' We don't want to trigger autocommands now, they may have nasty','line_number':6016,'multiline':False]['text':' side-effects like wiping buffers','line_number':6017,'multiline':False]['text':' compare the two files line by line','line_number':6024,'multiline':False]['text':' restore curwin/curbuf and a few other things','line_number':6038,'multiline':False]['text':' safety check','line_number':6041,'multiline':False]['text':'
 * Wipe out a buffer and decrement the last buffer number if it was used for
 * this buffer.  Call this to wipe out a temp buffer that does not contain any
 * marks.
 ','line_number':6049,'multiline':True]['text':' When TRUE trigger autocommands.','line_number':6057,'multiline':False]['text':' Don't trigger BufDelete autocommands here.','line_number':6062,'multiline':False]