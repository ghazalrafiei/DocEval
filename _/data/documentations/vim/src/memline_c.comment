['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]['text':' for debugging','line_number':10,'multiline':False]['text':' #define CHECK(c, s)	do { if (c) emsg((s)); } while (0)','line_number':11,'multiline':False]['text':'','line_number':12,'multiline':True]['text':'
 * memline.c: Contains the functions for appending, deleting and changing the
 * text lines. The memfile functions are used to store the information in
 * blocks of memory, backed up by a file. The structure of the information is
 * a tree.  The root of the tree is a pointer block. The leaves of the tree
 * are data blocks. In between may be several layers of pointer blocks,
 * forming branches.
 *
 * Three types of blocks are used:
 * - Block nr 0 contains information for recovery
 * - Pointer blocks contain list of pointers to other blocks.
 * - Data blocks contain the actual text.
 *
 * Block nr 0 contains the block0 structure (see below).
 *
 * Block nr 1 is the first pointer block. It is the root of the tree.
 * Other pointer blocks are branches.
 *
 *  If a line is too big to fit in a single page, the block containing that
 *  line is made big enough to hold the line. It may span several pages.
 *  Otherwise all blocks are one page.
 *
 *  A data block that was filled when starting to edit a file and was not
 *  changed since then, can have a negative block number. This means that it
 *  has not yet been assigned a place in the file. When recovering, the lines
 *  in this data block can be read from the original file. When the block is
 *  changed (lines appended/deleted/changed) or when it is flushed it gets a
 *  positive number. Use mf_trans_del() to get the new number, before calling
 *  mf_get().
 ','line_number':14,'multiline':True]['text':' it's in os_unix.h for Unix','line_number':47,'multiline':False]['text':' for Open() and Close()','line_number':52,'multiline':False]['text':' contents of the first block','line_number':55,'multiline':False]['text':' contents of a pointer block','line_number':56,'multiline':False]['text':' contents of a data block','line_number':57,'multiline':False]['text':' block/line-count pair','line_number':58,'multiline':False]['text':' data block id','line_number':60,'multiline':False]['text':' pointer block id','line_number':61,'multiline':False]['text':' block 0 id 0','line_number':62,'multiline':False]['text':' block 0 id 1','line_number':63,'multiline':False]['text':' block 0 id 1 'cm' 0','line_number':64,'multiline':False]['text':' block 0 id 1 'cm' 1','line_number':65,'multiline':False]['text':' block 0 id 1 'cm' 2','line_number':66,'multiline':False]['text':' BLOCK0_ID1_C3 and BLOCK0_ID1_C4 are for libsodium encryption.  However, for','line_number':67,'multiline':False]['text':' these the swapfile is disabled, thus they will not be used.  Added for','line_number':68,'multiline':False]['text':' consistency anyway.','line_number':69,'multiline':False]['text':' block 0 id 1 'cm' 3','line_number':70,'multiline':False]['text':' block 0 id 1 'cm' 4','line_number':71,'multiline':False]['text':' CRYPT_M_ZIP','line_number':75,'multiline':False]['text':' CRYPT_M_BF','line_number':76,'multiline':False]['text':' CRYPT_M_BF2','line_number':77,'multiline':False]['text':' CRYPT_M_SOD  - Unused!','line_number':78,'multiline':False]['text':' CRYPT_M_SOD2  - Unused!','line_number':79,'multiline':False]['text':'
 * pointer to a block, used in a pointer block
 ','line_number':83,'multiline':True]['text':' block number','line_number':88,'multiline':False]['text':' number of lines in this branch','line_number':89,'multiline':False]['text':' lnum for this block (for recovery)','line_number':90,'multiline':False]['text':' number of pages in block pe_bnum','line_number':91,'multiline':False]['text':'
 * A pointer block contains a list of branches in the tree.
 ','line_number':94,'multiline':True]['text':' ID for pointer block: PTR_ID','line_number':99,'multiline':False]['text':' number of pointers in this block','line_number':100,'multiline':False]['text':' maximum value for pb_count','line_number':101,'multiline':False]['text':' list of pointers to blocks (actually longer)','line_number':102,'multiline':False]['text':' followed by empty space until end of page','line_number':103,'multiline':False]['text':' Value for pb_count_max.','line_number':106,'multiline':False]['text':'
 * A data block is a leaf in the tree.
 *
 * The text of the lines is at the end of the block. The text of the first line
 * in the block is put at the end, the text of the second line in front of it,
 * etc. Thus the order of the lines is the opposite of the line number.
 ','line_number':109,'multiline':True]['text':' ID for data block: DATA_ID','line_number':118,'multiline':False]['text':' free space available','line_number':119,'multiline':False]['text':' byte where text starts','line_number':120,'multiline':False]['text':' byte just after data block','line_number':121,'multiline':False]['text':' number of lines in this block','line_number':122,'multiline':False]['text':' index for start of line (actually bigger)','line_number':123,'multiline':False]['text':' followed by empty space up to db_txt_start','line_number':124,'multiline':False]['text':' followed by the text in the lines until','line_number':125,'multiline':False]['text':' end of page','line_number':126,'multiline':False]['text':'
 * The low bits of db_index hold the actual index. The topmost bit is
 * used for the global command to be able to mark a line.
 * This method is not clean, but otherwise there would be at least one extra
 * byte used for each line.
 * The mark has to be in this place to keep it with the correct line when other
 * lines are inserted or deleted.
 ','line_number':129,'multiline':True]['text':' size of one db_index entry','line_number':140,'multiline':False]['text':' size of data block header','line_number':141,'multiline':False]['text':' what it was in older versions','line_number':143,'multiline':False]['text':' 2 bytes used for other things','line_number':144,'multiline':False]['text':' 10 bytes used for other things','line_number':145,'multiline':False]['text':'
 * Restrict the numbers to 32 bits, otherwise most compilers will complain.
 * This won't detect a 64 bit machine that only swaps a byte in the top 32
 * bits, but that is crazy anyway.
 ','line_number':148,'multiline':True]['text':'
 * Block zero holds all info about the swap file.
 *
 * NOTE: DEFINITION OF BLOCK 0 SHOULD NOT CHANGE! It would make all existing
 * swap files unusable!
 *
 * If size of block0 changes anyway, adjust MIN_SWAP_PAGE_SIZE in vim.h!!
 *
 * This block is built up of single bytes, to make it portable across
 * different machines. b0_magic_* is used to check the byte order and size of
 * variables, because the rest of the swap file is not portable.
 ','line_number':158,'multiline':True]['text':' id for block 0: BLOCK0_ID0 and BLOCK0_ID1,','line_number':172,'multiline':False]['text':' BLOCK0_ID1_C0, BLOCK0_ID1_C1, etc.','line_number':173,'multiline':False]['text':' Vim version string','line_number':174,'multiline':False]['text':' number of bytes per page','line_number':175,'multiline':False]['text':' last modification time of file','line_number':176,'multiline':False]['text':' inode of b0_fname','line_number':177,'multiline':False]['text':' process id of creator (or 0)','line_number':178,'multiline':False]['text':' name of user (uid if no name)','line_number':179,'multiline':False]['text':' host name (if it has a name)','line_number':180,'multiline':False]['text':' name of file being edited','line_number':181,'multiline':False]['text':' check for byte order of long','line_number':182,'multiline':False]['text':' check for byte order of int','line_number':183,'multiline':False]['text':' check for byte order of short','line_number':184,'multiline':False]['text':' check for last char','line_number':185,'multiline':False]['text':'
 * Note: b0_dirty and b0_flags are put at the end of the file name.  For very
 * long file names in older versions of Vim they are invalid.
 * The 'fileencoding' comes before b0_flags, with a NUL in front.  But only
 * when there is room, for very long file names it's omitted.
 ','line_number':188,'multiline':True]['text':'
 * The b0_flags field is new in Vim 7.0.
 ','line_number':197,'multiline':True]['text':'
 * Crypt seed goes here, 8 bytes.  New in Vim 7.3.
 * Without encryption these bytes may be used for 'fenc'.
 ','line_number':202,'multiline':True]['text':' The lowest two bits contain the fileformat.  Zero means it's not set','line_number':208,'multiline':False]['text':' (compatible with Vim 6.x), otherwise it's EOL_UNIX + 1, EOL_DOS + 1 or','line_number':209,'multiline':False]['text':' EOL_MAC + 1.','line_number':210,'multiline':False]['text':' Swap file is in directory of edited file.  Used to find the file from','line_number':213,'multiline':False]['text':' different mount points.','line_number':214,'multiline':False]['text':' The 'fileencoding' is at the end of b0_fname[], with a NUL in front of it.','line_number':217,'multiline':False]['text':' When empty there is only the NUL.','line_number':218,'multiline':False]['text':' nr of entries added to ml_stack at a time','line_number':221,'multiline':False]['text':'
 * The line number where the first mark may be is remembered.
 * If it is 0 there are no marks at all.
 * (always used for the current buffer only, no buffer change possible while
 * executing a global command).
 ','line_number':223,'multiline':True]['text':'
 * arguments for ml_find_line()
 ','line_number':231,'multiline':True]['text':' delete line','line_number':234,'multiline':False]['text':' insert line','line_number':235,'multiline':False]['text':' just find the line','line_number':236,'multiline':False]['text':' flush locked block','line_number':237,'multiline':False]['text':' DEL, INS or FIND','line_number':238,'multiline':False]['text':' argument for ml_upd_block0()','line_number':240,'multiline':False]['text':' update timestamp and filename','line_number':242,'multiline':False]['text':' update the B0_SAME_DIR flag','line_number':243,'multiline':False]['text':' update crypt key','line_number':244,'multiline':False]['text':'
 * Open a new memline for "buf".
 *
 * Return FAIL for failure, OK otherwise.
 ','line_number':276,'multiline':True]['text':'
     * init fields in memline struct
     ','line_number':290,'multiline':True]['text':' no stack yet','line_number':293,'multiline':False]['text':' no stack yet','line_number':294,'multiline':False]['text':' nothing in the stack','line_number':295,'multiline':False]['text':' no cached block','line_number':296,'multiline':False]['text':' no cached line','line_number':297,'multiline':False]['text':'
     * When 'updatecount' is non-zero swap file may be opened later.
     ','line_number':306,'multiline':True]['text':'
     * Open the memfile.  No swap file is created yet.
     ','line_number':314,'multiline':True]['text':'
 * fill block0 struct and write page 0
 ','line_number':328,'multiline':True]['text':'
     * Always sync block number 0 to disk, so we can check the file name in
     * the swap file in findswapname(). Don't do this for a help files or
     * a spell buffer though.
     * Only works when there's a swapfile, otherwise it's done when the file
     * is created.
     ','line_number':367,'multiline':True]['text':'
     * Fill in root pointer block and write page 1.
     ','line_number':378,'multiline':True]['text':' line count after insertion','line_number':393,'multiline':False]['text':'
     * Allocate first data block and create an empty line 1.
     ','line_number':396,'multiline':True]['text':' at end of block','line_number':408,'multiline':False]['text':' empty line','line_number':411,'multiline':False]['text':' will also free(mfp->mf_fname)','line_number':420,'multiline':False]['text':'
 * Swapfile encryption is not supported by XChaCha20.  If this crypt method is
 * used then disable the swapfile, to avoid plain text being written to disk,
 * and return TRUE.
 * Otherwise return FALSE.
 ','line_number':427,'multiline':True]['text':'
 * Prepare encryption for "buf" for the current key and method.
 ','line_number':445,'multiline':True]['text':' Generate a seed and store it in the memfile.','line_number':458,'multiline':False]['text':'
 * Prepare encryption for "buf" with block 0 "b0p".
 * Note: should not be called with libsodium encryption, since xchacha20 does
 * not support swapfile encryption.
 ','line_number':467,'multiline':True]['text':' Generate a seed and store it in block 0 and in the memfile.','line_number':484,'multiline':False]['text':'
 * Called after the crypt key or 'cryptmethod' was changed for "buf".
 * Will apply this to the swapfile.
 * "old_key" is the previous key.  It is equal to buf->b_p_key when
 * 'cryptmethod' is changed.
 * "old_cm" is the previous 'cryptmethod'.  It is equal to the current
 * 'cryptmethod' when 'key' is changed.
 ','line_number':491,'multiline':True]['text':' no memfile yet, nothing to do','line_number':518,'multiline':False]['text':' First make sure the swapfile is in a consistent state, using the old','line_number':526,'multiline':False]['text':' key and method.','line_number':527,'multiline':False]['text':' Set the key, method and seed to be used for reading, these must be the','line_number':539,'multiline':False]['text':' old values.','line_number':540,'multiline':False]['text':' Update block 0 with the crypt flag and may set a new seed.','line_number':546,'multiline':False]['text':'
	 * Need to read back all data blocks from disk, decrypt them with the
	 * old key/method and mark them to be written. The algorithm is
	 * similar to what happens in ml_recover(), but we skip negative block
	 * numbers.
	 ','line_number':551,'multiline':True]['text':' flush buffered line','line_number':557,'multiline':False]['text':' flush locked block','line_number':558,'multiline':False]['text':' start with block 1','line_number':561,'multiline':False]['text':' which is 1 page','line_number':562,'multiline':False]['text':' start with first index in block 1','line_number':563,'multiline':False]['text':' no stack yet','line_number':567,'multiline':False]['text':' release previous block','line_number':572,'multiline':False]['text':' get the block (pointer or data)','line_number':574,'multiline':False]['text':' it is a pointer block','line_number':584,'multiline':False]['text':' empty block?','line_number':588,'multiline':False]['text':' go a block deeper','line_number':591,'multiline':False]['text':' Skip data block with negative block number.','line_number':595,'multiline':False]['text':' Should not happen, because of the ml_preserve()','line_number':596,'multiline':False]['text':' above. Get same block again for next index.','line_number':597,'multiline':False]['text':' going one block deeper in the tree, new entry in','line_number':602,'multiline':False]['text':' stack','line_number':603,'multiline':False]['text':' out of memory','line_number':607,'multiline':False]['text':' not a pointer block','line_number':619,'multiline':False]['text':' block id wrong','line_number':622,'multiline':False]['text':' It is a data block, need to write it back to disk.','line_number':626,'multiline':False]['text':' finished','line_number':633,'multiline':False]['text':' go one block up in the tree','line_number':636,'multiline':False]['text':' go to next index','line_number':639,'multiline':False]['text':' release previous block','line_number':643,'multiline':False]['text':'
 * ml_setname() is called when the file name of "buf" has been changed.
 * It may rename the swap file.
 ','line_number':653,'multiline':True]['text':' there is no swap file yet','line_number':669,'multiline':False]['text':'
	 * When 'updatecount' is 0 and 'noswapfile' there is no swap file.
	 * For help files we will make a swap file now.
	 ','line_number':671,'multiline':True]['text':' create a swap file','line_number':676,'multiline':False]['text':'
     * Try all directories in the 'directory' option.
     ','line_number':680,'multiline':True]['text':' tried all directories, fail','line_number':686,'multiline':False]['text':' alloc's fname','line_number':689,'multiline':False]['text':' out of memory','line_number':690,'multiline':False]['text':' no file name found for this dir','line_number':692,'multiline':False]['text':'
	 * Set full pathname for swap file now, because a ":!cd dir" may
	 * change directory without us knowing it.
	 ','line_number':696,'multiline':True]['text':' if the file name is the same we don't have to do anything','line_number':706,'multiline':False]['text':' need to close the swap file before renaming','line_number':713,'multiline':False]['text':' try to rename the swap file','line_number':720,'multiline':False]['text':' mf_fname is full pathname already','line_number':728,'multiline':False]['text':' this fname didn't work, try another','line_number':735,'multiline':False]['text':' need to (re)open the swap file','line_number':738,'multiline':False]['text':' could not (re)open the swap file, what can we do????','line_number':743,'multiline':False]['text':'
 * Open a file for the memfile for all buffers that are not readonly or have
 * been modified.
 * Used when 'updatecount' changes from zero to non-zero.
 ','line_number':759,'multiline':True]['text':'
 * Open a swap file for an existing memfile, if there is no swap file yet.
 * If we are unable to find a file name, mf_fname will be NULL
 * and the memfile will be in memory only (no recovery possible).
 ','line_number':774,'multiline':True]['text':' nothing to do','line_number':789,'multiline':False]['text':' For a spell buffer use a temp file name.','line_number':792,'multiline':False]['text':' consumes fname!','line_number':797,'multiline':False]['text':'
     * Try all directories in 'directory' option.
     ','line_number':803,'multiline':True]['text':' There is a small chance that between choosing the swap file name','line_number':811,'multiline':False]['text':' and creating it, another Vim creates the file.  In that case the','line_number':812,'multiline':False]['text':' creation will fail and we will use another directory.','line_number':813,'multiline':False]['text':' allocates fname','line_number':814,'multiline':False]['text':' out of memory','line_number':816,'multiline':False]['text':' consumes fname!','line_number':819,'multiline':False]['text':' don't sync yet in ml_sync_all()','line_number':821,'multiline':False]['text':'
	     * set full pathname for swap file now, because a ":!cd dir" may
	     * change directory without us knowing it.
	     ','line_number':824,'multiline':True]['text':' Flush block zero, so others can read it','line_number':832,'multiline':False]['text':' Mark all blocks that should be in the swapfile as dirty.','line_number':835,'multiline':False]['text':' Needed for when the 'swapfile' option was reset, so that','line_number':836,'multiline':False]['text':' the swap file was deleted, and then on again.','line_number':837,'multiline':False]['text':' Writing block 0 failed: close the file and try another dir','line_number':841,'multiline':False]['text':' call wait_return() later','line_number':848,'multiline':False]['text':' don't try to open a swap file again','line_number':855,'multiline':False]['text':'
 * If still need to create a swap file, and starting to edit a not-readonly
 * file, or reading into an existing buffer, create a swap file now.
 ','line_number':859,'multiline':True]['text':' reading file into new buffer','line_number':865,'multiline':False]['text':' might be reset by an E325 message','line_number':867,'multiline':False]['text':'
 * Close memline for buffer 'buf'.
 * If 'del_file' is TRUE, delete the swap file
 ','line_number':874,'multiline':True]['text':' not open','line_number':881,'multiline':False]['text':' close the .swp file','line_number':883,'multiline':False]['text':' Reset the "recovered" flag, give the ATTENTION prompt the next time','line_number':893,'multiline':False]['text':' this buffer is loaded.','line_number':894,'multiline':False]['text':'
 * Close all existing memlines and memfiles.
 * Only used when exiting.
 * When 'del_file' is TRUE, delete the memfiles.
 * But don't delete files that were ":preserve"d when we are POSIX compatible.
 ','line_number':898,'multiline':True]['text':' delete the internal wordlist','line_number':913,'multiline':False]['text':' delete created temp directory','line_number':916,'multiline':False]['text':'
 * Close all memfiles for not modified buffers.
 * Only use just before exiting!
 ','line_number':920,'multiline':True]['text':' close all not-modified buffers','line_number':931,'multiline':False]['text':'
 * Update the timestamp in the .swp file.
 * Used when the file has been written.
 ','line_number':934,'multiline':True]['text':'
 * Return FAIL when the ID of "b0p" is wrong.
 ','line_number':944,'multiline':True]['text':'
 * Update the timestamp or the B0_SAME_DIR flag of the .swp file.
 ','line_number':962,'multiline':True]['text':' Possibly update the seed in the memfile before there is a block0.','line_number':979,'multiline':False]['text':' what == UB_SAME_DIR','line_number':997,'multiline':False]['text':'
 * Write file name and timestamp into block 0 of a swap file.
 * Also set buf->b_mtime.
 * Don't use NameBuff[]!!!
 ','line_number':1003,'multiline':True]['text':' Systems that cannot translate "~user" back into a path: copy the','line_number':1018,'multiline':False]['text':' file name unmodified.  Do use slashes instead of backslashes for','line_number':1019,'multiline':False]['text':' portability.','line_number':1020,'multiline':False]['text':'
	 * For a file under the home directory of the current user, we try to
	 * replace the home directory path with "~user". This helps when
	 * editing the same file on different machines over a network.
	 * First replace home dir path with "~/" with home_replace().
	 * Then insert the user name to get "~user/".
	 ','line_number':1029,'multiline':True]['text':' If there is no user name or it is too long, don't use "~/"','line_number':1041,'multiline':False]['text':' Also add the 'fileencoding' if there is room.','line_number':1078,'multiline':False]['text':'
 * Update the B0_SAME_DIR flag of the swap file.  It's set if the file and the
 * swapfile for "buf" are in the same directory.
 * This is fail safe: if we are not sure the directories are equal the flag is
 * not set.
 ','line_number':1082,'multiline':True]['text':'
 * When there is room, add the 'fileencoding' to block zero.
 ','line_number':1097,'multiline':True]['text':' Without encryption use the same offset as in Vim 7.2 to be compatible.','line_number':1109,'multiline':False]['text':' With encryption it's OK to move elsewhere, the swap file is not','line_number':1110,'multiline':False]['text':' compatible anyway.','line_number':1111,'multiline':False]['text':'
 * Return TRUE if the process with number "b0p->b0_pid" is still running.
 * "swap_fname" is the name of the swap file, if it's from before a reboot then
 * the result is FALSE;
 ','line_number':1133,'multiline':True]['text':' If the system rebooted after when the swap file was written then the','line_number':1145,'multiline':False]['text':' process can't be running now.','line_number':1146,'multiline':False]['text':'
 * Try to recover curbuf from the .swp file.
 * If "checkext" is TRUE, check the extension and detect whether it is
 * a swap file.
 ','line_number':1160,'multiline':True]['text':'
     * If the file name ends in ".s[a-w][a-z]" we assume this is the swap file.
     * Otherwise a search is done to find the swap file(s).
     ','line_number':1208,'multiline':True]['text':' When there is no file name','line_number':1213,'multiline':False]['text':' make a copy for mf_open()','line_number':1228,'multiline':False]['text':' count the number of matching swap files','line_number':1234,'multiline':False]['text':' no swap files found','line_number':1236,'multiline':False]['text':' one swap file found, use it','line_number':1241,'multiline':False]['text':' several swap files found, choose','line_number':1243,'multiline':False]['text':' list the names of the swap files','line_number':1245,'multiline':False]['text':' get the swap file name that will be used','line_number':1253,'multiline':False]['text':' out of memory','line_number':1257,'multiline':False]['text':' When called from main() still need to initialize storage structure','line_number':1259,'multiline':False]['text':'
     * Allocate a buffer structure for the swap file that is used for recovery.
     * Only the memline and crypt information in it are really used.
     ','line_number':1263,'multiline':True]['text':'
     * init fields in memline struct
     ','line_number':1271,'multiline':True]['text':' no stack yet','line_number':1274,'multiline':False]['text':' no stack yet','line_number':1275,'multiline':False]['text':' nothing in the stack','line_number':1276,'multiline':False]['text':' no cached line','line_number':1277,'multiline':False]['text':' no locked block','line_number':1278,'multiline':False]['text':'
     * open the memfile from the old swap file
     ','line_number':1285,'multiline':True]['text':' save "fname_used" for the message:','line_number':1288,'multiline':False]['text':' mf_open() will consume "fname_used"!','line_number':1289,'multiline':False]['text':'
     * The page size set in mf_open() might be different from the page size
     * used in the swap file, we must get it from block 0.  But to read block
     * 0 we need a page size.  Use the minimal size for block 0 here, it will
     * be set to the real value below.
     ','line_number':1303,'multiline':True]['text':'
     * try to read block 0
     ','line_number':1311,'multiline':True]['text':' avoid going past the end of a corrupted hostname','line_number':1353,'multiline':False]['text':'
     * If we guessed the wrong page size, we have to recalculate the
     * highest block number in the file.
     ','line_number':1376,'multiline':True]['text':' no file or empty file','line_number':1395,'multiline':False]['text':' need to reallocate the memory used to store the data','line_number':1400,'multiline':False]['text':'
     * If .swp file name given directly, use name from swap file for buffer.
     ','line_number':1410,'multiline':True]['text':'
     * check date of swap file and original file
     ','line_number':1430,'multiline':True]['text':' Get the 'fileformat' and 'fileencoding' from block zero.','line_number':1442,'multiline':False]['text':' Use the same size as in add_b0_fenc().','line_number':1449,'multiline':False]['text':' release block 0','line_number':1458,'multiline':False]['text':'
     * Now that we are sure that the file is going to be recovered, clear the
     * contents of the current buffer.
     ','line_number':1461,'multiline':True]['text':'
     * Try reading the original file to obtain the values of 'fileformat',
     * 'fileencoding', etc.  Ignore errors.  The text itself is not used.
     * When the file is encrypted the user is asked to enter the key.
     ','line_number':1468,'multiline':True]['text':' Need to ask the user for the crypt key.  If this fails we continue','line_number':1480,'multiline':False]['text':' without a key, will probably get garbage text.','line_number':1481,'multiline':False]['text':' Use the 'fileformat' and 'fileencoding' as stored in the swap file.','line_number':1505,'multiline':False]['text':' start with block 1','line_number':1515,'multiline':False]['text':' which is 1 page','line_number':1516,'multiline':False]['text':' append after line 0 in curbuf','line_number':1517,'multiline':False]['text':' start with first index in block 1','line_number':1519,'multiline':False]['text':' no stack yet','line_number':1523,'multiline':False]['text':' release previous block','line_number':1534,'multiline':False]['text':'
	 * get block
	 ','line_number':1536,'multiline':True]['text':' there is a block','line_number':1550,'multiline':False]['text':' it is a pointer block','line_number':1553,'multiline':False]['text':' check line count when using pointer block first time','line_number':1569,'multiline':False]['text':' go a block deeper','line_number':1588,'multiline':False]['text':'
			 * Data block with negative block number.
			 * Try to read lines from the original file.
			 * This is slow, but it works.
			 ','line_number':1592,'multiline':True]['text':' get same block again for next index','line_number':1613,'multiline':False]['text':'
		     * going one block deeper in the tree
		     ','line_number':1617,'multiline':True]['text':' new entry in stack','line_number':1620,'multiline':False]['text':' out of memory','line_number':1623,'multiline':False]['text':' not a pointer block','line_number':1636,'multiline':False]['text':' block id wrong','line_number':1639,'multiline':False]['text':'
		     * It is a data block.
		     * Append all the lines in this block.
		     ','line_number':1653,'multiline':True]['text':' Check the length of the block.','line_number':1659,'multiline':False]['text':' If wrong, use the length given in the pointer block.','line_number':1660,'multiline':False]['text':' Make sure there is a NUL at the end of the block so we','line_number':1670,'multiline':False]['text':' don't go over the end when copying text.','line_number':1671,'multiline':False]['text':' Check the number of lines in the block.','line_number':1674,'multiline':False]['text':' If wrong, use the count in the data block.','line_number':1675,'multiline':False]['text':' line count must be wrong','line_number':1690,'multiline':False]['text':' avoid lots of lines with "???"','line_number':1703,'multiline':False]['text':' finished','line_number':1723,'multiline':False]['text':'
	 * go one block up in the tree
	 ','line_number':1726,'multiline':True]['text':' go to next index','line_number':1731,'multiline':False]['text':'
     * Compare the buffer contents with the original file.  When they differ
     * set the 'modified' flag.
     * Lines 1 - lnum are the new contents.
     * Lines lnum + 1 to ml_line_count are the original contents.
     * Line ml_line_count + 1 in the dummy empty line.
     ','line_number':1735,'multiline':True]['text':' Recovering an empty file results in two lines and the first line is','line_number':1744,'multiline':False]['text':' empty.  Don't set the modified flag then.','line_number':1745,'multiline':False]['text':' Need to copy one line, fetching the other one may flush it.','line_number':1756,'multiline':False]['text':'
     * Delete the lines from the original file and the dummy line from the
     * empty buffer.  These will now be after the last line in the buffer.
     ','line_number':1769,'multiline':True]['text':' Warn there could be an active Vim on the same file, the user may','line_number':1805,'multiline':False]['text':' want to kill it.','line_number':1806,'multiline':False]['text':' will also vim_free(mfp->mf_fname)','line_number':1830,'multiline':False]['text':'
 * Find the names of swap files in current directory and the directory given
 * with the 'directory' option.
 *
 * Used to:
 * - list the swap files for "vim -r"
 * - count the number of swap files when recovering
 * - list the swap files when recovering
 * - list the swap files for swapfilelist()
 * - find the name of the n'th swap file when recovering
 ','line_number':1851,'multiline':True]['text':' base for swap file name','line_number':1864,'multiline':False]['text':' when TRUE, list the swap file names','line_number':1865,'multiline':False]['text':' when not NULL add file names to it','line_number':1866,'multiline':False]['text':' when non-zero, return nr'th swap file name','line_number':1867,'multiline':False]['text':' result when "nr" > 0','line_number':1868,'multiline':False]['text':' Expand symlink in the file name, because the swap file is created','line_number':1887,'multiline':False]['text':' with the actual file instead of with the symlink.','line_number':1888,'multiline':False]['text':' use msg() to start the scrolling properly','line_number':1898,'multiline':False]['text':'
     * Do the loop for every directory in 'directory'.
     * First allocate some memory to put the directory name in.
     ','line_number':1903,'multiline':True]['text':'
	 * Isolate a directory name from *dirp and put it in dir_name (we know
	 * it is large enough, so use 31000 for length).
	 * Advance dirp to next directory name.
	 ','line_number':1911,'multiline':True]['text':' check current dir','line_number':1918,'multiline':False]['text':' For Unix names starting with a dot are special.  MS-Windows','line_number':1928,'multiline':False]['text':' supports this too, on some file systems.','line_number':1929,'multiline':False]['text':' check directory dir_name','line_number':1945,'multiline':False]['text':' For Unix names starting with a dot are special.  MS-Windows','line_number':1955,'multiline':False]['text':' supports this too, on some file systems.','line_number':1956,'multiline':False]['text':' Ends with '//', Use Full path for swap name','line_number':1977,'multiline':False]['text':' check for out-of-memory','line_number':1996,'multiline':False]['text':'
	 * When no swap file found, wildcard expansion might have failed (e.g.
	 * not able to execute the shell).
	 * Try finding a swap file by simply adding ".swp" to the file name.
	 ','line_number':2012,'multiline':True]['text':' It exists!','line_number':2031,'multiline':False]['text':'
	 * Remove swapfile name of the current buffer, it must be ignored.
	 * But keep it for swapfilelist().
	 ','line_number':2045,'multiline':True]['text':' Do not expand wildcards, on windows would try to expand','line_number':2054,'multiline':False]['text':' "%tmp%" in "%tmp%file".','line_number':2055,'multiline':False]['text':' Remove the name from files[i].  Move further entries','line_number':2058,'multiline':False]['text':' down.  When the array becomes empty free it here, since','line_number':2059,'multiline':False]['text':' FreeWild() won't be called below.','line_number':2060,'multiline':False]['text':' stop searching','line_number':2076,'multiline':False]['text':' print the swap file name','line_number':2099,'multiline':False]['text':'
 * Need _very_ long file names.
 * Append the full path to name with path separators made into percent
 * signs, to "dir". An unnamed buffer is handled as "" (<currentdir>/"")
 * The last character in "dir" must be an extra slash or backslash, it is
 * removed.
 ','line_number':2138,'multiline':True]['text':' remove one trailing slash','line_number':2162,'multiline':False]['text':'
 * Return information found in swapfile "fname" in dictionary "d".
 * This is used by the swapinfo() function.
 ','line_number':2178,'multiline':True]['text':' we have swap information','line_number':2198,'multiline':False]['text':'
 * Give information about an existing swap file.
 * Returns timestamp (0 when unknown).
 ','line_number':2221,'multiline':True]['text':' print the swap file date','line_number':2235,'multiline':False]['text':' print name of owner of the file','line_number':2239,'multiline':False]['text':'
     * print the original file name
     ','line_number':2254,'multiline':True]['text':'
 * Return TRUE if the swap file looks OK and there are no changes, thus it can
 * be safely deleted.
 ','line_number':2333,'multiline':True]['text':' must be able to stat the swap file','line_number':2345,'multiline':False]['text':' must be able to read the first block','line_number':2349,'multiline':False]['text':' the ID and magic number must be correct','line_number':2359,'multiline':False]['text':' must be unchanged','line_number':2363,'multiline':False]['text':' Host name must be known and must equal the current host name, otherwise','line_number':2368,'multiline':False]['text':' comparing pid is meaningless.','line_number':2369,'multiline':False]['text':' in case of corruption','line_number':2380,'multiline':False]['text':' process must be known and not be running','line_number':2385,'multiline':False]['text':' We do not check the user, it should be irrelevant for whether the swap','line_number':2390,'multiline':False]['text':' file is still useful.','line_number':2391,'multiline':False]['text':'
     * (Win32 and Win64) never short names, but do prepend a dot.
     * (Not MS-DOS or Win32 or Win64) maybe short name, maybe not: Try both.
     * Only use the short name if it is different.
     ','line_number':2402,'multiline':True]['text':'
     * May also add the file name with a dot prepended, for swap file in same
     * dir as original file.
     ','line_number':2417,'multiline':True]['text':'
     * Form the normal swap file name pattern by appending ".sw?".
     ','line_number':2429,'multiline':True]['text':' check if we have the same name twice','line_number':2439,'multiline':False]['text':' file name has been expanded to full path','line_number':2444,'multiline':False]['text':'
     * Also try with 'shortname' set, in case the file is on a DOS filesystem.
     ','line_number':2455,'multiline':True]['text':'
     * Remove the one from 'shortname', if it's the same as with 'noshortname'.
     ','line_number':2467,'multiline':True]['text':' file name has been expanded to full path','line_number':2473,'multiline':False]['text':'
 * sync all memlines
 *
 * If 'check_file' is TRUE, check if original file exists and was not changed.
 * If 'check_char' is TRUE, stop syncing when character becomes available, but
 * always sync at least one block.
 ','line_number':2488,'multiline':True]['text':' no file','line_number':2506,'multiline':False]['text':' flush buffered line','line_number':2514,'multiline':False]['text':' flush locked block','line_number':2515,'multiline':False]['text':'
	     * If the original file does not exist anymore or has been changed
	     * call ml_preserve() to get rid of all negative numbered blocks.
	     ','line_number':2520,'multiline':True]['text':' give message later','line_number':2533,'multiline':False]['text':' character available now','line_number':2540,'multiline':False]['text':'
 * sync one buffer, including negative blocks
 *
 * after this all the blocks are in the swap file
 *
 * Used for the :preserve command and when the original file has been
 * changed or deleted.
 *
 * when message is TRUE the success of preserving is reported
 ','line_number':2546,'multiline':True]['text':' We only want to stop when interrupted here, not when interrupted','line_number':2576,'multiline':False]['text':' before.','line_number':2577,'multiline':False]['text':' flush buffered line','line_number':2580,'multiline':False]['text':' flush locked block','line_number':2581,'multiline':False]['text':' stack is invalid after mf_sync(.., MFS_ALL)','line_number':2584,'multiline':False]['text':'
     * Some of the data blocks may have been changed from negative to
     * positive block number. In that case the pointer blocks need to be
     * updated.
     *
     * We don't know in which pointer block the references are, so we visit
     * all data blocks until there are no more translations to be done (or
     * we hit the end of the file, which can only happen in case a write fails,
     * e.g. when file system if full).
     * ml_find_line() does the work by translating the negative block numbers
     * when getting the first line of each data block.
     ','line_number':2587,'multiline':True]['text':' flush locked block','line_number':2613,'multiline':False]['text':' sync the updated pointer blocks','line_number':2614,'multiline':False]['text':' stack is invalid now','line_number':2617,'multiline':False]['text':'
 * NOTE: The pointer returned by the ml_get_*() functions only remains valid
 * until the next call!
 *  line1 = ml_get(1);
 *  line2 = ml_get(2);	// line1 is now invalid!
 * Make a copy of the line if necessary.
 ','line_number':2631,'multiline':True]['text':'
 * Return a pointer to a (read-only copy of a) line.
 *
 * On failure an error message is given and IObuff is returned (to avoid
 * having to check for error everywhere).
 ','line_number':2638,'multiline':True]['text':'
 * Return pointer to position "pos".
 ','line_number':2650,'multiline':True]['text':'
 * Return pointer to cursor line.
 ','line_number':2659,'multiline':True]['text':'
 * Return pointer to cursor position.
 ','line_number':2668,'multiline':True]['text':'
 * Return a pointer to a line in a specific buffer
 *
 * "will_change": if TRUE mark the buffer dirty (chars in the line will be
 * changed)
 ','line_number':2678,'multiline':True]['text':' line will be changed','line_number':2688,'multiline':False]['text':' invalid line number','line_number':2695,'multiline':False]['text':' Avoid giving this message for a recursive call, may happen when','line_number':2699,'multiline':False]['text':' the GUI redraws part of the text.','line_number':2700,'multiline':False]['text':' pretend line 0 is line 1','line_number':2712,'multiline':False]['text':' there are no lines','line_number':2715,'multiline':False]['text':'
     * See if it is the same line as requested last time.
     * Otherwise may need to flush last used line.
     * Don't use the last used line when 'swapfile' is reset, need to load all
     * blocks.
     ','line_number':2721,'multiline':True]['text':'
	 * Find the data block containing the line.
	 * This also fills the stack with the blocks from the root to the data
	 * block and releases any locked block.
	 ','line_number':2735,'multiline':True]['text':' Avoid giving this message for a recursive call, may happen','line_number':2744,'multiline':False]['text':' when the GUI redraws part of the text.','line_number':2745,'multiline':False]['text':' The text ends where the previous line starts.  The first line ends','line_number':2760,'multiline':False]['text':' at the end of the block.','line_number':2761,'multiline':False]['text':' can't make the change in the data block','line_number':2778,'multiline':False]['text':' make sure the text is in allocated memory','line_number':2789,'multiline':False]['text':' can't make the change in the data block','line_number':2796,'multiline':False]['text':'
 * Check if a line that was just obtained by a call to ml_get
 * is in allocated memory.
 * This ignores ML_ALLOCATED to get the same behavior as without the test
 * override.
 ','line_number':2804,'multiline':True]['text':'
 * Add text properties that continue from the previous line.
 ','line_number':2817,'multiline':True]['text':' init for gcc','line_number':2833,'multiline':False]['text':' Make two rounds:','line_number':2837,'multiline':False]['text':' 1. calculate the extra space needed','line_number':2838,'multiline':False]['text':' 2. allocate the space and fill it','line_number':2839,'multiline':False]['text':' nothing to do','line_number':2845,'multiline':False]['text':' Get the line above to find any props that continue in the next','line_number':2854,'multiline':False]['text':' line.','line_number':2855,'multiline':False]['text':' not exactly the right length','line_number':2867,'multiline':False]['text':' append after this line (can be 0)','line_number':2884,'multiline':False]['text':' text of the new line','line_number':2885,'multiline':False]['text':' length of line, including NUL, or 0','line_number':2886,'multiline':False]['text':' ML_APPEND_ flags','line_number':2887,'multiline':False]['text':' number of indexes in current block','line_number':2892,'multiline':False]['text':' space needed for new line','line_number':2895,'multiline':False]['text':' index for lnum in data block','line_number':2898,'multiline':False]['text':' text len with NUL without text properties','line_number':2907,'multiline':False]['text':' lnum out of range','line_number':2913,'multiline':False]['text':' space needed for the text','line_number':2920,'multiline':False]['text':' "len" may include text properties, get the length of the text.','line_number':2927,'multiline':False]['text':' Add text properties that continue from the previous line.','line_number':2936,'multiline':False]['text':' space needed for text + index','line_number':2940,'multiline':False]['text':'
 * find the data block containing the previous line
 * This also fills the stack with the blocks from the root to the data block
 * This also releases any locked block.
 ','line_number':2945,'multiline':True]['text':' got line one instead, correct db_idx','line_number':2956,'multiline':False]['text':' careful, it is negative!','line_number':2957,'multiline':False]['text':' get line count before the insertion','line_number':2960,'multiline':False]['text':'
 * If
 * - there is not enough room in the current block
 * - appending to the last line in the block
 * - not appending to the last line in the file
 * insert in front of the next block.
 ','line_number':2965,'multiline':True]['text':'
	 * Now that the line is not going to be inserted in the block that we
	 * expected, the line count has to be adjusted in the pointer blocks
	 * by using ml_locked_lineadd.
	 ','line_number':2975,'multiline':True]['text':' careful, it is negative!','line_number':2985,'multiline':False]['text':' get line count before the insertion','line_number':2986,'multiline':False]['text':' enough room in data block','line_number':2995,'multiline':False]['text':'
	 * Insert the new line in an existing data block, or in the data block
	 * allocated above.
	 ','line_number':2997,'multiline':True]['text':'
	 * move the text of the lines that follow to the front
	 * adjust the indexes of the lines that follow
	 ','line_number':3005,'multiline':True]['text':' if there are following lines','line_number':3009,'multiline':False]['text':'
	     * Offset is the start of the previous line.
	     * This will become the character just after the new line.
	     ','line_number':3011,'multiline':True]['text':' add line at the end (which is the start of the text)','line_number':3027,'multiline':False]['text':'
	 * copy the text into the block
	 ','line_number':3030,'multiline':True]['text':'
	 * Mark the block dirty.
	 ','line_number':3037,'multiline':True]['text':' not enough space in data block','line_number':3044,'multiline':False]['text':' init to shut up gcc','line_number':3052,'multiline':False]['text':' init to shut up gcc','line_number':3053,'multiline':False]['text':'
	 * There is not enough room, we have to create a new data block and
	 * copy some lines into it.
	 * Then we have to insert an entry in the pointer block.
	 * If this pointer block also is full, we go up another block, and so
	 * on, up to the root if necessary.
	 * The line counts in the pointer blocks have already been adjusted by
	 * ml_find_line().
	 *
	 * We are going to allocate a new data block. Depending on the
	 * situation it will be put to the left or right of the existing
	 * block.  If possible we put the new line in the left block and move
	 * the lines after it to the right block. Otherwise the new line is
	 * also put in the right block. This method is more efficient when
	 * inserting a lot of lines at one place.
	 ','line_number':3063,'multiline':True]['text':' left block is new, right block is existing','line_number':3079,'multiline':False]['text':' space_needed does not change','line_number':3083,'multiline':False]['text':' left block is existing, right block is new','line_number':3085,'multiline':False]['text':' put new line in right block','line_number':3089,'multiline':False]['text':' space_needed does not change','line_number':3090,'multiline':False]['text':' put new line in left block','line_number':3098,'multiline':False]['text':' put new line in right block','line_number':3103,'multiline':False]['text':' correct line counts in pointer blocks','line_number':3113,'multiline':False]['text':' left block is new','line_number':3118,'multiline':False]['text':' right block is new','line_number':3125,'multiline':False]['text':'
	 * May move the new line into the right/new block.
	 ','line_number':3139,'multiline':True]['text':'
	 * may move lines from the left/old block to the right/new one.
	 ','line_number':3154,'multiline':True]['text':'
	     * update indexes in the new block
	     ','line_number':3168,'multiline':True]['text':'
	 * May move the new line into the left (old or new) block.
	 ','line_number':3178,'multiline':True]['text':' left block is new','line_number':3193,'multiline':False]['text':' right block is new','line_number':3198,'multiline':False]['text':'
	 * release the two data blocks
	 * The new one (hp_new) already has a correct blocknumber.
	 * The old one (hp, in ml_locked) gets a positive blocknumber if
	 * we changed it and we are not editing a new file.
	 ','line_number':3209,'multiline':True]['text':'
	 * flush the old data block
	 * set ml_locked_lineadd to 0, because the updating of the
	 * pointer blocks is done below
	 ','line_number':3221,'multiline':True]['text':' flush data block','line_number':3228,'multiline':False]['text':'
	 * update pointer blocks for the new data block
	 ','line_number':3230,'multiline':True]['text':' must be pointer block','line_number':3240,'multiline':False]['text':'
	     * TODO: If the pointer block is full and we are adding at the end
	     * try to insert in front of the next block
	     ','line_number':3247,'multiline':True]['text':' block not full, add one entry','line_number':3251,'multiline':False]['text':' truncate stack','line_number':3272,'multiline':False]['text':' fix line count for rest of blocks in the stack','line_number':3277,'multiline':False]['text':' fix stack itself','line_number':3279,'multiline':False]['text':'
		 * We are finished, break the loop here.
		 ','line_number':3285,'multiline':True]['text':' pointer block full','line_number':3290,'multiline':False]['text':'
	     * split the pointer block
	     * allocate a new pointer block
	     * move some of the pointer into the new block
	     * prepare for updating the parent block
	     ','line_number':3291,'multiline':True]['text':' do this twice when splitting block 1','line_number':3297,'multiline':False]['text':' TODO: try to fix tree','line_number':3300,'multiline':False]['text':'
		 * if block 1 becomes full the tree is given an extra level
		 * The pointers from block 1 are moved into the new block.
		 * block 1 is updated to point to the new block
		 * then continue to split the new block
		 ','line_number':3307,'multiline':True]['text':' release block 1','line_number':3319,'multiline':False]['text':' new block is to be split','line_number':3320,'multiline':False]['text':' do block 1 again later','line_number':3324,'multiline':False]['text':'
	     * move the pointers after the current one to the new block
	     * If there are none, the new entry will be in the new block.
	     ','line_number':3326,'multiline':True]['text':'
	     * recompute line counts
	     ','line_number':3360,'multiline':True]['text':'
	 * Safety check: fallen out of for loop?
	 ','line_number':3379,'multiline':True]['text':' invalidate stack','line_number':3385,'multiline':False]['text':' The line was inserted below 'lnum'','line_number':3390,'multiline':False]['text':'
 * Flush any pending change and call ml_append_int()
 ','line_number':3422,'multiline':True]['text':' append after this line (can be 0)','line_number':3428,'multiline':False]['text':' text of the new line','line_number':3429,'multiline':False]['text':' length of line, including NUL, or 0','line_number':3430,'multiline':False]['text':' ML_APPEND_ flags','line_number':3431,'multiline':False]['text':' lnum out of range','line_number':3434,'multiline':False]['text':' This may also invoke ml_append_int().','line_number':3437,'multiline':False]['text':' When inserting above recorded changes: flush the changes before changing','line_number':3441,'multiline':False]['text':' the text.  Then flush the cached line, it may become invalid.','line_number':3442,'multiline':False]['text':'
 * Append a line after lnum (may be 0 to insert a line in front of the file).
 * "line" does not need to be allocated, but can't be another line in a
 * buffer, unlocking may make it invalid.
 *
 * "newfile": TRUE when starting to edit a new file, meaning that pe_old_lnum
 *		will be set for recovery
 * Check: The caller of this function should probably also call
 * appended_lines().
 *
 * return FAIL for failure, OK otherwise
 ','line_number':3451,'multiline':True]['text':' append after this line (can be 0)','line_number':3465,'multiline':False]['text':' text of the new line','line_number':3466,'multiline':False]['text':' length of new line, including NUL, or 0','line_number':3467,'multiline':False]['text':' flag, see above','line_number':3468,'multiline':False]['text':' append after this line (can be 0)','line_number':3475,'multiline':False]['text':' text of the new line','line_number':3476,'multiline':False]['text':' length of new line, including NUL, or 0','line_number':3477,'multiline':False]['text':' ML_APPEND_ values','line_number':3478,'multiline':False]['text':' When starting up, we might still need to create the memfile','line_number':3480,'multiline':False]['text':'
 * Like ml_append() but for an arbitrary buffer.  The buffer must already have
 * a memline.
 ','line_number':3489,'multiline':True]['text':' append after this line (can be 0)','line_number':3496,'multiline':False]['text':' text of the new line','line_number':3497,'multiline':False]['text':' length of new line, including NUL, or 0','line_number':3498,'multiline':False]['text':' flag, see above','line_number':3499,'multiline':False]['text':'
 * Replace line "lnum", with buffering, in current buffer.
 *
 * If "copy" is TRUE, make a copy of the line, otherwise the line has been
 * copied to allocated memory already.
 * If "copy" is FALSE the "line" may be freed to add text properties!
 * Do not use it after calling ml_replace().
 *
 * Check: The caller of this function should probably also call
 * changed_lines(), unless update_screen(UPD_NOT_VALID) is used.
 *
 * return FAIL for failure, OK otherwise
 ','line_number':3507,'multiline':True]['text':'
 * Replace a line for the current buffer.  Like ml_replace() with:
 * "len_arg" is the length of the text, excluding NUL.
 * If "has_props" is TRUE then "line_arg" includes the text properties and
 * "len_arg" includes the NUL of the text.
 * When "copy" is TRUE copy the text into allocated memory, otherwise
 * "line_arg" must be allocated and will be consumed here.
 ','line_number':3530,'multiline':True]['text':' just checking...','line_number':3549,'multiline':False]['text':' When starting up, we might still need to create the memfile','line_number':3552,'multiline':False]['text':' include the NUL after the text','line_number':3557,'multiline':False]['text':' copy the line to allocated memory','line_number':3560,'multiline':False]['text':' another line is buffered, flush it','line_number':3580,'multiline':False]['text':' Need to fetch the old line to copy over any text properties.','line_number':3585,'multiline':False]['text':' Need to copy over text properties, stored after the text.','line_number':3600,'multiline':False]['text':' free allocated line','line_number':3616,'multiline':False]['text':'
 * Adjust text properties in line "lnum" for a deleted line.
 * When "above" is true this is the line above the deleted line, otherwise this
 * is the line below the deleted line.
 * "del_props[del_props_len]" are the properties of the deleted line.
 ','line_number':3627,'multiline':True]['text':' first line in block, text at the end','line_number':3672,'multiline':False]['text':'
 * Delete line "lnum" in the current buffer.
 * When "flags" has ML_DEL_MESSAGE may give a "No lines in buffer" message.
 * When "flags" has ML_DEL_UNDO this is called from undo.
 *
 * return FAIL for failure, OK otherwise
 ','line_number':3725,'multiline':True]['text':' number of entries in block','line_number':3740,'multiline':False]['text':'
 * If the file becomes empty the last line is replaced by an empty line.
 ','line_number':3756,'multiline':True]['text':' file becomes empty','line_number':3759,'multiline':False]['text':' FEAT_BYTEOFF already handled in there, don't worry 'bout it below','line_number':3768,'multiline':False]['text':'
 * Find the data block containing the line.
 * This also fills the stack with the blocks from the root to the data block.
 * This also releases any locked block..
 ','line_number':3775,'multiline':True]['text':' compute line count before the delete','line_number':3788,'multiline':False]['text':' first line in block, text at the end','line_number':3796,'multiline':False]['text':' If there are text properties compute their byte length.','line_number':3806,'multiline':False]['text':' if needed make a copy, so that we can update properties in preceding and','line_number':3807,'multiline':False]['text':' following lines.','line_number':3808,'multiline':False]['text':'
 * special case: If there is only one line in the data block it becomes empty.
 * Then we have to remove the entry, pointing to this data block, from the
 * pointer block. If this pointer block also becomes empty, we go up another
 * block, and so on, up to the root if necessary.
 * The line counts in the pointer blocks have already been adjusted by
 * ml_find_line().
 ','line_number':3820,'multiline':True]['text':' free the data block','line_number':3830,'multiline':False]['text':' stack is invalid when failing','line_number':3836,'multiline':False]['text':' must be pointer block','line_number':3841,'multiline':False]['text':' the pointer block becomes empty!','line_number':3849,'multiline':False]['text':' move entries after the deleted one','line_number':3853,'multiline':False]['text':' truncate stack','line_number':3858,'multiline':False]['text':' fix line count for rest of blocks in the stack','line_number':3859,'multiline':False]['text':'
	 * delete the text by moving the next lines forwards
	 ','line_number':3875,'multiline':True]['text':'
	 * delete the index by moving the next indexes backwards
	 * Adjust the indexes for the text movement.
	 ','line_number':3882,'multiline':True]['text':'
	 * mark the block dirty and make sure it is in the file (for recovery)
	 ','line_number':3893,'multiline':True]['text':' Adjust text properties in the line above and below.','line_number':3912,'multiline':False]['text':'
 * Delete line "lnum" in the current buffer.
 * When "message" is TRUE may give a "No lines in buffer" message.
 *
 * Check: The caller of this function should probably also call
 * deleted_lines() after this.
 *
 * return FAIL for failure, OK otherwise
 ','line_number':3925,'multiline':True]['text':'
 * Like ml_delete() but using flags (see ml_delete_int()).
 ','line_number':3940,'multiline':True]['text':' When inserting above recorded changes: flush the changes before changing','line_number':3951,'multiline':False]['text':' the text.','line_number':3952,'multiline':False]['text':'
 * set the DB_MARKED flag for line 'lnum'
 ','line_number':3959,'multiline':True]['text':' invalid line number','line_number':3967,'multiline':False]['text':' give error message?','line_number':3970,'multiline':False]['text':'
     * find the data block containing the line
     * This also fills the stack with the blocks from the root to the data block
     * This also releases any locked block.
     ','line_number':3975,'multiline':True]['text':' give error message?','line_number':3981,'multiline':False]['text':'
 * find the first line with its DB_MARKED flag set
 ','line_number':3988,'multiline':True]['text':'
     * The search starts with lowest_marked line. This is the last line where
     * a mark was found, adjusted by inserting/deleting lines.
     ','line_number':4002,'multiline':True]['text':'
	 * Find the data block containing the line.
	 * This also fills the stack with the blocks from the root to the data
	 * block This also releases any locked block.
	 ','line_number':4008,'multiline':True]['text':' give error message?','line_number':4014,'multiline':False]['text':'
 * clear all DB_MARKED flags
 ','line_number':4032,'multiline':True]['text':' nothing to do','line_number':4043,'multiline':False]['text':'
     * The search starts with line lowest_marked.
     ','line_number':4046,'multiline':True]['text':'
	 * Find the data block containing the line.
	 * This also fills the stack with the blocks from the root to the data
	 * block and releases any locked block.
	 ','line_number':4051,'multiline':True]['text':' give error message?','line_number':4057,'multiline':False]['text':'
 * flush ml_line if necessary
 ','line_number':4073,'multiline':True]['text':' nothing to do','line_number':4094,'multiline':False]['text':' This code doesn't work recursively, but Netbeans may call back here','line_number':4098,'multiline':False]['text':' when obtaining the cursor position.','line_number':4099,'multiline':False]['text':' line is last in block','line_number':4116,'multiline':False]['text':' text of previous line follows','line_number':4118,'multiline':False]['text':' negative if lines gets smaller','line_number':4121,'multiline':False]['text':'
	     * if new line fits in data block, replace directly
	     ','line_number':4123,'multiline':True]['text':' if the length changes and there are following lines','line_number':4133,'multiline':False]['text':' move text of following lines','line_number':4137,'multiline':False]['text':' adjust pointers of this and following lines','line_number':4142,'multiline':False]['text':' adjust free space','line_number':4148,'multiline':False]['text':' copy new line into the data block','line_number':4152,'multiline':False]['text':' The else case is already covered by the insert and delete','line_number':4156,'multiline':False]['text':' Do not count the size of any text properties.','line_number':4159,'multiline':False]['text':'
		 * Cannot do it in one data block: Delete and append.
		 * Append first, because ml_delete_int() cannot delete the
		 * last line in a buffer, which causes trouble for a buffer
		 * that has only one line.
		 * Don't forget to copy the mark!
		 ','line_number':4169,'multiline':True]['text':' How about handling errors???','line_number':4176,'multiline':False]['text':'
 * create a new, empty, data block
 ','line_number':4197,'multiline':True]['text':'
 * create a new, empty, pointer block
 ','line_number':4218,'multiline':True]['text':'
 * Lookup line 'lnum' in a memline.
 *
 *   action: if ML_DELETE or ML_INSERT the line count is updated while searching
 *	     if ML_FLUSH only flush a locked block
 *	     if ML_FIND just find the line
 *
 * If the block was found it is locked and put in ml_locked.
 * The stack is updated to lead to the locked block. The ip_high field in
 * the stack is updated to reflect the last line in the block AFTER the
 * insert or delete, also if the pointer block has not been updated yet. But
 * if ml_locked != NULL ml_locked_lineadd must be added to ip_high.
 *
 * return: NULL for failure, pointer to block header otherwise
 ','line_number':4238,'multiline':True]['text':'
     * If there is a locked block check if the wanted line is in it.
     * If not, flush and release the locked block.
     * Don't do this for ML_INSERT_SAME, because the stack need to be updated.
     * Don't do this for ML_FLUSH, because we want to flush the locked block.
     * Don't do this when 'swapfile' is reset, we want to load all the blocks.
     ','line_number':4271,'multiline':True]['text':' remember to update pointer blocks and stack later','line_number':4285,'multiline':False]['text':'
	 * If lines have been added or deleted in the locked block, need to
	 * update the line count in pointer blocks.
	 ','line_number':4303,'multiline':True]['text':' nothing else to do','line_number':4311,'multiline':False]['text':' start at the root of the tree','line_number':4314,'multiline':False]['text':' first try stack entries','line_number':4319,'multiline':False]['text':' truncate stack at prev entry','line_number':4329,'multiline':False]['text':' not found, start at the root','line_number':4334,'multiline':False]['text':' ML_DELETE or ML_INSERT','line_number':4336,'multiline':False]['text':' start at the root','line_number':4337,'multiline':False]['text':'
 * search downwards in the tree until a data block is found
 ','line_number':4339,'multiline':True]['text':'
	 * update high for insert/delete
	 ','line_number':4347,'multiline':True]['text':' data block','line_number':4356,'multiline':False]['text':' must be pointer block','line_number':4366,'multiline':False]['text':' add new entry to stack','line_number':4373,'multiline':False]['text':' index not known yet','line_number':4379,'multiline':False]['text':'
		 * a negative block number may have been changed
		 ','line_number':4394,'multiline':True]['text':' past the end: something wrong!','line_number':4411,'multiline':False]['text':'
     * If action is ML_DELETE or ML_INSERT we have to correct the tree for
     * the incremented/decremented line counts, because there won't be a line
     * inserted/deleted after all.
     ','line_number':4437,'multiline':True]['text':'
 * add an entry to the info pointer stack
 *
 * return -1 for failure, number of the new entry otherwise
 ','line_number':4450,'multiline':True]['text':' may have to increase the stack size','line_number':4463,'multiline':False]['text':' more than 5 levels???','line_number':4466,'multiline':False]['text':'
 * Update the pointer blocks on the stack for inserted/deleted lines.
 * The stack itself is also updated.
 *
 * When a insert/delete line action fails, the line is not inserted/deleted,
 * but the pointer blocks have already been updated. That is fixed here by
 * walking through the stack.
 *
 * Count is the number of lines added, negative if lines have been deleted.
 ','line_number':4483,'multiline':True]['text':' must be pointer block','line_number':4507,'multiline':False]['text':'
 * Resolve a symlink in the last component of a file name.
 * Note that f_resolve() does it for every part of the path, we don't do that
 * here.
 * If it worked returns OK and the resolved link in "buf[MAXPATHL]".
 * Otherwise returns FAIL.
 ','line_number':4521,'multiline':True]['text':' Put the result so far in tmp[], starting with the original name.','line_number':4538,'multiline':False]['text':' Limit symlink depth to 100, catch recursive loops.','line_number':4543,'multiline':False]['text':' Found non-symlink or not existing file, stop here.','line_number':4555,'multiline':False]['text':' When at the first level use the unmodified name, skip the','line_number':4556,'multiline':False]['text':' call to vim_FullName().','line_number':4557,'multiline':False]['text':' Use the resolved name in tmp[].','line_number':4561,'multiline':False]['text':' There must be some error reading links, use original name.','line_number':4565,'multiline':False]['text':'
	 * Check whether the symlink is relative or absolute.
	 * If it's relative, build a new path based on the directory
	 * portion of the filename (if any) and the path the symlink
	 * points to.
	 ','line_number':4570,'multiline':True]['text':'
     * Try to resolve the full name of the file so that the swapfile name will
     * be consistent even when opening a relative symlink from different
     * working directories.
     ','line_number':4589,'multiline':True]['text':'
 * Make swap file name out of the file name and a directory name.
 * Returns pointer to allocated memory or NULL.
 ','line_number':4598,'multiline':True]['text':' Expand symlink in the file name, so that we put the swap file with the','line_number':4614,'multiline':False]['text':' actual file instead of with the symlink.','line_number':4615,'multiline':False]['text':' Need _very_ long file names','line_number':4620,'multiline':False]['text':' Ends with '//', Use Full path','line_number':4625,'multiline':False]['text':' Prepend a '.' to the swap file name for the current directory.','line_number':4645,'multiline':False]['text':' out of memory','line_number':4647,'multiline':False]['text':'
 * Get file name to use for swap file or backup file.
 * Use the name of the edited file "fname" and an entry in the 'dir' or 'bdir'
 * option "dname".
 * - If "dname" is ".", return "fname" (swap file in dir of file).
 * - If "dname" starts with "./", insert "dname" in "fname" (swap file
 *   relative to dir of file).
 * - Otherwise, prepend "dname" to the tail of "fname" (swap file in specific
 *   dir).
 *
 * The return value is an allocated string and can be NULL.
 ','line_number':4655,'multiline':True]['text':' don't use "dirname", it is a global for Alpha','line_number':4670,'multiline':False]['text':' no path before file name','line_number':4683,'multiline':False]['text':' out of memory','line_number':4691,'multiline':False]['text':'
 * Print the ATTENTION message: info about an existing swap file.
 ','line_number':4713,'multiline':True]['text':' buffer being edited','line_number':4718,'multiline':False]['text':' swap file name','line_number':4719,'multiline':False]['text':' Some of these messages are long to allow translation to','line_number':4744,'multiline':False]['text':' other languages.','line_number':4745,'multiline':False]['text':'
 * Trigger the SwapExists autocommands.
 * Returns a value for equivalent to do_dialog().
 ','line_number':4769,'multiline':True]['text':' Trigger SwapExists autocommands with <afile> set to the file being','line_number':4779,'multiline':False]['text':' edited.  Disallow changing directory here.','line_number':4780,'multiline':False]['text':'
 * Find out what name to use for the swap file for buffer 'buf'.
 *
 * Several names are tried to find one that does not exist
 * Returns the name in allocated memory or NULL.
 * When out of memory "dirp" is set to NULL.
 *
 * Note: If BASENAMELEN is not correct, you will get error messages for
 *	 not being able to open the swap or undo file
 * Note: May trigger SwapExists autocmd, pointers may change!
 ','line_number':4801,'multiline':True]['text':' pointer to list of directories','line_number':4815,'multiline':False]['text':' don't give warning for this file name','line_number':4816,'multiline':False]['text':'
     * If we start editing a new file, e.g. "test.doc", which resides on an
     * MSDOS compatible filesystem, it is possible that the file
     * "test.doc.swp" which we create will be exactly the same file. To avoid
     * this problem we temporarily create "test.doc".  Don't do this when the
     * check below for an 8.3 file name is used.
     ','line_number':4847,'multiline':True]['text':'
     * Isolate a directory name from *dirp and put it in dir_name.
     * First allocate some memory to put the directory name in.
     ','line_number':4859,'multiline':True]['text':'
     * we try different names until we find one that does not exist yet
     ','line_number':4869,'multiline':True]['text':' out of memory','line_number':4872,'multiline':False]['text':' must be out of memory','line_number':4879,'multiline':False]['text':' safety check','line_number':4881,'multiline':False]['text':'
 * Some systems have a MS-DOS compatible filesystem that use 8.3 character
 * file names. If this is the first try and the swap file name does not fit in
 * 8.3, detect if this is the case, set shortname and try again.
 ','line_number':4887,'multiline':True]['text':'
	     * Check if swapfile name does not fit in 8.3:
	     * It either contains two dots, is longer than 8 chars, or starts
	     * with a dot.
	     ','line_number':4902,'multiline':True]['text':' if fname == "xx.xx.swp",	    fname2 = "xx.xx.swx"','line_number':4916,'multiline':False]['text':' if fname == ".xx.swp",	    fname2 = ".xx.swpx"','line_number':4917,'multiline':False]['text':' if fname == "123456789.swp", fname2 = "12345678x.swp"','line_number':4918,'multiline':False]['text':'
		     * may need to create the files to be able to use mch_stat()
		     ','line_number':4928,'multiline':True]['text':'
			     * Both files exist now. If mch_stat() returns the
			     * same device and inode they are the same file.
			     ','line_number':4949,'multiline':True]['text':' try again with b_shortname set','line_number':4973,'multiline':False]['text':'
	 * check if the swapfile already exists
	 ','line_number':4979,'multiline':True]['text':' it does not exist','line_number':4982,'multiline':False]['text':'
	     * Extra security check: When a swap file is a symbolic link, this
	     * is most likely a symlink attack.
	     ','line_number':4987,'multiline':True]['text':'
	     * on the Amiga mch_getperm() will return -1 when the file exists
	     * but is being used by another program. This happens if you edit
	     * a file twice.
	     ','line_number':4995,'multiline':True]['text':' can open file, OK','line_number':5000,'multiline':False]['text':'
	 * A file name equal to old_fname is OK to use.
	 ','line_number':5013,'multiline':True]['text':'
	 * get here when file already exists
	 ','line_number':5019,'multiline':True]['text':' first try','line_number':5022,'multiline':False]['text':'
	     * on MS-DOS compatible filesystems (e.g. messydos) file.doc.swp
	     * and file.doc are the same file. To guess if this problem is
	     * present try if file.doc.swx exists. If it does, we set
	     * buf->b_shortname and try file_doc.swp (dots replaced by
	     * underscores for this file), and try again. If it doesn't we
	     * assume that "file.doc.swp" already exists.
	     ','line_number':5024,'multiline':True]['text':' not tried yet','line_number':5032,'multiline':False]['text':' try "file.swx"','line_number':5035,'multiline':False]['text':' "file.swx" seems to exist','line_number':5037,'multiline':False]['text':' try again with '.' replaced with '_'','line_number':5043,'multiline':False]['text':'
	     * If we get here the ".swp" file really exists.
	     * Give an error message, unless recovering, no file name, we are
	     * viewing a help file or when the path of the file is different
	     * (happens when all .swp files are in one directory).
	     ','line_number':5046,'multiline':True]['text':'
		 * Try to read block 0 from the swap file to get the original
		 * file name (and inode number).
		 ','line_number':5060,'multiline':True]['text':'
			 * If the swapfile has the same directory as the
			 * buffer don't compare the directory names, they can
			 * have a different mountpoint.
			 ','line_number':5069,'multiline':True]['text':' Symlinks may point to the same file even','line_number':5081,'multiline':False]['text':' when the name differs, need to check the','line_number':5082,'multiline':False]['text':' inode too.','line_number':5083,'multiline':False]['text':'
			     * The name in the swap file may be
			     * "~user/path/file".  Expand it first.
			     ','line_number':5093,'multiline':True]['text':' give the ATTENTION message when there is an old swap file','line_number':5111,'multiline':False]['text':' for the current file, and the buffer was not recovered.','line_number':5112,'multiline':False]['text':' Avoid getting a warning for the file being created','line_number':5121,'multiline':False]['text':' outside of Vim, it was created at the start of this','line_number':5122,'multiline':False]['text':' function.  Delete the file now, because Vim might exit','line_number':5123,'multiline':False]['text':' here if the window is closed.','line_number':5124,'multiline':False]['text':' It's safe to delete the swap file if all these are true:','line_number':5137,'multiline':False]['text':' - the edited file exists','line_number':5138,'multiline':False]['text':' - the swap file has no changes and looks OK','line_number':5139,'multiline':False]['text':'
		     * If there is an SwapExists autocommand and we can handle
		     * the response, trigger it.  It may return 0 to ask the
		     * user anyway.
		     ','line_number':5149,'multiline':True]['text':' always open readonly.','line_number':5163,'multiline':False]['text':' If we are supposed to start the GUI but it wasn't','line_number':5170,'multiline':False]['text':' completely started yet, start it now.  This makes','line_number':5171,'multiline':False]['text':' the messages displayed in the Vim window when','line_number':5172,'multiline':False]['text':' loading a session from the .gvimrc file.','line_number':5173,'multiline':False]['text':' Show info about the existing swap file.','line_number':5177,'multiline':False]['text':' We don't want a 'q' typed at the more-prompt','line_number':5180,'multiline':False]['text':' interrupt loading a file.','line_number':5181,'multiline':False]['text':' If vimrc has "simalt ~x" we don't want it to','line_number':5184,'multiline':False]['text':' interfere with the prompt here.','line_number':5185,'multiline':False]['text':' compensate for missing "Delete it" button','line_number':5219,'multiline':False]['text':' pretend screen didn't scroll, need redraw anyway','line_number':5225,'multiline':False]['text':' call wait_return() later','line_number':5254,'multiline':False]['text':' If the file was deleted this fname can be used.','line_number':5259,'multiline':False]['text':' Going to try another name, need the dummy file again.','line_number':5264,'multiline':False]['text':'
	 * Change the ".swp" extension to find another file that can be used.
	 * First decrement the last char: ".swo", ".swn", etc.
	 * If that still isn't enough decrement the last but one char: ".svz"
	 * Can happen when editing many "No Name" buffers.
	 ','line_number':5272,'multiline':True]['text':' ".s?a"','line_number':5278,'multiline':False]['text':' ".saa": tried enough, give up','line_number':5280,'multiline':False]['text':' ".svz", ".suz", etc.','line_number':5286,'multiline':False]['text':' ".swo", ".swn", etc.','line_number':5289,'multiline':False]['text':' file has been created temporarily','line_number':5294,'multiline':False]['text':'
 * Compare current file name with file name from swap file.
 * Try to use inode numbers when possible.
 * Return non-zero when files are different.
 *
 * When comparing file names a few things have to be taken into consideration:
 * - When working over a network the full path of a file depends on the host.
 *   We check the inode number if possible.  It is not 100% reliable though,
 *   because the device number cannot be used over a network.
 * - When a file does not exist yet (editing a new file) there is no inode
 *   number.
 * - The file name in a swap file may not be valid on the current host.  The
 *   "~user" form is used whenever possible to avoid this.
 *
 * This is getting complicated, let's make a table:
 *
 *		ino_c  ino_s  fname_c  fname_s	differ =
 *
 * both files exist -> compare inode numbers:
 *		!= 0   != 0	X	 X	ino_c != ino_s
 *
 * inode number(s) unknown, file names available -> compare file names
 *		== 0	X	OK	 OK	fname_c != fname_s
 *		 X     == 0	OK	 OK	fname_c != fname_s
 *
 * current file doesn't exist, file for swap file exist, file name(s) not
 * available -> probably different
 *		== 0   != 0    FAIL	 X	TRUE
 *		== 0   != 0	X	FAIL	TRUE
 *
 * current file exists, inode for swap unknown, file name(s) not
 * available -> probably different
 *		!= 0   == 0    FAIL	 X	TRUE
 *		!= 0   == 0	X	FAIL	TRUE
 *
 * current file doesn't exist, inode for swap unknown, one file name not
 * available -> probably different
 *		== 0   == 0    FAIL	 OK	TRUE
 *		== 0   == 0	OK	FAIL	TRUE
 *
 * current file doesn't exist, inode for swap unknown, both file names not
 * available -> compare file names
 *		== 0   == 0    FAIL	FAIL	fname_c != fname_s
 *
 * Note that when the ino_t is 64 bits, only the last 32 will be used.  This
 * can't be changed without making the block 0 incompatible with 32 bit
 * versions.
 ','line_number':5317,'multiline':True]['text':' current file name','line_number':5368,'multiline':False]['text':' file name from swap file','line_number':5369,'multiline':False]['text':' ino of current file','line_number':5373,'multiline':False]['text':' ino of file from swap file','line_number':5374,'multiline':False]['text':' full path of fname_c','line_number':5375,'multiline':False]['text':' full path of fname_s','line_number':5376,'multiline':False]['text':' flag: buf_c valid','line_number':5377,'multiline':False]['text':' flag: buf_s valid','line_number':5378,'multiline':False]['text':'
     * First we try to get the inode from the file name, because the inode in
     * the swap file may be outdated.  If that fails (e.g. this path is not
     * valid on this machine), use the inode from block 0.
     ','line_number':5383,'multiline':True]['text':'
     * One of the inode numbers is unknown, try a forced vim_FullName() and
     * compare the file names.
     ','line_number':5396,'multiline':True]['text':'
     * Can't compare inodes or file names, guess that the files are different,
     * unless both appear not to exist at all, then compare with the file name
     * in the swap file.
     ','line_number':5405,'multiline':True]['text':' CHECK_INODE','line_number':5414,'multiline':False]['text':'
 * Move a long integer into a four byte character array.
 * Used for machine independency in block zero.
 ','line_number':5416,'multiline':True]['text':'
 * Set the flags in the first block of the swap file:
 * - file is modified or not: buf->b_changed
 * - 'fileformat'
 * - 'fileencoding'
 ','line_number':5448,'multiline':True]['text':'
 * If "data" points to a data block encrypt the text in it and return a copy
 * in allocated memory.  Return NULL when out of memory.
 * Otherwise return "data".
 ','line_number':5479,'multiline':True]['text':' Copy the header and the text.','line_number':5512,'multiline':False]['text':' Encrypt the text.','line_number':5515,'multiline':False]['text':' Clear the gap.','line_number':5520,'multiline':False]['text':'
 * Decrypt the text in "data" if it points to an encrypted data block.
 ','line_number':5527,'multiline':True]['text':' data was messed up','line_number':5552,'multiline':False]['text':' Decrypt the text in place.','line_number':5558,'multiline':False]['text':'
 * Prepare for encryption/decryption, using the key, seed and offset.
 * Return an allocated cryptstate_T *.
 * Note: Encryption not supported for SODIUM
 ','line_number':5563,'multiline':True]['text':' Reading back blocks with the previous key/method/seed.','line_number':5580,'multiline':False]['text':' For PKzip: Append the offset to the key, so that we use a different','line_number':5600,'multiline':False]['text':' key for every block.','line_number':5601,'multiline':False]['text':' Using blowfish or better: add salt and seed. We use the byte offset','line_number':5609,'multiline':False]['text':' of the block for the salt.','line_number':5610,'multiline':False]['text':' max no of lines in chunk','line_number':5628,'multiline':False]['text':' should be half of MLCS_MAXL','line_number':5629,'multiline':False]['text':'
 * Keep information for finding byte offset of a line, updtype may be one of:
 * ML_CHNK_ADDLINE: Add len to parent chunk, possibly splitting it
 *	   Careful: ML_CHNK_ADDLINE may cause ml_find_line() to be called.
 * ML_CHNK_DELLINE: Subtract len from parent chunk, possibly deleting it
 * ML_CHNK_UPDLINE: Add len to parent chunk, as a signed entity.
 ','line_number':5631,'multiline':True]['text':'
	 * First line in empty buffer from ml_flush_line() -- reset
	 ','line_number':5676,'multiline':True]['text':'
     * Find chunk that our line belongs to, curline will be at start of the
     * chunk.
     ','line_number':5685,'multiline':True]['text':' Adjust cached curix & curline','line_number':5701,'multiline':False]['text':' May resize here so we don't have to do it in both cases below','line_number':5714,'multiline':False]['text':' Hmmmm, Give up on offset for this buffer','line_number':5724,'multiline':False]['text':' number of entries in block','line_number':5733,'multiline':False]['text':' Compute length of first half of lines in the split chunk','line_number':5743,'multiline':False]['text':' compute index of last line to use in this MEMLINE','line_number':5760,'multiline':False]['text':' We cannot use the text pointers to get the text length,','line_number':5777,'multiline':False]['text':' the text prop info would also be counted.  Go over the','line_number':5778,'multiline':False]['text':' lines.','line_number':5779,'multiline':False]['text':' first line in block, text at the end','line_number':5787,'multiline':False]['text':' Force recalc of curix & curline','line_number':5800,'multiline':False]['text':'
	     * We are in the last chunk and it is cheap to create a new one
	     * after this. Do it now to avoid the loop above later on
	     ','line_number':5807,'multiline':True]['text':'
		 * Line is just prior to last, move count for last
		 * This is the common case  when loading a new file
		 ','line_number':5820,'multiline':True]['text':' Force recalc of curix & curline','line_number':5847,'multiline':False]['text':' Collapse chunks','line_number':5869,'multiline':False]['text':'
 * Find offset for line or line with offset.
 * Find line with offset if "lnum" is 0; return remaining offset in offp
 * Find offset of line if "lnum" > 0
 * return -1 if information is not available
 ','line_number':5886,'multiline':True]['text':' number of entries in block','line_number':5900,'multiline':False]['text':' take care of cached line first','line_number':5909,'multiline':False]['text':' Not a "find offset" and offset 0 _must_ be in line 1','line_number':5922,'multiline':False]['text':'
     * Find the last chunk before the one containing our line. Last chunk is
     * special because it will never qualify.
     ','line_number':5923,'multiline':True]['text':' first line in block, text at the end','line_number':5956,'multiline':False]['text':' Compute index of last line to use in this MEMLINE','line_number':5960,'multiline':False]['text':' compensate for the extra bytes taken by textprops','line_number':5980,'multiline':False]['text':' cannot use the db_index pointer, need to get the actual text','line_number':6013,'multiline':False]['text':' lengths.','line_number':6014,'multiline':False]['text':' exactly one byte beyond the end','line_number':6045,'multiline':False]['text':' Count extra CR characters.','line_number':6053,'multiline':False]['text':' Don't count the last line break if 'noeol' and ('bin' or','line_number':6057,'multiline':False]['text':' 'nofixeol').','line_number':6058,'multiline':False]['text':'
 * Goto byte in buffer with offset 'cnt'.
 ','line_number':6067,'multiline':True]['text':' cached line may be dirty','line_number':6076,'multiline':False]['text':' past the end','line_number':6081,'multiline':False]['text':' Make sure the cursor is on the first byte of a multi-byte char.','line_number':6096,'multiline':False]