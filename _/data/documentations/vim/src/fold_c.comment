['text':' vi:set ts=8 sts=4 sw=4 noet:
 * vim600:fdm=marker fdl=1 fdc=3:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 * See README.txt for an overview of the Vim source code.
 ','line_number':1,'multiline':True]['text':'
 * fold.c: code for folding
 ','line_number':11,'multiline':True]['text':' local declarations. {{{1','line_number':19,'multiline':False]['text':' typedef fold_T {{{2','line_number':20,'multiline':False]['text':'
 * The toplevel folds for each window are stored in the w_folds growarray.
 * Each toplevel fold can contain an array of second level folds in the
 * fd_nested growarray.
 * The info stored in both growarrays is the same: An array of fold_T.
 ','line_number':21,'multiline':True]['text':' first line of fold; for nested fold','line_number':29,'multiline':False]['text':' relative to parent','line_number':30,'multiline':False]['text':' number of lines in the fold','line_number':31,'multiline':False]['text':' array of nested folds','line_number':32,'multiline':False]['text':' see below','line_number':33,'multiline':False]['text':' TRUE, FALSE or MAYBE: fold smaller than','line_number':34,'multiline':False]['text':' 'foldminlines'; MAYBE applies to nested','line_number':35,'multiline':False]['text':' folds too','line_number':36,'multiline':False]['text':' fold is open (nested ones can be closed)','line_number':39,'multiline':False]['text':' fold is closed','line_number':40,'multiline':False]['text':' depends on 'foldlevel' (nested folds too)','line_number':41,'multiline':False]['text':' maximum fold depth','line_number':43,'multiline':False]['text':' static functions {{{2','line_number':45,'multiline':False]['text':'
 * While updating the folds lines between invalid_top and invalid_bot have an
 * undefined fold level.  Only used for the window currently being updated.
 ','line_number':68,'multiline':True]['text':'
 * When using 'foldexpr' we sometimes get the level of the next line, which
 * calls foldlevel() to get the level of the current line, which hasn't been
 * stored yet.  To get around this chicken-egg problem the level of the
 * previous line is stored here when available.  prev_lnum is zero when the
 * level is not available.
 ','line_number':75,'multiline':True]['text':' Flags used for "done" argument of setManualFold.','line_number':85,'multiline':False]['text':' did close or open a fold','line_number':87,'multiline':False]['text':' did find a fold','line_number':88,'multiline':False]['text':' Exported folding functions. {{{1','line_number':94,'multiline':False]['text':' copyFoldingState() {{{2','line_number':95,'multiline':False]['text':'
 * Copy that folding state from window "wp_from" to window "wp_to".
 ','line_number':97,'multiline':True]['text':' hasAnyFolding() {{{2','line_number':108,'multiline':False]['text':'
 * Return TRUE if there may be folded lines in the current window.
 ','line_number':109,'multiline':True]['text':' very simple now, but can become more complex later','line_number':115,'multiline':False]['text':' hasFolding() {{{2','line_number':120,'multiline':False]['text':'
 * Return TRUE if line "lnum" in the current window is part of a closed
 * fold.
 * When returning TRUE, *firstp and *lastp are set to the first and last
 * lnum of the sequence of folded lines (skipped when NULL).
 ','line_number':121,'multiline':True]['text':' hasFoldingWin() {{{2','line_number':133,'multiline':False]['text':' when TRUE: use cached values of window','line_number':140,'multiline':False]['text':' where to store fold info','line_number':141,'multiline':False]['text':'
     * Return quickly when there is no folding at all in this window.
     ','line_number':157,'multiline':True]['text':'
	 * First look in cached info for displayed lines.  This is probably
	 * the fastest, but it can only be used if the entry is still valid.
	 ','line_number':169,'multiline':True]['text':'
	 * Recursively search for a fold that contains "lnum".
	 ','line_number':184,'multiline':True]['text':' Remember lowest level of fold that starts in "lnum".','line_number':193,'multiline':False]['text':' is this fold closed?','line_number':200,'multiline':False]['text':' Fold closed: Set last and quit loop.','line_number':205,'multiline':False]['text':' Fold found, but it's open: Check nested folds.  Line number is','line_number':210,'multiline':False]['text':' relative to containing fold.','line_number':211,'multiline':False]['text':' foldLevel() {{{2','line_number':244,'multiline':False]['text':'
 * Return fold level at line number "lnum" in the current window.
 ','line_number':246,'multiline':True]['text':' While updating the folds lines between invalid_top and invalid_bot have','line_number':252,'multiline':False]['text':' an undefined fold level.  Otherwise update the folds first.','line_number':253,'multiline':False]['text':' Return quickly when there is no folding at all in this window.','line_number':261,'multiline':False]['text':' lineFolded()	{{{2','line_number':269,'multiline':False]['text':'
 * Low level function to check if a line is folded.  Doesn't use any caching.
 * Return TRUE if line is folded.
 * Return FALSE if line is not folded.
 * Return MAYBE if the line is folded when next to a folded line.
 ','line_number':270,'multiline':True]['text':' foldedCount() {{{2','line_number':282,'multiline':False]['text':'
 * Count the number of lines that are folded at line number "lnum".
 * Normally "lnum" is the first line of a possible fold, and the returned
 * number is the number of lines in the fold.
 * Doesn't use caching from the displayed window.
 * Returns number of folded lines from "lnum", or 0 if line is not folded.
 * When "infop" is not NULL, fills *infop with the fold level info.
 ','line_number':283,'multiline':True]['text':' foldmethodIsManual() {{{2','line_number':301,'multiline':False]['text':'
 * Return TRUE if 'foldmethod' is "manual"
 ','line_number':302,'multiline':True]['text':' foldmethodIsIndent() {{{2','line_number':311,'multiline':False]['text':'
 * Return TRUE if 'foldmethod' is "indent"
 ','line_number':312,'multiline':True]['text':' foldmethodIsExpr() {{{2','line_number':321,'multiline':False]['text':'
 * Return TRUE if 'foldmethod' is "expr"
 ','line_number':322,'multiline':True]['text':' foldmethodIsMarker() {{{2','line_number':331,'multiline':False]['text':'
 * Return TRUE if 'foldmethod' is "marker"
 ','line_number':332,'multiline':True]['text':' foldmethodIsSyntax() {{{2','line_number':341,'multiline':False]['text':'
 * Return TRUE if 'foldmethod' is "syntax"
 ','line_number':342,'multiline':True]['text':' foldmethodIsDiff() {{{2','line_number':351,'multiline':False]['text':'
 * Return TRUE if 'foldmethod' is "diff"
 ','line_number':352,'multiline':True]['text':' closeFold() {{{2','line_number':361,'multiline':False]['text':'
 * Close fold for current window at line "lnum".
 * Repeat "count" times.
 ','line_number':362,'multiline':True]['text':' closeFoldRecurse() {{{2','line_number':372,'multiline':False]['text':'
 * Close fold for current window at line "lnum" recursively.
 ','line_number':373,'multiline':True]['text':' opFoldRange() {{{2','line_number':382,'multiline':False]['text':'
 * Open or Close folds for current window in lines "first" to "last".
 * Used for "zo", "zO", "zc" and "zC" in Visual mode.
 ','line_number':383,'multiline':True]['text':' TRUE to open, FALSE to close','line_number':391,'multiline':False]['text':' TRUE to do it recursively','line_number':392,'multiline':False]['text':' TRUE when Visual selection used','line_number':393,'multiline':False]['text':' avoid error messages','line_number':395,'multiline':False]['text':' Opening one level only: next fold to open is after the one going to','line_number':402,'multiline':False]['text':' be opened.','line_number':403,'multiline':False]['text':' Closing one level only: next line to close a fold is after just','line_number':407,'multiline':False]['text':' closed fold.','line_number':408,'multiline':False]['text':' Force a redraw to remove the Visual highlighting.','line_number':414,'multiline':False]['text':' openFold() {{{2','line_number':419,'multiline':False]['text':'
 * Open fold for current window at line "lnum".
 * Repeat "count" times.
 ','line_number':420,'multiline':True]['text':' openFoldRecurse() {{{2','line_number':430,'multiline':False]['text':'
 * Open fold for current window at line "lnum" recursively.
 ','line_number':431,'multiline':True]['text':' foldOpenCursor() {{{2','line_number':440,'multiline':False]['text':'
 * Open folds until the cursor line is not in a closed fold.
 ','line_number':441,'multiline':True]['text':' newFoldLevel() {{{2','line_number':460,'multiline':False]['text':'
 * Set new foldlevel for current window.
 ','line_number':461,'multiline':True]['text':'
	 * Set the same foldlevel in other windows in diff mode.
	 ','line_number':474,'multiline':True]['text':' Set all flags for the first level of folds to FD_LEVEL.  Following','line_number':498,'multiline':False]['text':' manual open/close will then change the flags to FD_OPEN or','line_number':499,'multiline':False]['text':' FD_CLOSED for those folds that don't use 'foldlevel'.','line_number':500,'multiline':False]['text':' foldCheckClose() {{{2','line_number':509,'multiline':False]['text':'
 * Apply 'foldlevel' to all folds that don't contain the cursor.
 ','line_number':510,'multiline':True]['text':' 'foldclose' can only be "all" right now','line_number':519,'multiline':False]['text':' checkCloseRec() {{{2','line_number':526,'multiline':False]['text':' Only manually opened folds may need to be closed.','line_number':537,'multiline':False]['text':' foldCreateAllowed() {{{2','line_number':554,'multiline':False]['text':'
 * Return TRUE if it's allowed to manually create or delete a fold.
 * Give an error message and return FALSE if not.
 ','line_number':555,'multiline':True]['text':' foldCreate() {{{2','line_number':571,'multiline':False]['text':'
 * Create a fold from line "start" to line "end" (inclusive) in the current
 * window.
 ','line_number':572,'multiline':True]['text':' reverse the range','line_number':592,'multiline':False]['text':' When 'foldmethod' is "marker" add markers, which creates the folds.','line_number':599,'multiline':False]['text':' Find the place to insert the new fold.','line_number':608,'multiline':False]['text':' New fold is completely inside this fold: Go one level','line_number':620,'multiline':False]['text':' deeper.','line_number':621,'multiline':False]['text':' This fold and new fold overlap: Insert here and move some','line_number':637,'multiline':False]['text':' folds inside the new fold.','line_number':638,'multiline':False]['text':' Count number of folds that will be contained in the new fold.','line_number':654,'multiline':False]['text':' If the first fold starts before the new fold, let the new fold','line_number':660,'multiline':False]['text':' start there.  Otherwise the existing fold would change.','line_number':661,'multiline':False]['text':' When last contained fold isn't completely contained, adjust end','line_number':665,'multiline':False]['text':' of new fold.','line_number':666,'multiline':False]['text':' Move contained folds to inside new fold.','line_number':669,'multiline':False]['text':' Adjust line numbers in contained folds to be relative to the','line_number':674,'multiline':False]['text':' new fold.','line_number':675,'multiline':False]['text':' Move remaining entries to after the new fold.','line_number':679,'multiline':False]['text':' insert new fold','line_number':685,'multiline':False]['text':' We want the new fold to be closed.  If it would remain open because','line_number':690,'multiline':False]['text':' of using 'foldlevel', need to adjust fd_flags of containing folds.','line_number':691,'multiline':False]['text':' redraw','line_number':699,'multiline':False]['text':' deleteFold() {{{2','line_number':703,'multiline':False]['text':'
 * Delete a fold at line "start" in the current window.
 * When "end" is not 0, delete all folds from "start" to "end".
 * When "recursive" is TRUE delete recursively.
 ','line_number':704,'multiline':True]['text':' TRUE when Visual selection used','line_number':714,'multiline':False]['text':' Find the deepest fold for "start".','line_number':734,'multiline':False]['text':' lnum is inside this fold, remember info','line_number':743,'multiline':False]['text':' if "lnum" is folded, don't check nesting','line_number':748,'multiline':False]['text':' check nested folds','line_number':753,'multiline':False]['text':' redraw window','line_number':781,'multiline':False]['text':' Force a redraw to remove the Visual highlighting.','line_number':788,'multiline':False]['text':' Deleting markers may make cursor column invalid.','line_number':793,'multiline':False]['text':' clearFolding() {{{2','line_number':800,'multiline':False]['text':'
 * Remove all folding for window "win".
 ','line_number':801,'multiline':True]['text':' foldUpdate() {{{2','line_number':811,'multiline':False]['text':'
 * Update folds for changes in the buffer of a window.
 * Note that inserted/deleted lines must have already been taken care of by
 * calling foldMarkAdjust().
 * The changes in lines from top to bot (inclusive).
 ','line_number':812,'multiline':True]['text':' will update later','line_number':827,'multiline':False]['text':' Mark all folds from top to bot (or bot to top) as maybe-small.','line_number':836,'multiline':False]['text':' reset got_int here, otherwise it won't work','line_number':861,'multiline':False]['text':' foldUpdateAll() {{{2','line_number':868,'multiline':False]['text':'
 * Update all lines in a window for folding.
 * Used when a fold setting changes or after reloading the buffer.
 * The actual updating is postponed until fold info is used, to avoid doing
 * every time a setting is changed or a syntax item is added.
 ','line_number':869,'multiline':True]['text':' foldMoveTo() {{{2','line_number':882,'multiline':False]['text':'
 * If "updown" is FALSE: Move to the start or end of the fold.
 * If "updown" is TRUE: move to fold at the same level.
 * If not moved return FAIL.
 ','line_number':883,'multiline':True]['text':' FORWARD or BACKWARD','line_number':891,'multiline':False]['text':' Repeat "count" times.','line_number':908,'multiline':False]['text':' Find nested folds.  Stop when a fold is closed.  The deepest fold','line_number':911,'multiline':False]['text':' that moves the cursor is used.','line_number':912,'multiline':False]['text':' When moving up, consider a fold above the cursor; when','line_number':929,'multiline':False]['text':' moving down consider a fold below the cursor.','line_number':930,'multiline':False]['text':' don't look for contained folds, they will always move','line_number':942,'multiline':False]['text':' the cursor too far.','line_number':943,'multiline':False]['text':' Check if this fold is closed.','line_number':949,'multiline':False]['text':' "[z" and "]z" stop at closed fold','line_number':954,'multiline':False]['text':' to start of next fold if there is one','line_number':963,'multiline':False]['text':' to end of previous fold if there is one','line_number':973,'multiline':False]['text':' Open fold found, set cursor to its start/end and then check','line_number':984,'multiline':False]['text':' nested folds.','line_number':985,'multiline':False]['text':' Check nested folds (if any).','line_number':1003,'multiline':False]['text':' foldInitWin() {{{2','line_number':1023,'multiline':False]['text':'
 * Init the fold info in a new window.
 ','line_number':1024,'multiline':True]['text':' find_wl_entry() {{{2','line_number':1033,'multiline':False]['text':'
 * Find an entry in the win->w_lines[] array for buffer line "lnum".
 * Only valid entries are considered (for entries where wl_valid is FALSE the
 * line number can be wrong).
 * Returns index of entry or -1 if not found.
 ','line_number':1034,'multiline':True]['text':' foldAdjustVisual() {{{2','line_number':1056,'multiline':False]['text':'
 * Adjust the Visual area to include any fold at the start or end completely.
 ','line_number':1057,'multiline':True]['text':' prevent cursor from moving on the trail byte','line_number':1089,'multiline':False]['text':' cursor_foldstart() {{{2','line_number':1094,'multiline':False]['text':'
 * Move the cursor to the first line of a closed fold.
 ','line_number':1095,'multiline':True]['text':' Internal functions for "fold_T" {{{1','line_number':1104,'multiline':False]['text':' cloneFoldGrowArray() {{{2','line_number':1105,'multiline':False]['text':'
 * Will "clone" (i.e deep copy) a garray_T of folds.
 *
 * Return FAIL if the operation cannot be completed, otherwise OK.
 ','line_number':1106,'multiline':True]['text':' foldFind() {{{2','line_number':1138,'multiline':False]['text':'
 * Search for line "lnum" in folds of growarray "gap".
 * Set "*fpp" to the fold struct for the fold that contains "lnum" or
 * the first fold below it (careful: it can be beyond the end of the array!).
 * Returns FALSE when there is no fold that contains "lnum".
 ','line_number':1139,'multiline':True]['text':'
     * Perform a binary search.
     * "low" is lowest index of possible match.
     * "high" is highest index of possible match.
     ','line_number':1158,'multiline':True]['text':' fold below lnum, adjust high','line_number':1170,'multiline':False]['text':' fold above lnum, adjust low','line_number':1173,'multiline':False]['text':' lnum is inside this fold','line_number':1177,'multiline':False]['text':' foldLevelWin() {{{2','line_number':1186,'multiline':False]['text':'
 * Return fold level at line number "lnum" in window "wp".
 ','line_number':1187,'multiline':True]['text':' Recursively search for a fold that contains "lnum".','line_number':1198,'multiline':False]['text':' Check nested folds.  Line number is relative to containing fold.','line_number':1204,'multiline':False]['text':' checkupdate() {{{2','line_number':1213,'multiline':False]['text':'
 * Check if the folds in window "wp" are invalid and update them if needed.
 ','line_number':1214,'multiline':True]['text':' will update all','line_number':1223,'multiline':False]['text':' setFoldRepeat() {{{2','line_number':1227,'multiline':False]['text':'
 * Open or close fold for current window at line "lnum".
 * Repeat "count" times.
 ','line_number':1228,'multiline':True]['text':' Only give an error message when no fold could be opened.','line_number':1244,'multiline':False]['text':' setManualFold() {{{2','line_number':1252,'multiline':False]['text':'
 * Open or close the fold in the current window which contains "lnum".
 * Also does this for other windows in diff mode when needed.
 ','line_number':1253,'multiline':True]['text':' TRUE when opening, FALSE when closing','line_number':1260,'multiline':False]['text':' TRUE when closing/opening recursive','line_number':1261,'multiline':False]['text':'
	 * Do the same operation in other windows in diff mode.  Calculate the
	 * line number from the diffs.
	 ','line_number':1270,'multiline':True]['text':' setManualFoldWin() {{{2','line_number':1289,'multiline':False]['text':'
 * Open or close the fold in window "wp" which contains "lnum".
 * "donep", when not NULL, points to flag that is set to DONE_FOLD when some
 * fold was found and to DONE_ACTION when some fold was opened or closed.
 * When "donep" is NULL give an error message when no fold was found for
 * "lnum", but only if "wp" is "curwin".
 * Return the line number of the next line that could be closed.
 * It's only valid when "opening" is TRUE!
 ','line_number':1290,'multiline':True]['text':' TRUE when opening, FALSE when closing','line_number':1303,'multiline':False]['text':' TRUE when closing/opening recursive','line_number':1304,'multiline':False]['text':'
     * Find the fold, open or close it.
     ','line_number':1321,'multiline':True]['text':' If there is a following fold, continue there next time.','line_number':1329,'multiline':False]['text':' lnum is inside this fold','line_number':1335,'multiline':False]['text':' If there is a following fold, continue there next time.','line_number':1338,'multiline':False]['text':' Change from level-dependent folding to manual.','line_number':1342,'multiline':False]['text':' Simple case: Close recursively means closing the fold.','line_number':1355,'multiline':False]['text':' When opening, open topmost closed fold.','line_number':1366,'multiline':False]['text':' fold is open, check nested folds','line_number':1377,'multiline':False]['text':' When closing and not recurse, close deepest open fold.','line_number':1386,'multiline':False]['text':' foldOpenNested() {{{2','line_number':1406,'multiline':False]['text':'
 * Open all nested folds in fold "fpr" recursively.
 ','line_number':1407,'multiline':True]['text':' deleteFoldEntry() {{{2','line_number':1424,'multiline':False]['text':'
 * Delete fold "idx" from growarray "gap".
 * When "recursive" is TRUE also delete all the folds contained in it.
 * When "recursive" is FALSE contained folds are moved one level up.
 ','line_number':1425,'multiline':True]['text':' recursively delete the contained folds','line_number':1441,'multiline':False]['text':' Move nested folds one level up, to overwrite the fold that is','line_number':1449,'multiline':False]['text':' deleted.','line_number':1450,'multiline':False]['text':' Get "fp" again, the array may have been reallocated.','line_number':1454,'multiline':False]['text':' adjust fd_top and fd_flags for the moved folds','line_number':1457,'multiline':False]['text':' move the existing folds down to make room','line_number':1468,'multiline':False]['text':' move the contained folds one level up','line_number':1472,'multiline':False]['text':' deleteFoldRecurse() {{{2','line_number':1480,'multiline':False]['text':'
 * Delete nested folds in a fold.
 ','line_number':1481,'multiline':True]['text':' foldMarkAdjust() {{{2','line_number':1494,'multiline':False]['text':'
 * Update line numbers of folds for inserted/deleted lines.
 ','line_number':1495,'multiline':True]['text':' If deleting marks from line1 to line2, but not deleting all those','line_number':1506,'multiline':False]['text':' lines, set line2 so that only deleted lines have their folds removed.','line_number':1507,'multiline':False]['text':' If appending a line in Insert mode, it should be included in the fold','line_number':1510,'multiline':False]['text':' just above the line.','line_number':1511,'multiline':False]['text':' foldMarkAdjustRecurse() {{{2','line_number':1517,'multiline':False]['text':' In Insert mode an inserted line at the top of a fold is considered part','line_number':1534,'multiline':False]['text':' of the fold, otherwise it isn't.','line_number':1535,'multiline':False]['text':' Find the fold containing or just below "line1".','line_number':1541,'multiline':False]['text':'
     * Adjust all folds below "line1" that are affected.
     ','line_number':1544,'multiline':True]['text':'
	 * Check for these situations:
	 *	  1  2	3
	 *	  1  2	3
	 * line1     2	3  4  5
	 *	     2	3  4  5
	 *	     2	3  4  5
	 * line2     2	3  4  5
	 *		3     5  6
	 *		3     5  6
	 ','line_number':1549,'multiline':True]['text':' last line of fold','line_number':1561,'multiline':False]['text':' 1. fold completely above line1: nothing to do','line_number':1563,'multiline':False]['text':' 6. fold below line2: only adjust for amount_after','line_number':1567,'multiline':False]['text':' 4. fold completely contained in range','line_number':1578,'multiline':False]['text':' Deleting lines: delete the fold completely','line_number':1581,'multiline':False]['text':' adjust index for deletion','line_number':1583,'multiline':False]['text':' 2 or 3: need to correct nested folds too','line_number':1593,'multiline':False]['text':' 2. fold contains line1, line2 is below fold','line_number':1598,'multiline':False]['text':' 3. fold contains line1 and line2','line_number':1606,'multiline':False]['text':' 5. fold is below line1 and contains line2; need to','line_number':1612,'multiline':False]['text':' correct nested folds too','line_number':1613,'multiline':False]['text':' getDeepestNesting() {{{2','line_number':1640,'multiline':False]['text':'
 * Get the lowest 'foldlevel' value that makes the deepest nested fold in the
 * current window open.
 ','line_number':1641,'multiline':True]['text':' check_closed() {{{2','line_number':1671,'multiline':False]['text':'
 * Check if a fold is closed and update the info needed to check nested folds.
 ','line_number':1672,'multiline':True]['text':' TRUE: outer fold had FD_LEVEL','line_number':1679,'multiline':False]['text':' folding depth','line_number':1680,'multiline':False]['text':' TRUE: outer this had fd_small == MAYBE','line_number':1681,'multiline':False]['text':' line number offset for fp->fd_top','line_number':1682,'multiline':False]['text':' Check if this fold is closed.  If the flag is FD_LEVEL this','line_number':1686,'multiline':False]['text':' fold and all folds it contains depend on 'foldlevel'.','line_number':1687,'multiline':False]['text':' Small fold isn't closed anyway.','line_number':1697,'multiline':False]['text':' checkSmall() {{{2','line_number':1711,'multiline':False]['text':'
 * Update fd_small field of fold "fp".
 ','line_number':1712,'multiline':True]['text':' offset for fp->fd_top','line_number':1719,'multiline':False]['text':' Mark any nested folds to maybe-small','line_number':1727,'multiline':False]['text':' setSmallMaybe() {{{2','line_number':1748,'multiline':False]['text':'
 * Set small flags in "gap" to MAYBE.
 ','line_number':1749,'multiline':True]['text':' foldCreateMarkers() {{{2','line_number':1763,'multiline':False]['text':'
 * Create a fold from line "start" to line "end" (inclusive) in the current
 * window by adding markers.
 ','line_number':1764,'multiline':True]['text':' Update both changes here, to avoid all folds after the start are','line_number':1781,'multiline':False]['text':' changed when the start marker is inserted and the end isn't.','line_number':1782,'multiline':False]['text':' foldAddMarker() {{{2','line_number':1786,'multiline':False]['text':'
 * Add "marker[markerlen]" in 'commentstring' to line "lnum".
 ','line_number':1787,'multiline':True]['text':' Allocate a new line: old-line + 'cms'-start + marker + 'cms'-end','line_number':1800,'multiline':False]['text':' Check if the line ends with an unclosed comment','line_number':1807,'multiline':False]['text':' Append the marker to the end of the line','line_number':1813,'multiline':False]['text':' deleteFoldMarkers() {{{2','line_number':1826,'multiline':False]['text':'
 * Delete the markers for a fold, causing it to be deleted.
 ','line_number':1827,'multiline':True]['text':' offset for fp->fd_top','line_number':1834,'multiline':False]['text':' foldDelMarker() {{{2','line_number':1847,'multiline':False]['text':'
 * Delete marker "marker[markerlen]" at the end of line "lnum".
 * Delete 'commentstring' if it matches.
 * If the marker is not found, there is no error message.  Could be a missing
 * close-marker.
 ','line_number':1848,'multiline':True]['text':' end marker may be missing and fold extends below the last line','line_number':1864,'multiline':False]['text':' Found the marker, include a digit if it's there.','line_number':1871,'multiline':False]['text':' Also delete 'commentstring' if it matches.','line_number':1877,'multiline':False]['text':' Make new line: text-before-marker + text-after-marker','line_number':1889,'multiline':False]['text':' get_foldtext() {{{2','line_number':1902,'multiline':False]['text':'
 * Return the text for a closed fold at line "lnum", with last line "lnume".
 * When 'foldtext' isn't set puts the result in "buf[FOLD_TEXT_LEN]".
 * Otherwise the result is in allocated memory.
 ','line_number':1903,'multiline':True]['text':' an error occurred when evaluating 'fdt' setting','line_number':1918,'multiline':False]['text':' window changed, try evaluating foldtext setting once again','line_number':1926,'multiline':False]['text':' a previous error should not abort evaluating 'foldexpr'','line_number':1930,'multiline':False]['text':' Set "v:foldstart" and "v:foldend".','line_number':1939,'multiline':False]['text':' Set "v:folddashes" to a string of "level" dashes.','line_number':1943,'multiline':False]['text':' Set "v:foldlevel" to "level".','line_number':1944,'multiline':False]['text':' skip evaluating 'foldtext' on errors','line_number':1953,'multiline':False]['text':' handle exceptions, but don't display errors','line_number':1963,'multiline':False]['text':' Replace unprintable characters, if there are any.  But','line_number':1985,'multiline':False]['text':' replace a TAB with a space.','line_number':1986,'multiline':False]['text':' foldtext_cleanup() {{{2','line_number':2025,'multiline':False]['text':'
 * Remove 'foldmarker' and 'commentstring' from "str" (in-place).
 ','line_number':2027,'multiline':True]['text':' first part or the whole comment','line_number':2033,'multiline':False]['text':' length of cms_start','line_number':2034,'multiline':False]['text':' last part of the comment or NULL','line_number':2035,'multiline':False]['text':' length of cms_end','line_number':2036,'multiline':False]['text':' Ignore leading and trailing white space in 'commentstring'.','line_number':2043,'multiline':False]['text':' locate "%s" in 'commentstring', use the part before and after it.','line_number':2049,'multiline':False]['text':' exclude white space before "%s"','line_number':2056,'multiline':False]['text':' skip "%s" and white space after it','line_number':2060,'multiline':False]['text':' May remove 'commentstring' start.  Useful when it's a double','line_number':2079,'multiline':False]['text':' quote and we already removed a double quote.','line_number':2080,'multiline':False]['text':' Folding by indent, expr, marker and syntax. {{{1','line_number':2118,'multiline':False]['text':' Define "fline_T", passed to get fold level for a line. {{{2','line_number':2119,'multiline':False]['text':' window','line_number':2122,'multiline':False]['text':' current line number','line_number':2123,'multiline':False]['text':' offset between lnum and real line number','line_number':2124,'multiline':False]['text':' line nr used by foldUpdateIEMSRecurse()','line_number':2125,'multiline':False]['text':' current level (-1 for undefined)','line_number':2126,'multiline':False]['text':' level used for next line','line_number':2127,'multiline':False]['text':' number of folds that are forced to start at','line_number':2128,'multiline':False]['text':' this line.','line_number':2129,'multiline':False]['text':' level of fold that is forced to end below','line_number':2130,'multiline':False]['text':' this line','line_number':2131,'multiline':False]['text':' level of fold that is forced to end above','line_number':2132,'multiline':False]['text':' this line (copy of "end" of prev. line)','line_number':2133,'multiline':False]['text':' Flag is set when redrawing is needed.','line_number':2136,'multiline':False]['text':' Function declarations. {{{2','line_number':2139,'multiline':False]['text':' foldUpdateIEMS() {{{2','line_number':2153,'multiline':False]['text':'
 * Update the folding for window "wp", at least from lines "top" to "bot".
 * Return TRUE if any folds did change.
 ','line_number':2154,'multiline':True]['text':' Avoid problems when being called recursively.','line_number':2168,'multiline':False]['text':' Need to update all folds.','line_number':2174,'multiline':False]['text':' Mark all folds as maybe-small.','line_number':2179,'multiline':False]['text':' add the context for "diff" folding','line_number':2184,'multiline':False]['text':' When deleting lines at the end of the buffer "top" can be past the end','line_number':2195,'multiline':False]['text':' of the buffer.','line_number':2196,'multiline':False]['text':' Init marker variables to speed up foldlevelMarker().','line_number':2216,'multiline':False]['text':' Need to get the level of the line above top, it is used if there is','line_number':2219,'multiline':False]['text':' no marker at the top.','line_number':2220,'multiline':False]['text':' Get the fold level at top - 1.','line_number':2223,'multiline':False]['text':' The fold may end just above the top, check for that.','line_number':2226,'multiline':False]['text':' If a fold started here, we already had the level, if it stops','line_number':2231,'multiline':False]['text':' here, we need to use lvl_next.  Could also start and end a fold','line_number':2232,'multiline':False]['text':' in the same line.','line_number':2233,'multiline':False]['text':' start one line back, because a "<1" may indicate the end of a','line_number':2248,'multiline':False]['text':' fold in the topline','line_number':2249,'multiline':False]['text':' Start one line back, because if the line above "top" has an','line_number':2262,'multiline':False]['text':' undefined fold level, folding it relies on the line under it,','line_number':2263,'multiline':False]['text':' which is "top".','line_number':2264,'multiline':False]['text':' Backup to a line for which the fold level is defined.  Since it's','line_number':2269,'multiline':False]['text':' always defined for line one, we will stop there.','line_number':2270,'multiline':False]['text':' Reset lvl_next each time, because it will be set to a value for','line_number':2274,'multiline':False]['text':' the next line, but we search backwards here.','line_number':2275,'multiline':False]['text':'
     * If folding is defined by the syntax, it is possible that a change in
     * one line will cause all sub-folds of the current fold to change (e.g.,
     * closing a C-style comment can cause folds in the subsequent lines to
     * appear). To take that into account we should adjust the value of "bot"
     * to point to the end of the current fold:
     ','line_number':2283,'multiline':True]['text':' Do at least one line.','line_number':2319,'multiline':False]['text':' Always stop at the end of the file ("end" can be past the end of','line_number':2324,'multiline':False]['text':' the file).','line_number':2325,'multiline':False]['text':' For "marker", "expr"  and "syntax"  methods: If a change caused','line_number':2330,'multiline':False]['text':' a fold to be removed, we need to continue at least until where','line_number':2331,'multiline':False]['text':' it ended.','line_number':2332,'multiline':False]['text':' For "syntax" method: Compare the foldlevel that the syntax','line_number':2346,'multiline':False]['text':' tells us to the foldlevel from the existing folds.  If they','line_number':2347,'multiline':False]['text':' don't match continue updating folds.','line_number':2348,'multiline':False]['text':' A level 1 fold starts at a line with foldlevel > 0.','line_number':2354,'multiline':False]['text':' There can't be any folds from start until end now.','line_number':2373,'multiline':False]['text':' If some fold changed, need to redraw and position cursor.','line_number':2376,'multiline':False]['text':' If we updated folds past "bot", need to redraw more lines.  Don't do','line_number':2380,'multiline':False]['text':' this in other situations, the changed lines will be redrawn anyway and','line_number':2381,'multiline':False]['text':' this method can cause the whole window to be updated.','line_number':2382,'multiline':False]['text':' foldUpdateIEMSRecurse() {{{2','line_number':2394,'multiline':False]['text':'
 * Update a fold that starts at "flp->lnum".  At this line there is always a
 * valid foldlevel, and its level >= "level".
 * "flp" is valid for "flp->lnum" when called and it's valid when returning.
 * "flp->lnum" is set to the lnum just below the fold, if it ends before
 * "bot", it's "bot" plus one if the fold continues and it's bigger when using
 * the marker method and a text change made following folds to change.
 * When returning, "flp->lnum_save" is the line number that was used to get
 * the level when the level at "flp->lnum" is invalid.
 * Remove any folds from "startlnum" up to here at this level.
 * Recursively update nested folds.
 * Below line "bot" there are no changes in the text.
 * "flp->lnum", "flp->lnum_save" and "bot" are relative to the start of the
 * outer fold.
 * "flp->off" is the offset to the real line number in the buffer.
 *
 * All this would be a lot simpler if all folds in the range would be deleted
 * and then created again.  But we would lose all information about the
 * folds, even when making changes that don't affect the folding (e.g. "vj~").
 *
 * Returns bot, which may have been increased for lines that also need to be
 * updated as a result of a detected change in the fold.
 ','line_number':2395,'multiline':True]['text':' flags used by containing fold','line_number':2426,'multiline':False]['text':' first lnum we got','line_number':2433,'multiline':False]['text':'
     * If using the marker method, the start line is not the start of a fold
     * at the level we're dealing with and the level is non-zero, we must use
     * the previous fold.  But ignore a fold that starts at or below
     * startlnum, it must be deleted.
     ','line_number':2439,'multiline':True]['text':'
     * Loop over all lines in this fold, or until "bot" is hit.
     * Handle nested folds inside of this fold.
     * "flp->lnum" is the current line.  When finding the end of the fold, it
     * is just below the end of the fold.
     * "*flp" contains the level of the line "flp->lnum" or a following one if
     * there are lines with an invalid fold level.  "flp->lnum_save" is the
     * line number that was used to get the fold level (below "flp->lnum" when
     * it has an invalid fold level).  When called the fold level is always
     * valid, thus "flp->lnum_save" is equal to "flp->lnum".
     ','line_number':2454,'multiline':True]['text':' Updating folds can be slow, check for CTRL-C.','line_number':2468,'multiline':False]['text':' Set "lvl" to the level of line "flp->lnum".  When flp->start is set','line_number':2471,'multiline':False]['text':' and after the first line of the fold, set the level to zero to','line_number':2472,'multiline':False]['text':' force the fold to end.  Do the same when had_end is set: Previous','line_number':2473,'multiline':False]['text':' line was marked as end of a fold.','line_number':2474,'multiline':False]['text':' For "marker" and "syntax" methods:','line_number':2484,'multiline':False]['text':' - If a change caused a nested fold to be removed, we need to','line_number':2485,'multiline':False]['text':'   delete it and continue at least until where it ended.','line_number':2486,'multiline':False]['text':' - If a change caused a nested fold to be created, or this fold','line_number':2487,'multiline':False]['text':'   to continue below its original end, need to finish this fold.','line_number':2488,'multiline':False]['text':' Compute how deep the folds currently are, if it's deeper','line_number':2497,'multiline':False]['text':' than "lvl" then some must be deleted, need to update','line_number':2498,'multiline':False]['text':' at least one nested fold.','line_number':2499,'multiline':False]['text':' At the start of the first nested fold and at the end of the current','line_number':2519,'multiline':False]['text':' fold: check if existing folds at this level, before the current','line_number':2520,'multiline':False]['text':' one, need to be deleted or truncated.','line_number':2521,'multiline':False]['text':'
	     * Remove or update folds that have lines between startlnum and
	     * firstlnum.
	     ','line_number':2529,'multiline':True]['text':' set concat to 1 if it's allowed to concatenate this fold','line_number':2535,'multiline':False]['text':' with a previous one that touches it.','line_number':2536,'multiline':False]['text':' Find an existing fold to re-use.  Preferably one that','line_number':2542,'multiline':False]['text':' includes startlnum, otherwise one that ends just before','line_number':2543,'multiline':False]['text':' startlnum or starts after it.','line_number':2544,'multiline':False]['text':' Use existing fold for the new fold.  If it starts','line_number':2556,'multiline':False]['text':' before where we started looking, extend it.  If it','line_number':2557,'multiline':False]['text':' starts at another line, update nested folds to keep','line_number':2558,'multiline':False]['text':' their position, compensating for the new fd_top.','line_number':2559,'multiline':False]['text':' have found a fold beginning where we want','line_number':2562,'multiline':False]['text':' like lines are inserted','line_number':2567,'multiline':False]['text':' like lines are deleted','line_number':2572,'multiline':False]['text':'
			     * Before there was a fold spanning from above
			     * startlnum to below firstlnum. This fold is valid
			     * above startlnum (because we are not updating
			     * that range), but there should now be a break in
			     * it.
			     * If the break is because we are now forced to
			     * start a new fold at the level "level" at line
			     * fline->lnum, then we need to split the fold at
			     * fline->lnum.
			     * If the break is because the range
			     * [startlnum, firstlnum) is now at a lower indent
			     * than "level", we need to split the fold in this
			     * range.
			     * Any splits have to be done recursively.
			     ','line_number':2589,'multiline':True]['text':' If using the "marker" or "syntax" method, we','line_number':2621,'multiline':False]['text':' need to continue until the end of the fold is','line_number':2622,'multiline':False]['text':' found.','line_number':2623,'multiline':False]['text':' A fold that starts at or after startlnum and stops','line_number':2647,'multiline':False]['text':' before the new fold must be deleted.  Continue','line_number':2648,'multiline':False]['text':' looking for the next one.','line_number':2649,'multiline':False]['text':' A fold has some lines above startlnum, truncate it','line_number':2655,'multiline':False]['text':' to stop just above startlnum.','line_number':2656,'multiline':False]['text':' Insert new fold.  Careful: ga_data may be NULL and it','line_number':2666,'multiline':False]['text':' may change!','line_number':2667,'multiline':False]['text':' The new fold continues until bot, unless we find the','line_number':2675,'multiline':False]['text':' end earlier.','line_number':2676,'multiline':False]['text':' When the containing fold is open, the new fold is open.','line_number':2679,'multiline':False]['text':' The new fold is closed if the fold above it is closed.','line_number':2680,'multiline':False]['text':' The first fold depends on the containing fold.','line_number':2681,'multiline':False]['text':' If using the "marker", "expr" or "syntax" method, we','line_number':2696,'multiline':False]['text':' need to continue until the end of the fold is found.','line_number':2697,'multiline':False]['text':'
	     * Found a line with a lower foldlevel, this fold ends just above
	     * "flp->lnum".
	     ','line_number':2710,'multiline':True]['text':'
	 * The fold includes the line "flp->lnum" and "flp->lnum_save".
	 * Check "fp" for safety.
	 ','line_number':2717,'multiline':True]['text':'
	     * There is a nested fold, handle it recursively.
	     ','line_number':2723,'multiline':True]['text':' At least do one line (can happen when finish is TRUE).','line_number':2726,'multiline':False]['text':' Line numbers in the nested fold are relative to the start of','line_number':2730,'multiline':False]['text':' this fold.','line_number':2731,'multiline':False]['text':' This fold may end at the same line, don't incr. flp->lnum.','line_number':2745,'multiline':False]['text':'
	     * Get the level of the next line, then continue the loop to check
	     * if it ends there.
	     * Skip over undefined lines, to find the foldlevel after it.
	     * For the last line in the file the foldlevel is always valid.
	     ','line_number':2749,'multiline':True]['text':' Make the previous level available to foldlevel().','line_number':2759,'multiline':False]['text':' leave flp->lnum_save to lnum of the line that was used to get','line_number':2774,'multiline':False]['text':' the level, flp->lnum to the lnum of the next line.','line_number':2775,'multiline':False]['text':' only happens when got_int is set','line_number':2781,'multiline':False]['text':'
     * Get here when:
     * lvl < level: the folds ends just above "flp->lnum"
     * lvl >= level: fold continues below "bot"
     ','line_number':2784,'multiline':True]['text':' Current fold at least extends until lnum.','line_number':2790,'multiline':False]['text':' running into the end of the buffer (deleted last line)','line_number':2798,'multiline':False]['text':' Delete contained folds from the end of the last one found until where','line_number':2801,'multiline':False]['text':' we stopped looking.','line_number':2802,'multiline':False]['text':' End of fold found, update the length when it got shorter.','line_number':2808,'multiline':False]['text':' fold continued below bot','line_number':2813,'multiline':False]['text':' marker method: truncate the fold and make sure the','line_number':2818,'multiline':False]['text':' previously included lines are processed again','line_number':2819,'multiline':False]['text':' indent or expr method: split fold to create a new one','line_number':2825,'multiline':False]['text':' below bot','line_number':2826,'multiline':False]['text':' delete following folds that end before the current line','line_number':2838,'multiline':False]['text':' Make fold that includes lnum start at lnum.','line_number':2849,'multiline':False]['text':' merge new fold with existing fold that follows','line_number':2860,'multiline':False]['text':' Need to redraw the lines we inspected, which might be further down than','line_number':2869,'multiline':False]['text':' was asked for.','line_number':2870,'multiline':False]['text':' foldInsert() {{{2','line_number':2877,'multiline':False]['text':'
 * Insert a new fold in "gap" at position "i".
 * Returns OK for success, FAIL for failure.
 ','line_number':2878,'multiline':True]['text':' foldSplit() {{{2','line_number':2897,'multiline':False]['text':'
 * Split the "i"th fold in "gap", which starts before "top" and ends below
 * "bot" in two pieces, one ending above "top" and the other starting below
 * "bot".
 * The caller must first have taken care of any nested folds from "top" to
 * "bot"!
 ','line_number':2898,'multiline':True]['text':' The fold continues below bot, need to split it.','line_number':2919,'multiline':False]['text':' Move nested folds below bot to new fold.  There can't be','line_number':2929,'multiline':False]['text':' any between top and bot, they have been removed by the caller.','line_number':2930,'multiline':False]['text':' foldRemove() {{{2','line_number':2953,'multiline':False]['text':'
 * Remove folds within the range "top" to and including "bot".
 * Check for these situations:
 *      1  2  3
 *      1  2  3
 * top     2  3  4  5
 *	   2  3  4  5
 * bot	   2  3  4  5
 *	      3     5  6
 *	      3     5  6
 *
 * 1: not changed
 * 2: truncate to stop above "top"
 * 3: split in two parts, one stops above "top", other starts below "bot".
 * 4: deleted
 * 5: made to start below "bot".
 * 6: not changed
 ','line_number':2954,'multiline':True]['text':' nothing to do','line_number':2978,'multiline':False]['text':' Find fold that includes top or a following one.','line_number':2982,'multiline':False]['text':' 2: or 3: need to delete nested folds','line_number':2985,'multiline':False]['text':' 3: need to split it.','line_number':2989,'multiline':False]['text':' 2: truncate fold at "top".','line_number':2994,'multiline':False]['text':' 6: Found a fold below bot, can stop looking.','line_number':3003,'multiline':False]['text':' Found an entry below top.','line_number':3008,'multiline':False]['text':' 5: Make fold that includes bot start below bot.','line_number':3012,'multiline':False]['text':' 4: Delete completely contained fold.','line_number':3021,'multiline':False]['text':' foldReverseOrder() {{{2','line_number':3027,'multiline':False]['text':' foldMoveRange() {{{2','line_number':3046,'multiline':False]['text':'
 * Move folds within the inclusive range "line1" to "line2" to after "dest"
 * requires "line1" <= "line2" <= "dest"
 *
 * There are the following situations for the first fold at or below line1 - 1.
 *       1  2  3  4
 *       1  2  3  4
 * line1    2  3  4
 *          2  3  4  5  6  7
 * line2       3  4  5  6  7
 *             3  4     6  7  8  9
 * dest           4        7  8  9
 *                4        7  8    10
 *                4        7  8    10
 *
 * In the following descriptions, "moved" means moving in the buffer, *and* in
 * the fold array.
 * Meanwhile, "shifted" just means moving in the buffer.
 * 1. not changed
 * 2. truncated above line1
 * 3. length reduced by  line2 - line1, folds starting between the end of 3 and
 *    dest are truncated and shifted up
 * 4. internal folds moved (from [line1, line2] to dest)
 * 5. moved to dest.
 * 6. truncated below line2 and moved.
 * 7. length reduced by line2 - dest, folds starting between line2 and dest are
 *    removed, top is moved down by move_len.
 * 8. truncated below dest and shifted up.
 * 9. shifted up
 * 10. not changed
 ','line_number':3047,'multiline':True]['text':' Case 4','line_number':3104,'multiline':False]['text':' don't have to change this fold, but have to move nested folds.','line_number':3105,'multiline':False]['text':' Case 3','line_number':3112,'multiline':False]['text':' Remove nested folds between line1 and line2 & reduce the','line_number':3113,'multiline':False]['text':' length of fold by "range_len".','line_number':3114,'multiline':False]['text':' Folds after this one must be dealt with.','line_number':3115,'multiline':False]['text':' Case 2 truncate fold, folds after this one must be dealt with.','line_number':3121,'multiline':False]['text':' Look at the next fold, and treat that one as if it were the first','line_number':3124,'multiline':False]['text':' after  "line1" (because now it is).','line_number':3125,'multiline':False]['text':' Case 10','line_number':3131,'multiline':False]['text':' No folds after "line1" and before "dest"','line_number':3132,'multiline':False]['text':' Case 9. (for all case 9's) -- shift up.','line_number':3138,'multiline':False]['text':' Case 8. -- ensure truncated at dest, shift up','line_number':3143,'multiline':False]['text':' Case 7 -- remove nested folds and shrink','line_number':3151,'multiline':False]['text':' Case 5 or 6','line_number':3159,'multiline':False]['text':' changes rely on whether there are folds between the end of','line_number':3160,'multiline':False]['text':' this fold and "dest".','line_number':3161,'multiline':False]['text':' 1. 2. or 3.','line_number':3168,'multiline':False]['text':' 2. or 3., truncate before moving','line_number':3170,'multiline':False]['text':' Record index of the first fold after the moved range.','line_number':3177,'multiline':False]['text':'
     * All folds are now correct, but not necessarily in the correct order.  We
     * must swap folds in the range [move_end, dest_index) with those in the
     * range [move_start, move_end).
     ','line_number':3189,'multiline':True]['text':' There are no folds after those moved, hence no folds have been moved','line_number':3195,'multiline':False]['text':' out of order.','line_number':3196,'multiline':False]['text':' foldMerge() {{{2','line_number':3208,'multiline':False]['text':'
 * Merge two adjacent folds (and the nested ones in them).
 * This only works correctly when the folds are really adjacent!  Thus "fp1"
 * must end just above "fp2".
 * The resulting fold is "fp1", nested folds are moved from "fp2" to "fp1".
 * Fold entry "fp2" in "gap" is deleted.
 ','line_number':3209,'multiline':True]['text':' If the last nested fold in fp1 touches the first nested fold in fp2,','line_number':3225,'multiline':False]['text':' merge them recursively.','line_number':3226,'multiline':False]['text':' Move nested folds in fp2 to the end of fp1.','line_number':3230,'multiline':False]['text':' foldlevelIndent() {{{2','line_number':3248,'multiline':False]['text':'
 * Low level function to get the foldlevel for the "indent" method.
 * Doesn't use any caching.
 * Returns a level of -1 if the foldlevel depends on surrounding lines.
 ','line_number':3249,'multiline':True]['text':' empty line or lines starting with a character in 'foldignore': level','line_number':3264,'multiline':False]['text':' depends on surrounding lines','line_number':3265,'multiline':False]['text':' first and last line can't be undefined, use level 0','line_number':3268,'multiline':False]['text':' foldlevelDiff() {{{2','line_number':3284,'multiline':False]['text':'
 * Low level function to get the foldlevel for the "diff" method.
 * Doesn't use any caching.
 ','line_number':3286,'multiline':True]['text':' foldlevelExpr() {{{2','line_number':3300,'multiline':False]['text':'
 * Low level function to get the foldlevel for the "expr" method.
 * Doesn't use any caching.
 * Returns a level of -1 if the foldlevel depends on surrounding lines.
 ','line_number':3301,'multiline':True]['text':' KeyTyped may be reset to 0 when calling a function which invokes','line_number':3330,'multiline':False]['text':' do_cmdline().  To make 'foldopen' work correctly restore KeyTyped.','line_number':3331,'multiline':False]['text':' "a1", "a2", .. : add to the fold level','line_number':3338,'multiline':False]['text':' "s1", "s2", .. : subtract from the fold level','line_number':3347,'multiline':False]['text':' ">1", ">2", .. : start a fold with a certain level','line_number':3358,'multiline':False]['text':' "<1", "<2", .. : end a fold with a certain level','line_number':3364,'multiline':False]['text':' "=": No change in level','line_number':3369,'multiline':False]['text':' "-1", "0", "1", ..: set fold level','line_number':3373,'multiline':False]['text':' Use the current level for the next line, so that "a1"','line_number':3375,'multiline':False]['text':' will work there.','line_number':3376,'multiline':False]['text':' If the level is unknown for the first or the last line in the file, use','line_number':3384,'multiline':False]['text':' level 0.','line_number':3385,'multiline':False]['text':' parseMarker() {{{2','line_number':3402,'multiline':False]['text':'
 * Parse 'foldmarker' and set "foldendmarker", "foldstartmarkerlen" and
 * "foldendmarkerlen".
 * Relies on the option value to have been checked for correctness already.
 ','line_number':3403,'multiline':True]['text':' foldlevelMarker() {{{2','line_number':3416,'multiline':False]['text':'
 * Low level function to get the foldlevel for the "marker" method.
 * "foldendmarker", "foldstartmarkerlen" and "foldendmarkerlen" must have been
 * set before calling this.
 * Requires that flp->lvl is set to the fold level of the previous line!
 * Careful: This means you can't call this function twice on the same line.
 * Doesn't use any caching.
 * Sets flp->start when a start marker was found.
 ','line_number':3417,'multiline':True]['text':' cache a few values for speed','line_number':3436,'multiline':False]['text':' Default: no start found, next level is same as current level','line_number':3442,'multiline':False]['text':' found startmarker: set flp->lvl','line_number':3452,'multiline':False]['text':' found endmarker: set flp->lvl_next','line_number':3477,'multiline':False]['text':' never start a fold with an end marker','line_number':3486,'multiline':False]['text':' The level can't go negative, must be missing a start marker.','line_number':3498,'multiline':False]['text':' foldlevelSyntax() {{{2','line_number':3503,'multiline':False]['text':'
 * Low level function to get the foldlevel for the "syntax" method.
 * Doesn't use any caching.
 ','line_number':3504,'multiline':True]['text':' Use the maximum fold level at the start of this line and the next.','line_number':3518,'multiline':False]['text':' fold(s) start here','line_number':3526,'multiline':False]['text':' functions for storing the fold state in a View {{{1','line_number':3533,'multiline':False]['text':' put_folds() {{{2','line_number':3534,'multiline':False]['text':'
 * Write commands to "fd" to restore the manual folds in window "wp".
 * Return FAIL if writing fails.
 ','line_number':3540,'multiline':True]['text':' If some folds are manually opened/closed, need to restore that.','line_number':3555,'multiline':False]['text':' put_folds_recurse() {{{2','line_number':3562,'multiline':False]['text':'
 * Write commands to "fd" to recreate manually created folds.
 * Returns FAIL when writing failed.
 ','line_number':3563,'multiline':True]['text':' Do nested folds first, they will be created closed.','line_number':3576,'multiline':False]['text':' put_foldopen_recurse() {{{2','line_number':3588,'multiline':False]['text':'
 * Write commands to "fd" to open and close manually opened/closed folds.
 * Returns FAIL when writing failed.
 ','line_number':3589,'multiline':True]['text':' open nested folds while this fold is open','line_number':3611,'multiline':False]['text':' close the parent when needed','line_number':3620,'multiline':False]['text':' Open or close the leaf according to the window foldlevel.','line_number':3629,'multiline':False]['text':' Do not close a leaf that is already closed, as it will close','line_number':3630,'multiline':False]['text':' the parent.','line_number':3631,'multiline':False]['text':' put_fold_open_close() {{{2','line_number':3645,'multiline':False]['text':'
 * Write the open or close command to "fd".
 * Returns FAIL when writing failed.
 ','line_number':3646,'multiline':True]['text':' FEAT_SESSION','line_number':3662,'multiline':False]['text':' }}}1','line_number':3664,'multiline':False]['text':' defined(FEAT_FOLDING) || defined(PROTO)','line_number':3665,'multiline':False]['text':'
 * "foldclosed()" and "foldclosedend()" functions
 ','line_number':3669,'multiline':True]['text':'
 * "foldclosed()" function
 ','line_number':3701,'multiline':True]['text':'
 * "foldclosedend()" function
 ','line_number':3710,'multiline':True]['text':'
 * "foldlevel()" function
 ','line_number':3719,'multiline':True]['text':'
 * "foldtext()" function
 ','line_number':3737,'multiline':True]['text':' Find first non-empty line in the fold.','line_number':3764,'multiline':False]['text':' Find interesting text in this line.','line_number':3769,'multiline':False]['text':' skip C comment-start','line_number':3771,'multiline':False]['text':' for %s','line_number':3786,'multiline':False]['text':' for %3ld','line_number':3787,'multiline':False]['text':' concatenated','line_number':3788,'multiline':False]['text':' remove 'foldmarker' and 'commentstring'','line_number':3794,'multiline':False]['text':'
 * "foldtextresult(lnum)" function
 ','line_number':3802,'multiline':True]['text':' reject recursive use','line_number':3825,'multiline':False]['text':' treat illegal types and illegal string values for {lnum} the same','line_number':3829,'multiline':False]['text':' FEAT_EVAL','line_number':3846,'multiline':False]