['text':'*
 * Confirms that a parent operation correctly inherits 'numYields' from each of its child operations
 * as the latter are popped off the CurOp stack.
 ','line_number':1,'multiline':True]['text':' Start a single mongoD using MongoRunner.','line_number':7,'multiline':False]['text':' Create the test DB and collection.','line_number':11,'multiline':False]['text':' Executes a bulk remove using the specified 'docsToRemove' array, captures the 'numYields'','line_number':16,'multiline':False]['text':' metrics from each child op, and confirms that the parent op's 'numYields' total is equivalent','line_number':17,'multiline':False]['text':' to the sum of the child ops.','line_number':18,'multiline':False]['text':' Sets parameters such that all operations will yield & the operation hangs on the server','line_number':20,'multiline':False]['text':' when we need to test.','line_number':21,'multiline':False]['text':' Starts parallel shell to run the command that will hang.','line_number':29,'multiline':False]['text':' Get child operations and sum yields. Each child op encounters two failpoints while','line_number':43,'multiline':False]['text':' running: 'hangBeforeChildRemoveOpFinishes' followed by 'hangBeforeChildRemoveOpIsPopped'.','line_number':44,'multiline':False]['text':' We use these two failpoints as an 'airlock', hanging at the first while we enable the','line_number':45,'multiline':False]['text':' second, then hanging at the second while we enable the first, to ensure that each child','line_number':46,'multiline':False]['text':' op is caught and their individual 'numYields' recorded.','line_number':47,'multiline':False]['text':' Wait for the child op to hit the first of two failpoints.','line_number':49,'multiline':False]['text':' Add the child's yield count to the running total, and record the opid.','line_number':53,'multiline':False]['text':' Enable the subsequent 'hangBeforeChildRemoveOpIsPopped' failpoint, just after the','line_number':59,'multiline':False]['text':' child op finishes but before it is popped from the stack.','line_number':60,'multiline':False]['text':' Let the operation proceed to the 'hangBeforeChildRemoveOpIsPopped' failpoint.','line_number':64,'multiline':False]['text':' If this is not the final child op, re-enable the 'hangBeforeChildRemoveOpFinishes'','line_number':69,'multiline':False]['text':' failpoint from earlier so that we don't miss the next child.','line_number':70,'multiline':False]['text':' Finally, allow the operation to continue.','line_number':76,'multiline':False]['text':' Wait for the operation to hit the 'hangAfterAllChildRemoveOpsArePopped' failpoint, then','line_number':81,'multiline':False]['text':' take the total number of yields recorded by the parent op.','line_number':82,'multiline':False]['text':' Verify that the parent's yield count equals the sum of the child ops' yields.','line_number':86,'multiline':False]['text':' Allow the parent operation to complete.','line_number':90,'multiline':False]['text':' Wait for the parallel shell to complete.','line_number':94,'multiline':False]['text':' Test that a parent remove op inherits the sum of its children's yields for a single remove.','line_number':98,'multiline':False]['text':' Test that a parent remove op inherits the sum of its children's yields for multiple removes.','line_number':102,'multiline':False]