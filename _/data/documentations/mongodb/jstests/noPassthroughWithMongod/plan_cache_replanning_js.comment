['text':'*
 * This test will attempt to create a scenario where the plan cache entry for a given query shape
 * oscillates. It achieves this by creating two indexes, A and B, on a collection, and interleaving
 * queries which are "ideal" for index A with queries that are "ideal" for index B.
 ','line_number':1,'multiline':True]['text':'*
 * Asserts that the plan contained in the plan cache 'entry' is an index scan plan over the index
 * with the given 'indexName'.
 *
 * Also verifies that the query hash matches the provided 'expectedQueryHash'.
 ','line_number':21,'multiline':True]['text':' The $planCacheStats output for the SBE plan cache only contains an debug string','line_number':32,'multiline':False]['text':' representation of the execution plan. Rather than parse this string, we just check that','line_number':33,'multiline':False]['text':' the index name appears somewhere in the plan.','line_number':34,'multiline':False]['text':' Carefully construct a collection so that some queries will do well with an {a: 1} index and','line_number':47,'multiline':False]['text':' others with a {b: 1} index.','line_number':48,'multiline':False]['text':' This query will be quick with {a: 1} index, and far slower {b: 1} index. With the {a: 1} index,','line_number':57,'multiline':False]['text':' the server should only need to examine one document. Using {b: 1}, it will have to scan through','line_number':58,'multiline':False]['text':' each document which has 2 as the value of the 'b' field.','line_number':59,'multiline':False]['text':' Opposite of 'aIndexQuery'. Should be quick if the {b: 1} index is used, and slower if the {a: 1}','line_number':64,'multiline':False]['text':' index is used.','line_number':65,'multiline':False]['text':' Run a query where the {b: 1} index will easily win.','line_number':74,'multiline':False]['text':' The plan cache should now hold an inactive entry.','line_number':77,'multiline':False]['text':' Re-run the query. The inactive cache entry should be promoted to an active entry.','line_number':84,'multiline':False]['text':' Now we will attempt to oscillate the cache entry by interleaving queries which should use the','line_number':91,'multiline':False]['text':' {a:1} and {b:1} index. When the plan using the {b: 1} index is in the cache, running a query','line_number':92,'multiline':False]['text':' which should use the {a: 1} index will perform very poorly, and trigger replanning (and vice','line_number':93,'multiline':False]['text':' versa).','line_number':94,'multiline':False]['text':' The {b: 1} plan is currently in the cache. Run the query which should use the {a: 1} index. The','line_number':96,'multiline':False]['text':' current cache entry will be deactivated, and then the cache entry for the {a: 1} will overwrite','line_number':97,'multiline':False]['text':' it (as active).','line_number':98,'multiline':False]['text':' Run the query which should use the {b: 1} index.','line_number':104,'multiline':False]['text':' The {b: 1} plan is again in the cache. Run the query which should use the {a: 1} index.','line_number':110,'multiline':False]['text':' The {a: 1} plan is back in the cache. Run the query which would perform better on the plan using','line_number':116,'multiline':False]['text':' the {b: 1} index, and ensure that plan gets written to the cache.','line_number':117,'multiline':False]['text':' Now run a plan that will perform poorly with both indices (it will be required to scan 500','line_number':124,'multiline':False]['text':' documents). This will result in replanning (and the cache entry being deactivated). However, the','line_number':125,'multiline':False]['text':' new plan will have a very high works value, and will replace the existing cache entry with a new','line_number':126,'multiline':False]['text':' cache entry whose works value got updated to the new higher value.','line_number':127,'multiline':False]['text':' The cache entry should have been deactivated.','line_number':133,'multiline':False]['text':' The works value should have doubled.','line_number':138,'multiline':False]['text':' Drop and recreate the collection. Now we test that the query system does not replan in cases','line_number':141,'multiline':False]['text':' where the plan is performing only slightly less efficiently than the cached plan.','line_number':142,'multiline':False]['text':' These are the possible values used for the 'tiebreak' field. The 'tiebreak' field is included','line_number':149,'multiline':False]['text':' to guarantee that certain documents are inspected before others to ensure that the plan may','line_number':150,'multiline':False]['text':' see documents which don't match the filter and "waste" work reading these documents.','line_number':151,'multiline':False]['text':' Special value of 'selectiveKey' for which the plan using {selectiveKey:1, tiebreak:1} is','line_number':155,'multiline':False]['text':' *slightly* less efficient, but still far better than the plan using {nonSelectiveKey:1,','line_number':156,'multiline':False]['text':' tiebreak:1}.','line_number':157,'multiline':False]['text':' The query using 'filterOnSelectiveKey' should require slightly fewer reads than','line_number':160,'multiline':False]['text':' 'filterOnSelectiveKeySpecialValue'. We will check that running','line_number':161,'multiline':False]['text':' 'filterOnSelectiveKeySpecialValue' when there is a cache entry generated from','line_number':162,'multiline':False]['text':' 'filterOnSelectiveKey' does *not* cause replanning.','line_number':163,'multiline':False]['text':' Insert 110 documents for each value of selectiveKey from 1-10. We use the number 110 docs','line_number':170,'multiline':False]['text':' because it is greater than the because it is greater than the predefined doc limit of 101 for','line_number':171,'multiline':False]['text':' cached planning and multi-planning.','line_number':172,'multiline':False]['text':' Now add one extra document so the plan requires a few more reads/works when the value of','line_number':180,'multiline':False]['text':' 'selectiveKey' is 'kSpecialSelectiveKey'. We use a low value of 'tiebreak' to ensure that','line_number':181,'multiline':False]['text':' this special, non-matching document is inspected before the documents which do match the','line_number':182,'multiline':False]['text':' filter.','line_number':183,'multiline':False]['text':' Now we run a query using the special value of 'selectiveKey' until the plan gets cached. We','line_number':187,'multiline':False]['text':' run it twice to make the cache entry active.','line_number':188,'multiline':False]['text':' Now look at the cache entry and store the values for works, keysExamined.','line_number':193,'multiline':False]['text':' Execution stats from when the plan cache entry was created are not exposed from the SBE plan','line_number':198,'multiline':False]['text':' cache.','line_number':199,'multiline':False]['text':' Clear the plan cache for the collection.','line_number':208,'multiline':False]['text':' Now run the query on the non-special value of 'selectiveKey' until it gets cached.','line_number':211,'multiline':False]['text':' The new cache entry's plan should have used fewer works (and examined fewer keys) compared','line_number':220,'multiline':False]['text':' to the old cache entry's, since the query on the special value is slightly less efficient.','line_number':221,'multiline':False]['text':' Now run the query on the "special" value again and check that replanning does not happen','line_number':229,'multiline':False]['text':' even though the plan is slightly less efficient than the one in the cache.','line_number':230,'multiline':False]['text':' Check that the cache entry hasn't changed.','line_number':233,'multiline':False]