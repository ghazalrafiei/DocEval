['text':' Tests for $merge against a stale mongos with combinations of sharded/unsharded source and target','line_number':1,'multiline':False]['text':' collections.','line_number':2,'multiline':False]['text':' Shards the collection 'coll' through 'mongos'.','line_number':22,'multiline':False]['text':' Shard the given collection on _id, split the collection into 2 chunks: [MinKey, 0) and','line_number':25,'multiline':False]['text':' [0, MaxKey), then move the [0, MaxKey) chunk to shard 1.','line_number':26,'multiline':False]['text':' Configures the two mongos, staleMongosSource and staleMongosTarget, to be stale on the source','line_number':33,'multiline':False]['text':' and target collections, respectively. For instance, if 'shardedSource' is true then','line_number':34,'multiline':False]['text':' staleMongosSource will believe that the source collection is unsharded.','line_number':35,'multiline':False]['text':' Initialize both mongos to believe the collections are unsharded.','line_number':37,'multiline':False]['text':' Shard the source collection through the staleMongosTarget mongos, keeping the','line_number':50,'multiline':False]['text':' staleMongosSource unaware.','line_number':51,'multiline':False]['text':' Shard the collection through staleMongosSource.','line_number':54,'multiline':False]['text':' Then drop the collection, but do not recreate it yet as that will happen on the next','line_number':57,'multiline':False]['text':' insert later in the test.','line_number':58,'multiline':False]['text':' Shard the target collection through the staleMongosSource mongos, keeping the','line_number':63,'multiline':False]['text':' staleMongosTarget unaware.','line_number':64,'multiline':False]['text':' Shard the collection through staleMongosTarget.','line_number':67,'multiline':False]['text':' Then drop the collection, but do not recreate it yet as that will happen on the next','line_number':70,'multiline':False]['text':' insert later in the test.','line_number':71,'multiline':False]['text':' Runs a $merge with the given modes against each mongos in 'mongosList'. This method will wrap','line_number':76,'multiline':False]['text':' 'mongosList' into a list if it is not an array.','line_number':77,'multiline':False]['text':' Insert several documents into the source and target collection without any conflicts.','line_number':86,'multiline':False]['text':' Note that the chunk split point is at {_id: 0}.','line_number':87,'multiline':False]['text':' If whenNotMatchedMode is "discard", then the documents in the source collection will','line_number':99,'multiline':False]['text':' not get written to the target since none of them match.','line_number':100,'multiline':False]['text':' Skip the combination of merge modes which will fail depending on the contents of the','line_number':106,'multiline':False]['text':' source and target collection, as this will cause the assertion below to trip.','line_number':107,'multiline':False]['text':' For each mode, test the following scenarios:','line_number':111,'multiline':False]['text':' * Both the source and target collections are sharded.','line_number':112,'multiline':False]['text':' * Both the source and target collections are unsharded.','line_number':113,'multiline':False]['text':' * Source collection is sharded and the target collection is unsharded.','line_number':114,'multiline':False]['text':' * Source collection is unsharded and the target collection is sharded.','line_number':115,'multiline':False]['text':'','line_number':128,'multiline':False]['text':' The remaining tests run against a mongos which is stale with respect to BOTH the source','line_number':129,'multiline':False]['text':' and target collections.','line_number':130,'multiline':False]['text':'','line_number':131,'multiline':False]['text':'','line_number':135,'multiline':False]['text':' 1. Both source and target collections are sharded.','line_number':136,'multiline':False]['text':'','line_number':137,'multiline':False]['text':' Insert into both collections through the stale mongos such that it believes the','line_number':141,'multiline':False]['text':' collections exist and are unsharded.','line_number':142,'multiline':False]['text':' Test against the stale mongos, which believes both collections are unsharded.','line_number':149,'multiline':False]['text':'','line_number':152,'multiline':False]['text':' 2. Both source and target collections are unsharded.','line_number':153,'multiline':False]['text':'','line_number':154,'multiline':False]['text':' The collections were both dropped through a different mongos, so the stale mongos still','line_number':158,'multiline':False]['text':' believes that they're sharded.','line_number':159,'multiline':False]['text':'','line_number':162,'multiline':False]['text':' 3. Source collection is sharded and target collection is unsharded.','line_number':163,'multiline':False]['text':'','line_number':164,'multiline':False]['text':' Insert into the source collection through the stale mongos such that it believes the','line_number':167,'multiline':False]['text':' collection exists and is unsharded.','line_number':168,'multiline':False]['text':' Shard the source collection through the fresh mongos.','line_number':171,'multiline':False]['text':' Shard the target through the stale mongos, but then drop and recreate it as unsharded','line_number':174,'multiline':False]['text':' through a different mongos.','line_number':175,'multiline':False]['text':' At this point, the stale mongos believes the source collection is unsharded and the','line_number':179,'multiline':False]['text':' target collection is sharded when in fact the reverse is true.','line_number':180,'multiline':False]['text':'','line_number':183,'multiline':False]['text':' 4. Source collection is unsharded and target collection is sharded.','line_number':184,'multiline':False]['text':'','line_number':185,'multiline':False]['text':' Insert into the target collection through the stale mongos such that it believes the','line_number':189,'multiline':False]['text':' collection exists and is unsharded.','line_number':190,'multiline':False]['text':' Shard the source through the stale mongos, but then drop and recreate it as unsharded','line_number':195,'multiline':False]['text':' through a different mongos.','line_number':196,'multiline':False]['text':' At this point, the stale mongos believes the source collection is sharded and the target','line_number':200,'multiline':False]['text':' collection is unsharded when in fact the reverse is true.','line_number':201,'multiline':False]['text':' Runs a legacy $out against each mongos in 'mongosList'. This method will wrap 'mongosList'','line_number':205,'multiline':False]['text':' into a list if it is not an array.','line_number':206,'multiline':False]['text':' Insert several documents into the source and target collection without any conflicts.','line_number':215,'multiline':False]['text':' Note that the chunk split point is at {_id: 0}.','line_number':216,'multiline':False]['text':' TODO SERVER-45186 Uncomment this section.','line_number':225,'multiline':False]['text':'
Legacy $out will fail if the target collection is sharded.
setupStaleMongos({shardedSource: false, shardedTarget: false});
runOutTest([staleMongosSource, staleMongosTarget]);

setupStaleMongos({shardedSource: true, shardedTarget: true});
assert.eq(assert.throws(() => runOutTest(staleMongosSource)).code, 28769);
assert.eq(assert.throws(() => runOutTest(staleMongosTarget)).code, ErrorCodes.IllegalOperation);

setupStaleMongos({shardedSource: true, shardedTarget: false});
runOutTest([staleMongosSource, staleMongosTarget]);

setupStaleMongos({shardedSource: false, shardedTarget: true});
assert.eq(assert.throws(() => runOutTest(staleMongosSource)).code, 28769);
assert.eq(assert.throws(() => runOutTest(staleMongosTarget)).code, ErrorCodes.IllegalOperation);
','line_number':226,'multiline':True]