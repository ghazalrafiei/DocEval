['text':'*
 * Run a query on a sharded cluster where one of the shards hangs. Running killCursors on the mongos
 * should always succeed.
 *
 * Uses getMore to pin an open cursor.
 * @tags: [
 *   requires_getmore,
 * ]
 ','line_number':1,'multiline':True]['text':' This test manually simulates a session, which is not compatible with implicit sessions.','line_number':13,'multiline':False]['text':' The startParallelShell function will take the string it's given and serialize it into a','line_number':38,'multiline':False]['text':' string. This means that we can't pass it functions which capture variables. Instead we use','line_number':39,'multiline':False]['text':' the trick below, by putting the values for the variables we'd like to capture inside the','line_number':40,'multiline':False]['text':' string. Kudos to Dave Storch for coming up with this idea.','line_number':41,'multiline':False]['text':' eslint-disable-next-line','line_number':54,'multiline':False]['text':' We expect that the operation will get interrupted and fail.','line_number':61,'multiline':False]['text':' Tests that the various cursors involved in a sharded query can be killed, even when pinned.','line_number':73,'multiline':False]['text':'','line_number':74,'multiline':False]['text':' Sets up a sharded cursor, opens a mongos cursor, and uses failpoints to cause the mongos','line_number':75,'multiline':False]['text':' cursor to hang due to getMore commands hanging on each of the shards. Then invokes','line_number':76,'multiline':False]['text':' 'killFunc', and verifies the cursors on the shards and the mongos cursor get cleaned up.','line_number':77,'multiline':False]['text':'','line_number':78,'multiline':False]['text':' 'getMoreErrCodes' are the error codes with which we expect the getMore to fail (e.g. a','line_number':79,'multiline':False]['text':' killCursors command should cause getMore to fail with "CursorKilled", but killOp should cause','line_number':80,'multiline':False]['text':' a getMore to fail with "Interrupted").','line_number':81,'multiline':False]['text':' Set up the mongods to hang on a getMore request. ONLY set the failpoint on the','line_number':89,'multiline':False]['text':' mongods. Setting the failpoint on the mongos will only cause it to spin, and not','line_number':90,'multiline':False]['text':' actually send any requests out.','line_number':91,'multiline':False]['text':' Run a find against mongos. This should open cursors on both of the shards.','line_number':97,'multiline':False]['text':' Manually start a session so it can be continued from inside a parallel shell.','line_number':101,'multiline':False]['text':' Wait until we know the mongod cursors are pinned.','line_number':115,'multiline':False]['text':' Use the function provided by the caller to kill the sharded query.','line_number':120,'multiline':False]['text':' The getMore should finish now that we've killed the cursor (even though the failpoint','line_number':123,'multiline':False]['text':' is still enabled).','line_number':124,'multiline':False]['text':' By now, the getMore run against the mongos has returned with an indication that the','line_number':128,'multiline':False]['text':' cursor has been killed.  Verify that the cursor is really gone by running a','line_number':129,'multiline':False]['text':' killCursors command, and checking that the cursor is reported as "not found".','line_number':130,'multiline':False]['text':' Eventually the cursors on the mongods should also be cleaned up. They should be','line_number':137,'multiline':False]['text':' killed by mongos when the mongos cursor gets killed.','line_number':138,'multiline':False]['text':' Test that running 'killCursors' against a pinned mongos cursor (with pinned mongod','line_number':165,'multiline':False]['text':' cursors) correctly cleans up all of the involved cursors.','line_number':166,'multiline':False]['text':' Run killCursors against the mongos cursor. Verify that the cursor is reported as','line_number':169,'multiline':False]['text':' killed successfully, and does not hang or return a "CursorInUse" error.','line_number':170,'multiline':False]['text':' Test that running killOp against one of the cursors pinned on mongod causes all involved','line_number':183,'multiline':False]['text':' cursors to be killed.','line_number':184,'multiline':False]['text':' This function ignores the mongos cursor id, since it instead uses currentOp to','line_number':186,'multiline':False]['text':' obtain an op id to kill.','line_number':187,'multiline':False]['text':' Test that running killCursors against one of the cursors pinned on mongod causes all','line_number':209,'multiline':False]['text':' involved cursors to be killed.','line_number':210,'multiline':False]['text':' This function ignores the mongos cursor id, since it instead uses currentOp to','line_number':212,'multiline':False]['text':' obtain the cursor id of one of the shard cursors.','line_number':213,'multiline':False]['text':' Test that running killSessions on the session which is running the getMore causes the','line_number':242,'multiline':False]['text':' cursor to be killed.','line_number':243,'multiline':False]['text':' This function ignores the mongos cursor id, since it instead uses listLocalSessions','line_number':245,'multiline':False]['text':' to obtain the session id of the session running the getMore.','line_number':246,'multiline':False]['text':' Must sort by 'lastUse' because there may be sessions left over on the server from','line_number':248,'multiline':False]['text':' the previous runs. We will only call killSessions on the most recently used one.','line_number':249,'multiline':False]['text':' Killing a session on mongos kills all matching remote cursors (through KillCursors) then','line_number':260,'multiline':False]['text':' all matching local operations (through KillOp), so the getMore can fail with either','line_number':261,'multiline':False]['text':' CursorKilled or Interrupted depending on which response is returned first.','line_number':262,'multiline':False]