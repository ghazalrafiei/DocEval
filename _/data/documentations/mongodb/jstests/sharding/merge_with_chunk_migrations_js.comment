['text':' Tests that the $merge aggregation stage is resilient to chunk migrations in both the source and','line_number':1,'multiline':False]['text':' output collection during execution.','line_number':2,'multiline':False]['text':' Match on the output namespace to avoid hanging the sharding metadata refresh aggregation when','line_number':12,'multiline':False]['text':' shard0 is a config shard.','line_number':13,'multiline':False]['text':' For modes 'whenNotMatchedMode:fail/discard', the $merge will not insert the expected','line_number':29,'multiline':False]['text':' documents, causing the assertion below to fail. To avoid that, we match the documents in','line_number':30,'multiline':False]['text':' target collection with the documents in source.','line_number':31,'multiline':False]['text':' Set the failpoint to hang in the first call to DocumentSourceCursor's getNext().','line_number':37,'multiline':False]['text':' The $_internalInhibitOptimization stage is added to the pipeline to prevent the pipeline','line_number':47,'multiline':False]['text':' from being optimized away after it's been split. Otherwise, we won't hit the failpoint.','line_number':48,'multiline':False]['text':' Start the $merge aggregation in a parallel shell.','line_number':59,'multiline':False]['text':' Wait for the parallel shell to hit the failpoint.','line_number':62,'multiline':False]['text':' Migrate the chunk on shard1 to shard0.','line_number':67,'multiline':False]['text':' Unset the failpoint to unblock the $merge and join with the parallel shell.','line_number':71,'multiline':False]['text':' Verify that the $merge succeeded.','line_number':75,'multiline':False]['text':' Now both chunks are on shard0. Run a similar test except migrate the chunks back to','line_number':78,'multiline':False]['text':' shard1 in the middle of execution.','line_number':79,'multiline':False]['text':' For modes 'whenNotMatchedMode:fail/discard', the $merge will not insert the expected','line_number':82,'multiline':False]['text':' documents, causing the assertion below to fail. To avoid that, we match the documents in','line_number':83,'multiline':False]['text':' target collection with the documents in source.','line_number':84,'multiline':False]['text':' The $_internalInhibitOptimization stage is added to the pipeline to prevent the pipeline','line_number':92,'multiline':False]['text':' from being optimized away after it's been split. Otherwise, we won't hit the failpoint.','line_number':93,'multiline':False]['text':' Wait for the parallel shell to hit the failpoint.','line_number':105,'multiline':False]['text':' Unset the failpoint to unblock the $merge and join with the parallel shell.','line_number':115,'multiline':False]['text':' Verify that the $merge succeeded.','line_number':119,'multiline':False]['text':' Reset the chunk distribution.','line_number':122,'multiline':False]['text':' Shard the source collection with shard key {shardKey: 1} and split into 2 chunks.','line_number':127,'multiline':False]['text':' Write a document to each chunk of the source collection.','line_number':130,'multiline':False]['text':' Run a similar test with chunk migrations on the output collection instead.','line_number':138,'multiline':False]['text':' Shard the output collection with shard key {shardKey: 1} and split into 2 chunks.','line_number':141,'multiline':False]['text':' Write two documents in the source collection that should target the two chunks in the target','line_number':144,'multiline':False]['text':' collection.','line_number':145,'multiline':False]