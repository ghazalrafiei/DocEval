['text':'*
 * Tests $lookup, $graphLookup, and $unionWith in a sharded environment to verify the local read
 * behavior of subpipelines dispatched as part of these stages.
 *
 * Requires 7.3 to avoid multiversion problems because we updated targeting logic.
 * @tags: [requires_majority_read_concern, requires_fcv_73]
 ','line_number':1,'multiline':True]['text':' Disable checking for index consistency to ensure that the config server doesn't issue an','line_number':26,'multiline':False]['text':' aggregate command which triggers the shards to refresh their sharding metadata as this test','line_number':27,'multiline':False]['text':' relies on shards to have specific metadata as specific times.','line_number':28,'multiline':False]['text':' In this test we perform writes which we expect to read on a secondary, so we need to enable','line_number':32,'multiline':False]['text':' causal consistency.','line_number':33,'multiline':False]['text':' Turn on the profiler and increase the query log level for both shards.','line_number':45,'multiline':False]['text':' Clear the logs on the primary nodes before starting a test to isolate relevant log lines.','line_number':59,'multiline':False]['text':' Query the logs for local reads against the namespace specified in the top-level stage and the','line_number':69,'multiline':False]['text':' 'foreign' namespace. The latter case catches reads when the original namespace was a view.','line_number':70,'multiline':False]['text':'*
 * Asserts that the assertions in the `expected` object hold by querying the profiler.
 * @param {Object} expected - See `assertAggResultAndRouting()`.
 * @param {String} comment - Identifier used as an option in the execution of the query.
 * @param {Array} pipeline - Pipeline executed.
 ','line_number':79,'multiline':True]['text':' Confirm that the top-level execution of the pipeline is as expected.','line_number':93,'multiline':False]['text':' Confirm that the subpipeline execution is as expected. Each subpipeline is either','line_number':110,'multiline':False]['text':' sent to remote shards, which can be seen in the profiler, or performed as a local','line_number':111,'multiline':False]['text':' read, which can be seen in a special log line. The filter on the namespace below','line_number':112,'multiline':False]['text':' ensures we catch both pipelines run against the view namespace and pipelines run','line_number':113,'multiline':False]['text':' against the underlying coll. The number of shard targeting and local read operations','line_number':114,'multiline':False]['text':' can depend on which shard, primary or non-primary, executes a subpipeline first. To','line_number':115,'multiline':False]['text':' account for this, the caller should take care when specifying the values for','line_number':116,'multiline':False]['text':' 'subPipelineRemote' and 'subPipelineLocal'.','line_number':117,'multiline':False]['text':'*
 * Runs the given pipeline with the given options. Asserts that the result set is the same as
 * `expectedResults` and inspects the profiler to verify the expectations in the `expected` object.
 * @param {Array} pipeline - Pipeline to execute against the local collection
 * @param {Array} expectedResults - Set of documents that we expect the pipeline to return
 * @param {Object} opts - Options that are passed to aggregate command
 * @param {Object} expected - Object containing "assertions" about the state of the profiler. This
 *     allows us to make assertions about the types of plans that were used to satisfy the given
 *     pipeline. This object can have the following fields, all of which are arrays of booleans with
 *     length equal to the number of shards in the cluster:
 *       - toplevelExec: true in the i'th position indicates that the i'th shard executed part of
 *         the pipeline; false indicates that shard was not targeted.
 *       - subPipelineRemote: true in the i'th position indicates that the i'th shard performed at
 *         least one non-local read (had to perform shard targeting); false indicates that the shard
 *         did not perform any such reads.
 *       - subPipelineLocal: true in the i'th position indicates that the i'th shard performed at
 *         least one local read; false indicates that the shard performed zero local reads.
 ','line_number':153,'multiline':True]['text':' Write documents to each chunk.','line_number':172,'multiline':False]['text':' For each replica set, ensure queries are routed to the appropriate node.','line_number':183,'multiline':False]['text':'','line_number':190,'multiline':False]['text':' $unionWith tests','line_number':191,'multiline':False]['text':'','line_number':192,'multiline':False]['text':' Ensure the $unionWith stage is executed on the primary to reduce flakiness.','line_number':194,'multiline':False]['text':' Test $unionWith when the foreign collection is sharded.','line_number':208,'multiline':False]['text':' The $unionWith stage is always run only on the primary.','line_number':213,'multiline':False]['text':' The node executing the $unionWith will open a cursor on every shard that contains the','line_number':215,'multiline':False]['text':' foreign collection.','line_number':216,'multiline':False]['text':' Test $unionWith when the foreign collection is unsharded.','line_number':221,'multiline':False]['text':' The node executing the $unionWith can read locally from the foreign collection, since it','line_number':226,'multiline':False]['text':' is also on the primary and is unsharded.','line_number':227,'multiline':False]['text':' Test $unionWith when the foreign namespace is a view of a sharded collection.','line_number':232,'multiline':False]['text':' The node executing the $unionWith will open a cursor on every shard that contains the','line_number':240,'multiline':False]['text':' foreign namespace.','line_number':241,'multiline':False]['text':' Test $unionWith when the foreign namespace is a view of an unsharded collection.','line_number':246,'multiline':False]['text':' The node executing the $unionWith can read locally from the foreign namespace, since it','line_number':253,'multiline':False]['text':' is also on the primary and is unsharded.','line_number':254,'multiline':False]['text':' Test $unionWith when the foreign collection does not exist.','line_number':259,'multiline':False]['text':' The node executing the $unionWith believes it has stale information about the foreign','line_number':266,'multiline':False]['text':' collection and needs to target shards to properly resolve it.','line_number':267,'multiline':False]['text':'','line_number':272,'multiline':False]['text':' $graphLookup tests','line_number':273,'multiline':False]['text':'','line_number':274,'multiline':False]['text':' Test $graphLookup when the foreign collection is sharded.','line_number':292,'multiline':False]['text':' The $graphLookup stage can always run in parallel across all nodes where the local collection','line_number':297,'multiline':False]['text':' exists.','line_number':298,'multiline':False]['text':' Each node executing the $graphLookup will perform a scatter-gather query and open a cursor on','line_number':300,'multiline':False]['text':' every shard that contains the foreign collection. We need a query into the foreign coll for','line_number':301,'multiline':False]['text':' each doc in the local coll, plus one additional recursive query for {b: {$eq: -1}}.','line_number':302,'multiline':False]['text':' Test $graphLookup when the foreign collection is unsharded.','line_number':307,'multiline':False]['text':' The shard executing the $graphLookup can read locally from the foreign collection,','line_number':312,'multiline':False]['text':' since it is unsharded.','line_number':313,'multiline':False]['text':' Test $graphLookup when the foreign namespace is a view of a sharded collection.','line_number':318,'multiline':False]['text':' TODO SERVER-83902: Only shard0 will execute the $graphLookup because we will not see that the','line_number':324,'multiline':False]['text':' 'from' collection is a sharded view. When views are tracked in the sharding catalog, we','line_number':325,'multiline':False]['text':' should be able to target both shards.','line_number':326,'multiline':False]['text':' The node executing the $graphLookup will perform a scatter-gather query and open a cursor on','line_number':329,'multiline':False]['text':' every shard that contains the foreign collection.','line_number':330,'multiline':False]['text':' Test $graphLookup when the foreign namespace is a view of an unsharded collection.','line_number':334,'multiline':False]['text':' TODO SERVER-83902: Only shard0 will execute the $graphLookup because we will not see that the','line_number':339,'multiline':False]['text':' 'from' collection is a sharded view. When views are tracked in the sharding catalog, we','line_number':340,'multiline':False]['text':' should be able to target both shards.','line_number':341,'multiline':False]['text':' Test $graphLookup when the foreign collection does not exist.','line_number':347,'multiline':False]['text':' Only execute on shard0 because the 'from' collection does not exist.','line_number':358,'multiline':False]['text':' If the primary node tries to execute a subpipeline first, then it believes it has stale info','line_number':360,'multiline':False]['text':' about the foreign coll and needs to target shards to properly resolve it. Afterwards, it can','line_number':361,'multiline':False]['text':' do local reads. As before, the other node sends its subpipelines over the network. This','line_number':362,'multiline':False]['text':' results in 3 remote reads. If the non-primary shard sends a subpipeline to execute on the','line_number':363,'multiline':False]['text':' primary shard first, then the primary does a coll refresh before it attempts to run one of','line_number':364,'multiline':False]['text':' its own subpipelines and does not need to target shards. This results in 2 remote reads.','line_number':365,'multiline':False]['text':'','line_number':370,'multiline':False]['text':' $lookup tests','line_number':371,'multiline':False]['text':'','line_number':372,'multiline':False]['text':' Test $lookup when the foreign collection is sharded.','line_number':382,'multiline':False]['text':' The $lookup can be executed in parallel because mongos knows both collections are sharded.','line_number':387,'multiline':False]['text':' For every document that flows through the $lookup stage, each node executing the $lookup','line_number':389,'multiline':False]['text':' will perform a scatter-gather query and open a cursor on every shard that contains the','line_number':390,'multiline':False]['text':' foreign collection.','line_number':391,'multiline':False]['text':' Test $lookup when the foreign collection is unsharded.','line_number':396,'multiline':False]['text':' The $lookup cannot be executed in parallel because the foreign collection is unsharded.','line_number':400,'multiline':False]['text':' The node executing the $lookup can read locally from the foreign namespace, since it is also','line_number':402,'multiline':False]['text':' on the primary and is unsharded.','line_number':403,'multiline':False]['text':' Test $lookup when the foreign namespace is a view of a sharded collection.','line_number':408,'multiline':False]['text':' The $lookup is not executed in parallel because mongos does not know the foreign','line_number':414,'multiline':False]['text':' namespace is sharded.','line_number':415,'multiline':False]['text':' For every document that flows through the $lookup stage, each node executing the $lookup','line_number':417,'multiline':False]['text':' will perform a scatter-gather query and open a cursor on every shard that contains the','line_number':418,'multiline':False]['text':' foreign collection.','line_number':419,'multiline':False]['text':' Test $lookup when both collection are sharded, but each shard only needs local data to perform','line_number':424,'multiline':False]['text':' the lookup.','line_number':425,'multiline':False]['text':' The $lookup is executed on each shard.','line_number':438,'multiline':False]['text':' Because $lookup is done on shard key, shards must be able to determine that data is needed','line_number':440,'multiline':False]['text':' only from the same shard and perform reads locally.','line_number':441,'multiline':False]['text':' Test $lookup when the foreign namespace is a view of an unsharded collection.','line_number':446,'multiline':False]['text':' The $lookup is not executed in parallel because mongos defaults to believing the foreign','line_number':451,'multiline':False]['text':' namespace is unsharded.','line_number':452,'multiline':False]['text':' The node executing the $lookup can read locally from the foreign namespace, since it is also','line_number':454,'multiline':False]['text':' on the primary and is unsharded.','line_number':455,'multiline':False]['text':' Test $lookup when it is routed to a secondary which is not yet aware of the foreign collection.','line_number':460,'multiline':False]['text':' The $lookup cannot be executed in parallel because the foreign collection is unsharded.','line_number':474,'multiline':False]['text':' Test $lookup when it is routed to a secondary which is aware of the foreign collection.','line_number':480,'multiline':False]['text':' Ensure the secondary knows about the foreign collection.','line_number':483,'multiline':False]['text':' The $lookup cannot be executed in parallel because the foreign collection is unsharded.','line_number':495,'multiline':False]['text':' Test $lookup when it is routed to a secondary which thinks the foreign collection is unsharded,','line_number':501,'multiline':False]['text':' but it is stale.','line_number':502,'multiline':False]['text':' Ensure the secondaries know about the local collection.','line_number':505,'multiline':False]['text':' Ensure the secondary knows about the foreign collection, and thinks it is unsharded.','line_number':508,'multiline':False]['text':' Shard the collection through mongos.','line_number':511,'multiline':False]['text':' The $lookup can be executed in parallel since mongos knows both collections are sharded.','line_number':523,'multiline':False]['text':' Omit `subPupelineLocal` assertion.','line_number':526,'multiline':False]['text':' If the primary executes a subpipeline first, it will try and fail to read locally. It','line_number':527,'multiline':False]['text':' falls back to targeting shards, which also fails due to a StaleShardVersionError. The','line_number':528,'multiline':False]['text':' entire subpipeline is re-tried after the refresh. If the non-primary shard executes a','line_number':529,'multiline':False]['text':' subpipeline first, it will refresh and target the correct shards, and the primary will','line_number':530,'multiline':False]['text':' do a refresh before it executes one of its own subpipelines. From then on, for every','line_number':531,'multiline':False]['text':' document that flows through the $lookup stage, each node executing the $lookup will','line_number':532,'multiline':False]['text':' perform a scatter-gather query and open a cursor on every shard that contains the foreign','line_number':533,'multiline':False]['text':' collection.','line_number':534,'multiline':False]['text':' Test $lookup when the foreign collection does not exist.','line_number':537,'multiline':False]['text':' The $lookup is not executed in parallel because mongos defaults to believing the foreign','line_number':548,'multiline':False]['text':' namespace is unsharded.','line_number':549,'multiline':False]['text':' The node executing the $lookup believes it has stale information about the foreign','line_number':551,'multiline':False]['text':' collection and needs to target shards to properly resolve it. Then, it can use the local','line_number':552,'multiline':False]['text':' read path for each subpipeline query.','line_number':553,'multiline':False]['text':' Because $lookup is pushed down, we will try to take a lock on the foreign collection to check','line_number':555,'multiline':False]['text':' foreign collection's sharding state. Given that the stale shard version is resolved earlier','line_number':556,'multiline':False]['text':' and we've figured out that the foreign collection is unsharded, we no longer need to target a','line_number':557,'multiline':False]['text':' shard and instead can read locally. As such, we will not generate an entry in the profiler','line_number':558,'multiline':False]['text':' for querying the foreign collection.','line_number':559,'multiline':False]['text':'','line_number':563,'multiline':False]['text':' Test $lookup where the foreign collection becomes sharded in the middle of the query.','line_number':564,'multiline':False]['text':'','line_number':565,'multiline':False]['text':' Set-up the involved collections, keeping 'foreign' unsharded. At the start of the query, the','line_number':567,'multiline':False]['text':' top-level $lookup should be able to do a local read when running subpipelines against 'foreign'.','line_number':568,'multiline':False]['text':' Set a failpoint on the first aggregate to be run against the nested $lookup's foreign collection.','line_number':580,'multiline':False]['text':' Assert we haven't lost any documents','line_number':606,'multiline':False]['text':' Start a parallel shell to run the nested $lookup.','line_number':610,'multiline':False]['text':' When we hit this failpoint, the nested $lookup will have just completed its first subpipeline.','line_number':615,'multiline':False]['text':' Shard 'foreign' to verify that $lookup execution changes correctly mid-query.','line_number':616,'multiline':False]['text':' Let the aggregate complete.','line_number':620,'multiline':False]['text':' At the beginning, the foreign collection is unsharded, so the $lookup cannot be parallelized.','line_number':625,'multiline':False]['text':' We know from prior tests that the $lookup will do a local read for the first local document,','line_number':627,'multiline':False]['text':' since it is executing on the primary with an unsharded foreign collection. Checking the local','line_number':628,'multiline':False]['text':' read log here can be flakey because of the failpoint; the local read log may be rotated off','line_number':629,'multiline':False]['text':' the internal log buffer before we can check for it. Instead, we can just check that for the','line_number':630,'multiline':False]['text':' remaining two local documents, $lookup has to open a cursor on every shard to get correct','line_number':631,'multiline':False]['text':' documents for 'foreign'.','line_number':632,'multiline':False]['text':'','line_number':637,'multiline':False]['text':' Test $lookup where the primary is moved in the middle of the query.','line_number':638,'multiline':False]['text':'','line_number':639,'multiline':False]['text':' Create the same set-up as before, with the same failpoint.','line_number':641,'multiline':False]['text':' Start a parallel shell to run the nested $lookup.','line_number':650,'multiline':False]['text':' When we hit this failpoint, the nested $lookup will have just completed its first subpipeline.','line_number':655,'multiline':False]['text':' Move the primary to the other shard to verify that $lookup execution changes correctly mid-query.','line_number':656,'multiline':False]['text':' Let the aggregate complete.','line_number':660,'multiline':False]['text':' We know from prior tests that the $lookup will do a local read for the first document, since','line_number':665,'multiline':False]['text':' it is executing on the primary with an unsharded foreign collection. Checking the local','line_number':666,'multiline':False]['text':' read log here can be flakey because of the failpoint; the local read log may be rotated off','line_number':667,'multiline':False]['text':' the internal log buffer before we can check for it. Instead, we can just check that for the','line_number':668,'multiline':False]['text':' remaining two local documents, $lookup tries and fails to read locally and must target','line_number':669,'multiline':False]['text':' shards to get correct foreign documents.','line_number':670,'multiline':False]['text':'','line_number':675,'multiline':False]['text':' Test $graphLookup where the primary is moved in the middle of the query.','line_number':676,'multiline':False]['text':'','line_number':677,'multiline':False]['text':' At this point, the primary is Shard1. Create a new sharded local collection, and shard it so that','line_number':679,'multiline':False]['text':' all of the data will be on Shard0.','line_number':680,'multiline':False]['text':' Run a $graphLookup with a nested $lookup. $graphLookup will be parallelized to run on both Shard0','line_number':686,'multiline':False]['text':' and Shard1, though only Shard0 will do any real work, since it has all of the local data. Then,','line_number':687,'multiline':False]['text':' the primary will be changed back to Shard0. The query should still complete succesfully and give','line_number':688,'multiline':False]['text':' the same output as above.','line_number':689,'multiline':False]['text':' Start a parallel shell to run the $graphLookup.','line_number':708,'multiline':False]['text':' When we hit this failpoint, the nested $lookup will have just completed its first subpipeline.','line_number':712,'multiline':False]['text':' Move the primary to the shard executing $graphLookup to verify that we still get correct results.','line_number':713,'multiline':False]['text':' Let the aggregate complete.','line_number':717,'multiline':False]