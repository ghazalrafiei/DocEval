['text':'*
 * Tests the behavior of a $lookup in a sharded environment. These include tests where the 'from'
 * collection is sharded when the local collection is sharded and unsharded, when the $lookup
 * subpipeline can target certain shards or is scatter-gather, and when the $lookup subpipeline
 * contains a nested $lookup stage. This also includes tests when the mongos has stale information
 * about the foreign collection.
 *
 * Shard targeting logic for $lookup changed in 7.3 and may not match the expected behavior in a
 * multiversion environment.
 * @tags: [
 *   requires_fcv_73,
 * ]
 ','line_number':1,'multiline':True]['text':' Turn on the profiler and increase the query log level for both shards.','line_number':31,'multiline':False]['text':' 'freshMongos' and 'freshReviews' are used later to shard/drop the 'reviews' collection. Note that','line_number':41,'multiline':False]['text':' we insert into the reviews collection only through 'freshReviews' so that 'freshMongos' has up to','line_number':42,'multiline':False]['text':' date information about its sharding state, but 'mongosDB' may have stale information.','line_number':43,'multiline':False]['text':' This insert lets 'freshMongos' know about the latest state of 'freshReviews', but 'mongosDB'','line_number':67,'multiline':False]['text':' may have a stale view.','line_number':68,'multiline':False]['text':' Here we perform the query through 'mongosDB', which may still have a stale view of the','line_number':81,'multiline':False]['text':' 'reviews' collection.','line_number':82,'multiline':False]['text':' If the primary delegates the merging functionality to a randomly chosen shard, confirm the','line_number':87,'multiline':False]['text':' expected behavior here.','line_number':88,'multiline':False]['text':' Confirm that the $lookup execution is as expected.','line_number':105,'multiline':False]['text':' Confirm that the $lookup subpipeline execution is as expected.','line_number':117,'multiline':False]['text':' If merger is randomly delegated, we can't know in advance if reads will be local or','line_number':134,'multiline':False]['text':' remote.','line_number':135,'multiline':False]['text':' If there is a nested $lookup within the top-level $lookup subpipeline, confirm that','line_number':153,'multiline':False]['text':' execution is as expected.','line_number':154,'multiline':False]['text':' Confirm that a nested $lookup is never on the shards part of the pipeline split and','line_number':156,'multiline':False]['text':' doesn't get dispatched to a foreign shard (that is, we should designate a merging','line_number':157,'multiline':False]['text':' shard to execute the nested $lookup).','line_number':158,'multiline':False]['text':' Confirm that the nested $lookup subpipeline execution is as expected.','line_number':168,'multiline':False]['text':' If there is an additional top-level $lookup, confirm that execution is as expected.','line_number':184,'multiline':False]['text':' Confirm that the second $lookup execution is as expected.','line_number':186,'multiline':False]['text':' Confirm that the second $lookup subpipeline execution is as expected.','line_number':197,'multiline':False]['text':' Test unsharded local collection and sharded foreign collection, with a targeted $lookup.','line_number':216,'multiline':False]['text':' Because the local collection is unsharded, the $lookup stage is executed on the primary','line_number':248,'multiline':False]['text':' shard of the database.','line_number':249,'multiline':False]['text':' For every document that flows through the $lookup stage, the node executing the $lookup will','line_number':251,'multiline':False]['text':' target the shard that holds the relevant data for the sharded foreign collection.','line_number':252,'multiline':False]['text':' Test unsharded local collection and sharded foreign collection, with an untargeted $lookup.','line_number':256,'multiline':False]['text':' Because the local collection is unsharded, the $lookup stage is executed on the primary','line_number':261,'multiline':False]['text':' shard of the database.','line_number':262,'multiline':False]['text':' For every document that flows through the $lookup stage, the node executing the $lookup will','line_number':264,'multiline':False]['text':' perform a scatter-gather query and open a cursor on every shard that contains the foreign','line_number':265,'multiline':False]['text':' collection.','line_number':266,'multiline':False]['text':' Test sharded local collection and sharded foreign collection, with a targeted $lookup.','line_number':270,'multiline':False]['text':' The 'orders' collection is sharded, so the $lookup stage is executed in parallel on every','line_number':308,'multiline':False]['text':' shard that contains the local collection.','line_number':309,'multiline':False]['text':' Each node executing the $lookup will, for every document that flows through the $lookup','line_number':311,'multiline':False]['text':' stage, target the shard(s) that holds the relevant data for the sharded foreign collection.','line_number':312,'multiline':False]['text':' In cases, when shard targets itself, it will not show up in profiler, as the read will be','line_number':314,'multiline':False]['text':' performed without remote cursor.','line_number':315,'multiline':False]['text':' Test sharded local collection and sharded foreign collection, with an untargeted $lookup.','line_number':319,'multiline':False]['text':' The 'orders' collection is sharded, so the $lookup stage is executed in parallel on every','line_number':325,'multiline':False]['text':' shard that contains the local collection.','line_number':326,'multiline':False]['text':' Each node executing the $lookup will, for every document that flows through the $lookup','line_number':328,'multiline':False]['text':' stage, perform a scatter-gather query and open a cursor on every shard that contains the','line_number':329,'multiline':False]['text':' foreign collection.','line_number':330,'multiline':False]['text':' Test sharded local collection and sharded foreign collection with a targeted top-level $lookup','line_number':334,'multiline':False]['text':' and a nested $lookup on an unsharded foreign collection.','line_number':335,'multiline':False]['text':' The 'orders' collection is sharded, so the $lookup stage is executed in parallel on every','line_number':376,'multiline':False]['text':' shard that contains the local collection.','line_number':377,'multiline':False]['text':' Each node executing the $lookup will, for every document that flows through the $lookup','line_number':379,'multiline':False]['text':' stage, target the shard that holds the relevant data for the sharded foreign collection.','line_number':380,'multiline':False]['text':' When executing the subpipeline, the nested $lookup stage will stay on the merging half of the','line_number':382,'multiline':False]['text':' pipeline and execute on the merging node, sending requests to execute the nested subpipelines','line_number':383,'multiline':False]['text':' on the primary shard (where the unsharded 'updates' collection is stored). The $lookup on the','line_number':384,'multiline':False]['text':' non-primary shard would need to send requests over the network (not needed in this case due','line_number':385,'multiline':False]['text':' to the initial $match on customer); the rest are done via local reads and are not logged.','line_number':386,'multiline':False]['text':' Test sharded local collection and sharded foreign collection with a targeted top-level $lookup','line_number':390,'multiline':False]['text':' and a nested targeted $lookup on a sharded foreign collection.','line_number':391,'multiline':False]['text':' The 'orders' collection is sharded, so the top-level stage $lookup is executed in parallel on','line_number':403,'multiline':False]['text':' every shard that contains the local collection.','line_number':404,'multiline':False]['text':' For every document that flows through the $lookup stage, the node executing the $lookup will','line_number':406,'multiline':False]['text':' target the shard(s) that holds the relevant data for the sharded foreign collection.','line_number':407,'multiline':False]['text':' When executing the subpipeline, the nested $lookup stage will stay on the merging half of the','line_number':409,'multiline':False]['text':' pipeline and execute on the merging node, targeting shards to execute the nested $lookup','line_number':410,'multiline':False]['text':' subpipeline.','line_number':411,'multiline':False]['text':' Test sharded local collection and sharded foreign collection with a targeted top-level $lookup','line_number':416,'multiline':False]['text':' and a nested untargeted $lookup on a sharded foreign collection.','line_number':417,'multiline':False]['text':' The 'orders' collection is sharded, so the $lookup stage is executed in parallel on every','line_number':425,'multiline':False]['text':' shard that contains the local collection.','line_number':426,'multiline':False]['text':' For every document that flows through the $lookup stage, the node executing the $lookup will','line_number':428,'multiline':False]['text':' target the shard that holds the relevant data for the sharded foreign collection.','line_number':429,'multiline':False]['text':' When executing the subpipeline, the nested $lookup stage will stay on the merging half of the','line_number':431,'multiline':False]['text':' pipeline and execute on the merging node, performing a scatter-gather query to execute the','line_number':432,'multiline':False]['text':' nested $lookup subpipeline.','line_number':433,'multiline':False]['text':' Test sharded local collection where the foreign namespace is a sharded view with another','line_number':437,'multiline':False]['text':' $lookup against a sharded collection. Note that the $lookup in the view should be treated as','line_number':438,'multiline':False]['text':' "nested" $lookup and should execute on the merging node.','line_number':439,'multiline':False]['text':' The 'orders' collection is sharded, but mongos does not know that the foreign namespace is','line_number':482,'multiline':False]['text':' a view on a sharded collection. It is instead treated as an unsharded collection, and the','line_number':483,'multiline':False]['text':' top-level $lookup is only on the primary.','line_number':484,'multiline':False]['text':' For every document that flows through the $lookup stage, the primary will target the shard(s)','line_number':486,'multiline':False]['text':' that holds the relevant data for the sharded foreign view.','line_number':487,'multiline':False]['text':' When executing the subpipeline, the "nested" $lookup stage contained in the view pipeline','line_number':489,'multiline':False]['text':' will stay on the merging half of the pipeline and execute on the merging node, targeting','line_number':490,'multiline':False]['text':' shards to execute the nested subpipeline.','line_number':491,'multiline':False]['text':' Test that a targeted $lookup on a sharded collection can execute correctly on mongos.','line_number':496,'multiline':False]['text':' Because the $lookup is after a $group that requires merging, the $lookup stage is','line_number':526,'multiline':False]['text':' executed on mongos.','line_number':527,'multiline':False]['text':' For every document that flows through the $lookup stage, the mongos executing the $lookup','line_number':530,'multiline':False]['text':' will target the shard that holds the relevant data for the sharded foreign collection.','line_number':531,'multiline':False]['text':' Test that an untargeted $lookup on a sharded collection can execute correctly on mongos.','line_number':535,'multiline':False]['text':' Because the $lookup is after a $group that requires merging, the $lookup stage is','line_number':542,'multiline':False]['text':' executed on mongos.','line_number':543,'multiline':False]['text':' For every document that flows through the $lookup stage, the mongos executing the $lookup','line_number':546,'multiline':False]['text':' will perform a scatter-gather query and open a cursor on every shard that contains the','line_number':547,'multiline':False]['text':'  foreign collection.','line_number':548,'multiline':False]['text':' Test that a targeted $lookup on a sharded collection can execute correctly when mongos delegates','line_number':552,'multiline':False]['text':' to a merging shard.','line_number':553,'multiline':False]['text':' Because the $lookup stage is after a $group that requires merging, but 'allowDiskUse' is','line_number':561,'multiline':False]['text':' true, the mongos delegates a merging shard to perform the $lookup execution.','line_number':562,'multiline':False]['text':' For every document that flows through the $lookup stage, the node executing the $lookup','line_number':564,'multiline':False]['text':' will target the shard that holds the relevant data for the sharded foreign collection.','line_number':565,'multiline':False]['text':' Test that an untargeted $lookup on a sharded collection can execute correctly when mongos','line_number':569,'multiline':False]['text':' delegates to a merging shard.','line_number':570,'multiline':False]['text':' Because the $lookup stage is after a $group that requires merging, but 'allowDiskUse' is','line_number':577,'multiline':False]['text':' true, the mongos delegates a merging shard to perform the $lookup execution.','line_number':578,'multiline':False]['text':' For every document that flows through the $lookup stage, the node executing the $lookup','line_number':580,'multiline':False]['text':' will perform a scatter-gather query and open a cursor on every shard that contains the','line_number':581,'multiline':False]['text':' foreign collection.','line_number':582,'multiline':False]['text':' Test that multiple top-level $lookup stages are able to be run in parallel.','line_number':586,'multiline':False]['text':' The 'orders' collection is sharded, so the $lookup stage is executed in parallel on every','line_number':619,'multiline':False]['text':' shard that contains the local collection.','line_number':620,'multiline':False]['text':' Each node executing the $lookup will, for every document that flows through the $lookup','line_number':622,'multiline':False]['text':' stage, target the shard(s) that holds the relevant data for the sharded foreign collection.','line_number':623,'multiline':False]['text':' The second $lookup stage's expected execution behavior is similar to the first, executing in','line_number':625,'multiline':False]['text':' parallel on every shard that contains the 'updates' collection and, for each node, targeting','line_number':626,'multiline':False]['text':' shards to execute the subpipeline.','line_number':627,'multiline':False]['text':' Test that a $lookup with a subpipeline containing a non-correlated pipeline prefix is properly','line_number':631,'multiline':False]['text':' cached in sharded environments.','line_number':632,'multiline':False]['text':' Test unsharded local collection and sharded foreign collection.','line_number':634,'multiline':False]['text':' To make sure that there is a non-correlated pipeline prefix, we will match on "name" instead','line_number':640,'multiline':False]['text':' of _id to prevent the $match stage from being optimized before the $group.','line_number':641,'multiline':False]['text':' Because the local collection is unsharded, the $lookup stage is executed on the primary','line_number':665,'multiline':False]['text':' shard of the database.','line_number':666,'multiline':False]['text':' The node executing the $lookup will open a cursor on','line_number':668,'multiline':False]['text':' every shard that contains the foreign collection for the first iteration of $lookup. The','line_number':669,'multiline':False]['text':' $group stage in the subpipeline is non-correlated so the $lookup will only need to send the','line_number':670,'multiline':False]['text':' subpipeline to each shard once to populate the cache, and will perform local queries against','line_number':671,'multiline':False]['text':' the cache in subsequent iterations.','line_number':672,'multiline':False]['text':' Test sharded local collection and sharded foreign collection.','line_number':676,'multiline':False]['text':' To make sure that there is a non-correlated pipeline prefix, we will match on "name" instead','line_number':682,'multiline':False]['text':' of _id to prevent the $match stage from being optimized before the $group.','line_number':683,'multiline':False]['text':' The 'orders' collection is sharded, so the top-level stage $lookup is executed in parallel on','line_number':709,'multiline':False]['text':' every shard that contains the local collection.','line_number':710,'multiline':False]['text':' Each node that executes the $lookup will open a cursor on every shard that contains the','line_number':712,'multiline':False]['text':' foreign collection for the first iteration of $lookup. The $group stage in the subpipeline','line_number':713,'multiline':False]['text':' is non-correlated so the $lookup will only need to send the subpipeline to each shard once','line_number':714,'multiline':False]['text':' to populate the cache, and will perform local queries against the cache in subsequent','line_number':715,'multiline':False]['text':' iterations.','line_number':716,'multiline':False]['text':' Test unsharded local collection and unsharded foreign collection.','line_number':720,'multiline':False]['text':' Because the local collection is unsharded, the $lookup stage is executed on the primary','line_number':723,'multiline':False]['text':' shard of the database.','line_number':724,'multiline':False]['text':' Because the foreign collection is unsharded, the node executing the $lookup can do a local','line_number':726,'multiline':False]['text':' read on the foreign coll during the first iteration of $lookup. The $group stage in the','line_number':727,'multiline':False]['text':' subpipeline is non-correlated so the $lookup will only need to do the local read once to','line_number':728,'multiline':False]['text':' populate the cache, and will perform local queries against the cache in subsequent','line_number':729,'multiline':False]['text':' iterations.','line_number':730,'multiline':False]['text':' Test sharded local collection and unsharded foreign collection.','line_number':735,'multiline':False]['text':' The 'orders' collection is sharded, but the foreign collection is not, so the $lookup stays','line_number':740,'multiline':False]['text':' on the merging half of the split pipeline and executes on the primary only.','line_number':741,'multiline':False]['text':' Because the foreign collection is unsharded, the node executing the $lookup can do a local','line_number':743,'multiline':False]['text':' read on the foreign coll during the first iteration of $lookup. The $group stage in the','line_number':744,'multiline':False]['text':' subpipeline is non-correlated so the $lookup will only need to do the local read once to','line_number':745,'multiline':False]['text':' populate the cache, and will perform local queries against the cache in subsequent','line_number':746,'multiline':False]['text':' iterations.','line_number':747,'multiline':False]['text':' Test sharded local collection and unsharded foreign collection is directed to the primary only.','line_number':752,'multiline':False]['text':' The 'orders' collection is sharded, but the foreign collection is unsharded, so the $lookup','line_number':773,'multiline':False]['text':' will stay on the merging part of the split pipeline and be sent to the primary only.','line_number':774,'multiline':False]['text':' Since it is unsharded, the foreign collection exists on the primary shard where the $lookup','line_number':776,'multiline':False]['text':' is executing. So, the $lookup can perform local reads into the foreign collection to execute','line_number':777,'multiline':False]['text':' the subpipelines.','line_number':778,'multiline':False]['text':' Test sharded local collection and sharded foreign collection that becomes unsharded.','line_number':783,'multiline':False]['text':' Shard the collection through the stale mongos, setting it up to believe the collection is','line_number':786,'multiline':False]['text':' sharded by {product_id: 1}. Perform a query through that mongos to ensure the cache is populated.','line_number':787,'multiline':False]['text':' Then, drop the collection from the other mongos.','line_number':788,'multiline':False]['text':' Now 'mongosDB' believes the collection is sharded, but it is actually unsharded. Test that the','line_number':793,'multiline':False]['text':' stale mongos still returns correct results.','line_number':794,'multiline':False]['text':' The stale mongos will believe that the foreign collection is sharded and will parallelize','line_number':797,'multiline':False]['text':' the $lookup.','line_number':798,'multiline':False]['text':' For every document that flows through the $lookup stage, each node will send the subpipelines','line_number':800,'multiline':False]['text':' to execute on the primary shard, since the foreign collection exists only on the primary.','line_number':801,'multiline':False]['text':' The primary shard can execute those subpipelines as local reads.','line_number':802,'multiline':False]['text':' Test sharded local collection and unsharded foreign collection that becomes sharded.','line_number':807,'multiline':False]['text':' Perform a query through the stale mongos to ensure the cache is populated and indicates that','line_number':810,'multiline':False]['text':' the foreign collection is unsharded. Then, shard the collection from the other mongos.','line_number':811,'multiline':False]['text':' Test that the stale mongos still returns correct results.','line_number':816,'multiline':False]['text':' The stale mongos will believe that the foreign collection is unsharded and will send the','line_number':819,'multiline':False]['text':' $lookup to the primary only.','line_number':820,'multiline':False]['text':' For every document that flows through the $lookup stage, the node executing the $lookup will','line_number':822,'multiline':False]['text':' perform a scatter-gather query and open a cursor on every shard that contains the foreign','line_number':823,'multiline':False]['text':' collection.','line_number':824,'multiline':False]