['text':'*
 * Sends killOp on the coordinator's OperationContext's opId at each point in the commit
 * coordination where there is an OperationContext and ensures the coordination still runs to
 * completion for all the points.
 *
 * @tags: [uses_transactions, uses_multi_shard_transaction]
 ','line_number':1,'multiline':True]['text':' Create a sharded collection with a chunk on each shard:','line_number':51,'multiline':False]['text':' shard0: [-inf, 0)','line_number':52,'multiline':False]['text':' shard1: [0, 10)','line_number':53,'multiline':False]['text':' shard2: [10, +inf)','line_number':54,'multiline':False]['text':' These forced refreshes are not strictly necessary; they just prevent extra TXN log lines','line_number':65,'multiline':False]['text':' from the shards starting, aborting, and restarting the transaction due to needing to','line_number':66,'multiline':False]['text':' refresh after the transaction has started.','line_number':67,'multiline':False]['text':' Start a new transaction by inserting a document onto each shard.','line_number':73,'multiline':False]['text':' Manually abort the transaction on one of the participants, so that the participant','line_number':93,'multiline':False]['text':' fails to prepare.','line_number':94,'multiline':False]['text':' Turn on failpoint to make the coordinator hang at a the specified point.','line_number':104,'multiline':False]['text':' Run commitTransaction through a parallel shell.','line_number':110,'multiline':False]['text':' Deliver killOp once the failpoint has been hit.','line_number':118,'multiline':False]['text':' Filter out the prepareTransaction op on the','line_number':133,'multiline':False]['text':' coordinator itself since killing it would','line_number':134,'multiline':False]['text':' cause the transaction to abort.','line_number':135,'multiline':False]['text':' timeout ','line_number':152,'multiline':True]['text':' interval ','line_number':152,'multiline':True]['text':' Use "greater than or equal to" since, for failpoints that pause the coordinator while','line_number':154,'multiline':False]['text':' it's sending prepare or sending the decision, there might be one additional thread that's','line_number':155,'multiline':False]['text':' doing the "send" to the local participant (or that thread might have already completed).','line_number':156,'multiline':False]['text':' If the commit coordination was not robust to killOp, then commitTransaction would fail','line_number':167,'multiline':False]['text':' with an Interrupted error rather than fail with NoSuchTransaction or return success.','line_number':168,'multiline':False]['text':' If deleting the coordinator doc was not robust to killOp, the document would still exist.','line_number':172,'multiline':False]['text':' Deletion is done asynchronously, so we might have to wait.','line_number':173,'multiline':False]['text':' Check that the transaction committed or aborted as expected.','line_number':177,'multiline':False]['text':' Use assert.soon(), because although coordinateCommitTransaction currently blocks','line_number':183,'multiline':False]['text':' until the commit process is fully complete, it will eventually be changed to only','line_number':184,'multiline':False]['text':' block until the decision is *written*, at which point the test can pass the','line_number':185,'multiline':False]['text':' operationTime returned by coordinateCommitTransaction as 'afterClusterTime' in the','line_number':186,'multiline':False]['text':' read to ensure the read sees the transaction's writes (TODO SERVER-37165).','line_number':187,'multiline':False]['text':' Test commit path.','line_number':198,'multiline':False]['text':' shouldCommit ','line_number':200,'multiline':True]