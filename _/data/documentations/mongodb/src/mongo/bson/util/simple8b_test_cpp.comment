['text':'*
 *    Copyright (C) 2021-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':39,'multiline':False]['text':' Performs addition as unsigned and cast back to signed to get overflow defined to wrapped around','line_number':58,'multiline':False]['text':' instead of undefined behavior.','line_number':59,'multiline':False]['text':' Tests in this file assume that the previous value was '0'. This is','line_number':127,'multiline':False]['text':' different semantics from BSONColumn.','line_number':128,'multiline':False]['text':' Tests in this file assume that the previous value was '0'. This is','line_number':144,'multiline':False]['text':' different semantics from BSONColumn.','line_number':145,'multiline':False]['text':' Test prefix sum with different initial prefixes','line_number':155,'multiline':False]['text':' The selector is 14 and the remaining 60 bits of data are all 1s, which represents skip.','line_number':184,'multiline':False]['text':' 1st word.','line_number':186,'multiline':False]['text':' The selector is 14 and there is only 1 bucket with the value 1.','line_number':193,'multiline':False]['text':' 1st word.','line_number':194,'multiline':False]['text':' The selector is 14 and there is only 1 bucket with the max possible value 0xFFFFFFFFFFFFFFE.','line_number':202,'multiline':False]['text':' 1st word.','line_number':204,'multiline':False]['text':' The selector is 12 and there are 3 bucket with the values 1, 2 and 3.','line_number':211,'multiline':False]['text':' 1st word.','line_number':212,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01. 0x55 = 0b01010101.','line_number':220,'multiline':False]['text':' 1st word.','line_number':229,'multiline':False]['text':' 2nd word.','line_number':237,'multiline':False]['text':' The selector is 8 and there are 7 bucket with the same value 0b00000001.','line_number':246,'multiline':False]['text':' The last 4 bits are dirty/unused.','line_number':247,'multiline':False]['text':' 1st word.','line_number':249,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01. 0x55 = 0b01010101.','line_number':257,'multiline':False]['text':' 1st word.','line_number':259,'multiline':False]['text':' 2nd word.','line_number':260,'multiline':False]['text':' 3rd word.','line_number':261,'multiline':False]['text':' 4th word.','line_number':262,'multiline':False]['text':' The selector is 14 and there is only 1 bucket with the max possible value 0xFFFFFFFFFFFFFFE.','line_number':271,'multiline':False]['text':' 1st word.','line_number':273,'multiline':False]['text':' 2nd word.','line_number':274,'multiline':False]['text':' 3rd word.','line_number':275,'multiline':False]['text':' 15 is 0b1111 and can not be added to the current word because it would overflow.','line_number':302,'multiline':False]['text':' We can not form a 57 bit word because we would be unable to determine','line_number':303,'multiline':False]['text':' if the last 3 bits are empty or unused.','line_number':304,'multiline':False]['text':' Therefore, we must form a word with 30 integers of 1's, 20 integers of 1's','line_number':305,'multiline':False]['text':' and the current vector would have seven 1's and one 15.','line_number':306,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01. 0x55 = 0b01010101.','line_number':310,'multiline':False]['text':' 1st word.','line_number':318,'multiline':False]['text':' The selector is 3 and there are 20 bucket with the same value 0b01.','line_number':319,'multiline':False]['text':' 0x24 = 0b00100100, 0x49 = 0b01001001 and 0x92 = 0b10010010.','line_number':320,'multiline':False]['text':' 2nd word.','line_number':328,'multiline':False]['text':' The selector is 7 and there are 8 bucket of 0b01 except the last bucket which is 0b1111.','line_number':329,'multiline':False]['text':' 0xE0 = 0b11100000 and 0x1 = 0x00000001 and together the last bucket is 0b1111.','line_number':330,'multiline':False]['text':' 3rd word.','line_number':338,'multiline':False]['text':' 0xFFFFFFFFFFFF is 48 bits and can not be added to the current word because it would overflow.','line_number':347,'multiline':False]['text':' We can not form a 57 bit word because we would be unable to determine','line_number':348,'multiline':False]['text':' if the last 3 bits are empty or unused. Therefore, we must form a word with 30 integers','line_number':349,'multiline':False]['text':' of 0's and 20 integers of 0's in the same append() iteration.','line_number':350,'multiline':False]['text':' 48 bit value.','line_number':351,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b00.','line_number':354,'multiline':False]['text':' 1st word.','line_number':362,'multiline':False]['text':' The selector is 3 and there are 20 bucket with the same value 0b00.','line_number':363,'multiline':False]['text':' 2nd word.','line_number':371,'multiline':False]['text':' The selector is 14 and there is only 1 bucket with 0xFFFFFFFFFFFF.','line_number':372,'multiline':False]['text':' 3rd word.','line_number':380,'multiline':False]['text':' The selector is 10 and there are 5 bucket with 12 bit buckets.','line_number':391,'multiline':False]['text':' 0xFF and 0x7F is 15 1's. The skip is 12 1's and 7 is 3 1's.','line_number':392,'multiline':False]['text':' 1st word.','line_number':393,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01. 0x55 = 0b01010101.','line_number':404,'multiline':False]['text':' 1st word.','line_number':412,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01','line_number':413,'multiline':False]['text':' except the skip, which is the 0x7 in the 6th byte. 0x55 = 0b01010101.','line_number':414,'multiline':False]['text':' 2nd word.','line_number':422,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01. 0x55 = 0b01010101.','line_number':423,'multiline':False]['text':' 3rd word.','line_number':431,'multiline':False]['text':' The selector is 6 and there are 10 bucket with the same value 0b000001.','line_number':432,'multiline':False]['text':' 4th word.','line_number':440,'multiline':False]['text':' The selector is 14 and there is only 1 bucket with the value 1.','line_number':441,'multiline':False]['text':' 5th word.','line_number':449,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01. 0x55 = 0b01010101.','line_number':459,'multiline':False]['text':' 1st word.','line_number':467,'multiline':False]['text':' The selector is 3 and there are 20 bucket with the same value 0b001.','line_number':468,'multiline':False]['text':' except the last 2 buckets, which are skips. 0xFC = 11111100, which is exactly 2 skips.','line_number':469,'multiline':False]['text':' 2nd word.','line_number':477,'multiline':False]['text':' The selector is 10 and there are 5 bucket with 12 bit buckets.','line_number':486,'multiline':False]['text':' The first two buckets are skips.','line_number':487,'multiline':False]['text':' 1st word.','line_number':488,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b11, referring to skip.','line_number':499,'multiline':False]['text':' 1st word.','line_number':507,'multiline':False]['text':' The selector is 14 and there is only bucket with the value','line_number':508,'multiline':False]['text':' 0b100000000000000000000000000000.','line_number':509,'multiline':False]['text':' 2nd word.','line_number':517,'multiline':False]['text':' The selector is 7 and the extension value is 1, so the values alternate','line_number':532,'multiline':False]['text':' between 0b111111 (skip) and 0b010110 (64).','line_number':533,'multiline':False]['text':' 1st word.','line_number':541,'multiline':False]['text':' The selector is 7 and the extension value is 1, so the values alternate','line_number':542,'multiline':False]['text':' between 0b111111 (skip) and 0b010110 (64).','line_number':543,'multiline':False]['text':' 2nd word.','line_number':551,'multiline':False]['text':' The selector is 13 and there are 2 buckets with one skip and then 0b010000 (64).','line_number':552,'multiline':False]['text':' 3rd word.','line_number':560,'multiline':False]['text':' The selector is 15 and the word is a RLE encoding with count = 16.','line_number':572,'multiline':False]['text':' The default RLE value is 0 if it is the first number.','line_number':573,'multiline':False]['text':' 1st word.','line_number':581,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01. 0x55 = 0b01010101.','line_number':582,'multiline':False]['text':' 2nd word.','line_number':590,'multiline':False]['text':' The selector is 15 and the word is a RLE encoding with count = 2.','line_number':591,'multiline':False]['text':' 3rd word.','line_number':599,'multiline':False]['text':' The selector is 14 and there is only 1 bucket with the value 1.','line_number':625,'multiline':False]['text':' 1st word.','line_number':633,'multiline':False]['text':' The selector is 14 and there is only 1 bucket with the value 2.','line_number':634,'multiline':False]['text':' 2nd word.','line_number':642,'multiline':False]['text':' 57344 = 1110000000000000 = 3 value bits and 13 zeros','line_number':658,'multiline':False]['text':' This should be encoded as:','line_number':659,'multiline':False]['text':' [(111) (1101)] x 8 [0010] [0111] = FBF7EFDFBF7EFD27','line_number':660,'multiline':False]['text':' This is in hex: 2FBF7EFDFBF7EFD7','line_number':661,'multiline':False]['text':' test that buffer was correct','line_number':666,'multiline':False]['text':' 57344 = 1110000000000000 = 3 value bits and 13 zeros','line_number':672,'multiline':False]['text':' This should be encoded with alternating skips as:','line_number':673,'multiline':False]['text':' [(111) (1111) (111) (1101)] x 4 [0010] [0111] = FFF7FFDFFF7FFD27','line_number':674,'multiline':False]['text':' test that buffer was correct','line_number':683,'multiline':False]['text':' 30 = 11110 so a single zero','line_number':689,'multiline':False]['text':' This should not be encoded with selector 7  since it will take 4 extra bits to store the','line_number':690,'multiline':False]['text':' count of zeros','line_number':691,'multiline':False]['text':' This should be encoded as:','line_number':692,'multiline':False]['text':' [11110] x 12 [0101] = F7BDEF7BDEF7BDE5','line_number':693,'multiline':False]['text':' test that buffer was correct','line_number':697,'multiline':False]['text':' 229376 = 111000000000000000 = 3 value bits and 15 zeros which would be stored as 111-1111','line_number':703,'multiline':False]['text':' using selector 7. However, we will add a padding bit to store as 0111-1111','line_number':704,'multiline':False]['text':' This should be encoded as:','line_number':705,'multiline':False]['text':' [(0111) (1111)] x7 [0011] [0111] = 7F7F7F7F7F7F7F37','line_number':706,'multiline':False]['text':' test that buffer was correct','line_number':710,'multiline':False]['text':' Base value = 1011 = 11','line_number':716,'multiline':False]['text':' Selector 7 value = 12615680 = 110000000001 + 15 zeros.','line_number':717,'multiline':False]['text':' We should encode this as:','line_number':718,'multiline':False]['text':' [(01100000001) (1111)] x 2 [(00000001011) (0000)] x 2 [0110] [0111] = 607','line_number':719,'multiline':False]['text':' D81F02C00B067','line_number':720,'multiline':False]['text':' test that buffer was correct','line_number':727,'multiline':False]['text':' Base value = 1011 = 11','line_number':733,'multiline':False]['text':' Selector 7 value = 12615680 = 110000000001 + 15 zeros.','line_number':734,'multiline':False]['text':' We should encode this as:','line_number':735,'multiline':False]['text':' [(00000001011) (0000)] x 2 [(01100000001) (1111)] x 2 [0110] [0111] = 2C0','line_number':736,'multiline':False]['text':' 0B0607D81F67','line_number':737,'multiline':False]['text':' test that buffer was correct','line_number':745,'multiline':False]['text':' 0x500000 = 101 + 20 zeros. This should be stored as (0101 0101) where the second value of 4','line_number':751,'multiline':False]['text':' is the nibble shift of 5*4. The first value is 0101 because we store at least 4 bits. This','line_number':752,'multiline':False]['text':' should be encoded as','line_number':753,'multiline':False]['text':' [(0101) (0101)] x 7 [0001] [1000] = 7575757575757518','line_number':754,'multiline':False]['text':'','line_number':755,'multiline':False]['text':' test that buffer was correct','line_number':759,'multiline':False]['text':' 7340032 = 111 + 20 zeros. This should be stored as (0111 0101) where the second value of 4 is','line_number':765,'multiline':False]['text':' the nibble shift of 4*4. The first value is 0111 because we  store at least 4 values. Then we','line_number':766,'multiline':False]['text':' have a value of all 1s for skip.','line_number':767,'multiline':False]['text':' This should be encoded as','line_number':768,'multiline':False]['text':' [(0111) (0101)] [(1111 1111) (0111 0101)] x 3 [0001] [1000] = 75FF75FF75FF7518','line_number':769,'multiline':False]['text':' test that buffer was correct','line_number':778,'multiline':False]['text':' A perfect skip value is one that aligns perfectly with the boundary. 1111 with 60 zeros does','line_number':784,'multiline':False]['text':' that. They need to be padded with an extra zero and cause the Selector to be 2 instead of 1','line_number':785,'multiline':False]['text':' bumping out the last skip to the next block.','line_number':786,'multiline':False]['text':' This should be encoded as','line_number':787,'multiline':False]['text':' [(01111 1111) x 6] [0010] [1000] = 3FEFFFFBFFFEFF28','line_number':788,'multiline':False]['text':'','line_number':789,'multiline':False]['text':' test that buffer was correct','line_number':797,'multiline':False]['text':' 7864320 = 1111 + 19 zeros. This is a value that should have 3 trailing zeros due to nibble.','line_number':803,'multiline':False]['text':' So we should encode as:','line_number':804,'multiline':False]['text':' [(1111000) (0100)] x 4 [0011] [1000] = 784F09E13C278438','line_number':805,'multiline':False]['text':' test that buffer was correct','line_number':809,'multiline':False]['text':' 549789368320 = 1(13 zeros)1 + 25 zeros. This is a value that should have 1 trailing zeros due','line_number':815,'multiline':False]['text':' to nibble. So we should encode as:','line_number':816,'multiline':False]['text':' [(0000001(13 zeros)10) (0110)] x2 [0110] [1000] = 80026008002668','line_number':817,'multiline':False]['text':' test that buffer was correct','line_number':821,'multiline':False]['text':' This tests that what only requires a seven selector value will be properly encoded as a eight','line_number':827,'multiline':False]['text':' selector value. The 57344 should be encoded as 3 ones and 13 zeros. The next value requires','line_number':828,'multiline':False]['text':' selector 8 which is 7340032 (3 ones and 20 zeros). We should choose a selector requiring 4','line_number':829,'multiline':False]['text':' valu bits to store these.','line_number':830,'multiline':False]['text':' This should be encoded as','line_number':831,'multiline':False]['text':' [(0111) (0101) x 3] [(1110 0011) x 4] [0001] [1000] = 757575E3E3E3E318','line_number':832,'multiline':False]['text':' test that buffer was correct','line_number':839,'multiline':False]['text':' This tests a combination of selector switches, rounding, and nibble shifts for our simple8b','line_number':845,'multiline':False]['text':' encoding. The first value of 6 is 110 which should be encoded as 0110 0000. The 57344 should','line_number':846,'multiline':False]['text':' be encoded as 3 ones and 13 zeros. The next value requires selector 8 which is 7340032 (3','line_number':847,'multiline':False]['text':' ones and 20 zeros). We should choose a selector requiring 4 valu bits to store these. This','line_number':848,'multiline':False]['text':' sohould be encoded as: [(0111) (0101) x 3] [(1110 0011) x 3] [0110 0000] [0001] [1000] =','line_number':849,'multiline':False]['text':' 17575E3E3E3E3608','line_number':850,'multiline':False]['text':' test that buffer was correct 17474E3E3E3E3608','line_number':860,'multiline':False]['text':' This tests a combination of selector switches, rounding, and nibble shifts for our simple8b','line_number':866,'multiline':False]['text':' encoding. TThe first value requires selector 8 which is 7340032 (3 ones','line_number':867,'multiline':False]['text':' and 20 zeros).  The 57344 should','line_number':868,'multiline':False]['text':' be encoded as 3 ones and 13 zeros. The next value of 6 is 110 which should be encoded as 0110','line_number':869,'multiline':False]['text':' 0000. We should choose a selector requiring 4 value bits to store these. This should be','line_number':870,'multiline':False]['text':' encoded as','line_number':871,'multiline':False]['text':' [0110 0000] [(1110 0011) x 3] [(0111) (0101) x 3] [0001] [1000] = 60E3E3E375757518','line_number':872,'multiline':False]['text':' test that buffer was correct','line_number':883,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01.','line_number':892,'multiline':False]['text':' 1st word.','line_number':900,'multiline':False]['text':' The selector is 15 and the word is RLE encoding with count = 1.','line_number':901,'multiline':False]['text':' 2nd word.','line_number':909,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01.','line_number':910,'multiline':False]['text':' 3rd word.','line_number':918,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01.','line_number':927,'multiline':False]['text':' 1st word.','line_number':935,'multiline':False]['text':' The selector is 15 and the word is RLE with max count = 16.','line_number':936,'multiline':False]['text':' 2nd word.','line_number':944,'multiline':False]['text':' The selector is 15 and the word is RLE with max count = 16.','line_number':945,'multiline':False]['text':' 3rd word.','line_number':953,'multiline':False]['text':' The selector is 1 and there are 60 bucket with skip.','line_number':962,'multiline':False]['text':' 1st word.','line_number':970,'multiline':False]['text':' The selector is 15 and the word is RLE encoding with count = 1.','line_number':971,'multiline':False]['text':' 2nd word.','line_number':979,'multiline':False]['text':' The selector is 1 and there are 60 bucket with skip.','line_number':980,'multiline':False]['text':' 3rd word.','line_number':988,'multiline':False]['text':' Make sure that flushing skips does not re-enable RLE when it fits a full Simple8b. We need at','line_number':994,'multiline':False]['text':' least 121 skips to verify this (60+60+1)','line_number':995,'multiline':False]['text':' The selector is 1 and there are 60 bucket with skip.','line_number':999,'multiline':False]['text':' 1st word.','line_number':1007,'multiline':False]['text':' The selector is 1 and there are 60 bucket with skip.','line_number':1008,'multiline':False]['text':' 2nd word.','line_number':1016,'multiline':False]['text':' The selector is 14 and there are 1 bucket with skip.','line_number':1017,'multiline':False]['text':' 3rd word.','line_number':1025,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01.','line_number':1036,'multiline':False]['text':' 1st word.','line_number':1044,'multiline':False]['text':' The selector is 15 and the word is RLE encoding with count = 2.','line_number':1045,'multiline':False]['text':' 2nd word.','line_number':1053,'multiline':False]['text':' The selector is 2 and there are 30 bucket with the same value 0b01.','line_number':1054,'multiline':False]['text':' 3rd word.','line_number':1062,'multiline':False]['text':' The selector is 14 and there is only one bucket with the value 7.','line_number':1063,'multiline':False]['text':' 4th word.','line_number':1071,'multiline':False]['text':' The selector is 15 and the word is RLE encoding with count = 2.','line_number':1081,'multiline':False]['text':' 1st word.','line_number':1089,'multiline':False]['text':' 8462480737302404222943232 = 111 + 80 zeros. This should be stored as (111 10100) where the','line_number':1096,'multiline':False]['text':' second value of 20 is the nibble shift of 4*20. The first value is 0111 because we store at','line_number':1097,'multiline':False]['text':' least 4 values. This should be encoded as [(111) (10100)] x6 [1000] [1000] = //','line_number':1098,'multiline':False]['text':' 81E8F47A3D1E8F48','line_number':1099,'multiline':False]['text':' Have a large value that forces the extended selectors to be used. Then we check that zeros','line_number':1107,'multiline':False]['text':' are handled correctly for them.','line_number':1108,'multiline':False]['text':' Stored as 0xF4, [value=(111) nibble count=(10100)]','line_number':1110,'multiline':False]['text':' 5 values with Selector8Large = 0x98','line_number':1113,'multiline':False]['text':' 8462480737302404222943232 = 111 + 80 zeros. This should be stored as (0111 10100) where the','line_number':1120,'multiline':False]['text':' second value of 20 is the nibble shift of 4*20. The first value is 0111 because we store at','line_number':1121,'multiline':False]['text':' least 4 values. With skip this should be encoded as:','line_number':1122,'multiline':False]['text':' [(1111) (11111) (0111) (10100)] x3 [1000] = 83FEF4FFBD3FEF48','line_number':1123,'multiline':False]['text':' A perfect skip value is one that aligns perfectly with the boundary. 1111 with 124 zeros does','line_number':1135,'multiline':False]['text':' that.','line_number':1136,'multiline':False]['text':' This should be encoded as','line_number':1137,'multiline':False]['text':' [(001111 11111) x 5] [1001] [1000] = 1FF3FE7FCFF9FF98','line_number':1138,'multiline':False]['text':' 170141183460469231731687303715884105728= 1 + 127 zeros. This is a value that should have 3','line_number':1146,'multiline':False]['text':' trailing zeros due to nibble. So we should encode as:','line_number':1147,'multiline':False]['text':' [(1000) (11111)] x6 [1000] [1000] = 23F1F8FC7E3F1F88','line_number':1148,'multiline':False]['text':' This tests that if we use a small int128_t, we still correctly store.','line_number':1156,'multiline':False]['text':' 57344 = 1110000000000000 = 3 value bits and 13 zeros','line_number':1157,'multiline':False]['text':' This should be encoded as:','line_number':1158,'multiline':False]['text':' [(111) (1101)] x 8 [0010] [0111] = FBF7EFDFBF7EFD27','line_number':1159,'multiline':False]['text':' Selector 7 value = 64 = 1 + 6 zeros.','line_number':1167,'multiline':False]['text':' We should encode this as:','line_number':1168,'multiline':False]['text':' [(01) (0110)] x 9 [0001] [0111] = 1659659659659617','line_number':1169,'multiline':False]['text':' test that buffer was correct','line_number':1172,'multiline':False]['text':' Selector 7 value','line_number':1178,'multiline':False]['text':' 57344 = 3 value bits and 13 zeros','line_number':1179,'multiline':False]['text':' This should be encoded as','line_number':1180,'multiline':False]['text':' [(111) (1101)] x8 [0010] [0111] = FBF7EFDFBF7EFD27 + 0xF (rle) + repeat seven selector','line_number':1181,'multiline':False]['text':' Selector 8 value','line_number':1191,'multiline':False]['text':' 7340032 = 1110000000000000 = 3 value bits and 20 zeros','line_number':1192,'multiline':False]['text':' This should be encoded as','line_number':1193,'multiline':False]['text':' [(0111) (0101)] x7 [0001] [1000] = 7575757575757518 + 0xF (rle) + repeat eight selector','line_number':1194,'multiline':False]['text':' Selector 8 value','line_number':1204,'multiline':False]['text':' 8462480737302404222943232= 111 + 80 zeros','line_number':1205,'multiline':False]['text':' This should be encoded as','line_number':1206,'multiline':False]['text':' [(0111) (10000)] x6 [1000] [1000] = 1E8F47A3D1E8F488 + 0xF (rle) + repeat eight selector','line_number':1207,'multiline':False]['text':' Write a single 1 and flush. Then we add 120 more 1s and check that this does not start RLE.','line_number':1223,'multiline':False]['text':' Write a large value with many trailing zeros that does not fit in the base selector, we then','line_number':1259,'multiline':False]['text':' flush and make sure that we can write a value that only fits in the base selector. We should','line_number':1260,'multiline':False]['text':' have reset possible selectors as part of the flush.','line_number':1261,'multiline':False]['text':' Write 150 1s and flush. This should result in a word with 30 1s followed by RLE. We make sure','line_number':1283,'multiline':False]['text':' that last value written is reset when RLE is the last thing we flush.','line_number':1284,'multiline':False]['text':' Last value written is only used for RLE so append 120 values of the same value and make sure','line_number':1290,'multiline':False]['text':' this does _NOT_ start RLE as flush occured in between.','line_number':1291,'multiline':False]['text':' Write 150 1s and flush. This should result in a word with 30 1s followed by RLE. We make sure','line_number':1324,'multiline':False]['text':' that last value written is reset when RLE is the last thing we flush.','line_number':1325,'multiline':False]['text':' Write 120 0s. They should be encoded as a single RLE block.','line_number':1332,'multiline':False]['text':' Reading all values as one block would be interpreted as everything is 1s as we wrote a','line_number':1354,'multiline':False]['text':' RLE block immediately after a block containing 1 values.','line_number':1355,'multiline':False]['text':' In practise the binary is split up in two parts where we can initialize the second part on','line_number':1360,'multiline':False]['text':' how the RLE should be interpreted.','line_number':1361,'multiline':False]['text':' previous ','line_number':1368,'multiline':True]['text':' Selector 8 value','line_number':1374,'multiline':False]['text':' 1111 + 124 zeros','line_number':1375,'multiline':False]['text':' This should be encoded as','line_number':1376,'multiline':False]['text':' [001111] [11111]  x5 [1001] [1000] = 1FF3FE7FCFF9FF98','line_number':1377,'multiline':False]['text':' This value needs 61 bits which it too large for Simple8b','line_number':1400,'multiline':False]['text':' Make sure we handle uint64_t max correctly.','line_number':1410,'multiline':False]['text':' Make sure we handle uint128_t max correctly.','line_number':1421,'multiline':False]['text':' Make sure we handle uint128_t max correctly.','line_number':1432,'multiline':False]['text':' This value has 52 meaningful bits and 61 trailing zeros. This is too many trailing zeros for','line_number':1443,'multiline':False]['text':' Selector 8 Small and too many meaningful bits for Selector 8 Large.','line_number':1444,'multiline':False]['text':' This value has 52 meaningful bits and 60 trailing zeros. But one extra 0 needs to be added to','line_number':1454,'multiline':False]['text':' the meaningful bits to differentiate from the missing value pattern to be able to store in','line_number':1455,'multiline':False]['text':' Extended 8 Small which brings it to 53 bits which is too many. Extended 8 Large can't be used','line_number':1456,'multiline':False]['text':' either as it can only store 51 meaningful bits.','line_number':1457,'multiline':False]['text':' This value has 52 meaningful bits and 59 trailing zeros. But 3 of the trailing bits need to','line_number':1467,'multiline':False]['text':' be stored in the data bits as it's not divisible by 4. This brings the data bits to 55 which','line_number':1468,'multiline':False]['text':' it too large.','line_number':1469,'multiline':False]['text':' This value has 63 meaningful bits and does not fit in Simple8b. When evaluating the extended','line_number':1479,'multiline':False]['text':' selectors it will almost fit as it can pack the 9 trailing zero in the count but the amount','line_number':1480,'multiline':False]['text':' of bits required will still be too large. Make sure append takes into the account the number','line_number':1481,'multiline':False]['text':' of bits used for the count when checking if the value can be stored.','line_number':1482,'multiline':False]