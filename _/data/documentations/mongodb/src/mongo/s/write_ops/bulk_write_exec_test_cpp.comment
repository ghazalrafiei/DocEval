['text':'*
 *    Copyright (C) 2023-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: no_include "cxxabi.h"','line_number':37,'multiline':False]['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':38,'multiline':False]['text':' Not changing metadata but incrementing _numRefreshes.','line_number':139,'multiline':False]['text':' x >= 0 values are untargetable','line_number':171,'multiline':False]['text':' Helper to create the response that a shard returns to a bulkwrite command request.','line_number':176,'multiline':False]['text':' cursorId','line_number':184,'multiline':False]['text':' This failpoint is to skip running the useTwoPhaseWriteProtocol check which expects the Grid','line_number':216,'multiline':False]['text':' to be initialized. With the feature flag on, the helper always returns false, which signifies','line_number':217,'multiline':False]['text':' that we have a targetable write op.','line_number':218,'multiline':False]['text':' Test targeting a single op in a bulkWrite request.','line_number':223,'multiline':False]['text':' Insert','line_number':245,'multiline':False]['text':' Update','line_number':248,'multiline':False]['text':' Delete','line_number':252,'multiline':False]['text':' Test targeting a single op with target error.','line_number':257,'multiline':False]['text':' Initialize the targeter so that x >= 0 values are untargetable so target call will encounter','line_number':265,'multiline':False]['text':' an error.','line_number':266,'multiline':False]['text':' target should return target error when recordTargetErrors = false.','line_number':273,'multiline':False]['text':' target should transition the writeOp to an error state upon target errors when','line_number':278,'multiline':False]['text':' recordTargetErrors = true.','line_number':279,'multiline':False]['text':' Insert','line_number':285,'multiline':False]['text':' Update','line_number':288,'multiline':False]['text':' Delete','line_number':292,'multiline':False]['text':' Test multiple ordered ops that target the same shard.','line_number':297,'multiline':False]['text':' Two different endpoints targeting the same shard for the two namespaces.','line_number':302,'multiline':False]['text':' Test that both writes target the same shard under two different endpoints for their','line_number':318,'multiline':False]['text':' namespace.','line_number':319,'multiline':False]['text':' Two inserts','line_number':331,'multiline':False]['text':' Two updates','line_number':335,'multiline':False]['text':' Two deletes','line_number':340,'multiline':False]['text':' Mixed op types: update + delete','line_number':344,'multiline':False]['text':' Test multiple ordered ops where one of them result in a target error.','line_number':351,'multiline':False]['text':' Initialize the targeter so that x >= 0 values are untargetable so target call will encounter','line_number':365,'multiline':False]['text':' an error.','line_number':366,'multiline':False]['text':' Only the first op should be targeted as the second op encounters a target error. But this','line_number':376,'multiline':False]['text':' won't record the target error since there could be an error in the first op before','line_number':377,'multiline':False]['text':' executing the second op.','line_number':378,'multiline':False]['text':' Pretending the first op was done successfully, the target error should be recorded in the','line_number':389,'multiline':False]['text':' second op.','line_number':390,'multiline':False]['text':' Requests where only the second op would get a target error.','line_number':397,'multiline':False]['text':' Insert gets the target error','line_number':399,'multiline':False]['text':' Update gets the target error','line_number':404,'multiline':False]['text':' Delete gets the target error','line_number':410,'multiline':False]['text':' Test that we abort execution when we receive a targeting error in a transaction.','line_number':417,'multiline':False]['text':' Initialize the targeter so that x >= 0 values are untargetable so target call will encounter','line_number':425,'multiline':False]['text':' an error.','line_number':426,'multiline':False]['text':' Set up state so that the first write is targetable but the second is not.','line_number':429,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':437,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that','line_number':440,'multiline':False]['text':' is how we set _inTransaction for a BulkWriteOp.','line_number':441,'multiline':False]['text':' Even though the first write is targetable, we should stop immediately and report failure','line_number':449,'multiline':False]['text':' because we are in a transaction.','line_number':450,'multiline':False]['text':' Test that we abort execution and throw a top-level error when receiving a','line_number':464,'multiline':False]['text':' TransientTransactionError while attempting to target writes in a transaction.','line_number':465,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':467,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that','line_number':470,'multiline':False]['text':' is how we set _inTransaction for a BulkWriteOp.','line_number':471,'multiline':False]['text':' Test multiple ordered ops that target two different shards.','line_number':484,'multiline':False]['text':' ops[0] -> shardA','line_number':504,'multiline':False]['text':' ops[1] -> shardB','line_number':505,'multiline':False]['text':' ops[2] -> shardA','line_number':506,'multiline':False]['text':' ops[3] -> shardB','line_number':507,'multiline':False]['text':' ops[4] -> shardA','line_number':508,'multiline':False]['text':' The resulting batch should be {shardA: [ops[0]]}.','line_number':523,'multiline':False]['text':' The resulting batch should be {shardB: [ops[1]]}.','line_number':537,'multiline':False]['text':' The resulting batch should be {shardA: [ops[2]]}.','line_number':551,'multiline':False]['text':' The resulting batch should be {shardB: [ops[3]]}.','line_number':565,'multiline':False]['text':' The resulting batch should be {shardA: [ops[4]]}.','line_number':579,'multiline':False]['text':' Test targeting ordered ops where a multi-target sub-batch must only contain writes for a','line_number':592,'multiline':False]['text':' single write op.','line_number':593,'multiline':False]['text':' Ordered update and delete ops. We place multi-target ops in between single-target ops to the','line_number':606,'multiline':False]['text':' same shards, to ensure we correctly separate the multi-target ops into their own batches.','line_number':607,'multiline':False]['text':' Expected targets:','line_number':608,'multiline':False]['text':' ops[0] -> shardA','line_number':609,'multiline':False]['text':' ops[1] -> shardA and shardB','line_number':610,'multiline':False]['text':' ops[2] -> shardB','line_number':611,'multiline':False]['text':' ops[3] -> shardB','line_number':612,'multiline':False]['text':' ops[4] -> shardA and shardB','line_number':613,'multiline':False]['text':' ops[5] -> shardA','line_number':614,'multiline':False]['text':' The resulting batches should be:','line_number':629,'multiline':False]['text':' {shardA: [ops[0]}','line_number':630,'multiline':False]['text':' {shardA: [ops[1]]}, {shardB: [ops[1]]}','line_number':631,'multiline':False]['text':' {shardB: [ops[2], ops[3]]}','line_number':632,'multiline':False]['text':' {shardA: [ops[4]]}, {shardB: [ops[4]]}','line_number':633,'multiline':False]['text':' {shardA: [ops[5]]}','line_number':634,'multiline':False]['text':' {shardA: [ops[0]}','line_number':638,'multiline':False]['text':' {shardA: [ops[1]]}, {shardB: [ops[1]]}','line_number':653,'multiline':False]['text':' {shardB: [ops[2], ops[3]]}','line_number':671,'multiline':False]['text':' {shardA: [ops[4]]}, {shardB: [ops[4]]}','line_number':688,'multiline':False]['text':' {shardA: [ops[5]]}','line_number':707,'multiline':False]['text':' Test targeting unordered ops of the same namespace that target the same shard/endpoint under two','line_number':721,'multiline':False]['text':' different shardVersions.','line_number':722,'multiline':False]['text':' As discussed in SERVER-34347, because of the way that (non-transactional) multi-target writes','line_number':723,'multiline':False]['text':' disregard the shardVersion and use ChunkVersion::IGNORED, we cannot have together in a single','line_number':724,'multiline':False]['text':' sub-batch an op for a multi-target write *and* an op for a single-target write that target','line_number':725,'multiline':False]['text':' the same endpoint, because the single target write will use the actual shardVersion.','line_number':726,'multiline':False]['text':' The endpoints we'll use for our targeter.','line_number':732,'multiline':False]['text':' Used for assertions below; equivalent to the endpoints that multi-target ops will use (same','line_number':748,'multiline':False]['text':' as those above but no shard version.)','line_number':749,'multiline':False]['text':' We expect the ops to target the following endpoints with/without shardVersion as indicated:','line_number':755,'multiline':False]['text':' ops[0] -> A, shardVersion included','line_number':756,'multiline':False]['text':' ops[1] -> A shardVersion ignored, B shardVersion ignored','line_number':757,'multiline':False]['text':' ops[2] -> B, shardVersion included','line_number':758,'multiline':False]['text':' ops[3] -> A shardVersion ignored, B shardVersion ignored','line_number':759,'multiline':False]['text':' ops[4] -> A shardVersion included','line_number':760,'multiline':False]['text':' Due to the interleaving of ops, each op should end up split into its own sub-batch, since no','line_number':762,'multiline':False]['text':' two consecutive ops target the same endpoint with the same shardVersion.','line_number':763,'multiline':False]['text':' batch with ops[0]','line_number':780,'multiline':False]['text':' batch with ops[1]','line_number':794,'multiline':False]['text':' batch with ops[2]','line_number':811,'multiline':False]['text':' batch with ops[3]','line_number':825,'multiline':False]['text':' batch with ops[4]','line_number':842,'multiline':False]['text':' Test multiple unordered ops that target two different shards.','line_number':855,'multiline':False]['text':' ops[0] -> shardA','line_number':875,'multiline':False]['text':' ops[1] -> shardB','line_number':876,'multiline':False]['text':' ops[2] -> shardA','line_number':877,'multiline':False]['text':' ops[3] -> shardB','line_number':878,'multiline':False]['text':' ops[4] -> shardA','line_number':879,'multiline':False]['text':' The two resulting batches should be:','line_number':893,'multiline':False]['text':' {shardA: [ops[0], ops[2], ops[4]]}','line_number':894,'multiline':False]['text':' {shardB: [ops[1], ops[3]]}','line_number':895,'multiline':False]['text':' Test multiple unordered ops where one of them result in a target error.','line_number':921,'multiline':False]['text':' Initialize the targeter so that x >= 0 values are untargetable so target call will encounter','line_number':935,'multiline':False]['text':' an error.','line_number':936,'multiline':False]['text':' Only the second op would get a target error.','line_number':940,'multiline':False]['text':' In the unordered case, both the first and the third ops should be targeted successfully','line_number':952,'multiline':False]['text':' despite targeting error on the second op.','line_number':953,'multiline':False]['text':' Tests targeting retryable timeseries update op.','line_number':964,'multiline':False]['text':' Set up targeters for both the bucket collection and the non-timeseries collection.','line_number':981,'multiline':False]['text':' Set up the opCtx for retryable writes.','line_number':997,'multiline':False]['text':' The first two retryable updates on nonTsNs should be batched together.','line_number':1005,'multiline':False]['text':' Each of the retryable timeseries updates should be in its own batch.','line_number':1018,'multiline':False]['text':' Tests that a targeted write batch to be sent to a shard is correctly converted to a','line_number':1042,'multiline':False]['text':' bulk command request.','line_number':1043,'multiline':False]['text':' Two different endpoints targeting the same shard for the two namespaces.','line_number':1049,'multiline':False]['text':' to nss 0','line_number':1064,'multiline':False]['text':' to nss 1','line_number':1065,'multiline':False]['text':' to nss 0','line_number':1066,'multiline':False]['text':' to nss 0','line_number':1067,'multiline':False]['text':' Randomly set ordered and bypass document validation.','line_number':1072,'multiline':False]['text':'allowShardKeyUpdatesWithoutFullShardKeyInQuery=','line_number':1089,'multiline':True]['text':' Tests that stmtIds are correctly attached to bulkWrite requests when the operations','line_number':1110,'multiline':False]['text':' are ordered.','line_number':1111,'multiline':False]['text':' Because the operations are ordered, the bulkWrite operations is broken up by shard','line_number':1125,'multiline':False]['text':' endpoint. In other words, targeting this request will result in two batches:','line_number':1126,'multiline':False]['text':' 1) to shard A, and then 2) another to shard B after the first batch is complete.','line_number':1127,'multiline':False]['text':' stmtId 0, shard A','line_number':1128,'multiline':False]['text':' stmtId 1, shard A','line_number':1129,'multiline':False]['text':' stmtId 2, shard B','line_number':1130,'multiline':False]['text':' stmtId 3, shard B','line_number':1131,'multiline':False]['text':' Setting the txnNumber makes it a retryable write.','line_number':1135,'multiline':False]['text':'allowShardKeyUpdatesWithoutFullShardKeyInQuery=','line_number':1145,'multiline':True]['text':' Target again to get a batch for the operations to shard B.','line_number':1151,'multiline':False]['text':'allowShardKeyUpdatesWithoutFullShardKeyInQuery=','line_number':1157,'multiline':True]['text':' Tests that stmtIds are correctly attached to bulkWrite requests when the operations','line_number':1164,'multiline':False]['text':' are unordered.','line_number':1165,'multiline':False]['text':' Since the ops aren't ordered, two batches are produced on a single targeting call:','line_number':1179,'multiline':False]['text':' 1) the ops to shard A (op 0 and op 2) are a batch and 2) the ops to shard B (op 1','line_number':1180,'multiline':False]['text':' and op 3) are a batch. Therefore the stmtIds in the bulkWrite request sent to the shards','line_number':1181,'multiline':False]['text':' will be interleaving.','line_number':1182,'multiline':False]['text':' stmtId 0, shard A','line_number':1183,'multiline':False]['text':' stmtId 1, shard B','line_number':1184,'multiline':False]['text':' stmtId 2, shard A','line_number':1185,'multiline':False]['text':' stmtId 3, shard B','line_number':1186,'multiline':False]['text':' Setting the txnNumber makes it a retryable write.','line_number':1190,'multiline':False]['text':' The batch to shard A contains op 0 and op 2.','line_number':1198,'multiline':False]['text':'allowShardKeyUpdatesWithoutFullShardKeyInQuery=','line_number':1201,'multiline':True]['text':' The batch to shard B contains op 1 and op 3.','line_number':1207,'multiline':False]['text':'allowShardKeyUpdatesWithoutFullShardKeyInQuery=','line_number':1210,'multiline':True]['text':' Tests that stmtIds are correctly attached to bulkWrite requests when the operations','line_number':1217,'multiline':False]['text':' are unordered and stmtIds are attached to the request already.','line_number':1218,'multiline':False]['text':' Since the ops aren't ordered, two batches are produced on a single targeting call:','line_number':1232,'multiline':False]['text':' 1) the ops to shard A (op 0 and op 2) are a batch and 2) the ops to shard B (op 1','line_number':1233,'multiline':False]['text':' and op 3) are a batch. Therefore the stmtIds in the bulkWrite request sent to the shards','line_number':1234,'multiline':False]['text':' will be interleaving.','line_number':1235,'multiline':False]['text':' stmtId 6, shard A','line_number':1236,'multiline':False]['text':' stmtId 7, shard B','line_number':1237,'multiline':False]['text':' stmtId 8, shard A','line_number':1238,'multiline':False]['text':' stmtId 9, shard B','line_number':1239,'multiline':False]['text':' Setting the txnNumber makes it a retryable write.','line_number':1244,'multiline':False]['text':' The batch to shard A contains op 0 and op 2.','line_number':1252,'multiline':False]['text':'allowShardKeyUpdatesWithoutFullShardKeyInQuery=','line_number':1255,'multiline':True]['text':' The batch to shard B contains op 1 and op 3.','line_number':1261,'multiline':False]['text':'allowShardKeyUpdatesWithoutFullShardKeyInQuery=','line_number':1264,'multiline':True]['text':' Tests that stmtIds are correctly attached to bulkWrite requests when the operations','line_number':1271,'multiline':False]['text':' are unordered and the stmtId field exists.','line_number':1272,'multiline':False]['text':' Since the ops aren't ordered, two batches are produced on a single targeting call:','line_number':1286,'multiline':False]['text':' 1) the ops to shard A (op 0 and op 2) are a batch and 2) the ops to shard B (op 1','line_number':1287,'multiline':False]['text':' and op 3) are a batch. Therefore the stmtIds in the bulkWrite request sent to the shards','line_number':1288,'multiline':False]['text':' will be interleaving.','line_number':1289,'multiline':False]['text':' stmtId 6, shard A','line_number':1290,'multiline':False]['text':' stmtId 7, shard B','line_number':1291,'multiline':False]['text':' stmtId 8, shard A','line_number':1292,'multiline':False]['text':' stmtId 9, shard B','line_number':1293,'multiline':False]['text':' Produces stmtIds 6, 7, 8, 9','line_number':1296,'multiline':False]['text':' Setting the txnNumber makes it a retryable write.','line_number':1298,'multiline':False]['text':' The batch to shard A contains op 0 and op 2.','line_number':1306,'multiline':False]['text':'allowShardKeyUpdatesWithoutFullShardKeyInQuery=','line_number':1309,'multiline':True]['text':' The batch to shard B contains op 1 and op 3.','line_number':1315,'multiline':False]['text':'allowShardKeyUpdatesWithoutFullShardKeyInQuery=','line_number':1318,'multiline':True]['text':' Test building a child bulkWrite request to send to shards involving timeseries collections.','line_number':1325,'multiline':False]['text':' Set up targeter for the bucket collection.','line_number':1335,'multiline':False]['text':'allowShardKeyUpdatesWithoutFullShardKeyInQuery=','line_number':1350,'multiline':True]['text':' Test that we translate to bucket namespace and set the isTimeseriesNamespace flag.','line_number':1352,'multiline':False]['text':' Test BatchItemRef.getLet().','line_number':1359,'multiline':False]['text':' The content of the request (updateOp and Let) do not matter here,','line_number':1363,'multiline':False]['text':' only that BatchItemRef.getLet() matches BulkWriteCommandRequest.setLet().','line_number':1364,'multiline':False]['text':' shard A','line_number':1390,'multiline':False]['text':' shard A','line_number':1391,'multiline':False]['text':' shard B','line_number':1392,'multiline':False]['text':' Test BulkWriteOp::noteChildBatchResponse with retriedStmtIds.','line_number':1403,'multiline':False]['text':' Test BulkWriteOp::noteWriteOpFinalResponse with retriedStmtIds.','line_number':1414,'multiline':False]['text':' Test a local CallbackCanceled error received during shutdown.','line_number':1456,'multiline':False]['text':' This isn't truly a death test but is written as one in order to isolate test execution in its','line_number':1457,'multiline':False]['text':' own process. This is needed because otherwise calling shutdownNoTerminate() would lead any','line_number':1458,'multiline':False]['text':' future tests run in the same process to also have the shutdown flag set.','line_number':1459,'multiline':False]['text':' We have to set the shutdown flag in order for a CallbackCanceled error to be treated as a','line_number':1468,'multiline':False]['text':' shutdown error.','line_number':1469,'multiline':False]['text':' Since we saw an execution-aborting error, the command should be considered finished.','line_number':1480,'multiline':False]['text':' Trigger abnormal exit to satisfy the DEATH_TEST checks.','line_number':1483,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':1489,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that is','line_number':1492,'multiline':False]['text':' how we set _inTransaction for a BulkWriteOp.','line_number':1493,'multiline':False]['text':' Since we are in a txn and we saw an error, the command should be considered finished.','line_number':1510,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':1515,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that is','line_number':1518,'multiline':False]['text':' how we set _inTransaction for a BulkWriteOp.','line_number':1519,'multiline':False]['text':' Since we are in a txn and we saw an error, the command should be considered finished.','line_number':1533,'multiline':False]['text':' BatchItemRef can only be created from an underlying request, but the only field we care','line_number':1587,'multiline':False]['text':' about on the request is the ops. The other fields are necessary to satisfy invariants.','line_number':1588,'multiline':False]['text':' Test that we calculate accurate estimates for bulkWrite insert ops.','line_number':1600,'multiline':False]['text':' Test that we calculate accurate estimates for bulkWrite update ops.','line_number':1609,'multiline':False]['text':' TODO (SERVER-82382): Replace ASSERT_GTE with ASSERT_EQ for the following test.','line_number':1610,'multiline':False]['text':' filter ','line_number':1612,'multiline':True]['text':' upsertSupplied ','line_number':1614,'multiline':True]['text':' hint ','line_number':1615,'multiline':True]['text':' filter ','line_number':1622,'multiline':True]['text':' upsertSupplied ','line_number':1624,'multiline':True]['text':' hint ','line_number':1625,'multiline':True]['text':' constants ','line_number':1627,'multiline':True]['text':' collation ','line_number':1628,'multiline':True]['text':' filter ','line_number':1634,'multiline':True]['text':' upsertSupplied ','line_number':1636,'multiline':True]['text':' hint ','line_number':1637,'multiline':True]['text':' constants ','line_number':1639,'multiline':True]['text':' collation ','line_number':1640,'multiline':True]['text':' We can't make an exact assertion when arrayFilters is set, because the way we estimate BSON','line_number':1641,'multiline':False]['text':' array index size overcounts for simplicity.','line_number':1642,'multiline':False]['text':' filter ','line_number':1646,'multiline':True]['text':' upsertSupplied ','line_number':1648,'multiline':True]['text':' hint ','line_number':1649,'multiline':True]['text':' We can't make an exact assertion when an update pipeline is used, because the way we estimate','line_number':1653,'multiline':False]['text':' BSON array index size overcounts for simplicity.','line_number':1654,'multiline':False]['text':' Test that we calculate accurate estimates for bulkWrite delete ops.','line_number':1658,'multiline':False]['text':' TODO (SERVER-82382): Replace ASSERT_GTE with ASSERT_EQ for the following test.','line_number':1659,'multiline':False]['text':' hint ','line_number':1661,'multiline':True]['text':' filter ','line_number':1664,'multiline':True]['text':' hint ','line_number':1665,'multiline':True]['text':' collation ','line_number':1666,'multiline':True]['text':' Simulates a situation where we receive a bulkWrite request with large top-level fields (in this','line_number':1670,'multiline':False]['text':' case, 'let') that is very close to MaxBSONObjInternalSize. Confirms that we factor in top-','line_number':1671,'multiline':False]['text':' level fields when deciding when to split batches.','line_number':1672,'multiline':False]['text':' Two different endpoints targeting the same shard for the two namespaces.','line_number':1677,'multiline':False]['text':' Create a ~15 MB let.','line_number':1692,'multiline':False]['text':' Create a ~.1 MB document to insert.','line_number':1696,'multiline':False]['text':' Ensure we've built a request that's actual serialized size is slightly bigger than','line_number':1709,'multiline':False]['text':' BSONObjMaxUserSize,  which is the threshold we use to split batches. This should guarantee','line_number':1710,'multiline':False]['text':' that the estimated size we calculate for a sub-batch containing all of these writes','line_number':1711,'multiline':False]['text':' would also be bigger than BSONMaxUserObjSize and that we will split into multiple batches.','line_number':1712,'multiline':False]['text':' We shouldn't have targeted all of the writes yet.','line_number':1720,'multiline':False]['text':' We should have been able to target all the remaining writes in a second batch.','line_number':1728,'multiline':False]['text':' A trivial empty bulkWrite request with a namespace.','line_number':1738,'multiline':False]['text':' Get a base size estimate.','line_number':1744,'multiline':False]['text':' When mongos actually sends out child batches to the shards, it may attach shardVersion,','line_number':1747,'multiline':False]['text':' databaseVersion, timeseries bucket namespace and the `isTimeseriesCollection` field to','line_number':1748,'multiline':False]['text':' namespace entries. And it may also attach generic fields like lsid, txnNumber and','line_number':1749,'multiline':False]['text':' writeConcern.','line_number':1750,'multiline':False]['text':' Add writeConcern and lsid/txnNumber if applicable.','line_number':1762,'multiline':False]['text':' Test that our initial base estimate is conservative enough to account for the above fields.','line_number':1767,'multiline':False]['text':' Used to test cases where we get an error for an entire batch (as opposed to errors for one or','line_number':1771,'multiline':False]['text':' more individual writes within the batch.)','line_number':1772,'multiline':False]['text':' Set up state such that targeting for an ordered bulkWrite would take two rounds:','line_number':1795,'multiline':False]['text':' - First round: a child batch targeting shard1 with the writes to nss1','line_number':1796,'multiline':False]['text':' - Second round: a child batch targeting shard2 with the writes to nss2','line_number':1797,'multiline':False]['text':' And so that targeting for an unordered bulkWrite would take one round:','line_number':1798,'multiline':False]['text':' - 2 child batches, one targeting shard1 with the writes to nss1 and one targeting shard2 with','line_number':1799,'multiline':False]['text':' the writes to nss2.','line_number':1800,'multiline':False]['text':' Various mock error responses used for testing.','line_number':1812,'multiline':False]['text':' We use a custom non-transient error code to confirm that we do not try to determine if an','line_number':1839,'multiline':False]['text':' error is transient based on the code and that we instead defer to whether or not a shard','line_number':1840,'multiline':False]['text':' attached the label.','line_number':1841,'multiline':False]['text':' These assertions are redundant to re-run on every test execution but are here to','line_number':1860,'multiline':False]['text':' illustrate the expected state after targeting.','line_number':1861,'multiline':False]['text':' We should have targeted only the first 2 writes.','line_number':1865,'multiline':False]['text':' We should have targeted all the writes.','line_number':1874,'multiline':False]['text':' Test a local shutdown error (i.e. because mongos is shutting down.)','line_number':1885,'multiline':False]['text':' Simulate a shutdown error.','line_number':1890,'multiline':False]['text':' In practice, we expect the thrown error to propagate up past the scope where the op is','line_number':1899,'multiline':False]['text':' created. But to be thorough the assertions below check that our bookkeeping when','line_number':1900,'multiline':False]['text':' encountering this error is correct.','line_number':1901,'multiline':False]['text':' For ordered writes, we will treat the batch error as a failure of the first write in the','line_number':1903,'multiline':False]['text':' batch. The other write in the batch should have been re-set to ready.','line_number':1904,'multiline':False]['text':' Since we saw an execution-aborting error, the command should be considered finished.','line_number':1909,'multiline':False]['text':' Test a local CallbackCanceled error that is received when not in shutdown.','line_number':1913,'multiline':False]['text':' We have to set the shutdown flag in order for a CallbackCanceled error to be treated as a','line_number':1918,'multiline':False]['text':' shutdown error. Since we have not set the flag this should be treated like any other','line_number':1919,'multiline':False]['text':' local error.','line_number':1920,'multiline':False]['text':' For ordered writes, we will treat the batch error as a failure of the first write in the','line_number':1923,'multiline':False]['text':' batch. The other write in the batch should have been re-set to ready.','line_number':1924,'multiline':False]['text':' Since we are ordered and we saw an error, the command should be considered finished.','line_number':1929,'multiline':False]['text':' The error for the first op should be the cancellation error.','line_number':1932,'multiline':False]['text':' Test a local CallbackCanceled error received during shutdown.','line_number':1941,'multiline':False]['text':' This isn't truly a death test but is written as one in order to isolate test execution in its','line_number':1942,'multiline':False]['text':' own process. This is needed because otherwise calling shutdownNoTerminate() would lead any','line_number':1943,'multiline':False]['text':' future tests run in the same process to also have the shutdown flag set.','line_number':1944,'multiline':False]['text':' We have to set the shutdown flag in order for a CallbackCanceled error to be treated as a','line_number':1949,'multiline':False]['text':' shutdown error.','line_number':1950,'multiline':False]['text':' We expect the error to be raised as a top-level error.','line_number':1953,'multiline':False]['text':' In practice, we expect the thrown error to propagate up past the scope where the op is','line_number':1959,'multiline':False]['text':' created. But to be thorough the assertions below check that our bookkeeping when','line_number':1960,'multiline':False]['text':' encountering this error is correct.','line_number':1961,'multiline':False]['text':' For ordered writes, we will treat the batch error as a failure of the first write in the','line_number':1963,'multiline':False]['text':' batch.','line_number':1964,'multiline':False]['text':' We should have reset the second op from the batch to ready.','line_number':1966,'multiline':False]['text':' These were never targeted and so are still ready.','line_number':1968,'multiline':False]['text':' Since we saw an execution-aborting error, the command should be considered finished.','line_number':1972,'multiline':False]['text':' Trigger abnormal exit to satisfy the DEATH_TEST checks.','line_number':1975,'multiline':False]['text':' Ordered bulkWrite: test handling of a local network error.','line_number':1979,'multiline':False]['text':' Simulate a network error.','line_number':1984,'multiline':False]['text':' For ordered writes, we will treat the batch error as a failure of the first write in the','line_number':1987,'multiline':False]['text':' batch. The other write in the batch should have been re-set to ready.','line_number':1988,'multiline':False]['text':' We never targeted these so they should still be ready.','line_number':1991,'multiline':False]['text':' Since we are ordered and we saw an error, the command should be considered finished.','line_number':1995,'multiline':False]['text':' The error for the first op should be the network error.','line_number':1998,'multiline':False]['text':' Unordered bulkWrite: test handling of a local network error.','line_number':2007,'multiline':False]['text':' Simulate a network error.','line_number':2013,'multiline':False]['text':' For unordered writes, we will treat the batch error as a failure of all the writes in the','line_number':2016,'multiline':False]['text':' batch.','line_number':2017,'multiline':False]['text':' These should still be pending.','line_number':2020,'multiline':False]['text':' Since we are unordered and have outstanding responses, we should not be finished.','line_number':2024,'multiline':False]['text':' Simulate successful response to the second batch.','line_number':2027,'multiline':False]['text':' We should now be finished.','line_number':2033,'multiline':False]['text':' The error for the first two ops should be the network error.','line_number':2036,'multiline':False]['text':' Ordered bulkWrite: Test handling of a local TransientTransactionError in a transaction.','line_number':2050,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':2052,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that is','line_number':2055,'multiline':False]['text':' how we set _inTransaction for a BulkWriteOp.','line_number':2056,'multiline':False]['text':' Simulate a network error (which is a transient transaction error.)','line_number':2062,'multiline':False]['text':' We expect the error to be raised as a top-level error.','line_number':2063,'multiline':False]['text':' In practice, we expect the thrown error to propagate up past the scope where the op is','line_number':2069,'multiline':False]['text':' created. But to be thorough the assertions below check that our bookkeeping when','line_number':2070,'multiline':False]['text':' encountering this error is correct.','line_number':2071,'multiline':False]['text':' For ordered writes, we will treat the batch error as a failure of the first write in the','line_number':2073,'multiline':False]['text':' batch. The other write in the batch should have been re-set to ready.','line_number':2074,'multiline':False]['text':' Since we are in a txn and we saw an error, the command should be considered finished.','line_number':2080,'multiline':False]['text':' Ordered bulkWrite: Test handling of a local non-TransientTransactionError in a transaction.','line_number':2084,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':2086,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that is','line_number':2089,'multiline':False]['text':' how we set _inTransaction for a BulkWriteOp.','line_number':2090,'multiline':False]['text':' Simulate an interruption error (which is not a TransientTransactionError.)','line_number':2096,'multiline':False]['text':' For ordered writes, we will treat the batch error as a failure of the first write in the','line_number':2099,'multiline':False]['text':' batch. The other write in the batch should have been re-set to ready.','line_number':2100,'multiline':False]['text':' Since we are both ordered and in a txn and we saw an error, the command should be','line_number':2105,'multiline':False]['text':' considered finished.','line_number':2106,'multiline':False]['text':' The error for the first op should be the interruption error.','line_number':2109,'multiline':False]['text':' Unordered bulkWrite: Test handling of a local TransientTransactionError in a transaction.','line_number':2118,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':2120,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that is','line_number':2123,'multiline':False]['text':' how we set _inTransaction for a BulkWriteOp.','line_number':2124,'multiline':False]['text':' Case 1: we receive the failed batch response with other batches outstanding.','line_number':2128,'multiline':False]['text':' Simulate a network error (which is a transient transaction error.)','line_number':2133,'multiline':False]['text':' We expect the error to be raised as a top-level error.','line_number':2134,'multiline':False]['text':' In practice, we expect the thrown error to propagate up past the scope where the op is','line_number':2140,'multiline':False]['text':' created. But to be thorough the assertions below check that our bookkeeping when','line_number':2141,'multiline':False]['text':' encountering this error is correct.','line_number':2142,'multiline':False]['text':' For unordered writes, we will treat the batch error as a failure of all of the writes','line_number':2144,'multiline':False]['text':' in the batch.','line_number':2145,'multiline':False]['text':' Since these were targeted but we didn't receive a response yet they should still be','line_number':2148,'multiline':False]['text':' Pending.','line_number':2149,'multiline':False]['text':' Since we saw an execution-aborting error, the command should be considered finished.','line_number':2153,'multiline':False]['text':' Case 2: we receive the failed batch response after receiving successful response for other','line_number':2157,'multiline':False]['text':' batch.','line_number':2158,'multiline':False]['text':' Simulate successful response to second batch.','line_number':2163,'multiline':False]['text':' Simulate a network error (which is a transient transaction error.)','line_number':2172,'multiline':False]['text':' We expect the error to be raised as a top-level error.','line_number':2173,'multiline':False]['text':' In practice, we expect the thrown error to propagate up past the scope where the op is','line_number':2179,'multiline':False]['text':' created. But to be thorough the assertions below check that our bookkeeping when','line_number':2180,'multiline':False]['text':' encountering this error is correct.','line_number':2181,'multiline':False]['text':' For unordered writes, we will treat the batch error as a failure of all of the writes','line_number':2183,'multiline':False]['text':' in the batch.','line_number':2184,'multiline':False]['text':' We already received successful responses for these writes.','line_number':2187,'multiline':False]['text':' The command should be considered finished.','line_number':2191,'multiline':False]['text':' Unordered bulkWrite: Test handling of a local non-TransientTransactionError in a transaction.','line_number':2196,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':2198,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that is','line_number':2201,'multiline':False]['text':' how we set _inTransaction for a BulkWriteOp.','line_number':2202,'multiline':False]['text':' Case 1: we receive the failed batch response with other batches outstanding.','line_number':2205,'multiline':False]['text':' Simulate an interruption error (which is not a TransientTransactionError.)','line_number':2211,'multiline':False]['text':' For unordered writes, we will treat the error as a failure of all the writes in the','line_number':2214,'multiline':False]['text':' batch.','line_number':2215,'multiline':False]['text':' We didn't receive responses for these yet.','line_number':2218,'multiline':False]['text':' However, since we are in a txn and we saw an execution-aborting error, the command should','line_number':2221,'multiline':False]['text':' be considered finished.','line_number':2222,'multiline':False]['text':' The error for the first two ops should be the interruption error.','line_number':2225,'multiline':False]['text':' Case 2: we receive the failed batch response after receiving successful response for other','line_number':2238,'multiline':False]['text':' batch.','line_number':2239,'multiline':False]['text':' Simulate successful response to second batch.','line_number':2244,'multiline':False]['text':' Simulate an interruption error (which is not a TransientTransactionError.)','line_number':2253,'multiline':False]['text':' For unordered writes, we will treat the error as a failure of all the writes in the','line_number':2256,'multiline':False]['text':' batch.','line_number':2257,'multiline':False]['text':' The command should be considered finished.','line_number':2262,'multiline':False]['text':' The error for the first two ops should be the interruption error.','line_number':2265,'multiline':False]['text':' Ordered bulkWrite: Test handling of a remote top-level error.','line_number':2281,'multiline':False]['text':' Simulate receiving an interrupted error from a shard.','line_number':2286,'multiline':False]['text':' For ordered writes, we will treat the batch error as a failure of the first write in the','line_number':2290,'multiline':False]['text':' batch. The other write in the batch should have been re-set to ready.','line_number':2291,'multiline':False]['text':' We never targeted these so they should still be ready.','line_number':2294,'multiline':False]['text':' Since we are ordered and we saw an error, the command should be considered finished.','line_number':2298,'multiline':False]['text':' The error for the first op should be the interrupted error.','line_number':2301,'multiline':False]['text':' Unordered bulkWrite: Test handling of a remote top-level error.','line_number':2310,'multiline':False]['text':' Simulate receiving an interrupted error from a shard.','line_number':2316,'multiline':False]['text':' For unordered writes, we will treat the batch error as a failure of all the writes in the','line_number':2320,'multiline':False]['text':' batch.','line_number':2321,'multiline':False]['text':' These should still be pending.','line_number':2324,'multiline':False]['text':' Since we are unordered and have outstanding responses, we should not be finished.','line_number':2328,'multiline':False]['text':' Simulate successful response to the second batch.','line_number':2331,'multiline':False]['text':' We should now be finished.','line_number':2337,'multiline':False]['text':' The error for the first two ops should be the interrupted error.','line_number':2340,'multiline':False]['text':' Ordered bulkWrite: Test handling of a remote top-level error that is not a','line_number':2354,'multiline':False]['text':' TransientTransactionError in a transaction.','line_number':2355,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':2357,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that is','line_number':2360,'multiline':False]['text':' how we set _inTransaction for a BulkWriteOp.','line_number':2361,'multiline':False]['text':' Simulate a remote interrupted error (which is not a transient txn error).','line_number':2367,'multiline':False]['text':' For ordered writes, we will treat the batch error as a failure of the first write in the','line_number':2371,'multiline':False]['text':' batch. The other write in the batch should have been re-set to ready.','line_number':2372,'multiline':False]['text':' Since we are both ordered and in a txn and we saw an error, the command should be','line_number':2377,'multiline':False]['text':' considered finished.','line_number':2378,'multiline':False]['text':' The error for the first op should be the interruption error.','line_number':2381,'multiline':False]['text':' Test handling of a WouldChangeOwningShard error in a transaction.','line_number':2390,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':2392,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that is','line_number':2395,'multiline':False]['text':' how we set _inTransaction for a BulkWriteOp.','line_number':2396,'multiline':False]['text':' Simulate a WouldChangeOwningShardError.','line_number':2426,'multiline':False]['text':' The command should be considered finished.','line_number':2430,'multiline':False]['text':' We should not have set the _aborted flag, unlike we would for other top-level errors,','line_number':2433,'multiline':False]['text':' since WouldChangeOwningShard errors do not abort their transactions.','line_number':2434,'multiline':False]['text':' The error for the first op should be the WCOS error.','line_number':2437,'multiline':False]['text':' Ordered bulkWrite: Test handling of a remote top-level error that is a TransientTransactionError','line_number':2446,'multiline':False]['text':' in a transaction.','line_number':2447,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':2449,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that is','line_number':2452,'multiline':False]['text':' how we set _inTransaction for a BulkWriteOp.','line_number':2453,'multiline':False]['text':' Simulate a custom remote error that has the TransientTransactionError label attached.','line_number':2459,'multiline':False]['text':' We expect the error to be raised as a top-level error.','line_number':2460,'multiline':False]['text':' In practice, we expect the thrown error to propagate up past the scope where the op is','line_number':2466,'multiline':False]['text':' created. But to be thorough the assertions below check that our bookkeeping when','line_number':2467,'multiline':False]['text':' encountering this error is correct.','line_number':2468,'multiline':False]['text':' For ordered writes, we will treat the batch error as a failure of the first write in the','line_number':2470,'multiline':False]['text':' batch. The other write in the batch should have been re-set to ready.','line_number':2471,'multiline':False]['text':' Since we are in a txn and we saw an error, the command should be considered finished.','line_number':2477,'multiline':False]['text':' Unordered bulkWrite: Test handling of a remote top-level error that is not a','line_number':2481,'multiline':False]['text':' TransientTransactionError in a transaction.','line_number':2482,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':2484,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that is','line_number':2487,'multiline':False]['text':' how we set _inTransaction for a BulkWriteOp.','line_number':2488,'multiline':False]['text':' Case 1: we receive the failed batch response with other batches outstanding.','line_number':2491,'multiline':False]['text':' Simulate a remote interrupted error (which is not a transient txn error).','line_number':2497,'multiline':False]['text':' For unordered writes, we will treat the error as a failure of all the writes in the','line_number':2501,'multiline':False]['text':' batch.','line_number':2502,'multiline':False]['text':' We didn't receive responses for these yet.','line_number':2505,'multiline':False]['text':' However, since we are in a txn and we saw an execution-aborting error, the command should','line_number':2508,'multiline':False]['text':' be considered finished.','line_number':2509,'multiline':False]['text':' The error for the first two ops should be the interruption error.','line_number':2512,'multiline':False]['text':' Case 2: we receive the failed batch response after receiving successful response for other','line_number':2525,'multiline':False]['text':' batch.','line_number':2526,'multiline':False]['text':' Simulate successful response to second batch.','line_number':2531,'multiline':False]['text':' Simulate a remote interrupted error (which is not a transient txn error).','line_number':2540,'multiline':False]['text':' For unordered writes, we will treat the error as a failure of all the writes in the','line_number':2544,'multiline':False]['text':' batch.','line_number':2545,'multiline':False]['text':' The command should be considered finished.','line_number':2550,'multiline':False]['text':' The error for the first two ops should be the interruption error.','line_number':2553,'multiline':False]['text':' Unordered bulkWrite: Test handling of a remote top-level error that is a','line_number':2569,'multiline':False]['text':' TransientTransactionError in a transaction.','line_number':2570,'multiline':False]['text':' Set up lsid/txnNumber to simulate txn.','line_number':2572,'multiline':False]['text':' Necessary for TransactionRouter::get to be non-null for this opCtx. The presence of that is','line_number':2575,'multiline':False]['text':' how we set _inTransaction for a BulkWriteOp.','line_number':2576,'multiline':False]['text':' Case 1: we receive the failed batch response with other batches outstanding.','line_number':2580,'multiline':False]['text':' Simulate a custom remote error that has the TransientTransactionError label attached.','line_number':2585,'multiline':False]['text':' We expect the error to be raised as a top-level error.','line_number':2586,'multiline':False]['text':' In practice, we expect the thrown error to propagate up past the scope where the op is','line_number':2593,'multiline':False]['text':' created. But to be thorough the assertions below check that our bookkeeping when','line_number':2594,'multiline':False]['text':' encountering this error is correct.','line_number':2595,'multiline':False]['text':' For unordered writes, we will treat the batch error as a failure of all of the writes','line_number':2597,'multiline':False]['text':' in the batch.','line_number':2598,'multiline':False]['text':' Since these were targeted but we didn't receive a response yet they should still be','line_number':2601,'multiline':False]['text':' Pending.','line_number':2602,'multiline':False]['text':' Since we saw an execution-aborting error, the command should be considered finished.','line_number':2606,'multiline':False]['text':' Case 2: we receive the failed batch response after receiving successful response for other','line_number':2610,'multiline':False]['text':' batch.','line_number':2611,'multiline':False]['text':' Simulate successful response to second batch.','line_number':2616,'multiline':False]['text':' Simulate a custom remote error that has the TransientTransactionError label attached.','line_number':2625,'multiline':False]['text':' We expect the error to be raised as a top-level error.','line_number':2626,'multiline':False]['text':' In practice, we expect the thrown error to propagate up past the scope where the op is','line_number':2633,'multiline':False]['text':' created. But to be thorough the assertions below check that our bookkeeping when','line_number':2634,'multiline':False]['text':' encountering this error is correct.','line_number':2635,'multiline':False]['text':' For unordered writes, we will treat the batch error as a failure of all of the writes','line_number':2637,'multiline':False]['text':' in the batch.','line_number':2638,'multiline':False]['text':' We already received successful responses for these writes.','line_number':2641,'multiline':False]['text':' The command should be considered finished.','line_number':2645,'multiline':False]['text':' Test that if we receive a mix of success/failure from shards and have to partially retarget that','line_number':2650,'multiline':False]['text':' the success result(s) from the first round of targeting are factored into the op's final reply.','line_number':2651,'multiline':False]['text':' Set up an op that will target both shards.','line_number':2653,'multiline':False]['text':' We should initially target writes to be sent in parallel to both shards.','line_number':2673,'multiline':False]['text':' Simulate OK response from first shard.','line_number':2679,'multiline':False]['text':' The write should still be pending.','line_number':2684,'multiline':False]['text':' Simulate StaleConfig from second shard.','line_number':2687,'multiline':False]['text':' We should have marked the write as ready so we can retarget as needed.','line_number':2696,'multiline':False]['text':' Clear targeting map for a new round of targeting.','line_number':2699,'multiline':False]['text':' We should have retargeted only the write to shardB, since we already succeeded on sharda','line_number':2702,'multiline':False]['text':' Simulate OK response from second shard.','line_number':2708,'multiline':False]['text':' We should now be done.','line_number':2713,'multiline':False]['text':' Seeing n: 2 here proves we saved the success reply from the first round of targeting.','line_number':2720,'multiline':False]['text':' Confirm the outcome of the targeting.','line_number':2740,'multiline':False]['text':' Simulate a ShardCannotRefreshDueToLocksHeld error from the shard.','line_number':2745,'multiline':False]['text':' We should have marked the write as ready so we can retarget as needed.','line_number':2750,'multiline':False]['text':' Clear targeting map for a new round of targeting; shardId should be still involved, and the','line_number':2753,'multiline':False]['text':' op state still pending.','line_number':2754,'multiline':False]['text':' Simulate OK response from the shard.','line_number':2762,'multiline':False]['text':' We should now be done.','line_number':2767,'multiline':False]['text':' Confirm the outcome of the targeting.','line_number':2801,'multiline':False]['text':' Simulate OK response from first shard.','line_number':2809,'multiline':False]['text':' Ensure that the write state is consistent.','line_number':2814,'multiline':False]['text':' Simulate a ShardCannotRefreshDueToLocksHeld error from the second shard.','line_number':2819,'multiline':False]['text':' We should have marked the remaining writes as ready so we can retarget as needed.','line_number':2825,'multiline':False]['text':' Clear targeting map for a new round of targeting.','line_number':2830,'multiline':False]['text':' We should have retargeted only the writes to shardB, since we already succeeded on shardA','line_number':2833,'multiline':False]['text':' // Simulate OK response from second shard.','line_number':2840,'multiline':False]['text':' We should now be done.','line_number':2847,'multiline':False]['text':' Test that we combine summary field values across multiple child batch responses.','line_number':2861,'multiline':False]['text':' nInserted=1 ','line_number':2876,'multiline':True]['text':' nMatched=1, nModified=1 ','line_number':2878,'multiline':True]['text':' nUpserted=1, nMatched=0 ','line_number':2883,'multiline':True]['text':' nDeleted=1 ','line_number':2884,'multiline':True]['text':' Test that noteWriteOpFinalResponse correctly updates summary fields.','line_number':2945,'multiline':False]['text':' nInserted=1 ','line_number':2964,'multiline':True]['text':' nDeleted=1 ','line_number':2968,'multiline':True]['text':' nMatched=1 ','line_number':2972,'multiline':True]['text':' nModified=1 ','line_number':2973,'multiline':True]['text':' nUpserted=1 ','line_number':2977,'multiline':True]['text':' Test that processFLEResponse correctly calculates summary fields.','line_number':2991,'multiline':False]['text':' nInserted=2 ','line_number':2998,'multiline':True]['text':' nInserted=1 ','line_number':3009,'multiline':True]['text':' nErrors=1 ','line_number':3011,'multiline':True]['text':' nDeleted=1 ','line_number':3022,'multiline':True]['text':' nErrors=1 ','line_number':3034,'multiline':True]['text':' nMatched=1 ','line_number':3045,'multiline':True]['text':' nModified=1 ','line_number':3046,'multiline':True]['text':' Reuse the single error reply from delete above.','line_number':3055,'multiline':False]['text':' This field should be ignored for upserts since we don't count upserts under nUpdated.','line_number':3066,'multiline':False]['text':' nUpserted=1 ','line_number':3071,'multiline':True]['text':'*
 * Mimics a sharding backend to test BulkWriteExec.
 ','line_number':3081,'multiline':True]['text':' Initialize the targeter so that x >= 0 values are untargetable so target call will encounter','line_number':3135,'multiline':False]['text':' an error.','line_number':3136,'multiline':False]['text':' Only the first op would get a target error.','line_number':3143,'multiline':False]['text':' Test unordered operations. Since only the first op is untargetable, the second op will','line_number':3150,'multiline':False]['text':' succeed without errors. But bulk_write_exec::execute would retry on targeting errors and','line_number':3151,'multiline':False]['text':' try to refresh the targeters upon targeting errors.','line_number':3152,'multiline':False]['text':' Mock a bulkWrite response to respond to the second op, which is valid.','line_number':3164,'multiline':False]['text':' This time there is no need to mock a response because when the first op's targeting fails,','line_number':3172,'multiline':False]['text':' the entire operation is halted and so nothing is sent to the shards.','line_number':3173,'multiline':False]['text':' Test ordered operations. This is mostly the same as the test case above except that we','line_number':3175,'multiline':False]['text':' should only return the first error for ordered operations.','line_number':3176,'multiline':False]['text':' We should have another refresh attempt.','line_number':3182,'multiline':False]['text':' Mock targeter that throws StaleEpoch on refresh to mimic the collection being dropped.','line_number':3196,'multiline':False]['text':' Initialize the targeter so that x >= 0 values are untargetable so target call will encounter','line_number':3208,'multiline':False]['text':' an error.','line_number':3209,'multiline':False]['text':' The first op would get a target error.','line_number':3213,'multiline':False]['text':' After the targeting error from the first op, targeter refresh will throw a StaleEpoch','line_number':3219,'multiline':False]['text':' exception which should abort the entire bulkWrite.','line_number':3220,'multiline':False]['text':' Tests that WriteConcernErrors are surfaced back to the user correctly,','line_number':3229,'multiline':False]['text':' even when the operation is a no-op (due to an error like BadValue).','line_number':3230,'multiline':False]['text':' withWriteConcernError ','line_number':3253,'multiline':True]['text':' Even when the operation is a no-op due to an error (BadValue), any WCE that','line_number':3258,'multiline':False]['text':' occurs should be returned to the user.','line_number':3259,'multiline':False]['text':' withWriteConcernError ','line_number':3271,'multiline':True]['text':' cursorId','line_number':3273,'multiline':False]['text':' Tests that WriteConcernErrors from multiple shards are merged correctly. Also tests','line_number':3283,'multiline':False]['text':' that WriteConcernErrors do not halt progress in ordered operations.','line_number':3284,'multiline':False]['text':' Writes to nss0 go to endpoint0 (shardA) and writes to nss1 go to endpoint1 (shardB).','line_number':3294,'multiline':False]['text':' Both operations executed, therefore the size of reply items is 2.','line_number':3307,'multiline':False]['text':' ShardA response.','line_number':3316,'multiline':False]['text':' withWriteConcernError ','line_number':3318,'multiline':True]['text':' Shard B response.','line_number':3322,'multiline':False]['text':' withWriteConcernError ','line_number':3324,'multiline':True]['text':' In the unordered case it isn't clear which of these is triggered for which shard request, but','line_number':3346,'multiline':False]['text':' since the two are the same, it doesn't matter in this case.','line_number':3347,'multiline':False]['text':' withWriteConcernError ','line_number':3349,'multiline':True]['text':' withWriteConcernError ','line_number':3353,'multiline':True]['text':' We don't really know which of the two mock responses below will be used for','line_number':3368,'multiline':False]['text':' which operation, since this is an unordered request, so we can't assert on','line_number':3369,'multiline':False]['text':' the exact status of each operation. However we can still assert on the number','line_number':3370,'multiline':False]['text':' of errors.','line_number':3371,'multiline':False]['text':' In the unordered case it isn't clear which of these is triggered for which shard request, but','line_number':3377,'multiline':False]['text':' since the two are the same, it doesn't matter in this case.','line_number':3378,'multiline':False]['text':' withWriteConcernError ','line_number':3380,'multiline':True]['text':' cursorId','line_number':3382,'multiline':False]['text':' TODO(SERVER-72790): Test refreshing targeters on stale config errors, including the case where','line_number':3422,'multiline':False]['text':' NoProgressMade is returned if stale config retry doesn't make any progress after','line_number':3423,'multiline':False]['text':' kMaxRoundsWithoutProgress.','line_number':3424,'multiline':False]['text':' namespace','line_number':3426,'multiline':False]['text':' namespace mongo','line_number':3428,'multiline':False]