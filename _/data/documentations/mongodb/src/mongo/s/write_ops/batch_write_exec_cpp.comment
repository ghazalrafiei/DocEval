['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' Helper to note several stale shard errors from a response','line_number':95,'multiline':False]['text':' Helper to note several stale db errors from a response','line_number':112,'multiline':False]['text':' The number of times we'll try to continue a batch op if no progress is being made. This only','line_number':154,'multiline':False]['text':' applies when no writes are occurring and metadata is not changing on reload.','line_number':155,'multiline':False]['text':' Helper to parse all of the childBatches and construct the proper requests to send using the','line_number':158,'multiline':False]['text':' AsyncRequestSender.','line_number':159,'multiline':False]['text':' Get as many batches as we can at once','line_number':169,'multiline':False]['text':' If the batch is nullptr, we sent it previously, so skip','line_number':173,'multiline':False]['text':' If we already have a batch for this shard, wait until the next time','line_number':177,'multiline':False]['text':' Indicate we're done by setting the batch to nullptr. We'll only get duplicate','line_number':203,'multiline':False]['text':' hostEndpoints if we have broadcast and non-broadcast endpoints for the same host,','line_number':204,'multiline':False]['text':' so this should be pretty efficient without moving stuff around.','line_number':205,'multiline':False]['text':' Recv-side is responsible for cleaning up the nextBatch when used','line_number':208,'multiline':False]['text':' If the network response is OK then we process the response from the resmote shard. The returned','line_number':214,'multiline':False]['text':' boolean dictates if we should abort rest of the batch.','line_number':215,'multiline':False]['text':' Stale routing info errors need to be tracked in order to trigger a refresh of the targeter.','line_number':223,'multiline':False]['text':' On the other hand, errors caused by the catalog cache being temporarily unavailable (such as','line_number':224,'multiline':False]['text':' ShardCannotRefreshDueToLocksHeld) are ignored in this context, since no deduction can be made','line_number':225,'multiline':False]['text':' around possible placement changes.','line_number':226,'multiline':False]['text':' Dispatch was ok, note response','line_number':239,'multiline':False]['text':' If we are in a transaction, we must fail the whole batch on any error.','line_number':242,'multiline':False]['text':' Note: this returns a bad status if any part of the batch failed.','line_number':244,'multiline':False]['text':' Throw when there is a transient transaction error since this','line_number':250,'multiline':False]['text':' should be a top level error and not just a write error.','line_number':251,'multiline':False]['text':' Note if anything was stale','line_number':260,'multiline':False]['text':' If the local process experiences an error trying to get the response from remote, process the','line_number':292,'multiline':False]['text':' error. The returned boolean dictates if we should abort the rest of the batch.','line_number':293,'multiline':False]['text':' Throw an error since the mongos itself is shutting down so this should','line_number':303,'multiline':False]['text':' be a top level error instead of a write error.','line_number':304,'multiline':False]['text':' Error occurred dispatching, note it','line_number':308,'multiline':False]['text':' If we are in a transaction, we must stop immediately (even for unordered).','line_number':323,'multiline':False]['text':' Throw when there is a transient transaction error since this should be a','line_number':325,'multiline':False]['text':' top level error and not just a write error.','line_number':326,'multiline':False]['text':' Iterates through all of the child batches and sends and processes each batch.','line_number':337,'multiline':False]['text':' Collect batches out on the network, mapped by endpoint','line_number':350,'multiline':False]['text':' Send the requests.','line_number':363,'multiline':False]['text':' Receive all of the responses.','line_number':373,'multiline':False]['text':' Block until a response is available.','line_number':375,'multiline':False]['text':' Get the TargetedWriteBatch to find where to put the response','line_number':378,'multiline':False]['text':' Then check if we successfully got a response.','line_number':385,'multiline':False]['text':' Remember that we successfully wrote to this shard','line_number':408,'multiline':False]['text':' NOTE: This will record lastOps for shards where we actually didn't update','line_number':409,'multiline':False]['text':' or delete any documents, which preserves old behavior but is conservative','line_number':410,'multiline':False]['text':' The ARS failed to retrieve the response due to some sort of local failure.','line_number':420,'multiline':False]['text':' Only processes one write response from the child batches. Currently this is used for the two','line_number':434,'multiline':False]['text':' phase protocol of the singleton writes without shard key and time-series retryable updates.','line_number':435,'multiline':False]['text':' Since we only send the write to a single shard, record the response of the write against the','line_number':444,'multiline':False]['text':' first TargetedWriteBatch, and record no-ops for the remaining targeted shards. We always','line_number':445,'multiline':False]['text':' resolve the first batch due to a quirk of this protocol running within an internal','line_number':446,'multiline':False]['text':' transaction. This is because StaleShardVersion errors are automatically retried within the','line_number':447,'multiline':False]['text':' internal transaction, and if there happened to be a moveChunk that changes the number of','line_number':448,'multiline':False]['text':' targetable shards, the two phase protocol would still complete successfully, but the','line_number':449,'multiline':False]['text':' childBatches here could potentially still only include targetedWrites for the previous subset','line_number':450,'multiline':False]['text':' of shards before the moveChunk (since the StaleShardVersion error was not made visible here).','line_number':451,'multiline':False]['text':' It isn't important which TargetedWriteBatch records the write response, just as long as only','line_number':452,'multiline':False]['text':' one does so that the response on the client is still valid.','line_number':453,'multiline':False]['text':' We expect that each TargetedWriteBatch should only contain 1 write op for each shard.','line_number':458,'multiline':False]['text':' Resolve the first child batch with the response of the write or a no-op response','line_number':463,'multiline':False]['text':' if there was no matching document.','line_number':464,'multiline':False]['text':' Explicitly set the status so that debug builds won't invariant when checking the','line_number':476,'multiline':False]['text':' status.','line_number':477,'multiline':False]['text':' The ARS failed to retrieve the response due to some sort of local failure.','line_number':489,'multiline':False]['text':' If there is a targeted write with a sampleId, use that write instead in order to pass the','line_number':511,'multiline':False]['text':' sampleId to the two phase write protocol. Otherwise, just choose the first targeted','line_number':512,'multiline':False]['text':' write.','line_number':513,'multiline':False]['text':' shardId ','line_number':514,'multiline':True]['text':' For a write without shard key, we expect each TargetedWriteBatch in childBatches to','line_number':517,'multiline':False]['text':' contain only one TargetedWrite directed to each shard.','line_number':518,'multiline':False]['text':' Explicitly set the status of a no-op if there is no response.','line_number':543,'multiline':False]['text':' All child batches should be from the same update statement, which means they should','line_number':582,'multiline':False]['text':' have the same index.','line_number':583,'multiline':False]['text':' resourceYielder ','line_number':598,'multiline':True]['text':' Get the TargetedWriteBatch to find where to put the response.','line_number':656,'multiline':False]['text':' Since we are not in a transaction we can not abort on Write Errors and the following','line_number':672,'multiline':False]['text':' value must be false.','line_number':673,'multiline':False]['text':' Remember that we successfully wrote to this shard','line_number':677,'multiline':False]['text':' NOTE: This will record lastOps for shards where we actually didn't update','line_number':678,'multiline':False]['text':' or delete any documents, which preserves old behavior but is conservative','line_number':679,'multiline':False]['text':' The write op is complete if we receive ok:1 n:1 shard response and we can return','line_number':690,'multiline':False]['text':' early. Any pending child write ops would be marked NoOp.','line_number':691,'multiline':False]['text':' Since we are not in a transaction we can not abort on Write Errors and the following','line_number':698,'multiline':False]['text':' value must be false.','line_number':699,'multiline':False]['text':' If there were any stale shard responses, we will need to retry the whole batch and hence','line_number':705,'multiline':False]['text':' we cancel all writes.','line_number':706,'multiline':False]['text':' If we are here due to a stale shard/db and n=1 response, we don't need to retry.','line_number':710,'multiline':False]['text':' Since all targeted writes belong to one writeOp we can break the loop.','line_number':714,'multiline':False]['text':' If the WriteType is 'WithoutShardKeyOrId', then we have detected an','line_number':732,'multiline':False]['text':' updateOne/deleteOne request without a shard key or _id. We will use a two phase','line_number':733,'multiline':False]['text':' protocol to apply the write.','line_number':734,'multiline':False]['text':' If there is only 1 targetable shard, we can skip using the two phase write','line_number':740,'multiline':False]['text':' protocol.','line_number':741,'multiline':False]['text':' Execute the two phase write protocol for writes that cannot directly target a','line_number':752,'multiline':False]['text':' shard. If there are any transaction errors, 'abortBatch' will be set.','line_number':753,'multiline':False]['text':' If the WriteType is 'TimeseriesRetryableUpdate', then we have detected','line_number':770,'multiline':False]['text':' a retryable time-series update request. We will run it in the internal','line_number':771,'multiline':False]['text':' transaction api and collect the response.','line_number':772,'multiline':False]['text':' namespace','line_number':780,'multiline':False]['text':' Current batch status','line_number':797,'multiline':False]['text':'','line_number':805,'multiline':False]['text':' Get child batches to send using the targeter','line_number':806,'multiline':False]['text':'','line_number':807,'multiline':False]['text':' Targeting errors can be caused by remote metadata changing (the collection could have','line_number':808,'multiline':False]['text':' been dropped and recreated, for example with a new shard key).  If a remote metadata','line_number':809,'multiline':False]['text':' change occurs *before* a client sends us a batch, we need to make sure that we don't','line_number':810,'multiline':False]['text':' error out just because we're staler than the client - otherwise mongos will be have','line_number':811,'multiline':False]['text':' unpredictable behavior.','line_number':812,'multiline':False]['text':'','line_number':813,'multiline':False]['text':' (If a metadata change happens *during* or *after* a client sends us a batch, however,','line_number':814,'multiline':False]['text':' we make no guarantees about delivery.)','line_number':815,'multiline':False]['text':'','line_number':816,'multiline':False]['text':' For this reason, we don't record targeting errors until we've refreshed our targeting','line_number':817,'multiline':False]['text':' metadata at least once *after* receiving the client batch - at that point, we know:','line_number':818,'multiline':False]['text':'','line_number':819,'multiline':False]['text':' 1) our new metadata is the same as the metadata when the client sent a batch, and so','line_number':820,'multiline':False]['text':'    targeting errors are real.','line_number':821,'multiline':False]['text':' OR','line_number':822,'multiline':False]['text':' 2) our new metadata is a newer version than when the client sent a batch, and so','line_number':823,'multiline':False]['text':'    the metadata must have changed after the client batch was sent.  We don't need to','line_number':824,'multiline':False]['text':'    deliver in this case, since for all the client knows we may have gotten the batch','line_number':825,'multiline':False]['text':'    exactly when the metadata changed.','line_number':826,'multiline':False]['text':'','line_number':827,'multiline':False]['text':' If we've already had a targeting error, we've refreshed the metadata once and can','line_number':831,'multiline':False]['text':' record target errors definitively.','line_number':832,'multiline':False]['text':' Don't do anything until a targeter refresh','line_number':836,'multiline':False]['text':' Throw when there is a transient transaction error since this should be a top','line_number':842,'multiline':False]['text':' level error and not just a write error.','line_number':843,'multiline':False]['text':' hasWriteConcernError ','line_number':845,'multiline':True]['text':' isCommitOrAbort ','line_number':846,'multiline':True]['text':' Tries to execute all of the child batches. If there are any transaction errors,','line_number':857,'multiline':False]['text':' 'abortBatch' will be set.','line_number':858,'multiline':False]['text':' allowShardKeyUpdatesWithoutFullShardKeyInQuery ','line_number':867,'multiline':True]['text':' If we're done, get out','line_number':883,'multiline':False]['text':' MORE WORK TO DO','line_number':887,'multiline':False]['text':'','line_number':889,'multiline':False]['text':' Refresh the targeter if we need to (no-op if nothing stale)','line_number':890,'multiline':False]['text':'','line_number':891,'multiline':False]['text':' It's okay if we can't refresh, we'll just record errors for the ops if needed','line_number':921,'multiline':False]['text':'','line_number':925,'multiline':False]['text':' Ensure progress is being made toward completing the batch op','line_number':926,'multiline':False]['text':'','line_number':927,'multiline':False]['text':' namespace mongo','line_number':991,'multiline':False]