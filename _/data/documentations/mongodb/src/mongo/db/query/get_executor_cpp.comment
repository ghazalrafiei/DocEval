['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':43,'multiline':False]['text':' static','line_number':207,'multiline':False]['text':' Filter index entries','line_number':212,'multiline':False]['text':' Check BSON objects in AllowedIndices::_indexKeyPatterns against IndexEntry::keyPattern.','line_number':213,'multiline':False]['text':' Removes IndexEntrys that do not match _indexKeyPatterns.','line_number':214,'multiline':False]['text':' Copy index entry into temp vector if found in query settings.','line_number':221,'multiline':False]['text':' Update results.','line_number':226,'multiline':False]['text':' The body is below in the "count hack" section but getExecutor calls it.','line_number':232,'multiline':False]['text':' namespace','line_number':234,'multiline':False]['text':' There is no path-level multikey information available, so we must assume 'path' is','line_number':247,'multiline':False]['text':' multikey.','line_number':248,'multiline':False]['text':' _id indexes are guaranteed to be non-multikey. Determining whether the index is multikey','line_number':273,'multiline':False]['text':' has a small cost associated with it, so we skip that here to make _id lookups faster.','line_number':274,'multiline':False]['text':' isMultikey ','line_number':278,'multiline':True]['text':' MultikeyPaths ','line_number':279,'multiline':True]['text':' multikey Pathset ','line_number':280,'multiline':True]['text':' wildcard projection ','line_number':287,'multiline':True]['text':' The fixed-size vector of multikey paths stored in the index catalog.','line_number':334,'multiline':False]['text':' The set of multikey paths from special metadata keys stored in the index itself.','line_number':336,'multiline':False]['text':' Indexes that have these metadata keys do not store a fixed-size vector of multikey','line_number':337,'multiline':False]['text':' metadata in the index catalog. Depending on the index type, an index uses one of','line_number':338,'multiline':False]['text':' these mechanisms (or neither), but not both.','line_number':339,'multiline':False]['text':'*
 * If query has query settings index hints set, filters params.indices according to the
 * configuration. In addition, sets that there were index filters or query settings applied.
 * Returns true if query settings were applied.
 ','line_number':374,'multiline':True]['text':' If 'querySettings' has no index hints specified, then there are no settings to be applied to','line_number':382,'multiline':False]['text':' this query.','line_number':383,'multiline':False]['text':' Retrieving the allowed indexes for the given collection.','line_number':389,'multiline':False]['text':' TODO: SERVER-79231 Apply QuerySettings for aggregate commands.','line_number':393,'multiline':False]['text':' Implement the proper nss comparison.','line_number':394,'multiline':False]['text':' Checks if index entry is present in the 'allowedIndexes' list.','line_number':411,'multiline':False]['text':' Remove indices from the planner parameters if the index is not in the 'allowedIndexes' list.','line_number':428,'multiline':False]['text':'*
 * If query supports index filters, filters params.indices according to the configuration. In
 * addition, sets that there were index filters or query settings applied.
 ','line_number':438,'multiline':True]['text':' Filter index catalog if index filters are specified for query.','line_number':449,'multiline':False]['text':' Also, signal to planner that application hint should be ignored.','line_number':450,'multiline':False]['text':'*
 * Applies query settings to the query if applicable. If not, tries to apply index filters.
 ','line_number':458,'multiline':True]['text':' Try to apply index filters only if query settings were not applied.','line_number':466,'multiline':False]['text':' Indexes excluded from API version 1 should _not_ be used for planning if apiStrict is','line_number':485,'multiline':False]['text':' set to true.','line_number':486,'multiline':False]['text':' Skip the addition of hidden indexes to prevent use in query planning.','line_number':493,'multiline':False]['text':' namespace','line_number':513,'multiline':False]['text':' We only include these sometimes, since they are slightly expensive to compute.','line_number':521,'multiline':False]['text':' _id queries can skip checking the catalog for indices since they will always use the _id','line_number':536,'multiline':False]['text':' index.','line_number':537,'multiline':False]['text':' If it's not NULL, we may have indices. Access the catalog and fill out IndexEntry(s)','line_number':540,'multiline':False]['text':' If query supports index filters or query settings, filter params.indices.','line_number':548,'multiline':False]['text':' We will not output collection scans unless there are no indexed solutions. NO_TABLE_SCAN','line_number':552,'multiline':False]['text':' overrides this behavior by not outputting a collscan even if there are no indexed','line_number':553,'multiline':False]['text':' solutions.','line_number':554,'multiline':False]['text':' There are certain cases where we ignore this restriction:','line_number':557,'multiline':False]['text':' If the caller wants a shard filter, make sure we're actually sharded.','line_number':565,'multiline':False]['text':' If the shard key is specified exactly, the query is guaranteed to only target one','line_number':570,'multiline':False]['text':' shard. Shards cannot own orphans for the key ranges they own, so there is no need','line_number':571,'multiline':False]['text':' to include a shard filtering stage. By omitting the shard filter, it may be possible','line_number':572,'multiline':False]['text':' to get a more efficient plan (for example, a COUNT_SCAN may be used if the query is','line_number':573,'multiline':False]['text':' eligible).','line_number':574,'multiline':False]['text':' If there's no metadata don't bother w/the shard filter since we won't know what','line_number':583,'multiline':False]['text':' the key pattern is anyway...','line_number':584,'multiline':False]['text':' Only include the full size stats when there's a CSI.','line_number':615,'multiline':False]['text':' Only fill this out when a CSI is present.','line_number':618,'multiline':False]['text':' include size stats ','line_number':643,'multiline':True]['text':' In the event of a self $lookup, we must have an entry for the main collection in the map','line_number':653,'multiline':False]['text':' of secondary collections.','line_number':654,'multiline':False]['text':' Only non-tailable cursors on the oplog are affected. Only forward cursors, not reverse','line_number':675,'multiline':False]['text':' cursors, are affected, but this is checked when the cursor is opened.','line_number':676,'multiline':False]['text':' Only primaries should require readers to wait for oplog visibility. In any other replication','line_number':681,'multiline':False]['text':' state, readers read at the most visible oplog timestamp. The reason why readers on primaries','line_number':682,'multiline':False]['text':' need to wait is because multiple optimes can be allocated for operations before their entries','line_number':683,'multiline':False]['text':' are written to the storage engine. "Holes" will appear when an operation with a later optime','line_number':684,'multiline':False]['text':' commits before an operation with an earlier optime, and readers should wait so that all data','line_number':685,'multiline':False]['text':' is consistent.','line_number':686,'multiline':False]['text':'','line_number':687,'multiline':False]['text':' On secondaries, the wait is done while holding a global lock, and the oplog visibility','line_number':688,'multiline':False]['text':' timestamp is updated at the end of every batch on a secondary, signalling the wait to','line_number':689,'multiline':False]['text':' complete. If a replication worker had a global lock and temporarily released it, a reader','line_number':690,'multiline':False]['text':' could acquire the lock to read the oplog. If the secondary reader were to wait for the oplog','line_number':691,'multiline':False]['text':' visibility timestamp to be updated, it would wait for a replication batch that would never','line_number':692,'multiline':False]['text':' complete because it couldn't reacquire its own lock, the global lock held by the waiting','line_number':693,'multiline':False]['text':' reader.','line_number':694,'multiline':False]['text':'*
 * Struct to hold information about a query plan's cache info.
 ','line_number':700,'multiline':True]['text':'*
 * Fills in the given information on the CurOp::OpDebug object, if it has not already been filled in
 * by an outer pipeline.
 ','line_number':708,'multiline':True]['text':'*
 * A class to hold the result of preparation of the query to be executed using classic engine. This
 * result stores and provides the following information:
 *     - A QuerySolutions for the query. May be null in certain circumstances, where the constructed
 *       execution tree does not have an associated query solution.
 *     - A root PlanStage of the constructed execution tree.
 ','line_number':722,'multiline':True]['text':'*
 * A class to hold the result of preparation of the query to be executed using SBE engine. This
 * result stores and provides the following information:
 *     - A vector of QuerySolutions. Elements of the vector may be null, in certain circumstances
 *       where the constructed execution tree does not have an associated query solution.
 *     - A vector of PlanStages, representing the roots of the constructed execution trees (in the
 *       case when the query has multiple solutions, we may construct an execution tree for each
 *       solution and pick the best plan after multi-planning). Elements of this vector can never be
 *       null. The size of this vector must always be empty or match the size of 'querySolutions'
 *       vector. It will be empty in circumstances where we only construct query solutions and delay
 *       building execution trees, which is any time we are not using a cached plan.
 *     - A root node of the extension plan. The plan can be combined with a solution to create a
 *       larger plan after the winning solution is found. Can be null, meaning "no extension".
 *     - An optional decisionWorks value, which is populated when a solution was reconstructed from
 *       the PlanCache, and will hold the number of work cycles taken to decide on a winning plan
 *       when the plan was first cached. It used to decided whether cached solution runtime planning
 *       needs to be done or not.
 *     - A 'needSubplanning' flag indicating that the query contains rooted $or predicate and is
 *       eligible for runtime sub-planning.
 ','line_number':765,'multiline':True]['text':' Only allow solutions to be added, execution trees will be generated later.','line_number':792,'multiline':False]['text':' Make sure we store an empty QuerySolution instead of a nullptr or nothing.','line_number':801,'multiline':False]['text':' We can report plan summary only if this result contains a single solution.','line_number':806,'multiline':False]['text':' We only need the query solution to build the explain summary.','line_number':809,'multiline':False]['text':' root ','line_number':811,'multiline':True]['text':' data ','line_number':811,'multiline':True]['text':'*
 * A helper class to build and prepare a PlanStage tree for execution. This class contains common
 * logic to build and prepare an execution tree for the provided canonical query, and also provides
 * methods to build various specialized PlanStage trees when we either:
 *    * Do not build a QuerySolutionNode tree for the input query, and as such do not undergo the
 *      normal stage builder process.
 *    * We have a QuerySolutionNode tree (or multiple query solution trees), but must execute some
 *      custom logic in order to build the final execution tree.
 *
 * In most cases, the helper bypasses the final step of building the execution tree and returns only
 * the query solution(s) if the 'DeferExecutionTreeGeneration' flag is true.
 ','line_number':873,'multiline':True]['text':'*
     * Returns a reference to the main collection that is targeted by this query.
     ','line_number':903,'multiline':True]['text':' Tailable: If the query requests tailable the collection must be capped.','line_number':926,'multiline':False]['text':' If the canonical query does not have a user-specified collation and no one has given the','line_number':933,'multiline':False]['text':' CanonicalQuery a collation already, set it from the collection default.','line_number':934,'multiline':False]['text':' Before consulting the plan cache, check if we should short-circuit and construct a','line_number':940,'multiline':False]['text':' find-by-_id plan.','line_number':941,'multiline':False]['text':' The planner should have returned an error status if there are no solutions.','line_number':972,'multiline':False]['text':' See if one of our solutions is a fast count hack in disguise.','line_number':975,'multiline':False]['text':' Force multiplanning (and therefore caching) if forcePlanCache is set. We could manually','line_number':992,'multiline':False]['text':' update the plan cache instead without multiplanning but this is simpler.','line_number':993,'multiline':False]['text':' Only one possible plan. Build the stages from the solution.','line_number':995,'multiline':False]['text':'*
     * Get the result object to be returned by this in-progress prepare() call.
     ','line_number':1013,'multiline':True]['text':'*
     * Release the result instance to be returned to the caller holding the result of the
     * prepare() call.
     ','line_number':1021,'multiline':True]['text':'*
     * Adds the query solution to the result object, additionally building the corresponding
     * execution tree if 'DeferExecutionTreeGeneration' is turned on.
     ','line_number':1029,'multiline':True]['text':'*
     * Fills out planner parameters if not already filled.
     ','line_number':1042,'multiline':True]['text':'*
     * Constructs a PlanStage tree from the given query 'solution'.
     ','line_number':1054,'multiline':True]['text':'*
     * Attempts to build a special cased fast-path query plan for a find-by-_id query. Returns
     * nullptr if this optimization does not apply.
     ','line_number':1059,'multiline':True]['text':'*
     * Constructs the plan cache key.
     ','line_number':1065,'multiline':True]['text':'*
     * Either constructs a PlanStage tree from a cached plan (if exists in the plan cache), or
     * constructs a "id hack" PlanStage tree. Returns nullptr if no cached plan or id hack plan can
     * be constructed.
     ','line_number':1070,'multiline':True]['text':'*
     * Constructs a special PlanStage tree for rooted $or queries. Each clause of the $or is planned
     * individually, and then an overall query plan is created based on the winning plan from each
     * clause.
     *
     * If sub-planning is implemented as a standalone component, rather than as part of the
     * execution tree, this method can populate the result object with additional information
     * required to perform the sub-planning.
     ','line_number':1077,'multiline':True]['text':'*
     * If the query have multiple solutions, this method either:
     *    * Constructs a special PlanStage tree to perform a multi-planning task and pick the best
     *      plan in runtime.
     *    * Or builds a PlanStage tree for each of the 'solutions' and stores them in the result
     *      object, if multi-planning is implemented as a standalone component.
     ','line_number':1088,'multiline':True]['text':' Used to avoid filling out the planner params twice.','line_number':1102,'multiline':False]['text':' In-progress result value of the prepare() call.','line_number':1104,'multiline':False]['text':'*
 * A helper class to prepare a classic PlanStage tree for execution.
 ','line_number':1108,'multiline':True]['text':' DeferExecutionTreeGeneration ','line_number':1115,'multiline':True]['text':' Might have to filter out orphaned docs.','line_number':1157,'multiline':False]['text':' Add a SortKeyGeneratorStage if the query requested sortKey metadata.','line_number':1170,'multiline':False]['text':' If returnKey was requested, add ReturnKeyStage to return only the index keys in','line_number':1177,'multiline':False]['text':' the resulting documents. If a projection was also specified, it will be ignored,','line_number':1178,'multiline':False]['text':' with the exception the $meta sortKey projection, which can be used along with the','line_number':1179,'multiline':False]['text':' returnKey.','line_number':1180,'multiline':False]['text':' There might be a projection. The idhack stage will always fetch the full','line_number':1189,'multiline':False]['text':' document, so we don't support covered projections. However, we might use the','line_number':1190,'multiline':False]['text':' simple inclusion fast path.','line_number':1191,'multiline':False]['text':' Stuff the right data into the params depending on what proj impl we use.','line_number':1192,'multiline':False]['text':' solution ','line_number':1210,'multiline':True]['text':' Try to look up a cached solution for the query.','line_number':1223,'multiline':False]['text':' We have a CachedSolution.  Have the planner turn it into a QuerySolution.','line_number':1229,'multiline':False]['text':' Add a CachedPlanStage on top of the previous root.','line_number':1244,'multiline':False]['text':'','line_number':1245,'multiline':False]['text':' 'decisionWorks' is used to determine whether the existing cache entry should','line_number':1246,'multiline':False]['text':' be evicted, and the query replanned.','line_number':1247,'multiline':False]['text':' solution ','line_number':1269,'multiline':True]['text':' Many solutions. Create a MultiPlanStage to pick the best, update the cache,','line_number':1275,'multiline':False]['text':' and so on. The working set will be shared by all candidate plans.','line_number':1276,'multiline':False]['text':' Takes ownership of 'nextPlanRoot'.','line_number':1285,'multiline':False]['text':' solution ','line_number':1290,'multiline':True]['text':'*
 * A helper class to prepare an SBE PlanStage tree for execution.
 ','line_number':1299,'multiline':True]['text':' DeferExecutionTreeGeneration ','line_number':1307,'multiline':True]['text':' TODO SERVER-66437 SBE is not currently used for IDHACK plans.','line_number':1337,'multiline':False]['text':' Nothing to be done here, all planning and stage building will be done by a SubPlanner.','line_number':1373,'multiline':False]['text':' We must have a tree of stages in order to have a valid plan executor, but the query','line_number':1413,'multiline':False]['text':' solution may be null.','line_number':1414,'multiline':False]['text':'*
 * Checks if the prepared execution plans require further planning in runtime to pick the best
 * plan based on the collected execution stats, and returns a 'RuntimePlanner' instance if such
 * planning needs to be done, or nullptr otherwise.
 ','line_number':1425,'multiline':True]['text':' If we have multiple solutions, we always need to do the runtime planning.','line_number':1440,'multiline':False]['text':' If the query can be run as sub-queries, the needSubplanning flag will be set to true and','line_number':1455,'multiline':False]['text':' we'll need to create a runtime planner to build a composite solution and pick the best plan','line_number':1456,'multiline':False]['text':' for each sub-query.','line_number':1457,'multiline':False]['text':' If we have a single solution and the plan is not pinned or plan contains a hash_lookup stage,','line_number':1471,'multiline':False]['text':' we will need to do the runtime planning to check if the cached plan still','line_number':1472,'multiline':False]['text':' performs efficiently, or requires re-planning.','line_number':1473,'multiline':False]['text':' Runtime planning is not required.','line_number':1483,'multiline':False]['text':' Now that we know what executor we are going to use, fill in some opDebug information, unless','line_number':1494,'multiline':False]['text':' it has already been filled by an outer pipeline.','line_number':1495,'multiline':False]['text':' Analyze the provided query and build the list of candidate plans for it.','line_number':1498,'multiline':False]['text':' We might have execution trees already if we pulled the plan from the cache. If not, we','line_number':1505,'multiline':False]['text':' need to generate one for each solution.','line_number':1506,'multiline':False]['text':' When query requires sub-planning, we may not get any executable plans.','line_number':1513,'multiline':False]['text':' In some circumstances (e.g. when have multiple candidate plans or using a cached one), we','line_number':1518,'multiline':False]['text':' might need to execute the plan(s) to pick the best one or to confirm the choice.','line_number':1519,'multiline':False]['text':' Do the runtime planning and pick the best candidate plan.','line_number':1529,'multiline':False]['text':' No need for runtime planning, just use the constructed plan stage tree.','line_number':1540,'multiline':False]['text':' Need to extend the solution with the agg pipeline and rebuild the execution tree.','line_number':1547,'multiline':False]['text':' Prepare the SBE tree for execution.','line_number':1566,'multiline':False]['text':'pipeline','line_number':1578,'multiline':True]['text':' generatedByBonsai ','line_number':1586,'multiline':True]['text':' getSlotBasedExecutor','line_number':1589,'multiline':False]['text':'*
 * Function which returns true if 'cq' uses features that are currently supported in SBE without
 * 'featureFlagSbeFull' being set; false otherwise.
 ','line_number':1591,'multiline':True]['text':' If we can't push down any agg stages when internalQueryFrameworkControl is set to','line_number':1596,'multiline':False]['text':' "trySbeRestricted", we return false.','line_number':1597,'multiline':False]['text':' Return true if all the expressions in the CanonicalQuery's filter and projection are SBE','line_number':1604,'multiline':False]['text':' compatible.','line_number':1605,'multiline':False]['text':'*
 * Attempts to create a slot-based executor for the query, if the query plan is eligible for SBE
 * execution. This function has three possible return values:
 *
 *  1. A plan executor. This is in the case where the query is SBE eligible and encounters no errors
 * in executor creation. This result is to be expected in the majority of cases.
 *  2. A non-OK status. This is when errors are encountered during executor creation.
 *  3. The canonical query. This is to return ownership of the 'canonicalQuery' argument in the case
 * where the query plan is not eligible for SBE execution but it is not an error case.
 ','line_number':1612,'multiline':True]['text':' Push down applicable pipeline stages and attach to the query, but don't remove from','line_number':1632,'multiline':False]['text':' the high-level pipeline object until we know for sure we will execute with SBE.','line_number':1633,'multiline':False]['text':' attachOnly ','line_number':1634,'multiline':True]['text':' (Ignore FCV check): This is intentional because we always want to use this feature once the','line_number':1637,'multiline':False]['text':' feature flag is enabled.','line_number':1638,'multiline':False]['text':' Given that we are using SBE, we need to remove the pushed-down stages','line_number':1658,'multiline':False]['text':' from the original pipeline object.','line_number':1659,'multiline':False]['text':' attachOnly ','line_number':1660,'multiline':True]['text':' Either we did not meet the criteria for attempting SBE, or we attempted query planning and','line_number':1676,'multiline':False]['text':' determined that SBE should not be used. Reset any fields that may have been modified, and','line_number':1677,'multiline':False]['text':' fall back to classic engine.','line_number':1678,'multiline':False]['text':' namespace','line_number':1684,'multiline':False]['text':' If the query is eligible for a fast path, use the fast path plan instead of','line_number':1704,'multiline':False]['text':' invoking the optimizer.','line_number':1705,'multiline':False]['text':'pipeline','line_number':1716,'multiline':True]['text':' If the query is not SBE compatible, do not attempt to run it on SBE.','line_number':1731,'multiline':False]['text':' If query settings engine version is set, use it to determine which engine should be','line_number':1736,'multiline':False]['text':' used.','line_number':1737,'multiline':False]['text':' The query is not eligible for SBE execution - reclaim the canonical query and','line_number':1762,'multiline':False]['text':' fall back to classic.','line_number':1763,'multiline':False]['text':' Ensure that 'sbeCompatible' is set accordingly.','line_number':1770,'multiline':False]['text':'','line_number':1808,'multiline':False]['text':' Find','line_number':1809,'multiline':False]['text':'','line_number':1810,'multiline':False]['text':' For metadata executor, we always have only one remote cursor, any id will work.','line_number':1865,'multiline':False]['text':' cq ','line_number':1877,'multiline':True]['text':'pipeline','line_number':1878,'multiline':True]['text':' solution ','line_number':1879,'multiline':True]['text':' optimizerData ','line_number':1881,'multiline':True]['text':' plannerOptions ','line_number':1882,'multiline':True]['text':' planIsFromCache ','line_number':1885,'multiline':True]['text':' generatedByBonsai ','line_number':1886,'multiline':True]['text':'*
 * Attempts to construct and return the projection AST corresponding to 'projObj'. Illegal to call
 * if 'projObj' is empty.
 *
 * If 'allowPositional' is false, and the projection AST involves positional projection, returns a
 * non-OK status.
 *
 * Marks any metadata dependencies required by the projection on the given CanonicalQuery.
 ','line_number':1892,'multiline':True]['text':' ProjectionExec requires the MatchDetails from the query expression when the projection','line_number':1913,'multiline':False]['text':' uses the positional operator. Since the query may no longer match the newly-updated','line_number':1914,'multiline':False]['text':' document, we forbid this case.','line_number':1915,'multiline':False]['text':' $meta sortKey is not allowed to be projected in findAndModify commands.','line_number':1923,'multiline':False]['text':' namespace','line_number':1932,'multiline':False]['text':'','line_number':1934,'multiline':False]['text':' Delete','line_number':1935,'multiline':False]['text':'','line_number':1936,'multiline':False]['text':' This check is duplicated from collection_internal::deleteDocument() for two reasons:','line_number':1956,'multiline':False]['text':' - Performing a remove on an empty capped collection would not call','line_number':1957,'multiline':False]['text':'   collection_internal::deleteDocument().','line_number':1958,'multiline':False]['text':' - We can avoid doing lookups on documents and erroring later when trying to delete them.','line_number':1959,'multiline':False]['text':' Treat collections that do not exist as empty collections. Return a PlanExecutor which','line_number':1995,'multiline':False]['text':' contains an EOF stage.','line_number':1996,'multiline':False]['text':' whether we must return owned data ','line_number':2007,'multiline':True]['text':' Only consider using the idhack if no hint was provided.','line_number':2013,'multiline':False]['text':' This is the idhack fast-path for getting a PlanExecutor without doing the work to','line_number':2015,'multiline':False]['text':' create a CanonicalQuery.','line_number':2016,'multiline':False]['text':' Construct delete request collator.','line_number':2022,'multiline':False]['text':' whether owned BSON must be returned ','line_number':2053,'multiline':True]['text':' If we're here then we don't have a parsed query, but we're also not eligible for','line_number':2057,'multiline':False]['text':' the idhack fast path. We need to force canonicalization now.','line_number':2058,'multiline':False]['text':' This is the regular path for when we have a CanonicalQuery.','line_number':2065,'multiline':False]['text':' Transfer the explain verbosity level into the expression context.','line_number':2072,'multiline':False]['text':' The underlying query plan must preserve the record id, since it will be needed in order to','line_number':2087,'multiline':False]['text':' identify the record to update.','line_number':2088,'multiline':False]['text':' TODO (SERVER-64506): support change streams' pre- and post-images.','line_number':2104,'multiline':False]['text':' TODO (SERVER-66079): allow batched deletions in the config.* namespace.','line_number':2105,'multiline':False]['text':' Checks if the delete is on a time-series collection and cannot run on bucket documents','line_number':2117,'multiline':False]['text':' directly.','line_number':2118,'multiline':False]['text':' We must have a tree of stages in order to have a valid plan executor, but the query','line_number':2144,'multiline':False]['text':' solution may be null.','line_number':2145,'multiline':False]['text':'','line_number':2156,'multiline':False]['text':' Update','line_number':2157,'multiline':False]['text':'','line_number':2158,'multiline':False]['text':' If there is no collection and this is an upsert, callers are supposed to create','line_number':2175,'multiline':False]['text':' the collection prior to calling this method. Explain, however, will never do','line_number':2176,'multiline':False]['text':' collection or database creation.','line_number':2177,'multiline':False]['text':' If this is a user-issued update, then we want to return an error: you cannot perform','line_number':2182,'multiline':False]['text':' writes on a secondary. If this is an update to a secondary from the replication system,','line_number':2183,'multiline':False]['text':' however, then we make an exception and let the write proceed.','line_number':2184,'multiline':False]['text':' If the collection doesn't exist, then return a PlanExecutor for a no-op EOF plan. We have','line_number':2208,'multiline':False]['text':' should have already enforced upstream that in this case either the upsert flag is false, or','line_number':2209,'multiline':False]['text':' we are an explain. If the collection doesn't exist, we're not an explain, and the upsert flag','line_number':2210,'multiline':False]['text':' is true, we expect the caller to have created the collection already.','line_number':2211,'multiline':False]['text':' whether owned BSON must be returned ','line_number':2223,'multiline':True]['text':' Only consider using the idhack if no hint was provided.','line_number':2228,'multiline':False]['text':' This is the idhack fast-path for getting a PlanExecutor without doing the work','line_number':2230,'multiline':False]['text':' to create a CanonicalQuery.','line_number':2231,'multiline':False]['text':' Working set 'ws' is discarded. InternalPlanner::updateWithIdHack() makes its own','line_number':2244,'multiline':False]['text':' WorkingSet.','line_number':2245,'multiline':False]['text':' If we're here then we don't have a parsed query, but we're also not eligible for','line_number':2255,'multiline':False]['text':' the idhack fast path. We need to force canonicalization now.','line_number':2256,'multiline':False]['text':' This is the regular path for when we have a CanonicalQuery.','line_number':2263,'multiline':False]['text':' If the plan stage is to return the newly-updated version of the documents, then it','line_number':2274,'multiline':False]['text':' is invalid to use a positional projection because the query expression need not','line_number':2275,'multiline':False]['text':' match the array element after the update has been applied.','line_number':2276,'multiline':False]['text':' The underlying query plan must preserve the record id, since it will be needed in order to','line_number':2285,'multiline':False]['text':' identify the record to update.','line_number':2286,'multiline':False]['text':' If this is a multi-update, we need to spool the data before beginning to apply','line_number':2304,'multiline':False]['text':' updates, in order to avoid the Halloween problem.','line_number':2305,'multiline':False]['text':' We must have a tree of stages in order to have a valid plan executor, but the query','line_number':2343,'multiline':False]['text':' solution may be null. Takes ownership of all args other than 'collection' and 'opCtx'','line_number':2344,'multiline':False]['text':'','line_number':2355,'multiline':False]['text':' Count hack','line_number':2356,'multiline':False]['text':'','line_number':2357,'multiline':False]['text':'*
 * If 'isn' represents a non-multikey index and its bounds contain a single null interval, return
 * its position. If 'isn' represents a multikey index and its bounds contain a single null and
 * empty array interval, return its position. Otherwise return boost::none.
 ','line_number':2361,'multiline':True]['text':' Return boost::none if we have multiple null intervals.','line_number':2374,'multiline':False]['text':'*
 * Returns 'true' if the provided solution 'soln' can be rewritten to use a fast counting stage.
 * Mutates the tree in 'soln->root'.
 *
 * Otherwise, returns 'false'.
 ','line_number':2387,'multiline':True]['text':' Root should be an ixscan or fetch w/o any filters.','line_number':2396,'multiline':False]['text':' If the root is a fetch, its child should be an ixscan','line_number':2405,'multiline':False]['text':' No filters allowed and side-stepping isSimpleRange for now.  TODO: do we ever see','line_number':2414,'multiline':False]['text':' isSimpleRange here?  because we could well use it.  I just don't think we ever do see','line_number':2415,'multiline':False]['text':' it.','line_number':2416,'multiline':False]['text':' Make sure the bounds are OK.','line_number':2422,'multiline':False]['text':' Since count scans return no data, they are always forward scans. Index scans, on the','line_number':2433,'multiline':False]['text':' other hand, may need to scan the index in reverse order in order to obtain a sort. If the','line_number':2434,'multiline':False]['text':' index scan direction is backwards, then we need to swap the start and end of the count','line_number':2435,'multiline':False]['text':' scan bounds.','line_number':2436,'multiline':False]['text':' If we have exactly one null interval, we should split the bounds and try to construct','line_number':2453,'multiline':False]['text':' two COUNT_SCAN stages joined by an OR stage. If we have exactly one null and empty array','line_number':2454,'multiline':False]['text':' interval, we should do the same with three COUNT_SCAN stages. If we had multiple such','line_number':2455,'multiline':False]['text':' intervals, we would need at least 2^N count scans for N intervals, meaning this would','line_number':2456,'multiline':False]['text':' quickly explode to a point where it would just be more efficient to use a single index','line_number':2457,'multiline':False]['text':' scan. Consequently, we draw the line at one such interval.','line_number':2458,'multiline':False]['text':' Build a new IET list based on the rewritten index bounds.','line_number':2477,'multiline':False]['text':' If undefinedCsn is non-null, then we should also be able to successfully generate','line_number':2496,'multiline':False]['text':' a count scan for the null interval case and for the empty array interval case.','line_number':2497,'multiline':False]['text':' For a multikey index, add the third COUNT_SCAN stage for empty array values.','line_number':2506,'multiline':False]['text':' Note that there is no need to deduplicate when the optimization is not','line_number':2515,'multiline':False]['text':' applied to multikey indexes.','line_number':2516,'multiline':False]['text':' Make the count node that we replace the fetch + ixscan with.','line_number':2527,'multiline':False]['text':' Takes ownership of 'cn' and deletes the old root.','line_number':2529,'multiline':False]['text':'*
 * Returns true if indices contains an index that can be used with DistinctNode (the "fast distinct
 * hack" node, which can be used only if there is an empty query predicate).  Sets indexOut to the
 * array index of PlannerParams::indices.  Look for the index for the fewest fields.  Criteria for
 * suitable index is that the index should be of type BTREE or HASHED and the index cannot be a
 * partial index.
 *
 * Multikey indices are not suitable for DistinctNode when the projection is on an array element.
 * Arrays are flattened in a multikey index which makes it impossible for the distinct scan stage
 * (plan stage generated from DistinctNode) to select the requested element by array index.
 *
 * Multikey indices cannot be used for the fast distinct hack if the field is dotted.  Currently the
 * solution generated for the distinct hack includes a projection stage and the projection stage
 * cannot be covered with a dotted field.
 ','line_number':2534,'multiline':True]['text':' Skip indices with non-matching collator.','line_number':2556,'multiline':False]['text':' Skip partial indices.','line_number':2560,'multiline':False]['text':' Skip indices where the first key is not 'field'.','line_number':2564,'multiline':False]['text':' Skip the index if the first key is a "plugin" such as "hashed", "2dsphere", and so on.','line_number':2569,'multiline':False]['text':' Compound hashed indexes can use distinct scan if the first field is 1 or -1. For the','line_number':2573,'multiline':False]['text':' other special indexes, the 1 or -1 index fields may be stored as a function of the data','line_number':2574,'multiline':False]['text':' rather than the raw data itself. Storing f(d) instead of 'd' precludes the distinct_scan','line_number':2575,'multiline':False]['text':' due to the possibility that f(d1) == f(d2).  Therefore, after fetching the base data,','line_number':2576,'multiline':False]['text':' either d1 or d2 would be incorrectly missing from the result set.','line_number':2577,'multiline':False]['text':' All other index types are not eligible.','line_number':2584,'multiline':False]['text':' Pick the index with the lowest number of fields.','line_number':2589,'multiline':False]['text':' namespace','line_number':2598,'multiline':False]['text':' Treat collections that do not exist as empty collections. Note that the explain reporting','line_number':2644,'multiline':False]['text':' machinery always assumes that the root stage for a count operation is a CountStage, so in','line_number':2645,'multiline':False]['text':' this case we put a CountStage on top of an EOFStage.','line_number':2646,'multiline':False]['text':' whether we must return owned BSON ','line_number':2654,'multiline':True]['text':' If the query is empty, then we can determine the count by just asking the collection','line_number':2658,'multiline':False]['text':' for its number of records. This is implemented by the CountStage, and we don't need','line_number':2659,'multiline':False]['text':' to create a child for the count stage in this case.','line_number':2660,'multiline':False]['text':'','line_number':2661,'multiline':False]['text':' If there is a hint, then we can't use a trival count plan as described above.','line_number':2662,'multiline':False]['text':' whether we must returned owned BSON ','line_number':2676,'multiline':True]['text':' Make a CountStage to be the new root.','line_number':2695,'multiline':False]['text':' We must have a tree of stages in order to have a valid plan executor, but the query','line_number':2698,'multiline':False]['text':' solution may be NULL. Takes ownership of all args other than 'collection' and 'opCtx'','line_number':2699,'multiline':False]['text':'','line_number':2711,'multiline':False]['text':' Distinct hack','line_number':2712,'multiline':False]['text':'','line_number':2713,'multiline':False]['text':' We can attempt to convert a plan if it follows one of these patterns (starting from the','line_number':2721,'multiline':False]['text':' root):','line_number':2722,'multiline':False]['text':'   1. PROJECT=>FETCH=>IXSCAN','line_number':2723,'multiline':False]['text':'   2. FETCH=>IXSCAN','line_number':2724,'multiline':False]['text':'   3. PROJECT=>IXSCAN','line_number':2725,'multiline':False]['text':' If the fetch has a filter, we're out of luck. We can't skip all keys with a given value,','line_number':2757,'multiline':False]['text':' since one of them may key a document that passes the filter.','line_number':2758,'multiline':False]['text':' If the query is on a field other than the distinct key, we may have generated a $** plan','line_number':2764,'multiline':False]['text':' which does not actually contain the distinct key field.','line_number':2765,'multiline':False]['text':' If the query includes object bounds, we cannot turn this IXSCAN into a DISTINCT_SCAN.','line_number':2769,'multiline':False]['text':' Wildcard indexes contain multiple keys per object, one for each subpath in ascending','line_number':2770,'multiline':False]['text':' (Path, Value, RecordId) order. If the distinct fields in two successive documents are','line_number':2771,'multiline':False]['text':' objects with the same leaf path values but in different field order, e.g. {a: 1, b: 2}','line_number':2772,'multiline':False]['text':' and {b: 2, a: 1}, we would therefore only return the first document and skip the other.','line_number':2773,'multiline':False]['text':' An additional filter must be applied to the data in the key, so we can't just skip','line_number':2779,'multiline':False]['text':' all the keys with a given value; we must examine every one to find the one that (may)','line_number':2780,'multiline':False]['text':' pass the filter.','line_number':2781,'multiline':False]['text':' We only set this when we have special query modifiers (.max() or .min()) or other','line_number':2786,'multiline':False]['text':' special cases.  Don't want to handle the interactions between those and distinct.','line_number':2787,'multiline':False]['text':' Don't think this will ever really be true but if it somehow is, just ignore this','line_number':2788,'multiline':False]['text':' soln.','line_number':2789,'multiline':False]['text':' Figure out which field we're skipping to the next value of.','line_number':2794,'multiline':False]['text':' If the "distinct" field is not the first field in the index bounds then the only way we','line_number':2805,'multiline':False]['text':' can guarantee that we'll never see duplicate values for the distinct field is to make','line_number':2806,'multiline':False]['text':' sure every field before the distinct field has equality bounds. For example, a','line_number':2807,'multiline':False]['text':' DISTINCT_SCAN on 'b' over the {a: 1, b: 1} index will scan a particular 'b' value','line_number':2808,'multiline':False]['text':' multiple times if that 'b' value exists in documents with different 'a' values. The','line_number':2809,'multiline':False]['text':' equality bounds on 'a' prevent the scan from seeing duplicate 'b' values by ensuring the','line_number':2810,'multiline':False]['text':' scan is limited to a single value for the 'a' field.','line_number':2811,'multiline':False]['text':' We should not use a distinct scan if the field over which we are computing the distinct is','line_number':2821,'multiline':False]['text':' multikey.','line_number':2822,'multiline':False]['text':' We don't have path-level multikey information available.','line_number':2826,'multiline':False]['text':' Path-level multikey information indicates that the distinct key contains at least one','line_number':2831,'multiline':False]['text':' array component.','line_number':2832,'multiline':False]['text':' Make a new DistinctNode. We will swap this for the ixscan in the provided solution.','line_number':2837,'multiline':False]['text':' If the original plan had PROJECT and FETCH stages, we can get rid of the PROJECT','line_number':2847,'multiline':False]['text':' transforming the plan from PROJECT=>FETCH=>IXSCAN to FETCH=>DISTINCT_SCAN.','line_number':2848,'multiline':False]['text':' Make the fetch the new root. This destroys the project stage.','line_number':2854,'multiline':False]['text':' Attach the distinct node in the index scan's place.','line_number':2858,'multiline':False]['text':' There is no fetch node. The PROJECT=>IXSCAN tree should become PROJECT=>DISTINCT_SCAN.','line_number':2861,'multiline':False]['text':' Attach the distinct node in the index scan's place.','line_number':2865,'multiline':False]['text':' Get the list of indexes that include the "distinct" field.','line_number':2874,'multiline':False]['text':' If the caller did not request a "strict" distinct scan then we may choose a plan which','line_number':2883,'multiline':False]['text':' unwinds arrays and treats each element in an array as its own key.','line_number':2884,'multiline':False]['text':' Skip the addition of hidden indexes to prevent use in query planning.','line_number':2893,'multiline':False]['text':' This handles regular fields of Compound Wildcard Indexes as well.','line_number':2897,'multiline':False]['text':' This CanonicalDistinct was generated as a result of transforming a $group with','line_number':2899,'multiline':False]['text':' $last accumulators using the GroupFromFirstTransformation. We cannot use a','line_number':2900,'multiline':False]['text':' DISTINCT_SCAN if $last is being applied to an indexed field which is multikey,','line_number':2901,'multiline':False]['text':' even if the 'canonicalDistinct' key does not include multikey paths. This is','line_number':2902,'multiline':False]['text':' because changing the sort direction also changes the comparison semantics for','line_number':2903,'multiline':False]['text':' arrays, which means that flipping the scan may not exactly flip the order that we','line_number':2904,'multiline':False]['text':' see documents in. In the case of using DISTINCT_SCAN for $group, that would mean','line_number':2905,'multiline':False]['text':' that $first of the flipped scan may not be the same document as $last from the','line_number':2906,'multiline':False]['text':' user's requested sort order.','line_number':2907,'multiline':False]['text':' If the caller requested "strict" distinct that does not "pre-unwind" arrays,','line_number':2915,'multiline':False]['text':' then an index which is multikey on the distinct field may not be used. This is','line_number':2916,'multiline':False]['text':' because when indexing an array each element gets inserted individually. Any plan','line_number':2917,'multiline':False]['text':' which involves scanning the index will have effectively "unwound" all arrays.','line_number':2918,'multiline':False]['text':' Check whether the $** projection captures the field over which we are distinct-ing.','line_number':2925,'multiline':False]['text':' It is not necessary to do any checks about 'mayUnwindArrays' in this case, because:','line_number':2935,'multiline':False]['text':' 1) If there is no predicate on the distinct(), a wildcard indices may not be used.','line_number':2936,'multiline':False]['text':' 2) distinct() _with_ a predicate may not be answered with a DISTINCT_SCAN on _any_','line_number':2937,'multiline':False]['text':' multikey index.','line_number':2938,'multiline':False]['text':' So, we will not distinct scan a wildcard index that's multikey on the distinct()','line_number':2940,'multiline':False]['text':' field, regardless of the value of 'mayUnwindArrays'.','line_number':2941,'multiline':False]['text':' If there exists an index filter, we ignore all hints. Else, we only keep the index specified','line_number':2950,'multiline':False]['text':' by the hint. Since we cannot have an index with name $natural, that case will clear the','line_number':2951,'multiline':False]['text':' plannerParams.indices.','line_number':2952,'multiline':False]['text':' If a query has neither a filter nor a sort, the query planner won't attempt to use an','line_number':2968,'multiline':False]['text':' index for it even if the index could provide the distinct semantics on the key from the','line_number':2969,'multiline':False]['text':' 'canonicalDistinct'. So, we create the solution "manually" from a suitable index.','line_number':2970,'multiline':False]['text':' The direction of the index doesn't matter in this case.','line_number':2971,'multiline':False]['text':' An index with a non-simple collation requires a FETCH stage.','line_number':2983,'multiline':False]['text':' While on this path there are no sort or filter, the solution still needs to create','line_number':2993,'multiline':False]['text':' the projection and 'analyzeDataAccess()' would do that. NB: whether other aspects of','line_number':2994,'multiline':False]['text':' data access are important, it's hard to say, this code has been like this since long','line_number':2995,'multiline':False]['text':' ago (and it has always passed in new 'QueryPlannerParams').','line_number':2996,'multiline':False]['text':' Ask the QueryPlanner for a list of solutions that scan one of the indexes from','line_number':3003,'multiline':False]['text':' fillOutPlannerParamsForDistinct() (i.e., the indexes that include the distinct field).','line_number':3004,'multiline':False]['text':' Then try to convert one of these plans to a DISTINCT_SCAN.','line_number':3005,'multiline':False]['text':' The first suitable distinct scan is as good as any other.','line_number':3017,'multiline':False]['text':' no suitable solution has been found','line_number':3023,'multiline':False]['text':' namespace','line_number':3025,'multiline':False]['text':' The caller should create EOF plan for the appropriate engine.','line_number':3034,'multiline':False]['text':' 'fillOutPlannerParamsForDistinct()' might consider as suitable an index that later might not','line_number':3048,'multiline':False]['text':' pass all the necessary conditions for distinct scan, but if it fills no suitable indexes at','line_number':3049,'multiline':False]['text':' all, it's for sure that distinct scan cannot be used.','line_number':3050,'multiline':False]['text':' Convert the solution into an executable tree.','line_number':3061,'multiline':False]['text':' namespace mongo','line_number':3097,'multiline':False]