['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':'*
 * Utility function to create MatchExpression
 ','line_number':90,'multiline':True]['text':' A version of the above for CoreIndexInfo, used for plan cache update tests.','line_number':111,'multiline':False]['text':' sparse','line_number':118,'multiline':False]['text':' name','line_number':119,'multiline':False]['text':' filterExpr','line_number':120,'multiline':False]['text':' collation','line_number':121,'multiline':False]['text':' wildcard','line_number':122,'multiline':False]['text':'*
 * Check that the stable keys of 'a' and 'b' are equal, but the index discriminators are not.
 ','line_number':126,'multiline':True]['text':' Should always have the begin and end delimiters.','line_number':135,'multiline':False]['text':' namespace','line_number':139,'multiline':False]['text':' When a sparse index is present, computeKey() should generate different keys depending on','line_number':141,'multiline':False]['text':' whether or not the predicates in the given query can use the index.','line_number':142,'multiline':False]['text':' sparse','line_number':148,'multiline':False]['text':' name','line_number':149,'multiline':False]['text':' 'cqEqNumber' and 'cqEqString' get the same key, since both are compatible with this','line_number':155,'multiline':False]['text':' index.','line_number':156,'multiline':False]['text':' 'cqEqNull' gets a different key, since it is not compatible with this index.','line_number':161,'multiline':False]['text':' When a partial index is present, computeKey() should generate different keys depending on','line_number':169,'multiline':False]['text':' whether or not the predicates in the given query "match" the predicates in the partial index','line_number':170,'multiline':False]['text':' filter.','line_number':171,'multiline':False]['text':' sparse','line_number':180,'multiline':False]['text':' name','line_number':181,'multiline':False]['text':' filterExpr','line_number':182,'multiline':False]['text':' 'cqGtZero' and 'cqGtFive' get the same key, since both are compatible with this index.','line_number':188,'multiline':False]['text':' 'cqGtNegativeFive' gets a different key, since it is not compatible with this index.','line_number':191,'multiline':False]['text':' sparse','line_number':204,'multiline':False]['text':' name','line_number':205,'multiline':False]['text':' filterExpr','line_number':206,'multiline':False]['text':' Note that these queries get optimized to a single $in over 'f'.','line_number':220,'multiline':False]['text':' sparse','line_number':240,'multiline':False]['text':' name','line_number':241,'multiline':False]['text':' filterExpr','line_number':242,'multiline':False]['text':' Although this query is technically a subset of the partial filter, the logic to determine','line_number':259,'multiline':False]['text':' such ('isSubsetOf' in the code) is conservative in how it compares certain shapes of','line_number':260,'multiline':False]['text':' expression trees.','line_number':261,'multiline':False]['text':' sparse','line_number':285,'multiline':False]['text':' name','line_number':286,'multiline':False]['text':' filterExpr','line_number':287,'multiline':False]['text':' Query shapes should get the same plan cache key if they have the same collation indexability.','line_number':297,'multiline':False]['text':' sparse','line_number':305,'multiline':False]['text':' name','line_number':306,'multiline':False]['text':' filterExpr','line_number':307,'multiline':False]['text':' collation','line_number':308,'multiline':False]['text':' 'containsString', 'containsObject', and 'containsArray' have the same key, since none are','line_number':317,'multiline':False]['text':' compatible with the index.','line_number':318,'multiline':False]['text':' 'noStrings' gets a different key since it is compatible with the index.','line_number':322,'multiline':False]['text':' 'noStrings' and 'containsStringHasCollation' get different keys, since the collation','line_number':328,'multiline':False]['text':' specified in the query is considered part of its shape. However, they have the same index','line_number':329,'multiline':False]['text':' compatibility, so the unstable part of their PlanCacheKeys should be the same.','line_number':330,'multiline':False]['text':' 'inContainsString', 'inContainsObject', and 'inContainsArray' have the same key, since none','line_number':346,'multiline':False]['text':' are compatible with the index.','line_number':347,'multiline':False]['text':' 'inNoStrings' gets a different key since it is compatible with the index.','line_number':351,'multiline':False]['text':' 'inNoStrings' and 'inContainsStringHasCollation' get the same key since they compatible with','line_number':357,'multiline':False]['text':' the index.','line_number':358,'multiline':False]['text':' Used to check that two queries have the same shape when no indexes are present.','line_number':370,'multiline':False]['text':' Compatible with index.','line_number':373,'multiline':False]['text':' Not compatible with index.','line_number':377,'multiline':False]['text':' Check that the queries which are compatible with the index have the same key.','line_number':384,'multiline':False]['text':' Check that the queries which have the same path as the index, but aren't supported, have','line_number':388,'multiline':False]['text':' different keys.','line_number':389,'multiline':False]['text':' The query on 'b' should have a completely different plan cache key (both with and without a','line_number':400,'multiline':False]['text':' wildcard index).','line_number':401,'multiline':False]['text':' More complex queries with similar shapes. This is to ensure that plan cache key encoding','line_number':407,'multiline':False]['text':' correctly traverses the expression tree.','line_number':408,'multiline':False]['text':' Same shape except 'a' is compared to an object.','line_number':410,'multiline':False]['text':' The two queries should have the same shape when no indexes are present, but different shapes','line_number':413,'multiline':False]['text':' when a $** index is present.','line_number':414,'multiline':False]['text':' Equality to empty obj and equality to non-empty obj have different plan cache keys.','line_number':430,'multiline':False]['text':' $in with empty obj and $in with non-empty obj have different plan cache keys.','line_number':438,'multiline':False]['text':' Test that queries on field 'x' are discriminated based on their relationship with the partial','line_number':458,'multiline':False]['text':' filter expression.','line_number':459,'multiline':False]['text':' The discriminator strings have the format "<xx>". That is, there are two discriminator','line_number':467,'multiline':False]['text':' bits for the "x" predicate, the first pertaining to the partialFilterExpression and the','line_number':468,'multiline':False]['text':' second around applicability to the wildcard index.','line_number':469,'multiline':False]['text':' The partialFilterExpression should lead to a discriminator over field 'x', but not over 'y'.','line_number':474,'multiline':False]['text':' (Separately, there are wildcard-related discriminator bits for both 'x' and 'y'.)','line_number':475,'multiline':False]['text':' The discriminator strings have the format "<xx><y>". That is, there are two discriminator','line_number':483,'multiline':False]['text':' bits for the "x" predicate (the first pertaining to the partialFilterExpression, the','line_number':484,'multiline':False]['text':' second around applicability to the wildcard index) and one discriminator bit for "y".','line_number':485,'multiline':False]['text':' $eq:null predicates cannot be assigned to a wildcard index. Make sure that this is','line_number':490,'multiline':False]['text':' discrimated correctly. This test is designed to reproduce SERVER-48614.','line_number':491,'multiline':False]['text':' The discriminator strings have the format "<xx><y>". That is, there are two discriminator','line_number':499,'multiline':False]['text':' bits for the "x" predicate (the first pertaining to the partialFilterExpression, the','line_number':500,'multiline':False]['text':' second around applicability to the wildcard index) and one discriminator bit for "y".','line_number':501,'multiline':False]['text':' Test that the discriminators are correct for an $eq:null predicate on 'x'. This predicate is','line_number':506,'multiline':False]['text':' imcompatible for two reasons: null equality predicates cannot be answered by wildcard','line_number':507,'multiline':False]['text':' indexes, and the predicate is not compatible with the partial filter expression. This should','line_number':508,'multiline':False]['text':' result in two "0" bits inside the discriminator string.','line_number':509,'multiline':False]['text':' Partial filter is an AND of multiple conditions.','line_number':518,'multiline':False]['text':' TODO update The discriminators should have the format <xx><yy><z>. The 'z' predicate has','line_number':529,'multiline':False]['text':' just one discriminator because it is not referenced in the partial filter expression. All','line_number':530,'multiline':False]['text':' predicates are compatible.','line_number':531,'multiline':False]['text':' The discriminators should have the format <xx><yy><z>. The 'y' predicate is not','line_number':537,'multiline':False]['text':' compatible with the partial filter expression, leading to one of the 'y' bits being set','line_number':538,'multiline':False]['text':' to zero.','line_number':539,'multiline':False]['text':' The discriminators have the format <x><y>. The discriminator for 'x' indicates whether','line_number':557,'multiline':False]['text':' the predicate is compatible with the partial filter expression, whereas the disciminator','line_number':558,'multiline':False]['text':' for 'y' is about compatibility with the wildcard index.','line_number':559,'multiline':False]['text':' Similar to the previous case, except with an 'x' predicate that is incompatible with the','line_number':565,'multiline':False]['text':' partial filter expression.','line_number':566,'multiline':False]['text':' Case where the 'y' predicate is not compatible with the wildcard index.','line_number':572,'multiline':False]['text':' The discriminators have the format <x><(x.y)(x.y)<y>. All predicates are compatible','line_number':590,'multiline':False]['text':' Here, the predicate on "x.y" is not compatible with the partial filter expression.','line_number':597,'multiline':False]['text':' Create a sparse index (which requires a discriminator).','line_number':611,'multiline':False]['text':' sparse','line_number':615,'multiline':False]['text':' name','line_number':616,'multiline':False]['text':' Create a normal btree index. It will have a discriminator.','line_number':636,'multiline':False]['text':' sparse','line_number':640,'multiline':False]['text':' name*/','line_number':641,'multiline':False]['text':' There will be one discriminator for the $not and another for the leaf node ({$eq: 123}).','line_number':650,'multiline':False]['text':' There will be one discriminator for the $not and another for the leaf node ({$eq: [1]}).','line_number':652,'multiline':False]['text':' Since the index can support equality to an array, the second discriminator will have a value','line_number':653,'multiline':False]['text':' of '1'.','line_number':654,'multiline':False]['text':' Create a normal btree index. It will have a discriminator.','line_number':669,'multiline':False]['text':' sparse','line_number':673,'multiline':False]['text':' name','line_number':674,'multiline':False]['text':' The unstable part of the key for $nin: [<array>] should have changed. The stable part,','line_number':679,'multiline':False]['text':' however, should not.','line_number':680,'multiline':False]['text':' Test for a bug which would be easy to introduce. If we only inserted discriminators for some','line_number':690,'multiline':False]['text':' nodes, we would have a problem. For example if our "stable" key was:','line_number':691,'multiline':False]['text':' (or[nt[eqa],nt[eqa]])','line_number':692,'multiline':False]['text':' And there was just one discriminator:','line_number':693,'multiline':False]['text':' <0>','line_number':694,'multiline':False]['text':' Whether the discriminator referred to the first not-eq node or the second would be','line_number':696,'multiline':False]['text':' ambiguous. This would make it possible for two queries with different shapes (and different','line_number':697,'multiline':False]['text':' plans) to get the same plan cache key. We test that this does not happen for a simple example.','line_number':698,'multiline':False]['text':' Create a normal btree index. It will have a discriminator.','line_number':708,'multiline':False]['text':' sparse','line_number':712,'multiline':False]['text':' name','line_number':713,'multiline':False]['text':' namespace mongo','line_number':721,'multiline':False]