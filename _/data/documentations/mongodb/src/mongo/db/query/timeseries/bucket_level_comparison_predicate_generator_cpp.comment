['text':'*
 *    Copyright (C) 2023-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':'*
 * Helper function to make comparison match expressions.
 ','line_number':54,'multiline':True]['text':'*
 * Creates an ObjectId initialized with an appropriate timestamp corresponding to 'rhs' and
 * returns it as a Value.
 ','line_number':62,'multiline':True]['text':' Indicates whether to initialize an ObjectId with a max or min value for the non-date bytes.','line_number':68,'multiline':False]['text':' Make an ObjectId corresponding to a date value. As a conversion from date to ObjectId will','line_number':70,'multiline':False]['text':' truncate milliseconds, we round up when needed to prevent missing results.','line_number':71,'multiline':False]['text':' Make an ObjectId corresponding to a date value adjusted by the max bucket value for the','line_number':81,'multiline':False]['text':' time series view that this query operates on. This predicate can be used in a comparison','line_number':82,'multiline':False]['text':' to gauge a max value for a given bucket, rather than a min value.','line_number':83,'multiline':False]['text':' Ensure we don't underflow.','line_number':85,'multiline':False]['text':' Subtract max bucket range.','line_number':87,'multiline':False]['text':' Since we're out of range, just make a predicate that is true for all dates.','line_number':90,'multiline':False]['text':' We'll never use an OID for a date < 0 due to OID range limitations, so we set the','line_number':91,'multiline':False]['text':' minimum date to 0.','line_number':92,'multiline':False]['text':' Because the OID timestamp is only 4 bytes, we can't convert larger dates','line_number':96,'multiline':False]['text':' An ObjectId consists of a 4-byte timestamp, as well as a unique value and a counter, thus','line_number':100,'multiline':False]['text':' two ObjectIds initialized with the same date will have different values. To ensure that we','line_number':101,'multiline':False]['text':' do not incorrectly include or exclude any buckets, depending on the operator we will','line_number':102,'multiline':False]['text':' construct either the largest or the smallest ObjectId possible with the corresponding date.','line_number':103,'multiline':False]['text':' If the query operand is not of type Date, the original query will not match on any documents','line_number':104,'multiline':False]['text':' because documents in a time-series collection must have a timeField of type Date. We will','line_number':105,'multiline':False]['text':' make this case faster by keeping the ObjectId as the lowest or highest possible value so as','line_number':106,'multiline':False]['text':' to eliminate all buckets.','line_number':107,'multiline':False]['text':'roundMillisUpToSecond','line_number':109,'multiline':True]['text':'roundMillisUpToSecond','line_number':111,'multiline':True]['text':' The control field's min and max are chosen using a field-order insensitive comparator, while','line_number':126,'multiline':False]['text':' MatchExpressions use a comparator that treats field-order as significant. Because of this we','line_number':127,'multiline':False]['text':' will not perform this optimization on queries with operands of compound types.','line_number':128,'multiline':False]['text':' MatchExpressions have special comparison semantics regarding null, in that {$eq: null} will','line_number':132,'multiline':False]['text':' match all documents where the field is either null or missing. Because this is different','line_number':133,'multiline':False]['text':' from both the comparison semantics that InternalExprComparison expressions and the control's','line_number':134,'multiline':False]['text':' min and max fields use, we will not perform this optimization on queries with null operands.','line_number':135,'multiline':False]['text':' The control field's min and max are chosen based on the collation of the collection. If the','line_number':139,'multiline':False]['text':' query's collation does not match the collection's collation and the query operand is a','line_number':140,'multiline':False]['text':' string or compound type (skipped above) we will not perform this optimization.','line_number':141,'multiline':False]['text':' This function only handles time and measurement predicates--not metadata.','line_number':147,'multiline':False]['text':' We must avoid mapping predicates on fields computed via $addFields or a computed $project.','line_number':156,'multiline':False]['text':' We must avoid mapping predicates on fields removed by $project.','line_number':161,'multiline':False]['text':' Users are not allowed to insert non-date measurements into time field. So this query','line_number':168,'multiline':False]['text':' would not match anything. We do not need to optimize for this case.','line_number':169,'multiline':False]['text':'*
 * Makes a disjunction of the given predicates.
 *
 * - The result is non-null; it may be an OrMatchExpression with zero children.
 * - Any trivially-false arguments are omitted.
 * - If only one argument is nontrivial, returns that argument rather than adding an extra
 *   OrMatchExpression around it.
 ','line_number':176,'multiline':True]['text':'
 * Creates a predicate that ensures that if there exists a subpath of matchExprPath such that the
 * type of `control.min.subpath` is not the same as `control.max.subpath` then we will match that
 * document.
 *
 * However, if the buckets collection has no mixed-schema data then this type-equality predicate is
 * unnecessary. In that case this function returns an empty, always-true predicate.
 ','line_number':197,'multiline':True]['text':' Assume that we're generating a predicate on "a.b"','line_number':218,'multiline':False]['text':' This whole block adds','line_number':225,'multiline':False]['text':' {$expr: {$ne: [{$type: "$control.min.a"}, {$type: "$control.max.a"}]}}','line_number':226,'multiline':False]['text':' in order to ensure that the type of `control.min.a` and `control.max.a` are the same.','line_number':227,'multiline':False]['text':' This produces {$expr: ... }','line_number':229,'multiline':False]['text':' This produces {$ne: ... }','line_number':231,'multiline':False]['text':' This produces [...]','line_number':235,'multiline':False]['text':' This produces {$type: ... }','line_number':237,'multiline':False]['text':' This produces [...]','line_number':240,'multiline':False]['text':' This produces "$control.min.a"','line_number':242,'multiline':False]['text':' This produces {$type: ... }','line_number':245,'multiline':False]['text':' This produces [...]','line_number':248,'multiline':False]['text':' This produces "$control.max.a"','line_number':250,'multiline':False]['text':' Since by this point we know that no time value has been inserted which is','line_number':312,'multiline':False]['text':' outside the epoch range, we know that no document can meet this criteria','line_number':313,'multiline':False]['text':' Since by this point we know that no time value has been inserted < 0,','line_number':322,'multiline':False]['text':' every document must meet this criteria','line_number':323,'multiline':False]['text':' If we are here we are guaranteed that 'timestamp > max32BitEpochMillis'. Since by','line_number':326,'multiline':False]['text':' this point we know that no time value has been inserted > max32BitEpochMillis, we','line_number':327,'multiline':False]['text':' know that no document can meet this criteria','line_number':328,'multiline':False]['text':' Since by this point we know that no time value has been inserted < 0,','line_number':335,'multiline':False]['text':' we know that no document can meet this criteria','line_number':336,'multiline':False]['text':' If we are here we are guaranteed that 'timestamp > max32BitEpochMillis'. Since by','line_number':339,'multiline':False]['text':' this point we know that no time value has been inserted > 0xffffffff every time value','line_number':340,'multiline':False]['text':' must be less than this value','line_number':341,'multiline':False]['text':' namespace','line_number':347,'multiline':False]['text':' We have to disable the tight predicate for the measurement field. There might be missing','line_number':365,'multiline':False]['text':' values in the measurements and the control fields ignore them on insertion. So we cannot','line_number':366,'multiline':False]['text':' use bucket min and max to determine the property of all events in the bucket. For','line_number':367,'multiline':False]['text':' measurement fields, there's a further problem that if the control field is an array, we','line_number':368,'multiline':False]['text':' cannot generate the tight predicate because the predicate will be implicitly mapped over','line_number':369,'multiline':False]['text':' the array elements.','line_number':370,'multiline':False]['text':' All events satisfy $eq if bucket min and max both satisfy $eq.','line_number':383,'multiline':False]['text':' All events satisfy $gt if bucket min satisfy $gt.','line_number':393,'multiline':False]['text':' All events satisfy $gte if bucket min satisfy $gte.','line_number':400,'multiline':False]['text':' All events satisfy $lt if bucket max satisfy $lt.','line_number':407,'multiline':False]['text':' All events satisfy $lte if bucket max satisfy $lte.','line_number':414,'multiline':False]['text':' The date is in the "extended" range if it doesn't fit into the bottom 32 bits.','line_number':476,'multiline':False]['text':' For $eq, make both a $lte against 'control.min' and a $gte predicate against','line_number':486,'multiline':False]['text':' 'control.max'.','line_number':487,'multiline':False]['text':'','line_number':488,'multiline':False]['text':' Since we haven't stored a time outside of the 32 bit range, we include a','line_number':489,'multiline':False]['text':' predicate against the _id field which is converted to the maximum for the','line_number':490,'multiline':False]['text':' corresponding range of ObjectIds and is adjusted by the max range for a bucket to','line_number':491,'multiline':False]['text':' approximate the max bucket value given the min. Also include a predicate against','line_number':492,'multiline':False]['text':' the _id field which is converted to the minimum for the range of ObjectIds','line_number':493,'multiline':False]['text':' corresponding to the given date. In addition, we include a {'control.min' :','line_number':494,'multiline':False]['text':' {$gte: 'time - bucketMaxSpanSeconds'}} and a {'control.max' : {$lte: 'time +','line_number':495,'multiline':False]['text':' bucketMaxSpanSeconds'}} predicate which will be helpful in reducing bounds for','line_number':496,'multiline':False]['text':' index scans on 'time' field and routing on mongos.','line_number':497,'multiline':False]['text':' For $gt, make a $gt predicate against 'control.max'. If the collection doesn't','line_number':515,'multiline':False]['text':' contain times outside the 32 bit range, include a predicate against the _id field','line_number':516,'multiline':False]['text':' which is converted to the maximum for the corresponding range of ObjectIds and is','line_number':517,'multiline':False]['text':' adjusted by the max range for a bucket to approximate the max bucket value given','line_number':518,'multiline':False]['text':' the min.','line_number':519,'multiline':False]['text':'','line_number':520,'multiline':False]['text':' In addition, we include a {'control.min' : {$gt: 'time - bucketMaxSpanSeconds'}}','line_number':521,'multiline':False]['text':' predicate which will be helpful in reducing bounds for index scans on 'time'','line_number':522,'multiline':False]['text':' field and routing on mongos.','line_number':523,'multiline':False]['text':'','line_number':524,'multiline':False]['text':' The same procedure applies to aggregation expressions of the form','line_number':525,'multiline':False]['text':' {$expr: {$gt: [...]}} that can be rewritten to use $_internalExprGt.','line_number':526,'multiline':False]['text':' For $gte, make a $gte predicate against 'control.max'. In addition, since the','line_number':537,'multiline':False]['text':' collection doesn't contain times outside the 32 bit range, include a predicate','line_number':538,'multiline':False]['text':' against the _id field which is converted to the minimum for the corresponding','line_number':539,'multiline':False]['text':' range of ObjectIds and is adjusted by the max range for a bucket to approximate','line_number':540,'multiline':False]['text':' the max bucket value given the min. In addition, we include a {'control.min' :','line_number':541,'multiline':False]['text':' {$gte: 'time - bucketMaxSpanSeconds'}} predicate which will be helpful in','line_number':542,'multiline':False]['text':' reducing bounds for index scans on 'time' field and routing on mongos.','line_number':543,'multiline':False]['text':'','line_number':544,'multiline':False]['text':' The same procedure applies to aggregation expressions of the form','line_number':545,'multiline':False]['text':' {$expr: {$gte: [...]}} that can be rewritten to use $_internalExprGte.','line_number':546,'multiline':False]['text':' For $lt, make a $lt predicate against 'control.min'. The comparison is against','line_number':558,'multiline':False]['text':' the 'time' field, so we include a predicate against the _id field which is','line_number':559,'multiline':False]['text':' converted to the minimum for the corresponding range of ObjectIds, unless the','line_number':560,'multiline':False]['text':' collection contain extended range dates which won't fit int the 32 bits allocated','line_number':561,'multiline':False]['text':' for _id.','line_number':562,'multiline':False]['text':'','line_number':563,'multiline':False]['text':' In addition, we include a {'control.max' : {$lt: 'time + bucketMaxSpanSeconds'}}','line_number':564,'multiline':False]['text':' predicate which will be helpful in reducing bounds for index scans on 'time'','line_number':565,'multiline':False]['text':' field and routing on mongos.','line_number':566,'multiline':False]['text':'','line_number':567,'multiline':False]['text':' The same procedure applies to aggregation expressions of the form','line_number':568,'multiline':False]['text':' {$expr: {$lt: [...]}} that can be rewritten to use $_internalExprLt.','line_number':569,'multiline':False]['text':' For $lte, make a $lte predicate against 'control.min'. In addition, if the','line_number':582,'multiline':False]['text':' collection doesn't contain times outside the 32 bit range, include a predicate','line_number':583,'multiline':False]['text':' against the _id field which is converted to the maximum for the corresponding','line_number':584,'multiline':False]['text':' range of ObjectIds. In addition, we include a {'control.max' : {$lte: 'time +','line_number':585,'multiline':False]['text':' bucketMaxSpanSeconds'}} predicate which will be helpful in reducing bounds for','line_number':586,'multiline':False]['text':' index scans on 'time' field and routing on mongos.','line_number':587,'multiline':False]['text':'','line_number':588,'multiline':False]['text':' The same procedure applies to aggregation expressions of the form','line_number':589,'multiline':False]['text':' {$expr: {$lte: [...]}} that can be rewritten to use $_internalExprLte.','line_number':590,'multiline':False]['text':' The date is in the "extended" range if it doesn't fit into the bottom 32 bits.','line_number':666,'multiline':False]['text':' For some queries with fixed buckets, we do not need to filter individual measurements or','line_number':674,'multiline':False]['text':' whole buckets, because it is guaranteed that all buckets returned from the index scan','line_number':675,'multiline':False]['text':' will only hold relevant measurements if the predicate aligns with the bucket boundaries.','line_number':676,'multiline':False]['text':' This is only true for predicates that only use $gte, and $lt. For $gt, $lte, and $eq we','line_number':677,'multiline':False]['text':' still need an eventFilter to correctly return relevant measurements. For example, for the','line_number':678,'multiline':False]['text':' predicate {$gt: 10:00} with bucketMaxSpanSeconds at 3600, the bucket spanning from','line_number':679,'multiline':False]['text':' 10:00-11:00 will hold relevant measurements, but we need the eventFilter to filter out values','line_number':680,'multiline':False]['text':' equal to 10:00 in the bucket. Similarly, for {$lte: 10:00}, the bucket 10:00-11:00 could have','line_number':681,'multiline':False]['text':' values equal to 10:00, but we need the eventFilter to remove values greater than 10:00.','line_number':682,'multiline':False]['text':' For $eq, make both a $lte against 'control.min' and a $gte predicate against','line_number':689,'multiline':False]['text':' 'control.max'.','line_number':690,'multiline':False]['text':'','line_number':691,'multiline':False]['text':' Since we haven't stored a time outside of the 32 bit range, we include a','line_number':692,'multiline':False]['text':' predicate against the _id field which is converted to the maximum for the','line_number':693,'multiline':False]['text':' corresponding range of ObjectIds and is adjusted by the max range for a bucket to','line_number':694,'multiline':False]['text':' approximate the max bucket value given the min. Also include a predicate against','line_number':695,'multiline':False]['text':' the _id field which is converted to the minimum for the range of ObjectIds','line_number':696,'multiline':False]['text':' corresponding to the given date. In addition, we include a {'control.min' :','line_number':697,'multiline':False]['text':' {$gte: 'time - bucketMaxSpanSeconds'}} and a {'control.max' : {$lte: 'time +','line_number':698,'multiline':False]['text':' bucketMaxSpanSeconds'}} predicate which will be helpful in reducing bounds for','line_number':699,'multiline':False]['text':' index scans on 'time' field and routing on mongos.','line_number':700,'multiline':False]['text':' For $gt, make a $gt predicate against 'control.max'. If the collection doesn't','line_number':718,'multiline':False]['text':' contain times outside the 32 bit range, include a predicate against the _id field','line_number':719,'multiline':False]['text':' which is converted to the maximum for the corresponding range of ObjectIds and is','line_number':720,'multiline':False]['text':' adjusted by the max range for a bucket to approximate the max bucket value given','line_number':721,'multiline':False]['text':' the min.','line_number':722,'multiline':False]['text':'','line_number':723,'multiline':False]['text':' In addition, we include a {'control.min' : {$gt: 'roundedTime'}} where','line_number':724,'multiline':False]['text':' 'roundedTime' is 'time' rounded down by bucketRoundingSeconds predicate which','line_number':725,'multiline':False]['text':' will be helpful in reducing bounds for index scans on 'time' field and routing on','line_number':726,'multiline':False]['text':' mongos.','line_number':727,'multiline':False]['text':'','line_number':728,'multiline':False]['text':' The same procedure applies to aggregation expressions of the form','line_number':729,'multiline':False]['text':' {$expr: {$gt: [...]}} that can be rewritten to use $_internalExprGt.','line_number':730,'multiline':False]['text':' For $gte, make a $gte predicate against 'control.max'. In addition, since the','line_number':741,'multiline':False]['text':' collection doesn't contain times outside the 32 bit range, include a predicate','line_number':742,'multiline':False]['text':' against the _id field which is converted to the minimum for the corresponding','line_number':743,'multiline':False]['text':' range of ObjectIds and is adjusted by the max range for a bucket to approximate','line_number':744,'multiline':False]['text':' the max bucket value given the min. In addition, we include a {'control.min' :','line_number':745,'multiline':False]['text':' {$gt: 'roundedTime'}} where 'roundedTime' is 'time' rounded down by','line_number':746,'multiline':False]['text':' bucketRoundingSeconds predicate which will be helpful in reducing bounds for','line_number':747,'multiline':False]['text':' index scans on 'time' field and routing on mongos.','line_number':748,'multiline':False]['text':'','line_number':749,'multiline':False]['text':' The same procedure applies to aggregation expressions of the form','line_number':750,'multiline':False]['text':' {$expr: {$gte: [...]}} that can be rewritten to use $_internalExprGte.','line_number':751,'multiline':False]['text':' For $lt, make a $lt predicate against 'control.min'. The comparison is against','line_number':763,'multiline':False]['text':' the 'time' field, so we include a predicate against the _id field which is','line_number':764,'multiline':False]['text':' converted to the minimum for the corresponding range of ObjectIds, unless the','line_number':765,'multiline':False]['text':' collection contain extended range dates which won't fit int the 32 bits allocated','line_number':766,'multiline':False]['text':' for _id.','line_number':767,'multiline':False]['text':'','line_number':768,'multiline':False]['text':' In addition, we include a {'control.max' : {$lt: 'time + bucketMaxSpanSeconds'}}','line_number':769,'multiline':False]['text':' predicate which will be helpful in reducing bounds for index scans on 'time'','line_number':770,'multiline':False]['text':' field and routing on mongos.','line_number':771,'multiline':False]['text':'','line_number':772,'multiline':False]['text':' The same procedure applies to aggregation expressions of the form','line_number':773,'multiline':False]['text':' {$expr: {$lt: [...]}} that can be rewritten to use $_internalExprLt.','line_number':774,'multiline':False]['text':' For $lte, make a $lte predicate against 'control.min'. In addition, if the','line_number':786,'multiline':False]['text':' collection doesn't contain times outside the 32 bit range, include a predicate','line_number':787,'multiline':False]['text':' against the _id field which is converted to the maximum for the corresponding','line_number':788,'multiline':False]['text':' range of ObjectIds. In addition, we include a {'control.max' : {$lte: 'time +','line_number':789,'multiline':False]['text':' bucketMaxSpanSeconds'}} predicate which will be helpful in reducing bounds for','line_number':790,'multiline':False]['text':' index scans on 'time' field and routing on mongos.','line_number':791,'multiline':False]['text':'','line_number':792,'multiline':False]['text':' The same procedure applies to aggregation expressions of the form','line_number':793,'multiline':False]['text':' {$expr: {$lte: [...]}} that can be rewritten to use $_internalExprLte.','line_number':794,'multiline':False]['text':' namespace timeseries','line_number':821,'multiline':False]['text':' namespace mongo','line_number':822,'multiline':False]