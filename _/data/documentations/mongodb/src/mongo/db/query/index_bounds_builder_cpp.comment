['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':36,'multiline':False]['text':' Helper for checking that an OIL "appears" to be ascending given one interval.','line_number':86,'multiline':False]['text':' Each individual interval being examined should be ascending or none.','line_number':88,'multiline':False]['text':' Should be either ascending, or have no direction (be a point/null/empty interval).','line_number':91,'multiline':False]['text':' The previous OIL's end value should be <= the next OIL's start value.','line_number':95,'multiline':False]['text':' Pass 'false' to avoid comparing the field names.','line_number':97,'multiline':False]['text':' Tightness rules are shared for $lt, $lte, $gt, $gte.','line_number':103,'multiline':False]['text':' Any time the bounds are empty, we consider them to be exact.','line_number':108,'multiline':False]['text':'*
 * This helper updates the query bounds tightness for the limited set of conditions where we see a
 * null query that can be covered.
 ','line_number':132,'multiline':True]['text':' Sparse indexes and hashed indexes require a FETCH stage with a filter for null queries.','line_number':139,'multiline':False]['text':' If we have a simple equality null query and our index is multikey, we cannot cover the','line_number':145,'multiline':False]['text':' query. This is because null intervals are translated into the null and undefined point','line_number':146,'multiline':False]['text':' intervals, and the undefined point interval includes entries for []. In the case of a','line_number':147,'multiline':False]['text':' single null interval, [] should not match.','line_number':148,'multiline':False]['text':' The query may be fully covered by the index if the projection allows it, since the case above','line_number':153,'multiline':False]['text':' about the empty array can only become an issue if there is an empty array present, which','line_number':154,'multiline':False]['text':' would mark the index as multikey.','line_number':155,'multiline':False]['text':' There are two values that could possibly be equal to null in an index: undefined and null.','line_number':165,'multiline':False]['text':' Just to be sure, make sure the bounds are in the right order if the hash values are opposite.','line_number':169,'multiline':False]['text':' Because of type-bracketing, {$gte: null} and {$lte: null} are equivalent to {$eq: null}.','line_number':174,'multiline':False]['text':' namespace','line_number':188,'multiline':False]['text':' Bounds building for simple regular expressions assumes that the index is in ASCII order,','line_number':195,'multiline':False]['text':' which is not necessarily true for an index with a collator.  Therefore, a regex can never','line_number':196,'multiline':False]['text':' use tight bounds if the index has a non-null collator. In this case, the regex must be','line_number':197,'multiline':False]['text':' applied to the fetched document rather than the index key, so the tightness is','line_number':198,'multiline':False]['text':' INEXACT_FETCH.','line_number':199,'multiline':False]['text':' ARGH, BSONValue would make this shorter.','line_number':210,'multiline':False]['text':' The start and end are equal.','line_number':239,'multiline':False]['text':' Strict weak requires irreflexivity which implies that equivalence returns false.','line_number':240,'multiline':False]['text':' Put the bound that's inclusive to the left.','line_number':245,'multiline':False]['text':' static','line_number':249,'multiline':False]['text':' translate outputs arg in sorted order.  intersectize assumes that its arguments are','line_number':259,'multiline':False]['text':' sorted.','line_number':260,'multiline':False]['text':' static','line_number':268,'multiline':False]['text':' Append the new intervals to oilOut.','line_number':278,'multiline':False]['text':' Union the appended intervals with the existing ones.','line_number':281,'multiline':False]['text':' iet::Builder ','line_number':302,'multiline':True]['text':' We have additional tightness values (MAYBE_COVERED), but we cannot generally cover those','line_number':303,'multiline':False]['text':' cases unless we have an appropriate projection.','line_number':304,'multiline':False]['text':' static','line_number':309,'multiline':False]['text':' Fill out the bounds and tightness appropriate for the given predicate.','line_number':316,'multiline':False]['text':' Under certain circumstances, queries on a $** index require that the bounds' tightness be','line_number':319,'multiline':False]['text':' adjusted regardless of the predicate. Having filled out the initial bounds, we apply any','line_number':320,'multiline':False]['text':' necessary changes to the tightness here.','line_number':321,'multiline':False]['text':' Check if 'elt' is the wildcard field.','line_number':323,'multiline':False]['text':' Adjust index bounds and tightness only if the index bounds generated are for the wildcard','line_number':326,'multiline':False]['text':' field.','line_number':327,'multiline':False]['text':'ietBuilder','line_number':340,'multiline':True]['text':' The Array case will not be handled because a typeSet with Array should not reach this','line_number':346,'multiline':False]['text':' function','line_number':347,'multiline':False]['text':' The String and Object types with collation require an inexact fetch.','line_number':350,'multiline':False]['text':' Null and Undefined Types always require an inexact fetch.','line_number':356,'multiline':False]['text':' Checks that either all the number types are present or "number" is present in the type set.','line_number':366,'multiline':False]['text':' This check is effectively typeSet.hasType(BSONType::String) XOR','line_number':374,'multiline':False]['text':' typeSet.hasType(BSONType::Symbol).','line_number':375,'multiline':False]['text':' Contains all the logic for determining bounds of a LT or LTE query.','line_number':383,'multiline':False]['text':' Use -infinity for one-sided numerical bounds','line_number':387,'multiline':False]['text':' For comparison to an array, we do lexicographic comparisons. In a multikey index, the','line_number':391,'multiline':False]['text':' index entries are the array elements themselves. We must therefore look at all types, and','line_number':392,'multiline':False]['text':' all values between MinKey and the first element in the array.','line_number':393,'multiline':False]['text':' The empty array is the lowest array.','line_number':405,'multiline':False]['text':' If the type of the element is greater than the type of the array, the bounds have to','line_number':408,'multiline':False]['text':' include that element. Otherwise the array type, and therefore `dataElt` is','line_number':409,'multiline':False]['text':' sufficiently large to include all relevant keys.','line_number':410,'multiline':False]['text':' If the array is empty, we need bounds that will match all arrays. Unfortunately,','line_number':425,'multiline':False]['text':' this means that we have to check the entire index, as any array could have a key','line_number':426,'multiline':False]['text':' anywhere in the multikey index.','line_number':427,'multiline':False]['text':' If the type of the element is smaller than the type of the array, the bounds need','line_number':430,'multiline':False]['text':' to extend to that element. Otherwise the array type, and therefore `dataElt` is','line_number':431,'multiline':False]['text':' sufficiently large include all relevant keys.','line_number':432,'multiline':False]['text':' For comparison to an array, we do lexicographic comparisons. In a multikey index, the','line_number':445,'multiline':False]['text':' index entries are the array elements themselves. We must therefore look at all types, and','line_number':446,'multiline':False]['text':' all values between the first element in the array and MaxKey.','line_number':447,'multiline':False]['text':' namespace','line_number':455,'multiline':False]['text':' This isn't a null query.','line_number':467,'multiline':False]['text':' Sparse indexes and hashed indexes still require a FETCH stage with a filter for null','line_number':472,'multiline':False]['text':' queries.','line_number':473,'multiline':False]['text':' Given the context of having a null $in query with eligible indexes, we may be able to cover','line_number':477,'multiline':False]['text':' some combinations of intervals that we could not cover individually.','line_number':478,'multiline':False]['text':' If the path has multiple components and we have a multikey index, we still need a FETCH','line_number':480,'multiline':False]['text':' in order to defend against cases where we have a multikey index on "a". These documents','line_number':481,'multiline':False]['text':' will generate null index keys: {"a.b": null} and {a: [1,2,3]}. However, a query like','line_number':482,'multiline':False]['text':' {"a.b": {$in: [null, []]}} should not match {a: [1, 2, 3]}.','line_number':483,'multiline':False]['text':' TODO SERVER-71021: it may be possible to cover more cases here.','line_number':484,'multiline':False]['text':' We must have an equality to an empty array for this null query to be covered, otherwise,','line_number':489,'multiline':False]['text':' because we generate both null and undefined point intervals for a null query, and because','line_number':490,'multiline':False]['text':' a multikey index reuses the same entry for [] and undefined, we will not be able to cover','line_number':491,'multiline':False]['text':' the query.','line_number':492,'multiline':False]['text':' There is a special case where we may have a covered null query (EXACT_MAYBE_COVERED) and a','line_number':503,'multiline':False]['text':' regex with inexact bounds that doesn't need a FETCH (INEXACT_COVERED). In this case, we want','line_number':504,'multiline':False]['text':' to update the tightness to INEXACT_MAYBE_COVERED, to indicate that we need to check if the','line_number':505,'multiline':False]['text':' projection allows us to cover the query, but ensure that we will have a filter on the index','line_number':506,'multiline':False]['text':' if it turns out we can.','line_number':507,'multiline':False]['text':' Otherwise, fallback to picking the new tightness if it is looser than the old tightness.','line_number':514,'multiline':False]['text':' We expect that the OIL we are constructing starts out empty.','line_number':525,'multiline':False]['text':' We should never be asked to translate an unsupported predicate for a hashed index.','line_number':535,'multiline':False]['text':' $elemMatch value requires an array.','line_number':552,'multiline':False]['text':' Scalars and directly nested objects are not matched with $elemMatch.','line_number':553,'multiline':False]['text':' We can't tell if a multi-key index key is derived from an array field.','line_number':554,'multiline':False]['text':' Therefore, a fetch is required.','line_number':555,'multiline':False]['text':' A NOT is indexed by virtue of its child. If we're here then the NOT's child','line_number':558,'multiline':False]['text':' must be a kind of node for which we can index negations. It can't be things like','line_number':559,'multiline':False]['text':' $mod, $regex, or $type.','line_number':560,'multiline':False]['text':' If we have a NOT -> EXISTS, we must handle separately.','line_number':563,'multiline':False]['text':' We should never try to use a sparse index for $exists:false.','line_number':565,'multiline':False]['text':' {$exists:false} is a point-interval on [null,null] that requires a fetch.','line_number':567,'multiline':False]['text':' This is a special type of query of the following shape: {a: {$not: {$in:','line_number':585,'multiline':False]['text':' [null, []]}}}. We never auto-parameterize such query according to our','line_number':586,'multiline':False]['text':' encoding rules (due to presence of null and an array elements).','line_number':587,'multiline':False]['text':' Until the index distinguishes between missing values and literal null values, we cannot','line_number':603,'multiline':False]['text':' build exact bounds for equality predicates on the literal value null. However, we _can_','line_number':604,'multiline':False]['text':' build exact bounds for the inverse, for example the query {a: {$ne: null}}.','line_number':605,'multiline':False]['text':' Generally speaking inverting bounds can only be done for exact bounds. Any looser bounds','line_number':610,'multiline':False]['text':' (like INEXACT_FETCH) would signal that inversion would be mistakenly excluding some','line_number':611,'multiline':False]['text':' values. One exception is for collation, whose index bounds are tracked as INEXACT_FETCH,','line_number':612,'multiline':False]['text':' but only because the index data is different than the user data, not because the range','line_number':613,'multiline':False]['text':' is imprecise.','line_number':614,'multiline':False]['text':' If the index is multikey on this path, it doesn't matter what the tightness of the child','line_number':619,'multiline':False]['text':' is, we must return INEXACT_FETCH. Consider a multikey index on 'a' with document','line_number':620,'multiline':False]['text':' {a: [1, 2, 3]} and query {a: {$ne: 3}}. If we treated the bounds [MinKey, 3), (3, MaxKey]','line_number':621,'multiline':False]['text':' as exact, then we would erroneously return the document!','line_number':622,'multiline':False]['text':' We only handle the {$exists:true} case, as {$exists:false}','line_number':632,'multiline':False]['text':' will have been translated to {$not:{ $exists:true }}.','line_number':633,'multiline':False]['text':'','line_number':634,'multiline':False]['text':' Documents with a missing value are stored *as if* they were','line_number':635,'multiline':False]['text':' explicitly given the value 'null'.  Given:','line_number':636,'multiline':False]['text':'    X = { b : 1 }','line_number':637,'multiline':False]['text':'    Y = { a : null, b : 1 }','line_number':638,'multiline':False]['text':' X and Y look identical from within a standard index on { a : 1 }.','line_number':639,'multiline':False]['text':' HOWEVER a sparse index on { a : 1 } will treat X and Y differently,','line_number':640,'multiline':False]['text':' storing Y and not storing X.','line_number':641,'multiline':False]['text':'','line_number':642,'multiline':False]['text':' We can safely use an index in the following cases:','line_number':643,'multiline':False]['text':' {a:{ $exists:true }} - normal index helps, but we must still fetch','line_number':644,'multiline':False]['text':' {a:{ $exists:true }} - hashed index helps, but we must still fetch','line_number':645,'multiline':False]['text':' {a:{ $exists:true }} - sparse index is exact','line_number':646,'multiline':False]['text':' {a:{ $exists:false }} - normal index requires a fetch','line_number':647,'multiline':False]['text':' {a:{ $exists:false }} - hashed index requires a fetch','line_number':648,'multiline':False]['text':' {a:{ $exists:false }} - sparse indexes cannot be used at all.','line_number':649,'multiline':False]['text':'','line_number':650,'multiline':False]['text':' Noted in SERVER-12869, in case this ever changes some day.','line_number':651,'multiline':False]['text':' A sparse, compound index on { a:1, b:1 } will include entries','line_number':653,'multiline':False]['text':' for all of the following documents:','line_number':654,'multiline':False]['text':'    { a:1 }, { b:1 }, { a:1, b:1 }','line_number':655,'multiline':False]['text':' So we must use INEXACT bounds in this case.','line_number':656,'multiline':False]['text':' There is no need to sort intervals or merge overlapping intervals here since the output','line_number':667,'multiline':False]['text':' is from one element.','line_number':668,'multiline':False]['text':' Adding const node here since we do not auto-parameterise comparisons expressed','line_number':675,'multiline':False]['text':' using $expr.','line_number':676,'multiline':False]['text':' Everything is < MaxKey, except for MaxKey. However the bounds need to be inclusive to','line_number':695,'multiline':False]['text':' find the array [MaxKey] which is smaller for a comparison but equal in a multikey index.','line_number':696,'multiline':False]['text':' Nothing is < NaN.','line_number':705,'multiline':False]['text':' If the operand to LT is equal to the lower bound X, the interval [X, X) is invalid','line_number':721,'multiline':False]['text':' and should not be added to the bounds.','line_number':722,'multiline':False]['text':' Unlike the regular $lt match expression, $_internalExprLt does not make special checks','line_number':738,'multiline':False]['text':' for when dataElt is MaxKey or NaN because it doesn't do type bracketing for any operand.','line_number':739,'multiline':False]['text':' Another difference is that $internalExprLt predicates on multikey paths will not use an','line_number':740,'multiline':False]['text':' index.','line_number':741,'multiline':False]['text':' Generally all intervals for $_internalExprLt will exclude the end key, however because','line_number':751,'multiline':False]['text':' null and missing are conflated in the index but treated as distinct values for','line_number':752,'multiline':False]['text':' expressions (with missing ordered as less than null), when dataElt is null we must build','line_number':753,'multiline':False]['text':' index bounds [MinKey, null] to include missing values and filter out the literal null','line_number':754,'multiline':False]['text':' values with an INEXACT_FETCH.','line_number':755,'multiline':False]['text':' If the operand to $_internalExprLt is equal to the lower bound X, the interval [X, X) is','line_number':759,'multiline':False]['text':' invalid and should not be added to the bounds. Because $_internalExprLt doesn't perform','line_number':760,'multiline':False]['text':' type bracketing, here we need to avoid adding the interval [MinKey, MinKey).','line_number':761,'multiline':False]['text':' Everything is <= MaxKey.','line_number':776,'multiline':False]['text':' Only NaN is <= NaN.','line_number':784,'multiline':False]['text':' Because of type-bracketing, $lte null is equivalent to $eq null. An equality to null','line_number':793,'multiline':False]['text':' query is special. It should return both undefined and null values.','line_number':794,'multiline':False]['text':' Unlike the regular $lte match expression, $_internalExprLte does not make special checks','line_number':820,'multiline':False]['text':' for when dataElt is MaxKey or NaN because it doesn't do type bracketing for any operand.','line_number':821,'multiline':False]['text':' Another difference is that $internalExprLte predicates on multikey paths will not use an','line_number':822,'multiline':False]['text':' index.','line_number':823,'multiline':False]['text':' Expressions treat null and missing as distinct values, with missing ordered as less than','line_number':836,'multiline':False]['text':' null. Thus for $_internalExprLte when dataElt is null we can treat the bounds as EXACT,','line_number':837,'multiline':False]['text':' since both null and missing values should be included.','line_number':838,'multiline':False]['text':' Everything is > MinKey, except MinKey. However the bounds need to be inclusive to find','line_number':855,'multiline':False]['text':' the array [MinKey], which is larger for a comparison but equal in a multikey index.','line_number':856,'multiline':False]['text':' Nothing is > NaN.','line_number':865,'multiline':False]['text':' If the operand to GT is equal to the upper bound X, the interval (X, X] is invalid','line_number':881,'multiline':False]['text':' and should not be added to the bounds.','line_number':882,'multiline':False]['text':' Unlike the regular $gt match expression, $_internalExprGt does not make special checks','line_number':897,'multiline':False]['text':' for when dataElt is MinKey or NaN because it doesn't do type bracketing for any operand.','line_number':898,'multiline':False]['text':' Another difference is that $internalExprGt predicates on multikey paths will not use an','line_number':899,'multiline':False]['text':' index.','line_number':900,'multiline':False]['text':' If the operand to $_internalExprGt is equal to the upper bound X, the interval (X, X] is','line_number':912,'multiline':False]['text':' invalid and should not be added to the bounds. Because $_internalExprGt doesn't perform','line_number':913,'multiline':False]['text':' type bracketing, here we need to avoid adding the interval (MaxKey, MaxKey].','line_number':914,'multiline':False]['text':' Expressions treat null and missing as distinct values, with missing ordered as less than','line_number':919,'multiline':False]['text':' null. Thus for $_internalExprGt when dataElt is null we can treat the bounds as EXACT,','line_number':920,'multiline':False]['text':' since both null and missing values should be excluded.','line_number':921,'multiline':False]['text':' Everything is >= MinKey.','line_number':938,'multiline':False]['text':' Only NaN is >= NaN.','line_number':946,'multiline':False]['text':' Because of type-bracketing, $lte null is equivalent to $eq null. An equality to null','line_number':955,'multiline':False]['text':' query is special. It should return both undefined and null values.','line_number':956,'multiline':False]['text':' Unlike the regular $gte match expression, $_internalExprGte does not make special checks','line_number':980,'multiline':False]['text':' for when dataElt is MinKey or NaN because it doesn't do type bracketing for any operand.','line_number':981,'multiline':False]['text':' Another difference is that $internalExprGte predicates on multikey paths will not use an','line_number':982,'multiline':False]['text':' index.','line_number':983,'multiline':False]['text':' Technically this could be EXACT_FETCH, if such a thing existed. But we don't need to','line_number':1011,'multiline':False]['text':' optimize this that much.','line_number':1012,'multiline':False]['text':' We have $type:"array". Since arrays are indexed by creating a key for each element,','line_number':1044,'multiline':False]['text':' we have to fetch all indexed documents and check whether the full document contains','line_number':1045,'multiline':False]['text':' an array.','line_number':1046,'multiline':False]['text':' If we are matching all numbers, we just use the bounds for NumberInt, as these bounds','line_number':1052,'multiline':False]['text':' also include all NumberDouble and NumberLong values.','line_number':1053,'multiline':False]['text':' Types with variable width use the smallest value of the next type as their upper','line_number':1067,'multiline':False]['text':' bound, so the upper bound needs to be excluded.','line_number':1068,'multiline':False]['text':' Sort the intervals, and merge redundant ones.','line_number':1078,'multiline':False]['text':' Create our various intervals.','line_number':1090,'multiline':False]['text':' We check if the $in predicate satisfies conditions to be a covered null predicate on the','line_number':1093,'multiline':False]['text':' basis of indexes, null intervals, and array intervals.','line_number':1094,'multiline':False]['text':' First, we generate the bounds the same way that we would do for an individual','line_number':1098,'multiline':False]['text':' equality. This will set tightness to the value it should be if this equality is being','line_number':1099,'multiline':False]['text':' considered in isolation.','line_number':1100,'multiline':False]['text':' We may have a covered null query. In this case, we update both empty array and','line_number':1105,'multiline':False]['text':' null interval tightness to EXACT_MAYBE_COVERED, as individually they would have a','line_number':1106,'multiline':False]['text':' tightness of INEXACT_FETCH. However, we already know we will be able to cover','line_number':1107,'multiline':False]['text':' these intervals together if we have appropriate projections. Note that any other','line_number':1108,'multiline':False]['text':' intervals that cannot be covered may still require the query to use a FETCH.','line_number':1109,'multiline':False]['text':' Equalities are already sorted and deduped so unionize is unneccesary if no regexes','line_number':1120,'multiline':False]['text':' are present. Hashed indexes may also cause the bounds to be out-of-order.','line_number':1121,'multiline':False]['text':' Arrays and nulls introduce multiple elements that necessitate a sort and deduping.','line_number':1122,'multiline':False]['text':' static','line_number':1176,'multiline':False]['text':' static','line_number':1190,'multiline':False]['text':' Ensure that both OILs are ascending.','line_number':1205,'multiline':False]['text':' oilAIntervals is before oilBIntervals. move oilAIntervals forward.','line_number':1214,'multiline':False]['text':' oilBIntervals is before oilAIntervals. move oilBIntervals forward.','line_number':1217,'multiline':False]['text':' static','line_number':1244,'multiline':False]['text':' This can happen.','line_number':1248,'multiline':False]['text':' Step 1: sort.','line_number':1253,'multiline':False]['text':' Step 2: Walk through and merge.','line_number':1256,'multiline':False]['text':' Compare i with i + 1.','line_number':1259,'multiline':False]['text':' This means our sort didn't work.','line_number':1262,'multiline':False]['text':' Intervals are correctly ordered.','line_number':1265,'multiline':False]['text':' We can move to the next pair.','line_number':1267,'multiline':False]['text':' Interval 'i' is equal to i+1, or is contained within i+1.','line_number':1270,'multiline':False]['text':' Remove interval i and don't move to the next value of 'i'.','line_number':1271,'multiline':False]['text':' Interval 'i' contains i+1, remove i+1 and don't move to the next value of 'i'.','line_number':1274,'multiline':False]['text':' We want to merge intervals i and i+1.','line_number':1278,'multiline':False]['text':' Interval 'i' starts before interval 'i+1'.','line_number':1279,'multiline':False]['text':' iv[i] is now the former iv[i + 1]','line_number':1287,'multiline':False]['text':' Don't increment 'i'.','line_number':1290,'multiline':False]['text':' static','line_number':1295,'multiline':False]['text':' static','line_number':1305,'multiline':False]['text':' static','line_number':1314,'multiline':False]['text':' static','line_number':1321,'multiline':False]['text':' static','line_number':1328,'multiline':False]['text':' static','line_number':1336,'multiline':False]['text':' static','line_number':1347,'multiline':False]['text':' Note that 'tightnessOut' is set by simpleRegex above.','line_number':1355,'multiline':False]['text':' Regexes are after strings.','line_number':1371,'multiline':False]['text':' static','line_number':1377,'multiline':False]['text':' An equality to null query is special. It should return both undefined and null values, so','line_number':1384,'multiline':False]['text':' is not a point query.','line_number':1385,'multiline':False]['text':' We have to copy the data out of the parse tree and stuff it into the index','line_number':1389,'multiline':False]['text':' bounds.  BSONValue will be useful here.','line_number':1390,'multiline':False]['text':' If we're here, Array == data.type().','line_number':1408,'multiline':False]['text':'','line_number':1409,'multiline':False]['text':' Using arrays with hashed indices is currently not supported, so we don't have to worry','line_number':1410,'multiline':False]['text':' about that case.','line_number':1411,'multiline':False]['text':'','line_number':1412,'multiline':False]['text':' Arrays are indexed by either:','line_number':1413,'multiline':False]['text':'','line_number':1414,'multiline':False]['text':' 1. the first element if there is one.  Note that using the first is arbitrary; we could','line_number':1415,'multiline':False]['text':' just as well use any array element.). If the query is {a: [1, 2, 3]}, for example, then','line_number':1416,'multiline':False]['text':' using the bounds [1, 1] for the multikey index will pick up every document containing the','line_number':1417,'multiline':False]['text':' array [1, 2, 3].','line_number':1418,'multiline':False]['text':'','line_number':1419,'multiline':False]['text':' 2. undefined if the array is empty.','line_number':1420,'multiline':False]['text':'','line_number':1421,'multiline':False]['text':' Also, arrays are indexed by:','line_number':1422,'multiline':False]['text':'','line_number':1423,'multiline':False]['text':' 3. the full array if it's inside of another array.  We check for this so that the query','line_number':1424,'multiline':False]['text':' {a: [1, 2, 3]} will match documents like {a: [[1, 2, 3], 4, 5]}.','line_number':1425,'multiline':False]['text':' Case 3.','line_number':1427,'multiline':False]['text':' Case 2.','line_number':1431,'multiline':False]['text':' Case 1.','line_number':1436,'multiline':False]['text':' static','line_number':1446,'multiline':False]['text':' static','line_number':1462,'multiline':False]['text':' The canonical check as to whether a key pattern element is "ascending" or "descending" is','line_number':1471,'multiline':False]['text':' (elt.number() >= 0). This is defined by the Ordering class.','line_number':1472,'multiline':False]['text':' Must be min->max or max->min.','line_number':1499,'multiline':False]['text':' As an example for the logic below, consider the index {a:1, b:1} and a count for','line_number':1501,'multiline':False]['text':' {a: {$gt: 2}}.  Our start key isn't inclusive (as it's $gt: 2) and looks like','line_number':1502,'multiline':False]['text':' {"":2} so far.  If we move to the key greater than {"":2, "": MaxKey} we will get','line_number':1503,'multiline':False]['text':' the first value of 'a' that is greater than 2.','line_number':1504,'multiline':False]['text':' In this case, consider the index {a:1, b:1} and a count for {a:{$gte: 2}}.','line_number':1508,'multiline':False]['text':' We want to look at all values where a is 2, so our start key is {"":2,','line_number':1509,'multiline':False]['text':' "":MinKey}.','line_number':1510,'multiline':False]['text':' Same deal as above.  Consider the index {a:1, b:1} and a count for {a: {$lt: 2}}.','line_number':1514,'multiline':False]['text':' Our end key isn't inclusive as ($lt: 2) and looks like {"":2} so far.  We can't','line_number':1515,'multiline':False]['text':' look at any values where a is 2 so we have to stop at {"":2, "": MinKey} as','line_number':1516,'multiline':False]['text':' that's the smallest key where a is still 2.','line_number':1517,'multiline':False]['text':' The reasoning here is the same as above but with the directions reversed.','line_number':1524,'multiline':False]['text':' static','line_number':1539,'multiline':False]['text':' We build our start/end keys as we go.','line_number':1545,'multiline':False]['text':' The start and end keys are inclusive unless we have a non-point interval, in which case','line_number':1549,'multiline':False]['text':' we take the inclusivity from there.','line_number':1550,'multiline':False]['text':' First, we skip over point intervals.','line_number':1556,'multiline':False]['text':' A point interval requires just one interval...','line_number':1559,'multiline':False]['text':' Since it's a point, start == end.','line_number':1566,'multiline':False]['text':' All our intervals are points.  We count for all values of one field.','line_number':1572,'multiline':False]['text':' After point intervals we can have exactly one non-point interval.','line_number':1578,'multiline':False]['text':' Add the non-point interval to our builder and set the inclusivity from it.','line_number':1584,'multiline':False]['text':' And after the non-point interval we can have any number of "all values" intervals.','line_number':1592,'multiline':False]['text':' "All Values" is just one point.','line_number':1595,'multiline':False]['text':' No dice.','line_number':1604,'multiline':False]['text':' static','line_number':1618,'multiline':False]['text':' Checks if the the intervals are [undefined, undefined] and [null, null].','line_number':1620,'multiline':False]['text':' Note: the order is always the same (see makeNullEqualityBounds()).','line_number':1621,'multiline':False]['text':' static','line_number':1626,'multiline':False]['text':' Checks if the the intervals are [undefined, undefined], [null, null], and [[], []]. These','line_number':1628,'multiline':False]['text':' will always be sorted in the above order during IndexBoundsBuilder::_translatePredicate().','line_number':1629,'multiline':False]['text':' namespace mongo','line_number':1635,'multiline':False]