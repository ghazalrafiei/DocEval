['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':'*
 * A specialization of the QueryPlannerTest fixture which makes it easy to present the planner with
 * a view of the available $** indexes.
 ','line_number':69,'multiline':True]['text':' We're interested in testing plans that use a $** index, so don't generate collection','line_number':78,'multiline':False]['text':' scans.','line_number':79,'multiline':False]['text':' Convert the set of std::string to a set of FieldRef.','line_number':89,'multiline':False]['text':' multikeyPaths','line_number':105,'multiline':False]['text':' sparse','line_number':107,'multiline':False]['text':' unique','line_number':108,'multiline':False]['text':'','line_number':119,'multiline':False]['text':' General planning tests.','line_number':120,'multiline':False]['text':'','line_number':121,'multiline':False]['text':' Expand the $** index and add the expanded entry to the list of available indices.','line_number':129,'multiline':False]['text':' Now run a query. This will tassert when the planner expands the expanded index.','line_number':135,'multiline':False]['text':'','line_number':139,'multiline':False]['text':' Null comparison and existence tests.','line_number':140,'multiline':False]['text':'','line_number':141,'multiline':False]['text':' "a.b.c" being multikey will prevent us from using the index since $elemMatch doesn't do','line_number':203,'multiline':False]['text':' implicit array traversal.','line_number':204,'multiline':False]['text':'','line_number':239,'multiline':False]['text':' Multikey planning tests.','line_number':240,'multiline':False]['text':'','line_number':241,'multiline':False]['text':'','line_number':661,'multiline':False]['text':' Array tests.','line_number':662,'multiline':False]['text':'','line_number':663,'multiline':False]['text':'','line_number':697,'multiline':False]['text':' $in tests.','line_number':698,'multiline':False]['text':'','line_number':699,'multiline':False]['text':' Logically equivalent to the preceding $in query.','line_number':733,'multiline':False]['text':' Indexed solution should be the same.','line_number':734,'multiline':False]['text':'','line_number':746,'multiline':False]['text':' Partial index tests.','line_number':747,'multiline':False]['text':'','line_number':748,'multiline':False]['text':' Must keep 'filterObj' around since match expressions will store pointers into the BSON they','line_number':778,'multiline':False]['text':' were parsed from.','line_number':779,'multiline':False]['text':' Test when the field query is not included by the partial filter expression.','line_number':799,'multiline':False]['text':'','line_number':826,'multiline':False]['text':' Index intersection tests.','line_number':827,'multiline':False]['text':'','line_number':828,'multiline':False]['text':' Enable both AND_SORTED and AND_HASH index intersection for this test.','line_number':831,'multiline':False]['text':' Add two standard single-field indexes.','line_number':835,'multiline':False]['text':' Run a point query on both fields and confirm that an AND_SORTED plan is generated.','line_number':839,'multiline':False]['text':' Three plans are generated: one IXSCAN for each index, and an AND_SORTED on both.','line_number':841,'multiline':False]['text':' Run a range query on both fields and confirm that an AND_HASH plan is generated.','line_number':851,'multiline':False]['text':' Three plans are generated: one IXSCAN for each index, and an AND_HASH on both.','line_number':853,'multiline':False]['text':' Now add a $** index and re-run the tests.','line_number':863,'multiline':False]['text':' First re-run the AND_SORTED test.','line_number':866,'multiline':False]['text':' Solution count has increased from 3 to 5, as $** 'duplicates' the {a:1} and {b:1} IXSCANS.','line_number':868,'multiline':False]['text':' The previous AND_SORTED solution is still present...','line_number':874,'multiline':False]['text':' ... but there are no additional AND_SORTED solutions contributed by the $** index.','line_number':878,'multiline':False]['text':' Now re-run the AND_HASH test.','line_number':884,'multiline':False]['text':' Solution count has increased from 3 to 5, as $** 'duplicates' the {a:1} and {b:1} IXSCANS.','line_number':886,'multiline':False]['text':' The previous AND_HASH solution is still present...','line_number':892,'multiline':False]['text':' ... but there are no additional AND_HASH solutions contributed by the $** index.','line_number':896,'multiline':False]['text':'','line_number':903,'multiline':False]['text':' Wildcard and $text index tests.','line_number':904,'multiline':False]['text':'','line_number':905,'multiline':False]['text':' Confirm that the wildcard index generates candidate plans for queries which do not include a','line_number':913,'multiline':False]['text':' $text predicate.','line_number':914,'multiline':False]['text':' Confirm that the wildcard index does not produce any candidate plans when a query includes a','line_number':922,'multiline':False]['text':' $text predicate, even for non-$text predicates which may be present in the query.','line_number':923,'multiline':False]['text':'','line_number':930,'multiline':False]['text':' Negation tests.','line_number':931,'multiline':False]['text':'','line_number':932,'multiline':False]['text':' Wildcard indexes can't support negation queries because they are sparse, and {a: {$ne: 5}}','line_number':935,'multiline':False]['text':' will match documents which don't have an "a" field.','line_number':936,'multiline':False]['text':' Logically, there's no reason a (sparse) wildcard index could not support a negation inside a','line_number':947,'multiline':False]['text':' "$elemMatch value", but it is not something we've implemented.','line_number':948,'multiline':False]['text':' Test the case where we use $elemMatch on a path which isn't even multikey. In this case,','line_number':958,'multiline':False]['text':' we'd know up front that the results would be empty, but this is not an optimization we','line_number':959,'multiline':False]['text':' support.','line_number':960,'multiline':False]['text':'','line_number':969,'multiline':False]['text':' Hinting with all paths index tests.','line_number':970,'multiline':False]['text':'','line_number':971,'multiline':False]['text':'','line_number':1062,'multiline':False]['text':' Object comparison tests.','line_number':1063,'multiline':False]['text':'','line_number':1064,'multiline':False]['text':' We can only use the index for the predicate on 'x'.','line_number':1075,'multiline':False]['text':'','line_number':1114,'multiline':False]['text':' Unsupported values tests.','line_number':1115,'multiline':False]['text':'','line_number':1116,'multiline':False]['text':' Simple case.','line_number':1132,'multiline':False]['text':' null inside an $in inside an $elemMatch is supported by the wildcard index, since it means','line_number':1137,'multiline':False]['text':' we're searching for an explicit null value.','line_number':1138,'multiline':False]['text':' An object or array inside an $in inside a $elemMatch is not supported by the index.','line_number':1148,'multiline':False]['text':'','line_number':1161,'multiline':False]['text':' Sorting tests.','line_number':1162,'multiline':False]['text':'','line_number':1163,'multiline':False]['text':' The non-blocking sort solution.','line_number':1181,'multiline':False]['text':' A blocking sort solution (by doing a scan with a filter on 'b').','line_number':1186,'multiline':False]['text':' Since there's no filter on the field that we're sorting by, we cannot use an index scan to','line_number':1232,'multiline':False]['text':' answer the query as $** indexes are sparse.','line_number':1233,'multiline':False]['text':'','line_number':1267,'multiline':False]['text':' Field name or array index tests.','line_number':1268,'multiline':False]['text':'','line_number':1269,'multiline':False]['text':' Queries whose path lies along a projected array index cannot be answered.','line_number':1274,'multiline':False]['text':' Queries on fields that are not projected array indices can be answered, even when such a','line_number':1287,'multiline':False]['text':' projection is present in the 'starPathsTempName' spec.','line_number':1288,'multiline':False]['text':' Queries on indices of arrays that have been projected in their entirety can be answered.','line_number':1295,'multiline':False]['text':' A numeric path component immediately following a multikey path may represent an array index,','line_number':1307,'multiline':False]['text':' a fieldname, or both. The $** index does not record array indices explicitly, so for all such','line_number':1308,'multiline':False]['text':' potential array indices in the query path, we generate bounds that both include and exclude','line_number':1309,'multiline':False]['text':' the numeric path components.','line_number':1310,'multiline':False]['text':' Ordinarily, a query such as {'a': {$gt: 0, $lt: 5}} on a multikey field 'a' produces an EXACT','line_number':1337,'multiline':False]['text':' IXSCAN on one of the predicates and a FETCH filter on the other. For fieldname-or-array-index','line_number':1338,'multiline':False]['text':' queries on 'a.0' or similar, however, *all* predicates must be added to the FETCH filter to','line_number':1339,'multiline':False]['text':' ensure correctness.','line_number':1340,'multiline':False]['text':' Finally, confirm that queries which include a numeric path component on a field that is *not*','line_number':1393,'multiline':False]['text':' multikey produce EXACT bounds and do *not* add their predicates to the filter.','line_number':1394,'multiline':False]['text':' Here, in contrast to the multikey case, we generate one indexed solution for each predicate','line_number':1401,'multiline':False]['text':' and only filter the *other* predicate in the FETCH stage.','line_number':1402,'multiline':False]['text':' 'a' is not multikey, so 'a.0' refers specifically to a fieldname rather than an array index,','line_number':1418,'multiline':False]['text':' and special bounds will not be generated.','line_number':1419,'multiline':False]['text':' 'a' is not multikey, so 'a.0.b' does not refer to multikey path 'a.b' and 'b.1' is therefore','line_number':1426,'multiline':False]['text':' also strictly a fieldname. Special bounds will not be generated for either.','line_number':1427,'multiline':False]['text':' 'a.b' is multikey but 'a.b.c' is not, so special bounds will only be generated for 'b.1'.','line_number':1435,'multiline':False]['text':' 'a.b' is multikey but 'a.b.c' is not. 'a.b.c.2.d' therefore refers to a different path than','line_number':1443,'multiline':False]['text':' multikey path 'a.[b].c.[d]', so special bounds will be generated for 'b.1' but not for 'd.3'.','line_number':1444,'multiline':False]['text':' 'a.b' and 'a.b.c.d' are both multikey. Special bounds will be generated for 'b.1' and 'd.3'.','line_number':1453,'multiline':False]['text':' 'a.b.0' is itself a multikey path, but since 'a.b' is multikey 'b.0' may refer to an array','line_number':1466,'multiline':False]['text':' element of 'b'. We generate special bounds for 'b.0'.','line_number':1467,'multiline':False]['text':' 'a.b' and 'a.b.0.c' are both multikey paths; we generate special bounds for 'b.0' and 'c.1'.','line_number':1475,'multiline':False]['text':' 'a.b' is multikey but 'a.b.c' is not, so we only generate special bounds for 'a.b.1'.','line_number':1484,'multiline':False]['text':' 'a.b' is multikey, but '01' is not eligible for consideration as a numeric array index; it is','line_number':1496,'multiline':False]['text':' always strictly a field name. We therefore do not generate special bounds.','line_number':1497,'multiline':False]['text':' '0' is multikey, but the first component in a path can never be an array index since it must','line_number':1508,'multiline':False]['text':' always be a field name. We therefore do not generate special bounds for '0.b'.','line_number':1509,'multiline':False]['text':' '0' is multikey, so a query on '0.1.b' will generate special bounds for '1' but not for '0'.','line_number':1516,'multiline':False]['text':' This query cannot be serviced by the wildcard index, because there are multiple successive','line_number':1582,'multiline':False]['text':' positional path components.','line_number':1583,'multiline':False]['text':' When an array index field exists in the query pattern and one of the resulting','line_number':1609,'multiline':False]['text':' fieldname-or-array-index paths is a prefix of another, then the subpath bounds generated by','line_number':1610,'multiline':False]['text':' the prefix path will contain all the bounds generated by its subpaths. Test that we avoid','line_number':1611,'multiline':False]['text':' overlap by removing the redundant paths.','line_number':1612,'multiline':False]['text':'','line_number':1613,'multiline':False]['text':' In the below example, 'a.0' is multikey and the query is on 'a.0.0'. We generate paths','line_number':1614,'multiline':False]['text':' 'a.0' and 'a.0.0' because the first '0' is an array index. But the subpaths bound','line_number':1615,'multiline':False]['text':' generated by 'a.0' -> ['a.0.','a.0/'] would contain all the bounds generated by','line_number':1616,'multiline':False]['text':' 'a.0.0'. Therefore we must remove path 'a.0.0' before generating the subpath bounds.','line_number':1617,'multiline':False]['text':' We can query through 8 levels of arrays via explicit array indices...','line_number':1654,'multiline':False]['text':' ... but after that, we decline to answer the query using the $** index.','line_number':1660,'multiline':False]['text':' However, we continue to allow implicit (non-indices) traversal of arrays to any depth.','line_number':1665,'multiline':False]['text':'','line_number':1672,'multiline':False]['text':' Min/max with wildcard index.','line_number':1673,'multiline':False]['text':'','line_number':1674,'multiline':False]['text':' Test with a query argument to check that the expanded indices are not used.','line_number':1701,'multiline':False]['text':' namespace mongo','line_number':1999,'multiline':False]