['text':'*
 *    Copyright (C) 2022-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: keep','line_number':62,'multiline':False]['text':'costModel','line_number':112,'multiline':True]['text':'debugMode','line_number':113,'multiline':True]['text':'debugLevel','line_number':113,'multiline':True]['text':' Plan output with properties.','line_number':140,'multiline':False]['text':'costModel','line_number':305,'multiline':True]['text':'debugMode','line_number':306,'multiline':True]['text':'debugLevel','line_number':306,'multiline':True]['text':'costModel','line_number':356,'multiline':True]['text':'debugMode','line_number':357,'multiline':True]['text':'debugLevel','line_number':357,'multiline':True]['text':' Assert we have specific CE details at certain nodes.','line_number':363,'multiline':False]['text':' Projection "pb1" is unused and we do not generate an aggregation expression for it.','line_number':374,'multiline':False]['text':'retainNonArrays','line_number':400,'multiline':True]['text':' This filter should stay above the unwind.','line_number':402,'multiline':False]['text':' This filter should be pushed down below the unwind.','line_number':406,'multiline':False]['text':'costModel','line_number':419,'multiline':True]['text':'debugMode','line_number':420,'multiline':True]['text':'debugLevel','line_number':420,'multiline':True]['text':'costModel','line_number':474,'multiline':True]['text':'debugMode','line_number':475,'multiline':True]['text':'debugLevel','line_number':475,'multiline':True]['text':' Only one copy of the filter.','line_number':481,'multiline':False]['text':'costModel','line_number':527,'multiline':True]['text':'debugMode','line_number':528,'multiline':True]['text':'debugLevel','line_number':528,'multiline':True]['text':' Limit-skip is attached to the collation node by virtue of physical props.','line_number':534,'multiline':False]['text':'costModel','line_number':571,'multiline':True]['text':'debugMode','line_number':572,'multiline':True]['text':'debugLevel','line_number':572,'multiline':True]['text':'costModel','line_number':616,'multiline':True]['text':'debugMode','line_number':617,'multiline':True]['text':'debugLevel','line_number':617,'multiline':True]['text':'costModel','line_number':659,'multiline':True]['text':'debugMode','line_number':660,'multiline':True]['text':'debugLevel','line_number':660,'multiline':True]['text':' Demonstrate sargable node is rewritten from filter node.','line_number':662,'multiline':False]['text':' Note: SargableNodes cannot be lowered and by default are not created unless we have','line_number':663,'multiline':False]['text':' indexes.','line_number':664,'multiline':False]['text':'costModel','line_number':692,'multiline':True]['text':'debugMode','line_number':693,'multiline':True]['text':'debugLevel','line_number':693,'multiline':True]['text':' Test sargable filter is satisfied with an index scan.','line_number':699,'multiline':False]['text':'costModel','line_number':719,'multiline':True]['text':'debugMode','line_number':720,'multiline':True]['text':'debugLevel','line_number':720,'multiline':True]['text':' Test we can optimize sargable filter nodes even without an index.','line_number':726,'multiline':False]['text':' This node will not be converted to Sargable.','line_number':745,'multiline':False]['text':'costModel','line_number':776,'multiline':True]['text':'debugMode','line_number':777,'multiline':True]['text':'debugLevel','line_number':777,'multiline':True]['text':'isMultiKey','line_number':837,'multiline':True]['text':'costModel','line_number':838,'multiline':True]['text':'debugMode','line_number':839,'multiline':True]['text':'debugLevel','line_number':839,'multiline':True]['text':' Dependent eval node.','line_number':872,'multiline':False]['text':' Non-sargable filter.','line_number':878,'multiline':False]['text':'isMultiKey','line_number':902,'multiline':True]['text':'costModel','line_number':903,'multiline':True]['text':'debugMode','line_number':904,'multiline':True]['text':'debugLevel','line_number':904,'multiline':True]['text':' Demonstrate non-sargable evaluation and filter are moved under the NLJ+seek,','line_number':910,'multiline':False]['text':' Verify which rules are used in different groups.','line_number':935,'multiline':False]['text':' NOLINT','line_number':950,'multiline':False]['text':' NOLINT','line_number':964,'multiline':False]['text':'isMultiKey','line_number':1010,'multiline':True]['text':'costModel','line_number':1011,'multiline':True]['text':'debugMode','line_number':1012,'multiline':True]['text':'debugLevel','line_number':1012,'multiline':True]['text':' We dont need a Seek if we dont have multi-key paths.','line_number':1018,'multiline':False]['text':'isMultiKey','line_number':1056,'multiline':True]['text':'costModel','line_number':1057,'multiline':True]['text':'debugMode','line_number':1058,'multiline':True]['text':'debugLevel','line_number':1058,'multiline':True]['text':' We need a Seek to obtain value for "a".','line_number':1064,'multiline':False]['text':' Make sure the intervals do not contain Null.','line_number':1083,'multiline':False]['text':'isMultiKey','line_number':1135,'multiline':True]['text':'costModel','line_number':1136,'multiline':True]['text':'debugMode','line_number':1137,'multiline':True]['text':'debugLevel','line_number':1137,'multiline':True]['text':' For now leave only GroupBy+Union RIDIntersect.','line_number':1141,'multiline':False]['text':' Iterate all the groups in a Memo in order to find an ABT that contains nodes with expected ce','line_number':1146,'multiline':False]['text':' values.','line_number':1147,'multiline':False]['text':' Check if there's an ABT contains all the expected ce values.','line_number':1157,'multiline':False]['text':'isMultiKey','line_number':1244,'multiline':True]['text':'costModel','line_number':1245,'multiline':True]['text':'debugMode','line_number':1246,'multiline':True]['text':'debugLevel','line_number':1246,'multiline':True]['text':' We can cover both fields with the index, and need separate sort on "b".','line_number':1252,'multiline':False]['text':'isMultiKey','line_number':1312,'multiline':True]['text':'costModel','line_number':1313,'multiline':True]['text':'debugMode','line_number':1314,'multiline':True]['text':'debugLevel','line_number':1314,'multiline':True]['text':' We can cover both fields with the index, and do not need a separate sort on "b".','line_number':1320,'multiline':False]['text':' A query with a large number of filters on different fields.','line_number':1335,'multiline':False]['text':'isMultiKey','line_number':1364,'multiline':True]['text':'isMultiKey','line_number':1367,'multiline':True]['text':'isMultiKey','line_number':1371,'multiline':True]['text':'costModel','line_number':1372,'multiline':True]['text':'debugMode','line_number':1373,'multiline':True]['text':'debugLevel','line_number':1373,'multiline':True]['text':' Without the changes to restrict SargableNode split to which this test is tied, we would','line_number':1378,'multiline':False]['text':' be exploring 2^kFilterCount plans, one for each created group.','line_number':1379,'multiline':False]['text':' With heuristic CE both indexes are equally preferable.','line_number':1412,'multiline':False]['text':'includeFieldName','line_number':1415,'multiline':True]['text':' In the absence of full implementation of query parameterization, here we pretend we have a','line_number':1423,'multiline':False]['text':' function "getQueryParam" which will return a query parameter by index.','line_number':1424,'multiline':False]['text':' Encode a condition using two query parameters (expressed as functions):','line_number':1431,'multiline':False]['text':' "a" > param_0 AND "a" >= param_1 (observe param_1 comparison is inclusive).','line_number':1432,'multiline':False]['text':'isMultiKey','line_number':1456,'multiline':True]['text':'costModel','line_number':1457,'multiline':True]['text':'debugMode','line_number':1458,'multiline':True]['text':'debugLevel','line_number':1458,'multiline':True]['text':' Observe unioning of two index scans with complex expressions for bounds. This encodes:','line_number':1465,'multiline':False]['text':' (max(param_0, param_1), Const [maxKey]] U [param_0 > param_1 ? MaxKey : param_1, max(param_0,','line_number':1466,'multiline':False]['text':' param_1)]','line_number':1467,'multiline':False]['text':'costModel','line_number':1530,'multiline':True]['text':'debugMode','line_number':1531,'multiline':True]['text':'debugLevel','line_number':1531,'multiline':True]['text':' Observe redundant predicate a <= MaxKey is removed.','line_number':1536,'multiline':False]['text':' Construct a query which tests "a" > 1 and "c" > 2 and "e" = 3.','line_number':1562,'multiline':False]['text':'isMultiKey','line_number':1584,'multiline':True]['text':'costModel','line_number':1585,'multiline':True]['text':'debugMode','line_number':1586,'multiline':True]['text':'debugLevel','line_number':1586,'multiline':True]['text':' We need to apply those hints in order to coax the RIN plan.','line_number':1590,'multiline':False]['text':' Demonstrate RIN plan which consists of three equality prefixes.','line_number':1598,'multiline':False]['text':' Construct a query which tests "a" > 1 and "b" > 2, and sorts descending on "a", then','line_number':1651,'multiline':False]['text':' ascending on "b".','line_number':1652,'multiline':False]['text':'isMultiKey','line_number':1673,'multiline':True]['text':'costModel','line_number':1674,'multiline':True]['text':'debugMode','line_number':1675,'multiline':True]['text':'debugLevel','line_number':1675,'multiline':True]['text':' We need to apply those hints in order to coax out the RIN plan.','line_number':1679,'multiline':False]['text':' Observe how the index scan for the first equality prefix (on "a") is reversed while the','line_number':1687,'multiline':False]['text':' second one (on "a") is not.','line_number':1688,'multiline':False]['text':' Construct a query which tests "a" in [1, 2] U [3, 4] and "b" in [5, 6] U [7, 8].','line_number':1718,'multiline':False]['text':'isMultiKey','line_number':1743,'multiline':True]['text':'costModel','line_number':1744,'multiline':True]['text':'debugMode','line_number':1745,'multiline':True]['text':'debugLevel','line_number':1745,'multiline':True]['text':' We need to apply those hints in order to coax out the RIN plan.','line_number':1749,'multiline':False]['text':'costModel','line_number':1855,'multiline':True]['text':'debugMode','line_number':1856,'multiline':True]['text':'debugLevel','line_number':1856,'multiline':True]['text':' Demonstrate we can combine the field access to "a" into a single entry and provide two output','line_number':1861,'multiline':False]['text':' projections.','line_number':1862,'multiline':False]['text':'costModel','line_number':1900,'multiline':True]['text':'debugMode','line_number':1901,'multiline':True]['text':'debugLevel','line_number':1901,'multiline':True]['text':' Demonstrate that we combine the field access for the filter and eval nodes.','line_number':1906,'multiline':False]['text':'costModel','line_number':1955,'multiline':True]['text':'debugMode','line_number':1956,'multiline':True]['text':'debugLevel','line_number':1956,'multiline':True]['text':' Observe filters are ordered from most selective (lowest sel) to least selective (highest','line_number':1962,'multiline':False]['text':' sel).','line_number':1963,'multiline':False]['text':'isMultiKey','line_number':2033,'multiline':True]['text':'costModel','line_number':2035,'multiline':True]['text':'debugMode','line_number':2036,'multiline':True]['text':'debugLevel','line_number':2036,'multiline':True]['text':'','line_number':2040,'multiline':False]['text':' Since we do not optimize with fast null handling, we need to split the predicate between the','line_number':2045,'multiline':False]['text':' index scan and fetch in order to handle null.','line_number':2046,'multiline':False]['text':'isMultiKey','line_number':2090,'multiline':True]['text':'costModel','line_number':2091,'multiline':True]['text':'debugMode','line_number':2092,'multiline':True]['text':'debugLevel','line_number':2092,'multiline':True]['text':' Should not need a collation node.','line_number':2098,'multiline':False]['text':' Index and collation node have incompatible ops.','line_number':2107,'multiline':False]['text':'isMultiKey','line_number':2117,'multiline':True]['text':'costModel','line_number':2118,'multiline':True]['text':'debugMode','line_number':2119,'multiline':True]['text':'debugLevel','line_number':2119,'multiline':True]['text':' Index does not have the right collation and now we need a collation node.','line_number':2125,'multiline':False]['text':'isMultiKey','line_number':2166,'multiline':True]['text':'costModel','line_number':2167,'multiline':True]['text':'debugMode','line_number':2168,'multiline':True]['text':'debugLevel','line_number':2168,'multiline':True]['text':'isMultiKey','line_number':2224,'multiline':True]['text':'costModel','line_number':2225,'multiline':True]['text':'debugMode','line_number':2226,'multiline':True]['text':'debugLevel','line_number':2226,'multiline':True]['text':' Verify collation is subsumed into the index scan.','line_number':2233,'multiline':False]['text':'isMultiKey','line_number':2266,'multiline':True]['text':'costModel','line_number':2267,'multiline':True]['text':'debugMode','line_number':2268,'multiline':True]['text':'debugLevel','line_number':2268,'multiline':True]['text':' Demonstrate the traverse is removed.','line_number':2275,'multiline':False]['text':' TODO SERVER-71551 Follow up unit tests with overriden Cost Model.','line_number':2327,'multiline':False]['text':'isMultiKey','line_number':2340,'multiline':True]['text':'isMultiKey','line_number':2342,'multiline':True]['text':'debugMode','line_number':2345,'multiline':True]['text':'debugLevel','line_number':2345,'multiline':True]['text':' Test RIDIntersect using only Group+Union.','line_number':2350,'multiline':False]['text':' GroupBy+Union cannot propagate collation requirement, and we need a separate','line_number':2355,'multiline':False]['text':' CollationNode.','line_number':2356,'multiline':False]['text':' Index2 will be used in reverse direction.','line_number':2405,'multiline':False]['text':' TODO SERVER-71551 Follow up unit tests with overriden Cost Model.','line_number':2472,'multiline':False]['text':'isMultiKey','line_number':2488,'multiline':True]['text':'isMultiKey','line_number':2492,'multiline':True]['text':'debugMode','line_number':2494,'multiline':True]['text':'debugLevel','line_number':2494,'multiline':True]['text':' NOLINT','line_number':2500,'multiline':False]['text':' TODO SERVER-71551 Follow up unit tests with overriden Cost Model.','line_number':2571,'multiline':False]['text':'isMultiKey','line_number':2588,'multiline':True]['text':'isMultiKey','line_number':2592,'multiline':True]['text':'debugMode','line_number':2595,'multiline':True]['text':'debugLevel','line_number':2595,'multiline':True]['text':' NOLINT','line_number':2601,'multiline':False]['text':' TODO SERVER-71551 Follow up unit tests with overriden Cost Model.','line_number':2672,'multiline':False]['text':'isMultiKey','line_number':2687,'multiline':True]['text':'isMultiKey','line_number':2691,'multiline':True]['text':'debugMode','line_number':2693,'multiline':True]['text':'debugLevel','line_number':2693,'multiline':True]['text':' Demonstrate we have a merge join because we have point predicates.','line_number':2699,'multiline':False]['text':' NOLINT','line_number':2700,'multiline':False]['text':' Create the following expression: {$and: [{a: {$eq: 1}}, {b: {$eq: 2}}]}','line_number':2734,'multiline':False]['text':' Create the following indexes: {a:1, c:1, {name: 'index1'}}, and {b:1, d:1, {name: 'index2'}}','line_number':2760,'multiline':False]['text':'isMultiKey','line_number':2773,'multiline':True]['text':'isMultiKey','line_number':2777,'multiline':True]['text':'costModel','line_number':2779,'multiline':True]['text':'debugMode','line_number':2780,'multiline':True]['text':'debugLevel','line_number':2780,'multiline':True]['text':' Index intersection via merge join relies on the fact that the RIDs of equal keys are sorted.','line_number':2786,'multiline':False]['text':' Demonstrate that we do not get a merge join when the lookup keys on both intersected indexes','line_number':2787,'multiline':False]['text':' do not cover all field indexes. In this case there is no guarantee that the RIDs of all','line_number':2788,'multiline':False]['text':' matching keys will be sorted, and therefore they cannot be merge-joined.','line_number':2789,'multiline':False]['text':' Also demonstrate we pick index1 with the more selective predicate.','line_number':2790,'multiline':False]['text':' NOLINT','line_number':2792,'multiline':False]['text':' Test the following scenario: (a = 0 or a = 1) and (b = 2 or b = 3) over a compound index on','line_number':2812,'multiline':False]['text':' {a, b}.','line_number':2813,'multiline':False]['text':'isMultiKey','line_number':2836,'multiline':True]['text':'costModel','line_number':2837,'multiline':True]['text':'debugMode','line_number':2838,'multiline':True]['text':'debugLevel','line_number':2838,'multiline':True]['text':' Demonstrate that we create four compound {a, b} index bounds: [=0, =2], [=0, =3], [=1, =2]','line_number':2844,'multiline':False]['text':' and [=1, =3].','line_number':2845,'multiline':False]['text':'isMultiKey','line_number':2907,'multiline':True]['text':'costModel','line_number':2908,'multiline':True]['text':'debugMode','line_number':2909,'multiline':True]['text':'debugLevel','line_number':2909,'multiline':True]['text':' Demonstrate that the predicates >70 and <90 are NOT combined into the same interval (70, 90)','line_number':2915,'multiline':False]['text':' since the paths are multiKey. With the heuristic estimate we may get either interval in the','line_number':2916,'multiline':False]['text':' index, and the other one as a residual filter.','line_number':2917,'multiline':False]['text':'includeFieldName','line_number':2925,'multiline':True]['text':'includeFieldName','line_number':2938,'multiline':True]['text':'includeFieldName','line_number':2941,'multiline':True]['text':'isMultiKey','line_number':2983,'multiline':True]['text':'costModel','line_number':2984,'multiline':True]['text':'debugMode','line_number':2985,'multiline':True]['text':'debugLevel','line_number':2985,'multiline':True]['text':' Demonstrate we can intersect the intervals since we have non-multikey paths, and the','line_number':2991,'multiline':False]['text':' collation requirement is satisfied via the index scan.','line_number':2992,'multiline':False]['text':' TODO SERVER-71551 Follow up unit tests with overriden Cost Model.','line_number':3027,'multiline':False]['text':'isMultiKey','line_number':3041,'multiline':True]['text':'debugMode','line_number':3043,'multiline':True]['text':'debugLevel','line_number':3043,'multiline':True]['text':' Demonstrate we can intersect the bounds here because composition does not contain','line_number':3049,'multiline':False]['text':' traverse.','line_number':3050,'multiline':False]['text':'isMultiKey','line_number':3100,'multiline':True]['text':'isMultiKey','line_number':3102,'multiline':True]['text':'isMultiKey','line_number':3104,'multiline':True]['text':'isMultiKey','line_number':3106,'multiline':True]['text':'costModel','line_number':3107,'multiline':True]['text':'debugMode','line_number':3108,'multiline':True]['text':'debugLevel','line_number':3108,'multiline':True]['text':' We do not intersect the bounds, because the outer composition is over the different fields.','line_number':3114,'multiline':False]['text':' Make filter and scan costs zero. This should make residual predicates very appealing.','line_number':3147,'multiline':False]['text':'isMultiKey','line_number':3161,'multiline':True]['text':'debugMode','line_number':3163,'multiline':True]['text':'debugLevel','line_number':3163,'multiline':True]['text':' NOLINT (test auto-update)','line_number':3170,'multiline':False]['text':' Demonstrate that we get an index intersection plan even though from costing perspective a','line_number':3175,'multiline':False]['text':' collection scan with residual predicates should have been preferable.','line_number':3176,'multiline':False]['text':' NOLINT (test auto-update)','line_number':3177,'multiline':False]['text':' NOLINT (test auto-update)','line_number':3199,'multiline':False]['text':' Demonstrate that without the hint we get residual predicates.','line_number':3204,'multiline':False]['text':' NOLINT (test auto-update)','line_number':3205,'multiline':False]['text':'isMultiKey','line_number':3263,'multiline':True]['text':'costModel','line_number':3264,'multiline':True]['text':'debugMode','line_number':3265,'multiline':True]['text':'debugLevel','line_number':3265,'multiline':True]['text':' Make sure we can use the index to cover "b" while testing "b.c" with a separate filter.','line_number':3271,'multiline':False]['text':'isMultiKey','line_number':3377,'multiline':True]['text':'isMultiKey','line_number':3378,'multiline':True]['text':'isMultiKey','line_number':3379,'multiline':True]['text':'isMultiKey','line_number':3380,'multiline':True]['text':'isMultiKey','line_number':3381,'multiline':True]['text':'isMultiKey','line_number':3383,'multiline':True]['text':'isMultiKey','line_number':3384,'multiline':True]['text':'isMultiKey','line_number':3385,'multiline':True]['text':'isMultiKey','line_number':3386,'multiline':True]['text':'isMultiKey','line_number':3388,'multiline':True]['text':'isMultiKey','line_number':3389,'multiline':True]['text':'isMultiKey','line_number':3390,'multiline':True]['text':'costModel','line_number':3391,'multiline':True]['text':'debugMode','line_number':3392,'multiline':True]['text':'debugLevel','line_number':3392,'multiline':True]['text':' Prefer index1 over index2 and index3 in order to cover all fields.','line_number':3399,'multiline':False]['text':'isMultiKey','line_number':3445,'multiline':True]['text':'isMultiKey','line_number':3446,'multiline':True]['text':'isMultiKey','line_number':3447,'multiline':True]['text':'costModel','line_number':3448,'multiline':True]['text':'debugMode','line_number':3449,'multiline':True]['text':'debugLevel','line_number':3449,'multiline':True]['text':' We can cover "b" with the index and filter before we Seek.','line_number':3455,'multiline':False]['text':' This encodes an elemMatch with a conjunction >70 and <90.','line_number':3479,'multiline':False]['text':'costModel','line_number':3503,'multiline':True]['text':'debugMode','line_number':3504,'multiline':True]['text':'debugLevel','line_number':3504,'multiline':True]['text':' This encodes an elemMatch with a conjunction >70 and <90.','line_number':3540,'multiline':False]['text':'isMultiKey','line_number':3566,'multiline':True]['text':'isMultiKey','line_number':3567,'multiline':True]['text':'costModel','line_number':3568,'multiline':True]['text':'debugMode','line_number':3569,'multiline':True]['text':'debugLevel','line_number':3569,'multiline':True]['text':' Demonstrate we can cover both the filter and the extracted elemMatch predicate with the','line_number':3575,'multiline':False]['text':' index.','line_number':3576,'multiline':False]['text':' This encodes an elemMatch with a conjunction >70 and <90.','line_number':3599,'multiline':False]['text':'multiKey','line_number':3625,'multiline':True]['text':'costModel','line_number':3626,'multiline':True]['text':'debugMode','line_number':3627,'multiline':True]['text':'debugLevel','line_number':3627,'multiline':True]['text':' If we do not have arrays (index is not multikey) we simplify to unsatisfiable query.','line_number':3633,'multiline':False]['text':'isMultiKey','line_number':3681,'multiline':True]['text':'isMultiKey','line_number':3682,'multiline':True]['text':' Sets large CE to offset IndexScan startup cost.','line_number':3686,'multiline':False]['text':'costModel','line_number':3687,'multiline':True]['text':'debugMode','line_number':3688,'multiline':True]['text':'debugLevel','line_number':3688,'multiline':True]['text':' We should pick the index, and do at least some filtering before the fetch.','line_number':3694,'multiline':False]['text':' We don't have index bounds, both because 'a' is not the first field of the index,','line_number':3695,'multiline':False]['text':' and because the predicates are on child fields 'a.b' and 'a.c'.','line_number':3696,'multiline':False]['text':' Also, we can't satisfy 'a.b' and 'a.c' on the same scan, because that would force','line_number':3697,'multiline':False]['text':' both predicates to match the same array-element of 'a'.','line_number':3698,'multiline':False]['text':' TODO SERVER-70780 we could be simplifying the paths even more:','line_number':3700,'multiline':False]['text':' ComposeA PathArr PathObj is true when the input is an array or object.','line_number':3701,'multiline':False]['text':' But the other 'Get Traverse Compare' here can only be true when the input is an object.','line_number':3702,'multiline':False]['text':' So the 'ComposeA PathArr PathObj' is redundant and we could remove it.','line_number':3703,'multiline':False]['text':' Note: currently we can pick non-deterministically to satisfy either a.b or a.c as a filter','line_number':3705,'multiline':False]['text':' node over the scan.','line_number':3706,'multiline':False]['text':'isMultiKey','line_number':3762,'multiline':True]['text':'isMultiKey','line_number':3764,'multiline':True]['text':'costModel','line_number':3765,'multiline':True]['text':'debugMode','line_number':3766,'multiline':True]['text':'debugLevel','line_number':3766,'multiline':True]['text':' We should pick the index, and generate bounds for the 'b' predicate.','line_number':3772,'multiline':False]['text':' TODO SERVER-71551 Follow up unit tests with overriden Cost Model.','line_number':3818,'multiline':False]['text':'isMultiKey','line_number':3833,'multiline':True]['text':' Sets large CE to offset IndexScan startup cost.','line_number':3837,'multiline':False]['text':'debugMode','line_number':3839,'multiline':True]['text':'debugLevel','line_number':3839,'multiline':True]['text':' We should not generate tight index bounds [2, 2], because nested elemMatch only matches','line_number':3845,'multiline':False]['text':' arrays of arrays, and multikey indexes only unwind one level of arrays. We run a residual','line_number':3846,'multiline':False]['text':' predicate to check that the inner array contains '2'.','line_number':3847,'multiline':False]['text':'isMultiKey','line_number':3900,'multiline':True]['text':'isMultiKey','line_number':3901,'multiline':True]['text':'costModel','line_number':3903,'multiline':True]['text':'debugMode','line_number':3904,'multiline':True]['text':'debugLevel','line_number':3904,'multiline':True]['text':'hints','line_number':3905,'multiline':True]['text':' We should get index bounds for the PathObj.','line_number':3911,'multiline':False]['text':' This encodes a match against an array constant.','line_number':3945,'multiline':False]['text':'isMultiKey','line_number':3968,'multiline':True]['text':'isMultiKey','line_number':3969,'multiline':True]['text':'costModel','line_number':3970,'multiline':True]['text':'debugMode','line_number':3971,'multiline':True]['text':'debugLevel','line_number':3971,'multiline':True]['text':' Demonstrate we get index bounds to handle the array constant, while we also retain the','line_number':3977,'multiline':False]['text':' original filter. We have index bound with the array itself unioned with bound using the first','line_number':3978,'multiline':False]['text':' array element.','line_number':3979,'multiline':False]['text':' This encodes a match against an array constant.','line_number':4028,'multiline':False]['text':'costModel','line_number':4048,'multiline':True]['text':'debugMode','line_number':4049,'multiline':True]['text':'debugLevel','line_number':4049,'multiline':True]['text':' Without an index, we retain the original array bounds predicate, and do not duplicate the','line_number':4055,'multiline':False]['text':' predicates in the sargable node (they are perf only)','line_number':4056,'multiline':False]['text':'costModel','line_number':4103,'multiline':True]['text':'debugMode','line_number':4104,'multiline':True]['text':'debugLevel','line_number':4104,'multiline':True]['text':' We have a collation node with limit-skip physical properties. It will be lowered to a','line_number':4110,'multiline':False]['text':' sort node with limit.','line_number':4111,'multiline':False]['text':' TODO: Test cases where partial filter bound is a range which subsumes the query','line_number':4216,'multiline':False]['text':' requirement','line_number':4217,'multiline':False]['text':' TODO: (e.g. half open interval)','line_number':4218,'multiline':False]['text':'isFilterContext','line_number':4225,'multiline':True]['text':'pathToInterval','line_number':4226,'multiline':True]['text':'isMultiKey','line_number':4239,'multiline':True]['text':'costModel','line_number':4242,'multiline':True]['text':'debugMode','line_number':4243,'multiline':True]['text':'debugLevel','line_number':4243,'multiline':True]['text':' Partial schema requirement is not on an index field. We get a seek on this field.','line_number':4249,'multiline':False]['text':'isFilterContext','line_number':4290,'multiline':True]['text':'pathToInterval','line_number':4291,'multiline':True]['text':'isMultiKey','line_number':4304,'multiline':True]['text':'costModel','line_number':4307,'multiline':True]['text':'debugMode','line_number':4308,'multiline':True]['text':'debugLevel','line_number':4308,'multiline':True]['text':' Partial schema requirement on an index field.','line_number':4314,'multiline':False]['text':'isFilterContext','line_number':4356,'multiline':True]['text':'pathToInterval','line_number':4357,'multiline':True]['text':'isMultiKey','line_number':4370,'multiline':True]['text':'costModel','line_number':4373,'multiline':True]['text':'debugMode','line_number':4374,'multiline':True]['text':'debugLevel','line_number':4374,'multiline':True]['text':' Incompatible partial filter. Use scan.','line_number':4380,'multiline':False]['text':'debugMode','line_number':4422,'multiline':True]['text':'debugLevel','line_number':4422,'multiline':True]['text':' Make sure the Scan node returns rid, and the Root node refers to it.','line_number':4428,'multiline':False]['text':' Non-sargable filter node.','line_number':4446,'multiline':False]['text':'debugMode','line_number':4459,'multiline':True]['text':'debugLevel','line_number':4459,'multiline':True]['text':' Each branch produces two projections, pUnion1 and pUnion2.','line_number':4479,'multiline':False]['text':'costModel','line_number':4511,'multiline':True]['text':'debugMode','line_number':4512,'multiline':True]['text':'debugLevel','line_number':4512,'multiline':True]['text':' Each branch produces two projections, pUnion1 and pUnion2.','line_number':4532,'multiline':False]['text':'costModel','line_number':4568,'multiline':True]['text':'debugMode','line_number':4569,'multiline':True]['text':'debugLevel','line_number':4569,'multiline':True]['text':'isMultiKey','line_number':4632,'multiline':True]['text':'costModel','line_number':4633,'multiline':True]['text':'debugMode','line_number':4634,'multiline':True]['text':'debugLevel','line_number':4634,'multiline':True]['text':' Demonstrate index nested loop join and variable interval intersection.','line_number':4640,'multiline':False]['text':' We have a predicate applied directly over the root projection without field extraction.','line_number':4656,'multiline':False]['text':'costModel','line_number':4672,'multiline':True]['text':'debugMode','line_number':4673,'multiline':True]['text':'debugLevel','line_number':4673,'multiline':True]['text':'costModel','line_number':4710,'multiline':True]['text':'debugMode','line_number':4711,'multiline':True]['text':'debugLevel','line_number':4711,'multiline':True]['text':' The FilterNode is first converted to a SargableNode, then it's converted back to a FilterNode','line_number':4716,'multiline':False]['text':' because it can't be satisfied with an index. The path under the resulting FilterNode should','line_number':4717,'multiline':False]['text':' be balanced.','line_number':4718,'multiline':False]['text':'costModel','line_number':4774,'multiline':True]['text':'debugMode','line_number':4775,'multiline':True]['text':'debugLevel','line_number':4775,'multiline':True]['text':' The FilterNode is first converted to a SargableNode, then it's converted back to a FilterNode','line_number':4781,'multiline':False]['text':' because it can't be satisfied with an index. The path under the resulting FilterNode should','line_number':4782,'multiline':False]['text':' be combined into one EqMember path that accounts for all original separate Eq and EqMember','line_number':4783,'multiline':False]['text':' paths, as well as one Gt path and one Lt path.','line_number':4784,'multiline':False]['text':'isMultiKey','line_number':4829,'multiline':True]['text':'costModel','line_number':4830,'multiline':True]['text':'debugMode','line_number':4831,'multiline':True]['text':'debugLevel','line_number':4831,'multiline':True]['text':'costModel','line_number':4865,'multiline':True]['text':'debugMode','line_number':4866,'multiline':True]['text':'debugLevel','line_number':4866,'multiline':True]['text':' Test sargable filter is satisfied with an index scan.','line_number':4872,'multiline':False]['text':'isMultiKey','line_number':5039,'multiline':True]['text':'costModel','line_number':5040,'multiline':True]['text':'debugMode','line_number':5041,'multiline':True]['text':'debugLevel','line_number':5041,'multiline':True]['text':' Observe we have a covered plan. The filters for subfields "b" and "c" are expressed as','line_number':5047,'multiline':False]['text':' residual predicates. Also observe the traverse for "a.c" is removed due to "a" being','line_number':5048,'multiline':False]['text':' non-multikey.','line_number':5049,'multiline':False]['text':'isMultiKey','line_number':5115,'multiline':True]['text':'isMultiKey','line_number':5116,'multiline':True]['text':'isMultiKey','line_number':5117,'multiline':True]['text':'costModel','line_number':5119,'multiline':True]['text':'debugMode','line_number':5120,'multiline':True]['text':'debugLevel','line_number':5120,'multiline':True]['text':' Demonstrate predicates are repeated on the Seek side. Also demonstrate null handling, and the','line_number':5127,'multiline':False]['text':' fact that we apply the predicates on the Seek side in increasing selectivity order.','line_number':5128,'multiline':False]['text':' TODO SERVER-71551 Follow up unit tests with overriden Cost Model.','line_number':5180,'multiline':False]['text':'isMultiKey','line_number':5195,'multiline':True]['text':'isMultiKey','line_number':5197,'multiline':True]['text':'debugMode','line_number':5200,'multiline':True]['text':'debugLevel','line_number':5200,'multiline':True]['text':' Demonstrate an intersection plan, with predicates repeated on the Seek side.','line_number':5207,'multiline':False]['text':' Start with conjunction of two traverses, over the same field.','line_number':5243,'multiline':False]['text':' The two traverses don't have to match the same array element,','line_number':5244,'multiline':False]['text':' so it's important not to combine them into one traverse.','line_number':5245,'multiline':False]['text':' Hint one predicate to be more selective than the other to ensure we have a predictable','line_number':5250,'multiline':False]['text':' outcome instead of a tie.','line_number':5251,'multiline':False]['text':'isMultiKey','line_number':5269,'multiline':True]['text':'costModel','line_number':5271,'multiline':True]['text':'debugMode','line_number':5272,'multiline':True]['text':'debugLevel','line_number':5272,'multiline':True]['text':' We end up with a multikey index scan. Each row in the index is an array-element of 'a'.','line_number':5278,'multiline':False]['text':' We should not check (a conjunction of) both predicates on the same index scan,','line_number':5279,'multiline':False]['text':' because that forces the same array element to match both, which is stricter than','line_number':5280,'multiline':False]['text':' the original query.','line_number':5281,'multiline':False]['text':' But at the same time, the index should help satisfy one predicate or the other.','line_number':5282,'multiline':False]['text':' Start with conjunction of two traverses, over the same field.','line_number':5315,'multiline':False]['text':' The two traverses don't have to match the same array element,','line_number':5316,'multiline':False]['text':' so it's important not to combine them into one traverse.','line_number':5317,'multiline':False]['text':'isMultiKey','line_number':5334,'multiline':True]['text':'costModel','line_number':5335,'multiline':True]['text':'debugMode','line_number':5336,'multiline':True]['text':'debugLevel','line_number':5336,'multiline':True]['text':' If we use the index to satisfy {a: 1} then we can't also use it to satisfy {'a.x': 1},','line_number':5342,'multiline':False]['text':' because that would be forcing the same array element to match both predicates.','line_number':5343,'multiline':False]['text':'isMultiKey','line_number':5378,'multiline':True]['text':'costModel','line_number':5379,'multiline':True]['text':'debugMode','line_number':5380,'multiline':True]['text':'debugLevel','line_number':5380,'multiline':True]['text':' NOLINT','line_number':5387,'multiline':False]['text':'isMultiKey','line_number':5602,'multiline':True]['text':'costModel','line_number':5603,'multiline':True]['text':'debugMode','line_number':5604,'multiline':True]['text':'debugLevel','line_number':5604,'multiline':True]['text':'includeRejected','line_number':5609,'multiline':True]['text':' Sort plans by estimated cost. If costs are equal, sort lexicographically by plan explain.','line_number':5612,'multiline':False]['text':' This allows us to break ties if costs are equal.','line_number':5613,'multiline':False]['text':' Display the 3 best plans.','line_number':5622,'multiline':False]['text':' NOLINT','line_number':5623,'multiline':False]['text':' NOLINT','line_number':5641,'multiline':False]['text':' NOLINT','line_number':5659,'multiline':False]['text':' Prepares CE hints such that:','line_number':5685,'multiline':False]['text':' - PathGet "b" Id has default selectivity 0.1.','line_number':5686,'multiline':False]['text':' - PathGet "b" Id has selectivity 0.001 if the interval is {<=Const [null]}.','line_number':5687,'multiline':False]['text':' The MQL generates the following ABT: db.coll.find({a: 10}, {b: 1, _id: 0}).','line_number':5702,'multiline':False]['text':'isMultiKey','line_number':5721,'multiline':True]['text':'costModel','line_number':5723,'multiline':True]['text':'debugMode','line_number':5724,'multiline':True]['text':'debugLevel','line_number':5724,'multiline':True]['text':' Because the interval {<=Const [null]} for PathGet "b" is highly selective, it is cheaper to','line_number':5729,'multiline':False]['text':' split the SargableNode into two by splitting the interval requirement. When the CE of the','line_number':5730,'multiline':False]['text':' document fetching (right child) is low enough to be negligible, the covered index scan (left','line_number':5731,'multiline':False]['text':' child) is cheaper than a regular index scan + fetch plan.','line_number':5732,'multiline':False]['text':' namespace','line_number':5754,'multiline':False]['text':' namespace mongo::optimizer','line_number':5755,'multiline':False]