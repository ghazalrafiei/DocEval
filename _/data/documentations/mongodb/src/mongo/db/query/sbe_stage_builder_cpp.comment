['text':'*
 *    Copyright (C) 2019-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':32,'multiline':False]['text':'*
 * Generates an EOF plan. Note that even though this plan will return nothing, it will still define
 * the slots specified by 'reqs'.
 ','line_number':156,'multiline':True]['text':' Fill in the search slots based on initial cursor response from mongot.','line_number':170,'multiline':False]['text':' Build a SearchNode in order to retrieve the search info.','line_number':178,'multiline':False]['text':' Set values for QSN slots.','line_number':182,'multiline':False]['text':' owned ','line_number':187,'multiline':True]['text':' owned ','line_number':195,'multiline':True]['text':' Variables on the cursor must be an object.','line_number':200,'multiline':False]['text':' View ','line_number':203,'multiline':True]['text':' owned ','line_number':204,'multiline':True]['text':' Both the SBE and the classic portions of the query can reference the same value,','line_number':205,'multiline':False]['text':' and this is the only place to set the value if using SBE so we don't worry about','line_number':206,'multiline':False]['text':' inconsistency.','line_number':207,'multiline':False]['text':' isConstant ','line_number':209,'multiline':True]['text':' namespace','line_number':220,'multiline':False]['text':'*
 * Performs necessary initialization steps to execute an SBE tree 'root', including binding params
 * from the current query 'cq' into the plan if it was cloned from the SBE plan cache.
 *   root - root node of the execution tree
 *   data - slot metadata (not actual parameter data!) that goes with the execution tree
 *   preparingFromCache - if true, 'root' and 'data' may have come from the SBE plan cache (though
 *     sometimes the caller says true even for non-cached plans). This means current parameters from
 *     'cq' need to be substituted into the execution plan.
 ','line_number':260,'multiline':True]['text':' Call markShouldCollectTimingInfo() if appropriate.','line_number':284,'multiline':False]['text':' Register this plan to yield according to the configured policy.','line_number':291,'multiline':False]['text':' Populate/renew "shardFilterer" if there exists a "shardFilterer" slot. The slot value should','line_number':299,'multiline':False]['text':' be set to Nothing in the plan cache to avoid extending the lifetime of the ownership filter.','line_number':300,'multiline':False]['text':' Refresh "let" variables in the 'RuntimeEnvironment'.','line_number':305,'multiline':False]['text':' Variables defined in "ExpressionContext" may not always be translated into SBE slots.','line_number':309,'multiline':False]['text':' This can happen if the query that created the cache entry had no value for a system','line_number':319,'multiline':False]['text':' variable, whereas the current query has a value for the system variable but does not','line_number':320,'multiline':False]['text':' actually make use of it in the query plan.','line_number':321,'multiline':False]['text':' This block binds parameters into the main MatchExpression and any additional ones that have','line_number':330,'multiline':False]['text':' been pushed down via 'cq._cqPipeline'. The corresponding SBE plan cache key construction was','line_number':331,'multiline':False]['text':' done in encodeSBE() (canonical_query_encoder.cpp). The main MatchExpression was parameterized','line_number':332,'multiline':False]['text':' in CanonicalQuery::cqInit() and the pushed-down ones in QueryPlanner::extendWithAggPipeline()','line_number':333,'multiline':False]['text':' (query_planner.cpp).','line_number':334,'multiline':False]['text':' prepareSlotBasedExecutableTree','line_number':354,'multiline':False]['text':' planNodeId ','line_number':373,'multiline':True]['text':' We assume here that node->ftsQuery is an FTSQueryImpl, not an FTSQueryNoop. In practice, this','line_number':424,'multiline':False]['text':' means that it is illegal to use the StageBuilder on a QuerySolution created by planning a','line_number':425,'multiline':False]['text':' query that contains "no-op" expressions.','line_number':426,'multiline':False]['text':' namespace','line_number':431,'multiline':False]['text':' Merge the childeren's MakeResultInfos, and then copy the first child's MakeResultInfo','line_number':444,'multiline':False]['text':' to 'outputs'.','line_number':445,'multiline':False]['text':' Copy the contents of reqs._slotNameSet (unordered) into 'names'.','line_number':462,'multiline':False]['text':' If 'reqs.getMRInfo()' is non-null, call MakeResultInfo::getRequiredNames() and take the','line_number':467,'multiline':False]['text':' UnownedSlotNames returned and add them to 'names'.','line_number':468,'multiline':False]['text':' Sort and de-dup the list, and then return it.','line_number':475,'multiline':False]['text':' Build the list of corresponding slots.','line_number':489,'multiline':False]['text':' Build the list of corresponding slots.','line_number':540,'multiline':False]['text':' Sort and de-dup the list by SlotId.','line_number':551,'multiline':False]['text':' Add all named slots to the list.','line_number':571,'multiline':False]['text':' We never clear kResult, regardless of whether it is required by 'reqs'.','line_number':639,'multiline':False]['text':' Compute the merged 'modField' list.','line_number':658,'multiline':False]['text':' Inspect the 'makeResultInfo->getModFields()' from each tree and check if it has all the','line_number':673,'multiline':False]['text':' fields from 'mergedModFields'.','line_number':674,'multiline':False]['text':' If 'makeResultInfo->getModFields()' does not contain all the fields from','line_number':679,'multiline':False]['text':' 'mergedModFields', then we need to populate the missing fields and','line_number':680,'multiline':False]['text':' update 'outputs' accordingly.','line_number':681,'multiline':False]['text':' Update 'makeResultInfo->modFields' and 'makeResultInfo->modFieldSet'.','line_number':697,'multiline':False]['text':' Initialize '_data->queryCollator'.','line_number':738,'multiline':False]['text':' SERVER-52803: In the future if we need to gather more information from the QuerySolutionNode','line_number':741,'multiline':False]['text':' tree, rather than doing one-off scans for each piece of information, we should add a formal','line_number':742,'multiline':False]['text':' analysis pass here.','line_number':743,'multiline':False]['text':' Currently, we assume that each query operates on at most one collection, but a rooted $or','line_number':744,'multiline':False]['text':' queries can have more than one collscan stages with clustered collections.','line_number':745,'multiline':False]['text':' skip if already analyzed this subtree','line_number':791,'multiline':False]['text':' Get the FieldSet produced by this node's child and return it.','line_number':817,'multiline':False]['text':' Union the FieldSets produced by all this node's children and return it.','line_number':824,'multiline':False]['text':' Loop over the parts of the index's keyPattern and add each top-level field','line_number':834,'multiline':False]['text':' that is referenced to 'result', and then return 'result'.','line_number':835,'multiline':False]['text':' Loop over thel fields produced by the GroupNode, add them to 'result', and then','line_number':851,'multiline':False]['text':' return 'result'.','line_number':852,'multiline':False]['text':' Get the FieldSet produced by this node's child, update it with the effects of','line_number':867,'multiline':False]['text':' this projection, and return it.','line_number':868,'multiline':False]['text':' We always produce a 'resultSlot'.','line_number':885,'multiline':False]['text':' We force the root stage to produce a 'recordId' if the iteration can be resumed (via a resume','line_number':889,'multiline':False]['text':' token or a tailable cursor) or if the caller simply expects to be able to read it.','line_number':890,'multiline':False]['text':' Set the target namespace to '_mainNss'. This is necessary as some QuerySolutionNodes that','line_number':893,'multiline':False]['text':' require a collection when stage building do not explicitly name which collection they are','line_number':894,'multiline':False]['text':' targeting.','line_number':895,'multiline':False]['text':' Build the SBE plan stage tree and return it.','line_number':898,'multiline':False]['text':' For a given SlotBasedStageBuilder instance, this build() method can only be called once.','line_number':903,'multiline':False]['text':' owned ','line_number':910,'multiline':True]['text':' Assert that we produced a 'resultSlot' and that we produced a 'recordIdSlot' if it was','line_number':918,'multiline':False]['text':' needed.','line_number':919,'multiline':False]['text':' Assign the 'returnKeySlot' to be the empty object.','line_number':949,'multiline':False]['text':' If 'reqs' has a kResult or kReturnKey request or if 'additionalFields' is not empty,','line_number':1055,'multiline':False]['text':' then we need to get all parts of the index key so that we can create the inflated','line_number':1056,'multiline':False]['text':' index key.','line_number':1057,'multiline':False]['text':' If the slots necessary for performing an index consistency check were not requested in','line_number':1063,'multiline':False]['text':' 'reqs', then set 'doIndexConsistencyCheck' to false to avoid generating unnecessary logic.','line_number':1064,'multiline':False]['text':' Remove the RecordId from the output if we were not requested to produce it.','line_number':1082,'multiline':False]['text':' COUNT_SCAN node doesn't expected to return index info.','line_number':1125,'multiline':False]['text':' forward ','line_number':1151,'multiline':True]['text':' forward ','line_number':1159,'multiline':True]['text':' indexKeysToInclude ','line_number':1162,'multiline':True]['text':' indexKeySlots ','line_number':1163,'multiline':True]['text':' lowPriority ','line_number':1167,'multiline':True]['text':' direction ','line_number':1177,'multiline':True]['text':' COUNT_SCAN stage doesn't produce any output, make an empty obj for kResult.','line_number':1193,'multiline':False]['text':' These are always safe since they will never match documents missing their field, or where','line_number':1209,'multiline':False]['text':' the element is an object or array.','line_number':1210,'multiline':False]['text':' NOT cannot be pushed into the cell traversal because for arrays, it should behave as','line_number':1295,'multiline':False]['text':' conjunction of negated child predicate on each element of the aray, but if we pushed it','line_number':1296,'multiline':False]['text':' into the traversal it would become a disjunction.','line_number':1297,'multiline':False]['text':' Create the balanced binary tree to keep the tree shallow and safe for recursion.','line_number':1335,'multiline':False]['text':' namespace','line_number':1351,'multiline':False]['text':' Get all the paths but make sure "_id" comes first (the order of paths given to the','line_number':1378,'multiline':False]['text':' column_scan stage defines the order of fields in the reconstructed record).','line_number':1379,'multiline':False]['text':' Identify the filtered columns, if any, and create slots/expressions for them.','line_number':1393,'multiline':False]['text':' Tag which of the paths should be included into the output.','line_number':1410,'multiline':False]['text':' projection when falling back to the row store','line_number':1412,'multiline':False]['text':' When building its output document (in 'recordSlot'), the 'ColumnStoreStage' should not try to','line_number':1423,'multiline':False]['text':' separately project both a document and its sub-fields (e.g., both 'a' and 'a.b'). Compute the','line_number':1424,'multiline':False]['text':' the subset of 'csn->allFields' that only includes a field if no other field in','line_number':1425,'multiline':False]['text':' 'csn->allFields' is its prefix.','line_number':1426,'multiline':False]['text':' Generate the expression that is applied to the row store record (in the case when the result','line_number':1437,'multiline':False]['text':' cannot be reconstructed from the index).','line_number':1438,'multiline':False]['text':' Avoid generating the row store expression if the projection is not necessary, as indicated by','line_number':1441,'multiline':False]['text':' the extraFieldsPermitted flag of the column store node.','line_number':1442,'multiline':False]['text':' We might get null abt if no paths were added to the builder. It means we should be','line_number':1445,'multiline':False]['text':' projecting an empty object.','line_number':1446,'multiline':False]['text':' Generate post assembly filter.','line_number':1467,'multiline':False]['text':' The child must produce a kRecordId slot, as well as all the kMeta and kSortKey slots required','line_number':1488,'multiline':False]['text':' by the parent of this FetchNode except for 'resultSlot'. Note that the child does _not_ need','line_number':1489,'multiline':False]['text':' to produce any kField slots. Any kField requests by the parent will be handled by the logic','line_number':1490,'multiline':False]['text':' below.','line_number':1491,'multiline':False]['text':' If the filter predicate doesn't need the whole document, then we take all the top-level','line_number':1540,'multiline':False]['text':' fields referenced by the filter predicate and we add them to 'fields'.','line_number':1541,'multiline':False]['text':' Only propagate kRecordId if requested.','line_number':1571,'multiline':False]['text':' Keep track of the number of entries in the "fields" vector that represent our output;','line_number':1593,'multiline':False]['text':' anything that gets added past this point by appendVectorUnique is coming from the vector of','line_number':1594,'multiline':False]['text':' sort keys.','line_number':1595,'multiline':False]['text':' If we have both limit and skip stages and the skip stage is beneath the limit, then','line_number':1647,'multiline':False]['text':' we can combine these two stages into one.','line_number':1648,'multiline':False]['text':'*
 * Given a field path, this function will return an expression that will be true if evaluating the
 * field path involves array traversal at any level of the path (including the leaf field).
 ','line_number':1679,'multiline':True]['text':'*
 * Given a field path, this function recursively builds an expression tree that will produce the
 * corresponding sort key for that path.
 ','line_number':1722,'multiline':True]['text':' Generate an expression to read a sub-field at the current nested level.','line_number':1744,'multiline':False]['text':' For the last level, we can just return the field slot without the need for a','line_number':1750,'multiline':False]['text':' traverse expression.','line_number':1751,'multiline':False]['text':' According to MQL's sorting semantics, when a leaf field is an empty array we','line_number':1762,'multiline':False]['text':' should use Undefined as the sort key.','line_number':1763,'multiline':False]['text':' Prepare a lambda expression that will navigate to the next component of the field path.','line_number':1776,'multiline':False]['text':' Generate the traverse expression for the current nested level.','line_number':1787,'multiline':False]['text':' Be sure to invoke the least/greatest fold expression only if the current nested level is an','line_number':1788,'multiline':False]['text':' array.','line_number':1789,'multiline':False]['text':' maxDepth ','line_number':1799,'multiline':True]['text':' According to MQL's sorting semantics, when a non-leaf field is an empty array or','line_number':1809,'multiline':False]['text':' doesn't exist we should use Null as the sort key.','line_number':1810,'multiline':False]['text':' namespace','line_number':1816,'multiline':False]['text':' getExecutor() should never call into buildSlotBasedExecutableTree() when the query','line_number':1834,'multiline':False]['text':' contains $meta, so this assertion should always be true.','line_number':1835,'multiline':False]['text':' If the sort pattern doesn't need the whole document, then we take all the top-level','line_number':1846,'multiline':False]['text':' fields referenced by the filter predicate and we add them to 'fields'.','line_number':1847,'multiline':False]['text':' When sort is followed by a limit the overhead of tracking the kField slots during sorting','line_number':1855,'multiline':False]['text':' is greater compared to the overhead of retrieving the necessary kFields from the BSON','line_number':1856,'multiline':False]['text':' object (kResult) after the sorting is done.','line_number':1857,'multiline':False]['text':' Handle the case where we are using kResult and there are no common prefixes.','line_number':1876,'multiline':False]['text':' Sorting has a limitation where only one of the sort patterns can involve arrays.','line_number':1879,'multiline':False]['text':' If there are at least two sort patterns, check the data for this possibility.','line_number':1880,'multiline':False]['text':' If the sort pattern only has one part, we don't need to generate a "parallel','line_number':1887,'multiline':False]['text':' arrays" check.','line_number':1888,'multiline':False]['text':' If the sort pattern has two parts, we can generate a simpler expression to','line_number':1891,'multiline':False]['text':' perform the "parallel arrays" check.','line_number':1892,'multiline':False]['text':' level ','line_number':1898,'multiline':True]['text':' If the sort pattern has three or more parts, we generate an expression to','line_number':1910,'multiline':False]['text':' perform the "parallel arrays" check that works (and scales well) for an','line_number':1911,'multiline':False]['text':' arbitrary number of sort pattern parts.','line_number':1912,'multiline':False]['text':' Apply the transformation required by the collation, if specified.','line_number':1963,'multiline':False]['text':' When there's no limit on the sort, the dominating factor is number of comparisons','line_number':1979,'multiline':False]['text':' (nlogn). A sort with a limit of k requires only nlogk comparisons. When k is small, the','line_number':1980,'multiline':False]['text':' number of key generations (n) can actually dominate the runtime. So for all top-k sorts','line_number':1981,'multiline':False]['text':' we use a "cheap" sort key: it's cheaper to construct but more expensive to compare. The','line_number':1982,'multiline':False]['text':' assumption here is that k << n.','line_number':1983,'multiline':False]['text':' generateSortKey() will handle the parallel arrays check and sort key traversal for us,','line_number':1996,'multiline':False]['text':' so we don't need to generate our own sort key traversal logic in the SBE plan.','line_number':1997,'multiline':False]['text':' In this case generateSortKey() produces a mem-comparable KeyString so we use for','line_number':2010,'multiline':False]['text':' the comparison. We always sort in ascending order because the KeyString takes the','line_number':2011,'multiline':False]['text':' ordering into account.','line_number':2012,'multiline':False]['text':' Generate the cheap sort key represented as an array then extract each component into','line_number':2016,'multiline':False]['text':' a slot:','line_number':2017,'multiline':False]['text':'','line_number':2018,'multiline':False]['text':' sort [s1, s2] [asc, dsc] ...','line_number':2019,'multiline':False]['text':' project s1=getElement(fullSortKey,0), s2=getElement(fullSortKey,1)','line_number':2020,'multiline':False]['text':' project fullSortKey=generateSortKeyCheap(bson)','line_number':2021,'multiline':False]['text':' Slots for sort stage to forward to parent stage. Values in these slots are not used during','line_number':2043,'multiline':False]['text':' sorting.','line_number':2044,'multiline':False]['text':' Project the fields that the parent requested using kResult','line_number':2058,'multiline':False]['text':' Clear from outputs everything that is not found in forwardingReqs and project from','line_number':2062,'multiline':False]['text':' kResult every required field not already in outputs.','line_number':2063,'multiline':False]['text':' The child must produce all of the slots required by the parent of this SortNode.','line_number':2098,'multiline':False]['text':' getExecutor() should never call into buildSlotBasedExecutableTree() when the query','line_number':2120,'multiline':False]['text':' contains $meta, so this assertion should always be true.','line_number':2121,'multiline':False]['text':' If a collation is set, wrap 'sortKeyExpr' with a call to collComparisonKey(). The','line_number':2134,'multiline':False]['text':' "comparison keys" returned by collComparisonKey() will be used in 'orderBy' instead','line_number':2135,'multiline':False]['text':' of the fields' actual values.','line_number':2136,'multiline':False]['text':' Slots for sort stage to forward to parent stage. Values in these slots are not used during','line_number':2151,'multiline':False]['text':' sorting.','line_number':2152,'multiline':False]['text':' Children must produce all of the slots required by the parent of this SortMergeNode. In','line_number':2197,'multiline':False]['text':' addition, children must always produce a 'recordIdSlot' if the 'dedup' flag is true, and','line_number':2198,'multiline':False]['text':' they must produce kField slots for each part of the sort pattern.','line_number':2199,'multiline':False]['text':' Children must produce a 'resultSlot' if they produce fetched results.','line_number':2208,'multiline':False]['text':' Stop propagating the RecordId output if none of our ancestors are going to use it.','line_number':2251,'multiline':False]['text':' If the filter predicate doesn't need the whole document, then we take all the top-level','line_number':2271,'multiline':False]['text':' fields referenced by the filter predicate and we add them to 'fields'.','line_number':2272,'multiline':False]['text':' The child must produce all of the slots required by the parent of this MatchNode. Also, if','line_number':2280,'multiline':False]['text':' the filter needs the whole document, the child must produce 'kResult' as well.','line_number':2281,'multiline':False]['text':'*
 * This builds the execution stage for an $unwind aggregation stage that has been pushed down to
 * SBE. This also builds a child project stage to get the field to be unwound, and ancestor project
 * stage(s) to add the $unwind outputs (value and optionally array index) to the result document.
 ','line_number':2304,'multiline':True]['text':'','line_number':2314,'multiline':False]['text':' Build the execution subtree for the child plan subtree.','line_number':2315,'multiline':False]['text':'','line_number':2316,'multiline':False]['text':' The child must produce all of the slots required by the parent of this UnwindNode, plus this','line_number':2318,'multiline':False]['text':' node needs to produce the result slot.','line_number':2319,'multiline':False]['text':' Clear the root of the original field being unwound so later plan stages do not reference it.','line_number':2322,'multiline':False]['text':'','line_number':2326,'multiline':False]['text':' Build a project execution child node to get the field to be unwound. This gets the value of','line_number':2327,'multiline':False]['text':' the field at the end of the full FieldPath out of the doc produced by the child and puts it','line_number':2328,'multiline':False]['text':' into 'getFieldSlot'. projectFieldsToSlots() is used instead of makeProjectStage() because','line_number':2329,'multiline':False]['text':' only the former supports dotted paths.','line_number':2330,'multiline':False]['text':'','line_number':2331,'multiline':False]['text':'','line_number':2344,'multiline':False]['text':' Build the unwind execution node itself. This will unwind the value in 'getFieldSlot' into','line_number':2345,'multiline':False]['text':' 'unwindSlot' and place the array index value into 'arrayIndexSlot'.','line_number':2346,'multiline':False]['text':'','line_number':2347,'multiline':False]['text':' inField ','line_number':2351,'multiline':True]['text':' outField ','line_number':2352,'multiline':True]['text':' outIndex ','line_number':2353,'multiline':True]['text':' yieldPolicy ','line_number':2356,'multiline':True]['text':' participateInTrialRunTracking ','line_number':2357,'multiline':True]['text':'','line_number':2359,'multiline':False]['text':' Build project parent node to add the unwind and/or index outputs to the result doc. Since','line_number':2360,'multiline':False]['text':' docs are immutable in SBE, doing this the simpler way via separate ProjectStages for each','line_number':2361,'multiline':False]['text':' output leads to an extra result doc copy if both unwind and index get projected. To avoid','line_number':2362,'multiline':False]['text':' this, we build a single ProjectStage that handles all possible combinations of needed','line_number':2363,'multiline':False]['text':' projections. This is simplified slightly by the fact that we know whether the index output','line_number':2364,'multiline':False]['text':' was requested or not, so we can wire only the relevant combinations.','line_number':2365,'multiline':False]['text':'','line_number':2366,'multiline':False]['text':' Paths in result document to project to.','line_number':2368,'multiline':False]['text':' Variables whose values are to be projected into the result document.','line_number':2371,'multiline':False]['text':' The projection expression that adds the index and/or unwind values to the result doc.','line_number':2374,'multiline':False]['text':' "includeArrayIndex" option (Cases 1-3). The index is always projected in these.','line_number':2378,'multiline':False]['text':' If our parent wants the array index field, set our outputs to point it to that slot.','line_number':2380,'multiline':False]['text':' Case 1: index Null, unwind val //////////////////////////////////////////////////////////','line_number':2387,'multiline':False]['text':' We need two copies of the Case 1 expression as it is used twice, but the copy constructor','line_number':2388,'multiline':False]['text':' is deleted so we are forced to std::move it.','line_number':2389,'multiline':False]['text':' Index output','line_number':2396,'multiline':False]['text':' Unwind output','line_number':2400,'multiline':False]['text':' current result doc: updated by the projection','line_number':2409,'multiline':False]['text':' Case 2: index val, unwind val ///////////////////////////////////////////////////////////','line_number':2412,'multiline':False]['text':' Index output','line_number':2416,'multiline':False]['text':' Unwind output','line_number':2420,'multiline':False]['text':' current result doc: updated by the projection','line_number':2429,'multiline':False]['text':' Case 3: index Null //////////////////////////////////////////////////////////////////////','line_number':2431,'multiline':False]['text':' Index output','line_number':2435,'multiline':False]['text':' current result document: updated by the projection','line_number':2444,'multiline':False]['text':' Wrap the above projection subexpressions in conditionals that correctly handle quirky MQL','line_number':2446,'multiline':False]['text':' edge cases:','line_number':2447,'multiline':False]['text':'   if isNull(index)','line_number':2448,'multiline':False]['text':'      then if exists(unwind)','line_number':2449,'multiline':False]['text':'              then project {Null, unwind}','line_number':2450,'multiline':False]['text':'              else project {Null,       }','line_number':2451,'multiline':False]['text':'      else if index >= 0','line_number':2452,'multiline':False]['text':'              then project {index, unwind}','line_number':2453,'multiline':False]['text':'              else project {Null,  unwind}','line_number':2454,'multiline':False]['text':' outer if ','line_number':2457,'multiline':True]['text':' outer then ','line_number':2459,'multiline':True]['text':' inner1 if ','line_number':2461,'multiline':True]['text':' inner1 then ','line_number':2463,'multiline':True]['text':' inner1 else ','line_number':2464,'multiline':True]['text':' outer else ','line_number':2465,'multiline':True]['text':' inner2 if ','line_number':2467,'multiline':True]['text':' inner2 then ','line_number':2471,'multiline':True]['text':' inner2 else ','line_number':2472,'multiline':True]['text':' No "includeArrayIndex" option (Cases 4-5). The index is never projected in these.','line_number':2475,'multiline':False]['text':' Case 4: unwind val //////////////////////////////////////////////////////////////////////','line_number':2477,'multiline':False]['text':' Unwind output','line_number':2481,'multiline':False]['text':' current result document: updated by the projection','line_number':2490,'multiline':False]['text':' Case 5: NO-OP - original doc ////////////////////////////////////////////////////////////','line_number':2492,'multiline':False]['text':' Does not need a generateProjection() call as it will be handled in the wrapper logic.','line_number':2493,'multiline':False]['text':' Wrap 'unwindValProjExpr' in a conditional that correctly handles the quirky MQL edge','line_number':2495,'multiline':False]['text':' cases. If the unwind field was not an array (indicated by 'arrayIndexSlot' containing','line_number':2496,'multiline':False]['text':' Null), we avoid projecting its value to the result, as if it is Nothing (instead of a','line_number':2497,'multiline':False]['text':' singleton) this would incorrectly create the dotted path above that value in the result','line_number':2498,'multiline':False]['text':' document. We don't need to project in the singleton case either as the result doc already','line_number':2499,'multiline':False]['text':' has that singleton at the unwind field location.','line_number':2500,'multiline':False]['text':' if ','line_number':2504,'multiline':True]['text':' then no-op ','line_number':2505,'multiline':True]['text':' else project ','line_number':2506,'multiline':True]['text':' else no "includeArrayIndex"','line_number':2508,'multiline':False]['text':' Create the ProjectStage that adds the output(s) to the result doc via 'finalProjectExpr'.','line_number':2510,'multiline':False]['text':' output result document','line_number':2514,'multiline':False]['text':' buildUnwind','line_number':2519,'multiline':False]['text':'*
 * Create a ProjectStage that evalutes the "newRoot" expression from a $replaceRoot pipeline stage
 * and append it to the root of the SBE plan.
 ','line_number':2521,'multiline':True]['text':' The $replaceRoot operation only ever needs 'kResult' if there are operations in the 'newRoot'','line_number':2533,'multiline':False]['text':' expression that need the whole document.','line_number':2534,'multiline':False]['text':' MQL semantics require $replaceRoot to fail if newRoot expression does not evaluate to an','line_number':2542,'multiline':False]['text':' object. We fill empty results with null and wrap the generated expression in an if statement','line_number':2543,'multiline':False]['text':' that fails if it does not evaluate to an object.','line_number':2544,'multiline':False]['text':' The wrapper checks that we add to 'validatedNewRootExpression' ensure that we will only ever','line_number':2559,'multiline':False]['text':' output a result with an object type, even if the type checker does not narrow down the set of','line_number':2560,'multiline':False]['text':' possible types that far.','line_number':2561,'multiline':False]['text':' buildReplaceRoot','line_number':2577,'multiline':False]['text':' Scan the ProjectNodes and build various path sets.','line_number':2709,'multiline':False]['text':' Scan the required fields and determine post-projection which paths will be Nothing','line_number':2736,'multiline':False]['text':' ('nothingPaths'), which paths will be unchanged ('passthruPaths'), which paths are','line_number':2737,'multiline':False]['text':' begin assigned exprs ('updatedPaths'), and which paths will need to be read from','line_number':2738,'multiline':False]['text':' kResult ('resultPaths').','line_number':2739,'multiline':False]['text':' We already checked 'keepDropPathSet' above. Here we check 'modifiedOrCreatedPathSet'','line_number':2759,'multiline':False]['text':' and 'pathPrefixSet' (or, if 'pathAllowed' is false, we check 'createdPathSet' and','line_number':2760,'multiline':False]['text':' 'createdPathPrefixSet').','line_number':2761,'multiline':False]['text':' The "covered projection" optimization can be used for this projection if and only if','line_number':2805,'multiline':False]['text':' all of the following conditions are met:','line_number':2806,'multiline':False]['text':'   1) 'isInclusion' is true.','line_number':2807,'multiline':False]['text':'   2) The 'nodes' vector contains Keep nodes only.','line_number':2808,'multiline':False]['text':'   3) The 'root' subtree has at least one unfetched IXSCAN node. (A corollary of this','line_number':2809,'multiline':False]['text':'      condition is that 'root->fetched()' must also be false.)','line_number':2810,'multiline':False]['text':'   4) Each pattern from each of the unfetched IXSCANs in the 'root' subtree contains','line_number':2811,'multiline':False]['text':'      all of projection paths that are needed by root's parent.','line_number':2812,'multiline':False]['text':'   5) For each top-level field needed by root's parent, the order of its subfields is','line_number':2813,'multiline':False]['text':'      statically knowable. (This condition is trivially met if there are no common','line_number':2814,'multiline':False]['text':'      prefixes among the projection paths needed by root's parent.)','line_number':2815,'multiline':False]['text':' Build a set of the projection paths, build a prefix set of projection paths, and','line_number':2826,'multiline':False]['text':' check if there are two or more paths with a common prefix.','line_number':2827,'multiline':False]['text':' If two of more paths needed by root's parent have a common prefix and the 'root' subtree','line_number':2844,'multiline':False]['text':' contains one or more FETCHs, then it's not possible to statically determine the subfield','line_number':2845,'multiline':False]['text':' order for all the top-level fields needed by root's parent. In this case, we can use the','line_number':2846,'multiline':False]['text':' "covered projection" optimization because we can't meet condition #4 listed above.','line_number':2847,'multiline':False]['text':' Read the pattern for this IXSCAN and build a part set. If the projection','line_number':2859,'multiline':False]['text':' paths have a common prefix, we also initialize the 'patternData' vector.','line_number':2860,'multiline':False]['text':' If this pattern does not contain all of the projection paths needed by','line_number':2876,'multiline':False]['text':' root's parent, then we can't use the "covered projection" optimization.','line_number':2877,'multiline':False]['text':' If the projection paths have a common prefix, determine the subfield order','line_number':2884,'multiline':False]['text':' for each top-level field produced by this IXSCAN.','line_number':2885,'multiline':False]['text':'','line_number':2886,'multiline':False]['text':' If this is the first IXSCAN in 'ixNodes', store its subfield order info into','line_number':2887,'multiline':False]['text':' 'patternWithTopLevelSorted'. If this is not the first IXSCAN in 'ixNodes',','line_number':2888,'multiline':False]['text':' compare its subfield order with what's stored in 'patternWithTopLevelSorted'.','line_number':2889,'multiline':False]['text':' If there are two or more IXSCANs whose patterns differ with respect to','line_number':2903,'multiline':False]['text':' how subfields are ordered, then we can't use the "covered projection"','line_number':2904,'multiline':False]['text':' optimization in this case because we can't meet condition #4 above.','line_number':2905,'multiline':False]['text':' If we know the post-image "allowed" field set is going to have more than 2 fields no matter','line_number':2919,'multiline':False]['text':' what based on looking at the size of 'allowed' and 'nodes', then we can just bail out early','line_number':2920,'multiline':False]['text':' and return boost::none.','line_number':2921,'multiline':False]['text':' Compute the post-image "allowed" field set. If 'postImageAllowedFields' 2 or more non-"_id"','line_number':2925,'multiline':False]['text':' fields, then we know it's not possible to materialize kResult using a fixed plan with a','line_number':2926,'multiline':False]['text':' resultBase.','line_number':2927,'multiline':False]['text':' Remove "_id" from 'postImageAllowedFields'. At this point, all the should remain in','line_number':2943,'multiline':False]['text':' 'postImageAllowedFields' (if anything) is the non-"_id" field.','line_number':2944,'multiline':False]['text':' Build the result and return it.','line_number':2947,'multiline':False]['text':' namespace','line_number':3010,'multiline':False]['text':' Get the ProjectNodes.','line_number':3021,'multiline':False]['text':' Get the parent's requirements.','line_number':3026,'multiline':False]['text':' Map the parent's required fields onto the outputs of this projection.','line_number':3071,'multiline':False]['text':' Eliminate parts of the projection that are known to be no-ops.','line_number':3083,'multiline':False]['text':' Compute the dependencies of any expressions in this projection that we need.','line_number':3118,'multiline':False]['text':' Figure out if this projection can use the "covered projection" optimization.','line_number':3167,'multiline':False]['text':' For covered projections, we ask our child directly for all the paths from 'paths'.','line_number':3171,'multiline':False]['text':' Clear 'fields'. We're going to re-build the list of fields to match the order of','line_number':3181,'multiline':False]['text':' ixn's key pattern.','line_number':3182,'multiline':False]['text':' If 'fields' contains "_id", handle that first.','line_number':3185,'multiline':False]['text':' Remove "_id" from 'fieldSet' so that the loop below doesn't add another occurrence.','line_number':3188,'multiline':False]['text':' Loop over ixn's key pattern and re-build the list of fields.','line_number':3192,'multiline':False]['text':' If 'useCoveredProjection' is false, figure out if this projection can use a fixed plan','line_number':3206,'multiline':False]['text':' without a resultBase.','line_number':3207,'multiline':False]['text':' If our parent doesn't need the full kResult object, then we can use a fixed plan without','line_number':3211,'multiline':False]['text':' a resultBase. If our parent needs kResult and this is an inclusion and we if can prove','line_number':3212,'multiline':False]['text':' that kResult will only have a single field or that kResult will only have "_id" and one','line_number':3213,'multiline':False]['text':' other field, then we can use a fixed plan. Otherwise, we cannot use a fixed plan.','line_number':3214,'multiline':False]['text':' If both 'useCoveredProjection' and 'useInputPlanWithoutObj' are false, figure out if','line_number':3233,'multiline':False]['text':' this projection can ask its descendants for kMakeResultInfo.','line_number':3234,'multiline':False]['text':' Verify that the effects of this projection's descendants would be compatible with','line_number':3237,'multiline':False]['text':' the MakeResultInfo req that this node would issue.','line_number':3238,'multiline':False]['text':' createdFieldSet ','line_number':3246,'multiline':True]['text':' Skip non-projection descendants.','line_number':3258,'multiline':False]['text':' Compose 'effects' with the descendant's effects and store the result into','line_number':3265,'multiline':False]['text':' 'effectsWithDesc'.','line_number':3266,'multiline':False]['text':' Check if this descendant would be able to support the MakeResultInfo req that it','line_number':3273,'multiline':False]['text':' would receive from its parent.','line_number':3274,'multiline':False]['text':' If this descendant wouldn't be able to support the MakeResultInfo req, then we','line_number':3280,'multiline':False]['text':' opt to not ask our child for MakeResultInfo.','line_number':3281,'multiline':False]['text':' If none of the descendants could support a request for MakeResultInfo, then it's not','line_number':3285,'multiline':False]['text':' worth it to ask our child for MakeResultInfo.','line_number':3286,'multiline':False]['text':' If we need to make a result and if we can't use the "covered projection" optimization and we','line_number':3294,'multiline':False]['text':' can't use a fixed plan or we can't ask for a MakeResultInfo from our child, then we have to','line_number':3295,'multiline':False]['text':' ask our child to produce kResult.','line_number':3296,'multiline':False]['text':' Start preparing the requirements for our child.','line_number':3302,'multiline':False]['text':' If our parent requested MakeResultInfo and we were able to support the MakeResultInfo req,','line_number':3306,'multiline':False]['text':' then we need to update the MakeResultInfo req inside 'childReqs' to reflect the effects of','line_number':3307,'multiline':False]['text':' this projection.','line_number':3308,'multiline':False]['text':' If our parent requested kMakeResultInfo but we weren't able to support the req, then we need','line_number':3313,'multiline':False]['text':' to clear the kMakeResultInfo req so it doesn't propogate to our child.','line_number':3314,'multiline':False]['text':' If our parent didn't request kMakeResultInfo and we decided to ask our child for','line_number':3319,'multiline':False]['text':' kMakeResultInfo, then we need to set up the initial kMakeResultInfo req.','line_number':3320,'multiline':False]['text':' Get the ProjectionEffects for this projection and replace all kCreates with kModify.','line_number':3322,'multiline':False]['text':' createdFieldSet ','line_number':3328,'multiline':True]['text':' Compose 'effects' with 'childAllowedFields'. This will effectively','line_number':3331,'multiline':False]['text':' add kDrops to 'effects' for every field that is known to not exist. Also,','line_number':3332,'multiline':False]['text':' if 'effects.defaultEffect' is kKeep and 'childAllowedFields' has a','line_number':3333,'multiline':False]['text':' finite "allowed" set, then 'effects.defaultEffect' will be set to kDrop.','line_number':3334,'multiline':False]['text':' Populate 'projInputFields' with the fields modified or created by this projection.','line_number':3337,'multiline':False]['text':' Populate 'projNothingInputFields' with fields created by this projection that are','line_number':3344,'multiline':False]['text':' known to not exist in the pre-image.','line_number':3345,'multiline':False]['text':' Add a MakeResultInfo request to 'childReqs'.','line_number':3352,'multiline':False]['text':' Compute the list of fields that we need to request from our child.','line_number':3356,'multiline':False]['text':' Call build() on the child.','line_number':3415,'multiline':False]['text':' Update 'outputs' so that the kField slot for each field in 'plan->projNothingInputFields'','line_number':3419,'multiline':False]['text':' is set to Nothing.','line_number':3420,'multiline':False]['text':' If 'effects' has at least one Modify/Create effect, or if this is an exclusion','line_number':3473,'multiline':False]['text':' projection and 'effects.defaultEffect' is Drop, then make a MakeObjInputPlan.','line_number':3474,'multiline':False]['text':' If there are no Create/Modify effects and either this is an inclusion or','line_number':3488,'multiline':False]['text':' 'effects.defaultEffefts' is not Drop, then we can take kResultBase from our','line_number':3489,'multiline':False]['text':' child and pass it to makeBsonObj() without using a MakeObjInputPlan.','line_number':3490,'multiline':False]['text':' If this is an exclusion projection, take all of the fields this projection','line_number':3492,'multiline':False]['text':' promised it would drop (via its MakeResultInfo req) and manually add "drop"','line_number':3493,'multiline':False]['text':' actions to 'paths' / 'nodes' for each of these fields.','line_number':3494,'multiline':False]['text':' When doing a covered projection, we need to re-order 'paths' so that it matches the order','line_number':3518,'multiline':False]['text':' of the ixn's pattern, and we need to replace all the "Keep" nodes with "SbExpr" nodes.','line_number':3519,'multiline':False]['text':' Do two passes, collecting all paths that start with "_id" during the first pass and','line_number':3524,'multiline':False]['text':' collecting all other paths during the second pass.','line_number':3525,'multiline':False]['text':' Materialize kResult (or a temporary subset of kResult) if needed.','line_number':3594,'multiline':False]['text':' resultBase ','line_number':3616,'multiline':True]['text':' Update kField slots in 'outputs' as appropriate.','line_number':3684,'multiline':False]['text':' Set kField slots to Nothing as appropriate.','line_number':3690,'multiline':False]['text':' Assign values retrieved from kResult to kField slots as appropriate.','line_number':3700,'multiline':False]['text':' Add the visible field drops/modifys from this projection to the MakeResultInfo.','line_number':3724,'multiline':False]['text':' If the materialized kResult was temporary, remove kResult from 'outputs'.','line_number':3735,'multiline':False]['text':' If the filter predicate doesn't need the whole document, then we take all the top-level','line_number':3753,'multiline':False]['text':' fields referenced by the filter predicate and we add them to 'fields'.','line_number':3754,'multiline':False]['text':' Children must produce all of the slots required by the parent of this OrNode. In addition','line_number':3762,'multiline':False]['text':' to that, children must always produce a 'recordIdSlot' if the 'dedup' flag is true, and','line_number':3763,'multiline':False]['text':' children must produce a 'resultSlot' if 'filter' needs the whole document.','line_number':3764,'multiline':False]['text':' Stop propagating the RecordId output if none of our ancestors are going to use it.','line_number':3798,'multiline':False]['text':' TextMatchNode guarantees to produce a fetched sub-plan, but it doesn't fetch itself. Instead,','line_number':3828,'multiline':False]['text':' its child sub-plan must be fully fetched, and a text match plan is constructed under this','line_number':3829,'multiline':False]['text':' assumption.','line_number':3830,'multiline':False]['text':' Create an FTS 'matcher' to apply 'ftsQuery' to matching documents.','line_number':3837,'multiline':False]['text':' Build an 'ftsMatch' expression to match a document stored in the 'kResult' slot using the','line_number':3841,'multiline':False]['text':' 'matcher' instance.','line_number':3842,'multiline':False]['text':' Wrap the 'ftsMatch' expression into an 'if' expression to ensure that it can be applied only','line_number':3849,'multiline':False]['text':' to a document.','line_number':3850,'multiline':False]['text':' Add a filter stage to apply 'ftsQuery' to matching documents and discard documents which do','line_number':3857,'multiline':False]['text':' not match.','line_number':3858,'multiline':False]['text':' Assign the 'returnKeySlot' to be the empty object.','line_number':3863,'multiline':False]['text':' TODO SERVER-49509: If the projection includes {$meta: "sortKey"}, the result of this stage','line_number':3878,'multiline':False]['text':' should also include the sort key. Everything else in the projection is ignored.','line_number':3879,'multiline':False]['text':' The child must produce all of the slots required by the parent of this ReturnKeyNode except','line_number':3882,'multiline':False]['text':' for 'resultSlot'. In addition to that, the child must always produce a 'returnKeySlot'.','line_number':3883,'multiline':False]['text':' After build() returns, we take the 'returnKeySlot' produced by the child and store it into','line_number':3884,'multiline':False]['text':' 'resultSlot' for the parent of this ReturnKeyNode to consume.','line_number':3885,'multiline':False]['text':' Designate outputs.','line_number':3934,'multiline':False]['text':' If there are more than 2 children, iterate all remaining children and hash','line_number':3972,'multiline':False]['text':' join together.','line_number':3973,'multiline':False]['text':' The previous HashJoinStage is always set as the inner stage, so that we can reuse the','line_number':3983,'multiline':False]['text':' innerIdSlot and innerResultSlot that have been designated as outputs.','line_number':3984,'multiline':False]['text':' Need at least two children.','line_number':4004,'multiline':False]['text':' Designate outputs.','line_number':4035,'multiline':False]['text':' If there are more than 2 children, iterate all remaining children and merge','line_number':4076,'multiline':False]['text':' join together.','line_number':4077,'multiline':False]['text':' Register a SlotId in the global environment which would contain a recordId to resume a','line_number':4107,'multiline':False]['text':' tailable collection scan from. A PlanStage executor will track the last seen recordId and','line_number':4108,'multiline':False]['text':' will reset a SlotAccessor for the resumeRecordIdSlot with this recordId.','line_number':4109,'multiline':False]['text':' For tailable collection scan we need to build a special union sub-tree consisting of two','line_number':4113,'multiline':False]['text':' branches:','line_number':4114,'multiline':False]['text':'   1) An anchor branch implementing an initial collection scan before the first EOF is hit.','line_number':4115,'multiline':False]['text':'   2) A resume branch implementing all consecutive collection scans from a recordId which was','line_number':4116,'multiline':False]['text':'      seen last.','line_number':4117,'multiline':False]['text':'','line_number':4118,'multiline':False]['text':' The 'makeStage' parameter is used to build a PlanStage tree which is served as a root stage','line_number':4119,'multiline':False]['text':' for each of the union branches. The same mechanism is used to build each union branch, and','line_number':4120,'multiline':False]['text':' the special logic which needs to be triggered depending on which branch we build is','line_number':4121,'multiline':False]['text':' controlled by setting the isTailableCollScanResumeBranch flag in PlanStageReqs.','line_number':4122,'multiline':False]['text':' Build the anchor branch and resume branch of the union.','line_number':4131,'multiline':False]['text':' Add a constant filter on top of the anchor branch, so that it would only execute on an','line_number':4135,'multiline':False]['text':' initial collection scan, that is, when resumeRecordId is not available yet.','line_number':4136,'multiline':False]['text':' Add a constant filter on top of the resume branch, so that it would only execute when we','line_number':4143,'multiline':False]['text':' resume a collection scan from the resumeRecordId.','line_number':4144,'multiline':False]['text':' Branch output slots become the input slots to the union.','line_number':4166,'multiline':False]['text':' Constructs an optimized SBE plan for 'filterNode' in the case that the fields of the','line_number':4176,'multiline':False]['text':' 'shardKeyPattern' are provided by 'child'. In this case, the SBE tree for 'child' will','line_number':4177,'multiline':False]['text':' fill out slots for the necessary components of the index key. These slots can be read','line_number':4178,'multiline':False]['text':' directly in order to determine the shard key that should be passed to the','line_number':4179,'multiline':False]['text':' 'shardFiltererSlot'.','line_number':4180,'multiline':False]['text':' Extract the child's key pattern.','line_number':4187,'multiline':False]['text':' If we're sharded make sure that we don't return data that isn't owned by the shard. This','line_number':4194,'multiline':False]['text':' situation can occur when pending documents from in-progress migrations are inserted and when','line_number':4195,'multiline':False]['text':' there are orphaned documents from aborted migrations. To check if the document is owned by','line_number':4196,'multiline':False]['text':' the shard, we need to own a 'ShardFilterer', and extract the document's shard key as a','line_number':4197,'multiline':False]['text':' BSONObj.','line_number':4198,'multiline':False]['text':' We register the "shardFilterer" slot but we don't construct the ShardFilterer here, because','line_number':4200,'multiline':False]['text':' once constructed the ShardFilterer will prevent orphaned documents from being deleted. We','line_number':4201,'multiline':False]['text':' will construct the ShardFilterer later while preparing the SBE tree for execution.','line_number':4202,'multiline':False]['text':' Maps from key name to a bool that indicates whether the key is hashed.','line_number':4212,'multiline':False]['text':' Build expressions to create shard key fields and deal with hashed shard keys.','line_number':4219,'multiline':False]['text':' Get the value stored in the index for this component of the shard key. We may have to','line_number':4231,'multiline':False]['text':' hash it.','line_number':4232,'multiline':False]['text':' Handle the case where the index key or shard key is hashed.','line_number':4235,'multiline':False]['text':' If the index stores hashed data, then we know the shard key field is hashed as','line_number':4238,'multiline':False]['text':' well. Nothing to do here. We can apply shard filtering with no other changes.','line_number':4239,'multiline':False]['text':' The shard key field is hashed but the index stores unhashed data. We must apply','line_number':4244,'multiline':False]['text':' the hash function before passing this off to the shard filter.','line_number':4245,'multiline':False]['text':' If we're not required to fill out the 'kResult' slot, then instead we can request a slot from','line_number':4270,'multiline':False]['text':' the child for each of the fields which constitute the shard key. This allows us to avoid','line_number':4271,'multiline':False]['text':' materializing an intermediate object for plans where shard filtering can be performed based','line_number':4272,'multiline':False]['text':' on the contents of index keys.','line_number':4273,'multiline':False]['text':'','line_number':4274,'multiline':False]['text':' We only apply this optimization in the special case that the child QSN is an IXSCAN, since in','line_number':4275,'multiline':False]['text':' this case we can request exactly the fields we need according to their position in the index','line_number':4276,'multiline':False]['text':' key pattern.','line_number':4277,'multiline':False]['text':' If we're sharded make sure that we don't return data that isn't owned by the shard. This','line_number':4284,'multiline':False]['text':' situation can occur when pending documents from in-progress migrations are inserted and when','line_number':4285,'multiline':False]['text':' there are orphaned documents from aborted migrations. To check if the document is owned by','line_number':4286,'multiline':False]['text':' the shard, we need to own a 'ShardFilterer', and extract the document's shard key as a','line_number':4287,'multiline':False]['text':' BSONObj.','line_number':4288,'multiline':False]['text':' We register the "shardFilterer" slot but we don't construct the ShardFilterer here, because','line_number':4290,'multiline':False]['text':' once constructed the ShardFilterer will prevent orphaned documents from being deleted. We','line_number':4291,'multiline':False]['text':' will construct the ShardFilterer later while preparing the SBE tree for execution.','line_number':4292,'multiline':False]['text':' Request slots for top level shard key fields and cache parsed key path.','line_number':4296,'multiline':False]['text':' Return true iff 'wfStmt' is a $topN or $bottomN operator.','line_number':4317,'multiline':False]['text':' Return true iff 'wfStmt' is one of $topN, $bottomN, $minN, $maxN, $firstN or $lastN.','line_number':4326,'multiline':False]['text':' namespace','line_number':4434,'multiline':False]['text':' If the parent requires kResult or MakeResultInfo, or if reqs.getFields() contained a dotted','line_number':4449,'multiline':False]['text':' path, or if 'windowNode->outputFields' contains a dotted path P where 'getTopLevelField(P)'','line_number':4450,'multiline':False]['text':' is in 'reqFieldSet', then we need to materialize kResult.','line_number':4451,'multiline':False]['text':' kResult is required for generating sort-key in $topN/$bottomN','line_number':4463,'multiline':False]['text':' Create a tuple of slots for each new slot added.','line_number':4484,'multiline':False]['text':' Get stages for partition by.','line_number':4526,'multiline':False]['text':' Assert partition slot is not an array.','line_number':4536,'multiline':False]['text':' Calculate list of forward slots.','line_number':4551,'multiline':False]['text':' Calculate slot for document position based window bounds, and add corresponding stages.','line_number':4556,'multiline':False]['text':' Calculate sort-by slot, and add corresponding stages.','line_number':4572,'multiline':False]['text':' Calculate slot for range and time range based window bounds','line_number':4594,'multiline':False]['text':' Creating window definitions, including the slots and expressions for the bounds and','line_number':4640,'multiline':False]['text':' accumulators.','line_number':4641,'multiline':False]['text':' We project window function input arguments in order to avoid repeated evaluation','line_number':4650,'multiline':False]['text':' for both add and remove expressions.','line_number':4651,'multiline':False]['text':' Check whether window is removable or not.','line_number':4659,'multiline':False]['text':' Create a fake accumulation statement for non-removable window bounds.','line_number':4688,'multiline':False]['text':' Get init expression arg for relevant functions','line_number':4691,'multiline':False]['text':' View ','line_number':4767,'multiline':True]['text':' View ','line_number':4770,'multiline':True]['text':' Build the key expression','line_number':4799,'multiline':False]['text':' View ','line_number':4832,'multiline':True]['text':' Create init/add/remove expressions.','line_number':4851,'multiline':False]['text':' Build bound expressions and create window definitions.','line_number':4907,'multiline':False]['text':' Create frame first and last slots if the window requires.','line_number':4909,'multiline':False]['text':' Build extra arguments for finalize expressions.','line_number':5032,'multiline':False]['text':' The window bounds of $shift is DocumentBounds{shiftByPos, shiftByPos}, so it is a','line_number':5095,'multiline':False]['text':' window frame of size 1. So $shift is equivalent to $first or $last on the window','line_number':5096,'multiline':False]['text':' bound.','line_number':5097,'multiline':False]['text':' Build finalize expressions.','line_number':5113,'multiline':False]['text':' Deal with empty window for finalize expressions.','line_number':5135,'multiline':False]['text':' If 'outputField' is not a dotted path, add 'outputField' and its corresponding slot','line_number':5163,'multiline':False]['text':' to 'outputPathMap'.','line_number':5164,'multiline':False]['text':' Assign frame first/last slots to window definitions.','line_number':5175,'multiline':False]['text':' Calculate sliding window.','line_number':5187,'multiline':False]['text':' Get final window outputs.','line_number':5197,'multiline':False]['text':' Now that we're done generating all the expressions we need to generate, we can finally','line_number':5201,'multiline':False]['text':' update the kField slots in 'outputs' to reflect the effects of this stage.','line_number':5202,'multiline':False]['text':' Materialize kResult if needed.','line_number':5210,'multiline':False]['text':' buildWindow','line_number':5233,'multiline':False]['text':' Register search query parameter slots.','line_number':5279,'multiline':False]['text':' val ','line_number':5282,'multiline':True]['text':' owned ','line_number':5283,'multiline':True]['text':' val ','line_number':5287,'multiline':True]['text':' Search cursor stage output slots','line_number':5301,'multiline':False]['text':' Register the $$SEARCH_META slot.','line_number':5305,'multiline':False]['text':' We have to generate all search metadata slots until we have migrate everything to SBE, this','line_number':5314,'multiline':False]['text':' is because the metadata usage may depends on post-SBE DocumentSources in the pipeline, the','line_number':5315,'multiline':False]['text':' SBE plan cache won't work in this case.','line_number':5316,'multiline':False]['text':' Make a project stage to convert '_id' field value into keystring.','line_number':5363,'multiline':False]['text':' indexKeysToInclude ','line_number':5397,'multiline':True]['text':' indexKeySlots ','line_number':5398,'multiline':True]['text':' forward ','line_number':5402,'multiline':True]['text':' lowPriority ','line_number':5403,'multiline':True]['text':' Slot stores the resulting document.','line_number':5405,'multiline':False]['text':' Slot stores rid if it it found, in our case same as seekRecordIdSlot.','line_number':5408,'multiline':False]['text':' Join the idx scan stage with fetch stage.','line_number':5411,'multiline':False]['text':' slotsToForward ','line_number':5424,'multiline':True]['text':' Join the search_cursor+project stage with idx_scan+fetch stage.','line_number':5426,'multiline':False]['text':' skip ','line_number':5432,'multiline':True]['text':' predicate ','line_number':5435,'multiline':True]['text':' Returns a non-null pointer to the root of a plan tree, or a non-OK status if the PlanStage tree','line_number':5451,'multiline':False]['text':' could not be constructed.','line_number':5452,'multiline':False]['text':' Define the 'builderCallback' typedef.','line_number':5455,'multiline':False]['text':' In SBE TEXT_OR behaves like a regular OR. All the work to support "textScore"','line_number':5478,'multiline':False]['text':' metadata is done outside of TEXT_OR, unlike the legacy implementation.','line_number':5479,'multiline':False]['text':' If this plan is for a tailable cursor scan, and we're not already in the process of building','line_number':5506,'multiline':False]['text':' a special union sub-tree implementing such scans, then start building a union sub-tree. Note','line_number':5507,'multiline':False]['text':' that LIMIT or SKIP stage is used as a splitting point of the two union branches, if present,','line_number':5508,'multiline':False]['text':' because we need to apply limit (or skip) only in the initial scan (in the anchor branch), and','line_number':5509,'multiline':False]['text':' the resume branch should not have it.','line_number':5510,'multiline':False]['text':' If the MakeResultInfo req wasn't satisfied by the child stage, make a "default"','line_number':5533,'multiline':False]['text':' MakeResultInfo object.','line_number':5534,'multiline':False]['text':' Throw an error if one or more of this MakeResultInfo's required Names are missing from','line_number':5546,'multiline':False]['text':' 'outputs' (ignoring kField Names, which will be checked separately during the next step','line_number':5547,'multiline':False]['text':' below).','line_number':5548,'multiline':False]['text':' Check if there are any required kField slots that are missing.','line_number':5561,'multiline':False]['text':' If any required kFields slots are missing, populate them (or throw an error if there is not','line_number':5580,'multiline':False]['text':' a kResult slot or a compatible kResultBase slot to retrieve the field from).','line_number':5581,'multiline':False]['text':' Metadata is exhausted by current node, later nodes/stages won't see metadata from input.','line_number':5606,'multiline':False]['text':' Clear non-required slots (excluding ~10 stages to preserve legacy behavior for now),','line_number':5610,'multiline':False]['text':' and also clear MakeResultInfo if it's not required.','line_number':5611,'multiline':False]['text':' Clear kResult if it's not required (excluding most cases when getMRInfo() is null','line_number':5620,'multiline':False]['text':' to preserve legacy behavior).','line_number':5621,'multiline':False]['text':' namespace mongo::stage_builder','line_number':5629,'multiline':False]