['text':'*
 *    Copyright (C) 2022-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: keep','line_number':48,'multiline':False]['text':'forValidation','line_number':86,'multiline':True]['text':' making a copy of CollecitonStatistics to override','line_number':87,'multiline':False]['text':' ndv including bucket boundary','line_number':99,'multiline':True]['text':' Add bucket boundary value to bounds.','line_number':110,'multiline':False]['text':' Create a histogram bucket.','line_number':117,'multiline':False]['text':' ndv excluding bucket boundary','line_number':121,'multiline':True]['text':' Add bucket boundary value to bounds.','line_number':133,'multiline':False]['text':' Increment count of values for each type tag.','line_number':140,'multiline':False]['text':' Set up scalar type counts.','line_number':181,'multiline':False]['text':' Set up histograms.','line_number':185,'multiline':False]['text':' Construct a histogram with two buckets: one for 3 ints equal to 1, another for 5 strings','line_number':221,'multiline':False]['text':' equal to "ing".','line_number':222,'multiline':False]['text':' frequency ','line_number':226,'multiline':True]['text':' frequency ','line_number':227,'multiline':True]['text':' Test $eq.','line_number':230,'multiline':False]['text':' Test case when field doesn't match fieldpath of histogram. This falls back to heuristics.','line_number':236,'multiline':False]['text':' Test $gt.','line_number':239,'multiline':False]['text':' Test $lt.','line_number':247,'multiline':False]['text':' Test $gte.','line_number':255,'multiline':False]['text':' Test $lte.','line_number':263,'multiline':False]['text':' Construct a histogram with three int buckets for field 'a'.','line_number':276,'multiline':False]['text':' frequency ','line_number':279,'multiline':True]['text':' frequency ','line_number':280,'multiline':True]['text':' frequency ','line_number':281,'multiline':True]['text':' Construct a histogram with two int buckets for field 'b'.','line_number':284,'multiline':False]['text':' frequency ','line_number':287,'multiline':True]['text':' frequency ','line_number':288,'multiline':True]['text':' Test simple conjunctions on one field. Note the first example: the range we expect to see','line_number':292,'multiline':False]['text':' here is (1, 3); however, the structure in the SargableNode gives us a conjunction of two','line_number':293,'multiline':False]['text':' intervals instead: (1, "") ^ (nan, 3) This is then estimated using exponential backoff to','line_number':294,'multiline':False]['text':' give us a less accurate result. The correct cardinality here would be 5.','line_number':295,'multiline':False]['text':' Test ranges which exclude each other.','line_number':301,'multiline':False]['text':' Test overlapping ranges. This is a similar case to {a: {$gt: 1}, a: {$lt: 3}} above: we','line_number':304,'multiline':False]['text':' expect to see the range [2, 2]; instead, we see the range [nan, 2] ^ [2, "").','line_number':305,'multiline':False]['text':' Test conjunctions over multiple fields for which we have histograms. Here we expect a','line_number':308,'multiline':False]['text':' cardinality estimated by exponential backoff.','line_number':309,'multiline':False]['text':' Test conjunctions over multiple fields for which we may not have histograms. This falls back','line_number':315,'multiline':False]['text':' to heuristic estimation for the non-histogrammable predicates, and fully fallsback to','line_number':316,'multiline':False]['text':' heuristics if no predicates have a histogram.','line_number':317,'multiline':False]['text':' Test disjunction where together the predicates include the entire range.','line_number':321,'multiline':False]['text':' Test disjunction with overlapping, redundant ranges.','line_number':326,'multiline':False]['text':' Test disjunction with disjoint ranges. We again expect exponential backoff here.','line_number':329,'multiline':False]['text':' Test disjunctions over multiple fields for which we have histograms.  We again expect','line_number':332,'multiline':False]['text':' exponential backoff here.','line_number':333,'multiline':False]['text':' Test conjunctions over multiple fields for which we may not have histograms. This is','line_number':341,'multiline':False]['text':' expected to fall back as described above.','line_number':342,'multiline':False]['text':' Basic histogram, which we will use for all fields: a scalar histogram with values in the','line_number':351,'multiline':False]['text':' range [1,11], most of which are in the middle bucket.','line_number':352,'multiline':False]['text':' frequency ','line_number':354,'multiline':True]['text':' frequency ','line_number':355,'multiline':True]['text':' frequency ','line_number':356,'multiline':True]['text':' range frequency ','line_number':356,'multiline':True]['text':' ndv ','line_number':356,'multiline':True]['text':' frequency ','line_number':357,'multiline':True]['text':' range frequency ','line_number':357,'multiline':True]['text':' ndv ','line_number':357,'multiline':True]['text':' frequency ','line_number':358,'multiline':True]['text':' Asymmetric disjunction.','line_number':369,'multiline':False]['text':' Asymmetric conjunction.','line_number':377,'multiline':False]['text':' Symmetric disjunction nested (3 levels).','line_number':385,'multiline':False]['text':' Symmetric conjunction nested (3 levels).','line_number':393,'multiline':False]['text':' Asymmetric disjunction nested (4 levels).','line_number':401,'multiline':False]['text':' Asymmetric conjunction nested (4 levels).','line_number':415,'multiline':False]['text':' Create a histogram with a single bucket that contains exactly one int (42) with a frequency','line_number':446,'multiline':False]['text':' of 50 (equal to the collection cardinality).','line_number':447,'multiline':False]['text':' frequency ','line_number':450,'multiline':True]['text':' Check against a variety of intervals that include 42 as a bound.','line_number':453,'multiline':False]['text':' Check against a variety of intervals that include 42 only as one bound.','line_number':464,'multiline':False]['text':' Check against a variety of intervals close to 42 using a lower bound of 41 and a higher bound','line_number':474,'multiline':False]['text':' of 43.','line_number':475,'multiline':False]['text':' Check against different types.','line_number':487,'multiline':False]['text':' frequency ','line_number':498,'multiline':True]['text':' frequency ','line_number':499,'multiline':True]['text':' range frequency ','line_number':499,'multiline':True]['text':' ndv ','line_number':499,'multiline':True]['text':' Test ranges that overlap only with the lower bound.','line_number':502,'multiline':False]['text':' Note: 5 values equal 10.','line_number':503,'multiline':False]['text':' Test ranges that overlap only with the upper bound.','line_number':508,'multiline':False]['text':' Test ranges that partially overlap with the entire histogram.','line_number':520,'multiline':False]['text':' Test ranges that include all values in the histogram.','line_number':529,'multiline':False]['text':' Test ranges that are fully included in the histogram.','line_number':540,'multiline':False]['text':' Test ranges that don't overlap with the histogram.','line_number':545,'multiline':False]['text':' Because we don't specify any indexes here, these intervals do not go through simplification.','line_number':563,'multiline':False]['text':' This means that instead of having one key in the requirements map of the generated sargable','line_number':564,'multiline':False]['text':' node corresponding to the path "intRange", we have two keys and two ranges, both','line_number':565,'multiline':False]['text':' corresponding to the same path. As a consequence, we combine the estimates for the intervals','line_number':566,'multiline':False]['text':' using exponential backoff, which results in an overestimate.','line_number':567,'multiline':False]['text':' When we specify that there is a non-multikey index on 'intRange', we expect to see interval','line_number':576,'multiline':False]['text':' simplification occurring, which should provide a better estimate for the following ranges.','line_number':577,'multiline':False]['text':' isMultiKey ','line_number':580,'multiline':True]['text':' Create a histogram with a single bucket that contains exactly one int (42) with a frequency','line_number':594,'multiline':False]['text':' of 50 (equal to the collection cardinality).','line_number':595,'multiline':False]['text':' frequency ','line_number':598,'multiline':True]['text':' frequency ','line_number':602,'multiline':True]['text':' heuristic ','line_number':605,'multiline':True]['text':' heuristic ','line_number':608,'multiline':True]['text':' When a predicate can't be precisely translated to a SargableNode (such as $elemMatch on a','line_number':610,'multiline':False]['text':' dotted path), we may still be able to translate an over-approximation. We generate a','line_number':611,'multiline':False]['text':' SargableNode with all predicates marked perfOnly, and keep the original Filter. The Filter','line_number':612,'multiline':False]['text':' ensures the results are correct, while the SargableNode hopefully will be answerable by an','line_number':613,'multiline':False]['text':' index.','line_number':614,'multiline':False]['text':'','line_number':615,'multiline':False]['text':' On the logical level, perfOnly predicates don't do anything, so we don't consider them in','line_number':616,'multiline':False]['text':' cardinality estimates. But when we split a SargableNode into an indexed part and a fetch','line_number':617,'multiline':False]['text':' part, we remove the perfOnly flag from the indexed part, and we should consider them to','line_number':618,'multiline':False]['text':' estimate how many index keys are returned.','line_number':619,'multiline':False]['text':'','line_number':620,'multiline':False]['text':' In this test, we want to exercise the histogram estimate for the SargableNode generated by','line_number':621,'multiline':False]['text':' $elemMatch on a dotted path. So we create an index on this field to ensure the SargableNode','line_number':622,'multiline':False]['text':' is split, and the predicates marked non-perfOnly.','line_number':623,'multiline':False]['text':'','line_number':624,'multiline':False]['text':' We also mark the index multikey, to prevent non-CE rewrites from removing the predicate','line_number':625,'multiline':False]['text':' entirely. (This scenario could happen if you remove all the arrays, and refresh the','line_number':626,'multiline':False]['text':' statistics.)','line_number':627,'multiline':False]['text':' isMultiKey ','line_number':635,'multiline':True]['text':' Generate a histogram for this data:','line_number':646,'multiline':False]['text':' {a: 1}, {a: 2}, {a: [1, 2, 3, 2, 2]}, {a: [10]}, {a: [2, 3, 3, 4, 5, 5, 6]}, {a: []}','line_number':647,'multiline':False]['text':'  - scalars: [1, 2]','line_number':648,'multiline':False]['text':'  - unique values: [1, 2, 3], [10], [2, 3, 4, 5, 6]','line_number':649,'multiline':False]['text':'      -> [1, 2, 2, 3, 3, 4, 5, 6, 10]','line_number':650,'multiline':False]['text':'  - min values: [1], [10], [2] -> [1, 1, 2, 2, 10]','line_number':651,'multiline':False]['text':'  - max values: [3], [10], [6] -> [1, 2, 3, 6, 10]','line_number':652,'multiline':False]['text':' Scalar buckets.','line_number':654,'multiline':False]['text':' frequency ','line_number':655,'multiline':True]['text':' frequency ','line_number':656,'multiline':True]['text':' Array unique buckets.','line_number':658,'multiline':False]['text':' frequency ','line_number':659,'multiline':True]['text':' frequency ','line_number':660,'multiline':True]['text':' frequency ','line_number':661,'multiline':True]['text':' frequency ','line_number':662,'multiline':True]['text':' frequency ','line_number':663,'multiline':True]['text':' frequency ','line_number':664,'multiline':True]['text':' frequency ','line_number':665,'multiline':True]['text':' Array min buckets.','line_number':668,'multiline':False]['text':' frequency ','line_number':669,'multiline':True]['text':' frequency ','line_number':670,'multiline':True]['text':' frequency ','line_number':671,'multiline':True]['text':' Array max buckets.','line_number':674,'multiline':False]['text':' frequency ','line_number':675,'multiline':True]['text':' frequency ','line_number':676,'multiline':True]['text':' frequency ','line_number':677,'multiline':True]['text':' Array type counts (3 arrays with ints).','line_number':679,'multiline':False]['text':' 4 arrays (including []).','line_number':680,'multiline':False]['text':' 1 empty array.','line_number':681,'multiline':False]['text':' Test simple predicates against 'a'. Note: in the $elemMatch case, we exclude scalar','line_number':684,'multiline':False]['text':' estimates. Without $elemMatch, we add the array histogram and scalar histogram estimates','line_number':685,'multiline':False]['text':' together.','line_number':686,'multiline':False]['text':' Test equality predicates.','line_number':688,'multiline':False]['text':' CE ','line_number':689,'multiline':True]['text':' $elemMatch CE ','line_number':689,'multiline':True]['text':' CE ','line_number':690,'multiline':True]['text':' $elemMatch CE ','line_number':690,'multiline':True]['text':' CE ','line_number':691,'multiline':True]['text':' $elemMatch CE ','line_number':691,'multiline':True]['text':' CE ','line_number':692,'multiline':True]['text':' $elemMatch CE ','line_number':692,'multiline':True]['text':' CE ','line_number':693,'multiline':True]['text':' $elemMatch CE ','line_number':693,'multiline':True]['text':' CE ','line_number':694,'multiline':True]['text':' $elemMatch CE ','line_number':694,'multiline':True]['text':' CE ','line_number':695,'multiline':True]['text':' $elemMatch CE ','line_number':695,'multiline':True]['text':' CE ','line_number':696,'multiline':True]['text':' $elemMatch CE ','line_number':696,'multiline':True]['text':' CE ','line_number':697,'multiline':True]['text':' $elemMatch CE ','line_number':697,'multiline':True]['text':' Test histogram boundary values.','line_number':699,'multiline':False]['text':' CE ','line_number':700,'multiline':True]['text':' $elemMatch CE ','line_number':700,'multiline':True]['text':' CE ','line_number':701,'multiline':True]['text':' $elemMatch CE ','line_number':701,'multiline':True]['text':' CE ','line_number':702,'multiline':True]['text':' $elemMatch CE ','line_number':702,'multiline':True]['text':' CE ','line_number':703,'multiline':True]['text':' $elemMatch CE ','line_number':703,'multiline':True]['text':' CE ','line_number':705,'multiline':True]['text':' $elemMatch CE ','line_number':705,'multiline':True]['text':' CE ','line_number':706,'multiline':True]['text':' $elemMatch CE ','line_number':706,'multiline':True]['text':' CE ','line_number':707,'multiline':True]['text':' $elemMatch CE ','line_number':707,'multiline':True]['text':' CE ','line_number':708,'multiline':True]['text':' $elemMatch CE ','line_number':708,'multiline':True]['text':' CE ','line_number':710,'multiline':True]['text':' $elemMatch CE ','line_number':710,'multiline':True]['text':' CE ','line_number':711,'multiline':True]['text':' $elemMatch CE ','line_number':711,'multiline':True]['text':' CE ','line_number':712,'multiline':True]['text':' $elemMatch CE ','line_number':712,'multiline':True]['text':' CE ','line_number':713,'multiline':True]['text':' $elemMatch CE ','line_number':713,'multiline':True]['text':' CE ','line_number':715,'multiline':True]['text':' $elemMatch CE ','line_number':715,'multiline':True]['text':' CE ','line_number':716,'multiline':True]['text':' $elemMatch CE ','line_number':716,'multiline':True]['text':' CE ','line_number':717,'multiline':True]['text':' $elemMatch CE ','line_number':717,'multiline':True]['text':' CE ','line_number':718,'multiline':True]['text':' $elemMatch CE ','line_number':718,'multiline':True]['text':' A scalar histogram with values in the range [1,10], most of which are in the middle bucket.','line_number':725,'multiline':False]['text':' frequency ','line_number':728,'multiline':True]['text':' frequency ','line_number':729,'multiline':True]['text':' frequency ','line_number':730,'multiline':True]['text':' range frequency ','line_number':730,'multiline':True]['text':' ndv ','line_number':730,'multiline':True]['text':' frequency ','line_number':731,'multiline':True]['text':' range frequency ','line_number':731,'multiline':True]['text':' ndv ','line_number':731,'multiline':True]['text':' An array histogram built on the following arrays with 35 occurrences of each:','line_number':734,'multiline':False]['text':' [{[1, 2, 3]: 35}, {[5, 5, 5, 5, 5]: 35}, {[6]: 35}, {[]: 35}, {[8, 9, 10]: 35}]','line_number':735,'multiline':False]['text':' No scalar buckets. ','line_number':739,'multiline':True]['text':' Array unique buckets.','line_number':741,'multiline':False]['text':' frequency ','line_number':742,'multiline':True]['text':' range frequency ','line_number':742,'multiline':True]['text':' ndv ','line_number':742,'multiline':True]['text':' frequency ','line_number':743,'multiline':True]['text':' range frequency ','line_number':743,'multiline':True]['text':' ndv ','line_number':743,'multiline':True]['text':' frequency ','line_number':744,'multiline':True]['text':' frequency ','line_number':745,'multiline':True]['text':' range frequency ','line_number':745,'multiline':True]['text':' ndv ','line_number':745,'multiline':True]['text':' Array min buckets.','line_number':748,'multiline':False]['text':' frequency ','line_number':749,'multiline':True]['text':' frequency ','line_number':750,'multiline':True]['text':' frequency ','line_number':751,'multiline':True]['text':' frequency ','line_number':752,'multiline':True]['text':' Array max buckets.','line_number':755,'multiline':False]['text':' frequency ','line_number':756,'multiline':True]['text':' frequency ','line_number':757,'multiline':True]['text':' frequency ','line_number':758,'multiline':True]['text':' frequency ','line_number':759,'multiline':True]['text':' Arrays with ints = 4*35 = 140.','line_number':761,'multiline':False]['text':' kCollCard arrays total.','line_number':762,'multiline':False]['text':' 35 empty arrays','line_number':763,'multiline':False]['text':' The mixed histogram has 87 scalars that follow approximately the same distribution as','line_number':768,'multiline':False]['text':' in the pure scalar case, and 88 arrays with the following distribution:','line_number':769,'multiline':False]['text':'  [{[1, 2, 3]: 17}, {[5, 5, 5, 5, 5]: 17}, {[6]: 17}, {[]: 20}, {[8, 9, 10]: 17}]','line_number':770,'multiline':False]['text':' Scalar buckets. These are half the number of values from the "scalar" histogram.','line_number':773,'multiline':False]['text':' frequency ','line_number':774,'multiline':True]['text':' frequency ','line_number':775,'multiline':True]['text':' frequency ','line_number':776,'multiline':True]['text':' range frequency ','line_number':776,'multiline':True]['text':' ndv ','line_number':776,'multiline':True]['text':' frequency ','line_number':777,'multiline':True]['text':' range frequency ','line_number':777,'multiline':True]['text':' ndv ','line_number':777,'multiline':True]['text':' Array unique buckets.','line_number':780,'multiline':False]['text':' frequency ','line_number':781,'multiline':True]['text':' range frequency ','line_number':781,'multiline':True]['text':' ndv ','line_number':781,'multiline':True]['text':' frequency ','line_number':782,'multiline':True]['text':' range frequency ','line_number':782,'multiline':True]['text':' ndv ','line_number':782,'multiline':True]['text':' frequency ','line_number':783,'multiline':True]['text':' frequency ','line_number':784,'multiline':True]['text':' range frequency ','line_number':784,'multiline':True]['text':' ndv ','line_number':784,'multiline':True]['text':' Array min buckets.','line_number':787,'multiline':False]['text':' frequency ','line_number':788,'multiline':True]['text':' frequency ','line_number':789,'multiline':True]['text':' frequency ','line_number':790,'multiline':True]['text':' frequency ','line_number':791,'multiline':True]['text':' Array max buckets.','line_number':794,'multiline':False]['text':' frequency ','line_number':795,'multiline':True]['text':' frequency ','line_number':796,'multiline':True]['text':' frequency ','line_number':797,'multiline':True]['text':' frequency ','line_number':798,'multiline':True]['text':' Arrays with ints = 17*4 = 68.','line_number':800,'multiline':False]['text':' kCollCard arrays total.','line_number':801,'multiline':False]['text':' 20 empty arrays.','line_number':802,'multiline':False]['text':' Test cardinality of individual predicates.','line_number':805,'multiline':False]['text':' CE ','line_number':806,'multiline':True]['text':' $elemMatch CE ','line_number':806,'multiline':True]['text':' CE ','line_number':807,'multiline':True]['text':' $elemMatch CE ','line_number':807,'multiline':True]['text':' CE ','line_number':808,'multiline':True]['text':' $elemMatch CE ','line_number':808,'multiline':True]['text':' Test cardinality of predicate combinations; the following tests make sure we correctly track','line_number':810,'multiline':False]['text':' which paths have $elemMatches and which don't. Some notes:','line_number':811,'multiline':False]['text':'  - Whenever we use 'scalar' + $elemMatch, we expect an estimate of 0 because $elemMatch never','line_number':812,'multiline':False]['text':' returns documents on non-array paths.','line_number':813,'multiline':False]['text':'  - Whenever we use 'mixed' + $elemMatch, we expect the estimate to decrease because we omit','line_number':814,'multiline':False]['text':' scalar values in 'mixed' from our estimate.','line_number':815,'multiline':False]['text':'  - We do not expect the estimate on 'array' to be affected by the presence of $elemMatch,','line_number':816,'multiline':False]['text':' since we only have array values for this field.','line_number':817,'multiline':False]['text':' Composite predicate on 'scalar' and 'array' fields.','line_number':819,'multiline':False]['text':' Composite predicate on 'mixed' and 'array' fields.','line_number':828,'multiline':False]['text':' Composite predicate on 'scalar' and 'mixed' fields.','line_number':837,'multiline':False]['text':' Composite predicate on all three fields without '$elemMatch' on 'array'.','line_number':842,'multiline':False]['text':' Composite predicate on all three fields with '$elemMatch' on 'array' (same expected results','line_number':847,'multiline':False]['text':' as above).','line_number':848,'multiline':False]['text':' Test case where the same path has both $match and $elemMatch (same as $elemMatch case).','line_number':851,'multiline':False]['text':' Test case where the same path has both a $match and $elemMatch, but where the top-level','line_number':856,'multiline':False]['text':' query is a disjunction.','line_number':857,'multiline':False]['text':' Test case with multiple predicates and ranges.','line_number':882,'multiline':False]['text':' Test multiple $elemMatches.','line_number':886,'multiline':False]['text':' Verify that we still return an estimate of 0.0 for any $elemMatch predicate on a scalar','line_number':905,'multiline':False]['text':' field when we have a non-multikey index.','line_number':906,'multiline':False]['text':' isMultiKey ','line_number':908,'multiline':True]['text':' Test how we estimate singular PathArr sargable predicate.','line_number':914,'multiline':False]['text':' Take into account both empty and non-empty arrays.','line_number':918,'multiline':False]['text':' There are no arrays in the 'scalar' field.','line_number':931,'multiline':False]['text':' About half the values of this field are arrays.','line_number':935,'multiline':False]['text':' This field is always an array.','line_number':939,'multiline':False]['text':' A very simple histogram encoding a collection with one document {a: [3, 10]}.','line_number':948,'multiline':False]['text':' No scalar buckets. ','line_number':950,'multiline':True]['text':' Array unique buckets.','line_number':952,'multiline':False]['text':' frequency ','line_number':953,'multiline':True]['text':' frequency ','line_number':954,'multiline':True]['text':' Array min buckets.','line_number':957,'multiline':False]['text':' frequency ','line_number':958,'multiline':True]['text':' Array max buckets.','line_number':961,'multiline':False]['text':' frequency ','line_number':962,'multiline':True]['text':' We only have one array with ints.','line_number':964,'multiline':False]['text':' Tests without indexes.','line_number':969,'multiline':False]['text':' Tests with multikey index (note that the index on "a" must be multikey due to arrays).','line_number':977,'multiline':False]['text':' isMultiKey ','line_number':979,'multiline':True]['text':' This test is designed such that for each document, we have the following fields:','line_number':992,'multiline':False]['text':' 1. scalar: Scalar histogram with no buckets, only type-counted data.','line_number':993,'multiline':False]['text':' 2. array: Array histogram with no buckets, only type-counted data inside of arrays.','line_number':994,'multiline':False]['text':' 3. mixed: Mixed histogram with no buckets, only type-counted data, both scalars and arrays.','line_number':995,'multiline':False]['text':' No histogram data. ','line_number':1002,'multiline':True]['text':' No scalar buckets. ','line_number':1009,'multiline':True]['text':' No array unique buckets. ','line_number':1010,'multiline':True]['text':' No array min buckets. ','line_number':1011,'multiline':True]['text':' No array max buckets. ','line_number':1012,'multiline':True]['text':' Count of each type in array type counters for field "mixed".','line_number':1018,'multiline':False]['text':' For the purposes of this test, we have one array of each value of a non-histogrammable type.','line_number':1021,'multiline':False]['text':' Count of each type in scalar type counters for field "mixed".','line_number':1028,'multiline':False]['text':' Quick sanity check of test setup for the "mixed" histogram. The idea is that we want a','line_number':1038,'multiline':False]['text':' portion of objects inside arrays, and the rest as scalars, but we want the total count of','line_number':1039,'multiline':False]['text':' types to be the same.','line_number':1040,'multiline':False]['text':' No scalar buckets. ','line_number':1046,'multiline':True]['text':' No array unique buckets. ','line_number':1047,'multiline':True]['text':' No array min buckets. ','line_number':1048,'multiline':True]['text':' No array max buckets. ','line_number':1049,'multiline':True]['text':' Empty array count. ','line_number':1052,'multiline':True]['text':' Set up indexes.','line_number':1057,'multiline':False]['text':' isMultiKey ','line_number':1059,'multiline':True]['text':' isMultiKey ','line_number':1061,'multiline':True]['text':' isMultiKey ','line_number':1063,'multiline':True]['text':' Tests for scalar type counts only.','line_number':1065,'multiline':False]['text':' For object-only intervals in a scalar histogram, we apply a heuristic to the object count.','line_number':1066,'multiline':False]['text':' Since we have a scalar histogram for "scalar", we expect all $elemMatch queries to have a','line_number':1067,'multiline':False]['text':' cardinality of 0.','line_number':1068,'multiline':False]['text':' Equality selectivity is sqrt(200)/200.','line_number':1069,'multiline':False]['text':' Closed-range selectivity is 0.2.','line_number':1070,'multiline':False]['text':' Open-range selectivity is 0.33.','line_number':1071,'multiline':False]['text':' Test object equality. Note that $gt/$gte queries on objects are closed range because of the','line_number':1073,'multiline':False]['text':' upper bound on object type.','line_number':1074,'multiline':False]['text':' Test intervals including the empty object. Note that range queries on objects do not generate','line_number':1083,'multiline':False]['text':' point equalities, so these fall back onto logic in interval estimation that identifies that','line_number':1084,'multiline':False]['text':' the generated intervals are subsets of the object type interval. Additionally, we don't','line_number':1085,'multiline':False]['text':' generate a SargableNode for the first case. The generated bounds are [{}, {}) because {} is','line_number':1086,'multiline':False]['text':' the "minimum" value for the object type.','line_number':1087,'multiline':False]['text':' Note: this query is equivalent to {$eq: {}}.','line_number':1091,'multiline':False]['text':' Rather than combining the intervals together, in the following cases we generate two','line_number':1094,'multiline':False]['text':' object-only intervals in the requirements map. Each individual interval is estimated','line_number':1095,'multiline':False]['text':' separately by applying a heuristic selectivity on object count, before we apply conjunctive','line_number':1096,'multiline':False]['text':' exponential backoff to combine them.','line_number':1097,'multiline':False]['text':' == 40/1000 * sqrt(66/1000) * 1000','line_number':1098,'multiline':False]['text':' Test intervals including {a: 1}. Similar to the above case, we have two intervals in the','line_number':1104,'multiline':False]['text':' requirements map.','line_number':1105,'multiline':False]['text':' Test that for null, we always return null count.','line_number':1115,'multiline':False]['text':' Note that for ranges including null (e.g. {$lt: null}) we don't generate any SargableNodes.','line_number':1116,'multiline':False]['text':' Test boolean count estimate.','line_number':1119,'multiline':False]['text':' Tests for array type counts only.','line_number':1123,'multiline':False]['text':' For object-only intervals in an array histogram, if we're using $elemMatch on an object-only','line_number':1124,'multiline':False]['text':' interval, we always return the array object count modified by a heuristic. While we have no','line_number':1125,'multiline':False]['text':' scalar type counts for "array", non-$elemMatch queries should also match objects embedded in','line_number':1126,'multiline':False]['text':' arrays, so we return the same estimate for both cases.','line_number':1127,'multiline':False]['text':' Test object equality.','line_number':1129,'multiline':False]['text':' Test intervals including the empty object.','line_number':1138,'multiline':False]['text':' Note: we don't even generate a SargableNode for the first case. The generated bounds are:','line_number':1139,'multiline':False]['text':' [{}, {}) because {} is the "minimum" value for the object type.','line_number':1140,'multiline':False]['text':' Note: this query is equivalent to {$eq: {}}.','line_number':1144,'multiline':False]['text':' Similar to above, here we have two object intervals for non-$elemMatch queries. However, for','line_number':1147,'multiline':False]['text':' $elemMatch queries, we have the following intervals in the requirements map:','line_number':1148,'multiline':False]['text':'  1. [[], BinData(0, )) with CE 1000','line_number':1149,'multiline':False]['text':'  2. The actual object interval, e.g. ({}, {b: 2, c: 3}] with CE 0.2*200','line_number':1150,'multiline':False]['text':' == 40/1000 * sqrt(1000/1000) * 1000','line_number':1151,'multiline':False]['text':' Test intervals including {a: 1}; similar to above, we have two object intervals.','line_number':1157,'multiline':False]['text':' Test that for null, we always return null count.','line_number':1167,'multiline':False]['text':' Note that for ranges including null (e.g. {$lt: null}) we don't generate any SargableNodes.','line_number':1168,'multiline':False]['text':' Test boolean count estimate; within arrays, the count of any boolean value is estimated as','line_number':1171,'multiline':False]['text':' 0.5*count of all arrays including booleans.','line_number':1172,'multiline':False]['text':' Tests for mixed type counts only. Regular match predicates should be estimated as the sum of','line_number':1177,'multiline':False]['text':' the scalar and array counts (e.g. for objects, 'kNumObj') modified heuristically,','line_number':1178,'multiline':False]['text':' while elemMatch predicates should be estimated without scalars, returning the array type','line_number':1179,'multiline':False]['text':' count (for objects this is 'kNumObjMA') * a heuristic selectivity.','line_number':1180,'multiline':False]['text':' 150*sqrt(150)/150','line_number':1181,'multiline':False]['text':' 0.33*150','line_number':1182,'multiline':False]['text':' 0.2*150','line_number':1183,'multiline':False]['text':' 50*sqrt(50)/50','line_number':1184,'multiline':False]['text':' We use different selectivities here because the input cardinality is smaller.','line_number':1185,'multiline':False]['text':' 0.45*50','line_number':1186,'multiline':False]['text':' 0.33*50','line_number':1187,'multiline':False]['text':' Test object equality.','line_number':1189,'multiline':False]['text':' Test intervals including the empty object.','line_number':1200,'multiline':False]['text':' Note: we don't even generate a SargableNode for the first case. The generated bounds are:','line_number':1201,'multiline':False]['text':' [{}, {}) because {} is the "minimum" value for the object type.','line_number':1202,'multiline':False]['text':' Note: same as {$eq: {}}.','line_number':1206,'multiline':False]['text':' Similar to above, here we have two object intervals for non-$elemMatch queries. However, for','line_number':1209,'multiline':False]['text':' $elemMatch queries, we have the following intervals in the requirements map:','line_number':1210,'multiline':False]['text':'  1. [[], BinData(0, ))','line_number':1211,'multiline':False]['text':'  2. The actual object interval, e.g. ({}, {b: 2, c: 3}]','line_number':1212,'multiline':False]['text':' Test intervals including {a: 1}; similar to above, we have two object intervals.','line_number':1219,'multiline':False]['text':' Test that for null, we always return null count.','line_number':1233,'multiline':False]['text':' Note that for ranges including null (e.g. {$lt: null}) we don't generate any SargableNodes.','line_number':1234,'multiline':False]['text':' Test boolean count estimate; this is estimated as half the count of arrays that include','line_number':1237,'multiline':False]['text':' booleans.','line_number':1238,'multiline':False]['text':' Test combinations of the three fields/ type counters.','line_number':1243,'multiline':False]['text':' Should always get a 0.0 cardinality for an $elemMatch on a scalar predicate.','line_number':1256,'multiline':False]['text':' This test validates the correct behaviour of both the nested-array type counter as well as','line_number':1278,'multiline':False]['text':' combinations of type counters and histogram estimates.','line_number':1279,'multiline':False]['text':' Total number of arrays.','line_number':1281,'multiline':False]['text':' Frequency of nested arrays, e.g. [[1, 2, 3]].','line_number':1282,'multiline':False]['text':' Frequency of 1.','line_number':1284,'multiline':False]['text':' Frequency of 2.','line_number':1285,'multiline':False]['text':' Frequency of 3.','line_number':1286,'multiline':False]['text':' Frequency of [1].','line_number':1287,'multiline':False]['text':' Frequency of [2].','line_number':1288,'multiline':False]['text':' Frequency of [3].','line_number':1289,'multiline':False]['text':' Total number of scalar objects.','line_number':1290,'multiline':False]['text':' Sanity test numbers.','line_number':1292,'multiline':False]['text':' Define histogram buckets.','line_number':1297,'multiline':False]['text':' Define type counts.','line_number':1303,'multiline':False]['text':' Empty array count. ','line_number':1316,'multiline':True]['text':' isMultiKey ','line_number':1319,'multiline':True]['text':' Some equality tests on types that are not present in the type counters should return 0.0.','line_number':1321,'multiline':False]['text':' We don't have any objects in arrays, so don't count them.','line_number':1325,'multiline':False]['text':' sqrt(390)','line_number':1326,'multiline':False]['text':' Quick equality test to see if regular array histogram estimation still works as expected.','line_number':1329,'multiline':False]['text':' Test a range predicate.','line_number':1334,'multiline':False]['text':' - For simple $lt, we correctly return both scalar and array counts that could match.','line_number':1335,'multiline':False]['text':' - For $elemMatch + $lt, we have two entries in the requirements map.','line_number':1336,'multiline':False]['text':'   - The PathArr interval, estimated correctly as 'kNumArr'.','line_number':1337,'multiline':False]['text':'   - The interval {$lt: 3}, estimated as an array histogram range interval.','line_number':1338,'multiline':False]['text':' We then combine the estimates for the two using conjunctive exponential backoff.','line_number':1339,'multiline':False]['text':' Test equality to arrays.','line_number':1345,'multiline':False]['text':' - $elemMatch, estimation, as expected, will return the count of nested arrays.','line_number':1346,'multiline':False]['text':' - For the case where we see equality to the array, we have a disjunction of intervals in the','line_number':1347,'multiline':False]['text':' same entry of the SargableNode requirements map. For the case of {$eq: [1]}, for example, we','line_number':1348,'multiline':False]['text':' have: [[1], [1]] U [1, 1]. As a result, we estimate each point interval separately:','line_number':1349,'multiline':False]['text':'   - [[1], [1]]: We estimate the nested array interval as 'kNestArrEst'.','line_number':1350,'multiline':False]['text':'   - [1, 1]: We estimate the regular point interval as 'kNumArr1' + 'kNum1'.','line_number':1351,'multiline':False]['text':' We then combine the results by exponential backoff. Note that we will NOT match {na: 1};','line_number':1352,'multiline':False]['text':' however, because of the way the interval is defined, our estimate suggests that we would.','line_number':1353,'multiline':False]['text':' TODO: is there a way to know this on the CE side?','line_number':1354,'multiline':False]['text':' For the last case, we have the interval [[1, 2, 3], [1, 2, 3]] U [1, 1].','line_number':1362,'multiline':False]['text':' TODO: is this interval semantically correct?','line_number':1363,'multiline':False]['text':' Now, we test the case of nested arrays.','line_number':1366,'multiline':False]['text':' - $elemMatch, once again, returns the number of nested arrays.','line_number':1367,'multiline':False]['text':' - Simple equality generates two intervals. We estimate both intervals using the nested array','line_number':1368,'multiline':False]['text':' type count. For {$eq: [[1, 2, 3]]}, we get:','line_number':1369,'multiline':False]['text':'   - [[1, 2, 3], [1, 2, 3]] U [[[1, 2, 3]]], [[1, 2, 3]]]','line_number':1370,'multiline':False]['text':' Note: we can't convert range queries on arrays to SargableNodes yet. If we ever can, we','line_number':1378,'multiline':False]['text':' should add some more tests here.','line_number':1379,'multiline':False]['text':' This is a sanity test to validate fallback for an interval with non-const bounds.','line_number':1383,'multiline':False]['text':' Validate we pick a histogram when we can.','line_number':1386,'multiline':False]['text':'inclusive','line_number':1388,'multiline':True]['text':'inclusive','line_number':1389,'multiline':True]['text':' Validate that we fallback to heuristic estimation when we have no histogram.','line_number':1396,'multiline':False]['text':' Validate that we use type counts for non-histogrammable types.','line_number':1404,'multiline':False]['text':'inclusive','line_number':1406,'multiline':True]['text':'inclusive','line_number':1407,'multiline':True]['text':' Validate that we fallback to heuristic estimation when we have no histogram.','line_number':1412,'multiline':False]['text':' Validate cases where we have non-const bounds.','line_number':1420,'multiline':False]['text':'inclusive','line_number':1422,'multiline':True]['text':'inclusive','line_number':1431,'multiline':True]['text':'inclusive','line_number':1438,'multiline':True]['text':'inclusive','line_number':1439,'multiline':True]['text':' In the scalar case, we generate 10 buckets, with each unique value as a boundary value with','line_number':1471,'multiline':False]['text':' cardinality 1. In the array case, we do the same for min/max/unique. Unfortunately, we are','line_number':1472,'multiline':False]['text':' not always able to generate sargable nodes, so we generally fall back to heuristic','line_number':1473,'multiline':False]['text':' estimation.','line_number':1474,'multiline':False]['text':' Test conjunctions where both fields have histograms. Note that when both ops are $ne, we','line_number':1492,'multiline':False]['text':' never use histogram estimation because the optimizer only generates filter nodes (no sargable','line_number':1493,'multiline':False]['text':' nodes).','line_number':1494,'multiline':False]['text':' Test conjunctions where only one field has a histogram (fallback to heuristics).','line_number':1503,'multiline':False]['text':' Same as above, but testing disjunction. In this case, if either op is $ne, we never use','line_number':1511,'multiline':False]['text':' histogram estimation because the optimizer only generates filter nodes.','line_number':1512,'multiline':False]['text':' Where only one fields has a histogram.','line_number':1521,'multiline':False]['text':' Remaining values in coll for 'tc' are missing.','line_number':1538,'multiline':False]['text':' Remaining values in coll for 'i' are missing.','line_number':1548,'multiline':False]['text':' 8.0 values of "i" match (0-7), and each is a bucket boundary.','line_number':1556,'multiline':False]['text':' We estimate this correctly as the number of true values.','line_number':1559,'multiline':False]['text':' We estimate this correctly as the number of false values.','line_number':1562,'multiline':False]['text':' We then apply exponential backoff to combine the estimates of the histogram & type counters.','line_number':1565,'multiline':False]['text':' CE = 8/40*sqrt(10/40)*40','line_number':1566,'multiline':False]['text':' CE = 8/40*sqrt(20/40)*40','line_number':1568,'multiline':False]['text':' Same tests, but with a disjunction of predicates.','line_number':1571,'multiline':False]['text':' CE = (1 - (1 - 10/40) * sqrt(1 - 8/40)) * 40','line_number':1572,'multiline':False]['text':' CE = (1 - (1 - 20/40) * sqrt(1 - 8.40)) * 40','line_number':1574,'multiline':False]['text':' Our current estimation would produce a negative estimate for this case. This test verifies we','line_number':1586,'multiline':False]['text':' round a negative result up to 0.0 before returning it.','line_number':1587,'multiline':False]['text':' lowInclusive ','line_number':1589,'multiline':True]['text':' highInclusive ','line_number':1592,'multiline':True]['text':' includeScalar ','line_number':1595,'multiline':True]['text':' namespace','line_number':1598,'multiline':False]['text':' namespace mongo::optimizer::ce','line_number':1599,'multiline':False]