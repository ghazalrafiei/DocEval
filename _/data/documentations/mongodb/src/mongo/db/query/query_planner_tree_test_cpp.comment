['text':'*
 *    Copyright (C) 2019-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':'','line_number':53,'multiline':False]['text':' tree operations','line_number':54,'multiline':False]['text':'','line_number':55,'multiline':False]['text':' Logical rewrite means we could get one of these two outcomes:','line_number':107,'multiline':False]['text':' Logical rewrite gives us at least one of these:','line_number':127,'multiline':False]['text':'','line_number':143,'multiline':False]['text':' Additional $or tests','line_number':144,'multiline':False]['text':'','line_number':145,'multiline':False]['text':' SERVER-13714.  A non-top-level indexable negation exposed a bug in plan enumeration.','line_number':206,'multiline':False]['text':' This is the min query to reproduce SERVER-13714','line_number':226,'multiline':False]['text':' SERVER-12594: we don't yet collapse an OR of ANDs into a single ixscan.','line_number':231,'multiline':False]['text':' SERVER-12594: we don't yet collapse an OR of ANDs into a single ixscan.','line_number':245,'multiline':False]['text':' SERVER-12594: we don't yet collapse an OR of ANDs into a single ixscan.','line_number':260,'multiline':False]['text':' SERVER-12594: we don't yet collapse an OR of ANDs into a single ixscan.','line_number':275,'multiline':False]['text':' SERVER-12594: we don't yet collapse an OR of ANDs into a single ixscan.','line_number':293,'multiline':False]['text':' SERVER-12594: we don't yet collapse an OR of ANDs into a single ixscan.','line_number':312,'multiline':False]['text':' We do collapse OR of ANDs if branches of the OR plan are using identical index scans.','line_number':328,'multiline':False]['text':'*
 * Due to SERVER-78752 this test was modified to disallow collapsing the or branches due to IETs
 * mismatch. To fix this and being able to collapse the $or the {$gte:1,$lte:1} needs to be
 * simplified to {a:1} before parameterization. TODO: SERVER-78962
 ','line_number':365,'multiline':True]['text':' With the simplifer enabled the solution below will be simplified to "{a:1, b:2, c:1, $or:','line_number':383,'multiline':False]['text':' [{d:3}, {e:4}]}", with the common terms '{a:1, b:2}' moved out of the nested $or. See the','line_number':384,'multiline':False]['text':' test below for the behaviour with the enabled simplifier.','line_number':385,'multiline':False]['text':' With the simplifer enabled the solution below will be simplified to "{a:1, b:2, c:1, $or:','line_number':402,'multiline':False]['text':' [{d:3}, {e:4}]}" which allow the multiplanner to build more effective test with only one','line_number':403,'multiline':False]['text':' fecth instead of two.','line_number':404,'multiline':False]['text':' Test that queries with single-child $and, $or do not crash when match-expression optimization','line_number':494,'multiline':False]['text':' is disabled. Normally these single-child nodes are eliminated, so when they are left in place','line_number':495,'multiline':False]['text':' it can confuse OR-pushdown optimization.','line_number':496,'multiline':False]['text':'','line_number':497,'multiline':False]['text':' Originally designed to reproduce SERVER-70597, which would only happen when the','line_number':498,'multiline':False]['text':' INDEX_INTERSECTION option is enabled.','line_number':499,'multiline':False]['text':' SERVER-13960: properly handle $or with a mix of exact and inexact predicates.','line_number':513,'multiline':False]['text':' SERVER-13960: multiple indices, each with an inexact covered predicate.','line_number':526,'multiline':False]['text':' SERVER-13960: an exact, inexact covered, and inexact fetch predicate.','line_number':541,'multiline':False]['text':' SERVER-13960: two inexact fetch predicates.','line_number':557,'multiline':False]['text':' true means multikey','line_number':559,'multiline':False]['text':' SERVER-13960: multikey with exact and inexact covered predicates.','line_number':574,'multiline':False]['text':' true means multikey','line_number':576,'multiline':False]['text':' SERVER-13960: $elemMatch object with $or.','line_number':587,'multiline':False]['text':' true means multikey','line_number':589,'multiline':False]['text':' SERVER-13960: $elemMatch object inside an $or, below an AND.','line_number':605,'multiline':False]['text':' true means multikey','line_number':607,'multiline':False]['text':' SERVER-13960: $or below $elemMatch with an inexact covered predicate.','line_number':633,'multiline':False]['text':' true means multikey','line_number':635,'multiline':False]['text':' SERVER-13960: $in with exact and inexact covered predicates.','line_number':646,'multiline':False]['text':' SERVER-13960: $in with exact, inexact covered, and inexact fetch predicates.','line_number':659,'multiline':False]['text':' SERVER-13960: $in with exact, inexact covered, and inexact fetch predicates','line_number':674,'multiline':False]['text':' over two indices.','line_number':675,'multiline':False]['text':'','line_number':694,'multiline':False]['text':' Tree operations that require simple tree rewriting.','line_number':695,'multiline':False]['text':'','line_number':696,'multiline':False]['text':'','line_number':709,'multiline':False]['text':' Logically equivalent queries','line_number':710,'multiline':False]['text':'','line_number':711,'multiline':False]['text':'','line_number':735,'multiline':False]['text':' $in','line_number':736,'multiline':False]['text':'','line_number':737,'multiline':False]['text':' Logically equivalent to the preceding $in query.','line_number':750,'multiline':False]['text':' Indexed solution should be the same.','line_number':751,'multiline':False]['text':' multikey','line_number':765,'multiline':False]['text':' sparse','line_number':766,'multiline':False]['text':' Logically equivalent to the preceding $in query.','line_number':784,'multiline':False]['text':' Indexed solution should be the same.','line_number':785,'multiline':False]['text':' Currently fails - pre-requisite to SERVER-12024','line_number':786,'multiline':False]['text':'
TEST_F(QueryPlannerTest, InCompoundIndexFirstOrEquivalent) {
    addIndex(fromjson("{a: 1, b: 1}"));
    runQuery(fromjson("{$and: [{$or: [{a: 1}, {a: 2}]}, {b: 3}]}"));

    assertNumSolutions(2U);
    assertSolutionExists("{cscan: {dir: 1, filter: {$and: [{$or: [{a: 1}, {a: 2}]}, {b: 3}]}}}");
    assertSolutionExists("{fetch: {filter: null, "
                         "node: {ixscan: {pattern: {a: 1, b: 1}}}}}");
}
','line_number':787,'multiline':True]['text':' TODO: update filter in cscan solution when SERVER-12024 is implemented','line_number':804,'multiline':False]['text':' Logically equivalent to the preceding $in query.','line_number':811,'multiline':False]['text':' Indexed solution should be the same.','line_number':812,'multiline':False]['text':' Currently fails - pre-requisite to SERVER-12024','line_number':813,'multiline':False]['text':'
TEST_F(QueryPlannerTest, InCompoundIndexLastOrEquivalent) {
    addIndex(fromjson("{a: 1, b: 1}"));
    runQuery(fromjson("{$and: [{a: 3}, {$or: [{b: 1}, {b: 2}]}]}"));

    assertNumSolutions(2U);
    assertSolutionExists("{cscan: {dir: 1, filter: {$and: [{a: 3}, {$or: [{b: 1}, {b: 2}]}]}}}");
    assertSolutionExists("{fetch: {filter: null, "
                         "node: {ixscan: {pattern: {a: 1, b: 1}}}}}");
}
','line_number':814,'multiline':True]['text':' No sort means we don't bother to blow up the bounds.','line_number':840,'multiline':False]['text':' We cap the # of ixscans we're willing to create.','line_number':881,'multiline':False]['text':' SERVER-13618: test that exploding scans for sort works even','line_number':891,'multiline':False]['text':' if we must reverse the scan direction.','line_number':892,'multiline':False]['text':' SERVER-13618','line_number':909,'multiline':False]['text':' SERVER-13752: don't try to explode if the ordered interval list for','line_number':926,'multiline':False]['text':' the leading field of the compound index is empty.','line_number':927,'multiline':False]['text':' SERVER-13752','line_number':936,'multiline':False]['text':' SERVER-13754: exploding an $or','line_number':950,'multiline':False]['text':' SERVER-13754: exploding an $or','line_number':974,'multiline':False]['text':' SERVER-13754: an $or that can't be exploded, because one clause of the','line_number':999,'multiline':False]['text':' $or doesn't provide the sort, even after explosion.','line_number':1000,'multiline':False]['text':' Verifies that the $or is not exploded due to too many ixscans in the explosion.','line_number':1018,'multiline':False]['text':' Both branches of the $or have 2 indexed predicates with an 11-element $in, which will','line_number':1022,'multiline':False]['text':' generate a total of 2*(11^2)=242 scans when exploded. This exceeds the permitted limit of','line_number':1023,'multiline':False]['text':' 200.','line_number':1024,'multiline':False]['text':' We cap the # of ixscans we're willing to create, so we don't get explosion. Instead','line_number':1033,'multiline':False]['text':' we get 3 different solutions which all use a blocking sort.','line_number':1034,'multiline':False]['text':' SERVER-15696: Make sure explodeForSort copies filters on IXSCAN stages to all of the','line_number':1053,'multiline':False]['text':' scans resulting from the explode. Regex is the easiest way to have the planner create','line_number':1054,'multiline':False]['text':' an index scan which filters using the index key.','line_number':1055,'multiline':False]['text':' Verifies that a OR > FETCH > IXSCAN plan is exploded for sort.','line_number':1076,'multiline':False]['text':' Field 'c' is not covered by an index and forces an introduction of a FETCH stage to form','line_number':1081,'multiline':False]['text':' OR > FETCH > IXSCAN tree.','line_number':1082,'multiline':False]['text':' Verifies that a mix of OR > IXSCAN and OR > FETCH > IXSCAN plan structures is exploded for sort.','line_number':1107,'multiline':False]['text':' Field 'c' is not covered by an index and forces an introduction of a FETCH stage to form','line_number':1112,'multiline':False]['text':' OR > FETCH > IXSCAN tree.','line_number':1113,'multiline':False]['text':' no projection','line_number':1140,'multiline':False]['text':' no skip','line_number':1141,'multiline':False]['text':' .limit(1)','line_number':1142,'multiline':False]['text':'','line_number':1195,'multiline':False]['text':' Multiple solutions','line_number':1196,'multiline':False]['text':'','line_number':1197,'multiline':False]['text':' 2 indexed solns and one non-indexed','line_number':1205,'multiline':False]['text':' 2 indexed solns and one non-indexed','line_number':1224,'multiline':False]['text':'','line_number':1254,'multiline':False]['text':' Sort with queries having point predicates.','line_number':1255,'multiline':False]['text':'','line_number':1256,'multiline':False]['text':' Verify that the solution doesn't require a sort stage.','line_number':1263,'multiline':False]['text':' Verify that we use 'sort' stage because 'b' is not part of the index.','line_number':1275,'multiline':False]['text':'','line_number':1283,'multiline':False]['text':' Sort orders','line_number':1284,'multiline':False]['text':'','line_number':1285,'multiline':False]['text':' Basic "keep sort in mind with an OR"','line_number':1314,'multiline':False]['text':' TODO the second solution should be mergeSort rather than just sort','line_number':1323,'multiline':False]['text':' Note that the first node of 'mergeSort' doesn't require reverse scan because of there is an','line_number':1347,'multiline':False]['text':' equality predicate on 'a' and scan in any direction will produce the results in sorted order','line_number':1348,'multiline':False]['text':' of 'a'.','line_number':1349,'multiline':False]['text':' The AND_HASH stage is not really needed, since the predicate {a: 5} is covered by the indexed','line_number':1982,'multiline':False]['text':' OR.','line_number':1983,'multiline':False]['text':' The filter is {$not: {a: 5}}, but there is no way to write a BSON expression that will parse','line_number':2014,'multiline':False]['text':' to that MatchExpression.','line_number':2015,'multiline':False]['text':' The filter is {$not: {a: 5}}, but there is no way to write a BSON expression that will parse','line_number':2048,'multiline':False]['text':' to that MatchExpression.','line_number':2049,'multiline':False]['text':' The AND_HASH stage is not really needed, since the predicate {a: 5} is covered by the indexed','line_number':2068,'multiline':False]['text':' OR.','line_number':2069,'multiline':False]['text':' Non-ixisect solutions.','line_number':2107,'multiline':False]['text':' Ixisect solutions.','line_number':2125,'multiline':False]['text':' When we have path-level multikey info, we ensure that predicates are assigned in order of','line_number':2415,'multiline':False]['text':' index position.','line_number':2416,'multiline':False]['text':' When we have path-level multikey info, we ensure that predicates are assigned in order of','line_number':2434,'multiline':False]['text':' index position.','line_number':2435,'multiline':False]['text':' SERVER-41872 fixed a case where variable "choice" ordering in the PlanEnumerator memo could lead','line_number':2443,'multiline':False]['text':' to different sets of solutions generated for the same input. This would occur in the case where','line_number':2444,'multiline':False]['text':' we only enumerate a subset of possible plans due to reaching internal limits and enumerate plans','line_number':2445,'multiline':False]['text':' in a non-stable order. With the fix for SERVER-41872, PlanEnumerator ordering is stable and','line_number':2446,'multiline':False]['text':' expected to always return the same set of solutions for a given input.','line_number':2447,'multiline':False]['text':' Test that we enumerate the expected plans with the special parameter set. In this test we have','line_number':2506,'multiline':False]['text':' two branches of an $or, each with two possible indexed solutions.','line_number':2507,'multiline':False]['text':' This max number has a value of 65 in order to potentillay triger any overflow of the possible','line_number':2546,'multiline':False]['text':' enumeration count, because each predicate in $or has two possible indexes, allowing for 2^65','line_number':2547,'multiline':False]['text':' possible enumerations.','line_number':2548,'multiline':False]['text':' Ensure that the query runs fine.','line_number':2558,'multiline':False]['text':' internalQueryMaxOrSolutions.load() + 2.','line_number':2561,'multiline':False]['text':' Test that we enumerate the expected plans with the special parameter set. In this test we have','line_number':2565,'multiline':False]['text':' two branches of an $or, each with one possible indexed solution.','line_number':2566,'multiline':False]['text':' Test that we enumerate the expected plans with the special parameter set. In this test we have','line_number':2588,'multiline':False]['text':' two branches of an $or, one with one possible indexed solution, the other with two possible','line_number':2589,'multiline':False]['text':' indexed solutions.','line_number':2590,'multiline':False]['text':' Test that the special parameter does in fact impact the order of enumeration. Here we rely on the','line_number':2615,'multiline':False]['text':' cap of number of or enumerations to prove that the plans we're interested in are enumerated','line_number':2616,'multiline':False]['text':' before we hit the limit.','line_number':2617,'multiline':False]['text':' For this query and the above indexes, each clause of the $or has three options to choose','line_number':2625,'multiline':False]['text':' from, for a total of 3 * 3 * 3 = 27 possible enumerations for just that $or sub-branch.','line_number':2626,'multiline':False]['text':' The $or enumeration is limited to 10, and then we have three plans where just the {a: 1}','line_number':2631,'multiline':False]['text':' predicate is indexed.','line_number':2632,'multiline':False]['text':' Because we did not set the 'ENUMERATE_OR_CHILDREN_LOCKSTEP' flag, we don't expect this','line_number':2641,'multiline':False]['text':' solution to be generated. This is in contrast to the next test case.','line_number':2642,'multiline':False]['text':' We still expect to generate the solutions which don't index the $or.','line_number':2655,'multiline':False]['text':' For this query and the above indexes, each clause of the $or has three options to choose','line_number':2672,'multiline':False]['text':' from, for a total of 3 * 3 * 3 = 27 possible enumerations for just that $or sub-branch.','line_number':2673,'multiline':False]['text':' The $or enumeration is limited to 10, and then we have three plans where just the {a: 1}','line_number':2678,'multiline':False]['text':' predicate is indexed.','line_number':2679,'multiline':False]['text':' For this query and the above indexes, each clause of the $or has a varying number options to','line_number':2717,'multiline':False]['text':' choose from, for a total of 2 * 3 * 4 * 2 = 48 possible enumerations for just that $or','line_number':2718,'multiline':False]['text':' sub-branch.','line_number':2719,'multiline':False]['text':' The $or enumeration is limited to 10, and then we have four plans where just the {a: 1}','line_number':2730,'multiline':False]['text':' predicate is indexed.','line_number':2731,'multiline':False]['text':' Lockstep enumerations. Definitely expected.','line_number':2734,'multiline':False]['text':' Everyone advances one more time, no longer lock step.','line_number':2751,'multiline':False]['text':' Normal enumeration. Here we observe an interesting phenomena. Before we get into plan','line_number':2760,'multiline':False]['text':' enumeration, the query is parsed and "normalized". This process involves putting the query in','line_number':2761,'multiline':False]['text':' a canonical order, in part so that similar queries can be recognized as such for caching. In','line_number':2762,'multiline':False]['text':' this case, it orders the $or children by their respective number of children. So our original','line_number':2763,'multiline':False]['text':' query will be enumerated as if it were typed in this order:','line_number':2764,'multiline':False]['text':' {a: 1,','line_number':2765,'multiline':False]['text':'  $or: [','line_number':2766,'multiline':False]['text':'    {b: 2.1, c: 2.1},','line_number':2767,'multiline':False]['text':'    {b: 2.2, c: 2.2},','line_number':2768,'multiline':False]['text':'    {b: 3, c: 3, d: 3},','line_number':2769,'multiline':False]['text':'    {b: 4, c: 4, d: 4, e: 4}','line_number':2770,'multiline':False]['text':'  ]','line_number':2771,'multiline':False]['text':' }','line_number':2772,'multiline':False]['text':' Here are the exact plans:','line_number':2773,'multiline':False]['text':' Now to the solutions which don't index the $or.','line_number':2831,'multiline':False]['text':' Disable the simplifier since once the simplifier is emabled it will simplify the expression','line_number':2863,'multiline':False]['text':' to a single $or and the test won't make sense: `{a: 1, $or: [{b: 2.1, c: 2.1}, {b:2.2,','line_number':2864,'multiline':False]['text':' c: 2.2}, {unindexed: 'thisPredicateToEnsureNestedOrsAreNotCombined', x: 3.0, y: 3.0},','line_number':2865,'multiline':False]['text':' {unindexed: 'thisPredicateToEnsureNestedOrsAreNotCombined', x: 3.1, y: 3.1}]}`.','line_number':2866,'multiline':False]['text':' For this query and the above indexes, each clause of the $or has 2 indexes to choose from,','line_number':2878,'multiline':False]['text':' for a total of 2 * 2 * 2 * 2 = 16 possible enumerations for just that $or sub-branch.','line_number':2879,'multiline':False]['text':' The $or enumeration is limited to 10, and then we have 4 plans where just the {a: 1}','line_number':2895,'multiline':False]['text':' predicate is indexed.','line_number':2896,'multiline':False]['text':' Both lockstep enumerations should be present.','line_number':2899,'multiline':False]['text':' This test was designed to reproduce SERVER-83091, a case in which an implementation error in the','line_number':2928,'multiline':False]['text':' lockstep $or enumeration algorithm could result in an infinite loop. This could happen only if','line_number':2929,'multiline':False]['text':' there were nested $or nodes and the inner $or hit the maximum number of plans that it is willing','line_number':2930,'multiline':False]['text':' to generate.','line_number':2931,'multiline':False]['text':' Disable the simplifier, since when enabled it will collapse nested $or nodes into a single','line_number':2933,'multiline':False]['text':' $or. Similarly, turn on the failpoint to disable match expression simplification which would','line_number':2934,'multiline':False]['text':' also eliminate the redundant $or.','line_number':2935,'multiline':False]['text':' The repro depends on the inner $or hitting its enumeration limit. The original problem from','line_number':2940,'multiline':False]['text':' SERVER-83091 can be reproduced with a simpler query if we lower the limit on the number of','line_number':2941,'multiline':False]['text':' plans that the 'PlanEnumerator' is allowed to generate for any $or node.','line_number':2942,'multiline':False]['text':' There are two plans, the only difference between the two being whether the nested $and','line_number':2963,'multiline':False]['text':' {a: 1, b: 2} uses the index on "a" or the index on "b".','line_number':2964,'multiline':False]['text':' Plan using the {a: 1} index for the innermost conjunction.','line_number':2967,'multiline':False]['text':' Alternative plan using the {b: 1} index for the innermost conjunction.','line_number':2990,'multiline':False]['text':' Ensure that when set to 1 we get a different result.','line_number':3032,'multiline':False]['text':' Here we simulate a change stream by requesting a tailable cursor on the oplog of the testColl','line_number':3060,'multiline':False]['text':' collection. See NamespaceString::oplog() method.','line_number':3061,'multiline':False]['text':' Here we simulate a change collection (serverless change stream) by requesting a tailable','line_number':3071,'multiline':False]['text':' cursor on the config.system.change_collection collection. See','line_number':3072,'multiline':False]['text':' NamespaceString::isChangeCollection() method.','line_number':3073,'multiline':False]['text':' namespace','line_number':3089,'multiline':False]['text':' namespace mongo','line_number':3090,'multiline':False]