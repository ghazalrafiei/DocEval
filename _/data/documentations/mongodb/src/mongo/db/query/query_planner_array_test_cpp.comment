['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' true means multikey','line_number':86,'multiline':False]['text':' SERVER-16256','line_number':99,'multiline':False]['text':' true means multikey','line_number':101,'multiline':False]['text':' SERVER-13677','line_number':119,'multiline':False]['text':' SERVER-13677','line_number':129,'multiline':False]['text':' true means multikey','line_number':131,'multiline':False]['text':' SERVER-13677','line_number':147,'multiline':False]['text':' true means multikey','line_number':149,'multiline':False]['text':' An ELEM_MATCH_VALUE can be indexed if all of its child predicates','line_number':184,'multiline':False]['text':' are "index bounds generating".','line_number':185,'multiline':False]['text':' We cannot build index bounds for the $size predicate. This means that the','line_number':194,'multiline':False]['text':' ELEM_MATCH_VALUE is not indexable, and we get no indexed solutions.','line_number':195,'multiline':False]['text':' SERVER-13664','line_number':244,'multiline':False]['text':' true means multikey','line_number':246,'multiline':False]['text':' SERVER-13664','line_number':264,'multiline':False]['text':' true means multikey','line_number':266,'multiline':False]['text':' true means multikey','line_number':268,'multiline':False]['text':' SERVER-13664','line_number':281,'multiline':False]['text':' SERVER-14180','line_number':293,'multiline':False]['text':' SERVER-14180','line_number':305,'multiline':False]['text':' $not can appear as a value operator inside of an elemMatch (value).  We shouldn't crash if we','line_number':317,'multiline':False]['text':' see it.','line_number':318,'multiline':False]['text':' SERVER-13789','line_number':324,'multiline':False]['text':' SERVER-13789','line_number':338,'multiline':False]['text':' SERVER-13789: Ensure that we properly compound in the multikey case when an','line_number':356,'multiline':False]['text':' $or is beneath an $elemMatch.','line_number':357,'multiline':False]['text':' true means multikey','line_number':359,'multiline':False]['text':' SERVER-13789: Right now we don't index $nor, but make sure that the planner','line_number':373,'multiline':False]['text':' doesn't get confused by a $nor beneath an $elemMatch.','line_number':374,'multiline':False]['text':' SERVER-13789: Make sure we properly handle an $or below $elemMatch that is not','line_number':383,'multiline':False]['text':' tagged by the enumerator to use an index.','line_number':384,'multiline':False]['text':' The index bounds can be compounded because the index is not multikey.','line_number':396,'multiline':False]['text':' The index bounds cannot be compounded because the predicates over 'a.x' and','line_number':410,'multiline':False]['text':' 'a.b.c' 1) share the prefix "a", and 2) are not conjoined by an $elemMatch','line_number':411,'multiline':False]['text':' over the prefix "a".','line_number':412,'multiline':False]['text':' true means multikey','line_number':414,'multiline':False]['text':' The index bounds cannot be intersected because the index is multikey.','line_number':426,'multiline':False]['text':' The bounds could be intersected if there was an $elemMatch applied to path','line_number':427,'multiline':False]['text':' "a.b.c". However, the $elemMatch is applied to the path "a.b" rather than','line_number':428,'multiline':False]['text':' the full path of the indexed field.','line_number':429,'multiline':False]['text':' true means multikey','line_number':431,'multiline':False]['text':' The index bounds cannot be intersected because the index is multikey.','line_number':445,'multiline':False]['text':' The bounds could be intersected if there was an $elemMatch applied to path','line_number':446,'multiline':False]['text':' "a.b.c". However, the $elemMatch is applied to the path "a.b" rather than','line_number':447,'multiline':False]['text':' the full path of the indexed field.','line_number':448,'multiline':False]['text':' true means multikey','line_number':450,'multiline':False]['text':' The bounds can be compounded because the index is not multikey.','line_number':464,'multiline':False]['text':' The bounds cannot be compounded. Although there is an $elemMatch over the','line_number':479,'multiline':False]['text':' shared path prefix 'a', the predicates must be conjoined by the same $elemMatch,','line_number':480,'multiline':False]['text':' without nested $elemMatch's intervening. The bounds could be compounded if','line_number':481,'multiline':False]['text':' the query were rewritten as {a: {$elemMatch: {'d.e': {$lte: 1}, 'b.c': {$gte: 1}}}}.','line_number':482,'multiline':False]['text':' true means multikey','line_number':484,'multiline':False]['text':' Bounds can be intersected for a multikey index when the predicates are','line_number':498,'multiline':False]['text':' joined by an $elemMatch over the full path of the index field.','line_number':499,'multiline':False]['text':' true means multikey','line_number':501,'multiline':False]['text':' We can intersect the bounds for all three predicates because','line_number':512,'multiline':False]['text':' the index is not multikey.','line_number':513,'multiline':False]['text':' Bounds can be intersected for a multikey index when the predicates are','line_number':527,'multiline':False]['text':' joined by an $elemMatch over the full path of the index field. The bounds','line_number':528,'multiline':False]['text':' from the $in predicate are not intersected with the bounds from the','line_number':529,'multiline':False]['text':' remaining to predicates because the $in is not joined to the other','line_number':530,'multiline':False]['text':' predicates with an $elemMatch.','line_number':531,'multiline':False]['text':' true means multikey','line_number':533,'multiline':False]['text':' Bounds can be intersected because the predicates are joined by an','line_number':550,'multiline':False]['text':' $elemMatch over the path "a.b.c", the full path of the multikey','line_number':551,'multiline':False]['text':' index field.','line_number':552,'multiline':False]['text':' true means multikey','line_number':554,'multiline':False]['text':' Bounds cannot be compounded for a multikey compound index when','line_number':565,'multiline':False]['text':' the predicates share a prefix (and there is no $elemMatch).','line_number':566,'multiline':False]['text':' true means multikey','line_number':568,'multiline':False]['text':' Bounds can be compounded because there is an $elemMatch applied to the','line_number':580,'multiline':False]['text':' shared prefix "a".','line_number':581,'multiline':False]['text':' true means multikey','line_number':583,'multiline':False]['text':' Bounds cannot be compounded for the multikey index even though there is an','line_number':594,'multiline':False]['text':' $elemMatch, because the $elemMatch does not join the two predicates. This','line_number':595,'multiline':False]['text':' query is semantically indentical to {'a.b': 1, 'a.c': 1}.','line_number':596,'multiline':False]['text':' true means multikey','line_number':598,'multiline':False]['text':' Bounds cannot be compounded for the multikey index even though there are','line_number':610,'multiline':False]['text':' $elemMatch's, because there is not an $elemMatch which joins the two','line_number':611,'multiline':False]['text':' predicates. This query is semantically indentical to {'a.b': 1, 'a.c': 1}.','line_number':612,'multiline':False]['text':' true means multikey','line_number':614,'multiline':False]['text':' Bounds for the predicates joined by the $elemMatch over the shared prefix','line_number':626,'multiline':False]['text':' "a" can be combined. However, the predicate 'a.b'==1 cannot also be combined','line_number':627,'multiline':False]['text':' given that it is outside of the $elemMatch.','line_number':628,'multiline':False]['text':' true means multikey','line_number':630,'multiline':False]['text':' Bounds for the predicates joined by the $elemMatch over the shared prefix','line_number':646,'multiline':False]['text':' "a" can be combined. However, the predicate outside the $elemMatch','line_number':647,'multiline':False]['text':' cannot also be combined.','line_number':648,'multiline':False]['text':' true means multikey','line_number':650,'multiline':False]['text':' Bounds for the predicates joined by the $elemMatch over the shared prefix','line_number':666,'multiline':False]['text':' "a" can be combined. However, the predicate outside the $elemMatch','line_number':667,'multiline':False]['text':' cannot also be combined.','line_number':668,'multiline':False]['text':' true means multikey','line_number':670,'multiline':False]['text':' There are two sets of fields that share a prefix: {'a.b', 'a.c'} and','line_number':682,'multiline':False]['text':' {'d.e', 'd.f'}. Since the index is multikey, we can only use the bounds from','line_number':683,'multiline':False]['text':' one member of each of these sets.','line_number':684,'multiline':False]['text':' true means multikey','line_number':686,'multiline':False]['text':' All bounds can be combined. Although, 'a.b' and 'a.c' share prefix 'a', the','line_number':700,'multiline':False]['text':' relevant predicates are joined by an $elemMatch on 'a'. Similarly, predicates','line_number':701,'multiline':False]['text':' over 'd.e' and 'd.f' are joined by an $elemMatch on 'd'.','line_number':702,'multiline':False]['text':' true means multikey','line_number':704,'multiline':False]['text':' Bounds for 'a.b' and 'a.c' can be combined because of the $elemMatch on 'a'.','line_number':720,'multiline':False]['text':' Since predicates an 'd.e' and 'd.f' have no $elemMatch, we use the bounds','line_number':721,'multiline':False]['text':' for only one of the two.','line_number':722,'multiline':False]['text':' true means multikey','line_number':724,'multiline':False]['text':' Bounds for 'd.e' and 'd.f' can be combined because of the $elemMatch on 'd'.','line_number':739,'multiline':False]['text':' Since predicates an 'a.b' and 'a.c' have no $elemMatch, we use the bounds','line_number':740,'multiline':False]['text':' for only one of the two.','line_number':741,'multiline':False]['text':' true means multikey','line_number':743,'multiline':False]['text':' The bounds cannot be compounded because 'a.b.x' and 'a.b.y' share prefix','line_number':758,'multiline':False]['text':' 'a.b' (and there is no $elemMatch).','line_number':759,'multiline':False]['text':' true means multikey','line_number':761,'multiline':False]['text':' The bounds can be compounded because the predicates are joined by an','line_number':773,'multiline':False]['text':' $elemMatch on the shared prefix "a.b".','line_number':774,'multiline':False]['text':' true means multikey','line_number':776,'multiline':False]['text':' The bounds cannot be compounded. Although there is an $elemMatch that appears','line_number':788,'multiline':False]['text':' to join the predicates, the path to which the $elemMatch is applied is "a".','line_number':789,'multiline':False]['text':' Therefore, the predicates contained in the $elemMatch are over "b.x" and "b.y".','line_number':790,'multiline':False]['text':' They cannot be compounded due to shared prefix "b".','line_number':791,'multiline':False]['text':' true means multikey','line_number':793,'multiline':False]['text':' The bounds can be compounded because the predicates are joined by an','line_number':805,'multiline':False]['text':' $elemMatch on the shared prefix "a.b".','line_number':806,'multiline':False]['text':' true means multikey','line_number':808,'multiline':False]['text':' This one is subtle. Say we compound the bounds for predicates over "a.b.c" and','line_number':820,'multiline':False]['text':' "a.b.d". This is okay because of the predicate over the shared prefix "a.b".','line_number':821,'multiline':False]['text':' It might seem like we can do the same for the $elemMatch over shared prefix "a.e",','line_number':822,'multiline':False]['text':' thus combining all bounds. But in fact, we can't combine any more bounds because','line_number':823,'multiline':False]['text':' we have already used prefix "a". In other words, this query is like having predicates','line_number':824,'multiline':False]['text':' over "a.b" and "a.e", so we can only use bounds from one of the two.','line_number':825,'multiline':False]['text':' true means multikey','line_number':827,'multiline':False]['text':' Similar to MultikeyComplexDoubleDotted above.','line_number':843,'multiline':False]['text':' true means multikey','line_number':845,'multiline':False]['text':' SERVER-13422: check that we plan $elemMatch object correctly with index intersection.','line_number':861,'multiline':False]['text':' true means multikey','line_number':865,'multiline':False]['text':' 3 single index solutions.','line_number':875,'multiline':False]['text':' 3 index intersection solutions. The last one has to intersect two','line_number':880,'multiline':False]['text':' predicates within the $elemMatch object.','line_number':881,'multiline':False]['text':' SERVER-14718','line_number':896,'multiline':False]['text':' true means multikey','line_number':899,'multiline':False]['text':' SERVER-14718','line_number':911,'multiline':False]['text':' true means multikey','line_number':914,'multiline':False]['text':' One solution using index on 'b' and one using index on 'a'.','line_number':920,'multiline':False]['text':' SERVER-14718','line_number':928,'multiline':False]['text':' true means multikey','line_number':931,'multiline':False]['text':' SERVER-14718','line_number':942,'multiline':False]['text':' true means multikey','line_number':945,'multiline':False]['text':' SERVER-14718','line_number':956,'multiline':False]['text':' true means multikey','line_number':959,'multiline':False]['text':' SERVER-14718','line_number':976,'multiline':False]['text':' true means multikey','line_number':979,'multiline':False]['text':' There are no indexed solutions, because negations of $mod are not indexable.','line_number':982,'multiline':False]['text':'*
 * Index bounds constraints on a field should not be intersected
 * if the index is multikey.
 ','line_number':987,'multiline':True]['text':'*
 * Constraints on fields with a shared parent should not be intersected
 * if the index is multikey.
 ','line_number':1005,'multiline':True]['text':' SERVER-16042','line_number':1030,'multiline':False]['text':' SERVER-16042','line_number':1047,'multiline':False]['text':' SERVER-16042','line_number':1066,'multiline':False]['text':' SERVER-16042','line_number':1087,'multiline':False]['text':' When we have path-level multikey info, we ensure that predicates are assigned in order of','line_number':2021,'multiline':False]['text':' index position.','line_number':2022,'multiline':False]['text':' TODO SERVER-30145: Fixing this ticket should allow us to generate tight bounds on "b.c.f" below.','line_number':2091,'multiline':False]['text':' TODO SERVER-30145: Fixing this ticket should allow us to generate tight bounds on "b.c.f" below.','line_number':2112,'multiline':False]['text':' TODO SERVER-30145: Fixing this ticket should allow us to generate tight bounds on "b.c.f" below.','line_number':2134,'multiline':False]['text':' We can't use the index because we would exclude {a: []} which should match.','line_number':2305,'multiline':False]['text':' true means multikey','line_number':2338,'multiline':False]['text':' We can't use the index because we would exclude {a: []} which should match.','line_number':2342,'multiline':False]['text':' true means multikey','line_number':2348,'multiline':False]['text':' We should be able to use the index because of the value $elemMatch.','line_number':2352,'multiline':False]['text':' true means multikey','line_number':2363,'multiline':False]['text':' We can't use the index because we would exclude {a: [{b: []}]} which should match.','line_number':2367,'multiline':False]['text':' We can't use the index because we would exclude {a: [{b: []}]} which should match.','line_number':2377,'multiline':False]['text':' Test for older versions of indexes where it is possible to have empty MultikeyPaths,','line_number':2399,'multiline':False]['text':' but still the index is considered multikey. In that case the index should not be','line_number':2400,'multiline':False]['text':' considered to evaluate an $elemMatch predicate with a positional path component.','line_number':2401,'multiline':False]['text':' 'c' is multikey.','line_number':2462,'multiline':False]['text':' multikey= ','line_number':2523,'multiline':True]['text':' Now without a query predicate.','line_number':2572,'multiline':False]['text':' namespace','line_number':2600,'multiline':False]