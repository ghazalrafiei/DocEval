['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' namespace','line_number':96,'multiline':False]['text':' If the session has non zero timeout then reset it back to 0 before returning the session back','line_number':111,'multiline':False]['text':' to the cache.','line_number':112,'multiline':False]['text':' Since we cannot have both a _lastTimestampSet and a _commitTimestamp, we set the','line_number':120,'multiline':False]['text':' commit time as whichever is non-empty. If both are empty, then _lastTimestampSet will','line_number':121,'multiline':False]['text':' be boost::none and we'll set the commit time to that.','line_number':122,'multiline':False]['text':' Prepare the transaction.','line_number':176,'multiline':False]['text':' Flushes the journal log to disk. Checkpoints all data if journaling is disabled.','line_number':200,'multiline':False]['text':' Take a checkpoint, rather than only flush the (oplog) journal, in order to lock in stable','line_number':213,'multiline':False]['text':' writes to unjournaled tables.','line_number':214,'multiline':False]['text':'','line_number':215,'multiline':False]['text':' If 'stableCheckpoint' is set, then we will only checkpoint data up to and including the','line_number':216,'multiline':False]['text':' stable_timestamp set on WT at the time of the checkpoint. Otherwise, we will checkpoint all','line_number':217,'multiline':False]['text':' of the data.','line_number':218,'multiline':False]['text':' Can't be in a WriteUnitOfWork, so safe to rollback if the AbandonSnapshotMode is','line_number':271,'multiline':False]['text':' kAbort. If kCommit, however, then any active cursors will remain positioned and valid.','line_number':272,'multiline':False]['text':' commit ','line_number':273,'multiline':True]['text':' Begin a new transaction, if one is not already started.','line_number':279,'multiline':False]['text':' We clear the context here, but we don't unset the flag. We need it still set to prevent a','line_number':298,'multiline':False]['text':' WCE loop in the multi-timestamp constraint code below. We are also expecting to hit the','line_number':299,'multiline':False]['text':' LOGV2_FATAL below, and don't really need to worry about re-using this recovery unit. If','line_number':300,'multiline':False]['text':' this changes in the future, we might need to unset _gatherWriteContextForDebugging under','line_number':301,'multiline':False]['text':' some conditions.','line_number':302,'multiline':False]['text':' The first write in this transaction was not timestamped. Other writes have used at least','line_number':308,'multiline':False]['text':' two different timestamps. This violates the multi timestamp constraint where if a','line_number':309,'multiline':False]['text':' transaction sets multiple timestamps, the first timestamp must be set prior to any','line_number':310,'multiline':False]['text':' writes. Vice-versa, if a transaction writes a document before setting a timestamp, it','line_number':311,'multiline':False]['text':' must not set multiple timestamps.','line_number':312,'multiline':False]['text':' `serverGlobalParams.slowMs` can be set to values <= 0. In those cases, give logging a','line_number':333,'multiline':False]['text':' break.','line_number':334,'multiline':False]['text':' There is currently no scenario where it is intentional to commit before the current','line_number':348,'multiline':False]['text':' read timestamp.','line_number':349,'multiline':False]['text':' The only point at which rollback_transaction() can time out is in the bonus-eviction','line_number':370,'multiline':False]['text':' phase. If the timeout expires here, the function will stop the eviction and return','line_number':371,'multiline':False]['text':' success. It cannot return an error due to timeout.','line_number':372,'multiline':False]['text':' We only need to update oplog visibility where commits can be out-of-order with','line_number':384,'multiline':False]['text':' respect to their assigned optime. This will ensure the oplog read timestamp gets','line_number':385,'multiline':False]['text':' updated when oplog 'holes' are filled: the last commit filling the last hole will','line_number':386,'multiline':False]['text':' prompt the oplog read timestamp to be forwarded.','line_number':387,'multiline':False]['text':'','line_number':388,'multiline':False]['text':' This should happen only on primary nodes.','line_number':389,'multiline':False]['text':' We reset the _lastTimestampSet between transactions. Since it is legal for one','line_number':402,'multiline':False]['text':' transaction on a RecoveryUnit to call setTimestamp() and another to call','line_number':403,'multiline':False]['text':' setCommitTimestamp().','line_number':404,'multiline':False]['text':' Default value is true; we assume all writes are ordered.','line_number':411,'multiline':False]['text':' Reset the kLastApplied read source back to the default of kNoTimestamp. Any reader requiring','line_number':417,'multiline':False]['text':' kLastApplied will set the read source again before reading. Resetting this read source','line_number':418,'multiline':False]['text':' simplifies the handling when stepup happens concurrently with read operations.','line_number':419,'multiline':False]['text':' After a ReadSource has been set on this RecoveryUnit, callers expect that this method returns','line_number':437,'multiline':False]['text':' the read timestamp that will be used for current or future transactions. Because callers use','line_number':438,'multiline':False]['text':' this timestamp to inform visibility of operations, it is therefore necessary to open a','line_number':439,'multiline':False]['text':' transaction to establish a read timestamp, but only for ReadSources that are expected to have','line_number':440,'multiline':False]['text':' read timestamps.','line_number':441,'multiline':False]['text':' The read timestamp is set by the user and does not require a transaction to be open.','line_number':447,'multiline':False]['text':' The lastApplied timestamp is not always available if the system has not accepted','line_number':451,'multiline':False]['text':' writes, so it is not possible to invariant that it exists.','line_number':452,'multiline':False]['text':' The following ReadSources can only establish a read timestamp when a transaction is','line_number':457,'multiline':False]['text':' opened.','line_number':458,'multiline':False]['text':' Ensure a transaction is opened. Storage engine operations require the global lock.','line_number':465,'multiline':False]['text':' The lastApplied and allDurable timestamps are not always available if the system has','line_number':472,'multiline':False]['text':' not accepted writes, so it is not possible to invariant that it exists as other','line_number':473,'multiline':False]['text':' ReadSources do.','line_number':474,'multiline':False]['text':' The follow ReadSources returned values in the first switch block.','line_number':484,'multiline':False]['text':' Only start a timer for transaction's lifetime if we're going to log it.','line_number':500,'multiline':False]['text':' Continue to the next case to read at the _readAtTimestamp.','line_number':547,'multiline':False]['text':' SnapshotTooOld errors indicate that PIT ops are failing to find an available','line_number':558,'multiline':False]['text':' snapshot at their specified atClusterTime.','line_number':559,'multiline':False]['text':' Since this is not in a critical section, we might have rounded to oldest between','line_number':588,'multiline':False]['text':' calling getAllDurable and setReadSnapshot.  We need to get the actual read timestamp we','line_number':589,'multiline':False]['text':' used.','line_number':590,'multiline':False]['text':' When there is not a lastApplied timestamp available, read without a timestamp. Do not','line_number':598,'multiline':False]['text':' round up the read timestamp to the oldest timestamp.','line_number':599,'multiline':False]['text':' There is a race that allows new transactions to start between the time we check for a','line_number':601,'multiline':False]['text':' read timestamp and start our transaction, which can temporarily violate the contract of','line_number':602,'multiline':False]['text':' kLastApplied. That is, writes will be visible that occur after the lastApplied time. This','line_number':603,'multiline':False]['text':' is only possible for readers that start immediately after an initial sync that did not','line_number':604,'multiline':False]['text':' replicate any oplog entries. Future transactions will start reading at a timestamp once','line_number':605,'multiline':False]['text':' timestamped writes have been made.','line_number':606,'multiline':False]['text':' We might have rounded to oldest between calling setTimestampReadSource and setReadSnapshot.','line_number':625,'multiline':False]['text':' We need to get the actual read timestamp we used.','line_number':626,'multiline':False]['text':' When using timestamps for reads and writes, it's important that readers and writers don't','line_number':637,'multiline':False]['text':' overlap with the timestamps they use. In other words, at any point in the system there should','line_number':638,'multiline':False]['text':' be a timestamp T such that writers only commit at times greater than T and readers only read','line_number':639,'multiline':False]['text':' at, or earlier than T. This time T is called the no-overlap point. Using the `kNoOverlap`','line_number':640,'multiline':False]['text':' ReadSource will compute the most recent known time that is safe to read at.','line_number':641,'multiline':False]['text':' The no-overlap point is computed as the minimum of the storage engine's all_durable time','line_number':643,'multiline':False]['text':' and replication's last applied time. On primaries, the last applied time is updated as','line_number':644,'multiline':False]['text':' transactions commit, which is not necessarily in the order they appear in the oplog. Thus','line_number':645,'multiline':False]['text':' the all_durable time is an appropriate value to read at.','line_number':646,'multiline':False]['text':' On secondaries, however, the all_durable time, as computed by the storage engine, can','line_number':648,'multiline':False]['text':' advance before oplog application completes a batch. This is because the all_durable time','line_number':649,'multiline':False]['text':' is only computed correctly if the storage engine is informed of commit timestamps in','line_number':650,'multiline':False]['text':' increasing order. Because oplog application processes a batch of oplog entries out of order,','line_number':651,'multiline':False]['text':' the timestamping requirement is not satisfied. Secondaries, however, only update the last','line_number':652,'multiline':False]['text':' applied time after a batch completes. Thus last applied is a valid no-overlap point on','line_number':653,'multiline':False]['text':' secondaries.','line_number':654,'multiline':False]['text':' By taking the minimum of the two values, storage can compute a legal time to read at without','line_number':656,'multiline':False]['text':' knowledge of the replication state. The no-overlap point is the minimum of the all_durable','line_number':657,'multiline':False]['text':' time, which represents the point where no transactions will commit any earlier, and','line_number':658,'multiline':False]['text':' lastApplied, which represents the highest optime a node has applied, a point no readers','line_number':659,'multiline':False]['text':' should read afterward.','line_number':660,'multiline':False]['text':' When there is not an all_durable or lastApplied timestamp available, read without a','line_number':664,'multiline':False]['text':' timestamp. Do not round up the read timestamp to the oldest timestamp.','line_number':665,'multiline':False]['text':' There is a race that allows new transactions to start between the time we check for a','line_number':667,'multiline':False]['text':' read timestamp and start our transaction, which can temporarily violate the contract of','line_number':668,'multiline':False]['text':' kNoOverlap. That is, writes will be visible that occur after the all_durable time. This','line_number':669,'multiline':False]['text':' is only possible for readers that start immediately after an initial sync that did not','line_number':670,'multiline':False]['text':' replicate any oplog entries. Future transactions will start reading at a timestamp once','line_number':671,'multiline':False]['text':' timestamped writes have been made.','line_number':672,'multiline':False]['text':' We might have rounded to oldest between calling getAllDurable and setReadSnapshot. We','line_number':691,'multiline':False]['text':' need to get the actual read timestamp we used.','line_number':692,'multiline':False]['text':'bytes in hex','line_number':699,'multiline':True]['text':'nul terminator','line_number':699,'multiline':True]['text':' We're still on the same timestamp.','line_number':710,'multiline':False]['text':' Starts the WT transaction associated with this session.','line_number':741,'multiline':False]['text':' This can be called either outside of a WriteUnitOfWork or in a prepared transaction after','line_number':758,'multiline':False]['text':' setPrepareTimestamp() is called. Prepared transactions ensure the correct timestamping','line_number':759,'multiline':False]['text':' semantics and the set-once commitTimestamp behavior is exactly what prepared transactions','line_number':760,'multiline':False]['text':' want.','line_number':761,'multiline':False]['text':' If there is an open storage transaction, it is not valid to try to change the behavior of','line_number':833,'multiline':False]['text':' ignoring prepare conflicts, since that behavior is applied when the transaction is opened.','line_number':834,'multiline':False]['text':' This cannot be called after WiredTigerRecoveryUnit::_txnOpen.','line_number':849,'multiline':False]['text':' The lastApplied timestamp is not always available if the system has not accepted writes.','line_number':876,'multiline':False]['text':' We compute operation statistics as the difference between the current session statistics and','line_number':909,'multiline':False]['text':' the session statistics of the last time the method was called, which should correspond to the','line_number':910,'multiline':False]['text':' end of one operation.','line_number':911,'multiline':False]['text':' namespace mongo','line_number':941,'multiline':False]