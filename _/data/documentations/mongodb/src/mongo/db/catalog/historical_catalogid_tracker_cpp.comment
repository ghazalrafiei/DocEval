['text':'*
 *    Copyright (C) 2023-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' Sentinel id for marking a catalogId mapping range as unknown. Must use an invalid RecordId.','line_number':51,'multiline':False]['text':' Maximum number of entries in catalogId mapping when inserting catalogId missing at timestamp.','line_number':53,'multiline':False]['text':' Used to avoid quadratic behavior when inserting entries at the beginning. When threshold is','line_number':54,'multiline':False]['text':' reached we will fall back to more durable catalog scans.','line_number':55,'multiline':False]['text':' Copy existing value from immutable data structure or default-construct if not existing','line_number':58,'multiline':False]['text':' Returns true if cleanup is needed for a catalogId range','line_number':68,'multiline':False]['text':' Cleanup may occur if we have more than one entry for the namespace.','line_number':70,'multiline':False]['text':' Returns the lowest time a catalogId range may be cleaned up. needsCleanup() needs to have been','line_number':74,'multiline':False]['text':' checked prior to calling this function','line_number':75,'multiline':False]['text':' When we have multiple entries, use the time at the second entry as the cleanup time,','line_number':77,'multiline':False]['text':' when the oldest timestamp advances past this we no longer need the first entry.','line_number':78,'multiline':False]['text':' Converts a not found lookup timestamp to a LookupResult based on the oldest maintained timestamp','line_number':82,'multiline':False]['text':' If the request was with a time prior to the oldest maintained time it is unknown, otherwise','line_number':85,'multiline':False]['text':' we know it is not existing.','line_number':86,'multiline':False]['text':' Converts a catalogId range into a lookup result that represents the latest state','line_number':93,'multiline':False]['text':' The algorithm is as follows for an input range of the following format that is sorted on','line_number':107,'multiline':False]['text':' timestamp: (ts1, id1), (ts2, id2), ..., (tsN, idN).','line_number':108,'multiline':False]['text':'','line_number':109,'multiline':False]['text':' We use upper_bound to perform binary search to the timestamp that is strictly larger than our','line_number':110,'multiline':False]['text':' query timestamp ts. The iterator can then be decremented to get the entry where the time is','line_number':111,'multiline':False]['text':' less or equal, this is the entry we are looking for. If upper_bound returns begin() or the','line_number':112,'multiline':False]['text':' 'id' in our found entry is the unknown marker the lookup result is unknown.','line_number':113,'multiline':False]['text':' Upper bound returns an iterator to the first entry with a larger timestamp. Decrement the','line_number':121,'multiline':False]['text':' iterator to get the last entry where the time is less or equal.','line_number':122,'multiline':False]['text':' namespace','line_number':133,'multiline':False]['text':' Mapping found for namespace, get result depending on timestamp.','line_number':138,'multiline':False]['text':' No mapping found for namespace, result is either not found or unknown depending on timestamp','line_number':144,'multiline':False]['text':' Mapping found for namespace, get result depending on timestamp.','line_number':152,'multiline':False]['text':' No mapping found for namespace, result is either not found or unknown depending on timestamp','line_number':159,'multiline':False]['text':' recordNonExistingAtTime can use a lot of entries because of the unknown marker that is','line_number':200,'multiline':False]['text':' needed. Constrain the memory usage.','line_number':201,'multiline':False]['text':' recordNonExistingAtTime can use a lot of entries because of the unknown marker that is','line_number':209,'multiline':False]['text':' needed. Constrain the memory usage.','line_number':210,'multiline':False]['text':' Helper lambda to perform the operation on both namespace and UUID','line_number':222,'multiline':False]['text':' Helper to update the cleanup time after we've performed an insert.','line_number':225,'multiline':False]['text':' Get copy of existing mapping, or default-construct new.','line_number':235,'multiline':False]['text':' Helper to write updated id mapping back into container at scope exit. This allows us','line_number':237,'multiline':False]['text':' to write to 'ids' as if we were doing inplace updates to the container.','line_number':238,'multiline':False]['text':' Binary search to the entry with same or larger timestamp. This represents the insert','line_number':241,'multiline':False]['text':' position in the container.','line_number':242,'multiline':False]['text':' An entry could exist already if concurrent writes are performed, keep the latest','line_number':249,'multiline':False]['text':' change in that case.','line_number':250,'multiline':False]['text':' If next element has same catalogId, we can adjust its timestamp to cover a longer','line_number':256,'multiline':False]['text':' range','line_number':257,'multiline':False]['text':' Otherwise insert new entry at timestamp','line_number':266,'multiline':False]['text':' Apply the insert to both namespace and uuid.','line_number':271,'multiline':False]['text':' Get copy of existing mapping, or default-construct new.','line_number':277,'multiline':False]['text':' Avoid inserting missing mapping when the list has grown past the threshold. Will cause','line_number':280,'multiline':False]['text':' the system to fall back to scanning the durable catalog.','line_number':281,'multiline':False]['text':' Helper to write updated id mapping back into container at scope exit','line_number':286,'multiline':False]['text':' Binary search to the entry with same or larger timestamp. This represents the insert position','line_number':289,'multiline':False]['text':' in the container.','line_number':290,'multiline':False]['text':' An entry could exist already if concurrent writes are performed, keep the latest','line_number':297,'multiline':False]['text':' change in that case.','line_number':298,'multiline':False]['text':' Otherwise insert new entry','line_number':301,'multiline':False]['text':' The iterator is positioned on the added/modified element above, reposition it to the next','line_number':305,'multiline':False]['text':' entry','line_number':306,'multiline':False]['text':' We don't want to assume that the namespace remains not existing until the next entry, as','line_number':309,'multiline':False]['text':' there can be times where the namespace actually does exist. To make sure we trigger the','line_number':310,'multiline':False]['text':' scanning of the durable catalog in this range we will insert a bogus entry using an invalid','line_number':311,'multiline':False]['text':' RecordId at the next timestamp. This will treat the range forward as unknown.','line_number':312,'multiline':False]['text':' If the next entry is on the next timestamp already, we can skip adding the bogus entry.','line_number':315,'multiline':False]['text':' If this function is called for a previously unknown namespace or UUID, we may not have','line_number':316,'multiline':False]['text':' any future valid entries and the iterator would be positioned at and at this point.','line_number':317,'multiline':False]['text':' Update cleanup time if needed','line_number':322,'multiline':False]['text':' Avoid inserting missing mapping when the list has grown past the threshold. Will cause','line_number':334,'multiline':False]['text':' the system to fall back to scanning the durable catalog.','line_number':335,'multiline':False]['text':' Helper to write updated id mapping back into container at scope exit','line_number':340,'multiline':False]['text':' Binary search to the entry with same or larger timestamp. This represents the insert position','line_number':343,'multiline':False]['text':' in the container.','line_number':344,'multiline':False]['text':' An entry could exist already if concurrent writes are performed, keep the latest','line_number':351,'multiline':False]['text':' change in that case.','line_number':352,'multiline':False]['text':' Otherwise insert new entry','line_number':355,'multiline':False]['text':' The iterator is positioned on the added/modified element above, reposition it to the next','line_number':359,'multiline':False]['text':' entry','line_number':360,'multiline':False]['text':' We don't want to assume that the namespace remains not existing until the next entry, as','line_number':363,'multiline':False]['text':' there can be times where the namespace actually does exist. To make sure we trigger the','line_number':364,'multiline':False]['text':' scanning of the durable catalog in this range we will insert a bogus entry using an invalid','line_number':365,'multiline':False]['text':' RecordId at the next timestamp. This will treat the range forward as unknown.','line_number':366,'multiline':False]['text':' If the next entry is on the next timestamp already, we can skip adding the bogus entry.','line_number':369,'multiline':False]['text':' If this function is called for a previously unknown namespace or UUID, we may not have','line_number':370,'multiline':False]['text':' any future valid entries and the iterator would be positioned at and at this point.','line_number':371,'multiline':False]['text':' Update cleanup time if needed','line_number':376,'multiline':False]['text':' Helper lambda to perform the operation on both namespace and UUID','line_number':392,'multiline':False]['text':' Batch all changes together','line_number':395,'multiline':False]['text':'','line_number':400,'multiline':False]['text':' Binary search for next larger timestamp','line_number':403,'multiline':False]['text':' Continue if there is nothing to cleanup for this timestamp yet','line_number':409,'multiline':False]['text':' There should always be at least two entries in the range when we hit this','line_number':411,'multiline':False]['text':' branch. For the namespace to be put in '_nssChanges' we need at least two','line_number':412,'multiline':False]['text':' entries.','line_number':413,'multiline':False]['text':' The iterator is positioned to the closest entry that has a larger timestamp,','line_number':420,'multiline':False]['text':' decrement to get a lower or equal timestamp. This represents the first entry that we','line_number':421,'multiline':False]['text':' may not cleanup.','line_number':422,'multiline':False]['text':' Erase range, we will leave at least one element due to the decrement above','line_number':425,'multiline':False]['text':' If more changes are needed for this namespace, keep it in the set and keep track','line_number':428,'multiline':False]['text':' of lowest timestamp.','line_number':429,'multiline':False]['text':' If the last remaining element is a drop earlier than the oldest timestamp, we can','line_number':436,'multiline':False]['text':' remove tracking this namespace','line_number':437,'multiline':False]['text':' Unmark this namespace or UUID for needing changes.','line_number':444,'multiline':False]['text':' Write back all changes to main container','line_number':448,'multiline':False]['text':' Iterate over all namespaces and UUIDs that is marked that they need cleanup','line_number':453,'multiline':False]['text':' Helper lambda to perform the operation on both namespace and UUID','line_number':467,'multiline':False]['text':' Batch all changes together','line_number':469,'multiline':False]['text':' Go through all known mappings and remove entries larger than input stable timestamp','line_number':473,'multiline':False]['text':' Binary search to the first entry with a too large timestamp','line_number':475,'multiline':False]['text':' Create a new range without the timestamps that are too large','line_number':481,'multiline':False]['text':' If the resulting range is empty, remove the key from the container','line_number':484,'multiline':False]['text':' Calculate when this namespace needs to be cleaned up next','line_number':490,'multiline':False]['text':' Write back all changes to main container','line_number':499,'multiline':False]['text':' Rollback on both namespace and uuid containers.','line_number':504,'multiline':False]['text':' Helper lambda to perform the operation on both namespace and UUID','line_number':519,'multiline':False]['text':' Make a copy of the vector stored at 'key'','line_number':521,'multiline':False]['text':' An entry could exist already if concurrent writes are performed, keep the latest','line_number':524,'multiline':False]['text':' change in that case.','line_number':525,'multiline':False]['text':' Otherwise, push new entry at the end. Timestamp is always increasing','line_number':532,'multiline':False]['text':' If the catalogId is the same as last entry, there's nothing we need to do. This can','line_number':534,'multiline':False]['text':' happen when the catalog is reopened.','line_number':535,'multiline':False]['text':' Push new mapping to the end and write back to the container. As this is a create, we do','line_number':540,'multiline':False]['text':' not need to update the cleanup time as a create can never yield an updated (lower)','line_number':541,'multiline':False]['text':' cleanup time for this namespace/uuid.','line_number':542,'multiline':False]['text':' Create on both namespace and uuid containers.','line_number':547,'multiline':False]['text':' Make sure untimestamped writes have a single entry in mapping. If we're mixing','line_number':556,'multiline':False]['text':' timestamped with untimestamped (such as repair). Ignore the untimestamped writes','line_number':557,'multiline':False]['text':' as an untimestamped deregister will correspond with an untimestamped register. We','line_number':558,'multiline':False]['text':' should leave the mapping as-is in this case.','line_number':559,'multiline':False]['text':' Ensure that the last entry in the history chain was a timestamped drop.','line_number':565,'multiline':False]['text':' This namespace or UUID was added due to an untimestamped write, add an entry','line_number':568,'multiline':False]['text':' with min timestamp','line_number':569,'multiline':False]['text':' Nothing to cleanup after untimestamped write','line_number':572,'multiline':False]['text':' Create on both namespace and uuid containers.','line_number':578,'multiline':False]['text':' Helper lambda to perform the operation on both namespace and UUID','line_number':586,'multiline':False]['text':' Make a copy of the vector stored at 'key'','line_number':588,'multiline':False]['text':' An entry could exist already if concurrent writes are performed, keep the latest change','line_number':590,'multiline':False]['text':' in that case.','line_number':591,'multiline':False]['text':' Otherwise, push new entry at the end. Timestamp is always increasing','line_number':598,'multiline':False]['text':' If the catalogId is the same as last entry, there's nothing we need to do. This can','line_number':600,'multiline':False]['text':' happen when the catalog is reopened.','line_number':601,'multiline':False]['text':' A drop entry can't be pushed in the container if it's empty. This is because we cannot','line_number':606,'multiline':False]['text':' initialize the namespace or UUID with a single drop.','line_number':607,'multiline':False]['text':' Push the drop at the end our or mapping','line_number':610,'multiline':False]['text':' This drop may result in the possibility of cleanup in the future','line_number':613,'multiline':False]['text':' Write back the updated mapping into our container','line_number':620,'multiline':False]['text':' Drop on both namespace and uuid containers','line_number':624,'multiline':False]['text':' Make sure untimestamped writes have a single entry in mapping. If we're mixing','line_number':630,'multiline':False]['text':' timestamped with untimestamped (such as repair). Ignore the untimestamped writes as','line_number':631,'multiline':False]['text':' an untimestamped deregister will correspond with an untimestamped register. We should','line_number':632,'multiline':False]['text':' leave the mapping as-is in this case.','line_number':633,'multiline':False]['text':' This namespace or UUID was removed due to an untimestamped write, clear entries.','line_number':638,'multiline':False]['text':' Nothing to cleanup after untimestamped write','line_number':641,'multiline':False]['text':' Drop on both namespace and uuid containers','line_number':646,'multiline':False]['text':' Make copies of existing mappings on these namespaces.','line_number':654,'multiline':False]['text':' First update 'to' mapping. This is similar to a 'create'.','line_number':658,'multiline':False]['text':' An entry could exist already if concurrent writes are performed, keep the latest change','line_number':660,'multiline':False]['text':' in that case.','line_number':661,'multiline':False]['text':' Timestamps should always be increasing.','line_number':664,'multiline':False]['text':' Push to end, we can take the catalogId from 'from'. We don't need to check if timestamp','line_number':667,'multiline':False]['text':' needs to be cleaned up as this is equivalent of a 'create'.','line_number':668,'multiline':False]['text':' Then, update 'from' mapping. This is similar to a 'drop'.','line_number':672,'multiline':False]['text':' Re-write latest entry if timestamp match (multiple changes occured in this transaction),','line_number':674,'multiline':False]['text':' otherwise push at end.','line_number':675,'multiline':False]['text':' Timestamps should always be increasing.','line_number':678,'multiline':False]['text':' Push to end and calculate cleanup timestamp.','line_number':680,'multiline':False]['text':' Store updates mappings back into container.','line_number':689,'multiline':False]['text':' We should never perform rename in a mixed-mode environment. 'from' should contain a','line_number':698,'multiline':False]['text':' single entry and there should be nothing in 'to' .','line_number':699,'multiline':False]['text':' Take the last known catalogId from 'from'.','line_number':705,'multiline':False]['text':' namespace mongo','line_number':711,'multiline':False]