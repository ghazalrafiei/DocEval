['text':'*
 *    Copyright (C) 2018-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: no_include "ext/alloc_traits.h"','line_number':46,'multiline':False]['text':' IWYU pragma: no_include "boost/intrusive/detail/iterator.hpp"','line_number':47,'multiline':False]['text':' This fail point allows collections to be given malformed validator. A malformed validator','line_number':115,'multiline':False]['text':' will not (and cannot) be enforced but it will be persisted.','line_number':116,'multiline':False]['text':' In resharding, if the user's original collection has a validator, then the temporary','line_number':128,'multiline':False]['text':' resharding collection is created with it as well.','line_number':129,'multiline':False]['text':' Allow schema on config.settings. This is created internally, and user changes to this','line_number':143,'multiline':False]['text':' validator are disallowed in the createCollection and collMod commands.','line_number':144,'multiline':False]['text':'*
 * Returns true if we are running retryable write or retryable internal multi-document transaction.
 ','line_number':172,'multiline':True]['text':' The 'control.min' and 'control.max' fields have the same ordering.','line_number':199,'multiline':False]['text':' The 'control.min' and 'control.max' fields have the same cardinality.','line_number':215,'multiline':False]['text':' First check the index catalog of the existing collection for the index entry.','line_number':225,'multiline':False]['text':' Next check the CollectionCatalog for a compatible drop pending index.','line_number':240,'multiline':False]['text':' The index entries are incompatible with the read timestamp, but we need to use the same','line_number':243,'multiline':False]['text':' shared ident to prevent the reaper from dropping idents prematurely.','line_number':244,'multiline':False]['text':' The index ident is expired, but it could still be drop pending. Mark it as in use if','line_number':249,'multiline':False]['text':' possible.','line_number':250,'multiline':False]['text':' Only use the behavior for non-replicated capped collections (which can accept concurrent','line_number':260,'multiline':False]['text':' writes). This behavior relies on RecordIds being allocated in increasing order. For clustered','line_number':261,'multiline':False]['text':' collections, users define their RecordIds and are not constrained to creating them in','line_number':262,'multiline':False]['text':' increasing order.','line_number':263,'multiline':False]['text':' The oplog tracks its visibility through support from the storage engine.','line_number':264,'multiline':False]['text':' namespace','line_number':267,'multiline':False]['text':' If the collection's default collator has a version not currently supported by our ICU','line_number':279,'multiline':False]['text':' integration, shut down the server. Errors other than IncompatibleCollationVersion should not','line_number':280,'multiline':False]['text':' be possible, so these are an invariant rather than fassert.','line_number':281,'multiline':False]['text':' Capped collections must preserve insertion order, so we serialize writes. One exception are','line_number':301,'multiline':False]['text':' clustered capped collections because they only guarantee insertion order when cluster keys','line_number':302,'multiline':False]['text':' are inserted in monotonically-increasing order.','line_number':303,'multiline':False]['text':' The record store will be null when the collection is instantiated as part of the repair','line_number':306,'multiline':False]['text':' path.','line_number':307,'multiline':False]['text':' Capped visibility must be initialized with the largest key in the store. All existing records','line_number':314,'multiline':False]['text':' when opening the collection should be visible. Concurrent writes will be past this key.','line_number':315,'multiline':False]['text':' The record store will be null when the collection is instantiated as part of the repair path.','line_number':321,'multiline':False]['text':' The repair path intentionally doesn't create a record store because it directly accesses the','line_number':322,'multiline':False]['text':' underlying storage engine.','line_number':323,'multiline':False]['text':' If this collection has been newly created, we need to register with the TTL cache at','line_number':376,'multiline':False]['text':' commit time, otherwise it is startup and we can register immediately.','line_number':377,'multiline':False]['text':' Use the shared state from the existing collection.','line_number':402,'multiline':False]['text':' When initializing a collection from an earlier point-in-time, we don't know when the last DDL','line_number':410,'multiline':False]['text':' operation took place at that point-in-time. We conservatively set the minimum valid snapshot','line_number':411,'multiline':False]['text':' to the read point-in-time.','line_number':412,'multiline':False]['text':' Determine which indexes from the existing collection can be shared with this newly','line_number':420,'multiline':False]['text':' initialized collection. The remaining indexes will be initialized by the IndexCatalog.','line_number':421,'multiline':False]['text':' If the indexes don't have the same ordering in 'idxIdent' and 'md', we perform a','line_number':434,'multiline':False]['text':' search instead. There's no guarantee these are in order, but they typically are.','line_number':435,'multiline':False]['text':'isPointInTimeRead=','line_number':447,'multiline':True]['text':' Update the idents for the newly initialized indexes. We must reuse the same shared_ptr<Ident>','line_number':449,'multiline':False]['text':' objects from existing indexes to prevent the index idents from being dropped by the drop','line_number':450,'multiline':False]['text':' pending ident reaper while this collection is still using them.','line_number':451,'multiline':False]['text':' Enforce that the validator can be used on this namespace.','line_number':472,'multiline':False]['text':' Make sure validationAction and validationLevel are allowed on this collection','line_number':475,'multiline':False]['text':' Make sure to copy the action and level before parsing MatchExpression, since certain features','line_number':479,'multiline':False]['text':' are not supported with certain combinations of action and level.','line_number':480,'multiline':False]['text':' Store the result (OK / error) of parsing the validator, but do not enforce that the result is','line_number':485,'multiline':False]['text':' OK. This is intentional, as users may have validators on disk which were considered well','line_number':486,'multiline':False]['text':' formed in older versions but not in newer versions.','line_number':487,'multiline':False]['text':' Log an error and startup warning if the collection validator is malformed.','line_number':491,'multiline':False]['text':' No indexes on the oplog.','line_number':506,'multiline':False]['text':' Collections clustered by _id do not have a separate _id index.','line_number':511,'multiline':False]['text':' We can lazily initialize the capped snapshot because no storage snapshot has been','line_number':537,'multiline':False]['text':' opened yet.','line_number':538,'multiline':False]['text':' In resharding, the donor shard primary is responsible for performing document validation','line_number':592,'multiline':False]['text':' and the recipient should not perform validation on documents inserted into the temporary','line_number':593,'multiline':False]['text':' resharding collection.','line_number':594,'multiline':False]['text':' The MatchExpression and contained ExpressionContext created as part of the validator are','line_number':673,'multiline':False]['text':' owned by the Collection and will outlive the OperationContext they were created under.','line_number':674,'multiline':False]['text':' Enforce a maximum feature version if requested.','line_number':677,'multiline':False]['text':' The match expression parser needs to know that we're parsing an expression for a','line_number':680,'multiline':False]['text':' validator to apply some additional checks.','line_number':681,'multiline':False]['text':' If the validation action is "warn" or the level is "moderate", then disallow any encryption','line_number':684,'multiline':False]['text':' keywords. This is to prevent any plaintext data from showing up in the logs.','line_number':685,'multiline':False]['text':' Also disallow if the collection has FLE2 encrypted fields.','line_number':686,'multiline':False]['text':' Capped clustered collections use TTL-based deletion.','line_number':757,'multiline':False]['text':' Storage engines can choose to manage oplog truncation internally.','line_number':762,'multiline':False]['text':' By registering ourselves as a writer, we inform the capped visibility system that we may be','line_number':959,'multiline':False]['text':' in the process of committing uncommitted records.','line_number':960,'multiline':False]['text':' We must atomically allocate and register any RecordIds so that we can correctly keep','line_number':968,'multiline':False]['text':' track of visibility. This ensures capped readers do not skip past any in-progress writes.','line_number':969,'multiline':False]['text':' We are guaranteed to have a contiguous range so we only register the min and max.','line_number':973,'multiline':False]['text':' Callers should be updating visibility as part of a write operation. We want to ensure that','line_number':984,'multiline':False]['text':' we never get here while holding an uninterruptible, read-ticketed lock. That would indicate','line_number':985,'multiline':False]['text':' that we are operating with the wrong global lock semantics, and either hold too weak a lock','line_number':986,'multiline':False]['text':' (e.g. IS) or that we upgraded in a way we shouldn't (e.g. IS -> IX).','line_number':987,'multiline':False]['text':' forward ','line_number':1011,'multiline':True]['text':' Unfinished index builds are excluded to avoid a potential deadlock when trying to collect','line_number':1062,'multiline':False]['text':' statistics from the index table while the index build is in the bulk load phase. See','line_number':1063,'multiline':False]['text':' SERVER-77018. This should not be too impactful as:','line_number':1064,'multiline':False]['text':' - During the collection scan phase, the index table is unused.','line_number':1065,'multiline':False]['text':' - During the bulk load phase, getFreeStorageBytes will probably return EBUSY, as the ident is','line_number':1066,'multiline':False]['text':'  in use by the index builder. (And worst case results in the deadlock).','line_number':1067,'multiline':False]['text':' - It might be possible to return meaningful data post bulk-load, but reusable bytes should be','line_number':1068,'multiline':False]['text':'  low anyways as the collection has been bulk loaded. Additionally, this would be a inaccurate','line_number':1069,'multiline':False]['text':'  anyways as the build is in progress.','line_number':1070,'multiline':False]['text':' - Once the index build is finished, this will be eventually accounted for.','line_number':1071,'multiline':False]['text':'*
 * order will be:
 * 1) store index specs
 * 2) drop indexes
 * 3) truncate record store
 * 4) re-write indexes
 ','line_number':1083,'multiline':True]['text':' 1) store index specs','line_number':1094,'multiline':False]['text':' 2) drop indexes','line_number':1104,'multiline':False]['text':' 3) truncate record store','line_number':1107,'multiline':False]['text':' 4) re-create indexes','line_number':1112,'multiline':False]['text':' Reparse the validator as there are some features which are only supported with certain','line_number':1157,'multiline':False]['text':' validation levels.','line_number':1158,'multiline':False]['text':' Reparse the validator as there are some features which are only supported with certain','line_number':1188,'multiline':False]['text':' validation actions.','line_number':1189,'multiline':False]['text':' validateIndexSpecCollation() should have checked that the index collation spec is','line_number':1274,'multiline':False]['text':' valid.','line_number':1275,'multiline':False]['text':' Validation was already performed above.','line_number':1293,'multiline':False]['text':' namespace','line_number':1305,'multiline':False]['text':' could be null.','line_number':1310,'multiline':False]['text':' could be null.','line_number':1321,'multiline':False]['text':' never had the index so nothing to do.','line_number':1458,'multiline':False]['text':' Confirm that our index is not already in the current metadata.','line_number':1481,'multiline':False]['text':' If we have uncommitted multikey writes we need to check here to read our own writes','line_number':1539,'multiline':False]['text':' Otherwise read from the metadata cache if there are no concurrent multikey writers','line_number':1551,'multiline':False]['text':' Check for concurrent writers, this can race with writers where it can be set immediately','line_number':1554,'multiline':False]['text':' after checking. This is fine we know that the reader in that case opened its snapshot','line_number':1555,'multiline':False]['text':' before the writer and we do not need to observe its result.','line_number':1556,'multiline':False]['text':' We need to read from the durable catalog if there are concurrent multikey writers to avoid','line_number':1566,'multiline':False]['text':' reading between the multikey write committing in the storage engine but before its onCommit','line_number':1567,'multiline':False]['text':' handler made the write visible for readers.','line_number':1568,'multiline':False]['text':' The index is already set as multikey and we aren't tracking path-level','line_number':1617,'multiline':False]['text':' multikey information for it. We return false to indicate that the index','line_number':1618,'multiline':False]['text':' metadata is unchanged.','line_number':1619,'multiline':False]['text':' We are tracking path-level multikey information for this index.','line_number':1626,'multiline':False]['text':' Store new path components that cause this index to be multikey in catalog's','line_number':1635,'multiline':False]['text':' index metadata.','line_number':1636,'multiline':False]['text':' If all of the sets in the multikey paths vector were empty, then no component','line_number':1646,'multiline':False]['text':' of any indexed field caused the index to be multikey. setIndexIsMultikey()','line_number':1647,'multiline':False]['text':' therefore shouldn't have been called.','line_number':1648,'multiline':False]['text':' We return false to indicate that the index metadata is unchanged.','line_number':1652,'multiline':False]['text':' Make a copy that is safe to read without locks that we insert in the durable catalog, we only','line_number':1658,'multiline':False]['text':' update the stored metadata on successful commit. The pending update is stored as a decoration','line_number':1659,'multiline':False]['text':' on the OperationContext to allow us to read our own writes.','line_number':1660,'multiline':False]['text':' First time this OperationContext needs to change multikey information for this','line_number':1672,'multiline':False]['text':' collection. We cannot use the cached metadata in this collection as we may have just','line_number':1673,'multiline':False]['text':' committed a multikey change concurrently to the storage engine without being able to','line_number':1674,'multiline':False]['text':' observe it if its onCommit handlers haven't run yet.','line_number':1675,'multiline':False]['text':' When reading from the durable catalog the index offsets are different because when','line_number':1679,'multiline':False]['text':' removing indexes in-memory just zeros out the slot instead of actually removing it. We','line_number':1680,'multiline':False]['text':' must adjust the entries so they match how they are stored in _metadata so we can rely on','line_number':1681,'multiline':False]['text':' the index offsets being stable. The order of valid indexes are the same, so we can','line_number':1682,'multiline':False]['text':' iterate from the end and move them into the right positions.','line_number':1683,'multiline':False]['text':' RAII Helper object to ensure we decrement the concurrent counter if and only if we','line_number':1708,'multiline':False]['text':' incremented it in a preCommit handler.','line_number':1709,'multiline':False]['text':' Mark this index that there is an ongoing multikey write. This forces readers to read from the','line_number':1736,'multiline':False]['text':' durable catalog to determine if the index is multikey or not.','line_number':1737,'multiline':False]['text':' Capture a reference to 'concurrentWriteTracker' to extend the lifetime of this object until','line_number':1741,'multiline':False]['text':' commiting/rolling back the transaction is fully complete.','line_number':1742,'multiline':False]['text':' Merge in changes to this index, other indexes may have been updated since we made our','line_number':1746,'multiline':False]['text':' copy. Don't check for result as another thread could be setting multikey at the same','line_number':1747,'multiline':False]['text':' time','line_number':1748,'multiline':False]['text':' Make a copy that is safe to read without locks that we insert in the durable catalog, we only','line_number':1783,'multiline':False]['text':' update the stored metadata on successful commit. The pending update is stored as a decoration','line_number':1784,'multiline':False]['text':' on the OperationContext to allow us to read our own writes.','line_number':1785,'multiline':False]['text':' Merge in changes to this index, other indexes may have been updated since we made our','line_number':1806,'multiline':False]['text':' copy.','line_number':1807,'multiline':False]['text':' Even though we are holding an exclusive lock on the Collection there may be an ongoing','line_number':1886,'multiline':False]['text':' multikey change on this OperationContext. Make sure we include that update when we copy the','line_number':1887,'multiline':False]['text':' metadata for this operation.','line_number':1888,'multiline':False]['text':' Copy metadata and apply provided function to make change.','line_number':1897,'multiline':False]['text':' Remove the cached multikey change, it is now included in the copied metadata. If we left it','line_number':1901,'multiline':False]['text':' here we could read stale data.','line_number':1902,'multiline':False]['text':' Store in durable catalog and replace pointer with our copied instance.','line_number':1907,'multiline':False]['text':' namespace mongo','line_number':1912,'multiline':False]